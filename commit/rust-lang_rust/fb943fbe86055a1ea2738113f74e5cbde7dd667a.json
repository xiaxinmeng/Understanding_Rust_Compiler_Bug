{"sha": "fb943fbe86055a1ea2738113f74e5cbde7dd667a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiOTQzZmJlODYwNTVhMWVhMjczODExM2Y3NGU1Y2JkZTdkZDY2N2E=", "commit": {"author": {"name": "kai.giebeler", "email": "kai.giebeler@audiotool.com", "date": "2021-01-17T21:25:56Z"}, "committer": {"name": "kai.giebeler", "email": "kai.giebeler@audiotool.com", "date": "2021-01-17T21:25:56Z"}, "message": "Merge remote-tracking branch 'upstream/master' into doc-markdown", "tree": {"sha": "6dd4e7c4e66d3199728152ecac6c581fec0dff83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dd4e7c4e66d3199728152ecac6c581fec0dff83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb943fbe86055a1ea2738113f74e5cbde7dd667a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb943fbe86055a1ea2738113f74e5cbde7dd667a", "html_url": "https://github.com/rust-lang/rust/commit/fb943fbe86055a1ea2738113f74e5cbde7dd667a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb943fbe86055a1ea2738113f74e5cbde7dd667a/comments", "author": null, "committer": null, "parents": [{"sha": "bd235707acd095fdd2b079d2992923d0d732a474", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd235707acd095fdd2b079d2992923d0d732a474", "html_url": "https://github.com/rust-lang/rust/commit/bd235707acd095fdd2b079d2992923d0d732a474"}, {"sha": "91292f1eefdb59c49101af0f058661fbd4750e98", "url": "https://api.github.com/repos/rust-lang/rust/commits/91292f1eefdb59c49101af0f058661fbd4750e98", "html_url": "https://github.com/rust-lang/rust/commit/91292f1eefdb59c49101af0f058661fbd4750e98"}], "stats": {"total": 15236, "additions": 10025, "deletions": 5211}, "files": [{"sha": "f46828fec91b25594d06952716e4357053ab4df4", "filename": ".github/ISSUE_TEMPLATE/false_negative.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/.github%2FISSUE_TEMPLATE%2Ffalse_negative.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/.github%2FISSUE_TEMPLATE%2Ffalse_negative.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Ffalse_negative.md?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,35 @@\n+---\n+name: Bug Report (False Negative)\n+about: Create a bug report about missing warnings from a lint\n+labels: L-bug, L-false-negative\n+---\n+<!--\n+Thank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\n+along with any information you feel relevant to replicating the bug.\n+-->\n+Lint name:\n+\n+\n+I tried this code:\n+\n+```rust\n+<code>\n+```\n+\n+I expected to see this happen: *explanation*\n+\n+Instead, this happened: *explanation*\n+\n+### Meta\n+\n+- `cargo clippy -V`: e.g. clippy 0.0.212 (f455e46 2020-06-20)\n+- `rustc -Vv`:\n+  ```\n+  rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n+  binary: rustc\n+  commit-hash: f455e46eae1a227d735091091144601b467e1565\n+  commit-date: 2020-06-20\n+  host: x86_64-unknown-linux-gnu\n+  release: 1.46.0-nightly\n+  LLVM version: 10.0\n+  ```"}, {"sha": "92a7373fc27d51f372cd389d1952800635400535", "filename": ".github/ISSUE_TEMPLATE/false_positive.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/.github%2FISSUE_TEMPLATE%2Ffalse_positive.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/.github%2FISSUE_TEMPLATE%2Ffalse_positive.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Ffalse_positive.md?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,35 @@\n+---\n+name: Bug Report (False Positive)\n+about: Create a bug report about a wrongly emitted lint warning\n+labels: L-bug, L-false-positive\n+---\n+<!--\n+Thank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\n+along with any information you feel relevant to replicating the bug.\n+-->\n+Lint name:\n+\n+\n+I tried this code:\n+\n+```rust\n+<code>\n+```\n+\n+I expected to see this happen: *explanation*\n+\n+Instead, this happened: *explanation*\n+\n+### Meta\n+\n+- `cargo clippy -V`: e.g. clippy 0.0.212 (f455e46 2020-06-20)\n+- `rustc -Vv`:\n+  ```\n+  rustc 1.46.0-nightly (f455e46ea 2020-06-20)\n+  binary: rustc\n+  commit-hash: f455e46eae1a227d735091091144601b467e1565\n+  commit-date: 2020-06-20\n+  host: x86_64-unknown-linux-gnu\n+  release: 1.46.0-nightly\n+  LLVM version: 10.0\n+  ```"}, {"sha": "9d5e12aac5f7b73701396d4703666d75cd4e12e8", "filename": ".github/workflows/clippy.yml", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/.github%2Fworkflows%2Fclippy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/.github%2Fworkflows%2Fclippy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy.yml?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -35,29 +35,11 @@ jobs:\n       with:\n         github_token: \"${{ secrets.github_token }}\"\n \n-    - name: rust-toolchain\n-      uses: actions-rs/toolchain@v1.0.6\n-      with:\n-        toolchain: nightly\n-        target: x86_64-unknown-linux-gnu\n-        profile: minimal\n-\n     - name: Checkout\n       uses: actions/checkout@v2.3.3\n \n-    - name: Run cargo update\n-      run: cargo update\n-\n-    - name: Cache cargo dir\n-      uses: actions/cache@v2\n-      with:\n-        path: ~/.cargo\n-        key: ${{ runner.os }}-x86_64-unknown-linux-gnu-${{ hashFiles('Cargo.lock') }}\n-        restore-keys: |\n-          ${{ runner.os }}-x86_64-unknown-linux-gnu\n-\n-    - name: Master Toolchain Setup\n-      run: bash setup-toolchain.sh\n+    - name: Install toolchain\n+      run: rustup show active-toolchain\n \n     # Run\n     - name: Set LD_LIBRARY_PATH (Linux)\n@@ -66,13 +48,16 @@ jobs:\n         echo \"LD_LIBRARY_PATH=${SYSROOT}/lib${LD_LIBRARY_PATH+:${LD_LIBRARY_PATH}}\" >> $GITHUB_ENV\n \n     - name: Build\n-      run: cargo build --features deny-warnings\n+      run: cargo build --features deny-warnings,internal-lints\n+\n+    - name: Test \"--fix -Zunstable-options\"\n+      run: cargo run --features deny-warnings,internal-lints --bin cargo-clippy -- clippy --fix -Zunstable-options\n \n     - name: Test\n-      run: cargo test --features deny-warnings\n+      run: cargo test --features deny-warnings,internal-lints\n \n     - name: Test clippy_lints\n-      run: cargo test --features deny-warnings\n+      run: cargo test --features deny-warnings,internal-lints\n       working-directory: clippy_lints\n \n     - name: Test rustc_tools_util\n@@ -98,9 +83,3 @@ jobs:\n         cargo dev new_lint --name new_late_pass --pass late\n         cargo check\n         git reset --hard HEAD\n-\n-    # Cleanup\n-    - name: Run cargo-cache --autoclean\n-      run: |\n-        cargo +nightly install cargo-cache --no-default-features --features ci-autoclean cargo-cache\n-        cargo cache"}, {"sha": "5d846eb64c78e5c0f78d72e682a961605879f928", "filename": ".github/workflows/clippy_bors.yml", "status": "modified", "additions": 13, "deletions": 84, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_bors.yml?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -23,6 +23,7 @@ jobs:\n     - uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n       with:\n         github_token: \"${{ secrets.github_token }}\"\n+\n     - name: Checkout\n       uses: actions/checkout@v2.3.3\n       with:\n@@ -84,31 +85,11 @@ jobs:\n         sudo apt-get install gcc-multilib libssl-dev:i386 libgit2-dev:i386\n       if: matrix.host == 'i686-unknown-linux-gnu'\n \n-    - name: rust-toolchain\n-      uses: actions-rs/toolchain@v1.0.6\n-      with:\n-        toolchain: nightly\n-        target: ${{ matrix.host }}\n-        profile: minimal\n-\n     - name: Checkout\n       uses: actions/checkout@v2.3.3\n \n-    - name: Run cargo update\n-      run: cargo update\n-\n-    - name: Cache cargo dir\n-      uses: actions/cache@v2\n-      with:\n-        path: ~/.cargo\n-        key: ${{ runner.os }}-${{ matrix.host }}-${{ hashFiles('Cargo.lock') }}\n-        restore-keys: |\n-          ${{ runner.os }}-${{ matrix.host }}\n-\n-    - name: Master Toolchain Setup\n-      run: bash setup-toolchain.sh\n-      env:\n-        HOST_TOOLCHAIN: ${{ matrix.host }}\n+    - name: Install toolchain\n+      run: rustup show active-toolchain\n \n     # Run\n     - name: Set LD_LIBRARY_PATH (Linux)\n@@ -129,13 +110,13 @@ jobs:\n         echo \"$SYSROOT/bin\" >> $GITHUB_PATH\n \n     - name: Build\n-      run: cargo build --features deny-warnings\n+      run: cargo build --features deny-warnings,internal-lints\n \n     - name: Test\n-      run: cargo test --features deny-warnings\n+      run: cargo test --features deny-warnings,internal-lints\n \n     - name: Test clippy_lints\n-      run: cargo test --features deny-warnings\n+      run: cargo test --features deny-warnings,internal-lints\n       working-directory: clippy_lints\n \n     - name: Test rustc_tools_util\n@@ -155,12 +136,6 @@ jobs:\n       env:\n         OS: ${{ runner.os }}\n \n-    # Cleanup\n-    - name: Run cargo-cache --autoclean\n-      run: |\n-        cargo +nightly install cargo-cache --no-default-features --features ci-autoclean cargo-cache\n-        cargo cache\n-\n   integration_build:\n     needs: changelog\n     runs-on: ubuntu-latest\n@@ -171,29 +146,11 @@ jobs:\n       with:\n         github_token: \"${{ secrets.github_token }}\"\n \n-    - name: rust-toolchain\n-      uses: actions-rs/toolchain@v1.0.6\n-      with:\n-        toolchain: nightly\n-        target: x86_64-unknown-linux-gnu\n-        profile: minimal\n-\n     - name: Checkout\n       uses: actions/checkout@v2.3.3\n \n-    - name: Run cargo update\n-      run: cargo update\n-\n-    - name: Cache cargo dir\n-      uses: actions/cache@v2\n-      with:\n-        path: ~/.cargo\n-        key: ${{ runner.os }}-x86_64-unknown-linux-gnu-${{ hashFiles('Cargo.lock') }}\n-        restore-keys: |\n-          ${{ runner.os }}-x86_64-unknown-linux-gnu\n-\n-    - name: Master Toolchain Setup\n-      run: bash setup-toolchain.sh\n+    - name: Install toolchain\n+      run: rustup show active-toolchain\n \n     # Run\n     - name: Build Integration Test\n@@ -214,11 +171,6 @@ jobs:\n         name: target\n         path: target\n \n-    # Cleanup\n-    - name: Run cargo-cache --autoclean\n-      run: |\n-        cargo +nightly install cargo-cache --no-default-features --features ci-autoclean cargo-cache\n-        cargo cache\n   integration:\n     needs: integration_build\n     strategy:\n@@ -252,29 +204,11 @@ jobs:\n       with:\n         github_token: \"${{ secrets.github_token }}\"\n \n-    - name: rust-toolchain\n-      uses: actions-rs/toolchain@v1.0.6\n-      with:\n-        toolchain: nightly\n-        target: x86_64-unknown-linux-gnu\n-        profile: minimal\n-\n     - name: Checkout\n       uses: actions/checkout@v2.3.3\n \n-    - name: Run cargo update\n-      run: cargo update\n-\n-    - name: Cache cargo dir\n-      uses: actions/cache@v2\n-      with:\n-        path: ~/.cargo\n-        key: ${{ runner.os }}-x86_64-unknown-linux-gnu-${{ hashFiles('Cargo.lock') }}\n-        restore-keys: |\n-          ${{ runner.os }}-x86_64-unknown-linux-gnu\n-\n-    - name: Master Toolchain Setup\n-      run: bash setup-toolchain.sh\n+    - name: Install toolchain\n+      run: rustup show active-toolchain\n \n     # Download\n     - name: Download target dir\n@@ -288,16 +222,11 @@ jobs:\n \n     # Run\n     - name: Test ${{ matrix.integration }}\n-      run: $CARGO_TARGET_DIR/debug/integration\n+      run: |\n+        RUSTUP_TOOLCHAIN=\"$(rustup show active-toolchain | grep -o -E \"nightly-[0-9]{4}-[0-9]{2}-[0-9]{2}\")\" \\\n+          $CARGO_TARGET_DIR/debug/integration\n       env:\n         INTEGRATION: ${{ matrix.integration }}\n-        RUSTUP_TOOLCHAIN: master\n-\n-    # Cleanup\n-    - name: Run cargo-cache --autoclean\n-      run: |\n-        cargo +nightly install cargo-cache --no-default-features --features ci-autoclean cargo-cache\n-        cargo cache\n \n   # These jobs doesn't actually test anything, but they're only used to tell\n   # bors the build completed, as there is no practical way to detect when a"}, {"sha": "95da775b7bc360ce4fcdb59e6fbb6a3935aa4766", "filename": ".github/workflows/clippy_dev.yml", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/.github%2Fworkflows%2Fclippy_dev.yml", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/.github%2Fworkflows%2Fclippy_dev.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_dev.yml?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -22,16 +22,20 @@ jobs:\n \n     steps:\n     # Setup\n+    - name: Checkout\n+      uses: actions/checkout@v2.3.3\n+\n+    - name: remove toolchain file\n+      run: rm rust-toolchain\n+\n     - name: rust-toolchain\n       uses: actions-rs/toolchain@v1.0.6\n       with:\n         toolchain: nightly\n         target: x86_64-unknown-linux-gnu\n         profile: minimal\n         components: rustfmt\n-\n-    - name: Checkout\n-      uses: actions/checkout@v2.3.3\n+        default: true\n \n     # Run\n     - name: Build"}, {"sha": "85f6929f924e2474cdbacd7237889a207a00d722", "filename": "CHANGELOG.md", "status": "modified", "additions": 143, "deletions": 3, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -6,11 +6,138 @@ document.\n \n ## Unreleased / In Rust Nightly\n \n-[b20d4c1...master](https://github.com/rust-lang/rust-clippy/compare/b20d4c1...master)\n+[4911ab1...master](https://github.com/rust-lang/rust-clippy/compare/4911ab1...master)\n+\n+## Rust 1.50\n+\n+Current beta, release 2021-02-11\n+\n+[b20d4c1...4911ab1](https://github.com/rust-lang/rust-clippy/compare/b20d4c1...4911ab1)\n+\n+### New Lints\n+\n+* [`suspicious_operation_groupings`] [#6086](https://github.com/rust-lang/rust-clippy/pull/6086)\n+* [`size_of_in_element_count`] [#6394](https://github.com/rust-lang/rust-clippy/pull/6394)\n+* [`unnecessary_wraps`] [#6070](https://github.com/rust-lang/rust-clippy/pull/6070)\n+* [`let_underscore_drop`] [#6305](https://github.com/rust-lang/rust-clippy/pull/6305)\n+* [`collapsible_match`] [#6402](https://github.com/rust-lang/rust-clippy/pull/6402)\n+* [`redundant_else`] [#6330](https://github.com/rust-lang/rust-clippy/pull/6330)\n+* [`zero_sized_map_values`] [#6218](https://github.com/rust-lang/rust-clippy/pull/6218)\n+* [`print_stderr`] [#6367](https://github.com/rust-lang/rust-clippy/pull/6367)\n+* [`string_from_utf8_as_bytes`] [#6134](https://github.com/rust-lang/rust-clippy/pull/6134)\n+\n+### Moves and Deprecations\n+\n+* Previously deprecated [`str_to_string`] and [`string_to_string`] have been un-deprecated\n+  as `restriction` lints [#6333](https://github.com/rust-lang/rust-clippy/pull/6333)\n+* Deprecate [`panic_params`] lint. This is now available in rustc as `panic_fmt`\n+  [#6351](https://github.com/rust-lang/rust-clippy/pull/6351)\n+* Move [`map_err_ignore`] to `restriction`\n+  [#6416](https://github.com/rust-lang/rust-clippy/pull/6416)\n+* Move [`await_holding_refcell_ref`] to `pedantic`\n+  [#6354](https://github.com/rust-lang/rust-clippy/pull/6354)\n+* Move [`await_holding_lock`] to `pedantic`\n+  [#6354](https://github.com/rust-lang/rust-clippy/pull/6354)\n+\n+### Enhancements\n+\n+* Add the `unreadable-literal-lint-fractions` configuration to disable\n+  the `unreadable_literal` lint for fractions\n+  [#6421](https://github.com/rust-lang/rust-clippy/pull/6421)\n+* [`clone_on_copy`]: Now shows the type in the lint message\n+  [#6443](https://github.com/rust-lang/rust-clippy/pull/6443)\n+* [`redundant_pattern_matching`]: Now also lints on `std::task::Poll`\n+  [#6339](https://github.com/rust-lang/rust-clippy/pull/6339)\n+* [`redundant_pattern_matching`]: Additionally also lints on `std::net::IpAddr`\n+  [#6377](https://github.com/rust-lang/rust-clippy/pull/6377)\n+* [`search_is_some`]: Now suggests `contains` instead of `find(foo).is_some()`\n+  [#6119](https://github.com/rust-lang/rust-clippy/pull/6119)\n+* [`clone_double_ref`]: Now prints the reference type in the lint message\n+  [#6442](https://github.com/rust-lang/rust-clippy/pull/6442)\n+* [`modulo_one`]: Now also lints on -1.\n+  [#6360](https://github.com/rust-lang/rust-clippy/pull/6360)\n+* [`empty_loop`]: Now lints no_std crates, too\n+  [#6205](https://github.com/rust-lang/rust-clippy/pull/6205)\n+* [`or_fun_call`]: Now also lints when indexing `HashMap` or `BTreeMap`\n+  [#6267](https://github.com/rust-lang/rust-clippy/pull/6267)\n+* [`wrong_self_convention`]: Now also lints in trait definitions\n+  [#6316](https://github.com/rust-lang/rust-clippy/pull/6316)\n+* [`needless_borrow`]: Print the type in the lint message\n+  [#6449](https://github.com/rust-lang/rust-clippy/pull/6449)\n+\n+[msrv_readme]: https://github.com/rust-lang/rust-clippy#specifying-the-minimum-supported-rust-version\n+\n+### False Positive Fixes\n+\n+* [`manual_range_contains`]: No longer lints in `const fn`\n+  [#6382](https://github.com/rust-lang/rust-clippy/pull/6382)\n+* [`unnecessary_lazy_evaluations`]: No longer lints if closure argument is used\n+  [#6370](https://github.com/rust-lang/rust-clippy/pull/6370)\n+* [`match_single_binding`]: Now ignores cases with `#[cfg()]` macros\n+  [#6435](https://github.com/rust-lang/rust-clippy/pull/6435)\n+* [`match_like_matches_macro`]: No longer lints on arms with attributes\n+  [#6290](https://github.com/rust-lang/rust-clippy/pull/6290)\n+* [`map_clone`]: No longer lints with deref and clone\n+  [#6269](https://github.com/rust-lang/rust-clippy/pull/6269)\n+* [`map_clone`]: No longer lints in the case of &mut\n+  [#6301](https://github.com/rust-lang/rust-clippy/pull/6301)\n+* [`needless_update`]: Now ignores `non_exhaustive` structs\n+  [#6464](https://github.com/rust-lang/rust-clippy/pull/6464)\n+* [`needless_collect`]: No longer lints when a collect is needed multiple times\n+  [#6313](https://github.com/rust-lang/rust-clippy/pull/6313)\n+* [`unnecessary_cast`] No longer lints cfg-dependent types\n+  [#6369](https://github.com/rust-lang/rust-clippy/pull/6369)\n+* [`declare_interior_mutable_const`] and [`borrow_interior_mutable_const`]:\n+  Both now ignore enums with frozen variants\n+  [#6110](https://github.com/rust-lang/rust-clippy/pull/6110)\n+\n+\n+### Suggestion Fixes/Improvements\n+\n+* [`vec_box`]: Provide correct type scope suggestion\n+  [#6271](https://github.com/rust-lang/rust-clippy/pull/6271)\n+* [`manual_range_contains`]: Give correct suggestion when using floats\n+  [#6320](https://github.com/rust-lang/rust-clippy/pull/6320)\n+* [`unnecessary_lazy_evaluations`]: Don't always mark suggestion as MachineApplicable\n+  [#6272](https://github.com/rust-lang/rust-clippy/pull/6272)\n+* [`manual_async_fn`]: Improve suggestion formatting\n+  [#6294](https://github.com/rust-lang/rust-clippy/pull/6294)\n+* [`unnecessary_cast`]: Fix incorrectly formatted float literal suggestion\n+  [#6362](https://github.com/rust-lang/rust-clippy/pull/6362)\n+\n+### ICE Fixes\n+\n+* Fix a crash in [`from_iter_instead_of_collect`]\n+  [#6304](https://github.com/rust-lang/rust-clippy/pull/6304)\n+* Fix a silent crash when parsing doc comments in [`needless_doctest_main`]\n+  [#6458](https://github.com/rust-lang/rust-clippy/pull/6458)\n+\n+### Documentation Improvements\n+\n+* The lint website search has been improved ([#6477](https://github.com/rust-lang/rust-clippy/pull/6477)):\n+  * Searching for lints with dashes and spaces is possible now. For example\n+    `missing-errors-doc` and `missing errors doc` are now valid aliases for lint names\n+  * Improved fuzzy search in lint descriptions\n+* Various README improvements\n+  [#6287](https://github.com/rust-lang/rust-clippy/pull/6287)\n+* Add known problems to [`comparison_chain`] documentation\n+  [#6390](https://github.com/rust-lang/rust-clippy/pull/6390)\n+* Fix example used in [`cargo_common_metadata`]\n+  [#6293](https://github.com/rust-lang/rust-clippy/pull/6293)\n+* Improve [`map_clone`] documentation\n+  [#6340](https://github.com/rust-lang/rust-clippy/pull/6340)\n+\n+### Others\n+\n+* You can now tell Clippy about the MSRV your project supports. Please refer to\n+  the specific README section to learn more about MSRV support [here][msrv_readme]\n+  [#6201](https://github.com/rust-lang/rust-clippy/pull/6201)\n+* Add `--no-deps` option to avoid running on path dependencies in workspaces\n+  [#6188](https://github.com/rust-lang/rust-clippy/pull/6188)\n \n ## Rust 1.49\n \n-Current beta, release 2020-12-31\n+Current stable, released 2020-12-31\n \n [e636b88...b20d4c1](https://github.com/rust-lang/rust-clippy/compare/e636b88...b20d4c1)\n \n@@ -116,7 +243,7 @@ Current beta, release 2020-12-31\n \n ## Rust 1.48\n \n-Current stable, released 2020-11-19\n+Released 2020-11-19\n \n [09bd400...e636b88](https://github.com/rust-lang/rust-clippy/compare/09bd400...e636b88)\n \n@@ -1751,6 +1878,7 @@ Released 2018-09-13\n [`boxed_local`]: https://rust-lang.github.io/rust-clippy/master/index.html#boxed_local\n [`builtin_type_shadow`]: https://rust-lang.github.io/rust-clippy/master/index.html#builtin_type_shadow\n [`cargo_common_metadata`]: https://rust-lang.github.io/rust-clippy/master/index.html#cargo_common_metadata\n+[`case_sensitive_file_extension_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#case_sensitive_file_extension_comparisons\n [`cast_lossless`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_lossless\n [`cast_possible_truncation`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_possible_truncation\n [`cast_possible_wrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_possible_wrap\n@@ -1769,7 +1897,9 @@ Released 2018-09-13\n [`cmp_null`]: https://rust-lang.github.io/rust-clippy/master/index.html#cmp_null\n [`cmp_owned`]: https://rust-lang.github.io/rust-clippy/master/index.html#cmp_owned\n [`cognitive_complexity`]: https://rust-lang.github.io/rust-clippy/master/index.html#cognitive_complexity\n+[`collapsible_else_if`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\n [`collapsible_if`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\n+[`collapsible_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_match\n [`comparison_chain`]: https://rust-lang.github.io/rust-clippy/master/index.html#comparison_chain\n [`comparison_to_empty`]: https://rust-lang.github.io/rust-clippy/master/index.html#comparison_to_empty\n [`copy_iterator`]: https://rust-lang.github.io/rust-clippy/master/index.html#copy_iterator\n@@ -1840,6 +1970,7 @@ Released 2018-09-13\n [`forget_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_copy\n [`forget_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_ref\n [`from_iter_instead_of_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_iter_instead_of_collect\n+[`from_over_into`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_over_into\n [`future_not_send`]: https://rust-lang.github.io/rust-clippy/master/index.html#future_not_send\n [`get_last_with_len`]: https://rust-lang.github.io/rust-clippy/master/index.html#get_last_with_len\n [`get_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#get_unwrap\n@@ -1971,6 +2102,7 @@ Released 2018-09-13\n [`needless_doctest_main`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_doctest_main\n [`needless_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_lifetimes\n [`needless_pass_by_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_pass_by_value\n+[`needless_question_mark`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_question_mark\n [`needless_range_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_range_loop\n [`needless_return`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_return\n [`needless_update`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_update\n@@ -2005,10 +2137,12 @@ Released 2018-09-13\n [`possible_missing_comma`]: https://rust-lang.github.io/rust-clippy/master/index.html#possible_missing_comma\n [`precedence`]: https://rust-lang.github.io/rust-clippy/master/index.html#precedence\n [`print_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#print_literal\n+[`print_stderr`]: https://rust-lang.github.io/rust-clippy/master/index.html#print_stderr\n [`print_stdout`]: https://rust-lang.github.io/rust-clippy/master/index.html#print_stdout\n [`print_with_newline`]: https://rust-lang.github.io/rust-clippy/master/index.html#print_with_newline\n [`println_empty_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#println_empty_string\n [`ptr_arg`]: https://rust-lang.github.io/rust-clippy/master/index.html#ptr_arg\n+[`ptr_as_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#ptr_as_ptr\n [`ptr_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#ptr_eq\n [`ptr_offset_with_cast`]: https://rust-lang.github.io/rust-clippy/master/index.html#ptr_offset_with_cast\n [`pub_enum_variant_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#pub_enum_variant_names\n@@ -2023,10 +2157,12 @@ Released 2018-09-13\n [`redundant_closure`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure\n [`redundant_closure_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure_call\n [`redundant_closure_for_method_calls`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure_for_method_calls\n+[`redundant_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_else\n [`redundant_field_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names\n [`redundant_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_pattern\n [`redundant_pattern_matching`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_pattern_matching\n [`redundant_pub_crate`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_pub_crate\n+[`redundant_slicing`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_slicing\n [`redundant_static_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_static_lifetimes\n [`ref_in_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_in_deref\n [`ref_option_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_option_ref\n@@ -2056,6 +2192,7 @@ Released 2018-09-13\n [`single_element_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_element_loop\n [`single_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_match\n [`single_match_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_match_else\n+[`size_of_in_element_count`]: https://rust-lang.github.io/rust-clippy/master/index.html#size_of_in_element_count\n [`skip_while_next`]: https://rust-lang.github.io/rust-clippy/master/index.html#skip_while_next\n [`slow_vector_initialization`]: https://rust-lang.github.io/rust-clippy/master/index.html#slow_vector_initialization\n [`stable_sort_primitive`]: https://rust-lang.github.io/rust-clippy/master/index.html#stable_sort_primitive\n@@ -2073,6 +2210,7 @@ Released 2018-09-13\n [`suspicious_else_formatting`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_else_formatting\n [`suspicious_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_map\n [`suspicious_op_assign_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_op_assign_impl\n+[`suspicious_operation_groupings`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_operation_groupings\n [`suspicious_unary_op_formatting`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_unary_op_formatting\n [`tabs_in_doc_comments`]: https://rust-lang.github.io/rust-clippy/master/index.html#tabs_in_doc_comments\n [`temporary_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_assignment\n@@ -2146,6 +2284,7 @@ Released 2018-09-13\n [`useless_transmute`]: https://rust-lang.github.io/rust-clippy/master/index.html#useless_transmute\n [`useless_vec`]: https://rust-lang.github.io/rust-clippy/master/index.html#useless_vec\n [`vec_box`]: https://rust-lang.github.io/rust-clippy/master/index.html#vec_box\n+[`vec_init_then_push`]: https://rust-lang.github.io/rust-clippy/master/index.html#vec_init_then_push\n [`vec_resize_to_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#vec_resize_to_zero\n [`verbose_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#verbose_bit_mask\n [`verbose_file_reads`]: https://rust-lang.github.io/rust-clippy/master/index.html#verbose_file_reads\n@@ -2166,5 +2305,6 @@ Released 2018-09-13\n [`zero_divided_by_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#zero_divided_by_zero\n [`zero_prefixed_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#zero_prefixed_literal\n [`zero_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#zero_ptr\n+[`zero_sized_map_values`]: https://rust-lang.github.io/rust-clippy/master/index.html#zero_sized_map_values\n [`zst_offset`]: https://rust-lang.github.io/rust-clippy/master/index.html#zst_offset\n <!-- end autogenerated links to lint list -->"}, {"sha": "f2641a23f563b0528be459163f3568057ff93aed", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 51, "deletions": 30, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -14,11 +14,16 @@ All contributors are expected to follow the [Rust Code of Conduct].\n \n - [Contributing to Clippy](#contributing-to-clippy)\n   - [Getting started](#getting-started)\n+    - [High level approach](#high-level-approach)\n     - [Finding something to fix/improve](#finding-something-to-fiximprove)\n   - [Writing code](#writing-code)\n   - [Getting code-completion for rustc internals to work](#getting-code-completion-for-rustc-internals-to-work)\n   - [How Clippy works](#how-clippy-works)\n-  - [Fixing build failures caused by Rust](#fixing-build-failures-caused-by-rust)\n+  - [Syncing changes between Clippy and `rust-lang/rust`](#syncing-changes-between-clippy-and-rust-langrust)\n+    - [Patching git-subtree to work with big repos](#patching-git-subtree-to-work-with-big-repos)\n+    - [Performing the sync from `rust-lang/rust` to Clippy](#performing-the-sync-from-rust-langrust-to-clippy)\n+    - [Performing the sync from Clippy to `rust-lang/rust`](#performing-the-sync-from-clippy-to-rust-langrust)\n+    - [Defining remotes](#defining-remotes)\n   - [Issue and PR triage](#issue-and-pr-triage)\n   - [Bors and Homu](#bors-and-homu)\n   - [Contributions](#contributions)\n@@ -44,7 +49,7 @@ first read the [Basics docs](doc/basics.md).**\n All issues on Clippy are mentored, if you want help with a bug just ask\n @Manishearth, @flip1995, @phansch or @yaahc.\n \n-Some issues are easier than others. The [`good first issue`] label can be used to find the easy issues.\n+Some issues are easier than others. The [`good-first-issue`] label can be used to find the easy issues.\n If you want to work on an issue, please leave a comment so that we can assign it to you!\n \n There are also some abandoned PRs, marked with [`S-inactive-closed`].\n@@ -63,16 +68,16 @@ To figure out how this syntax structure is encoded in the AST, it is recommended\n Usually the lint will end up to be a nested series of matches and ifs, [like so][deep-nesting].\n But we can make it nest-less by using [if_chain] macro, [like this][nest-less].\n \n-[`E-medium`] issues are generally pretty easy too, though it's recommended you work on an [`good first issue`]\n+[`E-medium`] issues are generally pretty easy too, though it's recommended you work on an [`good-first-issue`]\n first. Sometimes they are only somewhat involved code wise, but not difficult per-se.\n-Note that [`E-medium`] issues may require some knowledge of Clippy internals or some \n-debugging to find the actual problem behind the issue. \n+Note that [`E-medium`] issues may require some knowledge of Clippy internals or some\n+debugging to find the actual problem behind the issue.\n \n [`T-middle`] issues can be more involved and require verifying types. The [`ty`] module contains a\n lot of methods that are useful, though one of the most useful would be `expr_ty` (gives the type of\n an AST expression). `match_def_path()` in Clippy's `utils` module can also be useful.\n \n-[`good first issue`]: https://github.com/rust-lang/rust-clippy/labels/good%20first%20issue\n+[`good-first-issue`]: https://github.com/rust-lang/rust-clippy/labels/good-first-issue\n [`S-inactive-closed`]: https://github.com/rust-lang/rust-clippy/pulls?q=is%3Aclosed+label%3AS-inactive-closed\n [`T-AST`]: https://github.com/rust-lang/rust-clippy/labels/T-AST\n [`T-middle`]: https://github.com/rust-lang/rust-clippy/labels/T-middle\n@@ -106,7 +111,7 @@ To work around this, you need to have a copy of the [rustc-repo][rustc_repo] ava\n `git clone https://github.com/rust-lang/rust/`.\n Then you can run a `cargo dev` command to automatically make Clippy use the rustc-repo via path-dependencies\n which rust-analyzer will be able to understand.\n-Run `cargo dev ra-setup --repo-path <repo-path>` where `<repo-path>` is an absolute path to the rustc repo\n+Run `cargo dev ra_setup --repo-path <repo-path>` where `<repo-path>` is an absolute path to the rustc repo\n you just cloned.\n The command will add path-dependencies pointing towards rustc-crates inside the rustc repo to\n Clippys `Cargo.toml`s and should allow rust-analyzer to understand most of the types that Clippy uses.\n@@ -177,18 +182,26 @@ That's why the `else_if_without_else` example uses the `register_early_pass` fun\n [early_lint_pass]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html\n [late_lint_pass]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.LateLintPass.html\n \n-## Fixing build failures caused by Rust\n+## Syncing changes between Clippy and [`rust-lang/rust`]\n \n-Clippy currently gets built with `rustc` of the `rust-lang/rust` `master`\n-branch. Most of the times we have to adapt to the changes and only very rarely\n-there's an actual bug in Rust.\n+Clippy currently gets built with a pinned nightly version.\n \n-If you decide to make Clippy work again with a Rust commit that breaks it, you\n-have to sync the `rust-lang/rust-clippy` repository with the `subtree` copy of\n-Clippy in the `rust-lang/rust` repository.\n+In the `rust-lang/rust` repository, where rustc resides, there's a copy of Clippy\n+that compiler hackers modify from time to time to adapt to changes in the unstable\n+API of the compiler.\n \n-For general information about `subtree`s in the Rust repository see [Rust's\n-`CONTRIBUTING.md`][subtree].\n+We need to sync these changes back to this repository periodically, and the changes\n+made to this repository in the meantime also need to be synced to the `rust-lang/rust` repository.\n+\n+To avoid flooding the `rust-lang/rust` PR queue, this two-way sync process is done\n+in a bi-weekly basis if there's no urgent changes. This is done starting on the day of\n+the Rust stable release and then every other week. That way we guarantee that we keep\n+this repo up to date with the latest compiler API, and every feature in Clippy is available\n+for 2 weeks in nightly, before it can get to beta. For reference, the first sync\n+following this cadence was performed the 2020-08-27.\n+\n+This process is described in detail in the following sections. For general information\n+about `subtree`s in the Rust repository see [Rust's `CONTRIBUTING.md`][subtree].\n \n ### Patching git-subtree to work with big repos\n \n@@ -217,13 +230,14 @@ This shell has a hardcoded recursion limit set to 1000. In order to make this pr\n you need to force the script to run `bash` instead. You can do this by editing the first\n line of the `git-subtree` script and changing `sh` to `bash`.\n \n-### Performing the sync\n+### Performing the sync from [`rust-lang/rust`] to Clippy\n \n Here is a TL;DR version of the sync process (all of the following commands have\n to be run inside the `rust` directory):\n \n-1. Clone the [`rust-lang/rust`] repository\n-2. Sync the changes to the rust-copy of Clippy to your Clippy fork:\n+1. Clone the [`rust-lang/rust`] repository or make sure it is up to date.\n+2. Checkout the commit from the latest available nightly. You can get it using `rustup check`.\n+3. Sync the changes to the rust-copy of Clippy to your Clippy fork:\n     ```bash\n     # Make sure to change `your-github-name` to your github name in the following command\n     git subtree push -P src/tools/clippy git@github.com:your-github-name/rust-clippy sync-from-rust\n@@ -241,17 +255,11 @@ to be run inside the `rust` directory):\n     git checkout sync-from-rust\n     git merge upstream/master\n     ```\n-3. Open a PR to `rust-lang/rust-clippy` and wait for it to get merged (to\n+4. Open a PR to `rust-lang/rust-clippy` and wait for it to get merged (to\n    accelerate the process ping the `@rust-lang/clippy` team in your PR and/or\n    ~~annoy~~ ask them in the [Zulip] stream.)\n-   \n-### Syncing back changes in Clippy to [`rust-lang/rust`]\n \n-To avoid flooding the [`rust-lang/rust`] PR queue, changes in Clippy's repo are synced back\n-in a bi-weekly basis if there's no urgent changes. This is done starting on the day of\n-the Rust stable release and then every other week. That way we guarantee that\n-every feature in Clippy is available for 2 weeks in nightly, before it can get to beta.\n-For reference, the first sync following this cadence was performed the 2020-08-27.\n+### Performing the sync from Clippy to [`rust-lang/rust`]\n \n All of the following commands have to be run inside the `rust` directory.\n \n@@ -302,10 +310,19 @@ currently. Between writing new lints, fixing issues, reviewing pull requests and\n responding to issues there may not always be enough time to stay on top of it\n all.\n \n-Our highest priority is fixing [crashes][l-crash] and [bugs][l-bug]. We don't\n+Our highest priority is fixing [crashes][l-crash] and [bugs][l-bug], for example\n+an ICE in a popular crate that many other crates depend on. We don't\n want Clippy to crash on your code and we want it to be as reliable as the\n suggestions from Rust compiler errors.\n \n+We have prioritization labels and a sync-blocker label, which are described below.\n+- [P-low][p-low]: Requires attention (fix/response/evaluation) by a team member but isn't urgent.\n+- [P-medium][p-medium]: Should be addressed by a team member until the next sync.\n+- [P-high][p-high]: Should be immediately addressed and will require an out-of-cycle sync or a backport.\n+- [L-sync-blocker][l-sync-blocker]: An issue that \"blocks\" a sync. \n+Or rather: before the sync this should be addressed,\n+e.g. by removing a lint again, so it doesn't hit beta/stable.\n+\n ## Bors and Homu\n \n We use a bot powered by [Homu][homu] to help automate testing and landing of pull\n@@ -319,9 +336,13 @@ commands [here][homu_instructions].\n [triage]: https://forge.rust-lang.org/release/triage-procedure.html\n [l-crash]: https://github.com/rust-lang/rust-clippy/labels/L-crash\n [l-bug]: https://github.com/rust-lang/rust-clippy/labels/L-bug\n+[p-low]: https://github.com/rust-lang/rust-clippy/labels/P-low\n+[p-medium]: https://github.com/rust-lang/rust-clippy/labels/P-medium\n+[p-high]: https://github.com/rust-lang/rust-clippy/labels/P-high\n+[l-sync-blocker]: https://github.com/rust-lang/rust-clippy/labels/L-sync-blocker\n [homu]: https://github.com/rust-lang/homu\n-[homu_instructions]: https://buildbot2.rust-lang.org/homu/\n-[homu_queue]: https://buildbot2.rust-lang.org/homu/queue/clippy\n+[homu_instructions]: https://bors.rust-lang.org/\n+[homu_queue]: https://bors.rust-lang.org/queue/clippy\n \n ## Contributions\n "}, {"sha": "e60aa472846cfcee8f204bd28ec0fdfb0b4481a3", "filename": "Cargo.toml", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.212\"\n+version = \"0.1.51\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\",\n@@ -29,10 +29,10 @@ path = \"src/driver.rs\"\n \n [dependencies]\n # begin automatic update\n-clippy_lints = { version = \"0.0.212\", path = \"clippy_lints\" }\n+clippy_lints = { version = \"0.1.50\", path = \"clippy_lints\" }\n # end automatic update\n semver = \"0.11\"\n-rustc_tools_util = { version = \"0.2.0\", path = \"rustc_tools_util\"}\n+rustc_tools_util = { version = \"0.2.0\", path = \"rustc_tools_util\" }\n tempfile = { version = \"3.1.0\", optional = true }\n \n [dev-dependencies]\n@@ -49,8 +49,9 @@ derive-new = \"0.5\"\n rustc-workspace-hack = \"1.0.0\"\n \n [build-dependencies]\n-rustc_tools_util = { version = \"0.2.0\", path = \"rustc_tools_util\"}\n+rustc_tools_util = { version = \"0.2.0\", path = \"rustc_tools_util\" }\n \n [features]\n deny-warnings = []\n integration = [\"tempfile\"]\n+internal-lints = [\"clippy_lints/internal-lints\"]"}, {"sha": "a4928e17e6a947a3bbcb02a3e43ae9575ddc6cf8", "filename": "README.md", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -10,16 +10,16 @@ A collection of lints to catch common mistakes and improve your [Rust](https://g\n Lints are divided into categories, each with a default [lint level](https://doc.rust-lang.org/rustc/lints/levels.html).\n You can choose how much Clippy is supposed to ~~annoy~~ help you by changing the lint level by category.\n \n-Category | Description | Default level\n--- | -- | --\n-`clippy::all` | all lints that are on by default (correctness, style, complexity, perf) | **warn/deny**\n-`clippy::correctness` | code that is outright wrong or very useless | **deny**\n-`clippy::style` | code that should be written in a more idiomatic way | **warn**\n-`clippy::complexity` | code that does something simple but in a complex way | **warn**\n-`clippy::perf` | code that can be written to run faster | **warn**\n-`clippy::pedantic` | lints which are rather strict or might have false positives | allow\n-`clippy::nursery` | new lints that are still under development | allow\n-`clippy::cargo` | lints for the cargo manifest | allow\n+| Category              | Description                                                             | Default level |\n+| --------------------- | ----------------------------------------------------------------------- | ------------- |\n+| `clippy::all`         | all lints that are on by default (correctness, style, complexity, perf) | **warn/deny** |\n+| `clippy::correctness` | code that is outright wrong or very useless                             | **deny**      |\n+| `clippy::style`       | code that should be written in a more idiomatic way                     | **warn**      |\n+| `clippy::complexity`  | code that does something simple but in a complex way                    | **warn**      |\n+| `clippy::perf`        | code that can be written to run faster                                  | **warn**      |\n+| `clippy::pedantic`    | lints which are rather strict or might have false positives             | allow         |\n+| `clippy::nursery`     | new lints that are still under development                              | allow         |\n+| `clippy::cargo`       | lints for the cargo manifest                                            | allow         |\n \n More to come, please [file an issue](https://github.com/rust-lang/rust-clippy/issues) if you have ideas!\n \n@@ -82,16 +82,21 @@ Note that this is still experimental and only supported on the nightly channel:\n cargo clippy --fix -Z unstable-options\n ```\n \n-### Running Clippy from the command line without installing it\n+#### Workspaces\n \n-To have cargo compile your crate with Clippy without Clippy installation\n-in your code, you can use:\n+All the usual workspace options should work with Clippy. For example the following command\n+will run Clippy on the `example` crate:\n \n ```terminal\n-cargo run --bin cargo-clippy --manifest-path=path_to_clippys_Cargo.toml\n+cargo clippy -p example\n ```\n \n-*Note:* Be sure that Clippy was compiled with the same version of rustc that cargo invokes here!\n+As with `cargo check`, this includes dependencies that are members of the workspace, like path dependencies.\n+If you want to run Clippy **only** on the given crate, use the `--no-deps` option like this:\n+\n+```terminal\n+cargo clippy -p example -- --no-deps \n+```\n \n ### Travis CI\n \n@@ -114,18 +119,6 @@ script:\n   # etc.\n ```\n \n-If you are on nightly, It might happen that Clippy is not available for a certain nightly release.\n-In this case you can try to conditionally install Clippy from the Git repo.\n-\n-```yaml\n-language: rust\n-rust:\n-  - nightly\n-before_script:\n-   - rustup component add clippy --toolchain=nightly || cargo install --git https://github.com/rust-lang/rust-clippy/ --force clippy\n-   # etc.\n-```\n-\n Note that adding `-D warnings` will cause your build to fail if **any** warnings are found in your code.\n That includes warnings found by rustc (e.g. `dead_code`, etc.). If you want to avoid this and only cause\n an error for Clippy warnings, use `#![deny(clippy::all)]` in your code or `-D clippy::all` on the command\n@@ -182,7 +175,7 @@ cargo clippy -- -W clippy::lint_name\n ```\n \n This also works with lint groups. For example you\n-can run Clippy with warnings for all lints enabled: \n+can run Clippy with warnings for all lints enabled:\n ```terminal\n cargo clippy -- -W clippy::pedantic\n ```\n@@ -214,7 +207,8 @@ fn main() {\n }\n ```\n \n-Tilde/Caret version requirements (like `^1.0` or `~1.2`) can be specified as well.\n+You can also omit the patch version when specifying the MSRV, so `msrv = 1.30`\n+is equivalent to `msrv = 1.30.0`.\n \n Note: `custom_inner_attributes` is an unstable feature so it has to be enabled explicitly.\n "}, {"sha": "b877806946cfeb0435b5d348368ff3505e2cb414", "filename": "clippy_dev/src/bless.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_dev%2Fsrc%2Fbless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_dev%2Fsrc%2Fbless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fbless.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,99 @@\n+//! `bless` updates the reference files in the repo with changed output files\n+//! from the last test run.\n+\n+use std::env;\n+use std::ffi::OsStr;\n+use std::fs;\n+use std::lazy::SyncLazy;\n+use std::path::{Path, PathBuf};\n+use walkdir::WalkDir;\n+\n+use crate::clippy_project_root;\n+\n+// NOTE: this is duplicated with tests/cargo/mod.rs What to do?\n+pub static CARGO_TARGET_DIR: SyncLazy<PathBuf> = SyncLazy::new(|| match env::var_os(\"CARGO_TARGET_DIR\") {\n+    Some(v) => v.into(),\n+    None => env::current_dir().unwrap().join(\"target\"),\n+});\n+\n+static CLIPPY_BUILD_TIME: SyncLazy<Option<std::time::SystemTime>> = SyncLazy::new(|| {\n+    let profile = env::var(\"PROFILE\").unwrap_or_else(|_| \"debug\".to_string());\n+    let mut path = PathBuf::from(&**CARGO_TARGET_DIR);\n+    path.push(profile);\n+    path.push(\"cargo-clippy\");\n+    fs::metadata(path).ok()?.modified().ok()\n+});\n+\n+pub fn bless(ignore_timestamp: bool) {\n+    let test_suite_dirs = [\n+        clippy_project_root().join(\"tests\").join(\"ui\"),\n+        clippy_project_root().join(\"tests\").join(\"ui-internal\"),\n+        clippy_project_root().join(\"tests\").join(\"ui-toml\"),\n+        clippy_project_root().join(\"tests\").join(\"ui-cargo\"),\n+    ];\n+    for test_suite_dir in &test_suite_dirs {\n+        WalkDir::new(test_suite_dir)\n+            .into_iter()\n+            .filter_map(Result::ok)\n+            .filter(|f| f.path().extension() == Some(OsStr::new(\"rs\")))\n+            .for_each(|f| {\n+                let test_name = f.path().strip_prefix(test_suite_dir).unwrap();\n+                for &ext in &[\"stdout\", \"stderr\", \"fixed\"] {\n+                    update_reference_file(\n+                        f.path().with_extension(ext),\n+                        test_name.with_extension(ext),\n+                        ignore_timestamp,\n+                    );\n+                }\n+            });\n+    }\n+}\n+\n+fn update_reference_file(reference_file_path: PathBuf, test_name: PathBuf, ignore_timestamp: bool) {\n+    let test_output_path = build_dir().join(test_name);\n+    let relative_reference_file_path = reference_file_path.strip_prefix(clippy_project_root()).unwrap();\n+\n+    // If compiletest did not write any changes during the test run,\n+    // we don't have to update anything\n+    if !test_output_path.exists() {\n+        return;\n+    }\n+\n+    // If the test output was not updated since the last clippy build, it may be outdated\n+    if !ignore_timestamp && !updated_since_clippy_build(&test_output_path).unwrap_or(true) {\n+        return;\n+    }\n+\n+    let test_output_file = fs::read(&test_output_path).expect(\"Unable to read test output file\");\n+    let reference_file = fs::read(&reference_file_path).unwrap_or_default();\n+\n+    if test_output_file != reference_file {\n+        // If a test run caused an output file to change, update the reference file\n+        println!(\"updating {}\", &relative_reference_file_path.display());\n+        fs::copy(test_output_path, &reference_file_path).expect(\"Could not update reference file\");\n+\n+        // We need to re-read the file now because it was potentially updated from copying\n+        let reference_file = fs::read(&reference_file_path).unwrap_or_default();\n+\n+        if reference_file.is_empty() {\n+            // If we copied over an empty output file, we remove the now empty reference file\n+            println!(\"removing {}\", &relative_reference_file_path.display());\n+            fs::remove_file(reference_file_path).expect(\"Could not remove reference file\");\n+        }\n+    }\n+}\n+\n+fn updated_since_clippy_build(path: &Path) -> Option<bool> {\n+    let clippy_build_time = (*CLIPPY_BUILD_TIME)?;\n+    let modified = fs::metadata(path).ok()?.modified().ok()?;\n+    Some(modified >= clippy_build_time)\n+}\n+\n+fn build_dir() -> PathBuf {\n+    let profile = env::var(\"PROFILE\").unwrap_or_else(|_| \"debug\".to_string());\n+    let mut path = PathBuf::new();\n+    path.push(CARGO_TARGET_DIR.clone());\n+    path.push(profile);\n+    path.push(\"test_build_base\");\n+    path\n+}"}, {"sha": "6b528d219df27d62a37f859f0900f3f6402b2b58", "filename": "clippy_dev/src/fmt.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_dev%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_dev%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Ffmt.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,9 +1,9 @@\n use crate::clippy_project_root;\n use shell_escape::escape;\n use std::ffi::OsStr;\n-use std::io;\n use std::path::Path;\n use std::process::{self, Command};\n+use std::{fs, io};\n use walkdir::WalkDir;\n \n #[derive(Debug)]\n@@ -12,6 +12,7 @@ pub enum CliError {\n     IoError(io::Error),\n     RustfmtNotInstalled,\n     WalkDirError(walkdir::Error),\n+    RaSetupActive,\n }\n \n impl From<io::Error> for CliError {\n@@ -31,12 +32,23 @@ struct FmtContext {\n     verbose: bool,\n }\n \n+// the \"main\" function of cargo dev fmt\n pub fn run(check: bool, verbose: bool) {\n     fn try_run(context: &FmtContext) -> Result<bool, CliError> {\n         let mut success = true;\n \n         let project_root = clippy_project_root();\n \n+        // if we added a local rustc repo as path dependency to clippy for rust analyzer, we do NOT want to\n+        // format because rustfmt would also format the entire rustc repo as it is a local\n+        // dependency\n+        if fs::read_to_string(project_root.join(\"Cargo.toml\"))\n+            .expect(\"Failed to read clippy Cargo.toml\")\n+            .contains(&\"[target.'cfg(NOT_A_PLATFORM)'.dependencies]\")\n+        {\n+            return Err(CliError::RaSetupActive);\n+        }\n+\n         rustfmt_test(context)?;\n \n         success &= cargo_fmt(context, project_root.as_path())?;\n@@ -75,6 +87,13 @@ pub fn run(check: bool, verbose: bool) {\n             CliError::WalkDirError(err) => {\n                 eprintln!(\"error: {}\", err);\n             },\n+            CliError::RaSetupActive => {\n+                eprintln!(\n+                    \"error: a local rustc repo is enabled as path dependency via `cargo dev ra_setup`.\n+Not formatting because that would format the local repo as well!\n+Please revert the changes to Cargo.tomls first.\"\n+                );\n+            },\n         }\n     }\n "}, {"sha": "17cc08ee10fea312f5b3d392991f61326be4f362", "filename": "clippy_dev/src/lib.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flib.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -10,6 +10,7 @@ use std::lazy::SyncLazy;\n use std::path::{Path, PathBuf};\n use walkdir::WalkDir;\n \n+pub mod bless;\n pub mod fmt;\n pub mod new_lint;\n pub mod ra_setup;\n@@ -146,16 +147,30 @@ pub fn gen_deprecated<'a>(lints: impl Iterator<Item = &'a Lint>) -> Vec<String>\n }\n \n #[must_use]\n-pub fn gen_register_lint_list<'a>(lints: impl Iterator<Item = &'a Lint>) -> Vec<String> {\n-    let pre = \"    store.register_lints(&[\".to_string();\n-    let post = \"    ]);\".to_string();\n-    let mut inner = lints\n+pub fn gen_register_lint_list<'a>(\n+    internal_lints: impl Iterator<Item = &'a Lint>,\n+    usable_lints: impl Iterator<Item = &'a Lint>,\n+) -> Vec<String> {\n+    let header = \"    store.register_lints(&[\".to_string();\n+    let footer = \"    ]);\".to_string();\n+    let internal_lints = internal_lints\n+        .sorted_by_key(|l| format!(\"        &{}::{},\", l.module, l.name.to_uppercase()))\n+        .map(|l| {\n+            format!(\n+                \"        #[cfg(feature = \\\"internal-lints\\\")]\\n        &{}::{},\",\n+                l.module,\n+                l.name.to_uppercase()\n+            )\n+        });\n+    let other_lints = usable_lints\n+        .sorted_by_key(|l| format!(\"        &{}::{},\", l.module, l.name.to_uppercase()))\n         .map(|l| format!(\"        &{}::{},\", l.module, l.name.to_uppercase()))\n-        .sorted()\n-        .collect::<Vec<String>>();\n-    inner.insert(0, pre);\n-    inner.push(post);\n-    inner\n+        .sorted();\n+    let mut lint_list = vec![header];\n+    lint_list.extend(internal_lints);\n+    lint_list.extend(other_lints);\n+    lint_list.push(footer);\n+    lint_list\n }\n \n /// Gathers all files in `src/clippy_lints` and gathers all lints inside"}, {"sha": "2ea56c42fafd62316adc779fa60b5922b70ced30", "filename": "clippy_dev/src/main.rs", "status": "modified", "additions": 63, "deletions": 47, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fmain.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,10 +1,61 @@\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n \n-use clap::{App, Arg, SubCommand};\n-use clippy_dev::{fmt, new_lint, ra_setup, serve, stderr_length_check, update_lints};\n+use clap::{App, Arg, ArgMatches, SubCommand};\n+use clippy_dev::{bless, fmt, new_lint, ra_setup, serve, stderr_length_check, update_lints};\n \n fn main() {\n-    let matches = App::new(\"Clippy developer tooling\")\n+    let matches = get_clap_config();\n+\n+    match matches.subcommand() {\n+        (\"bless\", Some(matches)) => {\n+            bless::bless(matches.is_present(\"ignore-timestamp\"));\n+        },\n+        (\"fmt\", Some(matches)) => {\n+            fmt::run(matches.is_present(\"check\"), matches.is_present(\"verbose\"));\n+        },\n+        (\"update_lints\", Some(matches)) => {\n+            if matches.is_present(\"print-only\") {\n+                update_lints::print_lints();\n+            } else if matches.is_present(\"check\") {\n+                update_lints::run(update_lints::UpdateMode::Check);\n+            } else {\n+                update_lints::run(update_lints::UpdateMode::Change);\n+            }\n+        },\n+        (\"new_lint\", Some(matches)) => {\n+            match new_lint::create(\n+                matches.value_of(\"pass\"),\n+                matches.value_of(\"name\"),\n+                matches.value_of(\"category\"),\n+            ) {\n+                Ok(_) => update_lints::run(update_lints::UpdateMode::Change),\n+                Err(e) => eprintln!(\"Unable to create lint: {}\", e),\n+            }\n+        },\n+        (\"limit_stderr_length\", _) => {\n+            stderr_length_check::check();\n+        },\n+        (\"ra_setup\", Some(matches)) => ra_setup::run(matches.value_of(\"rustc-repo-path\")),\n+        (\"serve\", Some(matches)) => {\n+            let port = matches.value_of(\"port\").unwrap().parse().unwrap();\n+            let lint = matches.value_of(\"lint\");\n+            serve::run(port, lint);\n+        },\n+        _ => {},\n+    }\n+}\n+\n+fn get_clap_config<'a>() -> ArgMatches<'a> {\n+    App::new(\"Clippy developer tooling\")\n+        .subcommand(\n+            SubCommand::with_name(\"bless\")\n+                .about(\"bless the test output changes\")\n+                .arg(\n+                    Arg::with_name(\"ignore-timestamp\")\n+                        .long(\"ignore-timestamp\")\n+                        .help(\"Include files updated before clippy was built\"),\n+                ),\n+        )\n         .subcommand(\n             SubCommand::with_name(\"fmt\")\n                 .about(\"Run rustfmt on all projects and tests\")\n@@ -25,16 +76,16 @@ fn main() {\n                 .about(\"Updates lint registration and information from the source code\")\n                 .long_about(\n                     \"Makes sure that:\\n \\\n-                     * the lint count in README.md is correct\\n \\\n-                     * the changelog contains markdown link references at the bottom\\n \\\n-                     * all lint groups include the correct lints\\n \\\n-                     * lint modules in `clippy_lints/*` are visible in `src/lib.rs` via `pub mod`\\n \\\n-                     * all lints are registered in the lint store\",\n+                 * the lint count in README.md is correct\\n \\\n+                 * the changelog contains markdown link references at the bottom\\n \\\n+                 * all lint groups include the correct lints\\n \\\n+                 * lint modules in `clippy_lints/*` are visible in `src/lifb.rs` via `pub mod`\\n \\\n+                 * all lints are registered in the lint store\",\n                 )\n                 .arg(Arg::with_name(\"print-only\").long(\"print-only\").help(\n                     \"Print a table of lints to STDOUT. \\\n-                     This does not include deprecated and internal lints. \\\n-                     (Does not modify any files)\",\n+                 This does not include deprecated and internal lints. \\\n+                 (Does not modify any files)\",\n                 ))\n                 .arg(\n                     Arg::with_name(\"check\")\n@@ -88,7 +139,7 @@ fn main() {\n                 .about(\"Ensures that stderr files do not grow longer than a certain amount of lines.\"),\n         )\n         .subcommand(\n-            SubCommand::with_name(\"ra-setup\")\n+            SubCommand::with_name(\"ra_setup\")\n                 .about(\"Alter dependencies so rust-analyzer can find rustc internals\")\n                 .arg(\n                     Arg::with_name(\"rustc-repo-path\")\n@@ -113,40 +164,5 @@ fn main() {\n                 )\n                 .arg(Arg::with_name(\"lint\").help(\"Which lint's page to load initially (optional)\")),\n         )\n-        .get_matches();\n-\n-    match matches.subcommand() {\n-        (\"fmt\", Some(matches)) => {\n-            fmt::run(matches.is_present(\"check\"), matches.is_present(\"verbose\"));\n-        },\n-        (\"update_lints\", Some(matches)) => {\n-            if matches.is_present(\"print-only\") {\n-                update_lints::print_lints();\n-            } else if matches.is_present(\"check\") {\n-                update_lints::run(update_lints::UpdateMode::Check);\n-            } else {\n-                update_lints::run(update_lints::UpdateMode::Change);\n-            }\n-        },\n-        (\"new_lint\", Some(matches)) => {\n-            match new_lint::create(\n-                matches.value_of(\"pass\"),\n-                matches.value_of(\"name\"),\n-                matches.value_of(\"category\"),\n-            ) {\n-                Ok(_) => update_lints::run(update_lints::UpdateMode::Change),\n-                Err(e) => eprintln!(\"Unable to create lint: {}\", e),\n-            }\n-        },\n-        (\"limit_stderr_length\", _) => {\n-            stderr_length_check::check();\n-        },\n-        (\"ra-setup\", Some(matches)) => ra_setup::run(matches.value_of(\"rustc-repo-path\")),\n-        (\"serve\", Some(matches)) => {\n-            let port = matches.value_of(\"port\").unwrap().parse().unwrap();\n-            let lint = matches.value_of(\"lint\");\n-            serve::run(port, lint);\n-        },\n-        _ => {},\n-    }\n+        .get_matches()\n }"}, {"sha": "5f5048e79e7825162beb876071fa887e233298f8", "filename": "clippy_dev/src/ra_setup.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_dev%2Fsrc%2Fra_setup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_dev%2Fsrc%2Fra_setup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fra_setup.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -3,7 +3,7 @@\n use std::fs;\n use std::fs::File;\n use std::io::prelude::*;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n \n // This module takes an absolute path to a rustc repo and alters the dependencies to point towards\n // the respective rustc subcrates instead of using extern crate xyz.\n@@ -44,15 +44,15 @@ pub fn run(rustc_path: Option<&str>) {\n }\n \n fn inject_deps_into_manifest(\n-    rustc_source_dir: &PathBuf,\n+    rustc_source_dir: &Path,\n     manifest_path: &str,\n     cargo_toml: &str,\n     lib_rs: &str,\n ) -> std::io::Result<()> {\n     // do not inject deps if we have aleady done so\n     if cargo_toml.contains(\"[target.'cfg(NOT_A_PLATFORM)'.dependencies]\") {\n         eprintln!(\n-            \"cargo dev ra-setup: warning: deps already found inside {}, doing nothing.\",\n+            \"cargo dev ra_setup: warning: deps already found inside {}, doing nothing.\",\n             manifest_path\n         );\n         return Ok(());"}, {"sha": "edf6c5f57a49766d44f8a353c55937ac0b015354", "filename": "clippy_dev/src/update_lints.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fupdate_lints.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -22,20 +22,7 @@ pub fn run(update_mode: UpdateMode) {\n \n     let usable_lint_count = round_to_fifty(usable_lints.len());\n \n-    let mut file_change = replace_region_in_file(\n-        Path::new(\"src/lintlist/mod.rs\"),\n-        \"begin lint list\",\n-        \"end lint list\",\n-        false,\n-        update_mode == UpdateMode::Change,\n-        || {\n-            format!(\"vec!{:#?}\", sorted_usable_lints)\n-                .lines()\n-                .map(ToString::to_string)\n-                .collect::<Vec<_>>()\n-        },\n-    )\n-    .changed;\n+    let mut file_change = false;\n \n     file_change |= replace_region_in_file(\n         Path::new(\"README.md\"),\n@@ -81,7 +68,7 @@ pub fn run(update_mode: UpdateMode) {\n         \"end register lints\",\n         false,\n         update_mode == UpdateMode::Change,\n-        || gen_register_lint_list(usable_lints.iter().chain(internal_lints.iter())),\n+        || gen_register_lint_list(internal_lints.iter(), usable_lints.iter()),\n     )\n     .changed;\n "}, {"sha": "38098f8a14c783a0ae8a6b7c7b025554c518cfb6", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,7 +1,7 @@\n [package]\n name = \"clippy_lints\"\n # begin automatic update\n-version = \"0.0.212\"\n+version = \"0.1.51\"\n # end automatic update\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n@@ -28,11 +28,16 @@ smallvec = { version = \"1\", features = [\"union\"] }\n toml = \"0.5.3\"\n unicode-normalization = \"0.1\"\n semver = \"0.11\"\n+rustc-semver=\"1.1.0\"\n # NOTE: cargo requires serde feat in its url dep\n # see <https://github.com/rust-lang/rust/pull/63587#issuecomment-522343864>\n url = { version =  \"2.1.0\", features = [\"serde\"] }\n quote = \"1\"\n syn = { version = \"1\", features = [\"full\"] }\n+regex = \"1.4\"\n+lazy_static = \"1.4\"\n \n [features]\n deny-warnings = []\n+# build clippy with internal lints enabled, off by default\n+internal-lints = []"}, {"sha": "aa431f0596cca9c12ac22d5a7f35d173a64e445c", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,8 +1,7 @@\n use crate::consts::{constant, Constant};\n use crate::utils::{is_direct_expn_of, is_expn_of, match_panic_call, snippet_opt, span_lint_and_help};\n use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n-use rustc_hir::{Expr, ExprKind, PatKind, UnOp};\n+use rustc_hir::{Expr, ExprKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -102,31 +101,22 @@ enum AssertKind {\n /// Check if the expression matches\n ///\n /// ```rust,ignore\n-/// match { let _t = !c; _t } {\n-///     true => {\n-///         {\n-///             ::std::rt::begin_panic(message, _)\n-///         }\n-///     }\n-///     _ => { }\n-/// };\n+/// if !c {\n+///   {\n+///     ::std::rt::begin_panic(message, _)\n+///   }\n+/// }\n /// ```\n ///\n /// where `message` is any expression and `c` is a constant bool.\n fn match_assert_with_message<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<AssertKind> {\n     if_chain! {\n-        if let ExprKind::Match(ref expr, ref arms, _) = expr.kind;\n-        // matches { let _t = expr; _t }\n-        if let ExprKind::DropTemps(ref expr) = expr.kind;\n-        if let ExprKind::Unary(UnOp::UnNot, ref expr) = expr.kind;\n+        if let ExprKind::If(ref cond, ref then, _) = expr.kind;\n+        if let ExprKind::Unary(UnOp::UnNot, ref expr) = cond.kind;\n         // bind the first argument of the `assert!` macro\n         if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.typeck_results(), expr);\n-        // arm 1 pattern\n-        if let PatKind::Lit(ref lit_expr) = arms[0].pat.kind;\n-        if let ExprKind::Lit(ref lit) = lit_expr.kind;\n-        if let LitKind::Bool(true) = lit.node;\n-        // arm 1 block\n-        if let ExprKind::Block(ref block, _) = arms[0].body.kind;\n+        // block\n+        if let ExprKind::Block(ref block, _) = then.kind;\n         if block.stmts.is_empty();\n         if let Some(block_expr) = &block.expr;\n         // inner block is optional. unwrap it if it exists, or use the expression as is otherwise."}, {"sha": "9a00fc535fc5c297f818bb4614599c6c227816cb", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -5,7 +5,6 @@ use crate::utils::{\n     span_lint_and_sugg, span_lint_and_then, without_block_comments,\n };\n use if_chain::if_chain;\n-use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_ast::{AttrKind, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use rustc_errors::Applicability;\n use rustc_hir::{\n@@ -15,6 +14,7 @@ use rustc_lint::{CheckLintNameResult, EarlyContext, EarlyLintPass, LateContext,\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::Span;\n use rustc_span::sym;\n use rustc_span::symbol::{Symbol, SymbolStr};\n@@ -399,7 +399,7 @@ fn extract_clippy_lint(lint: &NestedMetaItem) -> Option<SymbolStr> {\n         if let Some(meta_item) = lint.meta_item();\n         if meta_item.path.segments.len() > 1;\n         if let tool_name = meta_item.path.segments[0].ident;\n-        if tool_name.as_str() == \"clippy\";\n+        if tool_name.name == sym::clippy;\n         let lint_name = meta_item.path.segments.last().unwrap().ident.name;\n         then {\n             return Some(lint_name.as_str());\n@@ -427,7 +427,7 @@ fn check_clippy_lint_names(cx: &LateContext<'_>, ident: &str, items: &[NestedMet\n                             .map(|l| Symbol::intern(&l.name_lower()))\n                             .collect::<Vec<_>>();\n                         let sugg = find_best_match_for_name(\n-                            symbols.iter(),\n+                            &symbols,\n                             Symbol::intern(&format!(\"clippy::{}\", name_lower)),\n                             None,\n                         );"}, {"sha": "ae64c688744542512bb804858aa55c873a805066", "filename": "clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -18,7 +18,7 @@ declare_clippy_lint! {\n     /// other solution is to ensure the mutex is unlocked before calling await,\n     /// either by introducing a scope or an explicit call to Drop::drop.\n     ///\n-    /// **Known problems:** None.\n+    /// **Known problems:** Will report false positive for explicitly dropped guards ([#6446](https://github.com/rust-lang/rust-clippy/issues/6446)).\n     ///\n     /// **Example:**\n     ///\n@@ -57,7 +57,7 @@ declare_clippy_lint! {\n     /// at runtime. Holding onto a `RefCell` ref across an `await` suspension point\n     /// risks panics from a mutable ref shared while other refs are outstanding.\n     ///\n-    /// **Known problems:** None.\n+    /// **Known problems:** Will report false positive for explicitly dropped refs ([#6353](https://github.com/rust-lang/rust-clippy/issues/6353)).\n     ///\n     /// **Example:**\n     ///\n@@ -99,7 +99,11 @@ impl LateLintPass<'_> for AwaitHolding {\n             };\n             let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n             let typeck_results = cx.tcx.typeck(def_id);\n-            check_interior_types(cx, &typeck_results.generator_interior_types, body.value.span);\n+            check_interior_types(\n+                cx,\n+                &typeck_results.generator_interior_types.as_ref().skip_binder(),\n+                body.value.span,\n+            );\n         }\n     }\n }"}, {"sha": "4efca10bcdf13d650cdff8067231ae3f8f32d4f5", "filename": "clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{differing_macro_contexts, higher, snippet_block_with_applicability, span_lint, span_lint_and_sugg};\n+use crate::utils::{differing_macro_contexts, snippet_block_with_applicability, span_lint, span_lint_and_sugg};\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::{BlockCheckMode, Expr, ExprKind};\n@@ -75,7 +75,7 @@ impl<'tcx> LateLintPass<'tcx> for BlocksInIfConditions {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n-        if let Some((cond, _, _)) = higher::if_block(&expr) {\n+        if let ExprKind::If(cond, _, _) = &expr.kind {\n             if let ExprKind::Block(block, _) = &cond.kind {\n                 if block.rules == BlockCheckMode::DefaultBlock {\n                     if block.stmts.is_empty() {"}, {"sha": "d5347ce6ed756d6faf97a9e8cb77fce1947fe58f", "filename": "clippy_lints/src/case_sensitive_file_extension_comparisons.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,88 @@\n+use crate::utils::paths::STRING;\n+use crate::utils::{match_def_path, span_lint_and_help};\n+use if_chain::if_chain;\n+use lazy_static::lazy_static;\n+use regex::Regex;\n+use rustc_ast::ast::LitKind;\n+use rustc_hir::{Expr, ExprKind, PathSegment};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{source_map::Spanned, Span};\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Checks for calls to `ends_with` with possible file extensions\n+    /// and suggests to use a case-insensitive approach instead.\n+    ///\n+    /// **Why is this bad?**\n+    /// `ends_with` is case-sensitive and may not detect files with a valid extension.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// fn is_rust_file(filename: &str) -> bool {\n+    ///     filename.ends_with(\".rs\")\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn is_rust_file(filename: &str) -> bool {\n+    ///     filename.rsplit('.').next().map(|ext| ext.eq_ignore_ascii_case(\"rs\")) == Some(true)\n+    /// }\n+    /// ```\n+    pub CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n+    pedantic,\n+    \"Checks for calls to ends_with with case-sensitive file extensions\"\n+}\n+\n+declare_lint_pass!(CaseSensitiveFileExtensionComparisons => [CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS]);\n+\n+fn check_case_sensitive_file_extension_comparison(ctx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Span> {\n+    lazy_static! {\n+        static ref RE: Regex = Regex::new(r\"^\\.([a-z0-9]{1,5}|[A-Z0-9]{1,5})$\").unwrap();\n+    }\n+    if_chain! {\n+        if let ExprKind::MethodCall(PathSegment { ident, .. }, _, [obj, extension, ..], span) = expr.kind;\n+        if ident.as_str() == \"ends_with\";\n+        if let ExprKind::Lit(Spanned { node: LitKind::Str(ext_literal, ..), ..}) = extension.kind;\n+        if RE.is_match(&ext_literal.as_str());\n+        then {\n+            let mut ty = ctx.typeck_results().expr_ty(obj);\n+            ty = match ty.kind() {\n+                ty::Ref(_, ty, ..) => ty,\n+                _ => ty\n+            };\n+\n+            match ty.kind() {\n+                ty::Str => {\n+                    return Some(span);\n+                },\n+                ty::Adt(&ty::AdtDef { did, .. }, _) => {\n+                    if match_def_path(ctx, did, &STRING) {\n+                        return Some(span);\n+                    }\n+                },\n+                _ => { return None; }\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+impl LateLintPass<'tcx> for CaseSensitiveFileExtensionComparisons {\n+    fn check_expr(&mut self, ctx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+        if let Some(span) = check_case_sensitive_file_extension_comparison(ctx, expr) {\n+            span_lint_and_help(\n+                ctx,\n+                CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n+                span,\n+                \"case-sensitive file extension comparison\",\n+                None,\n+                \"consider using a case-insensitive comparison instead\",\n+            );\n+        }\n+    }\n+}"}, {"sha": "54bc69e058bc79460966385bec88e8cfce71f6bb", "filename": "clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -6,9 +6,12 @@ use rustc_errors::Applicability;\n use rustc_hir::{BinOp, BinOpKind, Expr, ExprKind, QPath, TyKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n \n-use crate::utils::{snippet_with_applicability, span_lint_and_sugg, SpanlessEq};\n+use crate::utils::{meets_msrv, snippet_with_applicability, span_lint_and_sugg, SpanlessEq};\n+\n+const CHECKED_CONVERSIONS_MSRV: RustcVersion = RustcVersion::new(1, 34, 0);\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for explicit bounds checking when casting.\n@@ -39,10 +42,25 @@ declare_clippy_lint! {\n     \"`try_from` could replace manual bounds checking when casting\"\n }\n \n-declare_lint_pass!(CheckedConversions => [CHECKED_CONVERSIONS]);\n+pub struct CheckedConversions {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl CheckedConversions {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(CheckedConversions => [CHECKED_CONVERSIONS]);\n \n impl<'tcx> LateLintPass<'tcx> for CheckedConversions {\n     fn check_expr(&mut self, cx: &LateContext<'_>, item: &Expr<'_>) {\n+        if !meets_msrv(self.msrv.as_ref(), &CHECKED_CONVERSIONS_MSRV) {\n+            return;\n+        }\n+\n         let result = if_chain! {\n             if !in_external_macro(cx.sess(), item.span);\n             if let ExprKind::Binary(op, ref left, ref right) = &item.kind;\n@@ -74,6 +92,8 @@ impl<'tcx> LateLintPass<'tcx> for CheckedConversions {\n             }\n         }\n     }\n+\n+    extract_msrv_attr!(LateContext);\n }\n \n /// Searches for a single check from unsigned to _ is done"}, {"sha": "b3ebdf4ca30d8d21119c6559b51f9782456d2bc2", "filename": "clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -147,6 +147,9 @@ impl<'tcx> Visitor<'tcx> for CCHelper {\n     fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n         walk_expr(self, e);\n         match e.kind {\n+            ExprKind::If(_, _, _) => {\n+                self.cc += 1;\n+            },\n             ExprKind::Match(_, ref arms, _) => {\n                 if arms.len() > 1 {\n                     self.cc += 1;"}, {"sha": "93ccc76d0c9cdf829ed63b09cae07f21ad6c073d", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -23,9 +23,7 @@ use rustc_errors::Applicability;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for nested `if` statements which can be collapsed\n-    /// by `&&`-combining their conditions and for `else { if ... }` expressions\n-    /// that\n-    /// can be collapsed to `else if ...`.\n+    /// by `&&`-combining their conditions.\n     ///\n     /// **Why is this bad?** Each `if`-statement adds one level of nesting, which\n     /// makes code look more complex than it really is.\n@@ -40,7 +38,31 @@ declare_clippy_lint! {\n     ///     }\n     /// }\n     ///\n-    /// // or\n+    /// ```\n+    ///\n+    /// Should be written:\n+    ///\n+    /// ```rust.ignore\n+    /// if x && y {\n+    ///     \u2026\n+    /// }\n+    /// ```\n+    pub COLLAPSIBLE_IF,\n+    style,\n+    \"nested `if`s that can be collapsed (e.g., `if x { if y { ... } }`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for collapsible `else { if ... }` expressions\n+    /// that can be collapsed to `else if ...`.\n+    ///\n+    /// **Why is this bad?** Each `if`-statement adds one level of nesting, which\n+    /// makes code look more complex than it really is.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n     ///\n     /// if x {\n     ///     \u2026\n@@ -54,24 +76,18 @@ declare_clippy_lint! {\n     /// Should be written:\n     ///\n     /// ```rust.ignore\n-    /// if x && y {\n-    ///     \u2026\n-    /// }\n-    ///\n-    /// // or\n-    ///\n     /// if x {\n     ///     \u2026\n     /// } else if y {\n     ///     \u2026\n     /// }\n     /// ```\n-    pub COLLAPSIBLE_IF,\n+    pub COLLAPSIBLE_ELSE_IF,\n     style,\n-    \"`if`s that can be collapsed (e.g., `if x { if y { ... } }` and `else { if x { ... } }`)\"\n+    \"nested `else`-`if` expressions that can be collapsed (e.g., `else { if x { ... } }`)\"\n }\n \n-declare_lint_pass!(CollapsibleIf => [COLLAPSIBLE_IF]);\n+declare_lint_pass!(CollapsibleIf => [COLLAPSIBLE_IF, COLLAPSIBLE_ELSE_IF]);\n \n impl EarlyLintPass for CollapsibleIf {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n@@ -112,7 +128,7 @@ fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, else_: &ast::Expr) {\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,\n-                COLLAPSIBLE_IF,\n+                COLLAPSIBLE_ELSE_IF,\n                 block.span,\n                 \"this `else { if .. }` block can be collapsed\",\n                 \"collapse nested if block\","}, {"sha": "a34ba2d00a8c7bc71873bcb692b8ad7498542543", "filename": "clippy_lints/src/collapsible_match.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,172 @@\n+use crate::utils::visitors::LocalUsedVisitor;\n+use crate::utils::{span_lint_and_then, SpanlessEq};\n+use if_chain::if_chain;\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, QPath, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{DefIdTree, TyCtxt};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{MultiSpan, Span};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Finds nested `match` or `if let` expressions where the patterns may be \"collapsed\" together\n+    /// without adding any branches.\n+    ///\n+    /// Note that this lint is not intended to find _all_ cases where nested match patterns can be merged, but only\n+    /// cases where merging would most likely make the code more readable.\n+    ///\n+    /// **Why is this bad?** It is unnecessarily verbose and complex.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// fn func(opt: Option<Result<u64, String>>) {\n+    ///     let n = match opt {\n+    ///         Some(n) => match n {\n+    ///             Ok(n) => n,\n+    ///             _ => return,\n+    ///         }\n+    ///         None => return,\n+    ///     };\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn func(opt: Option<Result<u64, String>>) {\n+    ///     let n = match opt {\n+    ///         Some(Ok(n)) => n,\n+    ///         _ => return,\n+    ///     };\n+    /// }\n+    /// ```\n+    pub COLLAPSIBLE_MATCH,\n+    style,\n+    \"Nested `match` or `if let` expressions where the patterns may be \\\"collapsed\\\" together.\"\n+}\n+\n+declare_lint_pass!(CollapsibleMatch => [COLLAPSIBLE_MATCH]);\n+\n+impl<'tcx> LateLintPass<'tcx> for CollapsibleMatch {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n+        if let ExprKind::Match(_expr, arms, _source) = expr.kind {\n+            if let Some(wild_arm) = arms.iter().rfind(|arm| arm_is_wild_like(arm, cx.tcx)) {\n+                for arm in arms {\n+                    check_arm(arm, wild_arm, cx);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn check_arm(arm: &Arm<'_>, wild_outer_arm: &Arm<'_>, cx: &LateContext<'_>) {\n+    if_chain! {\n+        let expr = strip_singleton_blocks(arm.body);\n+        if let ExprKind::Match(expr_in, arms_inner, _) = expr.kind;\n+        // the outer arm pattern and the inner match\n+        if expr_in.span.ctxt() == arm.pat.span.ctxt();\n+        // there must be no more than two arms in the inner match for this lint\n+        if arms_inner.len() == 2;\n+        // no if guards on the inner match\n+        if arms_inner.iter().all(|arm| arm.guard.is_none());\n+        // match expression must be a local binding\n+        // match <local> { .. }\n+        if let ExprKind::Path(QPath::Resolved(None, path)) = expr_in.kind;\n+        if let Res::Local(binding_id) = path.res;\n+        // one of the branches must be \"wild-like\"\n+        if let Some(wild_inner_arm_idx) = arms_inner.iter().rposition(|arm_inner| arm_is_wild_like(arm_inner, cx.tcx));\n+        let (wild_inner_arm, non_wild_inner_arm) =\n+            (&arms_inner[wild_inner_arm_idx], &arms_inner[1 - wild_inner_arm_idx]);\n+        if !pat_contains_or(non_wild_inner_arm.pat);\n+        // the binding must come from the pattern of the containing match arm\n+        // ..<local>.. => match <local> { .. }\n+        if let Some(binding_span) = find_pat_binding(arm.pat, binding_id);\n+        // the \"wild-like\" branches must be equal\n+        if SpanlessEq::new(cx).eq_expr(wild_inner_arm.body, wild_outer_arm.body);\n+        // the binding must not be used in the if guard\n+        if !matches!(arm.guard, Some(Guard::If(guard)) if LocalUsedVisitor::new(binding_id).check_expr(guard));\n+        // ...or anywhere in the inner match\n+        if !arms_inner.iter().any(|arm| LocalUsedVisitor::new(binding_id).check_arm(arm));\n+        then {\n+            span_lint_and_then(\n+                cx,\n+                COLLAPSIBLE_MATCH,\n+                expr.span,\n+                \"Unnecessary nested match\",\n+                |diag| {\n+                    let mut help_span = MultiSpan::from_spans(vec![binding_span, non_wild_inner_arm.pat.span]);\n+                    help_span.push_span_label(binding_span, \"Replace this binding\".into());\n+                    help_span.push_span_label(non_wild_inner_arm.pat.span, \"with this pattern\".into());\n+                    diag.span_help(help_span, \"The outer pattern can be modified to include the inner pattern.\");\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+fn strip_singleton_blocks<'hir>(mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n+    while let ExprKind::Block(block, _) = expr.kind {\n+        match (block.stmts, block.expr) {\n+            ([stmt], None) => match stmt.kind {\n+                StmtKind::Expr(e) | StmtKind::Semi(e) => expr = e,\n+                _ => break,\n+            },\n+            ([], Some(e)) => expr = e,\n+            _ => break,\n+        }\n+    }\n+    expr\n+}\n+\n+/// A \"wild-like\" pattern is wild (\"_\") or `None`.\n+/// For this lint to apply, both the outer and inner match expressions\n+/// must have \"wild-like\" branches that can be combined.\n+fn arm_is_wild_like(arm: &Arm<'_>, tcx: TyCtxt<'_>) -> bool {\n+    if arm.guard.is_some() {\n+        return false;\n+    }\n+    match arm.pat.kind {\n+        PatKind::Binding(..) | PatKind::Wild => true,\n+        PatKind::Path(QPath::Resolved(None, path)) if is_none_ctor(path.res, tcx) => true,\n+        _ => false,\n+    }\n+}\n+\n+fn find_pat_binding(pat: &Pat<'_>, hir_id: HirId) -> Option<Span> {\n+    let mut span = None;\n+    pat.walk_short(|p| match &p.kind {\n+        // ignore OR patterns\n+        PatKind::Or(_) => false,\n+        PatKind::Binding(_bm, _, _ident, _) => {\n+            let found = p.hir_id == hir_id;\n+            if found {\n+                span = Some(p.span);\n+            }\n+            !found\n+        },\n+        _ => true,\n+    });\n+    span\n+}\n+\n+fn pat_contains_or(pat: &Pat<'_>) -> bool {\n+    let mut result = false;\n+    pat.walk(|p| {\n+        let is_or = matches!(p.kind, PatKind::Or(_));\n+        result |= is_or;\n+        !is_or\n+    });\n+    result\n+}\n+\n+fn is_none_ctor(res: Res, tcx: TyCtxt<'_>) -> bool {\n+    if let Some(none_id) = tcx.lang_items().option_none_variant() {\n+        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Const), id) = res {\n+            if let Some(variant_id) = tcx.parent(id) {\n+                return variant_id == none_id;\n+            }\n+        }\n+    }\n+    false\n+}"}, {"sha": "90d31dece13113ae9d2c64711211df9b1c67553a", "filename": "clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -12,7 +12,8 @@ declare_clippy_lint! {\n     /// **Why is this bad?** `if` is not guaranteed to be exhaustive and conditionals can get\n     /// repetitive\n     ///\n-    /// **Known problems:** None.\n+    /// **Known problems:** The match statement may be slower due to the compiler\n+    /// not inlining the call to cmp. See issue [#5354](https://github.com/rust-lang/rust-clippy/issues/5354)\n     ///\n     /// **Example:**\n     /// ```rust,ignore"}, {"sha": "166eadf86c177f49aa221145bcfaf4ba6c5342c3", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,6 +1,6 @@\n #![allow(clippy::float_cmp)]\n \n-use crate::utils::{clip, higher, sext, unsext};\n+use crate::utils::{clip, sext, unsext};\n use if_chain::if_chain;\n use rustc_ast::ast::{FloatTy, LitFloatType, LitKind};\n use rustc_data_structures::sync::Lrc;\n@@ -228,9 +228,6 @@ pub struct ConstEvalLateContext<'a, 'tcx> {\n impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n     /// Simple constant folding: Insert an expression, get a constant or none.\n     pub fn expr(&mut self, e: &Expr<'_>) -> Option<Constant> {\n-        if let Some((ref cond, ref then, otherwise)) = higher::if_block(&e) {\n-            return self.ifthenelse(cond, then, otherwise);\n-        }\n         match e.kind {\n             ExprKind::Path(ref qpath) => self.fetch_path(qpath, e.hir_id, self.typeck_results.expr_ty(e)),\n             ExprKind::Block(ref block, _) => self.block(block),\n@@ -249,6 +246,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                 UnOp::UnNeg => self.constant_negate(&o, self.typeck_results.expr_ty(e)),\n                 UnOp::UnDeref => Some(if let Constant::Ref(r) = o { *r } else { o }),\n             }),\n+            ExprKind::If(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, *otherwise),\n             ExprKind::Binary(op, ref left, ref right) => self.binop(op, left, right),\n             ExprKind::Call(ref callee, ref args) => {\n                 // We only handle a few const functions for now."}, {"sha": "944aaafb46de59e5748f60d3f1773a8e71f87657", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::{eq_expr_value, in_macro, search_same, SpanlessEq, SpanlessHash};\n-use crate::utils::{get_parent_expr, higher, if_sequence, span_lint_and_note};\n-use rustc_hir::{Block, Expr};\n+use crate::utils::{get_parent_expr, if_sequence, span_lint_and_note};\n+use rustc_hir::{Block, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -109,11 +109,13 @@ impl<'tcx> LateLintPass<'tcx> for CopyAndPaste {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if !expr.span.from_expansion() {\n             // skip ifs directly in else, it will be checked in the parent if\n-            if let Some(expr) = get_parent_expr(cx, expr) {\n-                if let Some((_, _, Some(ref else_expr))) = higher::if_block(&expr) {\n-                    if else_expr.hir_id == expr.hir_id {\n-                        return;\n-                    }\n+            if let Some(&Expr {\n+                kind: ExprKind::If(_, _, Some(ref else_expr)),\n+                ..\n+            }) = get_parent_expr(cx, expr)\n+            {\n+                if else_expr.hir_id == expr.hir_id {\n+                    return;\n                 }\n             }\n "}, {"sha": "48899b33899370b0afd37f57f8281d2a7bc41d15", "filename": "clippy_lints/src/copy_iterator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopy_iterator.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::{is_copy, match_path, paths, span_lint_and_note};\n-use rustc_hir::{Item, ItemKind};\n+use rustc_hir::{Impl, Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -33,10 +33,10 @@ declare_lint_pass!(CopyIterator => [COPY_ITERATOR]);\n \n impl<'tcx> LateLintPass<'tcx> for CopyIterator {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if let ItemKind::Impl {\n+        if let ItemKind::Impl(Impl {\n             of_trait: Some(ref trait_ref),\n             ..\n-        } = item.kind\n+        }) = item.kind\n         {\n             let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id(item.hir_id));\n "}, {"sha": "200b6a565cc43e53e29184ae7da416bd79440213", "filename": "clippy_lints/src/create_dir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fcreate_dir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fcreate_dir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcreate_dir.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -8,7 +8,7 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n declare_clippy_lint! {\n     /// **What it does:** Checks usage of `std::fs::create_dir` and suggest using `std::fs::create_dir_all` instead.\n     ///\n-    /// **Why is this bad?** Sometimes `std::fs::crate_dir` is mistakenly chosen over `std::fs::create_dir_all`.\n+    /// **Why is this bad?** Sometimes `std::fs::create_dir` is mistakenly chosen over `std::fs::create_dir_all`.\n     ///\n     /// **Known problems:** None.\n     ///"}, {"sha": "f7224811e6e79816a82376a564be2cc205d9d870", "filename": "clippy_lints/src/default.rs", "status": "modified", "additions": 78, "deletions": 120, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,12 +1,15 @@\n-use crate::utils::{any_parent_is_automatically_derived, contains_name, match_def_path, paths, qpath_res, snippet};\n+use crate::utils::{\n+    any_parent_is_automatically_derived, contains_name, match_def_path, paths, qpath_res, snippet_with_macro_callsite,\n+};\n use crate::utils::{span_lint_and_note, span_lint_and_sugg};\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir::def::Res;\n use rustc_hir::{Block, Expr, ExprKind, PatKind, QPath, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, Adt, Ty};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::Span;\n@@ -103,34 +106,52 @@ impl LateLintPass<'_> for Default {\n     }\n \n     fn check_block<'tcx>(&mut self, cx: &LateContext<'tcx>, block: &Block<'tcx>) {\n-        // find all binding statements like `let mut _ = T::default()` where `T::default()` is the\n-        // `default` method of the `Default` trait, and store statement index in current block being\n-        // checked and the name of the bound variable\n-        let binding_statements_using_default = enumerate_bindings_using_default(cx, block);\n-\n         // start from the `let mut _ = _::default();` and look at all the following\n         // statements, see if they re-assign the fields of the binding\n-        for (stmt_idx, binding_name, binding_type, span) in binding_statements_using_default {\n-            // the last statement of a block cannot trigger the lint\n-            if stmt_idx == block.stmts.len() - 1 {\n-                break;\n-            }\n+        let stmts_head = match block.stmts {\n+            // Skip the last statement since there cannot possibly be any following statements that re-assign fields.\n+            [head @ .., _] if !head.is_empty() => head,\n+            _ => return,\n+        };\n+        for (stmt_idx, stmt) in stmts_head.iter().enumerate() {\n+            // find all binding statements like `let mut _ = T::default()` where `T::default()` is the\n+            // `default` method of the `Default` trait, and store statement index in current block being\n+            // checked and the name of the bound variable\n+            let (local, variant, binding_name, binding_type, span) = if_chain! {\n+                // only take `let ...` statements\n+                if let StmtKind::Local(local) = stmt.kind;\n+                if let Some(expr) = local.init;\n+                if !any_parent_is_automatically_derived(cx.tcx, expr.hir_id);\n+                if !in_external_macro(cx.tcx.sess, expr.span);\n+                // only take bindings to identifiers\n+                if let PatKind::Binding(_, binding_id, ident, _) = local.pat.kind;\n+                // only when assigning `... = Default::default()`\n+                if is_expr_default(expr, cx);\n+                let binding_type = cx.typeck_results().node_type(binding_id);\n+                if let Some(adt) = binding_type.ty_adt_def();\n+                if adt.is_struct();\n+                let variant = adt.non_enum_variant();\n+                if adt.did.is_local() || !variant.is_field_list_non_exhaustive();\n+                let module_did = cx.tcx.parent_module(stmt.hir_id).to_def_id();\n+                if variant\n+                    .fields\n+                    .iter()\n+                    .all(|field| field.vis.is_accessible_from(module_did, cx.tcx));\n+                then {\n+                    (local, variant, ident.name, binding_type, expr.span)\n+                } else {\n+                    continue;\n+                }\n+            };\n \n             // find all \"later statement\"'s where the fields of the binding set as\n             // Default::default() get reassigned, unless the reassignment refers to the original binding\n             let mut first_assign = None;\n             let mut assigned_fields = Vec::new();\n             let mut cancel_lint = false;\n             for consecutive_statement in &block.stmts[stmt_idx + 1..] {\n-                // interrupt if the statement is a let binding (`Local`) that shadows the original\n-                // binding\n-                if stmt_shadows_binding(consecutive_statement, binding_name) {\n-                    break;\n-                }\n                 // find out if and which field was set by this `consecutive_statement`\n-                else if let Some((field_ident, assign_rhs)) =\n-                    field_reassigned_by_stmt(consecutive_statement, binding_name)\n-                {\n+                if let Some((field_ident, assign_rhs)) = field_reassigned_by_stmt(consecutive_statement, binding_name) {\n                     // interrupt and cancel lint if assign_rhs references the original binding\n                     if contains_name(binding_name, assign_rhs) {\n                         cancel_lint = true;\n@@ -152,7 +173,7 @@ impl LateLintPass<'_> for Default {\n                         first_assign = Some(consecutive_statement);\n                     }\n                 }\n-                // interrupt also if no field was assigned, since we only want to look at consecutive statements\n+                // interrupt if no field was assigned, since we only want to look at consecutive statements\n                 else {\n                     break;\n                 }\n@@ -161,55 +182,45 @@ impl LateLintPass<'_> for Default {\n             // if there are incorrectly assigned fields, do a span_lint_and_note to suggest\n             // construction using `Ty { fields, ..Default::default() }`\n             if !assigned_fields.is_empty() && !cancel_lint {\n-                // take the original assignment as span\n-                let stmt = &block.stmts[stmt_idx];\n-\n-                if let StmtKind::Local(preceding_local) = &stmt.kind {\n-                    // filter out fields like `= Default::default()`, because the FRU already covers them\n-                    let assigned_fields = assigned_fields\n-                        .into_iter()\n-                        .filter(|(_, rhs)| !is_expr_default(rhs, cx))\n-                        .collect::<Vec<(Symbol, &Expr<'_>)>>();\n+                // if all fields of the struct are not assigned, add `.. Default::default()` to the suggestion.\n+                let ext_with_default = !variant\n+                    .fields\n+                    .iter()\n+                    .all(|field| assigned_fields.iter().any(|(a, _)| a == &field.ident.name));\n \n-                    // if all fields of the struct are not assigned, add `.. Default::default()` to the suggestion.\n-                    let ext_with_default = !fields_of_type(binding_type)\n-                        .iter()\n-                        .all(|field| assigned_fields.iter().any(|(a, _)| a == &field.name));\n+                let field_list = assigned_fields\n+                    .into_iter()\n+                    .map(|(field, rhs)| {\n+                        // extract and store the assigned value for help message\n+                        let value_snippet = snippet_with_macro_callsite(cx, rhs.span, \"..\");\n+                        format!(\"{}: {}\", field, value_snippet)\n+                    })\n+                    .collect::<Vec<String>>()\n+                    .join(\", \");\n \n-                    let field_list = assigned_fields\n-                        .into_iter()\n-                        .map(|(field, rhs)| {\n-                            // extract and store the assigned value for help message\n-                            let value_snippet = snippet(cx, rhs.span, \"..\");\n-                            format!(\"{}: {}\", field, value_snippet)\n-                        })\n-                        .collect::<Vec<String>>()\n-                        .join(\", \");\n-\n-                    let sugg = if ext_with_default {\n-                        if field_list.is_empty() {\n-                            format!(\"{}::default()\", binding_type)\n-                        } else {\n-                            format!(\"{} {{ {}, ..Default::default() }}\", binding_type, field_list)\n-                        }\n+                let sugg = if ext_with_default {\n+                    if field_list.is_empty() {\n+                        format!(\"{}::default()\", binding_type)\n                     } else {\n-                        format!(\"{} {{ {} }}\", binding_type, field_list)\n-                    };\n+                        format!(\"{} {{ {}, ..Default::default() }}\", binding_type, field_list)\n+                    }\n+                } else {\n+                    format!(\"{} {{ {} }}\", binding_type, field_list)\n+                };\n \n-                    // span lint once per statement that binds default\n-                    span_lint_and_note(\n-                        cx,\n-                        FIELD_REASSIGN_WITH_DEFAULT,\n-                        first_assign.unwrap().span,\n-                        \"field assignment outside of initializer for an instance created with Default::default()\",\n-                        Some(preceding_local.span),\n-                        &format!(\n-                            \"consider initializing the variable with `{}` and removing relevant reassignments\",\n-                            sugg\n-                        ),\n-                    );\n-                    self.reassigned_linted.insert(span);\n-                }\n+                // span lint once per statement that binds default\n+                span_lint_and_note(\n+                    cx,\n+                    FIELD_REASSIGN_WITH_DEFAULT,\n+                    first_assign.unwrap().span,\n+                    \"field assignment outside of initializer for an instance created with Default::default()\",\n+                    Some(local.span),\n+                    &format!(\n+                        \"consider initializing the variable with `{}` and removing relevant reassignments\",\n+                        sugg\n+                    ),\n+                );\n+                self.reassigned_linted.insert(span);\n             }\n         }\n     }\n@@ -230,47 +241,6 @@ fn is_expr_default<'tcx>(expr: &'tcx Expr<'tcx>, cx: &LateContext<'tcx>) -> bool\n     }\n }\n \n-/// Returns the block indices, identifiers and types of bindings set as `Default::default()`, except\n-/// for when the pattern type is a tuple.\n-fn enumerate_bindings_using_default<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    block: &Block<'tcx>,\n-) -> Vec<(usize, Symbol, Ty<'tcx>, Span)> {\n-    block\n-        .stmts\n-        .iter()\n-        .enumerate()\n-        .filter_map(|(idx, stmt)| {\n-            if_chain! {\n-                // only take `let ...` statements\n-                if let StmtKind::Local(ref local) = stmt.kind;\n-                // only take bindings to identifiers\n-                if let PatKind::Binding(_, _, ident, _) = local.pat.kind;\n-                // that are not tuples\n-                let ty = cx.typeck_results().pat_ty(local.pat);\n-                if !matches!(ty.kind(), ty::Tuple(_));\n-                // only when assigning `... = Default::default()`\n-                if let Some(ref expr) = local.init;\n-                if is_expr_default(expr, cx);\n-                then {\n-                    Some((idx, ident.name, ty, expr.span))\n-                } else {\n-                    None\n-                }\n-            }\n-        })\n-        .collect()\n-}\n-\n-fn stmt_shadows_binding(this: &Stmt<'_>, shadowed: Symbol) -> bool {\n-    if let StmtKind::Local(local) = &this.kind {\n-        if let PatKind::Binding(_, _, ident, _) = local.pat.kind {\n-            return ident.name == shadowed;\n-        }\n-    }\n-    false\n-}\n-\n /// Returns the reassigned field and the assigning expression (right-hand side of assign).\n fn field_reassigned_by_stmt<'tcx>(this: &Stmt<'tcx>, binding_name: Symbol) -> Option<(Ident, &'tcx Expr<'tcx>)> {\n     if_chain! {\n@@ -280,8 +250,7 @@ fn field_reassigned_by_stmt<'tcx>(this: &Stmt<'tcx>, binding_name: Symbol) -> Op\n         // only take assignments to fields where the left-hand side field is a field of\n         // the same binding as the previous statement\n         if let ExprKind::Field(ref binding, field_ident) = assign_lhs.kind;\n-        if let ExprKind::Path(ref qpath) = binding.kind;\n-        if let QPath::Resolved(_, path) = qpath;\n+        if let ExprKind::Path(QPath::Resolved(_, path)) = binding.kind;\n         if let Some(second_binding_name) = path.segments.last();\n         if second_binding_name.ident.name == binding_name;\n         then {\n@@ -291,14 +260,3 @@ fn field_reassigned_by_stmt<'tcx>(this: &Stmt<'tcx>, binding_name: Symbol) -> Op\n         }\n     }\n }\n-\n-/// Returns the vec of fields for a struct and an empty vec for non-struct ADTs.\n-fn fields_of_type(ty: Ty<'_>) -> Vec<Ident> {\n-    if let Adt(adt, _) = ty.kind() {\n-        if adt.is_struct() {\n-            let variant = &adt.non_enum_variant();\n-            return variant.fields.iter().map(|f| f.ident).collect();\n-        }\n-    }\n-    vec![]\n-}"}, {"sha": "b1e363663bb27fd8fd5a051960fbc6e953e5ba39", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -7,7 +7,7 @@ use if_chain::if_chain;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{walk_expr, walk_fn, walk_item, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    BlockCheckMode, BodyId, Expr, ExprKind, FnDecl, HirId, Item, ItemKind, TraitRef, UnsafeSource, Unsafety,\n+    BlockCheckMode, BodyId, Expr, ExprKind, FnDecl, HirId, Impl, Item, ItemKind, TraitRef, UnsafeSource, Unsafety,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n@@ -164,10 +164,10 @@ declare_lint_pass!(Derive => [\n \n impl<'tcx> LateLintPass<'tcx> for Derive {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if let ItemKind::Impl {\n+        if let ItemKind::Impl(Impl {\n             of_trait: Some(ref trait_ref),\n             ..\n-        } = item.kind\n+        }) = item.kind\n         {\n             let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id(item.hir_id));\n             let is_automatically_derived = is_automatically_derived(&*item.attrs);"}, {"sha": "f518da55cd76fcb014202e5c4f5ca2f65ad22759", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 81, "deletions": 65, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -14,6 +14,7 @@ use rustc_middle::ty;\n use rustc_parse::maybe_new_parser_from_source_str;\n use rustc_session::parse::ParseSess;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::edition::Edition;\n use rustc_span::source_map::{BytePos, FilePathMapping, MultiSpan, SourceMap, Span};\n use rustc_span::{sym, FileName, Pos};\n use std::io;\n@@ -181,11 +182,8 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n                     lint_for_missing_headers(cx, item.hir_id, item.span, sig, headers, Some(body_id));\n                 }\n             },\n-            hir::ItemKind::Impl {\n-                of_trait: ref trait_ref,\n-                ..\n-            } => {\n-                self.in_trait_impl = trait_ref.is_some();\n+            hir::ItemKind::Impl(ref impl_) => {\n+                self.in_trait_impl = impl_.of_trait.is_some();\n             },\n             _ => {},\n         }\n@@ -377,7 +375,7 @@ fn check_attrs<'a>(cx: &LateContext<'_>, valid_idents: &FxHashSet<String>, attrs\n     check_doc(cx, valid_idents, events, &spans)\n }\n \n-const RUST_CODE: &[&str] = &[\"rust\", \"no_run\", \"should_panic\", \"compile_fail\", \"edition2018\"];\n+const RUST_CODE: &[&str] = &[\"rust\", \"no_run\", \"should_panic\", \"compile_fail\"];\n \n fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize>)>>(\n     cx: &LateContext<'_>,\n@@ -400,13 +398,24 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n     let mut in_link = None;\n     let mut in_heading = false;\n     let mut is_rust = false;\n+    let mut edition = None;\n     for (event, range) in events {\n         match event {\n             Start(CodeBlock(ref kind)) => {\n                 in_code = true;\n                 if let CodeBlockKind::Fenced(lang) = kind {\n-                    is_rust =\n-                        lang.is_empty() || !lang.contains(\"ignore\") && lang.split(',').any(|i| RUST_CODE.contains(&i));\n+                    for item in lang.split(',') {\n+                        if item == \"ignore\" {\n+                            is_rust = false;\n+                            break;\n+                        }\n+                        if let Some(stripped) = item.strip_prefix(\"edition\") {\n+                            is_rust = true;\n+                            edition = stripped.parse::<Edition>().ok();\n+                        } else if item.is_empty() || RUST_CODE.contains(&item) {\n+                            is_rust = true;\n+                        }\n+                    }\n                 }\n             },\n             End(CodeBlock(_)) => {\n@@ -436,7 +445,8 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n                 let (begin, span) = spans[index];\n                 if in_code {\n                     if is_rust {\n-                        check_code(cx, &text, span);\n+                        let edition = edition.unwrap_or_else(|| cx.tcx.sess.edition());\n+                        check_code(cx, &text, edition, span);\n                     }\n                 } else {\n                     // Adjust for the beginning of the current `Event`\n@@ -450,67 +460,73 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n     headers\n }\n \n-fn check_code(cx: &LateContext<'_>, text: &str, span: Span) {\n-    fn has_needless_main(code: &str) -> bool {\n-        let filename = FileName::anon_source_code(code);\n-\n-        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-        let emitter = EmitterWriter::new(box io::sink(), None, false, false, false, None, false);\n-        let handler = Handler::with_emitter(false, None, box emitter);\n-        let sess = ParseSess::with_span_handler(handler, sm);\n-\n-        let mut parser = match maybe_new_parser_from_source_str(&sess, filename, code.into()) {\n-            Ok(p) => p,\n-            Err(errs) => {\n-                for mut err in errs {\n-                    err.cancel();\n-                }\n-                return false;\n-            },\n-        };\n-\n-        let mut relevant_main_found = false;\n-        loop {\n-            match parser.parse_item() {\n-                Ok(Some(item)) => match &item.kind {\n-                    // Tests with one of these items are ignored\n-                    ItemKind::Static(..)\n-                    | ItemKind::Const(..)\n-                    | ItemKind::ExternCrate(..)\n-                    | ItemKind::ForeignMod(..) => return false,\n-                    // We found a main function ...\n-                    ItemKind::Fn(_, sig, _, Some(block)) if item.ident.name == sym::main => {\n-                        let is_async = matches!(sig.header.asyncness, Async::Yes{..});\n-                        let returns_nothing = match &sig.decl.output {\n-                            FnRetTy::Default(..) => true,\n-                            FnRetTy::Ty(ty) if ty.kind.is_unit() => true,\n-                            _ => false,\n-                        };\n-\n-                        if returns_nothing && !is_async && !block.stmts.is_empty() {\n-                            // This main function should be linted, but only if there are no other functions\n-                            relevant_main_found = true;\n-                        } else {\n-                            // This main function should not be linted, we're done\n-                            return false;\n+fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n+    fn has_needless_main(code: &str, edition: Edition) -> bool {\n+        rustc_driver::catch_fatal_errors(|| {\n+            rustc_span::with_session_globals(edition, || {\n+                let filename = FileName::anon_source_code(code);\n+\n+                let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+                let emitter = EmitterWriter::new(box io::sink(), None, false, false, false, None, false);\n+                let handler = Handler::with_emitter(false, None, box emitter);\n+                let sess = ParseSess::with_span_handler(handler, sm);\n+\n+                let mut parser = match maybe_new_parser_from_source_str(&sess, filename, code.into()) {\n+                    Ok(p) => p,\n+                    Err(errs) => {\n+                        for mut err in errs {\n+                            err.cancel();\n                         }\n+                        return false;\n                     },\n-                    // Another function was found; this case is ignored too\n-                    ItemKind::Fn(..) => return false,\n-                    _ => {},\n-                },\n-                Ok(None) => break,\n-                Err(mut e) => {\n-                    e.cancel();\n-                    return false;\n-                },\n-            }\n-        }\n+                };\n+\n+                let mut relevant_main_found = false;\n+                loop {\n+                    match parser.parse_item() {\n+                        Ok(Some(item)) => match &item.kind {\n+                            // Tests with one of these items are ignored\n+                            ItemKind::Static(..)\n+                            | ItemKind::Const(..)\n+                            | ItemKind::ExternCrate(..)\n+                            | ItemKind::ForeignMod(..) => return false,\n+                            // We found a main function ...\n+                            ItemKind::Fn(_, sig, _, Some(block)) if item.ident.name == sym::main => {\n+                                let is_async = matches!(sig.header.asyncness, Async::Yes { .. });\n+                                let returns_nothing = match &sig.decl.output {\n+                                    FnRetTy::Default(..) => true,\n+                                    FnRetTy::Ty(ty) if ty.kind.is_unit() => true,\n+                                    _ => false,\n+                                };\n+\n+                                if returns_nothing && !is_async && !block.stmts.is_empty() {\n+                                    // This main function should be linted, but only if there are no other functions\n+                                    relevant_main_found = true;\n+                                } else {\n+                                    // This main function should not be linted, we're done\n+                                    return false;\n+                                }\n+                            },\n+                            // Another function was found; this case is ignored too\n+                            ItemKind::Fn(..) => return false,\n+                            _ => {},\n+                        },\n+                        Ok(None) => break,\n+                        Err(mut e) => {\n+                            e.cancel();\n+                            return false;\n+                        },\n+                    }\n+                }\n \n-        relevant_main_found\n+                relevant_main_found\n+            })\n+        })\n+        .ok()\n+        .unwrap_or_default()\n     }\n \n-    if has_needless_main(text) {\n+    if has_needless_main(text, edition) {\n         span_lint(cx, NEEDLESS_DOCTEST_MAIN, span, \"needless `fn main` in doctest\");\n     }\n }"}, {"sha": "853b3afdc3ae2a0016e5c9da909c08b35cd2c400", "filename": "clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fempty_enum.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -8,8 +8,12 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n declare_clippy_lint! {\n     /// **What it does:** Checks for `enum`s with no variants.\n     ///\n+    /// As of this writing, the `never_type` is still a\n+    /// nightly-only experimental API. Therefore, this lint is only triggered\n+    /// if the `never_type` is enabled.\n+    ///\n     /// **Why is this bad?** If you want to introduce a type which\n-    /// can't be instantiated, you should use `!` (the never type),\n+    /// can't be instantiated, you should use `!` (the primitive type \"never\"),\n     /// or a wrapper around it, because `!` has more extensive\n     /// compiler support (type inference, etc...) and wrappers\n     /// around it are the conventional way to define an uninhabited type.\n@@ -40,6 +44,11 @@ declare_lint_pass!(EmptyEnum => [EMPTY_ENUM]);\n \n impl<'tcx> LateLintPass<'tcx> for EmptyEnum {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        // Only suggest the `never_type` if the feature is enabled\n+        if !cx.tcx.features().never_type {\n+            return;\n+        }\n+\n         let did = cx.tcx.hir().local_def_id(item.hir_id);\n         if let ItemKind::Enum(..) = item.kind {\n             let ty = cx.tcx.type_of(did);"}, {"sha": "37948e06869c3bfc4100d814663dd00c823dc37f", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::SpanlessEq;\n-use crate::utils::{get_item_name, higher, is_type_diagnostic_item, match_type, paths, snippet, snippet_opt};\n+use crate::utils::{get_item_name, is_type_diagnostic_item, match_type, paths, snippet, snippet_opt};\n use crate::utils::{snippet_with_applicability, span_lint_and_then};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -54,7 +54,7 @@ declare_lint_pass!(HashMapPass => [MAP_ENTRY]);\n \n impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some((ref check, ref then_block, ref else_block)) = higher::if_block(&expr) {\n+        if let ExprKind::If(ref check, ref then_block, ref else_block) = expr.kind {\n             if let ExprKind::Unary(UnOp::UnNot, ref check) = check.kind {\n                 if let Some((ty, map, key)) = check_cond(cx, check) {\n                     // in case of `if !m.contains_key(&k) { m.insert(k, v); }`"}, {"sha": "6308f6e2e7e9d6d8c825620ad644386dad8b5b6f", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,10 +1,10 @@\n use crate::utils::{\n-    eq_expr_value, higher, implements_trait, in_macro, is_copy, is_expn_of, multispan_sugg, snippet, span_lint,\n-    span_lint_and_then,\n+    ast_utils::is_useless_with_eq_exprs, eq_expr_value, higher, implements_trait, in_macro, is_copy, is_expn_of,\n+    multispan_sugg, snippet, span_lint, span_lint_and_then,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOp, BinOpKind, BorrowKind, Expr, ExprKind, StmtKind};\n+use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -102,7 +102,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n             if macro_with_not_op(&left.kind) || macro_with_not_op(&right.kind) {\n                 return;\n             }\n-            if is_valid_operator(op) && eq_expr_value(cx, left, right) {\n+            if is_useless_with_eq_exprs(higher::binop(op.node)) && eq_expr_value(cx, left, right) {\n                 span_lint(\n                     cx,\n                     EQ_OP,\n@@ -245,22 +245,3 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n         }\n     }\n }\n-\n-fn is_valid_operator(op: BinOp) -> bool {\n-    matches!(\n-        op.node,\n-        BinOpKind::Sub\n-            | BinOpKind::Div\n-            | BinOpKind::Eq\n-            | BinOpKind::Lt\n-            | BinOpKind::Le\n-            | BinOpKind::Gt\n-            | BinOpKind::Ge\n-            | BinOpKind::Ne\n-            | BinOpKind::And\n-            | BinOpKind::Or\n-            | BinOpKind::BitXor\n-            | BinOpKind::BitAnd\n-            | BinOpKind::BitOr\n-    )\n-}"}, {"sha": "40e93da8dffb4624e3c8457fae6e07fcacaf558f", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,15 +1,16 @@\n use rustc_hir::intravisit;\n-use rustc_hir::{self, Body, FnDecl, HirId, HirIdSet, ItemKind, Node};\n+use rustc_hir::{self, AssocItemKind, Body, FnDecl, HirId, HirIdSet, Impl, ItemKind, Node};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, TraitRef, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n+use rustc_span::symbol::kw;\n use rustc_target::abi::LayoutOf;\n use rustc_target::spec::abi::Abi;\n use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n \n-use crate::utils::span_lint;\n+use crate::utils::{contains_ty, span_lint};\n \n #[derive(Copy, Clone)]\n pub struct BoxedLocal {\n@@ -51,6 +52,7 @@ fn is_non_trait_box(ty: Ty<'_>) -> bool {\n struct EscapeDelegate<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     set: HirIdSet,\n+    trait_self_ty: Option<Ty<'a>>,\n     too_large_for_stack: u64,\n }\n \n@@ -72,19 +74,34 @@ impl<'tcx> LateLintPass<'tcx> for BoxedLocal {\n             }\n         }\n \n-        // If the method is an impl for a trait, don't warn.\n         let parent_id = cx.tcx.hir().get_parent_item(hir_id);\n         let parent_node = cx.tcx.hir().find(parent_id);\n \n+        let mut trait_self_ty = None;\n         if let Some(Node::Item(item)) = parent_node {\n-            if let ItemKind::Impl { of_trait: Some(_), .. } = item.kind {\n+            // If the method is an impl for a trait, don't warn.\n+            if let ItemKind::Impl(Impl { of_trait: Some(_), .. }) = item.kind {\n                 return;\n             }\n+\n+            // find `self` ty for this trait if relevant\n+            if let ItemKind::Trait(_, _, _, _, items) = item.kind {\n+                for trait_item in items {\n+                    if trait_item.id.hir_id == hir_id {\n+                        // be sure we have `self` parameter in this function\n+                        if let AssocItemKind::Fn { has_self: true } = trait_item.kind {\n+                            trait_self_ty =\n+                                Some(TraitRef::identity(cx.tcx, trait_item.id.hir_id.owner.to_def_id()).self_ty());\n+                        }\n+                    }\n+                }\n+            }\n         }\n \n         let mut v = EscapeDelegate {\n             cx,\n             set: HirIdSet::default(),\n+            trait_self_ty,\n             too_large_for_stack: self.too_large_for_stack,\n         };\n \n@@ -153,10 +170,17 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n                     return;\n                 }\n \n+                // skip if there is a `self` parameter binding to a type\n+                // that contains `Self` (i.e.: `self: Box<Self>`), see #4804\n+                if let Some(trait_self_ty) = self.trait_self_ty {\n+                    if map.name(cmt.hir_id) == kw::SelfLower && contains_ty(cmt.place.ty(), trait_self_ty) {\n+                        return;\n+                    }\n+                }\n+\n                 if is_non_trait_box(cmt.place.ty()) && !self.is_large_box(cmt.place.ty()) {\n                     self.set.insert(cmt.hir_id);\n                 }\n-                return;\n             }\n         }\n     }"}, {"sha": "1a722d39f730bb1cb293920cd610fbe9b8f329b7", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -22,7 +22,7 @@ declare_clippy_lint! {\n     /// **Known problems:** If creating the closure inside the closure has a side-\n     /// effect then moving the closure creation out will change when that side-\n     /// effect runs.\n-    /// See rust-lang/rust-clippy#1439 for more details.\n+    /// See [#1439](https://github.com/rust-lang/rust-clippy/issues/1439) for more details.\n     ///\n     /// **Example:**\n     /// ```rust,ignore\n@@ -45,8 +45,9 @@ declare_clippy_lint! {\n     ///\n     /// **Why is this bad?** It's unnecessary to create the closure.\n     ///\n-    /// **Known problems:** rust-lang/rust-clippy#3071, rust-lang/rust-clippy#4002,\n-    /// rust-lang/rust-clippy#3942\n+    /// **Known problems:** [#3071](https://github.com/rust-lang/rust-clippy/issues/3071),\n+    /// [#3942](https://github.com/rust-lang/rust-clippy/issues/3942),\n+    /// [#4002](https://github.com/rust-lang/rust-clippy/issues/4002)\n     ///\n     ///\n     /// **Example:**"}, {"sha": "9f389c8d2f9e71fc472c74258dd8f0351164a90f", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -57,11 +57,11 @@ impl<'tcx> LateLintPass<'tcx> for FallibleImplFrom {\n         // check for `impl From<???> for ..`\n         let impl_def_id = cx.tcx.hir().local_def_id(item.hir_id);\n         if_chain! {\n-            if let hir::ItemKind::Impl{ items: impl_items, .. } = item.kind;\n+            if let hir::ItemKind::Impl(impl_) = &item.kind;\n             if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_def_id);\n             if match_def_path(cx, impl_trait_ref.def_id, &FROM_TRAIT);\n             then {\n-                lint_impl_body(cx, item.span, impl_items);\n+                lint_impl_body(cx, item.span, impl_.items);\n             }\n         }\n     }"}, {"sha": "ffef78aac806770f6108d9f5c17c17359aab1855", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -2,7 +2,7 @@ use crate::consts::{\n     constant, constant_simple, Constant,\n     Constant::{Int, F32, F64},\n };\n-use crate::utils::{eq_expr_value, get_parent_expr, higher, numeric_literal, span_lint_and_sugg, sugg};\n+use crate::utils::{eq_expr_value, get_parent_expr, numeric_literal, span_lint_and_sugg, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, PathSegment, UnOp};\n@@ -556,11 +556,11 @@ fn are_negated<'a>(cx: &LateContext<'_>, expr1: &'a Expr<'a>, expr2: &'a Expr<'a\n \n fn check_custom_abs(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let Some((cond, body, Some(else_body))) = higher::if_block(&expr);\n+        if let ExprKind::If(cond, body, else_body) = expr.kind;\n         if let ExprKind::Block(block, _) = body.kind;\n         if block.stmts.is_empty();\n         if let Some(if_body_expr) = block.expr;\n-        if let ExprKind::Block(else_block, _) = else_body.kind;\n+        if let Some(ExprKind::Block(else_block, _)) = else_body.map(|el| &el.kind);\n         if else_block.stmts.is_empty();\n         if let Some(else_body_expr) = else_block.expr;\n         if let Some((if_expr_positive, body)) = are_negated(cx, if_body_expr, else_body_expr);"}, {"sha": "b010abda24d108f35752b6edc602e8a86c185654", "filename": "clippy_lints/src/from_over_into.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Ffrom_over_into.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Ffrom_over_into.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffrom_over_into.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,83 @@\n+use crate::utils::paths::INTO;\n+use crate::utils::{match_def_path, meets_msrv, span_lint_and_help};\n+use if_chain::if_chain;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+const FROM_OVER_INTO_MSRV: RustcVersion = RustcVersion::new(1, 41, 0);\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Searches for implementations of the `Into<..>` trait and suggests to implement `From<..>` instead.\n+    ///\n+    /// **Why is this bad?** According the std docs implementing `From<..>` is preferred since it gives you `Into<..>` for free where the reverse isn't true.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// struct StringWrapper(String);\n+    ///\n+    /// impl Into<StringWrapper> for String {\n+    ///     fn into(self) -> StringWrapper {\n+    ///         StringWrapper(self)\n+    ///     }\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// struct StringWrapper(String);\n+    ///\n+    /// impl From<String> for StringWrapper {\n+    ///     fn from(s: String) -> StringWrapper {\n+    ///         StringWrapper(s)\n+    ///     }\n+    /// }\n+    /// ```\n+    pub FROM_OVER_INTO,\n+    style,\n+    \"Warns on implementations of `Into<..>` to use `From<..>`\"\n+}\n+\n+pub struct FromOverInto {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl FromOverInto {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        FromOverInto { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(FromOverInto => [FROM_OVER_INTO]);\n+\n+impl LateLintPass<'_> for FromOverInto {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n+        if !meets_msrv(self.msrv.as_ref(), &FROM_OVER_INTO_MSRV) {\n+            return;\n+        }\n+\n+        let impl_def_id = cx.tcx.hir().local_def_id(item.hir_id);\n+        if_chain! {\n+            if let hir::ItemKind::Impl{ .. } = &item.kind;\n+            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_def_id);\n+            if match_def_path(cx, impl_trait_ref.def_id, &INTO);\n+\n+            then {\n+                span_lint_and_help(\n+                    cx,\n+                    FROM_OVER_INTO,\n+                    cx.tcx.sess.source_map().guess_head_span(item.span),\n+                    \"an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\",\n+                    None,\n+                    \"consider to implement `From` instead\",\n+                );\n+            }\n+        }\n+    }\n+\n+    extract_msrv_attr!(LateContext);\n+}"}, {"sha": "fd93548b55c6db3a327b2a9ac29fc7464476967b", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -405,13 +405,10 @@ impl<'tcx> Functions {\n                     break;\n                 }\n                 if in_comment {\n-                    match line.find(\"*/\") {\n-                        Some(i) => {\n-                            line = &line[i + 2..];\n-                            in_comment = false;\n-                            continue;\n-                        },\n-                        None => break,\n+                    if let Some(i) = line.find(\"*/\") {\n+                        line = &line[i + 2..];\n+                        in_comment = false;\n+                        continue;\n                     }\n                 } else {\n                     let multi_idx = line.find(\"/*\").unwrap_or_else(|| line.len());\n@@ -423,8 +420,8 @@ impl<'tcx> Functions {\n                         in_comment = true;\n                         continue;\n                     }\n-                    break;\n                 }\n+                break;\n             }\n             if code_in_line {\n                 line_count += 1;"}, {"sha": "58511c6d57c686dedd3c01f5f29a4a19d4fddec4", "filename": "clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -145,7 +145,7 @@ impl<'tcx, 'l> ArmVisitor<'tcx, 'l> {\n fn is_mutex_lock_call<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if_chain! {\n         if let ExprKind::MethodCall(path, _span, args, _) = &expr.kind;\n-        if path.ident.to_string() == \"lock\";\n+        if path.ident.as_str() == \"lock\";\n         let ty = cx.typeck_results().expr_ty(&args[0]);\n         if is_type_diagnostic_item(cx, ty, sym!(mutex_type));\n         then {"}, {"sha": "1194bd7e55e2566e5ad5c20f741d8888829e5e5f", "filename": "clippy_lints/src/if_let_some_result.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_some_result.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -41,8 +41,7 @@ declare_lint_pass!(OkIfLet => [IF_LET_SOME_RESULT]);\n impl<'tcx> LateLintPass<'tcx> for OkIfLet {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! { //begin checking variables\n-            if let ExprKind::Match(ref op, ref body, source) = expr.kind; //test if expr is a match\n-            if let MatchSource::IfLetDesugar { .. } = source; //test if it is an If Let\n+            if let ExprKind::Match(ref op, ref body, MatchSource::IfLetDesugar { .. }) = expr.kind; //test if expr is if let\n             if let ExprKind::MethodCall(_, ok_span, ref result_types, _) = op.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n             if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pat.kind; //get operation\n             if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;"}, {"sha": "109d90ff772b57b8172761cb06c353283304fdf0", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -68,8 +68,7 @@ fn expr_match(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                 if_chain! {\n                     if let StmtKind::Semi(expr, ..) = &stmt.kind;\n                     // make sure it's a break, otherwise we want to skip\n-                    if let ExprKind::Break(.., break_expr) = &expr.kind;\n-                    if let Some(break_expr) = break_expr;\n+                    if let ExprKind::Break(.., Some(break_expr)) = &expr.kind;\n                     then {\n                             lint(cx, expr.span, break_expr.span, LINT_BREAK);\n                     }\n@@ -82,6 +81,13 @@ fn expr_match(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                 lint(cx, expr.span, break_expr.span, LINT_BREAK);\n             }\n         },\n+        ExprKind::If(.., if_expr, else_expr) => {\n+            expr_match(cx, if_expr);\n+\n+            if let Some(else_expr) = else_expr {\n+                expr_match(cx, else_expr);\n+            }\n+        },\n         ExprKind::Match(.., arms, source) => {\n             let check_all_arms = match source {\n                 MatchSource::IfLetDesugar {"}, {"sha": "16e162badb5ee64a0172a3e23810490e13e2624b", "filename": "clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{higher, in_macro, match_qpath, span_lint_and_sugg, SpanlessEq};\n+use crate::utils::{in_macro, match_qpath, span_lint_and_sugg, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n@@ -42,7 +42,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n             return;\n         }\n         if_chain! {\n-            if let Some((ref cond, ref then, None)) = higher::if_block(&expr);\n+            if let ExprKind::If(cond, then, None) = &expr.kind;\n \n             // Check if the conditional expression is a binary operation\n             if let ExprKind::Binary(ref cond_op, ref cond_left, ref cond_right) = cond.kind;\n@@ -59,8 +59,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n             if let Some(target) = subtracts_one(cx, e);\n \n             // Extracting out the variable name\n-            if let ExprKind::Path(ref assign_path) = target.kind;\n-            if let QPath::Resolved(_, ref ares_path) = assign_path;\n+            if let ExprKind::Path(QPath::Resolved(_, ref ares_path)) = target.kind;\n \n             then {\n                 // Handle symmetric conditions in the if statement"}, {"sha": "ea26c84cde16a93260f18c9f73c90e0d29c81991", "filename": "clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_impl.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -2,7 +2,7 @@\n \n use crate::utils::{in_macro, span_lint_and_then};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::{def_id, Crate, Item, ItemKind};\n+use rustc_hir::{def_id, Crate, Impl, Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Span;\n@@ -49,11 +49,11 @@ impl_lint_pass!(MultipleInherentImpl => [MULTIPLE_INHERENT_IMPL]);\n \n impl<'tcx> LateLintPass<'tcx> for MultipleInherentImpl {\n     fn check_item(&mut self, _: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if let ItemKind::Impl {\n+        if let ItemKind::Impl(Impl {\n             ref generics,\n             of_trait: None,\n             ..\n-        } = item.kind\n+        }) = item.kind\n         {\n             // Remember for each inherent implementation encountered its span and generics\n             // but filter out implementations that have generic params (type or lifetime)"}, {"sha": "0927d218446ddb71c506d9cc19558c4fc265059e", "filename": "clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -58,12 +58,12 @@ impl EarlyLintPass for ItemsAfterStatements {\n             return;\n         }\n \n-        // skip initial items\n+        // skip initial items and trailing semicolons\n         let stmts = item\n             .stmts\n             .iter()\n             .map(|stmt| &stmt.kind)\n-            .skip_while(|s| matches!(**s, StmtKind::Item(..)));\n+            .skip_while(|s| matches!(**s, StmtKind::Item(..) | StmtKind::Empty));\n \n         // lint on all further items\n         for stmt in stmts {"}, {"sha": "a76595ed0897dd85ffa73afc66bfe79211d4392b", "filename": "clippy_lints/src/large_const_arrays.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Flarge_const_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Flarge_const_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_const_arrays.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -52,8 +52,7 @@ impl<'tcx> LateLintPass<'tcx> for LargeConstArrays {\n             if let ItemKind::Const(hir_ty, _) = &item.kind;\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             if let ty::Array(element_type, cst) = ty.kind();\n-            if let ConstKind::Value(val) = cst.val;\n-            if let ConstValue::Scalar(element_count) = val;\n+            if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.val;\n             if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);\n             if let Ok(element_size) = cx.layout_of(element_type).map(|l| l.size.bytes());\n             if self.maximum_allowed_size < element_count * element_size;"}, {"sha": "ad9b4f357a74dbbe8a489176075d158c0b45cb38", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -4,6 +4,7 @@ use crate::utils::{snippet_opt, span_lint_and_then};\n use rustc_errors::Applicability;\n use rustc_hir::{Item, ItemKind, VariantData};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_target::abi::LayoutOf;\n \n@@ -58,6 +59,9 @@ impl_lint_pass!(LargeEnumVariant => [LARGE_ENUM_VARIANT]);\n \n impl<'tcx> LateLintPass<'tcx> for LargeEnumVariant {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        if in_external_macro(cx.tcx.sess, item.span) {\n+            return;\n+        }\n         let did = cx.tcx.hir().local_def_id(item.hir_id);\n         if let ItemKind::Enum(ref def, _) = item.kind {\n             let ty = cx.tcx.type_of(did);"}, {"sha": "9a448ab125686cf2ce405a7ca9c1a84416b800c7", "filename": "clippy_lints/src/large_stack_arrays.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -43,8 +43,7 @@ impl<'tcx> LateLintPass<'tcx> for LargeStackArrays {\n         if_chain! {\n             if let ExprKind::Repeat(_, _) = expr.kind;\n             if let ty::Array(element_type, cst) = cx.typeck_results().expr_ty(expr).kind();\n-            if let ConstKind::Value(val) = cst.val;\n-            if let ConstValue::Scalar(element_count) = val;\n+            if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.val;\n             if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);\n             if let Ok(element_size) = cx.layout_of(element_type).map(|l| l.size.bytes());\n             if self.maximum_allowed_size < element_count * element_size;"}, {"sha": "e95caf6a35f900915920278e03abc2489bd4750d", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -3,7 +3,7 @@ use rustc_ast::ast::LitKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{AssocItemKind, BinOpKind, Expr, ExprKind, ImplItemRef, Item, ItemKind, TraitItemRef};\n+use rustc_hir::{AssocItemKind, BinOpKind, Expr, ExprKind, Impl, ImplItemRef, Item, ItemKind, TraitItemRef};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -115,11 +115,11 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n \n         match item.kind {\n             ItemKind::Trait(_, _, _, _, ref trait_items) => check_trait_items(cx, item, trait_items),\n-            ItemKind::Impl {\n+            ItemKind::Impl(Impl {\n                 of_trait: None,\n                 items: ref impl_items,\n                 ..\n-            } => check_impl_items(cx, item, impl_items),\n+            }) => check_impl_items(cx, item, impl_items),\n             _ => (),\n         }\n     }\n@@ -222,9 +222,8 @@ fn check_impl_items(cx: &LateContext<'_>, item: &Item<'_>, impl_items: &[ImplIte\n     let is_empty = if let Some(is_empty) = impl_items.iter().find(|i| is_named_self(cx, i, \"is_empty\")) {\n         if cx.access_levels.is_exported(is_empty.id.hir_id) {\n             return;\n-        } else {\n-            \"a private\"\n         }\n+        \"a private\"\n     } else {\n         \"no corresponding\"\n     };"}, {"sha": "db717cd1240a41b38a9f1d871595f3561b02c2b0", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 7, "deletions": 49, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,12 +1,10 @@\n-use crate::utils::{higher, qpath_res, snippet, span_lint_and_then};\n+use crate::utils::{qpath_res, snippet, span_lint_and_then, visitors::LocalUsedVisitor};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n-use rustc_hir::intravisit;\n use rustc_hir::BindingAnnotation;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -65,11 +63,11 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                 if let hir::StmtKind::Local(ref local) = stmt.kind;\n                 if let hir::PatKind::Binding(mode, canonical_id, ident, None) = local.pat.kind;\n                 if let hir::StmtKind::Expr(ref if_) = expr.kind;\n-                if let Some((ref cond, ref then, ref else_)) = higher::if_block(&if_);\n-                if !used_in_expr(cx, canonical_id, cond);\n+                if let hir::ExprKind::If(ref cond, ref then, ref else_) = if_.kind;\n+                if !LocalUsedVisitor::new(canonical_id).check_expr(cond);\n                 if let hir::ExprKind::Block(ref then, _) = then.kind;\n                 if let Some(value) = check_assign(cx, canonical_id, &*then);\n-                if !used_in_expr(cx, canonical_id, value);\n+                if !LocalUsedVisitor::new(canonical_id).check_expr(value);\n                 then {\n                     let span = stmt.span.to(if_.span);\n \n@@ -136,32 +134,6 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n     }\n }\n \n-struct UsedVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    id: hir::HirId,\n-    used: bool,\n-}\n-\n-impl<'a, 'tcx> intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        if_chain! {\n-            if let hir::ExprKind::Path(ref qpath) = expr.kind;\n-            if let Res::Local(local_id) = qpath_res(self.cx, qpath, expr.hir_id);\n-            if self.id == local_id;\n-            then {\n-                self.used = true;\n-                return;\n-            }\n-        }\n-        intravisit::walk_expr(self, expr);\n-    }\n-    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n-        intravisit::NestedVisitorMap::None\n-    }\n-}\n-\n fn check_assign<'tcx>(\n     cx: &LateContext<'tcx>,\n     decl: hir::HirId,\n@@ -176,18 +148,10 @@ fn check_assign<'tcx>(\n         if let Res::Local(local_id) = qpath_res(cx, qpath, var.hir_id);\n         if decl == local_id;\n         then {\n-            let mut v = UsedVisitor {\n-                cx,\n-                id: decl,\n-                used: false,\n-            };\n-\n-            for s in block.stmts.iter().take(block.stmts.len()-1) {\n-                intravisit::walk_stmt(&mut v, s);\n+            let mut v = LocalUsedVisitor::new(decl);\n \n-                if v.used {\n-                    return None;\n-                }\n+            if block.stmts.iter().take(block.stmts.len()-1).any(|stmt| v.check_stmt(stmt)) {\n+                return None;\n             }\n \n             return Some(value);\n@@ -196,9 +160,3 @@ fn check_assign<'tcx>(\n \n     None\n }\n-\n-fn used_in_expr<'tcx>(cx: &LateContext<'tcx>, id: hir::HirId, expr: &'tcx hir::Expr<'_>) -> bool {\n-    let mut v = UsedVisitor { cx, id, used: false };\n-    intravisit::walk_expr(&mut v, expr);\n-    v.used\n-}"}, {"sha": "70fdfd22caa068542ad463fd9f7754922bf1a095", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 112, "deletions": 39, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -27,6 +27,7 @@ extern crate rustc_ast;\n extern crate rustc_ast_pretty;\n extern crate rustc_attr;\n extern crate rustc_data_structures;\n+extern crate rustc_driver;\n extern crate rustc_errors;\n extern crate rustc_hir;\n extern crate rustc_hir_pretty;\n@@ -169,9 +170,11 @@ mod blocks_in_if_conditions;\n mod booleans;\n mod bytecount;\n mod cargo_common_metadata;\n+mod case_sensitive_file_extension_comparisons;\n mod checked_conversions;\n mod cognitive_complexity;\n mod collapsible_if;\n+mod collapsible_match;\n mod comparison_chain;\n mod copies;\n mod copy_iterator;\n@@ -205,6 +208,7 @@ mod float_literal;\n mod floating_point_arithmetic;\n mod format;\n mod formatting;\n+mod from_over_into;\n mod functions;\n mod future_not_send;\n mod get_last_with_len;\n@@ -268,6 +272,7 @@ mod needless_borrow;\n mod needless_borrowed_ref;\n mod needless_continue;\n mod needless_pass_by_value;\n+mod needless_question_mark;\n mod needless_update;\n mod neg_cmp_op_on_partial_ord;\n mod neg_multiply;\n@@ -293,8 +298,10 @@ mod question_mark;\n mod ranges;\n mod redundant_clone;\n mod redundant_closure_call;\n+mod redundant_else;\n mod redundant_field_names;\n mod redundant_pub_crate;\n+mod redundant_slicing;\n mod redundant_static_lifetimes;\n mod ref_option_ref;\n mod reference;\n@@ -305,9 +312,11 @@ mod self_assignment;\n mod serde_api;\n mod shadow;\n mod single_component_path_imports;\n+mod size_of_in_element_count;\n mod slow_vector_initialization;\n mod stable_sort_primitive;\n mod strings;\n+mod suspicious_operation_groupings;\n mod suspicious_trait_impl;\n mod swap;\n mod tabs_in_doc_comments;\n@@ -335,12 +344,14 @@ mod unwrap_in_result;\n mod use_self;\n mod useless_conversion;\n mod vec;\n+mod vec_init_then_push;\n mod vec_resize_to_zero;\n mod verbose_file_reads;\n mod wildcard_dependencies;\n mod wildcard_imports;\n mod write;\n mod zero_div_zero;\n+mod zero_sized_map_values;\n // end lints modules, do not remove this comment, it\u2019s used in `update_lints`\n \n pub use crate::utils::conf::Conf;\n@@ -497,6 +508,28 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n \n     // begin register lints, do not remove this comment, it\u2019s used in `update_lints`\n     store.register_lints(&[\n+        #[cfg(feature = \"internal-lints\")]\n+        &utils::internal_lints::CLIPPY_LINTS_INTERNAL,\n+        #[cfg(feature = \"internal-lints\")]\n+        &utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS,\n+        #[cfg(feature = \"internal-lints\")]\n+        &utils::internal_lints::COMPILER_LINT_FUNCTIONS,\n+        #[cfg(feature = \"internal-lints\")]\n+        &utils::internal_lints::DEFAULT_LINT,\n+        #[cfg(feature = \"internal-lints\")]\n+        &utils::internal_lints::INTERNING_DEFINED_SYMBOL,\n+        #[cfg(feature = \"internal-lints\")]\n+        &utils::internal_lints::INVALID_PATHS,\n+        #[cfg(feature = \"internal-lints\")]\n+        &utils::internal_lints::LINT_WITHOUT_LINT_PASS,\n+        #[cfg(feature = \"internal-lints\")]\n+        &utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n+        #[cfg(feature = \"internal-lints\")]\n+        &utils::internal_lints::OUTER_EXPN_EXPN_DATA,\n+        #[cfg(feature = \"internal-lints\")]\n+        &utils::internal_lints::PRODUCE_ICE,\n+        #[cfg(feature = \"internal-lints\")]\n+        &utils::internal_lints::UNNECESSARY_SYMBOL_STR,\n         &approx_const::APPROX_CONSTANT,\n         &arithmetic::FLOAT_ARITHMETIC,\n         &arithmetic::INTEGER_ARITHMETIC,\n@@ -527,9 +560,12 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &booleans::NONMINIMAL_BOOL,\n         &bytecount::NAIVE_BYTECOUNT,\n         &cargo_common_metadata::CARGO_COMMON_METADATA,\n+        &case_sensitive_file_extension_comparisons::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n         &checked_conversions::CHECKED_CONVERSIONS,\n         &cognitive_complexity::COGNITIVE_COMPLEXITY,\n+        &collapsible_if::COLLAPSIBLE_ELSE_IF,\n         &collapsible_if::COLLAPSIBLE_IF,\n+        &collapsible_match::COLLAPSIBLE_MATCH,\n         &comparison_chain::COMPARISON_CHAIN,\n         &copies::IFS_SAME_COND,\n         &copies::IF_SAME_THEN_ELSE,\n@@ -587,6 +623,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING,\n         &formatting::SUSPICIOUS_ELSE_FORMATTING,\n         &formatting::SUSPICIOUS_UNARY_OP_FORMATTING,\n+        &from_over_into::FROM_OVER_INTO,\n         &functions::DOUBLE_MUST_USE,\n         &functions::MUST_USE_CANDIDATE,\n         &functions::MUST_USE_UNIT,\n@@ -770,6 +807,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE,\n         &needless_continue::NEEDLESS_CONTINUE,\n         &needless_pass_by_value::NEEDLESS_PASS_BY_VALUE,\n+        &needless_question_mark::NEEDLESS_QUESTION_MARK,\n         &needless_update::NEEDLESS_UPDATE,\n         &neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD,\n         &neg_multiply::NEG_MULTIPLY,\n@@ -809,8 +847,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &ranges::REVERSED_EMPTY_RANGES,\n         &redundant_clone::REDUNDANT_CLONE,\n         &redundant_closure_call::REDUNDANT_CLOSURE_CALL,\n+        &redundant_else::REDUNDANT_ELSE,\n         &redundant_field_names::REDUNDANT_FIELD_NAMES,\n         &redundant_pub_crate::REDUNDANT_PUB_CRATE,\n+        &redundant_slicing::REDUNDANT_SLICING,\n         &redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES,\n         &ref_option_ref::REF_OPTION_REF,\n         &reference::DEREF_ADDROF,\n@@ -826,6 +866,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &shadow::SHADOW_SAME,\n         &shadow::SHADOW_UNRELATED,\n         &single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS,\n+        &size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT,\n         &slow_vector_initialization::SLOW_VECTOR_INITIALIZATION,\n         &stable_sort_primitive::STABLE_SORT_PRIMITIVE,\n         &strings::STRING_ADD,\n@@ -834,6 +875,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &strings::STRING_LIT_AS_BYTES,\n         &strings::STRING_TO_STRING,\n         &strings::STR_TO_STRING,\n+        &suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS,\n         &suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL,\n         &suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL,\n         &swap::ALMOST_SWAPPED,\n@@ -876,6 +918,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &types::LET_UNIT_VALUE,\n         &types::LINKEDLIST,\n         &types::OPTION_OPTION,\n+        &types::PTR_AS_PTR,\n         &types::RC_BUFFER,\n         &types::REDUNDANT_ALLOCATION,\n         &types::TYPE_COMPLEXITY,\n@@ -902,40 +945,44 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &unwrap_in_result::UNWRAP_IN_RESULT,\n         &use_self::USE_SELF,\n         &useless_conversion::USELESS_CONVERSION,\n-        &utils::internal_lints::CLIPPY_LINTS_INTERNAL,\n-        &utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS,\n-        &utils::internal_lints::COMPILER_LINT_FUNCTIONS,\n-        &utils::internal_lints::DEFAULT_LINT,\n-        &utils::internal_lints::INVALID_PATHS,\n-        &utils::internal_lints::LINT_WITHOUT_LINT_PASS,\n-        &utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n-        &utils::internal_lints::OUTER_EXPN_EXPN_DATA,\n-        &utils::internal_lints::PRODUCE_ICE,\n         &vec::USELESS_VEC,\n+        &vec_init_then_push::VEC_INIT_THEN_PUSH,\n         &vec_resize_to_zero::VEC_RESIZE_TO_ZERO,\n         &verbose_file_reads::VERBOSE_FILE_READS,\n         &wildcard_dependencies::WILDCARD_DEPENDENCIES,\n         &wildcard_imports::ENUM_GLOB_USE,\n         &wildcard_imports::WILDCARD_IMPORTS,\n         &write::PRINTLN_EMPTY_STRING,\n         &write::PRINT_LITERAL,\n+        &write::PRINT_STDERR,\n         &write::PRINT_STDOUT,\n         &write::PRINT_WITH_NEWLINE,\n         &write::USE_DEBUG,\n         &write::WRITELN_EMPTY_STRING,\n         &write::WRITE_LITERAL,\n         &write::WRITE_WITH_NEWLINE,\n         &zero_div_zero::ZERO_DIVIDED_BY_ZERO,\n+        &zero_sized_map_values::ZERO_SIZED_MAP_VALUES,\n     ]);\n     // end register lints, do not remove this comment, it\u2019s used in `update_lints`\n+\n+    // all the internal lints\n+    #[cfg(feature = \"internal-lints\")]\n+    {\n+        store.register_early_pass(|| box utils::internal_lints::ClippyLintsInternal);\n+        store.register_early_pass(|| box utils::internal_lints::ProduceIce);\n+        store.register_late_pass(|| box utils::inspector::DeepCodeInspector);\n+        store.register_late_pass(|| box utils::internal_lints::CollapsibleCalls);\n+        store.register_late_pass(|| box utils::internal_lints::CompilerLintFunctions::new());\n+        store.register_late_pass(|| box utils::internal_lints::InvalidPaths);\n+        store.register_late_pass(|| box utils::internal_lints::InterningDefinedSymbol::default());\n+        store.register_late_pass(|| box utils::internal_lints::LintWithoutLintPass::default());\n+        store.register_late_pass(|| box utils::internal_lints::MatchTypeOnDiagItem);\n+        store.register_late_pass(|| box utils::internal_lints::OuterExpnDataPass);\n+    }\n+    store.register_late_pass(|| box utils::author::Author);\n     store.register_late_pass(|| box await_holding_invalid::AwaitHolding);\n     store.register_late_pass(|| box serde_api::SerdeAPI);\n-    store.register_late_pass(|| box utils::internal_lints::CompilerLintFunctions::new());\n-    store.register_late_pass(|| box utils::internal_lints::LintWithoutLintPass::default());\n-    store.register_late_pass(|| box utils::internal_lints::OuterExpnDataPass);\n-    store.register_late_pass(|| box utils::internal_lints::InvalidPaths);\n-    store.register_late_pass(|| box utils::inspector::DeepCodeInspector);\n-    store.register_late_pass(|| box utils::author::Author);\n     let vec_box_size_threshold = conf.vec_box_size_threshold;\n     store.register_late_pass(move || box types::Types::new(vec_box_size_threshold));\n     store.register_late_pass(|| box booleans::NonminimalBool);\n@@ -958,28 +1005,35 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box len_zero::LenZero);\n     store.register_late_pass(|| box attrs::Attributes);\n     store.register_late_pass(|| box blocks_in_if_conditions::BlocksInIfConditions);\n+    store.register_late_pass(|| box collapsible_match::CollapsibleMatch);\n     store.register_late_pass(|| box unicode::Unicode);\n     store.register_late_pass(|| box unit_return_expecting_ord::UnitReturnExpectingOrd);\n     store.register_late_pass(|| box strings::StringAdd);\n     store.register_late_pass(|| box implicit_return::ImplicitReturn);\n     store.register_late_pass(|| box implicit_saturating_sub::ImplicitSaturatingSub);\n \n-    let parsed_msrv = conf.msrv.as_ref().and_then(|s| {\n+    let msrv = conf.msrv.as_ref().and_then(|s| {\n         parse_msrv(s, None, None).or_else(|| {\n             sess.err(&format!(\"error reading Clippy's configuration file. `{}` is not a valid Rust version\", s));\n             None\n         })\n     });\n \n-    let msrv = parsed_msrv.clone();\n-    store.register_late_pass(move || box methods::Methods::new(msrv.clone()));\n-    let msrv = parsed_msrv.clone();\n-    store.register_late_pass(move || box matches::Matches::new(msrv.clone()));\n-    let msrv = parsed_msrv.clone();\n-    store.register_early_pass(move || box manual_non_exhaustive::ManualNonExhaustive::new(msrv.clone()));\n-    let msrv = parsed_msrv;\n-    store.register_late_pass(move || box manual_strip::ManualStrip::new(msrv.clone()));\n+    store.register_late_pass(move || box methods::Methods::new(msrv));\n+    store.register_late_pass(move || box matches::Matches::new(msrv));\n+    store.register_early_pass(move || box manual_non_exhaustive::ManualNonExhaustive::new(msrv));\n+    store.register_late_pass(move || box manual_strip::ManualStrip::new(msrv));\n+    store.register_early_pass(move || box redundant_static_lifetimes::RedundantStaticLifetimes::new(msrv));\n+    store.register_early_pass(move || box redundant_field_names::RedundantFieldNames::new(msrv));\n+    store.register_late_pass(move || box checked_conversions::CheckedConversions::new(msrv));\n+    store.register_late_pass(move || box mem_replace::MemReplace::new(msrv));\n+    store.register_late_pass(move || box ranges::Ranges::new(msrv));\n+    store.register_late_pass(move || box from_over_into::FromOverInto::new(msrv));\n+    store.register_late_pass(move || box use_self::UseSelf::new(msrv));\n+    store.register_late_pass(move || box missing_const_for_fn::MissingConstForFn::new(msrv));\n+    store.register_late_pass(move || box needless_question_mark::NeedlessQuestionMark::new(msrv));\n \n+    store.register_late_pass(|| box size_of_in_element_count::SizeOfInElementCount);\n     store.register_late_pass(|| box map_clone::MapClone);\n     store.register_late_pass(|| box map_err_ignore::MapErrIgnore);\n     store.register_late_pass(|| box shadow::Shadow);\n@@ -989,7 +1043,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box main_recursion::MainRecursion::default());\n     store.register_late_pass(|| box lifetimes::Lifetimes);\n     store.register_late_pass(|| box entry::HashMapPass);\n-    store.register_late_pass(|| box ranges::Ranges);\n     store.register_late_pass(|| box types::Casts);\n     let type_complexity_threshold = conf.type_complexity_threshold;\n     store.register_late_pass(move || box types::TypeComplexity::new(type_complexity_threshold));\n@@ -1034,7 +1087,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box neg_multiply::NegMultiply);\n     store.register_late_pass(|| box mem_discriminant::MemDiscriminant);\n     store.register_late_pass(|| box mem_forget::MemForget);\n-    store.register_late_pass(|| box mem_replace::MemReplace);\n     store.register_late_pass(|| box arithmetic::Arithmetic::default());\n     store.register_late_pass(|| box assign_ops::AssignOps);\n     store.register_late_pass(|| box let_if_seq::LetIfSeq);\n@@ -1056,7 +1108,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box pass_by_ref_or_value);\n     store.register_late_pass(|| box ref_option_ref::RefOptionRef);\n     store.register_late_pass(|| box try_err::TryErr);\n-    store.register_late_pass(|| box use_self::UseSelf);\n     store.register_late_pass(|| box bytecount::ByteCount);\n     store.register_late_pass(|| box infinite_iter::InfiniteIter);\n     store.register_late_pass(|| box inline_fn_without_body::InlineFnWithoutBody);\n@@ -1066,6 +1117,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box types::UnitArg);\n     store.register_late_pass(|| box double_comparison::DoubleComparisons);\n     store.register_late_pass(|| box question_mark::QuestionMark);\n+    store.register_early_pass(|| box suspicious_operation_groupings::SuspiciousOperationGroupings);\n     store.register_late_pass(|| box suspicious_trait_impl::SuspiciousImpl);\n     store.register_late_pass(|| box map_unit_fn::MapUnit);\n     store.register_late_pass(|| box inherent_impl::MultipleInherentImpl::default());\n@@ -1081,10 +1133,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box unnecessary_wraps::UnnecessaryWraps);\n     store.register_late_pass(|| box types::RefToMut);\n     store.register_late_pass(|| box assertions_on_constants::AssertionsOnConstants);\n-    store.register_late_pass(|| box missing_const_for_fn::MissingConstForFn);\n     store.register_late_pass(|| box transmuting_null::TransmutingNull);\n     store.register_late_pass(|| box path_buf_push_overwrite::PathBufPushOverwrite);\n-    store.register_late_pass(|| box checked_conversions::CheckedConversions);\n     store.register_late_pass(|| box integer_division::IntegerDivision);\n     store.register_late_pass(|| box inherent_to_string::InherentToString);\n     let max_trait_bounds = conf.max_trait_bounds;\n@@ -1110,16 +1160,16 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| box items_after_statements::ItemsAfterStatements);\n     store.register_early_pass(|| box precedence::Precedence);\n     store.register_early_pass(|| box needless_continue::NeedlessContinue);\n+    store.register_early_pass(|| box redundant_else::RedundantElse);\n     store.register_late_pass(|| box create_dir::CreateDir);\n     store.register_early_pass(|| box needless_arbitrary_self_type::NeedlessArbitrarySelfType);\n-    store.register_early_pass(|| box redundant_static_lifetimes::RedundantStaticLifetimes);\n     store.register_late_pass(|| box cargo_common_metadata::CargoCommonMetadata);\n     store.register_late_pass(|| box multiple_crate_versions::MultipleCrateVersions);\n     store.register_late_pass(|| box wildcard_dependencies::WildcardDependencies);\n-    store.register_early_pass(|| box literal_representation::LiteralDigitGrouping);\n+    let literal_representation_lint_fraction_readability = conf.unreadable_literal_lint_fractions;\n+    store.register_early_pass(move || box literal_representation::LiteralDigitGrouping::new(literal_representation_lint_fraction_readability));\n     let literal_representation_threshold = conf.literal_representation_threshold;\n     store.register_early_pass(move || box literal_representation::DecimalLiteralRepresentation::new(literal_representation_threshold));\n-    store.register_early_pass(|| box utils::internal_lints::ClippyLintsInternal);\n     let enum_variant_name_threshold = conf.enum_variant_name_threshold;\n     store.register_early_pass(move || box enum_variants::EnumVariantNames::new(enum_variant_name_threshold));\n     store.register_early_pass(|| box tabs_in_doc_comments::TabsInDocComments);\n@@ -1133,7 +1183,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box large_const_arrays::LargeConstArrays::new(array_size_threshold));\n     store.register_late_pass(|| box floating_point_arithmetic::FloatingPointArithmetic);\n     store.register_early_pass(|| box as_conversions::AsConversions);\n-    store.register_early_pass(|| box utils::internal_lints::ProduceIce);\n     store.register_late_pass(|| box let_underscore::LetUnderscore);\n     store.register_late_pass(|| box atomic_ordering::AtomicOrdering);\n     store.register_early_pass(|| box single_component_path_imports::SingleComponentPathImports);\n@@ -1149,15 +1198,12 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box dereference::Dereferencing);\n     store.register_late_pass(|| box option_if_let_else::OptionIfLetElse);\n     store.register_late_pass(|| box future_not_send::FutureNotSend);\n-    store.register_late_pass(|| box utils::internal_lints::CollapsibleCalls);\n     store.register_late_pass(|| box if_let_mutex::IfLetMutex);\n     store.register_late_pass(|| box mut_mutex_lock::MutMutexLock);\n     store.register_late_pass(|| box match_on_vec_items::MatchOnVecItems);\n     store.register_late_pass(|| box manual_async_fn::ManualAsyncFn);\n-    store.register_early_pass(|| box redundant_field_names::RedundantFieldNames);\n     store.register_late_pass(|| box vec_resize_to_zero::VecResizeToZero);\n     store.register_late_pass(|| box panic_in_result_fn::PanicInResultFn);\n-\n     let single_char_binding_names_threshold = conf.single_char_binding_names_threshold;\n     store.register_early_pass(move || box non_expressive_names::NonExpressiveNames {\n         single_char_binding_names_threshold,\n@@ -1174,15 +1220,18 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box manual_ok_or::ManualOkOr);\n     store.register_late_pass(|| box float_equality_without_abs::FloatEqualityWithoutAbs);\n     store.register_late_pass(|| box async_yields_async::AsyncYieldsAsync);\n-    store.register_late_pass(|| box utils::internal_lints::MatchTypeOnDiagItem);\n     let disallowed_methods = conf.disallowed_methods.iter().cloned().collect::<FxHashSet<_>>();\n     store.register_late_pass(move || box disallowed_method::DisallowedMethod::new(&disallowed_methods));\n     store.register_early_pass(|| box asm_syntax::InlineAsmX86AttSyntax);\n     store.register_early_pass(|| box asm_syntax::InlineAsmX86IntelSyntax);\n     store.register_late_pass(|| box undropped_manually_drops::UndroppedManuallyDrops);\n     store.register_late_pass(|| box strings::StrToString);\n     store.register_late_pass(|| box strings::StringToString);\n-\n+    store.register_late_pass(|| box zero_sized_map_values::ZeroSizedMapValues);\n+    store.register_late_pass(|| box vec_init_then_push::VecInitThenPush::default());\n+    store.register_late_pass(move || box types::PtrAsPtr::new(msrv));\n+    store.register_late_pass(|| box case_sensitive_file_extension_comparisons::CaseSensitiveFileExtensionComparisons);\n+    store.register_late_pass(|| box redundant_slicing::RedundantSlicing);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1201,6 +1250,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&integer_division::INTEGER_DIVISION),\n         LintId::of(&let_underscore::LET_UNDERSCORE_MUST_USE),\n         LintId::of(&literal_representation::DECIMAL_LITERAL_REPRESENTATION),\n+        LintId::of(&map_err_ignore::MAP_ERR_IGNORE),\n         LintId::of(&matches::REST_PAT_IN_FULLY_BOUND_STRUCTS),\n         LintId::of(&matches::WILDCARD_ENUM_MATCH_ARM),\n         LintId::of(&mem_forget::MEM_FORGET),\n@@ -1229,6 +1279,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::RC_BUFFER),\n         LintId::of(&unwrap_in_result::UNWRAP_IN_RESULT),\n         LintId::of(&verbose_file_reads::VERBOSE_FILE_READS),\n+        LintId::of(&write::PRINT_STDERR),\n         LintId::of(&write::PRINT_STDOUT),\n         LintId::of(&write::USE_DEBUG),\n     ]);\n@@ -1238,6 +1289,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&await_holding_invalid::AWAIT_HOLDING_LOCK),\n         LintId::of(&await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n         LintId::of(&bit_mask::VERBOSE_BIT_MASK),\n+        LintId::of(&case_sensitive_file_extension_comparisons::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS),\n         LintId::of(&checked_conversions::CHECKED_CONVERSIONS),\n         LintId::of(&copies::SAME_FUNCTIONS_IN_IF_CONDITION),\n         LintId::of(&copy_iterator::COPY_ITERATOR),\n@@ -1267,7 +1319,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::EXPLICIT_ITER_LOOP),\n         LintId::of(&macro_use::MACRO_USE_IMPORTS),\n         LintId::of(&manual_ok_or::MANUAL_OK_OR),\n-        LintId::of(&map_err_ignore::MAP_ERR_IGNORE),\n         LintId::of(&match_on_vec_items::MATCH_ON_VEC_ITEMS),\n         LintId::of(&matches::MATCH_BOOL),\n         LintId::of(&matches::MATCH_SAME_ARMS),\n@@ -1291,6 +1342,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF),\n         LintId::of(&ranges::RANGE_MINUS_ONE),\n         LintId::of(&ranges::RANGE_PLUS_ONE),\n+        LintId::of(&redundant_else::REDUNDANT_ELSE),\n         LintId::of(&ref_option_ref::REF_OPTION_REF),\n         LintId::of(&shadow::SHADOW_UNRELATED),\n         LintId::of(&strings::STRING_ADD_ASSIGN),\n@@ -1307,24 +1359,29 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::LET_UNIT_VALUE),\n         LintId::of(&types::LINKEDLIST),\n         LintId::of(&types::OPTION_OPTION),\n+        LintId::of(&types::PTR_AS_PTR),\n         LintId::of(&unicode::NON_ASCII_LITERAL),\n         LintId::of(&unicode::UNICODE_NOT_NFC),\n         LintId::of(&unnested_or_patterns::UNNESTED_OR_PATTERNS),\n         LintId::of(&unused_self::UNUSED_SELF),\n         LintId::of(&wildcard_imports::ENUM_GLOB_USE),\n         LintId::of(&wildcard_imports::WILDCARD_IMPORTS),\n+        LintId::of(&zero_sized_map_values::ZERO_SIZED_MAP_VALUES),\n     ]);\n \n+    #[cfg(feature = \"internal-lints\")]\n     store.register_group(true, \"clippy::internal\", Some(\"clippy_internal\"), vec![\n         LintId::of(&utils::internal_lints::CLIPPY_LINTS_INTERNAL),\n         LintId::of(&utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS),\n         LintId::of(&utils::internal_lints::COMPILER_LINT_FUNCTIONS),\n         LintId::of(&utils::internal_lints::DEFAULT_LINT),\n+        LintId::of(&utils::internal_lints::INTERNING_DEFINED_SYMBOL),\n         LintId::of(&utils::internal_lints::INVALID_PATHS),\n         LintId::of(&utils::internal_lints::LINT_WITHOUT_LINT_PASS),\n         LintId::of(&utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM),\n         LintId::of(&utils::internal_lints::OUTER_EXPN_EXPN_DATA),\n         LintId::of(&utils::internal_lints::PRODUCE_ICE),\n+        LintId::of(&utils::internal_lints::UNNECESSARY_SYMBOL_STR),\n     ]);\n \n     store.register_group(true, \"clippy::all\", Some(\"clippy\"), vec![\n@@ -1347,7 +1404,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&booleans::LOGIC_BUG),\n         LintId::of(&booleans::NONMINIMAL_BOOL),\n         LintId::of(&bytecount::NAIVE_BYTECOUNT),\n+        LintId::of(&collapsible_if::COLLAPSIBLE_ELSE_IF),\n         LintId::of(&collapsible_if::COLLAPSIBLE_IF),\n+        LintId::of(&collapsible_match::COLLAPSIBLE_MATCH),\n         LintId::of(&comparison_chain::COMPARISON_CHAIN),\n         LintId::of(&copies::IFS_SAME_COND),\n         LintId::of(&copies::IF_SAME_THEN_ELSE),\n@@ -1382,6 +1441,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING),\n         LintId::of(&formatting::SUSPICIOUS_ELSE_FORMATTING),\n         LintId::of(&formatting::SUSPICIOUS_UNARY_OP_FORMATTING),\n+        LintId::of(&from_over_into::FROM_OVER_INTO),\n         LintId::of(&functions::DOUBLE_MUST_USE),\n         LintId::of(&functions::MUST_USE_UNIT),\n         LintId::of(&functions::NOT_UNSAFE_PTR_ARG_DEREF),\n@@ -1506,6 +1566,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&needless_bool::BOOL_COMPARISON),\n         LintId::of(&needless_bool::NEEDLESS_BOOL),\n         LintId::of(&needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE),\n+        LintId::of(&needless_question_mark::NEEDLESS_QUESTION_MARK),\n         LintId::of(&needless_update::NEEDLESS_UPDATE),\n         LintId::of(&neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),\n         LintId::of(&neg_multiply::NEG_MULTIPLY),\n@@ -1533,6 +1594,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&redundant_clone::REDUNDANT_CLONE),\n         LintId::of(&redundant_closure_call::REDUNDANT_CLOSURE_CALL),\n         LintId::of(&redundant_field_names::REDUNDANT_FIELD_NAMES),\n+        LintId::of(&redundant_slicing::REDUNDANT_SLICING),\n         LintId::of(&redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n         LintId::of(&reference::DEREF_ADDROF),\n         LintId::of(&reference::REF_IN_DEREF),\n@@ -1544,9 +1606,11 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&self_assignment::SELF_ASSIGNMENT),\n         LintId::of(&serde_api::SERDE_API_MISUSE),\n         LintId::of(&single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n+        LintId::of(&size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n         LintId::of(&slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n         LintId::of(&stable_sort_primitive::STABLE_SORT_PRIMITIVE),\n         LintId::of(&strings::STRING_FROM_UTF8_AS_BYTES),\n+        LintId::of(&suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS),\n         LintId::of(&suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n         LintId::of(&suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n         LintId::of(&swap::ALMOST_SWAPPED),\n@@ -1595,6 +1659,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&unwrap::UNNECESSARY_UNWRAP),\n         LintId::of(&useless_conversion::USELESS_CONVERSION),\n         LintId::of(&vec::USELESS_VEC),\n+        LintId::of(&vec_init_then_push::VEC_INIT_THEN_PUSH),\n         LintId::of(&vec_resize_to_zero::VEC_RESIZE_TO_ZERO),\n         LintId::of(&write::PRINTLN_EMPTY_STRING),\n         LintId::of(&write::PRINT_LITERAL),\n@@ -1612,7 +1677,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&attrs::UNKNOWN_CLIPPY_LINTS),\n         LintId::of(&blacklisted_name::BLACKLISTED_NAME),\n         LintId::of(&blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n+        LintId::of(&collapsible_if::COLLAPSIBLE_ELSE_IF),\n         LintId::of(&collapsible_if::COLLAPSIBLE_IF),\n+        LintId::of(&collapsible_match::COLLAPSIBLE_MATCH),\n         LintId::of(&comparison_chain::COMPARISON_CHAIN),\n         LintId::of(&default::FIELD_REASSIGN_WITH_DEFAULT),\n         LintId::of(&doc::MISSING_SAFETY_DOC),\n@@ -1625,6 +1692,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING),\n         LintId::of(&formatting::SUSPICIOUS_ELSE_FORMATTING),\n         LintId::of(&formatting::SUSPICIOUS_UNARY_OP_FORMATTING),\n+        LintId::of(&from_over_into::FROM_OVER_INTO),\n         LintId::of(&functions::DOUBLE_MUST_USE),\n         LintId::of(&functions::MUST_USE_UNIT),\n         LintId::of(&functions::RESULT_UNIT_ERR),\n@@ -1698,6 +1766,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&returns::LET_AND_RETURN),\n         LintId::of(&returns::NEEDLESS_RETURN),\n         LintId::of(&single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n+        LintId::of(&suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS),\n         LintId::of(&tabs_in_doc_comments::TABS_IN_DOC_COMMENTS),\n         LintId::of(&to_digit_is_some::TO_DIGIT_IS_SOME),\n         LintId::of(&try_err::TRY_ERR),\n@@ -1759,6 +1828,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&needless_bool::BOOL_COMPARISON),\n         LintId::of(&needless_bool::NEEDLESS_BOOL),\n         LintId::of(&needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE),\n+        LintId::of(&needless_question_mark::NEEDLESS_QUESTION_MARK),\n         LintId::of(&needless_update::NEEDLESS_UPDATE),\n         LintId::of(&neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),\n         LintId::of(&no_effect::NO_EFFECT),\n@@ -1769,6 +1839,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&ptr_offset_with_cast::PTR_OFFSET_WITH_CAST),\n         LintId::of(&ranges::RANGE_ZIP_WITH_LEN),\n         LintId::of(&redundant_closure_call::REDUNDANT_CLOSURE_CALL),\n+        LintId::of(&redundant_slicing::REDUNDANT_SLICING),\n         LintId::of(&reference::DEREF_ADDROF),\n         LintId::of(&reference::REF_IN_DEREF),\n         LintId::of(&repeat_once::REPEAT_ONCE),\n@@ -1850,6 +1921,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&regex::INVALID_REGEX),\n         LintId::of(&self_assignment::SELF_ASSIGNMENT),\n         LintId::of(&serde_api::SERDE_API_MISUSE),\n+        LintId::of(&size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n         LintId::of(&suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n         LintId::of(&suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n         LintId::of(&swap::ALMOST_SWAPPED),\n@@ -1890,6 +1962,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::BOX_VEC),\n         LintId::of(&types::REDUNDANT_ALLOCATION),\n         LintId::of(&vec::USELESS_VEC),\n+        LintId::of(&vec_init_then_push::VEC_INIT_THEN_PUSH),\n     ]);\n \n     store.register_group(true, \"clippy::cargo\", Some(\"clippy_cargo\"), vec!["}, {"sha": "e84c8b4e5b3e0317e7006e84abd689f1dca56d4b", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -501,7 +501,7 @@ impl<'tcx> Visitor<'tcx> for BodyLifetimeChecker {\n \n     // for lifetimes as parameters of generics\n     fn visit_lifetime(&mut self, lifetime: &'tcx Lifetime) {\n-        if lifetime.name.ident().name != kw::Invalid && lifetime.name.ident().name != kw::StaticLifetime {\n+        if lifetime.name.ident().name != kw::Empty && lifetime.name.ident().name != kw::StaticLifetime {\n             self.lifetimes_used_in_body = true;\n         }\n     }"}, {"sha": "87a957a9bd241728bd01fbaedaf06f08ee5836a7", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -11,7 +11,7 @@ use rustc_ast::ast::{Expr, ExprKind, Lit, LitKind};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n \n declare_clippy_lint! {\n     /// **What it does:** Warns if a long integral or floating-point constant does\n@@ -32,7 +32,7 @@ declare_clippy_lint! {\n     /// ```\n     pub UNREADABLE_LITERAL,\n     pedantic,\n-    \"long integer literal without underscores\"\n+    \"long literal without underscores\"\n }\n \n declare_clippy_lint! {\n@@ -208,7 +208,13 @@ impl WarningType {\n     }\n }\n \n-declare_lint_pass!(LiteralDigitGrouping => [\n+#[allow(clippy::module_name_repetitions)]\n+#[derive(Copy, Clone)]\n+pub struct LiteralDigitGrouping {\n+    lint_fraction_readability: bool,\n+}\n+\n+impl_lint_pass!(LiteralDigitGrouping => [\n     UNREADABLE_LITERAL,\n     INCONSISTENT_DIGIT_GROUPING,\n     LARGE_DIGIT_GROUPS,\n@@ -223,7 +229,7 @@ impl EarlyLintPass for LiteralDigitGrouping {\n         }\n \n         if let ExprKind::Lit(ref lit) = expr.kind {\n-            Self::check_lit(cx, lit)\n+            self.check_lit(cx, lit)\n         }\n     }\n }\n@@ -232,7 +238,13 @@ impl EarlyLintPass for LiteralDigitGrouping {\n const UUID_GROUP_LENS: [usize; 5] = [8, 4, 4, 4, 12];\n \n impl LiteralDigitGrouping {\n-    fn check_lit(cx: &EarlyContext<'_>, lit: &Lit) {\n+    pub fn new(lint_fraction_readability: bool) -> Self {\n+        Self {\n+            lint_fraction_readability,\n+        }\n+    }\n+\n+    fn check_lit(self, cx: &EarlyContext<'_>, lit: &Lit) {\n         if_chain! {\n             if let Some(src) = snippet_opt(cx, lit.span);\n             if let Some(mut num_lit) = NumericLiteral::from_lit(&src, &lit);\n@@ -247,9 +259,12 @@ impl LiteralDigitGrouping {\n \n                 let result = (|| {\n \n-                    let integral_group_size = Self::get_group_size(num_lit.integer.split('_'), num_lit.radix)?;\n+                    let integral_group_size = Self::get_group_size(num_lit.integer.split('_'), num_lit.radix, true)?;\n                     if let Some(fraction) = num_lit.fraction {\n-                        let fractional_group_size = Self::get_group_size(fraction.rsplit('_'), num_lit.radix)?;\n+                        let fractional_group_size = Self::get_group_size(\n+                            fraction.rsplit('_'),\n+                            num_lit.radix,\n+                            self.lint_fraction_readability)?;\n \n                         let consistent = Self::parts_consistent(integral_group_size,\n                                                                 fractional_group_size,\n@@ -363,7 +378,11 @@ impl LiteralDigitGrouping {\n \n     /// Returns the size of the digit groups (or None if ungrouped) if successful,\n     /// otherwise returns a `WarningType` for linting.\n-    fn get_group_size<'a>(groups: impl Iterator<Item = &'a str>, radix: Radix) -> Result<Option<usize>, WarningType> {\n+    fn get_group_size<'a>(\n+        groups: impl Iterator<Item = &'a str>,\n+        radix: Radix,\n+        lint_unreadable: bool,\n+    ) -> Result<Option<usize>, WarningType> {\n         let mut groups = groups.map(str::len);\n \n         let first = groups.next().expect(\"At least one group\");\n@@ -380,7 +399,7 @@ impl LiteralDigitGrouping {\n             } else {\n                 Ok(Some(second))\n             }\n-        } else if first > 5 {\n+        } else if first > 5 && lint_unreadable {\n             Err(WarningType::UnreadableLiteral)\n         } else {\n             Ok(None)"}, {"sha": "1c5ab2874b0481f92114eb50413e99bfec6f50f6", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 15, "deletions": 34, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -2,6 +2,7 @@ use crate::consts::constant;\n use crate::utils::paths;\n use crate::utils::sugg::Sugg;\n use crate::utils::usage::{is_unused, mutated_variables};\n+use crate::utils::visitors::LocalUsedVisitor;\n use crate::utils::{\n     contains_name, get_enclosing_block, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait,\n     indent_of, is_in_panic_handler, is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item,\n@@ -217,7 +218,7 @@ declare_clippy_lint! {\n     /// **Why is this bad?** The `while let` loop is usually shorter and more\n     /// readable.\n     ///\n-    /// **Known problems:** Sometimes the wrong binding is displayed (#383).\n+    /// **Known problems:** Sometimes the wrong binding is displayed ([#383](https://github.com/rust-lang/rust-clippy/issues/383)).\n     ///\n     /// **Example:**\n     /// ```rust,no_run\n@@ -741,6 +742,14 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n             // Break can come from the inner loop so remove them.\n             absorb_break(&never_loop_block(b, main_loop_id))\n         },\n+        ExprKind::If(ref e, ref e2, ref e3) => {\n+            let e1 = never_loop_expr(e, main_loop_id);\n+            let e2 = never_loop_expr(e2, main_loop_id);\n+            let e3 = e3\n+                .as_ref()\n+                .map_or(NeverLoopResult::Otherwise, |e| never_loop_expr(e, main_loop_id));\n+            combine_seq(e1, combine_branches(e2, e3))\n+        },\n         ExprKind::Match(ref e, ref arms, _) => {\n             let e = never_loop_expr(e, main_loop_id);\n             if arms.is_empty() {\n@@ -767,7 +776,7 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n         ExprKind::InlineAsm(ref asm) => asm\n             .operands\n             .iter()\n-            .map(|o| match o {\n+            .map(|(o, _)| match o {\n                 InlineAsmOperand::In { expr, .. }\n                 | InlineAsmOperand::InOut { expr, .. }\n                 | InlineAsmOperand::Const { expr }\n@@ -1919,8 +1928,7 @@ fn check_for_single_element_loop<'tcx>(\n     if_chain! {\n         if let ExprKind::AddrOf(BorrowKind::Ref, _, ref arg_expr) = arg.kind;\n         if let PatKind::Binding(.., target, _) = pat.kind;\n-        if let ExprKind::Array(ref arg_expr_list) = arg_expr.kind;\n-        if let [arg_expression] = arg_expr_list;\n+        if let ExprKind::Array([arg_expression]) = arg_expr.kind;\n         if let ExprKind::Path(ref list_item) = arg_expression.kind;\n         if let Some(list_item_name) = single_segment_path(list_item).map(|ps| ps.ident.name);\n         if let ExprKind::Block(ref block, _) = body.kind;\n@@ -2025,8 +2033,7 @@ fn check_for_mutability(cx: &LateContext<'_>, bound: &Expr<'_>) -> Option<HirId>\n                 let node_str = cx.tcx.hir().get(hir_id);\n                 if_chain! {\n                     if let Node::Binding(pat) = node_str;\n-                    if let PatKind::Binding(bind_ann, ..) = pat.kind;\n-                    if let BindingAnnotation::Mutable = bind_ann;\n+                    if let PatKind::Binding(BindingAnnotation::Mutable, ..) = pat.kind;\n                     then {\n                         return Some(hir_id);\n                     }\n@@ -2071,28 +2078,6 @@ fn pat_is_wild<'tcx>(pat: &'tcx PatKind<'_>, body: &'tcx Expr<'_>) -> bool {\n     }\n }\n \n-struct LocalUsedVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    local: HirId,\n-    used: bool,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for LocalUsedVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if same_var(self.cx, expr, self.local) {\n-            self.used = true;\n-        } else {\n-            walk_expr(self, expr);\n-        }\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n struct VarVisitor<'a, 'tcx> {\n     /// context reference\n     cx: &'a LateContext<'tcx>,\n@@ -2126,11 +2111,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n             then {\n                 let index_used_directly = same_var(self.cx, idx, self.var);\n                 let indexed_indirectly = {\n-                    let mut used_visitor = LocalUsedVisitor {\n-                        cx: self.cx,\n-                        local: self.var,\n-                        used: false,\n-                    };\n+                    let mut used_visitor = LocalUsedVisitor::new(self.var);\n                     walk_expr(&mut used_visitor, idx);\n                     used_visitor.used\n                 };\n@@ -2621,7 +2602,7 @@ fn is_loop(expr: &Expr<'_>) -> bool {\n }\n \n fn is_conditional(expr: &Expr<'_>) -> bool {\n-    matches!(expr.kind, ExprKind::Match(..))\n+    matches!(expr.kind, ExprKind::If(..) | ExprKind::Match(..))\n }\n \n fn is_nested(cx: &LateContext<'_>, match_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {"}, {"sha": "bb52888883af5a90c1e366d7a688d8b2b77a186e", "filename": "clippy_lints/src/macro_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmacro_use.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -105,7 +105,7 @@ impl MacroUseImports {\n impl<'tcx> LateLintPass<'tcx> for MacroUseImports {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n         if_chain! {\n-            if cx.sess().opts.edition == Edition::Edition2018;\n+            if cx.sess().opts.edition >= Edition::Edition2018;\n             if let hir::ItemKind::Use(path, _kind) = &item.kind;\n             if let Some(mac_attr) = item\n                 .attrs"}, {"sha": "89f5b2ff31137f0fe949b6706823361939d5c140", "filename": "clippy_lints/src/manual_async_fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -9,7 +9,7 @@ use rustc_hir::{\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** It checks for manual implementations of `async` functions.\n@@ -69,7 +69,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualAsyncFn {\n                     |diag| {\n                         if_chain! {\n                             if let Some(header_snip) = snippet_opt(cx, header_span);\n-                            if let Some(ret_pos) = position_before_rarrow(header_snip.clone());\n+                            if let Some(ret_pos) = position_before_rarrow(&header_snip);\n                             if let Some((ret_sugg, ret_snip)) = suggested_ret(cx, output);\n                             then {\n                                 let help = format!(\"make the function `async` and {}\", ret_sugg);\n@@ -137,7 +137,7 @@ fn future_output_ty<'tcx>(trait_ref: &'tcx TraitRef<'tcx>) -> Option<&'tcx Ty<'t\n         if let Some(args) = segment.args;\n         if args.bindings.len() == 1;\n         let binding = &args.bindings[0];\n-        if binding.ident.as_str() == \"Output\";\n+        if binding.ident.name == sym::Output;\n         if let TypeBindingKind::Equality{ty: output} = binding.kind;\n         then {\n             return Some(output)"}, {"sha": "91849e748878f645b6453e1571cf8357f0fab61f", "filename": "clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -4,17 +4,11 @@ use rustc_ast::ast::{Attribute, Item, ItemKind, StructField, Variant, VariantDat\n use rustc_attr as attr;\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{sym, Span};\n-use semver::{Version, VersionReq};\n \n-const MANUAL_NON_EXHAUSTIVE_MSRV: Version = Version {\n-    major: 1,\n-    minor: 40,\n-    patch: 0,\n-    pre: Vec::new(),\n-    build: Vec::new(),\n-};\n+const MANUAL_NON_EXHAUSTIVE_MSRV: RustcVersion = RustcVersion::new(1, 40, 0);\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for manual implementations of the non-exhaustive pattern.\n@@ -66,12 +60,12 @@ declare_clippy_lint! {\n \n #[derive(Clone)]\n pub struct ManualNonExhaustive {\n-    msrv: Option<VersionReq>,\n+    msrv: Option<RustcVersion>,\n }\n \n impl ManualNonExhaustive {\n     #[must_use]\n-    pub fn new(msrv: Option<VersionReq>) -> Self {\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n         Self { msrv }\n     }\n }"}, {"sha": "8c77e155b70ce4297ab971174ea0225afa61b236", "filename": "clippy_lints/src/manual_ok_or.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmanual_ok_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmanual_ok_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_ok_or.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -8,6 +8,7 @@ use rustc_lint::LintContext;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::sym;\n \n declare_clippy_lint! {\n     /// **What it does:**\n@@ -22,9 +23,6 @@ declare_clippy_lint! {\n     /// ```rust\n     /// let foo: Option<i32> = None;\n     /// foo.map_or(Err(\"error\"), |v| Ok(v));\n-    ///\n-    /// let foo: Option<i32> = None;\n-    /// foo.map_or(Err(\"error\"), |v| Ok(v));\n     /// ```\n     ///\n     /// Use instead:\n@@ -51,7 +49,7 @@ impl LateLintPass<'_> for ManualOkOr {\n             if args.len() == 3;\n             let method_receiver = &args[0];\n             let ty = cx.typeck_results().expr_ty(method_receiver);\n-            if is_type_diagnostic_item(cx, ty, sym!(option_type));\n+            if is_type_diagnostic_item(cx, ty, sym::option_type);\n             let or_expr = &args[1];\n             if is_ok_wrapping(cx, &args[2]);\n             if let ExprKind::Call(Expr { kind: ExprKind::Path(err_path), .. }, &[ref err_arg]) = or_expr.kind;"}, {"sha": "a0cfe145a301cb68649f8ab1f8bf23d35296d4aa", "filename": "clippy_lints/src/manual_strip.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_strip.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -13,18 +13,12 @@ use rustc_hir::{BorrowKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty;\n+use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Spanned;\n use rustc_span::Span;\n-use semver::{Version, VersionReq};\n \n-const MANUAL_STRIP_MSRV: Version = Version {\n-    major: 1,\n-    minor: 45,\n-    patch: 0,\n-    pre: Vec::new(),\n-    build: Vec::new(),\n-};\n+const MANUAL_STRIP_MSRV: RustcVersion = RustcVersion::new(1, 45, 0);\n \n declare_clippy_lint! {\n     /// **What it does:**\n@@ -61,12 +55,12 @@ declare_clippy_lint! {\n }\n \n pub struct ManualStrip {\n-    msrv: Option<VersionReq>,\n+    msrv: Option<RustcVersion>,\n }\n \n impl ManualStrip {\n     #[must_use]\n-    pub fn new(msrv: Option<VersionReq>) -> Self {\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n         Self { msrv }\n     }\n }\n@@ -86,7 +80,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n         }\n \n         if_chain! {\n-            if let Some((cond, then, _)) = higher::if_block(&expr);\n+            if let ExprKind::If(cond, then, _) = &expr.kind;\n             if let ExprKind::MethodCall(_, _, [target_arg, pattern], _) = cond.kind;\n             if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(cond.hir_id);\n             if let ExprKind::Path(target_path) = &target_arg.kind;\n@@ -225,8 +219,7 @@ fn find_stripping<'tcx>(\n                 if is_ref_str(self.cx, ex);\n                 let unref = peel_ref(ex);\n                 if let ExprKind::Index(indexed, index) = &unref.kind;\n-                if let Some(range) = higher::range(index);\n-                if let higher::Range { start, end, .. } = range;\n+                if let Some(higher::Range { start, end, .. }) = higher::range(index);\n                 if let ExprKind::Path(path) = &indexed.kind;\n                 if qpath_res(self.cx, path, ex.hir_id) == self.target;\n                 then {"}, {"sha": "1818836d5d5e836afa476aeb5da4564bf2278192", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -53,7 +53,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n         if_chain! {\n             if let hir::ExprKind::MethodCall(ref method, _, ref args, _) = e.kind;\n             if args.len() == 2;\n-            if method.ident.as_str() == \"map\";\n+            if method.ident.name == sym::map;\n             let ty = cx.typeck_results().expr_ty(&args[0]);\n             if is_type_diagnostic_item(cx, ty, sym::option_type) || match_trait_method(cx, e, &paths::ITERATOR);\n             if let hir::ExprKind::Closure(_, _, body_id, _, _) = args[1].kind;"}, {"sha": "76fe8e776eafda01f6d642edb19270a5182ddba2", "filename": "clippy_lints/src/map_err_ignore.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmap_err_ignore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmap_err_ignore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_err_ignore.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -7,7 +7,7 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n declare_clippy_lint! {\n     /// **What it does:** Checks for instances of `map_err(|_| Some::Enum)`\n     ///\n-    /// **Why is this bad?** This map_err throws away the original error rather than allowing the enum to contain and report the cause of the error\n+    /// **Why is this bad?** This `map_err` throws away the original error rather than allowing the enum to contain and report the cause of the error\n     ///\n     /// **Known problems:** None.\n     ///\n@@ -99,7 +99,7 @@ declare_clippy_lint! {\n     /// }\n     /// ```\n     pub MAP_ERR_IGNORE,\n-    pedantic,\n+    restriction,\n     \"`map_err` should not ignore the original error\"\n }\n \n@@ -133,9 +133,9 @@ impl<'tcx> LateLintPass<'tcx> for MapErrIgnore {\n                                     cx,\n                                     MAP_ERR_IGNORE,\n                                     body_span,\n-                                    \"`map_err(|_|...` ignores the original error\",\n+                                    \"`map_err(|_|...` wildcard pattern discards the original error\",\n                                     None,\n-                                    \"Consider wrapping the error in an enum variant\",\n+                                    \"consider storing the original error as a source in the new error, or silence this warning using an ignored identifier (`.map_err(|_foo| ...`)\",\n                                 );\n                             }\n                         }"}, {"sha": "9f9c108a85a0537610a14d98fb6547c43d9cc372", "filename": "clippy_lints/src/map_identity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmap_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmap_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_identity.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -63,7 +63,7 @@ impl<'tcx> LateLintPass<'tcx> for MapIdentity {\n fn get_map_argument<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a [Expr<'a>]> {\n     if_chain! {\n         if let ExprKind::MethodCall(ref method, _, ref args, _) = expr.kind;\n-        if args.len() == 2 && method.ident.as_str() == \"map\";\n+        if args.len() == 2 && method.ident.name == sym::map;\n         let caller_ty = cx.typeck_results().expr_ty(&args[0]);\n         if match_trait_method(cx, expr, &paths::ITERATOR)\n             || is_type_diagnostic_item(cx, caller_ty, sym::result_type)"}, {"sha": "01126e86199b41172d5087cba7fc7192cf4cf5c3", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -131,7 +131,7 @@ fn reduce_unit_expression<'a>(cx: &LateContext<'_>, expr: &'a hir::Expr<'_>) ->\n             Some(expr.span)\n         },\n         hir::ExprKind::Block(ref block, _) => {\n-            match (&block.stmts[..], block.expr.as_ref()) {\n+            match (block.stmts, block.expr.as_ref()) {\n                 (&[], Some(inner_expr)) => {\n                     // If block only contains an expression,\n                     // reduce `{ X }` to `X`"}, {"sha": "02021b873695f9dfc858e8a67955e7e2c809f775", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 117, "deletions": 45, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -2,10 +2,10 @@ use crate::consts::{constant, miri_to_const, Constant};\n use crate::utils::sugg::Sugg;\n use crate::utils::usage::is_unused;\n use crate::utils::{\n-    expr_block, get_arg_name, get_parent_expr, in_macro, indent_of, is_allowed, is_expn_of, is_refutable,\n-    is_type_diagnostic_item, is_wild, match_qpath, match_type, match_var, meets_msrv, multispan_sugg, remove_blocks,\n-    snippet, snippet_block, snippet_with_applicability, span_lint_and_help, span_lint_and_note, span_lint_and_sugg,\n-    span_lint_and_then,\n+    expr_block, get_arg_name, get_parent_expr, implements_trait, in_macro, indent_of, is_allowed, is_expn_of,\n+    is_refutable, is_type_diagnostic_item, is_wild, match_qpath, match_type, match_var, meets_msrv, multispan_sugg,\n+    peel_hir_pat_refs, peel_mid_ty_refs, peel_n_hir_expr_refs, remove_blocks, snippet, snippet_block, snippet_opt,\n+    snippet_with_applicability, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n };\n use crate::utils::{paths, search_same, SpanlessEq, SpanlessHash};\n use if_chain::if_chain;\n@@ -20,10 +20,10 @@ use rustc_hir::{\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty, TyS};\n+use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::{sym, Symbol};\n-use semver::{Version, VersionReq};\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry;\n use std::collections::Bound;\n@@ -412,8 +412,8 @@ declare_clippy_lint! {\n }\n \n declare_clippy_lint! {\n-    /// **What it does:** Lint for redundant pattern matching over `Result`, `Option` or\n-    /// `std::task::Poll`\n+    /// **What it does:** Lint for redundant pattern matching over `Result`, `Option`,\n+    /// `std::task::Poll` or `std::net::IpAddr`\n     ///\n     /// **Why is this bad?** It's more concise and clear to just use the proper\n     /// utility function\n@@ -424,12 +424,15 @@ declare_clippy_lint! {\n     ///\n     /// ```rust\n     /// # use std::task::Poll;\n+    /// # use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n     /// if let Ok(_) = Ok::<i32, i32>(42) {}\n     /// if let Err(_) = Err::<i32, i32>(42) {}\n     /// if let None = None::<()> {}\n     /// if let Some(_) = Some(42) {}\n     /// if let Poll::Pending = Poll::Pending::<()> {}\n     /// if let Poll::Ready(_) = Poll::Ready(42) {}\n+    /// if let IpAddr::V4(_) = IpAddr::V4(Ipv4Addr::LOCALHOST) {}\n+    /// if let IpAddr::V6(_) = IpAddr::V6(Ipv6Addr::LOCALHOST) {}\n     /// match Ok::<i32, i32>(42) {\n     ///     Ok(_) => true,\n     ///     Err(_) => false,\n@@ -440,12 +443,15 @@ declare_clippy_lint! {\n     ///\n     /// ```rust\n     /// # use std::task::Poll;\n+    /// # use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n     /// if Ok::<i32, i32>(42).is_ok() {}\n     /// if Err::<i32, i32>(42).is_err() {}\n     /// if None::<()>.is_none() {}\n     /// if Some(42).is_some() {}\n     /// if Poll::Pending::<()>.is_pending() {}\n     /// if Poll::Ready(42).is_ready() {}\n+    /// if IpAddr::V4(Ipv4Addr::LOCALHOST).is_ipv4() {}\n+    /// if IpAddr::V6(Ipv6Addr::LOCALHOST).is_ipv6() {}\n     /// Ok::<i32, i32>(42).is_ok();\n     /// ```\n     pub REDUNDANT_PATTERN_MATCHING,\n@@ -459,7 +465,8 @@ declare_clippy_lint! {\n     ///\n     /// **Why is this bad?** Readability and needless complexity.\n     ///\n-    /// **Known problems:** None\n+    /// **Known problems:** This lint falsely triggers, if there are arms with\n+    /// `cfg` attributes that remove an arm evaluating to `false`.\n     ///\n     /// **Example:**\n     /// ```rust\n@@ -528,13 +535,13 @@ declare_clippy_lint! {\n \n #[derive(Default)]\n pub struct Matches {\n-    msrv: Option<VersionReq>,\n+    msrv: Option<RustcVersion>,\n     infallible_destructuring_match_linted: bool,\n }\n \n impl Matches {\n     #[must_use]\n-    pub fn new(msrv: Option<VersionReq>) -> Self {\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n         Self {\n             msrv,\n             ..Matches::default()\n@@ -561,13 +568,7 @@ impl_lint_pass!(Matches => [\n     MATCH_SAME_ARMS,\n ]);\n \n-const MATCH_LIKE_MATCHES_MACRO_MSRV: Version = Version {\n-    major: 1,\n-    minor: 42,\n-    patch: 0,\n-    pre: Vec::new(),\n-    build: Vec::new(),\n-};\n+const MATCH_LIKE_MATCHES_MACRO_MSRV: RustcVersion = RustcVersion::new(1, 42, 0);\n \n impl<'tcx> LateLintPass<'tcx> for Matches {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n@@ -645,8 +646,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n         if_chain! {\n             if !in_external_macro(cx.sess(), pat.span);\n             if !in_macro(pat.span);\n-            if let PatKind::Struct(ref qpath, fields, true) = pat.kind;\n-            if let QPath::Resolved(_, ref path) = qpath;\n+            if let PatKind::Struct(QPath::Resolved(_, ref path), fields, true) = pat.kind;\n             if let Some(def_id) = path.res.opt_def_id();\n             let ty = cx.tcx.type_of(def_id);\n             if let ty::Adt(def, _) = ty.kind();\n@@ -689,10 +689,9 @@ fn check_single_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n             if stmts.len() == 1 && block_expr.is_none() || stmts.is_empty() && block_expr.is_some() {\n                 // single statement/expr \"else\" block, don't lint\n                 return;\n-            } else {\n-                // block with 2+ statements or 1 expr and 1+ statement\n-                Some(els)\n             }\n+            // block with 2+ statements or 1 expr and 1+ statement\n+            Some(els)\n         } else {\n             // not a block, don't lint\n             return;\n@@ -729,20 +728,60 @@ fn report_single_match_single_pattern(\n     let els_str = els.map_or(String::new(), |els| {\n         format!(\" else {}\", expr_block(cx, els, None, \"..\", Some(expr.span)))\n     });\n+\n+    let (msg, sugg) = if_chain! {\n+        let (pat, pat_ref_count) = peel_hir_pat_refs(arms[0].pat);\n+        if let PatKind::Path(_) | PatKind::Lit(_) = pat.kind;\n+        let (ty, ty_ref_count) = peel_mid_ty_refs(cx.typeck_results().expr_ty(ex));\n+        if let Some(trait_id) = cx.tcx.lang_items().structural_peq_trait();\n+        if ty.is_integral() || ty.is_char() || ty.is_str() || implements_trait(cx, ty, trait_id, &[]);\n+        then {\n+            // scrutinee derives PartialEq and the pattern is a constant.\n+            let pat_ref_count = match pat.kind {\n+                // string literals are already a reference.\n+                PatKind::Lit(Expr { kind: ExprKind::Lit(lit), .. }) if lit.node.is_str() => pat_ref_count + 1,\n+                _ => pat_ref_count,\n+            };\n+            // References are only implicitly added to the pattern, so no overflow here.\n+            // e.g. will work: match &Some(_) { Some(_) => () }\n+            // will not: match Some(_) { &Some(_) => () }\n+            let ref_count_diff = ty_ref_count - pat_ref_count;\n+\n+            // Try to remove address of expressions first.\n+            let (ex, removed) = peel_n_hir_expr_refs(ex, ref_count_diff);\n+            let ref_count_diff = ref_count_diff - removed;\n+\n+            let msg = \"you seem to be trying to use `match` for an equality check. Consider using `if`\";\n+            let sugg = format!(\n+                \"if {} == {}{} {}{}\",\n+                snippet(cx, ex.span, \"..\"),\n+                // PartialEq for different reference counts may not exist.\n+                \"&\".repeat(ref_count_diff),\n+                snippet(cx, arms[0].pat.span, \"..\"),\n+                expr_block(cx, &arms[0].body, None, \"..\", Some(expr.span)),\n+                els_str,\n+            );\n+            (msg, sugg)\n+        } else {\n+            let msg = \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\";\n+            let sugg = format!(\n+                \"if let {} = {} {}{}\",\n+                snippet(cx, arms[0].pat.span, \"..\"),\n+                snippet(cx, ex.span, \"..\"),\n+                expr_block(cx, &arms[0].body, None, \"..\", Some(expr.span)),\n+                els_str,\n+            );\n+            (msg, sugg)\n+        }\n+    };\n+\n     span_lint_and_sugg(\n         cx,\n         lint,\n         expr.span,\n-        \"you seem to be trying to use match for destructuring a single pattern. Consider using `if \\\n-         let`\",\n+        msg,\n         \"try this\",\n-        format!(\n-            \"if let {} = {} {}{}\",\n-            snippet(cx, arms[0].pat.span, \"..\"),\n-            snippet(cx, ex.span, \"..\"),\n-            expr_block(cx, &arms[0].body, None, \"..\", Some(expr.span)),\n-            els_str,\n-        ),\n+        sugg,\n         Applicability::HasPlaceholders,\n     );\n }\n@@ -955,16 +994,14 @@ fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n                 if let QPath::Resolved(_, p) = path {\n                     missing_variants.retain(|e| e.ctor_def_id != Some(p.res.def_id()));\n                 }\n-            } else if let PatKind::TupleStruct(ref path, ref patterns, ..) = arm.pat.kind {\n-                if let QPath::Resolved(_, p) = path {\n-                    // Some simple checks for exhaustive patterns.\n-                    // There is a room for improvements to detect more cases,\n-                    // but it can be more expensive to do so.\n-                    let is_pattern_exhaustive =\n-                        |pat: &&Pat<'_>| matches!(pat.kind, PatKind::Wild | PatKind::Binding(.., None));\n-                    if patterns.iter().all(is_pattern_exhaustive) {\n-                        missing_variants.retain(|e| e.ctor_def_id != Some(p.res.def_id()));\n-                    }\n+            } else if let PatKind::TupleStruct(QPath::Resolved(_, p), ref patterns, ..) = arm.pat.kind {\n+                // Some simple checks for exhaustive patterns.\n+                // There is a room for improvements to detect more cases,\n+                // but it can be more expensive to do so.\n+                let is_pattern_exhaustive =\n+                    |pat: &&Pat<'_>| matches!(pat.kind, PatKind::Wild | PatKind::Binding(.., None));\n+                if patterns.iter().all(is_pattern_exhaustive) {\n+                    missing_variants.retain(|e| e.ctor_def_id != Some(p.res.def_id()));\n                 }\n             }\n         }\n@@ -1167,13 +1204,16 @@ fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr\n         if b0 != b1;\n         let if_guard = &b0_arms[0].guard;\n         if if_guard.is_none() || b0_arms.len() == 1;\n+        if b0_arms[0].attrs.is_empty();\n         if b0_arms[1..].iter()\n             .all(|arm| {\n                 find_bool_lit(&arm.body.kind, desugared).map_or(false, |b| b == b0) &&\n-                arm.guard.is_none()\n+                arm.guard.is_none() && arm.attrs.is_empty()\n             });\n         then {\n-            let mut applicability = Applicability::MachineApplicable;\n+            // The suggestion may be incorrect, because some arms can have `cfg` attributes\n+            // evaluated into `false` and so such arms will be stripped before.\n+            let mut applicability = Applicability::MaybeIncorrect;\n             let pat = {\n                 use itertools::Itertools as _;\n                 b0_arms.iter()\n@@ -1237,6 +1277,24 @@ fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[A\n     if in_macro(expr.span) || arms.len() != 1 || is_refutable(cx, arms[0].pat) {\n         return;\n     }\n+\n+    // HACK:\n+    // This is a hack to deal with arms that are excluded by macros like `#[cfg]`. It is only used here\n+    // to prevent false positives as there is currently no better way to detect if code was excluded by\n+    // a macro. See PR #6435\n+    if_chain! {\n+        if let Some(match_snippet) = snippet_opt(cx, expr.span);\n+        if let Some(arm_snippet) = snippet_opt(cx, arms[0].span);\n+        if let Some(ex_snippet) = snippet_opt(cx, ex.span);\n+        let rest_snippet = match_snippet.replace(&arm_snippet, \"\").replace(&ex_snippet, \"\");\n+        if rest_snippet.contains(\"=>\");\n+        then {\n+            // The code it self contains another thick arrow \"=>\"\n+            // -> Either another arm or a comment\n+            return;\n+        }\n+    }\n+\n     let matched_vars = ex.span;\n     let bind_names = arms[0].pat.span;\n     let match_body = remove_blocks(&arms[0].body);\n@@ -1436,8 +1494,7 @@ fn is_ref_some_arm(arm: &Arm<'_>) -> Option<BindingAnnotation> {\n         if let ExprKind::Call(ref e, ref args) = remove_blocks(&arm.body).kind;\n         if let ExprKind::Path(ref some_path) = e.kind;\n         if match_qpath(some_path, &paths::OPTION_SOME) && args.len() == 1;\n-        if let ExprKind::Path(ref qpath) = args[0].kind;\n-        if let &QPath::Resolved(_, ref path2) = qpath;\n+        if let ExprKind::Path(QPath::Resolved(_, ref path2)) = args[0].kind;\n         if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n         then {\n             return Some(rb)\n@@ -1573,6 +1630,10 @@ mod redundant_pattern_match {\n                         \"is_some()\"\n                     } else if match_qpath(path, &paths::POLL_READY) {\n                         \"is_ready()\"\n+                    } else if match_qpath(path, &paths::IPADDR_V4) {\n+                        \"is_ipv4()\"\n+                    } else if match_qpath(path, &paths::IPADDR_V6) {\n+                        \"is_ipv6()\"\n                     } else {\n                         return;\n                     }\n@@ -1653,6 +1714,17 @@ mod redundant_pattern_match {\n                             \"is_ok()\",\n                             \"is_err()\",\n                         )\n+                        .or_else(|| {\n+                            find_good_method_for_match(\n+                                arms,\n+                                path_left,\n+                                path_right,\n+                                &paths::IPADDR_V4,\n+                                &paths::IPADDR_V6,\n+                                \"is_ipv4()\",\n+                                \"is_ipv6()\",\n+                            )\n+                        })\n                     } else {\n                         None\n                     }"}, {"sha": "19087b02077142fb84d86a62c87beffa7ac844d7", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,13 +1,14 @@\n use crate::utils::{\n-    in_macro, match_def_path, match_qpath, paths, snippet, snippet_with_applicability, span_lint_and_help,\n+    in_macro, match_def_path, match_qpath, meets_msrv, paths, snippet, snippet_with_applicability, span_lint_and_help,\n     span_lint_and_sugg, span_lint_and_then,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, QPath};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::sym;\n \n@@ -94,7 +95,7 @@ declare_clippy_lint! {\n     \"replacing a value of type `T` with `T::default()` instead of using `std::mem::take`\"\n }\n \n-declare_lint_pass!(MemReplace =>\n+impl_lint_pass!(MemReplace =>\n     [MEM_REPLACE_OPTION_WITH_NONE, MEM_REPLACE_WITH_UNINIT, MEM_REPLACE_WITH_DEFAULT]);\n \n fn check_replace_option_with_none(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n@@ -224,6 +225,19 @@ fn check_replace_with_default(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<\n     }\n }\n \n+const MEM_REPLACE_WITH_DEFAULT_MSRV: RustcVersion = RustcVersion::new(1, 40, 0);\n+\n+pub struct MemReplace {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl MemReplace {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for MemReplace {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n@@ -236,8 +250,11 @@ impl<'tcx> LateLintPass<'tcx> for MemReplace {\n             then {\n                 check_replace_option_with_none(cx, src, dest, expr.span);\n                 check_replace_with_uninit(cx, src, dest, expr.span);\n-                check_replace_with_default(cx, src, dest, expr.span);\n+                if meets_msrv(self.msrv.as_ref(), &MEM_REPLACE_WITH_DEFAULT_MSRV) {\n+                    check_replace_with_default(cx, src, dest, expr.span);\n+                }\n             }\n         }\n     }\n+    extract_msrv_attr!(LateContext);\n }"}, {"sha": "44c974b9d98577c2add2c02bedb8f8e1feea592e", "filename": "clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -90,8 +90,7 @@ fn is_min_or_max<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>) -> Option<M\n     if_chain! {\n         if let hir::ExprKind::Call(func, args) = &expr.kind;\n         if args.is_empty();\n-        if let hir::ExprKind::Path(path) = &func.kind;\n-        if let hir::QPath::TypeRelative(_, segment) = path;\n+        if let hir::ExprKind::Path(hir::QPath::TypeRelative(_, segment)) = &func.kind;\n         then {\n             match &*segment.ident.as_str() {\n                 \"max_value\" => return Some(MinMax::Max),"}, {"sha": "79aec928d298b7462e3fdc3e0e2356ccc331c9ce", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 118, "deletions": 97, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -14,27 +14,27 @@ use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{TraitItem, TraitItemKind};\n use rustc_lint::{LateContext, LateLintPass, Lint, LintContext};\n-use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, TraitRef, Ty, TyS};\n+use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{sym, SymbolStr};\n+use rustc_typeck::hir_ty_to_ty;\n \n use crate::consts::{constant, Constant};\n use crate::utils::eager_or_lazy::is_lazyness_candidate;\n use crate::utils::usage::mutated_variables;\n use crate::utils::{\n-    contains_ty, get_arg_name, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait, in_macro,\n-    is_copy, is_expn_of, is_type_diagnostic_item, iter_input_pats, last_path_segment, match_def_path, match_qpath,\n-    match_trait_method, match_type, match_var, meets_msrv, method_calls, method_chain_args, paths, remove_blocks,\n-    return_ty, single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n-    span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg, walk_ptrs_ty_depth, SpanlessEq,\n+    contains_return, contains_ty, get_arg_name, get_parent_expr, get_trait_def_id, has_iter_method, higher,\n+    implements_trait, in_macro, is_copy, is_expn_of, is_type_diagnostic_item, iter_input_pats, last_path_segment,\n+    match_def_path, match_qpath, match_trait_method, match_type, match_var, meets_msrv, method_calls,\n+    method_chain_args, paths, remove_blocks, return_ty, single_segment_path, snippet, snippet_with_applicability,\n+    snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg,\n+    walk_ptrs_ty_depth, SpanlessEq,\n };\n-use semver::{Version, VersionReq};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for `.unwrap()` calls on `Option`s and on `Result`s.\n@@ -1406,12 +1406,12 @@ declare_clippy_lint! {\n }\n \n pub struct Methods {\n-    msrv: Option<VersionReq>,\n+    msrv: Option<RustcVersion>,\n }\n \n impl Methods {\n     #[must_use]\n-    pub fn new(msrv: Option<VersionReq>) -> Self {\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n         Self { msrv }\n     }\n }\n@@ -1488,7 +1488,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"expect\", ..] => lint_expect(cx, expr, arg_lists[0]),\n             [\"unwrap_or\", \"map\"] => option_map_unwrap_or::lint(cx, expr, arg_lists[1], arg_lists[0], method_spans[1]),\n             [\"unwrap_or_else\", \"map\"] => {\n-                if !lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0]) {\n+                if !lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0], self.msrv.as_ref()) {\n                     unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"unwrap_or\");\n                 }\n             },\n@@ -1510,7 +1510,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"next\", \"iter\"] => lint_iter_next(cx, expr, arg_lists[1]),\n             [\"map\", \"filter\"] => lint_filter_map(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"map\", \"filter_map\"] => lint_filter_map_map(cx, expr, arg_lists[1], arg_lists[0]),\n-            [\"next\", \"filter_map\"] => lint_filter_map_next(cx, expr, arg_lists[1]),\n+            [\"next\", \"filter_map\"] => lint_filter_map_next(cx, expr, arg_lists[1], self.msrv.as_ref()),\n             [\"map\", \"find\"] => lint_find_map(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"flat_map\", \"filter\"] => lint_filter_flat_map(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"flat_map\", \"filter_map\"] => lint_filter_map_flat_map(cx, expr, arg_lists[1], arg_lists[0]),\n@@ -1569,7 +1569,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 lint_expect_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n \n                 let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0]);\n-                if args.len() == 1 && method_call.ident.name == sym!(clone) {\n+                if args.len() == 1 && method_call.ident.name == sym::clone {\n                     lint_clone_on_copy(cx, expr, &args[0], self_ty);\n                     lint_clone_on_ref_ptr(cx, expr, &args[0]);\n                 }\n@@ -1593,7 +1593,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                             }\n                         }\n                     },\n-                    ty::Ref(..) if method_call.ident.name == sym!(into_iter) => {\n+                    ty::Ref(..) if method_call.ident.name == sym::into_iter => {\n                         lint_into_iter(cx, expr, self_ty, *method_span);\n                     },\n                     _ => (),\n@@ -1624,10 +1624,15 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n         let item = cx.tcx.hir().expect_item(parent);\n         let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n         let self_ty = cx.tcx.type_of(def_id);\n+\n+        // if this impl block implements a trait, lint in trait definition instead\n+        if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = item.kind {\n+            return;\n+        }\n+\n         if_chain! {\n             if let hir::ImplItemKind::Fn(ref sig, id) = impl_item.kind;\n             if let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir().body(id)).next();\n-            if let hir::ItemKind::Impl{ of_trait: None, .. } = item.kind;\n \n             let method_def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n             let method_sig = cx.tcx.fn_sig(method_def_id);\n@@ -1669,40 +1674,17 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                     }\n                 }\n \n-                if let Some((ref conv, self_kinds)) = &CONVENTIONS\n-                    .iter()\n-                    .find(|(ref conv, _)| conv.check(&name))\n-                {\n-                    if !self_kinds.iter().any(|k| k.matches(cx, self_ty, first_arg_ty)) {\n-                        let lint = if item.vis.node.is_pub() {\n-                            WRONG_PUB_SELF_CONVENTION\n-                        } else {\n-                            WRONG_SELF_CONVENTION\n-                        };\n-\n-                        span_lint(\n-                            cx,\n-                            lint,\n-                            first_arg.pat.span,\n-                            &format!(\"methods called `{}` usually take {}; consider choosing a less ambiguous name\",\n-                                conv,\n-                                &self_kinds\n-                                    .iter()\n-                                    .map(|k| k.description())\n-                                    .collect::<Vec<_>>()\n-                                    .join(\" or \")\n-                            ),\n-                        );\n-                    }\n-                }\n+                lint_wrong_self_convention(\n+                    cx,\n+                    &name,\n+                    item.vis.node.is_pub(),\n+                    self_ty,\n+                    first_arg_ty,\n+                    first_arg.pat.span\n+                );\n             }\n         }\n \n-        // if this impl block implements a trait, lint in trait definition instead\n-        if let hir::ItemKind::Impl { of_trait: Some(_), .. } = item.kind {\n-            return;\n-        }\n-\n         if let hir::ImplItemKind::Fn(_, _) = impl_item.kind {\n             let ret_ty = return_ty(cx, impl_item.hir_id);\n \n@@ -1736,8 +1718,23 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n+        if in_external_macro(cx.tcx.sess, item.span) {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let TraitItemKind::Fn(ref sig, _) = item.kind;\n+            if let Some(first_arg_ty) = sig.decl.inputs.iter().next();\n+            let first_arg_span = first_arg_ty.span;\n+            let first_arg_ty = hir_ty_to_ty(cx.tcx, first_arg_ty);\n+            let self_ty = TraitRef::identity(cx.tcx, item.hir_id.owner.to_def_id()).self_ty();\n+\n+            then {\n+                lint_wrong_self_convention(cx, &item.ident.name.as_str(), false, self_ty, first_arg_ty, first_arg_span);\n+            }\n+        }\n+\n         if_chain! {\n-            if !in_external_macro(cx.tcx.sess, item.span);\n             if item.ident.name == sym::new;\n             if let TraitItemKind::Fn(_, _) = item.kind;\n             let ret_ty = return_ty(cx, item.hir_id);\n@@ -1758,6 +1755,39 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n     extract_msrv_attr!(LateContext);\n }\n \n+fn lint_wrong_self_convention<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    item_name: &str,\n+    is_pub: bool,\n+    self_ty: &'tcx TyS<'tcx>,\n+    first_arg_ty: &'tcx TyS<'tcx>,\n+    first_arg_span: Span,\n+) {\n+    let lint = if is_pub {\n+        WRONG_PUB_SELF_CONVENTION\n+    } else {\n+        WRONG_SELF_CONVENTION\n+    };\n+    if let Some((ref conv, self_kinds)) = &CONVENTIONS.iter().find(|(ref conv, _)| conv.check(item_name)) {\n+        if !self_kinds.iter().any(|k| k.matches(cx, self_ty, first_arg_ty)) {\n+            span_lint(\n+                cx,\n+                lint,\n+                first_arg_span,\n+                &format!(\n+                    \"methods called `{}` usually take {}; consider choosing a less ambiguous name\",\n+                    conv,\n+                    &self_kinds\n+                        .iter()\n+                        .map(|k| k.description())\n+                        .collect::<Vec<_>>()\n+                        .join(\" or \")\n+                ),\n+            );\n+        }\n+    }\n+}\n+\n /// Checks for the `OR_FUN_CALL` lint.\n #[allow(clippy::too_many_lines)]\n fn lint_or_fun_call<'tcx>(\n@@ -2018,6 +2048,7 @@ fn lint_expect_fun_call(\n             hir::ExprKind::Call(..)\n             | hir::ExprKind::MethodCall(..)\n             // These variants are debatable or require further examination\n+            | hir::ExprKind::If(..)\n             | hir::ExprKind::Match(..)\n             | hir::ExprKind::Block{ .. } => true,\n             _ => false,\n@@ -2101,8 +2132,11 @@ fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Exp\n                 cx,\n                 CLONE_DOUBLE_REF,\n                 expr.span,\n-                \"using `clone` on a double-reference; \\\n-                this will copy the reference instead of cloning the inner type\",\n+                &format!(\n+                    \"using `clone` on a double-reference; \\\n+                    this will copy the reference of type `{}` instead of cloning the inner type\",\n+                    ty\n+                ),\n                 |diag| {\n                     if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n                         let mut ty = innermost;\n@@ -2175,11 +2209,17 @@ fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Exp\n         } else {\n             snip = None;\n         }\n-        span_lint_and_then(cx, CLONE_ON_COPY, expr.span, \"using `clone` on a `Copy` type\", |diag| {\n-            if let Some((text, snip)) = snip {\n-                diag.span_suggestion(expr.span, text, snip, Applicability::MachineApplicable);\n-            }\n-        });\n+        span_lint_and_then(\n+            cx,\n+            CLONE_ON_COPY,\n+            expr.span,\n+            &format!(\"using `clone` on type `{}` which implements the `Copy` trait\", ty),\n+            |diag| {\n+                if let Some((text, snip)) = snip {\n+                    diag.span_suggestion(expr.span, text, snip, Applicability::MachineApplicable);\n+                }\n+            },\n+        );\n     }\n }\n \n@@ -2639,9 +2679,9 @@ fn lint_unwrap(cx: &LateContext<'_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::E\n fn lint_expect(cx: &LateContext<'_>, expr: &hir::Expr<'_>, expect_args: &[hir::Expr<'_>]) {\n     let obj_ty = cx.typeck_results().expr_ty(&expect_args[0]).peel_refs();\n \n-    let mess = if is_type_diagnostic_item(cx, obj_ty, sym!(option_type)) {\n+    let mess = if is_type_diagnostic_item(cx, obj_ty, sym::option_type) {\n         Some((EXPECT_USED, \"an Option\", \"None\"))\n-    } else if is_type_diagnostic_item(cx, obj_ty, sym!(result_type)) {\n+    } else if is_type_diagnostic_item(cx, obj_ty, sym::result_type) {\n         Some((EXPECT_USED, \"a Result\", \"Err\"))\n     } else {\n         None\n@@ -2734,14 +2774,20 @@ fn lint_map_flatten<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n     }\n }\n \n+const MAP_UNWRAP_OR_MSRV: RustcVersion = RustcVersion::new(1, 41, 0);\n+\n /// lint use of `map().unwrap_or_else()` for `Option`s and `Result`s\n /// Return true if lint triggered\n fn lint_map_unwrap_or_else<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n     map_args: &'tcx [hir::Expr<'_>],\n     unwrap_args: &'tcx [hir::Expr<'_>],\n+    msrv: Option<&RustcVersion>,\n ) -> bool {\n+    if !meets_msrv(msrv, &MAP_UNWRAP_OR_MSRV) {\n+        return false;\n+    }\n     // lint if the caller of `map()` is an `Option`\n     let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type);\n     let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::result_type);\n@@ -2924,9 +2970,20 @@ fn lint_filter_map<'tcx>(\n     }\n }\n \n+const FILTER_MAP_NEXT_MSRV: RustcVersion = RustcVersion::new(1, 30, 0);\n+\n /// lint use of `filter_map().next()` for `Iterators`\n-fn lint_filter_map_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, filter_args: &'tcx [hir::Expr<'_>]) {\n+fn lint_filter_map_next<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    filter_args: &'tcx [hir::Expr<'_>],\n+    msrv: Option<&RustcVersion>,\n+) {\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        if !meets_msrv(msrv, &FILTER_MAP_NEXT_MSRV) {\n+            return;\n+        }\n+\n         let msg = \"called `filter_map(..).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n                    `.find_map(..)` instead.\";\n         let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n@@ -3039,7 +3096,7 @@ fn lint_flat_map_identity<'tcx>(\n             if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = body.value.kind;\n \n             if path.segments.len() == 1;\n-            if path.segments[0].ident.as_str() == binding_ident.as_str();\n+            if path.segments[0].ident.name == binding_ident.name;\n \n             then {\n                 apply_lint(\"called `flat_map(|x| x)` on an `Iterator`\");\n@@ -3117,7 +3174,7 @@ fn lint_search_is_some<'tcx>(\n     else if search_method == \"find\" {\n         let is_string_or_str_slice = |e| {\n             let self_ty = cx.typeck_results().expr_ty(e).peel_refs();\n-            if is_type_diagnostic_item(cx, self_ty, sym!(string_type)) {\n+            if is_type_diagnostic_item(cx, self_ty, sym::string_type) {\n                 true\n             } else {\n                 *self_ty.kind() == ty::Str\n@@ -3471,13 +3528,7 @@ fn lint_suspicious_map(cx: &LateContext<'_>, expr: &hir::Expr<'_>) {\n     );\n }\n \n-const OPTION_AS_REF_DEREF_MSRV: Version = Version {\n-    major: 1,\n-    minor: 40,\n-    patch: 0,\n-    pre: Vec::new(),\n-    build: Vec::new(),\n-};\n+const OPTION_AS_REF_DEREF_MSRV: RustcVersion = RustcVersion::new(1, 40, 0);\n \n /// lint use of `_.as_ref().map(Deref::deref)` for `Option`s\n fn lint_option_as_ref_deref<'tcx>(\n@@ -3486,7 +3537,7 @@ fn lint_option_as_ref_deref<'tcx>(\n     as_ref_args: &[hir::Expr<'_>],\n     map_args: &[hir::Expr<'_>],\n     is_mut: bool,\n-    msrv: Option<&VersionReq>,\n+    msrv: Option<&RustcVersion>,\n ) {\n     if !meets_msrv(msrv, &OPTION_AS_REF_DEREF_MSRV) {\n         return;\n@@ -3877,36 +3928,6 @@ fn is_bool(ty: &hir::Ty<'_>) -> bool {\n     }\n }\n \n-// Returns `true` if `expr` contains a return expression\n-fn contains_return(expr: &hir::Expr<'_>) -> bool {\n-    struct RetCallFinder {\n-        found: bool,\n-    }\n-\n-    impl<'tcx> intravisit::Visitor<'tcx> for RetCallFinder {\n-        type Map = Map<'tcx>;\n-\n-        fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-            if self.found {\n-                return;\n-            }\n-            if let hir::ExprKind::Ret(..) = &expr.kind {\n-                self.found = true;\n-            } else {\n-                intravisit::walk_expr(self, expr);\n-            }\n-        }\n-\n-        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n-            intravisit::NestedVisitorMap::None\n-        }\n-    }\n-\n-    let mut visitor = RetCallFinder { found: false };\n-    visitor.visit_expr(expr);\n-    visitor.found\n-}\n-\n fn check_pointer_offset(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     if_chain! {\n         if args.len() == 2;"}, {"sha": "d98e6160d308561d2b1f115c1ce5e5372e3ba27f", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -69,10 +69,9 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n                             }\n                         }\n                         return (true, false);\n-                    } else {\n-                        // We don't know. It might do anything.\n-                        return (true, true);\n                     }\n+                    // We don't know. It might do anything.\n+                    return (true, true);\n                 }\n             }\n             (true, true)\n@@ -91,6 +90,12 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n             }\n             (found_mapping, found_filtering)\n         },\n+        // There must be an else_arm or there will be a type error\n+        hir::ExprKind::If(_, ref if_arm, Some(ref else_arm)) => {\n+            let if_check = check_expression(cx, arg_id, if_arm);\n+            let else_check = check_expression(cx, arg_id, else_arm);\n+            (if_check.0 | else_check.0, if_check.1 | else_check.1)\n+        },\n         hir::ExprKind::Path(path) if match_qpath(path, &paths::OPTION_NONE) => (false, true),\n         _ => (true, true),\n     }"}, {"sha": "8d0c3b8e0fe89f39921c198656a553095e85e689", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -89,9 +89,9 @@ fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Cons\n                 if let [obj, _] = args;\n                 if cx.typeck_results().expr_ty(obj).is_floating_point() || match_trait_method(cx, expr, &paths::ORD);\n                 then {\n-                    if path.ident.as_str() == sym!(max).as_str() {\n+                    if path.ident.name == sym!(max) {\n                         fetch_const(cx, args, MinMax::Max)\n-                    } else if path.ident.as_str() == sym!(min).as_str() {\n+                    } else if path.ident.name == sym!(min) {\n                         fetch_const(cx, args, MinMax::Min)\n                     } else {\n                         None"}, {"sha": "0512d74c7b1c8350bd31ca5f039d84578d663b83", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 83, "deletions": 61, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -18,7 +18,7 @@ use crate::utils::sugg::Sugg;\n use crate::utils::{\n     get_item_name, get_parent_expr, higher, implements_trait, in_constant, is_integer_const, iter_input_pats,\n     last_path_segment, match_qpath, match_trait_method, paths, snippet, snippet_opt, span_lint, span_lint_and_sugg,\n-    span_lint_and_then, span_lint_hir_and_then, SpanlessEq,\n+    span_lint_and_then, span_lint_hir_and_then, unsext, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -139,23 +139,26 @@ declare_clippy_lint! {\n }\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for getting the remainder of a division by one.\n+    /// **What it does:** Checks for getting the remainder of a division by one or minus\n+    /// one.\n     ///\n-    /// **Why is this bad?** The result can only ever be zero. No one will write\n-    /// such code deliberately, unless trying to win an Underhanded Rust\n-    /// Contest. Even for that contest, it's probably a bad idea. Use something more\n-    /// underhanded.\n+    /// **Why is this bad?** The result for a divisor of one can only ever be zero; for\n+    /// minus one it can cause panic/overflow (if the left operand is the minimal value of\n+    /// the respective integer type) or results in zero. No one will write such code\n+    /// deliberately, unless trying to win an Underhanded Rust Contest. Even for that\n+    /// contest, it's probably a bad idea. Use something more underhanded.\n     ///\n     /// **Known problems:** None.\n     ///\n     /// **Example:**\n     /// ```rust\n     /// # let x = 1;\n     /// let a = x % 1;\n+    /// let a = x % -1;\n     /// ```\n     pub MODULO_ONE,\n     correctness,\n-    \"taking a number modulo 1, which always returns 0\"\n+    \"taking a number modulo +/-1, which can either panic/overflow or always returns 0\"\n }\n \n declare_clippy_lint! {\n@@ -378,60 +381,8 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n                 return;\n             },\n             ExprKind::Binary(ref cmp, ref left, ref right) => {\n-                let op = cmp.node;\n-                if op.is_comparison() {\n-                    check_nan(cx, left, expr);\n-                    check_nan(cx, right, expr);\n-                    check_to_owned(cx, left, right, true);\n-                    check_to_owned(cx, right, left, false);\n-                }\n-                if (op == BinOpKind::Eq || op == BinOpKind::Ne) && (is_float(cx, left) || is_float(cx, right)) {\n-                    if is_allowed(cx, left) || is_allowed(cx, right) {\n-                        return;\n-                    }\n-\n-                    // Allow comparing the results of signum()\n-                    if is_signum(cx, left) && is_signum(cx, right) {\n-                        return;\n-                    }\n-\n-                    if let Some(name) = get_item_name(cx, expr) {\n-                        let name = name.as_str();\n-                        if name == \"eq\"\n-                            || name == \"ne\"\n-                            || name == \"is_nan\"\n-                            || name.starts_with(\"eq_\")\n-                            || name.ends_with(\"_eq\")\n-                        {\n-                            return;\n-                        }\n-                    }\n-                    let is_comparing_arrays = is_array(cx, left) || is_array(cx, right);\n-                    let (lint, msg) = get_lint_and_message(\n-                        is_named_constant(cx, left) || is_named_constant(cx, right),\n-                        is_comparing_arrays,\n-                    );\n-                    span_lint_and_then(cx, lint, expr.span, msg, |diag| {\n-                        let lhs = Sugg::hir(cx, left, \"..\");\n-                        let rhs = Sugg::hir(cx, right, \"..\");\n-\n-                        if !is_comparing_arrays {\n-                            diag.span_suggestion(\n-                                expr.span,\n-                                \"consider comparing them within some margin of error\",\n-                                format!(\n-                                    \"({}).abs() {} error_margin\",\n-                                    lhs - rhs,\n-                                    if op == BinOpKind::Eq { '<' } else { '>' }\n-                                ),\n-                                Applicability::HasPlaceholders, // snippet\n-                            );\n-                        }\n-                        diag.note(\"`f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\");\n-                    });\n-                } else if op == BinOpKind::Rem && is_integer_const(cx, right, 1) {\n-                    span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n-                }\n+                check_binary(cx, expr, cmp, left, right);\n+                return;\n             },\n             _ => {},\n         }\n@@ -744,3 +695,74 @@ fn check_cast(cx: &LateContext<'_>, span: Span, e: &Expr<'_>, ty: &hir::Ty<'_>)\n         }\n     }\n }\n+\n+fn check_binary(\n+    cx: &LateContext<'a>,\n+    expr: &Expr<'_>,\n+    cmp: &rustc_span::source_map::Spanned<rustc_hir::BinOpKind>,\n+    left: &'a Expr<'_>,\n+    right: &'a Expr<'_>,\n+) {\n+    let op = cmp.node;\n+    if op.is_comparison() {\n+        check_nan(cx, left, expr);\n+        check_nan(cx, right, expr);\n+        check_to_owned(cx, left, right, true);\n+        check_to_owned(cx, right, left, false);\n+    }\n+    if (op == BinOpKind::Eq || op == BinOpKind::Ne) && (is_float(cx, left) || is_float(cx, right)) {\n+        if is_allowed(cx, left) || is_allowed(cx, right) {\n+            return;\n+        }\n+\n+        // Allow comparing the results of signum()\n+        if is_signum(cx, left) && is_signum(cx, right) {\n+            return;\n+        }\n+\n+        if let Some(name) = get_item_name(cx, expr) {\n+            let name = name.as_str();\n+            if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") || name.ends_with(\"_eq\") {\n+                return;\n+            }\n+        }\n+        let is_comparing_arrays = is_array(cx, left) || is_array(cx, right);\n+        let (lint, msg) = get_lint_and_message(\n+            is_named_constant(cx, left) || is_named_constant(cx, right),\n+            is_comparing_arrays,\n+        );\n+        span_lint_and_then(cx, lint, expr.span, msg, |diag| {\n+            let lhs = Sugg::hir(cx, left, \"..\");\n+            let rhs = Sugg::hir(cx, right, \"..\");\n+\n+            if !is_comparing_arrays {\n+                diag.span_suggestion(\n+                    expr.span,\n+                    \"consider comparing them within some margin of error\",\n+                    format!(\n+                        \"({}).abs() {} error_margin\",\n+                        lhs - rhs,\n+                        if op == BinOpKind::Eq { '<' } else { '>' }\n+                    ),\n+                    Applicability::HasPlaceholders, // snippet\n+                );\n+            }\n+            diag.note(\"`f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\");\n+        });\n+    } else if op == BinOpKind::Rem {\n+        if is_integer_const(cx, right, 1) {\n+            span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n+        }\n+\n+        if let ty::Int(ity) = cx.typeck_results().expr_ty(right).kind() {\n+            if is_integer_const(cx, right, unsext(cx.tcx, -1, *ity)) {\n+                span_lint(\n+                    cx,\n+                    MODULO_ONE,\n+                    expr.span,\n+                    \"any number modulo -1 will panic/overflow or result in 0\",\n+                );\n+            }\n+        };\n+    }\n+}"}, {"sha": "6ebeaced62a335fcb806115cf1a1ec9c9ae291bd", "filename": "clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,14 +1,19 @@\n use crate::utils::qualify_min_const_fn::is_min_const_fn;\n-use crate::utils::{fn_has_unsatisfiable_preds, has_drop, is_entrypoint_fn, span_lint, trait_ref_of_method};\n+use crate::utils::{\n+    fn_has_unsatisfiable_preds, has_drop, is_entrypoint_fn, meets_msrv, span_lint, trait_ref_of_method,\n+};\n use rustc_hir as hir;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Body, Constness, FnDecl, GenericParamKind, HirId};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Span;\n use rustc_typeck::hir_ty_to_ty;\n \n+const MISSING_CONST_FOR_FN_MSRV: RustcVersion = RustcVersion::new(1, 37, 0);\n+\n declare_clippy_lint! {\n     /// **What it does:**\n     ///\n@@ -69,7 +74,18 @@ declare_clippy_lint! {\n     \"Lint functions definitions that could be made `const fn`\"\n }\n \n-declare_lint_pass!(MissingConstForFn => [MISSING_CONST_FOR_FN]);\n+impl_lint_pass!(MissingConstForFn => [MISSING_CONST_FOR_FN]);\n+\n+pub struct MissingConstForFn {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl MissingConstForFn {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n \n impl<'tcx> LateLintPass<'tcx> for MissingConstForFn {\n     fn check_fn(\n@@ -81,6 +97,10 @@ impl<'tcx> LateLintPass<'tcx> for MissingConstForFn {\n         span: Span,\n         hir_id: HirId,\n     ) {\n+        if !meets_msrv(self.msrv.as_ref(), &MISSING_CONST_FOR_FN_MSRV) {\n+            return;\n+        }\n+\n         let def_id = cx.tcx.hir().local_def_id(hir_id);\n \n         if in_external_macro(cx.tcx.sess, span) || is_entrypoint_fn(cx, def_id.to_def_id()) {\n@@ -99,7 +119,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingConstForFn {\n                 let has_const_generic_params = generics\n                     .params\n                     .iter()\n-                    .any(|param| matches!(param.kind, GenericParamKind::Const{ .. }));\n+                    .any(|param| matches!(param.kind, GenericParamKind::Const { .. }));\n \n                 if already_const(header) || has_const_generic_params {\n                     return;\n@@ -126,6 +146,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingConstForFn {\n             span_lint(cx, MISSING_CONST_FOR_FN, span, \"this could be a `const fn`\");\n         }\n     }\n+    extract_msrv_attr!(LateContext);\n }\n \n /// Returns true if any of the method parameters is a type that implements `Drop`. The method"}, {"sha": "0e49eaab4368578a203c4f14600efa133267a17b", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -2,7 +2,7 @@\n // *rustc*'s\n // [`missing_doc`].\n //\n-// [`missing_doc`]: https://github.com/rust-lang/rust/blob/d6d05904697d89099b55da3331155392f1db9c00/src/librustc_lint/builtin.rs#L246\n+// [`missing_doc`]: https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler/rustc_lint/src/builtin.rs#L415\n //\n \n use crate::utils::span_lint;\n@@ -63,14 +63,21 @@ impl MissingDoc {\n             if let Some(meta) = list.get(0);\n             if let Some(name) = meta.ident();\n             then {\n-                name.as_str() == \"include\"\n+                name.name == sym::include\n             } else {\n                 false\n             }\n         }\n     }\n \n-    fn check_missing_docs_attrs(&self, cx: &LateContext<'_>, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n+    fn check_missing_docs_attrs(\n+        &self,\n+        cx: &LateContext<'_>,\n+        attrs: &[ast::Attribute],\n+        sp: Span,\n+        article: &'static str,\n+        desc: &'static str,\n+    ) {\n         // If we're building a test harness, then warning about\n         // documentation is probably not really relevant right now.\n         if cx.sess().opts.test {\n@@ -94,7 +101,7 @@ impl MissingDoc {\n                 cx,\n                 MISSING_DOCS_IN_PRIVATE_ITEMS,\n                 sp,\n-                &format!(\"missing documentation for {}\", desc),\n+                &format!(\"missing documentation for {} {}\", article, desc),\n             );\n         }\n     }\n@@ -120,13 +127,11 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     }\n \n     fn check_crate(&mut self, cx: &LateContext<'tcx>, krate: &'tcx hir::Crate<'_>) {\n-        self.check_missing_docs_attrs(cx, &krate.item.attrs, krate.item.span, \"crate\");\n+        self.check_missing_docs_attrs(cx, &krate.item.attrs, krate.item.span, \"the\", \"crate\");\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'tcx>, it: &'tcx hir::Item<'_>) {\n-        let desc = match it.kind {\n-            hir::ItemKind::Const(..) => \"a constant\",\n-            hir::ItemKind::Enum(..) => \"an enum\",\n+        match it.kind {\n             hir::ItemKind::Fn(..) => {\n                 // ignore main()\n                 if it.ident.name == sym::main {\n@@ -136,34 +141,35 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n                         return;\n                     }\n                 }\n-                \"a function\"\n             },\n-            hir::ItemKind::Mod(..) => \"a module\",\n-            hir::ItemKind::Static(..) => \"a static\",\n-            hir::ItemKind::Struct(..) => \"a struct\",\n-            hir::ItemKind::Trait(..) => \"a trait\",\n-            hir::ItemKind::TraitAlias(..) => \"a trait alias\",\n-            hir::ItemKind::TyAlias(..) => \"a type alias\",\n-            hir::ItemKind::Union(..) => \"a union\",\n-            hir::ItemKind::OpaqueTy(..) => \"an existential type\",\n+            hir::ItemKind::Const(..)\n+            | hir::ItemKind::Enum(..)\n+            | hir::ItemKind::Mod(..)\n+            | hir::ItemKind::Static(..)\n+            | hir::ItemKind::Struct(..)\n+            | hir::ItemKind::Trait(..)\n+            | hir::ItemKind::TraitAlias(..)\n+            | hir::ItemKind::TyAlias(..)\n+            | hir::ItemKind::Union(..)\n+            | hir::ItemKind::OpaqueTy(..) => {},\n             hir::ItemKind::ExternCrate(..)\n-            | hir::ItemKind::ForeignMod(..)\n+            | hir::ItemKind::ForeignMod { .. }\n             | hir::ItemKind::GlobalAsm(..)\n             | hir::ItemKind::Impl { .. }\n             | hir::ItemKind::Use(..) => return,\n         };\n \n-        self.check_missing_docs_attrs(cx, &it.attrs, it.span, desc);\n+        let def_id = cx.tcx.hir().local_def_id(it.hir_id);\n+        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n+\n+        self.check_missing_docs_attrs(cx, &it.attrs, it.span, article, desc);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, trait_item: &'tcx hir::TraitItem<'_>) {\n-        let desc = match trait_item.kind {\n-            hir::TraitItemKind::Const(..) => \"an associated constant\",\n-            hir::TraitItemKind::Fn(..) => \"a trait method\",\n-            hir::TraitItemKind::Type(..) => \"an associated type\",\n-        };\n+        let def_id = cx.tcx.hir().local_def_id(trait_item.hir_id);\n+        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n \n-        self.check_missing_docs_attrs(cx, &trait_item.attrs, trait_item.span, desc);\n+        self.check_missing_docs_attrs(cx, &trait_item.attrs, trait_item.span, article, desc);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx hir::ImplItem<'_>) {\n@@ -178,21 +184,17 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             },\n         }\n \n-        let desc = match impl_item.kind {\n-            hir::ImplItemKind::Const(..) => \"an associated constant\",\n-            hir::ImplItemKind::Fn(..) => \"a method\",\n-            hir::ImplItemKind::TyAlias(_) => \"an associated type\",\n-        };\n-        self.check_missing_docs_attrs(cx, &impl_item.attrs, impl_item.span, desc);\n+        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n+        self.check_missing_docs_attrs(cx, &impl_item.attrs, impl_item.span, article, desc);\n     }\n \n     fn check_struct_field(&mut self, cx: &LateContext<'tcx>, sf: &'tcx hir::StructField<'_>) {\n         if !sf.is_positional() {\n-            self.check_missing_docs_attrs(cx, &sf.attrs, sf.span, \"a struct field\");\n+            self.check_missing_docs_attrs(cx, &sf.attrs, sf.span, \"a\", \"struct field\");\n         }\n     }\n \n     fn check_variant(&mut self, cx: &LateContext<'tcx>, v: &'tcx hir::Variant<'_>) {\n-        self.check_missing_docs_attrs(cx, &v.attrs, v.span, \"a variant\");\n+        self.check_missing_docs_attrs(cx, &v.attrs, v.span, \"a\", \"variant\");\n     }\n }"}, {"sha": "913d9daff46fd49a680f17ac9f2f207531660bba", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -125,7 +125,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n             | hir::ItemKind::Union(..)\n             | hir::ItemKind::OpaqueTy(..)\n             | hir::ItemKind::ExternCrate(..)\n-            | hir::ItemKind::ForeignMod(..)\n+            | hir::ItemKind::ForeignMod { .. }\n             | hir::ItemKind::Impl { .. }\n             | hir::ItemKind::Use(..) => {},\n         };"}, {"sha": "d795f12645794e2a2f6de2389e62737e8b8ae919", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -3,10 +3,7 @@\n //! This lint is **warn** by default\n \n use crate::utils::sugg::Sugg;\n-use crate::utils::{\n-    higher, is_expn_of, parent_node_is_if_expr, snippet_with_applicability, span_lint, span_lint_and_sugg,\n-};\n-use if_chain::if_chain;\n+use crate::utils::{is_expn_of, parent_node_is_if_expr, snippet_with_applicability, span_lint, span_lint_and_sugg};\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Block, Expr, ExprKind, StmtKind, UnOp};\n@@ -72,7 +69,7 @@ declare_lint_pass!(NeedlessBool => [NEEDLESS_BOOL]);\n impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         use self::Expression::{Bool, RetBool};\n-        if let Some((ref pred, ref then_block, Some(ref else_expr))) = higher::if_block(&e) {\n+        if let ExprKind::If(ref pred, ref then_block, Some(ref else_expr)) = e.kind {\n             let reduce = |ret, not| {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let snip = Sugg::hir_with_applicability(cx, pred, \"<predicate>\", &mut applicability);\n@@ -198,13 +195,9 @@ struct ExpressionInfoWithSpan {\n }\n \n fn is_unary_not(e: &Expr<'_>) -> (bool, Span) {\n-    if_chain! {\n-        if let ExprKind::Unary(unop, operand) = e.kind;\n-        if let UnOp::UnNot = unop;\n-        then {\n-            return (true, operand.span);\n-        }\n-    };\n+    if let ExprKind::Unary(UnOp::UnNot, operand) = e.kind {\n+        return (true, operand.span);\n+    }\n     (false, e.span)\n }\n "}, {"sha": "f1c06692e30d9efcff0840b66e40283a13dbc9ae", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -2,15 +2,14 @@\n //!\n //! This lint is **warn** by default\n \n-use crate::utils::{snippet_opt, span_lint_and_then};\n+use crate::utils::{is_automatically_derived, snippet_opt, span_lint_and_then};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BindingAnnotation, BorrowKind, Expr, ExprKind, HirId, Item, Mutability, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for address of operations (`&`) that are going to\n@@ -47,7 +46,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n             return;\n         }\n         if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, ref inner) = e.kind {\n-            if let ty::Ref(..) = cx.typeck_results().expr_ty(inner).kind() {\n+            if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty(inner).kind() {\n                 for adj3 in cx.typeck_results().expr_adjustments(e).windows(3) {\n                     if let [Adjustment {\n                         kind: Adjust::Deref(_), ..\n@@ -62,8 +61,11 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n                             cx,\n                             NEEDLESS_BORROW,\n                             e.span,\n-                            \"this expression borrows a reference that is immediately dereferenced \\\n+                            &format!(\n+                                \"this expression borrows a reference (`&{}`) that is immediately dereferenced \\\n                              by the compiler\",\n+                                ty\n+                            ),\n                             |diag| {\n                                 if let Some(snippet) = snippet_opt(cx, inner.span) {\n                                     diag.span_suggestion(\n@@ -113,7 +115,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n     }\n \n     fn check_item(&mut self, _: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if item.attrs.iter().any(|a| a.has_name(sym::automatically_derived)) {\n+        if is_automatically_derived(item.attrs) {\n             debug_assert!(self.derived_item.is_none());\n             self.derived_item = Some(item.hir_id);\n         }"}, {"sha": "c8f89f8046c856b992ef771679026b0a1a1fc4bf", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -8,11 +8,12 @@ use rustc_ast::ast::Attribute;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir::intravisit::FnKind;\n-use rustc_hir::{BindingAnnotation, Body, FnDecl, GenericArg, HirId, ItemKind, Node, PatKind, QPath, TyKind};\n+use rustc_hir::{BindingAnnotation, Body, FnDecl, GenericArg, HirId, Impl, ItemKind, Node, PatKind, QPath, TyKind};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, TypeFoldable};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::kw;\n use rustc_span::{sym, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n@@ -90,9 +91,10 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n \n         // Exclude non-inherent impls\n         if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n-            if matches!(item.kind, ItemKind::Impl{ of_trait: Some(_), .. } |\n-                ItemKind::Trait(..))\n-            {\n+            if matches!(\n+                item.kind,\n+                ItemKind::Impl(Impl { of_trait: Some(_), .. }) | ItemKind::Trait(..)\n+            ) {\n                 return;\n             }\n         }\n@@ -152,7 +154,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n             // Ignore `self`s.\n             if idx == 0 {\n                 if let PatKind::Binding(.., ident, _) = arg.pat.kind {\n-                    if ident.as_str() == \"self\" {\n+                    if ident.name == kw::SelfLower {\n                         continue;\n                     }\n                 }"}, {"sha": "9e9b79ee1cf08c227e4209b764e8ca6d7b24fcce", "filename": "clippy_lints/src/needless_question_mark.rs", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_question_mark.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,232 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::{Body, Expr, ExprKind, LangItem, MatchSource, QPath};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::ty::DefIdTree;\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::sym;\n+\n+use crate::utils;\n+use if_chain::if_chain;\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Suggests alternatives for useless applications of `?` in terminating expressions\n+    ///\n+    /// **Why is this bad?** There's no reason to use `?` to short-circuit when execution of the body will end there anyway.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// struct TO {\n+    ///     magic: Option<usize>,\n+    /// }\n+    ///\n+    /// fn f(to: TO) -> Option<usize> {\n+    ///     Some(to.magic?)\n+    /// }\n+    ///\n+    /// struct TR {\n+    ///     magic: Result<usize, bool>,\n+    /// }\n+    ///\n+    /// fn g(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    ///     tr.and_then(|t| Ok(t.magic?))\n+    /// }\n+    ///\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// struct TO {\n+    ///     magic: Option<usize>,\n+    /// }\n+    ///\n+    /// fn f(to: TO) -> Option<usize> {\n+    ///    to.magic\n+    /// }\n+    ///\n+    /// struct TR {\n+    ///     magic: Result<usize, bool>,\n+    /// }\n+    ///\n+    /// fn g(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    ///     tr.and_then(|t| t.magic)\n+    /// }\n+    /// ```\n+    pub NEEDLESS_QUESTION_MARK,\n+    complexity,\n+    \"Suggest `value.inner_option` instead of `Some(value.inner_option?)`. The same goes for `Result<T, E>`.\"\n+}\n+\n+const NEEDLESS_QUESTION_MARK_RESULT_MSRV: RustcVersion = RustcVersion::new(1, 13, 0);\n+const NEEDLESS_QUESTION_MARK_OPTION_MSRV: RustcVersion = RustcVersion::new(1, 22, 0);\n+\n+pub struct NeedlessQuestionMark {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl NeedlessQuestionMark {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(NeedlessQuestionMark => [NEEDLESS_QUESTION_MARK]);\n+\n+#[derive(Debug)]\n+enum SomeOkCall<'a> {\n+    SomeCall(&'a Expr<'a>, &'a Expr<'a>),\n+    OkCall(&'a Expr<'a>, &'a Expr<'a>),\n+}\n+\n+impl LateLintPass<'_> for NeedlessQuestionMark {\n+    /*\n+     * The question mark operator is compatible with both Result<T, E> and Option<T>,\n+     * from Rust 1.13 and 1.22 respectively.\n+     */\n+\n+    /*\n+     * What do we match:\n+     * Expressions that look like this:\n+     * Some(option?), Ok(result?)\n+     *\n+     * Where do we match:\n+     *      Last expression of a body\n+     *      Return statement\n+     *      A body's value (single line closure)\n+     *\n+     * What do we not match:\n+     *      Implicit calls to `from(..)` on the error value\n+     */\n+\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'_ Expr<'_>) {\n+        let e = match &expr.kind {\n+            ExprKind::Ret(Some(e)) => e,\n+            _ => return,\n+        };\n+\n+        if let Some(ok_some_call) = is_some_or_ok_call(self, cx, e) {\n+            emit_lint(cx, &ok_some_call);\n+        }\n+    }\n+\n+    fn check_body(&mut self, cx: &LateContext<'_>, body: &'_ Body<'_>) {\n+        // Function / Closure block\n+        let expr_opt = if let ExprKind::Block(block, _) = &body.value.kind {\n+            block.expr\n+        } else {\n+            // Single line closure\n+            Some(&body.value)\n+        };\n+\n+        if_chain! {\n+            if let Some(expr) = expr_opt;\n+            if let Some(ok_some_call) = is_some_or_ok_call(self, cx, expr);\n+            then {\n+                emit_lint(cx, &ok_some_call);\n+            }\n+        };\n+    }\n+\n+    extract_msrv_attr!(LateContext);\n+}\n+\n+fn emit_lint(cx: &LateContext<'_>, expr: &SomeOkCall<'_>) {\n+    let (entire_expr, inner_expr) = match expr {\n+        SomeOkCall::OkCall(outer, inner) | SomeOkCall::SomeCall(outer, inner) => (outer, inner),\n+    };\n+\n+    utils::span_lint_and_sugg(\n+        cx,\n+        NEEDLESS_QUESTION_MARK,\n+        entire_expr.span,\n+        \"Question mark operator is useless here\",\n+        \"try\",\n+        format!(\"{}\", utils::snippet(cx, inner_expr.span, r#\"\"...\"\"#)),\n+        Applicability::MachineApplicable,\n+    );\n+}\n+\n+fn is_some_or_ok_call<'a>(\n+    nqml: &NeedlessQuestionMark,\n+    cx: &'a LateContext<'_>,\n+    expr: &'a Expr<'_>,\n+) -> Option<SomeOkCall<'a>> {\n+    if_chain! {\n+        // Check outer expression matches CALL_IDENT(ARGUMENT) format\n+        if let ExprKind::Call(path, args) = &expr.kind;\n+        if let ExprKind::Path(QPath::Resolved(None, path)) = &path.kind;\n+        if is_some_ctor(cx, path.res) || is_ok_ctor(cx, path.res);\n+\n+        // Extract inner expression from ARGUMENT\n+        if let ExprKind::Match(inner_expr_with_q, _, MatchSource::TryDesugar) = &args[0].kind;\n+        if let ExprKind::Call(called, args) = &inner_expr_with_q.kind;\n+        if args.len() == 1;\n+\n+        if let ExprKind::Path(QPath::LangItem(LangItem::TryIntoResult, _)) = &called.kind;\n+        then {\n+            // Extract inner expr type from match argument generated by\n+            // question mark operator\n+            let inner_expr = &args[0];\n+\n+            let inner_ty = cx.typeck_results().expr_ty(inner_expr);\n+            let outer_ty = cx.typeck_results().expr_ty(expr);\n+\n+            // Check if outer and inner type are Option\n+            let outer_is_some = utils::is_type_diagnostic_item(cx, outer_ty, sym::option_type);\n+            let inner_is_some = utils::is_type_diagnostic_item(cx, inner_ty, sym::option_type);\n+\n+            // Check for Option MSRV\n+            let meets_option_msrv = utils::meets_msrv(nqml.msrv.as_ref(), &NEEDLESS_QUESTION_MARK_OPTION_MSRV);\n+            if outer_is_some && inner_is_some && meets_option_msrv {\n+                return Some(SomeOkCall::SomeCall(expr, inner_expr));\n+            }\n+\n+            // Check if outer and inner type are Result\n+            let outer_is_result = utils::is_type_diagnostic_item(cx, outer_ty, sym::result_type);\n+            let inner_is_result = utils::is_type_diagnostic_item(cx, inner_ty, sym::result_type);\n+\n+            // Additional check: if the error type of the Result can be converted\n+            // via the From trait, then don't match\n+            let does_not_call_from = !has_implicit_error_from(cx, expr, inner_expr);\n+\n+            // Must meet Result MSRV\n+            let meets_result_msrv = utils::meets_msrv(nqml.msrv.as_ref(), &NEEDLESS_QUESTION_MARK_RESULT_MSRV);\n+            if outer_is_result && inner_is_result && does_not_call_from && meets_result_msrv {\n+                return Some(SomeOkCall::OkCall(expr, inner_expr));\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn has_implicit_error_from(cx: &LateContext<'_>, entire_expr: &Expr<'_>, inner_result_expr: &Expr<'_>) -> bool {\n+    return cx.typeck_results().expr_ty(entire_expr) != cx.typeck_results().expr_ty(inner_result_expr);\n+}\n+\n+fn is_ok_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n+    if let Some(ok_id) = cx.tcx.lang_items().result_ok_variant() {\n+        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n+            if let Some(variant_id) = cx.tcx.parent(id) {\n+                return variant_id == ok_id;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+fn is_some_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n+    if let Some(some_id) = cx.tcx.lang_items().option_some_variant() {\n+        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n+            if let Some(variant_id) = cx.tcx.parent(id) {\n+                return variant_id == some_id;\n+            }\n+        }\n+    }\n+    false\n+}"}, {"sha": "41cf541ecf5ef59d8e814bae9ffde7d72d56f511", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -8,6 +8,9 @@ declare_clippy_lint! {\n     /// **What it does:** Checks for needlessly including a base struct on update\n     /// when all fields are changed anyway.\n     ///\n+    /// This lint is not applied to structs marked with\n+    /// [non_exhaustive](https://doc.rust-lang.org/reference/attributes/type_system.html).\n+    ///\n     /// **Why is this bad?** This will cost resources (because the base has to be\n     /// somewhere), and make the code less readable.\n     ///\n@@ -49,7 +52,9 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessUpdate {\n         if let ExprKind::Struct(_, ref fields, Some(ref base)) = expr.kind {\n             let ty = cx.typeck_results().expr_ty(expr);\n             if let ty::Adt(def, _) = ty.kind() {\n-                if fields.len() == def.non_enum_variant().fields.len() {\n+                if fields.len() == def.non_enum_variant().fields.len()\n+                    && !def.variants[0_usize.into()].is_field_list_non_exhaustive()\n+                {\n                     span_lint(\n                         cx,\n                         NEEDLESS_UPDATE,"}, {"sha": "bd3dac663fe273514bfc7c7c8fe75ef5ffa9f56a", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -60,9 +60,9 @@ impl_lint_pass!(NewWithoutDefault => [NEW_WITHOUT_DEFAULT]);\n impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n     #[allow(clippy::too_many_lines)]\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n-        if let hir::ItemKind::Impl {\n+        if let hir::ItemKind::Impl(hir::Impl {\n             of_trait: None, items, ..\n-        } = item.kind\n+        }) = item.kind\n         {\n             for assoc_item in items {\n                 if let hir::AssocItemKind::Fn { has_self: false } = assoc_item.kind {"}, {"sha": "3a9aa6ced03ba7558d89d7c3ee82af6ce46dca6d", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -7,7 +7,7 @@ use std::ptr;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{\n-    BodyId, Expr, ExprKind, HirId, ImplItem, ImplItemKind, Item, ItemKind, Node, TraitItem, TraitItemKind, UnOp,\n+    BodyId, Expr, ExprKind, HirId, Impl, ImplItem, ImplItemKind, Item, ItemKind, Node, TraitItem, TraitItemKind, UnOp,\n };\n use rustc_infer::traits::specialization_graph;\n use rustc_lint::{LateContext, LateLintPass, Lint};\n@@ -275,10 +275,10 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n             let item = cx.tcx.hir().expect_item(item_hir_id);\n \n             match &item.kind {\n-                ItemKind::Impl {\n+                ItemKind::Impl(Impl {\n                     of_trait: Some(of_trait_ref),\n                     ..\n-                } => {\n+                }) => {\n                     if_chain! {\n                         // Lint a trait impl item only when the definition is a generic type,\n                         // assuming a assoc const is not meant to be a interior mutable type.\n@@ -317,7 +317,7 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                         }\n                     }\n                 },\n-                ItemKind::Impl { of_trait: None, .. } => {\n+                ItemKind::Impl(Impl { of_trait: None, .. }) => {\n                     let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n                     // Normalize assoc types originated from generic params.\n                     let normalized = cx.tcx.normalize_erasing_regions(cx.param_env, ty);"}, {"sha": "446426b3e611f84e8ccad4a21cedab263ffda6ee", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -409,11 +409,10 @@ fn levenstein_not_1(a_name: &str, b_name: &str) -> bool {\n         if let Some(b2) = b_chars.next() {\n             // check if there's just one character inserted\n             return a != b2 || a_chars.ne(b_chars);\n-        } else {\n-            // tuple\n-            // ntuple\n-            return true;\n         }\n+        // tuple\n+        // ntuple\n+        return true;\n     }\n     // for item in items\n     true"}, {"sha": "7bdf975ffd446f82a9c97d0009565f8e084c9364", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -66,7 +66,7 @@ declare_lint_pass!(OptionIfLetElse => [OPTION_IF_LET_ELSE]);\n /// Returns true iff the given expression is the result of calling `Result::ok`\n fn is_result_ok(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n     if let ExprKind::MethodCall(ref path, _, &[ref receiver], _) = &expr.kind {\n-        path.ident.name.to_ident_string() == \"ok\"\n+        path.ident.name.as_str() == \"ok\"\n             && is_type_diagnostic_item(cx, &cx.typeck_results().expr_ty(&receiver), sym::result_type)\n     } else {\n         false\n@@ -109,25 +109,30 @@ fn extract_body_from_arm<'a>(arm: &'a Arm<'a>) -> Option<&'a Expr<'a>> {\n /// it in curly braces. Otherwise, we don't.\n fn should_wrap_in_braces(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     utils::get_enclosing_block(cx, expr.hir_id).map_or(false, |parent| {\n+        let mut should_wrap = false;\n+\n         if let Some(Expr {\n             kind:\n                 ExprKind::Match(\n                     _,\n                     arms,\n-                    MatchSource::IfDesugar {\n-                        contains_else_clause: true,\n-                    }\n-                    | MatchSource::IfLetDesugar {\n+                    MatchSource::IfLetDesugar {\n                         contains_else_clause: true,\n                     },\n                 ),\n             ..\n         }) = parent.expr\n         {\n-            expr.hir_id == arms[1].body.hir_id\n-        } else {\n-            false\n+            should_wrap = expr.hir_id == arms[1].body.hir_id;\n+        } else if let Some(Expr {\n+            kind: ExprKind::If(_, _, Some(else_clause)),\n+            ..\n+        }) = parent.expr\n+        {\n+            should_wrap = expr.hir_id == else_clause.hir_id;\n         }\n+\n+        should_wrap\n     })\n }\n "}, {"sha": "37e2b50def17a389b7473a280f59527f6ed2785b", "filename": "clippy_lints/src/panic_in_result_fn.rs", "status": "modified", "additions": 31, "deletions": 37, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,18 +1,16 @@\n-use crate::utils::{is_expn_of, is_type_diagnostic_item, return_ty, span_lint_and_then};\n+use crate::utils::{find_macro_calls, is_type_diagnostic_item, return_ty, span_lint_and_then};\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{self, FnKind, NestedVisitorMap, Visitor};\n-use rustc_hir::Expr;\n+use rustc_hir::intravisit::FnKind;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for usage of `panic!`, `unimplemented!`, `todo!` or `unreachable!` in a function of type result.\n+    /// **What it does:** Checks for usage of `panic!`, `unimplemented!`, `todo!`, `unreachable!` or assertions in a function of type result.\n     ///\n-    /// **Why is this bad?** For some codebases, it is desirable for functions of type result to return an error instead of crashing. Hence unimplemented, panic and unreachable should be avoided.\n+    /// **Why is this bad?** For some codebases, it is desirable for functions of type result to return an error instead of crashing. Hence panicking macros should be avoided.\n     ///\n-    /// **Known problems:** None.\n+    /// **Known problems:** Functions called from a function returning a `Result` may invoke a panicking macro. This is not checked.\n     ///\n     /// **Example:**\n     ///\n@@ -22,9 +20,15 @@ declare_clippy_lint! {\n     ///     panic!(\"error\");\n     /// }\n     /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn result_without_panic() -> Result<bool, String> {\n+    ///     Err(String::from(\"error\"))\n+    /// }\n+    /// ```\n     pub PANIC_IN_RESULT_FN,\n     restriction,\n-    \"functions of type `Result<..>` that contain `panic!()`, `todo!()` or `unreachable()` or `unimplemented()` \"\n+    \"functions of type `Result<..>` that contain `panic!()`, `todo!()`, `unreachable()`, `unimplemented()` or assertion\"\n }\n \n declare_lint_pass!(PanicInResultFn  => [PANIC_IN_RESULT_FN]);\n@@ -47,43 +51,33 @@ impl<'tcx> LateLintPass<'tcx> for PanicInResultFn {\n     }\n }\n \n-struct FindPanicUnimplementedUnreachable {\n-    result: Vec<Span>,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for FindPanicUnimplementedUnreachable {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if [\"unimplemented\", \"unreachable\", \"panic\", \"todo\"]\n-            .iter()\n-            .any(|fun| is_expn_of(expr.span, fun).is_some())\n-        {\n-            self.result.push(expr.span);\n-        }\n-        // and check sub-expressions\n-        intravisit::walk_expr(self, expr);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, body: &'tcx hir::Body<'tcx>) {\n-    let mut panics = FindPanicUnimplementedUnreachable { result: Vec::new() };\n-    panics.visit_expr(&body.value);\n-    if !panics.result.is_empty() {\n+    let panics = find_macro_calls(\n+        &[\n+            \"unimplemented\",\n+            \"unreachable\",\n+            \"panic\",\n+            \"todo\",\n+            \"assert\",\n+            \"assert_eq\",\n+            \"assert_ne\",\n+            \"debug_assert\",\n+            \"debug_assert_eq\",\n+            \"debug_assert_ne\",\n+        ],\n+        body,\n+    );\n+    if !panics.is_empty() {\n         span_lint_and_then(\n             cx,\n             PANIC_IN_RESULT_FN,\n             impl_span,\n-            \"used `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` in a function that returns `Result`\",\n+            \"used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\",\n             move |diag| {\n                 diag.help(\n-                    \"`unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\",\n+                    \"`unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\",\n                 );\n-                diag.span_note(panics.result, \"return Err() instead of panicking\");\n+                diag.span_note(panics, \"return Err() instead of panicking\");\n             },\n         );\n     }"}, {"sha": "359620cc079752b806be469b03505d40aa4a2e1f", "filename": "clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -66,7 +66,7 @@ declare_clippy_lint! {\n     /// ```\n     pub UNREACHABLE,\n     restriction,\n-    \"`unreachable!` should not be present in production code\"\n+    \"usage of the `unreachable!` macro\"\n }\n \n declare_lint_pass!(PanicUnimplemented => [UNIMPLEMENTED, UNREACHABLE, TODO, PANIC]);\n@@ -85,12 +85,7 @@ impl<'tcx> LateLintPass<'tcx> for PanicUnimplemented {\n             } else if is_expn_of(expr.span, \"todo\").is_some() {\n                 span_lint(cx, TODO, span, \"`todo` should not be present in production code\");\n             } else if is_expn_of(expr.span, \"unreachable\").is_some() {\n-                span_lint(\n-                    cx,\n-                    UNREACHABLE,\n-                    span,\n-                    \"`unreachable` should not be present in production code\",\n-                );\n+                span_lint(cx, UNREACHABLE, span, \"usage of the `unreachable!` macro\");\n             } else if is_expn_of(expr.span, \"panic\").is_some() {\n                 span_lint(cx, PANIC, span, \"`panic` should not be present in production code\");\n             }"}, {"sha": "ed314937ce8beb219ef18d8c407f71acd048e870", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::{is_automatically_derived, span_lint_hir};\n use if_chain::if_chain;\n-use rustc_hir::{Item, ItemKind};\n+use rustc_hir::{Impl, Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -34,7 +34,7 @@ declare_lint_pass!(PartialEqNeImpl => [PARTIALEQ_NE_IMPL]);\n impl<'tcx> LateLintPass<'tcx> for PartialEqNeImpl {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if_chain! {\n-            if let ItemKind::Impl{ of_trait: Some(ref trait_ref), items: impl_items, .. } = item.kind;\n+            if let ItemKind::Impl(Impl { of_trait: Some(ref trait_ref), items: impl_items, .. }) = item.kind;\n             if !is_automatically_derived(&*item.attrs);\n             if let Some(eq_trait) = cx.tcx.lang_items().eq_trait();\n             if trait_ref.path.res.def_id() == eq_trait;"}, {"sha": "d96a9b025f0890e449db1954d9eca346e5cfeac2", "filename": "clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -6,7 +6,7 @@ use rustc_ast::attr;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::intravisit::FnKind;\n-use rustc_hir::{BindingAnnotation, Body, FnDecl, HirId, ItemKind, MutTy, Mutability, Node, PatKind};\n+use rustc_hir::{BindingAnnotation, Body, FnDecl, HirId, Impl, ItemKind, MutTy, Mutability, Node, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -63,7 +63,7 @@ declare_clippy_lint! {\n     ///\n     /// **Why is this bad?** Arguments passed by value might result in an unnecessary\n     /// shallow copy, taking up more space in the stack and requiring a call to\n-    /// `memcpy`, which which can be expensive.\n+    /// `memcpy`, which can be expensive.\n     ///\n     /// **Example:**\n     ///\n@@ -244,9 +244,10 @@ impl<'tcx> LateLintPass<'tcx> for PassByRefOrValue {\n \n         // Exclude non-inherent impls\n         if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n-            if matches!(item.kind, ItemKind::Impl{ of_trait: Some(_), .. } |\n-            ItemKind::Trait(..))\n-            {\n+            if matches!(\n+                item.kind,\n+                ItemKind::Impl(Impl { of_trait: Some(_), .. }) | ItemKind::Trait(..)\n+            ) {\n                 return;\n             }\n         }"}, {"sha": "c6329a1381c909977e947e8f2cda63545bd1d590", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 48, "deletions": 18, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -8,8 +8,8 @@ use crate::utils::{\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{\n-    BinOpKind, BodyId, Expr, ExprKind, FnDecl, FnRetTy, GenericArg, HirId, ImplItem, ImplItemKind, Item, ItemKind,\n-    Lifetime, MutTy, Mutability, Node, PathSegment, QPath, TraitFn, TraitItem, TraitItemKind, Ty, TyKind,\n+    BinOpKind, BodyId, Expr, ExprKind, FnDecl, FnRetTy, GenericArg, HirId, Impl, ImplItem, ImplItemKind, Item,\n+    ItemKind, Lifetime, MutTy, Mutability, Node, PathSegment, QPath, TraitFn, TraitItem, TraitItemKind, Ty, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n@@ -132,7 +132,7 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n         if let ImplItemKind::Fn(ref sig, body_id) = item.kind {\n             let parent_item = cx.tcx.hir().get_parent_item(item.hir_id);\n             if let Some(Node::Item(it)) = cx.tcx.hir().find(parent_item) {\n-                if let ItemKind::Impl { of_trait: Some(_), .. } = it.kind {\n+                if let ItemKind::Impl(Impl { of_trait: Some(_), .. }) = it.kind {\n                     return; // ignore trait impls\n                 }\n             }\n@@ -182,20 +182,6 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n \n         if let ty::Ref(_, ty, Mutability::Not) = ty.kind() {\n             if is_type_diagnostic_item(cx, ty, sym::vec_type) {\n-                let mut ty_snippet = None;\n-                if_chain! {\n-                    if let TyKind::Path(QPath::Resolved(_, ref path)) = walk_ptrs_hir_ty(arg).kind;\n-                    if let Some(&PathSegment{args: Some(ref parameters), ..}) = path.segments.last();\n-                    then {\n-                        let types: Vec<_> = parameters.args.iter().filter_map(|arg| match arg {\n-                            GenericArg::Type(ty) => Some(ty),\n-                            _ => None,\n-                        }).collect();\n-                        if types.len() == 1 {\n-                            ty_snippet = snippet_opt(cx, types[0].span);\n-                        }\n-                    }\n-                };\n                 if let Some(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_owned()\")]) {\n                     span_lint_and_then(\n                         cx,\n@@ -204,7 +190,7 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n                         \"writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used \\\n                          with non-Vec-based slices.\",\n                         |diag| {\n-                            if let Some(ref snippet) = ty_snippet {\n+                            if let Some(ref snippet) = get_only_generic_arg_snippet(cx, arg) {\n                                 diag.span_suggestion(\n                                     arg.span,\n                                     \"change this to\",\n@@ -247,6 +233,33 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n                         },\n                     );\n                 }\n+            } else if match_type(cx, ty, &paths::PATH_BUF) {\n+                if let Some(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_path_buf()\"), (\"as_path\", \"\")]) {\n+                    span_lint_and_then(\n+                        cx,\n+                        PTR_ARG,\n+                        arg.span,\n+                        \"writing `&PathBuf` instead of `&Path` involves a new object where a slice will do.\",\n+                        |diag| {\n+                            diag.span_suggestion(\n+                                arg.span,\n+                                \"change this to\",\n+                                \"&Path\".into(),\n+                                Applicability::Unspecified,\n+                            );\n+                            for (clonespan, suggestion) in spans {\n+                                diag.span_suggestion_short(\n+                                    clonespan,\n+                                    &snippet_opt(cx, clonespan).map_or(\"change the call to\".into(), |x| {\n+                                        Cow::Owned(format!(\"change `{}` to\", x))\n+                                    }),\n+                                    suggestion.into(),\n+                                    Applicability::Unspecified,\n+                                );\n+                            }\n+                        },\n+                    );\n+                }\n             } else if match_type(cx, ty, &paths::COW) {\n                 if_chain! {\n                     if let TyKind::Rptr(_, MutTy { ref ty, ..} ) = arg.kind;\n@@ -309,6 +322,23 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n     }\n }\n \n+fn get_only_generic_arg_snippet(cx: &LateContext<'_>, arg: &Ty<'_>) -> Option<String> {\n+    if_chain! {\n+        if let TyKind::Path(QPath::Resolved(_, ref path)) = walk_ptrs_hir_ty(arg).kind;\n+        if let Some(&PathSegment{args: Some(ref parameters), ..}) = path.segments.last();\n+        let types: Vec<_> = parameters.args.iter().filter_map(|arg| match arg {\n+            GenericArg::Type(ty) => Some(ty),\n+            _ => None,\n+        }).collect();\n+        if types.len() == 1;\n+        then {\n+            snippet_opt(cx, types[0].span)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n fn get_rptr_lm<'tcx>(ty: &'tcx Ty<'tcx>) -> Option<(&'tcx Lifetime, Mutability, Span)> {\n     if let TyKind::Rptr(ref lt, ref m) = ty.kind {\n         Some((lt, m.mutbl, ty.span))"}, {"sha": "6c480d48c7561245a0ab0150e49edcf1a5803f1b", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -8,7 +8,7 @@ use rustc_span::sym;\n \n use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    eq_expr_value, higher, is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet_with_applicability,\n+    eq_expr_value, is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet_with_applicability,\n     span_lint_and_sugg,\n };\n \n@@ -50,7 +50,7 @@ impl QuestionMark {\n     /// If it matches, it will suggest to use the question mark operator instead\n     fn check_is_none_and_early_return_none(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let Some((if_expr, body, else_)) = higher::if_block(&expr);\n+            if let ExprKind::If(if_expr, body, else_) = &expr.kind;\n             if let ExprKind::MethodCall(segment, _, args, _) = &if_expr.kind;\n             if segment.ident.name == sym!(is_none);\n             if Self::expression_returns_none(cx, body);\n@@ -176,8 +176,7 @@ impl QuestionMark {\n             if block.stmts.len() == 1;\n             if let Some(expr) = block.stmts.iter().last();\n             if let StmtKind::Semi(ref expr) = expr.kind;\n-            if let ExprKind::Ret(ret_expr) = expr.kind;\n-            if let Some(ret_expr) = ret_expr;\n+            if let ExprKind::Ret(Some(ret_expr)) = expr.kind;\n \n             then {\n                 return Some(ret_expr);"}, {"sha": "3e454eecd970e37b85dfb0d150f13e3715b5d136", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -3,18 +3,19 @@ use if_chain::if_chain;\n use rustc_ast::ast::RangeLimits;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, PathSegment, QPath};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::sym;\n use rustc_span::symbol::Ident;\n use std::cmp::Ordering;\n \n use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    get_parent_expr, is_integer_const, single_segment_path, snippet, snippet_opt, snippet_with_applicability,\n-    span_lint, span_lint_and_sugg, span_lint_and_then,\n+    get_parent_expr, in_constant, is_integer_const, meets_msrv, single_segment_path, snippet, snippet_opt,\n+    snippet_with_applicability, span_lint, span_lint_and_sugg, span_lint_and_then,\n };\n use crate::utils::{higher, SpanlessEq};\n \n@@ -160,7 +161,20 @@ declare_clippy_lint! {\n     \"manually reimplementing {`Range`, `RangeInclusive`}`::contains`\"\n }\n \n-declare_lint_pass!(Ranges => [\n+const MANUAL_RANGE_CONTAINS_MSRV: RustcVersion = RustcVersion::new(1, 35, 0);\n+\n+pub struct Ranges {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl Ranges {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(Ranges => [\n     RANGE_ZIP_WITH_LEN,\n     RANGE_PLUS_ONE,\n     RANGE_MINUS_ONE,\n@@ -175,7 +189,9 @@ impl<'tcx> LateLintPass<'tcx> for Ranges {\n                 check_range_zip_with_len(cx, path, args, expr.span);\n             },\n             ExprKind::Binary(ref op, ref l, ref r) => {\n-                check_possible_range_contains(cx, op.node, l, r, expr.span);\n+                if meets_msrv(self.msrv.as_ref(), &MANUAL_RANGE_CONTAINS_MSRV) {\n+                    check_possible_range_contains(cx, op.node, l, r, expr);\n+                }\n             },\n             _ => {},\n         }\n@@ -184,9 +200,15 @@ impl<'tcx> LateLintPass<'tcx> for Ranges {\n         check_inclusive_range_minus_one(cx, expr);\n         check_reversed_empty_range(cx, expr);\n     }\n+    extract_msrv_attr!(LateContext);\n }\n \n-fn check_possible_range_contains(cx: &LateContext<'_>, op: BinOpKind, l: &Expr<'_>, r: &Expr<'_>, span: Span) {\n+fn check_possible_range_contains(cx: &LateContext<'_>, op: BinOpKind, l: &Expr<'_>, r: &Expr<'_>, expr: &Expr<'_>) {\n+    if in_constant(cx, expr.hir_id) {\n+        return;\n+    }\n+\n+    let span = expr.span;\n     let combine_and = match op {\n         BinOpKind::And | BinOpKind::BitAnd => true,\n         BinOpKind::Or | BinOpKind::BitOr => false,"}, {"sha": "06adbb523d706288c4e1a98b8a990fb188af7313", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -390,7 +390,10 @@ impl<'tcx> mir::visit::Visitor<'tcx> for LocalUseVisitor {\n         let local = place.local;\n \n         if local == self.used.0\n-            && !matches!(ctx, PlaceContext::MutatingUse(MutatingUseContext::Drop) | PlaceContext::NonUse(_))\n+            && !matches!(\n+                ctx,\n+                PlaceContext::MutatingUse(MutatingUseContext::Drop) | PlaceContext::NonUse(_)\n+            )\n         {\n             self.used.1 = true;\n         }"}, {"sha": "f398b3fff25a328ec6b5d94c249a9e78de88fef5", "filename": "clippy_lints/src/redundant_closure_call.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_closure_call.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -104,7 +104,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClosureCall {\n                 cx: &'a LateContext<'tcx>,\n                 path: &'tcx hir::Path<'tcx>,\n                 count: usize,\n-            };\n+            }\n             impl<'a, 'tcx> hir_visit::Visitor<'tcx> for ClosureUsageCount<'a, 'tcx> {\n                 type Map = Map<'tcx>;\n \n@@ -124,7 +124,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClosureCall {\n                 fn nested_visit_map(&mut self) -> hir_visit::NestedVisitorMap<Self::Map> {\n                     hir_visit::NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n                 }\n-            };\n+            }\n             let mut closure_usage_count = ClosureUsageCount { cx, path, count: 0 };\n             closure_usage_count.visit_block(block);\n             closure_usage_count.count"}, {"sha": "3d585cd27a3d07c9a5e808526767eae4cdaacd8d", "filename": "clippy_lints/src/redundant_else.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fredundant_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fredundant_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_else.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,135 @@\n+use crate::utils::span_lint_and_help;\n+use rustc_ast::ast::{Block, Expr, ExprKind, Stmt, StmtKind};\n+use rustc_ast::visit::{walk_expr, Visitor};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `else` blocks that can be removed without changing semantics.\n+    ///\n+    /// **Why is this bad?** The `else` block adds unnecessary indentation and verbosity.\n+    ///\n+    /// **Known problems:** Some may prefer to keep the `else` block for clarity.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// fn my_func(count: u32) {\n+    ///     if count == 0 {\n+    ///         print!(\"Nothing to do\");\n+    ///         return;\n+    ///     } else {\n+    ///         print!(\"Moving on...\");\n+    ///     }\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn my_func(count: u32) {\n+    ///     if count == 0 {\n+    ///         print!(\"Nothing to do\");\n+    ///         return;\n+    ///     }\n+    ///     print!(\"Moving on...\");\n+    /// }\n+    /// ```\n+    pub REDUNDANT_ELSE,\n+    pedantic,\n+    \"`else` branch that can be removed without changing semantics\"\n+}\n+\n+declare_lint_pass!(RedundantElse => [REDUNDANT_ELSE]);\n+\n+impl EarlyLintPass for RedundantElse {\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, stmt: &Stmt) {\n+        if in_external_macro(cx.sess, stmt.span) {\n+            return;\n+        }\n+        // Only look at expressions that are a whole statement\n+        let expr: &Expr = match &stmt.kind {\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr,\n+            _ => return,\n+        };\n+        // if else\n+        let (mut then, mut els): (&Block, &Expr) = match &expr.kind {\n+            ExprKind::If(_, then, Some(els)) => (then, els),\n+            _ => return,\n+        };\n+        loop {\n+            if !BreakVisitor::default().check_block(then) {\n+                // then block does not always break\n+                return;\n+            }\n+            match &els.kind {\n+                // else if else\n+                ExprKind::If(_, next_then, Some(next_els)) => {\n+                    then = next_then;\n+                    els = next_els;\n+                    continue;\n+                },\n+                // else if without else\n+                ExprKind::If(..) => return,\n+                // done\n+                _ => break,\n+            }\n+        }\n+        span_lint_and_help(\n+            cx,\n+            REDUNDANT_ELSE,\n+            els.span,\n+            \"redundant else block\",\n+            None,\n+            \"remove the `else` block and move the contents out\",\n+        );\n+    }\n+}\n+\n+/// Call `check` functions to check if an expression always breaks control flow\n+#[derive(Default)]\n+struct BreakVisitor {\n+    is_break: bool,\n+}\n+\n+impl<'ast> Visitor<'ast> for BreakVisitor {\n+    fn visit_block(&mut self, block: &'ast Block) {\n+        self.is_break = match block.stmts.as_slice() {\n+            [.., last] => self.check_stmt(last),\n+            _ => false,\n+        };\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'ast Expr) {\n+        self.is_break = match expr.kind {\n+            ExprKind::Break(..) | ExprKind::Continue(..) | ExprKind::Ret(..) => true,\n+            ExprKind::Match(_, ref arms) => arms.iter().all(|arm| self.check_expr(&arm.body)),\n+            ExprKind::If(_, ref then, Some(ref els)) => self.check_block(then) && self.check_expr(els),\n+            ExprKind::If(_, _, None)\n+            // ignore loops for simplicity\n+            | ExprKind::While(..) | ExprKind::ForLoop(..) | ExprKind::Loop(..) => false,\n+            _ => {\n+                walk_expr(self, expr);\n+                return;\n+            },\n+        };\n+    }\n+}\n+\n+impl BreakVisitor {\n+    fn check<T>(&mut self, item: T, visit: fn(&mut Self, T)) -> bool {\n+        visit(self, item);\n+        std::mem::replace(&mut self.is_break, false)\n+    }\n+\n+    fn check_block(&mut self, block: &Block) -> bool {\n+        self.check(block, Self::visit_block)\n+    }\n+\n+    fn check_expr(&mut self, expr: &Expr) -> bool {\n+        self.check(expr, Self::visit_expr)\n+    }\n+\n+    fn check_stmt(&mut self, stmt: &Stmt) -> bool {\n+        self.check(stmt, Self::visit_stmt)\n+    }\n+}"}, {"sha": "38dcf7a192c823beadf6e5a07e43f3c013eac754", "filename": "clippy_lints/src/redundant_field_names.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_field_names.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,9 +1,12 @@\n-use crate::utils::span_lint_and_sugg;\n+use crate::utils::{meets_msrv, span_lint_and_sugg};\n use rustc_ast::ast::{Expr, ExprKind};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_middle::lint::in_external_macro;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+const REDUNDANT_FIELD_NAMES_MSRV: RustcVersion = RustcVersion::new(1, 17, 0);\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for fields in struct literals where shorthands\n@@ -33,10 +36,25 @@ declare_clippy_lint! {\n     \"checks for fields in struct literals where shorthands could be used\"\n }\n \n-declare_lint_pass!(RedundantFieldNames => [REDUNDANT_FIELD_NAMES]);\n+pub struct RedundantFieldNames {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl RedundantFieldNames {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(RedundantFieldNames => [REDUNDANT_FIELD_NAMES]);\n \n impl EarlyLintPass for RedundantFieldNames {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n+        if !meets_msrv(self.msrv.as_ref(), &REDUNDANT_FIELD_NAMES_MSRV) {\n+            return;\n+        }\n+\n         if in_external_macro(cx.sess, expr.span) {\n             return;\n         }\n@@ -64,4 +82,5 @@ impl EarlyLintPass for RedundantFieldNames {\n             }\n         }\n     }\n+    extract_msrv_attr!(EarlyContext);\n }"}, {"sha": "e5ced13514f793088205d3a3b0284355f3cc6852", "filename": "clippy_lints/src/redundant_slicing.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fredundant_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fredundant_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_slicing.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,67 @@\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, LangItem};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::{lint::in_external_macro, ty::TyS};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use crate::utils::{is_type_lang_item, snippet_with_applicability, span_lint_and_sugg};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for redundant slicing expressions which use the full range, and\n+    /// do not change the type.\n+    ///\n+    /// **Why is this bad?** It unnecessarily adds complexity to the expression.\n+    ///\n+    /// **Known problems:** If the type being sliced has an implementation of `Index<RangeFull>`\n+    /// that actually changes anything then it can't be removed. However, this would be surprising\n+    /// to people reading the code and should have a note with it.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```ignore\n+    /// fn get_slice(x: &[u32]) -> &[u32] {\n+    ///     &x[..]\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```ignore\n+    /// fn get_slice(x: &[u32]) -> &[u32] {\n+    ///     x\n+    /// }\n+    /// ```\n+    pub REDUNDANT_SLICING,\n+    complexity,\n+    \"redundant slicing of the whole range of a type\"\n+}\n+\n+declare_lint_pass!(RedundantSlicing => [REDUNDANT_SLICING]);\n+\n+impl LateLintPass<'_> for RedundantSlicing {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if in_external_macro(cx.sess(), expr.span) {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let ExprKind::AddrOf(_, _, addressee) = expr.kind;\n+            if let ExprKind::Index(indexed, range) = addressee.kind;\n+            if is_type_lang_item(cx, cx.typeck_results().expr_ty_adjusted(range), LangItem::RangeFull);\n+            if TyS::same_type(cx.typeck_results().expr_ty(expr), cx.typeck_results().expr_ty(indexed));\n+            then {\n+                let mut app = Applicability::MachineApplicable;\n+                let hint = snippet_with_applicability(cx, indexed.span, \"..\", &mut app).into_owned();\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    REDUNDANT_SLICING,\n+                    expr.span,\n+                    \"redundant slicing of the whole range\",\n+                    \"use the original slice instead\",\n+                    hint,\n+                    app,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "fcfa3c12755af37e0979aac06021a48ee8473d99", "filename": "clippy_lints/src/redundant_static_lifetimes.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,8 +1,11 @@\n-use crate::utils::{snippet, span_lint_and_then};\n+use crate::utils::{meets_msrv, snippet, span_lint_and_then};\n use rustc_ast::ast::{Item, ItemKind, Ty, TyKind};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+const REDUNDANT_STATIC_LIFETIMES_MSRV: RustcVersion = RustcVersion::new(1, 17, 0);\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for constants and statics with an explicit `'static` lifetime.\n@@ -29,7 +32,18 @@ declare_clippy_lint! {\n     \"Using explicit `'static` lifetime for constants or statics when elision rules would allow omitting them.\"\n }\n \n-declare_lint_pass!(RedundantStaticLifetimes => [REDUNDANT_STATIC_LIFETIMES]);\n+pub struct RedundantStaticLifetimes {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl RedundantStaticLifetimes {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(RedundantStaticLifetimes => [REDUNDANT_STATIC_LIFETIMES]);\n \n impl RedundantStaticLifetimes {\n     // Recursively visit types\n@@ -84,6 +98,10 @@ impl RedundantStaticLifetimes {\n \n impl EarlyLintPass for RedundantStaticLifetimes {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n+        if !meets_msrv(self.msrv.as_ref(), &REDUNDANT_STATIC_LIFETIMES_MSRV) {\n+            return;\n+        }\n+\n         if !item.span.from_expansion() {\n             if let ItemKind::Const(_, ref var_type, _) = item.kind {\n                 self.visit_type(var_type, cx, \"constants have by default a `'static` lifetime\");\n@@ -96,4 +114,6 @@ impl EarlyLintPass for RedundantStaticLifetimes {\n             }\n         }\n     }\n+\n+    extract_msrv_attr!(EarlyContext);\n }"}, {"sha": "8cd6692ce03a09ceb9b42647865d101ec3c42771", "filename": "clippy_lints/src/ref_option_ref.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fref_option_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fref_option_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fref_option_ref.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -2,6 +2,7 @@ use crate::utils::{last_path_segment, snippet, span_lint_and_sugg};\n use rustc_hir::{GenericArg, Mutability, Ty, TyKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::sym;\n \n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -12,7 +13,7 @@ declare_clippy_lint! {\n     /// **Why is this bad?** Since `&` is Copy, it's useless to have a\n     /// reference on `Option<&T>`.\n     ///\n-    /// **Known problems:** It may be irrevelent to use this lint on\n+    /// **Known problems:** It may be irrelevant to use this lint on\n     /// public API code as it will make a breaking change to apply it.\n     ///\n     /// **Example:**\n@@ -41,7 +42,7 @@ impl<'tcx> LateLintPass<'tcx> for RefOptionRef {\n             if let Some(res) = last.res;\n             if let Some(def_id) = res.opt_def_id();\n \n-            if cx.tcx.is_diagnostic_item(sym!(option_type), def_id);\n+            if cx.tcx.is_diagnostic_item(sym::option_type, def_id);\n             if let Some(ref params) = last_path_segment(qpath).args ;\n             if !params.parenthesized;\n             if let Some(inner_ty) = params.args.iter().find_map(|arg| match arg {"}, {"sha": "e438f92b136ac453745d0f35cbfb85f52cf024da", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -131,7 +131,16 @@ impl<'tcx> LateLintPass<'tcx> for Return {\n         _: HirId,\n     ) {\n         match kind {\n-            FnKind::Closure(_) => check_final_expr(cx, &body.value, Some(body.value.span), RetReplacement::Empty),\n+            FnKind::Closure(_) => {\n+                // when returning without value in closure, replace this `return`\n+                // with an empty block to prevent invalid suggestion (see #6501)\n+                let replacement = if let ExprKind::Ret(None) = &body.value.kind {\n+                    RetReplacement::Block\n+                } else {\n+                    RetReplacement::Empty\n+                };\n+                check_final_expr(cx, &body.value, Some(body.value.span), replacement)\n+            },\n             FnKind::ItemFn(..) | FnKind::Method(..) => {\n                 if let ExprKind::Block(ref block, _) = body.value.kind {\n                     check_block_return(cx, block);\n@@ -184,6 +193,14 @@ fn check_final_expr<'tcx>(\n         ExprKind::Block(ref block, _) => {\n             check_block_return(cx, block);\n         },\n+        ExprKind::If(_, then, else_clause_opt) => {\n+            if let ExprKind::Block(ref ifblock, _) = then.kind {\n+                check_block_return(cx, ifblock);\n+            }\n+            if let Some(else_clause) = else_clause_opt {\n+                check_final_expr(cx, else_clause, None, RetReplacement::Empty);\n+            }\n+        },\n         // a match expr, check all arms\n         // an if/if let expr, check both exprs\n         // note, if without else is going to be a type checking error anyways\n@@ -194,10 +211,7 @@ fn check_final_expr<'tcx>(\n                     check_final_expr(cx, &arm.body, Some(arm.body.span), RetReplacement::Block);\n                 }\n             },\n-            MatchSource::IfDesugar {\n-                contains_else_clause: true,\n-            }\n-            | MatchSource::IfLetDesugar {\n+            MatchSource::IfLetDesugar {\n                 contains_else_clause: true,\n             } => {\n                 if let ExprKind::Block(ref ifblock, _) = arms[0].body.kind {\n@@ -212,6 +226,9 @@ fn check_final_expr<'tcx>(\n }\n \n fn emit_return_lint(cx: &LateContext<'_>, ret_span: Span, inner_span: Option<Span>, replacement: RetReplacement) {\n+    if ret_span.from_expansion() {\n+        return;\n+    }\n     match inner_span {\n         Some(inner_span) => {\n             if in_external_macro(cx.tcx.sess, inner_span) || inner_span.from_expansion() {"}, {"sha": "44e739725c82055a5f991fe7f41ccc630fe13590", "filename": "clippy_lints/src/serde_api.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fserde_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fserde_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde_api.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::{get_trait_def_id, paths, span_lint};\n-use rustc_hir::{Item, ItemKind};\n+use rustc_hir::{Impl, Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -22,11 +22,11 @@ declare_lint_pass!(SerdeAPI => [SERDE_API_MISUSE]);\n \n impl<'tcx> LateLintPass<'tcx> for SerdeAPI {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if let ItemKind::Impl {\n+        if let ItemKind::Impl(Impl {\n             of_trait: Some(ref trait_ref),\n             items,\n             ..\n-        } = item.kind\n+        }) = item.kind\n         {\n             let did = trait_ref.path.res.def_id();\n             if let Some(visit_did) = get_trait_def_id(cx, &paths::SERDE_DE_VISITOR) {"}, {"sha": "24da056770c9d18366936e92f3440655ab70e1ae", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -333,6 +333,13 @@ fn check_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, bindings: &mut\n                 check_expr(cx, e, bindings)\n             }\n         },\n+        ExprKind::If(ref cond, ref then, ref otherwise) => {\n+            check_expr(cx, cond, bindings);\n+            check_expr(cx, &**then, bindings);\n+            if let Some(ref o) = *otherwise {\n+                check_expr(cx, o, bindings);\n+            }\n+        },\n         ExprKind::Match(ref init, arms, _) => {\n             check_expr(cx, init, bindings);\n             let len = bindings.len();\n@@ -342,6 +349,10 @@ fn check_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, bindings: &mut\n                 if let Some(ref guard) = arm.guard {\n                     match guard {\n                         Guard::If(if_expr) => check_expr(cx, if_expr, bindings),\n+                        Guard::IfLet(guard_pat, guard_expr) => {\n+                            check_pat(cx, guard_pat, Some(*guard_expr), guard_pat.span, bindings);\n+                            check_expr(cx, guard_expr, bindings);\n+                        },\n                     }\n                 }\n                 check_expr(cx, &arm.body, bindings);\n@@ -385,5 +396,5 @@ fn is_self_shadow(name: Symbol, expr: &Expr<'_>) -> bool {\n }\n \n fn path_eq_name(name: Symbol, path: &Path<'_>) -> bool {\n-    !path.is_global() && path.segments.len() == 1 && path.segments[0].ident.as_str() == name.as_str()\n+    !path.is_global() && path.segments.len() == 1 && path.segments[0].ident.name == name\n }"}, {"sha": "1fc4ff5c2e61fcad025432b360ce6c422e8a933c", "filename": "clippy_lints/src/single_component_path_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsingle_component_path_imports.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -40,7 +40,7 @@ impl EarlyLintPass for SingleComponentPathImports {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n         if_chain! {\n             if !in_macro(item.span);\n-            if cx.sess.opts.edition == Edition::Edition2018;\n+            if cx.sess.opts.edition >= Edition::Edition2018;\n             if !item.vis.kind.is_pub();\n             if let ItemKind::Use(use_tree) = &item.kind;\n             if let segments = &use_tree.prefix.segments;"}, {"sha": "ea7a76146f52c3bf9aad1eaac7b9824f5594aca8", "filename": "clippy_lints/src/size_of_in_element_count.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsize_of_in_element_count.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,145 @@\n+//! Lint on use of `size_of` or `size_of_val` of T in an expression\n+//! expecting a count of T\n+\n+use crate::utils::{match_def_path, paths, span_lint_and_help};\n+use if_chain::if_chain;\n+use rustc_hir::BinOpKind;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{self, Ty, TyS, TypeAndMut};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Detects expressions where\n+    /// `size_of::<T>` or `size_of_val::<T>` is used as a\n+    /// count of elements of type `T`\n+    ///\n+    /// **Why is this bad?** These functions expect a count\n+    /// of `T` and not a number of bytes\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,no_run\n+    /// # use std::ptr::copy_nonoverlapping;\n+    /// # use std::mem::size_of;\n+    /// const SIZE: usize = 128;\n+    /// let x = [2u8; SIZE];\n+    /// let mut y = [2u8; SIZE];\n+    /// unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * SIZE) };\n+    /// ```\n+    pub SIZE_OF_IN_ELEMENT_COUNT,\n+    correctness,\n+    \"using `size_of::<T>` or `size_of_val::<T>` where a count of elements of `T` is expected\"\n+}\n+\n+declare_lint_pass!(SizeOfInElementCount => [SIZE_OF_IN_ELEMENT_COUNT]);\n+\n+fn get_size_of_ty(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<Ty<'tcx>> {\n+    match expr.kind {\n+        ExprKind::Call(count_func, _func_args) => {\n+            if_chain! {\n+                if let ExprKind::Path(ref count_func_qpath) = count_func.kind;\n+                if let Some(def_id) = cx.qpath_res(count_func_qpath, count_func.hir_id).opt_def_id();\n+                if match_def_path(cx, def_id, &paths::MEM_SIZE_OF)\n+                    || match_def_path(cx, def_id, &paths::MEM_SIZE_OF_VAL);\n+                then {\n+                    cx.typeck_results().node_substs(count_func.hir_id).types().next()\n+                } else {\n+                    None\n+                }\n+            }\n+        },\n+        ExprKind::Binary(op, left, right) if BinOpKind::Mul == op.node || BinOpKind::Div == op.node => {\n+            get_size_of_ty(cx, left).or_else(|| get_size_of_ty(cx, right))\n+        },\n+        ExprKind::Cast(expr, _) => get_size_of_ty(cx, expr),\n+        _ => None,\n+    }\n+}\n+\n+fn get_pointee_ty_and_count_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<(Ty<'tcx>, &'tcx Expr<'tcx>)> {\n+    const FUNCTIONS: [&[&str]; 8] = [\n+        &paths::COPY_NONOVERLAPPING,\n+        &paths::COPY,\n+        &paths::WRITE_BYTES,\n+        &paths::PTR_SWAP_NONOVERLAPPING,\n+        &paths::PTR_SLICE_FROM_RAW_PARTS,\n+        &paths::PTR_SLICE_FROM_RAW_PARTS_MUT,\n+        &paths::SLICE_FROM_RAW_PARTS,\n+        &paths::SLICE_FROM_RAW_PARTS_MUT,\n+    ];\n+    const METHODS: [&str; 11] = [\n+        \"write_bytes\",\n+        \"copy_to\",\n+        \"copy_from\",\n+        \"copy_to_nonoverlapping\",\n+        \"copy_from_nonoverlapping\",\n+        \"add\",\n+        \"wrapping_add\",\n+        \"sub\",\n+        \"wrapping_sub\",\n+        \"offset\",\n+        \"wrapping_offset\",\n+    ];\n+\n+    if_chain! {\n+        // Find calls to ptr::{copy, copy_nonoverlapping}\n+        // and ptr::{swap_nonoverlapping, write_bytes},\n+        if let ExprKind::Call(func, [.., count]) = expr.kind;\n+        if let ExprKind::Path(ref func_qpath) = func.kind;\n+        if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n+        if FUNCTIONS.iter().any(|func_path| match_def_path(cx, def_id, func_path));\n+\n+        // Get the pointee type\n+        if let Some(pointee_ty) = cx.typeck_results().node_substs(func.hir_id).types().next();\n+        then {\n+            return Some((pointee_ty, count));\n+        }\n+    };\n+    if_chain! {\n+        // Find calls to copy_{from,to}{,_nonoverlapping} and write_bytes methods\n+        if let ExprKind::MethodCall(method_path, _, [ptr_self, .., count], _) = expr.kind;\n+        let method_ident = method_path.ident.as_str();\n+        if METHODS.iter().any(|m| *m == &*method_ident);\n+\n+        // Get the pointee type\n+        if let ty::RawPtr(TypeAndMut { ty: pointee_ty, .. }) =\n+            cx.typeck_results().expr_ty(ptr_self).kind();\n+        then {\n+            return Some((pointee_ty, count));\n+        }\n+    };\n+    None\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for SizeOfInElementCount {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        const HELP_MSG: &str = \"use a count of elements instead of a count of bytes\\\n+            , it already gets multiplied by the size of the type\";\n+\n+        const LINT_MSG: &str = \"found a count of bytes \\\n+             instead of a count of elements of `T`\";\n+\n+        if_chain! {\n+            // Find calls to functions with an element count parameter and get\n+            // the pointee type and count parameter expression\n+            if let Some((pointee_ty, count_expr)) = get_pointee_ty_and_count_expr(cx, expr);\n+\n+            // Find a size_of call in the count parameter expression and\n+            // check that it's the same type\n+            if let Some(ty_used_for_size_of) = get_size_of_ty(cx, count_expr);\n+            if TyS::same_type(pointee_ty, ty_used_for_size_of);\n+            then {\n+                span_lint_and_help(\n+                    cx,\n+                    SIZE_OF_IN_ELEMENT_COUNT,\n+                    count_expr.span,\n+                    LINT_MSG,\n+                    None,\n+                    HELP_MSG\n+                );\n+            }\n+        };\n+    }\n+}"}, {"sha": "31dd5965473d3e9c0affb5c1f2a627de8cda1ff8", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -222,8 +222,7 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n             if method_names[0] == sym!(as_bytes);\n \n             // Check for slicer\n-            if let ExprKind::Struct(ref path, _, _) = right.kind;\n-            if let QPath::LangItem(LangItem::Range, _) = path;\n+            if let ExprKind::Struct(QPath::LangItem(LangItem::Range, _), _, _) = right.kind;\n \n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n@@ -373,7 +372,7 @@ impl LateLintPass<'_> for StringToString {\n             if let ExprKind::MethodCall(path, _, args, _) = &expr.kind;\n             if path.ident.name == sym!(to_string);\n             let ty = cx.typeck_results().expr_ty(&args[0]);\n-            if is_type_diagnostic_item(cx, ty, sym!(string_type));\n+            if is_type_diagnostic_item(cx, ty, sym::string_type);\n             then {\n                 span_lint_and_help(\n                     cx,"}, {"sha": "cccd24ccf9401eaca5085f88601deb18f0dc9189", "filename": "clippy_lints/src/suspicious_operation_groupings.rs", "status": "added", "additions": 693, "deletions": 0, "changes": 693, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,693 @@\n+use crate::utils::ast_utils::{eq_id, is_useless_with_eq_exprs, IdentIter};\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n+use core::ops::{Add, AddAssign};\n+use if_chain::if_chain;\n+use rustc_ast::ast::{BinOpKind, Expr, ExprKind, StmtKind};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Spanned;\n+use rustc_span::symbol::Ident;\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Checks for unlikely usages of binary operators that are almost\n+    /// certainly typos and/or copy/paste errors, given the other usages\n+    /// of binary operators nearby.\n+    /// **Why is this bad?**\n+    /// They are probably bugs and if they aren't then they look like bugs\n+    /// and you should add a comment explaining why you are doing such an\n+    /// odd set of operations.\n+    /// **Known problems:**\n+    /// There may be some false positives if you are trying to do something\n+    /// unusual that happens to look like a typo.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// struct Vec3 {\n+    ///     x: f64,\n+    ///     y: f64,\n+    ///     z: f64,\n+    /// }\n+    ///\n+    /// impl Eq for Vec3 {}\n+    ///\n+    /// impl PartialEq for Vec3 {\n+    ///     fn eq(&self, other: &Self) -> bool {\n+    ///         // This should trigger the lint because `self.x` is compared to `other.y`\n+    ///         self.x == other.y && self.y == other.y && self.z == other.z\n+    ///     }\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # struct Vec3 {\n+    /// #     x: f64,\n+    /// #     y: f64,\n+    /// #     z: f64,\n+    /// # }\n+    /// // same as above except:\n+    /// impl PartialEq for Vec3 {\n+    ///     fn eq(&self, other: &Self) -> bool {\n+    ///         // Note we now compare other.x to self.x\n+    ///         self.x == other.x && self.y == other.y && self.z == other.z\n+    ///     }\n+    /// }\n+    /// ```\n+    pub SUSPICIOUS_OPERATION_GROUPINGS,\n+    style,\n+    \"groupings of binary operations that look suspiciously like typos\"\n+}\n+\n+declare_lint_pass!(SuspiciousOperationGroupings => [SUSPICIOUS_OPERATION_GROUPINGS]);\n+\n+impl EarlyLintPass for SuspiciousOperationGroupings {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n+        if expr.span.from_expansion() {\n+            return;\n+        }\n+\n+        if let Some(binops) = extract_related_binops(&expr.kind) {\n+            check_binops(cx, &binops.iter().collect::<Vec<_>>());\n+\n+            let mut op_types = Vec::with_capacity(binops.len());\n+            // We could use a hashmap, etc. to avoid being O(n*m) here, but\n+            // we want the lints to be emitted in a consistent order. Besides,\n+            // m, (the number of distinct `BinOpKind`s in `binops`)\n+            // will often be small, and does have an upper limit.\n+            binops.iter().map(|b| b.op).for_each(|op| {\n+                if !op_types.contains(&op) {\n+                    op_types.push(op);\n+                }\n+            });\n+\n+            for op_type in op_types {\n+                let ops: Vec<_> = binops.iter().filter(|b| b.op == op_type).collect();\n+\n+                check_binops(cx, &ops);\n+            }\n+        }\n+    }\n+}\n+\n+fn check_binops(cx: &EarlyContext<'_>, binops: &[&BinaryOp<'_>]) {\n+    let binop_count = binops.len();\n+    if binop_count < 2 {\n+        // Single binary operation expressions would likely be false\n+        // positives.\n+        return;\n+    }\n+\n+    let mut one_ident_difference_count = 0;\n+    let mut no_difference_info = None;\n+    let mut double_difference_info = None;\n+    let mut expected_ident_loc = None;\n+\n+    let mut paired_identifiers = FxHashSet::default();\n+\n+    for (i, BinaryOp { left, right, op, .. }) in binops.iter().enumerate() {\n+        match ident_difference_expr(left, right) {\n+            IdentDifference::NoDifference => {\n+                if is_useless_with_eq_exprs(*op) {\n+                    // The `eq_op` lint should catch this in this case.\n+                    return;\n+                }\n+\n+                no_difference_info = Some(i);\n+            },\n+            IdentDifference::Single(ident_loc) => {\n+                one_ident_difference_count += 1;\n+                if let Some(previous_expected) = expected_ident_loc {\n+                    if previous_expected != ident_loc {\n+                        // This expression doesn't match the form we're\n+                        // looking for.\n+                        return;\n+                    }\n+                } else {\n+                    expected_ident_loc = Some(ident_loc);\n+                }\n+\n+                // If there was only a single difference, all other idents\n+                // must have been the same, and thus were paired.\n+                for id in skip_index(IdentIter::from(*left), ident_loc.index) {\n+                    paired_identifiers.insert(id);\n+                }\n+            },\n+            IdentDifference::Double(ident_loc1, ident_loc2) => {\n+                double_difference_info = Some((i, ident_loc1, ident_loc2));\n+            },\n+            IdentDifference::Multiple | IdentDifference::NonIdent => {\n+                // It's too hard to know whether this is a bug or not.\n+                return;\n+            },\n+        }\n+    }\n+\n+    let mut applicability = Applicability::MachineApplicable;\n+\n+    if let Some(expected_loc) = expected_ident_loc {\n+        match (no_difference_info, double_difference_info) {\n+            (Some(i), None) => attempt_to_emit_no_difference_lint(cx, binops, i, expected_loc),\n+            (None, Some((double_difference_index, ident_loc1, ident_loc2))) => {\n+                if_chain! {\n+                    if one_ident_difference_count == binop_count - 1;\n+                    if let Some(binop) = binops.get(double_difference_index);\n+                    then {\n+                        let changed_loc = if ident_loc1 == expected_loc {\n+                            ident_loc2\n+                        } else if ident_loc2 == expected_loc {\n+                            ident_loc1\n+                        } else {\n+                            // This expression doesn't match the form we're\n+                            // looking for.\n+                            return;\n+                        };\n+\n+                        if let Some(sugg) = ident_swap_sugg(\n+                            cx,\n+                            &paired_identifiers,\n+                            binop,\n+                            changed_loc,\n+                            &mut applicability,\n+                        ) {\n+                            emit_suggestion(\n+                                cx,\n+                                binop.span,\n+                                sugg,\n+                                applicability,\n+                            );\n+                        }\n+                    }\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n+\n+fn attempt_to_emit_no_difference_lint(\n+    cx: &EarlyContext<'_>,\n+    binops: &[&BinaryOp<'_>],\n+    i: usize,\n+    expected_loc: IdentLocation,\n+) {\n+    if let Some(binop) = binops.get(i).cloned() {\n+        // We need to try and figure out which identifier we should\n+        // suggest using instead. Since there could be multiple\n+        // replacement candidates in a given expression, and we're\n+        // just taking the first one, we may get some bad lint\n+        // messages.\n+        let mut applicability = Applicability::MaybeIncorrect;\n+\n+        // We assume that the correct ident is one used elsewhere in\n+        // the other binops, in a place that there was a single\n+        // difference between idents before.\n+        let old_left_ident = get_ident(binop.left, expected_loc);\n+        let old_right_ident = get_ident(binop.right, expected_loc);\n+\n+        for b in skip_index(binops.iter(), i) {\n+            if_chain! {\n+                if let (Some(old_ident), Some(new_ident)) =\n+                (old_left_ident, get_ident(b.left, expected_loc));\n+                if old_ident != new_ident;\n+                if let Some(sugg) = suggestion_with_swapped_ident(\n+                    cx,\n+                    binop.left,\n+                    expected_loc,\n+                    new_ident,\n+                    &mut applicability,\n+                );\n+                then {\n+                    emit_suggestion(\n+                        cx,\n+                        binop.span,\n+                        replace_left_sugg(cx, &binop, &sugg, &mut applicability),\n+                        applicability,\n+                    );\n+                    return;\n+                }\n+            }\n+\n+            if_chain! {\n+                if let (Some(old_ident), Some(new_ident)) =\n+                    (old_right_ident, get_ident(b.right, expected_loc));\n+                if old_ident != new_ident;\n+                if let Some(sugg) = suggestion_with_swapped_ident(\n+                    cx,\n+                    binop.right,\n+                    expected_loc,\n+                    new_ident,\n+                    &mut applicability,\n+                );\n+                then {\n+                    emit_suggestion(\n+                        cx,\n+                        binop.span,\n+                        replace_right_sugg(cx, &binop, &sugg, &mut applicability),\n+                        applicability,\n+                    );\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn emit_suggestion(cx: &EarlyContext<'_>, span: Span, sugg: String, applicability: Applicability) {\n+    span_lint_and_sugg(\n+        cx,\n+        SUSPICIOUS_OPERATION_GROUPINGS,\n+        span,\n+        \"This sequence of operators looks suspiciously like a bug.\",\n+        \"I think you meant\",\n+        sugg,\n+        applicability,\n+    )\n+}\n+\n+fn ident_swap_sugg(\n+    cx: &EarlyContext<'_>,\n+    paired_identifiers: &FxHashSet<Ident>,\n+    binop: &BinaryOp<'_>,\n+    location: IdentLocation,\n+    applicability: &mut Applicability,\n+) -> Option<String> {\n+    let left_ident = get_ident(&binop.left, location)?;\n+    let right_ident = get_ident(&binop.right, location)?;\n+\n+    let sugg = match (\n+        paired_identifiers.contains(&left_ident),\n+        paired_identifiers.contains(&right_ident),\n+    ) {\n+        (true, true) | (false, false) => {\n+            // We don't have a good guess of what ident should be\n+            // used instead, in these cases.\n+            *applicability = Applicability::MaybeIncorrect;\n+\n+            // We arbitraily choose one side to suggest changing,\n+            // since we don't have a better guess. If the user\n+            // ends up duplicating a clause, the `logic_bug` lint\n+            // should catch it.\n+\n+            let right_suggestion =\n+                suggestion_with_swapped_ident(cx, &binop.right, location, left_ident, applicability)?;\n+\n+            replace_right_sugg(cx, binop, &right_suggestion, applicability)\n+        },\n+        (false, true) => {\n+            // We haven't seen a pair involving the left one, so\n+            // it's probably what is wanted.\n+\n+            let right_suggestion =\n+                suggestion_with_swapped_ident(cx, &binop.right, location, left_ident, applicability)?;\n+\n+            replace_right_sugg(cx, binop, &right_suggestion, applicability)\n+        },\n+        (true, false) => {\n+            // We haven't seen a pair involving the right one, so\n+            // it's probably what is wanted.\n+            let left_suggestion = suggestion_with_swapped_ident(cx, &binop.left, location, right_ident, applicability)?;\n+\n+            replace_left_sugg(cx, binop, &left_suggestion, applicability)\n+        },\n+    };\n+\n+    Some(sugg)\n+}\n+\n+fn replace_left_sugg(\n+    cx: &EarlyContext<'_>,\n+    binop: &BinaryOp<'_>,\n+    left_suggestion: &str,\n+    applicability: &mut Applicability,\n+) -> String {\n+    format!(\n+        \"{} {} {}\",\n+        left_suggestion,\n+        binop.op.to_string(),\n+        snippet_with_applicability(cx, binop.right.span, \"..\", applicability),\n+    )\n+}\n+\n+fn replace_right_sugg(\n+    cx: &EarlyContext<'_>,\n+    binop: &BinaryOp<'_>,\n+    right_suggestion: &str,\n+    applicability: &mut Applicability,\n+) -> String {\n+    format!(\n+        \"{} {} {}\",\n+        snippet_with_applicability(cx, binop.left.span, \"..\", applicability),\n+        binop.op.to_string(),\n+        right_suggestion,\n+    )\n+}\n+\n+#[derive(Clone, Debug)]\n+struct BinaryOp<'exprs> {\n+    op: BinOpKind,\n+    span: Span,\n+    left: &'exprs Expr,\n+    right: &'exprs Expr,\n+}\n+\n+impl BinaryOp<'exprs> {\n+    fn new(op: BinOpKind, span: Span, (left, right): (&'exprs Expr, &'exprs Expr)) -> Self {\n+        Self { op, span, left, right }\n+    }\n+}\n+\n+fn strip_non_ident_wrappers(expr: &Expr) -> &Expr {\n+    let mut output = expr;\n+    loop {\n+        output = match &output.kind {\n+            ExprKind::Paren(ref inner) | ExprKind::Unary(_, ref inner) => inner,\n+            _ => {\n+                return output;\n+            },\n+        };\n+    }\n+}\n+\n+fn extract_related_binops(kind: &ExprKind) -> Option<Vec<BinaryOp<'_>>> {\n+    append_opt_vecs(chained_binops(kind), if_statment_binops(kind))\n+}\n+\n+fn if_statment_binops(kind: &ExprKind) -> Option<Vec<BinaryOp<'_>>> {\n+    match kind {\n+        ExprKind::If(ref condition, _, _) => chained_binops(&condition.kind),\n+        ExprKind::Paren(ref e) => if_statment_binops(&e.kind),\n+        ExprKind::Block(ref block, _) => {\n+            let mut output = None;\n+            for stmt in &block.stmts {\n+                match stmt.kind {\n+                    StmtKind::Expr(ref e) | StmtKind::Semi(ref e) => {\n+                        output = append_opt_vecs(output, if_statment_binops(&e.kind));\n+                    },\n+                    _ => {},\n+                }\n+            }\n+            output\n+        },\n+        _ => None,\n+    }\n+}\n+\n+fn append_opt_vecs<A>(target_opt: Option<Vec<A>>, source_opt: Option<Vec<A>>) -> Option<Vec<A>> {\n+    match (target_opt, source_opt) {\n+        (Some(mut target), Some(mut source)) => {\n+            target.reserve(source.len());\n+            for op in source.drain(..) {\n+                target.push(op);\n+            }\n+            Some(target)\n+        },\n+        (Some(v), None) | (None, Some(v)) => Some(v),\n+        (None, None) => None,\n+    }\n+}\n+\n+fn chained_binops(kind: &ExprKind) -> Option<Vec<BinaryOp<'_>>> {\n+    match kind {\n+        ExprKind::Binary(_, left_outer, right_outer) => chained_binops_helper(left_outer, right_outer),\n+        ExprKind::Paren(ref e) | ExprKind::Unary(_, ref e) => chained_binops(&e.kind),\n+        _ => None,\n+    }\n+}\n+\n+fn chained_binops_helper(left_outer: &'expr Expr, right_outer: &'expr Expr) -> Option<Vec<BinaryOp<'expr>>> {\n+    match (&left_outer.kind, &right_outer.kind) {\n+        (\n+            ExprKind::Paren(ref left_e) | ExprKind::Unary(_, ref left_e),\n+            ExprKind::Paren(ref right_e) | ExprKind::Unary(_, ref right_e),\n+        ) => chained_binops_helper(left_e, right_e),\n+        (ExprKind::Paren(ref left_e) | ExprKind::Unary(_, ref left_e), _) => chained_binops_helper(left_e, right_outer),\n+        (_, ExprKind::Paren(ref right_e) | ExprKind::Unary(_, ref right_e)) => {\n+            chained_binops_helper(left_outer, right_e)\n+        },\n+        (\n+            ExprKind::Binary(Spanned { node: left_op, .. }, ref left_left, ref left_right),\n+            ExprKind::Binary(Spanned { node: right_op, .. }, ref right_left, ref right_right),\n+        ) => match (\n+            chained_binops_helper(left_left, left_right),\n+            chained_binops_helper(right_left, right_right),\n+        ) {\n+            (Some(mut left_ops), Some(mut right_ops)) => {\n+                left_ops.reserve(right_ops.len());\n+                for op in right_ops.drain(..) {\n+                    left_ops.push(op);\n+                }\n+                Some(left_ops)\n+            },\n+            (Some(mut left_ops), _) => {\n+                left_ops.push(BinaryOp::new(*right_op, right_outer.span, (right_left, right_right)));\n+                Some(left_ops)\n+            },\n+            (_, Some(mut right_ops)) => {\n+                right_ops.insert(0, BinaryOp::new(*left_op, left_outer.span, (left_left, left_right)));\n+                Some(right_ops)\n+            },\n+            (None, None) => Some(vec![\n+                BinaryOp::new(*left_op, left_outer.span, (left_left, left_right)),\n+                BinaryOp::new(*right_op, right_outer.span, (right_left, right_right)),\n+            ]),\n+        },\n+        _ => None,\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Default, Debug)]\n+struct IdentLocation {\n+    index: usize,\n+}\n+\n+impl Add for IdentLocation {\n+    type Output = IdentLocation;\n+\n+    fn add(self, other: Self) -> Self::Output {\n+        Self {\n+            index: self.index + other.index,\n+        }\n+    }\n+}\n+\n+impl AddAssign for IdentLocation {\n+    fn add_assign(&mut self, other: Self) {\n+        *self = *self + other\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+enum IdentDifference {\n+    NoDifference,\n+    Single(IdentLocation),\n+    Double(IdentLocation, IdentLocation),\n+    Multiple,\n+    NonIdent,\n+}\n+\n+impl Add for IdentDifference {\n+    type Output = IdentDifference;\n+\n+    fn add(self, other: Self) -> Self::Output {\n+        match (self, other) {\n+            (Self::NoDifference, output) | (output, Self::NoDifference) => output,\n+            (Self::Multiple, _)\n+            | (_, Self::Multiple)\n+            | (Self::Double(_, _), Self::Single(_))\n+            | (Self::Single(_) | Self::Double(_, _), Self::Double(_, _)) => Self::Multiple,\n+            (Self::NonIdent, _) | (_, Self::NonIdent) => Self::NonIdent,\n+            (Self::Single(il1), Self::Single(il2)) => Self::Double(il1, il2),\n+        }\n+    }\n+}\n+\n+impl AddAssign for IdentDifference {\n+    fn add_assign(&mut self, other: Self) {\n+        *self = *self + other\n+    }\n+}\n+\n+impl IdentDifference {\n+    /// Returns true if learning about more differences will not change the value\n+    /// of this `IdentDifference`, and false otherwise.\n+    fn is_complete(&self) -> bool {\n+        match self {\n+            Self::NoDifference | Self::Single(_) | Self::Double(_, _) => false,\n+            Self::Multiple | Self::NonIdent => true,\n+        }\n+    }\n+}\n+\n+fn ident_difference_expr(left: &Expr, right: &Expr) -> IdentDifference {\n+    ident_difference_expr_with_base_location(left, right, IdentLocation::default()).0\n+}\n+\n+fn ident_difference_expr_with_base_location(\n+    left: &Expr,\n+    right: &Expr,\n+    mut base: IdentLocation,\n+) -> (IdentDifference, IdentLocation) {\n+    // Ideally, this function should not use IdentIter because it should return\n+    // early if the expressions have any non-ident differences. We want that early\n+    // return because if without that restriction the lint would lead to false\n+    // positives.\n+    //\n+    // But, we cannot (easily?) use a `rustc_ast::visit::Visitor`, since we need\n+    // the two expressions to be walked in lockstep. And without a `Visitor`, we'd\n+    // have to do all the AST traversal ourselves, which is a lot of work, since to\n+    // do it properly we'd need to be able to handle more or less every possible\n+    // AST node since `Item`s can be written inside `Expr`s.\n+    //\n+    // In practice, it seems likely that expressions, above a certain size, that\n+    // happen to use the exact same idents in the exact same order, and which are\n+    // not structured the same, would be rare. Therefore it seems likely that if\n+    // we do only the first layer of matching ourselves and eventually fallback on\n+    // IdentIter, then the output of this function will be almost always be correct\n+    // in practice.\n+    //\n+    // If it turns out that problematic cases are more prelavent than we assume,\n+    // then we should be able to change this function to do the correct traversal,\n+    // without needing to change the rest of the code.\n+\n+    #![allow(clippy::enum_glob_use)]\n+    use ExprKind::*;\n+\n+    match (\n+        &strip_non_ident_wrappers(left).kind,\n+        &strip_non_ident_wrappers(right).kind,\n+    ) {\n+        (Yield(_), Yield(_))\n+        | (Try(_), Try(_))\n+        | (Paren(_), Paren(_))\n+        | (Repeat(_, _), Repeat(_, _))\n+        | (Struct(_, _, _), Struct(_, _, _))\n+        | (MacCall(_), MacCall(_))\n+        | (LlvmInlineAsm(_), LlvmInlineAsm(_))\n+        | (InlineAsm(_), InlineAsm(_))\n+        | (Ret(_), Ret(_))\n+        | (Continue(_), Continue(_))\n+        | (Break(_, _), Break(_, _))\n+        | (AddrOf(_, _, _), AddrOf(_, _, _))\n+        | (Path(_, _), Path(_, _))\n+        | (Range(_, _, _), Range(_, _, _))\n+        | (Index(_, _), Index(_, _))\n+        | (Field(_, _), Field(_, _))\n+        | (AssignOp(_, _, _), AssignOp(_, _, _))\n+        | (Assign(_, _, _), Assign(_, _, _))\n+        | (TryBlock(_), TryBlock(_))\n+        | (Await(_), Await(_))\n+        | (Async(_, _, _), Async(_, _, _))\n+        | (Block(_, _), Block(_, _))\n+        | (Closure(_, _, _, _, _, _), Closure(_, _, _, _, _, _))\n+        | (Match(_, _), Match(_, _))\n+        | (Loop(_, _), Loop(_, _))\n+        | (ForLoop(_, _, _, _), ForLoop(_, _, _, _))\n+        | (While(_, _, _), While(_, _, _))\n+        | (If(_, _, _), If(_, _, _))\n+        | (Let(_, _), Let(_, _))\n+        | (Type(_, _), Type(_, _))\n+        | (Cast(_, _), Cast(_, _))\n+        | (Lit(_), Lit(_))\n+        | (Unary(_, _), Unary(_, _))\n+        | (Binary(_, _, _), Binary(_, _, _))\n+        | (Tup(_), Tup(_))\n+        | (MethodCall(_, _, _), MethodCall(_, _, _))\n+        | (Call(_, _), Call(_, _))\n+        | (ConstBlock(_), ConstBlock(_))\n+        | (Array(_), Array(_))\n+        | (Box(_), Box(_)) => {\n+            // keep going\n+        },\n+        _ => {\n+            return (IdentDifference::NonIdent, base);\n+        },\n+    }\n+\n+    let mut difference = IdentDifference::NoDifference;\n+\n+    for (left_attr, right_attr) in left.attrs.iter().zip(right.attrs.iter()) {\n+        let (new_difference, new_base) =\n+            ident_difference_via_ident_iter_with_base_location(left_attr, right_attr, base);\n+        base = new_base;\n+        difference += new_difference;\n+        if difference.is_complete() {\n+            return (difference, base);\n+        }\n+    }\n+\n+    let (new_difference, new_base) = ident_difference_via_ident_iter_with_base_location(left, right, base);\n+    base = new_base;\n+    difference += new_difference;\n+\n+    (difference, base)\n+}\n+\n+fn ident_difference_via_ident_iter_with_base_location<Iterable: Into<IdentIter>>(\n+    left: Iterable,\n+    right: Iterable,\n+    mut base: IdentLocation,\n+) -> (IdentDifference, IdentLocation) {\n+    // See the note in `ident_difference_expr_with_base_location` about `IdentIter`\n+    let mut difference = IdentDifference::NoDifference;\n+\n+    let mut left_iterator = left.into();\n+    let mut right_iterator = right.into();\n+\n+    loop {\n+        match (left_iterator.next(), right_iterator.next()) {\n+            (Some(left_ident), Some(right_ident)) => {\n+                if !eq_id(left_ident, right_ident) {\n+                    difference += IdentDifference::Single(base);\n+                    if difference.is_complete() {\n+                        return (difference, base);\n+                    }\n+                }\n+            },\n+            (Some(_), None) | (None, Some(_)) => {\n+                return (IdentDifference::NonIdent, base);\n+            },\n+            (None, None) => {\n+                return (difference, base);\n+            },\n+        }\n+        base += IdentLocation { index: 1 };\n+    }\n+}\n+\n+fn get_ident(expr: &Expr, location: IdentLocation) -> Option<Ident> {\n+    IdentIter::from(expr).nth(location.index)\n+}\n+\n+fn suggestion_with_swapped_ident(\n+    cx: &EarlyContext<'_>,\n+    expr: &Expr,\n+    location: IdentLocation,\n+    new_ident: Ident,\n+    applicability: &mut Applicability,\n+) -> Option<String> {\n+    get_ident(expr, location).and_then(|current_ident| {\n+        if eq_id(current_ident, new_ident) {\n+            // We never want to suggest a non-change\n+            return None;\n+        }\n+\n+        Some(format!(\n+            \"{}{}{}\",\n+            snippet_with_applicability(cx, expr.span.with_hi(current_ident.span.lo()), \"..\", applicability),\n+            new_ident.to_string(),\n+            snippet_with_applicability(cx, expr.span.with_lo(current_ident.span.hi()), \"..\", applicability),\n+        ))\n+    })\n+}\n+\n+fn skip_index<A, Iter>(iter: Iter, index: usize) -> impl Iterator<Item = A>\n+where\n+    Iter: Iterator<Item = A>,\n+{\n+    iter.enumerate()\n+        .filter_map(move |(i, a)| if i == index { None } else { Some(a) })\n+}"}, {"sha": "699fd51ccc194e30d2f16bc978cef70cbb39aba7", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -91,7 +91,7 @@ fn check_manual_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n             if let ExprKind::Path(QPath::Resolved(None, ref rhs2)) = rhs2.kind;\n             if rhs2.segments.len() == 1;\n \n-            if ident.as_str() == rhs2.segments[0].ident.as_str();\n+            if ident.name == rhs2.segments[0].ident.name;\n             if eq_expr_value(cx, tmp_init, lhs1);\n             if eq_expr_value(cx, rhs1, lhs2);\n             then {"}, {"sha": "c53727ba160046861e6d446e428482f5b0986837", "filename": "clippy_lints/src/to_string_in_display.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fto_string_in_display.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,7 +1,7 @@\n use crate::utils::{match_def_path, match_trait_method, paths, qpath_res, span_lint};\n use if_chain::if_chain;\n use rustc_hir::def::Res;\n-use rustc_hir::{Expr, ExprKind, HirId, ImplItem, ImplItemKind, Item, ItemKind};\n+use rustc_hir::{Expr, ExprKind, HirId, Impl, ImplItem, ImplItemKind, Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n \n@@ -111,7 +111,7 @@ impl LateLintPass<'_> for ToStringInDisplay {\n \n fn is_display_impl(cx: &LateContext<'_>, item: &Item<'_>) -> bool {\n     if_chain! {\n-        if let ItemKind::Impl { of_trait: Some(trait_ref), .. } = &item.kind;\n+        if let ItemKind::Impl(Impl { of_trait: Some(trait_ref), .. }) = &item.kind;\n         if let Some(did) = trait_ref.trait_def_id();\n         then {\n             match_def_path(cx, did, &paths::DISPLAY_TRAIT)"}, {"sha": "daff5f81e8c34c926a830089025eff5294a7d540", "filename": "clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -168,8 +168,7 @@ fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n         if_chain! {\n             if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate;\n             if !in_macro(bound_predicate.span);\n-            if let TyKind::Path(ref path) = bound_predicate.bounded_ty.kind;\n-            if let QPath::Resolved(_, Path { ref segments, .. }) = path;\n+            if let TyKind::Path(QPath::Resolved(_, Path { ref segments, .. })) = bound_predicate.bounded_ty.kind;\n             if let Some(segment) = segments.first();\n             if let Some(trait_resolutions_direct) = map.get(&segment.ident);\n             then {"}, {"sha": "6b171a0fa1af2ef2058f402837237f957153908f", "filename": "clippy_lints/src/transmuting_null.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmuting_null.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -48,8 +48,7 @@ impl<'tcx> LateLintPass<'tcx> for TransmutingNull {\n                 if_chain! {\n                     if let ExprKind::Path(ref _qpath) = args[0].kind;\n                     let x = const_eval_context.expr(&args[0]);\n-                    if let Some(constant) = x;\n-                    if let Constant::RawPtr(0) = constant;\n+                    if let Some(Constant::RawPtr(0)) = x;\n                     then {\n                         span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG)\n                     }"}, {"sha": "3b5a83d2a0bec7f0767718965bf42d845c101520", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 130, "deletions": 31, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -8,7 +8,6 @@ use if_chain::if_chain;\n use rustc_ast::{FloatTy, IntTy, LitFloatType, LitIntType, LitKind, UintTy};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n-use rustc_hir::def::Res;\n use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{\n     BinOpKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericBounds, GenericParamKind, HirId,\n@@ -19,7 +18,8 @@ use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::TypeFoldable;\n-use rustc_middle::ty::{self, InferTy, Ty, TyCtxt, TyS, TypeckResults};\n+use rustc_middle::ty::{self, InferTy, Ty, TyCtxt, TyS, TypeAndMut, TypeckResults};\n+use rustc_semver::RustcVersion;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::Span;\n@@ -30,11 +30,13 @@ use rustc_typeck::hir_ty_to_ty;\n \n use crate::consts::{constant, Constant};\n use crate::utils::paths;\n+use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    clip, comparisons, differing_macro_contexts, higher, in_constant, indent_of, int_bits, is_type_diagnostic_item,\n-    last_path_segment, match_def_path, match_path, method_chain_args, multispan_sugg, numeric_literal::NumericLiteral,\n-    qpath_res, reindent_multiline, sext, snippet, snippet_opt, snippet_with_applicability, snippet_with_macro_callsite,\n-    span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, unsext,\n+    clip, comparisons, differing_macro_contexts, higher, in_constant, indent_of, int_bits, is_hir_ty_cfg_dependant,\n+    is_type_diagnostic_item, last_path_segment, match_def_path, match_path, meets_msrv, method_chain_args,\n+    multispan_sugg, numeric_literal::NumericLiteral, qpath_res, reindent_multiline, sext, snippet, snippet_opt,\n+    snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg,\n+    span_lint_and_then, unsext,\n };\n \n declare_clippy_lint! {\n@@ -73,7 +75,7 @@ declare_clippy_lint! {\n     /// **Why is this bad?** `Vec` already keeps its contents in a separate area on\n     /// the heap. So if you `Box` its contents, you just add another level of indirection.\n     ///\n-    /// **Known problems:** Vec<Box<T: Sized>> makes sense if T is a large type (see #3530,\n+    /// **Known problems:** Vec<Box<T: Sized>> makes sense if T is a large type (see [#3530](https://github.com/rust-lang/rust-clippy/issues/3530),\n     /// 1st comment).\n     ///\n     /// **Example:**\n@@ -258,7 +260,7 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     fn check_fn(&mut self, cx: &LateContext<'_>, _: FnKind<'_>, decl: &FnDecl<'_>, _: &Body<'_>, _: Span, id: HirId) {\n         // Skip trait implementations; see issue #605.\n         if let Some(hir::Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_item(id)) {\n-            if let ItemKind::Impl { of_trait: Some(_), .. } = item.kind {\n+            if let ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = item.kind {\n                 return;\n             }\n         }\n@@ -738,8 +740,7 @@ fn is_any_trait(t: &hir::Ty<'_>) -> bool {\n fn get_bounds_if_impl_trait<'tcx>(cx: &LateContext<'tcx>, qpath: &QPath<'_>, id: HirId) -> Option<GenericBounds<'tcx>> {\n     if_chain! {\n         if let Some(did) = qpath_res(cx, qpath, id).opt_def_id();\n-        if let Some(node) = cx.tcx.hir().get_if_local(did);\n-        if let Node::GenericParam(generic_param) = node;\n+        if let Some(Node::GenericParam(generic_param)) = cx.tcx.hir().get_if_local(did);\n         if let GenericParamKind::Type { synthetic, .. } = generic_param.kind;\n         if synthetic == Some(SyntheticTyParamKind::ImplTrait);\n         then {\n@@ -1105,7 +1106,9 @@ fn is_empty_block(expr: &Expr<'_>) -> bool {\n         expr.kind,\n         ExprKind::Block(\n             Block {\n-                stmts: &[], expr: None, ..\n+                stmts: &[],\n+                expr: None,\n+                ..\n             },\n             _,\n         )\n@@ -1278,8 +1281,8 @@ declare_clippy_lint! {\n }\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for casts from a less-strictly-aligned pointer to a\n-    /// more-strictly-aligned pointer\n+    /// **What it does:** Checks for casts, using `as` or `pointer::cast`,\n+    /// from a less-strictly-aligned pointer to a more-strictly-aligned pointer\n     ///\n     /// **Why is this bad?** Dereferencing the resulting pointer may be undefined\n     /// behavior.\n@@ -1292,6 +1295,9 @@ declare_clippy_lint! {\n     /// ```rust\n     /// let _ = (&1u8 as *const u8) as *const u16;\n     /// let _ = (&mut 1u8 as *mut u8) as *mut u16;\n+    ///\n+    /// (&1u8 as *const u8).cast::<u16>();\n+    /// (&mut 1u8 as *mut u8).cast::<u16>();\n     /// ```\n     pub CAST_PTR_ALIGNMENT,\n     pedantic,\n@@ -1470,8 +1476,7 @@ fn check_loss_of_sign(cx: &LateContext<'_>, expr: &Expr<'_>, op: &Expr<'_>, cast\n     // don't lint for positive constants\n     let const_val = constant(cx, &cx.typeck_results(), op);\n     if_chain! {\n-        if let Some((const_val, _)) = const_val;\n-        if let Constant::Int(n) = const_val;\n+        if let Some((Constant::Int(n), _)) = const_val;\n         if let ty::Int(ity) = *cast_from.kind();\n         if sext(cx.tcx, n, ity) >= 0;\n         then {\n@@ -1634,12 +1639,8 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n             return;\n         }\n         if let ExprKind::Cast(ref ex, cast_to) = expr.kind {\n-            if let TyKind::Path(QPath::Resolved(_, path)) = cast_to.kind {\n-                if let Res::Def(_, def_id) = path.res {\n-                    if cx.tcx.has_attr(def_id, sym::cfg) || cx.tcx.has_attr(def_id, sym::cfg_attr) {\n-                        return;\n-                    }\n-                }\n+            if is_hir_ty_cfg_dependant(cx, cast_to) {\n+                return;\n             }\n             let (cast_from, cast_to) = (cx.typeck_results().expr_ty(ex), cx.typeck_results().expr_ty(expr));\n             lint_fn_to_numeric_cast(cx, expr, ex, cast_from, cast_to);\n@@ -1689,6 +1690,19 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n             }\n \n             lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n+        } else if let ExprKind::MethodCall(method_path, _, args, _) = expr.kind {\n+            if_chain! {\n+            if method_path.ident.name == sym!(cast);\n+            if let Some(generic_args) = method_path.args;\n+            if let [GenericArg::Type(cast_to)] = generic_args.args;\n+            // There probably is no obvious reason to do this, just to be consistent with `as` cases.\n+            if !is_hir_ty_cfg_dependant(cx, cast_to);\n+            then {\n+                let (cast_from, cast_to) =\n+                    (cx.typeck_results().expr_ty(&args[0]), cx.typeck_results().expr_ty(expr));\n+                lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n+            }\n+            }\n         }\n     }\n }\n@@ -2558,21 +2572,16 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n         }\n \n         match item.kind {\n-            ItemKind::Impl {\n-                ref generics,\n-                self_ty: ref ty,\n-                ref items,\n-                ..\n-            } => {\n+            ItemKind::Impl(ref impl_) => {\n                 let mut vis = ImplicitHasherTypeVisitor::new(cx);\n-                vis.visit_ty(ty);\n+                vis.visit_ty(impl_.self_ty);\n \n                 for target in &vis.found {\n                     if differing_macro_contexts(item.span, target.span()) {\n                         return;\n                     }\n \n-                    let generics_suggestion_span = generics.span.substitute_dummy({\n+                    let generics_suggestion_span = impl_.generics.span.substitute_dummy({\n                         let pos = snippet_opt(cx, item.span.until(target.span()))\n                             .and_then(|snip| Some(item.span.lo() + BytePos(snip.find(\"impl\")? as u32 + 4)));\n                         if let Some(pos) = pos {\n@@ -2583,7 +2592,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n                     });\n \n                     let mut ctr_vis = ImplicitHasherConstructorVisitor::new(cx, target);\n-                    for item in items.iter().map(|item| cx.tcx.hir().impl_item(item.id)) {\n+                    for item in impl_.items.iter().map(|item| cx.tcx.hir().impl_item(item.id)) {\n                         ctr_vis.visit_impl_item(item);\n                     }\n \n@@ -2596,7 +2605,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n                             target.type_name()\n                         ),\n                         move |diag| {\n-                            suggestion(cx, diag, generics.span, generics_suggestion_span, target, ctr_vis);\n+                            suggestion(cx, diag, impl_.generics.span, generics_suggestion_span, target, ctr_vis);\n                         },\n                     );\n                 }\n@@ -2878,3 +2887,93 @@ impl<'tcx> LateLintPass<'tcx> for RefToMut {\n         }\n     }\n }\n+\n+const PTR_AS_PTR_MSRV: RustcVersion = RustcVersion::new(1, 38, 0);\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Checks for `as` casts between raw pointers without changing its mutability,\n+    /// namely `*const T` to `*const U` and `*mut T` to `*mut U`.\n+    ///\n+    /// **Why is this bad?**\n+    /// Though `as` casts between raw pointers is not terrible, `pointer::cast` is safer because\n+    /// it cannot accidentally change the pointer's mutability nor cast the pointer to other types like `usize`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let ptr: *const u32 = &42_u32;\n+    /// let mut_ptr: *mut u32 = &mut 42_u32;\n+    /// let _ = ptr as *const i32;\n+    /// let _ = mut_ptr as *mut i32;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let ptr: *const u32 = &42_u32;\n+    /// let mut_ptr: *mut u32 = &mut 42_u32;\n+    /// let _ = ptr.cast::<i32>();\n+    /// let _ = mut_ptr.cast::<i32>();\n+    /// ```\n+    pub PTR_AS_PTR,\n+    pedantic,\n+    \"casting using `as` from and to raw pointers that doesn't change its mutability, where `pointer::cast` could take the place of `as`\"\n+}\n+\n+pub struct PtrAsPtr {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl PtrAsPtr {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(PtrAsPtr => [PTR_AS_PTR]);\n+\n+impl<'tcx> LateLintPass<'tcx> for PtrAsPtr {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if !meets_msrv(self.msrv.as_ref(), &PTR_AS_PTR_MSRV) {\n+            return;\n+        }\n+\n+        if expr.span.from_expansion() {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let ExprKind::Cast(cast_expr, cast_to_hir_ty) = expr.kind;\n+            let (cast_from, cast_to) = (cx.typeck_results().expr_ty(cast_expr), cx.typeck_results().expr_ty(expr));\n+            if let ty::RawPtr(TypeAndMut { mutbl: from_mutbl, .. }) = cast_from.kind();\n+            if let ty::RawPtr(TypeAndMut { ty: to_pointee_ty, mutbl: to_mutbl }) = cast_to.kind();\n+            if matches!((from_mutbl, to_mutbl),\n+                (Mutability::Not, Mutability::Not) | (Mutability::Mut, Mutability::Mut));\n+            // The `U` in `pointer::cast` have to be `Sized`\n+            // as explained here: https://github.com/rust-lang/rust/issues/60602.\n+            if to_pointee_ty.is_sized(cx.tcx.at(expr.span), cx.param_env);\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                let cast_expr_sugg = Sugg::hir_with_applicability(cx, cast_expr, \"_\", &mut applicability);\n+                let turbofish = match &cast_to_hir_ty.kind {\n+                        TyKind::Infer => Cow::Borrowed(\"\"),\n+                        TyKind::Ptr(mut_ty) if matches!(mut_ty.ty.kind, TyKind::Infer) => Cow::Borrowed(\"\"),\n+                        _ => Cow::Owned(format!(\"::<{}>\", to_pointee_ty)),\n+                    };\n+                span_lint_and_sugg(\n+                    cx,\n+                    PTR_AS_PTR,\n+                    expr.span,\n+                    \"`as` casting between raw pointers without changing its mutability\",\n+                    \"try `pointer::cast`, a safer alternative\",\n+                    format!(\"{}.cast{}()\", cast_expr_sugg.maybe_par(), turbofish),\n+                    applicability,\n+                );\n+            }\n+        }\n+    }\n+\n+    extract_msrv_attr!(LateContext);\n+}"}, {"sha": "9b45d38afd42f5eeed1a3064e2fbefd2845dd995", "filename": "clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -183,7 +183,7 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n             Param { pat: Pat { kind: PatKind::Binding(_, _, right_ident, _), .. }, .. }\n         ] = &closure_body.params;\n         if let ExprKind::MethodCall(method_path, _, [ref left_expr, ref right_expr], _) = &closure_body.value.kind;\n-        if method_path.ident.name.to_ident_string() == \"cmp\";\n+        if method_path.ident.name == sym::cmp;\n         then {\n             let (closure_body, closure_arg, reverse) = if mirrored_exprs(\n                 &cx,"}, {"sha": "8ac5dd696b7620d85216c281603c286582ed5411", "filename": "clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,14 +1,15 @@\n use crate::utils::{\n-    in_macro, is_type_diagnostic_item, match_qpath, paths, return_ty, snippet, span_lint_and_then,\n+    contains_return, in_macro, is_type_diagnostic_item, match_qpath, paths, return_ty, snippet, span_lint_and_then,\n     visitors::find_all_ret_expressions,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n-use rustc_hir::{Body, ExprKind, FnDecl, HirId, ItemKind, Node};\n+use rustc_hir::{Body, ExprKind, FnDecl, HirId, Impl, ItemKind, Node};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n declare_clippy_lint! {\n@@ -74,14 +75,17 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n         }\n \n         if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n-            if matches!(item.kind, ItemKind::Impl{ of_trait: Some(_), ..} | ItemKind::Trait(..)) {\n+            if matches!(\n+                item.kind,\n+                ItemKind::Impl(Impl { of_trait: Some(_), .. }) | ItemKind::Trait(..)\n+            ) {\n                 return;\n             }\n         }\n \n-        let (return_type, path) = if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym!(option_type)) {\n+        let (return_type, path) = if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym::option_type) {\n             (\"Option\", &paths::OPTION_SOME)\n-        } else if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym!(result_type)) {\n+        } else if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym::result_type) {\n             (\"Result\", &paths::RESULT_OK)\n         } else {\n             return;\n@@ -95,6 +99,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n                 if let ExprKind::Path(ref qpath) = func.kind;\n                 if match_qpath(qpath, path);\n                 if args.len() == 1;\n+                if !contains_return(&args[0]);\n                 then {\n                     suggs.push((ret_expr.span, snippet(cx, args[0].span.source_callsite(), \"..\").to_string()));\n                     true\n@@ -134,7 +139,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n                     diag.multipart_suggestion(\n                         \"...and change the returning expressions\",\n                         suggs,\n-                        Applicability::MachineApplicable,\n+                        Applicability::MaybeIncorrect,\n                     );\n                 },\n             );"}, {"sha": "5349c4f7eb8a78251c51bd412f3171afdb46dd1a", "filename": "clippy_lints/src/unused_self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Funused_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Funused_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_self.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,7 +1,7 @@\n use if_chain::if_chain;\n use rustc_hir::def::Res;\n use rustc_hir::intravisit::{walk_path, NestedVisitorMap, Visitor};\n-use rustc_hir::{HirId, ImplItem, ImplItemKind, ItemKind, Path};\n+use rustc_hir::{HirId, Impl, ImplItem, ImplItemKind, ItemKind, Path};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -49,7 +49,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedSelf {\n         let def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n         let assoc_item = cx.tcx.associated_item(def_id);\n         if_chain! {\n-            if let ItemKind::Impl { of_trait: None, .. } = parent_item.kind;\n+            if let ItemKind::Impl(Impl { of_trait: None, .. }) = parent_item.kind;\n             if assoc_item.fn_has_self_parameter;\n             if let ImplItemKind::Fn(.., body_id) = &impl_item.kind;\n             let body = cx.tcx.hir().body(*body_id);"}, {"sha": "a31cd5fda849ed918211bf6d6822cf8555b3954c", "filename": "clippy_lints/src/unused_unit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Funused_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Funused_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_unit.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -120,7 +120,7 @@ fn is_unit_expr(expr: &ast::Expr) -> bool {\n \n fn lint_unneeded_unit_return(cx: &EarlyContext<'_>, ty: &ast::Ty, span: Span) {\n     let (ret_span, appl) = if let Ok(fn_source) = cx.sess().source_map().span_to_snippet(span.with_hi(ty.span.hi())) {\n-        position_before_rarrow(fn_source).map_or((ty.span, Applicability::MaybeIncorrect), |rpos| {\n+        position_before_rarrow(&fn_source).map_or((ty.span, Applicability::MaybeIncorrect), |rpos| {\n             (\n                 #[allow(clippy::cast_possible_truncation)]\n                 ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),"}, {"sha": "b82909eaea604fd780e6709967469dd20b08c960", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,6 +1,5 @@\n use crate::utils::{\n-    differing_macro_contexts, higher::if_block, is_type_diagnostic_item, span_lint_and_then,\n-    usage::is_potentially_mutated,\n+    differing_macro_contexts, is_type_diagnostic_item, span_lint_and_then, usage::is_potentially_mutated,\n };\n use if_chain::if_chain;\n use rustc_hir::intravisit::{walk_expr, walk_fn, FnKind, NestedVisitorMap, Visitor};\n@@ -158,7 +157,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n         if in_external_macro(self.cx.tcx.sess, expr.span) {\n             return;\n         }\n-        if let Some((cond, then, els)) = if_block(&expr) {\n+        if let ExprKind::If(cond, then, els) = &expr.kind {\n             walk_expr(self, cond);\n             self.visit_branch(cond, then, false);\n             if let Some(els) = els {"}, {"sha": "72d1ca7392913f77040ef91ef531418c14e91640", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -12,11 +12,12 @@ use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty;\n use rustc_middle::ty::{DefIdTree, Ty};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::kw;\n use rustc_typeck::hir_ty_to_ty;\n \n-use crate::utils::{differing_macro_contexts, span_lint_and_sugg};\n+use crate::utils::{differing_macro_contexts, meets_msrv, span_lint_and_sugg};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for unnecessary repetition of structure name when a\n@@ -27,8 +28,8 @@ declare_clippy_lint! {\n     /// feels inconsistent.\n     ///\n     /// **Known problems:**\n-    /// - False positive when using associated types (#2843)\n-    /// - False positives in some situations when using generics (#3410)\n+    /// - False positive when using associated types ([#2843](https://github.com/rust-lang/rust-clippy/issues/2843))\n+    /// - False positives in some situations when using generics ([#3410](https://github.com/rust-lang/rust-clippy/issues/3410))\n     ///\n     /// **Example:**\n     /// ```rust\n@@ -53,7 +54,7 @@ declare_clippy_lint! {\n     \"unnecessary structure name repetition whereas `Self` is applicable\"\n }\n \n-declare_lint_pass!(UseSelf => [USE_SELF]);\n+impl_lint_pass!(UseSelf => [USE_SELF]);\n \n const SEGMENTS_MSG: &str = \"segments should be composed of at least 1 element\";\n \n@@ -157,14 +158,31 @@ fn check_trait_method_impl_decl<'tcx>(\n     }\n }\n \n+const USE_SELF_MSRV: RustcVersion = RustcVersion::new(1, 37, 0);\n+\n+pub struct UseSelf {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl UseSelf {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for UseSelf {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        if !meets_msrv(self.msrv.as_ref(), &USE_SELF_MSRV) {\n+            return;\n+        }\n+\n         if in_external_macro(cx.sess(), item.span) {\n             return;\n         }\n         if_chain! {\n-            if let ItemKind::Impl{ self_ty: ref item_type, items: refs, .. } = item.kind;\n-            if let TyKind::Path(QPath::Resolved(_, ref item_path)) = item_type.kind;\n+            if let ItemKind::Impl(impl_) = &item.kind;\n+            if let TyKind::Path(QPath::Resolved(_, ref item_path)) = impl_.self_ty.kind;\n             then {\n                 let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).args;\n                 let should_check = parameters.as_ref().map_or(\n@@ -182,7 +200,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n                     let impl_trait_ref = cx.tcx.impl_trait_ref(impl_def_id);\n \n                     if let Some(impl_trait_ref) = impl_trait_ref {\n-                        for impl_item_ref in refs {\n+                        for impl_item_ref in impl_.items {\n                             let impl_item = cx.tcx.hir().impl_item(impl_item_ref.id);\n                             if let ImplItemKind::Fn(FnSig{ decl: impl_decl, .. }, impl_body_id)\n                                     = &impl_item.kind {\n@@ -195,7 +213,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n                             }\n                         }\n                     } else {\n-                        for impl_item_ref in refs {\n+                        for impl_item_ref in impl_.items {\n                             let impl_item = cx.tcx.hir().impl_item(impl_item_ref.id);\n                             visitor.visit_impl_item(impl_item);\n                         }\n@@ -204,6 +222,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n             }\n         }\n     }\n+    extract_msrv_attr!(LateContext);\n }\n \n struct UseSelfVisitor<'a, 'tcx> {"}, {"sha": "c53348539860524ce55b0e9db2fadfd55ca07314", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -80,10 +80,10 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                         );\n                     }\n                 }\n-                if match_trait_method(cx, e, &paths::INTO_ITERATOR) && &*name.ident.as_str() == \"into_iter\" {\n+                if match_trait_method(cx, e, &paths::INTO_ITERATOR) && name.ident.name == sym::into_iter {\n                     if let Some(parent_expr) = get_parent_expr(cx, e) {\n                         if let ExprKind::MethodCall(ref parent_name, ..) = parent_expr.kind {\n-                            if &*parent_name.ident.as_str() != \"into_iter\" {\n+                            if parent_name.ident.name != sym::into_iter {\n                                 return;\n                             }\n                         }"}, {"sha": "eac5d0aa3ee9d88203cd0af1023d5a7d39e94196", "filename": "clippy_lints/src/utils/ast_utils.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -10,6 +10,17 @@ use rustc_ast::{self as ast, *};\n use rustc_span::symbol::Ident;\n use std::mem;\n \n+pub mod ident_iter;\n+pub use ident_iter::IdentIter;\n+\n+pub fn is_useless_with_eq_exprs(kind: BinOpKind) -> bool {\n+    use BinOpKind::*;\n+    matches!(\n+        kind,\n+        Sub | Div | Eq | Lt | Le | Gt | Ge | Ne | And | Or | BitXor | BitAnd | BitOr\n+    )\n+}\n+\n /// Checks if each element in the first slice is contained within the latter as per `eq_fn`.\n pub fn unordered_over<X>(left: &[X], right: &[X], mut eq_fn: impl FnMut(&X, &X) -> bool) -> bool {\n     left.len() == right.len() && left.iter().all(|l| right.iter().any(|r| eq_fn(l, r)))\n@@ -396,8 +407,15 @@ pub fn eq_use_tree_kind(l: &UseTreeKind, r: &UseTreeKind) -> bool {\n     }\n }\n \n+pub fn eq_anon_const(l: &AnonConst, r: &AnonConst) -> bool {\n+    eq_expr(&l.value, &r.value)\n+}\n+\n pub fn eq_defaultness(l: Defaultness, r: Defaultness) -> bool {\n-    matches!((l, r), (Defaultness::Final, Defaultness::Final) | (Defaultness::Default(_), Defaultness::Default(_)))\n+    matches!(\n+        (l, r),\n+        (Defaultness::Final, Defaultness::Final) | (Defaultness::Default(_), Defaultness::Default(_))\n+    )\n }\n \n pub fn eq_vis(l: &Visibility, r: &Visibility) -> bool {\n@@ -483,7 +501,18 @@ pub fn eq_generic_param(l: &GenericParam, r: &GenericParam) -> bool {\n         && match (&l.kind, &r.kind) {\n             (Lifetime, Lifetime) => true,\n             (Type { default: l }, Type { default: r }) => both(l, r, |l, r| eq_ty(l, r)),\n-            (Const { ty: l, kw_span: _ }, Const { ty: r, kw_span: _ }) => eq_ty(l, r),\n+            (\n+                Const {\n+                    ty: lt,\n+                    kw_span: _,\n+                    default: ld,\n+                },\n+                Const {\n+                    ty: rt,\n+                    kw_span: _,\n+                    default: rd,\n+                },\n+            ) => eq_ty(lt, rt) && both(ld, rd, |ld, rd| eq_anon_const(ld, rd)),\n             _ => false,\n         }\n         && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n@@ -527,7 +556,7 @@ pub fn eq_mac_args(l: &MacArgs, r: &MacArgs) -> bool {\n     match (l, r) {\n         (Empty, Empty) => true,\n         (Delimited(_, ld, lts), Delimited(_, rd, rts)) => ld == rd && lts.eq_unspanned(rts),\n-        (Eq(_, lts), Eq(_, rts)) => lts.eq_unspanned(rts),\n+        (Eq(_, lt), Eq(_, rt)) => lt.kind == rt.kind,\n         _ => false,\n     }\n }"}, {"sha": "eefcbabd835d2b669cf65be463c4130b366b66e7", "filename": "clippy_lints/src/utils/ast_utils/ident_iter.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fast_utils%2Fident_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fast_utils%2Fident_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fast_utils%2Fident_iter.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,45 @@\n+use core::iter::FusedIterator;\n+use rustc_ast::visit::{walk_attribute, walk_expr, Visitor};\n+use rustc_ast::{Attribute, Expr};\n+use rustc_span::symbol::Ident;\n+\n+pub struct IdentIter(std::vec::IntoIter<Ident>);\n+\n+impl Iterator for IdentIter {\n+    type Item = Ident;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.0.next()\n+    }\n+}\n+\n+impl FusedIterator for IdentIter {}\n+\n+impl From<&Expr> for IdentIter {\n+    fn from(expr: &Expr) -> Self {\n+        let mut visitor = IdentCollector::default();\n+\n+        walk_expr(&mut visitor, expr);\n+\n+        IdentIter(visitor.0.into_iter())\n+    }\n+}\n+\n+impl From<&Attribute> for IdentIter {\n+    fn from(attr: &Attribute) -> Self {\n+        let mut visitor = IdentCollector::default();\n+\n+        walk_attribute(&mut visitor, attr);\n+\n+        IdentIter(visitor.0.into_iter())\n+    }\n+}\n+\n+#[derive(Default)]\n+struct IdentCollector(Vec<Ident>);\n+\n+impl Visitor<'_> for IdentCollector {\n+    fn visit_ident(&mut self, ident: Ident) {\n+        self.0.push(ident);\n+    }\n+}"}, {"sha": "8d28421d70d707fdec87dcbf03a059f5d63ada2c", "filename": "clippy_lints/src/utils/attrs.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fattrs.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,6 +1,7 @@\n use rustc_ast::ast;\n use rustc_errors::Applicability;\n use rustc_session::Session;\n+use rustc_span::sym;\n use std::str::FromStr;\n \n /// Deprecation status of attributes known by Clippy.\n@@ -64,11 +65,11 @@ pub fn get_attr<'a>(\n             return false;\n         };\n         let attr_segments = &attr.path.segments;\n-        if attr_segments.len() == 2 && attr_segments[0].ident.to_string() == \"clippy\" {\n+        if attr_segments.len() == 2 && attr_segments[0].ident.name == sym::clippy {\n             BUILTIN_ATTRIBUTES\n                 .iter()\n-                .find_map(|(builtin_name, deprecation_status)| {\n-                    if *builtin_name == attr_segments[1].ident.to_string() {\n+                .find_map(|&(builtin_name, ref deprecation_status)| {\n+                    if attr_segments[1].ident.name.as_str() == builtin_name {\n                         Some(deprecation_status)\n                     } else {\n                         None\n@@ -99,7 +100,7 @@ pub fn get_attr<'a>(\n                             },\n                             DeprecationStatus::None => {\n                                 diag.cancel();\n-                                attr_segments[1].ident.to_string() == name\n+                                attr_segments[1].ident.name.as_str() == name\n                             },\n                         }\n                     },"}, {"sha": "43afa65de3e5518a1bf9c701c1dddf224d7f8775", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,7 +1,7 @@\n //! A group of attributes that can be attached to Rust code in order\n //! to generate a clippy lint detecting said code automatically.\n \n-use crate::utils::{get_attr, higher};\n+use crate::utils::get_attr;\n use rustc_ast::ast::{Attribute, LitFloatType, LitKind};\n use rustc_ast::walk_list;\n use rustc_data_structures::fx::FxHashMap;\n@@ -201,32 +201,6 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n \n     #[allow(clippy::too_many_lines)]\n     fn visit_expr(&mut self, expr: &Expr<'_>) {\n-        // handle if desugarings\n-        // TODO add more desugarings here\n-        if let Some((cond, then, opt_else)) = higher::if_block(&expr) {\n-            let cond_pat = self.next(\"cond\");\n-            let then_pat = self.next(\"then\");\n-            if let Some(else_) = opt_else {\n-                let else_pat = self.next(\"else_\");\n-                println!(\n-                    \"    if let Some((ref {}, ref {}, Some({}))) = higher::if_block(&{});\",\n-                    cond_pat, then_pat, else_pat, self.current\n-                );\n-                self.current = else_pat;\n-                self.visit_expr(else_);\n-            } else {\n-                println!(\n-                    \"    if let Some((ref {}, ref {}, None)) = higher::if_block(&{});\",\n-                    cond_pat, then_pat, self.current\n-                );\n-            }\n-            self.current = cond_pat;\n-            self.visit_expr(cond);\n-            self.current = then_pat;\n-            self.visit_expr(then);\n-            return;\n-        }\n-\n         print!(\"    if let ExprKind::\");\n         let current = format!(\"{}.kind\", self.current);\n         match expr.kind {\n@@ -351,6 +325,25 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = body_pat;\n                 self.visit_block(body);\n             },\n+            ExprKind::If(ref cond, ref then, ref opt_else) => {\n+                let cond_pat = self.next(\"cond\");\n+                let then_pat = self.next(\"then\");\n+                if let Some(ref else_) = *opt_else {\n+                    let else_pat = self.next(\"else_\");\n+                    println!(\n+                        \"If(ref {}, ref {}, Some(ref {})) = {};\",\n+                        cond_pat, then_pat, else_pat, current\n+                    );\n+                    self.current = else_pat;\n+                    self.visit_expr(else_);\n+                } else {\n+                    println!(\"If(ref {}, ref {}, None) = {};\", cond_pat, then_pat, current);\n+                }\n+                self.current = cond_pat;\n+                self.visit_expr(cond);\n+                self.current = then_pat;\n+                self.visit_expr(then);\n+            },\n             ExprKind::Match(ref expr, ref arms, desugaring) => {\n                 let des = desugaring_name(desugaring);\n                 let expr_pat = self.next(\"expr\");\n@@ -372,6 +365,18 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                                 self.current = if_expr_pat;\n                                 self.visit_expr(if_expr);\n                             },\n+                            hir::Guard::IfLet(ref if_let_pat, ref if_let_expr) => {\n+                                let if_let_pat_pat = self.next(\"pat\");\n+                                let if_let_expr_pat = self.next(\"expr\");\n+                                println!(\n+                                    \"    if let Guard::IfLet(ref {}, ref {}) = {};\",\n+                                    if_let_pat_pat, if_let_expr_pat, guard_pat\n+                                );\n+                                self.current = if_let_expr_pat;\n+                                self.visit_expr(if_let_expr);\n+                                self.current = if_let_pat_pat;\n+                                self.visit_pat(if_let_pat);\n+                            },\n                         }\n                     }\n                     self.current = format!(\"{}[{}].pat\", arms_pat, i);\n@@ -730,10 +735,7 @@ fn desugaring_name(des: hir::MatchSource) -> String {\n             \"MatchSource::IfLetDesugar {{ contains_else_clause: {} }}\",\n             contains_else_clause\n         ),\n-        hir::MatchSource::IfDesugar { contains_else_clause } => format!(\n-            \"MatchSource::IfDesugar {{ contains_else_clause: {} }}\",\n-            contains_else_clause\n-        ),\n+        hir::MatchSource::IfLetGuardDesugar => \"MatchSource::IfLetGuardDesugar\".to_string(),\n         hir::MatchSource::AwaitDesugar => \"MatchSource::AwaitDesugar\".to_string(),\n     }\n }"}, {"sha": "b5a8300376c1646e2d05311d09959ef2792cb853", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -106,7 +106,7 @@ macro_rules! define_Conf {\n \n pub use self::helpers::Conf;\n define_Conf! {\n-    /// Lint: MANUAL_NON_EXHAUSTIVE, MANUAL_STRIP, OPTION_AS_REF_DEREF, MATCH_LIKE_MATCHES_MACRO. The minimum rust version that the project supports\n+    /// Lint: REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN. The minimum rust version that the project supports\n     (msrv, \"msrv\": Option<String>, None),\n     /// Lint: BLACKLISTED_NAME. The list of blacklisted names to lint about. NB: `bar` is not here since it has legitimate uses\n     (blacklisted_names, \"blacklisted_names\": Vec<String>, [\"foo\", \"baz\", \"quux\"].iter().map(ToString::to_string).collect()),\n@@ -171,6 +171,8 @@ define_Conf! {\n     (warn_on_all_wildcard_imports, \"warn_on_all_wildcard_imports\": bool, false),\n     /// Lint: DISALLOWED_METHOD. The list of blacklisted methods to lint about. NB: `bar` is not here since it has legitimate uses\n     (disallowed_methods, \"disallowed_methods\": Vec<String>, Vec::<String>::new()),\n+    /// Lint: UNREADABLE_LITERAL. Should the fraction of a decimal be linted to include separators.\n+    (unreadable_literal_lint_fractions, \"unreadable_literal_lint_fractions\": bool, true),\n }\n \n impl Default for Conf {"}, {"sha": "a7a6b5855b754948957f7ce187261ac685303f37", "filename": "clippy_lints/src/utils/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -186,7 +186,9 @@ pub fn span_lint_hir_and_then(\n ///     |\n ///     = note: `-D fold-any` implied by `-D warnings`\n /// ```\n-#[allow(clippy::collapsible_span_lint_calls)]\n+\n+#[allow(clippy::unknown_clippy_lints)]\n+#[cfg_attr(feature = \"internal-lints\", allow(clippy::collapsible_span_lint_calls))]\n pub fn span_lint_and_sugg<'a, T: LintContext>(\n     cx: &'a T,\n     lint: &'static Lint,"}, {"sha": "2f157c5030f4466be1ba2cd83068702e95f85210", "filename": "clippy_lints/src/utils/eager_or_lazy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Feager_or_lazy.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -62,6 +62,7 @@ fn identify_some_pure_patterns(expr: &Expr<'_>) -> bool {\n         | ExprKind::Type(..)\n         | ExprKind::DropTemps(..)\n         | ExprKind::Loop(..)\n+        | ExprKind::If(..)\n         | ExprKind::Match(..)\n         | ExprKind::Closure(..)\n         | ExprKind::Block(..)"}, {"sha": "9b3585865da3236c0c7523a2a1058131b5b21542", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 4, "deletions": 33, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -162,42 +162,14 @@ pub fn while_loop<'tcx>(expr: &'tcx hir::Expr<'tcx>) -> Option<(&'tcx hir::Expr<\n         if let hir::Block { expr: Some(expr), .. } = &**block;\n         if let hir::ExprKind::Match(cond, arms, hir::MatchSource::WhileDesugar) = &expr.kind;\n         if let hir::ExprKind::DropTemps(cond) = &cond.kind;\n-        if let [arm, ..] = &arms[..];\n-        if let hir::Arm { body, .. } = arm;\n+        if let [hir::Arm { body, .. }, ..] = &arms[..];\n         then {\n             return Some((cond, body));\n         }\n     }\n     None\n }\n \n-/// Recover the essential nodes of a desugared if block\n-/// `if cond { then } else { els }` becomes `(cond, then, Some(els))`\n-pub fn if_block<'tcx>(\n-    expr: &'tcx hir::Expr<'tcx>,\n-) -> Option<(\n-    &'tcx hir::Expr<'tcx>,\n-    &'tcx hir::Expr<'tcx>,\n-    Option<&'tcx hir::Expr<'tcx>>,\n-)> {\n-    if let hir::ExprKind::Match(ref cond, ref arms, hir::MatchSource::IfDesugar { contains_else_clause }) = expr.kind {\n-        let cond = if let hir::ExprKind::DropTemps(ref cond) = cond.kind {\n-            cond\n-        } else {\n-            panic!(\"If block desugar must contain DropTemps\");\n-        };\n-        let then = &arms[0].body;\n-        let els = if contains_else_clause {\n-            Some(&*arms[1].body)\n-        } else {\n-            None\n-        };\n-        Some((cond, then, els))\n-    } else {\n-        None\n-    }\n-}\n-\n /// Represent the pre-expansion arguments of a `vec!` invocation.\n pub enum VecArgs<'a> {\n     /// `vec![elem; len]`\n@@ -268,12 +240,11 @@ pub fn extract_assert_macro_args<'tcx>(e: &'tcx Expr<'tcx>) -> Option<Vec<&'tcx\n \n     if let ExprKind::Block(ref block, _) = e.kind {\n         if block.stmts.len() == 1 {\n-            if let StmtKind::Semi(ref matchexpr) = block.stmts[0].kind {\n+            if let StmtKind::Semi(ref matchexpr) = block.stmts.get(0)?.kind {\n                 // macros with unique arg: `{debug_}assert!` (e.g., `debug_assert!(some_condition)`)\n                 if_chain! {\n-                    if let ExprKind::Match(ref ifclause, _, _) = matchexpr.kind;\n-                    if let ExprKind::DropTemps(ref droptmp) = ifclause.kind;\n-                    if let ExprKind::Unary(UnOp::UnNot, condition) = droptmp.kind;\n+                    if let ExprKind::If(ref clause, _, _)  = matchexpr.kind;\n+                    if let ExprKind::Unary(UnOp::UnNot, condition) = clause.kind;\n                     then {\n                         return Some(vec![condition]);\n                     }"}, {"sha": "10120a8805db25b6c64b618fac0568a075458fb8", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 50, "deletions": 11, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -81,12 +81,12 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             }\n         }\n \n-        match (&left.kind, &right.kind) {\n+        match (&reduce_exprkind(&left.kind), &reduce_exprkind(&right.kind)) {\n             (&ExprKind::AddrOf(lb, l_mut, ref le), &ExprKind::AddrOf(rb, r_mut, ref re)) => {\n                 lb == rb && l_mut == r_mut && self.eq_expr(le, re)\n             },\n             (&ExprKind::Continue(li), &ExprKind::Continue(ri)) => {\n-                both(&li.label, &ri.label, |l, r| l.ident.as_str() == r.ident.as_str())\n+                both(&li.label, &ri.label, |l, r| l.ident.name == r.ident.name)\n             },\n             (&ExprKind::Assign(ref ll, ref lr, _), &ExprKind::Assign(ref rl, ref rr, _)) => {\n                 self.allow_side_effects && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n@@ -102,7 +102,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                     })\n             },\n             (&ExprKind::Break(li, ref le), &ExprKind::Break(ri, ref re)) => {\n-                both(&li.label, &ri.label, |l, r| l.ident.as_str() == r.ident.as_str())\n+                both(&li.label, &ri.label, |l, r| l.ident.name == r.ident.name)\n                     && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n             (&ExprKind::Box(ref l), &ExprKind::Box(ref r)) => self.eq_expr(l, r),\n@@ -119,9 +119,12 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             (&ExprKind::Index(ref la, ref li), &ExprKind::Index(ref ra, ref ri)) => {\n                 self.eq_expr(la, ra) && self.eq_expr(li, ri)\n             },\n+            (&ExprKind::If(ref lc, ref lt, ref le), &ExprKind::If(ref rc, ref rt, ref re)) => {\n+                self.eq_expr(lc, rc) && self.eq_expr(&**lt, &**rt) && both(le, re, |l, r| self.eq_expr(l, r))\n+            },\n             (&ExprKind::Lit(ref l), &ExprKind::Lit(ref r)) => l.node == r.node,\n             (&ExprKind::Loop(ref lb, ref ll, ref lls), &ExprKind::Loop(ref rb, ref rl, ref rls)) => {\n-                lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.as_str() == r.ident.as_str())\n+                lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.name == r.ident.name)\n             },\n             (&ExprKind::Match(ref le, ref la, ref ls), &ExprKind::Match(ref re, ref ra, ref rs)) => {\n                 ls == rs\n@@ -169,6 +172,8 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     fn eq_guard(&mut self, left: &Guard<'_>, right: &Guard<'_>) -> bool {\n         match (left, right) {\n             (Guard::If(l), Guard::If(r)) => self.eq_expr(l, r),\n+            (Guard::IfLet(lp, le), Guard::IfLet(rp, re)) => self.eq_pat(lp, rp) && self.eq_expr(le, re),\n+            _ => false,\n         }\n     }\n \n@@ -186,7 +191,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n \n     pub fn eq_fieldpat(&mut self, left: &FieldPat<'_>, right: &FieldPat<'_>) -> bool {\n         let (FieldPat { ident: li, pat: lp, .. }, FieldPat { ident: ri, pat: rp, .. }) = (&left, &right);\n-        li.name.as_str() == ri.name.as_str() && self.eq_pat(lp, rp)\n+        li.name == ri.name && self.eq_pat(lp, rp)\n     }\n \n     /// Checks whether two patterns are the same.\n@@ -200,7 +205,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                 self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n             },\n             (&PatKind::Binding(ref lb, .., ref li, ref lp), &PatKind::Binding(ref rb, .., ref ri, ref rp)) => {\n-                lb == rb && li.name.as_str() == ri.name.as_str() && both(lp, rp, |l, r| self.eq_pat(l, r))\n+                lb == rb && li.name == ri.name && both(lp, rp, |l, r| self.eq_pat(l, r))\n             },\n             (&PatKind::Path(ref l), &PatKind::Path(ref r)) => self.eq_qpath(l, r),\n             (&PatKind::Lit(ref l), &PatKind::Lit(ref r)) => self.eq_expr(l, r),\n@@ -261,8 +266,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     pub fn eq_path_segment(&mut self, left: &PathSegment<'_>, right: &PathSegment<'_>) -> bool {\n         // The == of idents doesn't work with different contexts,\n         // we have to be explicit about hygiene\n-        left.ident.as_str() == right.ident.as_str()\n-            && both(&left.args, &right.args, |l, r| self.eq_path_parameters(l, r))\n+        left.ident.name == right.ident.name && both(&left.args, &right.args, |l, r| self.eq_path_parameters(l, r))\n     }\n \n     pub fn eq_ty(&mut self, left: &Ty<'_>, right: &Ty<'_>) -> bool {\n@@ -306,6 +310,32 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     }\n }\n \n+/// Some simple reductions like `{ return }` => `return`\n+fn reduce_exprkind<'hir>(kind: &'hir ExprKind<'hir>) -> &ExprKind<'hir> {\n+    if let ExprKind::Block(block, _) = kind {\n+        match (block.stmts, block.expr) {\n+            // `{}` => `()`\n+            ([], None) => &ExprKind::Tup(&[]),\n+            ([], Some(expr)) => match expr.kind {\n+                // `{ return .. }` => `return ..`\n+                ExprKind::Ret(..) => &expr.kind,\n+                _ => kind,\n+            },\n+            ([stmt], None) => match stmt.kind {\n+                StmtKind::Expr(expr) | StmtKind::Semi(expr) => match expr.kind {\n+                    // `{ return ..; }` => `return ..`\n+                    ExprKind::Ret(..) => &expr.kind,\n+                    _ => kind,\n+                },\n+                _ => kind,\n+            },\n+            _ => kind,\n+        }\n+    } else {\n+        kind\n+    }\n+}\n+\n fn swap_binop<'a>(\n     binop: BinOpKind,\n     lhs: &'a Expr<'a>,\n@@ -491,7 +521,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     }\n                 }\n                 asm.options.hash(&mut self.s);\n-                for op in asm.operands {\n+                for (op, _op_sp) in asm.operands {\n                     match op {\n                         InlineAsmOperand::In { reg, expr } => {\n                             reg.hash(&mut self.s);\n@@ -536,6 +566,15 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     self.hash_name(i.ident.name);\n                 }\n             },\n+            ExprKind::If(ref cond, ref then, ref else_opt) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::If;\n+                c.hash(&mut self.s);\n+                self.hash_expr(cond);\n+                self.hash_expr(&**then);\n+                if let Some(ref e) = *else_opt {\n+                    self.hash_expr(e);\n+                }\n+            },\n             ExprKind::Match(ref e, arms, ref s) => {\n                 self.hash_expr(e);\n \n@@ -643,7 +682,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n     pub fn hash_guard(&mut self, g: &Guard<'_>) {\n         match g {\n-            Guard::If(ref expr) => {\n+            Guard::If(ref expr) | Guard::IfLet(_, ref expr) => {\n                 self.hash_expr(expr);\n             },\n         }\n@@ -716,7 +755,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     }\n                     for segment in path.segments {\n                         segment.ident.name.hash(&mut self.s);\n-                        self.hash_generic_args(segment.generic_args().args);\n+                        self.hash_generic_args(segment.args().args);\n                     }\n                 },\n                 QPath::TypeRelative(ref ty, ref segment) => {"}, {"sha": "9bec24be9e4ebc7e89da87cd09837b517733c0ce", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -213,6 +213,15 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n         hir::ExprKind::Loop(..) => {\n             println!(\"{}Loop\", ind);\n         },\n+        hir::ExprKind::If(ref cond, _, ref else_opt) => {\n+            println!(\"{}If\", ind);\n+            println!(\"{}condition:\", ind);\n+            print_expr(cx, cond, indent + 1);\n+            if let Some(ref els) = *else_opt {\n+                println!(\"{}else:\", ind);\n+                print_expr(cx, els, indent + 1);\n+            }\n+        },\n         hir::ExprKind::Match(ref cond, _, ref source) => {\n             println!(\"{}Match\", ind);\n             println!(\"{}condition:\", ind);\n@@ -293,7 +302,7 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n             println!(\"{}template: {}\", ind, InlineAsmTemplatePiece::to_string(asm.template));\n             println!(\"{}options: {:?}\", ind, asm.options);\n             println!(\"{}operands:\", ind);\n-            for op in asm.operands {\n+            for (op, _op_sp) in asm.operands {\n                 match op {\n                     hir::InlineAsmOperand::In { expr, .. }\n                     | hir::InlineAsmOperand::InOut { expr, .. }\n@@ -395,7 +404,7 @@ fn print_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n             println!(\"function of type {:#?}\", item_ty);\n         },\n         hir::ItemKind::Mod(..) => println!(\"module\"),\n-        hir::ItemKind::ForeignMod(ref fm) => println!(\"foreign module with abi: {}\", fm.abi),\n+        hir::ItemKind::ForeignMod { abi, .. } => println!(\"foreign module with abi: {}\", abi),\n         hir::ItemKind::GlobalAsm(ref asm) => println!(\"global asm: {:?}\", asm),\n         hir::ItemKind::TyAlias(..) => {\n             println!(\"type alias for {:?}\", cx.tcx.type_of(did));\n@@ -423,13 +432,13 @@ fn print_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n         hir::ItemKind::TraitAlias(..) => {\n             println!(\"trait alias\");\n         },\n-        hir::ItemKind::Impl {\n+        hir::ItemKind::Impl(hir::Impl {\n             of_trait: Some(ref _trait_ref),\n             ..\n-        } => {\n+        }) => {\n             println!(\"trait impl\");\n         },\n-        hir::ItemKind::Impl { of_trait: None, .. } => {\n+        hir::ItemKind::Impl(hir::Impl { of_trait: None, .. }) => {\n             println!(\"impl\");\n         },\n     }\n@@ -560,5 +569,10 @@ fn print_guard(cx: &LateContext<'_>, guard: &hir::Guard<'_>, indent: usize) {\n             println!(\"{}If\", ind);\n             print_expr(cx, expr, indent + 1);\n         },\n+        hir::Guard::IfLet(pat, expr) => {\n+            println!(\"{}IfLet\", ind);\n+            print_pat(cx, pat, indent + 1);\n+            print_expr(cx, expr, indent + 1);\n+        },\n     }\n }"}, {"sha": "7aa17520ba79f3070d206eb851cb5aa8bfff6c42", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 233, "deletions": 3, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -10,11 +10,15 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::CRATE_HIR_ID;\n use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n-use rustc_hir::{Crate, Expr, ExprKind, HirId, Item, MutTy, Mutability, Node, Path, StmtKind, Ty, TyKind};\n+use rustc_hir::{\n+    BinOpKind, Crate, Expr, ExprKind, HirId, Item, MutTy, Mutability, Node, Path, StmtKind, Ty, TyKind, UnOp,\n+};\n use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n+use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n@@ -247,6 +251,52 @@ declare_clippy_lint! {\n     \"invalid path\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Checks for interning symbols that have already been pre-interned and defined as constants.\n+    ///\n+    /// **Why is this bad?**\n+    /// It's faster and easier to use the symbol constant.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// Bad:\n+    /// ```rust,ignore\n+    /// let _ = sym!(f32);\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust,ignore\n+    /// let _ = sym::f32;\n+    /// ```\n+    pub INTERNING_DEFINED_SYMBOL,\n+    internal,\n+    \"interning a symbol that is pre-interned and defined as a constant\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for unnecessary conversion from Symbol to a string.\n+    ///\n+    /// **Why is this bad?** It's faster use symbols directly intead of strings.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// Bad:\n+    /// ```rust,ignore\n+    /// symbol.as_str() == \"clippy\";\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust,ignore\n+    /// symbol == sym::clippy;\n+    /// ```\n+    pub UNNECESSARY_SYMBOL_STR,\n+    internal,\n+    \"unnecessary conversion between Symbol and string\"\n+}\n+\n declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n \n impl EarlyLintPass for ClippyLintsInternal {\n@@ -327,11 +377,11 @@ impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n         } else if is_expn_of(item.span, \"impl_lint_pass\").is_some()\n             || is_expn_of(item.span, \"declare_lint_pass\").is_some()\n         {\n-            if let hir::ItemKind::Impl {\n+            if let hir::ItemKind::Impl(hir::Impl {\n                 of_trait: None,\n                 items: ref impl_item_refs,\n                 ..\n-            } = item.kind\n+            }) = item.kind\n             {\n                 let mut collector = LintCollector {\n                     output: &mut self.registered_lints,\n@@ -840,3 +890,183 @@ impl<'tcx> LateLintPass<'tcx> for InvalidPaths {\n         }\n     }\n }\n+\n+#[derive(Default)]\n+pub struct InterningDefinedSymbol {\n+    // Maps the symbol value to the constant DefId.\n+    symbol_map: FxHashMap<u32, DefId>,\n+}\n+\n+impl_lint_pass!(InterningDefinedSymbol => [INTERNING_DEFINED_SYMBOL, UNNECESSARY_SYMBOL_STR]);\n+\n+impl<'tcx> LateLintPass<'tcx> for InterningDefinedSymbol {\n+    fn check_crate(&mut self, cx: &LateContext<'_>, _: &Crate<'_>) {\n+        if !self.symbol_map.is_empty() {\n+            return;\n+        }\n+\n+        for &module in &[&paths::KW_MODULE, &paths::SYM_MODULE] {\n+            if let Some(Res::Def(_, def_id)) = path_to_res(cx, module) {\n+                for item in cx.tcx.item_children(def_id).iter() {\n+                    if_chain! {\n+                        if let Res::Def(DefKind::Const, item_def_id) = item.res;\n+                        let ty = cx.tcx.type_of(item_def_id);\n+                        if match_type(cx, ty, &paths::SYMBOL);\n+                        if let Ok(ConstValue::Scalar(value)) = cx.tcx.const_eval_poly(item_def_id);\n+                        if let Ok(value) = value.to_u32();\n+                        then {\n+                            self.symbol_map.insert(value, item_def_id);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::Call(func, [arg]) = &expr.kind;\n+            if let ty::FnDef(def_id, _) = cx.typeck_results().expr_ty(func).kind();\n+            if match_def_path(cx, *def_id, &paths::SYMBOL_INTERN);\n+            if let Some(Constant::Str(arg)) = constant_simple(cx, cx.typeck_results(), arg);\n+            let value = Symbol::intern(&arg).as_u32();\n+            if let Some(&def_id) = self.symbol_map.get(&value);\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    INTERNING_DEFINED_SYMBOL,\n+                    is_expn_of(expr.span, \"sym\").unwrap_or(expr.span),\n+                    \"interning a defined symbol\",\n+                    \"try\",\n+                    cx.tcx.def_path_str(def_id),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+        if let ExprKind::Binary(op, left, right) = expr.kind {\n+            if matches!(op.node, BinOpKind::Eq | BinOpKind::Ne) {\n+                let data = [\n+                    (left, self.symbol_str_expr(left, cx)),\n+                    (right, self.symbol_str_expr(right, cx)),\n+                ];\n+                match data {\n+                    // both operands are a symbol string\n+                    [(_, Some(left)), (_, Some(right))] => {\n+                        span_lint_and_sugg(\n+                            cx,\n+                            UNNECESSARY_SYMBOL_STR,\n+                            expr.span,\n+                            \"unnecessary `Symbol` to string conversion\",\n+                            \"try\",\n+                            format!(\n+                                \"{} {} {}\",\n+                                left.as_symbol_snippet(cx),\n+                                op.node.as_str(),\n+                                right.as_symbol_snippet(cx),\n+                            ),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    },\n+                    // one of the operands is a symbol string\n+                    [(expr, Some(symbol)), _] | [_, (expr, Some(symbol))] => {\n+                        // creating an owned string for comparison\n+                        if matches!(symbol, SymbolStrExpr::Expr { is_to_owned: true, .. }) {\n+                            span_lint_and_sugg(\n+                                cx,\n+                                UNNECESSARY_SYMBOL_STR,\n+                                expr.span,\n+                                \"unnecessary string allocation\",\n+                                \"try\",\n+                                format!(\"{}.as_str()\", symbol.as_symbol_snippet(cx)),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                    },\n+                    // nothing found\n+                    [(_, None), (_, None)] => {},\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl InterningDefinedSymbol {\n+    fn symbol_str_expr<'tcx>(&self, expr: &'tcx Expr<'tcx>, cx: &LateContext<'tcx>) -> Option<SymbolStrExpr<'tcx>> {\n+        static IDENT_STR_PATHS: &[&[&str]] = &[&paths::IDENT_AS_STR, &paths::TO_STRING_METHOD];\n+        static SYMBOL_STR_PATHS: &[&[&str]] = &[\n+            &paths::SYMBOL_AS_STR,\n+            &paths::SYMBOL_TO_IDENT_STRING,\n+            &paths::TO_STRING_METHOD,\n+        ];\n+        // SymbolStr might be de-referenced: `&*symbol.as_str()`\n+        let call = if_chain! {\n+            if let ExprKind::AddrOf(_, _, e) = expr.kind;\n+            if let ExprKind::Unary(UnOp::UnDeref, e) = e.kind;\n+            then { e } else { expr }\n+        };\n+        if_chain! {\n+            // is a method call\n+            if let ExprKind::MethodCall(_, _, [item], _) = call.kind;\n+            if let Some(did) = cx.typeck_results().type_dependent_def_id(call.hir_id);\n+            let ty = cx.typeck_results().expr_ty(item);\n+            // ...on either an Ident or a Symbol\n+            if let Some(is_ident) = if match_type(cx, ty, &paths::SYMBOL) {\n+                Some(false)\n+            } else if match_type(cx, ty, &paths::IDENT) {\n+                Some(true)\n+            } else {\n+                None\n+            };\n+            // ...which converts it to a string\n+            let paths = if is_ident { IDENT_STR_PATHS } else { SYMBOL_STR_PATHS };\n+            if let Some(path) = paths.iter().find(|path| match_def_path(cx, did, path));\n+            then {\n+                let is_to_owned = path.last().unwrap().ends_with(\"string\");\n+                return Some(SymbolStrExpr::Expr {\n+                    item,\n+                    is_ident,\n+                    is_to_owned,\n+                });\n+            }\n+        }\n+        // is a string constant\n+        if let Some(Constant::Str(s)) = constant_simple(cx, cx.typeck_results(), expr) {\n+            let value = Symbol::intern(&s).as_u32();\n+            // ...which matches a symbol constant\n+            if let Some(&def_id) = self.symbol_map.get(&value) {\n+                return Some(SymbolStrExpr::Const(def_id));\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+enum SymbolStrExpr<'tcx> {\n+    /// a string constant with a corresponding symbol constant\n+    Const(DefId),\n+    /// a \"symbol to string\" expression like `symbol.as_str()`\n+    Expr {\n+        /// part that evaluates to `Symbol` or `Ident`\n+        item: &'tcx Expr<'tcx>,\n+        is_ident: bool,\n+        /// whether an owned `String` is created like `to_ident_string()`\n+        is_to_owned: bool,\n+    },\n+}\n+\n+impl<'tcx> SymbolStrExpr<'tcx> {\n+    /// Returns a snippet that evaluates to a `Symbol` and is const if possible\n+    fn as_symbol_snippet(&self, cx: &LateContext<'_>) -> Cow<'tcx, str> {\n+        match *self {\n+            Self::Const(def_id) => cx.tcx.def_path_str(def_id).into(),\n+            Self::Expr { item, is_ident, .. } => {\n+                let mut snip = snippet(cx, item.span.source_callsite(), \"..\");\n+                if is_ident {\n+                    // get `Ident.name`\n+                    snip.to_mut().push_str(\".name\");\n+                }\n+                snip\n+            },\n+        }\n+    }\n+}"}, {"sha": "62aae749c17dce2a9fb395f84eca16ac130072e1", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 137, "deletions": 25, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,5 +1,5 @@\n #[macro_use]\n-pub mod sym;\n+pub mod sym_helper;\n \n #[allow(clippy::module_name_repetitions)]\n pub mod ast_utils;\n@@ -14,6 +14,7 @@ pub mod eager_or_lazy;\n pub mod higher;\n mod hir_utils;\n pub mod inspector;\n+#[cfg(feature = \"internal-lints\")]\n pub mod internal_lints;\n pub mod numeric_literal;\n pub mod paths;\n@@ -40,7 +41,7 @@ use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n+use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::Node;\n use rustc_hir::{\n     def, Arm, Block, Body, Constness, Crate, Expr, ExprKind, FnDecl, HirId, ImplItem, ImplItemKind, Item, ItemKind,\n@@ -51,21 +52,21 @@ use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n use rustc_middle::ty::{self, layout::IntegerExt, Ty, TyCtxt, TypeFoldable};\n+use rustc_semver::RustcVersion;\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::original_sp;\n-use rustc_span::sym as rustc_sym;\n-use rustc_span::symbol::{self, kw, Symbol};\n+use rustc_span::sym;\n+use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{BytePos, Pos, Span, DUMMY_SP};\n use rustc_target::abi::Integer;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n-use semver::{Version, VersionReq};\n use smallvec::SmallVec;\n \n use crate::consts::{constant, Constant};\n \n-pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<VersionReq> {\n-    if let Ok(version) = VersionReq::parse(msrv) {\n+pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<RustcVersion> {\n+    if let Ok(version) = RustcVersion::parse(msrv) {\n         return Some(version);\n     } else if let Some(sess) = sess {\n         if let Some(span) = span {\n@@ -75,8 +76,8 @@ pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Opt\n     None\n }\n \n-pub fn meets_msrv(msrv: Option<&VersionReq>, lint_msrv: &Version) -> bool {\n-    msrv.map_or(true, |msrv| !msrv.matches(lint_msrv))\n+pub fn meets_msrv(msrv: Option<&RustcVersion>, lint_msrv: &RustcVersion) -> bool {\n+    msrv.map_or(true, |msrv| msrv.meets(*lint_msrv))\n }\n \n macro_rules! extract_msrv_attr {\n@@ -438,8 +439,8 @@ pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n     if_chain! {\n         if parent_impl != hir::CRATE_HIR_ID;\n         if let hir::Node::Item(item) = cx.tcx.hir().get(parent_impl);\n-        if let hir::ItemKind::Impl{ of_trait: trait_ref, .. } = &item.kind;\n-        then { return trait_ref.as_ref(); }\n+        if let hir::ItemKind::Impl(impl_) = &item.kind;\n+        then { return impl_.of_trait.as_ref(); }\n     }\n     None\n }\n@@ -572,6 +573,67 @@ pub fn contains_name(name: Symbol, expr: &Expr<'_>) -> bool {\n     cn.result\n }\n \n+/// Returns `true` if `expr` contains a return expression\n+pub fn contains_return(expr: &hir::Expr<'_>) -> bool {\n+    struct RetCallFinder {\n+        found: bool,\n+    }\n+\n+    impl<'tcx> hir::intravisit::Visitor<'tcx> for RetCallFinder {\n+        type Map = Map<'tcx>;\n+\n+        fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n+            if self.found {\n+                return;\n+            }\n+            if let hir::ExprKind::Ret(..) = &expr.kind {\n+                self.found = true;\n+            } else {\n+                hir::intravisit::walk_expr(self, expr);\n+            }\n+        }\n+\n+        fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n+            hir::intravisit::NestedVisitorMap::None\n+        }\n+    }\n+\n+    let mut visitor = RetCallFinder { found: false };\n+    visitor.visit_expr(expr);\n+    visitor.found\n+}\n+\n+struct FindMacroCalls<'a, 'b> {\n+    names: &'a [&'b str],\n+    result: Vec<Span>,\n+}\n+\n+impl<'a, 'b, 'tcx> Visitor<'tcx> for FindMacroCalls<'a, 'b> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.names.iter().any(|fun| is_expn_of(expr.span, fun).is_some()) {\n+            self.result.push(expr.span);\n+        }\n+        // and check sub-expressions\n+        intravisit::walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Finds calls of the specified macros in a function body.\n+pub fn find_macro_calls(names: &[&str], body: &Body<'_>) -> Vec<Span> {\n+    let mut fmc = FindMacroCalls {\n+        names,\n+        result: Vec::new(),\n+    };\n+    fmc.visit_expr(&body.value);\n+    fmc.result\n+}\n+\n /// Converts a span to a code snippet if available, otherwise use default.\n ///\n /// This is useful if you want to provide suggestions for your lint or more generally, if you want\n@@ -726,8 +788,7 @@ pub fn indent_of<T: LintContext>(cx: &T, span: Span) -> Option<usize> {\n /// fn into3(self)   -> () {}\n ///               ^\n /// ```\n-#[allow(clippy::needless_pass_by_value)]\n-pub fn position_before_rarrow(s: String) -> Option<usize> {\n+pub fn position_before_rarrow(s: &str) -> Option<usize> {\n     s.rfind(\"->\").map(|rpos| {\n         let mut rpos = rpos;\n         let chars: Vec<char> = s.chars().collect();\n@@ -1060,7 +1121,7 @@ pub fn is_refutable(cx: &LateContext<'_>, pat: &Pat<'_>) -> bool {\n /// Checks for the `#[automatically_derived]` attribute all `#[derive]`d\n /// implementations have.\n pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n-    attrs.iter().any(|attr| attr.has_name(rustc_sym::automatically_derived))\n+    attrs.iter().any(|attr| attr.has_name(sym::automatically_derived))\n }\n \n /// Remove blocks around an expression.\n@@ -1344,7 +1405,7 @@ pub fn if_sequence<'tcx>(\n     let mut conds = SmallVec::new();\n     let mut blocks: SmallVec<[&Block<'_>; 1]> = SmallVec::new();\n \n-    while let Some((ref cond, ref then_expr, ref else_expr)) = higher::if_block(&expr) {\n+    while let ExprKind::If(ref cond, ref then_expr, ref else_expr) = expr.kind {\n         conds.push(&**cond);\n         if let ExprKind::Block(ref block, _) = then_expr.kind {\n             blocks.push(block);\n@@ -1373,12 +1434,13 @@ pub fn parent_node_is_if_expr(expr: &Expr<'_>, cx: &LateContext<'_>) -> bool {\n     let map = cx.tcx.hir();\n     let parent_id = map.get_parent_node(expr.hir_id);\n     let parent_node = map.get(parent_id);\n-\n-    match parent_node {\n-        Node::Expr(e) => higher::if_block(&e).is_some(),\n-        Node::Arm(e) => higher::if_block(&e.body).is_some(),\n-        _ => false,\n-    }\n+    matches!(\n+        parent_node,\n+        Node::Expr(Expr {\n+            kind: ExprKind::If(_, _, _),\n+            ..\n+        })\n+    )\n }\n \n // Finds the attribute with the given name, if any\n@@ -1418,8 +1480,8 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n             false\n         },\n         ty::Dynamic(binder, _) => {\n-            for predicate in binder.skip_binder().iter() {\n-                if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate {\n+            for predicate in binder.iter() {\n+                if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder() {\n                     if must_use_attr(&cx.tcx.get_attrs(trait_ref.def_id)).is_some() {\n                         return true;\n                     }\n@@ -1453,7 +1515,7 @@ pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n pub fn is_no_std_crate(krate: &Crate<'_>) -> bool {\n     krate.item.attrs.iter().any(|attr| {\n         if let ast::AttrKind::Normal(ref attr, _) = attr.kind {\n-            attr.path == symbol::sym::no_std\n+            attr.path == sym::no_std\n         } else {\n             false\n         }\n@@ -1469,7 +1531,7 @@ pub fn is_no_std_crate(krate: &Crate<'_>) -> bool {\n /// ```\n pub fn is_trait_impl_item(cx: &LateContext<'_>, hir_id: HirId) -> bool {\n     if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n-        matches!(item.kind, ItemKind::Impl{ of_trait: Some(_), .. })\n+        matches!(item.kind, ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }))\n     } else {\n         false\n     }\n@@ -1607,6 +1669,44 @@ where\n     match_expr_list\n }\n \n+/// Peels off all references on the pattern. Returns the underlying pattern and the number of\n+/// references removed.\n+pub fn peel_hir_pat_refs(pat: &'a Pat<'a>) -> (&'a Pat<'a>, usize) {\n+    fn peel(pat: &'a Pat<'a>, count: usize) -> (&'a Pat<'a>, usize) {\n+        if let PatKind::Ref(pat, _) = pat.kind {\n+            peel(pat, count + 1)\n+        } else {\n+            (pat, count)\n+        }\n+    }\n+    peel(pat, 0)\n+}\n+\n+/// Peels off up to the given number of references on the expression. Returns the underlying\n+/// expression and the number of references removed.\n+pub fn peel_n_hir_expr_refs(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n+    fn f(expr: &'a Expr<'a>, count: usize, target: usize) -> (&'a Expr<'a>, usize) {\n+        match expr.kind {\n+            ExprKind::AddrOf(_, _, expr) if count != target => f(expr, count + 1, target),\n+            _ => (expr, count),\n+        }\n+    }\n+    f(expr, 0, count)\n+}\n+\n+/// Peels off all references on the type. Returns the underlying type and the number of references\n+/// removed.\n+pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n+    fn peel(ty: Ty<'_>, count: usize) -> (Ty<'_>, usize) {\n+        if let ty::Ref(_, ty, _) = ty.kind() {\n+            peel(ty, count + 1)\n+        } else {\n+            (ty, count)\n+        }\n+    }\n+    peel(ty, 0)\n+}\n+\n #[macro_export]\n macro_rules! unwrap_cargo_metadata {\n     ($cx: ident, $lint: ident, $deps: expr) => {{\n@@ -1625,6 +1725,18 @@ macro_rules! unwrap_cargo_metadata {\n     }};\n }\n \n+pub fn is_hir_ty_cfg_dependant(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n+    if_chain! {\n+        if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind;\n+        if let Res::Def(_, def_id) = path.res;\n+        then {\n+            cx.tcx.has_attr(def_id, sym::cfg) || cx.tcx.has_attr(def_id, sym::cfg_attr)\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::{reindent_multiline, without_block_comments};"}, {"sha": "c0b203b5388dce969ecb3a77662022d32d2532b8", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -20,6 +20,8 @@ pub const CLONE_TRAIT: [&str; 3] = [\"core\", \"clone\", \"Clone\"];\n pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const CMP_MAX: [&str; 3] = [\"core\", \"cmp\", \"max\"];\n pub const CMP_MIN: [&str; 3] = [\"core\", \"cmp\", \"min\"];\n+pub const COPY: [&str; 3] = [\"core\", \"intrinsics\", \"copy_nonoverlapping\"];\n+pub const COPY_NONOVERLAPPING: [&str; 3] = [\"core\", \"intrinsics\", \"copy\"];\n pub const COW: [&str; 3] = [\"alloc\", \"borrow\", \"Cow\"];\n pub const CSTRING_AS_C_STR: [&str; 5] = [\"std\", \"ffi\", \"c_str\", \"CString\", \"as_c_str\"];\n pub const DEFAULT_TRAIT: [&str; 3] = [\"core\", \"default\", \"Default\"];\n@@ -31,6 +33,7 @@ pub const DISPLAY_TRAIT: [&str; 3] = [\"core\", \"fmt\", \"Display\"];\n pub const DOUBLE_ENDED_ITERATOR: [&str; 4] = [\"core\", \"iter\", \"traits\", \"DoubleEndedIterator\"];\n pub const DROP: [&str; 3] = [\"core\", \"mem\", \"drop\"];\n pub const DURATION: [&str; 3] = [\"core\", \"time\", \"Duration\"];\n+#[cfg(feature = \"internal-lints\")]\n pub const EARLY_CONTEXT: [&str; 2] = [\"rustc_lint\", \"EarlyContext\"];\n pub const EXIT: [&str; 3] = [\"std\", \"process\", \"exit\"];\n pub const F32_EPSILON: [&str; 4] = [\"core\", \"f32\", \"<impl f32>\", \"EPSILON\"];\n@@ -51,23 +54,35 @@ pub const HASH: [&str; 3] = [\"core\", \"hash\", \"Hash\"];\n pub const HASHMAP: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n pub const HASHSET: [&str; 5] = [\"std\", \"collections\", \"hash\", \"set\", \"HashSet\"];\n+#[cfg(feature = \"internal-lints\")]\n+pub const IDENT: [&str; 3] = [\"rustc_span\", \"symbol\", \"Ident\"];\n+#[cfg(feature = \"internal-lints\")]\n+pub const IDENT_AS_STR: [&str; 4] = [\"rustc_span\", \"symbol\", \"Ident\", \"as_str\"];\n pub const INDEX: [&str; 3] = [\"core\", \"ops\", \"Index\"];\n pub const INDEX_MUT: [&str; 3] = [\"core\", \"ops\", \"IndexMut\"];\n pub const INSERT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"insert_str\"];\n pub const INTO: [&str; 3] = [\"core\", \"convert\", \"Into\"];\n pub const INTO_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"IntoIterator\"];\n pub const IO_READ: [&str; 3] = [\"std\", \"io\", \"Read\"];\n pub const IO_WRITE: [&str; 3] = [\"std\", \"io\", \"Write\"];\n+pub const IPADDR_V4: [&str; 4] = [\"std\", \"net\", \"IpAddr\", \"V4\"];\n+pub const IPADDR_V6: [&str; 4] = [\"std\", \"net\", \"IpAddr\", \"V6\"];\n pub const ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\"];\n+#[cfg(feature = \"internal-lints\")]\n+pub const KW_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"kw\"];\n+#[cfg(feature = \"internal-lints\")]\n pub const LATE_CONTEXT: [&str; 2] = [\"rustc_lint\", \"LateContext\"];\n pub const LINKED_LIST: [&str; 4] = [\"alloc\", \"collections\", \"linked_list\", \"LinkedList\"];\n+#[cfg(feature = \"internal-lints\")]\n pub const LINT: [&str; 2] = [\"rustc_lint_defs\", \"Lint\"];\n pub const MEM_DISCRIMINANT: [&str; 3] = [\"core\", \"mem\", \"discriminant\"];\n pub const MEM_FORGET: [&str; 3] = [\"core\", \"mem\", \"forget\"];\n pub const MEM_MANUALLY_DROP: [&str; 4] = [\"core\", \"mem\", \"manually_drop\", \"ManuallyDrop\"];\n pub const MEM_MAYBEUNINIT: [&str; 4] = [\"core\", \"mem\", \"maybe_uninit\", \"MaybeUninit\"];\n pub const MEM_MAYBEUNINIT_UNINIT: [&str; 5] = [\"core\", \"mem\", \"maybe_uninit\", \"MaybeUninit\", \"uninit\"];\n pub const MEM_REPLACE: [&str; 3] = [\"core\", \"mem\", \"replace\"];\n+pub const MEM_SIZE_OF: [&str; 3] = [\"core\", \"mem\", \"size_of\"];\n+pub const MEM_SIZE_OF_VAL: [&str; 3] = [\"core\", \"mem\", \"size_of_val\"];\n pub const MUTEX_GUARD: [&str; 4] = [\"std\", \"sync\", \"mutex\", \"MutexGuard\"];\n pub const OPEN_OPTIONS: [&str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n pub const OPS_MODULE: [&str; 2] = [\"core\", \"ops\"];\n@@ -95,6 +110,9 @@ pub const POLL_READY: [&str; 5] = [\"core\", \"task\", \"poll\", \"Poll\", \"Ready\"];\n pub const PTR_EQ: [&str; 3] = [\"core\", \"ptr\", \"eq\"];\n pub const PTR_NULL: [&str; 3] = [\"core\", \"ptr\", \"null\"];\n pub const PTR_NULL_MUT: [&str; 3] = [\"core\", \"ptr\", \"null_mut\"];\n+pub const PTR_SLICE_FROM_RAW_PARTS: [&str; 3] = [\"core\", \"ptr\", \"slice_from_raw_parts\"];\n+pub const PTR_SLICE_FROM_RAW_PARTS_MUT: [&str; 3] = [\"core\", \"ptr\", \"slice_from_raw_parts_mut\"];\n+pub const PTR_SWAP_NONOVERLAPPING: [&str; 3] = [\"core\", \"ptr\", \"swap_nonoverlapping\"];\n pub const PUSH_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"push_str\"];\n pub const RANGE_ARGUMENT_TRAIT: [&str; 3] = [\"core\", \"ops\", \"RangeBounds\"];\n pub const RC: [&str; 3] = [\"alloc\", \"rc\", \"Rc\"];\n@@ -116,6 +134,8 @@ pub const RWLOCK_READ_GUARD: [&str; 4] = [\"std\", \"sync\", \"rwlock\", \"RwLockReadGu\n pub const RWLOCK_WRITE_GUARD: [&str; 4] = [\"std\", \"sync\", \"rwlock\", \"RwLockWriteGuard\"];\n pub const SERDE_DESERIALIZE: [&str; 3] = [\"serde\", \"de\", \"Deserialize\"];\n pub const SERDE_DE_VISITOR: [&str; 3] = [\"serde\", \"de\", \"Visitor\"];\n+pub const SLICE_FROM_RAW_PARTS: [&str; 4] = [\"core\", \"slice\", \"raw\", \"from_raw_parts\"];\n+pub const SLICE_FROM_RAW_PARTS_MUT: [&str; 4] = [\"core\", \"slice\", \"raw\", \"from_raw_parts_mut\"];\n pub const SLICE_INTO_VEC: [&str; 4] = [\"alloc\", \"slice\", \"<impl [T]>\", \"into_vec\"];\n pub const SLICE_ITER: [&str; 4] = [\"core\", \"slice\", \"iter\", \"Iter\"];\n pub const STDERR: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stderr\"];\n@@ -131,6 +151,17 @@ pub const STR_ENDS_WITH: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"ends_with\"];\n pub const STR_FROM_UTF8: [&str; 4] = [\"core\", \"str\", \"converts\", \"from_utf8\"];\n pub const STR_LEN: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"len\"];\n pub const STR_STARTS_WITH: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"starts_with\"];\n+#[cfg(feature = \"internal-lints\")]\n+pub const SYMBOL: [&str; 3] = [\"rustc_span\", \"symbol\", \"Symbol\"];\n+#[cfg(feature = \"internal-lints\")]\n+pub const SYMBOL_AS_STR: [&str; 4] = [\"rustc_span\", \"symbol\", \"Symbol\", \"as_str\"];\n+#[cfg(feature = \"internal-lints\")]\n+pub const SYMBOL_INTERN: [&str; 4] = [\"rustc_span\", \"symbol\", \"Symbol\", \"intern\"];\n+#[cfg(feature = \"internal-lints\")]\n+pub const SYMBOL_TO_IDENT_STRING: [&str; 4] = [\"rustc_span\", \"symbol\", \"Symbol\", \"to_ident_string\"];\n+#[cfg(feature = \"internal-lints\")]\n+pub const SYM_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"sym\"];\n+#[cfg(feature = \"internal-lints\")]\n pub const SYNTAX_CONTEXT: [&str; 3] = [\"rustc_span\", \"hygiene\", \"SyntaxContext\"];\n pub const TO_OWNED: [&str; 3] = [\"alloc\", \"borrow\", \"ToOwned\"];\n pub const TO_OWNED_METHOD: [&str; 4] = [\"alloc\", \"borrow\", \"ToOwned\", \"to_owned\"];\n@@ -148,3 +179,4 @@ pub const VEC_NEW: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"new\"];\n pub const VEC_RESIZE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"resize\"];\n pub const WEAK_ARC: [&str; 3] = [\"alloc\", \"sync\", \"Weak\"];\n pub const WEAK_RC: [&str; 3] = [\"alloc\", \"rc\", \"Weak\"];\n+pub const WRITE_BYTES: [&str; 3] = [\"core\", \"intrinsics\", \"write_bytes\"];"}, {"sha": "b330f3d890e9cc6e4a3823629e30a0cb2f04d942", "filename": "clippy_lints/src/utils/ptr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fptr.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -72,7 +72,6 @@ impl<'a, 'tcx> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            return;\n         }\n         walk_expr(self, expr);\n     }"}, {"sha": "03678db575f0daceef3b58445d55d80c0172b6fd", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -103,6 +103,7 @@ impl<'a> Sugg<'a> {\n         match expr.kind {\n             hir::ExprKind::AddrOf(..)\n             | hir::ExprKind::Box(..)\n+            | hir::ExprKind::If(..)\n             | hir::ExprKind::Closure(..)\n             | hir::ExprKind::Unary(..)\n             | hir::ExprKind::Match(..) => Sugg::MaybeParen(snippet),"}, {"sha": "f47dc80ebade8222716a721293eb00b50e80aa52", "filename": "clippy_lints/src/utils/sym_helper.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fsym_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fsym_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsym_helper.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,4 +1,5 @@\n #[macro_export]\n+/// Convenience wrapper around rustc's `Symbol::intern`\n macro_rules! sym {\n     ($tt:tt) => {\n         rustc_span::symbol::Symbol::intern(stringify!($tt))", "previous_filename": "clippy_lints/src/utils/sym.rs"}, {"sha": "fc0db7f64ec9550dbc0dc830c6fb5c833a2a6a24", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -116,20 +116,27 @@ pub struct ParamBindingIdCollector {\n }\n impl<'tcx> ParamBindingIdCollector {\n     fn collect_binding_hir_ids(body: &'tcx hir::Body<'tcx>) -> Vec<hir::HirId> {\n-        let mut finder = ParamBindingIdCollector {\n-            binding_hir_ids: Vec::new(),\n-        };\n-        finder.visit_body(body);\n-        finder.binding_hir_ids\n+        let mut hir_ids: Vec<hir::HirId> = Vec::new();\n+        for param in body.params.iter() {\n+            let mut finder = ParamBindingIdCollector {\n+                binding_hir_ids: Vec::new(),\n+            };\n+            finder.visit_param(param);\n+            for hir_id in &finder.binding_hir_ids {\n+                hir_ids.push(*hir_id);\n+            }\n+        }\n+        hir_ids\n     }\n }\n impl<'tcx> intravisit::Visitor<'tcx> for ParamBindingIdCollector {\n     type Map = Map<'tcx>;\n \n-    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n-        if let hir::PatKind::Binding(_, hir_id, ..) = param.pat.kind {\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n+        if let hir::PatKind::Binding(_, hir_id, ..) = pat.kind {\n             self.binding_hir_ids.push(hir_id);\n         }\n+        intravisit::walk_pat(self, pat);\n     }\n \n     fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {"}, {"sha": "ebf69df31ca41e3702b00a1a91461b980ede5e72", "filename": "clippy_lints/src/utils/visitors.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Futils%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fvisitors.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,5 +1,7 @@\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{self, Visitor};\n+use rustc_hir::def::Res;\n+use rustc_hir::intravisit::{self, walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{Arm, Expr, ExprKind, HirId, QPath, Stmt};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n \n@@ -99,6 +101,13 @@ where\n                 }\n             } else {\n                 match expr.kind {\n+                    hir::ExprKind::If(cond, then, else_opt) => {\n+                        self.inside_stmt(true).visit_expr(cond);\n+                        self.visit_expr(then);\n+                        if let Some(el) = else_opt {\n+                            self.visit_expr(el);\n+                        }\n+                    },\n                     hir::ExprKind::Match(cond, arms, _) => {\n                         self.inside_stmt(true).visit_expr(cond);\n                         for arm in arms {\n@@ -123,3 +132,54 @@ where\n         !ret_finder.failed\n     }\n }\n+\n+pub struct LocalUsedVisitor {\n+    pub local_hir_id: HirId,\n+    pub used: bool,\n+}\n+\n+impl LocalUsedVisitor {\n+    pub fn new(local_hir_id: HirId) -> Self {\n+        Self {\n+            local_hir_id,\n+            used: false,\n+        }\n+    }\n+\n+    fn check<T>(&mut self, t: T, visit: fn(&mut Self, T)) -> bool {\n+        visit(self, t);\n+        std::mem::replace(&mut self.used, false)\n+    }\n+\n+    pub fn check_arm(&mut self, arm: &Arm<'_>) -> bool {\n+        self.check(arm, Self::visit_arm)\n+    }\n+\n+    pub fn check_expr(&mut self, expr: &Expr<'_>) -> bool {\n+        self.check(expr, Self::visit_expr)\n+    }\n+\n+    pub fn check_stmt(&mut self, stmt: &Stmt<'_>) -> bool {\n+        self.check(stmt, Self::visit_stmt)\n+    }\n+}\n+\n+impl<'v> Visitor<'v> for LocalUsedVisitor {\n+    type Map = Map<'v>;\n+\n+    fn visit_expr(&mut self, expr: &'v Expr<'v>) {\n+        if let ExprKind::Path(QPath::Resolved(None, path)) = expr.kind {\n+            if let Res::Local(id) = path.res {\n+                if id == self.local_hir_id {\n+                    self.used = true;\n+                    return;\n+                }\n+            }\n+        }\n+        walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "e632a7e57ee87b22fd351a80a3497bec5804a4de", "filename": "clippy_lints/src/vec_init_then_push.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec_init_then_push.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,187 @@\n+use crate::utils::{is_type_diagnostic_item, match_def_path, paths, snippet, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, Local, PatKind, QPath, Stmt, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{symbol::sym, Span, Symbol};\n+use std::convert::TryInto;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `push` immediately after creating a new `Vec`.\n+    ///\n+    /// **Why is this bad?** The `vec![]` macro is both more performant and easier to read than\n+    /// multiple `push` calls.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let mut v = Vec::new();\n+    /// v.push(0);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let v = vec![0];\n+    /// ```\n+    pub VEC_INIT_THEN_PUSH,\n+    perf,\n+    \"`push` immediately after `Vec` creation\"\n+}\n+\n+impl_lint_pass!(VecInitThenPush => [VEC_INIT_THEN_PUSH]);\n+\n+#[derive(Default)]\n+pub struct VecInitThenPush {\n+    searcher: Option<VecPushSearcher>,\n+}\n+\n+#[derive(Clone, Copy)]\n+enum VecInitKind {\n+    New,\n+    WithCapacity(u64),\n+}\n+struct VecPushSearcher {\n+    init: VecInitKind,\n+    name: Symbol,\n+    lhs_is_local: bool,\n+    lhs_span: Span,\n+    err_span: Span,\n+    found: u64,\n+}\n+impl VecPushSearcher {\n+    fn display_err(&self, cx: &LateContext<'_>) {\n+        match self.init {\n+            _ if self.found == 0 => return,\n+            VecInitKind::WithCapacity(x) if x > self.found => return,\n+            _ => (),\n+        };\n+\n+        let mut s = if self.lhs_is_local {\n+            String::from(\"let \")\n+        } else {\n+            String::new()\n+        };\n+        s.push_str(&snippet(cx, self.lhs_span, \"..\"));\n+        s.push_str(\" = vec![..];\");\n+\n+        span_lint_and_sugg(\n+            cx,\n+            VEC_INIT_THEN_PUSH,\n+            self.err_span,\n+            \"calls to `push` immediately after creation\",\n+            \"consider using the `vec![]` macro\",\n+            s,\n+            Applicability::HasPlaceholders,\n+        );\n+    }\n+}\n+\n+impl LateLintPass<'_> for VecInitThenPush {\n+    fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'tcx>) {\n+        self.searcher = None;\n+        if_chain! {\n+            if !in_external_macro(cx.sess(), local.span);\n+            if let Some(init) = local.init;\n+            if let PatKind::Binding(BindingAnnotation::Mutable, _, ident, None) = local.pat.kind;\n+            if let Some(init_kind) = get_vec_init_kind(cx, init);\n+            then {\n+                self.searcher = Some(VecPushSearcher {\n+                        init: init_kind,\n+                        name: ident.name,\n+                        lhs_is_local: true,\n+                        lhs_span: local.ty.map_or(local.pat.span, |t| local.pat.span.to(t.span)),\n+                        err_span: local.span,\n+                        found: 0,\n+                    });\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if self.searcher.is_none() {\n+            if_chain! {\n+                if !in_external_macro(cx.sess(), expr.span);\n+                if let ExprKind::Assign(left, right, _) = expr.kind;\n+                if let ExprKind::Path(QPath::Resolved(_, path)) = left.kind;\n+                if let Some(name) = path.segments.get(0);\n+                if let Some(init_kind) = get_vec_init_kind(cx, right);\n+                then {\n+                    self.searcher = Some(VecPushSearcher {\n+                        init: init_kind,\n+                        name: name.ident.name,\n+                        lhs_is_local: false,\n+                        lhs_span: left.span,\n+                        err_span: expr.span,\n+                        found: 0,\n+                    });\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n+        if let Some(searcher) = self.searcher.take() {\n+            if_chain! {\n+                if let StmtKind::Expr(expr) | StmtKind::Semi(expr) = stmt.kind;\n+                if let ExprKind::MethodCall(path, _, [self_arg, _], _) = expr.kind;\n+                if path.ident.name.as_str() == \"push\";\n+                if let ExprKind::Path(QPath::Resolved(_, self_path)) = self_arg.kind;\n+                if let [self_name] = self_path.segments;\n+                if self_name.ident.name == searcher.name;\n+                then {\n+                    self.searcher = Some(VecPushSearcher {\n+                        found: searcher.found + 1,\n+                        err_span: searcher.err_span.to(stmt.span),\n+                        .. searcher\n+                    });\n+                } else {\n+                    searcher.display_err(cx);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_block_post(&mut self, cx: &LateContext<'tcx>, _: &'tcx Block<'tcx>) {\n+        if let Some(searcher) = self.searcher.take() {\n+            searcher.display_err(cx);\n+        }\n+    }\n+}\n+\n+fn get_vec_init_kind<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<VecInitKind> {\n+    if let ExprKind::Call(func, args) = expr.kind {\n+        match func.kind {\n+            ExprKind::Path(QPath::TypeRelative(ty, name))\n+                if is_type_diagnostic_item(cx, cx.typeck_results().node_type(ty.hir_id), sym::vec_type) =>\n+            {\n+                if name.ident.name == sym::new {\n+                    return Some(VecInitKind::New);\n+                } else if name.ident.name.as_str() == \"with_capacity\" {\n+                    return args.get(0).and_then(|arg| {\n+                        if_chain! {\n+                            if let ExprKind::Lit(lit) = &arg.kind;\n+                            if let LitKind::Int(num, _) = lit.node;\n+                            then {\n+                                Some(VecInitKind::WithCapacity(num.try_into().ok()?))\n+                            } else {\n+                                None\n+                            }\n+                        }\n+                    });\n+                }\n+            }\n+            ExprKind::Path(QPath::Resolved(_, path))\n+                if match_def_path(cx, path.res.opt_def_id()?, &paths::DEFAULT_TRAIT_METHOD)\n+                    && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::vec_type) =>\n+            {\n+                return Some(VecInitKind::New);\n+            }\n+            _ => (),\n+        }\n+    }\n+    None\n+}"}, {"sha": "10005a7fc81ed1381abdada242234bcbbcb802de", "filename": "clippy_lints/src/wildcard_imports.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -7,7 +7,8 @@ use rustc_hir::{\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::BytePos;\n+use rustc_span::symbol::kw;\n+use rustc_span::{sym, BytePos};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for `use Enum::*`.\n@@ -198,12 +199,12 @@ impl WildcardImports {\n // Allow \"...prelude::..::*\" imports.\n // Many crates have a prelude, and it is imported as a glob by design.\n fn is_prelude_import(segments: &[PathSegment<'_>]) -> bool {\n-    segments.iter().any(|ps| ps.ident.as_str() == \"prelude\")\n+    segments.iter().any(|ps| ps.ident.name == sym::prelude)\n }\n \n // Allow \"super::*\" imports in tests.\n fn is_super_only_import(segments: &[PathSegment<'_>]) -> bool {\n-    segments.len() == 1 && segments[0].ident.as_str() == \"super\"\n+    segments.len() == 1 && segments[0].ident.name == kw::Super\n }\n \n fn is_test_module_or_function(item: &Item<'_>) -> bool {"}, {"sha": "af324f831dfa2e9fc16f9f412003a63d80585f42", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 73, "deletions": 39, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -10,7 +10,8 @@ use rustc_lexer::unescape::{self, EscapeError};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_parse::parser;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{sym, BytePos, Span, Symbol};\n+use rustc_span::symbol::kw;\n+use rustc_span::{sym, BytePos, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** This lint warns when you use `println!(\"\")` to\n@@ -75,6 +76,24 @@ declare_clippy_lint! {\n     \"printing on stdout\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for printing on *stderr*. The purpose of this lint\n+    /// is to catch debugging remnants.\n+    ///\n+    /// **Why is this bad?** People often print on *stderr* while debugging an\n+    /// application and might forget to remove those prints afterward.\n+    ///\n+    /// **Known problems:** Only catches `eprint!` and `eprintln!` calls.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// eprintln!(\"Hello world!\");\n+    /// ```\n+    pub PRINT_STDERR,\n+    restriction,\n+    \"printing on stderr\"\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for use of `Debug` formatting. The purpose of this\n     /// lint is to catch debugging remnants.\n@@ -201,6 +220,7 @@ impl_lint_pass!(Write => [\n     PRINT_WITH_NEWLINE,\n     PRINTLN_EMPTY_STRING,\n     PRINT_STDOUT,\n+    PRINT_STDERR,\n     USE_DEBUG,\n     PRINT_LITERAL,\n     WRITE_WITH_NEWLINE,\n@@ -243,47 +263,22 @@ impl EarlyLintPass for Write {\n                 .map_or(false, |crate_name| crate_name == \"build_script_build\")\n         }\n \n-        if mac.path == sym!(println) {\n-            if !is_build_script(cx) {\n-                span_lint(cx, PRINT_STDOUT, mac.span(), \"use of `println!`\");\n-            }\n-            if let (Some(fmt_str), _) = self.check_tts(cx, mac.args.inner_tokens(), false) {\n-                if fmt_str.symbol == Symbol::intern(\"\") {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        PRINTLN_EMPTY_STRING,\n-                        mac.span(),\n-                        \"using `println!(\\\"\\\")`\",\n-                        \"replace it with\",\n-                        \"println!()\".to_string(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-        } else if mac.path == sym!(print) {\n+        if mac.path == sym!(print) {\n             if !is_build_script(cx) {\n                 span_lint(cx, PRINT_STDOUT, mac.span(), \"use of `print!`\");\n             }\n-            if let (Some(fmt_str), _) = self.check_tts(cx, mac.args.inner_tokens(), false) {\n-                if check_newlines(&fmt_str) {\n-                    span_lint_and_then(\n-                        cx,\n-                        PRINT_WITH_NEWLINE,\n-                        mac.span(),\n-                        \"using `print!()` with a format string that ends in a single newline\",\n-                        |err| {\n-                            err.multipart_suggestion(\n-                                \"use `println!` instead\",\n-                                vec![\n-                                    (mac.path.span, String::from(\"println\")),\n-                                    (newline_span(&fmt_str), String::new()),\n-                                ],\n-                                Applicability::MachineApplicable,\n-                            );\n-                        },\n-                    );\n-                }\n+            self.lint_print_with_newline(cx, mac);\n+        } else if mac.path == sym!(println) {\n+            if !is_build_script(cx) {\n+                span_lint(cx, PRINT_STDOUT, mac.span(), \"use of `println!`\");\n             }\n+            self.lint_println_empty_string(cx, mac);\n+        } else if mac.path == sym!(eprint) {\n+            span_lint(cx, PRINT_STDERR, mac.span(), \"use of `eprint!`\");\n+            self.lint_print_with_newline(cx, mac);\n+        } else if mac.path == sym!(eprintln) {\n+            span_lint(cx, PRINT_STDERR, mac.span(), \"use of `eprintln!`\");\n+            self.lint_println_empty_string(cx, mac);\n         } else if mac.path == sym!(write) {\n             if let (Some(fmt_str), _) = self.check_tts(cx, mac.args.inner_tokens(), true) {\n                 if check_newlines(&fmt_str) {\n@@ -307,7 +302,7 @@ impl EarlyLintPass for Write {\n             }\n         } else if mac.path == sym!(writeln) {\n             if let (Some(fmt_str), expr) = self.check_tts(cx, mac.args.inner_tokens(), true) {\n-                if fmt_str.symbol == Symbol::intern(\"\") {\n+                if fmt_str.symbol == kw::Empty {\n                     let mut applicability = Applicability::MachineApplicable;\n                     // FIXME: remove this `#[allow(...)]` once the issue #5822 gets fixed\n                     #[allow(clippy::option_if_let_else)]\n@@ -487,6 +482,45 @@ impl Write {\n             }\n         }\n     }\n+\n+    fn lint_println_empty_string(&self, cx: &EarlyContext<'_>, mac: &MacCall) {\n+        if let (Some(fmt_str), _) = self.check_tts(cx, mac.args.inner_tokens(), false) {\n+            if fmt_str.symbol == kw::Empty {\n+                let name = mac.path.segments[0].ident.name;\n+                span_lint_and_sugg(\n+                    cx,\n+                    PRINTLN_EMPTY_STRING,\n+                    mac.span(),\n+                    &format!(\"using `{}!(\\\"\\\")`\", name),\n+                    \"replace it with\",\n+                    format!(\"{}!()\", name),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+\n+    fn lint_print_with_newline(&self, cx: &EarlyContext<'_>, mac: &MacCall) {\n+        if let (Some(fmt_str), _) = self.check_tts(cx, mac.args.inner_tokens(), false) {\n+            if check_newlines(&fmt_str) {\n+                let name = mac.path.segments[0].ident.name;\n+                let suggested = format!(\"{}ln\", name);\n+                span_lint_and_then(\n+                    cx,\n+                    PRINT_WITH_NEWLINE,\n+                    mac.span(),\n+                    &format!(\"using `{}!()` with a format string that ends in a single newline\", name),\n+                    |err| {\n+                        err.multipart_suggestion(\n+                            &format!(\"use `{}!` instead\", suggested),\n+                            vec![(mac.path.span, suggested), (newline_span(&fmt_str), String::new())],\n+                            Applicability::MachineApplicable,\n+                        );\n+                    },\n+                );\n+            }\n+        }\n+    }\n }\n \n /// Checks if the format string contains a single newline that terminates it."}, {"sha": "319b85ac42a805d29336cff18f3196eb3206fa30", "filename": "clippy_lints/src/zero_sized_map_values.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fzero_sized_map_values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_lints%2Fsrc%2Fzero_sized_map_values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_sized_map_values.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,84 @@\n+use if_chain::if_chain;\n+use rustc_hir::{self as hir, HirId, ItemKind, Node};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{Adt, Ty};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_target::abi::LayoutOf as _;\n+use rustc_typeck::hir_ty_to_ty;\n+\n+use crate::utils::{is_normalizable, is_type_diagnostic_item, match_type, paths, span_lint_and_help};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for maps with zero-sized value types anywhere in the code.\n+    ///\n+    /// **Why is this bad?** Since there is only a single value for a zero-sized type, a map\n+    /// containing zero sized values is effectively a set. Using a set in that case improves\n+    /// readability and communicates intent more clearly.\n+    ///\n+    /// **Known problems:**\n+    /// * A zero-sized type cannot be recovered later if it contains private fields.\n+    /// * This lints the signature of public items\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// fn unique_words(text: &str) -> HashMap<&str, ()> {\n+    ///     todo!();\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// fn unique_words(text: &str) -> HashSet<&str> {\n+    ///     todo!();\n+    /// }\n+    /// ```\n+    pub ZERO_SIZED_MAP_VALUES,\n+    pedantic,\n+    \"usage of map with zero-sized value type\"\n+}\n+\n+declare_lint_pass!(ZeroSizedMapValues => [ZERO_SIZED_MAP_VALUES]);\n+\n+impl LateLintPass<'_> for ZeroSizedMapValues {\n+    fn check_ty(&mut self, cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>) {\n+        if_chain! {\n+            if !hir_ty.span.from_expansion();\n+            if !in_trait_impl(cx, hir_ty.hir_id);\n+            let ty = ty_from_hir_ty(cx, hir_ty);\n+            if is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) || match_type(cx, ty, &paths::BTREEMAP);\n+            if let Adt(_, ref substs) = ty.kind();\n+            let ty = substs.type_at(1);\n+            // Do this to prevent `layout_of` crashing, being unable to fully normalize `ty`.\n+            if is_normalizable(cx, cx.param_env, ty);\n+            if let Ok(layout) = cx.layout_of(ty);\n+            if layout.is_zst();\n+            then {\n+                span_lint_and_help(cx, ZERO_SIZED_MAP_VALUES, hir_ty.span, \"map with zero-sized value type\", None, \"consider using a set instead\");\n+            }\n+        }\n+    }\n+}\n+\n+fn in_trait_impl(cx: &LateContext<'_>, hir_id: HirId) -> bool {\n+    let parent_id = cx.tcx.hir().get_parent_item(hir_id);\n+    if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_item(parent_id)) {\n+        if let ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = item.kind {\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+fn ty_from_hir_ty<'tcx>(cx: &LateContext<'tcx>, hir_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n+    cx.maybe_typeck_results()\n+        .and_then(|results| {\n+            if results.hir_owner == hir_ty.hir_id.owner {\n+                results.node_type_opt(hir_ty.hir_id)\n+            } else {\n+                None\n+            }\n+        })\n+        .unwrap_or_else(|| hir_ty_to_ty(cx.tcx, hir_ty))\n+}"}, {"sha": "85a91cd2decd59ffdad366977375be13f2fe52a5", "filename": "clippy_workspace_tests/path_dep/Cargo.toml", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_workspace_tests%2Fpath_dep%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_workspace_tests%2Fpath_dep%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_workspace_tests%2Fpath_dep%2FCargo.toml?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,3 @@\n+[package]\n+name = \"path_dep\"\n+version = \"0.1.0\""}, {"sha": "35ce524f2b10c367c0b3d71e4449f05458542261", "filename": "clippy_workspace_tests/path_dep/src/lib.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_workspace_tests%2Fpath_dep%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_workspace_tests%2Fpath_dep%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_workspace_tests%2Fpath_dep%2Fsrc%2Flib.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,6 @@\n+#![deny(clippy::empty_loop)]\n+\n+#[cfg(feature = \"primary_package_test\")]\n+pub fn lint_me() {\n+    loop {}\n+}"}, {"sha": "45362c11b856e3615cfa77348c12b251d127526b", "filename": "clippy_workspace_tests/subcrate/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_workspace_tests%2Fsubcrate%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/clippy_workspace_tests%2Fsubcrate%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_workspace_tests%2Fsubcrate%2FCargo.toml?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,3 +1,6 @@\n [package]\n name = \"subcrate\"\n version = \"0.1.0\"\n+\n+[dependencies]\n+path_dep = { path = \"../path_dep\" }"}, {"sha": "1a7a30c61be5b8fb9fc8987fc4fdc32667765165", "filename": "doc/adding_lints.md", "status": "modified", "additions": 67, "deletions": 13, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -98,12 +98,12 @@ While we are working on implementing our lint, we can keep running the UI\n test. That allows us to check if the output is turning into what we want.\n \n Once we are satisfied with the output, we need to run\n-`tests/ui/update-all-references.sh` to update the `.stderr` file for our lint.\n+`cargo dev bless` to update the `.stderr` file for our lint.\n Please note that, we should run `TESTNAME=foo_functions cargo uitest`\n-every time before running `tests/ui/update-all-references.sh`.\n+every time before running `cargo dev bless`.\n Running `TESTNAME=foo_functions cargo uitest` should pass then. When we commit\n our lint, we need to commit the generated `.stderr` files, too. In general, you\n-should only commit files changed by `tests/ui/update-all-references.sh` for the\n+should only commit files changed by `cargo dev bless` for the\n specific lint you are creating/editing. Note that if the generated files are\n empty, they should be removed.\n \n@@ -122,8 +122,7 @@ we will find by default two new crates, each with its manifest file:\n If you need more cases, you can copy one of those crates (under `foo_categories`) and rename it.\n \n The process of generating the `.stderr` file is the same, and prepending the `TESTNAME`\n-variable to `cargo uitest` works too, but the script to update the references\n-is in another path: `tests/ui-cargo/update-all-references.sh`.\n+variable to `cargo uitest` works too.\n \n ## Rustfix tests\n \n@@ -133,7 +132,7 @@ additionally run [rustfix] for that test. Rustfix will apply the suggestions\n from the lint to the code of the test file and compare that to the contents of\n a `.fixed` file.\n \n-Use `tests/ui/update-all-references.sh` to automatically generate the\n+Use `cargo dev bless` to automatically generate the\n `.fixed` file after running the tests.\n \n [rustfix]: https://github.com/rust-lang/rustfix\n@@ -148,10 +147,14 @@ add `// edition:2018` at the top of the test file (note that it's space-sensitiv\n \n Manually testing against an example file can be useful if you have added some\n `println!`s and the test suite output becomes unreadable. To try Clippy with\n-your local modifications, run `env CLIPPY_TESTS=true cargo run --bin\n-clippy-driver -- -L ./target/debug input.rs` from the working copy root.\n+your local modifications, run\n \n-With tests in place, let's have a look at implementing our lint now.\n+```\n+env __CLIPPY_INTERNAL_TESTS=true cargo run --bin clippy-driver -- -L ./target/debug input.rs\n+```\n+\n+from the working copy root. With tests in place, let's have a look at\n+implementing our lint now.\n \n ## Lint declaration\n \n@@ -226,13 +229,13 @@ store.register_early_pass(|| box foo_functions::FooFunctions);\n ```\n \n As one may expect, there is a corresponding `register_late_pass` method\n-available as well. Without a call to one of `register_early_pass` or \n+available as well. Without a call to one of `register_early_pass` or\n `register_late_pass`, the lint pass in question will not be run.\n \n-One reason that `cargo dev` does not automate this step is that multiple lints \n+One reason that `cargo dev` does not automate this step is that multiple lints\n can use the same lint pass, so registering the lint pass may already be done\n when adding a new lint. Another reason that this step is not automated is that\n-the order that the passes are registered determines the order the passes \n+the order that the passes are registered determines the order the passes\n actually run, which in turn affects the order that any emitted lints are output\n in.\n \n@@ -368,7 +371,7 @@ fn is_foo_fn(fn_kind: FnKind<'_>) -> bool {\n \n Now we should also run the full test suite with `cargo test`. At this point\n running `cargo test` should produce the expected output. Remember to run\n-`tests/ui/update-all-references.sh` to update the `.stderr` file.\n+`cargo dev bless` to update the `.stderr` file.\n \n `cargo test` (as opposed to `cargo uitest`) will also ensure that our lint\n implementation is not violating any Clippy lints itself.\n@@ -380,6 +383,57 @@ pass.\n [`FnKind::Fn`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/visit/enum.FnKind.html#variant.Fn\n [ident]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/symbol/struct.Ident.html\n \n+## Specifying the lint's minimum supported Rust version (msrv)\n+\n+Projects supporting older versions of Rust would need to disable a lint if it targets features\n+present in later versions. Support for this can be added by specifying an msrv in your lint like so,\n+\n+```rust\n+const MANUAL_STRIP_MSRV: RustcVersion = RustcVersion::new(1, 45, 0);\n+```\n+\n+The project's msrv will also have to be an attribute in the lint so you'll have to add a struct\n+and constructor for your lint. The project's msrv needs to be passed when the lint is registered\n+in `lib.rs`\n+\n+```rust\n+pub struct ManualStrip {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl ManualStrip {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+```\n+\n+The project's msrv can then be matched against the lint's msrv in the LintPass using the `meets_msrv` utility\n+function.\n+\n+``` rust\n+if !meets_msrv(self.msrv.as_ref(), &MANUAL_STRIP_MSRV) {\n+    return;\n+}\n+```\n+\n+The project's msrv can also be specified as an inner attribute, which overrides the value from\n+`clippy.toml`. This can be accounted for using the `extract_msrv_attr!(LintContext)` macro and passing\n+LateContext/EarlyContext.\n+\n+```rust\n+impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        ...\n+    }\n+    extract_msrv_attr!(LateContext);\n+}\n+```\n+\n+Once the msrv is added to the lint, a relevant test case should be added to `tests/ui/min_rust_version_attr.rs`\n+which verifies that the lint isn't emitted if the project's msrv is lower.\n+\n ## Author lint\n \n If you have trouble implementing your lint, there is also the internal `author`"}, {"sha": "954474a17aa8e35b31bafc2765f08ab2a14781aa", "filename": "doc/basics.md", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/doc%2Fbasics.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/doc%2Fbasics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fbasics.md?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,16 +1,14 @@\n # Basics for hacking on Clippy\n \n This document explains the basics for hacking on Clippy. Besides others, this\n-includes how to set-up the development environment, how to build and how to test\n-Clippy. For a more in depth description on the codebase take a look at [Adding\n-Lints] or [Common Tools].\n+includes how to build and test Clippy. For a more in depth description on\n+the codebase take a look at [Adding Lints] or [Common Tools].\n \n [Adding Lints]: https://github.com/rust-lang/rust-clippy/blob/master/doc/adding_lints.md\n [Common Tools]: https://github.com/rust-lang/rust-clippy/blob/master/doc/common_tools_writing_lints.md\n \n - [Basics for hacking on Clippy](#basics-for-hacking-on-clippy)\n-  - [Get the code](#get-the-code)\n-  - [Setup](#setup)\n+  - [Get the Code](#get-the-code)\n   - [Building and Testing](#building-and-testing)\n   - [`cargo dev`](#cargo-dev)\n   - [PR](#pr)\n@@ -38,29 +36,9 @@ git rebase upstream/master\n git push\n ```\n \n-## Setup\n-\n-Next we need to setup the toolchain to compile Clippy. Since Clippy heavily\n-relies on compiler internals it is build with the latest rustc master. To get\n-this toolchain, you can just use the `setup-toolchain.sh` script or use\n-`rustup-toolchain-install-master`:\n-\n-```bash\n-bash setup-toolchain.sh\n-# OR\n-cargo install rustup-toolchain-install-master\n-# For better IDE integration also add `-c rustfmt -c rust-src` (optional)\n-rustup-toolchain-install-master -f -n master -c rustc-dev -c llvm-tools\n-rustup override set master\n-```\n-\n-_Note:_ Sometimes you may get compiler errors when building Clippy, even if you\n-didn't change anything. Normally those will be fixed by a maintainer in a few hours. \n-\n ## Building and Testing\n \n-Once the `master` toolchain is installed, you can build and test Clippy like\n-every other Rust project:\n+You can build and test Clippy like every other Rust project:\n \n ```bash\n cargo build  # builds Clippy\n@@ -83,7 +61,7 @@ If the output of a [UI test] differs from the expected output, you can update th\n reference file with:\n \n ```bash\n-sh tests/ui/update-all-references.sh\n+cargo dev bless\n ```\n \n For example, this is necessary, if you fix a typo in an error message of a lint\n@@ -109,7 +87,7 @@ cargo dev update_lints\n # create a new lint and register it\n cargo dev new_lint\n # (experimental) Setup Clippy to work with rust-analyzer\n-cargo dev ra-setup\n+cargo dev ra_setup\n ```\n \n ## PR"}, {"sha": "fe8b080f56f2bc0c518c7b3e2049def4eed5b9f1", "filename": "doc/roadmap-2021.md", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/doc%2Froadmap-2021.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/doc%2Froadmap-2021.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Froadmap-2021.md?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,235 @@\n+# Roadmap 2021\n+\n+# Summary\n+\n+This Roadmap lays out the plans for Clippy in 2021:\n+\n+- Improving usability and reliability\n+- Improving experience of contributors and maintainers\n+- Develop and specify processes\n+\n+Members of the Clippy team will be assigned tasks from one or more of these\n+topics. The team member is then responsible to complete the assigned tasks. This\n+can either be done by implementing them or by providing mentorship to interested\n+contributors.\n+\n+# Motivation\n+\n+With the ongoing growth of the Rust language and with that of the whole\n+ecosystem, also Clippy gets more and more users and contributors. This is good\n+for the project, but also brings challenges along. Some of these challenges are:\n+\n+- More issues about reliability or usability are popping up\n+- Traffic is hard to handle for a small team\n+- Bigger projects don't get completed due to the lack of processes and/or time\n+  of the team members\n+\n+Additionally, according to the [Rust Roadmap 2021], clear processes should be\n+defined by every team and unified across teams. This Roadmap is the first step\n+towards this.\n+\n+[Rust Roadmap 2021]: https://github.com/rust-lang/rfcs/pull/3037\n+\n+# Explanation\n+\n+This section will explain the things that should be done in 2021. It is\n+important to note, that this document focuses on the \"What?\", not the \"How?\".\n+The later will be addressed in follow-up tracking issue, with an assigned team\n+member.\n+\n+The following is split up in two major sections. The first section covers the\n+user facing plans, the second section the internal plans.\n+\n+## User Facing\n+\n+Clippy should be as pleasant to use and configure as possible. This section\n+covers plans that should be implemented to improve the situation of Clippy in\n+this regard.\n+\n+### Usability\n+\n+In the following, plans to improve the usability are covered.\n+\n+#### No Output After `cargo check`\n+\n+Currently when `cargo clippy` is run after `cargo check`, it does not produce\n+any output. This is especially problematic since `rust-analyzer` is on the rise\n+and it uses `cargo check` for checking code. A fix is already implemented, but\n+it still has to be pushed over the finish line. This also includes the\n+stabilization of the `cargo clippy --fix` command or the support of multi-span\n+suggestions in `rustfix`.\n+\n+- [#4612](https://github.com/rust-lang/rust-clippy/issues/4612)\n+\n+#### `lints.toml` Configuration\n+\n+This is something that comes up every now and then: a reusable configuration\n+file, where lint levels can be defined. Discussions about this often lead to\n+nothing specific or to \"we need an RFC for this\". And this is exactly what needs\n+to be done. Get together with the cargo team and write an RFC and implement such\n+a configuration file somehow and somewhere.\n+\n+- [#3164](https://github.com/rust-lang/rust-clippy/issues/3164)\n+- [cargo#5034](https://github.com/rust-lang/cargo/issues/5034)\n+- [IRLO](https://internals.rust-lang.org/t/proposal-cargo-lint-configuration/9135/8)\n+\n+#### Lint Groups\n+\n+There are more and more issues about managing lints in Clippy popping up. Lints\n+are hard to implement with a guarantee of no/few false positives (FPs). One way\n+to address this might be to introduce more lint groups to give users the ability\n+to better manage lints, or improve the process of classifying lints, so that\n+disabling lints due to FPs becomes rare. It is important to note, that Clippy\n+lints are less conservative than `rustc` lints, which won't change in the\n+future.\n+\n+- [#5537](https://github.com/rust-lang/rust-clippy/issues/5537)\n+- [#6366](https://github.com/rust-lang/rust-clippy/issues/6366)\n+\n+### Reliability\n+\n+In the following, plans to improve the reliability are covered.\n+\n+#### False Positive Rate\n+\n+In the worst case, new lints are only available in nightly for 2 weeks, before\n+hitting beta and ultimately stable. This and the fact that fewer people use\n+nightly Rust nowadays makes it more probable that a lint with many FPs hits\n+stable. This leads to annoyed users, that will disable these new lints in the\n+best case and to more annoyed users, that will stop using Clippy in the worst.\n+A process should be developed and implemented to prevent this from happening.\n+\n+- [#6429](https://github.com/rust-lang/rust-clippy/issues/6429)\n+\n+## Internal\n+\n+(The end of) 2020 has shown, that Clippy has to think about the available\n+resources, especially regarding management and maintenance of the project. This\n+section address issues affecting team members and contributors.\n+\n+### Management\n+\n+In 2020 Clippy achieved over 1000 open issues with regularly between 25-35 open\n+PRs. This is simultaneously a win and a loss. More issues and PRs means more\n+people are interested in Clippy and in contributing to it. On the other hand, it\n+means for team members more work and for contributors longer wait times for\n+reviews. The following will describe plans how to improve the situation for both\n+team members and contributors.\n+\n+#### Clear Expectations for Team Members\n+\n+According to the [Rust Roadmap 2021], a document specifying what it means to be\n+a member of the team should be produced. This should not put more pressure on\n+the team members, but rather help them and interested folks to know what the\n+expectations are. With this it should also be easier to recruit new team members\n+and may encourage people to get in touch, if they're interested to join.\n+\n+#### Scaling up the Team\n+\n+More people means less work for each individual. Together with the document\n+about expectations for team members, a document defining the process of how to\n+join the team should be produced. This can also increase the stability of the\n+team, in case of current members dropping out (temporarily). There can also be\n+different roles in the team, like people triaging vs. people reviewing.\n+\n+#### Regular Meetings\n+\n+Other teams have regular meetings. Clippy is big enough that it might be worth\n+to also do them. Especially if more people join the team, this can be important\n+for sync-ups. Besides the asynchronous communication, that works well for\n+working on separate lints, a meeting adds a synchronous alternative at a known\n+time. This is especially helpful if there are bigger things that need to be\n+discussed (like the projects in this roadmap). For starters bi-weekly meetings\n+before Rust syncs might make sense.\n+\n+#### Triaging\n+\n+To get a handle on the influx of open issues, a process for triaging issues and\n+PRs should be developed. Officially, Clippy follows the Rust triage process, but\n+currently no one enforces it. This can be improved by sharing triage teams\n+across projects or by implementing dashboards / tools which simplify triaging.\n+\n+### Development\n+\n+Improving the developer and contributor experience is something the Clippy team\n+works on regularly. Though, some things might need special attention and\n+planing. These topics are listed in the following.\n+\n+#### Process for New and Existing Lints\n+\n+As already mentioned above, classifying new lints gets quite hard, because the\n+probability of a buggy lint getting into stable is quite high. A process should\n+be implemented on how to classify lints. In addition, a test system should be\n+developed to find out which lints are currently problematic in real world code\n+to fix or disable them.\n+\n+- [#6429 (comment)](https://github.com/rust-lang/rust-clippy/issues/6429#issuecomment-741056379)\n+- [#6429 (comment)](https://github.com/rust-lang/rust-clippy/issues/6429#issuecomment-741153345)\n+\n+#### Processes\n+\n+Related to the point before, a process for suggesting and discussing major\n+changes should be implemented. It's also not clearly defined when a lint should\n+be enabled or disabled by default. This can also be improved by the test system\n+mentioned above.\n+\n+#### Dev-Tools\n+\n+There's already `cargo dev` which makes Clippy development easier and more\n+pleasant. This can still be expanded, so that it covers more areas of the\n+development process.\n+\n+- [#5394](https://github.com/rust-lang/rust-clippy/issues/5394)\n+\n+#### Contributor Guide\n+\n+Similar to a Clippy Book, which describes how to use Clippy, a book about how to\n+contribute to Clippy might be helpful for new and existing contributors. There's\n+already the `doc` directory in the Clippy repo, this can be turned into a\n+`mdbook`.\n+\n+#### `rustc` integration\n+\n+Recently Clippy was integrated with `git subtree` into the `rust-lang/rust`\n+repository. This made syncing between the two repositories easier. A\n+`#[non_exhaustive]` list of things that still can be improved is:\n+\n+1. Use the same `rustfmt` version and configuration as `rustc`.\n+2. Make `cargo dev` work in the Rust repo, just as it works in the Clippy repo.\n+   E.g. `cargo dev bless` or `cargo dev update_lints`. And even add more things\n+   to it that might be useful for the Rust repo, e.g. `cargo dev deprecate`.\n+3. Easier sync process. The `subtree` situation is not ideal.\n+\n+## Prioritization\n+\n+The most pressing issues for users of Clippy are of course the user facing\n+issues. So there should be a priority on those issues, but without losing track\n+of the internal issues listed in this document.\n+\n+Getting the FP rate of warn/deny-by-default lints under control should have the\n+highest priority. Other user facing issues should also get a high priority, but\n+shouldn't be in the way of addressing internal issues.\n+\n+To better manage the upcoming projects, the basic internal processes, like\n+meetings, tracking issues and documentation, should be established as soon as\n+possible. They might even be necessary to properly manage the projects,\n+regarding the user facing issues.\n+\n+# Prior Art\n+\n+## Rust Roadmap\n+\n+Rust's roadmap process was established by [RFC 1728] in 2016. Since then every\n+year a roadmap was published, that defined the bigger plans for the coming\n+years. This years roadmap can be found [here][Rust Roadmap 2021].\n+\n+[RFC 1728]: https://rust-lang.github.io/rfcs/1728-north-star.html\n+\n+# Drawbacks\n+\n+## Big Roadmap\n+\n+This roadmap is pretty big and not all items listed in this document might be\n+addressed during 2021. Because this is the first roadmap for Clippy, having open\n+tasks at the end of 2021 is fine, but they should be revisited in the 2022\n+roadmap."}, {"sha": "72935072f8cdd8197181979da474f679f87dd221", "filename": "rust-toolchain", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1 +1,3 @@\n-nightly\n+[toolchain]\n+channel = \"nightly-2021-01-15\"\n+components = [\"llvm-tools-preview\", \"rustc-dev\", \"rust-src\", \"rustfmt\"]"}, {"sha": "191ea4315a6b5a8a29e56f6440f88115c466e8b9", "filename": "setup-toolchain.sh", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bd235707acd095fdd2b079d2992923d0d732a474/setup-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bd235707acd095fdd2b079d2992923d0d732a474/setup-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/setup-toolchain.sh?ref=bd235707acd095fdd2b079d2992923d0d732a474", "patch": "@@ -1,36 +0,0 @@\n-#!/usr/bin/env bash\n-# Set up the appropriate rustc toolchain\n-\n-set -e\n-\n-cd \"$(dirname \"$0\")\"\n-\n-RTIM_PATH=$(command -v rustup-toolchain-install-master) || INSTALLED=false\n-CARGO_HOME=${CARGO_HOME:-$HOME/.cargo}\n-\n-# Check if RTIM is not installed or installed in other locations not in ~/.cargo/bin\n-if [[ \"$INSTALLED\" == false || \"$RTIM_PATH\" == $CARGO_HOME/bin/rustup-toolchain-install-master ]]; then\n-    cargo +nightly install rustup-toolchain-install-master\n-else\n-    VERSION=$(rustup-toolchain-install-master -V | grep -o \"[0-9.]*\")\n-    REMOTE=$(cargo +nightly search rustup-toolchain-install-master | grep -o \"[0-9.]*\")\n-    echo \"info: skipping updating rustup-toolchain-install-master at $RTIM_PATH\"\n-    echo \"      current version : $VERSION\"\n-    echo \"      remote version  : $REMOTE\"\n-fi\n-\n-RUST_COMMIT=$(git ls-remote https://github.com/rust-lang/rust master | awk '{print $1}')\n-\n-if rustc +master -Vv 2>/dev/null | grep -q \"$RUST_COMMIT\"; then\n-    echo \"info: master toolchain is up-to-date\"\n-    exit 0\n-fi\n-\n-if [[ -n \"$HOST_TOOLCHAIN\" ]]; then\n-    TOOLCHAIN=('--host' \"$HOST_TOOLCHAIN\")\n-else\n-    TOOLCHAIN=()\n-fi\n-\n-rustup-toolchain-install-master -f -n master \"${TOOLCHAIN[@]}\" -c rustc-dev -c llvm-tools -- \"$RUST_COMMIT\"\n-rustup override set master"}, {"sha": "f5f6c09ed8e940e71b70469405950c3b9fe1f61d", "filename": "src/driver.rs", "status": "modified", "additions": 29, "deletions": 136, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -8,7 +8,6 @@\n \n // FIXME: switch to something more ergonomic here, once available.\n // (Currently there is no way to opt into sysroot crates without `extern crate`.)\n-extern crate rustc_data_structures;\n extern crate rustc_driver;\n extern crate rustc_errors;\n extern crate rustc_interface;\n@@ -26,8 +25,6 @@ use std::panic;\n use std::path::{Path, PathBuf};\n use std::process::{exit, Command};\n \n-mod lintlist;\n-\n /// If a command-line option matches `find_arg`, then apply the predicate `pred` on its value. If\n /// true, then return it. The parameter is assumed to be either `--arg=value` or `--arg value`.\n fn arg_value<'a, T: Deref<Target = str>>(\n@@ -92,113 +89,6 @@ impl rustc_driver::Callbacks for ClippyCallbacks {\n     }\n }\n \n-#[allow(clippy::find_map, clippy::filter_map)]\n-fn describe_lints() {\n-    use lintlist::{Level, Lint, ALL_LINTS, LINT_LEVELS};\n-    use rustc_data_structures::fx::FxHashSet;\n-\n-    println!(\n-        \"\n-Available lint options:\n-    -W <foo>           Warn about <foo>\n-    -A <foo>           Allow <foo>\n-    -D <foo>           Deny <foo>\n-    -F <foo>           Forbid <foo> (deny <foo> and all attempts to override)\n-\n-\"\n-    );\n-\n-    let lint_level = |lint: &Lint| {\n-        LINT_LEVELS\n-            .iter()\n-            .find(|level_mapping| level_mapping.0 == lint.group)\n-            .map(|(_, level)| match level {\n-                Level::Allow => \"allow\",\n-                Level::Warn => \"warn\",\n-                Level::Deny => \"deny\",\n-            })\n-            .unwrap()\n-    };\n-\n-    let mut lints: Vec<_> = ALL_LINTS.iter().collect();\n-    // The sort doesn't case-fold but it's doubtful we care.\n-    lints.sort_by_cached_key(|x: &&Lint| (lint_level(x), x.name));\n-\n-    let max_lint_name_len = lints\n-        .iter()\n-        .map(|lint| lint.name.len())\n-        .map(|len| len + \"clippy::\".len())\n-        .max()\n-        .unwrap_or(0);\n-\n-    let padded = |x: &str| {\n-        let mut s = \" \".repeat(max_lint_name_len - x.chars().count());\n-        s.push_str(x);\n-        s\n-    };\n-\n-    let scoped = |x: &str| format!(\"clippy::{}\", x);\n-\n-    let lint_groups: FxHashSet<_> = lints.iter().map(|lint| lint.group).collect();\n-\n-    println!(\"Lint checks provided by clippy:\\n\");\n-    println!(\"    {}  {:7.7}  meaning\", padded(\"name\"), \"default\");\n-    println!(\"    {}  {:7.7}  -------\", padded(\"----\"), \"-------\");\n-\n-    let print_lints = |lints: &[&Lint]| {\n-        for lint in lints {\n-            let name = lint.name.replace(\"_\", \"-\");\n-            println!(\n-                \"    {}  {:7.7}  {}\",\n-                padded(&scoped(&name)),\n-                lint_level(lint),\n-                lint.desc\n-            );\n-        }\n-        println!(\"\\n\");\n-    };\n-\n-    print_lints(&lints);\n-\n-    let max_group_name_len = std::cmp::max(\n-        \"clippy::all\".len(),\n-        lint_groups\n-            .iter()\n-            .map(|group| group.len())\n-            .map(|len| len + \"clippy::\".len())\n-            .max()\n-            .unwrap_or(0),\n-    );\n-\n-    let padded_group = |x: &str| {\n-        let mut s = \" \".repeat(max_group_name_len - x.chars().count());\n-        s.push_str(x);\n-        s\n-    };\n-\n-    println!(\"Lint groups provided by clippy:\\n\");\n-    println!(\"    {}  sub-lints\", padded_group(\"name\"));\n-    println!(\"    {}  ---------\", padded_group(\"----\"));\n-    println!(\"    {}  the set of all clippy lints\", padded_group(\"clippy::all\"));\n-\n-    let print_lint_groups = || {\n-        for group in lint_groups {\n-            let name = group.to_lowercase().replace(\"_\", \"-\");\n-            let desc = lints\n-                .iter()\n-                .filter(|&lint| lint.group == group)\n-                .map(|lint| lint.name)\n-                .map(|name| name.replace(\"_\", \"-\"))\n-                .collect::<Vec<String>>()\n-                .join(\", \");\n-            println!(\"    {}  {}\", padded_group(&scoped(&name)), desc);\n-        }\n-        println!(\"\\n\");\n-    };\n-\n-    print_lint_groups();\n-}\n-\n fn display_help() {\n     println!(\n         \"\\\n@@ -292,6 +182,7 @@ fn toolchain_path(home: Option<String>, toolchain: Option<String>) -> Option<Pat\n     })\n }\n \n+#[allow(clippy::too_many_lines)]\n pub fn main() {\n     rustc_driver::init_rustc_env_logger();\n     SyncLazy::force(&ICE_HOOK);\n@@ -379,17 +270,6 @@ pub fn main() {\n             exit(0);\n         }\n \n-        let should_describe_lints = || {\n-            let args: Vec<_> = env::args().collect();\n-            args.windows(2)\n-                .any(|args| args[1] == \"help\" && matches!(args[0].as_str(), \"-W\" | \"-A\" | \"-D\" | \"-F\"))\n-        };\n-\n-        if !wrapper_mode && should_describe_lints() {\n-            describe_lints();\n-            exit(0);\n-        }\n-\n         // this conditional check for the --sysroot flag is there so users can call\n         // `clippy_driver` directly\n         // without having to pass --sysroot or anything\n@@ -398,27 +278,40 @@ pub fn main() {\n             args.extend(vec![\"--sysroot\".into(), sys_root]);\n         };\n \n-        // this check ensures that dependencies are built but not linted and the final\n-        // crate is linted but not built\n-        let clippy_enabled = env::var(\"CLIPPY_TESTS\").map_or(false, |val| val == \"true\")\n-            || arg_value(&orig_args, \"--cap-lints\", |val| val == \"allow\").is_none();\n-\n+        let mut no_deps = false;\n+        let clippy_args = env::var(\"CLIPPY_ARGS\")\n+            .unwrap_or_default()\n+            .split(\"__CLIPPY_HACKERY__\")\n+            .filter_map(|s| match s {\n+                \"\" => None,\n+                \"--no-deps\" => {\n+                    no_deps = true;\n+                    None\n+                },\n+                _ => Some(s.to_string()),\n+            })\n+            .chain(vec![\"--cfg\".into(), r#\"feature=\"cargo-clippy\"\"#.into()])\n+            .collect::<Vec<String>>();\n+\n+        // We enable Clippy if one of the following conditions is met\n+        // - IF Clippy is run on its test suite OR\n+        // - IF Clippy is run on the main crate, not on deps (`!cap_lints_allow`) THEN\n+        //    - IF `--no-deps` is not set (`!no_deps`) OR\n+        //    - IF `--no-deps` is set and Clippy is run on the specified primary package\n+        let clippy_tests_set = env::var(\"__CLIPPY_INTERNAL_TESTS\").map_or(false, |val| val == \"true\");\n+        let cap_lints_allow = arg_value(&orig_args, \"--cap-lints\", |val| val == \"allow\").is_some();\n+        let in_primary_package = env::var(\"CARGO_PRIMARY_PACKAGE\").is_ok();\n+\n+        let clippy_enabled = clippy_tests_set || (!cap_lints_allow && (!no_deps || in_primary_package));\n         if clippy_enabled {\n-            args.extend(vec![\"--cfg\".into(), r#\"feature=\"cargo-clippy\"\"#.into()]);\n-            if let Ok(extra_args) = env::var(\"CLIPPY_ARGS\") {\n-                args.extend(extra_args.split(\"__CLIPPY_HACKERY__\").filter_map(|s| {\n-                    if s.is_empty() {\n-                        None\n-                    } else {\n-                        Some(s.to_string())\n-                    }\n-                }));\n-            }\n+            args.extend(clippy_args);\n         }\n+\n         let mut clippy = ClippyCallbacks;\n         let mut default = DefaultCallbacks;\n         let callbacks: &mut (dyn rustc_driver::Callbacks + Send) =\n             if clippy_enabled { &mut clippy } else { &mut default };\n+\n         rustc_driver::RunCompiler::new(&args, callbacks).run()\n     }))\n }"}, {"sha": "c817d83b33aeb12df5817b1c5a2e891c3423df17", "filename": "src/lintlist/lint.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bd235707acd095fdd2b079d2992923d0d732a474/src%2Flintlist%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd235707acd095fdd2b079d2992923d0d732a474/src%2Flintlist%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Flint.rs?ref=bd235707acd095fdd2b079d2992923d0d732a474", "patch": "@@ -1,27 +0,0 @@\n-/// Lint data parsed from the Clippy source code.\n-#[derive(Clone, PartialEq, Debug)]\n-pub struct Lint {\n-    pub name: &'static str,\n-    pub group: &'static str,\n-    pub desc: &'static str,\n-    pub deprecation: Option<&'static str>,\n-    pub module: &'static str,\n-}\n-\n-#[derive(PartialOrd, PartialEq, Ord, Eq)]\n-pub enum Level {\n-    Allow,\n-    Warn,\n-    Deny,\n-}\n-\n-pub const LINT_LEVELS: [(&str, Level); 8] = [\n-    (\"correctness\", Level::Deny),\n-    (\"style\", Level::Warn),\n-    (\"complexity\", Level::Warn),\n-    (\"perf\", Level::Warn),\n-    (\"restriction\", Level::Allow),\n-    (\"pedantic\", Level::Allow),\n-    (\"nursery\", Level::Allow),\n-    (\"cargo\", Level::Allow),\n-];"}, {"sha": "a104f687bdf663b3c660725a177b0973cc1659ee", "filename": "src/lintlist/mod.rs", "status": "removed", "additions": 0, "deletions": 2956, "changes": 2956, "blob_url": "https://github.com/rust-lang/rust/blob/bd235707acd095fdd2b079d2992923d0d732a474/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd235707acd095fdd2b079d2992923d0d732a474/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=bd235707acd095fdd2b079d2992923d0d732a474", "patch": "@@ -1,2956 +0,0 @@\n-//! This file is managed by `cargo dev update_lints`. Do not edit or format this file.\n-\n-use std::lazy::SyncLazy;\n-\n-pub mod lint;\n-pub use lint::Level;\n-pub use lint::Lint;\n-pub use lint::LINT_LEVELS;\n-\n-#[rustfmt::skip]\n-pub static ALL_LINTS: SyncLazy<Vec<Lint>> = SyncLazy::new(|| {\n-// begin lint list, do not remove this comment, it\u2019s used in `update_lints`\n-vec![\n-    Lint {\n-        name: \"absurd_extreme_comparisons\",\n-        group: \"correctness\",\n-        desc: \"a comparison with a maximum or minimum value that is always true or false\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"almost_swapped\",\n-        group: \"correctness\",\n-        desc: \"`foo = bar; bar = foo` sequence\",\n-        deprecation: None,\n-        module: \"swap\",\n-    },\n-    Lint {\n-        name: \"approx_constant\",\n-        group: \"correctness\",\n-        desc: \"the approximate of a known float constant (in `std::fXX::consts`)\",\n-        deprecation: None,\n-        module: \"approx_const\",\n-    },\n-    Lint {\n-        name: \"as_conversions\",\n-        group: \"restriction\",\n-        desc: \"using a potentially dangerous silent `as` conversion\",\n-        deprecation: None,\n-        module: \"as_conversions\",\n-    },\n-    Lint {\n-        name: \"assertions_on_constants\",\n-        group: \"style\",\n-        desc: \"`assert!(true)` / `assert!(false)` will be optimized out by the compiler, and should probably be replaced by a `panic!()` or `unreachable!()`\",\n-        deprecation: None,\n-        module: \"assertions_on_constants\",\n-    },\n-    Lint {\n-        name: \"assign_op_pattern\",\n-        group: \"style\",\n-        desc: \"assigning the result of an operation on a variable to that same variable\",\n-        deprecation: None,\n-        module: \"assign_ops\",\n-    },\n-    Lint {\n-        name: \"async_yields_async\",\n-        group: \"correctness\",\n-        desc: \"async blocks that return a type that can be awaited\",\n-        deprecation: None,\n-        module: \"async_yields_async\",\n-    },\n-    Lint {\n-        name: \"await_holding_lock\",\n-        group: \"pedantic\",\n-        desc: \"Inside an async function, holding a MutexGuard while calling await\",\n-        deprecation: None,\n-        module: \"await_holding_invalid\",\n-    },\n-    Lint {\n-        name: \"await_holding_refcell_ref\",\n-        group: \"pedantic\",\n-        desc: \"Inside an async function, holding a RefCell ref while calling await\",\n-        deprecation: None,\n-        module: \"await_holding_invalid\",\n-    },\n-    Lint {\n-        name: \"bad_bit_mask\",\n-        group: \"correctness\",\n-        desc: \"expressions of the form `_ & mask == select` that will only ever return `true` or `false`\",\n-        deprecation: None,\n-        module: \"bit_mask\",\n-    },\n-    Lint {\n-        name: \"bind_instead_of_map\",\n-        group: \"complexity\",\n-        desc: \"using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"blacklisted_name\",\n-        group: \"style\",\n-        desc: \"usage of a blacklisted/placeholder name\",\n-        deprecation: None,\n-        module: \"blacklisted_name\",\n-    },\n-    Lint {\n-        name: \"blanket_clippy_restriction_lints\",\n-        group: \"style\",\n-        desc: \"enabling the complete restriction group\",\n-        deprecation: None,\n-        module: \"attrs\",\n-    },\n-    Lint {\n-        name: \"blocks_in_if_conditions\",\n-        group: \"style\",\n-        desc: \"useless or complex blocks that can be eliminated in conditions\",\n-        deprecation: None,\n-        module: \"blocks_in_if_conditions\",\n-    },\n-    Lint {\n-        name: \"bool_comparison\",\n-        group: \"complexity\",\n-        desc: \"comparing a variable to a boolean, e.g., `if x == true` or `if x != true`\",\n-        deprecation: None,\n-        module: \"needless_bool\",\n-    },\n-    Lint {\n-        name: \"borrow_interior_mutable_const\",\n-        group: \"style\",\n-        desc: \"referencing `const` with interior mutability\",\n-        deprecation: None,\n-        module: \"non_copy_const\",\n-    },\n-    Lint {\n-        name: \"borrowed_box\",\n-        group: \"complexity\",\n-        desc: \"a borrow of a boxed type\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"box_vec\",\n-        group: \"perf\",\n-        desc: \"usage of `Box<Vec<T>>`, vector elements are already on the heap\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"boxed_local\",\n-        group: \"perf\",\n-        desc: \"using `Box<T>` where unnecessary\",\n-        deprecation: None,\n-        module: \"escape\",\n-    },\n-    Lint {\n-        name: \"builtin_type_shadow\",\n-        group: \"style\",\n-        desc: \"shadowing a builtin type\",\n-        deprecation: None,\n-        module: \"misc_early\",\n-    },\n-    Lint {\n-        name: \"cargo_common_metadata\",\n-        group: \"cargo\",\n-        desc: \"common metadata is defined in `Cargo.toml`\",\n-        deprecation: None,\n-        module: \"cargo_common_metadata\",\n-    },\n-    Lint {\n-        name: \"cast_lossless\",\n-        group: \"pedantic\",\n-        desc: \"casts using `as` that are known to be lossless, e.g., `x as u64` where `x: u8`\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"cast_possible_truncation\",\n-        group: \"pedantic\",\n-        desc: \"casts that may cause truncation of the value, e.g., `x as u8` where `x: u32`, or `x as i32` where `x: f32`\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"cast_possible_wrap\",\n-        group: \"pedantic\",\n-        desc: \"casts that may cause wrapping around the value, e.g., `x as i32` where `x: u32` and `x > i32::MAX`\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"cast_precision_loss\",\n-        group: \"pedantic\",\n-        desc: \"casts that cause loss of precision, e.g., `x as f32` where `x: u64`\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"cast_ptr_alignment\",\n-        group: \"pedantic\",\n-        desc: \"cast from a pointer to a more-strictly-aligned pointer\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"cast_ref_to_mut\",\n-        group: \"correctness\",\n-        desc: \"a cast of reference to a mutable pointer\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"cast_sign_loss\",\n-        group: \"pedantic\",\n-        desc: \"casts from signed types to unsigned types, e.g., `x as u32` where `x: i32`\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"char_lit_as_u8\",\n-        group: \"complexity\",\n-        desc: \"casting a character literal to `u8` truncates\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"chars_last_cmp\",\n-        group: \"style\",\n-        desc: \"using `.chars().last()` or `.chars().next_back()` to check if a string ends with a char\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"chars_next_cmp\",\n-        group: \"style\",\n-        desc: \"using `.chars().next()` to check if a string starts with a char\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"checked_conversions\",\n-        group: \"pedantic\",\n-        desc: \"`try_from` could replace manual bounds checking when casting\",\n-        deprecation: None,\n-        module: \"checked_conversions\",\n-    },\n-    Lint {\n-        name: \"clone_double_ref\",\n-        group: \"correctness\",\n-        desc: \"using `clone` on `&&T`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"clone_on_copy\",\n-        group: \"complexity\",\n-        desc: \"using `clone` on a `Copy` type\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"clone_on_ref_ptr\",\n-        group: \"restriction\",\n-        desc: \"using \\'clone\\' on a ref-counted pointer\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"cmp_nan\",\n-        group: \"correctness\",\n-        desc: \"comparisons to `NAN`, which will always return false, probably not intended\",\n-        deprecation: None,\n-        module: \"misc\",\n-    },\n-    Lint {\n-        name: \"cmp_null\",\n-        group: \"style\",\n-        desc: \"comparing a pointer to a null pointer, suggesting to use `.is_null()` instead.\",\n-        deprecation: None,\n-        module: \"ptr\",\n-    },\n-    Lint {\n-        name: \"cmp_owned\",\n-        group: \"perf\",\n-        desc: \"creating owned instances for comparing with others, e.g., `x == \\\"foo\\\".to_string()`\",\n-        deprecation: None,\n-        module: \"misc\",\n-    },\n-    Lint {\n-        name: \"cognitive_complexity\",\n-        group: \"nursery\",\n-        desc: \"functions that should be split up into multiple functions\",\n-        deprecation: None,\n-        module: \"cognitive_complexity\",\n-    },\n-    Lint {\n-        name: \"collapsible_if\",\n-        group: \"style\",\n-        desc: \"`if`s that can be collapsed (e.g., `if x { if y { ... } }` and `else { if x { ... } }`)\",\n-        deprecation: None,\n-        module: \"collapsible_if\",\n-    },\n-    Lint {\n-        name: \"comparison_chain\",\n-        group: \"style\",\n-        desc: \"`if`s that can be rewritten with `match` and `cmp`\",\n-        deprecation: None,\n-        module: \"comparison_chain\",\n-    },\n-    Lint {\n-        name: \"comparison_to_empty\",\n-        group: \"style\",\n-        desc: \"checking `x == \\\"\\\"` or `x == []` (or similar) when `.is_empty()` could be used instead\",\n-        deprecation: None,\n-        module: \"len_zero\",\n-    },\n-    Lint {\n-        name: \"copy_iterator\",\n-        group: \"pedantic\",\n-        desc: \"implementing `Iterator` on a `Copy` type\",\n-        deprecation: None,\n-        module: \"copy_iterator\",\n-    },\n-    Lint {\n-        name: \"create_dir\",\n-        group: \"restriction\",\n-        desc: \"calling `std::fs::create_dir` instead of `std::fs::create_dir_all`\",\n-        deprecation: None,\n-        module: \"create_dir\",\n-    },\n-    Lint {\n-        name: \"crosspointer_transmute\",\n-        group: \"complexity\",\n-        desc: \"transmutes that have to or from types that are a pointer to the other\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"dbg_macro\",\n-        group: \"restriction\",\n-        desc: \"`dbg!` macro is intended as a debugging tool\",\n-        deprecation: None,\n-        module: \"dbg_macro\",\n-    },\n-    Lint {\n-        name: \"debug_assert_with_mut_call\",\n-        group: \"nursery\",\n-        desc: \"mutable arguments in `debug_assert{,_ne,_eq}!`\",\n-        deprecation: None,\n-        module: \"mutable_debug_assertion\",\n-    },\n-    Lint {\n-        name: \"decimal_literal_representation\",\n-        group: \"restriction\",\n-        desc: \"using decimal representation when hexadecimal would be better\",\n-        deprecation: None,\n-        module: \"literal_representation\",\n-    },\n-    Lint {\n-        name: \"declare_interior_mutable_const\",\n-        group: \"style\",\n-        desc: \"declaring `const` with interior mutability\",\n-        deprecation: None,\n-        module: \"non_copy_const\",\n-    },\n-    Lint {\n-        name: \"default_trait_access\",\n-        group: \"pedantic\",\n-        desc: \"checks for literal calls to `Default::default()`\",\n-        deprecation: None,\n-        module: \"default\",\n-    },\n-    Lint {\n-        name: \"deprecated_cfg_attr\",\n-        group: \"complexity\",\n-        desc: \"usage of `cfg_attr(rustfmt)` instead of tool attributes\",\n-        deprecation: None,\n-        module: \"attrs\",\n-    },\n-    Lint {\n-        name: \"deprecated_semver\",\n-        group: \"correctness\",\n-        desc: \"use of `#[deprecated(since = \\\"x\\\")]` where x is not semver\",\n-        deprecation: None,\n-        module: \"attrs\",\n-    },\n-    Lint {\n-        name: \"deref_addrof\",\n-        group: \"complexity\",\n-        desc: \"use of `*&` or `*&mut` in an expression\",\n-        deprecation: None,\n-        module: \"reference\",\n-    },\n-    Lint {\n-        name: \"derive_hash_xor_eq\",\n-        group: \"correctness\",\n-        desc: \"deriving `Hash` but implementing `PartialEq` explicitly\",\n-        deprecation: None,\n-        module: \"derive\",\n-    },\n-    Lint {\n-        name: \"derive_ord_xor_partial_ord\",\n-        group: \"correctness\",\n-        desc: \"deriving `Ord` but implementing `PartialOrd` explicitly\",\n-        deprecation: None,\n-        module: \"derive\",\n-    },\n-    Lint {\n-        name: \"disallowed_method\",\n-        group: \"nursery\",\n-        desc: \"use of a disallowed method call\",\n-        deprecation: None,\n-        module: \"disallowed_method\",\n-    },\n-    Lint {\n-        name: \"diverging_sub_expression\",\n-        group: \"complexity\",\n-        desc: \"whether an expression contains a diverging sub expression\",\n-        deprecation: None,\n-        module: \"eval_order_dependence\",\n-    },\n-    Lint {\n-        name: \"doc_markdown\",\n-        group: \"pedantic\",\n-        desc: \"presence of `_`, `::` or camel-case outside backticks in documentation\",\n-        deprecation: None,\n-        module: \"doc\",\n-    },\n-    Lint {\n-        name: \"double_comparisons\",\n-        group: \"complexity\",\n-        desc: \"unnecessary double comparisons that can be simplified\",\n-        deprecation: None,\n-        module: \"double_comparison\",\n-    },\n-    Lint {\n-        name: \"double_must_use\",\n-        group: \"style\",\n-        desc: \"`#[must_use]` attribute on a `#[must_use]`-returning function / method\",\n-        deprecation: None,\n-        module: \"functions\",\n-    },\n-    Lint {\n-        name: \"double_neg\",\n-        group: \"style\",\n-        desc: \"`--x`, which is a double negation of `x` and not a pre-decrement as in C/C++\",\n-        deprecation: None,\n-        module: \"misc_early\",\n-    },\n-    Lint {\n-        name: \"double_parens\",\n-        group: \"complexity\",\n-        desc: \"Warn on unnecessary double parentheses\",\n-        deprecation: None,\n-        module: \"double_parens\",\n-    },\n-    Lint {\n-        name: \"drop_copy\",\n-        group: \"correctness\",\n-        desc: \"calls to `std::mem::drop` with a value that implements Copy\",\n-        deprecation: None,\n-        module: \"drop_forget_ref\",\n-    },\n-    Lint {\n-        name: \"drop_ref\",\n-        group: \"correctness\",\n-        desc: \"calls to `std::mem::drop` with a reference instead of an owned value\",\n-        deprecation: None,\n-        module: \"drop_forget_ref\",\n-    },\n-    Lint {\n-        name: \"duplicate_underscore_argument\",\n-        group: \"style\",\n-        desc: \"function arguments having names which only differ by an underscore\",\n-        deprecation: None,\n-        module: \"misc_early\",\n-    },\n-    Lint {\n-        name: \"duration_subsec\",\n-        group: \"complexity\",\n-        desc: \"checks for calculation of subsecond microseconds or milliseconds\",\n-        deprecation: None,\n-        module: \"duration_subsec\",\n-    },\n-    Lint {\n-        name: \"else_if_without_else\",\n-        group: \"restriction\",\n-        desc: \"`if` expression with an `else if`, but without a final `else` branch\",\n-        deprecation: None,\n-        module: \"else_if_without_else\",\n-    },\n-    Lint {\n-        name: \"empty_enum\",\n-        group: \"pedantic\",\n-        desc: \"enum with no variants\",\n-        deprecation: None,\n-        module: \"empty_enum\",\n-    },\n-    Lint {\n-        name: \"empty_line_after_outer_attr\",\n-        group: \"nursery\",\n-        desc: \"empty line after outer attribute\",\n-        deprecation: None,\n-        module: \"attrs\",\n-    },\n-    Lint {\n-        name: \"empty_loop\",\n-        group: \"style\",\n-        desc: \"empty `loop {}`, which should block or sleep\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"enum_clike_unportable_variant\",\n-        group: \"correctness\",\n-        desc: \"C-like enums that are `repr(isize/usize)` and have values that don\\'t fit into an `i32`\",\n-        deprecation: None,\n-        module: \"enum_clike\",\n-    },\n-    Lint {\n-        name: \"enum_glob_use\",\n-        group: \"pedantic\",\n-        desc: \"use items that import all variants of an enum\",\n-        deprecation: None,\n-        module: \"wildcard_imports\",\n-    },\n-    Lint {\n-        name: \"enum_variant_names\",\n-        group: \"style\",\n-        desc: \"enums where all variants share a prefix/postfix\",\n-        deprecation: None,\n-        module: \"enum_variants\",\n-    },\n-    Lint {\n-        name: \"eq_op\",\n-        group: \"correctness\",\n-        desc: \"equal operands on both sides of a comparison or bitwise combination (e.g., `x == x`)\",\n-        deprecation: None,\n-        module: \"eq_op\",\n-    },\n-    Lint {\n-        name: \"erasing_op\",\n-        group: \"correctness\",\n-        desc: \"using erasing operations, e.g., `x * 0` or `y & 0`\",\n-        deprecation: None,\n-        module: \"erasing_op\",\n-    },\n-    Lint {\n-        name: \"eval_order_dependence\",\n-        group: \"complexity\",\n-        desc: \"whether a variable read occurs before a write depends on sub-expression evaluation order\",\n-        deprecation: None,\n-        module: \"eval_order_dependence\",\n-    },\n-    Lint {\n-        name: \"excessive_precision\",\n-        group: \"style\",\n-        desc: \"excessive precision for float literal\",\n-        deprecation: None,\n-        module: \"float_literal\",\n-    },\n-    Lint {\n-        name: \"exit\",\n-        group: \"restriction\",\n-        desc: \"`std::process::exit` is called, terminating the program\",\n-        deprecation: None,\n-        module: \"exit\",\n-    },\n-    Lint {\n-        name: \"expect_fun_call\",\n-        group: \"perf\",\n-        desc: \"using any `expect` method with a function call\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"expect_used\",\n-        group: \"restriction\",\n-        desc: \"using `.expect()` on `Result` or `Option`, which might be better handled\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"expl_impl_clone_on_copy\",\n-        group: \"pedantic\",\n-        desc: \"implementing `Clone` explicitly on `Copy` types\",\n-        deprecation: None,\n-        module: \"derive\",\n-    },\n-    Lint {\n-        name: \"explicit_counter_loop\",\n-        group: \"complexity\",\n-        desc: \"for-looping with an explicit counter when `_.enumerate()` would do\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"explicit_deref_methods\",\n-        group: \"pedantic\",\n-        desc: \"Explicit use of deref or deref_mut method while not in a method chain.\",\n-        deprecation: None,\n-        module: \"dereference\",\n-    },\n-    Lint {\n-        name: \"explicit_into_iter_loop\",\n-        group: \"pedantic\",\n-        desc: \"for-looping over `_.into_iter()` when `_` would do\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"explicit_iter_loop\",\n-        group: \"pedantic\",\n-        desc: \"for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"explicit_write\",\n-        group: \"complexity\",\n-        desc: \"using the `write!()` family of functions instead of the `print!()` family of functions, when using the latter would work\",\n-        deprecation: None,\n-        module: \"explicit_write\",\n-    },\n-    Lint {\n-        name: \"extra_unused_lifetimes\",\n-        group: \"complexity\",\n-        desc: \"unused lifetimes in function definitions\",\n-        deprecation: None,\n-        module: \"lifetimes\",\n-    },\n-    Lint {\n-        name: \"fallible_impl_from\",\n-        group: \"nursery\",\n-        desc: \"Warn on impls of `From<..>` that contain `panic!()` or `unwrap()`\",\n-        deprecation: None,\n-        module: \"fallible_impl_from\",\n-    },\n-    Lint {\n-        name: \"field_reassign_with_default\",\n-        group: \"style\",\n-        desc: \"binding initialized with Default should have its fields set in the initializer\",\n-        deprecation: None,\n-        module: \"default\",\n-    },\n-    Lint {\n-        name: \"filetype_is_file\",\n-        group: \"restriction\",\n-        desc: \"`FileType::is_file` is not recommended to test for readable file type\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"filter_map\",\n-        group: \"pedantic\",\n-        desc: \"using combinations of `filter`, `map`, `filter_map` and `flat_map` which can usually be written as a single method call\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"filter_map_next\",\n-        group: \"pedantic\",\n-        desc: \"using combination of `filter_map` and `next` which can usually be written as a single method call\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"filter_next\",\n-        group: \"complexity\",\n-        desc: \"using `filter(p).next()`, which is more succinctly expressed as `.find(p)`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"find_map\",\n-        group: \"pedantic\",\n-        desc: \"using a combination of `find` and `map` can usually be written as a single method call\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"flat_map_identity\",\n-        group: \"complexity\",\n-        desc: \"call to `flat_map` where `flatten` is sufficient\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"float_arithmetic\",\n-        group: \"restriction\",\n-        desc: \"any floating-point arithmetic statement\",\n-        deprecation: None,\n-        module: \"arithmetic\",\n-    },\n-    Lint {\n-        name: \"float_cmp\",\n-        group: \"correctness\",\n-        desc: \"using `==` or `!=` on float values instead of comparing difference with an epsilon\",\n-        deprecation: None,\n-        module: \"misc\",\n-    },\n-    Lint {\n-        name: \"float_cmp_const\",\n-        group: \"restriction\",\n-        desc: \"using `==` or `!=` on float constants instead of comparing difference with an epsilon\",\n-        deprecation: None,\n-        module: \"misc\",\n-    },\n-    Lint {\n-        name: \"float_equality_without_abs\",\n-        group: \"correctness\",\n-        desc: \"float equality check without `.abs()`\",\n-        deprecation: None,\n-        module: \"float_equality_without_abs\",\n-    },\n-    Lint {\n-        name: \"fn_address_comparisons\",\n-        group: \"correctness\",\n-        desc: \"comparison with an address of a function item\",\n-        deprecation: None,\n-        module: \"unnamed_address\",\n-    },\n-    Lint {\n-        name: \"fn_params_excessive_bools\",\n-        group: \"pedantic\",\n-        desc: \"using too many bools in function parameters\",\n-        deprecation: None,\n-        module: \"excessive_bools\",\n-    },\n-    Lint {\n-        name: \"fn_to_numeric_cast\",\n-        group: \"style\",\n-        desc: \"casting a function pointer to a numeric type other than usize\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"fn_to_numeric_cast_with_truncation\",\n-        group: \"style\",\n-        desc: \"casting a function pointer to a numeric type not wide enough to store the address\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"for_kv_map\",\n-        group: \"style\",\n-        desc: \"looping on a map using `iter` when `keys` or `values` would do\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"for_loops_over_fallibles\",\n-        group: \"correctness\",\n-        desc: \"for-looping over an `Option` or a `Result`, which is more clearly expressed as an `if let`\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"forget_copy\",\n-        group: \"correctness\",\n-        desc: \"calls to `std::mem::forget` with a value that implements Copy\",\n-        deprecation: None,\n-        module: \"drop_forget_ref\",\n-    },\n-    Lint {\n-        name: \"forget_ref\",\n-        group: \"correctness\",\n-        desc: \"calls to `std::mem::forget` with a reference instead of an owned value\",\n-        deprecation: None,\n-        module: \"drop_forget_ref\",\n-    },\n-    Lint {\n-        name: \"from_iter_instead_of_collect\",\n-        group: \"style\",\n-        desc: \"use `.collect()` instead of `::from_iter()`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"future_not_send\",\n-        group: \"nursery\",\n-        desc: \"public Futures must be Send\",\n-        deprecation: None,\n-        module: \"future_not_send\",\n-    },\n-    Lint {\n-        name: \"get_last_with_len\",\n-        group: \"complexity\",\n-        desc: \"Using `x.get(x.len() - 1)` when `x.last()` is correct and simpler\",\n-        deprecation: None,\n-        module: \"get_last_with_len\",\n-    },\n-    Lint {\n-        name: \"get_unwrap\",\n-        group: \"restriction\",\n-        desc: \"using `.get().unwrap()` or `.get_mut().unwrap()` when using `[]` would work instead\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"identity_op\",\n-        group: \"complexity\",\n-        desc: \"using identity operations, e.g., `x + 0` or `y / 1`\",\n-        deprecation: None,\n-        module: \"identity_op\",\n-    },\n-    Lint {\n-        name: \"if_let_mutex\",\n-        group: \"correctness\",\n-        desc: \"locking a `Mutex` in an `if let` block can cause deadlocks\",\n-        deprecation: None,\n-        module: \"if_let_mutex\",\n-    },\n-    Lint {\n-        name: \"if_let_some_result\",\n-        group: \"style\",\n-        desc: \"usage of `ok()` in `if let Some(pat)` statements is unnecessary, match on `Ok(pat)` instead\",\n-        deprecation: None,\n-        module: \"if_let_some_result\",\n-    },\n-    Lint {\n-        name: \"if_not_else\",\n-        group: \"pedantic\",\n-        desc: \"`if` branches that could be swapped so no negation operation is necessary on the condition\",\n-        deprecation: None,\n-        module: \"if_not_else\",\n-    },\n-    Lint {\n-        name: \"if_same_then_else\",\n-        group: \"correctness\",\n-        desc: \"`if` with the same `then` and `else` blocks\",\n-        deprecation: None,\n-        module: \"copies\",\n-    },\n-    Lint {\n-        name: \"ifs_same_cond\",\n-        group: \"correctness\",\n-        desc: \"consecutive `if`s with the same condition\",\n-        deprecation: None,\n-        module: \"copies\",\n-    },\n-    Lint {\n-        name: \"implicit_hasher\",\n-        group: \"pedantic\",\n-        desc: \"missing generalization over different hashers\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"implicit_return\",\n-        group: \"restriction\",\n-        desc: \"use a return statement like `return expr` instead of an expression\",\n-        deprecation: None,\n-        module: \"implicit_return\",\n-    },\n-    Lint {\n-        name: \"implicit_saturating_sub\",\n-        group: \"pedantic\",\n-        desc: \"Perform saturating subtraction instead of implicitly checking lower bound of data type\",\n-        deprecation: None,\n-        module: \"implicit_saturating_sub\",\n-    },\n-    Lint {\n-        name: \"imprecise_flops\",\n-        group: \"nursery\",\n-        desc: \"usage of imprecise floating point operations\",\n-        deprecation: None,\n-        module: \"floating_point_arithmetic\",\n-    },\n-    Lint {\n-        name: \"inconsistent_digit_grouping\",\n-        group: \"style\",\n-        desc: \"integer literals with digits grouped inconsistently\",\n-        deprecation: None,\n-        module: \"literal_representation\",\n-    },\n-    Lint {\n-        name: \"indexing_slicing\",\n-        group: \"restriction\",\n-        desc: \"indexing/slicing usage\",\n-        deprecation: None,\n-        module: \"indexing_slicing\",\n-    },\n-    Lint {\n-        name: \"ineffective_bit_mask\",\n-        group: \"correctness\",\n-        desc: \"expressions where a bit mask will be rendered useless by a comparison, e.g., `(x | 1) > 2`\",\n-        deprecation: None,\n-        module: \"bit_mask\",\n-    },\n-    Lint {\n-        name: \"inefficient_to_string\",\n-        group: \"pedantic\",\n-        desc: \"using `to_string` on `&&T` where `T: ToString`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"infallible_destructuring_match\",\n-        group: \"style\",\n-        desc: \"a `match` statement with a single infallible arm instead of a `let`\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"infinite_iter\",\n-        group: \"correctness\",\n-        desc: \"infinite iteration\",\n-        deprecation: None,\n-        module: \"infinite_iter\",\n-    },\n-    Lint {\n-        name: \"inherent_to_string\",\n-        group: \"style\",\n-        desc: \"type implements inherent method `to_string()`, but should instead implement the `Display` trait\",\n-        deprecation: None,\n-        module: \"inherent_to_string\",\n-    },\n-    Lint {\n-        name: \"inherent_to_string_shadow_display\",\n-        group: \"correctness\",\n-        desc: \"type implements inherent method `to_string()`, which gets shadowed by the implementation of the `Display` trait\",\n-        deprecation: None,\n-        module: \"inherent_to_string\",\n-    },\n-    Lint {\n-        name: \"inline_always\",\n-        group: \"pedantic\",\n-        desc: \"use of `#[inline(always)]`\",\n-        deprecation: None,\n-        module: \"attrs\",\n-    },\n-    Lint {\n-        name: \"inline_asm_x86_att_syntax\",\n-        group: \"restriction\",\n-        desc: \"prefer Intel x86 assembly syntax\",\n-        deprecation: None,\n-        module: \"asm_syntax\",\n-    },\n-    Lint {\n-        name: \"inline_asm_x86_intel_syntax\",\n-        group: \"restriction\",\n-        desc: \"prefer AT&T x86 assembly syntax\",\n-        deprecation: None,\n-        module: \"asm_syntax\",\n-    },\n-    Lint {\n-        name: \"inline_fn_without_body\",\n-        group: \"correctness\",\n-        desc: \"use of `#[inline]` on trait methods without bodies\",\n-        deprecation: None,\n-        module: \"inline_fn_without_body\",\n-    },\n-    Lint {\n-        name: \"int_plus_one\",\n-        group: \"complexity\",\n-        desc: \"instead of using `x >= y + 1`, use `x > y`\",\n-        deprecation: None,\n-        module: \"int_plus_one\",\n-    },\n-    Lint {\n-        name: \"integer_arithmetic\",\n-        group: \"restriction\",\n-        desc: \"any integer arithmetic expression which could overflow or panic\",\n-        deprecation: None,\n-        module: \"arithmetic\",\n-    },\n-    Lint {\n-        name: \"integer_division\",\n-        group: \"restriction\",\n-        desc: \"integer division may cause loss of precision\",\n-        deprecation: None,\n-        module: \"integer_division\",\n-    },\n-    Lint {\n-        name: \"into_iter_on_ref\",\n-        group: \"style\",\n-        desc: \"using `.into_iter()` on a reference\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"invalid_atomic_ordering\",\n-        group: \"correctness\",\n-        desc: \"usage of invalid atomic ordering in atomic operations and memory fences\",\n-        deprecation: None,\n-        module: \"atomic_ordering\",\n-    },\n-    Lint {\n-        name: \"invalid_regex\",\n-        group: \"correctness\",\n-        desc: \"invalid regular expressions\",\n-        deprecation: None,\n-        module: \"regex\",\n-    },\n-    Lint {\n-        name: \"invalid_upcast_comparisons\",\n-        group: \"pedantic\",\n-        desc: \"a comparison involving an upcast which is always true or false\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"invisible_characters\",\n-        group: \"correctness\",\n-        desc: \"using an invisible character in a string literal, which is confusing\",\n-        deprecation: None,\n-        module: \"unicode\",\n-    },\n-    Lint {\n-        name: \"items_after_statements\",\n-        group: \"pedantic\",\n-        desc: \"blocks where an item comes after a statement\",\n-        deprecation: None,\n-        module: \"items_after_statements\",\n-    },\n-    Lint {\n-        name: \"iter_cloned_collect\",\n-        group: \"style\",\n-        desc: \"using `.cloned().collect()` on slice to create a `Vec`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"iter_next_loop\",\n-        group: \"correctness\",\n-        desc: \"for-looping over `_.next()` which is probably not intended\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"iter_next_slice\",\n-        group: \"style\",\n-        desc: \"using `.iter().next()` on a sliced array, which can be shortened to just `.get()`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"iter_nth\",\n-        group: \"perf\",\n-        desc: \"using `.iter().nth()` on a standard library type with O(1) element access\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"iter_nth_zero\",\n-        group: \"style\",\n-        desc: \"replace `iter.nth(0)` with `iter.next()`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"iter_skip_next\",\n-        group: \"style\",\n-        desc: \"using `.skip(x).next()` on an iterator\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"iterator_step_by_zero\",\n-        group: \"correctness\",\n-        desc: \"using `Iterator::step_by(0)`, which will panic at runtime\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"just_underscores_and_digits\",\n-        group: \"style\",\n-        desc: \"unclear name\",\n-        deprecation: None,\n-        module: \"non_expressive_names\",\n-    },\n-    Lint {\n-        name: \"large_const_arrays\",\n-        group: \"perf\",\n-        desc: \"large non-scalar const array may cause performance overhead\",\n-        deprecation: None,\n-        module: \"large_const_arrays\",\n-    },\n-    Lint {\n-        name: \"large_digit_groups\",\n-        group: \"pedantic\",\n-        desc: \"grouping digits into groups that are too large\",\n-        deprecation: None,\n-        module: \"literal_representation\",\n-    },\n-    Lint {\n-        name: \"large_enum_variant\",\n-        group: \"perf\",\n-        desc: \"large size difference between variants on an enum\",\n-        deprecation: None,\n-        module: \"large_enum_variant\",\n-    },\n-    Lint {\n-        name: \"large_stack_arrays\",\n-        group: \"pedantic\",\n-        desc: \"allocating large arrays on stack may cause stack overflow\",\n-        deprecation: None,\n-        module: \"large_stack_arrays\",\n-    },\n-    Lint {\n-        name: \"large_types_passed_by_value\",\n-        group: \"pedantic\",\n-        desc: \"functions taking large arguments by value\",\n-        deprecation: None,\n-        module: \"pass_by_ref_or_value\",\n-    },\n-    Lint {\n-        name: \"len_without_is_empty\",\n-        group: \"style\",\n-        desc: \"traits or impls with a public `len` method but no corresponding `is_empty` method\",\n-        deprecation: None,\n-        module: \"len_zero\",\n-    },\n-    Lint {\n-        name: \"len_zero\",\n-        group: \"style\",\n-        desc: \"checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` could be used instead\",\n-        deprecation: None,\n-        module: \"len_zero\",\n-    },\n-    Lint {\n-        name: \"let_and_return\",\n-        group: \"style\",\n-        desc: \"creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\",\n-        deprecation: None,\n-        module: \"returns\",\n-    },\n-    Lint {\n-        name: \"let_underscore_drop\",\n-        group: \"pedantic\",\n-        desc: \"non-binding let on a type that implements `Drop`\",\n-        deprecation: None,\n-        module: \"let_underscore\",\n-    },\n-    Lint {\n-        name: \"let_underscore_lock\",\n-        group: \"correctness\",\n-        desc: \"non-binding let on a synchronization lock\",\n-        deprecation: None,\n-        module: \"let_underscore\",\n-    },\n-    Lint {\n-        name: \"let_underscore_must_use\",\n-        group: \"restriction\",\n-        desc: \"non-binding let on a `#[must_use]` expression\",\n-        deprecation: None,\n-        module: \"let_underscore\",\n-    },\n-    Lint {\n-        name: \"let_unit_value\",\n-        group: \"pedantic\",\n-        desc: \"creating a `let` binding to a value of unit type, which usually can\\'t be used afterwards\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"linkedlist\",\n-        group: \"pedantic\",\n-        desc: \"usage of LinkedList, usually a vector is faster, or a more specialized data structure like a `VecDeque`\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"logic_bug\",\n-        group: \"correctness\",\n-        desc: \"boolean expressions that contain terminals which can be eliminated\",\n-        deprecation: None,\n-        module: \"booleans\",\n-    },\n-    Lint {\n-        name: \"lossy_float_literal\",\n-        group: \"restriction\",\n-        desc: \"lossy whole number float literals\",\n-        deprecation: None,\n-        module: \"float_literal\",\n-    },\n-    Lint {\n-        name: \"macro_use_imports\",\n-        group: \"pedantic\",\n-        desc: \"#[macro_use] is no longer needed\",\n-        deprecation: None,\n-        module: \"macro_use\",\n-    },\n-    Lint {\n-        name: \"main_recursion\",\n-        group: \"style\",\n-        desc: \"recursion using the entrypoint\",\n-        deprecation: None,\n-        module: \"main_recursion\",\n-    },\n-    Lint {\n-        name: \"manual_async_fn\",\n-        group: \"style\",\n-        desc: \"manual implementations of `async` functions can be simplified using the dedicated syntax\",\n-        deprecation: None,\n-        module: \"manual_async_fn\",\n-    },\n-    Lint {\n-        name: \"manual_memcpy\",\n-        group: \"perf\",\n-        desc: \"manually copying items between slices\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"manual_non_exhaustive\",\n-        group: \"style\",\n-        desc: \"manual implementations of the non-exhaustive pattern can be simplified using #[non_exhaustive]\",\n-        deprecation: None,\n-        module: \"manual_non_exhaustive\",\n-    },\n-    Lint {\n-        name: \"manual_ok_or\",\n-        group: \"pedantic\",\n-        desc: \"finds patterns that can be encoded more concisely with `Option::ok_or`\",\n-        deprecation: None,\n-        module: \"manual_ok_or\",\n-    },\n-    Lint {\n-        name: \"manual_range_contains\",\n-        group: \"style\",\n-        desc: \"manually reimplementing {`Range`, `RangeInclusive`}`::contains`\",\n-        deprecation: None,\n-        module: \"ranges\",\n-    },\n-    Lint {\n-        name: \"manual_saturating_arithmetic\",\n-        group: \"style\",\n-        desc: \"`.chcked_add/sub(x).unwrap_or(MAX/MIN)`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"manual_strip\",\n-        group: \"complexity\",\n-        desc: \"suggests using `strip_{prefix,suffix}` over `str::{starts,ends}_with` and slicing\",\n-        deprecation: None,\n-        module: \"manual_strip\",\n-    },\n-    Lint {\n-        name: \"manual_swap\",\n-        group: \"complexity\",\n-        desc: \"manual swap of two variables\",\n-        deprecation: None,\n-        module: \"swap\",\n-    },\n-    Lint {\n-        name: \"manual_unwrap_or\",\n-        group: \"complexity\",\n-        desc: \"finds patterns that can be encoded more concisely with `Option::unwrap_or` or `Result::unwrap_or`\",\n-        deprecation: None,\n-        module: \"manual_unwrap_or\",\n-    },\n-    Lint {\n-        name: \"many_single_char_names\",\n-        group: \"style\",\n-        desc: \"too many single character bindings\",\n-        deprecation: None,\n-        module: \"non_expressive_names\",\n-    },\n-    Lint {\n-        name: \"map_clone\",\n-        group: \"style\",\n-        desc: \"using `iterator.map(|x| x.clone())`, or dereferencing closures for `Copy` types\",\n-        deprecation: None,\n-        module: \"map_clone\",\n-    },\n-    Lint {\n-        name: \"map_collect_result_unit\",\n-        group: \"style\",\n-        desc: \"using `.map(_).collect::<Result<(),_>()`, which can be replaced with `try_for_each`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"map_entry\",\n-        group: \"perf\",\n-        desc: \"use of `contains_key` followed by `insert` on a `HashMap` or `BTreeMap`\",\n-        deprecation: None,\n-        module: \"entry\",\n-    },\n-    Lint {\n-        name: \"map_err_ignore\",\n-        group: \"pedantic\",\n-        desc: \"`map_err` should not ignore the original error\",\n-        deprecation: None,\n-        module: \"map_err_ignore\",\n-    },\n-    Lint {\n-        name: \"map_flatten\",\n-        group: \"pedantic\",\n-        desc: \"using combinations of `flatten` and `map` which can usually be written as a single method call\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"map_identity\",\n-        group: \"complexity\",\n-        desc: \"using iterator.map(|x| x)\",\n-        deprecation: None,\n-        module: \"map_identity\",\n-    },\n-    Lint {\n-        name: \"map_unwrap_or\",\n-        group: \"pedantic\",\n-        desc: \"using `.map(f).unwrap_or(a)` or `.map(f).unwrap_or_else(func)`, which are more succinctly expressed as `map_or(a, f)` or `map_or_else(a, f)`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"match_as_ref\",\n-        group: \"complexity\",\n-        desc: \"a `match` on an Option value instead of using `as_ref()` or `as_mut`\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"match_bool\",\n-        group: \"pedantic\",\n-        desc: \"a `match` on a boolean expression instead of an `if..else` block\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"match_like_matches_macro\",\n-        group: \"style\",\n-        desc: \"a match that could be written with the matches! macro\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"match_on_vec_items\",\n-        group: \"pedantic\",\n-        desc: \"matching on vector elements can panic\",\n-        deprecation: None,\n-        module: \"match_on_vec_items\",\n-    },\n-    Lint {\n-        name: \"match_overlapping_arm\",\n-        group: \"style\",\n-        desc: \"a `match` with overlapping arms\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"match_ref_pats\",\n-        group: \"style\",\n-        desc: \"a `match` or `if let` with all arms prefixed with `&` instead of deref-ing the match expression\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"match_same_arms\",\n-        group: \"pedantic\",\n-        desc: \"`match` with identical arm bodies\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"match_single_binding\",\n-        group: \"complexity\",\n-        desc: \"a match with a single binding instead of using `let` statement\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"match_wild_err_arm\",\n-        group: \"pedantic\",\n-        desc: \"a `match` with `Err(_)` arm and take drastic actions\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"match_wildcard_for_single_variants\",\n-        group: \"pedantic\",\n-        desc: \"a wildcard enum match for a single variant\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"maybe_infinite_iter\",\n-        group: \"pedantic\",\n-        desc: \"possible infinite iteration\",\n-        deprecation: None,\n-        module: \"infinite_iter\",\n-    },\n-    Lint {\n-        name: \"mem_discriminant_non_enum\",\n-        group: \"correctness\",\n-        desc: \"calling `mem::descriminant` on non-enum type\",\n-        deprecation: None,\n-        module: \"mem_discriminant\",\n-    },\n-    Lint {\n-        name: \"mem_forget\",\n-        group: \"restriction\",\n-        desc: \"`mem::forget` usage on `Drop` types, likely to cause memory leaks\",\n-        deprecation: None,\n-        module: \"mem_forget\",\n-    },\n-    Lint {\n-        name: \"mem_replace_option_with_none\",\n-        group: \"style\",\n-        desc: \"replacing an `Option` with `None` instead of `take()`\",\n-        deprecation: None,\n-        module: \"mem_replace\",\n-    },\n-    Lint {\n-        name: \"mem_replace_with_default\",\n-        group: \"style\",\n-        desc: \"replacing a value of type `T` with `T::default()` instead of using `std::mem::take`\",\n-        deprecation: None,\n-        module: \"mem_replace\",\n-    },\n-    Lint {\n-        name: \"mem_replace_with_uninit\",\n-        group: \"correctness\",\n-        desc: \"`mem::replace(&mut _, mem::uninitialized())` or `mem::replace(&mut _, mem::zeroed())`\",\n-        deprecation: None,\n-        module: \"mem_replace\",\n-    },\n-    Lint {\n-        name: \"min_max\",\n-        group: \"correctness\",\n-        desc: \"`min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\",\n-        deprecation: None,\n-        module: \"minmax\",\n-    },\n-    Lint {\n-        name: \"mismatched_target_os\",\n-        group: \"correctness\",\n-        desc: \"usage of `cfg(operating_system)` instead of `cfg(target_os = \\\"operating_system\\\")`\",\n-        deprecation: None,\n-        module: \"attrs\",\n-    },\n-    Lint {\n-        name: \"misrefactored_assign_op\",\n-        group: \"complexity\",\n-        desc: \"having a variable on both sides of an assign op\",\n-        deprecation: None,\n-        module: \"assign_ops\",\n-    },\n-    Lint {\n-        name: \"missing_const_for_fn\",\n-        group: \"nursery\",\n-        desc: \"Lint functions definitions that could be made `const fn`\",\n-        deprecation: None,\n-        module: \"missing_const_for_fn\",\n-    },\n-    Lint {\n-        name: \"missing_docs_in_private_items\",\n-        group: \"restriction\",\n-        desc: \"detects missing documentation for public and private members\",\n-        deprecation: None,\n-        module: \"missing_doc\",\n-    },\n-    Lint {\n-        name: \"missing_errors_doc\",\n-        group: \"pedantic\",\n-        desc: \"`pub fn` returns `Result` without `# Errors` in doc comment\",\n-        deprecation: None,\n-        module: \"doc\",\n-    },\n-    Lint {\n-        name: \"missing_inline_in_public_items\",\n-        group: \"restriction\",\n-        desc: \"detects missing `#[inline]` attribute for public callables (functions, trait methods, methods...)\",\n-        deprecation: None,\n-        module: \"missing_inline\",\n-    },\n-    Lint {\n-        name: \"missing_safety_doc\",\n-        group: \"style\",\n-        desc: \"`pub unsafe fn` without `# Safety` docs\",\n-        deprecation: None,\n-        module: \"doc\",\n-    },\n-    Lint {\n-        name: \"mistyped_literal_suffixes\",\n-        group: \"correctness\",\n-        desc: \"mistyped literal suffix\",\n-        deprecation: None,\n-        module: \"literal_representation\",\n-    },\n-    Lint {\n-        name: \"mixed_case_hex_literals\",\n-        group: \"style\",\n-        desc: \"hex literals whose letter digits are not consistently upper- or lowercased\",\n-        deprecation: None,\n-        module: \"misc_early\",\n-    },\n-    Lint {\n-        name: \"module_inception\",\n-        group: \"style\",\n-        desc: \"modules that have the same name as their parent module\",\n-        deprecation: None,\n-        module: \"enum_variants\",\n-    },\n-    Lint {\n-        name: \"module_name_repetitions\",\n-        group: \"pedantic\",\n-        desc: \"type names prefixed/postfixed with their containing module\\'s name\",\n-        deprecation: None,\n-        module: \"enum_variants\",\n-    },\n-    Lint {\n-        name: \"modulo_arithmetic\",\n-        group: \"restriction\",\n-        desc: \"any modulo arithmetic statement\",\n-        deprecation: None,\n-        module: \"modulo_arithmetic\",\n-    },\n-    Lint {\n-        name: \"modulo_one\",\n-        group: \"correctness\",\n-        desc: \"taking a number modulo 1, which always returns 0\",\n-        deprecation: None,\n-        module: \"misc\",\n-    },\n-    Lint {\n-        name: \"multiple_crate_versions\",\n-        group: \"cargo\",\n-        desc: \"multiple versions of the same crate being used\",\n-        deprecation: None,\n-        module: \"multiple_crate_versions\",\n-    },\n-    Lint {\n-        name: \"multiple_inherent_impl\",\n-        group: \"restriction\",\n-        desc: \"Multiple inherent impl that could be grouped\",\n-        deprecation: None,\n-        module: \"inherent_impl\",\n-    },\n-    Lint {\n-        name: \"must_use_candidate\",\n-        group: \"pedantic\",\n-        desc: \"function or method that could take a `#[must_use]` attribute\",\n-        deprecation: None,\n-        module: \"functions\",\n-    },\n-    Lint {\n-        name: \"must_use_unit\",\n-        group: \"style\",\n-        desc: \"`#[must_use]` attribute on a unit-returning function / method\",\n-        deprecation: None,\n-        module: \"functions\",\n-    },\n-    Lint {\n-        name: \"mut_from_ref\",\n-        group: \"correctness\",\n-        desc: \"fns that create mutable refs from immutable ref args\",\n-        deprecation: None,\n-        module: \"ptr\",\n-    },\n-    Lint {\n-        name: \"mut_mut\",\n-        group: \"pedantic\",\n-        desc: \"usage of double-mut refs, e.g., `&mut &mut ...`\",\n-        deprecation: None,\n-        module: \"mut_mut\",\n-    },\n-    Lint {\n-        name: \"mut_mutex_lock\",\n-        group: \"style\",\n-        desc: \"`&mut Mutex::lock` does unnecessary locking\",\n-        deprecation: None,\n-        module: \"mut_mutex_lock\",\n-    },\n-    Lint {\n-        name: \"mut_range_bound\",\n-        group: \"complexity\",\n-        desc: \"for loop over a range where one of the bounds is a mutable variable\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"mutable_key_type\",\n-        group: \"correctness\",\n-        desc: \"Check for mutable `Map`/`Set` key type\",\n-        deprecation: None,\n-        module: \"mut_key\",\n-    },\n-    Lint {\n-        name: \"mutex_atomic\",\n-        group: \"perf\",\n-        desc: \"using a mutex where an atomic value could be used instead\",\n-        deprecation: None,\n-        module: \"mutex_atomic\",\n-    },\n-    Lint {\n-        name: \"mutex_integer\",\n-        group: \"nursery\",\n-        desc: \"using a mutex for an integer type\",\n-        deprecation: None,\n-        module: \"mutex_atomic\",\n-    },\n-    Lint {\n-        name: \"naive_bytecount\",\n-        group: \"perf\",\n-        desc: \"use of naive `<slice>.filter(|&x| x == y).count()` to count byte values\",\n-        deprecation: None,\n-        module: \"bytecount\",\n-    },\n-    Lint {\n-        name: \"needless_arbitrary_self_type\",\n-        group: \"complexity\",\n-        desc: \"type of `self` parameter is already by default `Self`\",\n-        deprecation: None,\n-        module: \"needless_arbitrary_self_type\",\n-    },\n-    Lint {\n-        name: \"needless_bool\",\n-        group: \"complexity\",\n-        desc: \"if-statements with plain booleans in the then- and else-clause, e.g., `if p { true } else { false }`\",\n-        deprecation: None,\n-        module: \"needless_bool\",\n-    },\n-    Lint {\n-        name: \"needless_borrow\",\n-        group: \"nursery\",\n-        desc: \"taking a reference that is going to be automatically dereferenced\",\n-        deprecation: None,\n-        module: \"needless_borrow\",\n-    },\n-    Lint {\n-        name: \"needless_borrowed_reference\",\n-        group: \"complexity\",\n-        desc: \"taking a needless borrowed reference\",\n-        deprecation: None,\n-        module: \"needless_borrowed_ref\",\n-    },\n-    Lint {\n-        name: \"needless_collect\",\n-        group: \"perf\",\n-        desc: \"collecting an iterator when collect is not needed\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"needless_continue\",\n-        group: \"pedantic\",\n-        desc: \"`continue` statements that can be replaced by a rearrangement of code\",\n-        deprecation: None,\n-        module: \"needless_continue\",\n-    },\n-    Lint {\n-        name: \"needless_doctest_main\",\n-        group: \"style\",\n-        desc: \"presence of `fn main() {` in code examples\",\n-        deprecation: None,\n-        module: \"doc\",\n-    },\n-    Lint {\n-        name: \"needless_lifetimes\",\n-        group: \"complexity\",\n-        desc: \"using explicit lifetimes for references in function arguments when elision rules would allow omitting them\",\n-        deprecation: None,\n-        module: \"lifetimes\",\n-    },\n-    Lint {\n-        name: \"needless_pass_by_value\",\n-        group: \"pedantic\",\n-        desc: \"functions taking arguments by value, but not consuming them in its body\",\n-        deprecation: None,\n-        module: \"needless_pass_by_value\",\n-    },\n-    Lint {\n-        name: \"needless_range_loop\",\n-        group: \"style\",\n-        desc: \"for-looping over a range of indices where an iterator over items would do\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"needless_return\",\n-        group: \"style\",\n-        desc: \"using a return statement like `return expr;` where an expression would suffice\",\n-        deprecation: None,\n-        module: \"returns\",\n-    },\n-    Lint {\n-        name: \"needless_update\",\n-        group: \"complexity\",\n-        desc: \"using `Foo { ..base }` when there are no missing fields\",\n-        deprecation: None,\n-        module: \"needless_update\",\n-    },\n-    Lint {\n-        name: \"neg_cmp_op_on_partial_ord\",\n-        group: \"complexity\",\n-        desc: \"The use of negated comparison operators on partially ordered types may produce confusing code.\",\n-        deprecation: None,\n-        module: \"neg_cmp_op_on_partial_ord\",\n-    },\n-    Lint {\n-        name: \"neg_multiply\",\n-        group: \"style\",\n-        desc: \"multiplying integers with `-1`\",\n-        deprecation: None,\n-        module: \"neg_multiply\",\n-    },\n-    Lint {\n-        name: \"never_loop\",\n-        group: \"correctness\",\n-        desc: \"any loop that will always `break` or `return`\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"new_ret_no_self\",\n-        group: \"style\",\n-        desc: \"not returning type containing `Self` in a `new` method\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"new_without_default\",\n-        group: \"style\",\n-        desc: \"`fn new() -> Self` method without `Default` implementation\",\n-        deprecation: None,\n-        module: \"new_without_default\",\n-    },\n-    Lint {\n-        name: \"no_effect\",\n-        group: \"complexity\",\n-        desc: \"statements with no effect\",\n-        deprecation: None,\n-        module: \"no_effect\",\n-    },\n-    Lint {\n-        name: \"non_ascii_literal\",\n-        group: \"pedantic\",\n-        desc: \"using any literal non-ASCII chars in a string literal instead of using the `\\\\\\\\u` escape\",\n-        deprecation: None,\n-        module: \"unicode\",\n-    },\n-    Lint {\n-        name: \"nonminimal_bool\",\n-        group: \"complexity\",\n-        desc: \"boolean expressions that can be written more concisely\",\n-        deprecation: None,\n-        module: \"booleans\",\n-    },\n-    Lint {\n-        name: \"nonsensical_open_options\",\n-        group: \"correctness\",\n-        desc: \"nonsensical combination of options for opening a file\",\n-        deprecation: None,\n-        module: \"open_options\",\n-    },\n-    Lint {\n-        name: \"not_unsafe_ptr_arg_deref\",\n-        group: \"correctness\",\n-        desc: \"public functions dereferencing raw pointer arguments but not marked `unsafe`\",\n-        deprecation: None,\n-        module: \"functions\",\n-    },\n-    Lint {\n-        name: \"ok_expect\",\n-        group: \"style\",\n-        desc: \"using `ok().expect()`, which gives worse error messages than calling `expect` directly on the Result\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"op_ref\",\n-        group: \"style\",\n-        desc: \"taking a reference to satisfy the type constraints on `==`\",\n-        deprecation: None,\n-        module: \"eq_op\",\n-    },\n-    Lint {\n-        name: \"option_as_ref_deref\",\n-        group: \"complexity\",\n-        desc: \"using `as_ref().map(Deref::deref)`, which is more succinctly expressed as `as_deref()`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"option_env_unwrap\",\n-        group: \"correctness\",\n-        desc: \"using `option_env!(...).unwrap()` to get environment variable\",\n-        deprecation: None,\n-        module: \"option_env_unwrap\",\n-    },\n-    Lint {\n-        name: \"option_if_let_else\",\n-        group: \"pedantic\",\n-        desc: \"reimplementation of Option::map_or\",\n-        deprecation: None,\n-        module: \"option_if_let_else\",\n-    },\n-    Lint {\n-        name: \"option_map_or_none\",\n-        group: \"style\",\n-        desc: \"using `Option.map_or(None, f)`, which is more succinctly expressed as `and_then(f)`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"option_map_unit_fn\",\n-        group: \"complexity\",\n-        desc: \"using `option.map(f)`, where `f` is a function or closure that returns `()`\",\n-        deprecation: None,\n-        module: \"map_unit_fn\",\n-    },\n-    Lint {\n-        name: \"option_option\",\n-        group: \"pedantic\",\n-        desc: \"usage of `Option<Option<T>>`\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"or_fun_call\",\n-        group: \"perf\",\n-        desc: \"using any `*or` method with a function call, which suggests `*or_else`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"out_of_bounds_indexing\",\n-        group: \"correctness\",\n-        desc: \"out of bounds constant indexing\",\n-        deprecation: None,\n-        module: \"indexing_slicing\",\n-    },\n-    Lint {\n-        name: \"overflow_check_conditional\",\n-        group: \"complexity\",\n-        desc: \"overflow checks inspired by C which are likely to panic\",\n-        deprecation: None,\n-        module: \"overflow_check_conditional\",\n-    },\n-    Lint {\n-        name: \"panic\",\n-        group: \"restriction\",\n-        desc: \"usage of the `panic!` macro\",\n-        deprecation: None,\n-        module: \"panic_unimplemented\",\n-    },\n-    Lint {\n-        name: \"panic_in_result_fn\",\n-        group: \"restriction\",\n-        desc: \"functions of type `Result<..>` that contain `panic!()`, `todo!()` or `unreachable()` or `unimplemented()` \",\n-        deprecation: None,\n-        module: \"panic_in_result_fn\",\n-    },\n-    Lint {\n-        name: \"panicking_unwrap\",\n-        group: \"correctness\",\n-        desc: \"checks for calls of `unwrap[_err]()` that will always fail\",\n-        deprecation: None,\n-        module: \"unwrap\",\n-    },\n-    Lint {\n-        name: \"partialeq_ne_impl\",\n-        group: \"complexity\",\n-        desc: \"re-implementing `PartialEq::ne`\",\n-        deprecation: None,\n-        module: \"partialeq_ne_impl\",\n-    },\n-    Lint {\n-        name: \"path_buf_push_overwrite\",\n-        group: \"nursery\",\n-        desc: \"calling `push` with file system root on `PathBuf` can overwrite it\",\n-        deprecation: None,\n-        module: \"path_buf_push_overwrite\",\n-    },\n-    Lint {\n-        name: \"pattern_type_mismatch\",\n-        group: \"restriction\",\n-        desc: \"type of pattern does not match the expression type\",\n-        deprecation: None,\n-        module: \"pattern_type_mismatch\",\n-    },\n-    Lint {\n-        name: \"possible_missing_comma\",\n-        group: \"correctness\",\n-        desc: \"possible missing comma in array\",\n-        deprecation: None,\n-        module: \"formatting\",\n-    },\n-    Lint {\n-        name: \"precedence\",\n-        group: \"complexity\",\n-        desc: \"operations where precedence may be unclear\",\n-        deprecation: None,\n-        module: \"precedence\",\n-    },\n-    Lint {\n-        name: \"print_literal\",\n-        group: \"style\",\n-        desc: \"printing a literal with a format string\",\n-        deprecation: None,\n-        module: \"write\",\n-    },\n-    Lint {\n-        name: \"print_stdout\",\n-        group: \"restriction\",\n-        desc: \"printing on stdout\",\n-        deprecation: None,\n-        module: \"write\",\n-    },\n-    Lint {\n-        name: \"print_with_newline\",\n-        group: \"style\",\n-        desc: \"using `print!()` with a format string that ends in a single newline\",\n-        deprecation: None,\n-        module: \"write\",\n-    },\n-    Lint {\n-        name: \"println_empty_string\",\n-        group: \"style\",\n-        desc: \"using `println!(\\\"\\\")` with an empty string\",\n-        deprecation: None,\n-        module: \"write\",\n-    },\n-    Lint {\n-        name: \"ptr_arg\",\n-        group: \"style\",\n-        desc: \"fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively\",\n-        deprecation: None,\n-        module: \"ptr\",\n-    },\n-    Lint {\n-        name: \"ptr_eq\",\n-        group: \"style\",\n-        desc: \"use `std::ptr::eq` when comparing raw pointers\",\n-        deprecation: None,\n-        module: \"ptr_eq\",\n-    },\n-    Lint {\n-        name: \"ptr_offset_with_cast\",\n-        group: \"complexity\",\n-        desc: \"unneeded pointer offset cast\",\n-        deprecation: None,\n-        module: \"ptr_offset_with_cast\",\n-    },\n-    Lint {\n-        name: \"pub_enum_variant_names\",\n-        group: \"pedantic\",\n-        desc: \"public enums where all variants share a prefix/postfix\",\n-        deprecation: None,\n-        module: \"enum_variants\",\n-    },\n-    Lint {\n-        name: \"question_mark\",\n-        group: \"style\",\n-        desc: \"checks for expressions that could be replaced by the question mark operator\",\n-        deprecation: None,\n-        module: \"question_mark\",\n-    },\n-    Lint {\n-        name: \"range_minus_one\",\n-        group: \"pedantic\",\n-        desc: \"`x..=(y-1)` reads better as `x..y`\",\n-        deprecation: None,\n-        module: \"ranges\",\n-    },\n-    Lint {\n-        name: \"range_plus_one\",\n-        group: \"pedantic\",\n-        desc: \"`x..(y+1)` reads better as `x..=y`\",\n-        deprecation: None,\n-        module: \"ranges\",\n-    },\n-    Lint {\n-        name: \"range_zip_with_len\",\n-        group: \"complexity\",\n-        desc: \"zipping iterator with a range when `enumerate()` would do\",\n-        deprecation: None,\n-        module: \"ranges\",\n-    },\n-    Lint {\n-        name: \"rc_buffer\",\n-        group: \"restriction\",\n-        desc: \"shared ownership of a buffer type\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"redundant_allocation\",\n-        group: \"perf\",\n-        desc: \"redundant allocation\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"redundant_clone\",\n-        group: \"perf\",\n-        desc: \"`clone()` of an owned value that is going to be dropped immediately\",\n-        deprecation: None,\n-        module: \"redundant_clone\",\n-    },\n-    Lint {\n-        name: \"redundant_closure\",\n-        group: \"style\",\n-        desc: \"redundant closures, i.e., `|a| foo(a)` (which can be written as just `foo`)\",\n-        deprecation: None,\n-        module: \"eta_reduction\",\n-    },\n-    Lint {\n-        name: \"redundant_closure_call\",\n-        group: \"complexity\",\n-        desc: \"throwaway closures called in the expression they are defined\",\n-        deprecation: None,\n-        module: \"redundant_closure_call\",\n-    },\n-    Lint {\n-        name: \"redundant_closure_for_method_calls\",\n-        group: \"pedantic\",\n-        desc: \"redundant closures for method calls\",\n-        deprecation: None,\n-        module: \"eta_reduction\",\n-    },\n-    Lint {\n-        name: \"redundant_field_names\",\n-        group: \"style\",\n-        desc: \"checks for fields in struct literals where shorthands could be used\",\n-        deprecation: None,\n-        module: \"redundant_field_names\",\n-    },\n-    Lint {\n-        name: \"redundant_pattern\",\n-        group: \"style\",\n-        desc: \"using `name @ _` in a pattern\",\n-        deprecation: None,\n-        module: \"misc_early\",\n-    },\n-    Lint {\n-        name: \"redundant_pattern_matching\",\n-        group: \"style\",\n-        desc: \"use the proper utility function avoiding an `if let`\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"redundant_pub_crate\",\n-        group: \"nursery\",\n-        desc: \"Using `pub(crate)` visibility on items that are not crate visible due to the visibility of the module that contains them.\",\n-        deprecation: None,\n-        module: \"redundant_pub_crate\",\n-    },\n-    Lint {\n-        name: \"redundant_static_lifetimes\",\n-        group: \"style\",\n-        desc: \"Using explicit `\\'static` lifetime for constants or statics when elision rules would allow omitting them.\",\n-        deprecation: None,\n-        module: \"redundant_static_lifetimes\",\n-    },\n-    Lint {\n-        name: \"ref_in_deref\",\n-        group: \"complexity\",\n-        desc: \"Use of reference in auto dereference expression.\",\n-        deprecation: None,\n-        module: \"reference\",\n-    },\n-    Lint {\n-        name: \"ref_option_ref\",\n-        group: \"pedantic\",\n-        desc: \"use `Option<&T>` instead of `&Option<&T>`\",\n-        deprecation: None,\n-        module: \"ref_option_ref\",\n-    },\n-    Lint {\n-        name: \"repeat_once\",\n-        group: \"complexity\",\n-        desc: \"using `.repeat(1)` instead of `String.clone()`, `str.to_string()` or `slice.to_vec()` \",\n-        deprecation: None,\n-        module: \"repeat_once\",\n-    },\n-    Lint {\n-        name: \"rest_pat_in_fully_bound_structs\",\n-        group: \"restriction\",\n-        desc: \"a match on a struct that binds all fields but still uses the wildcard pattern\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"result_map_or_into_option\",\n-        group: \"style\",\n-        desc: \"using `Result.map_or(None, Some)`, which is more succinctly expressed as `ok()`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"result_map_unit_fn\",\n-        group: \"complexity\",\n-        desc: \"using `result.map(f)`, where `f` is a function or closure that returns `()`\",\n-        deprecation: None,\n-        module: \"map_unit_fn\",\n-    },\n-    Lint {\n-        name: \"result_unit_err\",\n-        group: \"style\",\n-        desc: \"public function returning `Result` with an `Err` type of `()`\",\n-        deprecation: None,\n-        module: \"functions\",\n-    },\n-    Lint {\n-        name: \"reversed_empty_ranges\",\n-        group: \"correctness\",\n-        desc: \"reversing the limits of range expressions, resulting in empty ranges\",\n-        deprecation: None,\n-        module: \"ranges\",\n-    },\n-    Lint {\n-        name: \"same_functions_in_if_condition\",\n-        group: \"pedantic\",\n-        desc: \"consecutive `if`s with the same function call\",\n-        deprecation: None,\n-        module: \"copies\",\n-    },\n-    Lint {\n-        name: \"same_item_push\",\n-        group: \"style\",\n-        desc: \"the same item is pushed inside of a for loop\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"search_is_some\",\n-        group: \"complexity\",\n-        desc: \"using an iterator or string search followed by `is_some()`, which is more succinctly expressed as a call to `any()` or `contains()`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"self_assignment\",\n-        group: \"correctness\",\n-        desc: \"explicit self-assignment\",\n-        deprecation: None,\n-        module: \"self_assignment\",\n-    },\n-    Lint {\n-        name: \"serde_api_misuse\",\n-        group: \"correctness\",\n-        desc: \"various things that will negatively affect your serde experience\",\n-        deprecation: None,\n-        module: \"serde_api\",\n-    },\n-    Lint {\n-        name: \"shadow_reuse\",\n-        group: \"restriction\",\n-        desc: \"rebinding a name to an expression that re-uses the original value, e.g., `let x = x + 1`\",\n-        deprecation: None,\n-        module: \"shadow\",\n-    },\n-    Lint {\n-        name: \"shadow_same\",\n-        group: \"restriction\",\n-        desc: \"rebinding a name to itself, e.g., `let mut x = &mut x`\",\n-        deprecation: None,\n-        module: \"shadow\",\n-    },\n-    Lint {\n-        name: \"shadow_unrelated\",\n-        group: \"pedantic\",\n-        desc: \"rebinding a name without even using the original value\",\n-        deprecation: None,\n-        module: \"shadow\",\n-    },\n-    Lint {\n-        name: \"short_circuit_statement\",\n-        group: \"complexity\",\n-        desc: \"using a short circuit boolean condition as a statement\",\n-        deprecation: None,\n-        module: \"misc\",\n-    },\n-    Lint {\n-        name: \"should_implement_trait\",\n-        group: \"style\",\n-        desc: \"defining a method that should be implementing a std trait\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"similar_names\",\n-        group: \"pedantic\",\n-        desc: \"similarly named items and bindings\",\n-        deprecation: None,\n-        module: \"non_expressive_names\",\n-    },\n-    Lint {\n-        name: \"single_char_add_str\",\n-        group: \"style\",\n-        desc: \"`push_str()` or `insert_str()` used with a single-character string literal as parameter\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"single_char_pattern\",\n-        group: \"perf\",\n-        desc: \"using a single-character str where a char could be used, e.g., `_.split(\\\"x\\\")`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"single_component_path_imports\",\n-        group: \"style\",\n-        desc: \"imports with single component path are redundant\",\n-        deprecation: None,\n-        module: \"single_component_path_imports\",\n-    },\n-    Lint {\n-        name: \"single_element_loop\",\n-        group: \"complexity\",\n-        desc: \"there is no reason to have a single element loop\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"single_match\",\n-        group: \"style\",\n-        desc: \"a `match` statement with a single nontrivial arm (i.e., where the other arm is `_ => {}`) instead of `if let`\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"single_match_else\",\n-        group: \"pedantic\",\n-        desc: \"a `match` statement with two arms where the second arm\\'s pattern is a placeholder instead of a specific match pattern\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"skip_while_next\",\n-        group: \"complexity\",\n-        desc: \"using `skip_while(p).next()`, which is more succinctly expressed as `.find(!p)`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"slow_vector_initialization\",\n-        group: \"perf\",\n-        desc: \"slow vector initialization\",\n-        deprecation: None,\n-        module: \"slow_vector_initialization\",\n-    },\n-    Lint {\n-        name: \"stable_sort_primitive\",\n-        group: \"perf\",\n-        desc: \"use of sort() when sort_unstable() is equivalent\",\n-        deprecation: None,\n-        module: \"stable_sort_primitive\",\n-    },\n-    Lint {\n-        name: \"str_to_string\",\n-        group: \"restriction\",\n-        desc: \"using `to_string()` on a `&str`, which should be `to_owned()`\",\n-        deprecation: None,\n-        module: \"strings\",\n-    },\n-    Lint {\n-        name: \"string_add\",\n-        group: \"restriction\",\n-        desc: \"using `x + ..` where x is a `String` instead of `push_str()`\",\n-        deprecation: None,\n-        module: \"strings\",\n-    },\n-    Lint {\n-        name: \"string_add_assign\",\n-        group: \"pedantic\",\n-        desc: \"using `x = x + ..` where x is a `String` instead of `push_str()`\",\n-        deprecation: None,\n-        module: \"strings\",\n-    },\n-    Lint {\n-        name: \"string_extend_chars\",\n-        group: \"style\",\n-        desc: \"using `x.extend(s.chars())` where s is a `&str` or `String`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"string_from_utf8_as_bytes\",\n-        group: \"complexity\",\n-        desc: \"casting string slices to byte slices and back\",\n-        deprecation: None,\n-        module: \"strings\",\n-    },\n-    Lint {\n-        name: \"string_lit_as_bytes\",\n-        group: \"nursery\",\n-        desc: \"calling `as_bytes` on a string literal instead of using a byte string literal\",\n-        deprecation: None,\n-        module: \"strings\",\n-    },\n-    Lint {\n-        name: \"string_to_string\",\n-        group: \"restriction\",\n-        desc: \"using `to_string()` on a `String`, which should be `clone()`\",\n-        deprecation: None,\n-        module: \"strings\",\n-    },\n-    Lint {\n-        name: \"struct_excessive_bools\",\n-        group: \"pedantic\",\n-        desc: \"using too many bools in a struct\",\n-        deprecation: None,\n-        module: \"excessive_bools\",\n-    },\n-    Lint {\n-        name: \"suboptimal_flops\",\n-        group: \"nursery\",\n-        desc: \"usage of sub-optimal floating point operations\",\n-        deprecation: None,\n-        module: \"floating_point_arithmetic\",\n-    },\n-    Lint {\n-        name: \"suspicious_arithmetic_impl\",\n-        group: \"correctness\",\n-        desc: \"suspicious use of operators in impl of arithmetic trait\",\n-        deprecation: None,\n-        module: \"suspicious_trait_impl\",\n-    },\n-    Lint {\n-        name: \"suspicious_assignment_formatting\",\n-        group: \"style\",\n-        desc: \"suspicious formatting of `*=`, `-=` or `!=`\",\n-        deprecation: None,\n-        module: \"formatting\",\n-    },\n-    Lint {\n-        name: \"suspicious_else_formatting\",\n-        group: \"style\",\n-        desc: \"suspicious formatting of `else`\",\n-        deprecation: None,\n-        module: \"formatting\",\n-    },\n-    Lint {\n-        name: \"suspicious_map\",\n-        group: \"complexity\",\n-        desc: \"suspicious usage of map\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"suspicious_op_assign_impl\",\n-        group: \"correctness\",\n-        desc: \"suspicious use of operators in impl of OpAssign trait\",\n-        deprecation: None,\n-        module: \"suspicious_trait_impl\",\n-    },\n-    Lint {\n-        name: \"suspicious_unary_op_formatting\",\n-        group: \"style\",\n-        desc: \"suspicious formatting of unary `-` or `!` on the RHS of a BinOp\",\n-        deprecation: None,\n-        module: \"formatting\",\n-    },\n-    Lint {\n-        name: \"tabs_in_doc_comments\",\n-        group: \"style\",\n-        desc: \"using tabs in doc comments is not recommended\",\n-        deprecation: None,\n-        module: \"tabs_in_doc_comments\",\n-    },\n-    Lint {\n-        name: \"temporary_assignment\",\n-        group: \"complexity\",\n-        desc: \"assignments to temporaries\",\n-        deprecation: None,\n-        module: \"temporary_assignment\",\n-    },\n-    Lint {\n-        name: \"to_digit_is_some\",\n-        group: \"style\",\n-        desc: \"`char.is_digit()` is clearer\",\n-        deprecation: None,\n-        module: \"to_digit_is_some\",\n-    },\n-    Lint {\n-        name: \"to_string_in_display\",\n-        group: \"correctness\",\n-        desc: \"`to_string` method used while implementing `Display` trait\",\n-        deprecation: None,\n-        module: \"to_string_in_display\",\n-    },\n-    Lint {\n-        name: \"todo\",\n-        group: \"restriction\",\n-        desc: \"`todo!` should not be present in production code\",\n-        deprecation: None,\n-        module: \"panic_unimplemented\",\n-    },\n-    Lint {\n-        name: \"too_many_arguments\",\n-        group: \"complexity\",\n-        desc: \"functions with too many arguments\",\n-        deprecation: None,\n-        module: \"functions\",\n-    },\n-    Lint {\n-        name: \"too_many_lines\",\n-        group: \"pedantic\",\n-        desc: \"functions with too many lines\",\n-        deprecation: None,\n-        module: \"functions\",\n-    },\n-    Lint {\n-        name: \"toplevel_ref_arg\",\n-        group: \"style\",\n-        desc: \"an entire binding declared as `ref`, in a function argument or a `let` statement\",\n-        deprecation: None,\n-        module: \"misc\",\n-    },\n-    Lint {\n-        name: \"trait_duplication_in_bounds\",\n-        group: \"pedantic\",\n-        desc: \"Check if the same trait bounds are specified twice during a function declaration\",\n-        deprecation: None,\n-        module: \"trait_bounds\",\n-    },\n-    Lint {\n-        name: \"transmute_bytes_to_str\",\n-        group: \"complexity\",\n-        desc: \"transmutes from a `&[u8]` to a `&str`\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"transmute_float_to_int\",\n-        group: \"complexity\",\n-        desc: \"transmutes from a float to an integer\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"transmute_int_to_bool\",\n-        group: \"complexity\",\n-        desc: \"transmutes from an integer to a `bool`\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"transmute_int_to_char\",\n-        group: \"complexity\",\n-        desc: \"transmutes from an integer to a `char`\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"transmute_int_to_float\",\n-        group: \"complexity\",\n-        desc: \"transmutes from an integer to a float\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"transmute_ptr_to_ptr\",\n-        group: \"complexity\",\n-        desc: \"transmutes from a pointer to a pointer / a reference to a reference\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"transmute_ptr_to_ref\",\n-        group: \"complexity\",\n-        desc: \"transmutes from a pointer to a reference type\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"transmutes_expressible_as_ptr_casts\",\n-        group: \"complexity\",\n-        desc: \"transmutes that could be a pointer cast\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"transmuting_null\",\n-        group: \"correctness\",\n-        desc: \"transmutes from a null pointer to a reference, which is undefined behavior\",\n-        deprecation: None,\n-        module: \"transmuting_null\",\n-    },\n-    Lint {\n-        name: \"trivial_regex\",\n-        group: \"style\",\n-        desc: \"trivial regular expressions\",\n-        deprecation: None,\n-        module: \"regex\",\n-    },\n-    Lint {\n-        name: \"trivially_copy_pass_by_ref\",\n-        group: \"pedantic\",\n-        desc: \"functions taking small copyable arguments by reference\",\n-        deprecation: None,\n-        module: \"pass_by_ref_or_value\",\n-    },\n-    Lint {\n-        name: \"try_err\",\n-        group: \"style\",\n-        desc: \"return errors explicitly rather than hiding them behind a `?`\",\n-        deprecation: None,\n-        module: \"try_err\",\n-    },\n-    Lint {\n-        name: \"type_complexity\",\n-        group: \"complexity\",\n-        desc: \"usage of very complex types that might be better factored into `type` definitions\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"type_repetition_in_bounds\",\n-        group: \"pedantic\",\n-        desc: \"Types are repeated unnecessary in trait bounds use `+` instead of using `T: _, T: _`\",\n-        deprecation: None,\n-        module: \"trait_bounds\",\n-    },\n-    Lint {\n-        name: \"undropped_manually_drops\",\n-        group: \"correctness\",\n-        desc: \"use of safe `std::mem::drop` function to drop a std::mem::ManuallyDrop, which will not drop the inner value\",\n-        deprecation: None,\n-        module: \"undropped_manually_drops\",\n-    },\n-    Lint {\n-        name: \"unicode_not_nfc\",\n-        group: \"pedantic\",\n-        desc: \"using a Unicode literal not in NFC normal form (see [Unicode tr15](http://www.unicode.org/reports/tr15/) for further information)\",\n-        deprecation: None,\n-        module: \"unicode\",\n-    },\n-    Lint {\n-        name: \"unimplemented\",\n-        group: \"restriction\",\n-        desc: \"`unimplemented!` should not be present in production code\",\n-        deprecation: None,\n-        module: \"panic_unimplemented\",\n-    },\n-    Lint {\n-        name: \"uninit_assumed_init\",\n-        group: \"correctness\",\n-        desc: \"`MaybeUninit::uninit().assume_init()`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"unit_arg\",\n-        group: \"complexity\",\n-        desc: \"passing unit to a function\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"unit_cmp\",\n-        group: \"correctness\",\n-        desc: \"comparing unit values\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"unit_return_expecting_ord\",\n-        group: \"correctness\",\n-        desc: \"fn arguments of type Fn(...) -> Ord returning the unit type ().\",\n-        deprecation: None,\n-        module: \"unit_return_expecting_ord\",\n-    },\n-    Lint {\n-        name: \"unknown_clippy_lints\",\n-        group: \"style\",\n-        desc: \"unknown_lints for scoped Clippy lints\",\n-        deprecation: None,\n-        module: \"attrs\",\n-    },\n-    Lint {\n-        name: \"unnecessary_cast\",\n-        group: \"complexity\",\n-        desc: \"cast to the same type, e.g., `x as i32` where `x: i32`\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"unnecessary_filter_map\",\n-        group: \"complexity\",\n-        desc: \"using `filter_map` when a more succinct alternative exists\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"unnecessary_fold\",\n-        group: \"style\",\n-        desc: \"using `fold` when a more succinct alternative exists\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"unnecessary_lazy_evaluations\",\n-        group: \"style\",\n-        desc: \"using unnecessary lazy evaluation, which can be replaced with simpler eager evaluation\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"unnecessary_mut_passed\",\n-        group: \"style\",\n-        desc: \"an argument passed as a mutable reference although the callee only demands an immutable reference\",\n-        deprecation: None,\n-        module: \"mut_reference\",\n-    },\n-    Lint {\n-        name: \"unnecessary_operation\",\n-        group: \"complexity\",\n-        desc: \"outer expressions with no effect\",\n-        deprecation: None,\n-        module: \"no_effect\",\n-    },\n-    Lint {\n-        name: \"unnecessary_sort_by\",\n-        group: \"complexity\",\n-        desc: \"Use of `Vec::sort_by` when `Vec::sort_by_key` or `Vec::sort` would be clearer\",\n-        deprecation: None,\n-        module: \"unnecessary_sort_by\",\n-    },\n-    Lint {\n-        name: \"unnecessary_unwrap\",\n-        group: \"complexity\",\n-        desc: \"checks for calls of `unwrap[_err]()` that cannot fail\",\n-        deprecation: None,\n-        module: \"unwrap\",\n-    },\n-    Lint {\n-        name: \"unnecessary_wraps\",\n-        group: \"complexity\",\n-        desc: \"functions that only return `Ok` or `Some`\",\n-        deprecation: None,\n-        module: \"unnecessary_wraps\",\n-    },\n-    Lint {\n-        name: \"unneeded_field_pattern\",\n-        group: \"restriction\",\n-        desc: \"struct fields bound to a wildcard instead of using `..`\",\n-        deprecation: None,\n-        module: \"misc_early\",\n-    },\n-    Lint {\n-        name: \"unneeded_wildcard_pattern\",\n-        group: \"complexity\",\n-        desc: \"tuple patterns with a wildcard pattern (`_`) is next to a rest pattern (`..`)\",\n-        deprecation: None,\n-        module: \"misc_early\",\n-    },\n-    Lint {\n-        name: \"unnested_or_patterns\",\n-        group: \"pedantic\",\n-        desc: \"unnested or-patterns, e.g., `Foo(Bar) | Foo(Baz) instead of `Foo(Bar | Baz)`\",\n-        deprecation: None,\n-        module: \"unnested_or_patterns\",\n-    },\n-    Lint {\n-        name: \"unreachable\",\n-        group: \"restriction\",\n-        desc: \"`unreachable!` should not be present in production code\",\n-        deprecation: None,\n-        module: \"panic_unimplemented\",\n-    },\n-    Lint {\n-        name: \"unreadable_literal\",\n-        group: \"pedantic\",\n-        desc: \"long integer literal without underscores\",\n-        deprecation: None,\n-        module: \"literal_representation\",\n-    },\n-    Lint {\n-        name: \"unsafe_derive_deserialize\",\n-        group: \"pedantic\",\n-        desc: \"deriving `serde::Deserialize` on a type that has methods using `unsafe`\",\n-        deprecation: None,\n-        module: \"derive\",\n-    },\n-    Lint {\n-        name: \"unsafe_removed_from_name\",\n-        group: \"style\",\n-        desc: \"`unsafe` removed from API names on import\",\n-        deprecation: None,\n-        module: \"unsafe_removed_from_name\",\n-    },\n-    Lint {\n-        name: \"unseparated_literal_suffix\",\n-        group: \"pedantic\",\n-        desc: \"literals whose suffix is not separated by an underscore\",\n-        deprecation: None,\n-        module: \"misc_early\",\n-    },\n-    Lint {\n-        name: \"unsound_collection_transmute\",\n-        group: \"correctness\",\n-        desc: \"transmute between collections of layout-incompatible types\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"unused_io_amount\",\n-        group: \"correctness\",\n-        desc: \"unused written/read amount\",\n-        deprecation: None,\n-        module: \"unused_io_amount\",\n-    },\n-    Lint {\n-        name: \"unused_self\",\n-        group: \"pedantic\",\n-        desc: \"methods that contain a `self` argument but don\\'t use it\",\n-        deprecation: None,\n-        module: \"unused_self\",\n-    },\n-    Lint {\n-        name: \"unused_unit\",\n-        group: \"style\",\n-        desc: \"needless unit expression\",\n-        deprecation: None,\n-        module: \"unused_unit\",\n-    },\n-    Lint {\n-        name: \"unusual_byte_groupings\",\n-        group: \"style\",\n-        desc: \"binary or hex literals that aren\\'t grouped by four\",\n-        deprecation: None,\n-        module: \"literal_representation\",\n-    },\n-    Lint {\n-        name: \"unwrap_in_result\",\n-        group: \"restriction\",\n-        desc: \"functions of type `Result<..>` or `Option`<...> that contain `expect()` or `unwrap()`\",\n-        deprecation: None,\n-        module: \"unwrap_in_result\",\n-    },\n-    Lint {\n-        name: \"unwrap_used\",\n-        group: \"restriction\",\n-        desc: \"using `.unwrap()` on `Result` or `Option`, which should at least get a better message using `expect()`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"use_debug\",\n-        group: \"restriction\",\n-        desc: \"use of `Debug`-based formatting\",\n-        deprecation: None,\n-        module: \"write\",\n-    },\n-    Lint {\n-        name: \"use_self\",\n-        group: \"nursery\",\n-        desc: \"unnecessary structure name repetition whereas `Self` is applicable\",\n-        deprecation: None,\n-        module: \"use_self\",\n-    },\n-    Lint {\n-        name: \"used_underscore_binding\",\n-        group: \"pedantic\",\n-        desc: \"using a binding which is prefixed with an underscore\",\n-        deprecation: None,\n-        module: \"misc\",\n-    },\n-    Lint {\n-        name: \"useless_asref\",\n-        group: \"complexity\",\n-        desc: \"using `as_ref` where the types before and after the call are the same\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"useless_attribute\",\n-        group: \"correctness\",\n-        desc: \"use of lint attributes on `extern crate` items\",\n-        deprecation: None,\n-        module: \"attrs\",\n-    },\n-    Lint {\n-        name: \"useless_conversion\",\n-        group: \"complexity\",\n-        desc: \"calls to `Into`, `TryInto`, `From`, `TryFrom`, or `IntoIter` which perform useless conversions to the same type\",\n-        deprecation: None,\n-        module: \"useless_conversion\",\n-    },\n-    Lint {\n-        name: \"useless_format\",\n-        group: \"complexity\",\n-        desc: \"useless use of `format!`\",\n-        deprecation: None,\n-        module: \"format\",\n-    },\n-    Lint {\n-        name: \"useless_let_if_seq\",\n-        group: \"nursery\",\n-        desc: \"unidiomatic `let mut` declaration followed by initialization in `if`\",\n-        deprecation: None,\n-        module: \"let_if_seq\",\n-    },\n-    Lint {\n-        name: \"useless_transmute\",\n-        group: \"nursery\",\n-        desc: \"transmutes that have the same to and from types or could be a cast/coercion\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"useless_vec\",\n-        group: \"perf\",\n-        desc: \"useless `vec!`\",\n-        deprecation: None,\n-        module: \"vec\",\n-    },\n-    Lint {\n-        name: \"vec_box\",\n-        group: \"complexity\",\n-        desc: \"usage of `Vec<Box<T>>` where T: Sized, vector elements are already on the heap\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"vec_resize_to_zero\",\n-        group: \"correctness\",\n-        desc: \"emptying a vector with `resize(0, an_int)` instead of `clear()` is probably an argument inversion mistake\",\n-        deprecation: None,\n-        module: \"vec_resize_to_zero\",\n-    },\n-    Lint {\n-        name: \"verbose_bit_mask\",\n-        group: \"pedantic\",\n-        desc: \"expressions where a bit mask is less readable than the corresponding method call\",\n-        deprecation: None,\n-        module: \"bit_mask\",\n-    },\n-    Lint {\n-        name: \"verbose_file_reads\",\n-        group: \"restriction\",\n-        desc: \"use of `File::read_to_end` or `File::read_to_string`\",\n-        deprecation: None,\n-        module: \"verbose_file_reads\",\n-    },\n-    Lint {\n-        name: \"vtable_address_comparisons\",\n-        group: \"correctness\",\n-        desc: \"comparison with an address of a trait vtable\",\n-        deprecation: None,\n-        module: \"unnamed_address\",\n-    },\n-    Lint {\n-        name: \"while_immutable_condition\",\n-        group: \"correctness\",\n-        desc: \"variables used within while expression are not mutated in the body\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"while_let_loop\",\n-        group: \"complexity\",\n-        desc: \"`loop { if let { ... } else break }`, which can be written as a `while let` loop\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"while_let_on_iterator\",\n-        group: \"style\",\n-        desc: \"using a while-let loop instead of a for loop on an iterator\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"wildcard_dependencies\",\n-        group: \"cargo\",\n-        desc: \"wildcard dependencies being used\",\n-        deprecation: None,\n-        module: \"wildcard_dependencies\",\n-    },\n-    Lint {\n-        name: \"wildcard_enum_match_arm\",\n-        group: \"restriction\",\n-        desc: \"a wildcard enum match arm using `_`\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"wildcard_imports\",\n-        group: \"pedantic\",\n-        desc: \"lint `use _::*` statements\",\n-        deprecation: None,\n-        module: \"wildcard_imports\",\n-    },\n-    Lint {\n-        name: \"wildcard_in_or_patterns\",\n-        group: \"complexity\",\n-        desc: \"a wildcard pattern used with others patterns in same match arm\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"write_literal\",\n-        group: \"style\",\n-        desc: \"writing a literal with a format string\",\n-        deprecation: None,\n-        module: \"write\",\n-    },\n-    Lint {\n-        name: \"write_with_newline\",\n-        group: \"style\",\n-        desc: \"using `write!()` with a format string that ends in a single newline\",\n-        deprecation: None,\n-        module: \"write\",\n-    },\n-    Lint {\n-        name: \"writeln_empty_string\",\n-        group: \"style\",\n-        desc: \"using `writeln!(buf, \\\"\\\")` with an empty string\",\n-        deprecation: None,\n-        module: \"write\",\n-    },\n-    Lint {\n-        name: \"wrong_pub_self_convention\",\n-        group: \"restriction\",\n-        desc: \"defining a public method named with an established prefix (like \\\"into_\\\") that takes `self` with the wrong convention\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"wrong_self_convention\",\n-        group: \"style\",\n-        desc: \"defining a method named with an established prefix (like \\\"into_\\\") that takes `self` with the wrong convention\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"wrong_transmute\",\n-        group: \"correctness\",\n-        desc: \"transmutes that are confusing at best, undefined behaviour at worst and always useless\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"zero_divided_by_zero\",\n-        group: \"complexity\",\n-        desc: \"usage of `0.0 / 0.0` to obtain NaN instead of `f32::NAN` or `f64::NAN`\",\n-        deprecation: None,\n-        module: \"zero_div_zero\",\n-    },\n-    Lint {\n-        name: \"zero_prefixed_literal\",\n-        group: \"complexity\",\n-        desc: \"integer literals starting with `0`\",\n-        deprecation: None,\n-        module: \"misc_early\",\n-    },\n-    Lint {\n-        name: \"zero_ptr\",\n-        group: \"style\",\n-        desc: \"using `0 as *{const, mut} T`\",\n-        deprecation: None,\n-        module: \"misc\",\n-    },\n-    Lint {\n-        name: \"zst_offset\",\n-        group: \"correctness\",\n-        desc: \"Check for offset calculations on raw pointers to zero-sized types\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-]\n-// end lint list, do not remove this comment, it\u2019s used in `update_lints`\n-});"}, {"sha": "ea06743394d1075ba270830ba5e49b0c783cc3bf", "filename": "src/main.rs", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/src%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/src%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -62,7 +62,7 @@ struct ClippyCmd {\n     unstable_options: bool,\n     cargo_subcommand: &'static str,\n     args: Vec<String>,\n-    clippy_args: String,\n+    clippy_args: Vec<String>,\n }\n \n impl ClippyCmd {\n@@ -99,7 +99,10 @@ impl ClippyCmd {\n             args.insert(0, \"+nightly\".to_string());\n         }\n \n-        let clippy_args: String = old_args.map(|arg| format!(\"{}__CLIPPY_HACKERY__\", arg)).collect();\n+        let mut clippy_args: Vec<String> = old_args.collect();\n+        if cargo_subcommand == \"fix\" && !clippy_args.iter().any(|arg| arg == \"--no-deps\") {\n+            clippy_args.push(\"--no-deps\".into());\n+        }\n \n         ClippyCmd {\n             unstable_options,\n@@ -147,10 +150,15 @@ impl ClippyCmd {\n \n     fn into_std_cmd(self) -> Command {\n         let mut cmd = Command::new(\"cargo\");\n+        let clippy_args: String = self\n+            .clippy_args\n+            .iter()\n+            .map(|arg| format!(\"{}__CLIPPY_HACKERY__\", arg))\n+            .collect();\n \n         cmd.env(self.path_env(), Self::path())\n             .envs(ClippyCmd::target_dir())\n-            .env(\"CLIPPY_ARGS\", self.clippy_args)\n+            .env(\"CLIPPY_ARGS\", clippy_args)\n             .arg(self.cargo_subcommand)\n             .args(&self.args);\n \n@@ -201,6 +209,24 @@ mod tests {\n         assert!(cmd.args.iter().any(|arg| arg.ends_with(\"unstable-options\")));\n     }\n \n+    #[test]\n+    fn fix_implies_no_deps() {\n+        let args = \"cargo clippy --fix -Zunstable-options\"\n+            .split_whitespace()\n+            .map(ToString::to_string);\n+        let cmd = ClippyCmd::new(args);\n+        assert!(cmd.clippy_args.iter().any(|arg| arg == \"--no-deps\"));\n+    }\n+\n+    #[test]\n+    fn no_deps_not_duplicated_with_fix() {\n+        let args = \"cargo clippy --fix -Zunstable-options -- --no-deps\"\n+            .split_whitespace()\n+            .map(ToString::to_string);\n+        let cmd = ClippyCmd::new(args);\n+        assert_eq!(cmd.clippy_args.iter().filter(|arg| *arg == \"--no-deps\").count(), 1);\n+    }\n+\n     #[test]\n     fn check() {\n         let args = \"cargo clippy\".split_whitespace().map(ToString::to_string);"}, {"sha": "94f5e616cace8cb0fbe8ea83e9ef6911809db16b", "filename": "tests/compile-test.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -12,6 +12,9 @@ use std::path::{Path, PathBuf};\n \n mod cargo;\n \n+// whether to run internal tests or not\n+const RUN_INTERNAL_TESTS: bool = cfg!(feature = \"internal-lints\");\n+\n fn host_lib() -> PathBuf {\n     option_env!(\"HOST_LIBS\").map_or(cargo::CARGO_TARGET_DIR.join(env!(\"PROFILE\")), PathBuf::from)\n }\n@@ -41,7 +44,9 @@ fn third_party_crates() -> String {\n         };\n         if let Some(name) = path.file_name().and_then(OsStr::to_str) {\n             for dep in CRATES {\n-                if name.starts_with(&format!(\"lib{}-\", dep)) && name.ends_with(\".rlib\") {\n+                if name.starts_with(&format!(\"lib{}-\", dep))\n+                    && name.rsplit('.').next().map(|ext| ext.eq_ignore_ascii_case(\"rlib\")) == Some(true)\n+                {\n                     if let Some(old) = crates.insert(dep, path.clone()) {\n                         panic!(\"Found multiple rlibs for crate `{}`: `{:?}` and `{:?}\", dep, old, path);\n                     }\n@@ -96,6 +101,16 @@ fn run_mode(cfg: &mut compiletest::Config) {\n     compiletest::run_tests(&cfg);\n }\n \n+fn run_internal_tests(cfg: &mut compiletest::Config) {\n+    // only run internal tests with the internal-tests feature\n+    if !RUN_INTERNAL_TESTS {\n+        return;\n+    }\n+    cfg.mode = TestMode::Ui;\n+    cfg.src_base = Path::new(\"tests\").join(\"ui-internal\");\n+    compiletest::run_tests(&cfg);\n+}\n+\n fn run_ui_toml(config: &mut compiletest::Config) {\n     fn run_tests(config: &compiletest::Config, mut tests: Vec<tester::TestDescAndFn>) -> Result<bool, io::Error> {\n         let mut result = true;\n@@ -199,7 +214,6 @@ fn run_ui_cargo(config: &mut compiletest::Config) {\n                         Some(\"main.rs\") => {},\n                         _ => continue,\n                     }\n-\n                     let paths = compiletest::common::TestPaths {\n                         file: file_path,\n                         base: config.src_base.clone(),\n@@ -242,7 +256,7 @@ fn run_ui_cargo(config: &mut compiletest::Config) {\n \n fn prepare_env() {\n     set_var(\"CLIPPY_DISABLE_DOCS_LINKS\", \"true\");\n-    set_var(\"CLIPPY_TESTS\", \"true\");\n+    set_var(\"__CLIPPY_INTERNAL_TESTS\", \"true\");\n     //set_var(\"RUST_BACKTRACE\", \"0\");\n }\n \n@@ -253,4 +267,5 @@ fn compile_test() {\n     run_mode(&mut config);\n     run_ui_toml(&mut config);\n     run_ui_cargo(&mut config);\n+    run_internal_tests(&mut config);\n }"}, {"sha": "052223d6d6ff7f4156f17b0562a4d72335a875cb", "filename": "tests/dogfood.rs", "status": "modified", "additions": 81, "deletions": 6, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdogfood.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -3,7 +3,7 @@\n #![feature(once_cell)]\n \n use std::lazy::SyncLazy;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use std::process::Command;\n \n mod cargo;\n@@ -18,7 +18,8 @@ fn dogfood_clippy() {\n     }\n     let root_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n \n-    let output = Command::new(&*CLIPPY_PATH)\n+    let mut command = Command::new(&*CLIPPY_PATH);\n+    command\n         .current_dir(root_dir)\n         .env(\"CLIPPY_DOGFOOD\", \"1\")\n         .env(\"CARGO_INCREMENTAL\", \"0\")\n@@ -27,11 +28,16 @@ fn dogfood_clippy() {\n         .arg(\"--all-features\")\n         .arg(\"--\")\n         .args(&[\"-D\", \"clippy::all\"])\n-        .args(&[\"-D\", \"clippy::internal\"])\n         .args(&[\"-D\", \"clippy::pedantic\"])\n-        .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n-        .output()\n-        .unwrap();\n+        .arg(\"-Cdebuginfo=0\"); // disable debuginfo to generate less data in the target dir\n+\n+    // internal lints only exist if we build with the internal-lints feature\n+    if cfg!(feature = \"internal-lints\") {\n+        command.args(&[\"-D\", \"clippy::internal\"]);\n+    }\n+\n+    let output = command.output().unwrap();\n+\n     println!(\"status: {}\", output.status);\n     println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n     println!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n@@ -41,12 +47,77 @@ fn dogfood_clippy() {\n \n #[test]\n fn dogfood_subprojects() {\n+    fn test_no_deps_ignores_path_deps_in_workspaces() {\n+        fn clean(cwd: &Path, target_dir: &Path) {\n+            Command::new(\"cargo\")\n+                .current_dir(cwd)\n+                .env(\"CARGO_TARGET_DIR\", target_dir)\n+                .arg(\"clean\")\n+                .args(&[\"-p\", \"subcrate\"])\n+                .args(&[\"-p\", \"path_dep\"])\n+                .output()\n+                .unwrap();\n+        }\n+\n+        if cargo::is_rustc_test_suite() {\n+            return;\n+        }\n+        let root = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n+        let target_dir = root.join(\"target\").join(\"dogfood\");\n+        let cwd = root.join(\"clippy_workspace_tests\");\n+\n+        // Make sure we start with a clean state\n+        clean(&cwd, &target_dir);\n+\n+        // `path_dep` is a path dependency of `subcrate` that would trigger a denied lint.\n+        // Make sure that with the `--no-deps` argument Clippy does not run on `path_dep`.\n+        let output = Command::new(&*CLIPPY_PATH)\n+            .current_dir(&cwd)\n+            .env(\"CLIPPY_DOGFOOD\", \"1\")\n+            .env(\"CARGO_INCREMENTAL\", \"0\")\n+            .arg(\"clippy\")\n+            .args(&[\"-p\", \"subcrate\"])\n+            .arg(\"--\")\n+            .arg(\"--no-deps\")\n+            .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n+            .args(&[\"--cfg\", r#\"feature=\"primary_package_test\"\"#])\n+            .output()\n+            .unwrap();\n+        println!(\"status: {}\", output.status);\n+        println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n+        println!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n+\n+        assert!(output.status.success());\n+\n+        // Make sure we start with a clean state\n+        clean(&cwd, &target_dir);\n+\n+        // Test that without the `--no-deps` argument, `path_dep` is linted.\n+        let output = Command::new(&*CLIPPY_PATH)\n+            .current_dir(&cwd)\n+            .env(\"CLIPPY_DOGFOOD\", \"1\")\n+            .env(\"CARGO_INCREMENTAL\", \"0\")\n+            .arg(\"clippy\")\n+            .args(&[\"-p\", \"subcrate\"])\n+            .arg(\"--\")\n+            .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n+            .args(&[\"--cfg\", r#\"feature=\"primary_package_test\"\"#])\n+            .output()\n+            .unwrap();\n+        println!(\"status: {}\", output.status);\n+        println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n+        println!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n+\n+        assert!(!output.status.success());\n+    }\n+\n     // run clippy on remaining subprojects and fail the test if lint warnings are reported\n     if cargo::is_rustc_test_suite() {\n         return;\n     }\n     let root_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n \n+    // NOTE: `path_dep` crate is omitted on purpose here\n     for d in &[\n         \"clippy_workspace_tests\",\n         \"clippy_workspace_tests/src\",\n@@ -72,4 +143,8 @@ fn dogfood_subprojects() {\n \n         assert!(output.status.success());\n     }\n+\n+    // NOTE: Since tests run in parallel we can't run cargo commands on the same workspace at the\n+    // same time, so we test this immediately after the dogfood for workspaces.\n+    test_no_deps_ignores_path_deps_in_workspaces();\n }"}, {"sha": "1718089e8bd27db39c2d7e4c64d15810547b988d", "filename": "tests/integration.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fintegration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fintegration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fintegration.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -72,6 +72,8 @@ fn integration_test() {\n         panic!(\"incompatible crate versions\");\n     } else if stderr.contains(\"failed to run `rustc` to learn about target-specific information\") {\n         panic!(\"couldn't find librustc_driver, consider setting `LD_LIBRARY_PATH`\");\n+    } else if stderr.contains(\"toolchain\") && stderr.contains(\"is not installed\") {\n+        panic!(\"missing required toolchain\");\n     }\n \n     match output.status.code() {"}, {"sha": "4391499a1e1f8e779470f3d1927dcd95c88eadd1", "filename": "tests/ui-cargo/update-all-references.sh", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-cargo%2Fupdate-all-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-cargo%2Fupdate-all-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fupdate-all-references.sh?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,18 +1,3 @@\n #!/bin/bash\n-#\n-# A script to update the references for all tests. The idea is that\n-# you do a run, which will generate files in the build directory\n-# containing the (normalized) actual output of the compiler. You then\n-# run this script, which will copy those files over. If you find\n-# yourself manually editing a foo.stderr file, you're doing it wrong.\n-#\n-# See all `update-references.sh`, if you just want to update a single test.\n \n-if [[ \"$1\" == \"--help\" || \"$1\" == \"-h\" ]]; then\n-    echo \"usage: $0\"\n-fi\n-\n-BUILD_DIR=$PWD/target/debug/test_build_base\n-MY_DIR=$(dirname \"$0\")\n-cd \"$MY_DIR\" || exit\n-find . -name '*.rs' -exec ./update-references.sh \"$BUILD_DIR\" {} +\n+echo \"Please use 'cargo dev bless' instead.\""}, {"sha": "2ab51168bcaa61c4fd96d093a6e3adf50371ae9d", "filename": "tests/ui-cargo/update-references.sh", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bd235707acd095fdd2b079d2992923d0d732a474/tests%2Fui-cargo%2Fupdate-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bd235707acd095fdd2b079d2992923d0d732a474/tests%2Fui-cargo%2Fupdate-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fupdate-references.sh?ref=bd235707acd095fdd2b079d2992923d0d732a474", "patch": "@@ -1,46 +0,0 @@\n-#!/bin/bash\n-\n-# A script to update the references for particular tests. The idea is\n-# that you do a run, which will generate files in the build directory\n-# containing the (normalized) actual output of the compiler. This\n-# script will then copy that output and replace the \"expected output\"\n-# files. You can then commit the changes.\n-#\n-# If you find yourself manually editing a foo.stderr file, you're\n-# doing it wrong.\n-\n-if [[ \"$1\" == \"--help\" || \"$1\" == \"-h\" || \"$1\" == \"\" || \"$2\" == \"\" ]]; then\n-    echo \"usage: $0 <build-directory> <relative-path-to-rs-files>\"\n-    echo \"\"\n-    echo \"For example:\"\n-    echo \"   $0 ../../../build/x86_64-apple-darwin/test/ui *.rs */*.rs\"\n-fi\n-\n-MYDIR=$(dirname \"$0\")\n-\n-BUILD_DIR=\"$1\"\n-shift\n-\n-while [[ \"$1\" != \"\" ]]; do\n-    STDERR_NAME=\"${1/%.rs/.stderr}\"\n-    STDOUT_NAME=\"${1/%.rs/.stdout}\"\n-    shift\n-    if [[ -f \"$BUILD_DIR\"/\"$STDOUT_NAME\" ]] && \\\n-           ! (cmp -s -- \"$BUILD_DIR\"/\"$STDOUT_NAME\" \"$MYDIR\"/\"$STDOUT_NAME\"); then\n-        echo updating \"$MYDIR\"/\"$STDOUT_NAME\"\n-        cp \"$BUILD_DIR\"/\"$STDOUT_NAME\" \"$MYDIR\"/\"$STDOUT_NAME\"\n-        if [[ ! -s \"$MYDIR\"/\"$STDOUT_NAME\" ]]; then\n-            echo removing \"$MYDIR\"/\"$STDOUT_NAME\"\n-            rm \"$MYDIR\"/\"$STDOUT_NAME\"\n-        fi\n-    fi\n-    if [[ -f \"$BUILD_DIR\"/\"$STDERR_NAME\" ]] && \\\n-           ! (cmp -s -- \"$BUILD_DIR\"/\"$STDERR_NAME\" \"$MYDIR\"/\"$STDERR_NAME\"); then\n-        echo updating \"$MYDIR\"/\"$STDERR_NAME\"\n-        cp \"$BUILD_DIR\"/\"$STDERR_NAME\" \"$MYDIR\"/\"$STDERR_NAME\"\n-        if [[ ! -s \"$MYDIR\"/\"$STDERR_NAME\" ]]; then\n-            echo removing \"$MYDIR\"/\"$STDERR_NAME\"\n-            rm \"$MYDIR\"/\"$STDERR_NAME\"\n-        fi\n-    fi\n-done"}, {"sha": "e588c23345e2fdd8ad010e05a0db259589f7bade", "filename": "tests/ui-internal/collapsible_span_lint_calls.fixed", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fcollapsible_span_lint_calls.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fcollapsible_span_lint_calls.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fcollapsible_span_lint_calls.fixed?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "previous_filename": "tests/ui/collapsible_span_lint_calls.fixed"}, {"sha": "d5dd3bb562b429d9265f3ba1d5c80a4c977a4dc2", "filename": "tests/ui-internal/collapsible_span_lint_calls.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fcollapsible_span_lint_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fcollapsible_span_lint_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fcollapsible_span_lint_calls.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "previous_filename": "tests/ui/collapsible_span_lint_calls.rs"}, {"sha": "874d4a9f255c27dcaa542325be407d65d25cfabd", "filename": "tests/ui-internal/collapsible_span_lint_calls.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fcollapsible_span_lint_calls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fcollapsible_span_lint_calls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fcollapsible_span_lint_calls.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "previous_filename": "tests/ui/collapsible_span_lint_calls.stderr"}, {"sha": "5b30c9d5721ca5a0dcf8c7fe0ef200c2339d50f2", "filename": "tests/ui-internal/custom_ice_message.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fcustom_ice_message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fcustom_ice_message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fcustom_ice_message.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "previous_filename": "tests/ui/custom_ice_message.rs"}, {"sha": "a1b8e2ee162cf67eb3722946e1884415b768149c", "filename": "tests/ui-internal/custom_ice_message.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fcustom_ice_message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fcustom_ice_message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fcustom_ice_message.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "previous_filename": "tests/ui/custom_ice_message.stderr"}, {"sha": "053faae02ce3e0d3aa457083224bb9d32b20ba30", "filename": "tests/ui-internal/default_lint.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fdefault_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fdefault_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fdefault_lint.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "previous_filename": "tests/ui/default_lint.rs"}, {"sha": "5c5836a7d297e82a0ae0c18b819d73ef39b3caf9", "filename": "tests/ui-internal/default_lint.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fdefault_lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fdefault_lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fdefault_lint.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "previous_filename": "tests/ui/default_lint.stderr"}, {"sha": "9ab845a573aca66fc880008bee4c0a9f791bda90", "filename": "tests/ui-internal/interning_defined_symbol.fixed", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Finterning_defined_symbol.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Finterning_defined_symbol.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Finterning_defined_symbol.fixed?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,36 @@\n+// run-rustfix\n+#![deny(clippy::internal)]\n+#![feature(rustc_private)]\n+\n+extern crate rustc_span;\n+\n+use rustc_span::symbol::Symbol;\n+\n+macro_rules! sym {\n+    ($tt:tt) => {\n+        rustc_span::symbol::Symbol::intern(stringify!($tt))\n+    };\n+}\n+\n+fn main() {\n+    // Direct use of Symbol::intern\n+    let _ = rustc_span::sym::f32;\n+\n+    // Using a sym macro\n+    let _ = rustc_span::sym::f32;\n+\n+    // Correct suggestion when symbol isn't stringified constant name\n+    let _ = rustc_span::sym::proc_dash_macro;\n+\n+    // interning a keyword\n+    let _ = rustc_span::symbol::kw::SelfLower;\n+\n+    // Interning a symbol that is not defined\n+    let _ = Symbol::intern(\"xyz123\");\n+    let _ = sym!(xyz123);\n+\n+    // Using a different `intern` function\n+    let _ = intern(\"f32\");\n+}\n+\n+fn intern(_: &str) {}"}, {"sha": "a58e182971d7323e63b595a9e501f0abb63a63f6", "filename": "tests/ui-internal/interning_defined_symbol.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Finterning_defined_symbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Finterning_defined_symbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Finterning_defined_symbol.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,36 @@\n+// run-rustfix\n+#![deny(clippy::internal)]\n+#![feature(rustc_private)]\n+\n+extern crate rustc_span;\n+\n+use rustc_span::symbol::Symbol;\n+\n+macro_rules! sym {\n+    ($tt:tt) => {\n+        rustc_span::symbol::Symbol::intern(stringify!($tt))\n+    };\n+}\n+\n+fn main() {\n+    // Direct use of Symbol::intern\n+    let _ = Symbol::intern(\"f32\");\n+\n+    // Using a sym macro\n+    let _ = sym!(f32);\n+\n+    // Correct suggestion when symbol isn't stringified constant name\n+    let _ = Symbol::intern(\"proc-macro\");\n+\n+    // interning a keyword\n+    let _ = Symbol::intern(\"self\");\n+\n+    // Interning a symbol that is not defined\n+    let _ = Symbol::intern(\"xyz123\");\n+    let _ = sym!(xyz123);\n+\n+    // Using a different `intern` function\n+    let _ = intern(\"f32\");\n+}\n+\n+fn intern(_: &str) {}"}, {"sha": "50c1c268eb132e9fdaaab784fae4861be227eb9e", "filename": "tests/ui-internal/interning_defined_symbol.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Finterning_defined_symbol.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Finterning_defined_symbol.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Finterning_defined_symbol.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,33 @@\n+error: interning a defined symbol\n+  --> $DIR/interning_defined_symbol.rs:17:13\n+   |\n+LL |     let _ = Symbol::intern(\"f32\");\n+   |             ^^^^^^^^^^^^^^^^^^^^^ help: try: `rustc_span::sym::f32`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/interning_defined_symbol.rs:2:9\n+   |\n+LL | #![deny(clippy::internal)]\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: `#[deny(clippy::interning_defined_symbol)]` implied by `#[deny(clippy::internal)]`\n+\n+error: interning a defined symbol\n+  --> $DIR/interning_defined_symbol.rs:20:13\n+   |\n+LL |     let _ = sym!(f32);\n+   |             ^^^^^^^^^ help: try: `rustc_span::sym::f32`\n+\n+error: interning a defined symbol\n+  --> $DIR/interning_defined_symbol.rs:23:13\n+   |\n+LL |     let _ = Symbol::intern(\"proc-macro\");\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `rustc_span::sym::proc_dash_macro`\n+\n+error: interning a defined symbol\n+  --> $DIR/interning_defined_symbol.rs:26:13\n+   |\n+LL |     let _ = Symbol::intern(\"self\");\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: try: `rustc_span::symbol::kw::SelfLower`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "01e28ae5e9d3581c0995e1b88abb0fd738494052", "filename": "tests/ui-internal/invalid_paths.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Finvalid_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Finvalid_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Finvalid_paths.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "previous_filename": "tests/ui/invalid_paths.rs"}, {"sha": "bd69d661b714fe8bd29e553588d2736e3eb22fc3", "filename": "tests/ui-internal/invalid_paths.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Finvalid_paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Finvalid_paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Finvalid_paths.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "previous_filename": "tests/ui/invalid_paths.stderr"}, {"sha": "beaef79a340afad2c371352f2dda86f385c95d8c", "filename": "tests/ui-internal/lint_without_lint_pass.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Flint_without_lint_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Flint_without_lint_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Flint_without_lint_pass.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "previous_filename": "tests/ui/lint_without_lint_pass.rs"}, {"sha": "1257dae96d71cc17c0261ff5f66efcea3575c165", "filename": "tests/ui-internal/lint_without_lint_pass.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Flint_without_lint_pass.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Flint_without_lint_pass.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Flint_without_lint_pass.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "previous_filename": "tests/ui/lint_without_lint_pass.stderr"}, {"sha": "fe950b0aa7c7004c729c33cc7b6dab3392d1260a", "filename": "tests/ui-internal/match_type_on_diag_item.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fmatch_type_on_diag_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fmatch_type_on_diag_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fmatch_type_on_diag_item.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "previous_filename": "tests/ui/match_type_on_diag_item.rs"}, {"sha": "82465dbaf6ecc9d9e61b5f99e25f62948da7ebc7", "filename": "tests/ui-internal/match_type_on_diag_item.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fmatch_type_on_diag_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fmatch_type_on_diag_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fmatch_type_on_diag_item.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "previous_filename": "tests/ui/match_type_on_diag_item.stderr"}, {"sha": "b0b3498f057f7f7d05eb87124c4acb68a45aa7e6", "filename": "tests/ui-internal/outer_expn_data.fixed", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fouter_expn_data.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fouter_expn_data.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fouter_expn_data.fixed?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "previous_filename": "tests/ui/outer_expn_data.fixed"}, {"sha": "55a3fed00d075dfa5a4d7360fa9b9f0a85ece34f", "filename": "tests/ui-internal/outer_expn_data.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fouter_expn_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fouter_expn_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fouter_expn_data.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "previous_filename": "tests/ui/outer_expn_data.rs"}, {"sha": "56b6ce1f78ea4de38c7f1b1d0ffb666565c1f05a", "filename": "tests/ui-internal/outer_expn_data.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fouter_expn_data.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Fouter_expn_data.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fouter_expn_data.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "previous_filename": "tests/ui/outer_expn_data.stderr"}, {"sha": "2ec0efe4c10a5125ed60d9220ebdb419bc78214a", "filename": "tests/ui-internal/unnecessary_symbol_str.fixed", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Funnecessary_symbol_str.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Funnecessary_symbol_str.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_symbol_str.fixed?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+#![feature(rustc_private)]\n+#![deny(clippy::internal)]\n+#![allow(clippy::unnecessary_operation, unused_must_use)]\n+\n+extern crate rustc_span;\n+\n+use rustc_span::symbol::{Ident, Symbol};\n+\n+fn main() {\n+    Symbol::intern(\"foo\") == rustc_span::sym::clippy;\n+    Symbol::intern(\"foo\") == rustc_span::symbol::kw::SelfLower;\n+    Symbol::intern(\"foo\") != rustc_span::symbol::kw::SelfUpper;\n+    Ident::invalid().name == rustc_span::sym::clippy;\n+    rustc_span::sym::clippy == Ident::invalid().name;\n+}"}, {"sha": "87e1b3a2ee76a9ebd8d53268d29835a5a3904a34", "filename": "tests/ui-internal/unnecessary_symbol_str.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Funnecessary_symbol_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Funnecessary_symbol_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_symbol_str.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+#![feature(rustc_private)]\n+#![deny(clippy::internal)]\n+#![allow(clippy::unnecessary_operation, unused_must_use)]\n+\n+extern crate rustc_span;\n+\n+use rustc_span::symbol::{Ident, Symbol};\n+\n+fn main() {\n+    Symbol::intern(\"foo\").as_str() == \"clippy\";\n+    Symbol::intern(\"foo\").to_string() == \"self\";\n+    Symbol::intern(\"foo\").to_ident_string() != \"Self\";\n+    &*Ident::invalid().as_str() == \"clippy\";\n+    \"clippy\" == Ident::invalid().to_string();\n+}"}, {"sha": "b1284b7c8ffd036393046ea09ab8dcebd6abe0cd", "filename": "tests/ui-internal/unnecessary_symbol_str.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Funnecessary_symbol_str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-internal%2Funnecessary_symbol_str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_symbol_str.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,39 @@\n+error: unnecessary `Symbol` to string conversion\n+  --> $DIR/unnecessary_symbol_str.rs:11:5\n+   |\n+LL |     Symbol::intern(\"foo\").as_str() == \"clippy\";\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Symbol::intern(\"foo\") == rustc_span::sym::clippy`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unnecessary_symbol_str.rs:3:9\n+   |\n+LL | #![deny(clippy::internal)]\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: `#[deny(clippy::unnecessary_symbol_str)]` implied by `#[deny(clippy::internal)]`\n+\n+error: unnecessary `Symbol` to string conversion\n+  --> $DIR/unnecessary_symbol_str.rs:12:5\n+   |\n+LL |     Symbol::intern(\"foo\").to_string() == \"self\";\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Symbol::intern(\"foo\") == rustc_span::symbol::kw::SelfLower`\n+\n+error: unnecessary `Symbol` to string conversion\n+  --> $DIR/unnecessary_symbol_str.rs:13:5\n+   |\n+LL |     Symbol::intern(\"foo\").to_ident_string() != \"Self\";\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Symbol::intern(\"foo\") != rustc_span::symbol::kw::SelfUpper`\n+\n+error: unnecessary `Symbol` to string conversion\n+  --> $DIR/unnecessary_symbol_str.rs:14:5\n+   |\n+LL |     &*Ident::invalid().as_str() == \"clippy\";\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Ident::invalid().name == rustc_span::sym::clippy`\n+\n+error: unnecessary `Symbol` to string conversion\n+  --> $DIR/unnecessary_symbol_str.rs:15:5\n+   |\n+LL |     \"clippy\" == Ident::invalid().to_string();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `rustc_span::sym::clippy == Ident::invalid().name`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "6feaf7d5c0c1b02aa339b0c0ec48460e61ea8e93", "filename": "tests/ui-toml/lint_decimal_readability/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-toml%2Flint_decimal_readability%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-toml%2Flint_decimal_readability%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Flint_decimal_readability%2Fclippy.toml?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1 @@\n+unreadable-literal-lint-fractions = false\n\\ No newline at end of file"}, {"sha": "9377eb69b233aca281df4305c86149d13f90b2f6", "filename": "tests/ui-toml/lint_decimal_readability/test.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-toml%2Flint_decimal_readability%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-toml%2Flint_decimal_readability%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Flint_decimal_readability%2Ftest.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,22 @@\n+#[deny(clippy::unreadable_literal)]\n+\n+fn allow_inconsistent_digit_grouping() {\n+    #![allow(clippy::inconsistent_digit_grouping)]\n+    let _pass1 = 100_200_300.123456789;\n+}\n+\n+fn main() {\n+    allow_inconsistent_digit_grouping();\n+\n+    let _pass1 = 100_200_300.100_200_300;\n+    let _pass2 = 1.123456789;\n+    let _pass3 = 1.0;\n+    let _pass4 = 10000.00001;\n+    let _pass5 = 1.123456789e1;\n+\n+    // due to clippy::inconsistent-digit-grouping\n+    let _fail1 = 100_200_300.123456789;\n+\n+    // fail due to the integer part\n+    let _fail2 = 100200300.300200100;\n+}"}, {"sha": "9119ef19a7be1aae36193412bcba84b58b204340", "filename": "tests/ui-toml/lint_decimal_readability/test.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-toml%2Flint_decimal_readability%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-toml%2Flint_decimal_readability%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Flint_decimal_readability%2Ftest.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,10 @@\n+error: digits grouped inconsistently by underscores\n+  --> $DIR/test.rs:18:18\n+   |\n+LL |     let _fail1 = 100_200_300.123456789;\n+   |                  ^^^^^^^^^^^^^^^^^^^^^ help: consider: `100_200_300.123_456_789`\n+   |\n+   = note: `-D clippy::inconsistent-digit-grouping` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "7b3c476461d506af54bad5ba90cfbcd6d290a245", "filename": "tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `msrv`, `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `pass-by-value-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `third-party` at line 5 column 1\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `msrv`, `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `pass-by-value-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `unreadable-literal-lint-fractions`, `third-party` at line 5 column 1\n \n error: aborting due to previous error\n "}, {"sha": "4391499a1e1f8e779470f3d1927dcd95c88eadd1", "filename": "tests/ui-toml/update-all-references.sh", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-toml%2Fupdate-all-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui-toml%2Fupdate-all-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fupdate-all-references.sh?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,18 +1,3 @@\n #!/bin/bash\n-#\n-# A script to update the references for all tests. The idea is that\n-# you do a run, which will generate files in the build directory\n-# containing the (normalized) actual output of the compiler. You then\n-# run this script, which will copy those files over. If you find\n-# yourself manually editing a foo.stderr file, you're doing it wrong.\n-#\n-# See all `update-references.sh`, if you just want to update a single test.\n \n-if [[ \"$1\" == \"--help\" || \"$1\" == \"-h\" ]]; then\n-    echo \"usage: $0\"\n-fi\n-\n-BUILD_DIR=$PWD/target/debug/test_build_base\n-MY_DIR=$(dirname \"$0\")\n-cd \"$MY_DIR\" || exit\n-find . -name '*.rs' -exec ./update-references.sh \"$BUILD_DIR\" {} +\n+echo \"Please use 'cargo dev bless' instead.\""}, {"sha": "2ab51168bcaa61c4fd96d093a6e3adf50371ae9d", "filename": "tests/ui-toml/update-references.sh", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bd235707acd095fdd2b079d2992923d0d732a474/tests%2Fui-toml%2Fupdate-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bd235707acd095fdd2b079d2992923d0d732a474/tests%2Fui-toml%2Fupdate-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fupdate-references.sh?ref=bd235707acd095fdd2b079d2992923d0d732a474", "patch": "@@ -1,46 +0,0 @@\n-#!/bin/bash\n-\n-# A script to update the references for particular tests. The idea is\n-# that you do a run, which will generate files in the build directory\n-# containing the (normalized) actual output of the compiler. This\n-# script will then copy that output and replace the \"expected output\"\n-# files. You can then commit the changes.\n-#\n-# If you find yourself manually editing a foo.stderr file, you're\n-# doing it wrong.\n-\n-if [[ \"$1\" == \"--help\" || \"$1\" == \"-h\" || \"$1\" == \"\" || \"$2\" == \"\" ]]; then\n-    echo \"usage: $0 <build-directory> <relative-path-to-rs-files>\"\n-    echo \"\"\n-    echo \"For example:\"\n-    echo \"   $0 ../../../build/x86_64-apple-darwin/test/ui *.rs */*.rs\"\n-fi\n-\n-MYDIR=$(dirname \"$0\")\n-\n-BUILD_DIR=\"$1\"\n-shift\n-\n-while [[ \"$1\" != \"\" ]]; do\n-    STDERR_NAME=\"${1/%.rs/.stderr}\"\n-    STDOUT_NAME=\"${1/%.rs/.stdout}\"\n-    shift\n-    if [[ -f \"$BUILD_DIR\"/\"$STDOUT_NAME\" ]] && \\\n-           ! (cmp -s -- \"$BUILD_DIR\"/\"$STDOUT_NAME\" \"$MYDIR\"/\"$STDOUT_NAME\"); then\n-        echo updating \"$MYDIR\"/\"$STDOUT_NAME\"\n-        cp \"$BUILD_DIR\"/\"$STDOUT_NAME\" \"$MYDIR\"/\"$STDOUT_NAME\"\n-        if [[ ! -s \"$MYDIR\"/\"$STDOUT_NAME\" ]]; then\n-            echo removing \"$MYDIR\"/\"$STDOUT_NAME\"\n-            rm \"$MYDIR\"/\"$STDOUT_NAME\"\n-        fi\n-    fi\n-    if [[ -f \"$BUILD_DIR\"/\"$STDERR_NAME\" ]] && \\\n-           ! (cmp -s -- \"$BUILD_DIR\"/\"$STDERR_NAME\" \"$MYDIR\"/\"$STDERR_NAME\"); then\n-        echo updating \"$MYDIR\"/\"$STDERR_NAME\"\n-        cp \"$BUILD_DIR\"/\"$STDERR_NAME\" \"$MYDIR\"/\"$STDERR_NAME\"\n-        if [[ ! -s \"$MYDIR\"/\"$STDERR_NAME\" ]]; then\n-            echo removing \"$MYDIR\"/\"$STDERR_NAME\"\n-            rm \"$MYDIR\"/\"$STDERR_NAME\"\n-        fi\n-    fi\n-done"}, {"sha": "cac64a3f40b41fbd3052577107cdb6fd8cb86779", "filename": "tests/ui/author/if.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fauthor%2Fif.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fauthor%2Fif.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fif.stdout?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,7 +1,7 @@\n if_chain! {\n     if let StmtKind::Local(ref local) = stmt.kind;\n     if let Some(ref init) = local.init;\n-    if let Some((ref cond, ref then, Some(else_))) = higher::if_block(&init);\n+    if let ExprKind::If(ref cond, ref then, Some(ref else_)) = init.kind;\n     if let ExprKind::Block(ref block) = else_.kind;\n     if let Some(trailing_expr) = &block.expr;\n     if block.stmts.len() == 1;"}, {"sha": "d6ecd8568ce78966249f5d2872b274e469ff80ce", "filename": "tests/ui/auxiliary/macro_rules.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -84,3 +84,29 @@ macro_rules! as_conv {\n         0u32 as u64\n     };\n }\n+\n+#[macro_export]\n+macro_rules! large_enum_variant {\n+    () => {\n+        enum LargeEnumInMacro {\n+            A(i32),\n+            B([i32; 8000]),\n+        }\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! field_reassign_with_default {\n+    () => {\n+        #[derive(Default)]\n+        struct A {\n+            pub i: i32,\n+            pub j: i64,\n+        }\n+        fn lint() {\n+            let mut a: A = Default::default();\n+            a.i = 42;\n+            a;\n+        }\n+    };\n+}"}, {"sha": "24891682d368d0bfa2f167f88512040928442dab", "filename": "tests/ui/auxiliary/proc_macro_derive.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -4,6 +4,7 @@\n #![crate_type = \"proc-macro\"]\n #![feature(repr128, proc_macro_quote)]\n #![allow(incomplete_features)]\n+#![allow(clippy::field_reassign_with_default)]\n #![allow(clippy::eq_op)]\n \n extern crate proc_macro;\n@@ -23,3 +24,20 @@ pub fn derive(_: TokenStream) -> TokenStream {\n     };\n     output\n }\n+\n+#[proc_macro_derive(FieldReassignWithDefault)]\n+pub fn derive_foo(_input: TokenStream) -> TokenStream {\n+    quote! {\n+        #[derive(Default)]\n+        struct A {\n+            pub i: i32,\n+            pub j: i64,\n+        }\n+        #[automatically_derived]\n+        fn lint() {\n+            let mut a: A = Default::default();\n+            a.i = 42;\n+            a;\n+        }\n+    }\n+}"}, {"sha": "68719c2bc6d05ea1afa005e00caee7f3c83b2418", "filename": "tests/ui/case_sensitive_file_extension_comparisons.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcase_sensitive_file_extension_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcase_sensitive_file_extension_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcase_sensitive_file_extension_comparisons.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,44 @@\n+#![warn(clippy::case_sensitive_file_extension_comparisons)]\n+\n+use std::string::String;\n+\n+struct TestStruct {}\n+\n+impl TestStruct {\n+    fn ends_with(self, arg: &str) {}\n+}\n+\n+fn is_rust_file(filename: &str) -> bool {\n+    filename.ends_with(\".rs\")\n+}\n+\n+fn main() {\n+    // std::string::String and &str should trigger the lint failure with .ext12\n+    let _ = String::from(\"\").ends_with(\".ext12\");\n+    let _ = \"str\".ends_with(\".ext12\");\n+\n+    // The test struct should not trigger the lint failure with .ext12\n+    TestStruct {}.ends_with(\".ext12\");\n+\n+    // std::string::String and &str should trigger the lint failure with .EXT12\n+    let _ = String::from(\"\").ends_with(\".EXT12\");\n+    let _ = \"str\".ends_with(\".EXT12\");\n+\n+    // The test struct should not trigger the lint failure with .EXT12\n+    TestStruct {}.ends_with(\".EXT12\");\n+\n+    // Should not trigger the lint failure with .eXT12\n+    let _ = String::from(\"\").ends_with(\".eXT12\");\n+    let _ = \"str\".ends_with(\".eXT12\");\n+    TestStruct {}.ends_with(\".eXT12\");\n+\n+    // Should not trigger the lint failure with .EXT123 (too long)\n+    let _ = String::from(\"\").ends_with(\".EXT123\");\n+    let _ = \"str\".ends_with(\".EXT123\");\n+    TestStruct {}.ends_with(\".EXT123\");\n+\n+    // Shouldn't fail if it doesn't start with a dot\n+    let _ = String::from(\"\").ends_with(\"a.ext\");\n+    let _ = \"str\".ends_with(\"a.extA\");\n+    TestStruct {}.ends_with(\"a.ext\");\n+}"}, {"sha": "05b98169f2d17b0dd1be7812b07acd5236fb566b", "filename": "tests/ui/case_sensitive_file_extension_comparisons.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcase_sensitive_file_extension_comparisons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcase_sensitive_file_extension_comparisons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcase_sensitive_file_extension_comparisons.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,43 @@\n+error: case-sensitive file extension comparison\n+  --> $DIR/case_sensitive_file_extension_comparisons.rs:12:14\n+   |\n+LL |     filename.ends_with(\".rs\")\n+   |              ^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::case-sensitive-file-extension-comparisons` implied by `-D warnings`\n+   = help: consider using a case-insensitive comparison instead\n+\n+error: case-sensitive file extension comparison\n+  --> $DIR/case_sensitive_file_extension_comparisons.rs:17:30\n+   |\n+LL |     let _ = String::from(\"\").ends_with(\".ext12\");\n+   |                              ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a case-insensitive comparison instead\n+\n+error: case-sensitive file extension comparison\n+  --> $DIR/case_sensitive_file_extension_comparisons.rs:18:19\n+   |\n+LL |     let _ = \"str\".ends_with(\".ext12\");\n+   |                   ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a case-insensitive comparison instead\n+\n+error: case-sensitive file extension comparison\n+  --> $DIR/case_sensitive_file_extension_comparisons.rs:24:30\n+   |\n+LL |     let _ = String::from(\"\").ends_with(\".EXT12\");\n+   |                              ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a case-insensitive comparison instead\n+\n+error: case-sensitive file extension comparison\n+  --> $DIR/case_sensitive_file_extension_comparisons.rs:25:19\n+   |\n+LL |     let _ = \"str\".ends_with(\".EXT12\");\n+   |                   ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a case-insensitive comparison instead\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "d011e84b115a7aee99a7f049af33f3fac36be4d2", "filename": "tests/ui/cast_alignment.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcast_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcast_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast_alignment.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -12,6 +12,10 @@ fn main() {\n     (&1u8 as *const u8) as *const u16;\n     (&mut 1u8 as *mut u8) as *mut u16;\n \n+    // cast to more-strictly-aligned type, but with the `pointer::cast` function.\n+    (&1u8 as *const u8).cast::<u16>();\n+    (&mut 1u8 as *mut u8).cast::<u16>();\n+\n     /* These should be ok */\n \n     // not a pointer type"}, {"sha": "7998b787b91fbd70cb353d0c1ef990d11e6018d7", "filename": "tests/ui/cast_alignment.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcast_alignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcast_alignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast_alignment.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -12,5 +12,17 @@ error: casting from `*mut u8` to a more-strictly-aligned pointer (`*mut u16`) (1\n LL |     (&mut 1u8 as *mut u8) as *mut u16;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: casting from `*const u8` to a more-strictly-aligned pointer (`*const u16`) (1 < 2 bytes)\n+  --> $DIR/cast_alignment.rs:16:5\n+   |\n+LL |     (&1u8 as *const u8).cast::<u16>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: casting from `*mut u8` to a more-strictly-aligned pointer (`*mut u16`) (1 < 2 bytes)\n+  --> $DIR/cast_alignment.rs:17:5\n+   |\n+LL |     (&mut 1u8 as *mut u8).cast::<u16>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "d924625132eb0ccc48844f6cfce21e54302c5615", "filename": "tests/ui/clone_on_copy.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fclone_on_copy.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fclone_on_copy.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclone_on_copy.fixed?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -5,7 +5,8 @@\n     clippy::redundant_clone,\n     clippy::deref_addrof,\n     clippy::no_effect,\n-    clippy::unnecessary_operation\n+    clippy::unnecessary_operation,\n+    clippy::vec_init_then_push\n )]\n \n use std::cell::RefCell;"}, {"sha": "97f4946724458d5955f1d82b7ade9345f0a750b8", "filename": "tests/ui/clone_on_copy.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclone_on_copy.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -5,7 +5,8 @@\n     clippy::redundant_clone,\n     clippy::deref_addrof,\n     clippy::no_effect,\n-    clippy::unnecessary_operation\n+    clippy::unnecessary_operation,\n+    clippy::vec_init_then_push\n )]\n \n use std::cell::RefCell;"}, {"sha": "7a706884fb0e7d74e71bba20d1b1ae331e4ca4f4", "filename": "tests/ui/clone_on_copy.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fclone_on_copy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fclone_on_copy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclone_on_copy.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,31 +1,31 @@\n-error: using `clone` on a `Copy` type\n-  --> $DIR/clone_on_copy.rs:22:5\n+error: using `clone` on type `i32` which implements the `Copy` trait\n+  --> $DIR/clone_on_copy.rs:23:5\n    |\n LL |     42.clone();\n    |     ^^^^^^^^^^ help: try removing the `clone` call: `42`\n    |\n    = note: `-D clippy::clone-on-copy` implied by `-D warnings`\n \n-error: using `clone` on a `Copy` type\n-  --> $DIR/clone_on_copy.rs:26:5\n+error: using `clone` on type `i32` which implements the `Copy` trait\n+  --> $DIR/clone_on_copy.rs:27:5\n    |\n LL |     (&42).clone();\n    |     ^^^^^^^^^^^^^ help: try dereferencing it: `*(&42)`\n \n-error: using `clone` on a `Copy` type\n-  --> $DIR/clone_on_copy.rs:29:5\n+error: using `clone` on type `i32` which implements the `Copy` trait\n+  --> $DIR/clone_on_copy.rs:30:5\n    |\n LL |     rc.borrow().clone();\n    |     ^^^^^^^^^^^^^^^^^^^ help: try dereferencing it: `*rc.borrow()`\n \n-error: using `clone` on a `Copy` type\n-  --> $DIR/clone_on_copy.rs:35:14\n+error: using `clone` on type `char` which implements the `Copy` trait\n+  --> $DIR/clone_on_copy.rs:36:14\n    |\n LL |     is_ascii('z'.clone());\n    |              ^^^^^^^^^^^ help: try removing the `clone` call: `'z'`\n \n-error: using `clone` on a `Copy` type\n-  --> $DIR/clone_on_copy.rs:39:14\n+error: using `clone` on type `i32` which implements the `Copy` trait\n+  --> $DIR/clone_on_copy.rs:40:14\n    |\n LL |     vec.push(42.clone());\n    |              ^^^^^^^^^^ help: try removing the `clone` call: `42`"}, {"sha": "fa4bc30e933a2a0ba4252edafe3b7ef9e9e5cbf7", "filename": "tests/ui/collapsible_else_if.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcollapsible_else_if.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcollapsible_else_if.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_else_if.fixed?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -3,6 +3,8 @@\n \n #[rustfmt::skip]\n #[warn(clippy::collapsible_if)]\n+#[warn(clippy::collapsible_else_if)]\n+\n fn main() {\n     let x = \"hello\";\n     let y = \"world\";"}, {"sha": "bf6c1d1f894d7807a5c03a00b5e08f02f6ffa30c", "filename": "tests/ui/collapsible_else_if.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcollapsible_else_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcollapsible_else_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_else_if.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -3,6 +3,8 @@\n \n #[rustfmt::skip]\n #[warn(clippy::collapsible_if)]\n+#[warn(clippy::collapsible_else_if)]\n+\n fn main() {\n     let x = \"hello\";\n     let y = \"world\";"}, {"sha": "ee3e11ae565d405435cafdbae0e27cf845698ee6", "filename": "tests/ui/collapsible_else_if.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcollapsible_else_if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcollapsible_else_if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_else_if.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,5 +1,5 @@\n error: this `else { if .. }` block can be collapsed\n-  --> $DIR/collapsible_else_if.rs:12:12\n+  --> $DIR/collapsible_else_if.rs:14:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -9,7 +9,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-   = note: `-D clippy::collapsible-if` implied by `-D warnings`\n+   = note: `-D clippy::collapsible-else-if` implied by `-D warnings`\n help: collapse nested if block\n    |\n LL |     } else if y == \"world\" {\n@@ -18,7 +18,7 @@ LL |     }\n    |\n \n error: this `else { if .. }` block can be collapsed\n-  --> $DIR/collapsible_else_if.rs:20:12\n+  --> $DIR/collapsible_else_if.rs:22:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -36,7 +36,7 @@ LL |     }\n    |\n \n error: this `else { if .. }` block can be collapsed\n-  --> $DIR/collapsible_else_if.rs:28:12\n+  --> $DIR/collapsible_else_if.rs:30:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -59,7 +59,7 @@ LL |     }\n    |\n \n error: this `else { if .. }` block can be collapsed\n-  --> $DIR/collapsible_else_if.rs:39:12\n+  --> $DIR/collapsible_else_if.rs:41:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -82,7 +82,7 @@ LL |     }\n    |\n \n error: this `else { if .. }` block can be collapsed\n-  --> $DIR/collapsible_else_if.rs:50:12\n+  --> $DIR/collapsible_else_if.rs:52:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -105,7 +105,7 @@ LL |     }\n    |\n \n error: this `else { if .. }` block can be collapsed\n-  --> $DIR/collapsible_else_if.rs:61:12\n+  --> $DIR/collapsible_else_if.rs:63:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -128,7 +128,7 @@ LL |     }\n    |\n \n error: this `else { if .. }` block can be collapsed\n-  --> $DIR/collapsible_else_if.rs:72:12\n+  --> $DIR/collapsible_else_if.rs:74:12\n    |\n LL |       } else {\n    |  ____________^"}, {"sha": "a83e6c77b12e5bc38dc8b76a76611d539160d91a", "filename": "tests/ui/collapsible_match.rs", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_match.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,239 @@\n+#![warn(clippy::collapsible_match)]\n+#![allow(clippy::needless_return, clippy::no_effect, clippy::single_match)]\n+\n+fn lint_cases(opt_opt: Option<Option<u32>>, res_opt: Result<Option<u32>, String>) {\n+    // match without block\n+    match res_opt {\n+        Ok(val) => match val {\n+            Some(n) => foo(n),\n+            _ => return,\n+        },\n+        _ => return,\n+    }\n+\n+    // match with block\n+    match res_opt {\n+        Ok(val) => match val {\n+            Some(n) => foo(n),\n+            _ => return,\n+        },\n+        _ => return,\n+    }\n+\n+    // if let, if let\n+    if let Ok(val) = res_opt {\n+        if let Some(n) = val {\n+            take(n);\n+        }\n+    }\n+\n+    // if let else, if let else\n+    if let Ok(val) = res_opt {\n+        if let Some(n) = val {\n+            take(n);\n+        } else {\n+            return;\n+        }\n+    } else {\n+        return;\n+    }\n+\n+    // if let, match\n+    if let Ok(val) = res_opt {\n+        match val {\n+            Some(n) => foo(n),\n+            _ => (),\n+        }\n+    }\n+\n+    // match, if let\n+    match res_opt {\n+        Ok(val) => {\n+            if let Some(n) = val {\n+                take(n);\n+            }\n+        },\n+        _ => {},\n+    }\n+\n+    // if let else, match\n+    if let Ok(val) = res_opt {\n+        match val {\n+            Some(n) => foo(n),\n+            _ => return,\n+        }\n+    } else {\n+        return;\n+    }\n+\n+    // match, if let else\n+    match res_opt {\n+        Ok(val) => {\n+            if let Some(n) = val {\n+                take(n);\n+            } else {\n+                return;\n+            }\n+        },\n+        _ => return,\n+    }\n+\n+    // None in inner match same as outer wild branch\n+    match res_opt {\n+        Ok(val) => match val {\n+            Some(n) => foo(n),\n+            None => return,\n+        },\n+        _ => return,\n+    }\n+\n+    // None in outer match same as inner wild branch\n+    match opt_opt {\n+        Some(val) => match val {\n+            Some(n) => foo(n),\n+            _ => return,\n+        },\n+        None => return,\n+    }\n+}\n+\n+fn negative_cases(res_opt: Result<Option<u32>, String>, res_res: Result<Result<u32, String>, String>) {\n+    // no wild pattern in outer match\n+    match res_opt {\n+        Ok(val) => match val {\n+            Some(n) => foo(n),\n+            _ => return,\n+        },\n+        Err(_) => return,\n+    }\n+\n+    // inner branch is not wild or None\n+    match res_res {\n+        Ok(val) => match val {\n+            Ok(n) => foo(n),\n+            Err(_) => return,\n+        },\n+        _ => return,\n+    }\n+\n+    // statement before inner match\n+    match res_opt {\n+        Ok(val) => {\n+            \"hi buddy\";\n+            match val {\n+                Some(n) => foo(n),\n+                _ => return,\n+            }\n+        },\n+        _ => return,\n+    }\n+\n+    // statement after inner match\n+    match res_opt {\n+        Ok(val) => {\n+            match val {\n+                Some(n) => foo(n),\n+                _ => return,\n+            }\n+            \"hi buddy\";\n+        },\n+        _ => return,\n+    }\n+\n+    // wild branches do not match\n+    match res_opt {\n+        Ok(val) => match val {\n+            Some(n) => foo(n),\n+            _ => {\n+                \"sup\";\n+                return;\n+            },\n+        },\n+        _ => return,\n+    }\n+\n+    // binding used in if guard\n+    match res_opt {\n+        Ok(val) if val.is_some() => match val {\n+            Some(n) => foo(n),\n+            _ => return,\n+        },\n+        _ => return,\n+    }\n+\n+    // binding used in inner match body\n+    match res_opt {\n+        Ok(val) => match val {\n+            Some(_) => take(val),\n+            _ => return,\n+        },\n+        _ => return,\n+    }\n+\n+    // if guard on inner match\n+    {\n+        match res_opt {\n+            Ok(val) => match val {\n+                Some(n) if make() => foo(n),\n+                _ => return,\n+            },\n+            _ => return,\n+        }\n+        match res_opt {\n+            Ok(val) => match val {\n+                _ => make(),\n+                _ if make() => return,\n+            },\n+            _ => return,\n+        }\n+    }\n+\n+    // differing macro contexts\n+    {\n+        macro_rules! mac {\n+            ($val:ident) => {\n+                match $val {\n+                    Some(n) => foo(n),\n+                    _ => return,\n+                }\n+            };\n+        }\n+        match res_opt {\n+            Ok(val) => mac!(val),\n+            _ => return,\n+        }\n+    }\n+\n+    // OR pattern\n+    enum E<T> {\n+        A(T),\n+        B(T),\n+        C(T),\n+    };\n+    match make::<E<Option<u32>>>() {\n+        E::A(val) | E::B(val) => match val {\n+            Some(n) => foo(n),\n+            _ => return,\n+        },\n+        _ => return,\n+    }\n+    match make::<Option<E<u32>>>() {\n+        Some(val) => match val {\n+            E::A(val) | E::B(val) => foo(val),\n+            _ => return,\n+        },\n+        _ => return,\n+    }\n+}\n+\n+fn make<T>() -> T {\n+    unimplemented!()\n+}\n+\n+fn foo<T, U>(t: T) -> U {\n+    unimplemented!()\n+}\n+\n+fn take<T>(t: T) {}\n+\n+fn main() {}"}, {"sha": "63ac6a1613dc648ce44a90a139d768d18e2a7788", "filename": "tests/ui/collapsible_match.stderr", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcollapsible_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcollapsible_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_match.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,179 @@\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:7:20\n+   |\n+LL |           Ok(val) => match val {\n+   |  ____________________^\n+LL | |             Some(n) => foo(n),\n+LL | |             _ => return,\n+LL | |         },\n+   | |_________^\n+   |\n+   = note: `-D clippy::collapsible-match` implied by `-D warnings`\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:7:12\n+   |\n+LL |         Ok(val) => match val {\n+   |            ^^^ Replace this binding\n+LL |             Some(n) => foo(n),\n+   |             ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:16:20\n+   |\n+LL |           Ok(val) => match val {\n+   |  ____________________^\n+LL | |             Some(n) => foo(n),\n+LL | |             _ => return,\n+LL | |         },\n+   | |_________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:16:12\n+   |\n+LL |         Ok(val) => match val {\n+   |            ^^^ Replace this binding\n+LL |             Some(n) => foo(n),\n+   |             ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:25:9\n+   |\n+LL | /         if let Some(n) = val {\n+LL | |             take(n);\n+LL | |         }\n+   | |_________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:24:15\n+   |\n+LL |     if let Ok(val) = res_opt {\n+   |               ^^^ Replace this binding\n+LL |         if let Some(n) = val {\n+   |                ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:32:9\n+   |\n+LL | /         if let Some(n) = val {\n+LL | |             take(n);\n+LL | |         } else {\n+LL | |             return;\n+LL | |         }\n+   | |_________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:31:15\n+   |\n+LL |     if let Ok(val) = res_opt {\n+   |               ^^^ Replace this binding\n+LL |         if let Some(n) = val {\n+   |                ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:43:9\n+   |\n+LL | /         match val {\n+LL | |             Some(n) => foo(n),\n+LL | |             _ => (),\n+LL | |         }\n+   | |_________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:42:15\n+   |\n+LL |     if let Ok(val) = res_opt {\n+   |               ^^^ Replace this binding\n+LL |         match val {\n+LL |             Some(n) => foo(n),\n+   |             ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:52:13\n+   |\n+LL | /             if let Some(n) = val {\n+LL | |                 take(n);\n+LL | |             }\n+   | |_____________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:51:12\n+   |\n+LL |         Ok(val) => {\n+   |            ^^^ Replace this binding\n+LL |             if let Some(n) = val {\n+   |                    ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:61:9\n+   |\n+LL | /         match val {\n+LL | |             Some(n) => foo(n),\n+LL | |             _ => return,\n+LL | |         }\n+   | |_________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:60:15\n+   |\n+LL |     if let Ok(val) = res_opt {\n+   |               ^^^ Replace this binding\n+LL |         match val {\n+LL |             Some(n) => foo(n),\n+   |             ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:72:13\n+   |\n+LL | /             if let Some(n) = val {\n+LL | |                 take(n);\n+LL | |             } else {\n+LL | |                 return;\n+LL | |             }\n+   | |_____________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:71:12\n+   |\n+LL |         Ok(val) => {\n+   |            ^^^ Replace this binding\n+LL |             if let Some(n) = val {\n+   |                    ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:83:20\n+   |\n+LL |           Ok(val) => match val {\n+   |  ____________________^\n+LL | |             Some(n) => foo(n),\n+LL | |             None => return,\n+LL | |         },\n+   | |_________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:83:12\n+   |\n+LL |         Ok(val) => match val {\n+   |            ^^^ Replace this binding\n+LL |             Some(n) => foo(n),\n+   |             ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:92:22\n+   |\n+LL |           Some(val) => match val {\n+   |  ______________________^\n+LL | |             Some(n) => foo(n),\n+LL | |             _ => return,\n+LL | |         },\n+   | |_________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:92:14\n+   |\n+LL |         Some(val) => match val {\n+   |              ^^^ Replace this binding\n+LL |             Some(n) => foo(n),\n+   |             ^^^^^^^ with this pattern\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "d571ac4ab693e3cc1415cfe200b840c41617c92d", "filename": "tests/ui/collapsible_match2.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcollapsible_match2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcollapsible_match2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_match2.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,53 @@\n+#![warn(clippy::collapsible_match)]\n+#![allow(clippy::needless_return, clippy::no_effect, clippy::single_match)]\n+\n+fn lint_cases(opt_opt: Option<Option<u32>>, res_opt: Result<Option<u32>, String>) {\n+    // if guards on outer match\n+    {\n+        match res_opt {\n+            Ok(val) if make() => match val {\n+                Some(n) => foo(n),\n+                _ => return,\n+            },\n+            _ => return,\n+        }\n+        match res_opt {\n+            Ok(val) => match val {\n+                Some(n) => foo(n),\n+                _ => return,\n+            },\n+            _ if make() => return,\n+            _ => return,\n+        }\n+    }\n+\n+    // macro\n+    {\n+        macro_rules! mac {\n+            ($outer:expr => $pat:pat, $e:expr => $inner_pat:pat, $then:expr) => {\n+                match $outer {\n+                    $pat => match $e {\n+                        $inner_pat => $then,\n+                        _ => return,\n+                    },\n+                    _ => return,\n+                }\n+            };\n+        }\n+        // Lint this since the patterns are not defined by the macro.\n+        // Allows the lint to work on if_chain! for example.\n+        // Fixing the lint requires knowledge of the specific macro, but we optimistically assume that\n+        // there is still a better way to write this.\n+        mac!(res_opt => Ok(val), val => Some(n), foo(n));\n+    }\n+}\n+\n+fn make<T>() -> T {\n+    unimplemented!()\n+}\n+\n+fn foo<T, U>(t: T) -> U {\n+    unimplemented!()\n+}\n+\n+fn main() {}"}, {"sha": "490d82d12cd59d3099b750d112174c034e1bc013", "filename": "tests/ui/collapsible_match2.stderr", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcollapsible_match2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcollapsible_match2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_match2.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,61 @@\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match2.rs:8:34\n+   |\n+LL |               Ok(val) if make() => match val {\n+   |  __________________________________^\n+LL | |                 Some(n) => foo(n),\n+LL | |                 _ => return,\n+LL | |             },\n+   | |_____________^\n+   |\n+   = note: `-D clippy::collapsible-match` implied by `-D warnings`\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match2.rs:8:16\n+   |\n+LL |             Ok(val) if make() => match val {\n+   |                ^^^ Replace this binding\n+LL |                 Some(n) => foo(n),\n+   |                 ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match2.rs:15:24\n+   |\n+LL |               Ok(val) => match val {\n+   |  ________________________^\n+LL | |                 Some(n) => foo(n),\n+LL | |                 _ => return,\n+LL | |             },\n+   | |_____________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match2.rs:15:16\n+   |\n+LL |             Ok(val) => match val {\n+   |                ^^^ Replace this binding\n+LL |                 Some(n) => foo(n),\n+   |                 ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match2.rs:29:29\n+   |\n+LL |                       $pat => match $e {\n+   |  _____________________________^\n+LL | |                         $inner_pat => $then,\n+LL | |                         _ => return,\n+LL | |                     },\n+   | |_____________________^\n+...\n+LL |           mac!(res_opt => Ok(val), val => Some(n), foo(n));\n+   |           ------------------------------------------------- in this macro invocation\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match2.rs:41:28\n+   |\n+LL |         mac!(res_opt => Ok(val), val => Some(n), foo(n));\n+   |                            ^^^          ^^^^^^^ with this pattern\n+   |                            |\n+   |                            Replace this binding\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "59469ec5891c8b45db0c7cdbbde844f9f3bc32a1", "filename": "tests/ui/crashes/ice-3891.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcrashes%2Fice-3891.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcrashes%2Fice-3891.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-3891.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,10 +1,10 @@\n-error: invalid suffix `x` for integer literal\n+error: invalid suffix `x` for number literal\n   --> $DIR/ice-3891.rs:2:5\n    |\n LL |     1x;\n    |     ^^ invalid suffix `x`\n    |\n-   = help: the suffix must be one of the integral types (`u32`, `isize`, etc)\n+   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n \n error: aborting due to previous error\n "}, {"sha": "ac6c3e4aba046bed0696e01f1c43c9b67f661d7d", "filename": "tests/ui/crashes/ice-6539.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcrashes%2Fice-6539.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcrashes%2Fice-6539.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-6539.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,16 @@\n+// The test for the ICE 6539: https://github.com/rust-lang/rust-clippy/issues/6539.\n+// The cause is that `zero_sized_map_values` used `layout_of` with types from type aliases,\n+// which is essentially the same as the ICE 4968.\n+// Note that only type aliases with associated types caused the crash this time,\n+// not others such as trait impls.\n+\n+use std::collections::{BTreeMap, HashMap};\n+\n+pub trait Trait {\n+    type Assoc;\n+}\n+\n+type TypeAlias<T> = HashMap<(), <T as Trait>::Assoc>;\n+type TypeAlias2<T> = BTreeMap<(), <T as Trait>::Assoc>;\n+\n+fn main() {}"}, {"sha": "c57a45dc7aab9b1c1f3e48dfc7e41558b6002fc9", "filename": "tests/ui/crashes/used_underscore_binding_macro.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcrashes%2Fused_underscore_binding_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fcrashes%2Fused_underscore_binding_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fused_underscore_binding_macro.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,7 +1,6 @@\n-#![allow(clippy::useless_attribute)] //issue #2910\n+// edition:2018\n \n-#[macro_use]\n-extern crate serde_derive;\n+use serde::Deserialize;\n \n /// Tests that we do not lint for unused underscores in a `MacroAttribute`\n /// expansion"}, {"sha": "a2e5c13c45282c50b93ec0e00d6723660af34033", "filename": "tests/ui/empty_enum.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty_enum.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,6 +1,7 @@\n #![allow(dead_code)]\n #![warn(clippy::empty_enum)]\n-\n+// Enable never type to test empty enum lint\n+#![feature(never_type)]\n enum Empty {}\n \n fn main() {}"}, {"sha": "7125e5f602b75ba962c400f6824b82e19b3d4bba", "filename": "tests/ui/empty_enum.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fempty_enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fempty_enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty_enum.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,5 +1,5 @@\n error: enum with no variants\n-  --> $DIR/empty_enum.rs:4:1\n+  --> $DIR/empty_enum.rs:5:1\n    |\n LL | enum Empty {}\n    | ^^^^^^^^^^^^^"}, {"sha": "386677352e29be18d9b0876af6f3c89e10097091", "filename": "tests/ui/empty_enum_without_never_type.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fempty_enum_without_never_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fempty_enum_without_never_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty_enum_without_never_type.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,7 @@\n+#![allow(dead_code)]\n+#![warn(clippy::empty_enum)]\n+\n+// `never_type` is not enabled; this test has no stderr file\n+enum Empty {}\n+\n+fn main() {}"}, {"sha": "8df32649ad948b3d85aa3fae9a2bc468def694eb", "filename": "tests/ui/eprint_with_newline.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Feprint_with_newline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Feprint_with_newline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feprint_with_newline.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,49 @@\n+#![allow(clippy::print_literal)]\n+#![warn(clippy::print_with_newline)]\n+\n+fn main() {\n+    eprint!(\"Hello\\n\");\n+    eprint!(\"Hello {}\\n\", \"world\");\n+    eprint!(\"Hello {} {}\\n\", \"world\", \"#2\");\n+    eprint!(\"{}\\n\", 1265);\n+    eprint!(\"\\n\");\n+\n+    // these are all fine\n+    eprint!(\"\");\n+    eprint!(\"Hello\");\n+    eprintln!(\"Hello\");\n+    eprintln!(\"Hello\\n\");\n+    eprintln!(\"Hello {}\\n\", \"world\");\n+    eprint!(\"Issue\\n{}\", 1265);\n+    eprint!(\"{}\", 1265);\n+    eprint!(\"\\n{}\", 1275);\n+    eprint!(\"\\n\\n\");\n+    eprint!(\"like eof\\n\\n\");\n+    eprint!(\"Hello {} {}\\n\\n\", \"world\", \"#2\");\n+    eprintln!(\"\\ndon't\\nwarn\\nfor\\nmultiple\\nnewlines\\n\"); // #3126\n+    eprintln!(\"\\nbla\\n\\n\"); // #3126\n+\n+    // Escaping\n+    eprint!(\"\\\\n\"); // #3514\n+    eprint!(\"\\\\\\n\"); // should fail\n+    eprint!(\"\\\\\\\\n\");\n+\n+    // Raw strings\n+    eprint!(r\"\\n\"); // #3778\n+\n+    // Literal newlines should also fail\n+    eprint!(\n+        \"\n+\"\n+    );\n+    eprint!(\n+        r\"\n+\"\n+    );\n+\n+    // Don't warn on CRLF (#4208)\n+    eprint!(\"\\r\\n\");\n+    eprint!(\"foo\\r\\n\");\n+    eprint!(\"\\\\r\\n\"); //~ ERROR\n+    eprint!(\"foo\\rbar\\n\") // ~ ERROR\n+}"}, {"sha": "31811d1d92a04285321bf4d5c0c6e3dead552d0a", "filename": "tests/ui/eprint_with_newline.stderr", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Feprint_with_newline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Feprint_with_newline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feprint_with_newline.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,121 @@\n+error: using `eprint!()` with a format string that ends in a single newline\n+  --> $DIR/eprint_with_newline.rs:5:5\n+   |\n+LL |     eprint!(\"Hello/n\");\n+   |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::print-with-newline` implied by `-D warnings`\n+help: use `eprintln!` instead\n+   |\n+LL |     eprintln!(\"Hello\");\n+   |     ^^^^^^^^       --\n+\n+error: using `eprint!()` with a format string that ends in a single newline\n+  --> $DIR/eprint_with_newline.rs:6:5\n+   |\n+LL |     eprint!(\"Hello {}/n\", \"world\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use `eprintln!` instead\n+   |\n+LL |     eprintln!(\"Hello {}\", \"world\");\n+   |     ^^^^^^^^          --\n+\n+error: using `eprint!()` with a format string that ends in a single newline\n+  --> $DIR/eprint_with_newline.rs:7:5\n+   |\n+LL |     eprint!(\"Hello {} {}/n\", \"world\", \"#2\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use `eprintln!` instead\n+   |\n+LL |     eprintln!(\"Hello {} {}\", \"world\", \"#2\");\n+   |     ^^^^^^^^             --\n+\n+error: using `eprint!()` with a format string that ends in a single newline\n+  --> $DIR/eprint_with_newline.rs:8:5\n+   |\n+LL |     eprint!(\"{}/n\", 1265);\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use `eprintln!` instead\n+   |\n+LL |     eprintln!(\"{}\", 1265);\n+   |     ^^^^^^^^    --\n+\n+error: using `eprint!()` with a format string that ends in a single newline\n+  --> $DIR/eprint_with_newline.rs:9:5\n+   |\n+LL |     eprint!(\"/n\");\n+   |     ^^^^^^^^^^^^^\n+   |\n+help: use `eprintln!` instead\n+   |\n+LL |     eprintln!();\n+   |     ^^^^^^^^ --\n+\n+error: using `eprint!()` with a format string that ends in a single newline\n+  --> $DIR/eprint_with_newline.rs:28:5\n+   |\n+LL |     eprint!(\"//n\"); // should fail\n+   |     ^^^^^^^^^^^^^^^\n+   |\n+help: use `eprintln!` instead\n+   |\n+LL |     eprintln!(\"/\"); // should fail\n+   |     ^^^^^^^^    --\n+\n+error: using `eprint!()` with a format string that ends in a single newline\n+  --> $DIR/eprint_with_newline.rs:35:5\n+   |\n+LL | /     eprint!(\n+LL | |         \"\n+LL | | \"\n+LL | |     );\n+   | |_____^\n+   |\n+help: use `eprintln!` instead\n+   |\n+LL |     eprintln!(\n+LL |         \"\"\n+   |\n+\n+error: using `eprint!()` with a format string that ends in a single newline\n+  --> $DIR/eprint_with_newline.rs:39:5\n+   |\n+LL | /     eprint!(\n+LL | |         r\"\n+LL | | \"\n+LL | |     );\n+   | |_____^\n+   |\n+help: use `eprintln!` instead\n+   |\n+LL |     eprintln!(\n+LL |         r\"\"\n+   |\n+\n+error: using `eprint!()` with a format string that ends in a single newline\n+  --> $DIR/eprint_with_newline.rs:47:5\n+   |\n+LL |     eprint!(\"/r/n\"); //~ ERROR\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+help: use `eprintln!` instead\n+   |\n+LL |     eprintln!(\"/r\"); //~ ERROR\n+   |     ^^^^^^^^     --\n+\n+error: using `eprint!()` with a format string that ends in a single newline\n+  --> $DIR/eprint_with_newline.rs:48:5\n+   |\n+LL |     eprint!(\"foo/rbar/n\") // ~ ERROR\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use `eprintln!` instead\n+   |\n+LL |     eprintln!(\"foo/rbar\") // ~ ERROR\n+   |     ^^^^^^^^          --\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "7ab23320db6d1b7aba040e382ea317cb517b2d2c", "filename": "tests/ui/eq_op.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feq_op.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -86,3 +86,12 @@ fn check_ignore_macro() {\n     // checks if the lint ignores macros with `!` operator\n     !bool_macro!(1) && !bool_macro!(\"\");\n }\n+\n+struct Nested {\n+    inner: ((i32,), (i32,), (i32,)),\n+}\n+\n+fn check_nested(n1: &Nested, n2: &Nested) -> bool {\n+    // `n2.inner.0.0` mistyped as `n1.inner.0.0`\n+    (n1.inner.0).0 == (n1.inner.0).0 && (n1.inner.1).0 == (n2.inner.1).0 && (n1.inner.2).0 == (n2.inner.2).0\n+}"}, {"sha": "8ef658af8df429829ec50d85dfcdbe4f8ab3bd74", "filename": "tests/ui/eq_op.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Feq_op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Feq_op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feq_op.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -162,5 +162,13 @@ error: equal expressions as operands to `/`\n LL |     const D: u32 = A / A;\n    |                    ^^^^^\n \n-error: aborting due to 27 previous errors\n+error: equal expressions as operands to `==`\n+  --> $DIR/eq_op.rs:96:5\n+   |\n+LL |     (n1.inner.0).0 == (n1.inner.0).0 && (n1.inner.1).0 == (n2.inner.1).0 && (n1.inner.2).0 == (n2.inner.2).0\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[deny(clippy::eq_op)]` on by default\n+\n+error: aborting due to 28 previous errors\n "}, {"sha": "d26f48fc68f85ebe4ebd07a4027c81539e311dad", "filename": "tests/ui/escape_analysis.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fescape_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fescape_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fescape_analysis.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -182,3 +182,23 @@ pub extern \"C\" fn do_not_warn_me(_c_pointer: Box<String>) -> () {}\n \n #[rustfmt::skip] // Forces rustfmt to not add ABI\n pub extern fn do_not_warn_me_no_abi(_c_pointer: Box<String>) -> () {}\n+\n+// Issue #4804 - default implementation in trait\n+mod issue4804 {\n+    trait DefaultTraitImplTest {\n+        // don't warn on `self`\n+        fn default_impl(self: Box<Self>) -> u32 {\n+            5\n+        }\n+\n+        // warn on `x: Box<u32>`\n+        fn default_impl_x(self: Box<Self>, x: Box<u32>) -> u32 {\n+            4\n+        }\n+    }\n+\n+    trait WarnTrait {\n+        // warn on `x: Box<u32>`\n+        fn foo(x: Box<u32>) {}\n+    }\n+}"}, {"sha": "4a82b4419f9974488e68f4f7ec8d3a5932687fcd", "filename": "tests/ui/escape_analysis.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fescape_analysis.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fescape_analysis.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fescape_analysis.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -12,5 +12,17 @@ error: local variable doesn't need to be boxed here\n LL | pub fn new(_needs_name: Box<PeekableSeekable<&()>>) -> () {}\n    |            ^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: local variable doesn't need to be boxed here\n+  --> $DIR/escape_analysis.rs:195:44\n+   |\n+LL |         fn default_impl_x(self: Box<Self>, x: Box<u32>) -> u32 {\n+   |                                            ^\n+\n+error: local variable doesn't need to be boxed here\n+  --> $DIR/escape_analysis.rs:202:16\n+   |\n+LL |         fn foo(x: Box<u32>) {}\n+   |                ^\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "16aa1b07733d5d8049b25a5c2ca56ad0f1323fc7", "filename": "tests/ui/eta.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Feta.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Feta.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -12,7 +12,7 @@ error: redundant closure found\n LL |     meta(|a| foo(a));\n    |          ^^^^^^^^^^ help: remove closure as shown: `foo`\n \n-error: this expression borrows a reference that is immediately dereferenced by the compiler\n+error: this expression borrows a reference (`&u8`) that is immediately dereferenced by the compiler\n   --> $DIR/eta.rs:24:21\n    |\n LL |     all(&[1, 2, 3], &&2, |x, y| below(x, y)); //is adjusted"}, {"sha": "9fc208f5332a5ccbb9e9567425bac44d2ffb1dd7", "filename": "tests/ui/field_reassign_with_default.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Ffield_reassign_with_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Ffield_reassign_with_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffield_reassign_with_default.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,5 +1,18 @@\n+// aux-build:proc_macro_derive.rs\n+// aux-build:macro_rules.rs\n+\n #![warn(clippy::field_reassign_with_default)]\n \n+#[macro_use]\n+extern crate proc_macro_derive;\n+#[macro_use]\n+extern crate macro_rules;\n+\n+// Don't lint on derives that derive `Default`\n+// See https://github.com/rust-lang/rust-clippy/issues/6545\n+#[derive(FieldReassignWithDefault)]\n+struct DerivedStruct;\n+\n #[derive(Default)]\n struct A {\n     i: i32,\n@@ -11,6 +24,11 @@ struct B {\n     j: i64,\n }\n \n+#[derive(Default)]\n+struct C {\n+    i: Vec<i32>,\n+    j: i64,\n+}\n /// Implements .next() that returns a different number each time.\n struct SideEffect(i32);\n \n@@ -107,4 +125,23 @@ fn main() {\n     x.i = side_effect.next();\n     x.j = 2;\n     x.i = side_effect.next();\n+\n+    // don't lint - some private fields\n+    let mut x = m::F::default();\n+    x.a = 1;\n+\n+    // don't expand macros in the suggestion (#6522)\n+    let mut a: C = C::default();\n+    a.i = vec![1];\n+\n+    // Don't lint in external macros\n+    field_reassign_with_default!();\n+}\n+\n+mod m {\n+    #[derive(Default)]\n+    pub struct F {\n+        pub a: u64,\n+        b: u64,\n+    }\n }"}, {"sha": "2f0f28f7bb724f92422ce0e618423342880d8f1f", "filename": "tests/ui/field_reassign_with_default.stderr", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Ffield_reassign_with_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Ffield_reassign_with_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffield_reassign_with_default.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,75 +1,87 @@\n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:30:5\n+  --> $DIR/field_reassign_with_default.rs:48:5\n    |\n LL |     a.i = 42;\n    |     ^^^^^^^^^\n    |\n    = note: `-D clippy::field-reassign-with-default` implied by `-D warnings`\n-note: consider initializing the variable with `A { i: 42, ..Default::default() }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:29:5\n+note: consider initializing the variable with `main::A { i: 42, ..Default::default() }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:47:5\n    |\n LL |     let mut a: A = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:70:5\n+  --> $DIR/field_reassign_with_default.rs:88:5\n    |\n LL |     a.j = 43;\n    |     ^^^^^^^^^\n    |\n-note: consider initializing the variable with `A { j: 43, i: 42 }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:69:5\n+note: consider initializing the variable with `main::A { j: 43, i: 42 }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:87:5\n    |\n LL |     let mut a: A = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:75:5\n+  --> $DIR/field_reassign_with_default.rs:93:5\n    |\n LL |     a.i = 42;\n    |     ^^^^^^^^^\n    |\n-note: consider initializing the variable with `A { i: 42, j: 44 }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:74:5\n+note: consider initializing the variable with `main::A { i: 42, j: 44 }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:92:5\n    |\n LL |     let mut a: A = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:81:5\n+  --> $DIR/field_reassign_with_default.rs:99:5\n    |\n LL |     a.i = 42;\n    |     ^^^^^^^^^\n    |\n-note: consider initializing the variable with `A { i: 42, ..Default::default() }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:80:5\n+note: consider initializing the variable with `main::A { i: 42, ..Default::default() }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:98:5\n    |\n LL |     let mut a = A::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:91:5\n+  --> $DIR/field_reassign_with_default.rs:109:5\n    |\n LL |     a.i = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: consider initializing the variable with `A::default()` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:90:5\n+note: consider initializing the variable with `main::A { i: Default::default(), ..Default::default() }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:108:5\n    |\n LL |     let mut a: A = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:95:5\n+  --> $DIR/field_reassign_with_default.rs:113:5\n    |\n LL |     a.i = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: consider initializing the variable with `A { j: 45, ..Default::default() }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:94:5\n+note: consider initializing the variable with `main::A { i: Default::default(), j: 45 }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:112:5\n    |\n LL |     let mut a: A = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 6 previous errors\n+error: field assignment outside of initializer for an instance created with Default::default()\n+  --> $DIR/field_reassign_with_default.rs:135:5\n+   |\n+LL |     a.i = vec![1];\n+   |     ^^^^^^^^^^^^^^\n+   |\n+note: consider initializing the variable with `C { i: vec![1], ..Default::default() }` and removing relevant reassignments\n+  --> $DIR/field_reassign_with_default.rs:134:5\n+   |\n+LL |     let mut a: C = C::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 7 previous errors\n "}, {"sha": "263d9a7b92ddb2edb65bacef04ee55ca3870e3ad", "filename": "tests/ui/float_cmp_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Ffloat_cmp_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Ffloat_cmp_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloat_cmp_const.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -48,7 +48,7 @@ fn main() {\n     v != 1.0;\n \n     const ZERO_ARRAY: [f32; 3] = [0.0, 0.0, 0.0];\n-    const ZERO_INF_ARRAY: [f32; 3] = [0.0, ::std::f32::INFINITY, ::std::f32::NEG_INFINITY];\n+    const ZERO_INF_ARRAY: [f32; 3] = [0.0, f32::INFINITY, f32::NEG_INFINITY];\n     const NON_ZERO_ARRAY: [f32; 3] = [0.0, 0.1, 0.2];\n     const NON_ZERO_ARRAY2: [f32; 3] = [0.2, 0.1, 0.0];\n "}, {"sha": "0d14807ff1cfcf1f2745b521f0c101c7ca85eddb", "filename": "tests/ui/formatting.rs", "status": "modified", "additions": 1, "deletions": 86, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformatting.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -10,91 +10,6 @@ fn foo() -> bool {\n \n #[rustfmt::skip]\n fn main() {\n-    // weird `else` formatting:\n-    if foo() {\n-    } {\n-    }\n-\n-    if foo() {\n-    } if foo() {\n-    }\n-\n-    let _ = { // if as the last expression\n-        let _ = 0;\n-\n-        if foo() {\n-        } if foo() {\n-        }\n-        else {\n-        }\n-    };\n-\n-    let _ = { // if in the middle of a block\n-        if foo() {\n-        } if foo() {\n-        }\n-        else {\n-        }\n-\n-        let _ = 0;\n-    };\n-\n-    if foo() {\n-    } else\n-    {\n-    }\n-\n-    if foo() {\n-    }\n-    else\n-    {\n-    }\n-\n-    if foo() {\n-    } else\n-    if foo() { // the span of the above error should continue here\n-    }\n-\n-    if foo() {\n-    }\n-    else\n-    if foo() { // the span of the above error should continue here\n-    }\n-\n-    // those are ok:\n-    if foo() {\n-    }\n-    {\n-    }\n-\n-    if foo() {\n-    } else {\n-    }\n-\n-    if foo() {\n-    }\n-    else {\n-    }\n-\n-    if foo() {\n-    }\n-    if foo() {\n-    }\n-\n-    if foo() {\n-    } else if foo() {\n-    }\n-\n-    if foo() {\n-    }\n-    else if foo() {\n-    }\n-\n-    if foo() {\n-    }\n-    else if\n-    foo() {}\n-\n     // weird op_eq formatting:\n     let mut a = 42;\n     a =- 35;\n@@ -146,7 +61,7 @@ fn main() {\n \n     // don't lint if the indentation suggests not to\n     let _ = &[\n-        1 + 2, 3 \n+        1 + 2, 3\n                 - 4, 5\n     ];\n     // lint if it doesn't"}, {"sha": "bde434c7e2e78737ae451a9c8dd776712aba5090", "filename": "tests/ui/formatting.stderr", "status": "modified", "additions": 7, "deletions": 82, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fformatting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fformatting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformatting.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,80 +1,5 @@\n-error: this looks like an `else {..}` but the `else` is missing\n-  --> $DIR/formatting.rs:15:6\n-   |\n-LL |     } {\n-   |      ^\n-   |\n-   = note: `-D clippy::suspicious-else-formatting` implied by `-D warnings`\n-   = note: to remove this lint, add the missing `else` or add a new line before the next block\n-\n-error: this looks like an `else if` but the `else` is missing\n-  --> $DIR/formatting.rs:19:6\n-   |\n-LL |     } if foo() {\n-   |      ^\n-   |\n-   = note: to remove this lint, add the missing `else` or add a new line before the second `if`\n-\n-error: this looks like an `else if` but the `else` is missing\n-  --> $DIR/formatting.rs:26:10\n-   |\n-LL |         } if foo() {\n-   |          ^\n-   |\n-   = note: to remove this lint, add the missing `else` or add a new line before the second `if`\n-\n-error: this looks like an `else if` but the `else` is missing\n-  --> $DIR/formatting.rs:34:10\n-   |\n-LL |         } if foo() {\n-   |          ^\n-   |\n-   = note: to remove this lint, add the missing `else` or add a new line before the second `if`\n-\n-error: this is an `else {..}` but the formatting might hide it\n-  --> $DIR/formatting.rs:43:6\n-   |\n-LL |       } else\n-   |  ______^\n-LL | |     {\n-   | |____^\n-   |\n-   = note: to remove this lint, remove the `else` or remove the new line between `else` and `{..}`\n-\n-error: this is an `else {..}` but the formatting might hide it\n-  --> $DIR/formatting.rs:48:6\n-   |\n-LL |       }\n-   |  ______^\n-LL | |     else\n-LL | |     {\n-   | |____^\n-   |\n-   = note: to remove this lint, remove the `else` or remove the new line between `else` and `{..}`\n-\n-error: this is an `else if` but the formatting might hide it\n-  --> $DIR/formatting.rs:54:6\n-   |\n-LL |       } else\n-   |  ______^\n-LL | |     if foo() { // the span of the above error should continue here\n-   | |____^\n-   |\n-   = note: to remove this lint, remove the `else` or remove the new line between `else` and `if`\n-\n-error: this is an `else if` but the formatting might hide it\n-  --> $DIR/formatting.rs:59:6\n-   |\n-LL |       }\n-   |  ______^\n-LL | |     else\n-LL | |     if foo() { // the span of the above error should continue here\n-   | |____^\n-   |\n-   = note: to remove this lint, remove the `else` or remove the new line between `else` and `if`\n-\n error: this looks like you are trying to use `.. -= ..`, but you really are doing `.. = (- ..)`\n-  --> $DIR/formatting.rs:100:6\n+  --> $DIR/formatting.rs:15:6\n    |\n LL |     a =- 35;\n    |      ^^^^\n@@ -83,23 +8,23 @@ LL |     a =- 35;\n    = note: to remove this lint, use either `-=` or `= -`\n \n error: this looks like you are trying to use `.. *= ..`, but you really are doing `.. = (* ..)`\n-  --> $DIR/formatting.rs:101:6\n+  --> $DIR/formatting.rs:16:6\n    |\n LL |     a =* &191;\n    |      ^^^^\n    |\n    = note: to remove this lint, use either `*=` or `= *`\n \n error: this looks like you are trying to use `.. != ..`, but you really are doing `.. = (! ..)`\n-  --> $DIR/formatting.rs:104:6\n+  --> $DIR/formatting.rs:19:6\n    |\n LL |     b =! false;\n    |      ^^^^\n    |\n    = note: to remove this lint, use either `!=` or `= !`\n \n error: possibly missing a comma here\n-  --> $DIR/formatting.rs:113:19\n+  --> $DIR/formatting.rs:28:19\n    |\n LL |         -1, -2, -3 // <= no comma here\n    |                   ^\n@@ -108,20 +33,20 @@ LL |         -1, -2, -3 // <= no comma here\n    = note: to remove this lint, add a comma or write the expr in a single line\n \n error: possibly missing a comma here\n-  --> $DIR/formatting.rs:117:19\n+  --> $DIR/formatting.rs:32:19\n    |\n LL |         -1, -2, -3 // <= no comma here\n    |                   ^\n    |\n    = note: to remove this lint, add a comma or write the expr in a single line\n \n error: possibly missing a comma here\n-  --> $DIR/formatting.rs:154:11\n+  --> $DIR/formatting.rs:69:11\n    |\n LL |         -1\n    |           ^\n    |\n    = note: to remove this lint, add a comma or write the expr in a single line\n \n-error: aborting due to 14 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "292d0924fb17a4ca1b32bf0a39fa6a81fdc68e82", "filename": "tests/ui/from_over_into.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Ffrom_over_into.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Ffrom_over_into.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffrom_over_into.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,21 @@\n+#![warn(clippy::from_over_into)]\n+\n+// this should throw an error\n+struct StringWrapper(String);\n+\n+impl Into<StringWrapper> for String {\n+    fn into(self) -> StringWrapper {\n+        StringWrapper(self)\n+    }\n+}\n+\n+// this is fine\n+struct A(String);\n+\n+impl From<String> for A {\n+    fn from(s: String) -> A {\n+        A(s)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "b101d2704fbda52692767a9e2a2a67679bea3711", "filename": "tests/ui/from_over_into.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Ffrom_over_into.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Ffrom_over_into.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffrom_over_into.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,11 @@\n+error: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n+  --> $DIR/from_over_into.rs:6:1\n+   |\n+LL | impl Into<StringWrapper> for String {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::from-over-into` implied by `-D warnings`\n+   = help: consider to implement `From` instead\n+\n+error: aborting due to previous error\n+"}, {"sha": "e83ce47e563080b5a25e0bad69d0d57fc3c581be", "filename": "tests/ui/if_same_then_else2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fif_same_then_else2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fif_same_then_else2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_same_then_else2.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,6 +1,7 @@\n #![warn(clippy::if_same_then_else)]\n #![allow(\n     clippy::blacklisted_name,\n+    clippy::collapsible_else_if,\n     clippy::collapsible_if,\n     clippy::ifs_same_cond,\n     clippy::needless_return,"}, {"sha": "f98e30fa376fea22a8198cb4faffd5218ba94dad", "filename": "tests/ui/if_same_then_else2.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fif_same_then_else2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fif_same_then_else2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_same_then_else2.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,5 +1,5 @@\n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:20:12\n+  --> $DIR/if_same_then_else2.rs:21:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -13,7 +13,7 @@ LL | |     }\n    |\n    = note: `-D clippy::if-same-then-else` implied by `-D warnings`\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:11:13\n+  --> $DIR/if_same_then_else2.rs:12:13\n    |\n LL |       if true {\n    |  _____________^\n@@ -26,7 +26,7 @@ LL | |     } else {\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:34:12\n+  --> $DIR/if_same_then_else2.rs:35:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -36,7 +36,7 @@ LL | |     }\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:32:13\n+  --> $DIR/if_same_then_else2.rs:33:13\n    |\n LL |       if true {\n    |  _____________^\n@@ -45,7 +45,7 @@ LL | |     } else {\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:41:12\n+  --> $DIR/if_same_then_else2.rs:42:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -55,7 +55,7 @@ LL | |     }\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:39:13\n+  --> $DIR/if_same_then_else2.rs:40:13\n    |\n LL |       if true {\n    |  _____________^\n@@ -64,7 +64,7 @@ LL | |     } else {\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:91:12\n+  --> $DIR/if_same_then_else2.rs:92:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -74,7 +74,7 @@ LL | |     };\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:89:21\n+  --> $DIR/if_same_then_else2.rs:90:21\n    |\n LL |       let _ = if true {\n    |  _____________________^\n@@ -83,7 +83,7 @@ LL | |     } else {\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:98:12\n+  --> $DIR/if_same_then_else2.rs:99:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -93,7 +93,7 @@ LL | |     }\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:96:13\n+  --> $DIR/if_same_then_else2.rs:97:13\n    |\n LL |       if true {\n    |  _____________^\n@@ -102,7 +102,7 @@ LL | |     } else {\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:123:12\n+  --> $DIR/if_same_then_else2.rs:124:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -112,7 +112,7 @@ LL | |     }\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else2.rs:120:20\n+  --> $DIR/if_same_then_else2.rs:121:20\n    |\n LL |       } else if true {\n    |  ____________________^"}, {"sha": "d439ca1e4e1a171ca3ef20dc99f2311b968b5573", "filename": "tests/ui/item_after_statement.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fitem_after_statement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fitem_after_statement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fitem_after_statement.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -37,3 +37,16 @@ fn mac() {\n     b!();\n     println!(\"{}\", a);\n }\n+\n+fn semicolon() {\n+    struct S {\n+        a: u32,\n+    };\n+    impl S {\n+        fn new(a: u32) -> Self {\n+            Self { a }\n+        }\n+    }\n+\n+    let _ = S::new(3);\n+}"}, {"sha": "d22fee3f27b05818c3ed86e1127c010726bb7afa", "filename": "tests/ui/large_enum_variant.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_enum_variant.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,7 +1,12 @@\n+// aux-build:macro_rules.rs\n+\n #![allow(dead_code)]\n #![allow(unused_variables)]\n #![warn(clippy::large_enum_variant)]\n \n+#[macro_use]\n+extern crate macro_rules;\n+\n enum LargeEnum {\n     A(i32),\n     B([i32; 8000]),\n@@ -51,4 +56,6 @@ enum LargeEnumOk {\n     LargeB([i32; 8001]),\n }\n \n-fn main() {}\n+fn main() {\n+    large_enum_variant!();\n+}"}, {"sha": "d39a4d462aabde949de878d8821d11950cecfc73", "filename": "tests/ui/large_enum_variant.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Flarge_enum_variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Flarge_enum_variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_enum_variant.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,12 +1,12 @@\n error: large size difference between variants\n-  --> $DIR/large_enum_variant.rs:7:5\n+  --> $DIR/large_enum_variant.rs:12:5\n    |\n LL |     B([i32; 8000]),\n    |     ^^^^^^^^^^^^^^ this variant is 32000 bytes\n    |\n    = note: `-D clippy::large-enum-variant` implied by `-D warnings`\n note: and the second-largest variant is 4 bytes:\n-  --> $DIR/large_enum_variant.rs:6:5\n+  --> $DIR/large_enum_variant.rs:11:5\n    |\n LL |     A(i32),\n    |     ^^^^^^\n@@ -16,13 +16,13 @@ LL |     B(Box<[i32; 8000]>),\n    |       ^^^^^^^^^^^^^^^^\n \n error: large size difference between variants\n-  --> $DIR/large_enum_variant.rs:31:5\n+  --> $DIR/large_enum_variant.rs:36:5\n    |\n LL |     ContainingLargeEnum(LargeEnum),\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this variant is 32004 bytes\n    |\n note: and the second-largest variant is 8 bytes:\n-  --> $DIR/large_enum_variant.rs:30:5\n+  --> $DIR/large_enum_variant.rs:35:5\n    |\n LL |     VariantOk(i32, u32),\n    |     ^^^^^^^^^^^^^^^^^^^\n@@ -32,30 +32,30 @@ LL |     ContainingLargeEnum(Box<LargeEnum>),\n    |                         ^^^^^^^^^^^^^^\n \n error: large size difference between variants\n-  --> $DIR/large_enum_variant.rs:41:5\n+  --> $DIR/large_enum_variant.rs:46:5\n    |\n LL |     StructLikeLarge { x: [i32; 8000], y: i32 },\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this variant is 32004 bytes\n    |\n note: and the second-largest variant is 8 bytes:\n-  --> $DIR/large_enum_variant.rs:40:5\n+  --> $DIR/large_enum_variant.rs:45:5\n    |\n LL |     VariantOk(i32, u32),\n    |     ^^^^^^^^^^^^^^^^^^^\n help: consider boxing the large fields to reduce the total size of the enum\n-  --> $DIR/large_enum_variant.rs:41:5\n+  --> $DIR/large_enum_variant.rs:46:5\n    |\n LL |     StructLikeLarge { x: [i32; 8000], y: i32 },\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: large size difference between variants\n-  --> $DIR/large_enum_variant.rs:46:5\n+  --> $DIR/large_enum_variant.rs:51:5\n    |\n LL |     StructLikeLarge2 { x: [i32; 8000] },\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this variant is 32000 bytes\n    |\n note: and the second-largest variant is 8 bytes:\n-  --> $DIR/large_enum_variant.rs:45:5\n+  --> $DIR/large_enum_variant.rs:50:5\n    |\n LL |     VariantOk(i32, u32),\n    |     ^^^^^^^^^^^^^^^^^^^"}, {"sha": "00e037843f8c29e47afffe937d9ddc6052ee190c", "filename": "tests/ui/map_err.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmap_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmap_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_err.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -22,5 +22,9 @@ fn main() -> Result<(), Errors> {\n \n     println!(\"{:?}\", x.map_err(|_| Errors::Ignored));\n \n+    // Should not warn you because you explicitly ignore the parameter\n+    // using a named wildcard value\n+    println!(\"{:?}\", x.map_err(|_foo| Errors::Ignored));\n+\n     Ok(())\n }"}, {"sha": "37e87e64de28f1be6c43b29e5ac6f56f2e12afa3", "filename": "tests/ui/map_err.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmap_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmap_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_err.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,11 +1,11 @@\n-error: `map_err(|_|...` ignores the original error\n+error: `map_err(|_|...` wildcard pattern discards the original error\n   --> $DIR/map_err.rs:23:32\n    |\n LL |     println!(\"{:?}\", x.map_err(|_| Errors::Ignored));\n    |                                ^^^\n    |\n    = note: `-D clippy::map-err-ignore` implied by `-D warnings`\n-   = help: Consider wrapping the error in an enum variant\n+   = help: consider storing the original error as a source in the new error, or silence this warning using an ignored identifier (`.map_err(|_foo| ...`)\n \n error: aborting due to previous error\n "}, {"sha": "84981a52597327992a772f61ceff6ea23dcd59be", "filename": "tests/ui/match_expr_like_matches_macro.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_expr_like_matches_macro.fixed?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -39,7 +39,7 @@ fn main() {\n         B(i32),\n         C,\n         D,\n-    };\n+    }\n     let x = E::A(2);\n     {\n         // lint"}, {"sha": "94c7c3cadacf749799ba4a32510e28466e560001", "filename": "tests/ui/match_expr_like_matches_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmatch_expr_like_matches_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmatch_expr_like_matches_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_expr_like_matches_macro.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -51,7 +51,7 @@ fn main() {\n         B(i32),\n         C,\n         D,\n-    };\n+    }\n     let x = E::A(2);\n     {\n         // lint"}, {"sha": "526e94b10bd0ee460bf57dc993222fc47da3b2c8", "filename": "tests/ui/match_single_binding.fixed", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmatch_single_binding.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmatch_single_binding.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.fixed?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -87,4 +87,32 @@ fn main() {\n             unwrapped\n         })\n         .collect::<Vec<u8>>();\n+    // Ok\n+    let x = 1;\n+    match x {\n+        #[cfg(disabled_feature)]\n+        0 => println!(\"Disabled branch\"),\n+        _ => println!(\"Enabled branch\"),\n+    }\n+    // Lint\n+    let x = 1;\n+    let y = 1;\n+    println!(\"Single branch\");\n+    // Ok\n+    let x = 1;\n+    let y = 1;\n+    match match y {\n+        0 => 1,\n+        _ => 2,\n+    } {\n+        #[cfg(disabled_feature)]\n+        0 => println!(\"Array index start\"),\n+        _ => println!(\"Not an array index start\"),\n+    }\n+    // False negative\n+    let x = 1;\n+    match x {\n+        // =>\n+        _ => println!(\"Not an array index start\"),\n+    }\n }"}, {"sha": "6a2ca7c5e9340d132cea73a483a703888ea2ee69", "filename": "tests/ui/match_single_binding.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -99,4 +99,37 @@ fn main() {\n             unwrapped => unwrapped,\n         })\n         .collect::<Vec<u8>>();\n+    // Ok\n+    let x = 1;\n+    match x {\n+        #[cfg(disabled_feature)]\n+        0 => println!(\"Disabled branch\"),\n+        _ => println!(\"Enabled branch\"),\n+    }\n+    // Lint\n+    let x = 1;\n+    let y = 1;\n+    match match y {\n+        0 => 1,\n+        _ => 2,\n+    } {\n+        _ => println!(\"Single branch\"),\n+    }\n+    // Ok\n+    let x = 1;\n+    let y = 1;\n+    match match y {\n+        0 => 1,\n+        _ => 2,\n+    } {\n+        #[cfg(disabled_feature)]\n+        0 => println!(\"Array index start\"),\n+        _ => println!(\"Not an array index start\"),\n+    }\n+    // False negative\n+    let x = 1;\n+    match x {\n+        // =>\n+        _ => println!(\"Not an array index start\"),\n+    }\n }"}, {"sha": "cbbf5d29c02471a024d0ef8c072768030ed9d026", "filename": "tests/ui/match_single_binding.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmatch_single_binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmatch_single_binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -167,5 +167,16 @@ LL |             unwrapped\n LL |         })\n    |\n \n-error: aborting due to 11 previous errors\n+error: this match could be replaced by its body itself\n+  --> $DIR/match_single_binding.rs:112:5\n+   |\n+LL | /     match match y {\n+LL | |         0 => 1,\n+LL | |         _ => 2,\n+LL | |     } {\n+LL | |         _ => println!(\"Single branch\"),\n+LL | |     }\n+   | |_____^ help: consider using the match body instead: `println!(\"Single branch\");`\n+\n+error: aborting due to 12 previous errors\n "}, {"sha": "0f47f1cbc4026cb77c88eb4e70612e83ba70a60c", "filename": "tests/ui/min_rust_version_attr.rs", "status": "modified", "additions": 128, "deletions": 2, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmin_rust_version_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmin_rust_version_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmin_rust_version_attr.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -2,7 +2,7 @@\n #![feature(custom_inner_attributes)]\n #![clippy::msrv = \"1.0.0\"]\n \n-use std::ops::Deref;\n+use std::ops::{Deref, RangeFrom};\n \n fn option_as_ref_deref() {\n     let mut opt = Some(String::from(\"123\"));\n@@ -35,17 +35,143 @@ fn match_same_arms2() {\n     };\n }\n \n-fn manual_strip_msrv() {\n+pub fn manual_strip_msrv() {\n     let s = \"hello, world!\";\n     if s.starts_with(\"hello, \") {\n         assert_eq!(s[\"hello, \".len()..].to_uppercase(), \"WORLD!\");\n     }\n }\n \n+pub fn redundant_fieldnames() {\n+    let start = 0;\n+    let _ = RangeFrom { start: start };\n+}\n+\n+pub fn redundant_static_lifetime() {\n+    const VAR_ONE: &'static str = \"Test constant #1\";\n+}\n+\n+pub fn checked_conversion() {\n+    let value: i64 = 42;\n+    let _ = value <= (u32::max_value() as i64) && value >= 0;\n+    let _ = value <= (u32::MAX as i64) && value >= 0;\n+}\n+\n+pub struct FromOverInto(String);\n+\n+impl Into<FromOverInto> for String {\n+    fn into(self) -> FromOverInto {\n+        FromOverInto(self)\n+    }\n+}\n+\n+pub fn filter_map_next() {\n+    let a = [\"1\", \"lol\", \"3\", \"NaN\", \"5\"];\n+\n+    #[rustfmt::skip]\n+    let _: Option<u32> = vec![1, 2, 3, 4, 5, 6]\n+        .into_iter()\n+        .filter_map(|x| {\n+            if x == 2 {\n+                Some(x * 2)\n+            } else {\n+                None\n+            }\n+        })\n+        .next();\n+}\n+\n+#[allow(clippy::no_effect)]\n+#[allow(clippy::short_circuit_statement)]\n+#[allow(clippy::unnecessary_operation)]\n+pub fn manual_range_contains() {\n+    let x = 5;\n+    x >= 8 && x < 12;\n+}\n+\n+pub fn use_self() {\n+    struct Foo {}\n+\n+    impl Foo {\n+        fn new() -> Foo {\n+            Foo {}\n+        }\n+        fn test() -> Foo {\n+            Foo::new()\n+        }\n+    }\n+}\n+\n+fn replace_with_default() {\n+    let mut s = String::from(\"foo\");\n+    let _ = std::mem::replace(&mut s, String::default());\n+}\n+\n+fn map_unwrap_or() {\n+    let opt = Some(1);\n+\n+    // Check for `option.map(_).unwrap_or(_)` use.\n+    // Single line case.\n+    let _ = opt\n+        .map(|x| x + 1)\n+        // Should lint even though this call is on a separate line.\n+        .unwrap_or(0);\n+}\n+\n+// Could be const\n+fn missing_const_for_fn() -> i32 {\n+    1\n+}\n+\n fn main() {\n+    filter_map_next();\n+    checked_conversion();\n+    redundant_fieldnames();\n+    redundant_static_lifetime();\n     option_as_ref_deref();\n     match_like_matches();\n     match_same_arms();\n     match_same_arms2();\n     manual_strip_msrv();\n+    manual_range_contains();\n+    use_self();\n+    replace_with_default();\n+    map_unwrap_or();\n+    missing_const_for_fn();\n+}\n+\n+mod meets_msrv {\n+    #![feature(custom_inner_attributes)]\n+    #![clippy::msrv = \"1.45.0\"]\n+\n+    fn main() {\n+        let s = \"hello, world!\";\n+        if s.starts_with(\"hello, \") {\n+            assert_eq!(s[\"hello, \".len()..].to_uppercase(), \"WORLD!\");\n+        }\n+    }\n+}\n+\n+mod just_under_msrv {\n+    #![feature(custom_inner_attributes)]\n+    #![clippy::msrv = \"1.46.0\"]\n+\n+    fn main() {\n+        let s = \"hello, world!\";\n+        if s.starts_with(\"hello, \") {\n+            assert_eq!(s[\"hello, \".len()..].to_uppercase(), \"WORLD!\");\n+        }\n+    }\n+}\n+\n+mod just_above_msrv {\n+    #![feature(custom_inner_attributes)]\n+    #![clippy::msrv = \"1.44.0\"]\n+\n+    fn main() {\n+        let s = \"hello, world!\";\n+        if s.starts_with(\"hello, \") {\n+            assert_eq!(s[\"hello, \".len()..].to_uppercase(), \"WORLD!\");\n+        }\n+    }\n }"}, {"sha": "e3e3b335cbe165721ed9ea5260dbe9f71dcd2bb4", "filename": "tests/ui/min_rust_version_attr.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmin_rust_version_attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmin_rust_version_attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmin_rust_version_attr.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,37 @@\n+error: stripping a prefix manually\n+  --> $DIR/min_rust_version_attr.rs:150:24\n+   |\n+LL |             assert_eq!(s[\"hello, \".len()..].to_uppercase(), \"WORLD!\");\n+   |                        ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::manual-strip` implied by `-D warnings`\n+note: the prefix was tested here\n+  --> $DIR/min_rust_version_attr.rs:149:9\n+   |\n+LL |         if s.starts_with(\"hello, \") {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using the `strip_prefix` method\n+   |\n+LL |         if let Some(<stripped>) = s.strip_prefix(\"hello, \") {\n+LL |             assert_eq!(<stripped>.to_uppercase(), \"WORLD!\");\n+   |\n+\n+error: stripping a prefix manually\n+  --> $DIR/min_rust_version_attr.rs:162:24\n+   |\n+LL |             assert_eq!(s[\"hello, \".len()..].to_uppercase(), \"WORLD!\");\n+   |                        ^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the prefix was tested here\n+  --> $DIR/min_rust_version_attr.rs:161:9\n+   |\n+LL |         if s.starts_with(\"hello, \") {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using the `strip_prefix` method\n+   |\n+LL |         if let Some(<stripped>) = s.strip_prefix(\"hello, \") {\n+LL |             assert_eq!(<stripped>.to_uppercase(), \"WORLD!\");\n+   |\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "98fffe1e3512b9c41750f598f0787ce56329eade", "filename": "tests/ui/min_rust_version_no_patch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmin_rust_version_no_patch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmin_rust_version_no_patch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmin_rust_version_no_patch.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,6 +1,6 @@\n #![allow(clippy::redundant_clone)]\n #![feature(custom_inner_attributes)]\n-#![clippy::msrv = \"^1.0\"]\n+#![clippy::msrv = \"1.0\"]\n \n fn manual_strip_msrv() {\n     let s = \"hello, world!\";"}, {"sha": "d56c5cc4c3ae25b84514b8742bbfc76844cdc90e", "filename": "tests/ui/missing-doc-crate-missing.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmissing-doc-crate-missing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmissing-doc-crate-missing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing-doc-crate-missing.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,4 +1,4 @@\n-error: missing documentation for crate\n+error: missing documentation for the crate\n   --> $DIR/missing-doc-crate-missing.rs:1:1\n    |\n LL | / #![warn(clippy::missing_docs_in_private_items)]"}, {"sha": "7e10404ca005e9fa259b08dc69e114ed4e7c2c3a", "filename": "tests/ui/missing-doc-impl.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmissing-doc-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmissing-doc-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing-doc-impl.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -51,13 +51,13 @@ LL | |     fn foo_with_impl(&self) {}\n LL | | }\n    | |_^\n \n-error: missing documentation for a trait method\n+error: missing documentation for an associated function\n   --> $DIR/missing-doc-impl.rs:39:5\n    |\n LL |     fn foo(&self);\n    |     ^^^^^^^^^^^^^^\n \n-error: missing documentation for a trait method\n+error: missing documentation for an associated function\n   --> $DIR/missing-doc-impl.rs:40:5\n    |\n LL |     fn foo_with_impl(&self) {}\n@@ -75,25 +75,25 @@ error: missing documentation for an associated type\n LL |     type AssociatedTypeDef = Self;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: missing documentation for a method\n+error: missing documentation for an associated function\n   --> $DIR/missing-doc-impl.rs:62:5\n    |\n LL |     pub fn foo() {}\n    |     ^^^^^^^^^^^^^^^\n \n-error: missing documentation for a method\n+error: missing documentation for an associated function\n   --> $DIR/missing-doc-impl.rs:63:5\n    |\n LL |     fn bar() {}\n    |     ^^^^^^^^^^^\n \n-error: missing documentation for a method\n+error: missing documentation for an associated function\n   --> $DIR/missing-doc-impl.rs:67:5\n    |\n LL |     pub fn foo() {}\n    |     ^^^^^^^^^^^^^^^\n \n-error: missing documentation for a method\n+error: missing documentation for an associated function\n   --> $DIR/missing-doc-impl.rs:70:5\n    |\n LL |     fn foo2() {}"}, {"sha": "678a312f66e53af9ed72aeb8765c9db6cbbb53e1", "filename": "tests/ui/modulo_one.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmodulo_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmodulo_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmodulo_one.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -2,13 +2,22 @@\n #![allow(clippy::no_effect, clippy::unnecessary_operation)]\n \n static STATIC_ONE: usize = 2 - 1;\n+static STATIC_NEG_ONE: i64 = 1 - 2;\n \n fn main() {\n     10 % 1;\n+    10 % -1;\n     10 % 2;\n+    i32::MIN % (-1); // also caught by rustc\n \n     const ONE: u32 = 1 * 1;\n+    const NEG_ONE: i64 = 1 - 2;\n+    const INT_MIN: i64 = i64::MIN;\n \n     2 % ONE;\n-    5 % STATIC_ONE;\n+    5 % STATIC_ONE; // NOT caught by lint\n+    2 % NEG_ONE;\n+    5 % STATIC_NEG_ONE; // NOT caught by lint\n+    INT_MIN % NEG_ONE; // also caught by rustc\n+    INT_MIN % STATIC_NEG_ONE; // ONLY caught by rustc\n }"}, {"sha": "2b2c699733852dd464507708dc41ad79a15b92eb", "filename": "tests/ui/modulo_one.stderr", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmodulo_one.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fmodulo_one.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmodulo_one.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,30 +1,74 @@\n+error: this arithmetic operation will overflow\n+  --> $DIR/modulo_one.rs:11:5\n+   |\n+LL |     i32::MIN % (-1); // also caught by rustc\n+   |     ^^^^^^^^^^^^^^^ attempt to compute the remainder of `i32::MIN % -1_i32`, which would overflow\n+   |\n+   = note: `#[deny(arithmetic_overflow)]` on by default\n+\n+error: this arithmetic operation will overflow\n+  --> $DIR/modulo_one.rs:21:5\n+   |\n+LL |     INT_MIN % NEG_ONE; // also caught by rustc\n+   |     ^^^^^^^^^^^^^^^^^ attempt to compute the remainder of `i64::MIN % -1_i64`, which would overflow\n+\n+error: this arithmetic operation will overflow\n+  --> $DIR/modulo_one.rs:22:5\n+   |\n+LL |     INT_MIN % STATIC_NEG_ONE; // ONLY caught by rustc\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ attempt to compute the remainder of `i64::MIN % -1_i64`, which would overflow\n+\n error: any number modulo 1 will be 0\n-  --> $DIR/modulo_one.rs:7:5\n+  --> $DIR/modulo_one.rs:8:5\n    |\n LL |     10 % 1;\n    |     ^^^^^^\n    |\n    = note: `-D clippy::modulo-one` implied by `-D warnings`\n \n+error: any number modulo -1 will panic/overflow or result in 0\n+  --> $DIR/modulo_one.rs:9:5\n+   |\n+LL |     10 % -1;\n+   |     ^^^^^^^\n+\n+error: any number modulo -1 will panic/overflow or result in 0\n+  --> $DIR/modulo_one.rs:11:5\n+   |\n+LL |     i32::MIN % (-1); // also caught by rustc\n+   |     ^^^^^^^^^^^^^^^\n+\n error: the operation is ineffective. Consider reducing it to `1`\n-  --> $DIR/modulo_one.rs:10:22\n+  --> $DIR/modulo_one.rs:13:22\n    |\n LL |     const ONE: u32 = 1 * 1;\n    |                      ^^^^^\n    |\n    = note: `-D clippy::identity-op` implied by `-D warnings`\n \n error: the operation is ineffective. Consider reducing it to `1`\n-  --> $DIR/modulo_one.rs:10:22\n+  --> $DIR/modulo_one.rs:13:22\n    |\n LL |     const ONE: u32 = 1 * 1;\n    |                      ^^^^^\n \n error: any number modulo 1 will be 0\n-  --> $DIR/modulo_one.rs:12:5\n+  --> $DIR/modulo_one.rs:17:5\n    |\n LL |     2 % ONE;\n    |     ^^^^^^^\n \n-error: aborting due to 4 previous errors\n+error: any number modulo -1 will panic/overflow or result in 0\n+  --> $DIR/modulo_one.rs:19:5\n+   |\n+LL |     2 % NEG_ONE;\n+   |     ^^^^^^^^^^^\n+\n+error: any number modulo -1 will panic/overflow or result in 0\n+  --> $DIR/modulo_one.rs:21:5\n+   |\n+LL |     INT_MIN % NEG_ONE; // also caught by rustc\n+   |     ^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 11 previous errors\n "}, {"sha": "bea4b41b803d09b0230619010d4aa390692ef673", "filename": "tests/ui/needless_borrow.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fneedless_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fneedless_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,4 +1,4 @@\n-error: this expression borrows a reference that is immediately dereferenced by the compiler\n+error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:14:15\n    |\n LL |     let c = x(&&a);\n@@ -12,7 +12,7 @@ error: this pattern creates a reference to a reference\n LL |     if let Some(ref cake) = Some(&5) {}\n    |                 ^^^^^^^^ help: change this to: `cake`\n \n-error: this expression borrows a reference that is immediately dereferenced by the compiler\n+error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:28:15\n    |\n LL |         46 => &&a,"}, {"sha": "83e9bbaa3af43dc1bdc1f8c60f77130b42c9bcb5", "filename": "tests/ui/needless_doc_main.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fneedless_doc_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fneedless_doc_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_doc_main.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -10,7 +10,7 @@\n /// ```\n ///\n /// With an explicit return type it should lint too\n-/// ```\n+/// ```edition2015\n /// fn main() -> () {\n ///     unimplemented!();\n /// }\n@@ -39,7 +39,7 @@ fn bad_doctests() {}\n /// ```\n ///\n /// This shouldn't lint either, because main is async:\n-/// ```\n+/// ```edition2018\n /// async fn main() {\n ///     assert_eq!(42, ANSWER);\n /// }\n@@ -128,6 +128,12 @@ fn bad_doctests() {}\n /// ```\n fn no_false_positives() {}\n \n+/// Yields a parse error when interpreted as rust code:\n+/// ```\n+/// r#\"hi\"\n+/// ```\n+fn issue_6022() {}\n+\n fn main() {\n     bad_doctests();\n     no_false_positives();"}, {"sha": "70218f3f041d8675cbb8c5d74800e66462f904ed", "filename": "tests/ui/needless_question_mark.fixed", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fneedless_question_mark.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fneedless_question_mark.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_question_mark.fixed?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,163 @@\n+// run-rustfix\n+\n+#![warn(clippy::needless_question_mark)]\n+#![allow(clippy::needless_return, clippy::unnecessary_unwrap, dead_code, unused_must_use)]\n+#![feature(custom_inner_attributes)]\n+\n+struct TO {\n+    magic: Option<usize>,\n+}\n+\n+struct TR {\n+    magic: Result<usize, bool>,\n+}\n+\n+fn simple_option_bad1(to: TO) -> Option<usize> {\n+    // return as a statement\n+    return to.magic;\n+}\n+\n+// formatting will add a semi-colon, which would make\n+// this identical to the test case above\n+#[rustfmt::skip]\n+fn simple_option_bad2(to: TO) -> Option<usize> {\n+    // return as an expression\n+    return to.magic\n+}\n+\n+fn simple_option_bad3(to: TO) -> Option<usize> {\n+    // block value \"return\"\n+    to.magic\n+}\n+\n+fn simple_option_bad4(to: Option<TO>) -> Option<usize> {\n+    // single line closure\n+    to.and_then(|t| t.magic)\n+}\n+\n+// formatting this will remove the block brackets, making\n+// this test identical to the one above\n+#[rustfmt::skip]\n+fn simple_option_bad5(to: Option<TO>) -> Option<usize> {\n+    // closure with body\n+    to.and_then(|t| {\n+        t.magic\n+    })\n+}\n+\n+fn simple_result_bad1(tr: TR) -> Result<usize, bool> {\n+    return tr.magic;\n+}\n+\n+// formatting will add a semi-colon, which would make\n+// this identical to the test case above\n+#[rustfmt::skip]\n+fn simple_result_bad2(tr: TR) -> Result<usize, bool> {\n+    return tr.magic\n+}\n+\n+fn simple_result_bad3(tr: TR) -> Result<usize, bool> {\n+    tr.magic\n+}\n+\n+fn simple_result_bad4(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    tr.and_then(|t| t.magic)\n+}\n+\n+// formatting this will remove the block brackets, making\n+// this test identical to the one above\n+#[rustfmt::skip]\n+fn simple_result_bad5(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    tr.and_then(|t| {\n+        t.magic\n+    })\n+}\n+\n+fn also_bad(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    if tr.is_ok() {\n+        let t = tr.unwrap();\n+        return t.magic;\n+    }\n+    Err(false)\n+}\n+\n+fn false_positive_test<U, T>(x: Result<(), U>) -> Result<(), T>\n+where\n+    T: From<U>,\n+{\n+    Ok(x?)\n+}\n+\n+fn main() {}\n+\n+mod question_mark_none {\n+    #![clippy::msrv = \"1.12.0\"]\n+    fn needless_question_mark_option() -> Option<usize> {\n+        struct TO {\n+            magic: Option<usize>,\n+        }\n+        let to = TO { magic: None };\n+        Some(to.magic?) // should not be triggered\n+    }\n+\n+    fn needless_question_mark_result() -> Result<usize, bool> {\n+        struct TO {\n+            magic: Result<usize, bool>,\n+        }\n+        let to = TO { magic: Ok(1_usize) };\n+        Ok(to.magic?) // should not be triggered\n+    }\n+\n+    fn main() {\n+        needless_question_mark_option();\n+        needless_question_mark_result();\n+    }\n+}\n+\n+mod question_mark_result {\n+    #![clippy::msrv = \"1.21.0\"]\n+    fn needless_question_mark_option() -> Option<usize> {\n+        struct TO {\n+            magic: Option<usize>,\n+        }\n+        let to = TO { magic: None };\n+        Some(to.magic?) // should not be triggered\n+    }\n+\n+    fn needless_question_mark_result() -> Result<usize, bool> {\n+        struct TO {\n+            magic: Result<usize, bool>,\n+        }\n+        let to = TO { magic: Ok(1_usize) };\n+        to.magic // should be triggered\n+    }\n+\n+    fn main() {\n+        needless_question_mark_option();\n+        needless_question_mark_result();\n+    }\n+}\n+\n+mod question_mark_both {\n+    #![clippy::msrv = \"1.22.0\"]\n+    fn needless_question_mark_option() -> Option<usize> {\n+        struct TO {\n+            magic: Option<usize>,\n+        }\n+        let to = TO { magic: None };\n+        to.magic // should be triggered\n+    }\n+\n+    fn needless_question_mark_result() -> Result<usize, bool> {\n+        struct TO {\n+            magic: Result<usize, bool>,\n+        }\n+        let to = TO { magic: Ok(1_usize) };\n+        to.magic // should be triggered\n+    }\n+\n+    fn main() {\n+        needless_question_mark_option();\n+        needless_question_mark_result();\n+    }\n+}"}, {"sha": "60ac2c8d72eac920afe0a46b4253f8ac5594b316", "filename": "tests/ui/needless_question_mark.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_question_mark.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,163 @@\n+// run-rustfix\n+\n+#![warn(clippy::needless_question_mark)]\n+#![allow(clippy::needless_return, clippy::unnecessary_unwrap, dead_code, unused_must_use)]\n+#![feature(custom_inner_attributes)]\n+\n+struct TO {\n+    magic: Option<usize>,\n+}\n+\n+struct TR {\n+    magic: Result<usize, bool>,\n+}\n+\n+fn simple_option_bad1(to: TO) -> Option<usize> {\n+    // return as a statement\n+    return Some(to.magic?);\n+}\n+\n+// formatting will add a semi-colon, which would make\n+// this identical to the test case above\n+#[rustfmt::skip]\n+fn simple_option_bad2(to: TO) -> Option<usize> {\n+    // return as an expression\n+    return Some(to.magic?)\n+}\n+\n+fn simple_option_bad3(to: TO) -> Option<usize> {\n+    // block value \"return\"\n+    Some(to.magic?)\n+}\n+\n+fn simple_option_bad4(to: Option<TO>) -> Option<usize> {\n+    // single line closure\n+    to.and_then(|t| Some(t.magic?))\n+}\n+\n+// formatting this will remove the block brackets, making\n+// this test identical to the one above\n+#[rustfmt::skip]\n+fn simple_option_bad5(to: Option<TO>) -> Option<usize> {\n+    // closure with body\n+    to.and_then(|t| {\n+        Some(t.magic?)\n+    })\n+}\n+\n+fn simple_result_bad1(tr: TR) -> Result<usize, bool> {\n+    return Ok(tr.magic?);\n+}\n+\n+// formatting will add a semi-colon, which would make\n+// this identical to the test case above\n+#[rustfmt::skip]\n+fn simple_result_bad2(tr: TR) -> Result<usize, bool> {\n+    return Ok(tr.magic?)\n+}\n+\n+fn simple_result_bad3(tr: TR) -> Result<usize, bool> {\n+    Ok(tr.magic?)\n+}\n+\n+fn simple_result_bad4(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    tr.and_then(|t| Ok(t.magic?))\n+}\n+\n+// formatting this will remove the block brackets, making\n+// this test identical to the one above\n+#[rustfmt::skip]\n+fn simple_result_bad5(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    tr.and_then(|t| {\n+        Ok(t.magic?)\n+    })\n+}\n+\n+fn also_bad(tr: Result<TR, bool>) -> Result<usize, bool> {\n+    if tr.is_ok() {\n+        let t = tr.unwrap();\n+        return Ok(t.magic?);\n+    }\n+    Err(false)\n+}\n+\n+fn false_positive_test<U, T>(x: Result<(), U>) -> Result<(), T>\n+where\n+    T: From<U>,\n+{\n+    Ok(x?)\n+}\n+\n+fn main() {}\n+\n+mod question_mark_none {\n+    #![clippy::msrv = \"1.12.0\"]\n+    fn needless_question_mark_option() -> Option<usize> {\n+        struct TO {\n+            magic: Option<usize>,\n+        }\n+        let to = TO { magic: None };\n+        Some(to.magic?) // should not be triggered\n+    }\n+\n+    fn needless_question_mark_result() -> Result<usize, bool> {\n+        struct TO {\n+            magic: Result<usize, bool>,\n+        }\n+        let to = TO { magic: Ok(1_usize) };\n+        Ok(to.magic?) // should not be triggered\n+    }\n+\n+    fn main() {\n+        needless_question_mark_option();\n+        needless_question_mark_result();\n+    }\n+}\n+\n+mod question_mark_result {\n+    #![clippy::msrv = \"1.21.0\"]\n+    fn needless_question_mark_option() -> Option<usize> {\n+        struct TO {\n+            magic: Option<usize>,\n+        }\n+        let to = TO { magic: None };\n+        Some(to.magic?) // should not be triggered\n+    }\n+\n+    fn needless_question_mark_result() -> Result<usize, bool> {\n+        struct TO {\n+            magic: Result<usize, bool>,\n+        }\n+        let to = TO { magic: Ok(1_usize) };\n+        Ok(to.magic?) // should be triggered\n+    }\n+\n+    fn main() {\n+        needless_question_mark_option();\n+        needless_question_mark_result();\n+    }\n+}\n+\n+mod question_mark_both {\n+    #![clippy::msrv = \"1.22.0\"]\n+    fn needless_question_mark_option() -> Option<usize> {\n+        struct TO {\n+            magic: Option<usize>,\n+        }\n+        let to = TO { magic: None };\n+        Some(to.magic?) // should be triggered\n+    }\n+\n+    fn needless_question_mark_result() -> Result<usize, bool> {\n+        struct TO {\n+            magic: Result<usize, bool>,\n+        }\n+        let to = TO { magic: Ok(1_usize) };\n+        Ok(to.magic?) // should be triggered\n+    }\n+\n+    fn main() {\n+        needless_question_mark_option();\n+        needless_question_mark_result();\n+    }\n+}"}, {"sha": "b4eb21882ece95a30fa14fe7493c991df2556887", "filename": "tests/ui/needless_question_mark.stderr", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fneedless_question_mark.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fneedless_question_mark.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_question_mark.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,88 @@\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:17:12\n+   |\n+LL |     return Some(to.magic?);\n+   |            ^^^^^^^^^^^^^^^ help: try: `to.magic`\n+   |\n+   = note: `-D clippy::needless-question-mark` implied by `-D warnings`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:25:12\n+   |\n+LL |     return Some(to.magic?)\n+   |            ^^^^^^^^^^^^^^^ help: try: `to.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:30:5\n+   |\n+LL |     Some(to.magic?)\n+   |     ^^^^^^^^^^^^^^^ help: try: `to.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:35:21\n+   |\n+LL |     to.and_then(|t| Some(t.magic?))\n+   |                     ^^^^^^^^^^^^^^ help: try: `t.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:44:9\n+   |\n+LL |         Some(t.magic?)\n+   |         ^^^^^^^^^^^^^^ help: try: `t.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:49:12\n+   |\n+LL |     return Ok(tr.magic?);\n+   |            ^^^^^^^^^^^^^ help: try: `tr.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:56:12\n+   |\n+LL |     return Ok(tr.magic?)\n+   |            ^^^^^^^^^^^^^ help: try: `tr.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:60:5\n+   |\n+LL |     Ok(tr.magic?)\n+   |     ^^^^^^^^^^^^^ help: try: `tr.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:64:21\n+   |\n+LL |     tr.and_then(|t| Ok(t.magic?))\n+   |                     ^^^^^^^^^^^^ help: try: `t.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:72:9\n+   |\n+LL |         Ok(t.magic?)\n+   |         ^^^^^^^^^^^^ help: try: `t.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:79:16\n+   |\n+LL |         return Ok(t.magic?);\n+   |                ^^^^^^^^^^^^ help: try: `t.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:132:9\n+   |\n+LL |         Ok(to.magic?) // should be triggered\n+   |         ^^^^^^^^^^^^^ help: try: `to.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:148:9\n+   |\n+LL |         Some(to.magic?) // should be triggered\n+   |         ^^^^^^^^^^^^^^^ help: try: `to.magic`\n+\n+error: Question mark operator is useless here\n+  --> $DIR/needless_question_mark.rs:156:9\n+   |\n+LL |         Ok(to.magic?) // should be triggered\n+   |         ^^^^^^^^^^^^^ help: try: `to.magic`\n+\n+error: aborting due to 14 previous errors\n+"}, {"sha": "f137e8ecae935a69765127624d3ac5a1c6ac28cd", "filename": "tests/ui/needless_return.fixed", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fneedless_return.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fneedless_return.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.fixed?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -86,6 +86,34 @@ fn borrows_but_not_last(value: bool) -> String {\n     }\n }\n \n+macro_rules! needed_return {\n+    ($e:expr) => {\n+        if $e > 3 {\n+            return;\n+        }\n+    };\n+}\n+\n+fn test_return_in_macro() {\n+    // This will return and the macro below won't be executed. Removing the `return` from the macro\n+    // will change semantics.\n+    needed_return!(10);\n+    needed_return!(0);\n+}\n+\n+mod issue6501 {\n+    fn foo(bar: Result<(), ()>) {\n+        bar.unwrap_or_else(|_| {})\n+    }\n+\n+    fn test_closure() {\n+        let _ = || {\n+            \n+        };\n+        let _ = || {};\n+    }\n+}\n+\n fn main() {\n     let _ = test_end_of_fn();\n     let _ = test_no_semicolon();"}, {"sha": "d754e4d37a844fcbf6fdfafaaad5ac8632e23a21", "filename": "tests/ui/needless_return.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fneedless_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fneedless_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -86,6 +86,34 @@ fn borrows_but_not_last(value: bool) -> String {\n     }\n }\n \n+macro_rules! needed_return {\n+    ($e:expr) => {\n+        if $e > 3 {\n+            return;\n+        }\n+    };\n+}\n+\n+fn test_return_in_macro() {\n+    // This will return and the macro below won't be executed. Removing the `return` from the macro\n+    // will change semantics.\n+    needed_return!(10);\n+    needed_return!(0);\n+}\n+\n+mod issue6501 {\n+    fn foo(bar: Result<(), ()>) {\n+        bar.unwrap_or_else(|_| return)\n+    }\n+\n+    fn test_closure() {\n+        let _ = || {\n+            return;\n+        };\n+        let _ = || return;\n+    }\n+}\n+\n fn main() {\n     let _ = test_end_of_fn();\n     let _ = test_no_semicolon();"}, {"sha": "d1240e161c07e7de80a2bac1432c4a6fdafe8bab", "filename": "tests/ui/needless_return.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fneedless_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fneedless_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -84,5 +84,23 @@ error: unneeded `return` statement\n LL |         return String::new();\n    |         ^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::new()`\n \n-error: aborting due to 14 previous errors\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:106:32\n+   |\n+LL |         bar.unwrap_or_else(|_| return)\n+   |                                ^^^^^^ help: replace `return` with an empty block: `{}`\n+\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:111:13\n+   |\n+LL |             return;\n+   |             ^^^^^^^ help: remove `return`\n+\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:113:20\n+   |\n+LL |         let _ = || return;\n+   |                    ^^^^^^ help: replace `return` with an empty block: `{}`\n+\n+error: aborting due to 17 previous errors\n "}, {"sha": "b93ff048a62f21de1f957e5c1df595552dae851d", "filename": "tests/ui/needless_update.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_update.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -6,9 +6,20 @@ struct S {\n     pub b: i32,\n }\n \n+#[non_exhaustive]\n+struct T {\n+    pub x: i32,\n+    pub y: i32,\n+}\n+\n fn main() {\n     let base = S { a: 0, b: 0 };\n     S { ..base }; // no error\n     S { a: 1, ..base }; // no error\n     S { a: 1, b: 1, ..base };\n+\n+    let base = T { x: 0, y: 0 };\n+    T { ..base }; // no error\n+    T { x: 1, ..base }; // no error\n+    T { x: 1, y: 1, ..base }; // no error\n }"}, {"sha": "b154b3b306ddcc1fab314d1d11ef898865015f7c", "filename": "tests/ui/needless_update.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fneedless_update.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fneedless_update.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_update.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,5 +1,5 @@\n error: struct update has no effect, all the fields in the struct have already been specified\n-  --> $DIR/needless_update.rs:13:23\n+  --> $DIR/needless_update.rs:19:23\n    |\n LL |     S { a: 1, b: 1, ..base };\n    |                       ^^^^"}, {"sha": "eb744b0c198fabf28dc94e0b387d4d09da513c57", "filename": "tests/ui/panic_in_result_fn.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fpanic_in_result_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fpanic_in_result_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanic_in_result_fn.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,4 +1,4 @@\n-error: used `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` in a function that returns `Result`\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:7:5\n    |\n LL | /     fn result_with_panic() -> Result<bool, String> // should emit lint\n@@ -8,15 +8,15 @@ LL | |     }\n    | |_____^\n    |\n    = note: `-D clippy::panic-in-result-fn` implied by `-D warnings`\n-   = help: `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n note: return Err() instead of panicking\n   --> $DIR/panic_in_result_fn.rs:9:9\n    |\n LL |         panic!(\"error\");\n    |         ^^^^^^^^^^^^^^^^\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: used `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` in a function that returns `Result`\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:12:5\n    |\n LL | /     fn result_with_unimplemented() -> Result<bool, String> // should emit lint\n@@ -25,15 +25,15 @@ LL | |         unimplemented!();\n LL | |     }\n    | |_____^\n    |\n-   = help: `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n note: return Err() instead of panicking\n   --> $DIR/panic_in_result_fn.rs:14:9\n    |\n LL |         unimplemented!();\n    |         ^^^^^^^^^^^^^^^^^\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: used `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` in a function that returns `Result`\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:17:5\n    |\n LL | /     fn result_with_unreachable() -> Result<bool, String> // should emit lint\n@@ -42,15 +42,15 @@ LL | |         unreachable!();\n LL | |     }\n    | |_____^\n    |\n-   = help: `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n note: return Err() instead of panicking\n   --> $DIR/panic_in_result_fn.rs:19:9\n    |\n LL |         unreachable!();\n    |         ^^^^^^^^^^^^^^^\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: used `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` in a function that returns `Result`\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:22:5\n    |\n LL | /     fn result_with_todo() -> Result<bool, String> // should emit lint\n@@ -59,15 +59,15 @@ LL | |         todo!(\"Finish this\");\n LL | |     }\n    | |_____^\n    |\n-   = help: `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n note: return Err() instead of panicking\n   --> $DIR/panic_in_result_fn.rs:24:9\n    |\n LL |         todo!(\"Finish this\");\n    |         ^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: used `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` in a function that returns `Result`\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:53:1\n    |\n LL | / fn function_result_with_panic() -> Result<bool, String> // should emit lint\n@@ -76,15 +76,15 @@ LL | |     panic!(\"error\");\n LL | | }\n    | |_^\n    |\n-   = help: `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n note: return Err() instead of panicking\n   --> $DIR/panic_in_result_fn.rs:55:5\n    |\n LL |     panic!(\"error\");\n    |     ^^^^^^^^^^^^^^^^\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: used `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` in a function that returns `Result`\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:68:1\n    |\n LL | / fn main() -> Result<(), String> {\n@@ -93,7 +93,7 @@ LL | |     Ok(())\n LL | | }\n    | |_^\n    |\n-   = help: `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n note: return Err() instead of panicking\n   --> $DIR/panic_in_result_fn.rs:69:5\n    |"}, {"sha": "ffdf8288adc709d1808072d082e3325b35c3821f", "filename": "tests/ui/panic_in_result_fn_assertions.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fpanic_in_result_fn_assertions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fpanic_in_result_fn_assertions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanic_in_result_fn_assertions.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,48 @@\n+#![warn(clippy::panic_in_result_fn)]\n+#![allow(clippy::unnecessary_wraps)]\n+\n+struct A;\n+\n+impl A {\n+    fn result_with_assert_with_message(x: i32) -> Result<bool, String> // should emit lint\n+    {\n+        assert!(x == 5, \"wrong argument\");\n+        Ok(true)\n+    }\n+\n+    fn result_with_assert_eq(x: i32) -> Result<bool, String> // should emit lint\n+    {\n+        assert_eq!(x, 5);\n+        Ok(true)\n+    }\n+\n+    fn result_with_assert_ne(x: i32) -> Result<bool, String> // should emit lint\n+    {\n+        assert_ne!(x, 1);\n+        Ok(true)\n+    }\n+\n+    fn other_with_assert_with_message(x: i32) // should not emit lint\n+    {\n+        assert!(x == 5, \"wrong argument\");\n+    }\n+\n+    fn other_with_assert_eq(x: i32) // should not emit lint\n+    {\n+        assert_eq!(x, 5);\n+    }\n+\n+    fn other_with_assert_ne(x: i32) // should not emit lint\n+    {\n+        assert_ne!(x, 1);\n+    }\n+\n+    fn result_without_banned_functions() -> Result<bool, String> // should not emit lint\n+    {\n+        let assert = \"assert!\";\n+        println!(\"No {}\", assert);\n+        Ok(true)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a17f043737d4e009fae59b46d62399e6c8ae3a5d", "filename": "tests/ui/panic_in_result_fn_assertions.stderr", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fpanic_in_result_fn_assertions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fpanic_in_result_fn_assertions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanic_in_result_fn_assertions.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,57 @@\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n+  --> $DIR/panic_in_result_fn_assertions.rs:7:5\n+   |\n+LL | /     fn result_with_assert_with_message(x: i32) -> Result<bool, String> // should emit lint\n+LL | |     {\n+LL | |         assert!(x == 5, \"wrong argument\");\n+LL | |         Ok(true)\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::panic-in-result-fn` implied by `-D warnings`\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+note: return Err() instead of panicking\n+  --> $DIR/panic_in_result_fn_assertions.rs:9:9\n+   |\n+LL |         assert!(x == 5, \"wrong argument\");\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n+  --> $DIR/panic_in_result_fn_assertions.rs:13:5\n+   |\n+LL | /     fn result_with_assert_eq(x: i32) -> Result<bool, String> // should emit lint\n+LL | |     {\n+LL | |         assert_eq!(x, 5);\n+LL | |         Ok(true)\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+note: return Err() instead of panicking\n+  --> $DIR/panic_in_result_fn_assertions.rs:15:9\n+   |\n+LL |         assert_eq!(x, 5);\n+   |         ^^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n+  --> $DIR/panic_in_result_fn_assertions.rs:19:5\n+   |\n+LL | /     fn result_with_assert_ne(x: i32) -> Result<bool, String> // should emit lint\n+LL | |     {\n+LL | |         assert_ne!(x, 1);\n+LL | |         Ok(true)\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+note: return Err() instead of panicking\n+  --> $DIR/panic_in_result_fn_assertions.rs:21:9\n+   |\n+LL |         assert_ne!(x, 1);\n+   |         ^^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "b60c79f97c865935a72e954ad765a6680e5eb4d2", "filename": "tests/ui/panic_in_result_fn_debug_assertions.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fpanic_in_result_fn_debug_assertions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fpanic_in_result_fn_debug_assertions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanic_in_result_fn_debug_assertions.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,48 @@\n+#![warn(clippy::panic_in_result_fn)]\n+#![allow(clippy::unnecessary_wraps)]\n+\n+struct A;\n+\n+impl A {\n+    fn result_with_debug_assert_with_message(x: i32) -> Result<bool, String> // should emit lint\n+    {\n+        debug_assert!(x == 5, \"wrong argument\");\n+        Ok(true)\n+    }\n+\n+    fn result_with_debug_assert_eq(x: i32) -> Result<bool, String> // should emit lint\n+    {\n+        debug_assert_eq!(x, 5);\n+        Ok(true)\n+    }\n+\n+    fn result_with_debug_assert_ne(x: i32) -> Result<bool, String> // should emit lint\n+    {\n+        debug_assert_ne!(x, 1);\n+        Ok(true)\n+    }\n+\n+    fn other_with_debug_assert_with_message(x: i32) // should not emit lint\n+    {\n+        debug_assert!(x == 5, \"wrong argument\");\n+    }\n+\n+    fn other_with_debug_assert_eq(x: i32) // should not emit lint\n+    {\n+        debug_assert_eq!(x, 5);\n+    }\n+\n+    fn other_with_debug_assert_ne(x: i32) // should not emit lint\n+    {\n+        debug_assert_ne!(x, 1);\n+    }\n+\n+    fn result_without_banned_functions() -> Result<bool, String> // should not emit lint\n+    {\n+        let debug_assert = \"debug_assert!\";\n+        println!(\"No {}\", debug_assert);\n+        Ok(true)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ec18e89698c56d6d2cc59a158adcdb3a0053e166", "filename": "tests/ui/panic_in_result_fn_debug_assertions.stderr", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fpanic_in_result_fn_debug_assertions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fpanic_in_result_fn_debug_assertions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanic_in_result_fn_debug_assertions.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,57 @@\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n+  --> $DIR/panic_in_result_fn_debug_assertions.rs:7:5\n+   |\n+LL | /     fn result_with_debug_assert_with_message(x: i32) -> Result<bool, String> // should emit lint\n+LL | |     {\n+LL | |         debug_assert!(x == 5, \"wrong argument\");\n+LL | |         Ok(true)\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::panic-in-result-fn` implied by `-D warnings`\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+note: return Err() instead of panicking\n+  --> $DIR/panic_in_result_fn_debug_assertions.rs:9:9\n+   |\n+LL |         debug_assert!(x == 5, \"wrong argument\");\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n+  --> $DIR/panic_in_result_fn_debug_assertions.rs:13:5\n+   |\n+LL | /     fn result_with_debug_assert_eq(x: i32) -> Result<bool, String> // should emit lint\n+LL | |     {\n+LL | |         debug_assert_eq!(x, 5);\n+LL | |         Ok(true)\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+note: return Err() instead of panicking\n+  --> $DIR/panic_in_result_fn_debug_assertions.rs:15:9\n+   |\n+LL |         debug_assert_eq!(x, 5);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n+  --> $DIR/panic_in_result_fn_debug_assertions.rs:19:5\n+   |\n+LL | /     fn result_with_debug_assert_ne(x: i32) -> Result<bool, String> // should emit lint\n+LL | |     {\n+LL | |         debug_assert_ne!(x, 1);\n+LL | |         Ok(true)\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+note: return Err() instead of panicking\n+  --> $DIR/panic_in_result_fn_debug_assertions.rs:21:9\n+   |\n+LL |         debug_assert_ne!(x, 1);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "6028323a3c84d2dee0ed4b4cbcad5424a42e5bac", "filename": "tests/ui/panicking_macros.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fpanicking_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fpanicking_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanicking_macros.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -62,23 +62,23 @@ error: `unimplemented` should not be present in production code\n LL |     unimplemented!(\"{} {}\", \"panic with\", \"multiple arguments\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: `unreachable` should not be present in production code\n+error: usage of the `unreachable!` macro\n   --> $DIR/panicking_macros.rs:32:5\n    |\n LL |     unreachable!();\n    |     ^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::unreachable` implied by `-D warnings`\n \n-error: `unreachable` should not be present in production code\n+error: usage of the `unreachable!` macro\n   --> $DIR/panicking_macros.rs:33:5\n    |\n LL |     unreachable!(\"message\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: `unreachable` should not be present in production code\n+error: usage of the `unreachable!` macro\n   --> $DIR/panicking_macros.rs:34:5\n    |\n LL |     unreachable!(\"{} {}\", \"panic with\", \"multiple arguments\");\n@@ -102,7 +102,7 @@ error: `unimplemented` should not be present in production code\n LL |     unimplemented!();\n    |     ^^^^^^^^^^^^^^^^^\n \n-error: `unreachable` should not be present in production code\n+error: usage of the `unreachable!` macro\n   --> $DIR/panicking_macros.rs:43:5\n    |\n LL |     unreachable!();"}, {"sha": "fa07e74a7be47ef865870592b5e5e72d5dca284a", "filename": "tests/ui/print_stderr.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fprint_stderr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fprint_stderr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_stderr.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,8 @@\n+#![warn(clippy::print_stderr)]\n+\n+fn main() {\n+    eprintln!(\"Hello\");\n+    println!(\"This should not do anything\");\n+    eprint!(\"World\");\n+    print!(\"Nor should this\");\n+}"}, {"sha": "5af735af65769b9512f336d38dec186afbeffcb2", "filename": "tests/ui/print_stderr.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fprint_stderr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fprint_stderr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_stderr.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,16 @@\n+error: use of `eprintln!`\n+  --> $DIR/print_stderr.rs:4:5\n+   |\n+LL |     eprintln!(\"Hello\");\n+   |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::print-stderr` implied by `-D warnings`\n+\n+error: use of `eprint!`\n+  --> $DIR/print_stderr.rs:6:5\n+   |\n+LL |     eprint!(\"World\");\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "9760680927a63d9b9772c929fd3bf700e66ba175", "filename": "tests/ui/println_empty_string.fixed", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fprintln_empty_string.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fprintln_empty_string.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprintln_empty_string.fixed?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -8,4 +8,11 @@ fn main() {\n     match \"a\" {\n         _ => println!(),\n     }\n+\n+    eprintln!();\n+    eprintln!();\n+\n+    match \"a\" {\n+        _ => eprintln!(),\n+    }\n }"}, {"sha": "80fdb3e6e2105412918e757fa7790a8697d193e9", "filename": "tests/ui/println_empty_string.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fprintln_empty_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fprintln_empty_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprintln_empty_string.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -8,4 +8,11 @@ fn main() {\n     match \"a\" {\n         _ => println!(\"\"),\n     }\n+\n+    eprintln!();\n+    eprintln!(\"\");\n+\n+    match \"a\" {\n+        _ => eprintln!(\"\"),\n+    }\n }"}, {"sha": "17fe4ea74790c4de796cb0bbdf6342f7924fe65b", "filename": "tests/ui/println_empty_string.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fprintln_empty_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fprintln_empty_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprintln_empty_string.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -12,5 +12,17 @@ error: using `println!(\"\")`\n LL |         _ => println!(\"\"),\n    |              ^^^^^^^^^^^^ help: replace it with: `println!()`\n \n-error: aborting due to 2 previous errors\n+error: using `eprintln!(\"\")`\n+  --> $DIR/println_empty_string.rs:13:5\n+   |\n+LL |     eprintln!(\"\");\n+   |     ^^^^^^^^^^^^^ help: replace it with: `eprintln!()`\n+\n+error: using `eprintln!(\"\")`\n+  --> $DIR/println_empty_string.rs:16:14\n+   |\n+LL |         _ => eprintln!(\"\"),\n+   |              ^^^^^^^^^^^^^ help: replace it with: `eprintln!()`\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "06370dfce65188899dda939fb0dbee8e561c7170", "filename": "tests/ui/ptr_arg.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_arg.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -2,6 +2,7 @@\n #![warn(clippy::ptr_arg)]\n \n use std::borrow::Cow;\n+use std::path::PathBuf;\n \n fn do_vec(x: &Vec<i64>) {\n     //Nothing here\n@@ -21,6 +22,15 @@ fn do_str_mut(x: &mut String) {\n     //Nothing here either\n }\n \n+fn do_path(x: &PathBuf) {\n+    //Nothing here either\n+}\n+\n+fn do_path_mut(x: &mut PathBuf) {\n+    // no error here\n+    //Nothing here either\n+}\n+\n fn main() {}\n \n trait Foo {\n@@ -55,6 +65,14 @@ fn str_cloned(x: &String) -> String {\n     x.clone()\n }\n \n+fn path_cloned(x: &PathBuf) -> PathBuf {\n+    let a = x.clone();\n+    let b = x.clone();\n+    let c = b.clone();\n+    let d = a.clone().clone().clone();\n+    x.clone()\n+}\n+\n fn false_positive_capacity(x: &Vec<u8>, y: &String) {\n     let a = x.capacity();\n     let b = y.clone();\n@@ -87,10 +105,12 @@ impl Foo2 for String {\n // Check that the allow attribute on parameters is honored\n mod issue_5644 {\n     use std::borrow::Cow;\n+    use std::path::PathBuf;\n \n     fn allowed(\n         #[allow(clippy::ptr_arg)] _v: &Vec<u32>,\n         #[allow(clippy::ptr_arg)] _s: &String,\n+        #[allow(clippy::ptr_arg)] _p: &PathBuf,\n         #[allow(clippy::ptr_arg)] _c: &Cow<[i32]>,\n     ) {\n     }\n@@ -100,6 +120,7 @@ mod issue_5644 {\n         fn allowed(\n             #[allow(clippy::ptr_arg)] _v: &Vec<u32>,\n             #[allow(clippy::ptr_arg)] _s: &String,\n+            #[allow(clippy::ptr_arg)] _p: &PathBuf,\n             #[allow(clippy::ptr_arg)] _c: &Cow<[i32]>,\n         ) {\n         }\n@@ -109,8 +130,28 @@ mod issue_5644 {\n         fn allowed(\n             #[allow(clippy::ptr_arg)] _v: &Vec<u32>,\n             #[allow(clippy::ptr_arg)] _s: &String,\n+            #[allow(clippy::ptr_arg)] _p: &PathBuf,\n             #[allow(clippy::ptr_arg)] _c: &Cow<[i32]>,\n         ) {\n         }\n     }\n }\n+\n+mod issue6509 {\n+    use std::path::PathBuf;\n+\n+    fn foo_vec(vec: &Vec<u8>) {\n+        let _ = vec.clone().pop();\n+        let _ = vec.clone().clone();\n+    }\n+\n+    fn foo_path(path: &PathBuf) {\n+        let _ = path.clone().pop();\n+        let _ = path.clone().clone();\n+    }\n+\n+    fn foo_str(str: &PathBuf) {\n+        let _ = str.clone().pop();\n+        let _ = str.clone().clone();\n+    }\n+}"}, {"sha": "708318bbe295c410f4dd20370842f9c2ce95e648", "filename": "tests/ui/ptr_arg.stderr", "status": "modified", "additions": 94, "deletions": 8, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fptr_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fptr_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_arg.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,25 +1,31 @@\n error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices.\n-  --> $DIR/ptr_arg.rs:6:14\n+  --> $DIR/ptr_arg.rs:7:14\n    |\n LL | fn do_vec(x: &Vec<i64>) {\n    |              ^^^^^^^^^ help: change this to: `&[i64]`\n    |\n    = note: `-D clippy::ptr-arg` implied by `-D warnings`\n \n error: writing `&String` instead of `&str` involves a new object where a slice will do.\n-  --> $DIR/ptr_arg.rs:15:14\n+  --> $DIR/ptr_arg.rs:16:14\n    |\n LL | fn do_str(x: &String) {\n    |              ^^^^^^^ help: change this to: `&str`\n \n+error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do.\n+  --> $DIR/ptr_arg.rs:25:15\n+   |\n+LL | fn do_path(x: &PathBuf) {\n+   |               ^^^^^^^^ help: change this to: `&Path`\n+\n error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices.\n-  --> $DIR/ptr_arg.rs:28:18\n+  --> $DIR/ptr_arg.rs:38:18\n    |\n LL |     fn do_vec(x: &Vec<i64>);\n    |                  ^^^^^^^^^ help: change this to: `&[i64]`\n \n error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices.\n-  --> $DIR/ptr_arg.rs:41:14\n+  --> $DIR/ptr_arg.rs:51:14\n    |\n LL | fn cloned(x: &Vec<u8>) -> Vec<u8> {\n    |              ^^^^^^^^\n@@ -38,7 +44,7 @@ LL |     x.to_owned()\n    |\n \n error: writing `&String` instead of `&str` involves a new object where a slice will do.\n-  --> $DIR/ptr_arg.rs:50:18\n+  --> $DIR/ptr_arg.rs:60:18\n    |\n LL | fn str_cloned(x: &String) -> String {\n    |                  ^^^^^^^\n@@ -60,8 +66,31 @@ help: change `x.clone()` to\n LL |     x.to_string()\n    |\n \n+error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do.\n+  --> $DIR/ptr_arg.rs:68:19\n+   |\n+LL | fn path_cloned(x: &PathBuf) -> PathBuf {\n+   |                   ^^^^^^^^\n+   |\n+help: change this to\n+   |\n+LL | fn path_cloned(x: &Path) -> PathBuf {\n+   |                   ^^^^^\n+help: change `x.clone()` to\n+   |\n+LL |     let a = x.to_path_buf();\n+   |             ^^^^^^^^^^^^^^^\n+help: change `x.clone()` to\n+   |\n+LL |     let b = x.to_path_buf();\n+   |             ^^^^^^^^^^^^^^^\n+help: change `x.clone()` to\n+   |\n+LL |     x.to_path_buf()\n+   |\n+\n error: writing `&String` instead of `&str` involves a new object where a slice will do.\n-  --> $DIR/ptr_arg.rs:58:44\n+  --> $DIR/ptr_arg.rs:76:44\n    |\n LL | fn false_positive_capacity(x: &Vec<u8>, y: &String) {\n    |                                            ^^^^^^^\n@@ -80,10 +109,67 @@ LL |     let c = y;\n    |             ^\n \n error: using a reference to `Cow` is not recommended.\n-  --> $DIR/ptr_arg.rs:72:25\n+  --> $DIR/ptr_arg.rs:90:25\n    |\n LL | fn test_cow_with_ref(c: &Cow<[i32]>) {}\n    |                         ^^^^^^^^^^^ help: change this to: `&[i32]`\n \n-error: aborting due to 7 previous errors\n+error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices.\n+  --> $DIR/ptr_arg.rs:143:21\n+   |\n+LL |     fn foo_vec(vec: &Vec<u8>) {\n+   |                     ^^^^^^^^\n+   |\n+help: change this to\n+   |\n+LL |     fn foo_vec(vec: &[u8]) {\n+   |                     ^^^^^\n+help: change `vec.clone()` to\n+   |\n+LL |         let _ = vec.to_owned().pop();\n+   |                 ^^^^^^^^^^^^^^\n+help: change `vec.clone()` to\n+   |\n+LL |         let _ = vec.to_owned().clone();\n+   |                 ^^^^^^^^^^^^^^\n+\n+error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do.\n+  --> $DIR/ptr_arg.rs:148:23\n+   |\n+LL |     fn foo_path(path: &PathBuf) {\n+   |                       ^^^^^^^^\n+   |\n+help: change this to\n+   |\n+LL |     fn foo_path(path: &Path) {\n+   |                       ^^^^^\n+help: change `path.clone()` to\n+   |\n+LL |         let _ = path.to_path_buf().pop();\n+   |                 ^^^^^^^^^^^^^^^^^^\n+help: change `path.clone()` to\n+   |\n+LL |         let _ = path.to_path_buf().clone();\n+   |                 ^^^^^^^^^^^^^^^^^^\n+\n+error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do.\n+  --> $DIR/ptr_arg.rs:153:21\n+   |\n+LL |     fn foo_str(str: &PathBuf) {\n+   |                     ^^^^^^^^\n+   |\n+help: change this to\n+   |\n+LL |     fn foo_str(str: &Path) {\n+   |                     ^^^^^\n+help: change `str.clone()` to\n+   |\n+LL |         let _ = str.to_path_buf().pop();\n+   |                 ^^^^^^^^^^^^^^^^^\n+help: change `str.clone()` to\n+   |\n+LL |         let _ = str.to_path_buf().clone();\n+   |                 ^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 12 previous errors\n "}, {"sha": "8346a9454f4eee45040c9bcae8905de7cd64c494", "filename": "tests/ui/ptr_as_ptr.fixed", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fptr_as_ptr.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fptr_as_ptr.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_as_ptr.fixed?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,50 @@\n+// run-rustfix\n+\n+#![warn(clippy::ptr_as_ptr)]\n+#![feature(custom_inner_attributes)]\n+\n+fn main() {\n+    let ptr: *const u32 = &42_u32;\n+    let mut_ptr: *mut u32 = &mut 42_u32;\n+\n+    let _ = ptr.cast::<i32>();\n+    let _ = mut_ptr.cast::<i32>();\n+\n+    // Make sure the lint can handle the difference in their operator precedences.\n+    unsafe {\n+        let ptr_ptr: *const *const u32 = &ptr;\n+        let _ = (*ptr_ptr).cast::<i32>();\n+    }\n+\n+    // Changes in mutability. Do not lint this.\n+    let _ = ptr as *mut i32;\n+    let _ = mut_ptr as *const i32;\n+\n+    // `pointer::cast` cannot perform unsized coercions unlike `as`. Do not lint this.\n+    let ptr_of_array: *const [u32; 4] = &[1, 2, 3, 4];\n+    let _ = ptr_of_array as *const [u32];\n+    let _ = ptr_of_array as *const dyn std::fmt::Debug;\n+\n+    // Ensure the lint doesn't produce unnecessary turbofish for inferred types.\n+    let _: *const i32 = ptr.cast();\n+    let _: *mut i32 = mut_ptr.cast();\n+}\n+\n+fn _msrv_1_37() {\n+    #![clippy::msrv = \"1.37\"]\n+    let ptr: *const u32 = &42_u32;\n+    let mut_ptr: *mut u32 = &mut 42_u32;\n+\n+    // `pointer::cast` was stabilized in 1.38. Do not lint this\n+    let _ = ptr as *const i32;\n+    let _ = mut_ptr as *mut i32;\n+}\n+\n+fn _msrv_1_38() {\n+    #![clippy::msrv = \"1.38\"]\n+    let ptr: *const u32 = &42_u32;\n+    let mut_ptr: *mut u32 = &mut 42_u32;\n+\n+    let _ = ptr.cast::<i32>();\n+    let _ = mut_ptr.cast::<i32>();\n+}"}, {"sha": "b68d4bc0aaca1f91cc3ed1244953124fe29aaf49", "filename": "tests/ui/ptr_as_ptr.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fptr_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fptr_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_as_ptr.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,50 @@\n+// run-rustfix\n+\n+#![warn(clippy::ptr_as_ptr)]\n+#![feature(custom_inner_attributes)]\n+\n+fn main() {\n+    let ptr: *const u32 = &42_u32;\n+    let mut_ptr: *mut u32 = &mut 42_u32;\n+\n+    let _ = ptr as *const i32;\n+    let _ = mut_ptr as *mut i32;\n+\n+    // Make sure the lint can handle the difference in their operator precedences.\n+    unsafe {\n+        let ptr_ptr: *const *const u32 = &ptr;\n+        let _ = *ptr_ptr as *const i32;\n+    }\n+\n+    // Changes in mutability. Do not lint this.\n+    let _ = ptr as *mut i32;\n+    let _ = mut_ptr as *const i32;\n+\n+    // `pointer::cast` cannot perform unsized coercions unlike `as`. Do not lint this.\n+    let ptr_of_array: *const [u32; 4] = &[1, 2, 3, 4];\n+    let _ = ptr_of_array as *const [u32];\n+    let _ = ptr_of_array as *const dyn std::fmt::Debug;\n+\n+    // Ensure the lint doesn't produce unnecessary turbofish for inferred types.\n+    let _: *const i32 = ptr as *const _;\n+    let _: *mut i32 = mut_ptr as _;\n+}\n+\n+fn _msrv_1_37() {\n+    #![clippy::msrv = \"1.37\"]\n+    let ptr: *const u32 = &42_u32;\n+    let mut_ptr: *mut u32 = &mut 42_u32;\n+\n+    // `pointer::cast` was stabilized in 1.38. Do not lint this\n+    let _ = ptr as *const i32;\n+    let _ = mut_ptr as *mut i32;\n+}\n+\n+fn _msrv_1_38() {\n+    #![clippy::msrv = \"1.38\"]\n+    let ptr: *const u32 = &42_u32;\n+    let mut_ptr: *mut u32 = &mut 42_u32;\n+\n+    let _ = ptr as *const i32;\n+    let _ = mut_ptr as *mut i32;\n+}"}, {"sha": "854906dc111dfec2bcd5a4dc3852ee99f5a2ec74", "filename": "tests/ui/ptr_as_ptr.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fptr_as_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fptr_as_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_as_ptr.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,46 @@\n+error: `as` casting between raw pointers without changing its mutability\n+  --> $DIR/ptr_as_ptr.rs:10:13\n+   |\n+LL |     let _ = ptr as *const i32;\n+   |             ^^^^^^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `ptr.cast::<i32>()`\n+   |\n+   = note: `-D clippy::ptr-as-ptr` implied by `-D warnings`\n+\n+error: `as` casting between raw pointers without changing its mutability\n+  --> $DIR/ptr_as_ptr.rs:11:13\n+   |\n+LL |     let _ = mut_ptr as *mut i32;\n+   |             ^^^^^^^^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `mut_ptr.cast::<i32>()`\n+\n+error: `as` casting between raw pointers without changing its mutability\n+  --> $DIR/ptr_as_ptr.rs:16:17\n+   |\n+LL |         let _ = *ptr_ptr as *const i32;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `(*ptr_ptr).cast::<i32>()`\n+\n+error: `as` casting between raw pointers without changing its mutability\n+  --> $DIR/ptr_as_ptr.rs:29:25\n+   |\n+LL |     let _: *const i32 = ptr as *const _;\n+   |                         ^^^^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `ptr.cast()`\n+\n+error: `as` casting between raw pointers without changing its mutability\n+  --> $DIR/ptr_as_ptr.rs:30:23\n+   |\n+LL |     let _: *mut i32 = mut_ptr as _;\n+   |                       ^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `mut_ptr.cast()`\n+\n+error: `as` casting between raw pointers without changing its mutability\n+  --> $DIR/ptr_as_ptr.rs:48:13\n+   |\n+LL |     let _ = ptr as *const i32;\n+   |             ^^^^^^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `ptr.cast::<i32>()`\n+\n+error: `as` casting between raw pointers without changing its mutability\n+  --> $DIR/ptr_as_ptr.rs:49:13\n+   |\n+LL |     let _ = mut_ptr as *mut i32;\n+   |             ^^^^^^^^^^^^^^^^^^^ help: try `pointer::cast`, a safer alternative: `mut_ptr.cast::<i32>()`\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "47c974e614b91e80bda1fd3b46dfe11a92b240f9", "filename": "tests/ui/range_contains.fixed", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Frange_contains.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Frange_contains.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange_contains.fixed?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -44,3 +44,8 @@ fn main() {\n     (0. ..1.).contains(&y);\n     !(0. ..=1.).contains(&y);\n }\n+\n+// Fix #6373\n+pub const fn in_range(a: i32) -> bool {\n+    3 <= a && a <= 20\n+}"}, {"sha": "835deced5e4cba34a443debfc104ce0ac21b8635", "filename": "tests/ui/range_contains.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Frange_contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Frange_contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange_contains.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -44,3 +44,8 @@ fn main() {\n     y >= 0. && y < 1.;\n     y < 0. || y > 1.;\n }\n+\n+// Fix #6373\n+pub const fn in_range(a: i32) -> bool {\n+    3 <= a && a <= 20\n+}"}, {"sha": "737c8a9f8db43783313ab6d6fdfbfe0341709984", "filename": "tests/ui/redundant_else.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_else.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,154 @@\n+#![warn(clippy::redundant_else)]\n+#![allow(clippy::needless_return)]\n+\n+fn main() {\n+    loop {\n+        // break\n+        if foo() {\n+            println!(\"Love your neighbor;\");\n+            break;\n+        } else {\n+            println!(\"yet don't pull down your hedge.\");\n+        }\n+        // continue\n+        if foo() {\n+            println!(\"He that lies down with Dogs,\");\n+            continue;\n+        } else {\n+            println!(\"shall rise up with fleas.\");\n+        }\n+        // match block\n+        if foo() {\n+            match foo() {\n+                1 => break,\n+                _ => return,\n+            }\n+        } else {\n+            println!(\"You may delay, but time will not.\");\n+        }\n+    }\n+    // else if\n+    if foo() {\n+        return;\n+    } else if foo() {\n+        return;\n+    } else {\n+        println!(\"A fat kitchen makes a lean will.\");\n+    }\n+    // let binding outside of block\n+    let _ = {\n+        if foo() {\n+            return;\n+        } else {\n+            1\n+        }\n+    };\n+    // else if with let binding outside of block\n+    let _ = {\n+        if foo() {\n+            return;\n+        } else if foo() {\n+            return;\n+        } else {\n+            2\n+        }\n+    };\n+    // inside if let\n+    let _ = if let Some(1) = foo() {\n+        let _ = 1;\n+        if foo() {\n+            return;\n+        } else {\n+            1\n+        }\n+    } else {\n+        1\n+    };\n+\n+    //\n+    // non-lint cases\n+    //\n+\n+    // sanity check\n+    if foo() {\n+        let _ = 1;\n+    } else {\n+        println!(\"Who is wise? He that learns from every one.\");\n+    }\n+    // else if without else\n+    if foo() {\n+        return;\n+    } else if foo() {\n+        foo()\n+    };\n+    // nested if return\n+    if foo() {\n+        if foo() {\n+            return;\n+        }\n+    } else {\n+        foo()\n+    };\n+    // match with non-breaking branch\n+    if foo() {\n+        match foo() {\n+            1 => foo(),\n+            _ => return,\n+        }\n+    } else {\n+        println!(\"Three may keep a secret, if two of them are dead.\");\n+    }\n+    // let binding\n+    let _ = if foo() {\n+        return;\n+    } else {\n+        1\n+    };\n+    // assign\n+    let a;\n+    a = if foo() {\n+        return;\n+    } else {\n+        1\n+    };\n+    // assign-op\n+    a += if foo() {\n+        return;\n+    } else {\n+        1\n+    };\n+    // if return else if else\n+    if foo() {\n+        return;\n+    } else if foo() {\n+        1\n+    } else {\n+        2\n+    };\n+    // if else if return else\n+    if foo() {\n+        1\n+    } else if foo() {\n+        return;\n+    } else {\n+        2\n+    };\n+    // else if with let binding\n+    let _ = if foo() {\n+        return;\n+    } else if foo() {\n+        return;\n+    } else {\n+        2\n+    };\n+    // inside function call\n+    Box::new(if foo() {\n+        return;\n+    } else {\n+        1\n+    });\n+}\n+\n+fn foo<T>() -> T {\n+    unimplemented!(\"I'm not Santa Claus\")\n+}"}, {"sha": "9000cdc814b1fe7fe27ec966785d9d106851dd2f", "filename": "tests/ui/redundant_else.stderr", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_else.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,80 @@\n+error: redundant else block\n+  --> $DIR/redundant_else.rs:10:16\n+   |\n+LL |           } else {\n+   |  ________________^\n+LL | |             println!(\"yet don't pull down your hedge.\");\n+LL | |         }\n+   | |_________^\n+   |\n+   = note: `-D clippy::redundant-else` implied by `-D warnings`\n+   = help: remove the `else` block and move the contents out\n+\n+error: redundant else block\n+  --> $DIR/redundant_else.rs:17:16\n+   |\n+LL |           } else {\n+   |  ________________^\n+LL | |             println!(\"shall rise up with fleas.\");\n+LL | |         }\n+   | |_________^\n+   |\n+   = help: remove the `else` block and move the contents out\n+\n+error: redundant else block\n+  --> $DIR/redundant_else.rs:26:16\n+   |\n+LL |           } else {\n+   |  ________________^\n+LL | |             println!(\"You may delay, but time will not.\");\n+LL | |         }\n+   | |_________^\n+   |\n+   = help: remove the `else` block and move the contents out\n+\n+error: redundant else block\n+  --> $DIR/redundant_else.rs:35:12\n+   |\n+LL |       } else {\n+   |  ____________^\n+LL | |         println!(\"A fat kitchen makes a lean will.\");\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: remove the `else` block and move the contents out\n+\n+error: redundant else block\n+  --> $DIR/redundant_else.rs:42:16\n+   |\n+LL |           } else {\n+   |  ________________^\n+LL | |             1\n+LL | |         }\n+   | |_________^\n+   |\n+   = help: remove the `else` block and move the contents out\n+\n+error: redundant else block\n+  --> $DIR/redundant_else.rs:52:16\n+   |\n+LL |           } else {\n+   |  ________________^\n+LL | |             2\n+LL | |         }\n+   | |_________^\n+   |\n+   = help: remove the `else` block and move the contents out\n+\n+error: redundant else block\n+  --> $DIR/redundant_else.rs:61:16\n+   |\n+LL |           } else {\n+   |  ________________^\n+LL | |             1\n+LL | |         }\n+   | |_________^\n+   |\n+   = help: remove the `else` block and move the contents out\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "acc8de5f41ee879e282c50a49ae1f1e7f756587e", "filename": "tests/ui/redundant_pattern_matching_ipaddr.fixed", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_pattern_matching_ipaddr.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_pattern_matching_ipaddr.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_ipaddr.fixed?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,73 @@\n+// run-rustfix\n+\n+#![warn(clippy::all)]\n+#![warn(clippy::redundant_pattern_matching)]\n+#![allow(unused_must_use, clippy::needless_bool, clippy::match_like_matches_macro)]\n+\n+use std::net::{\n+    IpAddr::{self, V4, V6},\n+    Ipv4Addr, Ipv6Addr,\n+};\n+\n+fn main() {\n+    let ipaddr: IpAddr = V4(Ipv4Addr::LOCALHOST);\n+    if ipaddr.is_ipv4() {}\n+\n+    if V4(Ipv4Addr::LOCALHOST).is_ipv4() {}\n+\n+    if V6(Ipv6Addr::LOCALHOST).is_ipv6() {}\n+\n+    while V4(Ipv4Addr::LOCALHOST).is_ipv4() {}\n+\n+    while V6(Ipv6Addr::LOCALHOST).is_ipv6() {}\n+\n+    if V4(Ipv4Addr::LOCALHOST).is_ipv4() {}\n+\n+    if V6(Ipv6Addr::LOCALHOST).is_ipv6() {}\n+\n+    if let V4(ipaddr) = V4(Ipv4Addr::LOCALHOST) {\n+        println!(\"{}\", ipaddr);\n+    }\n+\n+    V4(Ipv4Addr::LOCALHOST).is_ipv4();\n+\n+    V4(Ipv4Addr::LOCALHOST).is_ipv6();\n+\n+    V6(Ipv6Addr::LOCALHOST).is_ipv6();\n+\n+    V6(Ipv6Addr::LOCALHOST).is_ipv4();\n+\n+    let _ = if V4(Ipv4Addr::LOCALHOST).is_ipv4() {\n+        true\n+    } else {\n+        false\n+    };\n+\n+    ipaddr_const();\n+\n+    let _ = if gen_ipaddr().is_ipv4() {\n+        1\n+    } else if gen_ipaddr().is_ipv6() {\n+        2\n+    } else {\n+        3\n+    };\n+}\n+\n+fn gen_ipaddr() -> IpAddr {\n+    V4(Ipv4Addr::LOCALHOST)\n+}\n+\n+const fn ipaddr_const() {\n+    if V4(Ipv4Addr::LOCALHOST).is_ipv4() {}\n+\n+    if V6(Ipv6Addr::LOCALHOST).is_ipv6() {}\n+\n+    while V4(Ipv4Addr::LOCALHOST).is_ipv4() {}\n+\n+    while V6(Ipv6Addr::LOCALHOST).is_ipv6() {}\n+\n+    V4(Ipv4Addr::LOCALHOST).is_ipv4();\n+\n+    V6(Ipv6Addr::LOCALHOST).is_ipv6();\n+}"}, {"sha": "678d91ce93acda75d753e0222792723338c59fb5", "filename": "tests/ui/redundant_pattern_matching_ipaddr.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_pattern_matching_ipaddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_pattern_matching_ipaddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_ipaddr.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,91 @@\n+// run-rustfix\n+\n+#![warn(clippy::all)]\n+#![warn(clippy::redundant_pattern_matching)]\n+#![allow(unused_must_use, clippy::needless_bool, clippy::match_like_matches_macro)]\n+\n+use std::net::{\n+    IpAddr::{self, V4, V6},\n+    Ipv4Addr, Ipv6Addr,\n+};\n+\n+fn main() {\n+    let ipaddr: IpAddr = V4(Ipv4Addr::LOCALHOST);\n+    if let V4(_) = &ipaddr {}\n+\n+    if let V4(_) = V4(Ipv4Addr::LOCALHOST) {}\n+\n+    if let V6(_) = V6(Ipv6Addr::LOCALHOST) {}\n+\n+    while let V4(_) = V4(Ipv4Addr::LOCALHOST) {}\n+\n+    while let V6(_) = V6(Ipv6Addr::LOCALHOST) {}\n+\n+    if V4(Ipv4Addr::LOCALHOST).is_ipv4() {}\n+\n+    if V6(Ipv6Addr::LOCALHOST).is_ipv6() {}\n+\n+    if let V4(ipaddr) = V4(Ipv4Addr::LOCALHOST) {\n+        println!(\"{}\", ipaddr);\n+    }\n+\n+    match V4(Ipv4Addr::LOCALHOST) {\n+        V4(_) => true,\n+        V6(_) => false,\n+    };\n+\n+    match V4(Ipv4Addr::LOCALHOST) {\n+        V4(_) => false,\n+        V6(_) => true,\n+    };\n+\n+    match V6(Ipv6Addr::LOCALHOST) {\n+        V4(_) => false,\n+        V6(_) => true,\n+    };\n+\n+    match V6(Ipv6Addr::LOCALHOST) {\n+        V4(_) => true,\n+        V6(_) => false,\n+    };\n+\n+    let _ = if let V4(_) = V4(Ipv4Addr::LOCALHOST) {\n+        true\n+    } else {\n+        false\n+    };\n+\n+    ipaddr_const();\n+\n+    let _ = if let V4(_) = gen_ipaddr() {\n+        1\n+    } else if let V6(_) = gen_ipaddr() {\n+        2\n+    } else {\n+        3\n+    };\n+}\n+\n+fn gen_ipaddr() -> IpAddr {\n+    V4(Ipv4Addr::LOCALHOST)\n+}\n+\n+const fn ipaddr_const() {\n+    if let V4(_) = V4(Ipv4Addr::LOCALHOST) {}\n+\n+    if let V6(_) = V6(Ipv6Addr::LOCALHOST) {}\n+\n+    while let V4(_) = V4(Ipv4Addr::LOCALHOST) {}\n+\n+    while let V6(_) = V6(Ipv6Addr::LOCALHOST) {}\n+\n+    match V4(Ipv4Addr::LOCALHOST) {\n+        V4(_) => true,\n+        V6(_) => false,\n+    };\n+\n+    match V6(Ipv6Addr::LOCALHOST) {\n+        V4(_) => false,\n+        V6(_) => true,\n+    };\n+}"}, {"sha": "caf458cd862e01a27b7e53cd2343483667cae4ca", "filename": "tests/ui/redundant_pattern_matching_ipaddr.stderr", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_pattern_matching_ipaddr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_pattern_matching_ipaddr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_ipaddr.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,130 @@\n+error: redundant pattern matching, consider using `is_ipv4()`\n+  --> $DIR/redundant_pattern_matching_ipaddr.rs:14:12\n+   |\n+LL |     if let V4(_) = &ipaddr {}\n+   |     -------^^^^^---------- help: try this: `if ipaddr.is_ipv4()`\n+   |\n+   = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n+\n+error: redundant pattern matching, consider using `is_ipv4()`\n+  --> $DIR/redundant_pattern_matching_ipaddr.rs:16:12\n+   |\n+LL |     if let V4(_) = V4(Ipv4Addr::LOCALHOST) {}\n+   |     -------^^^^^-------------------------- help: try this: `if V4(Ipv4Addr::LOCALHOST).is_ipv4()`\n+\n+error: redundant pattern matching, consider using `is_ipv6()`\n+  --> $DIR/redundant_pattern_matching_ipaddr.rs:18:12\n+   |\n+LL |     if let V6(_) = V6(Ipv6Addr::LOCALHOST) {}\n+   |     -------^^^^^-------------------------- help: try this: `if V6(Ipv6Addr::LOCALHOST).is_ipv6()`\n+\n+error: redundant pattern matching, consider using `is_ipv4()`\n+  --> $DIR/redundant_pattern_matching_ipaddr.rs:20:15\n+   |\n+LL |     while let V4(_) = V4(Ipv4Addr::LOCALHOST) {}\n+   |     ----------^^^^^-------------------------- help: try this: `while V4(Ipv4Addr::LOCALHOST).is_ipv4()`\n+\n+error: redundant pattern matching, consider using `is_ipv6()`\n+  --> $DIR/redundant_pattern_matching_ipaddr.rs:22:15\n+   |\n+LL |     while let V6(_) = V6(Ipv6Addr::LOCALHOST) {}\n+   |     ----------^^^^^-------------------------- help: try this: `while V6(Ipv6Addr::LOCALHOST).is_ipv6()`\n+\n+error: redundant pattern matching, consider using `is_ipv4()`\n+  --> $DIR/redundant_pattern_matching_ipaddr.rs:32:5\n+   |\n+LL | /     match V4(Ipv4Addr::LOCALHOST) {\n+LL | |         V4(_) => true,\n+LL | |         V6(_) => false,\n+LL | |     };\n+   | |_____^ help: try this: `V4(Ipv4Addr::LOCALHOST).is_ipv4()`\n+\n+error: redundant pattern matching, consider using `is_ipv6()`\n+  --> $DIR/redundant_pattern_matching_ipaddr.rs:37:5\n+   |\n+LL | /     match V4(Ipv4Addr::LOCALHOST) {\n+LL | |         V4(_) => false,\n+LL | |         V6(_) => true,\n+LL | |     };\n+   | |_____^ help: try this: `V4(Ipv4Addr::LOCALHOST).is_ipv6()`\n+\n+error: redundant pattern matching, consider using `is_ipv6()`\n+  --> $DIR/redundant_pattern_matching_ipaddr.rs:42:5\n+   |\n+LL | /     match V6(Ipv6Addr::LOCALHOST) {\n+LL | |         V4(_) => false,\n+LL | |         V6(_) => true,\n+LL | |     };\n+   | |_____^ help: try this: `V6(Ipv6Addr::LOCALHOST).is_ipv6()`\n+\n+error: redundant pattern matching, consider using `is_ipv4()`\n+  --> $DIR/redundant_pattern_matching_ipaddr.rs:47:5\n+   |\n+LL | /     match V6(Ipv6Addr::LOCALHOST) {\n+LL | |         V4(_) => true,\n+LL | |         V6(_) => false,\n+LL | |     };\n+   | |_____^ help: try this: `V6(Ipv6Addr::LOCALHOST).is_ipv4()`\n+\n+error: redundant pattern matching, consider using `is_ipv4()`\n+  --> $DIR/redundant_pattern_matching_ipaddr.rs:52:20\n+   |\n+LL |     let _ = if let V4(_) = V4(Ipv4Addr::LOCALHOST) {\n+   |             -------^^^^^-------------------------- help: try this: `if V4(Ipv4Addr::LOCALHOST).is_ipv4()`\n+\n+error: redundant pattern matching, consider using `is_ipv4()`\n+  --> $DIR/redundant_pattern_matching_ipaddr.rs:60:20\n+   |\n+LL |     let _ = if let V4(_) = gen_ipaddr() {\n+   |             -------^^^^^--------------- help: try this: `if gen_ipaddr().is_ipv4()`\n+\n+error: redundant pattern matching, consider using `is_ipv6()`\n+  --> $DIR/redundant_pattern_matching_ipaddr.rs:62:19\n+   |\n+LL |     } else if let V6(_) = gen_ipaddr() {\n+   |            -------^^^^^--------------- help: try this: `if gen_ipaddr().is_ipv6()`\n+\n+error: redundant pattern matching, consider using `is_ipv4()`\n+  --> $DIR/redundant_pattern_matching_ipaddr.rs:74:12\n+   |\n+LL |     if let V4(_) = V4(Ipv4Addr::LOCALHOST) {}\n+   |     -------^^^^^-------------------------- help: try this: `if V4(Ipv4Addr::LOCALHOST).is_ipv4()`\n+\n+error: redundant pattern matching, consider using `is_ipv6()`\n+  --> $DIR/redundant_pattern_matching_ipaddr.rs:76:12\n+   |\n+LL |     if let V6(_) = V6(Ipv6Addr::LOCALHOST) {}\n+   |     -------^^^^^-------------------------- help: try this: `if V6(Ipv6Addr::LOCALHOST).is_ipv6()`\n+\n+error: redundant pattern matching, consider using `is_ipv4()`\n+  --> $DIR/redundant_pattern_matching_ipaddr.rs:78:15\n+   |\n+LL |     while let V4(_) = V4(Ipv4Addr::LOCALHOST) {}\n+   |     ----------^^^^^-------------------------- help: try this: `while V4(Ipv4Addr::LOCALHOST).is_ipv4()`\n+\n+error: redundant pattern matching, consider using `is_ipv6()`\n+  --> $DIR/redundant_pattern_matching_ipaddr.rs:80:15\n+   |\n+LL |     while let V6(_) = V6(Ipv6Addr::LOCALHOST) {}\n+   |     ----------^^^^^-------------------------- help: try this: `while V6(Ipv6Addr::LOCALHOST).is_ipv6()`\n+\n+error: redundant pattern matching, consider using `is_ipv4()`\n+  --> $DIR/redundant_pattern_matching_ipaddr.rs:82:5\n+   |\n+LL | /     match V4(Ipv4Addr::LOCALHOST) {\n+LL | |         V4(_) => true,\n+LL | |         V6(_) => false,\n+LL | |     };\n+   | |_____^ help: try this: `V4(Ipv4Addr::LOCALHOST).is_ipv4()`\n+\n+error: redundant pattern matching, consider using `is_ipv6()`\n+  --> $DIR/redundant_pattern_matching_ipaddr.rs:87:5\n+   |\n+LL | /     match V6(Ipv6Addr::LOCALHOST) {\n+LL | |         V4(_) => false,\n+LL | |         V6(_) => true,\n+LL | |     };\n+   | |_____^ help: try this: `V6(Ipv6Addr::LOCALHOST).is_ipv6()`\n+\n+error: aborting due to 18 previous errors\n+"}, {"sha": "66f580a0a683426e250479c01e5a8a6c1ff86dd6", "filename": "tests/ui/redundant_pattern_matching_option.fixed", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_pattern_matching_option.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_pattern_matching_option.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_option.fixed?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -37,8 +37,7 @@ fn main() {\n     let _ = None::<()>.is_none();\n \n     let opt = Some(false);\n-    let x = if opt.is_some() { true } else { false };\n-    takes_bool(x);\n+    let _ = if opt.is_some() { true } else { false };\n \n     issue6067();\n \n@@ -55,8 +54,6 @@ fn gen_opt() -> Option<()> {\n     None\n }\n \n-fn takes_bool(_: bool) {}\n-\n fn foo() {}\n \n fn bar() {}"}, {"sha": "f18b27b8b95c30b4cc33e5756e2d51d4bf5bcd75", "filename": "tests/ui/redundant_pattern_matching_option.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_pattern_matching_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_pattern_matching_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_option.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -46,8 +46,7 @@ fn main() {\n     };\n \n     let opt = Some(false);\n-    let x = if let Some(_) = opt { true } else { false };\n-    takes_bool(x);\n+    let _ = if let Some(_) = opt { true } else { false };\n \n     issue6067();\n \n@@ -64,8 +63,6 @@ fn gen_opt() -> Option<()> {\n     None\n }\n \n-fn takes_bool(_: bool) {}\n-\n fn foo() {}\n \n fn bar() {}"}, {"sha": "58482a0ab70dcbe0c4c1a2bef214861dcbd06d3a", "filename": "tests/ui/redundant_pattern_matching_option.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_pattern_matching_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_pattern_matching_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_option.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -73,47 +73,47 @@ LL | |     };\n error: redundant pattern matching, consider using `is_some()`\n   --> $DIR/redundant_pattern_matching_option.rs:49:20\n    |\n-LL |     let x = if let Some(_) = opt { true } else { false };\n+LL |     let _ = if let Some(_) = opt { true } else { false };\n    |             -------^^^^^^^------ help: try this: `if opt.is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:54:20\n+  --> $DIR/redundant_pattern_matching_option.rs:53:20\n    |\n LL |     let _ = if let Some(_) = gen_opt() {\n    |             -------^^^^^^^------------ help: try this: `if gen_opt().is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:56:19\n+  --> $DIR/redundant_pattern_matching_option.rs:55:19\n    |\n LL |     } else if let None = gen_opt() {\n    |            -------^^^^------------ help: try this: `if gen_opt().is_none()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:77:12\n+  --> $DIR/redundant_pattern_matching_option.rs:74:12\n    |\n LL |     if let Some(_) = Some(42) {}\n    |     -------^^^^^^^----------- help: try this: `if Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:79:12\n+  --> $DIR/redundant_pattern_matching_option.rs:76:12\n    |\n LL |     if let None = None::<()> {}\n    |     -------^^^^------------- help: try this: `if None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:81:15\n+  --> $DIR/redundant_pattern_matching_option.rs:78:15\n    |\n LL |     while let Some(_) = Some(42) {}\n    |     ----------^^^^^^^----------- help: try this: `while Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:83:15\n+  --> $DIR/redundant_pattern_matching_option.rs:80:15\n    |\n LL |     while let None = None::<()> {}\n    |     ----------^^^^------------- help: try this: `while None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching_option.rs:85:5\n+  --> $DIR/redundant_pattern_matching_option.rs:82:5\n    |\n LL | /     match Some(42) {\n LL | |         Some(_) => true,\n@@ -122,7 +122,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching_option.rs:90:5\n+  --> $DIR/redundant_pattern_matching_option.rs:87:5\n    |\n LL | /     match None::<()> {\n LL | |         Some(_) => false,"}, {"sha": "465aa80dac27c4512eef6b6011dbe4840fea1f22", "filename": "tests/ui/redundant_pattern_matching_poll.fixed", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_pattern_matching_poll.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_pattern_matching_poll.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_poll.fixed?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -34,8 +34,7 @@ fn main() {\n     let _ = Pending::<()>.is_pending();\n \n     let poll = Ready(false);\n-    let x = if poll.is_ready() { true } else { false };\n-    takes_poll(x);\n+    let _ = if poll.is_ready() { true } else { false };\n \n     poll_const();\n \n@@ -52,8 +51,6 @@ fn gen_poll() -> Poll<()> {\n     Pending\n }\n \n-fn takes_poll(_: bool) {}\n-\n fn foo() {}\n \n fn bar() {}"}, {"sha": "7891ff353b13ee5d9ba4c81a5bde2004a3c68dde", "filename": "tests/ui/redundant_pattern_matching_poll.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_pattern_matching_poll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_pattern_matching_poll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_poll.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -43,8 +43,7 @@ fn main() {\n     };\n \n     let poll = Ready(false);\n-    let x = if let Ready(_) = poll { true } else { false };\n-    takes_poll(x);\n+    let _ = if let Ready(_) = poll { true } else { false };\n \n     poll_const();\n \n@@ -61,8 +60,6 @@ fn gen_poll() -> Poll<()> {\n     Pending\n }\n \n-fn takes_poll(_: bool) {}\n-\n fn foo() {}\n \n fn bar() {}"}, {"sha": "5ffc6c47c90a220691a4069329a5ec0a3b279167", "filename": "tests/ui/redundant_pattern_matching_poll.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_pattern_matching_poll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_pattern_matching_poll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_poll.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -67,47 +67,47 @@ LL | |     };\n error: redundant pattern matching, consider using `is_ready()`\n   --> $DIR/redundant_pattern_matching_poll.rs:46:20\n    |\n-LL |     let x = if let Ready(_) = poll { true } else { false };\n+LL |     let _ = if let Ready(_) = poll { true } else { false };\n    |             -------^^^^^^^^------- help: try this: `if poll.is_ready()`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:51:20\n+  --> $DIR/redundant_pattern_matching_poll.rs:50:20\n    |\n LL |     let _ = if let Ready(_) = gen_poll() {\n    |             -------^^^^^^^^------------- help: try this: `if gen_poll().is_ready()`\n \n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:53:19\n+  --> $DIR/redundant_pattern_matching_poll.rs:52:19\n    |\n LL |     } else if let Pending = gen_poll() {\n    |            -------^^^^^^^------------- help: try this: `if gen_poll().is_pending()`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:71:12\n+  --> $DIR/redundant_pattern_matching_poll.rs:68:12\n    |\n LL |     if let Ready(_) = Ready(42) {}\n    |     -------^^^^^^^^------------ help: try this: `if Ready(42).is_ready()`\n \n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:73:12\n+  --> $DIR/redundant_pattern_matching_poll.rs:70:12\n    |\n LL |     if let Pending = Pending::<()> {}\n    |     -------^^^^^^^---------------- help: try this: `if Pending::<()>.is_pending()`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:75:15\n+  --> $DIR/redundant_pattern_matching_poll.rs:72:15\n    |\n LL |     while let Ready(_) = Ready(42) {}\n    |     ----------^^^^^^^^------------ help: try this: `while Ready(42).is_ready()`\n \n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:77:15\n+  --> $DIR/redundant_pattern_matching_poll.rs:74:15\n    |\n LL |     while let Pending = Pending::<()> {}\n    |     ----------^^^^^^^---------------- help: try this: `while Pending::<()>.is_pending()`\n \n error: redundant pattern matching, consider using `is_ready()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:79:5\n+  --> $DIR/redundant_pattern_matching_poll.rs:76:5\n    |\n LL | /     match Ready(42) {\n LL | |         Ready(_) => true,\n@@ -116,7 +116,7 @@ LL | |     };\n    | |_____^ help: try this: `Ready(42).is_ready()`\n \n error: redundant pattern matching, consider using `is_pending()`\n-  --> $DIR/redundant_pattern_matching_poll.rs:84:5\n+  --> $DIR/redundant_pattern_matching_poll.rs:81:5\n    |\n LL | /     match Pending::<()> {\n LL | |         Ready(_) => false,"}, {"sha": "922b8b4ce57f613069b5c5a0c9575f0f6f2bf13a", "filename": "tests/ui/redundant_slicing.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_slicing.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,11 @@\n+#![allow(unused)]\n+#![warn(clippy::redundant_slicing)]\n+\n+fn main() {\n+    let x: &[u32] = &[0];\n+    let err = &x[..];\n+\n+    let v = vec![0];\n+    let ok = &v[..];\n+    let err = &(&v[..])[..];\n+}"}, {"sha": "9efd6484ad0c1769f884f59f75b5792aa1ed1b19", "filename": "tests/ui/redundant_slicing.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_slicing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fredundant_slicing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_slicing.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,16 @@\n+error: redundant slicing of the whole range\n+  --> $DIR/redundant_slicing.rs:6:15\n+   |\n+LL |     let err = &x[..];\n+   |               ^^^^^^ help: use the original slice instead: `x`\n+   |\n+   = note: `-D clippy::redundant-slicing` implied by `-D warnings`\n+\n+error: redundant slicing of the whole range\n+  --> $DIR/redundant_slicing.rs:10:15\n+   |\n+LL |     let err = &(&v[..])[..];\n+   |               ^^^^^^^^^^^^^ help: use the original slice instead: `(&v[..])`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "ca884b41c45792ae0a6a16d39802b06b3c6fb070", "filename": "tests/ui/single_match.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -81,6 +81,62 @@ fn single_match_know_enum() {\n     }\n }\n \n+// issue #173\n+fn if_suggestion() {\n+    let x = \"test\";\n+    match x {\n+        \"test\" => println!(),\n+        _ => (),\n+    }\n+\n+    #[derive(PartialEq, Eq)]\n+    enum Foo {\n+        A,\n+        B,\n+        C(u32),\n+    }\n+\n+    let x = Foo::A;\n+    match x {\n+        Foo::A => println!(),\n+        _ => (),\n+    }\n+\n+    const FOO_C: Foo = Foo::C(0);\n+    match x {\n+        FOO_C => println!(),\n+        _ => (),\n+    }\n+\n+    match &&x {\n+        Foo::A => println!(),\n+        _ => (),\n+    }\n+\n+    let x = &x;\n+    match &x {\n+        Foo::A => println!(),\n+        _ => (),\n+    }\n+\n+    enum Bar {\n+        A,\n+        B,\n+    }\n+    impl PartialEq for Bar {\n+        fn eq(&self, rhs: &Self) -> bool {\n+            matches!((self, rhs), (Self::A, Self::A) | (Self::B, Self::B))\n+        }\n+    }\n+    impl Eq for Bar {}\n+\n+    let x = Bar::A;\n+    match x {\n+        Bar::A => println!(),\n+        _ => (),\n+    }\n+}\n+\n macro_rules! single_match {\n     ($num:literal) => {\n         match $num {"}, {"sha": "7ea6955b7401e4ecb17ca4995b820a10bf4bb5c3", "filename": "tests/ui/single_match.stderr", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fsingle_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fsingle_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,4 +1,4 @@\n-error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match.rs:8:5\n    |\n LL | /     match x {\n@@ -17,7 +17,7 @@ LL |         println!(\"{:?}\", y);\n LL |     };\n    |\n \n-error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match.rs:16:5\n    |\n LL | /     match x {\n@@ -29,7 +29,7 @@ LL | |         _ => (),\n LL | |     }\n    | |_____^ help: try this: `if let Some(y) = x { println!(\"{:?}\", y) }`\n \n-error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match.rs:25:5\n    |\n LL | /     match z {\n@@ -38,7 +38,7 @@ LL | |         _ => {},\n LL | |     };\n    | |_____^ help: try this: `if let (2..=3, 7..=9) = z { dummy() }`\n \n-error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match.rs:54:5\n    |\n LL | /     match x {\n@@ -47,7 +47,7 @@ LL | |         None => (),\n LL | |     };\n    | |_____^ help: try this: `if let Some(y) = x { dummy() }`\n \n-error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match.rs:59:5\n    |\n LL | /     match y {\n@@ -56,7 +56,7 @@ LL | |         Err(..) => (),\n LL | |     };\n    | |_____^ help: try this: `if let Ok(y) = y { dummy() }`\n \n-error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match.rs:66:5\n    |\n LL | /     match c {\n@@ -65,5 +65,59 @@ LL | |         Cow::Owned(..) => (),\n LL | |     };\n    | |_____^ help: try this: `if let Cow::Borrowed(..) = c { dummy() }`\n \n-error: aborting due to 6 previous errors\n+error: you seem to be trying to use `match` for an equality check. Consider using `if`\n+  --> $DIR/single_match.rs:87:5\n+   |\n+LL | /     match x {\n+LL | |         \"test\" => println!(),\n+LL | |         _ => (),\n+LL | |     }\n+   | |_____^ help: try this: `if x == \"test\" { println!() }`\n+\n+error: you seem to be trying to use `match` for an equality check. Consider using `if`\n+  --> $DIR/single_match.rs:100:5\n+   |\n+LL | /     match x {\n+LL | |         Foo::A => println!(),\n+LL | |         _ => (),\n+LL | |     }\n+   | |_____^ help: try this: `if x == Foo::A { println!() }`\n+\n+error: you seem to be trying to use `match` for an equality check. Consider using `if`\n+  --> $DIR/single_match.rs:106:5\n+   |\n+LL | /     match x {\n+LL | |         FOO_C => println!(),\n+LL | |         _ => (),\n+LL | |     }\n+   | |_____^ help: try this: `if x == FOO_C { println!() }`\n+\n+error: you seem to be trying to use `match` for an equality check. Consider using `if`\n+  --> $DIR/single_match.rs:111:5\n+   |\n+LL | /     match &&x {\n+LL | |         Foo::A => println!(),\n+LL | |         _ => (),\n+LL | |     }\n+   | |_____^ help: try this: `if x == Foo::A { println!() }`\n+\n+error: you seem to be trying to use `match` for an equality check. Consider using `if`\n+  --> $DIR/single_match.rs:117:5\n+   |\n+LL | /     match &x {\n+LL | |         Foo::A => println!(),\n+LL | |         _ => (),\n+LL | |     }\n+   | |_____^ help: try this: `if x == &Foo::A { println!() }`\n+\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match.rs:134:5\n+   |\n+LL | /     match x {\n+LL | |         Bar::A => println!(),\n+LL | |         _ => (),\n+LL | |     }\n+   | |_____^ help: try this: `if let Bar::A = x { println!() }`\n+\n+error: aborting due to 12 previous errors\n "}, {"sha": "20be4fa226cf154f1de72a8dcb6ab2f71285a79b", "filename": "tests/ui/single_match_else.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fsingle_match_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fsingle_match_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match_else.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,4 +1,4 @@\n-error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match_else.rs:14:5\n    |\n LL | /     match ExprNode::Butterflies {\n@@ -19,7 +19,7 @@ LL |         None\n LL |     }\n    |\n \n-error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match_else.rs:70:5\n    |\n LL | /     match Some(1) {\n@@ -39,7 +39,7 @@ LL |         return\n LL |     }\n    |\n \n-error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match_else.rs:79:5\n    |\n LL | /     match Some(1) {"}, {"sha": "b13e390705ab79e96317b57375dff763f9725039", "filename": "tests/ui/size_of_in_element_count.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fsize_of_in_element_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fsize_of_in_element_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsize_of_in_element_count.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,61 @@\n+#![warn(clippy::size_of_in_element_count)]\n+#![allow(clippy::ptr_offset_with_cast)]\n+\n+use std::mem::{size_of, size_of_val};\n+use std::ptr::{\n+    copy, copy_nonoverlapping, slice_from_raw_parts, slice_from_raw_parts_mut, swap_nonoverlapping, write_bytes,\n+};\n+use std::slice::{from_raw_parts, from_raw_parts_mut};\n+\n+fn main() {\n+    const SIZE: usize = 128;\n+    const HALF_SIZE: usize = SIZE / 2;\n+    const DOUBLE_SIZE: usize = SIZE * 2;\n+    let mut x = [2u8; SIZE];\n+    let mut y = [2u8; SIZE];\n+\n+    // Count is size_of (Should trigger the lint)\n+    unsafe { copy_nonoverlapping::<u8>(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>()) };\n+    unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0])) };\n+\n+    unsafe { x.as_ptr().copy_to(y.as_mut_ptr(), size_of::<u8>()) };\n+    unsafe { x.as_ptr().copy_to_nonoverlapping(y.as_mut_ptr(), size_of::<u8>()) };\n+    unsafe { y.as_mut_ptr().copy_from(x.as_ptr(), size_of::<u8>()) };\n+    unsafe { y.as_mut_ptr().copy_from_nonoverlapping(x.as_ptr(), size_of::<u8>()) };\n+\n+    unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>()) };\n+    unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0])) };\n+\n+    unsafe { y.as_mut_ptr().write_bytes(0u8, size_of::<u8>() * SIZE) };\n+    unsafe { write_bytes(y.as_mut_ptr(), 0u8, size_of::<u8>() * SIZE) };\n+\n+    unsafe { swap_nonoverlapping(y.as_mut_ptr(), x.as_mut_ptr(), size_of::<u8>() * SIZE) };\n+\n+    slice_from_raw_parts_mut(y.as_mut_ptr(), size_of::<u8>() * SIZE);\n+    slice_from_raw_parts(y.as_ptr(), size_of::<u8>() * SIZE);\n+\n+    unsafe { from_raw_parts_mut(y.as_mut_ptr(), size_of::<u8>() * SIZE) };\n+    unsafe { from_raw_parts(y.as_ptr(), size_of::<u8>() * SIZE) };\n+\n+    unsafe { y.as_mut_ptr().sub(size_of::<u8>()) };\n+    y.as_ptr().wrapping_sub(size_of::<u8>());\n+    unsafe { y.as_ptr().add(size_of::<u8>()) };\n+    y.as_mut_ptr().wrapping_add(size_of::<u8>());\n+    unsafe { y.as_ptr().offset(size_of::<u8>() as isize) };\n+    y.as_mut_ptr().wrapping_offset(size_of::<u8>() as isize);\n+\n+    // Count expression involving multiplication of size_of (Should trigger the lint)\n+    unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * SIZE) };\n+\n+    // Count expression involving nested multiplications of size_of (Should trigger the lint)\n+    unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), HALF_SIZE * size_of_val(&x[0]) * 2) };\n+\n+    // Count expression involving divisions of size_of (Should trigger the lint)\n+    unsafe { copy(x.as_ptr(), y.as_mut_ptr(), DOUBLE_SIZE * size_of::<u8>() / 2) };\n+\n+    // No size_of calls (Should not trigger the lint)\n+    unsafe { copy(x.as_ptr(), y.as_mut_ptr(), SIZE) };\n+\n+    // Different types for pointee and size_of (Should not trigger the lint)\n+    unsafe { y.as_mut_ptr().write_bytes(0u8, size_of::<u16>() / 2 * SIZE) };\n+}"}, {"sha": "8cf3612abda36a1dab853a18bece3bb3e48d77d8", "filename": "tests/ui/size_of_in_element_count.stderr", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fsize_of_in_element_count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fsize_of_in_element_count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsize_of_in_element_count.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,195 @@\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:18:68\n+   |\n+LL |     unsafe { copy_nonoverlapping::<u8>(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>()) };\n+   |                                                                    ^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::size-of-in-element-count` implied by `-D warnings`\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:19:62\n+   |\n+LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0])) };\n+   |                                                              ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:21:49\n+   |\n+LL |     unsafe { x.as_ptr().copy_to(y.as_mut_ptr(), size_of::<u8>()) };\n+   |                                                 ^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:22:64\n+   |\n+LL |     unsafe { x.as_ptr().copy_to_nonoverlapping(y.as_mut_ptr(), size_of::<u8>()) };\n+   |                                                                ^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:23:51\n+   |\n+LL |     unsafe { y.as_mut_ptr().copy_from(x.as_ptr(), size_of::<u8>()) };\n+   |                                                   ^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:24:66\n+   |\n+LL |     unsafe { y.as_mut_ptr().copy_from_nonoverlapping(x.as_ptr(), size_of::<u8>()) };\n+   |                                                                  ^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:26:47\n+   |\n+LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>()) };\n+   |                                               ^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:27:47\n+   |\n+LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0])) };\n+   |                                               ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:29:46\n+   |\n+LL |     unsafe { y.as_mut_ptr().write_bytes(0u8, size_of::<u8>() * SIZE) };\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:30:47\n+   |\n+LL |     unsafe { write_bytes(y.as_mut_ptr(), 0u8, size_of::<u8>() * SIZE) };\n+   |                                               ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:32:66\n+   |\n+LL |     unsafe { swap_nonoverlapping(y.as_mut_ptr(), x.as_mut_ptr(), size_of::<u8>() * SIZE) };\n+   |                                                                  ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:34:46\n+   |\n+LL |     slice_from_raw_parts_mut(y.as_mut_ptr(), size_of::<u8>() * SIZE);\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:35:38\n+   |\n+LL |     slice_from_raw_parts(y.as_ptr(), size_of::<u8>() * SIZE);\n+   |                                      ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:37:49\n+   |\n+LL |     unsafe { from_raw_parts_mut(y.as_mut_ptr(), size_of::<u8>() * SIZE) };\n+   |                                                 ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:38:41\n+   |\n+LL |     unsafe { from_raw_parts(y.as_ptr(), size_of::<u8>() * SIZE) };\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:40:33\n+   |\n+LL |     unsafe { y.as_mut_ptr().sub(size_of::<u8>()) };\n+   |                                 ^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:41:29\n+   |\n+LL |     y.as_ptr().wrapping_sub(size_of::<u8>());\n+   |                             ^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:42:29\n+   |\n+LL |     unsafe { y.as_ptr().add(size_of::<u8>()) };\n+   |                             ^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:43:33\n+   |\n+LL |     y.as_mut_ptr().wrapping_add(size_of::<u8>());\n+   |                                 ^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:44:32\n+   |\n+LL |     unsafe { y.as_ptr().offset(size_of::<u8>() as isize) };\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:45:36\n+   |\n+LL |     y.as_mut_ptr().wrapping_offset(size_of::<u8>() as isize);\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:48:62\n+   |\n+LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * SIZE) };\n+   |                                                              ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:51:62\n+   |\n+LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), HALF_SIZE * size_of_val(&x[0]) * 2) };\n+   |                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: found a count of bytes instead of a count of elements of `T`\n+  --> $DIR/size_of_in_element_count.rs:54:47\n+   |\n+LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), DOUBLE_SIZE * size_of::<u8>() / 2) };\n+   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes, it already gets multiplied by the size of the type\n+\n+error: aborting due to 24 previous errors\n+"}, {"sha": "226010ec6df3a24c63898f53a81c227b8a3781af", "filename": "tests/ui/suspicious_else_formatting.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fsuspicious_else_formatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fsuspicious_else_formatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_else_formatting.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,79 @@\n+#![warn(clippy::suspicious_else_formatting)]\n+\n+fn foo() -> bool {\n+    true\n+}\n+\n+#[rustfmt::skip]\n+fn main() {\n+    // weird `else` formatting:\n+    if foo() {\n+    } {\n+    }\n+\n+    if foo() {\n+    } if foo() {\n+    }\n+\n+    let _ = { // if as the last expression\n+        let _ = 0;\n+\n+        if foo() {\n+        } if foo() {\n+        }\n+        else {\n+        }\n+    };\n+\n+    let _ = { // if in the middle of a block\n+        if foo() {\n+        } if foo() {\n+        }\n+        else {\n+        }\n+\n+        let _ = 0;\n+    };\n+\n+    if foo() {\n+    } else\n+    {\n+    }\n+\n+    if foo() {\n+    }\n+    else\n+    {\n+    }\n+\n+    if foo() {\n+    } else\n+    if foo() { // the span of the above error should continue here\n+    }\n+\n+    if foo() {\n+    }\n+    else\n+    if foo() { // the span of the above error should continue here\n+    }\n+\n+    // those are ok:\n+    if foo() {\n+    }\n+    {\n+    }\n+\n+    if foo() {\n+    } else {\n+    }\n+\n+    if foo() {\n+    }\n+    else {\n+    }\n+\n+    if foo() {\n+    }\n+    if foo() {\n+    }\n+}"}, {"sha": "bbc036d376fefc9ead1a8cb034eceb23f3a728c5", "filename": "tests/ui/suspicious_else_formatting.stderr", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fsuspicious_else_formatting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fsuspicious_else_formatting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_else_formatting.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,77 @@\n+error: this looks like an `else {..}` but the `else` is missing\n+  --> $DIR/suspicious_else_formatting.rs:11:6\n+   |\n+LL |     } {\n+   |      ^\n+   |\n+   = note: `-D clippy::suspicious-else-formatting` implied by `-D warnings`\n+   = note: to remove this lint, add the missing `else` or add a new line before the next block\n+\n+error: this looks like an `else if` but the `else` is missing\n+  --> $DIR/suspicious_else_formatting.rs:15:6\n+   |\n+LL |     } if foo() {\n+   |      ^\n+   |\n+   = note: to remove this lint, add the missing `else` or add a new line before the second `if`\n+\n+error: this looks like an `else if` but the `else` is missing\n+  --> $DIR/suspicious_else_formatting.rs:22:10\n+   |\n+LL |         } if foo() {\n+   |          ^\n+   |\n+   = note: to remove this lint, add the missing `else` or add a new line before the second `if`\n+\n+error: this looks like an `else if` but the `else` is missing\n+  --> $DIR/suspicious_else_formatting.rs:30:10\n+   |\n+LL |         } if foo() {\n+   |          ^\n+   |\n+   = note: to remove this lint, add the missing `else` or add a new line before the second `if`\n+\n+error: this is an `else {..}` but the formatting might hide it\n+  --> $DIR/suspicious_else_formatting.rs:39:6\n+   |\n+LL |       } else\n+   |  ______^\n+LL | |     {\n+   | |____^\n+   |\n+   = note: to remove this lint, remove the `else` or remove the new line between `else` and `{..}`\n+\n+error: this is an `else {..}` but the formatting might hide it\n+  --> $DIR/suspicious_else_formatting.rs:44:6\n+   |\n+LL |       }\n+   |  ______^\n+LL | |     else\n+LL | |     {\n+   | |____^\n+   |\n+   = note: to remove this lint, remove the `else` or remove the new line between `else` and `{..}`\n+\n+error: this is an `else if` but the formatting might hide it\n+  --> $DIR/suspicious_else_formatting.rs:50:6\n+   |\n+LL |       } else\n+   |  ______^\n+LL | |     if foo() { // the span of the above error should continue here\n+   | |____^\n+   |\n+   = note: to remove this lint, remove the `else` or remove the new line between `else` and `if`\n+\n+error: this is an `else if` but the formatting might hide it\n+  --> $DIR/suspicious_else_formatting.rs:55:6\n+   |\n+LL |       }\n+   |  ______^\n+LL | |     else\n+LL | |     if foo() { // the span of the above error should continue here\n+   | |____^\n+   |\n+   = note: to remove this lint, remove the `else` or remove the new line between `else` and `if`\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "dd6f4ec7bd9b57bed579d463145cf35be8757302", "filename": "tests/ui/suspicious_operation_groupings.rs", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_operation_groupings.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,207 @@\n+#![warn(clippy::suspicious_operation_groupings)]\n+\n+struct Vec3 {\n+    x: f64,\n+    y: f64,\n+    z: f64,\n+}\n+\n+impl Eq for Vec3 {}\n+\n+impl PartialEq for Vec3 {\n+    fn eq(&self, other: &Self) -> bool {\n+        // This should trigger the lint because `self.x` is compared to `other.y`\n+        self.x == other.y && self.y == other.y && self.z == other.z\n+    }\n+}\n+\n+struct S {\n+    a: i32,\n+    b: i32,\n+    c: i32,\n+    d: i32,\n+}\n+\n+fn buggy_ab_cmp(s1: &S, s2: &S) -> bool {\n+    // There's no `s1.b`\n+    s1.a < s2.a && s1.a < s2.b\n+}\n+\n+struct SAOnly {\n+    a: i32,\n+}\n+\n+impl S {\n+    fn a(&self) -> i32 {\n+        0\n+    }\n+}\n+\n+fn do_not_give_bad_suggestions_for_this_unusual_expr(s1: &S, s2: &SAOnly) -> bool {\n+    // This is superficially similar to `buggy_ab_cmp`, but we should not suggest\n+    // `s2.b` since that is invalid.\n+    s1.a < s2.a && s1.a() < s1.b\n+}\n+\n+fn do_not_give_bad_suggestions_for_this_macro_expr(s1: &S, s2: &SAOnly) -> bool {\n+    macro_rules! s1 {\n+        () => {\n+            S {\n+                a: 1,\n+                b: 1,\n+                c: 1,\n+                d: 1,\n+            }\n+        };\n+    }\n+\n+    // This is superficially similar to `buggy_ab_cmp`, but we should not suggest\n+    // `s2.b` since that is invalid.\n+    s1.a < s2.a && s1!().a < s1.b\n+}\n+\n+fn do_not_give_bad_suggestions_for_this_incorrect_expr(s1: &S, s2: &SAOnly) -> bool {\n+    // There's two `s1.b`, but we should not suggest `s2.b` since that is invalid\n+    s1.a < s2.a && s1.b < s1.b\n+}\n+\n+fn permissable(s1: &S, s2: &S) -> bool {\n+    // Something like this seems like it might actually be what is desired.\n+    s1.a == s2.b\n+}\n+\n+fn non_boolean_operators(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.c`\n+    s1.a * s2.a + s1.b * s2.b + s1.c * s2.b + s1.d * s2.d\n+}\n+\n+fn odd_number_of_pairs(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.b`\n+    s1.a * s2.a + s1.b * s2.c + s1.c * s2.c\n+}\n+\n+fn not_caught_by_eq_op_middle_change_left(s1: &S, s2: &S) -> i32 {\n+    // There's no `s1.b`\n+    s1.a * s2.a + s2.b * s2.b + s1.c * s2.c\n+}\n+\n+fn not_caught_by_eq_op_middle_change_right(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.b`\n+    s1.a * s2.a + s1.b * s1.b + s1.c * s2.c\n+}\n+\n+fn not_caught_by_eq_op_start(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.a`\n+    s1.a * s1.a + s1.b * s2.b + s1.c * s2.c\n+}\n+\n+fn not_caught_by_eq_op_end(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.c`\n+    s1.a * s2.a + s1.b * s2.b + s1.c * s1.c\n+}\n+\n+fn the_cross_product_should_not_lint(s1: &S, s2: &S) -> (i32, i32, i32) {\n+    (\n+        s1.b * s2.c - s1.c * s2.b,\n+        s1.c * s2.a - s1.a * s2.c,\n+        s1.a * s2.b - s1.b * s2.a,\n+    )\n+}\n+\n+fn outer_parens_simple(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.b`\n+    (s1.a * s2.a + s1.b * s1.b)\n+}\n+\n+fn outer_parens(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.c`\n+    (s1.a * s2.a + s1.b * s2.b + s1.c * s2.b + s1.d * s2.d)\n+}\n+\n+fn inner_parens(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.c`\n+    (s1.a * s2.a) + (s1.b * s2.b) + (s1.c * s2.b) + (s1.d * s2.d)\n+}\n+\n+fn outer_and_some_inner_parens(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.c`\n+    ((s1.a * s2.a) + (s1.b * s2.b) + (s1.c * s2.b) + (s1.d * s2.d))\n+}\n+\n+fn all_parens_balanced_tree(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.c`\n+    (((s1.a * s2.a) + (s1.b * s2.b)) + ((s1.c * s2.b) + (s1.d * s2.d)))\n+}\n+\n+fn all_parens_left_tree(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.c`\n+    (((s1.a * s2.a) + (s1.b * s2.b) + (s1.c * s2.b)) + (s1.d * s2.d))\n+}\n+\n+fn all_parens_right_tree(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.c`\n+    ((s1.a * s2.a) + ((s1.b * s2.b) + (s1.c * s2.b) + (s1.d * s2.d)))\n+}\n+\n+fn inside_other_binop_expression(s1: &S, s2: &S) -> i32 {\n+    // There's no `s1.b`\n+    (s1.a * s2.a + s2.b * s2.b) / 2\n+}\n+\n+fn inside_function_call(s1: &S, s2: &S) -> i32 {\n+    // There's no `s1.b`\n+    i32::swap_bytes(s1.a * s2.a + s2.b * s2.b)\n+}\n+\n+fn inside_larger_boolean_expression(s1: &S, s2: &S) -> bool {\n+    // There's no `s1.c`\n+    s1.a > 0 && s1.b > 0 && s1.d == s2.c && s1.d == s2.d\n+}\n+\n+fn inside_larger_boolean_expression_with_unsorted_ops(s1: &S, s2: &S) -> bool {\n+    // There's no `s1.c`\n+    s1.a > 0 && s1.d == s2.c && s1.b > 0 && s1.d == s2.d\n+}\n+\n+struct Nested {\n+    inner: ((i32,), (i32,), (i32,)),\n+}\n+\n+fn changed_middle_ident(n1: &Nested, n2: &Nested) -> bool {\n+    // There's no `n2.inner.2.0`\n+    (n1.inner.0).0 == (n2.inner.0).0 && (n1.inner.1).0 == (n2.inner.1).0 && (n1.inner.2).0 == (n2.inner.1).0\n+}\n+\n+// `eq_op` should catch this one.\n+fn changed_initial_ident(n1: &Nested, n2: &Nested) -> bool {\n+    // There's no `n2.inner.0.0`\n+    (n1.inner.0).0 == (n1.inner.0).0 && (n1.inner.1).0 == (n2.inner.1).0 && (n1.inner.2).0 == (n2.inner.2).0\n+}\n+\n+fn inside_fn_with_similar_expression(s1: &S, s2: &S, strict: bool) -> bool {\n+    if strict {\n+        s1.a < s2.a && s1.b < s2.b\n+    } else {\n+        // There's no `s1.b` in this subexpression\n+        s1.a <= s2.a && s1.a <= s2.b\n+    }\n+}\n+\n+fn inside_an_if_statement(s1: &S, s2: &S) {\n+    // There's no `s1.b`\n+    if s1.a < s2.a && s1.a < s2.b {\n+        s1.c = s2.c;\n+    }\n+}\n+\n+fn maximum_unary_minus_right_tree(s1: &S, s2: &S) -> i32 {\n+    // There's no `s2.c`\n+    -(-(-s1.a * -s2.a) + (-(-s1.b * -s2.b) + -(-s1.c * -s2.b) + -(-s1.d * -s2.d)))\n+}\n+\n+fn unary_minus_and_an_if_expression(s1: &S, s2: &S) -> i32 {\n+    // There's no `s1.b`\n+    -(if -s1.a < -s2.a && -s1.a < -s2.b { s1.c } else { s2.a })\n+}\n+\n+fn main() {}"}, {"sha": "ce7108217f18dccd5d81743633318de7124697ae", "filename": "tests/ui/suspicious_operation_groupings.stderr", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fsuspicious_operation_groupings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Fsuspicious_operation_groupings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_operation_groupings.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -0,0 +1,166 @@\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:14:9\n+   |\n+LL |         self.x == other.y && self.y == other.y && self.z == other.z\n+   |         ^^^^^^^^^^^^^^^^^ help: I think you meant: `self.x == other.x`\n+   |\n+   = note: `-D clippy::suspicious-operation-groupings` implied by `-D warnings`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:14:9\n+   |\n+LL |         self.x == other.y && self.y == other.y && self.z == other.z\n+   |         ^^^^^^^^^^^^^^^^^ help: I think you meant: `self.x == other.x`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:27:20\n+   |\n+LL |     s1.a < s2.a && s1.a < s2.b\n+   |                    ^^^^^^^^^^^ help: I think you meant: `s1.b < s2.b`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:75:33\n+   |\n+LL |     s1.a * s2.a + s1.b * s2.b + s1.c * s2.b + s1.d * s2.d\n+   |                                 ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:80:19\n+   |\n+LL |     s1.a * s2.a + s1.b * s2.c + s1.c * s2.c\n+   |                   ^^^^^^^^^^^ help: I think you meant: `s1.b * s2.b`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:80:19\n+   |\n+LL |     s1.a * s2.a + s1.b * s2.c + s1.c * s2.c\n+   |                   ^^^^^^^^^^^ help: I think you meant: `s1.b * s2.b`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:85:19\n+   |\n+LL |     s1.a * s2.a + s2.b * s2.b + s1.c * s2.c\n+   |                   ^^^^^^^^^^^ help: I think you meant: `s1.b * s2.b`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:90:19\n+   |\n+LL |     s1.a * s2.a + s1.b * s1.b + s1.c * s2.c\n+   |                   ^^^^^^^^^^^ help: I think you meant: `s1.b * s2.b`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:95:5\n+   |\n+LL |     s1.a * s1.a + s1.b * s2.b + s1.c * s2.c\n+   |     ^^^^^^^^^^^ help: I think you meant: `s1.a * s2.a`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:100:33\n+   |\n+LL |     s1.a * s2.a + s1.b * s2.b + s1.c * s1.c\n+   |                                 ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:113:20\n+   |\n+LL |     (s1.a * s2.a + s1.b * s1.b)\n+   |                    ^^^^^^^^^^^ help: I think you meant: `s1.b * s2.b`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:118:34\n+   |\n+LL |     (s1.a * s2.a + s1.b * s2.b + s1.c * s2.b + s1.d * s2.d)\n+   |                                  ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:123:38\n+   |\n+LL |     (s1.a * s2.a) + (s1.b * s2.b) + (s1.c * s2.b) + (s1.d * s2.d)\n+   |                                      ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:128:39\n+   |\n+LL |     ((s1.a * s2.a) + (s1.b * s2.b) + (s1.c * s2.b) + (s1.d * s2.d))\n+   |                                       ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:133:42\n+   |\n+LL |     (((s1.a * s2.a) + (s1.b * s2.b)) + ((s1.c * s2.b) + (s1.d * s2.d)))\n+   |                                          ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:133:42\n+   |\n+LL |     (((s1.a * s2.a) + (s1.b * s2.b)) + ((s1.c * s2.b) + (s1.d * s2.d)))\n+   |                                          ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:138:40\n+   |\n+LL |     (((s1.a * s2.a) + (s1.b * s2.b) + (s1.c * s2.b)) + (s1.d * s2.d))\n+   |                                        ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:143:40\n+   |\n+LL |     ((s1.a * s2.a) + ((s1.b * s2.b) + (s1.c * s2.b) + (s1.d * s2.d)))\n+   |                                        ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:148:20\n+   |\n+LL |     (s1.a * s2.a + s2.b * s2.b) / 2\n+   |                    ^^^^^^^^^^^ help: I think you meant: `s1.b * s2.b`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:153:35\n+   |\n+LL |     i32::swap_bytes(s1.a * s2.a + s2.b * s2.b)\n+   |                                   ^^^^^^^^^^^ help: I think you meant: `s1.b * s2.b`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:158:29\n+   |\n+LL |     s1.a > 0 && s1.b > 0 && s1.d == s2.c && s1.d == s2.d\n+   |                             ^^^^^^^^^^^^ help: I think you meant: `s1.c == s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:163:17\n+   |\n+LL |     s1.a > 0 && s1.d == s2.c && s1.b > 0 && s1.d == s2.d\n+   |                 ^^^^^^^^^^^^ help: I think you meant: `s1.c == s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:172:77\n+   |\n+LL |     (n1.inner.0).0 == (n2.inner.0).0 && (n1.inner.1).0 == (n2.inner.1).0 && (n1.inner.2).0 == (n2.inner.1).0\n+   |                                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: I think you meant: `(n1.inner.2).0 == (n2.inner.2).0`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:186:25\n+   |\n+LL |         s1.a <= s2.a && s1.a <= s2.b\n+   |                         ^^^^^^^^^^^^ help: I think you meant: `s1.b <= s2.b`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:192:23\n+   |\n+LL |     if s1.a < s2.a && s1.a < s2.b {\n+   |                       ^^^^^^^^^^^ help: I think you meant: `s1.b < s2.b`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:199:48\n+   |\n+LL |     -(-(-s1.a * -s2.a) + (-(-s1.b * -s2.b) + -(-s1.c * -s2.b) + -(-s1.d * -s2.d)))\n+   |                                                ^^^^^^^^^^^^^ help: I think you meant: `-s1.c * -s2.c`\n+\n+error: This sequence of operators looks suspiciously like a bug.\n+  --> $DIR/suspicious_operation_groupings.rs:204:27\n+   |\n+LL |     -(if -s1.a < -s2.a && -s1.a < -s2.b { s1.c } else { s2.a })\n+   |                           ^^^^^^^^^^^^^ help: I think you meant: `-s1.b < -s2.b`\n+\n+error: aborting due to 27 previous errors\n+"}, {"sha": "5b96bb59c5f188beda95e9f595bb496114dd7706", "filename": "tests/ui/try_err.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Ftry_err.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Ftry_err.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftry_err.fixed?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -2,7 +2,7 @@\n // aux-build:macro_rules.rs\n \n #![deny(clippy::try_err)]\n-#![allow(clippy::unnecessary_wraps)]\n+#![allow(clippy::unnecessary_wraps, clippy::needless_question_mark)]\n \n #[macro_use]\n extern crate macro_rules;"}, {"sha": "f220d697d2cd7e5e0592596605bb0b038ef6a468", "filename": "tests/ui/try_err.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftry_err.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -2,7 +2,7 @@\n // aux-build:macro_rules.rs\n \n #![deny(clippy::try_err)]\n-#![allow(clippy::unnecessary_wraps)]\n+#![allow(clippy::unnecessary_wraps, clippy::needless_question_mark)]\n \n #[macro_use]\n extern crate macro_rules;"}, {"sha": "b6a7bc5a1cc95466bd3f3d4fa0c28a6998053753", "filename": "tests/ui/unit_arg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_arg.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -5,7 +5,8 @@\n     unused_variables,\n     clippy::unused_unit,\n     clippy::unnecessary_wraps,\n-    clippy::or_fun_call\n+    clippy::or_fun_call,\n+    clippy::needless_question_mark\n )]\n \n use std::fmt::Debug;"}, {"sha": "094cff8c98591146dd7558d321afed17894cd9d6", "filename": "tests/ui/unit_arg.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Funit_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Funit_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_arg.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -1,5 +1,5 @@\n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:30:5\n+  --> $DIR/unit_arg.rs:31:5\n    |\n LL | /     foo({\n LL | |         1;\n@@ -20,7 +20,7 @@ LL |     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:33:5\n+  --> $DIR/unit_arg.rs:34:5\n    |\n LL |     foo(foo(1));\n    |     ^^^^^^^^^^^\n@@ -32,7 +32,7 @@ LL |     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:34:5\n+  --> $DIR/unit_arg.rs:35:5\n    |\n LL | /     foo({\n LL | |         foo(1);\n@@ -54,7 +54,7 @@ LL |     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:39:5\n+  --> $DIR/unit_arg.rs:40:5\n    |\n LL | /     b.bar({\n LL | |         1;\n@@ -74,7 +74,7 @@ LL |     b.bar(());\n    |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:42:5\n+  --> $DIR/unit_arg.rs:43:5\n    |\n LL |     taking_multiple_units(foo(0), foo(1));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -87,7 +87,7 @@ LL |     taking_multiple_units((), ());\n    |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:43:5\n+  --> $DIR/unit_arg.rs:44:5\n    |\n LL | /     taking_multiple_units(foo(0), {\n LL | |         foo(1);\n@@ -110,7 +110,7 @@ LL |     taking_multiple_units((), ());\n    |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:47:5\n+  --> $DIR/unit_arg.rs:48:5\n    |\n LL | /     taking_multiple_units(\n LL | |         {\n@@ -140,7 +140,7 @@ LL |         foo(2);\n  ...\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:58:13\n+  --> $DIR/unit_arg.rs:59:13\n    |\n LL |     None.or(Some(foo(2)));\n    |             ^^^^^^^^^^^^\n@@ -154,7 +154,7 @@ LL |     });\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:61:5\n+  --> $DIR/unit_arg.rs:62:5\n    |\n LL |     foo(foo(()))\n    |     ^^^^^^^^^^^^\n@@ -166,7 +166,7 @@ LL |     foo(())\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:94:5\n+  --> $DIR/unit_arg.rs:95:5\n    |\n LL |     Some(foo(1))\n    |     ^^^^^^^^^^^^"}, {"sha": "9df1ae568673084298ac3c1acb5672c602616a50", "filename": "tests/ui/unnecessary_clone.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Funnecessary_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Funnecessary_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_clone.stderr?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -30,21 +30,21 @@ error: using `.clone()` on a ref-counted pointer\n LL |     let _: Arc<dyn SomeTrait> = x.clone();\n    |                                 ^^^^^^^^^ help: try this: `Arc::<SomeImpl>::clone(&x)`\n \n-error: using `clone` on a `Copy` type\n+error: using `clone` on type `T` which implements the `Copy` trait\n   --> $DIR/unnecessary_clone.rs:40:5\n    |\n LL |     t.clone();\n    |     ^^^^^^^^^ help: try removing the `clone` call: `t`\n    |\n    = note: `-D clippy::clone-on-copy` implied by `-D warnings`\n \n-error: using `clone` on a `Copy` type\n+error: using `clone` on type `std::option::Option<T>` which implements the `Copy` trait\n   --> $DIR/unnecessary_clone.rs:42:5\n    |\n LL |     Some(t).clone();\n    |     ^^^^^^^^^^^^^^^ help: try removing the `clone` call: `Some(t)`\n \n-error: using `clone` on a double-reference; this will copy the reference instead of cloning the inner type\n+error: using `clone` on a double-reference; this will copy the reference of type `&std::vec::Vec<i32>` instead of cloning the inner type\n   --> $DIR/unnecessary_clone.rs:48:22\n    |\n LL |     let z: &Vec<_> = y.clone();\n@@ -60,13 +60,13 @@ help: or try being explicit if you are sure, that you want to clone a reference\n LL |     let z: &Vec<_> = <&std::vec::Vec<i32>>::clone(y);\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: using `clone` on a `Copy` type\n+error: using `clone` on type `many_derefs::E` which implements the `Copy` trait\n   --> $DIR/unnecessary_clone.rs:84:20\n    |\n LL |         let _: E = a.clone();\n    |                    ^^^^^^^^^ help: try dereferencing it: `*****a`\n \n-error: using `clone` on a double-reference; this will copy the reference instead of cloning the inner type\n+error: using `clone` on a double-reference; this will copy the reference of type `&[u8]` instead of cloning the inner type\n   --> $DIR/unnecessary_clone.rs:89:22\n    |\n LL |         let _ = &mut encoded.clone();\n@@ -81,7 +81,7 @@ help: or try being explicit if you are sure, that you want to clone a reference\n LL |         let _ = &mut <&[u8]>::clone(encoded);\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: using `clone` on a double-reference; this will copy the reference instead of cloning the inner type\n+error: using `clone` on a double-reference; this will copy the reference of type `&[u8]` instead of cloning the inner type\n   --> $DIR/unnecessary_clone.rs:90:18\n    |\n LL |         let _ = &encoded.clone();"}, {"sha": "b05dd143bfd745f6901e2fd34109bdae5fdd611c", "filename": "tests/ui/unnecessary_lazy_eval_unfixable.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Funnecessary_lazy_eval_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Funnecessary_lazy_eval_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_lazy_eval_unfixable.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -15,4 +15,8 @@ fn main() {\n     }\n     let _ = Ok(1).unwrap_or_else(|e::E| 2);\n     let _ = Ok(1).unwrap_or_else(|SomeStruct { .. }| 2);\n+\n+    // Fix #6343\n+    let arr = [(Some(1),)];\n+    Some(&0).and_then(|&i| arr[i].0);\n }"}, {"sha": "a4570098d7167da8393f6c4933d20cf277be8962", "filename": "tests/ui/unnecessary_wraps.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_wraps.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -109,6 +109,13 @@ impl B for A {\n     }\n }\n \n+fn issue_6384(s: &str) -> Option<&str> {\n+    Some(match s {\n+        \"a\" => \"A\",\n+        _ => return None,\n+    })\n+}\n+\n fn main() {\n     // method calls are not linted\n     func1(true, true);"}, {"sha": "c2e38037addd2465af022e7ce1b786ca33b24260", "filename": "tests/ui/unreadable_literal.fixed", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Funreadable_literal.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Funreadable_literal.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funreadable_literal.fixed?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -10,6 +10,14 @@ macro_rules! foo {\n     };\n }\n \n+struct Bar(f32);\n+\n+macro_rules! bar {\n+    () => {\n+        Bar(100200300400.100200300400500)\n+    };\n+}\n+\n fn main() {\n     let _good = (\n         0b1011_i64,\n@@ -26,10 +34,12 @@ fn main() {\n     let _good_sci = 1.1234e1;\n     let _bad_sci = 1.123_456e1;\n \n-    let _fail9 = 0x00ab_cdef;\n-    let _fail10: u32 = 0xBAFE_BAFE;\n-    let _fail11 = 0x0abc_deff;\n-    let _fail12: i128 = 0x00ab_cabc_abca_bcab_cabc;\n+    let _fail1 = 0x00ab_cdef;\n+    let _fail2: u32 = 0xBAFE_BAFE;\n+    let _fail3 = 0x0abc_deff;\n+    let _fail4: i128 = 0x00ab_cabc_abca_bcab_cabc;\n+    let _fail5 = 1.100_300_400;\n \n     let _ = foo!();\n+    let _ = bar!();\n }"}, {"sha": "8296945b25eb4713fc702fa08d298cdf2d9a6214", "filename": "tests/ui/unreadable_literal.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Funreadable_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb943fbe86055a1ea2738113f74e5cbde7dd667a/tests%2Fui%2Funreadable_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funreadable_literal.rs?ref=fb943fbe86055a1ea2738113f74e5cbde7dd667a", "patch": "@@ -10,6 +10,14 @@ macro_rules! foo {\n     };\n }\n \n+struct Bar(f32);\n+\n+macro_rules! bar {\n+    () => {\n+        Bar(100200300400.100200300400500)\n+    };\n+}\n+\n fn main() {\n     let _good = (\n         0b1011_i64,\n@@ -26,10 +34,12 @@ fn main() {\n     let _good_sci = 1.1234e1;\n     let _bad_sci = 1.123456e1;\n \n-    let _fail9 = 0xabcdef;\n-    let _fail10: u32 = 0xBAFEBAFE;\n-    let _fail11 = 0xabcdeff;\n-    let _fail12: i128 = 0xabcabcabcabcabcabc;\n+    let _fail1 = 0xabcdef;\n+    let _fail2: u32 = 0xBAFEBAFE;\n+    let _fail3 = 0xabcdeff;\n+    let _fail4: i128 = 0xabcabcabcabcabcabc;\n+    let _fail5 = 1.100300400;\n \n     let _ = foo!();\n+    let _ = bar!();\n }"}]}