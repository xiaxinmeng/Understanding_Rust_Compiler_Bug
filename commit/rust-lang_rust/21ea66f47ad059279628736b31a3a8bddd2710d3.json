{"sha": "21ea66f47ad059279628736b31a3a8bddd2710d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxZWE2NmY0N2FkMDU5Mjc5NjI4NzM2YjMxYTNhOGJkZGQyNzEwZDM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-12-13T03:58:48Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-12-23T20:12:45Z"}, "message": "Add structs for ranges to core::ops.", "tree": {"sha": "69fc30d89fadcfc69bea00673820d50209384408", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69fc30d89fadcfc69bea00673820d50209384408"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21ea66f47ad059279628736b31a3a8bddd2710d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21ea66f47ad059279628736b31a3a8bddd2710d3", "html_url": "https://github.com/rust-lang/rust/commit/21ea66f47ad059279628736b31a3a8bddd2710d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21ea66f47ad059279628736b31a3a8bddd2710d3/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "658529467d9d69ac9e09cacf98a6d61d781c2c76", "url": "https://api.github.com/repos/rust-lang/rust/commits/658529467d9d69ac9e09cacf98a6d61d781c2c76", "html_url": "https://github.com/rust-lang/rust/commit/658529467d9d69ac9e09cacf98a6d61d781c2c76"}], "stats": {"total": 142, "additions": 141, "deletions": 1}, "files": [{"sha": "9de723f38ee97fbd45ff614c9a60cc35c41085b8", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21ea66f47ad059279628736b31a3a8bddd2710d3/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ea66f47ad059279628736b31a3a8bddd2710d3/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=21ea66f47ad059279628736b31a3a8bddd2710d3", "patch": "@@ -59,7 +59,7 @@\n #![allow(unknown_features, raw_pointer_deriving)]\n #![feature(globs, intrinsics, lang_items, macro_rules, phase)]\n #![feature(simd, unsafe_destructor, slicing_syntax)]\n-#![feature(default_type_params, unboxed_closures)]\n+#![feature(default_type_params, unboxed_closures, associated_types)]\n #![deny(missing_docs)]\n \n mod macros;"}, {"sha": "63451d06cb507f995064043ed540e4ece8fe9b57", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/21ea66f47ad059279628736b31a3a8bddd2710d3/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ea66f47ad059279628736b31a3a8bddd2710d3/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=21ea66f47ad059279628736b31a3a8bddd2710d3", "patch": "@@ -51,7 +51,12 @@\n //! See the documentation for each trait for a minimum implementation that prints\n //! something to the screen.\n \n+use clone::Clone;\n+use cmp::Ord;\n+use iter::{Iterator,DoubleEndedIterator};\n use kinds::Sized;\n+use kinds::Copy;\n+use option::Option::{mod, Some, None};\n \n /// The `Drop` trait is used to run some code when a value goes out of scope. This\n /// is sometimes called a 'destructor'.\n@@ -833,6 +838,114 @@ pub trait SliceMut<Sized? Idx, Sized? Result> for Sized? {\n     fn slice_or_fail_mut<'a>(&'a mut self, from: &Idx, to: &Idx) -> &'a mut Result;\n }\n \n+\n+\n+/// REVIEW could be in a better module\n+/// The `Countable` trait identifies objects which are countable, i.e., are\n+/// analogous to the natural numbers. A countable object can be incremented and\n+/// and decremented and ordered. The `difference` function provides a way to\n+/// compare two Countable objects (it could be provided using increment and Ord,\n+/// but the implementation would be so inefficient as to be useless).\n+#[unstable = \"Trait is unstable.\"]\n+pub trait Countable: Ord {\n+    // FIXME(#19391) needs a snapshot\n+    //type T;\n+\n+    /// Change self to the next object.\n+    fn increment(&mut self);\n+    /// Change self to the previous object.\n+    fn decrement(&mut self);\n+    /// The difference between two countable objects.\n+    /// Temporarily a uint, should be an associated type, but\n+    // FIXME(#19391) needs a snapshot\n+    fn difference(a: &Self, b: &Self) -> uint;\n+    //fn difference(a: &Self, b: &Self) -> <Self as Countable>::T;\n+}\n+\n+macro_rules! countable_impl(\n+    ($($t:ty)*) => ($(\n+        #[unstable = \"Trait is unstable.\"]\n+        impl Countable for $t {\n+            // FIXME(#19391) needs a snapshot\n+            //type T = uint;\n+\n+            #[inline]\n+            fn increment(&mut self) { *self += 1; }\n+            #[inline]\n+            fn decrement(&mut self) { *self -= 1; }\n+            #[inline]\n+            fn difference(a: &$t, b: &$t) -> uint { (*a - *b) as uint }\n+        }\n+    )*)\n+)\n+\n+countable_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n+\n+/// An unbounded range.\n+pub struct FullRange;\n+\n+/// A range which i bounded at both ends.\n+pub struct Range<Idx> {\n+    /// The lower bound of the range (inclusive).\n+    pub start: Idx,\n+    /// The upper bound of the range (exclusive).\n+    pub end: Idx,\n+}\n+\n+// FIXME(#19391) needs a snapshot\n+//impl<Idx: Clone + Countable<T=uint>> Iterator<Idx> for Range<Idx> {\n+impl<Idx: Clone + Countable> Iterator<Idx> for Range<Idx> {\n+    #[inline]\n+    fn next(&mut self) -> Option<Idx> {\n+        if self.start < self.end {\n+            let result = self.start.clone();\n+            self.start.increment();\n+            return Some(result);\n+        }\n+\n+        return None;\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let hint = Countable::difference(&self.end, &self.start);\n+        (hint, Some(hint))\n+    }\n+}\n+\n+impl<Idx: Clone + Countable> DoubleEndedIterator<Idx> for Range<Idx> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Idx> {\n+        if self.start < self.end {\n+            self.end.decrement();\n+            return Some(self.end.clone());\n+        }\n+\n+        return None;\n+    }\n+}\n+\n+/// A range which is only bounded below.\n+pub struct RangeFrom<Idx> {\n+    /// The lower bound of the range (inclusive).\n+    pub start: Idx,\n+}\n+\n+impl<Idx: Clone + Countable> Iterator<Idx> for RangeFrom<Idx> {\n+    #[inline]\n+    fn next(&mut self) -> Option<Idx> {\n+        // Deliberately overflow so we loop forever.\n+        let result = self.start.clone();\n+        self.start.increment();\n+        return Some(result);\n+    }\n+}\n+\n+impl<Idx: Copy> Copy for Range<Idx> {}\n+impl<Idx: Copy> Copy for RangeFrom<Idx> {}\n+impl Copy for FullRange {}\n+\n+\n /// The `Deref` trait is used to specify the functionality of dereferencing\n /// operations like `*v`.\n ///"}, {"sha": "c4acef32ee81c79b10077d05946f83fb8cd1003b", "filename": "src/libcoretest/ops.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/21ea66f47ad059279628736b31a3a8bddd2710d3/src%2Flibcoretest%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ea66f47ad059279628736b31a3a8bddd2710d3/src%2Flibcoretest%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fops.rs?ref=21ea66f47ad059279628736b31a3a8bddd2710d3", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use test::Bencher;\n+use core::ops::{Range, FullRange, RangeFrom};\n \n // Overhead of dtors\n \n@@ -27,3 +28,29 @@ fn alloc_obj_with_dtor(b: &mut Bencher) {\n         HasDtor { _x : 10 };\n     })\n }\n+\n+// Test the Range structs without the syntactic sugar.\n+\n+#[test]\n+fn test_range() {\n+    let r = Range { start: 2u, end: 10 };\n+    for (i, ri) in r.enumerate() {\n+        assert!(ri == i + 2);\n+        assert!(ri >= 2u && ri < 10u);\n+    }\n+}\n+\n+#[test]\n+fn test_range_from() {\n+    let r = RangeFrom { start: 2u };\n+    for (i, ri) in r.take(10).enumerate() {\n+        assert!(ri == i + 2);\n+        assert!(ri >= 2u && ri < 12u);\n+    }\n+}\n+\n+#[test]\n+fn test_full_range() {\n+    // Not much to test.\n+    let _ = FullRange;\n+}"}]}