{"sha": "121ae1d29cd22e3438732077b6fc3d3587f30ec3", "node_id": "C_kwDOAAsO6NoAKDEyMWFlMWQyOWNkMjJlMzQzODczMjA3N2I2ZmMzZDM1ODdmMzBlYzM", "commit": {"author": {"name": "Jacob Hoffman-Andrews", "email": "github@hoffman-andrews.com", "date": "2023-03-09T22:23:56Z"}, "committer": {"name": "Jacob Hoffman-Andrews", "email": "github@hoffman-andrews.com", "date": "2023-03-11T23:36:50Z"}, "message": "rustdoc: reduce allocs in FnDecl::inner_full_print\n\nInstead of maintaining parallel buffers for both HTML and non-HTML output,\nfollow the idiom from the rest of format.rs that f.alternate() == true means\ntextual output. Also, add an argument to control line wrapping explicitly.\n\nThis allows the caller to render once with textual output and no line wrapping,\nto decide whether line wrapping should be applied in the final HTML output.\n\nAlso, remove some format! and \" \".repeat calls, and remove a dependency on\ncalling `String::replace` to switch from newlines to spaces.\n\nThis coincidentally fixes some minor bugs where the old code was undercounting\nthe number of characters for a declaration in text mode.", "tree": {"sha": "23d82ec82d747a4ae6fdb4c942eb70ddaa0e1acb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23d82ec82d747a4ae6fdb4c942eb70ddaa0e1acb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/121ae1d29cd22e3438732077b6fc3d3587f30ec3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/121ae1d29cd22e3438732077b6fc3d3587f30ec3", "html_url": "https://github.com/rust-lang/rust/commit/121ae1d29cd22e3438732077b6fc3d3587f30ec3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/121ae1d29cd22e3438732077b6fc3d3587f30ec3/comments", "author": {"login": "jsha", "id": 220205, "node_id": "MDQ6VXNlcjIyMDIwNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/220205?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsha", "html_url": "https://github.com/jsha", "followers_url": "https://api.github.com/users/jsha/followers", "following_url": "https://api.github.com/users/jsha/following{/other_user}", "gists_url": "https://api.github.com/users/jsha/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsha/subscriptions", "organizations_url": "https://api.github.com/users/jsha/orgs", "repos_url": "https://api.github.com/users/jsha/repos", "events_url": "https://api.github.com/users/jsha/events{/privacy}", "received_events_url": "https://api.github.com/users/jsha/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsha", "id": 220205, "node_id": "MDQ6VXNlcjIyMDIwNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/220205?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsha", "html_url": "https://github.com/jsha", "followers_url": "https://api.github.com/users/jsha/followers", "following_url": "https://api.github.com/users/jsha/following{/other_user}", "gists_url": "https://api.github.com/users/jsha/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsha/subscriptions", "organizations_url": "https://api.github.com/users/jsha/orgs", "repos_url": "https://api.github.com/users/jsha/repos", "events_url": "https://api.github.com/users/jsha/events{/privacy}", "received_events_url": "https://api.github.com/users/jsha/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6dfaa143662ddfd6ed2fecadef20eae0ec5d267d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dfaa143662ddfd6ed2fecadef20eae0ec5d267d", "html_url": "https://github.com/rust-lang/rust/commit/6dfaa143662ddfd6ed2fecadef20eae0ec5d267d"}], "stats": {"total": 136, "additions": 71, "deletions": 65}, "files": [{"sha": "024ea62c31aa93cfe2d0883657b06006c3da67eb", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 71, "deletions": 65, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/121ae1d29cd22e3438732077b6fc3d3587f30ec3/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/121ae1d29cd22e3438732077b6fc3d3587f30ec3/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=121ae1d29cd22e3438732077b6fc3d3587f30ec3", "patch": "@@ -1,13 +1,15 @@\n //! HTML formatting module\n //!\n //! This module contains a large number of `fmt::Display` implementations for\n-//! various types in `rustdoc::clean`. These implementations all currently\n-//! assume that HTML output is desired, although it may be possible to redesign\n-//! them in the future to instead emit any format desired.\n+//! various types in `rustdoc::clean`.\n+//!\n+//! These implementations all emit HTML. As an internal implementation detail,\n+//! some of them support an alternate format that emits text, but that should\n+//! not be used external to this module.\n \n use std::borrow::Cow;\n use std::cell::Cell;\n-use std::fmt;\n+use std::fmt::{self, Write};\n use std::iter::{self, once};\n \n use rustc_ast as ast;\n@@ -126,7 +128,6 @@ impl Buffer {\n     // the fmt::Result return type imposed by fmt::Write (and avoiding the trait\n     // import).\n     pub(crate) fn write_fmt(&mut self, v: fmt::Arguments<'_>) {\n-        use fmt::Write;\n         self.buffer.write_fmt(v).unwrap();\n     }\n \n@@ -279,8 +280,6 @@ pub(crate) fn print_where_clause<'a, 'tcx: 'a>(\n     indent: usize,\n     ending: Ending,\n ) -> impl fmt::Display + 'a + Captures<'tcx> {\n-    use fmt::Write;\n-\n     display_fn(move |f| {\n         let mut where_predicates = gens.where_predicates.iter().filter(|pred| {\n             !matches!(pred, clean::WherePredicate::BoundPredicate { bounds, .. } if bounds.is_empty())\n@@ -1306,6 +1305,28 @@ impl clean::BareFunctionDecl {\n     }\n }\n \n+// Implements Write but only counts the bytes \"written\".\n+struct WriteCounter(usize);\n+\n+impl std::fmt::Write for WriteCounter {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        self.0 += s.len();\n+        Ok(())\n+    }\n+}\n+\n+// Implements Display by emitting the given number of spaces.\n+struct Indent(usize);\n+\n+impl fmt::Display for Indent {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        (0..self.0).for_each(|_| {\n+            f.write_char(' ').unwrap();\n+        });\n+        Ok(())\n+    }\n+}\n+\n impl clean::FnDecl {\n     pub(crate) fn print<'b, 'a: 'b, 'tcx: 'a>(\n         &'a self,\n@@ -1345,95 +1366,80 @@ impl clean::FnDecl {\n         indent: usize,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n-        display_fn(move |f| self.inner_full_print(header_len, indent, f, cx))\n+        display_fn(move |f| {\n+            // First, generate the text form of the declaration, with no line wrapping, and count the bytes.\n+            let mut counter = WriteCounter(0);\n+            write!(&mut counter, \"{:#}\", display_fn(|f| { self.inner_full_print(None, f, cx) }))\n+                .unwrap();\n+            // If the text form was over 80 characters wide, we will line-wrap our output.\n+            let line_wrapping_indent =\n+                if header_len + counter.0 > 80 { Some(indent) } else { None };\n+            // Generate the final output. This happens to accept `{:#}` formatting to get textual\n+            // output but in practice it is only formatted with `{}` to get HTML output.\n+            self.inner_full_print(line_wrapping_indent, f, cx)\n+        })\n     }\n \n     fn inner_full_print(\n         &self,\n-        header_len: usize,\n-        indent: usize,\n+        // For None, the declaration will not be line-wrapped. For Some(n),\n+        // the declaration will be line-wrapped, with an indent of n spaces.\n+        line_wrapping_indent: Option<usize>,\n         f: &mut fmt::Formatter<'_>,\n         cx: &Context<'_>,\n     ) -> fmt::Result {\n         let amp = if f.alternate() { \"&\" } else { \"&amp;\" };\n-        let mut args = Buffer::html();\n-        let mut args_plain = Buffer::new();\n+\n+        write!(f, \"(\")?;\n+        if let Some(n) = line_wrapping_indent {\n+            write!(f, \"\\n{}\", Indent(n + 4))?;\n+        }\n         for (i, input) in self.inputs.values.iter().enumerate() {\n+            if i > 0 {\n+                match line_wrapping_indent {\n+                    None => write!(f, \", \")?,\n+                    Some(n) => write!(f, \",\\n{}\", Indent(n + 4))?,\n+                };\n+            }\n             if let Some(selfty) = input.to_self() {\n                 match selfty {\n                     clean::SelfValue => {\n-                        args.push_str(\"self\");\n-                        args_plain.push_str(\"self\");\n+                        write!(f, \"self\")?;\n                     }\n                     clean::SelfBorrowed(Some(ref lt), mtbl) => {\n-                        write!(args, \"{}{} {}self\", amp, lt.print(), mtbl.print_with_space());\n-                        write!(args_plain, \"&{} {}self\", lt.print(), mtbl.print_with_space());\n+                        write!(f, \"{}{} {}self\", amp, lt.print(), mtbl.print_with_space())?;\n                     }\n                     clean::SelfBorrowed(None, mtbl) => {\n-                        write!(args, \"{}{}self\", amp, mtbl.print_with_space());\n-                        write!(args_plain, \"&{}self\", mtbl.print_with_space());\n+                        write!(f, \"{}{}self\", amp, mtbl.print_with_space())?;\n                     }\n                     clean::SelfExplicit(ref typ) => {\n-                        if f.alternate() {\n-                            write!(args, \"self: {:#}\", typ.print(cx));\n-                        } else {\n-                            write!(args, \"self: {}\", typ.print(cx));\n-                        }\n-                        write!(args_plain, \"self: {:#}\", typ.print(cx));\n+                        write!(f, \"self: \")?;\n+                        fmt::Display::fmt(&typ.print(cx), f)?;\n                     }\n                 }\n             } else {\n-                if i > 0 {\n-                    args.push_str(\"\\n\");\n-                }\n                 if input.is_const {\n-                    args.push_str(\"const \");\n-                    args_plain.push_str(\"const \");\n-                }\n-                write!(args, \"{}: \", input.name);\n-                write!(args_plain, \"{}: \", input.name);\n-\n-                if f.alternate() {\n-                    write!(args, \"{:#}\", input.type_.print(cx));\n-                } else {\n-                    write!(args, \"{}\", input.type_.print(cx));\n+                    write!(f, \"const \")?;\n                 }\n-                write!(args_plain, \"{:#}\", input.type_.print(cx));\n-            }\n-            if i + 1 < self.inputs.values.len() {\n-                args.push_str(\",\");\n-                args_plain.push_str(\",\");\n+                write!(f, \"{}: \", input.name)?;\n+                fmt::Display::fmt(&input.type_.print(cx), f)?;\n             }\n         }\n \n-        let mut args_plain = format!(\"({})\", args_plain.into_inner());\n-        let mut args = args.into_inner();\n-\n         if self.c_variadic {\n-            args.push_str(\",\\n ...\");\n-            args_plain.push_str(\", ...\");\n+            match line_wrapping_indent {\n+                None => write!(f, \", ...\")?,\n+                Some(n) => write!(f, \"\\n{}...\", Indent(n + 4))?,\n+            };\n         }\n \n-        let arrow_plain = format!(\"{:#}\", self.output.print(cx));\n-        let arrow =\n-            if f.alternate() { arrow_plain.clone() } else { format!(\"{}\", self.output.print(cx)) };\n-\n-        let declaration_len = header_len + args_plain.len() + arrow_plain.len();\n-        let output = if declaration_len > 80 {\n-            let full_pad = format!(\"\\n{}\", \" \".repeat(indent + 4));\n-            let close_pad = format!(\"\\n{}\", \" \".repeat(indent));\n-            format!(\n-                \"({pad}{args}{close}){arrow}\",\n-                pad = if self.inputs.values.is_empty() { \"\" } else { &full_pad },\n-                args = args.replace('\\n', &full_pad),\n-                close = close_pad,\n-                arrow = arrow\n-            )\n-        } else {\n-            format!(\"({args}){arrow}\", args = args.replace('\\n', \" \"), arrow = arrow)\n+        match line_wrapping_indent {\n+            None => write!(f, \")\")?,\n+            Some(n) => write!(f, \"\\n{})\", Indent(n))?,\n         };\n \n-        write!(f, \"{}\", output)\n+        fmt::Display::fmt(&self.output.print(cx), f)?;\n+        Ok(())\n     }\n }\n "}]}