{"sha": "ae42318bef7e76fd94c534724d23ab8e87ddc809", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlNDIzMThiZWY3ZTc2ZmQ5NGM1MzQ3MjRkMjNhYjhlODdkZGM4MDk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-10-04T05:06:51Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-10-04T05:07:11Z"}, "message": "core: Make some parts of task private", "tree": {"sha": "ced23372846c19c5726183533fff0e45b1f8f7e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ced23372846c19c5726183533fff0e45b1f8f7e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae42318bef7e76fd94c534724d23ab8e87ddc809", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae42318bef7e76fd94c534724d23ab8e87ddc809", "html_url": "https://github.com/rust-lang/rust/commit/ae42318bef7e76fd94c534724d23ab8e87ddc809", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae42318bef7e76fd94c534724d23ab8e87ddc809/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2fc7316a98af57645c38590d3606fac60823c90", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2fc7316a98af57645c38590d3606fac60823c90", "html_url": "https://github.com/rust-lang/rust/commit/c2fc7316a98af57645c38590d3606fac60823c90"}], "stats": {"total": 72, "additions": 36, "deletions": 36}, "files": [{"sha": "991011893152c3da8559c9f4f99d6a0caa305541", "filename": "src/libcore/task/local_data.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ae42318bef7e76fd94c534724d23ab8e87ddc809/src%2Flibcore%2Ftask%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae42318bef7e76fd94c534724d23ab8e87ddc809/src%2Flibcore%2Ftask%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data.rs?ref=ae42318bef7e76fd94c534724d23ab8e87ddc809", "patch": "@@ -78,7 +78,7 @@ pub unsafe fn local_data_modify<T: Owned>(\n }\n \n #[test]\n-pub fn test_tls_multitask() unsafe {\n+fn test_tls_multitask() unsafe {\n     fn my_key(_x: @~str) { }\n     local_data_set(my_key, @~\"parent data\");\n     do task::spawn unsafe {\n@@ -94,15 +94,15 @@ pub fn test_tls_multitask() unsafe {\n }\n \n #[test]\n-pub fn test_tls_overwrite() unsafe {\n+fn test_tls_overwrite() unsafe {\n     fn my_key(_x: @~str) { }\n     local_data_set(my_key, @~\"first data\");\n     local_data_set(my_key, @~\"next data\"); // Shouldn't leak.\n     assert *(local_data_get(my_key).get()) == ~\"next data\";\n }\n \n #[test]\n-pub fn test_tls_pop() unsafe {\n+fn test_tls_pop() unsafe {\n     fn my_key(_x: @~str) { }\n     local_data_set(my_key, @~\"weasel\");\n     assert *(local_data_pop(my_key).get()) == ~\"weasel\";\n@@ -111,7 +111,7 @@ pub fn test_tls_pop() unsafe {\n }\n \n #[test]\n-pub fn test_tls_modify() unsafe {\n+fn test_tls_modify() unsafe {\n     fn my_key(_x: @~str) { }\n     local_data_modify(my_key, |data| {\n         match data {\n@@ -130,7 +130,7 @@ pub fn test_tls_modify() unsafe {\n }\n \n #[test]\n-pub fn test_tls_crust_automorestack_memorial_bug() unsafe {\n+fn test_tls_crust_automorestack_memorial_bug() unsafe {\n     // This might result in a stack-canary clobber if the runtime fails to set\n     // sp_limit to 0 when calling the cleanup extern - it might automatically\n     // jump over to the rust stack, which causes next_c_sp to get recorded as\n@@ -143,7 +143,7 @@ pub fn test_tls_crust_automorestack_memorial_bug() unsafe {\n }\n \n #[test]\n-pub fn test_tls_multiple_types() unsafe {\n+fn test_tls_multiple_types() unsafe {\n     fn str_key(_x: @~str) { }\n     fn box_key(_x: @@()) { }\n     fn int_key(_x: @int) { }\n@@ -155,7 +155,7 @@ pub fn test_tls_multiple_types() unsafe {\n }\n \n #[test]\n-pub fn test_tls_overwrite_multiple_types() {\n+fn test_tls_overwrite_multiple_types() {\n     fn str_key(_x: @~str) { }\n     fn box_key(_x: @@()) { }\n     fn int_key(_x: @int) { }\n@@ -171,7 +171,7 @@ pub fn test_tls_overwrite_multiple_types() {\n #[test]\n #[should_fail]\n #[ignore(cfg(windows))]\n-pub fn test_tls_cleanup_on_failure() unsafe {\n+fn test_tls_cleanup_on_failure() unsafe {\n     fn str_key(_x: @~str) { }\n     fn box_key(_x: @@()) { }\n     fn int_key(_x: @int) { }"}, {"sha": "e84e4dad164f3ac911227c05f45821491b06de7f", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ae42318bef7e76fd94c534724d23ab8e87ddc809/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae42318bef7e76fd94c534724d23ab8e87ddc809/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=ae42318bef7e76fd94c534724d23ab8e87ddc809", "patch": "@@ -17,19 +17,19 @@ impl LocalData: Eq {\n \n // We use dvec because it's the best data structure in core. If TLS is used\n // heavily in future, this could be made more efficient with a proper map.\n-pub type TaskLocalElement = (*libc::c_void, *libc::c_void, LocalData);\n+type TaskLocalElement = (*libc::c_void, *libc::c_void, LocalData);\n // Has to be a pointer at outermost layer; the foreign call returns void *.\n-pub type TaskLocalMap = @dvec::DVec<Option<TaskLocalElement>>;\n+type TaskLocalMap = @dvec::DVec<Option<TaskLocalElement>>;\n \n-pub extern fn cleanup_task_local_map(map_ptr: *libc::c_void) unsafe {\n+extern fn cleanup_task_local_map(map_ptr: *libc::c_void) unsafe {\n     assert !map_ptr.is_null();\n     // Get and keep the single reference that was created at the beginning.\n     let _map: TaskLocalMap = cast::reinterpret_cast(&map_ptr);\n     // All local_data will be destroyed along with the map.\n }\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n-pub unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n+unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n \n     // Relies on the runtime initialising the pointer to null.\n     // NOTE: The map's box lives in TLS invisibly referenced once. Each time\n@@ -52,7 +52,7 @@ pub unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n     }\n }\n \n-pub unsafe fn key_to_key_value<T: Owned>(\n+unsafe fn key_to_key_value<T: Owned>(\n     key: LocalDataKey<T>) -> *libc::c_void {\n \n     // Keys are closures, which are (fnptr,envptr) pairs. Use fnptr.\n@@ -62,7 +62,7 @@ pub unsafe fn key_to_key_value<T: Owned>(\n }\n \n // If returning Some(..), returns with @T with the map's reference. Careful!\n-pub unsafe fn local_data_lookup<T: Owned>(\n+unsafe fn local_data_lookup<T: Owned>(\n     map: TaskLocalMap, key: LocalDataKey<T>)\n     -> Option<(uint, *libc::c_void)> {\n \n@@ -80,7 +80,7 @@ pub unsafe fn local_data_lookup<T: Owned>(\n     }\n }\n \n-pub unsafe fn local_get_helper<T: Owned>(\n+unsafe fn local_get_helper<T: Owned>(\n     task: *rust_task, key: LocalDataKey<T>,\n     do_pop: bool) -> Option<@T> {\n "}, {"sha": "ff07150cfa2da906a96a8134bbf6de1c18233565", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ae42318bef7e76fd94c534724d23ab8e87ddc809/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae42318bef7e76fd94c534724d23ab8e87ddc809/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=ae42318bef7e76fd94c534724d23ab8e87ddc809", "patch": "@@ -69,16 +69,16 @@ macro_rules! move_it (\n     { $x:expr } => { unsafe { let y <- *ptr::addr_of(&($x)); move y } }\n )\n \n-pub type TaskSet = send_map::linear::LinearMap<*rust_task,()>;\n+type TaskSet = send_map::linear::LinearMap<*rust_task,()>;\n \n-pub fn new_taskset() -> TaskSet {\n+fn new_taskset() -> TaskSet {\n     send_map::linear::LinearMap()\n }\n-pub fn taskset_insert(tasks: &mut TaskSet, task: *rust_task) {\n+fn taskset_insert(tasks: &mut TaskSet, task: *rust_task) {\n     let didnt_overwrite = tasks.insert(task, ());\n     assert didnt_overwrite;\n }\n-pub fn taskset_remove(tasks: &mut TaskSet, task: *rust_task) {\n+fn taskset_remove(tasks: &mut TaskSet, task: *rust_task) {\n     let was_present = tasks.remove(&task);\n     assert was_present;\n }\n@@ -87,20 +87,20 @@ pub fn taskset_each(tasks: &TaskSet, blk: fn(v: *rust_task) -> bool) {\n }\n \n // One of these per group of linked-failure tasks.\n-pub type TaskGroupData = {\n+type TaskGroupData = {\n     // All tasks which might kill this group. When this is empty, the group\n     // can be \"GC\"ed (i.e., its link in the ancestor list can be removed).\n     mut members:     TaskSet,\n     // All tasks unidirectionally supervised by (directly or transitively)\n     // tasks in this group.\n     mut descendants: TaskSet,\n };\n-pub type TaskGroupArc = private::Exclusive<Option<TaskGroupData>>;\n+type TaskGroupArc = private::Exclusive<Option<TaskGroupData>>;\n \n-pub type TaskGroupInner = &mut Option<TaskGroupData>;\n+type TaskGroupInner = &mut Option<TaskGroupData>;\n \n // A taskgroup is 'dead' when nothing can cause it to fail; only members can.\n-pub pure fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n+pure fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n     (&tg.members).is_empty()\n }\n \n@@ -111,7 +111,7 @@ pub pure fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n // taskgroup which was spawned-unlinked. Tasks from intermediate generations\n // have references to the middle of the list; when intermediate generations\n // die, their node in the list will be collected at a descendant's spawn-time.\n-pub type AncestorNode = {\n+type AncestorNode = {\n     // Since the ancestor list is recursive, we end up with references to\n     // exclusives within other exclusives. This is dangerous business (if\n     // circular references arise, deadlock and memory leaks are imminent).\n@@ -124,16 +124,16 @@ pub type AncestorNode = {\n     // Recursive rest of the list.\n     mut ancestors:    AncestorList,\n };\n-pub enum AncestorList = Option<private::Exclusive<AncestorNode>>;\n+enum AncestorList = Option<private::Exclusive<AncestorNode>>;\n \n // Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n #[inline(always)]\n-pub fn access_group<U>(x: &TaskGroupArc, blk: fn(TaskGroupInner) -> U) -> U {\n+fn access_group<U>(x: &TaskGroupArc, blk: fn(TaskGroupInner) -> U) -> U {\n     unsafe { x.with(blk) }\n }\n \n #[inline(always)]\n-pub fn access_ancestors<U>(x: &private::Exclusive<AncestorNode>,\n+fn access_ancestors<U>(x: &private::Exclusive<AncestorNode>,\n                        blk: fn(x: &mut AncestorNode) -> U) -> U {\n     unsafe { x.with(blk) }\n }\n@@ -146,7 +146,7 @@ pub fn access_ancestors<U>(x: &private::Exclusive<AncestorNode>,\n // (3) As a bonus, coalesces away all 'dead' taskgroup nodes in the list.\n // FIXME(#2190): Change Option<fn@(...)> to Option<fn&(...)>, to save on\n // allocations. Once that bug is fixed, changing the sigil should suffice.\n-pub fn each_ancestor(list:        &mut AncestorList,\n+fn each_ancestor(list:        &mut AncestorList,\n                      bail_opt:    Option<fn@(TaskGroupInner)>,\n                      forward_blk: fn(TaskGroupInner) -> bool)\n         -> bool {\n@@ -271,7 +271,7 @@ pub fn each_ancestor(list:        &mut AncestorList,\n }\n \n // One of these per task.\n-pub struct TCB {\n+struct TCB {\n     me:            *rust_task,\n     // List of tasks with whose fates this one's is intertwined.\n     tasks:         TaskGroupArc, // 'none' means the group has failed.\n@@ -303,7 +303,7 @@ pub struct TCB {\n     }\n }\n \n-pub fn TCB(me: *rust_task, tasks: TaskGroupArc, ancestors: AncestorList,\n+fn TCB(me: *rust_task, tasks: TaskGroupArc, ancestors: AncestorList,\n        is_main: bool, notifier: Option<AutoNotify>) -> TCB {\n \n     let notifier = move notifier;\n@@ -318,7 +318,7 @@ pub fn TCB(me: *rust_task, tasks: TaskGroupArc, ancestors: AncestorList,\n     }\n }\n \n-pub struct AutoNotify {\n+struct AutoNotify {\n     notify_chan: Chan<Notification>,\n     mut failed:  bool,\n     drop {\n@@ -327,14 +327,14 @@ pub struct AutoNotify {\n     }\n }\n \n-pub fn AutoNotify(chan: Chan<Notification>) -> AutoNotify {\n+fn AutoNotify(chan: Chan<Notification>) -> AutoNotify {\n     AutoNotify {\n         notify_chan: chan,\n         failed: true // Un-set above when taskgroup successfully made.\n     }\n }\n \n-pub fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n+fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n                            is_member: bool) -> bool {\n     let newstate = util::replace(state, None);\n     // If 'None', the group was failing. Can't enlist.\n@@ -350,7 +350,7 @@ pub fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n }\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n-pub fn leave_taskgroup(state: TaskGroupInner, me: *rust_task,\n+fn leave_taskgroup(state: TaskGroupInner, me: *rust_task,\n                        is_member: bool) {\n     let newstate = util::replace(state, None);\n     // If 'None', already failing and we've already gotten a kill signal.\n@@ -363,7 +363,7 @@ pub fn leave_taskgroup(state: TaskGroupInner, me: *rust_task,\n }\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n-pub fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n+fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n     // NB: We could do the killing iteration outside of the group arc, by\n     // having \"let mut newstate\" here, swapping inside, and iterating after.\n     // But that would let other exiting tasks fall-through and exit while we\n@@ -405,7 +405,7 @@ macro_rules! taskgroup_key (\n     () => (cast::transmute((-2 as uint, 0u)))\n )\n \n-pub fn gen_child_taskgroup(linked: bool, supervised: bool)\n+fn gen_child_taskgroup(linked: bool, supervised: bool)\n     -> (TaskGroupArc, AncestorList, bool) {\n     let spawner = rt::rust_get_task();\n     /*######################################################################*"}]}