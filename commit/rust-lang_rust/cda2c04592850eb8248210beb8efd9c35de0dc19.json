{"sha": "cda2c04592850eb8248210beb8efd9c35de0dc19", "node_id": "C_kwDOAAsO6NoAKGNkYTJjMDQ1OTI4NTBlYjgyNDgyMTBiZWI4ZWZkOWMzNWRlMGRjMTk", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-07-20T19:30:37Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-08-04T14:26:51Z"}, "message": "Explicitly gather lifetimes and definitions in RPIT", "tree": {"sha": "c38443a35a424091b7091b90ec656ab278d46441", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c38443a35a424091b7091b90ec656ab278d46441"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cda2c04592850eb8248210beb8efd9c35de0dc19", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEF0ntrgrd9qf9uuThgTGiTgx5768FAmLr1ysACgkQgTGiTgx5\n7684XBAAiRpJjrG5OZE0a7DKD8QYYeYWpVVQupoT7ZX6L6Ptvh0+UYEWbIY0Yp21\n96qLHVcQH0V9yhKkRSZ4E8mhHSl/gfHjKRsssFNT7T49JnS8QvdRcVJ0AvAf5lvn\nGXcnDxvrG/dh3RyyERz1nRN3bi0MmB9mmStXrpUsOhgQZNfC59gmq3qtOGb5/oFY\nv9rDfoLQg2K0bbUZu98gIsBpBQ6FeYrLtCNx0hvtleYc8JblWLdjAVkSLZd8bK+q\nHbjnUrwMDLjViagH4MTLlwE9MBpD+d0RcfJcxKlnb0hQegJsyH3SQqXBOxGxhwoX\n90xNrceB7iuR53oCctb9ZZhjtRQmaHUUCVH/ChdL4bXzMAT45Xf0jCpdtGsoUv7F\n0Dt6KQmkmEUbJGFjuo8ldAMNxP1nOQmzBTXgZtL/Sw81xQzznED5ed9fYg6jblwL\nPuw1KuiWxzDVD1fZdAMs/QM0T0D2+qbdCvi5FEr/hf/5gR7IQD+kS4bzuVRX4QZY\ncdQlg0FialUbiOddUM6+DPKrCK7/JMC5CUwVFY5PFZPl08+vILCnyLQOujuh2l2X\nNbaaCq9EtpCH0Mp94Gi/5K/HNUcjxwcbvuuSEj7o5OfWHtinM/wGJIANus9GZ3Eb\nUAfwPDb9kK6xnQl18m/ejvniZWCHwvaRXPLCL+t9/z5M+NZEDy8=\n=RGAq\n-----END PGP SIGNATURE-----", "payload": "tree c38443a35a424091b7091b90ec656ab278d46441\nparent 84a24a1b3c183066644be2db03c48545d796f01f\nauthor Santiago Pastorino <spastorino@gmail.com> 1658345437 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1659623211 -0300\n\nExplicitly gather lifetimes and definitions in RPIT\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cda2c04592850eb8248210beb8efd9c35de0dc19", "html_url": "https://github.com/rust-lang/rust/commit/cda2c04592850eb8248210beb8efd9c35de0dc19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cda2c04592850eb8248210beb8efd9c35de0dc19/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84a24a1b3c183066644be2db03c48545d796f01f", "url": "https://api.github.com/repos/rust-lang/rust/commits/84a24a1b3c183066644be2db03c48545d796f01f", "html_url": "https://github.com/rust-lang/rust/commit/84a24a1b3c183066644be2db03c48545d796f01f"}], "stats": {"total": 249, "additions": 207, "deletions": 42}, "files": [{"sha": "3503e5de8ccdb3320c70a92286f90701878a65c3", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cda2c04592850eb8248210beb8efd9c35de0dc19/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda2c04592850eb8248210beb8efd9c35de0dc19/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=cda2c04592850eb8248210beb8efd9c35de0dc19", "patch": "@@ -25,7 +25,9 @@ pub use UnsafeSource::*;\n use crate::ptr::P;\n use crate::token::{self, CommentKind, Delimiter};\n use crate::tokenstream::{DelimSpan, LazyTokenStream, TokenStream};\n+use crate::visit::{self, BoundKind, LifetimeCtxt, Visitor};\n \n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::sync::Lrc;\n@@ -64,7 +66,7 @@ impl fmt::Debug for Label {\n \n /// A \"Lifetime\" is an annotation of the scope in which variable\n /// can be used, e.g. `'a` in `&'a i32`.\n-#[derive(Clone, Encodable, Decodable, Copy)]\n+#[derive(Clone, Encodable, Decodable, Copy, PartialEq, Eq)]\n pub struct Lifetime {\n     pub id: NodeId,\n     pub ident: Ident,\n@@ -323,6 +325,63 @@ impl GenericBound {\n \n pub type GenericBounds = Vec<GenericBound>;\n \n+struct LifetimeCollectVisitor<'ast> {\n+    current_binders: Vec<NodeId>,\n+    binders_to_ignore: FxHashMap<NodeId, Vec<NodeId>>,\n+    collected_lifetimes: Vec<&'ast Lifetime>,\n+}\n+\n+impl<'ast> Visitor<'ast> for LifetimeCollectVisitor<'ast> {\n+    fn visit_lifetime(&mut self, lifetime: &'ast Lifetime, _: LifetimeCtxt) {\n+        if !self.collected_lifetimes.contains(&lifetime) {\n+            self.collected_lifetimes.push(lifetime);\n+        }\n+        self.binders_to_ignore.insert(lifetime.id, self.current_binders.clone());\n+    }\n+\n+    fn visit_poly_trait_ref(&mut self, t: &'ast PolyTraitRef, m: &'ast TraitBoundModifier) {\n+        self.current_binders.push(t.trait_ref.ref_id);\n+\n+        visit::walk_poly_trait_ref(self, t, m);\n+\n+        self.current_binders.pop();\n+    }\n+\n+    fn visit_ty(&mut self, t: &'ast Ty) {\n+        if let TyKind::BareFn(_) = t.kind {\n+            self.current_binders.push(t.id);\n+        }\n+        visit::walk_ty(self, t);\n+        if let TyKind::BareFn(_) = t.kind {\n+            self.current_binders.pop();\n+        }\n+    }\n+}\n+\n+pub fn lifetimes_in_ret_ty(ret_ty: &FnRetTy) -> (Vec<&Lifetime>, FxHashMap<NodeId, Vec<NodeId>>) {\n+    let mut visitor = LifetimeCollectVisitor {\n+        current_binders: Vec::new(),\n+        binders_to_ignore: FxHashMap::default(),\n+        collected_lifetimes: Vec::new(),\n+    };\n+    visitor.visit_fn_ret_ty(ret_ty);\n+    (visitor.collected_lifetimes, visitor.binders_to_ignore)\n+}\n+\n+pub fn lifetimes_in_bounds(\n+    bounds: &GenericBounds,\n+) -> (Vec<&Lifetime>, FxHashMap<NodeId, Vec<NodeId>>) {\n+    let mut visitor = LifetimeCollectVisitor {\n+        current_binders: Vec::new(),\n+        binders_to_ignore: FxHashMap::default(),\n+        collected_lifetimes: Vec::new(),\n+    };\n+    for bound in bounds {\n+        visitor.visit_param_bound(bound, BoundKind::Bound);\n+    }\n+    (visitor.collected_lifetimes, visitor.binders_to_ignore)\n+}\n+\n /// Specifies the enforced ordering for generic parameters. In the future,\n /// if we wanted to relax this order, we could override `PartialEq` and\n /// `PartialOrd`, to allow the kinds to be unordered."}, {"sha": "dfd23dbd4d730702ea3005a7019e177703a4b631", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 147, "deletions": 41, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/cda2c04592850eb8248210beb8efd9c35de0dc19/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda2c04592850eb8248210beb8efd9c35de0dc19/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=cda2c04592850eb8248210beb8efd9c35de0dc19", "patch": "@@ -1304,17 +1304,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             TyKind::ImplTrait(def_node_id, ref bounds) => {\n                 let span = t.span;\n                 match itctx {\n-                    ImplTraitContext::ReturnPositionOpaqueTy { origin } => self\n-                        .lower_opaque_impl_trait(span, origin, def_node_id, |this| {\n-                            this.lower_param_bounds(bounds, itctx, true)\n-                        }),\n+                    ImplTraitContext::ReturnPositionOpaqueTy { origin } => {\n+                        self.lower_opaque_impl_trait(span, origin, def_node_id, bounds, itctx)\n+                    }\n                     ImplTraitContext::TypeAliasesOpaqueTy => {\n                         let nested_itctx = ImplTraitContext::TypeAliasesOpaqueTy;\n                         self.lower_opaque_impl_trait(\n                             span,\n                             hir::OpaqueTyOrigin::TyAlias,\n                             def_node_id,\n-                            |this| this.lower_param_bounds(bounds, nested_itctx, true),\n+                            bounds,\n+                            nested_itctx,\n                         )\n                     }\n                     ImplTraitContext::Universal => {\n@@ -1354,13 +1354,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::Ty { kind, span: self.lower_span(t.span), hir_id: self.lower_node_id(t.id) }\n     }\n \n-    #[tracing::instrument(level = \"debug\", skip(self, lower_bounds))]\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn lower_opaque_impl_trait(\n         &mut self,\n         span: Span,\n         origin: hir::OpaqueTyOrigin,\n         opaque_ty_node_id: NodeId,\n-        lower_bounds: impl FnOnce(&mut Self) -> hir::GenericBounds<'hir>,\n+        bounds: &GenericBounds,\n+        itctx: ImplTraitContext,\n     ) -> hir::TyKind<'hir> {\n         // Make sure we know that some funky desugaring has been going on here.\n         // This is a first: there is code in other places like for loop\n@@ -1374,23 +1375,122 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut collected_lifetimes = FxHashMap::default();\n         self.with_hir_id_owner(opaque_ty_node_id, |lctx| {\n             let hir_bounds = if origin == hir::OpaqueTyOrigin::TyAlias {\n-                lower_bounds(lctx)\n+                lctx.lower_param_bounds(bounds, itctx, true)\n             } else {\n-                let lifetime_stash = std::mem::replace(\n-                    &mut lctx.captured_lifetimes,\n-                    Some(LifetimeCaptureContext {\n-                        parent_def_id: opaque_ty_def_id,\n-                        captures: std::mem::take(&mut collected_lifetimes),\n-                        binders_to_ignore: Default::default(),\n-                    }),\n-                );\n+                if std::env::var(\"NEW_COLLECT_LIFETIMES\").is_ok() {\n+                    let lifetime_stash = std::mem::replace(\n+                        &mut lctx.captured_lifetimes,\n+                        Some(LifetimeCaptureContext {\n+                            parent_def_id: opaque_ty_def_id,\n+                            captures: std::mem::take(&mut collected_lifetimes),\n+                            binders_to_ignore: Default::default(),\n+                        }),\n+                    );\n+\n+                    let (lifetimes_in_bounds, binders_to_ignore) = ast::lifetimes_in_bounds(bounds);\n+\n+                    for lifetime in &lifetimes_in_bounds {\n+                        let ident = lifetime.ident;\n+                        let span = ident.span;\n+\n+                        let res = lctx\n+                            .resolver\n+                            .get_lifetime_res(lifetime.id)\n+                            .unwrap_or(LifetimeRes::Error);\n+\n+                        if let Some(mut captured_lifetimes) = lctx.captured_lifetimes.take() {\n+                            match res {\n+                                LifetimeRes::Param { param, binder } => {\n+                                    if !captured_lifetimes.binders_to_ignore.contains(&binder)\n+                                        && !binders_to_ignore\n+                                            .get(&lifetime.id)\n+                                            .unwrap_or(&Vec::new())\n+                                            .contains(&binder)\n+                                    {\n+                                        match captured_lifetimes.captures.entry(param) {\n+                                            Entry::Occupied(_) => {}\n+                                            Entry::Vacant(v) => {\n+                                                let node_id = lctx.next_node_id();\n+                                                let name = ParamName::Plain(ident);\n+\n+                                                lctx.create_def(\n+                                                    captured_lifetimes.parent_def_id,\n+                                                    node_id,\n+                                                    DefPathData::LifetimeNs(name.ident().name),\n+                                                );\n+\n+                                                v.insert((span, node_id, name, res));\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+\n+                                LifetimeRes::Fresh { param, binder } => {\n+                                    debug_assert_eq!(ident.name, kw::UnderscoreLifetime);\n+                                    if !captured_lifetimes.binders_to_ignore.contains(&binder)\n+                                        && !binders_to_ignore\n+                                            .get(&lifetime.id)\n+                                            .unwrap_or(&Vec::new())\n+                                            .contains(&binder)\n+                                    {\n+                                        let param = lctx.local_def_id(param);\n+                                        match captured_lifetimes.captures.entry(param) {\n+                                            Entry::Occupied(_) => {}\n+                                            Entry::Vacant(v) => {\n+                                                let node_id = lctx.next_node_id();\n+\n+                                                let name = ParamName::Fresh;\n+\n+                                                lctx.create_def(\n+                                                    captured_lifetimes.parent_def_id,\n+                                                    node_id,\n+                                                    DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n+                                                );\n+\n+                                                v.insert((span, node_id, name, res));\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+\n+                                LifetimeRes::Infer | LifetimeRes::Static | LifetimeRes::Error => {}\n+\n+                                res => panic!(\n+                                    \"Unexpected lifetime resolution {:?} for {:?} at {:?}\",\n+                                    res, lifetime.ident, lifetime.ident.span\n+                                ),\n+                            }\n+\n+                            lctx.captured_lifetimes = Some(captured_lifetimes);\n+                        }\n+                    }\n+\n+                    let ret = lctx.lower_param_bounds(bounds, itctx, false);\n+\n+                    let ctxt =\n+                        std::mem::replace(&mut lctx.captured_lifetimes, lifetime_stash).unwrap();\n+\n+                    collected_lifetimes = ctxt.captures;\n+\n+                    ret\n+                } else {\n+                    let lifetime_stash = std::mem::replace(\n+                        &mut lctx.captured_lifetimes,\n+                        Some(LifetimeCaptureContext {\n+                            parent_def_id: opaque_ty_def_id,\n+                            captures: std::mem::take(&mut collected_lifetimes),\n+                            binders_to_ignore: Default::default(),\n+                        }),\n+                    );\n \n-                let ret = lower_bounds(lctx);\n+                    let ret = lctx.lower_param_bounds(bounds, itctx, true);\n \n-                let ctxt = std::mem::replace(&mut lctx.captured_lifetimes, lifetime_stash).unwrap();\n-                collected_lifetimes = ctxt.captures;\n+                    let ctxt =\n+                        std::mem::replace(&mut lctx.captured_lifetimes, lifetime_stash).unwrap();\n+                    collected_lifetimes = ctxt.captures;\n \n-                ret\n+                    ret\n+                }\n             };\n             debug!(?collected_lifetimes);\n \n@@ -1855,16 +1955,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         captures: bool,\n     ) -> hir::Lifetime {\n         debug!(?self.captured_lifetimes);\n+\n         let name = match res {\n             LifetimeRes::Param { mut param, binder } => {\n                 let p_name = ParamName::Plain(ident);\n-                if captures {\n-                    if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n+                if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n+                    if captures {\n                         if !captured_lifetimes.binders_to_ignore.contains(&binder) {\n                             match captured_lifetimes.captures.entry(param) {\n                                 Entry::Occupied(o) => param = self.local_def_id(o.get().1),\n                                 Entry::Vacant(v) => {\n                                     let p_id = self.next_node_id();\n+\n                                     let p_def_id = self.create_def(\n                                         captured_lifetimes.parent_def_id,\n                                         p_id,\n@@ -1876,36 +1978,40 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 }\n                             }\n                         }\n-\n-                        self.captured_lifetimes = Some(captured_lifetimes);\n+                    } else {\n+                        if let Entry::Occupied(o) = captured_lifetimes.captures.entry(param) {\n+                            param = self.local_def_id(o.get().1);\n+                        }\n                     }\n+                    self.captured_lifetimes = Some(captured_lifetimes);\n                 }\n+\n                 hir::LifetimeName::Param(param, p_name)\n             }\n             LifetimeRes::Fresh { param, binder } => {\n                 debug_assert_eq!(ident.name, kw::UnderscoreLifetime);\n+\n                 let mut param = self.local_def_id(param);\n-                if captures {\n-                    if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n-                        if !captured_lifetimes.binders_to_ignore.contains(&binder) {\n-                            match captured_lifetimes.captures.entry(param) {\n-                                Entry::Occupied(o) => param = self.local_def_id(o.get().1),\n-                                Entry::Vacant(v) => {\n-                                    let p_id = self.next_node_id();\n-                                    let p_def_id = self.create_def(\n-                                        captured_lifetimes.parent_def_id,\n-                                        p_id,\n-                                        DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n-                                    );\n+                if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n+                    if !captured_lifetimes.binders_to_ignore.contains(&binder) {\n+                        match captured_lifetimes.captures.entry(param) {\n+                            Entry::Occupied(o) => param = self.local_def_id(o.get().1),\n+                            Entry::Vacant(v) => {\n+                                let p_id = self.next_node_id();\n+\n+                                let p_def_id = self.create_def(\n+                                    captured_lifetimes.parent_def_id,\n+                                    p_id,\n+                                    DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n+                                );\n \n-                                    v.insert((span, p_id, ParamName::Fresh, res));\n-                                    param = p_def_id;\n-                                }\n+                                v.insert((span, p_id, ParamName::Fresh, res));\n+                                param = p_def_id;\n                             }\n                         }\n-\n-                        self.captured_lifetimes = Some(captured_lifetimes);\n                     }\n+\n+                    self.captured_lifetimes = Some(captured_lifetimes);\n                 }\n                 hir::LifetimeName::Param(param, ParamName::Fresh)\n             }"}]}