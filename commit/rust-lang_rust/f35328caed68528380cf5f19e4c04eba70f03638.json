{"sha": "f35328caed68528380cf5f19e4c04eba70f03638", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNTMyOGNhZWQ2ODUyODM4MGNmNWYxOWU0YzA0ZWJhNzBmMDM2Mzg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-05T19:23:34Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-07T02:51:13Z"}, "message": "rustc: Avoid UB with signed division/remainder\n\nDivision and remainder by 0 are undefined behavior, and are detected at runtime.\nThis commit adds support for ensuring that MIN / -1 is also checked for at\nruntime, as this would cause signed overflow, or undefined behvaior.\n\nCloses #8460", "tree": {"sha": "b84e254f133ab642f0a935be3366bc9e06c0bb57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b84e254f133ab642f0a935be3366bc9e06c0bb57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f35328caed68528380cf5f19e4c04eba70f03638", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f35328caed68528380cf5f19e4c04eba70f03638", "html_url": "https://github.com/rust-lang/rust/commit/f35328caed68528380cf5f19e4c04eba70f03638", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f35328caed68528380cf5f19e4c04eba70f03638/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fd075f5af12afe91a6be7398cfc85b2903c28bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fd075f5af12afe91a6be7398cfc85b2903c28bb", "html_url": "https://github.com/rust-lang/rust/commit/9fd075f5af12afe91a6be7398cfc85b2903c28bb"}], "stats": {"total": 126, "additions": 102, "deletions": 24}, "files": [{"sha": "9be07eaaca9340b7a7e95723d513422b11680af0", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 63, "deletions": 20, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/f35328caed68528380cf5f19e4c04eba70f03638/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35328caed68528380cf5f19e4c04eba70f03638/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f35328caed68528380cf5f19e4c04eba70f03638", "patch": "@@ -80,6 +80,7 @@ use libc::{c_uint, uint64_t};\n use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n use std::rc::Rc;\n+use std::{i8, i16, i32, i64};\n use syntax::abi::{X86, X86_64, Arm, Mips, Rust, RustIntrinsic};\n use syntax::ast_util::{local_def, is_local};\n use syntax::attr::AttrMetaMethods;\n@@ -777,35 +778,77 @@ pub fn cast_shift_rhs(op: ast::BinOp,\n     }\n }\n \n-pub fn fail_if_zero<'a>(\n+pub fn fail_if_zero_or_overflows<'a>(\n                     cx: &'a Block<'a>,\n                     span: Span,\n                     divrem: ast::BinOp,\n+                    lhs: ValueRef,\n                     rhs: ValueRef,\n                     rhs_t: ty::t)\n                     -> &'a Block<'a> {\n-    let text = if divrem == ast::BiDiv {\n-        \"attempted to divide by zero\"\n+    let (zero_text, overflow_text) = if divrem == ast::BiDiv {\n+        (\"attempted to divide by zero\",\n+         \"attempted to divide with overflow\")\n     } else {\n-        \"attempted remainder with a divisor of zero\"\n+        (\"attempted remainder with a divisor of zero\",\n+         \"attempted remainder with overflow\")\n     };\n-    let is_zero = match ty::get(rhs_t).sty {\n-      ty::ty_int(t) => {\n-        let zero = C_integral(Type::int_from_ty(cx.ccx(), t), 0u64, false);\n-        ICmp(cx, lib::llvm::IntEQ, rhs, zero)\n-      }\n-      ty::ty_uint(t) => {\n-        let zero = C_integral(Type::uint_from_ty(cx.ccx(), t), 0u64, false);\n-        ICmp(cx, lib::llvm::IntEQ, rhs, zero)\n-      }\n-      _ => {\n-        cx.sess().bug(format!(\"fail-if-zero on unexpected type: {}\",\n-                              ty_to_str(cx.tcx(), rhs_t)).as_slice());\n-      }\n+    let (is_zero, is_signed) = match ty::get(rhs_t).sty {\n+        ty::ty_int(t) => {\n+            let zero = C_integral(Type::int_from_ty(cx.ccx(), t), 0u64, false);\n+            (ICmp(cx, lib::llvm::IntEQ, rhs, zero), true)\n+        }\n+        ty::ty_uint(t) => {\n+            let zero = C_integral(Type::uint_from_ty(cx.ccx(), t), 0u64, false);\n+            (ICmp(cx, lib::llvm::IntEQ, rhs, zero), false)\n+        }\n+        _ => {\n+            cx.sess().bug(format!(\"fail-if-zero on unexpected type: {}\",\n+                                  ty_to_str(cx.tcx(), rhs_t)).as_slice());\n+        }\n     };\n-    with_cond(cx, is_zero, |bcx| {\n-        controlflow::trans_fail(bcx, span, InternedString::new(text))\n-    })\n+    let bcx = with_cond(cx, is_zero, |bcx| {\n+        controlflow::trans_fail(bcx, span, InternedString::new(zero_text))\n+    });\n+\n+    // To quote LLVM's documentation for the sdiv instruction:\n+    //\n+    //      Division by zero leads to undefined behavior. Overflow also leads\n+    //      to undefined behavior; this is a rare case, but can occur, for\n+    //      example, by doing a 32-bit division of -2147483648 by -1.\n+    //\n+    // In order to avoid undefined behavior, we perform runtime checks for\n+    // signed division/remainder which would trigger overflow. For unsigned\n+    // integers, no action beyond checking for zero need be taken.\n+    if is_signed {\n+        let (llty, min) = match ty::get(rhs_t).sty {\n+            ty::ty_int(t) => {\n+                let llty = Type::int_from_ty(cx.ccx(), t);\n+                let min = match t {\n+                    ast::TyI if llty == Type::i32(cx.ccx()) => i32::MIN as u64,\n+                    ast::TyI => i64::MIN as u64,\n+                    ast::TyI8 => i8::MIN as u64,\n+                    ast::TyI16 => i16::MIN as u64,\n+                    ast::TyI32 => i32::MIN as u64,\n+                    ast::TyI64 => i64::MIN as u64,\n+                };\n+                (llty, min)\n+            }\n+            _ => unreachable!(),\n+        };\n+        let minus_one = ICmp(bcx, lib::llvm::IntEQ, rhs,\n+                             C_integral(llty, -1, false));\n+        with_cond(bcx, minus_one, |bcx| {\n+            let is_min = ICmp(bcx, lib::llvm::IntEQ, lhs,\n+                              C_integral(llty, min, true));\n+            with_cond(bcx, is_min, |bcx| {\n+                controlflow::trans_fail(bcx, span,\n+                                        InternedString::new(overflow_text))\n+            })\n+        })\n+    } else {\n+        bcx\n+    }\n }\n \n pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> ValueRef {"}, {"sha": "9f90de61cfeb6478bca49d3b66add136ac4dbc80", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f35328caed68528380cf5f19e4c04eba70f03638/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35328caed68528380cf5f19e4c04eba70f03638/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=f35328caed68528380cf5f19e4c04eba70f03638", "patch": "@@ -1297,8 +1297,8 @@ fn trans_eager_binop<'a>(\n             FDiv(bcx, lhs, rhs)\n         } else {\n             // Only zero-check integers; fp /0 is NaN\n-            bcx = base::fail_if_zero(bcx, binop_expr.span,\n-                                     op, rhs, rhs_t);\n+            bcx = base::fail_if_zero_or_overflows(bcx, binop_expr.span,\n+                                                  op, lhs, rhs, rhs_t);\n             if is_signed {\n                 SDiv(bcx, lhs, rhs)\n             } else {\n@@ -1311,8 +1311,8 @@ fn trans_eager_binop<'a>(\n             FRem(bcx, lhs, rhs)\n         } else {\n             // Only zero-check integers; fp %0 is NaN\n-            bcx = base::fail_if_zero(bcx, binop_expr.span,\n-                                     op, rhs, rhs_t);\n+            bcx = base::fail_if_zero_or_overflows(bcx, binop_expr.span,\n+                                                  op, lhs, rhs, rhs_t);\n             if is_signed {\n                 SRem(bcx, lhs, rhs)\n             } else {"}, {"sha": "762152c92038ff213ba57c7a2c755f30337d2fe7", "filename": "src/test/run-pass/issue-8460.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f35328caed68528380cf5f19e4c04eba70f03638/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35328caed68528380cf5f19e4c04eba70f03638/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8460.rs?ref=f35328caed68528380cf5f19e4c04eba70f03638", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::{int, i8, i16, i32, i64};\n+use std::task;\n+\n+fn main() {\n+    assert!(task::try(proc() int::MIN / -1).is_err());\n+    assert!(task::try(proc() i8::MIN / -1).is_err());\n+    assert!(task::try(proc() i16::MIN / -1).is_err());\n+    assert!(task::try(proc() i32::MIN / -1).is_err());\n+    assert!(task::try(proc() i64::MIN / -1).is_err());\n+    assert!(task::try(proc() 1i / 0).is_err());\n+    assert!(task::try(proc() 1i8 / 0).is_err());\n+    assert!(task::try(proc() 1i16 / 0).is_err());\n+    assert!(task::try(proc() 1i32 / 0).is_err());\n+    assert!(task::try(proc() 1i64 / 0).is_err());\n+    assert!(task::try(proc() int::MIN % -1).is_err());\n+    assert!(task::try(proc() i8::MIN % -1).is_err());\n+    assert!(task::try(proc() i16::MIN % -1).is_err());\n+    assert!(task::try(proc() i32::MIN % -1).is_err());\n+    assert!(task::try(proc() i64::MIN % -1).is_err());\n+    assert!(task::try(proc() 1i % 0).is_err());\n+    assert!(task::try(proc() 1i8 % 0).is_err());\n+    assert!(task::try(proc() 1i16 % 0).is_err());\n+    assert!(task::try(proc() 1i32 % 0).is_err());\n+    assert!(task::try(proc() 1i64 % 0).is_err());\n+}"}]}