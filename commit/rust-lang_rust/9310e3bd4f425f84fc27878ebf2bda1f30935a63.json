{"sha": "9310e3bd4f425f84fc27878ebf2bda1f30935a63", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzMTBlM2JkNGY0MjVmODRmYzI3ODc4ZWJmMmJkYTFmMzA5MzVhNjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-21T18:52:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-21T18:52:46Z"}, "message": "Auto merge of #71930 - Nadrieril:exhaustiveness-remove-tyerr, r=varkor\n\nDe-abuse TyKind::Error in exhaustiveness checking\n\nReplaces https://github.com/rust-lang/rust/pull/71074. Context: https://github.com/rust-lang/rust/issues/70866.\n\nIn order to remove the use of `TyKind::Error`, I had to make sure we skip over those fields whose inhabitedness should not be observed. This is potentially error-prone however, since we must be careful not to mix filtered and unfiltered lists of patterns. I managed to hide away most of the filtering behind a new `Fields` struct, that I used everywhere relevant. I quite like the result; I think the twin concepts of `Constructor` and `Fields` make a good mental model.\n\nAs usual, I tried to separate commits that shuffle code around from commits that require more thought to review.\n\ncc @varkor @Centril", "tree": {"sha": "120fa2fbc4061f1a5b4fe22c8169b7a9882f6909", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/120fa2fbc4061f1a5b4fe22c8169b7a9882f6909"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9310e3bd4f425f84fc27878ebf2bda1f30935a63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9310e3bd4f425f84fc27878ebf2bda1f30935a63", "html_url": "https://github.com/rust-lang/rust/commit/9310e3bd4f425f84fc27878ebf2bda1f30935a63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9310e3bd4f425f84fc27878ebf2bda1f30935a63/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "148c125b1bf20674e8d0c55c21b3433a6d465b07", "url": "https://api.github.com/repos/rust-lang/rust/commits/148c125b1bf20674e8d0c55c21b3433a6d465b07", "html_url": "https://github.com/rust-lang/rust/commit/148c125b1bf20674e8d0c55c21b3433a6d465b07"}, {"sha": "d7e1d5f0c275c6e876f97a3d95d27a020bc88046", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7e1d5f0c275c6e876f97a3d95d27a020bc88046", "html_url": "https://github.com/rust-lang/rust/commit/d7e1d5f0c275c6e876f97a3d95d27a020bc88046"}], "stats": {"total": 687, "additions": 427, "deletions": 260}, "files": [{"sha": "626e531c807b72b2840eacd25e82c583bfa7d920", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 402, "deletions": 259, "changes": 661, "blob_url": "https://github.com/rust-lang/rust/blob/9310e3bd4f425f84fc27878ebf2bda1f30935a63/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9310e3bd4f425f84fc27878ebf2bda1f30935a63/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=9310e3bd4f425f84fc27878ebf2bda1f30935a63", "patch": "@@ -1,5 +1,5 @@\n-/// Note: most tests relevant to this file can be found (at the time of writing)\n-/// in src/tests/ui/pattern/usefulness.\n+/// Note: most of the tests relevant to this file can be found (at the time of writing) in\n+/// src/tests/ui/pattern/usefulness.\n ///\n /// This file includes the logic for exhaustiveness and usefulness checking for\n /// pattern-matching. Specifically, given a list of patterns for a type, we can\n@@ -13,6 +13,8 @@\n /// summarise the algorithm here to hopefully save time and be a little clearer\n /// (without being so rigorous).\n ///\n+/// # Premise\n+///\n /// The core of the algorithm revolves about a \"usefulness\" check. In particular, we\n /// are trying to compute a predicate `U(P, p)` where `P` is a list of patterns (we refer to this as\n /// a matrix). `U(P, p)` represents whether, given an existing list of patterns\n@@ -27,8 +29,51 @@\n /// pattern to those that have come before it doesn't increase the number of values\n /// we're matching).\n ///\n+/// # Core concept\n+///\n+/// The idea that powers everything that is done in this file is the following: a value is made\n+/// from a constructor applied to some fields. Examples of constructors are `Some`, `None`, `(,)`\n+/// (the 2-tuple constructor), `Foo {..}` (the constructor for a struct `Foo`), and `2` (the\n+/// constructor for the number `2`). Fields are just a (possibly empty) list of values.\n+///\n+/// Some of the constructors listed above might feel weird: `None` and `2` don't take any\n+/// arguments. This is part of what makes constructors so general: we will consider plain values\n+/// like numbers and string literals to be constructors that take no arguments, also called \"0-ary\n+/// constructors\"; they are the simplest case of constructors. This allows us to see any value as\n+/// made up from a tree of constructors, each having a given number of children. For example:\n+/// `(None, Ok(0))` is made from 4 different constructors.\n+///\n+/// This idea can be extended to patterns: a pattern captures a set of possible values, and we can\n+/// describe this set using constructors. For example, `Err(_)` captures all values of the type\n+/// `Result<T, E>` that start with the `Err` constructor (for some choice of `T` and `E`). The\n+/// wildcard `_` captures all values of the given type starting with any of the constructors for\n+/// that type.\n+///\n+/// We use this to compute whether different patterns might capture a same value. Do the patterns\n+/// `Ok(\"foo\")` and `Err(_)` capture a common value? The answer is no, because the first pattern\n+/// captures only values starting with the `Ok` constructor and the second only values starting\n+/// with the `Err` constructor. Do the patterns `Some(42)` and `Some(1..10)` intersect? They might,\n+/// since they both capture values starting with `Some`. To be certain, we need to dig under the\n+/// `Some` constructor and continue asking the question. This is the main idea behind the\n+/// exhaustiveness algorithm: by looking at patterns constructor-by-constructor, we can efficiently\n+/// figure out if some new pattern might capture a value that hadn't been captured by previous\n+/// patterns.\n+///\n+/// Constructors are represented by the `Constructor` enum, and its fields by the `Fields` enum.\n+/// Most of the complexity of this file resides in transforming between patterns and\n+/// (`Constructor`, `Fields`) pairs, handling all the special cases correctly.\n+///\n+/// Caveat: this constructors/fields distinction doesn't quite cover every Rust value. For example\n+/// a value of type `Rc<u64>` doesn't fit this idea very well, nor do various other things.\n+/// However, this idea covers most of the cases that are relevant to exhaustiveness checking.\n+///\n+///\n+/// # Algorithm\n+///\n+/// Recall that `U(P, p)` represents whether, given an existing list of patterns (aka matrix) `P`,\n+/// adding a new pattern `p` will cover previously-uncovered values of the type.\n /// During the course of the algorithm, the rows of the matrix won't just be individual patterns,\n-/// but rather partially-deconstructed patterns in the form of a list of patterns. The paper\n+/// but rather partially-deconstructed patterns in the form of a list of fields. The paper\n /// calls those pattern-vectors, and we will call them pattern-stacks. The same holds for the\n /// new pattern `p`.\n ///\n@@ -242,7 +287,7 @@ use rustc_hir::{HirId, RangeEnd};\n use rustc_middle::mir::interpret::{truncate, AllocId, ConstValue, Pointer, Scalar};\n use rustc_middle::mir::Field;\n use rustc_middle::ty::layout::IntegerExt;\n-use rustc_middle::ty::{self, Const, Ty, TyCtxt, TypeFoldable, VariantDef};\n+use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n use rustc_session::lint;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Integer, Size, VariantIdx};\n@@ -441,13 +486,11 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n         &self,\n         cx: &mut MatchCheckCtxt<'p, 'tcx>,\n         constructor: &Constructor<'tcx>,\n-        ctor_wild_subpatterns: &'p [Pat<'tcx>],\n+        ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Option<PatStack<'p, 'tcx>> {\n-        let new_heads = specialize_one_pattern(cx, self.head(), constructor, ctor_wild_subpatterns);\n-        new_heads.map(|mut new_head| {\n-            new_head.0.extend_from_slice(&self.0[1..]);\n-            new_head\n-        })\n+        let new_fields =\n+            specialize_one_pattern(cx, self.head(), constructor, ctor_wild_subpatterns)?;\n+        Some(new_fields.push_on_patstack(&self.0[1..]))\n     }\n }\n \n@@ -503,7 +546,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n         &self,\n         cx: &mut MatchCheckCtxt<'p, 'tcx>,\n         constructor: &Constructor<'tcx>,\n-        ctor_wild_subpatterns: &'p [Pat<'tcx>],\n+        ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Matrix<'p, 'tcx> {\n         self.0\n             .iter()\n@@ -593,7 +636,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    // Returns whether the given type is an enum from another crate declared `#[non_exhaustive]`.\n+    /// Returns whether the given type is an enum from another crate declared `#[non_exhaustive]`.\n     crate fn is_foreign_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n         match ty.kind {\n             ty::Adt(def, ..) => {\n@@ -602,15 +645,6 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n             _ => false,\n         }\n     }\n-\n-    // Returns whether the given variant is from another crate and has its fields declared\n-    // `#[non_exhaustive]`.\n-    fn is_foreign_non_exhaustive_variant(&self, ty: Ty<'tcx>, variant: &VariantDef) -> bool {\n-        match ty.kind {\n-            ty::Adt(def, ..) => variant.is_field_list_non_exhaustive() && !def.did.is_local(),\n-            _ => false,\n-        }\n-    }\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -722,10 +756,17 @@ impl Slice {\n     }\n }\n \n+/// A value can be decomposed into a constructor applied to some fields. This struct represents\n+/// the constructor. See also `Fields`.\n+///\n+/// `pat_constructor` retrieves the constructor corresponding to a pattern.\n+/// `specialize_one_pattern` returns the list of fields corresponding to a pattern, given a\n+/// constructor. `Constructor::apply` reconstructs the pattern from a pair of `Constructor` and\n+/// `Fields`.\n #[derive(Clone, Debug, PartialEq)]\n enum Constructor<'tcx> {\n-    /// The constructor of all patterns that don't vary by constructor,\n-    /// e.g., struct patterns and fixed-length arrays.\n+    /// The constructor for patterns that have a single constructor, like tuples, struct patterns\n+    /// and fixed-length arrays.\n     Single,\n     /// Enum variants.\n     Variant(DefId),\n@@ -850,107 +891,10 @@ impl<'tcx> Constructor<'tcx> {\n         }\n     }\n \n-    /// This returns one wildcard pattern for each argument to this constructor.\n-    ///\n-    /// This must be consistent with `apply`, `specialize_one_pattern`, and `arity`.\n-    fn wildcard_subpatterns<'a>(\n-        &self,\n-        cx: &MatchCheckCtxt<'a, 'tcx>,\n-        ty: Ty<'tcx>,\n-    ) -> Vec<Pat<'tcx>> {\n-        debug!(\"wildcard_subpatterns({:#?}, {:?})\", self, ty);\n-\n-        match self {\n-            Single | Variant(_) => match ty.kind {\n-                ty::Tuple(ref fs) => {\n-                    fs.into_iter().map(|t| t.expect_ty()).map(Pat::wildcard_from_ty).collect()\n-                }\n-                ty::Ref(_, rty, _) => vec![Pat::wildcard_from_ty(rty)],\n-                ty::Adt(adt, substs) => {\n-                    if adt.is_box() {\n-                        // Use T as the sub pattern type of Box<T>.\n-                        vec![Pat::wildcard_from_ty(substs.type_at(0))]\n-                    } else {\n-                        let variant = &adt.variants[self.variant_index_for_adt(cx, adt)];\n-                        let is_non_exhaustive = cx.is_foreign_non_exhaustive_variant(ty, variant);\n-                        variant\n-                            .fields\n-                            .iter()\n-                            .map(|field| {\n-                                let is_visible = adt.is_enum()\n-                                    || field.vis.is_accessible_from(cx.module, cx.tcx);\n-                                let is_uninhabited = cx.is_uninhabited(field.ty(cx.tcx, substs));\n-                                match (is_visible, is_non_exhaustive, is_uninhabited) {\n-                                    // Treat all uninhabited types in non-exhaustive variants as\n-                                    // `TyErr`.\n-                                    (_, true, true) => cx.tcx.types.err,\n-                                    // Treat all non-visible fields as `TyErr`. They can't appear\n-                                    // in any other pattern from this match (because they are\n-                                    // private), so their type does not matter - but we don't want\n-                                    // to know they are uninhabited.\n-                                    (false, ..) => cx.tcx.types.err,\n-                                    (true, ..) => {\n-                                        let ty = field.ty(cx.tcx, substs);\n-                                        match ty.kind {\n-                                            // If the field type returned is an array of an unknown\n-                                            // size return an TyErr.\n-                                            ty::Array(_, len)\n-                                                if len\n-                                                    .try_eval_usize(cx.tcx, cx.param_env)\n-                                                    .is_none() =>\n-                                            {\n-                                                cx.tcx.types.err\n-                                            }\n-                                            _ => ty,\n-                                        }\n-                                    }\n-                                }\n-                            })\n-                            .map(Pat::wildcard_from_ty)\n-                            .collect()\n-                    }\n-                }\n-                _ => vec![],\n-            },\n-            Slice(_) => match ty.kind {\n-                ty::Slice(ty) | ty::Array(ty, _) => {\n-                    let arity = self.arity(cx, ty);\n-                    (0..arity).map(|_| Pat::wildcard_from_ty(ty)).collect()\n-                }\n-                _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n-            },\n-            ConstantValue(..) | FloatRange(..) | IntRange(..) | NonExhaustive => vec![],\n-        }\n-    }\n-\n-    /// This computes the arity of a constructor. The arity of a constructor\n-    /// is how many subpattern patterns of that constructor should be expanded to.\n-    ///\n-    /// For instance, a tuple pattern `(_, 42, Some([]))` has the arity of 3.\n-    /// A struct pattern's arity is the number of fields it contains, etc.\n-    ///\n-    /// This must be consistent with `wildcard_subpatterns`, `specialize_one_pattern`, and `apply`.\n-    fn arity<'a>(&self, cx: &MatchCheckCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> u64 {\n-        debug!(\"Constructor::arity({:#?}, {:?})\", self, ty);\n-        match self {\n-            Single | Variant(_) => match ty.kind {\n-                ty::Tuple(ref fs) => fs.len() as u64,\n-                ty::Slice(..) | ty::Array(..) => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n-                ty::Ref(..) => 1,\n-                ty::Adt(adt, _) => {\n-                    adt.variants[self.variant_index_for_adt(cx, adt)].fields.len() as u64\n-                }\n-                _ => 0,\n-            },\n-            Slice(slice) => slice.arity(),\n-            ConstantValue(..) | FloatRange(..) | IntRange(..) | NonExhaustive => 0,\n-        }\n-    }\n-\n     /// Apply a constructor to a list of patterns, yielding a new pattern. `pats`\n     /// must have as many elements as this constructor's arity.\n     ///\n-    /// This must be consistent with `wildcard_subpatterns`, `specialize_one_pattern`, and `arity`.\n+    /// This is roughly the inverse of `specialize_one_pattern`.\n     ///\n     /// Examples:\n     /// `self`: `Constructor::Single`\n@@ -962,13 +906,13 @@ impl<'tcx> Constructor<'tcx> {\n     /// `ty`: `Option<bool>`\n     /// `pats`: `[false]`\n     /// returns `Some(false)`\n-    fn apply<'a>(\n+    fn apply<'p>(\n         &self,\n-        cx: &MatchCheckCtxt<'a, 'tcx>,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n         ty: Ty<'tcx>,\n-        pats: impl IntoIterator<Item = Pat<'tcx>>,\n+        fields: Fields<'p, 'tcx>,\n     ) -> Pat<'tcx> {\n-        let mut subpatterns = pats.into_iter();\n+        let mut subpatterns = fields.all_patterns();\n \n         let pat = match self {\n             Single | Variant(_) => match ty.kind {\n@@ -1033,8 +977,263 @@ impl<'tcx> Constructor<'tcx> {\n \n     /// Like `apply`, but where all the subpatterns are wildcards `_`.\n     fn apply_wildcards<'a>(&self, cx: &MatchCheckCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> Pat<'tcx> {\n-        let subpatterns = self.wildcard_subpatterns(cx, ty).into_iter().rev();\n-        self.apply(cx, ty, subpatterns)\n+        self.apply(cx, ty, Fields::wildcards(cx, self, ty))\n+    }\n+}\n+\n+/// Some fields need to be explicitly hidden away in certain cases; see the comment above the\n+/// `Fields` struct. This struct represents such a potentially-hidden field. When a field is hidden\n+/// we still keep its type around.\n+#[derive(Debug, Copy, Clone)]\n+enum FilteredField<'p, 'tcx> {\n+    Kept(&'p Pat<'tcx>),\n+    Hidden(Ty<'tcx>),\n+}\n+\n+impl<'p, 'tcx> FilteredField<'p, 'tcx> {\n+    fn kept(self) -> Option<&'p Pat<'tcx>> {\n+        match self {\n+            FilteredField::Kept(p) => Some(p),\n+            FilteredField::Hidden(_) => None,\n+        }\n+    }\n+\n+    fn to_pattern(self) -> Pat<'tcx> {\n+        match self {\n+            FilteredField::Kept(p) => p.clone(),\n+            FilteredField::Hidden(ty) => Pat::wildcard_from_ty(ty),\n+        }\n+    }\n+}\n+\n+/// A value can be decomposed into a constructor applied to some fields. This struct represents\n+/// those fields, generalized to allow patterns in each field. See also `Constructor`.\n+///\n+/// If a private or `non_exhaustive` field is uninhabited, the code mustn't observe that it is\n+/// uninhabited. For that, we filter these fields out of the matrix. This is subtle because we\n+/// still need to have those fields back when going to/from a `Pat`. Most of this is handled\n+/// automatically in `Fields`, but when constructing or deconstructing `Fields` you need to be\n+/// careful. As a rule, when going to/from the matrix, use the filtered field list; when going\n+/// to/from `Pat`, use the full field list.\n+/// This filtering is uncommon in practice, because uninhabited fields are rarely used, so we avoid\n+/// it when possible to preserve performance.\n+#[derive(Debug, Clone)]\n+enum Fields<'p, 'tcx> {\n+    /// Lists of patterns that don't contain any filtered fields.\n+    /// `Slice` and `Vec` behave the same; the difference is only to avoid allocating and\n+    /// triple-dereferences when possible. Frankly this is premature optimization, I (Nadrieril)\n+    /// have not measured if it really made a difference.\n+    Slice(&'p [Pat<'tcx>]),\n+    Vec(SmallVec<[&'p Pat<'tcx>; 2]>),\n+    /// Patterns where some of the fields need to be hidden. `len` caches the number of non-hidden\n+    /// fields.\n+    Filtered {\n+        fields: SmallVec<[FilteredField<'p, 'tcx>; 2]>,\n+        len: usize,\n+    },\n+}\n+\n+impl<'p, 'tcx> Fields<'p, 'tcx> {\n+    fn empty() -> Self {\n+        Fields::Slice(&[])\n+    }\n+\n+    /// Construct a new `Fields` from the given pattern. Must not be used if the pattern is a field\n+    /// of a struct/tuple/variant.\n+    fn from_single_pattern(pat: &'p Pat<'tcx>) -> Self {\n+        Fields::Slice(std::slice::from_ref(pat))\n+    }\n+\n+    /// Construct a new `Fields` from the given patterns. You must be sure those patterns can't\n+    /// contain fields that need to be filtered out. When in doubt, prefer `replace_fields`.\n+    fn from_slice_unfiltered(pats: &'p [Pat<'tcx>]) -> Self {\n+        Fields::Slice(pats)\n+    }\n+\n+    /// Convenience; internal use.\n+    fn wildcards_from_tys(\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        tys: impl IntoIterator<Item = Ty<'tcx>>,\n+    ) -> Self {\n+        let wilds = tys.into_iter().map(Pat::wildcard_from_ty);\n+        let pats = cx.pattern_arena.alloc_from_iter(wilds);\n+        Fields::Slice(pats)\n+    }\n+\n+    /// Creates a new list of wildcard fields for a given constructor.\n+    fn wildcards(\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        constructor: &Constructor<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> Self {\n+        debug!(\"Fields::wildcards({:#?}, {:?})\", constructor, ty);\n+        let wildcard_from_ty = |ty| &*cx.pattern_arena.alloc(Pat::wildcard_from_ty(ty));\n+\n+        match constructor {\n+            Single | Variant(_) => match ty.kind {\n+                ty::Tuple(ref fs) => {\n+                    Fields::wildcards_from_tys(cx, fs.into_iter().map(|ty| ty.expect_ty()))\n+                }\n+                ty::Ref(_, rty, _) => Fields::from_single_pattern(wildcard_from_ty(rty)),\n+                ty::Adt(adt, substs) => {\n+                    if adt.is_box() {\n+                        // Use T as the sub pattern type of Box<T>.\n+                        Fields::from_single_pattern(wildcard_from_ty(substs.type_at(0)))\n+                    } else {\n+                        let variant = &adt.variants[constructor.variant_index_for_adt(cx, adt)];\n+                        // Whether we must not match the fields of this variant exhaustively.\n+                        let is_non_exhaustive =\n+                            variant.is_field_list_non_exhaustive() && !adt.did.is_local();\n+                        let field_tys = variant.fields.iter().map(|field| field.ty(cx.tcx, substs));\n+                        // In the following cases, we don't need to filter out any fields. This is\n+                        // the vast majority of real cases, since uninhabited fields are uncommon.\n+                        let has_no_hidden_fields = (adt.is_enum() && !is_non_exhaustive)\n+                            || !field_tys.clone().any(|ty| cx.is_uninhabited(ty));\n+\n+                        if has_no_hidden_fields {\n+                            Fields::wildcards_from_tys(cx, field_tys)\n+                        } else {\n+                            let mut len = 0;\n+                            let fields = variant\n+                                .fields\n+                                .iter()\n+                                .map(|field| {\n+                                    let ty = field.ty(cx.tcx, substs);\n+                                    let is_visible = adt.is_enum()\n+                                        || field.vis.is_accessible_from(cx.module, cx.tcx);\n+                                    let is_uninhabited = cx.is_uninhabited(ty);\n+\n+                                    // In the cases of either a `#[non_exhaustive]` field list\n+                                    // or a non-public field, we hide uninhabited fields in\n+                                    // order not to reveal the uninhabitedness of the whole\n+                                    // variant.\n+                                    if is_uninhabited && (!is_visible || is_non_exhaustive) {\n+                                        FilteredField::Hidden(ty)\n+                                    } else {\n+                                        len += 1;\n+                                        FilteredField::Kept(wildcard_from_ty(ty))\n+                                    }\n+                                })\n+                                .collect();\n+                            Fields::Filtered { fields, len }\n+                        }\n+                    }\n+                }\n+                _ => Fields::empty(),\n+            },\n+            Slice(slice) => match ty.kind {\n+                ty::Slice(ty) | ty::Array(ty, _) => {\n+                    let arity = slice.arity();\n+                    Fields::wildcards_from_tys(cx, (0..arity).map(|_| ty))\n+                }\n+                _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, ty),\n+            },\n+            ConstantValue(..) | FloatRange(..) | IntRange(..) | NonExhaustive => Fields::empty(),\n+        }\n+    }\n+\n+    fn len(&self) -> usize {\n+        match self {\n+            Fields::Slice(pats) => pats.len(),\n+            Fields::Vec(pats) => pats.len(),\n+            Fields::Filtered { len, .. } => *len,\n+        }\n+    }\n+\n+    /// Returns the complete list of patterns, including hidden fields.\n+    fn all_patterns(self) -> impl Iterator<Item = Pat<'tcx>> {\n+        let pats: SmallVec<[_; 2]> = match self {\n+            Fields::Slice(pats) => pats.iter().cloned().collect(),\n+            Fields::Vec(pats) => pats.into_iter().cloned().collect(),\n+            Fields::Filtered { fields, .. } => {\n+                // We don't skip any fields here.\n+                fields.into_iter().map(|p| p.to_pattern()).collect()\n+            }\n+        };\n+        pats.into_iter()\n+    }\n+\n+    /// Overrides some of the fields with the provided patterns. Exactly like\n+    /// `replace_fields_indexed`, except that it takes `FieldPat`s as input.\n+    fn replace_with_fieldpats(\n+        &self,\n+        new_pats: impl IntoIterator<Item = &'p FieldPat<'tcx>>,\n+    ) -> Self {\n+        self.replace_fields_indexed(\n+            new_pats.into_iter().map(|pat| (pat.field.index(), &pat.pattern)),\n+        )\n+    }\n+\n+    /// Overrides some of the fields with the provided patterns. This is used when a pattern\n+    /// defines some fields but not all, for example `Foo { field1: Some(_), .. }`: here we start with a\n+    /// `Fields` that is just one wildcard per field of the `Foo` struct, and override the entry\n+    /// corresponding to `field1` with the pattern `Some(_)`. This is also used for slice patterns\n+    /// for the same reason.\n+    fn replace_fields_indexed(\n+        &self,\n+        new_pats: impl IntoIterator<Item = (usize, &'p Pat<'tcx>)>,\n+    ) -> Self {\n+        let mut fields = self.clone();\n+        if let Fields::Slice(pats) = fields {\n+            fields = Fields::Vec(pats.iter().collect());\n+        }\n+\n+        match &mut fields {\n+            Fields::Vec(pats) => {\n+                for (i, pat) in new_pats {\n+                    pats[i] = pat\n+                }\n+            }\n+            Fields::Filtered { fields, .. } => {\n+                for (i, pat) in new_pats {\n+                    if let FilteredField::Kept(p) = &mut fields[i] {\n+                        *p = pat\n+                    }\n+                }\n+            }\n+            Fields::Slice(_) => unreachable!(),\n+        }\n+        fields\n+    }\n+\n+    /// Replaces contained fields with the given filtered list of patterns, e.g. taken from the\n+    /// matrix. There must be `len()` patterns in `pats`.\n+    fn replace_fields(\n+        &self,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        pats: impl IntoIterator<Item = Pat<'tcx>>,\n+    ) -> Self {\n+        let pats: &[_] = cx.pattern_arena.alloc_from_iter(pats);\n+\n+        match self {\n+            Fields::Filtered { fields, len } => {\n+                let mut pats = pats.iter();\n+                let mut fields = fields.clone();\n+                for f in &mut fields {\n+                    if let FilteredField::Kept(p) = f {\n+                        // We take one input pattern for each `Kept` field, in order.\n+                        *p = pats.next().unwrap();\n+                    }\n+                }\n+                Fields::Filtered { fields, len: *len }\n+            }\n+            _ => Fields::Slice(pats),\n+        }\n+    }\n+\n+    fn push_on_patstack(self, stack: &[&'p Pat<'tcx>]) -> PatStack<'p, 'tcx> {\n+        let pats: SmallVec<_> = match self {\n+            Fields::Slice(pats) => pats.iter().chain(stack.iter().copied()).collect(),\n+            Fields::Vec(mut pats) => {\n+                pats.extend_from_slice(stack);\n+                pats\n+            }\n+            Fields::Filtered { fields, .. } => {\n+                // We skip hidden fields here\n+                fields.into_iter().filter_map(|p| p.kept()).chain(stack.iter().copied()).collect()\n+            }\n+        };\n+        PatStack::from_vec(pats)\n     }\n }\n \n@@ -1064,15 +1263,16 @@ impl<'tcx, 'p> Usefulness<'tcx, 'p> {\n \n     fn apply_constructor(\n         self,\n-        cx: &MatchCheckCtxt<'_, 'tcx>,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n         ctor: &Constructor<'tcx>,\n         ty: Ty<'tcx>,\n+        ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Self {\n         match self {\n             UsefulWithWitness(witnesses) => UsefulWithWitness(\n                 witnesses\n                     .into_iter()\n-                    .map(|witness| witness.apply_constructor(cx, &ctor, ty))\n+                    .map(|witness| witness.apply_constructor(cx, &ctor, ty, ctor_wild_subpatterns))\n                     .collect(),\n             ),\n             x => x,\n@@ -1192,17 +1392,19 @@ impl<'tcx> Witness<'tcx> {\n     ///\n     /// left_ty: struct X { a: (bool, &'static str), b: usize}\n     /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n-    fn apply_constructor<'a>(\n+    fn apply_constructor<'p>(\n         mut self,\n-        cx: &MatchCheckCtxt<'a, 'tcx>,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n         ctor: &Constructor<'tcx>,\n         ty: Ty<'tcx>,\n+        ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Self {\n-        let arity = ctor.arity(cx, ty);\n         let pat = {\n-            let len = self.0.len() as u64;\n-            let pats = self.0.drain((len - arity) as usize..).rev();\n-            ctor.apply(cx, ty, pats)\n+            let len = self.0.len();\n+            let arity = ctor_wild_subpatterns.len();\n+            let pats = self.0.drain((len - arity)..).rev();\n+            let fields = ctor_wild_subpatterns.replace_fields(cx, pats);\n+            ctor.apply(cx, ty, fields)\n         };\n \n         self.0.push(pat);\n@@ -1600,11 +1802,7 @@ impl<'tcx> fmt::Debug for MissingConstructors<'tcx> {\n /// to a set of such vectors `m` - this is defined as there being a set of\n /// inputs that will match `v` but not any of the sets in `m`.\n ///\n-/// All the patterns at each column of the `matrix ++ v` matrix must\n-/// have the same type, except that wildcard (PatKind::Wild) patterns\n-/// with type `TyErr` are also allowed, even if the \"type of the column\"\n-/// is not `TyErr`. That is used to represent private fields, as using their\n-/// real type would assert that they are inhabited.\n+/// All the patterns at each column of the `matrix ++ v` matrix must have the same type.\n ///\n /// This is used both for reachability checking (if a pattern isn't useful in\n /// relation to preceding patterns, it is not reachable) and exhaustiveness\n@@ -1668,34 +1866,7 @@ crate fn is_useful<'p, 'tcx>(\n         return if any_is_useful { Useful(unreachable_pats) } else { NotUseful };\n     }\n \n-    let (ty, span) = matrix\n-        .heads()\n-        .map(|r| (r.ty, r.span))\n-        .find(|(ty, _)| !ty.references_error())\n-        .unwrap_or((v.head().ty, v.head().span));\n-    let pcx = PatCtxt {\n-        // TyErr is used to represent the type of wildcard patterns matching\n-        // against inaccessible (private) fields of structs, so that we won't\n-        // be able to observe whether the types of the struct's fields are\n-        // inhabited.\n-        //\n-        // If the field is truly inaccessible, then all the patterns\n-        // matching against it must be wildcard patterns, so its type\n-        // does not matter.\n-        //\n-        // However, if we are matching against non-wildcard patterns, we\n-        // need to know the real type of the field so we can specialize\n-        // against it. This primarily occurs through constants - they\n-        // can include contents for fields that are inaccessible at the\n-        // location of the match. In that case, the field's type is\n-        // inhabited - by the constant - so we can just use it.\n-        //\n-        // FIXME: this might lead to \"unstable\" behavior with macro hygiene\n-        // introducing uninhabited patterns for inaccessible fields. We\n-        // need to figure out how to model that.\n-        ty,\n-        span,\n-    };\n+    let pcx = PatCtxt { ty: v.head().ty, span: v.head().span };\n \n     debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v.head());\n \n@@ -1827,19 +1998,19 @@ fn is_useful_specialized<'p, 'tcx>(\n     matrix: &Matrix<'p, 'tcx>,\n     v: &PatStack<'p, 'tcx>,\n     ctor: Constructor<'tcx>,\n-    lty: Ty<'tcx>,\n+    ty: Ty<'tcx>,\n     witness_preference: WitnessPreference,\n     hir_id: HirId,\n     is_under_guard: bool,\n ) -> Usefulness<'tcx, 'p> {\n-    debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n+    debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, ty);\n \n-    let ctor_wild_subpatterns =\n-        cx.pattern_arena.alloc_from_iter(ctor.wildcard_subpatterns(cx, lty));\n-    let matrix = matrix.specialize_constructor(cx, &ctor, ctor_wild_subpatterns);\n-    v.specialize_constructor(cx, &ctor, ctor_wild_subpatterns)\n+    // We cache the result of `Fields::wildcards` because it is used a lot.\n+    let ctor_wild_subpatterns = Fields::wildcards(cx, &ctor, ty);\n+    let matrix = matrix.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns);\n+    v.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns)\n         .map(|v| is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false))\n-        .map(|u| u.apply_constructor(cx, &ctor, lty))\n+        .map(|u| u.apply_constructor(cx, &ctor, ty, &ctor_wild_subpatterns))\n         .unwrap_or(NotUseful)\n }\n \n@@ -2303,27 +2474,6 @@ fn constructor_covered_by_range<'tcx>(\n     if intersects { Some(()) } else { None }\n }\n \n-fn patterns_for_variant<'p, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n-    subpatterns: &'p [FieldPat<'tcx>],\n-    ctor_wild_subpatterns: &'p [Pat<'tcx>],\n-    is_non_exhaustive: bool,\n-) -> PatStack<'p, 'tcx> {\n-    let mut result: SmallVec<_> = ctor_wild_subpatterns.iter().collect();\n-\n-    for subpat in subpatterns {\n-        if !is_non_exhaustive || !cx.is_uninhabited(subpat.pattern.ty) {\n-            result[subpat.field.index()] = &subpat.pattern;\n-        }\n-    }\n-\n-    debug!(\n-        \"patterns_for_variant({:#?}, {:#?}) = {:#?}\",\n-        subpatterns, ctor_wild_subpatterns, result\n-    );\n-    PatStack::from_vec(result)\n-}\n-\n /// This is the main specialization step. It expands the pattern\n /// into `arity` patterns based on the constructor. For most patterns, the step is trivial,\n /// for instance tuple patterns are flattened and box patterns expand into their inner pattern.\n@@ -2333,37 +2483,40 @@ fn patterns_for_variant<'p, 'tcx>(\n /// different patterns.\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n+///\n+/// This is roughly the inverse of `Constructor::apply`.\n fn specialize_one_pattern<'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     pat: &'p Pat<'tcx>,\n     constructor: &Constructor<'tcx>,\n-    ctor_wild_subpatterns: &'p [Pat<'tcx>],\n-) -> Option<PatStack<'p, 'tcx>> {\n+    ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n+) -> Option<Fields<'p, 'tcx>> {\n     if let NonExhaustive = constructor {\n         // Only a wildcard pattern can match the special extra constructor\n-        return if pat.is_wildcard() { Some(PatStack::default()) } else { None };\n+        if !pat.is_wildcard() {\n+            return None;\n+        }\n+        return Some(Fields::empty());\n     }\n \n     let result = match *pat.kind {\n         PatKind::AscribeUserType { .. } => bug!(), // Handled by `expand_pattern`\n \n-        PatKind::Binding { .. } | PatKind::Wild => Some(ctor_wild_subpatterns.iter().collect()),\n+        PatKind::Binding { .. } | PatKind::Wild => Some(ctor_wild_subpatterns.clone()),\n \n         PatKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let variant = &adt_def.variants[variant_index];\n-            let is_non_exhaustive = cx.is_foreign_non_exhaustive_variant(pat.ty, variant);\n-            Some(Variant(variant.def_id))\n-                .filter(|variant_constructor| variant_constructor == constructor)\n-                .map(|_| {\n-                    patterns_for_variant(cx, subpatterns, ctor_wild_subpatterns, is_non_exhaustive)\n-                })\n+            if constructor != &Variant(variant.def_id) {\n+                return None;\n+            }\n+            Some(ctor_wild_subpatterns.replace_with_fieldpats(subpatterns))\n         }\n \n         PatKind::Leaf { ref subpatterns } => {\n-            Some(patterns_for_variant(cx, subpatterns, ctor_wild_subpatterns, false))\n+            Some(ctor_wild_subpatterns.replace_with_fieldpats(subpatterns))\n         }\n \n-        PatKind::Deref { ref subpattern } => Some(PatStack::from_pattern(subpattern)),\n+        PatKind::Deref { ref subpattern } => Some(Fields::from_single_pattern(subpattern)),\n \n         PatKind::Constant { value } if constructor.is_slice() => {\n             // We extract an `Option` for the pointer because slices of zero\n@@ -2376,11 +2529,10 @@ fn specialize_one_pattern<'p, 'tcx>(\n                     // Shortcut for `n == 0` where no matter what `alloc` and `offset` we produce,\n                     // the result would be exactly what we early return here.\n                     if n == 0 {\n-                        if ctor_wild_subpatterns.len() as u64 == 0 {\n-                            return Some(PatStack::from_slice(&[]));\n-                        } else {\n+                        if ctor_wild_subpatterns.len() as u64 != n {\n                             return None;\n                         }\n+                        return Some(Fields::empty());\n                     }\n                     match value.val {\n                         ty::ConstKind::Value(ConstValue::ByRef { offset, alloc, .. }) => {\n@@ -2414,75 +2566,66 @@ fn specialize_one_pattern<'p, 'tcx>(\n                     constructor,\n                 ),\n             };\n-            if ctor_wild_subpatterns.len() as u64 == n {\n-                // convert a constant slice/array pattern to a list of patterns.\n-                let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n-                let ptr = Pointer::new(AllocId(0), offset);\n-                (0..n)\n-                    .map(|i| {\n-                        let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n-                        let scalar = alloc.read_scalar(&cx.tcx, ptr, layout.size).ok()?;\n-                        let scalar = scalar.not_undef().ok()?;\n-                        let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n-                        let pattern =\n-                            Pat { ty, span: pat.span, kind: box PatKind::Constant { value } };\n-                        Some(&*cx.pattern_arena.alloc(pattern))\n-                    })\n-                    .collect()\n-            } else {\n-                None\n+            if ctor_wild_subpatterns.len() as u64 != n {\n+                return None;\n+            }\n+\n+            // Convert a constant slice/array pattern to a list of patterns.\n+            let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n+            let ptr = Pointer::new(AllocId(0), offset);\n+            let pats = cx.pattern_arena.alloc_from_iter((0..n).filter_map(|i| {\n+                let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n+                let scalar = alloc.read_scalar(&cx.tcx, ptr, layout.size).ok()?;\n+                let scalar = scalar.not_undef().ok()?;\n+                let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n+                let pattern = Pat { ty, span: pat.span, kind: box PatKind::Constant { value } };\n+                Some(pattern)\n+            }));\n+            // Ensure none of the dereferences failed.\n+            if pats.len() as u64 != n {\n+                return None;\n             }\n+            Some(Fields::from_slice_unfiltered(pats))\n         }\n \n         PatKind::Constant { .. } | PatKind::Range { .. } => {\n             // If the constructor is a:\n             // - Single value: add a row if the pattern contains the constructor.\n             // - Range: add a row if the constructor intersects the pattern.\n             if let IntRange(ctor) = constructor {\n-                match IntRange::from_pat(cx.tcx, cx.param_env, pat) {\n-                    Some(pat) => ctor.intersection(cx.tcx, &pat).map(|_| {\n-                        // Constructor splitting should ensure that all intersections we encounter\n-                        // are actually inclusions.\n-                        assert!(ctor.is_subrange(&pat));\n-                        PatStack::default()\n-                    }),\n-                    _ => None,\n-                }\n+                let pat = IntRange::from_pat(cx.tcx, cx.param_env, pat)?;\n+                ctor.intersection(cx.tcx, &pat)?;\n+                // Constructor splitting should ensure that all intersections we encounter\n+                // are actually inclusions.\n+                assert!(ctor.is_subrange(&pat));\n             } else {\n                 // Fallback for non-ranges and ranges that involve\n                 // floating-point numbers, which are not conveniently handled\n                 // by `IntRange`. For these cases, the constructor may not be a\n                 // range so intersection actually devolves into being covered\n                 // by the pattern.\n-                constructor_covered_by_range(cx.tcx, cx.param_env, constructor, pat)\n-                    .map(|()| PatStack::default())\n+                constructor_covered_by_range(cx.tcx, cx.param_env, constructor, pat)?;\n             }\n+            Some(Fields::empty())\n         }\n \n         PatKind::Array { ref prefix, ref slice, ref suffix }\n         | PatKind::Slice { ref prefix, ref slice, ref suffix } => match *constructor {\n             Slice(_) => {\n+                // Number of subpatterns for this pattern\n                 let pat_len = prefix.len() + suffix.len();\n-                if let Some(slice_count) = ctor_wild_subpatterns.len().checked_sub(pat_len) {\n-                    if slice_count == 0 || slice.is_some() {\n-                        Some(\n-                            prefix\n-                                .iter()\n-                                .chain(\n-                                    ctor_wild_subpatterns\n-                                        .iter()\n-                                        .skip(prefix.len())\n-                                        .take(slice_count)\n-                                        .chain(suffix.iter()),\n-                                )\n-                                .collect(),\n-                        )\n-                    } else {\n-                        None\n-                    }\n-                } else {\n-                    None\n+                // Number of subpatterns for this constructor\n+                let arity = ctor_wild_subpatterns.len();\n+\n+                if (slice.is_none() && arity != pat_len) || pat_len > arity {\n+                    return None;\n                 }\n+\n+                // Replace the prefix and the suffix with the given patterns, leaving wildcards in\n+                // the middle if there was a subslice pattern `..`.\n+                let prefix = prefix.iter().enumerate();\n+                let suffix = suffix.iter().enumerate().map(|(i, p)| (arity - suffix.len() + i, p));\n+                Some(ctor_wild_subpatterns.replace_fields_indexed(prefix.chain(suffix)))\n             }\n             ConstantValue(cv) => {\n                 match slice_pat_covered_by_const(\n@@ -2494,7 +2637,7 @@ fn specialize_one_pattern<'p, 'tcx>(\n                     suffix,\n                     cx.param_env,\n                 ) {\n-                    Ok(true) => Some(PatStack::default()),\n+                    Ok(true) => Some(Fields::empty()),\n                     Ok(false) => None,\n                     Err(ErrorReported) => None,\n                 }"}, {"sha": "707502640e05c613619a3d458a3f91f479cd6c98", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9310e3bd4f425f84fc27878ebf2bda1f30935a63/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9310e3bd4f425f84fc27878ebf2bda1f30935a63/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=9310e3bd4f425f84fc27878ebf2bda1f30935a63", "patch": "@@ -187,9 +187,9 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         let matrix = check_arms(&mut cx, &inlined_arms, source);\n \n         // Fifth, check if the match is exhaustive.\n-        let scrut_ty = self.tables.node_type(scrut.hir_id);\n         // Note: An empty match isn't the same as an empty matrix for diagnostics purposes,\n         // since an empty matrix can occur when there are arms, if those arms all have guards.\n+        let scrut_ty = self.tables.expr_ty_adjusted(scrut);\n         let is_empty_match = inlined_arms.is_empty();\n         check_exhaustive(&mut cx, scrut_ty, scrut.span, &matrix, scrut.hir_id, is_empty_match);\n     }"}, {"sha": "fb139b5033b3b40b6571331624344cb3e1e843e9", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9310e3bd4f425f84fc27878ebf2bda1f30935a63/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9310e3bd4f425f84fc27878ebf2bda1f30935a63/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=9310e3bd4f425f84fc27878ebf2bda1f30935a63", "patch": "@@ -436,6 +436,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if let Some(m) = contains_ref_bindings {\n             self.check_expr_with_needs(scrut, Needs::maybe_mut_place(m))\n+        } else if arms.is_empty() {\n+            self.check_expr(scrut)\n         } else {\n             // ...but otherwise we want to use any supertype of the\n             // scrutinee. This is sort of a workaround, see note (*) in"}, {"sha": "e2ff9ac87ef51efd5aacaab3a72df0bdf2fae787", "filename": "src/test/ui/pattern/usefulness/issue-71930-type-of-match-scrutinee.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9310e3bd4f425f84fc27878ebf2bda1f30935a63/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-71930-type-of-match-scrutinee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9310e3bd4f425f84fc27878ebf2bda1f30935a63/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-71930-type-of-match-scrutinee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-71930-type-of-match-scrutinee.rs?ref=9310e3bd4f425f84fc27878ebf2bda1f30935a63", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+\n+// In PR 71930, it was discovered that the code to retrieve the inferred type of a match scrutinee\n+// was incorrect.\n+\n+fn f() -> ! {\n+    panic!()\n+}\n+\n+fn g() -> usize {\n+    match f() { // Should infer type `bool`\n+        false => 0,\n+        true => 1,\n+    }\n+}\n+\n+fn h() -> usize {\n+    match f() { // Should infer type `!`\n+    }\n+}\n+\n+fn main() {}"}]}