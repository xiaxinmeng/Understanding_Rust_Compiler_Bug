{"sha": "35a0407814a6b5a04f0929105631e9c69e293e9d", "node_id": "C_kwDOAAsO6NoAKDM1YTA0MDc4MTRhNmI1YTA0ZjA5MjkxMDU2MzFlOWM2OWUyOTNlOWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-15T15:19:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-15T15:19:40Z"}, "message": "Auto merge of #101410 - dingxiangfei2009:fix-let-else-scoping, r=jackh726\n\nReorder nesting scopes and declare bindings without drop schedule\n\nFix #99228\nFix #99975\n\nStorages are previously not declared before entering the `else` block of a `let .. else` statement. However, when breaking out of the pattern matching into the `else` block, those storages are recorded as scheduled for drops. This is not expected.\n\nThis MR fixes this issue by not scheduling the drops for those storages.\n\ncc `@est31`", "tree": {"sha": "8e8ab0230130faf7dbe38a997deb1cde8d019b18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e8ab0230130faf7dbe38a997deb1cde8d019b18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35a0407814a6b5a04f0929105631e9c69e293e9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35a0407814a6b5a04f0929105631e9c69e293e9d", "html_url": "https://github.com/rust-lang/rust/commit/35a0407814a6b5a04f0929105631e9c69e293e9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35a0407814a6b5a04f0929105631e9c69e293e9d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "294f0eef736aa13cadf28ce7160a18a94ca7b87c", "url": "https://api.github.com/repos/rust-lang/rust/commits/294f0eef736aa13cadf28ce7160a18a94ca7b87c", "html_url": "https://github.com/rust-lang/rust/commit/294f0eef736aa13cadf28ce7160a18a94ca7b87c"}, {"sha": "4a5d2a561c6f82f928d6f14fe6e8f9ad2415b9a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a5d2a561c6f82f928d6f14fe6e8f9ad2415b9a8", "html_url": "https://github.com/rust-lang/rust/commit/4a5d2a561c6f82f928d6f14fe6e8f9ad2415b9a8"}], "stats": {"total": 286, "additions": 221, "deletions": 65}, "files": [{"sha": "7ab7870c4642f523226f32558b235bd41016804f", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 166, "deletions": 22, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/35a0407814a6b5a04f0929105631e9c69e293e9d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a0407814a6b5a04f0929105631e9c69e293e9d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=35a0407814a6b5a04f0929105631e9c69e293e9d", "patch": "@@ -109,13 +109,170 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         )\n                     );\n                 }\n+                StmtKind::Let {\n+                    remainder_scope,\n+                    init_scope,\n+                    pattern,\n+                    initializer: Some(initializer),\n+                    lint_level,\n+                    else_block: Some(else_block),\n+                } => {\n+                    // When lowering the statement `let <pat> = <expr> else { <else> };`,\n+                    // the `<else>` block is nested in the parent scope enclosing this statment.\n+                    // That scope is usually either the enclosing block scope,\n+                    // or the remainder scope of the last statement.\n+                    // This is to make sure that temporaries instantiated in `<expr>` are dropped\n+                    // as well.\n+                    // In addition, even though bindings in `<pat>` only come into scope if\n+                    // the pattern matching passes, in the MIR building the storages for them\n+                    // are declared as live any way.\n+                    // This is similar to `let x;` statements without an initializer expression,\n+                    // where the value of `x` in this example may or may be assigned,\n+                    // because the storage for their values may not be live after all due to\n+                    // failure in pattern matching.\n+                    // For this reason, we declare those storages as live but we do not schedule\n+                    // any drop yet- they are scheduled later after the pattern matching.\n+                    // The generated MIR will have `StorageDead` whenever the control flow breaks out\n+                    // of the parent scope, regardless of the result of the pattern matching.\n+                    // However, the drops are inserted in MIR only when the control flow breaks out of\n+                    // the scope of the remainder scope associated with this `let .. else` statement.\n+                    // Pictorial explanation of the scope structure:\n+                    // \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                    // \u2502  Scope of the enclosing block,  \u2502\n+                    // \u2502  or the last remainder scope    \u2502\n+                    // \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n+                    // \u2502  \u2502  Scope for <else> block   \u2502  \u2502\n+                    // \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n+                    // \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n+                    // \u2502  \u2502  Remainder scope of       \u2502  \u2502\n+                    // \u2502  \u2502  this let-else statement  \u2502  \u2502\n+                    // \u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u2502\n+                    // \u2502  \u2502  \u2502 <expr> scope        \u2502  \u2502  \u2502\n+                    // \u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2502\n+                    // \u2502  \u2502  extended temporaries in  \u2502  \u2502\n+                    // \u2502  \u2502  <expr> lives in this     \u2502  \u2502\n+                    // \u2502  \u2502  scope                    \u2502  \u2502\n+                    // \u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u2502\n+                    // \u2502  \u2502  \u2502 Scopes for the rest \u2502  \u2502  \u2502\n+                    // \u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2502\n+                    // \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n+                    // \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                    // Generated control flow:\n+                    //          \u2502 let Some(x) = y() else { return; }\n+                    //          \u2502\n+                    // \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                    // \u2502 evaluate y()   \u2502\n+                    // \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                    //          \u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                    // \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502Drop temporaries\u2502\n+                    // \u2502Test the pattern\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u25bain y()          \u2502\n+                    // \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502because breaking\u2502\n+                    //          \u2502              \u2502out of <expr>   \u2502\n+                    // \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502scope           \u2502\n+                    // \u2502Move value into \u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                    // \u2502binding x       \u2502              \u2502\n+                    // \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                    //          \u2502              \u2502Drop extended   \u2502\n+                    // \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502temporaries in  \u2502\n+                    // \u2502Drop temporaries\u2502      \u2502<expr> because  \u2502\n+                    // \u2502in y()          \u2502      \u2502breaking out of \u2502\n+                    // \u2502because breaking\u2502      \u2502remainder scope \u2502\n+                    // \u2502out of <expr>   \u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                    // \u2502scope           \u2502              \u2502\n+                    // \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                    //          \u2502              \u2502Enter <else>    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\n+                    // \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502block           \u2502 return;\n+                    // \u2502Continue...     \u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                    // \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+                    let ignores_expr_result = matches!(pattern.kind, PatKind::Wild);\n+                    this.block_context.push(BlockFrame::Statement { ignores_expr_result });\n+\n+                    // Lower the `else` block first because its parent scope is actually\n+                    // enclosing the rest of the `let .. else ..` parts.\n+                    let else_block_span = this.thir[*else_block].span;\n+                    // This place is not really used because this destination place\n+                    // should never be used to take values at the end of the failure\n+                    // block.\n+                    let dummy_place = this.temp(this.tcx.types.never, else_block_span);\n+                    let failure_entry = this.cfg.start_new_block();\n+                    let failure_block;\n+                    unpack!(\n+                        failure_block = this.ast_block(\n+                            dummy_place,\n+                            failure_entry,\n+                            *else_block,\n+                            this.source_info(else_block_span),\n+                        )\n+                    );\n+                    this.cfg.terminate(\n+                        failure_block,\n+                        this.source_info(else_block_span),\n+                        TerminatorKind::Unreachable,\n+                    );\n+\n+                    // Declare the bindings, which may create a source scope.\n+                    let remainder_span = remainder_scope.span(this.tcx, this.region_scope_tree);\n+                    this.push_scope((*remainder_scope, source_info));\n+                    let_scope_stack.push(remainder_scope);\n+\n+                    let visibility_scope =\n+                        Some(this.new_source_scope(remainder_span, LintLevel::Inherited, None));\n+\n+                    let init = &this.thir[*initializer];\n+                    let initializer_span = init.span;\n+                    this.declare_bindings(\n+                        visibility_scope,\n+                        remainder_span,\n+                        pattern,\n+                        ArmHasGuard(false),\n+                        Some((None, initializer_span)),\n+                    );\n+                    this.visit_primary_bindings(\n+                        pattern,\n+                        UserTypeProjections::none(),\n+                        &mut |this, _, _, _, node, span, _, _| {\n+                            this.storage_live_binding(block, node, span, OutsideGuard, false);\n+                        },\n+                    );\n+                    let failure = unpack!(\n+                        block = this.in_opt_scope(\n+                            opt_destruction_scope.map(|de| (de, source_info)),\n+                            |this| {\n+                                let scope = (*init_scope, source_info);\n+                                this.in_scope(scope, *lint_level, |this| {\n+                                    this.ast_let_else(\n+                                        block,\n+                                        init,\n+                                        initializer_span,\n+                                        *else_block,\n+                                        &last_remainder_scope,\n+                                        pattern,\n+                                    )\n+                                })\n+                            }\n+                        )\n+                    );\n+                    this.cfg.goto(failure, source_info, failure_entry);\n+\n+                    if let Some(source_scope) = visibility_scope {\n+                        this.source_scope = source_scope;\n+                    }\n+                    last_remainder_scope = *remainder_scope;\n+                }\n+                StmtKind::Let { init_scope, initializer: None, else_block: Some(_), .. } => {\n+                    span_bug!(\n+                        init_scope.span(this.tcx, this.region_scope_tree),\n+                        \"initializer is missing, but else block is present in this let binding\",\n+                    )\n+                }\n                 StmtKind::Let {\n                     remainder_scope,\n                     init_scope,\n                     ref pattern,\n                     initializer,\n                     lint_level,\n-                    else_block,\n+                    else_block: None,\n                 } => {\n                     let ignores_expr_result = matches!(pattern.kind, PatKind::Wild);\n                     this.block_context.push(BlockFrame::Statement { ignores_expr_result });\n@@ -141,27 +298,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 |this| {\n                                     let scope = (*init_scope, source_info);\n                                     this.in_scope(scope, *lint_level, |this| {\n-                                        if let Some(else_block) = else_block {\n-                                            this.ast_let_else(\n-                                                block,\n-                                                init,\n-                                                initializer_span,\n-                                                *else_block,\n-                                                visibility_scope,\n-                                                last_remainder_scope,\n-                                                remainder_span,\n-                                                pattern,\n-                                            )\n-                                        } else {\n-                                            this.declare_bindings(\n-                                                visibility_scope,\n-                                                remainder_span,\n-                                                pattern,\n-                                                ArmHasGuard(false),\n-                                                Some((None, initializer_span)),\n-                                            );\n-                                            this.expr_into_pattern(block, pattern, init) // irrefutable pattern\n-                                        }\n+                                        this.declare_bindings(\n+                                            visibility_scope,\n+                                            remainder_span,\n+                                            pattern,\n+                                            ArmHasGuard(false),\n+                                            Some((None, initializer_span)),\n+                                        );\n+                                        this.expr_into_pattern(block, &pattern, init) // irrefutable pattern\n                                     })\n                                 },\n                             )"}, {"sha": "e0727725f68d5a92524cf01a57d101716a3d051b", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 6, "deletions": 34, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/35a0407814a6b5a04f0929105631e9c69e293e9d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a0407814a6b5a04f0929105631e9c69e293e9d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=35a0407814a6b5a04f0929105631e9c69e293e9d", "patch": "@@ -699,7 +699,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.cfg.push(block, Statement { source_info, kind: StatementKind::StorageLive(local_id) });\n         // Although there is almost always scope for given variable in corner cases\n         // like #92893 we might get variable with no scope.\n-        if let Some(region_scope) = self.region_scope_tree.var_scope(var.0.local_id) && schedule_drop{\n+        if let Some(region_scope) = self.region_scope_tree.var_scope(var.0.local_id) && schedule_drop {\n             self.schedule_drop(span, region_scope, local_id, DropKind::Storage);\n         }\n         Place::from(local_id)\n@@ -2274,23 +2274,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         init: &Expr<'tcx>,\n         initializer_span: Span,\n         else_block: BlockId,\n-        visibility_scope: Option<SourceScope>,\n-        remainder_scope: region::Scope,\n-        remainder_span: Span,\n+        let_else_scope: &region::Scope,\n         pattern: &Pat<'tcx>,\n-    ) -> BlockAnd<()> {\n+    ) -> BlockAnd<BasicBlock> {\n         let else_block_span = self.thir[else_block].span;\n-        let (matching, failure) = self.in_if_then_scope(remainder_scope, |this| {\n+        let (matching, failure) = self.in_if_then_scope(*let_else_scope, |this| {\n             let scrutinee = unpack!(block = this.lower_scrutinee(block, init, initializer_span));\n             let pat = Pat { ty: init.ty, span: else_block_span, kind: PatKind::Wild };\n             let mut wildcard = Candidate::new(scrutinee.clone(), &pat, false);\n-            this.declare_bindings(\n-                visibility_scope,\n-                remainder_span,\n-                pattern,\n-                ArmHasGuard(false),\n-                Some((None, initializer_span)),\n-            );\n             let mut candidate = Candidate::new(scrutinee.clone(), pattern, false);\n             let fake_borrow_temps = this.lower_match_tree(\n                 block,\n@@ -2321,28 +2312,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 None,\n                 None,\n             );\n-            this.break_for_else(failure, remainder_scope, this.source_info(initializer_span));\n+            this.break_for_else(failure, *let_else_scope, this.source_info(initializer_span));\n             matching.unit()\n         });\n-\n-        // This place is not really used because this destination place\n-        // should never be used to take values at the end of the failure\n-        // block.\n-        let dummy_place = self.temp(self.tcx.types.never, else_block_span);\n-        let failure_block;\n-        unpack!(\n-            failure_block = self.ast_block(\n-                dummy_place,\n-                failure,\n-                else_block,\n-                self.source_info(else_block_span),\n-            )\n-        );\n-        self.cfg.terminate(\n-            failure_block,\n-            self.source_info(else_block_span),\n-            TerminatorKind::Unreachable,\n-        );\n-        matching.unit()\n+        matching.and(failure)\n     }\n }"}, {"sha": "b89db79bef8d9513646b955a3c57fa9001289cc2", "filename": "compiler/rustc_typeck/src/check/region.rs", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/35a0407814a6b5a04f0929105631e9c69e293e9d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a0407814a6b5a04f0929105631e9c69e293e9d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregion.rs?ref=35a0407814a6b5a04f0929105631e9c69e293e9d", "patch": "@@ -126,6 +126,29 @@ fn resolve_block<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, blk: &'tcx h\n \n         for (i, statement) in blk.stmts.iter().enumerate() {\n             match statement.kind {\n+                hir::StmtKind::Local(hir::Local { els: Some(els), .. }) => {\n+                    // Let-else has a special lexical structure for variables.\n+                    // First we take a checkpoint of the current scope context here.\n+                    let mut prev_cx = visitor.cx;\n+\n+                    visitor.enter_scope(Scope {\n+                        id: blk.hir_id.local_id,\n+                        data: ScopeData::Remainder(FirstStatementIndex::new(i)),\n+                    });\n+                    visitor.cx.var_parent = visitor.cx.parent;\n+                    visitor.visit_stmt(statement);\n+                    // We need to back out temporarily to the last enclosing scope\n+                    // for the `else` block, so that even the temporaries receiving\n+                    // extended lifetime will be dropped inside this block.\n+                    // We are visiting the `else` block in this order so that\n+                    // the sequence of visits agree with the order in the default\n+                    // `hir::intravisit` visitor.\n+                    mem::swap(&mut prev_cx, &mut visitor.cx);\n+                    visitor.terminating_scopes.insert(els.hir_id.local_id);\n+                    visitor.visit_block(els);\n+                    // From now on, we continue normally.\n+                    visitor.cx = prev_cx;\n+                }\n                 hir::StmtKind::Local(..) | hir::StmtKind::Item(..) => {\n                     // Each declaration introduces a subscope for bindings\n                     // introduced by the declaration; this subscope covers a\n@@ -138,10 +161,10 @@ fn resolve_block<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, blk: &'tcx h\n                         data: ScopeData::Remainder(FirstStatementIndex::new(i)),\n                     });\n                     visitor.cx.var_parent = visitor.cx.parent;\n+                    visitor.visit_stmt(statement)\n                 }\n-                hir::StmtKind::Expr(..) | hir::StmtKind::Semi(..) => {}\n+                hir::StmtKind::Expr(..) | hir::StmtKind::Semi(..) => visitor.visit_stmt(statement),\n             }\n-            visitor.visit_stmt(statement)\n         }\n         walk_list!(visitor, visit_expr, &blk.expr);\n     }\n@@ -460,7 +483,6 @@ fn resolve_local<'tcx>(\n     visitor: &mut RegionResolutionVisitor<'tcx>,\n     pat: Option<&'tcx hir::Pat<'tcx>>,\n     init: Option<&'tcx hir::Expr<'tcx>>,\n-    els: Option<&'tcx hir::Block<'tcx>>,\n ) {\n     debug!(\"resolve_local(pat={:?}, init={:?})\", pat, init);\n \n@@ -547,9 +569,6 @@ fn resolve_local<'tcx>(\n     if let Some(pat) = pat {\n         visitor.visit_pat(pat);\n     }\n-    if let Some(els) = els {\n-        visitor.visit_block(els);\n-    }\n \n     /// Returns `true` if `pat` match the `P&` non-terminal.\n     ///\n@@ -766,7 +785,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n             // (i.e., `'static`), which means that after `g` returns, it drops,\n             // and all the associated destruction scope rules apply.\n             self.cx.var_parent = None;\n-            resolve_local(self, None, Some(&body.value), None);\n+            resolve_local(self, None, Some(&body.value));\n         }\n \n         if body.generator_kind.is_some() {\n@@ -793,7 +812,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n         resolve_expr(self, ex);\n     }\n     fn visit_local(&mut self, l: &'tcx Local<'tcx>) {\n-        resolve_local(self, Some(&l.pat), l.init, l.els)\n+        resolve_local(self, Some(&l.pat), l.init)\n     }\n }\n "}, {"sha": "7f93563e28842119a6b983edbf1418a09b5955ec", "filename": "src/test/ui/async-await/async-await-let-else.no-drop-tracking.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35a0407814a6b5a04f0929105631e9c69e293e9d/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.no-drop-tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/35a0407814a6b5a04f0929105631e9c69e293e9d/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.no-drop-tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.no-drop-tracking.stderr?ref=35a0407814a6b5a04f0929105631e9c69e293e9d", "patch": "@@ -35,7 +35,7 @@ LL |         bar2(Rc::new(())).await\n    |              |\n    |              has type `Rc<()>` which is not `Send`\n LL |     };\n-   |      - `Rc::new(())` is later dropped here\n+   |     - `Rc::new(())` is later dropped here\n note: required by a bound in `is_send`\n   --> $DIR/async-await-let-else.rs:19:15\n    |"}, {"sha": "80f635561941271c7b59dc33418d21cd7e080dcc", "filename": "src/test/ui/let-else/issue-99975.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/35a0407814a6b5a04f0929105631e9c69e293e9d/src%2Ftest%2Fui%2Flet-else%2Fissue-99975.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a0407814a6b5a04f0929105631e9c69e293e9d/src%2Ftest%2Fui%2Flet-else%2Fissue-99975.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Fissue-99975.rs?ref=35a0407814a6b5a04f0929105631e9c69e293e9d", "patch": "@@ -0,0 +1,20 @@\n+// run-pass\n+// compile-flags: -C opt-level=3 -Zvalidate-mir\n+\n+#![feature(let_else)]\n+\n+fn return_result() -> Option<String> {\n+    Some(\"ok\".to_string())\n+}\n+\n+fn start() -> String {\n+    let Some(content) = return_result() else {\n+        return \"none\".to_string()\n+    };\n+\n+    content\n+}\n+\n+fn main() {\n+    start();\n+}"}, {"sha": "8542c3496b045f5eb8682fce59884274bdcf9560", "filename": "src/test/ui/let-else/let-else-temporary-lifetime.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35a0407814a6b5a04f0929105631e9c69e293e9d/src%2Ftest%2Fui%2Flet-else%2Flet-else-temporary-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a0407814a6b5a04f0929105631e9c69e293e9d/src%2Ftest%2Fui%2Flet-else%2Flet-else-temporary-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-temporary-lifetime.rs?ref=35a0407814a6b5a04f0929105631e9c69e293e9d", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+// compile-flags: -Zvalidate-mir\n #![feature(let_else)]\n \n use std::fmt::Display;"}]}