{"sha": "1c1f30bebfc3ffb8aabf85f688faa855ba36f3cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjMWYzMGJlYmZjM2ZmYjhhYWJmODVmNjg4ZmFhODU1YmEzNmYzY2I=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-15T09:49:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-15T09:49:30Z"}, "message": "Merge #9288\n\n9288: internal: cleanup tests r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "c46da0f7ded3abd3428763cd92cfa21e1bd2b24c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c46da0f7ded3abd3428763cd92cfa21e1bd2b24c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c1f30bebfc3ffb8aabf85f688faa855ba36f3cb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgyHeqCRBK7hj4Ov3rIwAAT9gIAFWDPoLomttgqSubmh5m1yiR\nr8tCuElUt4mC9hfmBm9x7nA/dCnqFhcZ1Do/oAJ2rGxTDXpsMLvLcy5jPLjqwv6I\n+EnEli7S04RB1t9l4pM7qQCrXLMlL/6zak8mZWzADmMO3WjSD7ILdppR71AgTWuj\nlfbt5GPQaiIfgfe2y9Q0NX2lH/nQXx9cQQatHXODL3RlQMOqYENiBsRyrjT8hqrh\nYJVYtRQHVZLPaG4RS0UdnX9Oq9h1/sel8ABNFO8+qQTLD5EpjM5ydWcUfVkDAiA0\nsX5dQSDLhyCIU5OGBhH6GzcC21CG4gyTVAa6xXcOjDLaDKZaxR7apC4jIwV3kGk=\n=Ks09\n-----END PGP SIGNATURE-----\n", "payload": "tree c46da0f7ded3abd3428763cd92cfa21e1bd2b24c\nparent 93750f5e704f00a7896edc2f39f6da26326a5a74\nparent 1e100e8b3e87fa3414760889c59e9511e3a43a43\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623750570 +0000\ncommitter GitHub <noreply@github.com> 1623750570 +0000\n\nMerge #9288\n\n9288: internal: cleanup tests r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c1f30bebfc3ffb8aabf85f688faa855ba36f3cb", "html_url": "https://github.com/rust-lang/rust/commit/1c1f30bebfc3ffb8aabf85f688faa855ba36f3cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c1f30bebfc3ffb8aabf85f688faa855ba36f3cb/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93750f5e704f00a7896edc2f39f6da26326a5a74", "url": "https://api.github.com/repos/rust-lang/rust/commits/93750f5e704f00a7896edc2f39f6da26326a5a74", "html_url": "https://github.com/rust-lang/rust/commit/93750f5e704f00a7896edc2f39f6da26326a5a74"}, {"sha": "1e100e8b3e87fa3414760889c59e9511e3a43a43", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e100e8b3e87fa3414760889c59e9511e3a43a43", "html_url": "https://github.com/rust-lang/rust/commit/1e100e8b3e87fa3414760889c59e9511e3a43a43"}], "stats": {"total": 1213, "additions": 600, "deletions": 613}, "files": [{"sha": "1d7be183a7508f8f688fa36fa7e0177cc78848bb", "filename": "crates/ide_assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 593, "deletions": 608, "changes": 1201, "blob_url": "https://github.com/rust-lang/rust/blob/1c1f30bebfc3ffb8aabf85f688faa855ba36f3cb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c1f30bebfc3ffb8aabf85f688faa855ba36f3cb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=1c1f30bebfc3ffb8aabf85f688faa855ba36f3cb", "patch": "@@ -216,190 +216,187 @@ mod tests {\n         cov_mark::check!(qualify_path_unqualified_name);\n         check_assist(\n             qualify_path,\n-            r\"\n-            mod std {\n-                pub mod fmt {\n-                    pub struct Formatter;\n-                }\n-            }\n+            r#\"\n+mod std {\n+    pub mod fmt {\n+        pub struct Formatter;\n+    }\n+}\n \n-            use std::fmt;\n+use std::fmt;\n \n-            $0Formatter\n-            \",\n-            r\"\n-            mod std {\n-                pub mod fmt {\n-                    pub struct Formatter;\n-                }\n-            }\n+$0Formatter\n+\"#,\n+            r#\"\n+mod std {\n+    pub mod fmt {\n+        pub struct Formatter;\n+    }\n+}\n \n-            use std::fmt;\n+use std::fmt;\n \n-            fmt::Formatter\n-            \",\n+fmt::Formatter\n+\"#,\n         );\n     }\n \n     #[test]\n     fn applicable_when_found_an_import() {\n         check_assist(\n             qualify_path,\n-            r\"\n-            $0PubStruct\n+            r#\"\n+$0PubStruct\n \n-            pub mod PubMod {\n-                pub struct PubStruct;\n-            }\n-            \",\n-            r\"\n-            PubMod::PubStruct\n+pub mod PubMod {\n+    pub struct PubStruct;\n+}\n+\"#,\n+            r#\"\n+PubMod::PubStruct\n \n-            pub mod PubMod {\n-                pub struct PubStruct;\n-            }\n-            \",\n+pub mod PubMod {\n+    pub struct PubStruct;\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn applicable_in_macros() {\n         check_assist(\n             qualify_path,\n-            r\"\n-            macro_rules! foo {\n-                ($i:ident) => { fn foo(a: $i) {} }\n-            }\n-            foo!(Pub$0Struct);\n+            r#\"\n+macro_rules! foo {\n+    ($i:ident) => { fn foo(a: $i) {} }\n+}\n+foo!(Pub$0Struct);\n \n-            pub mod PubMod {\n-                pub struct PubStruct;\n-            }\n-            \",\n-            r\"\n-            macro_rules! foo {\n-                ($i:ident) => { fn foo(a: $i) {} }\n-            }\n-            foo!(PubMod::PubStruct);\n+pub mod PubMod {\n+    pub struct PubStruct;\n+}\n+\"#,\n+            r#\"\n+macro_rules! foo {\n+    ($i:ident) => { fn foo(a: $i) {} }\n+}\n+foo!(PubMod::PubStruct);\n \n-            pub mod PubMod {\n-                pub struct PubStruct;\n-            }\n-            \",\n+pub mod PubMod {\n+    pub struct PubStruct;\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn applicable_when_found_multiple_imports() {\n         check_assist(\n             qualify_path,\n-            r\"\n-            PubSt$0ruct\n+            r#\"\n+PubSt$0ruct\n \n-            pub mod PubMod1 {\n-                pub struct PubStruct;\n-            }\n-            pub mod PubMod2 {\n-                pub struct PubStruct;\n-            }\n-            pub mod PubMod3 {\n-                pub struct PubStruct;\n-            }\n-            \",\n-            r\"\n-            PubMod3::PubStruct\n+pub mod PubMod1 {\n+    pub struct PubStruct;\n+}\n+pub mod PubMod2 {\n+    pub struct PubStruct;\n+}\n+pub mod PubMod3 {\n+    pub struct PubStruct;\n+}\n+\"#,\n+            r#\"\n+PubMod3::PubStruct\n \n-            pub mod PubMod1 {\n-                pub struct PubStruct;\n-            }\n-            pub mod PubMod2 {\n-                pub struct PubStruct;\n-            }\n-            pub mod PubMod3 {\n-                pub struct PubStruct;\n-            }\n-            \",\n+pub mod PubMod1 {\n+    pub struct PubStruct;\n+}\n+pub mod PubMod2 {\n+    pub struct PubStruct;\n+}\n+pub mod PubMod3 {\n+    pub struct PubStruct;\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn not_applicable_for_already_imported_types() {\n         check_assist_not_applicable(\n             qualify_path,\n-            r\"\n-            use PubMod::PubStruct;\n+            r#\"\n+use PubMod::PubStruct;\n \n-            PubStruct$0\n+PubStruct$0\n \n-            pub mod PubMod {\n-                pub struct PubStruct;\n-            }\n-            \",\n+pub mod PubMod {\n+    pub struct PubStruct;\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn not_applicable_for_types_with_private_paths() {\n         check_assist_not_applicable(\n             qualify_path,\n-            r\"\n-            PrivateStruct$0\n+            r#\"\n+PrivateStruct$0\n \n-            pub mod PubMod {\n-                struct PrivateStruct;\n-            }\n-            \",\n+pub mod PubMod {\n+    struct PrivateStruct;\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn not_applicable_when_no_imports_found() {\n-        check_assist_not_applicable(\n-            qualify_path,\n-            \"\n-            PubStruct$0\",\n-        );\n+        check_assist_not_applicable(qualify_path, r#\"PubStruct$0\"#);\n     }\n \n     #[test]\n     fn not_applicable_in_import_statements() {\n         check_assist_not_applicable(\n             qualify_path,\n-            r\"\n-            use PubStruct$0;\n+            r#\"\n+use PubStruct$0;\n \n-            pub mod PubMod {\n-                pub struct PubStruct;\n-            }\",\n+pub mod PubMod {\n+    pub struct PubStruct;\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn qualify_function() {\n         check_assist(\n             qualify_path,\n-            r\"\n-            test_function$0\n+            r#\"\n+test_function$0\n \n-            pub mod PubMod {\n-                pub fn test_function() {};\n-            }\n-            \",\n-            r\"\n-            PubMod::test_function\n+pub mod PubMod {\n+    pub fn test_function() {};\n+}\n+\"#,\n+            r#\"\n+PubMod::test_function\n \n-            pub mod PubMod {\n-                pub fn test_function() {};\n-            }\n-            \",\n+pub mod PubMod {\n+    pub fn test_function() {};\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn qualify_macro() {\n         check_assist(\n             qualify_path,\n-            r\"\n+            r#\"\n //- /lib.rs crate:crate_with_macro\n #[macro_export]\n macro_rules! foo {\n@@ -410,26 +407,26 @@ macro_rules! foo {\n fn main() {\n     foo$0\n }\n-\",\n-            r\"\n+\"#,\n+            r#\"\n fn main() {\n     crate_with_macro::foo\n }\n-\",\n+\"#,\n         );\n     }\n \n     #[test]\n     fn qualify_path_target() {\n         check_assist_target(\n             qualify_path,\n-            r\"\n-            struct AssistInfo {\n-                group_label: Option<$0GroupLabel>,\n-            }\n+            r#\"\n+struct AssistInfo {\n+    group_label: Option<$0GroupLabel>,\n+}\n \n-            mod m { pub struct GroupLabel; }\n-            \",\n+mod m { pub struct GroupLabel; }\n+\"#,\n             \"GroupLabel\",\n         )\n     }\n@@ -438,68 +435,68 @@ fn main() {\n     fn not_applicable_when_path_start_is_imported() {\n         check_assist_not_applicable(\n             qualify_path,\n-            r\"\n-            pub mod mod1 {\n-                pub mod mod2 {\n-                    pub mod mod3 {\n-                        pub struct TestStruct;\n-                    }\n-                }\n-            }\n+            r#\"\n+pub mod mod1 {\n+    pub mod mod2 {\n+        pub mod mod3 {\n+            pub struct TestStruct;\n+        }\n+    }\n+}\n \n-            use mod1::mod2;\n-            fn main() {\n-                mod2::mod3::TestStruct$0\n-            }\n-            \",\n+use mod1::mod2;\n+fn main() {\n+    mod2::mod3::TestStruct$0\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn not_applicable_for_imported_function() {\n         check_assist_not_applicable(\n             qualify_path,\n-            r\"\n-            pub mod test_mod {\n-                pub fn test_function() {}\n-            }\n+            r#\"\n+pub mod test_mod {\n+    pub fn test_function() {}\n+}\n \n-            use test_mod::test_function;\n-            fn main() {\n-                test_function$0\n-            }\n-            \",\n+use test_mod::test_function;\n+fn main() {\n+    test_function$0\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn associated_struct_function() {\n         check_assist(\n             qualify_path,\n-            r\"\n-            mod test_mod {\n-                pub struct TestStruct {}\n-                impl TestStruct {\n-                    pub fn test_function() {}\n-                }\n-            }\n+            r#\"\n+mod test_mod {\n+    pub struct TestStruct {}\n+    impl TestStruct {\n+        pub fn test_function() {}\n+    }\n+}\n \n-            fn main() {\n-                TestStruct::test_function$0\n-            }\n-            \",\n-            r\"\n-            mod test_mod {\n-                pub struct TestStruct {}\n-                impl TestStruct {\n-                    pub fn test_function() {}\n-                }\n-            }\n+fn main() {\n+    TestStruct::test_function$0\n+}\n+\"#,\n+            r#\"\n+mod test_mod {\n+    pub struct TestStruct {}\n+    impl TestStruct {\n+        pub fn test_function() {}\n+    }\n+}\n \n-            fn main() {\n-                test_mod::TestStruct::test_function\n-            }\n-            \",\n+fn main() {\n+    test_mod::TestStruct::test_function\n+}\n+\"#,\n         );\n     }\n \n@@ -508,131 +505,119 @@ fn main() {\n         cov_mark::check!(qualify_path_qualifier_start);\n         check_assist(\n             qualify_path,\n-            r\"\n-            mod test_mod {\n-                pub struct TestStruct {}\n-                impl TestStruct {\n-                    const TEST_CONST: u8 = 42;\n-                }\n-            }\n+            r#\"\n+mod test_mod {\n+    pub struct TestStruct {}\n+    impl TestStruct {\n+        const TEST_CONST: u8 = 42;\n+    }\n+}\n \n-            fn main() {\n-                TestStruct::TEST_CONST$0\n-            }\n-            \",\n-            r\"\n-            mod test_mod {\n-                pub struct TestStruct {}\n-                impl TestStruct {\n-                    const TEST_CONST: u8 = 42;\n-                }\n-            }\n+fn main() {\n+    TestStruct::TEST_CONST$0\n+}\n+\"#,\n+            r#\"\n+mod test_mod {\n+    pub struct TestStruct {}\n+    impl TestStruct {\n+        const TEST_CONST: u8 = 42;\n+    }\n+}\n \n-            fn main() {\n-                test_mod::TestStruct::TEST_CONST\n-            }\n-            \",\n+fn main() {\n+    test_mod::TestStruct::TEST_CONST\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    #[ignore = \"FIXME: non-trait assoc items completion is unsupported yet, see FIXME in the import_assets.rs for more details\"]\n     fn associated_struct_const_unqualified() {\n-        check_assist(\n+        // FIXME: non-trait assoc items completion is unsupported yet, see FIXME in the import_assets.rs for more details\n+        check_assist_not_applicable(\n             qualify_path,\n-            r\"\n-            mod test_mod {\n-                pub struct TestStruct {}\n-                impl TestStruct {\n-                    const TEST_CONST: u8 = 42;\n-                }\n-            }\n-\n-            fn main() {\n-                TEST_CONST$0\n-            }\n-            \",\n-            r\"\n-            mod test_mod {\n-                pub struct TestStruct {}\n-                impl TestStruct {\n-                    const TEST_CONST: u8 = 42;\n-                }\n-            }\n+            r#\"\n+mod test_mod {\n+    pub struct TestStruct {}\n+    impl TestStruct {\n+        const TEST_CONST: u8 = 42;\n+    }\n+}\n \n-            fn main() {\n-                test_mod::TestStruct::TEST_CONST\n-            }\n-            \",\n+fn main() {\n+    TEST_CONST$0\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn associated_trait_function() {\n         check_assist(\n             qualify_path,\n-            r\"\n-            mod test_mod {\n-                pub trait TestTrait {\n-                    fn test_function();\n-                }\n-                pub struct TestStruct {}\n-                impl TestTrait for TestStruct {\n-                    fn test_function() {}\n-                }\n-            }\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_function();\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_function() {}\n+    }\n+}\n \n-            fn main() {\n-                test_mod::TestStruct::test_function$0\n-            }\n-            \",\n-            r\"\n-            mod test_mod {\n-                pub trait TestTrait {\n-                    fn test_function();\n-                }\n-                pub struct TestStruct {}\n-                impl TestTrait for TestStruct {\n-                    fn test_function() {}\n-                }\n-            }\n+fn main() {\n+    test_mod::TestStruct::test_function$0\n+}\n+\"#,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_function();\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_function() {}\n+    }\n+}\n \n-            fn main() {\n-                <test_mod::TestStruct as test_mod::TestTrait>::test_function\n-            }\n-            \",\n+fn main() {\n+    <test_mod::TestStruct as test_mod::TestTrait>::test_function\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn not_applicable_for_imported_trait_for_function() {\n         check_assist_not_applicable(\n             qualify_path,\n-            r\"\n-            mod test_mod {\n-                pub trait TestTrait {\n-                    fn test_function();\n-                }\n-                pub trait TestTrait2 {\n-                    fn test_function();\n-                }\n-                pub enum TestEnum {\n-                    One,\n-                    Two,\n-                }\n-                impl TestTrait2 for TestEnum {\n-                    fn test_function() {}\n-                }\n-                impl TestTrait for TestEnum {\n-                    fn test_function() {}\n-                }\n-            }\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_function();\n+    }\n+    pub trait TestTrait2 {\n+        fn test_function();\n+    }\n+    pub enum TestEnum {\n+        One,\n+        Two,\n+    }\n+    impl TestTrait2 for TestEnum {\n+        fn test_function() {}\n+    }\n+    impl TestTrait for TestEnum {\n+        fn test_function() {}\n+    }\n+}\n \n-            use test_mod::TestTrait2;\n-            fn main() {\n-                test_mod::TestEnum::test_function$0;\n-            }\n-            \",\n+use test_mod::TestTrait2;\n+fn main() {\n+    test_mod::TestEnum::test_function$0;\n+}\n+\"#,\n         )\n     }\n \n@@ -641,68 +626,68 @@ fn main() {\n         cov_mark::check!(qualify_path_trait_assoc_item);\n         check_assist(\n             qualify_path,\n-            r\"\n-            mod test_mod {\n-                pub trait TestTrait {\n-                    const TEST_CONST: u8;\n-                }\n-                pub struct TestStruct {}\n-                impl TestTrait for TestStruct {\n-                    const TEST_CONST: u8 = 42;\n-                }\n-            }\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        const TEST_CONST: u8;\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        const TEST_CONST: u8 = 42;\n+    }\n+}\n \n-            fn main() {\n-                test_mod::TestStruct::TEST_CONST$0\n-            }\n-            \",\n-            r\"\n-            mod test_mod {\n-                pub trait TestTrait {\n-                    const TEST_CONST: u8;\n-                }\n-                pub struct TestStruct {}\n-                impl TestTrait for TestStruct {\n-                    const TEST_CONST: u8 = 42;\n-                }\n-            }\n+fn main() {\n+    test_mod::TestStruct::TEST_CONST$0\n+}\n+\"#,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        const TEST_CONST: u8;\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        const TEST_CONST: u8 = 42;\n+    }\n+}\n \n-            fn main() {\n-                <test_mod::TestStruct as test_mod::TestTrait>::TEST_CONST\n-            }\n-            \",\n+fn main() {\n+    <test_mod::TestStruct as test_mod::TestTrait>::TEST_CONST\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn not_applicable_for_imported_trait_for_const() {\n         check_assist_not_applicable(\n             qualify_path,\n-            r\"\n-            mod test_mod {\n-                pub trait TestTrait {\n-                    const TEST_CONST: u8;\n-                }\n-                pub trait TestTrait2 {\n-                    const TEST_CONST: f64;\n-                }\n-                pub enum TestEnum {\n-                    One,\n-                    Two,\n-                }\n-                impl TestTrait2 for TestEnum {\n-                    const TEST_CONST: f64 = 42.0;\n-                }\n-                impl TestTrait for TestEnum {\n-                    const TEST_CONST: u8 = 42;\n-                }\n-            }\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        const TEST_CONST: u8;\n+    }\n+    pub trait TestTrait2 {\n+        const TEST_CONST: f64;\n+    }\n+    pub enum TestEnum {\n+        One,\n+        Two,\n+    }\n+    impl TestTrait2 for TestEnum {\n+        const TEST_CONST: f64 = 42.0;\n+    }\n+    impl TestTrait for TestEnum {\n+        const TEST_CONST: u8 = 42;\n+    }\n+}\n \n-            use test_mod::TestTrait2;\n-            fn main() {\n-                test_mod::TestEnum::TEST_CONST$0;\n-            }\n-            \",\n+use test_mod::TestTrait2;\n+fn main() {\n+    test_mod::TestEnum::TEST_CONST$0;\n+}\n+\"#,\n         )\n     }\n \n@@ -711,283 +696,283 @@ fn main() {\n         cov_mark::check!(qualify_path_trait_method);\n         check_assist(\n             qualify_path,\n-            r\"\n-            mod test_mod {\n-                pub trait TestTrait {\n-                    fn test_method(&self);\n-                }\n-                pub struct TestStruct {}\n-                impl TestTrait for TestStruct {\n-                    fn test_method(&self) {}\n-                }\n-            }\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(&self) {}\n+    }\n+}\n \n-            fn main() {\n-                let test_struct = test_mod::TestStruct {};\n-                test_struct.test_meth$0od()\n-            }\n-            \",\n-            r\"\n-            mod test_mod {\n-                pub trait TestTrait {\n-                    fn test_method(&self);\n-                }\n-                pub struct TestStruct {}\n-                impl TestTrait for TestStruct {\n-                    fn test_method(&self) {}\n-                }\n-            }\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    test_struct.test_meth$0od()\n+}\n+\"#,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(&self) {}\n+    }\n+}\n \n-            fn main() {\n-                let test_struct = test_mod::TestStruct {};\n-                test_mod::TestTrait::test_method(&test_struct)\n-            }\n-            \",\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    test_mod::TestTrait::test_method(&test_struct)\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn trait_method_multi_params() {\n         check_assist(\n             qualify_path,\n-            r\"\n-            mod test_mod {\n-                pub trait TestTrait {\n-                    fn test_method(&self, test: i32);\n-                }\n-                pub struct TestStruct {}\n-                impl TestTrait for TestStruct {\n-                    fn test_method(&self, test: i32) {}\n-                }\n-            }\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(&self, test: i32);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(&self, test: i32) {}\n+    }\n+}\n \n-            fn main() {\n-                let test_struct = test_mod::TestStruct {};\n-                test_struct.test_meth$0od(42)\n-            }\n-            \",\n-            r\"\n-            mod test_mod {\n-                pub trait TestTrait {\n-                    fn test_method(&self, test: i32);\n-                }\n-                pub struct TestStruct {}\n-                impl TestTrait for TestStruct {\n-                    fn test_method(&self, test: i32) {}\n-                }\n-            }\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    test_struct.test_meth$0od(42)\n+}\n+\"#,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(&self, test: i32);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(&self, test: i32) {}\n+    }\n+}\n \n-            fn main() {\n-                let test_struct = test_mod::TestStruct {};\n-                test_mod::TestTrait::test_method(&test_struct, 42)\n-            }\n-            \",\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    test_mod::TestTrait::test_method(&test_struct, 42)\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn trait_method_consume() {\n         check_assist(\n             qualify_path,\n-            r\"\n-            mod test_mod {\n-                pub trait TestTrait {\n-                    fn test_method(self);\n-                }\n-                pub struct TestStruct {}\n-                impl TestTrait for TestStruct {\n-                    fn test_method(self) {}\n-                }\n-            }\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(self) {}\n+    }\n+}\n \n-            fn main() {\n-                let test_struct = test_mod::TestStruct {};\n-                test_struct.test_meth$0od()\n-            }\n-            \",\n-            r\"\n-            mod test_mod {\n-                pub trait TestTrait {\n-                    fn test_method(self);\n-                }\n-                pub struct TestStruct {}\n-                impl TestTrait for TestStruct {\n-                    fn test_method(self) {}\n-                }\n-            }\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    test_struct.test_meth$0od()\n+}\n+\"#,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(self) {}\n+    }\n+}\n \n-            fn main() {\n-                let test_struct = test_mod::TestStruct {};\n-                test_mod::TestTrait::test_method(test_struct)\n-            }\n-            \",\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    test_mod::TestTrait::test_method(test_struct)\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn trait_method_cross_crate() {\n         check_assist(\n             qualify_path,\n-            r\"\n-            //- /main.rs crate:main deps:dep\n-            fn main() {\n-                let test_struct = dep::test_mod::TestStruct {};\n-                test_struct.test_meth$0od()\n-            }\n-            //- /dep.rs crate:dep\n-            pub mod test_mod {\n-                pub trait TestTrait {\n-                    fn test_method(&self);\n-                }\n-                pub struct TestStruct {}\n-                impl TestTrait for TestStruct {\n-                    fn test_method(&self) {}\n-                }\n-            }\n-            \",\n-            r\"\n-            fn main() {\n-                let test_struct = dep::test_mod::TestStruct {};\n-                dep::test_mod::TestTrait::test_method(&test_struct)\n-            }\n-            \",\n+            r#\"\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    let test_struct = dep::test_mod::TestStruct {};\n+    test_struct.test_meth$0od()\n+}\n+//- /dep.rs crate:dep\n+pub mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(&self) {}\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let test_struct = dep::test_mod::TestStruct {};\n+    dep::test_mod::TestTrait::test_method(&test_struct)\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn assoc_fn_cross_crate() {\n         check_assist(\n             qualify_path,\n-            r\"\n-            //- /main.rs crate:main deps:dep\n-            fn main() {\n-                dep::test_mod::TestStruct::test_func$0tion\n-            }\n-            //- /dep.rs crate:dep\n-            pub mod test_mod {\n-                pub trait TestTrait {\n-                    fn test_function();\n-                }\n-                pub struct TestStruct {}\n-                impl TestTrait for TestStruct {\n-                    fn test_function() {}\n-                }\n-            }\n-            \",\n-            r\"\n-            fn main() {\n-                <dep::test_mod::TestStruct as dep::test_mod::TestTrait>::test_function\n-            }\n-            \",\n+            r#\"\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    dep::test_mod::TestStruct::test_func$0tion\n+}\n+//- /dep.rs crate:dep\n+pub mod test_mod {\n+    pub trait TestTrait {\n+        fn test_function();\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_function() {}\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    <dep::test_mod::TestStruct as dep::test_mod::TestTrait>::test_function\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn assoc_const_cross_crate() {\n         check_assist(\n             qualify_path,\n-            r\"\n-            //- /main.rs crate:main deps:dep\n-            fn main() {\n-                dep::test_mod::TestStruct::CONST$0\n-            }\n-            //- /dep.rs crate:dep\n-            pub mod test_mod {\n-                pub trait TestTrait {\n-                    const CONST: bool;\n-                }\n-                pub struct TestStruct {}\n-                impl TestTrait for TestStruct {\n-                    const CONST: bool = true;\n-                }\n-            }\n-            \",\n-            r\"\n-            fn main() {\n-                <dep::test_mod::TestStruct as dep::test_mod::TestTrait>::CONST\n-            }\n-            \",\n+            r#\"\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    dep::test_mod::TestStruct::CONST$0\n+}\n+//- /dep.rs crate:dep\n+pub mod test_mod {\n+    pub trait TestTrait {\n+        const CONST: bool;\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        const CONST: bool = true;\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    <dep::test_mod::TestStruct as dep::test_mod::TestTrait>::CONST\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn assoc_fn_as_method_cross_crate() {\n         check_assist_not_applicable(\n             qualify_path,\n-            r\"\n-            //- /main.rs crate:main deps:dep\n-            fn main() {\n-                let test_struct = dep::test_mod::TestStruct {};\n-                test_struct.test_func$0tion()\n-            }\n-            //- /dep.rs crate:dep\n-            pub mod test_mod {\n-                pub trait TestTrait {\n-                    fn test_function();\n-                }\n-                pub struct TestStruct {}\n-                impl TestTrait for TestStruct {\n-                    fn test_function() {}\n-                }\n-            }\n-            \",\n+            r#\"\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    let test_struct = dep::test_mod::TestStruct {};\n+    test_struct.test_func$0tion()\n+}\n+//- /dep.rs crate:dep\n+pub mod test_mod {\n+    pub trait TestTrait {\n+        fn test_function();\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_function() {}\n+    }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn private_trait_cross_crate() {\n         check_assist_not_applicable(\n             qualify_path,\n-            r\"\n-            //- /main.rs crate:main deps:dep\n-            fn main() {\n-                let test_struct = dep::test_mod::TestStruct {};\n-                test_struct.test_meth$0od()\n-            }\n-            //- /dep.rs crate:dep\n-            pub mod test_mod {\n-                trait TestTrait {\n-                    fn test_method(&self);\n-                }\n-                pub struct TestStruct {}\n-                impl TestTrait for TestStruct {\n-                    fn test_method(&self) {}\n-                }\n-            }\n-            \",\n+            r#\"\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    let test_struct = dep::test_mod::TestStruct {};\n+    test_struct.test_meth$0od()\n+}\n+//- /dep.rs crate:dep\n+pub mod test_mod {\n+    trait TestTrait {\n+        fn test_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(&self) {}\n+    }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn not_applicable_for_imported_trait_for_method() {\n         check_assist_not_applicable(\n             qualify_path,\n-            r\"\n-            mod test_mod {\n-                pub trait TestTrait {\n-                    fn test_method(&self);\n-                }\n-                pub trait TestTrait2 {\n-                    fn test_method(&self);\n-                }\n-                pub enum TestEnum {\n-                    One,\n-                    Two,\n-                }\n-                impl TestTrait2 for TestEnum {\n-                    fn test_method(&self) {}\n-                }\n-                impl TestTrait for TestEnum {\n-                    fn test_method(&self) {}\n-                }\n-            }\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(&self);\n+    }\n+    pub trait TestTrait2 {\n+        fn test_method(&self);\n+    }\n+    pub enum TestEnum {\n+        One,\n+        Two,\n+    }\n+    impl TestTrait2 for TestEnum {\n+        fn test_method(&self) {}\n+    }\n+    impl TestTrait for TestEnum {\n+        fn test_method(&self) {}\n+    }\n+}\n \n-            use test_mod::TestTrait2;\n-            fn main() {\n-                let one = test_mod::TestEnum::One;\n-                one.test$0_method();\n-            }\n-            \",\n+use test_mod::TestTrait2;\n+fn main() {\n+    let one = test_mod::TestEnum::One;\n+    one.test$0_method();\n+}\n+\"#,\n         )\n     }\n \n@@ -1114,15 +1099,15 @@ fn main() {}\n     fn keep_generic_annotations_leading_colon() {\n         check_assist(\n             qualify_path,\n-            r\"\n+            r#\"\n //- /lib.rs crate:dep\n pub mod generic { pub struct Thing<'a, T>(&'a T); }\n \n //- /main.rs crate:main deps:dep\n fn foo() -> Thin$0g::<'static, ()> {}\n \n fn main() {}\n-\",\n+\"#,\n             r\"\n fn foo() -> dep::generic::Thing::<'static, ()> {}\n \n@@ -1135,106 +1120,106 @@ fn main() {}\n     fn associated_struct_const_generic() {\n         check_assist(\n             qualify_path,\n-            r\"\n-            mod test_mod {\n-                pub struct TestStruct<T> {}\n-                impl<T> TestStruct<T> {\n-                    const TEST_CONST: u8 = 42;\n-                }\n-            }\n+            r#\"\n+mod test_mod {\n+    pub struct TestStruct<T> {}\n+    impl<T> TestStruct<T> {\n+        const TEST_CONST: u8 = 42;\n+    }\n+}\n \n-            fn main() {\n-                TestStruct::<()>::TEST_CONST$0\n-            }\n-            \",\n-            r\"\n-            mod test_mod {\n-                pub struct TestStruct<T> {}\n-                impl<T> TestStruct<T> {\n-                    const TEST_CONST: u8 = 42;\n-                }\n-            }\n+fn main() {\n+    TestStruct::<()>::TEST_CONST$0\n+}\n+\"#,\n+            r#\"\n+mod test_mod {\n+    pub struct TestStruct<T> {}\n+    impl<T> TestStruct<T> {\n+        const TEST_CONST: u8 = 42;\n+    }\n+}\n \n-            fn main() {\n-                test_mod::TestStruct::<()>::TEST_CONST\n-            }\n-            \",\n+fn main() {\n+    test_mod::TestStruct::<()>::TEST_CONST\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn associated_trait_const_generic() {\n         check_assist(\n             qualify_path,\n-            r\"\n-            mod test_mod {\n-                pub trait TestTrait {\n-                    const TEST_CONST: u8;\n-                }\n-                pub struct TestStruct<T> {}\n-                impl<T> TestTrait for TestStruct<T> {\n-                    const TEST_CONST: u8 = 42;\n-                }\n-            }\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        const TEST_CONST: u8;\n+    }\n+    pub struct TestStruct<T> {}\n+    impl<T> TestTrait for TestStruct<T> {\n+        const TEST_CONST: u8 = 42;\n+    }\n+}\n \n-            fn main() {\n-                test_mod::TestStruct::<()>::TEST_CONST$0\n-            }\n-            \",\n-            r\"\n-            mod test_mod {\n-                pub trait TestTrait {\n-                    const TEST_CONST: u8;\n-                }\n-                pub struct TestStruct<T> {}\n-                impl<T> TestTrait for TestStruct<T> {\n-                    const TEST_CONST: u8 = 42;\n-                }\n-            }\n+fn main() {\n+    test_mod::TestStruct::<()>::TEST_CONST$0\n+}\n+\"#,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        const TEST_CONST: u8;\n+    }\n+    pub struct TestStruct<T> {}\n+    impl<T> TestTrait for TestStruct<T> {\n+        const TEST_CONST: u8 = 42;\n+    }\n+}\n \n-            fn main() {\n-                <test_mod::TestStruct::<()> as test_mod::TestTrait>::TEST_CONST\n-            }\n-            \",\n+fn main() {\n+    <test_mod::TestStruct::<()> as test_mod::TestTrait>::TEST_CONST\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn trait_method_generic() {\n         check_assist(\n             qualify_path,\n-            r\"\n-            mod test_mod {\n-                pub trait TestTrait {\n-                    fn test_method<T>(&self);\n-                }\n-                pub struct TestStruct {}\n-                impl TestTrait for TestStruct {\n-                    fn test_method<T>(&self) {}\n-                }\n-            }\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method<T>(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method<T>(&self) {}\n+    }\n+}\n \n-            fn main() {\n-                let test_struct = test_mod::TestStruct {};\n-                test_struct.test_meth$0od::<()>()\n-            }\n-            \",\n-            r\"\n-            mod test_mod {\n-                pub trait TestTrait {\n-                    fn test_method<T>(&self);\n-                }\n-                pub struct TestStruct {}\n-                impl TestTrait for TestStruct {\n-                    fn test_method<T>(&self) {}\n-                }\n-            }\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    test_struct.test_meth$0od::<()>()\n+}\n+\"#,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method<T>(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method<T>(&self) {}\n+    }\n+}\n \n-            fn main() {\n-                let test_struct = test_mod::TestStruct {};\n-                test_mod::TestTrait::test_method::<()>(&test_struct)\n-            }\n-            \",\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    test_mod::TestTrait::test_method::<()>(&test_struct)\n+}\n+\"#,\n         );\n     }\n }"}, {"sha": "a2af2035fc3ef4806c87130f01efaa3e00a98d2b", "filename": "crates/ide_assists/src/handlers/replace_impl_trait_with_generic.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c1f30bebfc3ffb8aabf85f688faa855ba36f3cb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_impl_trait_with_generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c1f30bebfc3ffb8aabf85f688faa855ba36f3cb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_impl_trait_with_generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_impl_trait_with_generic.rs?ref=1c1f30bebfc3ffb8aabf85f688faa855ba36f3cb", "patch": "@@ -105,12 +105,13 @@ fn foo<B: Bar\n     }\n \n     #[test]\n-    #[ignore = \"This case is very rare but there is no simple solutions to fix it.\"]\n     fn replace_impl_trait_with_exist_generic_letter() {\n+        // FIXME: This is wrong, we should pick a different name if the one we\n+        // want is already bound.\n         check_assist(\n             replace_impl_trait_with_generic,\n             r#\"fn foo<B>(bar: $0impl Bar) {}\"#,\n-            r#\"fn foo<B, C: Bar>(bar: C) {}\"#,\n+            r#\"fn foo<B, B: Bar>(bar: B) {}\"#,\n         );\n     }\n "}, {"sha": "5a88ec7429f09c9f59d804247715992f8b6e3906", "filename": "crates/ide_db/src/helpers/insert_use/tests.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1c1f30bebfc3ffb8aabf85f688faa855ba36f3cb/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c1f30bebfc3ffb8aabf85f688faa855ba36f3cb/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use%2Ftests.rs?ref=1c1f30bebfc3ffb8aabf85f688faa855ba36f3cb", "patch": "@@ -511,13 +511,14 @@ use std::io;\n }\n \n #[test]\n-#[ignore] // FIXME: Support this\n fn split_out_merge() {\n+    // FIXME: This is suboptimal, we want to get `use std::fmt::{self, Result}`\n+    // instead.\n     check_module(\n         \"std::fmt::Result\",\n         r\"use std::{fmt, io};\",\n-        r\"use std::fmt::{self, Result};\n-use std::io;\",\n+        r\"use std::fmt::Result;\n+use std::{fmt, io};\",\n     )\n }\n "}]}