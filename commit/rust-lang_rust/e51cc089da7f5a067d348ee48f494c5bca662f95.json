{"sha": "e51cc089da7f5a067d348ee48f494c5bca662f95", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1MWNjMDg5ZGE3ZjVhMDY3ZDM0OGVlNDhmNDk0YzViY2E2NjJmOTU=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-11-09T13:11:28Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-11-12T15:02:44Z"}, "message": "Move checked arithmetic operators into Int trait", "tree": {"sha": "999f0ab2a748880de52b1d5d18b51b9151ceaeab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/999f0ab2a748880de52b1d5d18b51b9151ceaeab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e51cc089da7f5a067d348ee48f494c5bca662f95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e51cc089da7f5a067d348ee48f494c5bca662f95", "html_url": "https://github.com/rust-lang/rust/commit/e51cc089da7f5a067d348ee48f494c5bca662f95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e51cc089da7f5a067d348ee48f494c5bca662f95/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e57cd843ccf303d1387ced8d331cb1c19cdaf1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e57cd843ccf303d1387ced8d331cb1c19cdaf1c", "html_url": "https://github.com/rust-lang/rust/commit/7e57cd843ccf303d1387ced8d331cb1c19cdaf1c"}], "stats": {"total": 695, "additions": 324, "deletions": 371}, "files": [{"sha": "7033f493f0f8fce0df924d87203de4aaa7f4c35b", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=e51cc089da7f5a067d348ee48f494c5bca662f95", "patch": "@@ -97,7 +97,7 @@ syn keyword rustTrait FromIterator IntoIterator Extend ExactSize\n syn keyword rustTrait Iterator DoubleEndedIterator\n syn keyword rustTrait RandomAccessIterator CloneableIterator\n syn keyword rustTrait OrdIterator MutableDoubleEndedIterator\n-syn keyword rustTrait Num NumCast CheckedAdd CheckedSub CheckedMul CheckedDiv\n+syn keyword rustTrait Num NumCast\n syn keyword rustTrait Signed Unsigned Primitive Int Float\n syn keyword rustTrait FloatMath ToPrimitive FromPrimitive\n syn keyword rustTrait Box"}, {"sha": "1e9ab34b0aca4e80813a1f02c63fc1d5c6909303", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=e51cc089da7f5a067d348ee48f494c5bca662f95", "patch": "@@ -132,7 +132,7 @@ impl Drop for Arena {\n \n #[inline]\n fn round_up(base: uint, align: uint) -> uint {\n-    (base.checked_add(&(align - 1))).unwrap() & !(align - 1)\n+    (base.checked_add(align - 1)).unwrap() & !(align - 1)\n }\n \n // Walk down a chunk, running the destructors for any objects stored\n@@ -376,8 +376,8 @@ fn calculate_size<T>(capacity: uint) -> uint {\n     let mut size = mem::size_of::<TypedArenaChunk<T>>();\n     size = round_up(size, mem::min_align_of::<T>());\n     let elem_size = mem::size_of::<T>();\n-    let elems_size = elem_size.checked_mul(&capacity).unwrap();\n-    size = size.checked_add(&elems_size).unwrap();\n+    let elems_size = elem_size.checked_mul(capacity).unwrap();\n+    size = size.checked_add(elems_size).unwrap();\n     size\n }\n \n@@ -432,7 +432,7 @@ impl<T> TypedArenaChunk<T> {\n     #[inline]\n     fn end(&self) -> *const u8 {\n         unsafe {\n-            let size = mem::size_of::<T>().checked_mul(&self.capacity).unwrap();\n+            let size = mem::size_of::<T>().checked_mul(self.capacity).unwrap();\n             self.start().offset(size as int)\n         }\n     }\n@@ -481,7 +481,7 @@ impl<T> TypedArena<T> {\n     fn grow(&self) {\n         unsafe {\n             let chunk = *self.first.borrow_mut();\n-            let new_capacity = (*chunk).capacity.checked_mul(&2).unwrap();\n+            let new_capacity = (*chunk).capacity.checked_mul(2).unwrap();\n             let chunk = TypedArenaChunk::<T>::new(chunk, new_capacity);\n             self.ptr.set((*chunk).start() as *const T);\n             self.end.set((*chunk).end() as *const T);"}, {"sha": "9f51c6d1b5ea2372bb4ca62c1e7d7b2b1cf0408d", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=e51cc089da7f5a067d348ee48f494c5bca662f95", "patch": "@@ -161,7 +161,7 @@ impl<T> Vec<T> {\n         } else if capacity == 0 {\n             Vec::new()\n         } else {\n-            let size = capacity.checked_mul(&mem::size_of::<T>())\n+            let size = capacity.checked_mul(mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n             let ptr = unsafe { allocate(size, mem::min_align_of::<T>()) };\n             Vec { ptr: ptr as *mut T, len: 0, cap: capacity }\n@@ -601,7 +601,7 @@ impl<T> Vec<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn reserve(&mut self, additional: uint) {\n         if self.cap - self.len < additional {\n-            match self.len.checked_add(&additional) {\n+            match self.len.checked_add(additional) {\n                 None => panic!(\"Vec::reserve: `uint` overflow\"),\n                 // if the checked_add\n                 Some(new_cap) => {\n@@ -638,7 +638,7 @@ impl<T> Vec<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         if self.cap - self.len < additional {\n-            match self.len.checked_add(&additional) {\n+            match self.len.checked_add(additional) {\n                 None => panic!(\"Vec::reserve: `uint` overflow\"),\n                 Some(new_cap) => self.grow_capacity(new_cap)\n             }\n@@ -971,7 +971,7 @@ impl<T> Vec<T> {\n     pub fn push(&mut self, value: T) {\n         if mem::size_of::<T>() == 0 {\n             // zero-size types consume no memory, so we can't rely on the address space running out\n-            self.len = self.len.checked_add(&1).expect(\"length overflow\");\n+            self.len = self.len.checked_add(1).expect(\"length overflow\");\n             unsafe { mem::forget(value); }\n             return\n         }\n@@ -1064,7 +1064,7 @@ impl<T> Vec<T> {\n         if mem::size_of::<T>() == 0 { return }\n \n         if capacity > self.cap {\n-            let size = capacity.checked_mul(&mem::size_of::<T>())\n+            let size = capacity.checked_mul(mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n             unsafe {\n                 self.ptr = alloc_or_realloc(self.ptr, self.cap * mem::size_of::<T>(), size);"}, {"sha": "0effc4b19dc5dd53159eb7b9cb9d8a521822f7a5", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=e51cc089da7f5a067d348ee48f494c5bca662f95", "patch": "@@ -60,9 +60,9 @@ This `for` loop syntax can be applied to any iterator over any type.\n \n use clone::Clone;\n use cmp;\n-use cmp::{PartialEq, PartialOrd, Ord};\n+use cmp::{PartialOrd, Ord};\n use mem;\n-use num::{Zero, One, CheckedAdd, CheckedSub, ToPrimitive, Int};\n+use num::{Zero, One, ToPrimitive, Int};\n use ops::{Add, Mul, Sub};\n use option::{Option, Some, None};\n use uint;\n@@ -1093,7 +1093,7 @@ impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for Chain<T, U> {\n         let lower = a_lower.saturating_add(b_lower);\n \n         let upper = match (a_upper, b_upper) {\n-            (Some(x), Some(y)) => x.checked_add(&y),\n+            (Some(x), Some(y)) => x.checked_add(y),\n             _ => None\n         };\n \n@@ -1415,7 +1415,7 @@ impl<A, T: Iterator<A>> Iterator<A> for Peekable<A, T> {\n         if self.peeked.is_some() {\n             let lo = lo.saturating_add(1);\n             let hi = match hi {\n-                Some(x) => x.checked_add(&1),\n+                Some(x) => x.checked_add(1),\n                 None => None\n             };\n             (lo, hi)\n@@ -1680,7 +1680,7 @@ impl<'a, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for FlatMap<'a, A, T,\n         let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n         let lo = flo.saturating_add(blo);\n         match (self.iter.size_hint(), fhi, bhi) {\n-            ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(&b)),\n+            ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(b)),\n             _ => (lo, None)\n         }\n     }\n@@ -1946,15 +1946,15 @@ impl<A: Add<A, A> + PartialOrd + Clone + ToPrimitive> Iterator<A> for Range<A> {\n         // the i64/u64 might lie within their range.\n         let bound = match self.state.to_i64() {\n             Some(a) => {\n-                let sz = self.stop.to_i64().map(|b| b.checked_sub(&a));\n+                let sz = self.stop.to_i64().map(|b| b.checked_sub(a));\n                 match sz {\n                     Some(Some(bound)) => bound.to_uint(),\n                     _ => None,\n                 }\n             },\n             None => match self.state.to_u64() {\n                 Some(a) => {\n-                    let sz = self.stop.to_u64().map(|b| b.checked_sub(&a));\n+                    let sz = self.stop.to_u64().map(|b| b.checked_sub(a));\n                     match sz {\n                         Some(Some(bound)) => bound.to_uint(),\n                         _ => None\n@@ -2024,7 +2024,7 @@ impl<A: Add<A, A> + PartialOrd + Clone + ToPrimitive> Iterator<A> for RangeInclu\n         } else {\n             let lo = lo.saturating_add(1);\n             let hi = match hi {\n-                Some(x) => x.checked_add(&1),\n+                Some(x) => x.checked_add(1),\n                 None => None\n             };\n             (lo, hi)\n@@ -2060,18 +2060,17 @@ pub struct RangeStep<A> {\n \n /// Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n #[inline]\n-pub fn range_step<A: CheckedAdd + PartialOrd +\n-                  Clone + Zero>(start: A, stop: A, step: A) -> RangeStep<A> {\n+pub fn range_step<A: Int>(start: A, stop: A, step: A) -> RangeStep<A> {\n     let rev = step < Zero::zero();\n     RangeStep{state: start, stop: stop, step: step, rev: rev}\n }\n \n-impl<A: CheckedAdd + PartialOrd + Clone> Iterator<A> for RangeStep<A> {\n+impl<A: Int> Iterator<A> for RangeStep<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if (self.rev && self.state > self.stop) || (!self.rev && self.state < self.stop) {\n-            let result = self.state.clone();\n-            match self.state.checked_add(&self.step) {\n+            let result = self.state;\n+            match self.state.checked_add(self.step) {\n                 Some(x) => self.state = x,\n                 None => self.state = self.stop.clone()\n             }\n@@ -2094,19 +2093,18 @@ pub struct RangeStepInclusive<A> {\n \n /// Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n #[inline]\n-pub fn range_step_inclusive<A: CheckedAdd + PartialOrd + Clone + Zero>(start: A, stop: A,\n-                                                                step: A) -> RangeStepInclusive<A> {\n+pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepInclusive<A> {\n     let rev = step < Zero::zero();\n     RangeStepInclusive{state: start, stop: stop, step: step, rev: rev, done: false}\n }\n \n-impl<A: CheckedAdd + PartialOrd + Clone + PartialEq> Iterator<A> for RangeStepInclusive<A> {\n+impl<A: Int> Iterator<A> for RangeStepInclusive<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if !self.done && ((self.rev && self.state >= self.stop) ||\n                           (!self.rev && self.state <= self.stop)) {\n-            let result = self.state.clone();\n-            match self.state.checked_add(&self.step) {\n+            let result = self.state;\n+            match self.state.checked_add(self.step) {\n                 Some(x) => self.state = x,\n                 None => self.done = true\n             }"}, {"sha": "b26e8dd83fe40c8c29b14cefc43042b6313162ec", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 191, "deletions": 220, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=e51cc089da7f5a067d348ee48f494c5bca662f95", "patch": "@@ -348,10 +348,6 @@ trait_impl!(Primitive for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n /// operators, bit counting methods, and endian conversion functions.\n pub trait Int: Primitive\n              + Ord\n-             + CheckedAdd\n-             + CheckedSub\n-             + CheckedMul\n-             + CheckedDiv\n              + Bounded\n              + Not<Self>\n              + BitAnd<Self,Self>\n@@ -526,11 +522,65 @@ pub trait Int: Primitive\n         if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n     }\n \n+    /// Adds two numbers, checking for overflow. If overflow occurs, `None` is\n+    /// returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::Int;\n+    ///\n+    /// assert_eq!(5u16.checked_add(65530), Some(65535));\n+    /// assert_eq!(6u16.checked_add(65530), None);\n+    /// ```\n+    fn checked_add(self, other: Self) -> Option<Self>;\n+\n+    /// Subtracts two numbers, checking for underflow. If underflow occurs,\n+    /// `None` is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::Int;\n+    ///\n+    /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n+    /// assert_eq!((-128i8).checked_sub(1), None);\n+    /// ```\n+    fn checked_sub(self, other: Self) -> Option<Self>;\n+\n+    /// Multiplies two numbers, checking for underflow or overflow. If underflow\n+    /// or overflow occurs, `None` is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::Int;\n+    ///\n+    /// assert_eq!(5u8.checked_mul(51), Some(255));\n+    /// assert_eq!(5u8.checked_mul(52), None);\n+    /// ```\n+    fn checked_mul(self, other: Self) -> Option<Self>;\n+\n+    /// Divides two numbers, checking for underflow, overflow and division by\n+    /// zero. If underflow occurs, `None` is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::Int;\n+    ///\n+    /// assert_eq!((-127i8).checked_div(-1), Some(127));\n+    /// assert_eq!((-128i8).checked_div(-1), None);\n+    /// assert_eq!((1i8).checked_div(0), None);\n+    /// ```\n+    #[inline]\n+    fn checked_div(self, other: Self) -> Option<Self>;\n+\n     /// Saturating addition. Returns `self + other`, saturating at the\n     /// numeric bounds instead of overflowing.\n     #[inline]\n     fn saturating_add(self, other: Self) -> Self {\n-        match self.checked_add(&other) {\n+        match self.checked_add(other) {\n             Some(x)                       => x,\n             None if other >= Zero::zero() => Bounded::max_value(),\n             None                          => Bounded::min_value(),\n@@ -541,17 +591,30 @@ pub trait Int: Primitive\n     /// numeric bounds instead of overflowing.\n     #[inline]\n     fn saturating_sub(self, other: Self) -> Self {\n-        match self.checked_sub(&other) {\n+        match self.checked_sub(other) {\n             Some(x)                       => x,\n             None if other >= Zero::zero() => Bounded::min_value(),\n             None                          => Bounded::max_value(),\n         }\n     }\n }\n \n+macro_rules! checked_op {\n+    ($T:ty, $U:ty, $op:path, $x:expr, $y:expr) => {{\n+        let (result, overflowed) = unsafe { $op($x as $U, $y as $U) };\n+        if overflowed { None } else { Some(result as $T) }\n+    }}\n+}\n+\n macro_rules! uint_impl {\n-    ($T:ty, $ActualT:ty, $BITS:expr,\n-     $ctpop:path, $ctlz:path, $cttz:path, $bswap:path) => {\n+    ($T:ty = $ActualT:ty, $BITS:expr,\n+     $ctpop:path,\n+     $ctlz:path,\n+     $cttz:path,\n+     $bswap:path,\n+     $add_with_overflow:path,\n+     $sub_with_overflow:path,\n+     $mul_with_overflow:path) => {\n         impl Int for $T {\n             #[inline]\n             fn count_ones(self) -> uint { unsafe { $ctpop(self as $ActualT) as uint } }\n@@ -578,6 +641,29 @@ macro_rules! uint_impl {\n \n             #[inline]\n             fn swap_bytes(self) -> $T { unsafe { $bswap(self as $ActualT) as $T } }\n+\n+            #[inline]\n+            fn checked_add(self, other: $T) -> Option<$T> {\n+                checked_op!($T, $ActualT, $add_with_overflow, self, other)\n+            }\n+\n+            #[inline]\n+            fn checked_sub(self, other: $T) -> Option<$T> {\n+                checked_op!($T, $ActualT, $sub_with_overflow, self, other)\n+            }\n+\n+            #[inline]\n+            fn checked_mul(self, other: $T) -> Option<$T> {\n+                checked_op!($T, $ActualT, $mul_with_overflow, self, other)\n+            }\n+\n+            #[inline]\n+            fn checked_div(self, v: $T) -> Option<$T> {\n+                match v {\n+                    0 => None,\n+                    v => Some(self / v),\n+                }\n+            }\n         }\n     }\n }\n@@ -586,74 +672,145 @@ macro_rules! uint_impl {\n /// consistency with the other `bswap` intrinsics.\n unsafe fn bswap8(x: u8) -> u8 { x }\n \n-uint_impl!(u8, u8, 8,\n+uint_impl!(u8 = u8, 8,\n     intrinsics::ctpop8,\n     intrinsics::ctlz8,\n     intrinsics::cttz8,\n-    bswap8)\n+    bswap8,\n+    intrinsics::u8_add_with_overflow,\n+    intrinsics::u8_sub_with_overflow,\n+    intrinsics::u8_mul_with_overflow)\n \n-uint_impl!(u16, u16, 16,\n+uint_impl!(u16 = u16, 16,\n     intrinsics::ctpop16,\n     intrinsics::ctlz16,\n     intrinsics::cttz16,\n-    intrinsics::bswap16)\n+    intrinsics::bswap16,\n+    intrinsics::u16_add_with_overflow,\n+    intrinsics::u16_sub_with_overflow,\n+    intrinsics::u16_mul_with_overflow)\n \n-uint_impl!(u32, u32, 32,\n+uint_impl!(u32 = u32, 32,\n     intrinsics::ctpop32,\n     intrinsics::ctlz32,\n     intrinsics::cttz32,\n-    intrinsics::bswap32)\n+    intrinsics::bswap32,\n+    intrinsics::u32_add_with_overflow,\n+    intrinsics::u32_sub_with_overflow,\n+    intrinsics::u32_mul_with_overflow)\n \n-uint_impl!(u64, u64, 64,\n+uint_impl!(u64 = u64, 64,\n     intrinsics::ctpop64,\n     intrinsics::ctlz64,\n     intrinsics::cttz64,\n-    intrinsics::bswap64)\n+    intrinsics::bswap64,\n+    intrinsics::u64_add_with_overflow,\n+    intrinsics::u64_sub_with_overflow,\n+    intrinsics::u64_mul_with_overflow)\n \n #[cfg(target_word_size = \"32\")]\n-uint_impl!(uint, u32, 32,\n+uint_impl!(uint = u32, 32,\n     intrinsics::ctpop32,\n     intrinsics::ctlz32,\n     intrinsics::cttz32,\n-    intrinsics::bswap32)\n+    intrinsics::bswap32,\n+    intrinsics::u32_add_with_overflow,\n+    intrinsics::u32_sub_with_overflow,\n+    intrinsics::u32_mul_with_overflow)\n \n #[cfg(target_word_size = \"64\")]\n-uint_impl!(uint, u64, 64,\n+uint_impl!(uint = u64, 64,\n     intrinsics::ctpop64,\n     intrinsics::ctlz64,\n     intrinsics::cttz64,\n-    intrinsics::bswap64)\n+    intrinsics::bswap64,\n+    intrinsics::u64_add_with_overflow,\n+    intrinsics::u64_sub_with_overflow,\n+    intrinsics::u64_mul_with_overflow)\n \n macro_rules! int_impl {\n-    ($T:ty, $U:ty) => {\n+    ($T:ty = $ActualT:ty, $UnsignedT:ty,\n+     $add_with_overflow:path,\n+     $sub_with_overflow:path,\n+     $mul_with_overflow:path) => {\n         impl Int for $T {\n             #[inline]\n-            fn count_ones(self) -> uint { (self as $U).count_ones() }\n+            fn count_ones(self) -> uint { (self as $UnsignedT).count_ones() }\n \n             #[inline]\n-            fn leading_zeros(self) -> uint { (self as $U).leading_zeros() }\n+            fn leading_zeros(self) -> uint { (self as $UnsignedT).leading_zeros() }\n \n             #[inline]\n-            fn trailing_zeros(self) -> uint { (self as $U).trailing_zeros() }\n+            fn trailing_zeros(self) -> uint { (self as $UnsignedT).trailing_zeros() }\n \n             #[inline]\n-            fn rotate_left(self, n: uint) -> $T { (self as $U).rotate_left(n) as $T }\n+            fn rotate_left(self, n: uint) -> $T { (self as $UnsignedT).rotate_left(n) as $T }\n \n             #[inline]\n-            fn rotate_right(self, n: uint) -> $T { (self as $U).rotate_right(n) as $T }\n+            fn rotate_right(self, n: uint) -> $T { (self as $UnsignedT).rotate_right(n) as $T }\n \n             #[inline]\n-            fn swap_bytes(self) -> $T { (self as $U).swap_bytes() as $T }\n+            fn swap_bytes(self) -> $T { (self as $UnsignedT).swap_bytes() as $T }\n+\n+            #[inline]\n+            fn checked_add(self, other: $T) -> Option<$T> {\n+                checked_op!($T, $ActualT, $add_with_overflow, self, other)\n+            }\n+\n+            #[inline]\n+            fn checked_sub(self, other: $T) -> Option<$T> {\n+                checked_op!($T, $ActualT, $sub_with_overflow, self, other)\n+            }\n+\n+            #[inline]\n+            fn checked_mul(self, other: $T) -> Option<$T> {\n+                checked_op!($T, $ActualT, $mul_with_overflow, self, other)\n+            }\n+\n+            #[inline]\n+            fn checked_div(self, v: $T) -> Option<$T> {\n+                match v {\n+                    0   => None,\n+                   -1 if self == Bounded::min_value()\n+                        => None,\n+                    v   => Some(self / v),\n+                }\n+            }\n         }\n     }\n }\n \n-int_impl!(i8, u8)\n-int_impl!(i16, u16)\n-int_impl!(i32, u32)\n-int_impl!(i64, u64)\n-#[cfg(target_word_size = \"32\")] int_impl!(int, u32)\n-#[cfg(target_word_size = \"64\")] int_impl!(int, u64)\n+int_impl!(i8 = i8, u8,\n+    intrinsics::i8_add_with_overflow,\n+    intrinsics::i8_sub_with_overflow,\n+    intrinsics::i8_mul_with_overflow)\n+\n+int_impl!(i16 = i16, u16,\n+    intrinsics::i16_add_with_overflow,\n+    intrinsics::i16_sub_with_overflow,\n+    intrinsics::i16_mul_with_overflow)\n+\n+int_impl!(i32 = i32, u32,\n+    intrinsics::i32_add_with_overflow,\n+    intrinsics::i32_sub_with_overflow,\n+    intrinsics::i32_mul_with_overflow)\n+\n+int_impl!(i64 = i64, u64,\n+    intrinsics::i64_add_with_overflow,\n+    intrinsics::i64_sub_with_overflow,\n+    intrinsics::i64_mul_with_overflow)\n+\n+#[cfg(target_word_size = \"32\")]\n+int_impl!(int = i32, u32,\n+    intrinsics::i32_add_with_overflow,\n+    intrinsics::i32_sub_with_overflow,\n+    intrinsics::i32_mul_with_overflow)\n+\n+#[cfg(target_word_size = \"64\")]\n+int_impl!(int = i64, u64,\n+    intrinsics::i64_add_with_overflow,\n+    intrinsics::i64_sub_with_overflow,\n+    intrinsics::i64_mul_with_overflow)\n \n /// Unsigned integers\n pub trait UnsignedInt: Int {\n@@ -686,7 +843,7 @@ pub trait UnsignedInt: Int {\n             tmp = tmp | (tmp >> shift);\n             shift = shift << 1u;\n         }\n-        tmp.checked_add(&one())\n+        tmp.checked_add(one())\n     }\n }\n \n@@ -1184,192 +1341,6 @@ impl_num_cast!(int,   to_int)\n impl_num_cast!(f32,   to_f32)\n impl_num_cast!(f64,   to_f64)\n \n-/// Performs addition that returns `None` instead of wrapping around on overflow.\n-pub trait CheckedAdd: Add<Self, Self> {\n-    /// Adds two numbers, checking for overflow. If overflow happens, `None` is returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::num::CheckedAdd;\n-    /// assert_eq!(5u16.checked_add(&65530), Some(65535));\n-    /// assert_eq!(6u16.checked_add(&65530), None);\n-    /// ```\n-    fn checked_add(&self, v: &Self) -> Option<Self>;\n-}\n-\n-macro_rules! checked_impl(\n-    ($trait_name:ident, $method:ident, $t:ty, $op:path) => {\n-        impl $trait_name for $t {\n-            #[inline]\n-            fn $method(&self, v: &$t) -> Option<$t> {\n-                unsafe {\n-                    let (x, y) = $op(*self, *v);\n-                    if y { None } else { Some(x) }\n-                }\n-            }\n-        }\n-    }\n-)\n-macro_rules! checked_cast_impl(\n-    ($trait_name:ident, $method:ident, $t:ty, $cast:ty, $op:path) => {\n-        impl $trait_name for $t {\n-            #[inline]\n-            fn $method(&self, v: &$t) -> Option<$t> {\n-                unsafe {\n-                    let (x, y) = $op(*self as $cast, *v as $cast);\n-                    if y { None } else { Some(x as $t) }\n-                }\n-            }\n-        }\n-    }\n-)\n-\n-#[cfg(target_word_size = \"32\")]\n-checked_cast_impl!(CheckedAdd, checked_add, uint, u32, intrinsics::u32_add_with_overflow)\n-#[cfg(target_word_size = \"64\")]\n-checked_cast_impl!(CheckedAdd, checked_add, uint, u64, intrinsics::u64_add_with_overflow)\n-\n-checked_impl!(CheckedAdd, checked_add, u8,  intrinsics::u8_add_with_overflow)\n-checked_impl!(CheckedAdd, checked_add, u16, intrinsics::u16_add_with_overflow)\n-checked_impl!(CheckedAdd, checked_add, u32, intrinsics::u32_add_with_overflow)\n-checked_impl!(CheckedAdd, checked_add, u64, intrinsics::u64_add_with_overflow)\n-\n-#[cfg(target_word_size = \"32\")]\n-checked_cast_impl!(CheckedAdd, checked_add, int, i32, intrinsics::i32_add_with_overflow)\n-#[cfg(target_word_size = \"64\")]\n-checked_cast_impl!(CheckedAdd, checked_add, int, i64, intrinsics::i64_add_with_overflow)\n-\n-checked_impl!(CheckedAdd, checked_add, i8,  intrinsics::i8_add_with_overflow)\n-checked_impl!(CheckedAdd, checked_add, i16, intrinsics::i16_add_with_overflow)\n-checked_impl!(CheckedAdd, checked_add, i32, intrinsics::i32_add_with_overflow)\n-checked_impl!(CheckedAdd, checked_add, i64, intrinsics::i64_add_with_overflow)\n-\n-/// Performs subtraction that returns `None` instead of wrapping around on underflow.\n-pub trait CheckedSub: Sub<Self, Self> {\n-    /// Subtracts two numbers, checking for underflow. If underflow happens, `None` is returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::num::CheckedSub;\n-    /// assert_eq!((-127i8).checked_sub(&1), Some(-128));\n-    /// assert_eq!((-128i8).checked_sub(&1), None);\n-    /// ```\n-    fn checked_sub(&self, v: &Self) -> Option<Self>;\n-}\n-\n-#[cfg(target_word_size = \"32\")]\n-checked_cast_impl!(CheckedSub, checked_sub, uint, u32, intrinsics::u32_sub_with_overflow)\n-#[cfg(target_word_size = \"64\")]\n-checked_cast_impl!(CheckedSub, checked_sub, uint, u64, intrinsics::u64_sub_with_overflow)\n-\n-checked_impl!(CheckedSub, checked_sub, u8,  intrinsics::u8_sub_with_overflow)\n-checked_impl!(CheckedSub, checked_sub, u16, intrinsics::u16_sub_with_overflow)\n-checked_impl!(CheckedSub, checked_sub, u32, intrinsics::u32_sub_with_overflow)\n-checked_impl!(CheckedSub, checked_sub, u64, intrinsics::u64_sub_with_overflow)\n-\n-#[cfg(target_word_size = \"32\")]\n-checked_cast_impl!(CheckedSub, checked_sub, int, i32, intrinsics::i32_sub_with_overflow)\n-#[cfg(target_word_size = \"64\")]\n-checked_cast_impl!(CheckedSub, checked_sub, int, i64, intrinsics::i64_sub_with_overflow)\n-\n-checked_impl!(CheckedSub, checked_sub, i8,  intrinsics::i8_sub_with_overflow)\n-checked_impl!(CheckedSub, checked_sub, i16, intrinsics::i16_sub_with_overflow)\n-checked_impl!(CheckedSub, checked_sub, i32, intrinsics::i32_sub_with_overflow)\n-checked_impl!(CheckedSub, checked_sub, i64, intrinsics::i64_sub_with_overflow)\n-\n-/// Performs multiplication that returns `None` instead of wrapping around on underflow or\n-/// overflow.\n-pub trait CheckedMul: Mul<Self, Self> {\n-    /// Multiplies two numbers, checking for underflow or overflow. If underflow or overflow\n-    /// happens, `None` is returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::num::CheckedMul;\n-    /// assert_eq!(5u8.checked_mul(&51), Some(255));\n-    /// assert_eq!(5u8.checked_mul(&52), None);\n-    /// ```\n-    fn checked_mul(&self, v: &Self) -> Option<Self>;\n-}\n-\n-#[cfg(target_word_size = \"32\")]\n-checked_cast_impl!(CheckedMul, checked_mul, uint, u32, intrinsics::u32_mul_with_overflow)\n-#[cfg(target_word_size = \"64\")]\n-checked_cast_impl!(CheckedMul, checked_mul, uint, u64, intrinsics::u64_mul_with_overflow)\n-\n-checked_impl!(CheckedMul, checked_mul, u8,  intrinsics::u8_mul_with_overflow)\n-checked_impl!(CheckedMul, checked_mul, u16, intrinsics::u16_mul_with_overflow)\n-checked_impl!(CheckedMul, checked_mul, u32, intrinsics::u32_mul_with_overflow)\n-checked_impl!(CheckedMul, checked_mul, u64, intrinsics::u64_mul_with_overflow)\n-\n-#[cfg(target_word_size = \"32\")]\n-checked_cast_impl!(CheckedMul, checked_mul, int, i32, intrinsics::i32_mul_with_overflow)\n-#[cfg(target_word_size = \"64\")]\n-checked_cast_impl!(CheckedMul, checked_mul, int, i64, intrinsics::i64_mul_with_overflow)\n-\n-checked_impl!(CheckedMul, checked_mul, i8,  intrinsics::i8_mul_with_overflow)\n-checked_impl!(CheckedMul, checked_mul, i16, intrinsics::i16_mul_with_overflow)\n-checked_impl!(CheckedMul, checked_mul, i32, intrinsics::i32_mul_with_overflow)\n-checked_impl!(CheckedMul, checked_mul, i64, intrinsics::i64_mul_with_overflow)\n-\n-/// Performs division that returns `None` instead of panicking on division by zero and instead of\n-/// wrapping around on underflow and overflow.\n-pub trait CheckedDiv: Div<Self, Self> {\n-    /// Divides two numbers, checking for underflow, overflow and division by zero. If any of that\n-    /// happens, `None` is returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::num::CheckedDiv;\n-    /// assert_eq!((-127i8).checked_div(&-1), Some(127));\n-    /// assert_eq!((-128i8).checked_div(&-1), None);\n-    /// assert_eq!((1i8).checked_div(&0), None);\n-    /// ```\n-    fn checked_div(&self, v: &Self) -> Option<Self>;\n-}\n-\n-macro_rules! checkeddiv_int_impl(\n-    ($t:ty, $min:expr) => {\n-        impl CheckedDiv for $t {\n-            #[inline]\n-            fn checked_div(&self, v: &$t) -> Option<$t> {\n-                if *v == 0 || (*self == $min && *v == -1) {\n-                    None\n-                } else {\n-                    Some(*self / *v)\n-                }\n-            }\n-        }\n-    }\n-)\n-\n-checkeddiv_int_impl!(int, int::MIN)\n-checkeddiv_int_impl!(i8, i8::MIN)\n-checkeddiv_int_impl!(i16, i16::MIN)\n-checkeddiv_int_impl!(i32, i32::MIN)\n-checkeddiv_int_impl!(i64, i64::MIN)\n-\n-macro_rules! checkeddiv_uint_impl(\n-    ($($t:ty)*) => ($(\n-        impl CheckedDiv for $t {\n-            #[inline]\n-            fn checked_div(&self, v: &$t) -> Option<$t> {\n-                if *v == 0 {\n-                    None\n-                } else {\n-                    Some(*self / *v)\n-                }\n-            }\n-        }\n-    )*)\n-)\n-\n-checkeddiv_uint_impl!(uint u8 u16 u32 u64)\n-\n /// Used for representing the classification of floating point numbers\n #[deriving(PartialEq, Show)]\n pub enum FPCategory {"}, {"sha": "045aca8aa0a8bd7d7aa88d18ac33b7e0d9e3fb50", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=e51cc089da7f5a067d348ee48f494c5bca662f95", "patch": "@@ -51,7 +51,7 @@ pub use cmp::{Ordering, Less, Equal, Greater, Equiv};\n pub use iter::{FromIterator, Extend};\n pub use iter::{Iterator, DoubleEndedIterator, RandomAccessIterator, CloneableIterator};\n pub use iter::{OrdIterator, MutableDoubleEndedIterator, ExactSize};\n-pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n+pub use num::{Num, NumCast};\n pub use num::{Signed, Unsigned, Float};\n pub use num::{Primitive, Int, ToPrimitive, FromPrimitive};\n pub use option::{Option, Some, None};"}, {"sha": "7b223dc501beb44dc359bf527183bb8e5e726978", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=e51cc089da7f5a067d348ee48f494c5bca662f95", "patch": "@@ -40,7 +40,7 @@ use cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering, Less, Equal, Greater, Equiv}\n use cmp;\n use default::Default;\n use iter::*;\n-use num::{CheckedAdd, Int, div_rem};\n+use num::{Int, div_rem};\n use ops;\n use option::{None, Option, Some};\n use ptr;\n@@ -1346,7 +1346,7 @@ impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n             (0, Some(0))\n         } else {\n             let x = self.v.len() - self.size;\n-            (x.saturating_add(1), x.checked_add(&1u))\n+            (x.saturating_add(1), x.checked_add(1u))\n         }\n     }\n }"}, {"sha": "b3bed201598d813baf9309865aa222402e7a88b3", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=e51cc089da7f5a067d348ee48f494c5bca662f95", "patch": "@@ -25,7 +25,7 @@ use iter::{Map, Iterator};\n use iter::{DoubleEndedIterator, ExactSize};\n use iter::range;\n use kinds::Sized;\n-use num::{CheckedMul, Int};\n+use num::Int;\n use option::{Option, None, Some};\n use raw::Repr;\n use slice::{mod, SlicePrelude};\n@@ -750,7 +750,7 @@ impl<'a> Iterator<u16> for Utf16CodeUnits<'a> {\n         // every char gets either one u16 or two u16,\n         // so this iterator is between 1 or 2 times as\n         // long as the underlying iterator.\n-        (low, high.and_then(|n| n.checked_mul(&2)))\n+        (low, high.and_then(|n| n.checked_mul(2)))\n     }\n }\n "}, {"sha": "51af2e2916d9342356d0c7e1d3ca71ef71c2437b", "filename": "src/libcoretest/num/int_macros.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=e51cc089da7f5a067d348ee48f494c5bca662f95", "patch": "@@ -16,7 +16,6 @@ mod tests {\n     use core::$T_i::*;\n     use core::int;\n     use num;\n-    use core::num::CheckedDiv;\n \n     #[test]\n     fn test_overflows() {\n@@ -152,9 +151,9 @@ mod tests {\n \n     #[test]\n     fn test_signed_checked_div() {\n-        assert!(10i.checked_div(&2) == Some(5));\n-        assert!(5i.checked_div(&0) == None);\n-        assert!(int::MIN.checked_div(&-1) == None);\n+        assert!(10i.checked_div(2) == Some(5));\n+        assert!(5i.checked_div(0) == None);\n+        assert!(int::MIN.checked_div(-1) == None);\n     }\n }\n "}, {"sha": "1d3f1718d72fc7e879328f32bdbee262b7f652f7", "filename": "src/libcoretest/num/uint_macros.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint_macros.rs?ref=e51cc089da7f5a067d348ee48f494c5bca662f95", "patch": "@@ -15,7 +15,6 @@ macro_rules! uint_module (($T:ty, $T_i:ident) => (\n mod tests {\n     use core::$T_i::*;\n     use num;\n-    use core::num::CheckedDiv;\n \n     #[test]\n     fn test_overflows() {\n@@ -120,8 +119,8 @@ mod tests {\n \n     #[test]\n     fn test_unsigned_checked_div() {\n-        assert!(10u.checked_div(&2) == Some(5));\n-        assert!(5u.checked_div(&0) == None);\n+        assert!(10u.checked_div(2) == Some(5));\n+        assert!(5u.checked_div(0) == None);\n     }\n }\n ))"}, {"sha": "26d5d3fb2f9e22268f0ce6ddbd18a079282b4b6f", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=e51cc089da7f5a067d348ee48f494c5bca662f95", "patch": "@@ -126,7 +126,7 @@ impl<'a, T: Clone> WeightedChoice<'a, T> {\n         // weights so we can binary search. This *could* drop elements\n         // with weight == 0 as an optimisation.\n         for item in items.iter_mut() {\n-            running_total = match running_total.checked_add(&item.weight) {\n+            running_total = match running_total.checked_add(item.weight) {\n                 Some(n) => n,\n                 None => panic!(\"WeightedChoice::new called with a total weight \\\n                                larger than a uint can contain\")"}, {"sha": "5e2df42d2d6e97c810aebefc7cda6ee95d69c6a3", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=e51cc089da7f5a067d348ee48f494c5bca662f95", "patch": "@@ -24,15 +24,13 @@ use middle::trans::type_::Type;\n use syntax::abi;\n use syntax::ast;\n \n-use std::num::CheckedMul;\n-\n // LLVM doesn't like objects that are too big. Issue #17913\n fn ensure_array_fits_in_address_space(ccx: &CrateContext,\n                                       llet: Type,\n                                       size: machine::llsize,\n                                       scapegoat: ty::t) {\n     let esz = machine::llsize_of_alloc(ccx, llet);\n-    match esz.checked_mul(&size) {\n+    match esz.checked_mul(size) {\n         Some(n) if n < ccx.max_obj_size() => {}\n         _ => { ccx.report_overbig_object(scapegoat) }\n     }"}, {"sha": "71d6ad791ec2faad735fc55841486a4fd799d1ee", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=e51cc089da7f5a067d348ee48f494c5bca662f95", "patch": "@@ -61,14 +61,14 @@ impl ToBits for u64 {\n \n /// Adds the specified number of bytes to the bit count. panic!() if this would cause numeric\n /// overflow.\n-fn add_bytes_to_bits<T: Int + CheckedAdd + ToBits>(bits: T, bytes: T) -> T {\n+fn add_bytes_to_bits<T: Int + ToBits>(bits: T, bytes: T) -> T {\n     let (new_high_bits, new_low_bits) = bytes.to_bits();\n \n     if new_high_bits > Zero::zero() {\n         panic!(\"numeric overflow occurred.\")\n     }\n \n-    match bits.checked_add(&new_low_bits) {\n+    match bits.checked_add(new_low_bits) {\n         Some(x) => return x,\n         None => panic!(\"numeric overflow occurred.\")\n     }"}, {"sha": "f387b660ed19a4fd18b2f2114f4ac0764b9dc13a", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=e51cc089da7f5a067d348ee48f494c5bca662f95", "patch": "@@ -609,7 +609,7 @@ impl<'a> PrettyEncoder<'a> {\n     /// This is safe to set during encoding.\n     pub fn set_indent<'a>(&mut self, indent: uint) {\n         // self.indent very well could be 0 so we need to use checked division.\n-        let level = self.curr_indent.checked_div(&self.indent).unwrap_or(0);\n+        let level = self.curr_indent.checked_div(self.indent).unwrap_or(0);\n         self.indent = indent;\n         self.curr_indent = level * self.indent;\n     }"}, {"sha": "dd65a00d110b9e0af7a304d6ce3cb98ded307aa6", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=e51cc089da7f5a067d348ee48f494c5bca662f95", "patch": "@@ -17,7 +17,7 @@ use iter::{Iterator, count};\n use kinds::{Sized, marker};\n use mem::{min_align_of, size_of};\n use mem;\n-use num::{CheckedAdd, CheckedMul, UnsignedInt};\n+use num::{Int, UnsignedInt};\n use ops::{Deref, DerefMut, Drop};\n use option::{Some, None, Option};\n use ptr::{RawPtr, copy_nonoverlapping_memory, zero_memory};\n@@ -604,9 +604,9 @@ impl<K, V> RawTable<K, V> {\n                 vals_size,   min_align_of::< V >());\n \n         // One check for overflow that covers calculation and rounding of size.\n-        let size_of_bucket = size_of::<u64>().checked_add(&size_of::<K>()).unwrap()\n-                                             .checked_add(&size_of::<V>()).unwrap();\n-        assert!(size >= capacity.checked_mul(&size_of_bucket)\n+        let size_of_bucket = size_of::<u64>().checked_add(size_of::<K>()).unwrap()\n+                                             .checked_add(size_of::<V>()).unwrap();\n+        assert!(size >= capacity.checked_mul(size_of_bucket)\n                                 .expect(\"capacity overflow\"),\n                 \"capacity overflow\");\n "}, {"sha": "2be88e01eed4b2afb703899034062fe44e5a5846", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=e51cc089da7f5a067d348ee48f494c5bca662f95", "patch": "@@ -24,7 +24,6 @@ pub use core::num::{Num, div_rem, Zero, zero, One, one};\n pub use core::num::{Signed, abs, signum};\n pub use core::num::{Unsigned, pow, Bounded};\n pub use core::num::{Primitive, Int, UnsignedInt};\n-pub use core::num::{CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n pub use core::num::{cast, FromPrimitive, NumCast, ToPrimitive};\n pub use core::num::{next_power_of_two, is_power_of_two};\n pub use core::num::{checked_next_power_of_two};\n@@ -636,36 +635,36 @@ mod tests {\n     #[test]\n     fn test_checked_add() {\n         let five_less = uint::MAX - 5;\n-        assert_eq!(five_less.checked_add(&0), Some(uint::MAX - 5));\n-        assert_eq!(five_less.checked_add(&1), Some(uint::MAX - 4));\n-        assert_eq!(five_less.checked_add(&2), Some(uint::MAX - 3));\n-        assert_eq!(five_less.checked_add(&3), Some(uint::MAX - 2));\n-        assert_eq!(five_less.checked_add(&4), Some(uint::MAX - 1));\n-        assert_eq!(five_less.checked_add(&5), Some(uint::MAX));\n-        assert_eq!(five_less.checked_add(&6), None);\n-        assert_eq!(five_less.checked_add(&7), None);\n+        assert_eq!(five_less.checked_add(0), Some(uint::MAX - 5));\n+        assert_eq!(five_less.checked_add(1), Some(uint::MAX - 4));\n+        assert_eq!(five_less.checked_add(2), Some(uint::MAX - 3));\n+        assert_eq!(five_less.checked_add(3), Some(uint::MAX - 2));\n+        assert_eq!(five_less.checked_add(4), Some(uint::MAX - 1));\n+        assert_eq!(five_less.checked_add(5), Some(uint::MAX));\n+        assert_eq!(five_less.checked_add(6), None);\n+        assert_eq!(five_less.checked_add(7), None);\n     }\n \n     #[test]\n     fn test_checked_sub() {\n-        assert_eq!(5u.checked_sub(&0), Some(5));\n-        assert_eq!(5u.checked_sub(&1), Some(4));\n-        assert_eq!(5u.checked_sub(&2), Some(3));\n-        assert_eq!(5u.checked_sub(&3), Some(2));\n-        assert_eq!(5u.checked_sub(&4), Some(1));\n-        assert_eq!(5u.checked_sub(&5), Some(0));\n-        assert_eq!(5u.checked_sub(&6), None);\n-        assert_eq!(5u.checked_sub(&7), None);\n+        assert_eq!(5u.checked_sub(0), Some(5));\n+        assert_eq!(5u.checked_sub(1), Some(4));\n+        assert_eq!(5u.checked_sub(2), Some(3));\n+        assert_eq!(5u.checked_sub(3), Some(2));\n+        assert_eq!(5u.checked_sub(4), Some(1));\n+        assert_eq!(5u.checked_sub(5), Some(0));\n+        assert_eq!(5u.checked_sub(6), None);\n+        assert_eq!(5u.checked_sub(7), None);\n     }\n \n     #[test]\n     fn test_checked_mul() {\n         let third = uint::MAX / 3;\n-        assert_eq!(third.checked_mul(&0), Some(0));\n-        assert_eq!(third.checked_mul(&1), Some(third));\n-        assert_eq!(third.checked_mul(&2), Some(third * 2));\n-        assert_eq!(third.checked_mul(&3), Some(third * 3));\n-        assert_eq!(third.checked_mul(&4), None);\n+        assert_eq!(third.checked_mul(0), Some(0));\n+        assert_eq!(third.checked_mul(1), Some(third));\n+        assert_eq!(third.checked_mul(2), Some(third * 2));\n+        assert_eq!(third.checked_mul(3), Some(third * 3));\n+        assert_eq!(third.checked_mul(4), None);\n     }\n \n     macro_rules! test_next_power_of_two("}, {"sha": "875d03d6c259496c4459370fdecffeebc8f24cb5", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=e51cc089da7f5a067d348ee48f494c5bca662f95", "patch": "@@ -601,11 +601,11 @@ pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n                 Some(x) => x,\n                 None => return None,\n             };\n-            result = match result.checked_mul(&radix) {\n+            result = match result.checked_mul(radix) {\n                 Some(result) => result,\n                 None => return None,\n             };\n-            result = match result.checked_add(&x) {\n+            result = match result.checked_add(x) {\n                 Some(result) => result,\n                 None => return None,\n             };\n@@ -616,11 +616,11 @@ pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n                 Some(x) => x,\n                 None => return None,\n             };\n-            result = match result.checked_mul(&radix) {\n+            result = match result.checked_mul(radix) {\n                 Some(result) => result,\n                 None => return None,\n             };\n-            result = match result.checked_sub(&x) {\n+            result = match result.checked_sub(x) {\n                 Some(result) => result,\n                 None => return None,\n             };"}, {"sha": "3c20d205b7741b1baed0079ebbd67945d5b426a8", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=e51cc089da7f5a067d348ee48f494c5bca662f95", "patch": "@@ -67,7 +67,7 @@\n #[doc(no_inline)] pub use iter::{Iterator, DoubleEndedIterator};\n #[doc(no_inline)] pub use iter::{RandomAccessIterator, CloneableIterator};\n #[doc(no_inline)] pub use iter::{OrdIterator, MutableDoubleEndedIterator};\n-#[doc(no_inline)] pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n+#[doc(no_inline)] pub use num::{Num, NumCast};\n #[doc(no_inline)] pub use num::{Signed, Unsigned, Primitive, Int, Float};\n #[doc(no_inline)] pub use num::{FloatMath, ToPrimitive, FromPrimitive};\n #[doc(no_inline)] pub use boxed::Box;"}, {"sha": "6afeb76b83fbeaa01b67ebc9eacda7acb7689229", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 60, "deletions": 71, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=e51cc089da7f5a067d348ee48f494c5bca662f95", "patch": "@@ -15,8 +15,7 @@\n use {fmt, i64};\n use ops::{Add, Sub, Mul, Div, Neg};\n use option::{Option, Some, None};\n-use num;\n-use num::{CheckedAdd, CheckedMul};\n+use num::Int;\n use result::{Result, Ok, Err};\n \n /// The number of nanoseconds in a microsecond.\n@@ -69,7 +68,7 @@ impl Duration {\n     /// Fails when the duration is out of bounds.\n     #[inline]\n     pub fn weeks(weeks: i64) -> Duration {\n-        let secs = weeks.checked_mul(&SECS_PER_WEEK).expect(\"Duration::weeks out of bounds\");\n+        let secs = weeks.checked_mul(SECS_PER_WEEK).expect(\"Duration::weeks out of bounds\");\n         Duration::seconds(secs)\n     }\n \n@@ -78,7 +77,7 @@ impl Duration {\n     /// Fails when the duration is out of bounds.\n     #[inline]\n     pub fn days(days: i64) -> Duration {\n-        let secs = days.checked_mul(&SECS_PER_DAY).expect(\"Duration::days out of bounds\");\n+        let secs = days.checked_mul(SECS_PER_DAY).expect(\"Duration::days out of bounds\");\n         Duration::seconds(secs)\n     }\n \n@@ -87,7 +86,7 @@ impl Duration {\n     /// Fails when the duration is out of bounds.\n     #[inline]\n     pub fn hours(hours: i64) -> Duration {\n-        let secs = hours.checked_mul(&SECS_PER_HOUR).expect(\"Duration::hours ouf of bounds\");\n+        let secs = hours.checked_mul(SECS_PER_HOUR).expect(\"Duration::hours ouf of bounds\");\n         Duration::seconds(secs)\n     }\n \n@@ -96,7 +95,7 @@ impl Duration {\n     /// Fails when the duration is out of bounds.\n     #[inline]\n     pub fn minutes(minutes: i64) -> Duration {\n-        let secs = minutes.checked_mul(&SECS_PER_MINUTE).expect(\"Duration::minutes out of bounds\");\n+        let secs = minutes.checked_mul(SECS_PER_MINUTE).expect(\"Duration::minutes out of bounds\");\n         Duration::seconds(secs)\n     }\n \n@@ -191,33 +190,64 @@ impl Duration {\n     /// Returns the total number of whole microseconds in the duration,\n     /// or `None` on overflow (exceeding 2^63 microseconds in either direction).\n     pub fn num_microseconds(&self) -> Option<i64> {\n-        let secs_part = try_opt!(self.num_seconds().checked_mul(&MICROS_PER_SEC));\n+        let secs_part = try_opt!(self.num_seconds().checked_mul(MICROS_PER_SEC));\n         let nanos_part = self.nanos_mod_sec() / NANOS_PER_MICRO;\n-        secs_part.checked_add(&(nanos_part as i64))\n+        secs_part.checked_add(nanos_part as i64)\n     }\n \n     /// Returns the total number of whole nanoseconds in the duration,\n     /// or `None` on overflow (exceeding 2^63 nanoseconds in either direction).\n     pub fn num_nanoseconds(&self) -> Option<i64> {\n-        let secs_part = try_opt!(self.num_seconds().checked_mul(&(NANOS_PER_SEC as i64)));\n+        let secs_part = try_opt!(self.num_seconds().checked_mul(NANOS_PER_SEC as i64));\n         let nanos_part = self.nanos_mod_sec();\n-        secs_part.checked_add(&(nanos_part as i64))\n+        secs_part.checked_add(nanos_part as i64)\n     }\n-}\n \n-impl num::Bounded for Duration {\n-    #[inline] fn min_value() -> Duration { MIN }\n-    #[inline] fn max_value() -> Duration { MAX }\n-}\n+    /// Add two durations, returning `None` if overflow occured.\n+    pub fn checked_add(&self, rhs: &Duration) -> Option<Duration> {\n+        let mut secs = try_opt!(self.secs.checked_add(rhs.secs));\n+        let mut nanos = self.nanos + rhs.nanos;\n+        if nanos >= NANOS_PER_SEC {\n+            nanos -= NANOS_PER_SEC;\n+            secs = try_opt!(secs.checked_add(1));\n+        }\n+        let d = Duration { secs: secs, nanos: nanos };\n+        // Even if d is within the bounds of i64 seconds,\n+        // it might still overflow i64 milliseconds.\n+        if d < MIN || d > MAX { None } else { Some(d) }\n+    }\n+\n+    /// Subtract two durations, returning `None` if overflow occured.\n+    pub fn checked_sub(&self, rhs: &Duration) -> Option<Duration> {\n+        let mut secs = try_opt!(self.secs.checked_sub(rhs.secs));\n+        let mut nanos = self.nanos - rhs.nanos;\n+        if nanos < 0 {\n+            nanos += NANOS_PER_SEC;\n+            secs = try_opt!(secs.checked_sub(1));\n+        }\n+        let d = Duration { secs: secs, nanos: nanos };\n+        // Even if d is within the bounds of i64 seconds,\n+        // it might still overflow i64 milliseconds.\n+        if d < MIN || d > MAX { None } else { Some(d) }\n+    }\n \n-impl num::Zero for Duration {\n+    /// The minimum possible `Duration`: `i64::MIN` milliseconds.\n     #[inline]\n-    fn zero() -> Duration {\n+    pub fn min_value() -> Duration { MIN }\n+\n+    /// The maximum possible `Duration`: `i64::MAX` milliseconds.\n+    #[inline]\n+    pub fn max_value() -> Duration { MAX }\n+\n+    /// A duration where the stored seconds and nanoseconds are equal to zero.\n+    #[inline]\n+    pub fn zero() -> Duration {\n         Duration { secs: 0, nanos: 0 }\n     }\n \n+    /// Returns `true` if the duration equals `Duration::zero()`.\n     #[inline]\n-    fn is_zero(&self) -> bool {\n+    pub fn is_zero(&self) -> bool {\n         self.secs == 0 && self.nanos == 0\n     }\n }\n@@ -245,21 +275,6 @@ impl Add<Duration,Duration> for Duration {\n     }\n }\n \n-impl num::CheckedAdd for Duration {\n-    fn checked_add(&self, rhs: &Duration) -> Option<Duration> {\n-        let mut secs = try_opt!(self.secs.checked_add(&rhs.secs));\n-        let mut nanos = self.nanos + rhs.nanos;\n-        if nanos >= NANOS_PER_SEC {\n-            nanos -= NANOS_PER_SEC;\n-            secs = try_opt!(secs.checked_add(&1));\n-        }\n-        let d = Duration { secs: secs, nanos: nanos };\n-        // Even if d is within the bounds of i64 seconds,\n-        // it might still overflow i64 milliseconds.\n-        if d < MIN || d > MAX { None } else { Some(d) }\n-    }\n-}\n-\n impl Sub<Duration,Duration> for Duration {\n     fn sub(&self, rhs: &Duration) -> Duration {\n         let mut secs = self.secs - rhs.secs;\n@@ -272,21 +287,6 @@ impl Sub<Duration,Duration> for Duration {\n     }\n }\n \n-impl num::CheckedSub for Duration {\n-    fn checked_sub(&self, rhs: &Duration) -> Option<Duration> {\n-        let mut secs = try_opt!(self.secs.checked_sub(&rhs.secs));\n-        let mut nanos = self.nanos - rhs.nanos;\n-        if nanos < 0 {\n-            nanos += NANOS_PER_SEC;\n-            secs = try_opt!(secs.checked_sub(&1));\n-        }\n-        let d = Duration { secs: secs, nanos: nanos };\n-        // Even if d is within the bounds of i64 seconds,\n-        // it might still overflow i64 milliseconds.\n-        if d < MIN || d > MAX { None } else { Some(d) }\n-    }\n-}\n-\n impl Mul<i32,Duration> for Duration {\n     fn mul(&self, rhs: &i32) -> Duration {\n         // Multiply nanoseconds as i64, because it cannot overflow that way.\n@@ -379,15 +379,12 @@ fn div_rem_64(this: i64, other: i64) -> (i64, i64) {\n mod tests {\n     use super::{Duration, MIN, MAX};\n     use {i32, i64};\n-    use num::{Zero, CheckedAdd, CheckedSub};\n     use option::{Some, None};\n     use to_string::ToString;\n \n     #[test]\n     fn test_duration() {\n-        let d: Duration = Zero::zero();\n-        assert_eq!(d, Zero::zero());\n-        assert!(Duration::seconds(1) != Zero::zero());\n+        assert!(Duration::seconds(1) != Duration::zero());\n         assert_eq!(Duration::seconds(1) + Duration::seconds(2), Duration::seconds(3));\n         assert_eq!(Duration::seconds(86399) + Duration::seconds(4),\n                    Duration::days(1) + Duration::seconds(3));\n@@ -403,8 +400,7 @@ mod tests {\n \n     #[test]\n     fn test_duration_num_days() {\n-        let d: Duration = Zero::zero();\n-        assert_eq!(d.num_days(), 0);\n+        assert_eq!(Duration::zero().num_days(), 0);\n         assert_eq!(Duration::days(1).num_days(), 1);\n         assert_eq!(Duration::days(-1).num_days(), -1);\n         assert_eq!(Duration::seconds(86399).num_days(), 0);\n@@ -417,8 +413,7 @@ mod tests {\n \n     #[test]\n     fn test_duration_num_seconds() {\n-        let d: Duration = Zero::zero();\n-        assert_eq!(d.num_seconds(), 0);\n+        assert_eq!(Duration::zero().num_seconds(), 0);\n         assert_eq!(Duration::seconds(1).num_seconds(), 1);\n         assert_eq!(Duration::seconds(-1).num_seconds(), -1);\n         assert_eq!(Duration::milliseconds(999).num_seconds(), 0);\n@@ -429,8 +424,7 @@ mod tests {\n \n     #[test]\n     fn test_duration_num_milliseconds() {\n-        let d: Duration = Zero::zero();\n-        assert_eq!(d.num_milliseconds(), 0);\n+        assert_eq!(Duration::zero().num_milliseconds(), 0);\n         assert_eq!(Duration::milliseconds(1).num_milliseconds(), 1);\n         assert_eq!(Duration::milliseconds(-1).num_milliseconds(), -1);\n         assert_eq!(Duration::microseconds(999).num_milliseconds(), 0);\n@@ -445,8 +439,7 @@ mod tests {\n \n     #[test]\n     fn test_duration_num_microseconds() {\n-        let d: Duration = Zero::zero();\n-        assert_eq!(d.num_microseconds(), Some(0));\n+        assert_eq!(Duration::zero().num_microseconds(), Some(0));\n         assert_eq!(Duration::microseconds(1).num_microseconds(), Some(1));\n         assert_eq!(Duration::microseconds(-1).num_microseconds(), Some(-1));\n         assert_eq!(Duration::nanoseconds(999).num_microseconds(), Some(0));\n@@ -470,8 +463,7 @@ mod tests {\n \n     #[test]\n     fn test_duration_num_nanoseconds() {\n-        let d: Duration = Zero::zero();\n-        assert_eq!(d.num_nanoseconds(), Some(0));\n+        assert_eq!(Duration::zero().num_nanoseconds(), Some(0));\n         assert_eq!(Duration::nanoseconds(1).num_nanoseconds(), Some(1));\n         assert_eq!(Duration::nanoseconds(-1).num_nanoseconds(), Some(-1));\n         assert_eq!(Duration::nanoseconds(i64::MAX).num_nanoseconds(), Some(i64::MAX));\n@@ -504,10 +496,9 @@ mod tests {\n \n     #[test]\n     fn test_duration_mul() {\n-        let d: Duration = Zero::zero();\n-        assert_eq!(d * i32::MAX, d);\n-        assert_eq!(d * i32::MIN, d);\n-        assert_eq!(Duration::nanoseconds(1) * 0, Zero::zero());\n+        assert_eq!(Duration::zero() * i32::MAX, Duration::zero());\n+        assert_eq!(Duration::zero() * i32::MIN, Duration::zero());\n+        assert_eq!(Duration::nanoseconds(1) * 0, Duration::zero());\n         assert_eq!(Duration::nanoseconds(1) * 1, Duration::nanoseconds(1));\n         assert_eq!(Duration::nanoseconds(1) * 1_000_000_000, Duration::seconds(1));\n         assert_eq!(Duration::nanoseconds(1) * -1_000_000_000, -Duration::seconds(1));\n@@ -522,9 +513,8 @@ mod tests {\n \n     #[test]\n     fn test_duration_div() {\n-        let d: Duration = Zero::zero();\n-        assert_eq!(d / i32::MAX, d);\n-        assert_eq!(d / i32::MIN, d);\n+        assert_eq!(Duration::zero() / i32::MAX, Duration::zero());\n+        assert_eq!(Duration::zero() / i32::MIN, Duration::zero());\n         assert_eq!(Duration::nanoseconds(123_456_789) / 1, Duration::nanoseconds(123_456_789));\n         assert_eq!(Duration::nanoseconds(123_456_789) / -1, -Duration::nanoseconds(123_456_789));\n         assert_eq!(-Duration::nanoseconds(123_456_789) / -1, Duration::nanoseconds(123_456_789));\n@@ -540,8 +530,7 @@ mod tests {\n \n     #[test]\n     fn test_duration_fmt() {\n-        let d: Duration = Zero::zero();\n-        assert_eq!(d.to_string(), \"PT0S\".to_string());\n+        assert_eq!(Duration::zero().to_string(), \"PT0S\".to_string());\n         assert_eq!(Duration::days(42).to_string(), \"P42D\".to_string());\n         assert_eq!(Duration::days(-42).to_string(), \"-P42D\".to_string());\n         assert_eq!(Duration::seconds(42).to_string(), \"PT42S\".to_string());"}, {"sha": "0f364d1ba0b6050d234d7e78192c121ec53ed427", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e51cc089da7f5a067d348ee48f494c5bca662f95/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=e51cc089da7f5a067d348ee48f494c5bca662f95", "patch": "@@ -63,7 +63,7 @@ impl ParseSess {\n     pub fn reserve_node_ids(&self, count: ast::NodeId) -> ast::NodeId {\n         let v = self.node_id.get();\n \n-        match v.checked_add(&count) {\n+        match v.checked_add(count) {\n             Some(next) => { self.node_id.set(next); }\n             None => panic!(\"Input too large, ran out of node ids!\")\n         }"}]}