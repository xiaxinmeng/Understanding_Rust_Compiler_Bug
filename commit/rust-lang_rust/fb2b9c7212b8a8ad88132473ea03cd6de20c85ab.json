{"sha": "fb2b9c7212b8a8ad88132473ea03cd6de20c85ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiMmI5YzcyMTJiOGE4YWQ4ODEzMjQ3M2VhMDNjZDZkZTIwYzg1YWI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-23T08:42:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-23T08:42:45Z"}, "message": "Merge #7062\n\n7062: Add diagnostic for filter_map followed by next r=theotherphil a=theotherphil\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/1725\n\nCo-authored-by: Phil Ellison <phil.j.ellison@gmail.com>", "tree": {"sha": "582ca4f048a09f86c0e489bbd31950d2b738036b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/582ca4f048a09f86c0e489bbd31950d2b738036b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb2b9c7212b8a8ad88132473ea03cd6de20c85ab", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgC+GFCRBK7hj4Ov3rIwAAdHIIAAjaAU0D469Td3418khGrkom\nRzSv5y+JWyCz6UxolJG3Kab3IZe1GxVqO4/hbgKAQbjPuWkvq2zBU6p/4u50Q9JF\n6G11t563XjXhBohDiAaw1ITuMAeyL/m3HspTHk/6Ccdg54sLKhb68IQvXxFgwYWX\nDORS5XxqZSmt64a88YeDKJHT6KUWFihmg1E36qblzIAXjxIlPQJfWdw+5h0n7jke\nHIM3z4LDq1Wb4XxHfLsqR1xndD+v2g80bg8mWqEdXlVj8JNBAo4O0Xakn4A0/cgD\nXVTDMfDqu3osZV2fy3vWIknDPMEguJD/MjdD0+9ZwUZY1oXusAIWDuhYyX5J+mk=\n=Vdee\n-----END PGP SIGNATURE-----\n", "payload": "tree 582ca4f048a09f86c0e489bbd31950d2b738036b\nparent eab5db20edd9604ba5d489fa8c6430eb7bac6610\nparent db6dda94a39534bbf20da844a4f221c3d14509c4\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1611391365 +0000\ncommitter GitHub <noreply@github.com> 1611391365 +0000\n\nMerge #7062\n\n7062: Add diagnostic for filter_map followed by next r=theotherphil a=theotherphil\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/1725\n\nCo-authored-by: Phil Ellison <phil.j.ellison@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb2b9c7212b8a8ad88132473ea03cd6de20c85ab", "html_url": "https://github.com/rust-lang/rust/commit/fb2b9c7212b8a8ad88132473ea03cd6de20c85ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb2b9c7212b8a8ad88132473ea03cd6de20c85ab/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eab5db20edd9604ba5d489fa8c6430eb7bac6610", "url": "https://api.github.com/repos/rust-lang/rust/commits/eab5db20edd9604ba5d489fa8c6430eb7bac6610", "html_url": "https://github.com/rust-lang/rust/commit/eab5db20edd9604ba5d489fa8c6430eb7bac6610"}, {"sha": "db6dda94a39534bbf20da844a4f221c3d14509c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/db6dda94a39534bbf20da844a4f221c3d14509c4", "html_url": "https://github.com/rust-lang/rust/commit/db6dda94a39534bbf20da844a4f221c3d14509c4"}], "stats": {"total": 243, "additions": 224, "deletions": 19}, "files": [{"sha": "5343a036c0190f9f41c7d335f5a60939649a602c", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb2b9c7212b8a8ad88132473ea03cd6de20c85ab/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2b9c7212b8a8ad88132473ea03cd6de20c85ab/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=fb2b9c7212b8a8ad88132473ea03cd6de20c85ab", "patch": "@@ -5,5 +5,5 @@ pub use hir_expand::diagnostics::{\n };\n pub use hir_ty::diagnostics::{\n     IncorrectCase, MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkOrSomeInTailExpr,\n-    NoSuchField, RemoveThisSemicolon,\n+    NoSuchField, RemoveThisSemicolon, ReplaceFilterMapNextWithFindMap,\n };"}, {"sha": "84ea09b5387bc2a95c8148ba8adfc33d7c853211", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb2b9c7212b8a8ad88132473ea03cd6de20c85ab/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2b9c7212b8a8ad88132473ea03cd6de20c85ab/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=fb2b9c7212b8a8ad88132473ea03cd6de20c85ab", "patch": "@@ -304,6 +304,7 @@ pub use hir_expand::name as __name;\n #[macro_export]\n macro_rules! __known_path {\n     (core::iter::IntoIterator) => {};\n+    (core::iter::Iterator) => {};\n     (core::result::Result) => {};\n     (core::option::Option) => {};\n     (core::ops::Range) => {};"}, {"sha": "c7609e90d98016d75232a88a4e448a8c7f50dcd5", "filename": "crates/hir_expand/src/name.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb2b9c7212b8a8ad88132473ea03cd6de20c85ab/crates%2Fhir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2b9c7212b8a8ad88132473ea03cd6de20c85ab/crates%2Fhir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fname.rs?ref=fb2b9c7212b8a8ad88132473ea03cd6de20c85ab", "patch": "@@ -186,6 +186,9 @@ pub mod known {\n         Neg,\n         Not,\n         Index,\n+        // Components of known path (function name)\n+        filter_map,\n+        next,\n         // Builtin macros\n         file,\n         column,"}, {"sha": "323c5f96308e003edd4b17803301a56eca5b2749", "filename": "crates/hir_ty/src/diagnostics.rs", "status": "modified", "additions": 112, "deletions": 4, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/fb2b9c7212b8a8ad88132473ea03cd6de20c85ab/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2b9c7212b8a8ad88132473ea03cd6de20c85ab/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs?ref=fb2b9c7212b8a8ad88132473ea03cd6de20c85ab", "patch": "@@ -247,7 +247,7 @@ impl Diagnostic for RemoveThisSemicolon {\n \n // Diagnostic: break-outside-of-loop\n //\n-// This diagnostic is triggered if `break` keyword is used outside of a loop.\n+// This diagnostic is triggered if the `break` keyword is used outside of a loop.\n #[derive(Debug)]\n pub struct BreakOutsideOfLoop {\n     pub file: HirFileId,\n@@ -271,7 +271,7 @@ impl Diagnostic for BreakOutsideOfLoop {\n \n // Diagnostic: missing-unsafe\n //\n-// This diagnostic is triggered if operation marked as `unsafe` is used outside of `unsafe` function or block.\n+// This diagnostic is triggered if an operation marked as `unsafe` is used outside of an `unsafe` function or block.\n #[derive(Debug)]\n pub struct MissingUnsafe {\n     pub file: HirFileId,\n@@ -295,7 +295,7 @@ impl Diagnostic for MissingUnsafe {\n \n // Diagnostic: mismatched-arg-count\n //\n-// This diagnostic is triggered if function is invoked with an incorrect amount of arguments.\n+// This diagnostic is triggered if a function is invoked with an incorrect amount of arguments.\n #[derive(Debug)]\n pub struct MismatchedArgCount {\n     pub file: HirFileId,\n@@ -347,7 +347,7 @@ impl fmt::Display for CaseType {\n \n // Diagnostic: incorrect-ident-case\n //\n-// This diagnostic is triggered if item name doesn't follow https://doc.rust-lang.org/1.0.0/style/style/naming/README.html[Rust naming convention].\n+// This diagnostic is triggered if an item name doesn't follow https://doc.rust-lang.org/1.0.0/style/style/naming/README.html[Rust naming convention].\n #[derive(Debug)]\n pub struct IncorrectCase {\n     pub file: HirFileId,\n@@ -386,6 +386,31 @@ impl Diagnostic for IncorrectCase {\n     }\n }\n \n+// Diagnostic: replace-filter-map-next-with-find-map\n+//\n+// This diagnostic is triggered when `.filter_map(..).next()` is used, rather than the more concise `.find_map(..)`.\n+#[derive(Debug)]\n+pub struct ReplaceFilterMapNextWithFindMap {\n+    pub file: HirFileId,\n+    /// This expression is the whole method chain up to and including `.filter_map(..).next()`.\n+    pub next_expr: AstPtr<ast::Expr>,\n+}\n+\n+impl Diagnostic for ReplaceFilterMapNextWithFindMap {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"replace-filter-map-next-with-find-map\")\n+    }\n+    fn message(&self) -> String {\n+        \"replace filter_map(..).next() with find_map(..)\".to_string()\n+    }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.next_expr.clone().into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use base_db::{fixture::WithFixture, FileId, SourceDatabase, SourceDatabaseExt};\n@@ -644,4 +669,87 @@ fn foo() { break; }\n             \"#,\n         );\n     }\n+\n+    // Register the required standard library types to make the tests work\n+    fn add_filter_map_with_find_next_boilerplate(body: &str) -> String {\n+        let prefix = r#\"\n+        //- /main.rs crate:main deps:core\n+        use core::iter::Iterator;\n+        use core::option::Option::{self, Some, None};\n+        \"#;\n+        let suffix = r#\"\n+        //- /core/lib.rs crate:core\n+        pub mod option {\n+            pub enum Option<T> { Some(T), None }\n+        }\n+        pub mod iter {\n+            pub trait Iterator {\n+                type Item;\n+                fn filter_map<B, F>(self, f: F) -> FilterMap where F: FnMut(Self::Item) -> Option<B> { FilterMap }\n+                fn next(&mut self) -> Option<Self::Item>;\n+            }\n+            pub struct FilterMap {}\n+            impl Iterator for FilterMap {\n+                type Item = i32;\n+                fn next(&mut self) -> i32 { 7 }\n+            }\n+        }\n+        \"#;\n+        format!(\"{}{}{}\", prefix, body, suffix)\n+    }\n+\n+    #[test]\n+    fn replace_filter_map_next_with_find_map2() {\n+        check_diagnostics(&add_filter_map_with_find_next_boilerplate(\n+            r#\"\n+            fn foo() {\n+                let m = [1, 2, 3].iter().filter_map(|x| if *x == 2 { Some (4) } else { None }).next();\n+                      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ replace filter_map(..).next() with find_map(..)\n+            }\n+        \"#,\n+        ));\n+    }\n+\n+    #[test]\n+    fn replace_filter_map_next_with_find_map_no_diagnostic_without_next() {\n+        check_diagnostics(&add_filter_map_with_find_next_boilerplate(\n+            r#\"\n+            fn foo() {\n+                let m = [1, 2, 3]\n+                    .iter()\n+                    .filter_map(|x| if *x == 2 { Some (4) } else { None })\n+                    .len();\n+            }\n+            \"#,\n+        ));\n+    }\n+\n+    #[test]\n+    fn replace_filter_map_next_with_find_map_no_diagnostic_with_intervening_methods() {\n+        check_diagnostics(&add_filter_map_with_find_next_boilerplate(\n+            r#\"\n+            fn foo() {\n+                let m = [1, 2, 3]\n+                    .iter()\n+                    .filter_map(|x| if *x == 2 { Some (4) } else { None })\n+                    .map(|x| x + 2)\n+                    .len();\n+            }\n+            \"#,\n+        ));\n+    }\n+\n+    #[test]\n+    fn replace_filter_map_next_with_find_map_no_diagnostic_if_not_in_chain() {\n+        check_diagnostics(&add_filter_map_with_find_next_boilerplate(\n+            r#\"\n+            fn foo() {\n+                let m = [1, 2, 3]\n+                    .iter()\n+                    .filter_map(|x| if *x == 2 { Some (4) } else { None });\n+                let n = m.next();\n+            }\n+            \"#,\n+        ));\n+    }\n }"}, {"sha": "d740b7265554d194d84ed76f6885f6341eab27e3", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 74, "deletions": 11, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/fb2b9c7212b8a8ad88132473ea03cd6de20c85ab/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2b9c7212b8a8ad88132473ea03cd6de20c85ab/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=fb2b9c7212b8a8ad88132473ea03cd6de20c85ab", "patch": "@@ -2,8 +2,10 @@\n \n use std::sync::Arc;\n \n-use hir_def::{expr::Statement, path::path, resolver::HasResolver, AdtId, DefWithBodyId};\n-use hir_expand::diagnostics::DiagnosticSink;\n+use hir_def::{\n+    expr::Statement, path::path, resolver::HasResolver, AdtId, AssocItemId, DefWithBodyId,\n+};\n+use hir_expand::{diagnostics::DiagnosticSink, name};\n use rustc_hash::FxHashSet;\n use syntax::{ast, AstPtr};\n \n@@ -24,6 +26,8 @@ pub(crate) use hir_def::{\n     LocalFieldId, VariantId,\n };\n \n+use super::ReplaceFilterMapNextWithFindMap;\n+\n pub(super) struct ExprValidator<'a, 'b: 'a> {\n     owner: DefWithBodyId,\n     infer: Arc<InferenceResult>,\n@@ -40,6 +44,8 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n     }\n \n     pub(super) fn validate_body(&mut self, db: &dyn HirDatabase) {\n+        self.check_for_filter_map_next(db);\n+\n         let body = db.body(self.owner.into());\n \n         for (id, expr) in body.exprs.iter() {\n@@ -150,20 +156,76 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         }\n     }\n \n-    fn validate_call(&mut self, db: &dyn HirDatabase, call_id: ExprId, expr: &Expr) -> Option<()> {\n+    fn check_for_filter_map_next(&mut self, db: &dyn HirDatabase) {\n+        // Find the FunctionIds for Iterator::filter_map and Iterator::next\n+        let iterator_path = path![core::iter::Iterator];\n+        let resolver = self.owner.resolver(db.upcast());\n+        let iterator_trait_id = match resolver.resolve_known_trait(db.upcast(), &iterator_path) {\n+            Some(id) => id,\n+            None => return,\n+        };\n+        let iterator_trait_items = &db.trait_data(iterator_trait_id).items;\n+        let filter_map_function_id =\n+            match iterator_trait_items.iter().find(|item| item.0 == name![filter_map]) {\n+                Some((_, AssocItemId::FunctionId(id))) => id,\n+                _ => return,\n+            };\n+        let next_function_id = match iterator_trait_items.iter().find(|item| item.0 == name![next])\n+        {\n+            Some((_, AssocItemId::FunctionId(id))) => id,\n+            _ => return,\n+        };\n+\n+        // Search function body for instances of .filter_map(..).next()\n+        let body = db.body(self.owner.into());\n+        let mut prev = None;\n+        for (id, expr) in body.exprs.iter() {\n+            if let Expr::MethodCall { receiver, .. } = expr {\n+                let function_id = match self.infer.method_resolution(id) {\n+                    Some(id) => id,\n+                    None => continue,\n+                };\n+\n+                if function_id == *filter_map_function_id {\n+                    prev = Some(id);\n+                    continue;\n+                }\n+\n+                if function_id == *next_function_id {\n+                    if let Some(filter_map_id) = prev {\n+                        if *receiver == filter_map_id {\n+                            let (_, source_map) = db.body_with_source_map(self.owner.into());\n+                            if let Ok(next_source_ptr) = source_map.expr_syntax(id) {\n+                                self.sink.push(ReplaceFilterMapNextWithFindMap {\n+                                    file: next_source_ptr.file_id,\n+                                    next_expr: next_source_ptr.value,\n+                                });\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            prev = None;\n+        }\n+    }\n+\n+    fn validate_call(&mut self, db: &dyn HirDatabase, call_id: ExprId, expr: &Expr) {\n         // Check that the number of arguments matches the number of parameters.\n \n         // FIXME: Due to shortcomings in the current type system implementation, only emit this\n         // diagnostic if there are no type mismatches in the containing function.\n         if self.infer.type_mismatches.iter().next().is_some() {\n-            return None;\n+            return;\n         }\n \n         let is_method_call = matches!(expr, Expr::MethodCall { .. });\n         let (sig, args) = match expr {\n             Expr::Call { callee, args } => {\n                 let callee = &self.infer.type_of_expr[*callee];\n-                let sig = callee.callable_sig(db)?;\n+                let sig = match callee.callable_sig(db) {\n+                    Some(sig) => sig,\n+                    None => return,\n+                };\n                 (sig, args.clone())\n             }\n             Expr::MethodCall { receiver, args, .. } => {\n@@ -175,22 +237,25 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n                     // if the receiver is of unknown type, it's very likely we\n                     // don't know enough to correctly resolve the method call.\n                     // This is kind of a band-aid for #6975.\n-                    return None;\n+                    return;\n                 }\n \n                 // FIXME: note that we erase information about substs here. This\n                 // is not right, but, luckily, doesn't matter as we care only\n                 // about the number of params\n-                let callee = self.infer.method_resolution(call_id)?;\n+                let callee = match self.infer.method_resolution(call_id) {\n+                    Some(callee) => callee,\n+                    None => return,\n+                };\n                 let sig = db.callable_item_signature(callee.into()).value;\n \n                 (sig, args)\n             }\n-            _ => return None,\n+            _ => return,\n         };\n \n         if sig.is_varargs {\n-            return None;\n+            return;\n         }\n \n         let params = sig.params();\n@@ -213,8 +278,6 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n                 });\n             }\n         }\n-\n-        None\n     }\n \n     fn validate_match("}, {"sha": "8607139ba3cbb1d9190b2b8be7dec21545a22f55", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb2b9c7212b8a8ad88132473ea03cd6de20c85ab/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2b9c7212b8a8ad88132473ea03cd6de20c85ab/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=fb2b9c7212b8a8ad88132473ea03cd6de20c85ab", "patch": "@@ -136,6 +136,9 @@ pub(crate) fn diagnostics(\n         .on::<hir::diagnostics::IncorrectCase, _>(|d| {\n             res.borrow_mut().push(warning_with_fix(d, &sema));\n         })\n+        .on::<hir::diagnostics::ReplaceFilterMapNextWithFindMap, _>(|d| {\n+            res.borrow_mut().push(warning_with_fix(d, &sema));\n+        })\n         .on::<hir::diagnostics::InactiveCode, _>(|d| {\n             // If there's inactive code somewhere in a macro, don't propagate to the call-site.\n             if d.display_source().file_id.expansion_info(db).is_some() {"}, {"sha": "cbfc66ab3c0fa1bb34d10c55fef1598ead5edbb3", "filename": "crates/ide/src/diagnostics/fixes.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fb2b9c7212b8a8ad88132473ea03cd6de20c85ab/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb2b9c7212b8a8ad88132473ea03cd6de20c85ab/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs?ref=fb2b9c7212b8a8ad88132473ea03cd6de20c85ab", "patch": "@@ -4,7 +4,7 @@ use hir::{\n     db::AstDatabase,\n     diagnostics::{\n         Diagnostic, IncorrectCase, MissingFields, MissingOkOrSomeInTailExpr, NoSuchField,\n-        RemoveThisSemicolon, UnresolvedModule,\n+        RemoveThisSemicolon, ReplaceFilterMapNextWithFindMap, UnresolvedModule,\n     },\n     HasSource, HirDisplay, InFile, Semantics, VariantDef,\n };\n@@ -15,8 +15,8 @@ use ide_db::{\n };\n use syntax::{\n     algo,\n-    ast::{self, edit::IndentLevel, make},\n-    AstNode,\n+    ast::{self, edit::IndentLevel, make, ArgListOwner},\n+    AstNode, TextRange,\n };\n use text_edit::TextEdit;\n \n@@ -144,6 +144,33 @@ impl DiagnosticWithFix for IncorrectCase {\n     }\n }\n \n+impl DiagnosticWithFix for ReplaceFilterMapNextWithFindMap {\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Fix> {\n+        let root = sema.db.parse_or_expand(self.file)?;\n+        let next_expr = self.next_expr.to_node(&root);\n+        let next_call = ast::MethodCallExpr::cast(next_expr.syntax().clone())?;\n+\n+        let filter_map_call = ast::MethodCallExpr::cast(next_call.receiver()?.syntax().clone())?;\n+        let filter_map_name_range = filter_map_call.name_ref()?.ident_token()?.text_range();\n+        let filter_map_args = filter_map_call.arg_list()?;\n+\n+        let range_to_replace =\n+            TextRange::new(filter_map_name_range.start(), next_expr.syntax().text_range().end());\n+        let replacement = format!(\"find_map{}\", filter_map_args.syntax().text());\n+        let trigger_range = next_expr.syntax().text_range();\n+\n+        let edit = TextEdit::replace(range_to_replace, replacement);\n+\n+        let source_change = SourceChange::from_text_edit(self.file.original_file(sema.db), edit);\n+\n+        Some(Fix::new(\n+            \"Replace filter_map(..).next() with find_map()\",\n+            source_change,\n+            trigger_range,\n+        ))\n+    }\n+}\n+\n fn missing_record_expr_field_fix(\n     sema: &Semantics<RootDatabase>,\n     usage_file_id: FileId,"}]}