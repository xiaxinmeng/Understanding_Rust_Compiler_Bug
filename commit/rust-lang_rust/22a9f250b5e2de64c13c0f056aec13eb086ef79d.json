{"sha": "22a9f250b5e2de64c13c0f056aec13eb086ef79d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyYTlmMjUwYjVlMmRlNjRjMTNjMGYwNTZhZWMxM2ViMDg2ZWY3OWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-17T21:33:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-17T21:33:15Z"}, "message": "auto merge of #19958 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "d996edc2a0a259556be226b4f60437f961fb09b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d996edc2a0a259556be226b4f60437f961fb09b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22a9f250b5e2de64c13c0f056aec13eb086ef79d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22a9f250b5e2de64c13c0f056aec13eb086ef79d", "html_url": "https://github.com/rust-lang/rust/commit/22a9f250b5e2de64c13c0f056aec13eb086ef79d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22a9f250b5e2de64c13c0f056aec13eb086ef79d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66c297d847ce06a8982d4d322221b17a3cd04f90", "url": "https://api.github.com/repos/rust-lang/rust/commits/66c297d847ce06a8982d4d322221b17a3cd04f90", "html_url": "https://github.com/rust-lang/rust/commit/66c297d847ce06a8982d4d322221b17a3cd04f90"}, {"sha": "5c98952409c9123b5f26b3c620029cd1914a07b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c98952409c9123b5f26b3c620029cd1914a07b6", "html_url": "https://github.com/rust-lang/rust/commit/5c98952409c9123b5f26b3c620029cd1914a07b6"}], "stats": {"total": 3796, "additions": 2330, "deletions": 1466}, "files": [{"sha": "6cd704b3703760d0ab5599e5098dd3a02e8fbce8", "filename": ".gitmodules", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -11,3 +11,6 @@\n [submodule \"src/jemalloc\"]\n \tpath = src/jemalloc\n \turl = https://github.com/rust-lang/jemalloc.git\n+[submodule \"src/rust-installer\"]\n+\tpath = src/rust-installer\n+\turl = https://github.com/rust-lang/rust-installer"}, {"sha": "c7a3406a9e746e2f9329c479f4fed02904b95980", "filename": "mk/ctags.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/mk%2Fctags.mk", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/mk%2Fctags.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fctags.mk?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -27,7 +27,7 @@ CTAGS_LOCATIONS=$(patsubst ${CFG_SRC_DIR}src/llvm,, \\\n \t\t\t\t$(patsubst ${CFG_SRC_DIR}src/rt/msvc,, \\\n \t\t\t\t$(patsubst ${CFG_SRC_DIR}src/rt/vg,, \\\n \t\t\t\t$(wildcard ${CFG_SRC_DIR}src/*) $(wildcard ${CFG_SRC_DIR}src/rt/*) \\\n-\t\t\t\t)))))))))\n+\t\t\t\t))))))))\n CTAGS_OPTS=--options=\"${CFG_SRC_DIR}src/etc/ctags.rust\" --languages=-javascript --recurse ${CTAGS_LOCATIONS}\n # We could use `--languages=Rust`, but there is value in producing tags for the\n # C++ parts of the code base too (at the time of writing, those are .h and .cpp"}, {"sha": "2db26f819dfdf2a27f9da1adac5d179b379c6fe7", "filename": "mk/dist.mk", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -58,6 +58,7 @@ PKG_FILES := \\\n       rt                                       \\\n       rustllvm                                 \\\n       snapshots.txt                            \\\n+      rust-installer                           \\\n       test)                                    \\\n     $(PKG_GITMODULES)                          \\\n     $(filter-out config.stamp, \\\n@@ -209,33 +210,40 @@ distcheck-osx: dist-osx\n # Unix binary installer tarballs\n ######################################################################\n \n+NON_INSTALLED_PREFIXES=COPYRIGHT,LICENSE-APACHE,LICENSE-MIT,README.md,doc\n+\n define DEF_INSTALLER\n \n $$(eval $$(call DEF_PREPARE,dir-$(1)))\n \n dist-install-dir-$(1): PREPARE_HOST=$(1)\n dist-install-dir-$(1): PREPARE_TARGETS=$(2)\n-dist-install-dir-$(1): PREPARE_DEST_DIR=tmp/dist/$$(PKG_NAME)-$(1)\n+dist-install-dir-$(1): PREPARE_DEST_DIR=tmp/dist/$$(PKG_NAME)-$(1)-image\n dist-install-dir-$(1): PREPARE_DIR_CMD=$(DEFAULT_PREPARE_DIR_CMD)\n dist-install-dir-$(1): PREPARE_BIN_CMD=$(DEFAULT_PREPARE_BIN_CMD)\n dist-install-dir-$(1): PREPARE_LIB_CMD=$(DEFAULT_PREPARE_LIB_CMD)\n dist-install-dir-$(1): PREPARE_MAN_CMD=$(DEFAULT_PREPARE_MAN_CMD)\n dist-install-dir-$(1): PREPARE_CLEAN=true\n dist-install-dir-$(1): prepare-base-dir-$(1) docs compiler-docs\n-\t$$(Q)(cd $$(PREPARE_DEST_DIR)/ && find . -type f | sed 's/^\\.\\///') \\\n-      > tmp/dist/manifest-$(1).in\n-\t$$(Q)mv tmp/dist/manifest-$(1).in $$(PREPARE_DEST_DIR)/$$(CFG_LIBDIR_RELATIVE)/rustlib/manifest.in\n-# Add remaining non-installed files\n \t$$(Q)$$(PREPARE_MAN_CMD) $$(S)COPYRIGHT $$(PREPARE_DEST_DIR)\n \t$$(Q)$$(PREPARE_MAN_CMD) $$(S)LICENSE-APACHE $$(PREPARE_DEST_DIR)\n \t$$(Q)$$(PREPARE_MAN_CMD) $$(S)LICENSE-MIT $$(PREPARE_DEST_DIR)\n \t$$(Q)$$(PREPARE_MAN_CMD) $$(S)README.md $$(PREPARE_DEST_DIR)\n \t$$(Q)cp -r doc $$(PREPARE_DEST_DIR)\n-\t$$(Q)$$(PREPARE_BIN_CMD) $$(S)src/etc/install.sh $$(PREPARE_DEST_DIR)\n \n dist/$$(PKG_NAME)-$(1).tar.gz: dist-install-dir-$(1)\n \t@$(call E, build: $$@)\n-\t$$(Q)tar -czf dist/$$(PKG_NAME)-$(1).tar.gz -C tmp/dist $$(PKG_NAME)-$(1)\n+\t$$(Q)$$(S)src/rust-installer/gen-installer.sh \\\n+\t\t--product-name=Rust \\\n+\t\t--verify-bin=rustc \\\n+\t\t--rel-manifest-dir=rustlib \\\n+\t\t--success-message=Rust-is-ready-to-roll. \\\n+\t\t--image-dir=tmp/dist/$$(PKG_NAME)-$(1)-image \\\n+\t\t--work-dir=tmp/dist \\\n+\t\t--output-dir=dist \\\n+\t\t--non-installed-prefixes=$$(NON_INSTALLED_PREFIXES) \\\n+\t\t--package-name=$$(PKG_NAME)-$(1)\n+\t$$(Q)rm -R tmp/dist/$$(PKG_NAME)-$(1)-image\n \n endef\n "}, {"sha": "632df3c754b8d153efdf193e1365f7a5bfa73366", "filename": "mk/install.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/mk%2Finstall.mk", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/mk%2Finstall.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Finstall.mk?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -25,7 +25,7 @@ endif\n # Remove tmp files because it's a decent amount of disk space\n \t$(Q)rm -R tmp/dist\n \n-prepare_install: dist-install-dir-$(CFG_BUILD) | tmp/empty_dir\n+prepare_install: dist/$(PKG_NAME)-$(CFG_BUILD).tar.gz | tmp/empty_dir\n \n uninstall:\n ifeq (root user, $(USER) $(patsubst %,user,$(SUDO_USER)))\n@@ -38,7 +38,7 @@ endif\n # Remove tmp files because it's a decent amount of disk space\n \t$(Q)rm -R tmp/dist\n \n-prepare_uninstall: dist-install-dir-$(CFG_BUILD) | tmp/empty_dir\n+prepare_uninstall: dist/$(PKG_NAME)-$(CFG_BUILD).tar.gz | tmp/empty_dir\n \n .PHONY: install prepare_install uninstall prepare_uninstall\n "}, {"sha": "59be0152d587660111dd391f0de0d742c395c8d3", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -394,7 +394,7 @@ fn extract_gdb_version(full_version_line: Option<String>) -> Option<String> {\n \n             match re.captures(full_version_line) {\n                 Some(captures) => {\n-                    Some(captures.at(2).to_string())\n+                    Some(captures.at(2).unwrap_or(\"\").to_string())\n                 }\n                 None => {\n                     println!(\"Could not extract GDB version from line '{}'\",\n@@ -428,7 +428,7 @@ fn extract_lldb_version(full_version_line: Option<String>) -> Option<String> {\n \n             match re.captures(full_version_line) {\n                 Some(captures) => {\n-                    Some(captures.at(1).to_string())\n+                    Some(captures.at(1).unwrap_or(\"\").to_string())\n                 }\n                 None => {\n                     println!(\"Could not extract LLDB version from line '{}'\","}, {"sha": "b7df43aabdd2093b9b6462970cdb30bff074bdf6", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -66,10 +66,10 @@ fn parse_expected(last_nonfollow_error: Option<uint>,\n                   line: &str,\n                   re: &Regex) -> Option<(WhichLine, ExpectedError)> {\n     re.captures(line).and_then(|caps| {\n-        let adjusts = caps.name(\"adjusts\").len();\n-        let kind = caps.name(\"kind\").to_ascii_lower();\n-        let msg = caps.name(\"msg\").trim().to_string();\n-        let follow = caps.name(\"follow\").len() > 0;\n+        let adjusts = caps.name(\"adjusts\").unwrap_or(\"\").len();\n+        let kind = caps.name(\"kind\").unwrap_or(\"\").to_ascii_lower();\n+        let msg = caps.name(\"msg\").unwrap_or(\"\").trim().to_string();\n+        let follow = caps.name(\"follow\").unwrap_or(\"\").len() > 0;\n \n         let (which, line) = if follow {\n             assert!(adjusts == 0, \"use either //~| or //~^, not both.\");"}, {"sha": "9e73863239fbc06b05e807f243b7bb65d99d7cf5", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -24,7 +24,7 @@ Some examples that demonstrate different aspects of the language:\n [HashMap]: https://github.com/rust-lang/rust/blob/master/src/libcollections/hashmap.rs\n [json]: https://github.com/rust-lang/rust/blob/master/src/libserialize/json.rs\n \n-You may also be interested in browsing [GitHub's Rust][github-rust] page.\n+You may also be interested in browsing [trending Rust repositories][github-rust] on GitHub.\n \n [github-rust]: https://github.com/trending?l=rust\n \n@@ -42,7 +42,7 @@ Let the fact that this is an easily countable number be a warning.\n \n ## Does it run on Windows?\n \n-Yes. All development happens in lock-step on all 3 target platforms. Using MinGW, not Cygwin. Note that the windows implementation currently has some limitations: in particular 64-bit build is [not fully supported yet][win64], and all executables created by rustc [depend on libgcc DLL at runtime][libgcc].\n+Yes. All development happens in lockstep on all 3 target platforms (using MinGW, not Cygwin). Note that the Windows implementation currently has some limitations; in particular, the 64-bit build is [not fully supported yet][win64], and all executables created by rustc [depend on libgcc DLL at runtime][libgcc].\n \n [win64]: https://github.com/rust-lang/rust/issues/1237\n [libgcc]: https://github.com/rust-lang/rust/issues/11782\n@@ -104,7 +104,7 @@ Similar to the reasoning about default-sync: it wires fewer assumptions into the\n \n ## Why are strings UTF-8 by default? Why not UCS2 or UCS4?\n \n-The `str` type is UTF-8 because we observe more text in the wild in this encoding -- particularly in network transmissions, which are endian-agnostic -- and we think it's best that the default treatment of I/O not involve having to recode codepoints in each direction.\n+The `str` type is UTF-8 because we observe more text in the wild in this encoding \u2013 particularly in network transmissions, which are endian-agnostic \u2013 and we think it's best that the default treatment of I/O not involve having to recode codepoints in each direction.\n \n This does mean that indexed access to a Unicode codepoint inside a `str` value is an O(n) operation. On the one hand, this is clearly undesirable; on the other hand, this problem is full of trade-offs and we'd like to point a few important qualifications:\n \n@@ -145,23 +145,27 @@ For simplicity, we do not plan to do so. Implementing automatic semicolon insert\n \n ## How do I get my program to display the output of logging macros?\n \n-**Short answer** set the RUST_LOG environment variable to the name of your source file, sans extension.\n+**Short Answer**: Set the `RUST_LOG` environment variable to the name of your source file, sans extension.\n \n ```sh\n rustc hello.rs\n export RUST_LOG=hello\n ./hello\n ```\n \n-**Long answer** RUST_LOG takes a 'logging spec' that consists of a\n+**Long Answer**: `RUST_LOG` takes a 'logging spec' that consists of a\n comma-separated list of paths, where a path consists of the crate name and\n-sequence of module names, each separated by double-colons. For standalone .rs\n-files the crate is implicitly named after the source file, so in the above\n-example we were setting RUST_LOG to the name of the hello crate. Multiple paths\n+sequence of module names, each separated by double-colons. For standalone `.rs`\n+files, the crate is implicitly named after the source file, so in the above\n+example we were setting `RUST_LOG` to the name of the hello crate. Multiple paths\n can be combined to control the exact logging you want to see. For example, when\n-debugging linking in the compiler you might set\n-`RUST_LOG=rustc::metadata::creader,rustc::util::filesearch,rustc::back::rpath`\n-For a full description see [the logging crate][1].\n+debugging linking in the compiler, you might set the following:\n+\n+```sh\n+RUST_LOG=rustc::metadata::creader,rustc::util::filesearch,rustc::back::rpath\n+```\n+\n+For a full description, see [the logging crate][1].\n \n ## How fast is Rust?\n \n@@ -172,6 +176,6 @@ performance.\n That said, it is an explicit goal of Rust to be as fast as C++ for most things.\n Language decisions are made with performance in mind, and we want Rust to be as\n fast as possible. Given that Rust is built on top of LLVM, any performance\n-improvements in it also help us be faster.\n+improvements in it also help Rust become faster.\n \n [1]:log/index.html"}, {"sha": "a7f4d103aca14b5d0ba30cc06612db26eadac092", "filename": "src/doc/guide-macros.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fdoc%2Fguide-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fdoc%2Fguide-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-macros.md?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -195,7 +195,7 @@ early_return!(input_2, [T::SpecialB]);\n As the above example demonstrates, `$(...)*` is also valid on the right-hand\n side of a macro definition. The behavior of `*` in transcription,\n especially in cases where multiple `*`s are nested, and multiple different\n-names are involved, can seem somewhat magical and intuitive at first. The\n+names are involved, can seem somewhat magical and unintuitive at first. The\n system that interprets them is called \"Macro By Example\". The two rules to\n keep in mind are (1) the behavior of `$(...)*` is to walk through one \"layer\"\n of repetitions for all of the `$name`s it contains in lockstep, and (2) each"}, {"sha": "1a46970414371fb8708a2cf50d06134cb5110af2", "filename": "src/doc/guide-ownership.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fdoc%2Fguide-ownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fdoc%2Fguide-ownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ownership.md?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -341,7 +341,7 @@ fn main() {\n     {                         //  |\n         let y = &5i;          // ---+ y goes into scope\n         let f = Foo { x: y }; // ---+ f goes into scope\n-\tx = &f.x;\t      //  | | error here\n+        x = &f.x;             //  | | error here\n     }                         // ---+ f & y go out of scope\n                               //  |\n     println!(\"{}\", x);        //  |\n@@ -416,7 +416,7 @@ note: `car` moved here because it has type `Car`, which is non-copyable\n ```\n \n We need our `Car` to be pointed to by multiple `Wheel`s. We can't do that with\n-`Box<T>`, because it has a single owner. We can do t with `Rc<T>` instead:\n+`Box<T>`, because it has a single owner. We can do it with `Rc<T>` instead:\n \n ```rust\n use std::rc::Rc;"}, {"sha": "682c89fcc53fcc73bd3646247c970a8f41d2c0eb", "filename": "src/doc/guide-testing.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fdoc%2Fguide-testing.md", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fdoc%2Fguide-testing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-testing.md?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -357,7 +357,7 @@ Let's finally check out that third section: documentation tests.\n \n Nothing is better than documentation with examples. Nothing is worse than\n examples that don't actually work, because the code has changed since the\n-documentation has been written. To this end, Rust supports automaticaly\n+documentation has been written. To this end, Rust supports automatically\n running examples in your documentation. Here's a fleshed-out `src/lib.rs`\n with examples:\n "}, {"sha": "08d2c5bf978064fa14a5df31b84f7055adaa3c57", "filename": "src/doc/guide.md", "status": "modified", "additions": 48, "deletions": 28, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -418,6 +418,19 @@ let x: int = 5;\n If I asked you to read this out loud to the rest of the class, you'd say \"`x`\n is a binding with the type `int` and the value `five`.\"\n \n+In future examples, we may annotate the type in a comment. The examples will\n+look like this:\n+\n+```{rust}\n+fn main() {\n+    let x = 5i; // x: int\n+}\n+```\n+\n+Note the similarities between this annotation and the syntax you use with `let`.\n+Including these kinds of comments is not idiomatic Rust, but we'll occasionally\n+include them to help you understand what the types that Rust infers are.\n+\n By default, bindings are **immutable**. This code will not compile:\n \n ```{ignore}\n@@ -436,7 +449,7 @@ error: re-assignment of immutable variable `x`\n If you want a binding to be mutable, you can use `mut`:\n \n ```{rust}\n-let mut x = 5i;\n+let mut x = 5i; // mut x: int\n x = 10i;\n ```\n \n@@ -538,7 +551,7 @@ format in a more detailed manner, there are a [wide number of options\n available](std/fmt/index.html). For now, we'll just stick to the default:\n integers aren't very complicated to print.\n \n-# If\n+# `if`\n \n Rust's take on `if` is not particularly complex, but it's much more like the\n `if` you'll find in a dynamically typed language than in a more traditional\n@@ -584,15 +597,15 @@ let y = if x == 5i {\n     10i\n } else {\n     15i\n-};\n+}; // y: int\n ```\n \n Which we can (and probably should) write like this:\n \n ```{rust}\n let x = 5i;\n \n-let y = if x == 5i { 10i } else { 15i };\n+let y = if x == 5i { 10i } else { 15i }; // y: int\n ```\n \n This reveals two interesting things about Rust: it is an expression-based\n@@ -928,8 +941,8 @@ destructuring. You can assign one tuple into another, if they have the same\n arity and contained types.\n \n ```rust\n-let mut x = (1i, 2i);\n-let y = (2i, 3i);\n+let mut x = (1i, 2i); // x: (int, int)\n+let y = (2i, 3i);     // y: (int, int)\n \n x = y;\n ```\n@@ -981,7 +994,7 @@ struct Point {\n }\n \n fn main() {\n-    let origin = Point { x: 0i, y: 0i };\n+    let origin = Point { x: 0i, y: 0i }; // origin: Point\n \n     println!(\"The origin is at ({}, {})\", origin.x, origin.y);\n }\n@@ -1101,7 +1114,7 @@ fn main() {\n     let x = 5i;\n     let y = 10i;\n \n-    let ordering = cmp(x, y);\n+    let ordering = cmp(x, y); // ordering: Ordering\n \n     if ordering == Less {\n         println!(\"less\");\n@@ -1388,7 +1401,7 @@ Instead, it looks like this:\n \n ```{rust}\n for x in range(0i, 10i) {\n-    println!(\"{}\", x);\n+    println!(\"{}\", x); // x: int\n }\n ```\n \n@@ -1423,8 +1436,8 @@ The other kind of looping construct in Rust is the `while` loop. It looks like\n this:\n \n ```{rust}\n-let mut x = 5u;\n-let mut done = false;\n+let mut x = 5u;       // mut x: uint\n+let mut done = false; // mut done: bool\n \n while !done {\n     x += x - 3;\n@@ -1520,7 +1533,7 @@ The first kind is a `&str`. This is pronounced a 'string slice.' String literals\n are of the type `&str`:\n \n ```{rust}\n-let string = \"Hello there.\";\n+let string = \"Hello there.\"; // string: &str\n ```\n \n This string is statically allocated, meaning that it's saved inside our\n@@ -1532,7 +1545,7 @@ A `String`, on the other hand, is an in-memory string.  This string is\n growable, and is also guaranteed to be UTF-8.\n \n ```{rust}\n-let mut s = \"Hello\".to_string();\n+let mut s = \"Hello\".to_string(); // mut s: String\n println!(\"{}\", s);\n \n s.push_str(\", world.\");\n@@ -1588,16 +1601,19 @@ things. The most basic is the **array**, a fixed-size list of elements of the\n same type. By default, arrays are immutable.\n \n ```{rust}\n-let a = [1i, 2i, 3i];\n-let mut m = [1i, 2i, 3i];\n+let a = [1i, 2i, 3i];     // a: [int, ..3]\n+let mut m = [1i, 2i, 3i]; // mut m: [int, ..3]\n ```\n \n You can create an array with a given number of elements, all initialized to the\n same value, with `[val, ..N]` syntax. The compiler ensures that arrays are\n always initialized.\n \n+There's a shorthand for initializing each element of an array to the same\n+value. In this example, each element of `a` will be initialized to `0i`:\n+\n ```{rust}\n-let a = [0i, ..20];  // Shorthand for array of 20 elements all initialized to 0\n+let a = [0i, ..20]; // a: [int, ..20]\n ```\n \n Arrays have type `[T,..N]`. We'll talk about this `T` notation later, when we\n@@ -1608,7 +1624,7 @@ You can get the number of elements in an array `a` with `a.len()`, and use\n number in order:\n \n ```{rust}\n-let a = [1i, 2, 3];     // Only the first item needs a type suffix\n+let a = [1i, 2, 3]; // Only the first item needs a type suffix\n \n println!(\"a has {} elements\", a.len());\n for e in a.iter() {\n@@ -1619,7 +1635,7 @@ for e in a.iter() {\n You can access a particular element of an array with **subscript notation**:\n \n ```{rust}\n-let names = [\"Graydon\", \"Brian\", \"Niko\"];\n+let names = [\"Graydon\", \"Brian\", \"Niko\"]; // names: [&str, 3]\n \n println!(\"The second name is: {}\", names[1]);\n ```\n@@ -1637,7 +1653,7 @@ later). Vectors are to arrays what `String` is to `&str`. You can create them\n with the `vec!` macro:\n \n ```{rust}\n-let v = vec![1i, 2, 3];\n+let v = vec![1i, 2, 3]; // v: Vec<int>\n ```\n \n (Notice that unlike the `println!` macro we've used in the past, we use square\n@@ -1648,8 +1664,10 @@ You can get the length of, iterate over, and subscript vectors just like\n arrays. In addition, (mutable) vectors can grow automatically:\n \n ```{rust}\n-let mut nums = vec![1i, 2, 3];\n+let mut nums = vec![1i, 2, 3]; // mut nums: Vec<int>\n+\n nums.push(4);\n+\n println!(\"The length of nums is now {}\", nums.len());   // Prints 4\n ```\n \n@@ -1823,10 +1841,12 @@ use std::io;\n fn main() {\n     println!(\"Type something!\");\n \n-    let input = io::stdin()\n-                  .read_line()\n-                  .ok()\n-                  .expect(\"Failed to read line\");\n+                                                  // here, we'll show the types at each step\n+\n+    let input = io::stdin()                       // std::io::stdio::StdinReader\n+                  .read_line()                    // IoResult<String>\n+                  .ok()                           // Option<String>\n+                  .expect(\"Failed to read line\"); // String\n \n     println!(\"{}\", input);\n }\n@@ -1969,7 +1989,7 @@ use std::rand;\n fn main() {\n     println!(\"Guess the number!\");\n \n-    let secret_number = (rand::random() % 100i) + 1i;\n+    let secret_number = (rand::random() % 100i) + 1i; // secret_number: int\n \n     println!(\"The secret number is: {}\", secret_number);\n \n@@ -2262,8 +2282,8 @@ In this case, we say `x` is a `uint` explicitly, so Rust is able to properly\n tell `random()` what to generate. In a similar fashion, both of these work:\n \n ```{rust,ignore}\n-let input_num = from_str::<uint>(\"5\");\n-let input_num: Option<uint> = from_str(\"5\");\n+let input_num = from_str::<uint>(\"5\");       // input_num: Option<uint>\n+let input_num: Option<uint> = from_str(\"5\"); // input_num: Option<uint>\n ```\n \n Anyway, with us now converting our input to a number, our code looks like this:\n@@ -4419,7 +4439,7 @@ for i in range(0u, nums.len()) {\n ```\n \n This is strictly worse than using an actual iterator. The `.iter()` method on\n-vectors returns an iterator which iterates through a reference to each element\n+vectors returns an iterator that iterates through a reference to each element\n of the vector in turn. So write this:\n \n ```{rust}"}, {"sha": "8bc48fc7934e22e9079c42197fc588be9c0c377c", "filename": "src/etc/install.sh", "status": "removed", "additions": 0, "deletions": 519, "changes": 519, "blob_url": "https://github.com/rust-lang/rust/blob/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Fetc%2Finstall.sh", "raw_url": "https://github.com/rust-lang/rust/raw/66c297d847ce06a8982d4d322221b17a3cd04f90/src%2Fetc%2Finstall.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstall.sh?ref=66c297d847ce06a8982d4d322221b17a3cd04f90", "patch": "@@ -1,519 +0,0 @@\n-#!/bin/sh\n-# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-msg() {\n-    echo \"install: $1\"\n-}\n-\n-step_msg() {\n-    msg\n-    msg \"$1\"\n-    msg\n-}\n-\n-warn() {\n-    echo \"install: WARNING: $1\"\n-}\n-\n-err() {\n-    echo \"install: error: $1\"\n-    exit 1\n-}\n-\n-need_ok() {\n-    if [ $? -ne 0 ]\n-    then\n-        err \"$1\"\n-    fi\n-}\n-\n-need_cmd() {\n-    if command -v $1 >/dev/null 2>&1\n-    then msg \"found $1\"\n-    else err \"need $1\"\n-    fi\n-}\n-\n-putvar() {\n-    local T\n-    eval T=\\$$1\n-    eval TLEN=\\${#$1}\n-    if [ $TLEN -gt 35 ]\n-    then\n-        printf \"install: %-20s := %.35s ...\\n\" $1 \"$T\"\n-    else\n-        printf \"install: %-20s := %s %s\\n\" $1 \"$T\" \"$2\"\n-    fi\n-}\n-\n-valopt() {\n-    VAL_OPTIONS=\"$VAL_OPTIONS $1\"\n-\n-    local OP=$1\n-    local DEFAULT=$2\n-    shift\n-    shift\n-    local DOC=\"$*\"\n-    if [ $HELP -eq 0 ]\n-    then\n-        local UOP=$(echo $OP | tr '[:lower:]' '[:upper:]' | tr '\\-' '\\_')\n-        local V=\"CFG_${UOP}\"\n-        eval $V=\"$DEFAULT\"\n-        for arg in $CFG_ARGS\n-        do\n-            if echo \"$arg\" | grep -q -- \"--$OP=\"\n-            then\n-                val=$(echo \"$arg\" | cut -f2 -d=)\n-                eval $V=$val\n-            fi\n-        done\n-        putvar $V\n-    else\n-        if [ -z \"$DEFAULT\" ]\n-        then\n-            DEFAULT=\"<none>\"\n-        fi\n-        OP=\"${OP}=[${DEFAULT}]\"\n-        printf \"    --%-30s %s\\n\" \"$OP\" \"$DOC\"\n-    fi\n-}\n-\n-opt() {\n-    BOOL_OPTIONS=\"$BOOL_OPTIONS $1\"\n-\n-    local OP=$1\n-    local DEFAULT=$2\n-    shift\n-    shift\n-    local DOC=\"$*\"\n-    local FLAG=\"\"\n-\n-    if [ $DEFAULT -eq 0 ]\n-    then\n-        FLAG=\"enable\"\n-    else\n-        FLAG=\"disable\"\n-        DOC=\"don't $DOC\"\n-    fi\n-\n-    if [ $HELP -eq 0 ]\n-    then\n-        for arg in $CFG_ARGS\n-        do\n-            if [ \"$arg\" = \"--${FLAG}-${OP}\" ]\n-            then\n-                OP=$(echo $OP | tr 'a-z-' 'A-Z_')\n-                FLAG=$(echo $FLAG | tr 'a-z' 'A-Z')\n-                local V=\"CFG_${FLAG}_${OP}\"\n-                eval $V=1\n-                putvar $V\n-            fi\n-        done\n-    else\n-        if [ ! -z \"$META\" ]\n-        then\n-            OP=\"$OP=<$META>\"\n-        fi\n-        printf \"    --%-30s %s\\n\" \"$FLAG-$OP\" \"$DOC\"\n-     fi\n-}\n-\n-flag() {\n-    BOOL_OPTIONS=\"$BOOL_OPTIONS $1\"\n-\n-    local OP=$1\n-    shift\n-    local DOC=\"$*\"\n-\n-    if [ $HELP -eq 0 ]\n-    then\n-        for arg in $CFG_ARGS\n-        do\n-            if [ \"$arg\" = \"--${OP}\" ]\n-            then\n-                OP=$(echo $OP | tr 'a-z-' 'A-Z_')\n-                local V=\"CFG_${OP}\"\n-                eval $V=1\n-                putvar $V\n-            fi\n-        done\n-    else\n-        if [ ! -z \"$META\" ]\n-        then\n-            OP=\"$OP=<$META>\"\n-        fi\n-        printf \"    --%-30s %s\\n\" \"$OP\" \"$DOC\"\n-     fi\n-}\n-\n-validate_opt () {\n-    for arg in $CFG_ARGS\n-    do\n-        isArgValid=0\n-        for option in $BOOL_OPTIONS\n-        do\n-            if test --disable-$option = $arg\n-            then\n-                isArgValid=1\n-            fi\n-            if test --enable-$option = $arg\n-            then\n-                isArgValid=1\n-            fi\n-            if test --$option = $arg\n-            then\n-                isArgValid=1\n-            fi\n-        done\n-        for option in $VAL_OPTIONS\n-        do\n-            if echo \"$arg\" | grep -q -- \"--$option=\"\n-            then\n-                isArgValid=1\n-            fi\n-        done\n-        if [ \"$arg\" = \"--help\" ]\n-        then\n-            echo\n-            echo \"No more help available for Configure options,\"\n-            echo \"check the Wiki or join our IRC channel\"\n-            break\n-        else\n-            if test $isArgValid -eq 0\n-            then\n-                err \"Option '$arg' is not recognized\"\n-            fi\n-        fi\n-    done\n-}\n-\n-absolutify() {\n-    FILE_PATH=\"${1}\"\n-    FILE_PATH_DIRNAME=\"$(dirname ${FILE_PATH})\"\n-    FILE_PATH_BASENAME=\"$(basename ${FILE_PATH})\"\n-    FILE_ABS_PATH=\"$(cd ${FILE_PATH_DIRNAME} && pwd)\"\n-    FILE_PATH=\"${FILE_ABS_PATH}/${FILE_PATH_BASENAME}\"\n-    # This is the return value\n-    ABSOLUTIFIED=\"${FILE_PATH}\"\n-}\n-\n-msg \"looking for install programs\"\n-need_cmd mkdir\n-need_cmd printf\n-need_cmd cut\n-need_cmd grep\n-need_cmd uname\n-need_cmd tr\n-need_cmd sed\n-\n-CFG_SRC_DIR=\"$(cd $(dirname $0) && pwd)\"\n-CFG_SELF=\"$0\"\n-CFG_ARGS=\"$@\"\n-\n-HELP=0\n-if [ \"$1\" = \"--help\" ]\n-then\n-    HELP=1\n-    shift\n-    echo\n-    echo \"Usage: $CFG_SELF [options]\"\n-    echo\n-    echo \"Options:\"\n-    echo\n-else\n-    step_msg \"processing $CFG_SELF args\"\n-fi\n-\n-# Check for mingw or cygwin in order to special case $CFG_LIBDIR_RELATIVE.\n-# This logic is duplicated from configure in order to get the correct libdir\n-# for Windows installs.\n-CFG_OSTYPE=$(uname -s)\n-\n-case $CFG_OSTYPE in\n-\n-    MINGW32*)\n-        CFG_OSTYPE=pc-mingw32\n-        ;;\n-\n-    MINGW64*)\n-        # msys2, MSYSTEM=MINGW64\n-        CFG_OSTYPE=w64-mingw32\n-        ;;\n-\n-# Thad's Cygwin identifers below\n-\n-#   Vista 32 bit\n-    CYGWIN_NT-6.0)\n-        CFG_OSTYPE=pc-mingw32\n-        ;;\n-\n-#   Vista 64 bit\n-    CYGWIN_NT-6.0-WOW64)\n-        CFG_OSTYPE=w64-mingw32\n-        ;;\n-\n-#   Win 7 32 bit\n-    CYGWIN_NT-6.1)\n-        CFG_OSTYPE=pc-mingw32\n-        ;;\n-\n-#   Win 7 64 bit\n-    CYGWIN_NT-6.1-WOW64)\n-        CFG_OSTYPE=w64-mingw32\n-        ;;\n-esac\n-\n-OPTIONS=\"\"\n-BOOL_OPTIONS=\"\"\n-VAL_OPTIONS=\"\"\n-\n-# On windows we just store the libraries in the bin directory because\n-# there's no rpath. This is where the build system itself puts libraries;\n-# --libdir is used to configure the installation directory.\n-# FIXME: Thise needs to parameterized over target triples. Do it in platform.mk\n-CFG_LIBDIR_RELATIVE=lib\n-if [ \"$CFG_OSTYPE\" = \"pc-mingw32\" ] || [ \"$CFG_OSTYPE\" = \"w64-mingw32\" ]\n-then\n-    CFG_LIBDIR_RELATIVE=bin\n-fi\n-\n-if [ \"$CFG_OSTYPE\" = \"pc-mingw32\" ] || [ \"$CFG_OSTYPE\" = \"w64-mingw32\" ]\n-then\n-    CFG_LD_PATH_VAR=PATH\n-    CFG_OLD_LD_PATH_VAR=$PATH\n-elif [ \"$CFG_OSTYPE\" = \"Darwin\" ]\n-then\n-    CFG_LD_PATH_VAR=DYLD_LIBRARY_PATH\n-    CFG_OLD_LD_PATH_VAR=$DYLD_LIBRARY_PATH\n-else\n-    CFG_LD_PATH_VAR=LD_LIBRARY_PATH\n-    CFG_OLD_LD_PATH_VAR=$LD_LIBRARY_PATH\n-fi\n-\n-flag uninstall \"only uninstall from the installation prefix\"\n-opt verify 1 \"verify that the installed binaries run correctly\"\n-valopt prefix \"/usr/local\" \"set installation prefix\"\n-# NB This is exactly the same definition as in `configure`.\n-valopt libdir \"${CFG_PREFIX}/${CFG_LIBDIR_RELATIVE}\" \"install libraries\"\n-case \"$CFG_LIBDIR\" in\n-    \"$CFG_PREFIX\"/*) CAT_INC=2;;\n-    \"$CFG_PREFIX\"*)  CAT_INC=1;;\n-    *)\n-        err \"libdir must begin with the prefix. Use --prefix to set it accordingly.\";;\n-esac\n-CFG_LIBDIR_RELATIVE=`echo ${CFG_LIBDIR} | cut -c$((${#CFG_PREFIX}+${CAT_INC}))-`\n-\n-valopt mandir \"${CFG_PREFIX}/share/man\" \"install man pages in PATH\"\n-\n-if [ $HELP -eq 1 ]\n-then\n-    echo\n-    exit 0\n-fi\n-\n-step_msg \"validating $CFG_SELF args\"\n-validate_opt\n-\n-\n-# OK, let's get installing ...\n-\n-# Sanity check: can we run the binaries?\n-if [ -z \"${CFG_DISABLE_VERIFY}\" ]\n-then\n-    # Don't do this if uninstalling. Failure here won't help in any way.\n-    if [ -z \"${CFG_UNINSTALL}\" ]\n-    then\n-        msg \"verifying platform can run binaries\"\n-        export $CFG_LD_PATH_VAR=\"${CFG_SRC_DIR}/lib:$CFG_OLD_LD_PATH_VAR\"\n-        \"${CFG_SRC_DIR}/bin/rustc\" --version > /dev/null\n-        if [ $? -ne 0 ]\n-        then\n-            err \"can't execute rustc binary on this platform\"\n-        fi\n-        export $CFG_LD_PATH_VAR=$CFG_OLD_LD_PATH_VAR\n-    fi\n-fi\n-\n-# Sanity check: can we can write to the destination?\n-msg \"verifying destination is writable\"\n-umask 022 && mkdir -p \"${CFG_LIBDIR}\"\n-need_ok \"can't write to destination. consider \\`sudo\\`.\"\n-touch \"${CFG_LIBDIR}/rust-install-probe\" > /dev/null\n-if [ $? -ne 0 ]\n-then\n-    err \"can't write to destination. consider \\`sudo\\`.\"\n-fi\n-rm -f \"${CFG_LIBDIR}/rust-install-probe\"\n-need_ok \"failed to remove install probe\"\n-\n-# Sanity check: don't install to the directory containing the installer.\n-# That would surely cause chaos.\n-msg \"verifying destination is not the same as source\"\n-INSTALLER_DIR=\"$(cd $(dirname $0) && pwd)\"\n-PREFIX_DIR=\"$(cd ${CFG_PREFIX} && pwd)\"\n-if [ \"${INSTALLER_DIR}\" = \"${PREFIX_DIR}\" ]\n-then\n-    err \"can't install to same directory as installer\"\n-fi\n-\n-# Using an absolute path to libdir in a few places so that the status\n-# messages are consistently using absolute paths.\n-absolutify \"${CFG_LIBDIR}\"\n-ABS_LIBDIR=\"${ABSOLUTIFIED}\"\n-\n-# The file name of the manifest we're going to create during install\n-INSTALLED_MANIFEST=\"${ABS_LIBDIR}/rustlib/manifest\"\n-\n-# First, uninstall from the installation prefix.\n-# Errors are warnings - try to rm everything in the manifest even if some fail.\n-if [ -f \"${INSTALLED_MANIFEST}\" ]\n-then\n-    # Iterate through installed manifest and remove files\n-    while read p; do\n-        # The installed manifest contains absolute paths\n-        msg \"removing $p\"\n-        if [ -f \"$p\" ]\n-        then\n-            rm -f \"$p\"\n-            if [ $? -ne 0 ]\n-            then\n-                warn \"failed to remove $p\"\n-            fi\n-        else\n-            warn \"supposedly installed file $p does not exist!\"\n-        fi\n-    done < \"${INSTALLED_MANIFEST}\"\n-\n-    # If we fail to remove rustlib below, then the installed manifest will\n-    # still be full; the installed manifest needs to be empty before install.\n-    msg \"removing ${INSTALLED_MANIFEST}\"\n-    rm -f \"${INSTALLED_MANIFEST}\"\n-    # For the above reason, this is a hard error\n-    need_ok \"failed to remove installed manifest\"\n-\n-    # Remove 'rustlib' directory\n-    msg \"removing ${ABS_LIBDIR}/rustlib\"\n-    rm -Rf \"${ABS_LIBDIR}/rustlib\"\n-    if [ $? -ne 0 ]\n-    then\n-        warn \"failed to remove rustlib\"\n-    fi\n-else\n-    # There's no manifest. If we were asked to uninstall, then that's a problem.\n-    if [ -n \"${CFG_UNINSTALL}\" ]\n-    then\n-        err \"unable to find installation manifest at ${CFG_LIBDIR}/rustlib\"\n-    fi\n-fi\n-\n-# If we're only uninstalling then exit\n-if [ -n \"${CFG_UNINSTALL}\" ]\n-then\n-    echo\n-    echo \"    Rust is uninstalled. Have a nice day.\"\n-    echo\n-    exit 0\n-fi\n-\n-# Create the installed manifest, which we will fill in with absolute file paths\n-mkdir -p \"${CFG_LIBDIR}/rustlib\"\n-need_ok \"failed to create rustlib\"\n-touch \"${INSTALLED_MANIFEST}\"\n-need_ok \"failed to create installed manifest\"\n-\n-# Now install, iterate through the new manifest and copy files\n-while read p; do\n-\n-    # Decide the destination of the file\n-    FILE_INSTALL_PATH=\"${CFG_PREFIX}/$p\"\n-\n-    if echo \"$p\" | grep \"^${CFG_LIBDIR_RELATIVE}/\" > /dev/null\n-    then\n-        pp=`echo $p | sed \"s%^${CFG_LIBDIR_RELATIVE}/%%\"`\n-        FILE_INSTALL_PATH=\"${CFG_LIBDIR}/$pp\"\n-    fi\n-\n-    if echo \"$p\" | grep \"^share/man/\" > /dev/null\n-    then\n-        pp=`echo $p | sed 's/^share\\/man\\///'`\n-        FILE_INSTALL_PATH=\"${CFG_MANDIR}/$pp\"\n-    fi\n-\n-    # Make sure there's a directory for it\n-    umask 022 && mkdir -p \"$(dirname ${FILE_INSTALL_PATH})\"\n-    need_ok \"directory creation failed\"\n-\n-    # Make the path absolute so we can uninstall it later without\n-    # starting from the installation cwd\n-    absolutify \"${FILE_INSTALL_PATH}\"\n-    FILE_INSTALL_PATH=\"${ABSOLUTIFIED}\"\n-\n-    # Install the file\n-    msg \"${FILE_INSTALL_PATH}\"\n-    if echo \"$p\" | grep \"^bin/\" > /dev/null\n-    then\n-        install -m755 \"${CFG_SRC_DIR}/$p\" \"${FILE_INSTALL_PATH}\"\n-    else\n-        install -m644 \"${CFG_SRC_DIR}/$p\" \"${FILE_INSTALL_PATH}\"\n-    fi\n-    need_ok \"file creation failed\"\n-\n-    # Update the manifest\n-    echo \"${FILE_INSTALL_PATH}\" >> \"${INSTALLED_MANIFEST}\"\n-    need_ok \"failed to update manifest\"\n-\n-# The manifest lists all files to install\n-done < \"${CFG_SRC_DIR}/${CFG_LIBDIR_RELATIVE}/rustlib/manifest.in\"\n-\n-# Run ldconfig to make dynamic libraries available to the linker\n-if [ \"$CFG_OSTYPE\" = \"Linux\" ]\n-    then\n-    ldconfig\n-    if [ $? -ne 0 ]\n-    then\n-        warn \"failed to run ldconfig.\"\n-        warn \"this may happen when not installing as root and may be fine\"\n-    fi\n-fi\n-\n-# Sanity check: can we run the installed binaries?\n-#\n-# As with the verification above, make sure the right LD_LIBRARY_PATH-equivalent\n-# is in place. Try first without this variable, and if that fails try again with\n-# the variable. If the second time tries, print a hopefully helpful message to\n-# add something to the appropriate environment variable.\n-if [ -z \"${CFG_DISABLE_VERIFY}\" ]\n-then\n-    msg \"verifying installed binaries are executable\"\n-    \"${CFG_PREFIX}/bin/rustc\" --version 2> /dev/null 1> /dev/null\n-    if [ $? -ne 0 ]\n-    then\n-        export $CFG_LD_PATH_VAR=\"${CFG_PREFIX}/lib:$CFG_OLD_LD_PATH_VAR\"\n-        \"${CFG_PREFIX}/bin/rustc\" --version > /dev/null\n-        if [ $? -ne 0 ]\n-        then\n-            ERR=\"can't execute installed rustc binary. \"\n-            ERR=\"${ERR}installation may be broken. \"\n-            ERR=\"${ERR}if this is expected then rerun install.sh with \\`--disable-verify\\` \"\n-            ERR=\"${ERR}or \\`make install\\` with \\`--disable-verify-install\\`\"\n-            err \"${ERR}\"\n-        else\n-            echo\n-            echo \"    Note: please ensure '${CFG_PREFIX}/lib' is added to ${CFG_LD_PATH_VAR}\"\n-        fi\n-    fi\n-fi\n-\n-echo\n-echo \"    Rust is ready to roll.\"\n-echo\n-\n-"}, {"sha": "95e647c91cfe60ce71ae2cd2fa748fb52c9b0375", "filename": "src/etc/make-win-dist.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fetc%2Fmake-win-dist.py", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fetc%2Fmake-win-dist.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmake-win-dist.py?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -107,7 +107,7 @@ def make_win_dist(rust_root, gcc_root, target_triple):\n     for src in target_tools:\n         shutil.copy(src, target_bin_dir)\n \n-    # Copy platform libs to platform-spcific lib directory\n+    # Copy platform libs to platform-specific lib directory\n     target_lib_dir = os.path.join(gcc_root, \"bin\", \"rustlib\", target_triple, \"lib\")\n     if not os.path.exists(target_lib_dir):\n         os.makedirs(target_lib_dir)"}, {"sha": "5b8ccf924ebab1a95e1d6d0bf92aa2ca903ce240", "filename": "src/etc/rustup.sh", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fetc%2Frustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fetc%2Frustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frustup.sh?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -231,6 +231,7 @@ validate_opt() {\n \n probe_need CFG_CURL  curl\n probe_need CFG_TAR   tar\n+probe_need CFG_FILE  file\n \n CFG_SRC_DIR=\"$(cd $(dirname $0) && pwd)/\"\n CFG_SELF=\"$0\"\n@@ -359,7 +360,7 @@ esac\n # Detect 64 bit linux systems with 32 bit userland and force 32 bit compilation\n if [ $CFG_OSTYPE = unknown-linux-gnu -a $CFG_CPUTYPE = x86_64 ]\n then\n-    file -L \"$SHELL\" | grep -q \"x86[_-]64\"\n+    \"${CFG_FILE}\" -L \"$SHELL\" | grep -q \"x86[_-]64\"\n     if [ $? != 0 ]; then\n         CFG_CPUTYPE=i686\n     fi"}, {"sha": "f7b19cf6fbf5e06ef290bbbe45878b1659f9ac36", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -173,10 +173,10 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, token::Token>) -> TokenAn\n     );\n \n     let m = re.captures(s).expect(format!(\"The regex didn't match {}\", s).as_slice());\n-    let start = m.name(\"start\");\n-    let end = m.name(\"end\");\n-    let toknum = m.name(\"toknum\");\n-    let content = m.name(\"content\");\n+    let start = m.name(\"start\").unwrap_or(\"\");\n+    let end = m.name(\"end\").unwrap_or(\"\");\n+    let toknum = m.name(\"toknum\").unwrap_or(\"\");\n+    let content = m.name(\"content\").unwrap_or(\"\");\n \n     let proto_tok = tokens.get(toknum).expect(format!(\"didn't find token {} in the map\",\n                                                               toknum).as_slice());"}, {"sha": "ee4efa2d27399a0be122db1e9761e75c63d88b39", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -14,6 +14,7 @@\n //! between tasks.\n \n use core::atomic;\n+use core::borrow::BorrowFrom;\n use core::clone::Clone;\n use core::fmt::{mod, Show};\n use core::cmp::{Eq, Ord, PartialEq, PartialOrd, Ordering};\n@@ -155,6 +156,12 @@ impl<T> Clone for Arc<T> {\n     }\n }\n \n+impl<T> BorrowFrom<Arc<T>> for T {\n+    fn borrow_from(owned: &Arc<T>) -> &T {\n+        &**owned\n+    }\n+}\n+\n #[experimental = \"Deref is experimental.\"]\n impl<T> Deref<T> for Arc<T> {\n     #[inline]\n@@ -316,7 +323,9 @@ impl<T: fmt::Show> fmt::Show for Arc<T> {\n     }\n }\n \n+#[stable]\n impl<T: Default + Sync + Send> Default for Arc<T> {\n+    #[stable]\n     fn default() -> Arc<T> { Arc::new(Default::default()) }\n }\n "}, {"sha": "879a8cc6951a133063fcb91afe0ae22526144fc7", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -45,11 +45,15 @@ pub static HEAP: () = ();\n #[unstable = \"custom allocators will add an additional type parameter (with default)\"]\n pub struct Box<T>(*mut T);\n \n+#[stable]\n impl<T: Default> Default for Box<T> {\n+    #[stable]\n     fn default() -> Box<T> { box Default::default() }\n }\n \n+#[stable]\n impl<T> Default for Box<[T]> {\n+    #[stable]\n     fn default() -> Box<[T]> { box [] }\n }\n "}, {"sha": "0257c640d3ccd58599927f2336a925c4cd815dab", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -448,6 +448,7 @@ impl<T: Default> Default for Rc<T> {\n     /// let x: Rc<int> = Default::default();\n     /// ```\n     #[inline]\n+    #[stable]\n     fn default() -> Rc<T> {\n         Rc::new(Default::default())\n     }"}, {"sha": "9421159269896200fe4c706fa08618c3cd1ddf5d", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -172,8 +172,10 @@ pub struct BinaryHeap<T> {\n     data: Vec<T>,\n }\n \n+#[stable]\n impl<T: Ord> Default for BinaryHeap<T> {\n     #[inline]\n+    #[stable]\n     fn default() -> BinaryHeap<T> { BinaryHeap::new() }\n }\n "}, {"sha": "df860d6000eb7134087e1fb66d1467cc44bc1e61", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -824,8 +824,10 @@ pub fn from_fn<F>(len: uint, mut f: F) -> Bitv where F: FnMut(uint) -> bool {\n     bitv\n }\n \n+#[stable]\n impl Default for Bitv {\n     #[inline]\n+    #[stable]\n     fn default() -> Bitv { Bitv::new() }\n }\n "}, {"sha": "c7cbb5a1c299e25b59c485b08b3cbebf6e3d80f9", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -29,6 +29,7 @@ use std::hash::{Writer, Hash};\n use core::default::Default;\n use core::{iter, fmt, mem};\n use core::fmt::Show;\n+use core::iter::Map;\n \n use ring_buf::RingBuf;\n \n@@ -110,12 +111,14 @@ pub struct MoveEntries<K, V> {\n }\n \n /// An iterator over a BTreeMap's keys.\n-pub type Keys<'a, K, V> =\n-    iter::Map<(&'a K, &'a V), &'a K, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>;\n+pub struct Keys<'a, K: 'a, V: 'a> {\n+    inner: Map<(&'a K, &'a V), &'a K, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n+}\n \n /// An iterator over a BTreeMap's values.\n-pub type Values<'a, K, V> =\n-    iter::Map<(&'a K, &'a V), &'a V, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>;\n+pub struct Values<'a, K: 'a, V: 'a> {\n+    inner: Map<(&'a K, &'a V), &'a V, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n+}\n \n /// A view into a single entry in a map, which may either be vacant or occupied.\n pub enum Entry<'a, K:'a, V:'a> {\n@@ -829,7 +832,9 @@ impl<S: Writer, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n     }\n }\n \n+#[stable]\n impl<K: Ord, V> Default for BTreeMap<K, V> {\n+    #[stable]\n     fn default() -> BTreeMap<K, V> {\n         BTreeMap::new()\n     }\n@@ -1054,6 +1059,25 @@ impl<K, V> DoubleEndedIterator<(K, V)> for MoveEntries<K, V> {\n impl<K, V> ExactSizeIterator<(K, V)> for MoveEntries<K, V> {}\n \n \n+impl<'a, K, V> Iterator<&'a K> for Keys<'a, K, V> {\n+    fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+impl<'a, K, V> DoubleEndedIterator<&'a K> for Keys<'a, K, V> {\n+    fn next_back(&mut self) -> Option<(&'a K)> { self.inner.next_back() }\n+}\n+impl<'a, K, V> ExactSizeIterator<&'a K> for Keys<'a, K, V> {}\n+\n+\n+impl<'a, K, V> Iterator<&'a V> for Values<'a, K, V> {\n+    fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+impl<'a, K, V> DoubleEndedIterator<&'a V> for Values<'a, K, V> {\n+    fn next_back(&mut self) -> Option<(&'a V)> { self.inner.next_back() }\n+}\n+impl<'a, K, V> ExactSizeIterator<&'a V> for Values<'a, K, V> {}\n+\n \n impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     /// Sets the value of the entry with the VacantEntry's key,\n@@ -1204,7 +1228,7 @@ impl<K, V> BTreeMap<K, V> {\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n \n-        self.iter().map(first)\n+        Keys { inner: self.iter().map(first) }\n     }\n \n     /// Gets an iterator over the values of the map.\n@@ -1225,7 +1249,7 @@ impl<K, V> BTreeMap<K, V> {\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n \n-        self.iter().map(second)\n+        Values { inner: self.iter().map(second) }\n     }\n \n     /// Return the number of elements in the map."}, {"sha": "9698b06c7fa0f266c7bd52f89e11d0c541959470", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -19,7 +19,6 @@ pub use self::TraversalItem::*;\n use core::prelude::*;\n \n use core::{slice, mem, ptr, cmp, num, raw};\n-use core::kinds::marker;\n use core::iter::Zip;\n use core::borrow::BorrowFrom;\n use alloc::heap;\n@@ -176,7 +175,6 @@ fn calculate_offsets_generic<K, V>(capacity: uint, is_leaf: bool) -> (uint, uint\n struct RawItems<T> {\n     head: *const T,\n     tail: *const T,\n-    marker: marker::NoCopy\n }\n \n impl<T> RawItems<T> {\n@@ -189,13 +187,11 @@ impl<T> RawItems<T> {\n             RawItems {\n                 head: ptr,\n                 tail: (ptr as uint + len) as *const T,\n-                marker: marker::NoCopy\n             }\n         } else {\n             RawItems {\n                 head: ptr,\n                 tail: ptr.offset(len as int),\n-                marker: marker::NoCopy\n             }\n         }\n     }"}, {"sha": "8f75113c01dbf018ccb07bbb977217703be3838a", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -17,8 +17,8 @@ use btree_map::{BTreeMap, Keys, MoveEntries};\n use std::hash::Hash;\n use core::borrow::BorrowFrom;\n use core::default::Default;\n-use core::{iter, fmt};\n-use core::iter::Peekable;\n+use core::fmt;\n+use core::iter::{Peekable, Map};\n use core::fmt::Show;\n \n // FIXME(conventions): implement bounded iterators\n@@ -33,11 +33,14 @@ pub struct BTreeSet<T>{\n }\n \n /// An iterator over a BTreeSet's items.\n-pub type Items<'a, T> = Keys<'a, T, ()>;\n+pub struct Items<'a, T: 'a> {\n+    iter: Keys<'a, T, ()>\n+}\n \n /// An owning iterator over a BTreeSet's items.\n-pub type MoveItems<T> =\n-    iter::Map<(T, ()), T, MoveEntries<T, ()>, fn((T, ())) -> T>;\n+pub struct MoveItems<T> {\n+    iter: Map<(T, ()), T, MoveEntries<T, ()>, fn((T, ())) -> T>\n+}\n \n /// A lazy iterator producing elements in the set difference (in-order).\n pub struct DifferenceItems<'a, T:'a> {\n@@ -105,7 +108,7 @@ impl<T> BTreeSet<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> Items<'a, T> {\n-        self.map.keys()\n+        Items { iter: self.map.keys() }\n     }\n \n     /// Gets an iterator for moving out the BtreeSet's contents.\n@@ -124,7 +127,7 @@ impl<T> BTreeSet<T> {\n     pub fn into_iter(self) -> MoveItems<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n \n-        self.map.into_iter().map(first)\n+        MoveItems { iter: self.map.into_iter().map(first) }\n     }\n }\n \n@@ -436,7 +439,9 @@ impl<T: Ord> Extend<T> for BTreeSet<T> {\n     }\n }\n \n+#[stable]\n impl<T: Ord> Default for BTreeSet<T> {\n+    #[stable]\n     fn default() -> BTreeSet<T> {\n         BTreeSet::new()\n     }\n@@ -635,6 +640,25 @@ impl<T: Show> Show for BTreeSet<T> {\n     }\n }\n \n+impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n+    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n+    fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n+}\n+impl<'a, T> ExactSizeIterator<&'a T> for Items<'a, T> {}\n+\n+\n+impl<T> Iterator<T> for MoveItems<T> {\n+    fn next(&mut self) -> Option<T> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n+    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n+}\n+impl<T> ExactSizeIterator<T> for MoveItems<T> {}\n+\n /// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n                         short: Ordering, long: Ordering) -> Ordering {"}, {"sha": "e7454aef51e8e9aac9d7f00478d40b0a26769040", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -192,8 +192,10 @@ impl<T> DList<T> {\n     }\n }\n \n+#[stable]\n impl<T> Default for DList<T> {\n     #[inline]\n+    #[stable]\n     fn default() -> DList<T> { DList::new() }\n }\n "}, {"sha": "cdb92d302e9d31ed880c3a21cee4fae0090baa9a", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 253, "deletions": 53, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -68,7 +68,9 @@ impl<T> Drop for RingBuf<T> {\n     }\n }\n \n+#[stable]\n impl<T> Default for RingBuf<T> {\n+    #[stable]\n     #[inline]\n     fn default() -> RingBuf<T> { RingBuf::new() }\n }\n@@ -102,17 +104,15 @@ impl<T> RingBuf<T> {\n \n     /// Copies a contiguous block of memory len long from src to dst\n     #[inline]\n-    fn copy(&self, dst: uint, src: uint, len: uint) {\n-        unsafe {\n-            debug_assert!(dst + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n-                          self.cap);\n-            debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n-                          self.cap);\n-            ptr::copy_memory(\n-                self.ptr.offset(dst as int),\n-                self.ptr.offset(src as int) as *const T,\n-                len);\n-        }\n+    unsafe fn copy(&self, dst: uint, src: uint, len: uint) {\n+        debug_assert!(dst + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n+                      self.cap);\n+        debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n+                      self.cap);\n+        ptr::copy_memory(\n+            self.ptr.offset(dst as int),\n+            self.ptr.offset(src as int) as *const T,\n+            len);\n     }\n }\n \n@@ -377,7 +377,7 @@ impl<T> RingBuf<T> {\n         }\n     }\n \n-    /// Returns a front-to-back iterator which returns mutable references.\n+    /// Returns a front-to-back iterator that returns mutable references.\n     ///\n     /// # Examples\n     ///\n@@ -402,7 +402,6 @@ impl<T> RingBuf<T> {\n             cap: self.cap,\n             ptr: self.ptr,\n             marker: marker::ContravariantLifetime::<'a>,\n-            marker2: marker::NoCopy\n         }\n     }\n \n@@ -732,7 +731,7 @@ impl<T> RingBuf<T> {\n \n                 self.tail = self.wrap_index(self.tail - 1);\n             },\n-            (true, true, _) => {\n+            (true, true, _) => unsafe {\n                 // contiguous, insert closer to tail:\n                 //\n                 //             T   I         H\n@@ -752,13 +751,15 @@ impl<T> RingBuf<T> {\n                 //      [o I A o o o o o . . . . . . . o]\n                 //       M                             M\n \n-                let old_tail = self.tail;\n-                self.tail = self.wrap_index(self.tail - 1);\n+                let new_tail = self.wrap_index(self.tail - 1);\n+\n+                self.copy(new_tail, self.tail, 1);\n+                // Already moved the tail, so we only copy `i - 1` elements.\n+                self.copy(self.tail, self.tail + 1, i - 1);\n \n-                self.copy(self.tail, old_tail, 1);\n-                self.copy(old_tail, old_tail + 1, i);\n+                self.tail = new_tail;\n             },\n-            (true, false, _) => {\n+            (true, false, _) => unsafe {\n                 //  contiguous, insert closer to head:\n                 //\n                 //             T       I     H\n@@ -768,12 +769,11 @@ impl<T> RingBuf<T> {\n                 //      [. . . o o o o I A o o . . . . .]\n                 //                       M M M\n \n-                let old_head = self.head;\n+                self.copy(idx + 1, idx, self.head - idx);\n                 self.head = self.wrap_index(self.head + 1);\n-                self.copy(idx + 1, idx, old_head - idx);\n             },\n-            (false, true, true) => {\n-                // discontiguous, tail section, insert closer to tail:\n+            (false, true, true) => unsafe {\n+                // discontiguous, insert closer to tail, tail section:\n                 //\n                 //                   H         T   I\n                 //      [o o o o o o . . . . . o o A o o]\n@@ -782,12 +782,11 @@ impl<T> RingBuf<T> {\n                 //      [o o o o o o . . . . o o I A o o]\n                 //                           M M\n \n-                let old_tail = self.tail;\n-                self.tail = self.tail - 1;\n-                self.copy(self.tail, old_tail, i);\n+                self.copy(self.tail - 1, self.tail, i);\n+                self.tail -= 1;\n             },\n-            (false, false, true) => {\n-                // discontiguous, tail section, insert closer to head:\n+            (false, false, true) => unsafe {\n+                // discontiguous, insert closer to head, tail section:\n                 //\n                 //           H             T         I\n                 //      [o o . . . . . . . o o o o o A o]\n@@ -796,20 +795,19 @@ impl<T> RingBuf<T> {\n                 //      [o o o . . . . . . o o o o o I A]\n                 //       M M M                         M\n \n-                let old_head = self.head;\n-                self.head = self.head + 1;\n-\n                 // copy elements up to new head\n-                self.copy(1, 0, old_head);\n+                self.copy(1, 0, self.head);\n \n                 // copy last element into empty spot at bottom of buffer\n                 self.copy(0, self.cap - 1, 1);\n \n                 // move elements from idx to end forward not including ^ element\n                 self.copy(idx + 1, idx, self.cap - 1 - idx);\n+\n+                self.head += 1;\n             },\n-            (false, true, false) if idx == 0 => {\n-                // discontiguous, head section, insert is closer to tail,\n+            (false, true, false) if idx == 0 => unsafe {\n+                // discontiguous, insert is closer to tail, head section,\n                 // and is at index zero in the internal buffer:\n                 //\n                 //       I                   H     T\n@@ -819,16 +817,16 @@ impl<T> RingBuf<T> {\n                 //      [A o o o o o o o o o . . o o o I]\n                 //                               M M M\n \n-                let old_tail = self.tail;\n-                self.tail = self.tail - 1;\n                 // copy elements up to new tail\n-                self.copy(old_tail - 1, old_tail, i);\n+                self.copy(self.tail - 1, self.tail, self.cap - self.tail);\n \n                 // copy last element into empty spot at bottom of buffer\n                 self.copy(self.cap - 1, 0, 1);\n+\n+                self.tail -= 1;\n             },\n-            (false, true, false) => {\n-                // discontiguous, head section, insert closer to tail:\n+            (false, true, false) => unsafe {\n+                // discontiguous, insert closer to tail, head section:\n                 //\n                 //             I             H     T\n                 //      [o o o A o o o o o o . . . o o o]\n@@ -837,19 +835,19 @@ impl<T> RingBuf<T> {\n                 //      [o o I A o o o o o o . . o o o o]\n                 //       M M                     M M M M\n \n-                let old_tail = self.tail;\n-                self.tail = self.tail - 1;\n                 // copy elements up to new tail\n-                self.copy(old_tail - 1, old_tail, i);\n+                self.copy(self.tail - 1, self.tail, self.cap - self.tail);\n \n                 // copy last element into empty spot at bottom of buffer\n                 self.copy(self.cap - 1, 0, 1);\n \n                 // move elements from idx-1 to end forward not including ^ element\n                 self.copy(0, 1, idx - 1);\n-            }\n-            (false, false, false) => {\n-                // discontiguous, head section, insert closer to head:\n+\n+                self.tail -= 1;\n+            },\n+            (false, false, false) => unsafe {\n+                // discontiguous, insert closer to head, head section:\n                 //\n                 //               I     H           T\n                 //      [o o o o A o o . . . . . . o o o]\n@@ -858,9 +856,8 @@ impl<T> RingBuf<T> {\n                 //      [o o o o I A o o . . . . . o o o]\n                 //                 M M M\n \n-                let old_head = self.head;\n-                self.head = self.head + 1;\n-                self.copy(idx + 1, idx, old_head - idx);\n+                self.copy(idx + 1, idx, self.head - idx);\n+                self.head += 1;\n             }\n         }\n \n@@ -870,6 +867,170 @@ impl<T> RingBuf<T> {\n             self.buffer_write(new_idx, t);\n         }\n     }\n+\n+    /// Removes and returns the element at position `i` from the ringbuf.\n+    /// Whichever end is closer to the removal point will be moved to make\n+    /// room, and all the affected elements will be moved to new positions.\n+    /// Returns `None` if `i` is out of bounds.\n+    ///\n+    /// # Example\n+    /// ```rust\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf = RingBuf::new();\n+    /// buf.push_back(5i);\n+    /// buf.push_back(10i);\n+    /// buf.push_back(12i);\n+    /// buf.push_back(15);\n+    /// buf.remove(2);\n+    /// assert_eq!(Some(&15), buf.get(2));\n+    /// ```\n+    #[unstable = \"matches collection reform specification; waiting on panic semantics\"]\n+    pub fn remove(&mut self, i: uint) -> Option<T> {\n+        if self.is_empty() || self.len() <= i {\n+            return None;\n+        }\n+\n+        // There are three main cases:\n+        //  Elements are contiguous\n+        //  Elements are discontiguous and the removal is in the tail section\n+        //  Elements are discontiguous and the removal is in the head section\n+        //      - special case when elements are technically contiguous,\n+        //        but self.head = 0\n+        //\n+        // For each of those there are two more cases:\n+        //  Insert is closer to tail\n+        //  Insert is closer to head\n+        //\n+        // Key: H - self.head\n+        //      T - self.tail\n+        //      o - Valid element\n+        //      x - Element marked for removal\n+        //      R - Indicates element that is being removed\n+        //      M - Indicates element was moved\n+\n+        let idx = self.wrap_index(self.tail + i);\n+\n+        let elem = unsafe {\n+            Some(self.buffer_read(idx))\n+        };\n+\n+        let distance_to_tail = i;\n+        let distance_to_head = self.len() - i;\n+\n+        let contiguous = self.tail <= self.head;\n+\n+        match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n+            (true, true, _) => unsafe {\n+                // contiguous, remove closer to tail:\n+                //\n+                //             T   R         H\n+                //      [. . . o o x o o o o . . . . . .]\n+                //\n+                //               T           H\n+                //      [. . . . o o o o o o . . . . . .]\n+                //               M M\n+\n+                self.copy(self.tail + 1, self.tail, i);\n+                self.tail += 1;\n+            },\n+            (true, false, _) => unsafe {\n+                // contiguous, remove closer to head:\n+                //\n+                //             T       R     H\n+                //      [. . . o o o o x o o . . . . . .]\n+                //\n+                //             T           H\n+                //      [. . . o o o o o o . . . . . . .]\n+                //                     M M\n+\n+                self.copy(idx, idx + 1, self.head - idx - 1);\n+                self.head -= 1;\n+            },\n+            (false, true, true) => unsafe {\n+                // discontiguous, remove closer to tail, tail section:\n+                //\n+                //                   H         T   R\n+                //      [o o o o o o . . . . . o o x o o]\n+                //\n+                //                   H           T\n+                //      [o o o o o o . . . . . . o o o o]\n+                //                               M M\n+\n+                self.copy(self.tail + 1, self.tail, i);\n+                self.tail = self.wrap_index(self.tail + 1);\n+            },\n+            (false, false, false) => unsafe {\n+                // discontiguous, remove closer to head, head section:\n+                //\n+                //               R     H           T\n+                //      [o o o o x o o . . . . . . o o o]\n+                //\n+                //                   H             T\n+                //      [o o o o o o . . . . . . . o o o]\n+                //               M M\n+\n+                self.copy(idx, idx + 1, self.head - idx - 1);\n+                self.head -= 1;\n+            },\n+            (false, false, true) => unsafe {\n+                // discontiguous, remove closer to head, tail section:\n+                //\n+                //             H           T         R\n+                //      [o o o . . . . . . o o o o o x o]\n+                //\n+                //           H             T\n+                //      [o o . . . . . . . o o o o o o o]\n+                //       M M                         M M\n+                //\n+                // or quasi-discontiguous, remove next to head, tail section:\n+                //\n+                //       H                 T         R\n+                //      [. . . . . . . . . o o o o o x o]\n+                //\n+                //                         T           H\n+                //      [. . . . . . . . . o o o o o o .]\n+                //                                   M\n+\n+                // draw in elements in the tail section\n+                self.copy(idx, idx + 1, self.cap - idx - 1);\n+\n+                // Prevents underflow.\n+                if self.head != 0 {\n+                    // copy first element into empty spot\n+                    self.copy(self.cap - 1, 0, 1);\n+\n+                    // move elements in the head section backwards\n+                    self.copy(0, 1, self.head - 1);\n+                }\n+\n+                self.head = self.wrap_index(self.head - 1);\n+            },\n+            (false, true, false) => unsafe {\n+                // discontiguous, remove closer to tail, head section:\n+                //\n+                //           R               H     T\n+                //      [o o x o o o o o o o . . . o o o]\n+                //\n+                //                           H       T\n+                //      [o o o o o o o o o o . . . . o o]\n+                //       M M M                       M M\n+\n+                // draw in elements up to idx\n+                self.copy(1, 0, idx);\n+\n+                // copy last element into empty spot\n+                self.copy(0, self.cap - 1, 1);\n+\n+                // move elements from tail to end forward, excluding the last one\n+                self.copy(self.tail + 1, self.tail, self.cap - self.tail - 1);\n+\n+                self.tail = self.wrap_index(self.tail + 1);\n+            }\n+        }\n+\n+        return elem;\n+    }\n }\n \n /// Returns the index in the underlying buffer for a given logical element index.\n@@ -952,7 +1113,6 @@ pub struct MutItems<'a, T:'a> {\n     head: uint,\n     cap: uint,\n     marker: marker::ContravariantLifetime<'a>,\n-    marker2: marker::NoCopy\n }\n \n impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n@@ -1103,6 +1263,7 @@ mod tests {\n     use core::iter;\n     use self::Taggy::*;\n     use self::Taggypar::*;\n+    use std::cmp;\n     use std::fmt::Show;\n     use std::prelude::*;\n     use std::hash;\n@@ -1892,11 +2053,11 @@ mod tests {\n     #[test]\n     fn test_insert() {\n         // This test checks that every single combination of tail position, length, and\n-        // insertion position is tested. Capacity 7 should be large enough to cover every case.\n+        // insertion position is tested. Capacity 15 should be large enough to cover every case.\n \n-        let mut tester = RingBuf::with_capacity(7);\n-        // can't guarantee we got 7, so have to get what we got.\n-        // 7 would be great, but we will definitely get 2^k - 1, for k >= 3, or else\n+        let mut tester = RingBuf::with_capacity(15);\n+        // can't guarantee we got 15, so have to get what we got.\n+        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n         // this test isn't covering what it wants to\n         let cap = tester.capacity();\n \n@@ -1915,6 +2076,45 @@ mod tests {\n                         }\n                     }\n                     tester.insert(to_insert, to_insert);\n+                    assert!(tester.tail < tester.cap);\n+                    assert!(tester.head < tester.cap);\n+                    assert_eq!(tester, expected);\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_remove() {\n+        // This test checks that every single combination of tail position, length, and\n+        // removal position is tested. Capacity 15 should be large enough to cover every case.\n+\n+        let mut tester = RingBuf::with_capacity(15);\n+        // can't guarantee we got 15, so have to get what we got.\n+        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+        // this test isn't covering what it wants to\n+        let cap = tester.capacity();\n+\n+        // len is the length *after* removal\n+        for len in range(0, cap - 1) {\n+            // 0, 1, 2, .., len - 1\n+            let expected = iter::count(0, 1).take(len).collect();\n+            for tail_pos in range(0, cap) {\n+                for to_remove in range(0, len + 1) {\n+                    tester.tail = tail_pos;\n+                    tester.head = tail_pos;\n+                    for i in range(0, len) {\n+                        if i == to_remove {\n+                            tester.push_back(1234);\n+                        }\n+                        tester.push_back(i);\n+                    }\n+                    if to_remove == len {\n+                        tester.push_back(1234);\n+                    }\n+                    tester.remove(to_remove);\n+                    assert!(tester.tail < tester.cap);\n+                    assert!(tester.head < tester.cap);\n                     assert_eq!(tester, expected);\n                 }\n             }"}, {"sha": "19ca1c9fd2bcea1ecb5f1085de743384d1ee2e93", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -1597,17 +1597,24 @@ mod tests {\n \n     #[test]\n     fn test_escape_unicode() {\n-        assert_eq!(\"abc\".escape_unicode(), String::from_str(\"\\\\x61\\\\x62\\\\x63\"));\n-        assert_eq!(\"a c\".escape_unicode(), String::from_str(\"\\\\x61\\\\x20\\\\x63\"));\n-        assert_eq!(\"\\r\\n\\t\".escape_unicode(), String::from_str(\"\\\\x0d\\\\x0a\\\\x09\"));\n-        assert_eq!(\"'\\\"\\\\\".escape_unicode(), String::from_str(\"\\\\x27\\\\x22\\\\x5c\"));\n+        assert_eq!(\"abc\".escape_unicode(),\n+                   String::from_str(\"\\\\u{61}\\\\u{62}\\\\u{63}\"));\n+        assert_eq!(\"a c\".escape_unicode(),\n+                   String::from_str(\"\\\\u{61}\\\\u{20}\\\\u{63}\"));\n+        assert_eq!(\"\\r\\n\\t\".escape_unicode(),\n+                   String::from_str(\"\\\\u{d}\\\\u{a}\\\\u{9}\"));\n+        assert_eq!(\"'\\\"\\\\\".escape_unicode(),\n+                   String::from_str(\"\\\\u{27}\\\\u{22}\\\\u{5c}\"));\n         assert_eq!(\"\\x00\\x01\\u{fe}\\u{ff}\".escape_unicode(),\n-                   String::from_str(\"\\\\x00\\\\x01\\\\u00fe\\\\u00ff\"));\n-        assert_eq!(\"\\u{100}\\u{ffff}\".escape_unicode(), String::from_str(\"\\\\u0100\\\\uffff\"));\n+                   String::from_str(\"\\\\u{0}\\\\u{1}\\\\u{fe}\\\\u{ff}\"));\n+        assert_eq!(\"\\u{100}\\u{ffff}\".escape_unicode(),\n+                   String::from_str(\"\\\\u{100}\\\\u{ffff}\"));\n         assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_unicode(),\n-                   String::from_str(\"\\\\U00010000\\\\U0010ffff\"));\n-        assert_eq!(\"ab\\u{fb00}\".escape_unicode(), String::from_str(\"\\\\x61\\\\x62\\\\ufb00\"));\n-        assert_eq!(\"\\u{1d4ea}\\r\".escape_unicode(), String::from_str(\"\\\\U0001d4ea\\\\x0d\"));\n+                   String::from_str(\"\\\\u{10000}\\\\u{10ffff}\"));\n+        assert_eq!(\"ab\\u{fb00}\".escape_unicode(),\n+                   String::from_str(\"\\\\u{61}\\\\u{62}\\\\u{fb00}\"));\n+        assert_eq!(\"\\u{1d4ea}\\r\".escape_unicode(),\n+                   String::from_str(\"\\\\u{1d4ea}\\\\u{d}\"));\n     }\n \n     #[test]\n@@ -1616,11 +1623,14 @@ mod tests {\n         assert_eq!(\"a c\".escape_default(), String::from_str(\"a c\"));\n         assert_eq!(\"\\r\\n\\t\".escape_default(), String::from_str(\"\\\\r\\\\n\\\\t\"));\n         assert_eq!(\"'\\\"\\\\\".escape_default(), String::from_str(\"\\\\'\\\\\\\"\\\\\\\\\"));\n-        assert_eq!(\"\\u{100}\\u{ffff}\".escape_default(), String::from_str(\"\\\\u0100\\\\uffff\"));\n+        assert_eq!(\"\\u{100}\\u{ffff}\".escape_default(),\n+                   String::from_str(\"\\\\u{100}\\\\u{ffff}\"));\n         assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_default(),\n-                   String::from_str(\"\\\\U00010000\\\\U0010ffff\"));\n-        assert_eq!(\"ab\\u{fb00}\".escape_default(), String::from_str(\"ab\\\\ufb00\"));\n-        assert_eq!(\"\\u{1d4ea}\\r\".escape_default(), String::from_str(\"\\\\U0001d4ea\\\\r\"));\n+                   String::from_str(\"\\\\u{10000}\\\\u{10ffff}\"));\n+        assert_eq!(\"ab\\u{fb00}\".escape_default(),\n+                   String::from_str(\"ab\\\\u{fb00}\"));\n+        assert_eq!(\"\\u{1d4ea}\\r\".escape_default(),\n+                   String::from_str(\"\\\\u{1d4ea}\\\\r\"));\n     }\n \n     #[test]"}, {"sha": "ba89fc133c4f65087b855638c567a7086c1316dd", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -826,6 +826,7 @@ impl StrAllocating for String {\n \n #[stable]\n impl Default for String {\n+    #[stable]\n     fn default() -> String {\n         String::new()\n     }\n@@ -859,6 +860,16 @@ impl<'a, S: Str> Equiv<S> for String {\n #[cfg(stage0)]\n #[experimental = \"waiting on Add stabilization\"]\n impl<S: Str> Add<S, String> for String {\n+    /// Concatenates `self` and `other` as a new mutable `String`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let string1 = \"foo\".to_string();\n+    /// let string2 = \"bar\".to_string();\n+    /// let string3 = string1 + string2;\n+    /// assert_eq!(string3, \"foobar\".to_string());\n+    /// ```\n     fn add(&self, other: &S) -> String {\n         let mut s = String::from_str(self.as_slice());\n         s.push_str(other.as_slice());"}, {"sha": "2b14f9569b0cf216eb9b05487b19d5f7d6c48fc4", "filename": "src/libcollections/tree/map.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Ftree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Ftree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fmap.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -185,8 +185,10 @@ impl<K: Ord + Show, V: Show> Show for TreeMap<K, V> {\n     }\n }\n \n+#[stable]\n impl<K: Ord, V> Default for TreeMap<K,V> {\n     #[inline]\n+    #[stable]\n     fn default() -> TreeMap<K, V> { TreeMap::new() }\n }\n "}, {"sha": "c3aebc2736c960d44eb3c96e1f529f11052ce7f3", "filename": "src/libcollections/tree/set.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Ftree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Ftree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fset.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -134,8 +134,10 @@ impl<T: Ord + Show> Show for TreeSet<T> {\n     }\n }\n \n+#[stable]\n impl<T: Ord> Default for TreeSet<T> {\n     #[inline]\n+    #[stable]\n     fn default() -> TreeSet<T> { TreeSet::new() }\n }\n "}, {"sha": "67c5407eb6e5b871d01d34832f20a0342619c123", "filename": "src/libcollections/trie/map.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Ftrie%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Ftrie%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fmap.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -150,8 +150,10 @@ impl<T: Show> Show for TrieMap<T> {\n     }\n }\n \n+#[stable]\n impl<T> Default for TrieMap<T> {\n     #[inline]\n+    #[stable]\n     fn default() -> TrieMap<T> { TrieMap::new() }\n }\n "}, {"sha": "5d24673ae751c4a0eac10b2e9a63748e476d7e01", "filename": "src/libcollections/trie/set.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Ftrie%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Ftrie%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fset.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -69,8 +69,10 @@ impl Show for TrieSet {\n     }\n }\n \n+#[stable]\n impl Default for TrieSet {\n     #[inline]\n+    #[stable]\n     fn default() -> TrieSet { TrieSet::new() }\n }\n "}, {"sha": "75a389a7c9500e959bfa98aec93041bef8204e1e", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 106, "deletions": 74, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -11,6 +11,38 @@\n //! A growable list type, written `Vec<T>` but pronounced 'vector.'\n //!\n //! Vectors have `O(1)` indexing, push (to the end) and pop (from the end).\n+//!\n+//! # Examples\n+//!\n+//! Explicitly creating a `Vec<T>` with `new()`:\n+//!\n+//! ```\n+//! let xs: Vec<i32> = Vec::new();\n+//! ```\n+//!\n+//! Using the `vec!` macro:\n+//!\n+//! ```\n+//! let ys: Vec<i32> = vec![];\n+//!\n+//! let zs = vec![1i32, 2, 3, 4, 5];\n+//! ```\n+//!\n+//! Push:\n+//!\n+//! ```\n+//! let mut xs = vec![1i32, 2];\n+//!\n+//! xs.push(3);\n+//! ```\n+//!\n+//! And pop:\n+//!\n+//! ```\n+//! let mut xs = vec![1i32, 2];\n+//!\n+//! let two = xs.pop();\n+//! ```\n \n use core::prelude::*;\n \n@@ -32,7 +64,7 @@ use core::uint;\n \n use slice::CloneSliceExt;\n \n-/// An owned, growable vector.\n+/// A growable list type, written `Vec<T>` but pronounced 'vector.'\n ///\n /// # Examples\n ///\n@@ -66,7 +98,7 @@ use slice::CloneSliceExt;\n /// assert_eq!(vec, vec![1, 2, 3, 4]);\n /// ```\n ///\n-/// Use a `Vec` as an efficient stack:\n+/// Use a `Vec<T>` as an efficient stack:\n ///\n /// ```\n /// let mut stack = Vec::new();\n@@ -87,20 +119,17 @@ use slice::CloneSliceExt;\n ///\n /// # Capacity and reallocation\n ///\n-/// The capacity of a vector is the amount of space allocated for any future\n-/// elements that will be added onto the vector. This is not to be confused\n-/// with the *length* of a vector, which specifies the number of actual\n-/// elements within the vector. If a vector's length exceeds its capacity,\n-/// its capacity will automatically be increased, but its elements will\n-/// have to be reallocated.\n+/// The capacity of a vector is the amount of space allocated for any future elements that will be\n+/// added onto the vector. This is not to be confused with the *length* of a vector, which\n+/// specifies the number of actual elements within the vector. If a vector's length exceeds its\n+/// capacity, its capacity will automatically be increased, but its elements will have to be\n+/// reallocated.\n ///\n-/// For example, a vector with capacity 10 and length 0 would be an empty\n-/// vector with space for 10 more elements. Pushing 10 or fewer elements onto\n-/// the vector will not change its capacity or cause reallocation to occur.\n-/// However, if the vector's length is increased to 11, it will have to\n-/// reallocate, which can be slow. For this reason, it is recommended\n-/// to use `Vec::with_capacity` whenever possible to specify how big the vector\n-/// is expected to get.\n+/// For example, a vector with capacity 10 and length 0 would be an empty vector with space for 10\n+/// more elements. Pushing 10 or fewer elements onto the vector will not change its capacity or\n+/// cause reallocation to occur. However, if the vector's length is increased to 11, it will have\n+/// to reallocate, which can be slow. For this reason, it is recommended to use\n+/// `Vec::with_capacity` whenever possible to specify how big the vector is expected to get.\n #[unsafe_no_drop_flag]\n #[stable]\n pub struct Vec<T> {\n@@ -131,7 +160,7 @@ impl<'a, T> IntoCow<'a, Vec<T>, [T]> for &'a [T] where T: Clone {\n }\n \n impl<T> Vec<T> {\n-    /// Constructs a new, empty `Vec`.\n+    /// Constructs a new, empty `Vec<T>`.\n     ///\n     /// The vector will not allocate until elements are pushed onto it.\n     ///\n@@ -150,16 +179,15 @@ impl<T> Vec<T> {\n         Vec { ptr: EMPTY as *mut T, len: 0, cap: 0 }\n     }\n \n-    /// Constructs a new, empty `Vec` with the specified capacity.\n+    /// Constructs a new, empty `Vec<T>` with the specified capacity.\n     ///\n-    /// The vector will be able to hold exactly `capacity` elements without\n-    /// reallocating. If `capacity` is 0, the vector will not allocate.\n+    /// The vector will be able to hold exactly `capacity` elements without reallocating. If\n+    /// `capacity` is 0, the vector will not allocate.\n     ///\n-    /// It is important to note that this function does not specify the\n-    /// *length* of the returned vector, but only the *capacity*. (For an\n-    /// explanation of the difference between length and capacity, see\n-    /// the main `Vec` docs above, 'Capacity and reallocation'.) To create\n-    /// a vector of a given length, use `Vec::from_elem` or `Vec::from_fn`.\n+    /// It is important to note that this function does not specify the *length* of the returned\n+    /// vector, but only the *capacity*. (For an explanation of the difference between length and\n+    /// capacity, see the main `Vec<T>` docs above, 'Capacity and reallocation'.) To create a\n+    /// vector of a given length, use `Vec::from_elem` or `Vec::from_fn`.\n     ///\n     /// # Examples\n     ///\n@@ -193,10 +221,10 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Creates and initializes a `Vec`.\n+    /// Creates and initializes a `Vec<T>`.\n     ///\n-    /// Creates a `Vec` of size `length` and initializes the elements to the\n-    /// value returned by the closure `op`.\n+    /// Creates a `Vec<T>` of size `length` and initializes the elements to the value returned by\n+    /// the closure `op`.\n     ///\n     /// # Examples\n     ///\n@@ -261,10 +289,9 @@ impl<T> Vec<T> {\n \n     /// Creates a vector by copying the elements from a raw pointer.\n     ///\n-    /// This function will copy `elts` contiguous elements starting at `ptr`\n-    /// into a new allocation owned by the returned `Vec`. The elements of the\n-    /// buffer are copied into the vector without cloning, as if `ptr::read()`\n-    /// were called on them.\n+    /// This function will copy `elts` contiguous elements starting at `ptr` into a new allocation\n+    /// owned by the returned `Vec<T>`. The elements of the buffer are copied into the vector\n+    /// without cloning, as if `ptr::read()` were called on them.\n     #[inline]\n     #[unstable = \"just renamed from raw::from_buf\"]\n     pub unsafe fn from_raw_buf(ptr: *const T, elts: uint) -> Vec<T> {\n@@ -274,11 +301,10 @@ impl<T> Vec<T> {\n         dst\n     }\n \n-    /// Consumes the `Vec`, partitioning it based on a predicate.\n+    /// Consumes the `Vec<T>`, partitioning it based on a predicate.\n     ///\n-    /// Partitions the `Vec` into two `Vec`s `(A,B)`, where all elements of `A`\n-    /// satisfy `f` and all elements of `B` do not. The order of elements is\n-    /// preserved.\n+    /// Partitions the `Vec<T>` into two `Vec<T>`s `(A,B)`, where all elements of `A` satisfy `f`\n+    /// and all elements of `B` do not. The order of elements is preserved.\n     ///\n     /// # Examples\n     ///\n@@ -307,9 +333,9 @@ impl<T> Vec<T> {\n }\n \n impl<T: Clone> Vec<T> {\n-    /// Constructs a `Vec` with copies of a value.\n+    /// Constructs a `Vec<T>` with copies of a value.\n     ///\n-    /// Creates a `Vec` with `length` copies of `value`.\n+    /// Creates a `Vec<T>` with `length` copies of `value`.\n     ///\n     /// # Examples\n     ///\n@@ -332,10 +358,10 @@ impl<T: Clone> Vec<T> {\n         }\n     }\n \n-    /// Appends all elements in a slice to the `Vec`.\n+    /// Appends all elements in a slice to the `Vec<T>`.\n     ///\n     /// Iterates over the slice `other`, clones each element, and then appends\n-    /// it to this `Vec`. The `other` vector is traversed in-order.\n+    /// it to this `Vec<T>`. The `other` vector is traversed in-order.\n     ///\n     /// # Examples\n     ///\n@@ -364,9 +390,9 @@ impl<T: Clone> Vec<T> {\n         }\n     }\n \n-    /// Grows the `Vec` in-place.\n+    /// Grows the `Vec<T>` in-place.\n     ///\n-    /// Adds `n` copies of `value` to the `Vec`.\n+    /// Adds `n` copies of `value` to the `Vec<T>`.\n     ///\n     /// # Examples\n     ///\n@@ -388,7 +414,7 @@ impl<T: Clone> Vec<T> {\n \n     /// Partitions a vector based on a predicate.\n     ///\n-    /// Clones the elements of the vector, partitioning them into two `Vec`s\n+    /// Clones the elements of the vector, partitioning them into two `Vec<T>`s\n     /// `(a, b)`, where all elements of `a` satisfy `f` and all elements of `b`\n     /// do not. The order of elements is preserved.\n     ///\n@@ -647,8 +673,7 @@ unsafe fn dealloc<T>(ptr: *mut T, len: uint) {\n }\n \n impl<T> Vec<T> {\n-    /// Returns the number of elements the vector can hold without\n-    /// reallocating.\n+    /// Returns the number of elements the vector can hold without reallocating.\n     ///\n     /// # Examples\n     ///\n@@ -669,7 +694,7 @@ impl<T> Vec<T> {\n     }\n \n     /// Reserves capacity for at least `additional` more elements to be inserted in the given\n-    /// `Vec`. The collection may reserve more space to avoid frequent reallocations.\n+    /// `Vec<T>`. The collection may reserve more space to avoid frequent reallocations.\n     ///\n     /// # Panics\n     ///\n@@ -703,7 +728,7 @@ impl<T> Vec<T> {\n     }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n-    /// given `Vec`. Does nothing if the capacity is already sufficient.\n+    /// given `Vec<T>`. Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it requests. Therefore\n     /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n@@ -730,16 +755,19 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Shrinks the capacity of the vector as much as possible. It will drop\n-    /// down as close as possible to the length but the allocator may still\n-    /// inform the vector that there is space for a few more elements.\n+    /// Shrinks the capacity of the vector as much as possible.\n+    ///\n+    /// It will drop down as close as possible to the length but the allocator may still inform the\n+    /// vector that there is space for a few more elements.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// let mut vec: Vec<int> = Vec::with_capacity(10);\n+    ///\n     /// vec.push_all(&[1, 2, 3]);\n     /// assert_eq!(vec.capacity(), 10);\n+    ///\n     /// vec.shrink_to_fit();\n     /// assert!(vec.capacity() >= 3);\n     /// ```\n@@ -828,14 +856,14 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Creates a consuming iterator, that is, one that moves each\n-    /// value out of the vector (from start to end). The vector cannot\n-    /// be used after calling this.\n+    /// Creates a consuming iterator, that is, one that moves each value out of the vector (from\n+    /// start to end). The vector cannot be used after calling this.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// let v = vec![\"a\".to_string(), \"b\".to_string()];\n+    ///\n     /// for s in v.into_iter() {\n     ///     // s has type String, not &String\n     ///     println!(\"{}\", s);\n@@ -860,9 +888,8 @@ impl<T> Vec<T> {\n \n     /// Sets the length of a vector.\n     ///\n-    /// This will explicitly set the size of the vector, without actually\n-    /// modifying its buffers, so it is up to the caller to ensure that the\n-    /// vector is actually the specified size.\n+    /// This will explicitly set the size of the vector, without actually modifying its buffers, so\n+    /// it is up to the caller to ensure that the vector is actually the specified size.\n     ///\n     /// # Examples\n     ///\n@@ -878,8 +905,10 @@ impl<T> Vec<T> {\n         self.len = len;\n     }\n \n-    /// Removes an element from anywhere in the vector and return it, replacing\n-    /// it with the last element. This does not preserve ordering, but is O(1).\n+    /// Removes an element from anywhere in the vector and return it, replacing it with the last\n+    /// element.\n+    ///\n+    /// This does not preserve ordering, but is O(1).\n     ///\n     /// Returns `None` if `index` is out of bounds.\n     ///\n@@ -908,13 +937,12 @@ impl<T> Vec<T> {\n         self.pop()\n     }\n \n-    /// Inserts an element at position `index` within the vector, shifting all\n-    /// elements after position `i` one position to the right.\n+    /// Inserts an element at position `index` within the vector, shifting all elements after\n+    /// position `i` one position to the right.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `index` is not between `0` and the vector's length (both\n-    /// bounds inclusive).\n+    /// Panics if `index` is not between `0` and the vector's length (both bounds inclusive).\n     ///\n     /// # Examples\n     ///\n@@ -947,9 +975,9 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Removes and returns the element at position `index` within the vector,\n-    /// shifting all elements after position `index` one position to the left.\n-    /// Returns `None` if `i` is out of bounds.\n+    /// Removes and returns the element at position `index` within the vector, shifting all\n+    /// elements after position `index` one position to the left. Returns `None` if `i` is out of\n+    /// bounds.\n     ///\n     /// # Examples\n     ///\n@@ -988,8 +1016,8 @@ impl<T> Vec<T> {\n \n     /// Retains only the elements specified by the predicate.\n     ///\n-    /// In other words, remove all elements `e` such that `f(&e)` returns false.\n-    /// This method operates in place and preserves the order of the retained elements.\n+    /// In other words, remove all elements `e` such that `f(&e)` returns false. This method\n+    /// operates in place and preserves the order of the retained elements.\n     ///\n     /// # Examples\n     ///\n@@ -1078,8 +1106,7 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Removes the last element from a vector and returns it, or `None` if\n-    /// it is empty.\n+    /// Removes the last element from a vector and returns it, or `None` if it is empty.\n     ///\n     /// # Examples\n     ///\n@@ -1107,7 +1134,9 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut v = vec![1i, 2, 3];\n+    ///\n     /// v.clear();\n+    ///\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n@@ -1116,7 +1145,7 @@ impl<T> Vec<T> {\n         self.truncate(0)\n     }\n \n-    /// Return the number of elements in the vector\n+    /// Returns the number of elements in the vector.\n     ///\n     /// # Examples\n     ///\n@@ -1128,13 +1157,14 @@ impl<T> Vec<T> {\n     #[stable]\n     pub fn len(&self) -> uint { self.len }\n \n-    /// Returns true if the vector contains no elements\n+    /// Returns `true` if the vector contains no elements.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// let mut v = Vec::new();\n     /// assert!(v.is_empty());\n+    ///\n     /// v.push(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n@@ -1169,7 +1199,9 @@ impl<T: PartialEq> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![1i, 2, 2, 3, 2];\n+    ///\n     /// vec.dedup();\n+    ///\n     /// assert_eq!(vec, vec![1i, 2, 3, 2]);\n     /// ```\n     #[unstable = \"this function may be renamed\"]\n@@ -1330,6 +1362,7 @@ impl<T> Drop for Vec<T> {\n \n #[stable]\n impl<T> Default for Vec<T> {\n+    #[stable]\n     fn default() -> Vec<T> {\n         Vec::new()\n     }\n@@ -1441,10 +1474,9 @@ impl<T> Drop for MoveItems<T> {\n \n /// Converts an iterator of pairs into a pair of vectors.\n ///\n-/// Returns a tuple containing two vectors where the i-th element of the first\n-/// vector contains the first element of the i-th tuple of the input iterator,\n-/// and the i-th element of the second vector contains the second element\n-/// of the i-th tuple of the input iterator.\n+/// Returns a tuple containing two vectors where the i-th element of the first vector contains the\n+/// first element of the i-th tuple of the input iterator, and the i-th element of the second\n+/// vector contains the second element of the i-th tuple of the input iterator.\n #[unstable = \"this functionality may become more generic over time\"]\n pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (Vec<T>, Vec<U>) {\n     let (lo, _) = iter.size_hint();"}, {"sha": "9f1a0075352b10f094fd66c9b3ba6e8a19473fee", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 47, "deletions": 14, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -19,7 +19,7 @@ use core::default::Default;\n use core::fmt;\n use core::hash::{Hash, Writer};\n use core::iter;\n-use core::iter::{Enumerate, FilterMap};\n+use core::iter::{Enumerate, FilterMap, Map};\n use core::mem::replace;\n use core::ops::FnOnce;\n \n@@ -66,7 +66,9 @@ pub struct VecMap<V> {\n     v: Vec<Option<V>>,\n }\n \n+#[stable]\n impl<V> Default for VecMap<V> {\n+    #[stable]\n     #[inline]\n     fn default() -> VecMap<V> { VecMap::new() }\n }\n@@ -144,7 +146,7 @@ impl<V> VecMap<V> {\n     pub fn keys<'r>(&'r self) -> Keys<'r, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n \n-        self.iter().map(first)\n+        Keys { iter: self.iter().map(first) }\n     }\n \n     /// Returns an iterator visiting all values in ascending order by the keys.\n@@ -153,7 +155,7 @@ impl<V> VecMap<V> {\n     pub fn values<'r>(&'r self) -> Values<'r, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n \n-        self.iter().map(second)\n+        Values { iter: self.iter().map(second) }\n     }\n \n     /// Returns an iterator visiting all key-value pairs in ascending order by the keys.\n@@ -240,7 +242,7 @@ impl<V> VecMap<V> {\n         }\n \n         let values = replace(&mut self.v, vec!());\n-        values.into_iter().enumerate().filter_map(filter)\n+        MoveItems { iter: values.into_iter().enumerate().filter_map(filter) }\n     }\n \n     /// Return the number of elements in the map.\n@@ -603,7 +605,7 @@ macro_rules! double_ended_iterator {\n     }\n }\n \n-/// Forward iterator over a map.\n+/// An iterator over the key-value pairs of a map.\n pub struct Entries<'a, V:'a> {\n     front: uint,\n     back: uint,\n@@ -613,7 +615,7 @@ pub struct Entries<'a, V:'a> {\n iterator!(impl Entries -> (uint, &'a V), as_ref)\n double_ended_iterator!(impl Entries -> (uint, &'a V), as_ref)\n \n-/// Forward iterator over the key-value pairs of a map, with the\n+/// An iterator over the key-value pairs of a map, with the\n /// values being mutable.\n pub struct MutEntries<'a, V:'a> {\n     front: uint,\n@@ -624,19 +626,50 @@ pub struct MutEntries<'a, V:'a> {\n iterator!(impl MutEntries -> (uint, &'a mut V), as_mut)\n double_ended_iterator!(impl MutEntries -> (uint, &'a mut V), as_mut)\n \n-/// Forward iterator over the keys of a map\n-pub type Keys<'a, V> = iter::Map<(uint, &'a V), uint, Entries<'a, V>, fn((uint, &'a V)) -> uint>;\n+/// An iterator over the keys of a map.\n+pub struct Keys<'a, V: 'a> {\n+    iter: Map<(uint, &'a V), uint, Entries<'a, V>, fn((uint, &'a V)) -> uint>\n+}\n \n-/// Forward iterator over the values of a map\n-pub type Values<'a, V> =\n-    iter::Map<(uint, &'a V), &'a V, Entries<'a, V>, fn((uint, &'a V)) -> &'a V>;\n+/// An iterator over the values of a map.\n+pub struct Values<'a, V: 'a> {\n+    iter: Map<(uint, &'a V), &'a V, Entries<'a, V>, fn((uint, &'a V)) -> &'a V>\n+}\n \n-/// Iterator over the key-value pairs of a map, the iterator consumes the map\n-pub type MoveItems<V> = FilterMap<\n+/// A consuming iterator over the key-value pairs of a map.\n+pub struct MoveItems<V> {\n+    iter: FilterMap<\n     (uint, Option<V>),\n     (uint, V),\n     Enumerate<vec::MoveItems<Option<V>>>,\n-    fn((uint, Option<V>)) -> Option<(uint, V)>>;\n+    fn((uint, Option<V>)) -> Option<(uint, V)>>\n+}\n+\n+impl<'a, V> Iterator<uint> for Keys<'a, V> {\n+    fn next(&mut self) -> Option<uint> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+impl<'a, V> DoubleEndedIterator<uint> for Keys<'a, V> {\n+    fn next_back(&mut self) -> Option<uint> { self.iter.next_back() }\n+}\n+\n+\n+impl<'a, V> Iterator<&'a V> for Values<'a, V> {\n+    fn next(&mut self) -> Option<(&'a V)> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+impl<'a, V> DoubleEndedIterator<&'a V> for Values<'a, V> {\n+    fn next_back(&mut self) -> Option<(&'a V)> { self.iter.next_back() }\n+}\n+\n+\n+impl<V> Iterator<(uint, V)> for MoveItems<V> {\n+    fn next(&mut self) -> Option<(uint, V)> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+impl<V> DoubleEndedIterator<(uint, V)> for MoveItems<V> {\n+    fn next_back(&mut self) -> Option<(uint, V)> { self.iter.next_back() }\n+}\n \n #[cfg(test)]\n mod test_map {"}, {"sha": "bb2fed19e2afdb8d79cc83a2a7ac2505b053dbe5", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -15,36 +15,31 @@\n pub use self::Ordering::*;\n \n use intrinsics;\n-use std::kinds::marker;\n use cell::UnsafeCell;\n use kinds::Copy;\n \n /// A boolean type which can be safely shared between threads.\n #[stable]\n pub struct AtomicBool {\n     v: UnsafeCell<uint>,\n-    nocopy: marker::NoCopy\n }\n \n /// A signed integer type which can be safely shared between threads.\n #[stable]\n pub struct AtomicInt {\n     v: UnsafeCell<int>,\n-    nocopy: marker::NoCopy\n }\n \n /// An unsigned integer type which can be safely shared between threads.\n #[stable]\n pub struct AtomicUint {\n     v: UnsafeCell<uint>,\n-    nocopy: marker::NoCopy\n }\n \n /// A raw pointer type which can be safely shared between threads.\n #[stable]\n pub struct AtomicPtr<T> {\n     p: UnsafeCell<uint>,\n-    nocopy: marker::NoCopy\n }\n \n /// Atomic memory orderings\n@@ -87,15 +82,15 @@ impl Copy for Ordering {}\n /// An `AtomicBool` initialized to `false`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n pub const INIT_ATOMIC_BOOL: AtomicBool =\n-        AtomicBool { v: UnsafeCell { value: 0 }, nocopy: marker::NoCopy };\n+        AtomicBool { v: UnsafeCell { value: 0 } };\n /// An `AtomicInt` initialized to `0`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n pub const INIT_ATOMIC_INT: AtomicInt =\n-        AtomicInt { v: UnsafeCell { value: 0 }, nocopy: marker::NoCopy };\n+        AtomicInt { v: UnsafeCell { value: 0 } };\n /// An `AtomicUint` initialized to `0`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n pub const INIT_ATOMIC_UINT: AtomicUint =\n-        AtomicUint { v: UnsafeCell { value: 0, }, nocopy: marker::NoCopy };\n+        AtomicUint { v: UnsafeCell { value: 0, } };\n \n // NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n const UINT_TRUE: uint = -1;\n@@ -115,7 +110,7 @@ impl AtomicBool {\n     #[stable]\n     pub fn new(v: bool) -> AtomicBool {\n         let val = if v { UINT_TRUE } else { 0 };\n-        AtomicBool { v: UnsafeCell::new(val), nocopy: marker::NoCopy }\n+        AtomicBool { v: UnsafeCell::new(val) }\n     }\n \n     /// Loads a value from the bool.\n@@ -355,7 +350,7 @@ impl AtomicInt {\n     #[inline]\n     #[stable]\n     pub fn new(v: int) -> AtomicInt {\n-        AtomicInt {v: UnsafeCell::new(v), nocopy: marker::NoCopy}\n+        AtomicInt {v: UnsafeCell::new(v)}\n     }\n \n     /// Loads a value from the int.\n@@ -541,7 +536,7 @@ impl AtomicUint {\n     #[inline]\n     #[stable]\n     pub fn new(v: uint) -> AtomicUint {\n-        AtomicUint { v: UnsafeCell::new(v), nocopy: marker::NoCopy }\n+        AtomicUint { v: UnsafeCell::new(v) }\n     }\n \n     /// Loads a value from the uint.\n@@ -728,7 +723,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable]\n     pub fn new(p: *mut T) -> AtomicPtr<T> {\n-        AtomicPtr { p: UnsafeCell::new(p as uint), nocopy: marker::NoCopy }\n+        AtomicPtr { p: UnsafeCell::new(p as uint) }\n     }\n \n     /// Loads a value from the pointer."}, {"sha": "01979e975774c4b491b708b1d8017f843aabc4d4", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -215,8 +215,9 @@ impl<T:Copy> Clone for Cell<T> {\n     }\n }\n \n-#[unstable]\n+#[stable]\n impl<T:Default + Copy> Default for Cell<T> {\n+    #[stable]\n     fn default() -> Cell<T> {\n         Cell::new(Default::default())\n     }\n@@ -234,7 +235,6 @@ impl<T:PartialEq + Copy> PartialEq for Cell<T> {\n pub struct RefCell<T> {\n     value: UnsafeCell<T>,\n     borrow: Cell<BorrowFlag>,\n-    nocopy: marker::NoCopy,\n     noshare: marker::NoSync,\n }\n \n@@ -251,7 +251,6 @@ impl<T> RefCell<T> {\n         RefCell {\n             value: UnsafeCell::new(value),\n             borrow: Cell::new(UNUSED),\n-            nocopy: marker::NoCopy,\n             noshare: marker::NoSync,\n         }\n     }\n@@ -349,8 +348,9 @@ impl<T: Clone> Clone for RefCell<T> {\n     }\n }\n \n-#[unstable]\n+#[stable]\n impl<T:Default> Default for RefCell<T> {\n+    #[stable]\n     fn default() -> RefCell<T> {\n         RefCell::new(Default::default())\n     }"}, {"sha": "9c12b3f68d3de71603f732bdb14a3448d88c554c", "filename": "src/libcore/char.rs", "status": "modified", "additions": 69, "deletions": 76, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -15,11 +15,11 @@\n #![allow(non_snake_case)]\n #![doc(primitive = \"char\")]\n \n+use iter::Iterator;\n use mem::transmute;\n use ops::FnMut;\n-use option::Option;\n use option::Option::{None, Some};\n-use iter::{range_step, Iterator, RangeStep};\n+use option::Option;\n use slice::SliceExt;\n \n // UTF-8 ranges and tags for encoding characters\n@@ -141,7 +141,7 @@ pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n #[unstable = \"pending decisions about costructors for primitives\"]\n pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     if radix > 36 {\n-        panic!(\"from_digit: radix is to high (maximum 36)\");\n+        panic!(\"from_digit: radix is too high (maximum 36)\");\n     }\n     if num < radix {\n         unsafe {\n@@ -156,34 +156,15 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     }\n }\n \n-///\n-/// Returns the hexadecimal Unicode escape of a `char`\n-///\n-/// The rules are as follows:\n-///\n-/// - chars in [0,0xff] get 2-digit escapes: `\\\\xNN`\n-/// - chars in [0x100,0xffff] get 4-digit escapes: `\\\\u{NNNN}`\n-/// - chars above 0x10000 get 8-digit escapes: `\\\\u{{NNN}NNNNN}`\n-///\n+/// Deprecated, call the escape_unicode method instead.\n #[deprecated = \"use the Char::escape_unicode method\"]\n pub fn escape_unicode<F>(c: char, mut f: F) where F: FnMut(char) {\n     for char in c.escape_unicode() {\n         f(char);\n     }\n }\n \n-///\n-/// Returns a 'default' ASCII and C++11-like literal escape of a `char`\n-///\n-/// The default is chosen with a bias toward producing literals that are\n-/// legal in a variety of languages, including C++11 and similar C-family\n-/// languages. The exact rules are:\n-///\n-/// - Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n-/// - Single-quote, double-quote and backslash chars are backslash-escaped.\n-/// - Any other chars in the range [0x20,0x7e] are not escaped.\n-/// - Any other chars are given hex Unicode escapes; see `escape_unicode`.\n-///\n+/// Deprecated, call the escape_default method instead.\n #[deprecated = \"use the Char::escape_default method\"]\n pub fn escape_default<F>(c: char, mut f: F) where F: FnMut(char) {\n     for c in c.escape_default() {\n@@ -267,13 +248,11 @@ pub trait Char {\n     /// Returns an iterator that yields the hexadecimal Unicode escape\n     /// of a character, as `char`s.\n     ///\n-    /// The rules are as follows:\n-    ///\n-    /// * Characters in [0,0xff] get 2-digit escapes: `\\\\xNN`\n-    /// * Characters in [0x100,0xffff] get 4-digit escapes: `\\\\u{NNNN}`.\n-    /// * Characters above 0x10000 get 8-digit escapes: `\\\\u{{NNN}NNNNN}`.\n+    /// All characters are escaped with Rust syntax of the form `\\\\u{NNNN}`\n+    /// where `NNNN` is the shortest hexadecimal representation of the code\n+    /// point.\n     #[unstable = \"pending error conventions, trait organization\"]\n-    fn escape_unicode(self) -> UnicodeEscapedChars;\n+    fn escape_unicode(self) -> EscapeUnicode;\n \n     /// Returns an iterator that yields the 'default' ASCII and\n     /// C++11-like literal escape of a character, as `char`s.\n@@ -288,7 +267,7 @@ pub trait Char {\n     /// * Any other chars in the range [0x20,0x7e] are not escaped.\n     /// * Any other chars are given hex Unicode escapes; see `escape_unicode`.\n     #[unstable = \"pending error conventions, trait organization\"]\n-    fn escape_default(self) -> DefaultEscapedChars;\n+    fn escape_default(self) -> EscapeDefault;\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-8.\n@@ -358,23 +337,23 @@ impl Char for char {\n     fn from_u32(i: u32) -> Option<char> { from_u32(i) }\n \n     #[unstable = \"pending error conventions, trait organization\"]\n-    fn escape_unicode(self) -> UnicodeEscapedChars {\n-        UnicodeEscapedChars { c: self, state: UnicodeEscapedCharsState::Backslash }\n+    fn escape_unicode(self) -> EscapeUnicode {\n+        EscapeUnicode { c: self, state: EscapeUnicodeState::Backslash }\n     }\n \n     #[unstable = \"pending error conventions, trait organization\"]\n-    fn escape_default(self) -> DefaultEscapedChars {\n+    fn escape_default(self) -> EscapeDefault {\n         let init_state = match self {\n-            '\\t' => DefaultEscapedCharsState::Backslash('t'),\n-            '\\r' => DefaultEscapedCharsState::Backslash('r'),\n-            '\\n' => DefaultEscapedCharsState::Backslash('n'),\n-            '\\\\' => DefaultEscapedCharsState::Backslash('\\\\'),\n-            '\\'' => DefaultEscapedCharsState::Backslash('\\''),\n-            '\"'  => DefaultEscapedCharsState::Backslash('\"'),\n-            '\\x20' ... '\\x7e' => DefaultEscapedCharsState::Char(self),\n-            _ => DefaultEscapedCharsState::Unicode(self.escape_unicode())\n+            '\\t' => EscapeDefaultState::Backslash('t'),\n+            '\\r' => EscapeDefaultState::Backslash('r'),\n+            '\\n' => EscapeDefaultState::Backslash('n'),\n+            '\\\\' => EscapeDefaultState::Backslash('\\\\'),\n+            '\\'' => EscapeDefaultState::Backslash('\\''),\n+            '\"'  => EscapeDefaultState::Backslash('\"'),\n+            '\\x20' ... '\\x7e' => EscapeDefaultState::Char(self),\n+            _ => EscapeDefaultState::Unicode(self.escape_unicode())\n         };\n-        DefaultEscapedChars { state: init_state }\n+        EscapeDefault { state: init_state }\n     }\n \n     #[inline]\n@@ -451,72 +430,86 @@ impl Char for char {\n \n /// An iterator over the characters that represent a `char`, as escaped by\n /// Rust's unicode escaping rules.\n-pub struct UnicodeEscapedChars {\n+pub struct EscapeUnicode {\n     c: char,\n-    state: UnicodeEscapedCharsState\n+    state: EscapeUnicodeState\n }\n \n-enum UnicodeEscapedCharsState {\n+enum EscapeUnicodeState {\n     Backslash,\n     Type,\n-    Value(RangeStep<i32>),\n+    LeftBrace,\n+    Value(uint),\n+    RightBrace,\n+    Done,\n }\n \n-impl Iterator<char> for UnicodeEscapedChars {\n+impl Iterator<char> for EscapeUnicode {\n     fn next(&mut self) -> Option<char> {\n         match self.state {\n-            UnicodeEscapedCharsState::Backslash => {\n-                self.state = UnicodeEscapedCharsState::Type;\n+            EscapeUnicodeState::Backslash => {\n+                self.state = EscapeUnicodeState::Type;\n                 Some('\\\\')\n             }\n-            UnicodeEscapedCharsState::Type => {\n-                let (typechar, pad) = if self.c <= '\\x7f' { ('x', 2) }\n-                                      else if self.c <= '\\u{ffff}' { ('u', 4) }\n-                                      else { ('U', 8) };\n-                self.state = UnicodeEscapedCharsState::Value(range_step(4 * (pad - 1), -1, -4i32));\n-                Some(typechar)\n+            EscapeUnicodeState::Type => {\n+                self.state = EscapeUnicodeState::LeftBrace;\n+                Some('u')\n             }\n-            UnicodeEscapedCharsState::Value(ref mut range_step) => match range_step.next() {\n-                Some(offset) => {\n-                    let offset = offset as uint;\n-                    let v = match ((self.c as i32) >> offset) & 0xf {\n-                        i @ 0 ... 9 => '0' as i32 + i,\n-                        i => 'a' as i32 + (i - 10)\n-                    };\n-                    Some(unsafe { transmute(v) })\n+            EscapeUnicodeState::LeftBrace => {\n+                let mut n = 0u;\n+                while (self.c as u32) >> (4 * (n + 1)) != 0 {\n+                    n += 1;\n                 }\n-                None => None\n+                self.state = EscapeUnicodeState::Value(n);\n+                Some('{')\n+            }\n+            EscapeUnicodeState::Value(offset) => {\n+                let v = match ((self.c as i32) >> (offset * 4)) & 0xf {\n+                    i @ 0 ... 9 => '0' as i32 + i,\n+                    i => 'a' as i32 + (i - 10)\n+                };\n+                if offset == 0 {\n+                    self.state = EscapeUnicodeState::RightBrace;\n+                } else {\n+                    self.state = EscapeUnicodeState::Value(offset - 1);\n+                }\n+                Some(unsafe { transmute(v) })\n+            }\n+            EscapeUnicodeState::RightBrace => {\n+                self.state = EscapeUnicodeState::Done;\n+                Some('}')\n             }\n+            EscapeUnicodeState::Done => None,\n         }\n     }\n }\n \n /// An iterator over the characters that represent a `char`, escaped\n /// for maximum portability.\n-pub struct DefaultEscapedChars {\n-    state: DefaultEscapedCharsState\n+pub struct EscapeDefault {\n+    state: EscapeDefaultState\n }\n \n-enum DefaultEscapedCharsState {\n+enum EscapeDefaultState {\n     Backslash(char),\n     Char(char),\n     Done,\n-    Unicode(UnicodeEscapedChars),\n+    Unicode(EscapeUnicode),\n }\n \n-impl Iterator<char> for DefaultEscapedChars {\n+impl Iterator<char> for EscapeDefault {\n     fn next(&mut self) -> Option<char> {\n         match self.state {\n-            DefaultEscapedCharsState::Backslash(c) => {\n-                self.state = DefaultEscapedCharsState::Char(c);\n+            EscapeDefaultState::Backslash(c) => {\n+                self.state = EscapeDefaultState::Char(c);\n                 Some('\\\\')\n             }\n-            DefaultEscapedCharsState::Char(c) => {\n-                self.state = DefaultEscapedCharsState::Done;\n+            EscapeDefaultState::Char(c) => {\n+                self.state = EscapeDefaultState::Done;\n                 Some(c)\n             }\n-            DefaultEscapedCharsState::Done => None,\n-            DefaultEscapedCharsState::Unicode(ref mut iter) => iter.next()\n+            EscapeDefaultState::Done => None,\n+            EscapeDefaultState::Unicode(ref mut iter) => iter.next()\n         }\n     }\n }"}, {"sha": "10facfe4750f9922175c50cb7c9d78915b97dc5a", "filename": "src/libcore/default.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -97,6 +97,7 @@\n ///     bar: f32,\n /// }\n /// ```\n+#[stable]\n pub trait Default {\n     /// Returns the \"default value\" for a type.\n     ///\n@@ -130,13 +131,16 @@ pub trait Default {\n     ///     fn default() -> Kind { Kind::A }\n     /// }\n     /// ```\n+    #[stable]\n     fn default() -> Self;\n }\n \n macro_rules! default_impl(\n     ($t:ty, $v:expr) => {\n+        #[stable]\n         impl Default for $t {\n             #[inline]\n+            #[stable]\n             fn default() -> $t { $v }\n         }\n     }"}, {"sha": "1f511ed759ed8608580333d7613212d66a83ad87", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -203,8 +203,10 @@ impl Clone for SipState {\n     }\n }\n \n+#[stable]\n impl Default for SipState {\n     #[inline]\n+    #[stable]\n     fn default() -> SipState {\n         SipState::new()\n     }"}, {"sha": "e2afee9905d7f9d8f8dfcd0399694dff10bfd029", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -217,6 +217,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// `forget` is unsafe because the caller is responsible for\n     /// ensuring the argument is deallocated already.\n+    #[stable]\n     pub fn forget<T>(_: T) -> ();\n \n     /// Unsafely transforms a value of one type into a value of another type.\n@@ -232,6 +233,7 @@ extern \"rust-intrinsic\" {\n     /// let v: &[u8] = unsafe { mem::transmute(\"L\") };\n     /// assert!(v == [76u8]);\n     /// ```\n+    #[stable]\n     pub fn transmute<T,U>(e: T) -> U;\n \n     /// Gives the address for the return value of the enclosing function."}, {"sha": "7e0380e8785a634fa6dd527cb1bce9b5025f5dff", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 150, "deletions": 26, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -110,8 +110,8 @@ pub trait Iterator<A> {\n #[unstable = \"new convention for extension traits\"]\n /// An extension trait providing numerous methods applicable to all iterators.\n pub trait IteratorExt<A>: Iterator<A> {\n-    /// Chain this iterator with another, returning a new iterator which will\n-    /// finish iterating over the current iterator, and then it will iterate\n+    /// Chain this iterator with another, returning a new iterator that will\n+    /// finish iterating over the current iterator, and then iterate\n     /// over the other specified iterator.\n     ///\n     /// # Example\n@@ -130,7 +130,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n         Chain{a: self, b: other, flag: false}\n     }\n \n-    /// Creates an iterator which iterates over both this and the specified\n+    /// Creates an iterator that iterates over both this and the specified\n     /// iterators simultaneously, yielding the two elements as pairs. When\n     /// either iterator returns None, all further invocations of next() will\n     /// return None.\n@@ -151,7 +151,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n         Zip{a: self, b: other}\n     }\n \n-    /// Creates a new iterator which will apply the specified function to each\n+    /// Creates a new iterator that will apply the specified function to each\n     /// element returned by the first, yielding the mapped element instead.\n     ///\n     /// # Example\n@@ -169,8 +169,8 @@ pub trait IteratorExt<A>: Iterator<A> {\n         Map{iter: self, f: f}\n     }\n \n-    /// Creates an iterator which applies the predicate to each element returned\n-    /// by this iterator. Only elements which have the predicate evaluate to\n+    /// Creates an iterator that applies the predicate to each element returned\n+    /// by this iterator. Only elements that have the predicate evaluate to\n     /// `true` will be yielded.\n     ///\n     /// # Example\n@@ -187,7 +187,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n         Filter{iter: self, predicate: predicate}\n     }\n \n-    /// Creates an iterator which both filters and maps elements.\n+    /// Creates an iterator that both filters and maps elements.\n     /// If the specified function returns None, the element is skipped.\n     /// Otherwise the option is unwrapped and the new value is yielded.\n     ///\n@@ -205,7 +205,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n         FilterMap { iter: self, f: f }\n     }\n \n-    /// Creates an iterator which yields a pair of the value returned by this\n+    /// Creates an iterator that yields a pair of the value returned by this\n     /// iterator plus the current index of iteration.\n     ///\n     /// # Example\n@@ -248,7 +248,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n         Peekable{iter: self, peeked: None}\n     }\n \n-    /// Creates an iterator which invokes the predicate on elements until it\n+    /// Creates an iterator that invokes the predicate on elements until it\n     /// returns false. Once the predicate returns false, all further elements are\n     /// yielded.\n     ///\n@@ -268,7 +268,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n         SkipWhile{iter: self, flag: false, predicate: predicate}\n     }\n \n-    /// Creates an iterator which yields elements so long as the predicate\n+    /// Creates an iterator that yields elements so long as the predicate\n     /// returns true. After the predicate returns false for the first time, no\n     /// further elements will be yielded.\n     ///\n@@ -287,8 +287,8 @@ pub trait IteratorExt<A>: Iterator<A> {\n         TakeWhile{iter: self, flag: false, predicate: predicate}\n     }\n \n-    /// Creates an iterator which skips the first `n` elements of this iterator,\n-    /// and then it yields all further items.\n+    /// Creates an iterator that skips the first `n` elements of this iterator,\n+    /// and then yields all further items.\n     ///\n     /// # Example\n     ///\n@@ -305,8 +305,8 @@ pub trait IteratorExt<A>: Iterator<A> {\n         Skip{iter: self, n: n}\n     }\n \n-    /// Creates an iterator which yields the first `n` elements of this\n-    /// iterator, and then it will always return None.\n+    /// Creates an iterator that yields the first `n` elements of this\n+    /// iterator, and then will always return None.\n     ///\n     /// # Example\n     ///\n@@ -324,7 +324,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n         Take{iter: self, n: n}\n     }\n \n-    /// Creates a new iterator which behaves in a similar fashion to fold.\n+    /// Creates a new iterator that behaves in a similar fashion to fold.\n     /// There is a state which is passed between each iteration and can be\n     /// mutated as necessary. The yielded values from the closure are yielded\n     /// from the Scan instance when not None.\n@@ -1223,7 +1223,7 @@ impl<A, T: Clone + RandomAccessIterator<A>> RandomAccessIterator<A> for Cycle<T>\n     }\n }\n \n-/// An iterator which strings two iterators together\n+/// An iterator that strings two iterators together\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n@@ -1297,7 +1297,7 @@ for Chain<T, U> {\n     }\n }\n \n-/// An iterator which iterates two other iterators simultaneously\n+/// An iterator that iterates two other iterators simultaneously\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n@@ -1380,14 +1380,27 @@ RandomAccessIterator<(A, B)> for Zip<T, U> {\n     }\n }\n \n-/// An iterator which maps the values of `iter` with `f`\n+/// An iterator that maps the values of `iter` with `f`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n pub struct Map<A, B, I: Iterator<A>, F: FnMut(A) -> B> {\n     iter: I,\n     f: F,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, B, I, F> Clone for Map<A, B, I, F> where\n+    I: Clone + Iterator<A>,\n+    F: Clone + FnMut(A) -> B,\n+{\n+    fn clone(&self) -> Map<A, B, I, F> {\n+        Map {\n+            iter: self.iter.clone(),\n+            f: self.f.clone(),\n+        }\n+    }\n+}\n+\n impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<A>, F: FnMut(A) -> B {\n     #[inline]\n     fn do_map(&mut self, elt: Option<A>) -> Option<B> {\n@@ -1441,14 +1454,27 @@ impl<A, B, I, F> RandomAccessIterator<B> for Map<A, B, I, F> where\n     }\n }\n \n-/// An iterator which filters the elements of `iter` with `predicate`\n+/// An iterator that filters the elements of `iter` with `predicate`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n pub struct Filter<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n     iter: I,\n     predicate: P,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, I, P> Clone for Filter<A, I, P> where\n+    I: Clone + Iterator<A>,\n+    P: Clone + FnMut(&A) -> bool,\n+{\n+    fn clone(&self) -> Filter<A, I, P> {\n+        Filter {\n+            iter: self.iter.clone(),\n+            predicate: self.predicate.clone(),\n+        }\n+    }\n+}\n+\n #[unstable = \"trait is unstable\"]\n impl<A, I, P> Iterator<A> for Filter<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n     #[inline]\n@@ -1486,14 +1512,27 @@ impl<A, I, P> DoubleEndedIterator<A> for Filter<A, I, P> where\n     }\n }\n \n-/// An iterator which uses `f` to both filter and map elements from `iter`\n+/// An iterator that uses `f` to both filter and map elements from `iter`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n pub struct FilterMap<A, B, I, F> where I: Iterator<A>, F: FnMut(A) -> Option<B> {\n     iter: I,\n     f: F,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where\n+    I: Clone + Iterator<A>,\n+    F: Clone + FnMut(A) -> Option<B>,\n+{\n+    fn clone(&self) -> FilterMap<A, B, I, F> {\n+        FilterMap {\n+            iter: self.iter.clone(),\n+            f: self.f.clone(),\n+        }\n+    }\n+}\n+\n #[unstable = \"trait is unstable\"]\n impl<A, B, I, F> Iterator<B> for FilterMap<A, B, I, F> where\n     I: Iterator<A>,\n@@ -1534,7 +1573,7 @@ impl<A, B, I, F> DoubleEndedIterator<B> for FilterMap<A, B, I, F> where\n     }\n }\n \n-/// An iterator which yields the current count and the element during iteration\n+/// An iterator that yields the current count and the element during iteration\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n@@ -1648,7 +1687,7 @@ impl<'a, A, T: Iterator<A>> Peekable<A, T> {\n     }\n }\n \n-/// An iterator which rejects elements while `predicate` is true\n+/// An iterator that rejects elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n pub struct SkipWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n@@ -1657,6 +1696,20 @@ pub struct SkipWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n     predicate: P,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, I, P> Clone for SkipWhile<A, I, P> where\n+    I: Clone + Iterator<A>,\n+    P: Clone + FnMut(&A) -> bool,\n+{\n+    fn clone(&self) -> SkipWhile<A, I, P> {\n+        SkipWhile {\n+            iter: self.iter.clone(),\n+            flag: self.flag,\n+            predicate: self.predicate.clone(),\n+        }\n+    }\n+}\n+\n #[unstable = \"trait is unstable\"]\n impl<A, I, P> Iterator<A> for SkipWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n     #[inline]\n@@ -1677,7 +1730,7 @@ impl<A, I, P> Iterator<A> for SkipWhile<A, I, P> where I: Iterator<A>, P: FnMut(\n     }\n }\n \n-/// An iterator which only accepts elements while `predicate` is true\n+/// An iterator that only accepts elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n pub struct TakeWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n@@ -1686,6 +1739,20 @@ pub struct TakeWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n     predicate: P,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, I, P> Clone for TakeWhile<A, I, P> where\n+    I: Clone + Iterator<A>,\n+    P: Clone + FnMut(&A) -> bool,\n+{\n+    fn clone(&self) -> TakeWhile<A, I, P> {\n+        TakeWhile {\n+            iter: self.iter.clone(),\n+            flag: self.flag,\n+            predicate: self.predicate.clone(),\n+        }\n+    }\n+}\n+\n #[unstable = \"trait is unstable\"]\n impl<A, I, P> Iterator<A> for TakeWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n     #[inline]\n@@ -1714,7 +1781,7 @@ impl<A, I, P> Iterator<A> for TakeWhile<A, I, P> where I: Iterator<A>, P: FnMut(\n     }\n }\n \n-/// An iterator which skips over `n` elements of `iter`.\n+/// An iterator that skips over `n` elements of `iter`.\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n@@ -1782,7 +1849,7 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Skip<T> {\n     }\n }\n \n-/// An iterator which only iterates over the first `n` iterations of `iter`.\n+/// An iterator that only iterates over the first `n` iterations of `iter`.\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n@@ -1847,6 +1914,21 @@ pub struct Scan<A, B, I, St, F> where I: Iterator<A>, F: FnMut(&mut St, A) -> Op\n     pub state: St,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where\n+    I: Clone + Iterator<A>,\n+    St: Clone,\n+    F: Clone + FnMut(&mut St, A) -> Option<B>,\n+{\n+    fn clone(&self) -> Scan<A, B, I, St, F> {\n+        Scan {\n+            iter: self.iter.clone(),\n+            f: self.f.clone(),\n+            state: self.state.clone(),\n+        }\n+    }\n+}\n+\n #[unstable = \"trait is unstable\"]\n impl<A, B, I, St, F> Iterator<B> for Scan<A, B, I, St, F> where\n     I: Iterator<A>,\n@@ -1876,6 +1958,22 @@ pub struct FlatMap<A, B, I, U, F> where I: Iterator<A>, U: Iterator<B>, F: FnMut\n     backiter: Option<U>,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where\n+    I: Clone + Iterator<A>,\n+    U: Clone + Iterator<B>,\n+    F: Clone + FnMut(A) -> U,\n+{\n+    fn clone(&self) -> FlatMap<A, B, I, U, F> {\n+        FlatMap {\n+            iter: self.iter.clone(),\n+            f: self.f.clone(),\n+            frontiter: self.frontiter.clone(),\n+            backiter: self.backiter.clone(),\n+        }\n+    }\n+}\n+\n #[unstable = \"trait is unstable\"]\n impl<A, B, I, U, F> Iterator<B> for FlatMap<A, B, I, U, F> where\n     I: Iterator<A>,\n@@ -2020,6 +2118,19 @@ pub struct Inspect<A, I, F> where I: Iterator<A>, F: FnMut(&A) {\n     f: F,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, I, F> Clone for Inspect<A, I, F> where\n+    I: Clone + Iterator<A>,\n+    F: Clone + FnMut(&A),\n+{\n+    fn clone(&self) -> Inspect<A, I, F> {\n+        Inspect {\n+            iter: self.iter.clone(),\n+            f: self.f.clone(),\n+        }\n+    }\n+}\n+\n impl<A, I, F> Inspect<A, I, F> where I: Iterator<A>, F: FnMut(&A) {\n     #[inline]\n     fn do_inspect(&mut self, elt: Option<A>) -> Option<A> {\n@@ -2075,7 +2186,7 @@ impl<A, I, F> RandomAccessIterator<A> for Inspect<A, I, F> where\n     }\n }\n \n-/// An iterator which passes mutable state to a closure and yields the result.\n+/// An iterator that passes mutable state to a closure and yields the result.\n ///\n /// # Example: The Fibonacci Sequence\n ///\n@@ -2114,6 +2225,19 @@ pub struct Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     pub state: St,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, St, F> Clone for Unfold<A, St, F> where\n+    F: Clone + FnMut(&mut St) -> Option<A>,\n+    St: Clone,\n+{\n+    fn clone(&self) -> Unfold<A, St, F> {\n+        Unfold {\n+            f: self.f.clone(),\n+            state: self.state.clone(),\n+        }\n+    }\n+}\n+\n #[experimental]\n impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     /// Creates a new iterator with the specified closure as the \"iterator"}, {"sha": "69f65e23389f3e804eed4b008277f086d066f22b", "filename": "src/libcore/kinds.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -259,13 +259,14 @@ pub mod marker {\n     #[deriving(Clone, PartialEq, Eq, PartialOrd, Ord)]\n     pub struct InvariantLifetime<'a>;\n \n+    impl<'a> Copy for InvariantLifetime<'a> {}\n+\n     /// A type which is considered \"not sendable\", meaning that it cannot\n     /// be safely sent between tasks, even if it is owned. This is\n     /// typically embedded in other types, such as `Gc`, to ensure that\n     /// their instances remain thread-local.\n     #[lang=\"no_send_bound\"]\n-    #[deriving(Clone, PartialEq, Eq, PartialOrd, Ord)]\n-    #[allow(missing_copy_implementations)]\n+    #[deriving(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n     pub struct NoSend;\n \n     /// A type which is considered \"not POD\", meaning that it is not\n@@ -280,8 +281,7 @@ pub mod marker {\n     /// its contents are not threadsafe, hence they cannot be\n     /// shared between tasks.\n     #[lang=\"no_sync_bound\"]\n-    #[deriving(Clone, PartialEq, Eq, PartialOrd, Ord)]\n-    #[allow(missing_copy_implementations)]\n+    #[deriving(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n     pub struct NoSync;\n \n     /// A type which is considered managed by the GC. This is typically"}, {"sha": "2620928acc1acca5070786ac304568f20dbb194d", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 148, "deletions": 49, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -13,9 +13,13 @@\n //! This module contains functions for querying the size and alignment of\n //! types, initializing and manipulating memory.\n \n+#![stable]\n+\n+use kinds::Sized;\n use intrinsics;\n use ptr;\n \n+#[stable]\n pub use intrinsics::transmute;\n \n /// Moves a thing into the void.\n@@ -29,13 +33,29 @@ pub use intrinsics::transmute;\n pub use intrinsics::forget;\n \n /// Returns the size of a type in bytes.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::size_of::<i32>());\n+/// ```\n #[inline]\n #[stable]\n pub fn size_of<T>() -> uint {\n     unsafe { intrinsics::size_of::<T>() }\n }\n \n /// Returns the size of the type that `_val` points to in bytes.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::size_of_val(&5i32));\n+/// ```\n #[inline]\n #[stable]\n pub fn size_of_val<T>(_val: &T) -> uint {\n@@ -44,16 +64,30 @@ pub fn size_of_val<T>(_val: &T) -> uint {\n \n /// Returns the ABI-required minimum alignment of a type\n ///\n-/// This is the alignment used for struct fields. It may be smaller\n-/// than the preferred alignment.\n+/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::min_align_of::<i32>());\n+/// ```\n #[inline]\n #[stable]\n pub fn min_align_of<T>() -> uint {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n \n-/// Returns the ABI-required minimum alignment of the type of the value that\n-/// `_val` points to\n+/// Returns the ABI-required minimum alignment of the type of the value that `_val` points to\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::min_align_of_val(&5i32));\n+/// ```\n #[inline]\n #[stable]\n pub fn min_align_of_val<T>(_val: &T) -> uint {\n@@ -62,9 +96,16 @@ pub fn min_align_of_val<T>(_val: &T) -> uint {\n \n /// Returns the alignment in memory for a type.\n ///\n-/// This function will return the alignment, in bytes, of a type in memory. If\n-/// the alignment returned is adhered to, then the type is guaranteed to\n-/// function properly.\n+/// This function will return the alignment, in bytes, of a type in memory. If the alignment\n+/// returned is adhered to, then the type is guaranteed to function properly.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::align_of::<i32>());\n+/// ```\n #[inline]\n #[stable]\n pub fn align_of<T>() -> uint {\n@@ -77,9 +118,16 @@ pub fn align_of<T>() -> uint {\n \n /// Returns the alignment of the type of the value that `_val` points to.\n ///\n-/// This is similar to `align_of`, but function will properly handle types such\n-/// as trait objects (in the future), returning the alignment for an arbitrary\n-/// value at runtime.\n+/// This is similar to `align_of`, but function will properly handle types such as trait objects\n+/// (in the future), returning the alignment for an arbitrary value at runtime.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::align_of_val(&5i32));\n+/// ```\n #[inline]\n #[stable]\n pub fn align_of_val<T>(_val: &T) -> uint {\n@@ -88,15 +136,22 @@ pub fn align_of_val<T>(_val: &T) -> uint {\n \n /// Create a value initialized to zero.\n ///\n-/// This function is similar to allocating space for a local variable and\n-/// zeroing it out (an unsafe operation).\n+/// This function is similar to allocating space for a local variable and zeroing it out (an unsafe\n+/// operation).\n ///\n-/// Care must be taken when using this function, if the type `T` has a\n-/// destructor and the value falls out of scope (due to unwinding or returning)\n-/// before being initialized, then the destructor will run on zeroed\n-/// data, likely leading to crashes.\n+/// Care must be taken when using this function, if the type `T` has a destructor and the value\n+/// falls out of scope (due to unwinding or returning) before being initialized, then the\n+/// destructor will run on zeroed data, likely leading to crashes.\n ///\n /// This is useful for FFI functions sometimes, but should generally be avoided.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// let x: int = unsafe { mem::zeroed() };\n+/// ```\n #[inline]\n #[stable]\n pub unsafe fn zeroed<T>() -> T {\n@@ -105,20 +160,41 @@ pub unsafe fn zeroed<T>() -> T {\n \n /// Create an uninitialized value.\n ///\n-/// Care must be taken when using this function, if the type `T` has a\n-/// destructor and the value falls out of scope (due to unwinding or returning)\n-/// before being initialized, then the destructor will run on uninitialized\n-/// data, likely leading to crashes.\n+/// Care must be taken when using this function, if the type `T` has a destructor and the value\n+/// falls out of scope (due to unwinding or returning) before being initialized, then the\n+/// destructor will run on uninitialized data, likely leading to crashes.\n ///\n /// This is useful for FFI functions sometimes, but should generally be avoided.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// let x: int = unsafe { mem::uninitialized() };\n+/// ```\n #[inline]\n #[stable]\n pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::uninit()\n }\n \n-/// Swap the values at two mutable locations of the same type, without\n-/// deinitialising or copying either one.\n+/// Swap the values at two mutable locations of the same type, without deinitialising or copying\n+/// either one.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// let x = &mut 5i;\n+/// let y = &mut 42i;\n+///\n+/// mem::swap(x, y);\n+///\n+/// assert_eq!(42i, *x);\n+/// assert_eq!(5i, *y);\n+/// ```\n #[inline]\n #[stable]\n pub fn swap<T>(x: &mut T, y: &mut T) {\n@@ -137,13 +213,26 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n     }\n }\n \n-/// Replace the value at a mutable location with a new one, returning the old\n-/// value, without deinitialising or copying either one.\n+/// Replace the value at a mutable location with a new one, returning the old value, without\n+/// deinitialising or copying either one.\n+///\n+/// This is primarily used for transferring and swapping ownership of a value in a mutable\n+/// location.\n+///\n+/// # Examples\n+///\n+/// A simple example:\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// let mut v: Vec<i32> = Vec::new();\n+///\n+/// mem::replace(&mut v, Vec::new());\n+/// ```\n ///\n-/// This is primarily used for transferring and swapping ownership of a value\n-/// in a mutable location. For example, this function allows consumption of\n-/// one field of a struct by replacing it with another value. The normal approach\n-/// doesn't always work:\n+/// This function allows consumption of one field of a struct by replacing it with another value.\n+/// The normal approach doesn't always work:\n ///\n /// ```rust,ignore\n /// struct Buffer<T> { buf: Vec<T> }\n@@ -158,16 +247,16 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// }\n /// ```\n ///\n-/// Note that `T` does not necessarily implement `Clone`, so it can't even\n-/// clone and reset `self.buf`. But `replace` can be used to disassociate\n-/// the original value of `self.buf` from `self`, allowing it to be returned:\n+/// Note that `T` does not necessarily implement `Clone`, so it can't even clone and reset\n+/// `self.buf`. But `replace` can be used to disassociate the original value of `self.buf` from\n+/// `self`, allowing it to be returned:\n ///\n /// ```rust\n+/// use std::mem;\n /// # struct Buffer<T> { buf: Vec<T> }\n /// impl<T> Buffer<T> {\n ///     fn get_and_reset(&mut self) -> Vec<T> {\n-///         use std::mem::replace;\n-///         replace(&mut self.buf, Vec::new())\n+///         mem::replace(&mut self.buf, Vec::new())\n ///     }\n /// }\n /// ```\n@@ -180,10 +269,10 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n \n /// Disposes of a value.\n ///\n-/// This function can be used to destroy any value by allowing `drop` to take\n-/// ownership of its argument.\n+/// This function can be used to destroy any value by allowing `drop` to take ownership of its\n+/// argument.\n ///\n-/// # Example\n+/// # Examples\n ///\n /// ```\n /// use std::cell::RefCell;\n@@ -192,6 +281,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n ///\n /// let mut mutable_borrow = x.borrow_mut();\n /// *mutable_borrow = 1;\n+///\n /// drop(mutable_borrow); // relinquish the mutable borrow on this slot\n ///\n /// let borrow = x.borrow();\n@@ -201,18 +291,25 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n #[stable]\n pub fn drop<T>(_x: T) { }\n \n-/// Interprets `src` as `&U`, and then reads `src` without moving the contained\n-/// value.\n+/// Interprets `src` as `&U`, and then reads `src` without moving the contained value.\n+///\n+/// This function will unsafely assume the pointer `src` is valid for `sizeof(U)` bytes by\n+/// transmuting `&T` to `&U` and then reading the `&U`. It will also unsafely create a copy of the\n+/// contained value instead of moving out of `src`.\n+///\n+/// It is not a compile-time error if `T` and `U` have different sizes, but it is highly encouraged\n+/// to only invoke this function where `T` and `U` have the same size. This function triggers\n+/// undefined behavior if `U` is larger than `T`.\n ///\n-/// This function will unsafely assume the pointer `src` is valid for\n-/// `sizeof(U)` bytes by transmuting `&T` to `&U` and then reading the `&U`. It\n-/// will also unsafely create a copy of the contained value instead of moving\n-/// out of `src`.\n+/// # Examples\n ///\n-/// It is not a compile-time error if `T` and `U` have different sizes, but it\n-/// is highly encouraged to only invoke this function where `T` and `U` have the\n-/// same size. This function triggers undefined behavior if `U` is larger than\n-/// `T`.\n+/// ```\n+/// use std::mem;\n+///\n+/// let one = unsafe { mem::transmute_copy(&1i) };\n+///\n+/// assert_eq!(1u, one);\n+/// ```\n #[inline]\n #[stable]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n@@ -223,15 +320,17 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n #[inline]\n #[unstable = \"this function may be removed in the future due to its \\\n               questionable utility\"]\n-pub unsafe fn copy_lifetime<'a, S, T:'a>(_ptr: &'a S, ptr: &T) -> &'a T {\n+pub unsafe fn copy_lifetime<'a, Sized? S, Sized? T: 'a>(_ptr: &'a S,\n+                                                        ptr: &T) -> &'a T {\n     transmute(ptr)\n }\n \n /// Transforms lifetime of the second mutable pointer to match the first.\n #[inline]\n #[unstable = \"this function may be removed in the future due to its \\\n               questionable utility\"]\n-pub unsafe fn copy_mut_lifetime<'a, S, T:'a>(_ptr: &'a mut S,\n-                                          ptr: &mut T) -> &'a mut T {\n+pub unsafe fn copy_mut_lifetime<'a, Sized? S, Sized? T: 'a>(_ptr: &'a mut S,\n+                                                            ptr: &mut T)\n+                                                            -> &'a mut T {\n     transmute(ptr)\n }"}, {"sha": "deb1cea1c0ec33e61d00f996fea7337815d05cf7", "filename": "src/libcore/option.rs", "status": "modified", "additions": 88, "deletions": 26, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -168,8 +168,10 @@ use ops::{Deref, FnOnce};\n #[stable]\n pub enum Option<T> {\n     /// No value\n+    #[stable]\n     None,\n     /// Some value `T`\n+    #[stable]\n     Some(T)\n }\n \n@@ -261,7 +263,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x, Some(42u));\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for mut conventions\"]\n+    #[stable]\n     pub fn as_mut<'r>(&'r mut self) -> Option<&'r mut T> {\n         match *self {\n             Some(ref mut x) => Some(x),\n@@ -321,7 +323,7 @@ impl<T> Option<T> {\n     /// x.expect(\"the world is ending\"); // panics with `world is ending`\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for conventions\"]\n+    #[stable]\n     pub fn expect(self, msg: &str) -> T {\n         match self {\n             Some(val) => val,\n@@ -353,7 +355,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.unwrap(), \"air\"); // fails\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for conventions\"]\n+    #[stable]\n     pub fn unwrap(self) -> T {\n         match self {\n             Some(val) => val,\n@@ -370,7 +372,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for conventions\"]\n+    #[stable]\n     pub fn unwrap_or(self, def: T) -> T {\n         match self {\n             Some(x) => x,\n@@ -388,7 +390,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.unwrap_or_else(|| 2 * k), 20u);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for conventions\"]\n+    #[stable]\n     pub fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T {\n         match self {\n             Some(x) => x,\n@@ -412,7 +414,7 @@ impl<T> Option<T> {\n     /// let num_as_int: Option<uint> = num_as_str.map(|n| n.len());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {\n         match self {\n             Some(x) => Some(f(x)),\n@@ -432,7 +434,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.map_or(42u, |v| v.len()), 42u);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     pub fn map_or<U, F: FnOnce(T) -> U>(self, def: U, f: F) -> U {\n         match self {\n             Some(t) => f(t),\n@@ -454,7 +456,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 42u);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     pub fn map_or_else<U, D: FnOnce() -> U, F: FnOnce(T) -> U>(self, def: D, f: F) -> U {\n         match self {\n             Some(t) => f(t),\n@@ -520,9 +522,9 @@ impl<T> Option<T> {\n     /// assert_eq!(x.iter().next(), None);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for iterator conventions\"]\n-    pub fn iter<'r>(&'r self) -> Item<&'r T> {\n-        Item{opt: self.as_ref()}\n+    #[stable]\n+    pub fn iter(&self) -> Iter<T> {\n+        Iter { inner: Item { opt: self.as_ref() } }\n     }\n \n     /// Returns a mutable iterator over the possibly contained value.\n@@ -542,8 +544,8 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for iterator conventions\"]\n-    pub fn iter_mut<'r>(&'r mut self) -> Item<&'r mut T> {\n-        Item{opt: self.as_mut()}\n+    pub fn iter_mut(&mut self) -> IterMut<T> {\n+        IterMut { inner: Item { opt: self.as_mut() } }\n     }\n \n     /// Returns a consuming iterator over the possibly contained value.\n@@ -560,9 +562,9 @@ impl<T> Option<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for iterator conventions\"]\n-    pub fn into_iter(self) -> Item<T> {\n-        Item{opt: self}\n+    #[stable]\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        IntoIter { inner: Item { opt: self } }\n     }\n \n     /////////////////////////////////////////////////////////////////////////\n@@ -614,7 +616,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.and_then(sq).and_then(sq), None);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     pub fn and_then<U, F: FnOnce(T) -> Option<U>>(self, f: F) -> Option<U> {\n         match self {\n             Some(x) => f(x),\n@@ -666,7 +668,7 @@ impl<T> Option<T> {\n     /// assert_eq!(None.or_else(nobody), None);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     pub fn or_else<F: FnOnce() -> Option<T>>(self, f: F) -> Option<T> {\n         match self {\n             Some(_) => self,\n@@ -731,7 +733,7 @@ impl<T: Default> Option<T> {\n     /// assert_eq!(0i, bad_year);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for conventions\"]\n+    #[stable]\n     pub fn unwrap_or_default(self) -> T {\n         match self {\n             Some(x) => x,\n@@ -744,6 +746,7 @@ impl<T: Default> Option<T> {\n // Trait implementations\n /////////////////////////////////////////////////////////////////////////////\n \n+#[unstable = \"waiting on the stability of the trait itself\"]\n impl<T> AsSlice<T> for Option<T> {\n     /// Convert from `Option<T>` to `&[T]` (without copying)\n     #[inline]\n@@ -760,21 +763,18 @@ impl<T> AsSlice<T> for Option<T> {\n \n #[stable]\n impl<T> Default for Option<T> {\n+    #[stable]\n     #[inline]\n+    #[stable]\n     fn default() -> Option<T> { None }\n }\n \n /////////////////////////////////////////////////////////////////////////////\n-// The Option Iterator\n+// The Option Iterators\n /////////////////////////////////////////////////////////////////////////////\n \n-/// An `Option` iterator that yields either one or zero elements\n-///\n-/// The `Item` iterator is returned by the `iter`, `iter_mut` and `into_iter`\n-/// methods on `Option`.\n #[deriving(Clone)]\n-#[unstable = \"waiting for iterator conventions\"]\n-pub struct Item<A> {\n+struct Item<A> {\n     opt: Option<A>\n }\n \n@@ -802,6 +802,66 @@ impl<A> DoubleEndedIterator<A> for Item<A> {\n \n impl<A> ExactSizeIterator<A> for Item<A> {}\n \n+/// An iterator over a reference of the contained item in an Option.\n+#[stable]\n+pub struct Iter<'a, A: 'a> { inner: Item<&'a A> }\n+\n+impl<'a, A> Iterator<&'a A> for Iter<'a, A> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a A> { self.inner.next() }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+\n+impl<'a, A> DoubleEndedIterator<&'a A> for Iter<'a, A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a A> { self.inner.next_back() }\n+}\n+\n+impl<'a, A> ExactSizeIterator<&'a A> for Iter<'a, A> {}\n+\n+impl<'a, A> Clone for Iter<'a, A> {\n+    fn clone(&self) -> Iter<'a, A> {\n+        Iter { inner: self.inner.clone() }\n+    }\n+}\n+\n+/// An iterator over a mutable reference of the contained item in an Option.\n+#[stable]\n+pub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }\n+\n+impl<'a, A> Iterator<&'a mut A> for IterMut<'a, A> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut A> { self.inner.next() }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+\n+impl<'a, A> DoubleEndedIterator<&'a mut A> for IterMut<'a, A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut A> { self.inner.next_back() }\n+}\n+\n+impl<'a, A> ExactSizeIterator<&'a mut A> for IterMut<'a, A> {}\n+\n+/// An iterator over the item contained inside an Option.\n+#[stable]\n+pub struct IntoIter<A> { inner: Item<A> }\n+\n+impl<A> Iterator<A> for IntoIter<A> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> { self.inner.next() }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+\n+impl<A> DoubleEndedIterator<A> for IntoIter<A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> { self.inner.next_back() }\n+}\n+\n+impl<A> ExactSizeIterator<A> for IntoIter<A> {}\n+\n /////////////////////////////////////////////////////////////////////////////\n // FromIterator\n /////////////////////////////////////////////////////////////////////////////\n@@ -826,6 +886,7 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// assert!(res == Some(vec!(2u, 3u)));\n     /// ```\n     #[inline]\n+    #[stable]\n     fn from_iter<I: Iterator<Option<A>>>(iter: I) -> Option<V> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n@@ -860,5 +921,6 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     }\n }\n \n+#[stable]\n impl<T:Copy> Copy for Option<T> {}\n "}, {"sha": "411a46ee1bd5893b41245b18cbf44abfc04c638c", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -292,13 +292,11 @@ impl<T> SliceExt<T> for [T] {\n             if mem::size_of::<T>() == 0 {\n                 MutItems{ptr: p,\n                          end: (p as uint + self.len()) as *mut T,\n-                         marker: marker::ContravariantLifetime::<'a>,\n-                         marker2: marker::NoCopy}\n+                         marker: marker::ContravariantLifetime::<'a>}\n             } else {\n                 MutItems{ptr: p,\n                          end: p.offset(self.len() as int),\n-                         marker: marker::ContravariantLifetime::<'a>,\n-                         marker2: marker::NoCopy}\n+                         marker: marker::ContravariantLifetime::<'a>}\n             }\n         }\n     }\n@@ -647,8 +645,9 @@ impl<'a, T, Sized? U: AsSlice<T>> AsSlice<T> for &'a mut U {\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n-#[unstable = \"waiting for DST\"]\n+#[stable]\n impl<'a, T> Default for &'a [T] {\n+    #[stable]\n     fn default() -> &'a [T] { &[] }\n }\n \n@@ -818,7 +817,6 @@ pub struct MutItems<'a, T: 'a> {\n     ptr: *mut T,\n     end: *mut T,\n     marker: marker::ContravariantLifetime<'a>,\n-    marker2: marker::NoCopy\n }\n \n #[experimental]\n@@ -894,6 +892,17 @@ pub struct Splits<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     finished: bool\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<'a, T, P> Clone for Splits<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n+    fn clone(&self) -> Splits<'a, T, P> {\n+        Splits {\n+            v: self.v,\n+            pred: self.pred.clone(),\n+            finished: self.finished,\n+        }\n+    }\n+}\n+\n #[experimental = \"needs review\"]\n impl<'a, T, P> Iterator<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]"}, {"sha": "1a7467555a5a3705165faa9abef7292b9866da00", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -2349,7 +2349,9 @@ impl StrPrelude for str {\n     fn len(&self) -> uint { self.repr().len }\n }\n \n+#[stable]\n impl<'a> Default for &'a str {\n+    #[stable]\n     fn default() -> &'a str { \"\" }\n }\n "}, {"sha": "5ea84f7db9179bb440bc88dbcdf7bb60ad282f63", "filename": "src/libcore/tuple/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Ftuple%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcore%2Ftuple%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple%2Fmod.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -182,6 +182,7 @@ macro_rules! tuple_impls {\n \n             #[stable]\n             impl<$($T:Default),+> Default for ($($T,)+) {\n+                #[stable]\n                 #[inline]\n                 fn default() -> ($($T,)+) {\n                     ($({ let x: $T = Default::default(); x},)+)"}, {"sha": "bed38f8c29666babdd7549f4b60fb17e7b10614f", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -135,38 +135,35 @@ fn test_escape_default() {\n     let s = string('~');\n     assert_eq!(s, \"~\");\n     let s = string('\\x00');\n-    assert_eq!(s, \"\\\\x00\");\n+    assert_eq!(s, \"\\\\u{0}\");\n     let s = string('\\x1f');\n-    assert_eq!(s, \"\\\\x1f\");\n+    assert_eq!(s, \"\\\\u{1f}\");\n     let s = string('\\x7f');\n-    assert_eq!(s, \"\\\\x7f\");\n-    let s = string('\\u00ff');\n-    assert_eq!(s, \"\\\\u00ff\");\n-    let s = string('\\u011b');\n-    assert_eq!(s, \"\\\\u011b\");\n-    let s = string('\\U0001d4b6');\n-    assert_eq!(s, \"\\\\U0001d4b6\");\n+    assert_eq!(s, \"\\\\u{7f}\");\n+    let s = string('\\u{ff}');\n+    assert_eq!(s, \"\\\\u{ff}\");\n+    let s = string('\\u{11b}');\n+    assert_eq!(s, \"\\\\u{11b}\");\n+    let s = string('\\u{1d4b6}');\n+    assert_eq!(s, \"\\\\u{1d4b6}\");\n }\n \n #[test]\n fn test_escape_unicode() {\n-    fn string(c: char) -> String {\n-        let mut result = String::new();\n-        escape_unicode(c, |c| { result.push(c); });\n-        return result;\n-    }\n+    fn string(c: char) -> String { c.escape_unicode().collect() }\n+\n     let s = string('\\x00');\n-    assert_eq!(s, \"\\\\x00\");\n+    assert_eq!(s, \"\\\\u{0}\");\n     let s = string('\\n');\n-    assert_eq!(s, \"\\\\x0a\");\n+    assert_eq!(s, \"\\\\u{a}\");\n     let s = string(' ');\n-    assert_eq!(s, \"\\\\x20\");\n+    assert_eq!(s, \"\\\\u{20}\");\n     let s = string('a');\n-    assert_eq!(s, \"\\\\x61\");\n-    let s = string('\\u011b');\n-    assert_eq!(s, \"\\\\u011b\");\n-    let s = string('\\U0001d4b6');\n-    assert_eq!(s, \"\\\\U0001d4b6\");\n+    assert_eq!(s, \"\\\\u{61}\");\n+    let s = string('\\u{11b}');\n+    assert_eq!(s, \"\\\\u{11b}\");\n+    let s = string('\\u{1d4b6}');\n+    assert_eq!(s, \"\\\\u{1d4b6}\");\n }\n \n #[test]"}, {"sha": "f7b714757f8da4ed21074e835a7acf283588911a", "filename": "src/libcoretest/tuple.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcoretest%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibcoretest%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ftuple.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -15,32 +15,6 @@ fn test_clone() {\n     assert_eq!(a, b);\n }\n \n-#[test]\n-fn test_getters() {\n-    macro_rules! test_getter(\n-        ($x:expr, $valN:ident, $refN:ident, $mutN:ident,\n-         $init:expr, $incr:expr, $result:expr) => ({\n-            assert_eq!($x.$valN(), $init);\n-            assert_eq!(*$x.$refN(), $init);\n-            *$x.$mutN() += $incr;\n-            assert_eq!(*$x.$refN(), $result);\n-        })\n-    )\n-    let mut x = (0u8, 1u16, 2u32, 3u64, 4u, 5i8, 6i16, 7i32, 8i64, 9i, 10f32, 11f64);\n-    test_getter!(x, val0,  ref0,  mut0,  0,    1,   1);\n-    test_getter!(x, val1,  ref1,  mut1,  1,    1,   2);\n-    test_getter!(x, val2,  ref2,  mut2,  2,    1,   3);\n-    test_getter!(x, val3,  ref3,  mut3,  3,    1,   4);\n-    test_getter!(x, val4,  ref4,  mut4,  4,    1,   5);\n-    test_getter!(x, val5,  ref5,  mut5,  5,    1,   6);\n-    test_getter!(x, val6,  ref6,  mut6,  6,    1,   7);\n-    test_getter!(x, val7,  ref7,  mut7,  7,    1,   8);\n-    test_getter!(x, val8,  ref8,  mut8,  8,    1,   9);\n-    test_getter!(x, val9,  ref9,  mut9,  9,    1,   10);\n-    test_getter!(x, val10, ref10, mut10, 10.0, 1.0, 11.0);\n-    test_getter!(x, val11, ref11, mut11, 11.0, 1.0, 12.0);\n-}\n-\n #[test]\n fn test_tuple_cmp() {\n     let (small, big) = ((1u, 2u, 3u), (3u, 2u, 1u));"}, {"sha": "38729eece5ab566e1b93b59e5ce777b44ac1a97b", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -78,7 +78,7 @@\n //! ```\n \n #![crate_name = \"getopts\"]\n-#![experimental]\n+#![experimental = \"use the crates.io `getopts` library instead\"]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\","}, {"sha": "34e19aa4a03e79179679e6cbe9b74cc7e8598acf", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 43, "deletions": 7, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -421,6 +421,14 @@ pub trait Labeller<'a,N,E> {\n }\n \n impl<'a> LabelText<'a> {\n+    pub fn label<S:IntoCow<'a, String, str>>(s: S) -> LabelText<'a> {\n+        LabelStr(s.into_cow())\n+    }\n+\n+    pub fn escaped<S:IntoCow<'a, String, str>>(s: S) -> LabelText<'a> {\n+        EscStr(s.into_cow())\n+    }\n+\n     fn escape_char<F>(c: char, mut f: F) where F: FnMut(char) {\n         match c {\n             // not escaping \\\\, since Graphviz escString needs to\n@@ -505,11 +513,29 @@ pub trait GraphWalk<'a, N, E> {\n     fn target(&'a self, edge: &E) -> N;\n }\n \n+#[deriving(Copy, PartialEq, Eq, Show)]\n+pub enum RenderOption {\n+    NoEdgeLabels,\n+    NoNodeLabels,\n+}\n+\n+/// Returns vec holding all the default render options.\n+pub fn default_options() -> Vec<RenderOption> { vec![] }\n+\n /// Renders directed graph `g` into the writer `w` in DOT syntax.\n-/// (Main entry point for the library.)\n+/// (Simple wrapper around `render_opts` that passes a default set of options.)\n pub fn render<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N,E>, W:Writer>(\n               g: &'a G,\n-              w: &mut W) -> io::IoResult<()>\n+              w: &mut W) -> io::IoResult<()> {\n+    render_opts(g, w, &[])\n+}\n+\n+/// Renders directed graph `g` into the writer `w` in DOT syntax.\n+/// (Main entry point for the library.)\n+pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N,E>, W:Writer>(\n+              g: &'a G,\n+              w: &mut W,\n+              options: &[RenderOption]) -> io::IoResult<()>\n {\n     fn writeln<W:Writer>(w: &mut W, arg: &[&str]) -> io::IoResult<()> {\n         for &s in arg.iter() { try!(w.write_str(s)); }\n@@ -524,9 +550,13 @@ pub fn render<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N,E>,\n     for n in g.nodes().iter() {\n         try!(indent(w));\n         let id = g.node_id(n);\n-        let escaped = g.node_label(n).escape();\n-        try!(writeln(w, &[id.as_slice(),\n-                          \"[label=\\\"\", escaped.as_slice(), \"\\\"];\"]));\n+        if options.contains(&RenderOption::NoNodeLabels) {\n+            try!(writeln(w, &[id.as_slice(), \";\"]));\n+        } else {\n+            let escaped = g.node_label(n).escape();\n+            try!(writeln(w, &[id.as_slice(),\n+                              \"[label=\\\"\", escaped.as_slice(), \"\\\"];\"]));\n+        }\n     }\n \n     for e in g.edges().iter() {\n@@ -536,8 +566,14 @@ pub fn render<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N,E>,\n         let target = g.target(e);\n         let source_id = g.node_id(&source);\n         let target_id = g.node_id(&target);\n-        try!(writeln(w, &[source_id.as_slice(), \" -> \", target_id.as_slice(),\n-                          \"[label=\\\"\", escaped_label.as_slice(), \"\\\"];\"]));\n+        if options.contains(&RenderOption::NoEdgeLabels) {\n+            try!(writeln(w, &[source_id.as_slice(),\n+                              \" -> \", target_id.as_slice(), \";\"]));\n+        } else {\n+            try!(writeln(w, &[source_id.as_slice(),\n+                              \" -> \", target_id.as_slice(),\n+                              \"[label=\\\"\", escaped_label.as_slice(), \"\\\"];\"]));\n+        }\n     }\n \n     writeln(w, &[\"}\"])"}, {"sha": "976b9bcf37eb8206efa4b2b6b56980ba46612eba", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -157,7 +157,7 @@\n //! if logging is disabled, none of the components of the log will be executed.\n \n #![crate_name = \"log\"]\n-#![experimental]\n+#![experimental = \"use the crates.io `log` library instead\"]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\","}, {"sha": "dfcdad481a91abf1c59d9ccb410c6df4b1c804a6", "filename": "src/librand/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -185,7 +185,7 @@ pub trait Rng {\n         Rand::rand(self)\n     }\n \n-    /// Return an iterator which will yield an infinite number of randomly\n+    /// Return an iterator that will yield an infinite number of randomly\n     /// generated items.\n     ///\n     /// # Example"}, {"sha": "46ee67940f26997ed832cdb298bb24ce561de223", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -142,7 +142,9 @@ impl<R: Rng + Default> Reseeder<R> for ReseedWithDefault {\n         *rng = Default::default();\n     }\n }\n+#[stable]\n impl Default for ReseedWithDefault {\n+    #[stable]\n     fn default() -> ReseedWithDefault { ReseedWithDefault }\n }\n "}, {"sha": "bbedbc75395d63151ae0eeb95094d6c232ec1dab", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -499,8 +499,9 @@ pub mod reader {\n             Ok(result)\n         }\n \n-        fn read_enum_variant<T, F>(&mut self, _: &[&str], f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+        fn read_enum_variant<T, F>(&mut self, _: &[&str],\n+                                   mut f: F) -> DecodeResult<T>\n+            where F: FnMut(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n         {\n             debug!(\"read_enum_variant()\");\n             let idx = try!(self._next_uint(EsEnumVid));\n@@ -526,8 +527,9 @@ pub mod reader {\n             f(self)\n         }\n \n-        fn read_enum_struct_variant<T, F>(&mut self, _: &[&str], f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+        fn read_enum_struct_variant<T, F>(&mut self, _: &[&str],\n+                                          mut f: F) -> DecodeResult<T>\n+            where F: FnMut(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n         {\n             debug!(\"read_enum_struct_variant()\");\n             let idx = try!(self._next_uint(EsEnumVid));\n@@ -610,8 +612,8 @@ pub mod reader {\n             self.read_tuple_arg(idx, f)\n         }\n \n-        fn read_option<T, F>(&mut self, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>, bool) -> DecodeResult<T>,\n+        fn read_option<T, F>(&mut self, mut f: F) -> DecodeResult<T> where\n+            F: FnMut(&mut Decoder<'doc>, bool) -> DecodeResult<T>,\n         {\n             debug!(\"read_option()\");\n             self.read_enum(\"Option\", move |this| {"}, {"sha": "9ad02afee993478314f4457ab12e33d223695186", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -103,7 +103,9 @@\n //! let re = regex!(r\"(\\d{4})-(\\d{2})-(\\d{2})\");\n //! let text = \"2012-03-14, 2013-01-01 and 2014-07-05\";\n //! for cap in re.captures_iter(text) {\n-//!     println!(\"Month: {} Day: {} Year: {}\", cap.at(2), cap.at(3), cap.at(1));\n+//!     println!(\"Month: {} Day: {} Year: {}\",\n+//!              cap.at(2).unwrap_or(\"\"), cap.at(3).unwrap_or(\"\"),\n+//!              cap.at(1).unwrap_or(\"\"));\n //! }\n //! // Output:\n //! // Month: 03 Day: 14 Year: 2012\n@@ -285,7 +287,7 @@\n //! # fn main() {\n //! let re = regex!(r\"(?i)a+(?-i)b+\");\n //! let cap = re.captures(\"AaAaAbbBBBb\").unwrap();\n-//! assert_eq!(cap.at(0), \"AaAaAbb\");\n+//! assert_eq!(cap.at(0), Some(\"AaAaAbb\"));\n //! # }\n //! ```\n //!\n@@ -362,7 +364,7 @@\n #![crate_name = \"regex\"]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n-#![experimental]\n+#![experimental = \"use the crates.io `regex` library instead\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\","}, {"sha": "53181bfbb7e3fbfdcb09708cd019d6477e893ea0", "filename": "src/libregex/re.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -273,9 +273,9 @@ impl Regex {\n     /// let re = regex!(r\"'([^']+)'\\s+\\((\\d{4})\\)\");\n     /// let text = \"Not my favorite movie: 'Citizen Kane' (1941).\";\n     /// let caps = re.captures(text).unwrap();\n-    /// assert_eq!(caps.at(1), \"Citizen Kane\");\n-    /// assert_eq!(caps.at(2), \"1941\");\n-    /// assert_eq!(caps.at(0), \"'Citizen Kane' (1941)\");\n+    /// assert_eq!(caps.at(1), Some(\"Citizen Kane\"));\n+    /// assert_eq!(caps.at(2), Some(\"1941\"));\n+    /// assert_eq!(caps.at(0), Some(\"'Citizen Kane' (1941)\"));\n     /// # }\n     /// ```\n     ///\n@@ -291,9 +291,9 @@ impl Regex {\n     /// let re = regex!(r\"'(?P<title>[^']+)'\\s+\\((?P<year>\\d{4})\\)\");\n     /// let text = \"Not my favorite movie: 'Citizen Kane' (1941).\";\n     /// let caps = re.captures(text).unwrap();\n-    /// assert_eq!(caps.name(\"title\"), \"Citizen Kane\");\n-    /// assert_eq!(caps.name(\"year\"), \"1941\");\n-    /// assert_eq!(caps.at(0), \"'Citizen Kane' (1941)\");\n+    /// assert_eq!(caps.name(\"title\"), Some(\"Citizen Kane\"));\n+    /// assert_eq!(caps.name(\"year\"), Some(\"1941\"));\n+    /// assert_eq!(caps.at(0), Some(\"'Citizen Kane' (1941)\"));\n     /// # }\n     /// ```\n     ///\n@@ -434,7 +434,7 @@ impl Regex {\n     /// # use regex::Captures; fn main() {\n     /// let re = regex!(r\"([^,\\s]+),\\s+(\\S+)\");\n     /// let result = re.replace(\"Springsteen, Bruce\", |&: caps: &Captures| {\n-    ///     format!(\"{} {}\", caps.at(2), caps.at(1))\n+    ///     format!(\"{} {}\", caps.at(2).unwrap_or(\"\"), caps.at(1).unwrap_or(\"\"))\n     /// });\n     /// assert_eq!(result.as_slice(), \"Bruce Springsteen\");\n     /// # }\n@@ -712,27 +712,25 @@ impl<'t> Captures<'t> {\n         Some((self.locs[s].unwrap(), self.locs[e].unwrap()))\n     }\n \n-    /// Returns the matched string for the capture group `i`.\n-    /// If `i` isn't a valid capture group or didn't match anything, then the\n-    /// empty string is returned.\n-    pub fn at(&self, i: uint) -> &'t str {\n+    /// Returns the matched string for the capture group `i`.  If `i` isn't\n+    /// a valid capture group or didn't match anything, then `None` is\n+    /// returned.\n+    pub fn at(&self, i: uint) -> Option<&'t str> {\n         match self.pos(i) {\n-            None => \"\",\n-            Some((s, e)) => {\n-                self.text.slice(s, e)\n-            }\n+            None => None,\n+            Some((s, e)) => Some(self.text.slice(s, e))\n         }\n     }\n \n-    /// Returns the matched string for the capture group named `name`.\n-    /// If `name` isn't a valid capture group or didn't match anything, then\n-    /// the empty string is returned.\n-    pub fn name(&self, name: &str) -> &'t str {\n+    /// Returns the matched string for the capture group named `name`.  If\n+    /// `name` isn't a valid capture group or didn't match anything, then\n+    /// `None` is returned.\n+    pub fn name(&self, name: &str) -> Option<&'t str> {\n         match self.named {\n-            None => \"\",\n+            None => None,\n             Some(ref h) => {\n                 match h.get(name) {\n-                    None => \"\",\n+                    None => None,\n                     Some(i) => self.at(*i),\n                 }\n             }\n@@ -769,11 +767,12 @@ impl<'t> Captures<'t> {\n         // FIXME: Don't use regexes for this. It's completely unnecessary.\n         let re = Regex::new(r\"(^|[^$]|\\b)\\$(\\w+)\").unwrap();\n         let text = re.replace_all(text, |&mut: refs: &Captures| -> String {\n-            let (pre, name) = (refs.at(1), refs.at(2));\n+            let pre = refs.at(1).unwrap_or(\"\");\n+            let name = refs.at(2).unwrap_or(\"\");\n             format!(\"{}{}\", pre,\n                     match from_str::<uint>(name.as_slice()) {\n-                None => self.name(name).to_string(),\n-                Some(i) => self.at(i).to_string(),\n+                None => self.name(name).unwrap_or(\"\").to_string(),\n+                Some(i) => self.at(i).unwrap_or(\"\").to_string(),\n             })\n         });\n         let re = Regex::new(r\"\\$\\$\").unwrap();\n@@ -802,7 +801,7 @@ impl<'t> Iterator<&'t str> for SubCaptures<'t> {\n     fn next(&mut self) -> Option<&'t str> {\n         if self.idx < self.caps.len() {\n             self.idx += 1;\n-            Some(self.caps.at(self.idx - 1))\n+            Some(self.caps.at(self.idx - 1).unwrap_or(\"\"))\n         } else {\n             None\n         }"}, {"sha": "bf1095d21b2f5ac69a9875ca6bb721c814425908", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -13,7 +13,7 @@\n \n #![crate_name = \"regex_macros\"]\n #![crate_type = \"dylib\"]\n-#![experimental]\n+#![experimental = \"use the crates.io `regex_macros` library instead\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]"}, {"sha": "cc383aa217a7b8ba459a0b2df375103176fdf3ae", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -364,12 +364,12 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n     }\n }\n \n-fn encode_path<PI: Iterator<PathElem> + Clone>(rbml_w: &mut Encoder,\n-                                               mut path: PI) {\n+fn encode_path<PI: Iterator<PathElem>>(rbml_w: &mut Encoder, path: PI) {\n+    let path = path.collect::<Vec<_>>();\n     rbml_w.start_tag(tag_path);\n-    rbml_w.wr_tagged_u32(tag_path_len, path.clone().count() as u32);\n-    for pe in path {\n-        let tag = match pe {\n+    rbml_w.wr_tagged_u32(tag_path_len, path.len() as u32);\n+    for pe in path.iter() {\n+        let tag = match *pe {\n             ast_map::PathMod(_) => tag_path_elem_mod,\n             ast_map::PathName(_) => tag_path_elem_name\n         };"}, {"sha": "0e10155beb470de6e21c5e6eab16b3e7a818db23", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -462,15 +462,13 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.straightline(expr, pred, [r, l].iter().map(|&e| &**e))\n             }\n \n+            ast::ExprBox(Some(ref l), ref r) |\n             ast::ExprIndex(ref l, ref r) |\n             ast::ExprBinary(_, ref l, ref r) => { // NB: && and || handled earlier\n                 self.straightline(expr, pred, [l, r].iter().map(|&e| &**e))\n             }\n \n-            ast::ExprBox(ref p, ref e) => {\n-                self.straightline(expr, pred, [p, e].iter().map(|&e| &**e))\n-            }\n-\n+            ast::ExprBox(None, ref e) |\n             ast::ExprAddrOf(_, ref e) |\n             ast::ExprCast(ref e, _) |\n             ast::ExprUnary(_, ref e) |"}, {"sha": "2cb78beff4c8533c6628235988e91f628fa423d1", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -631,7 +631,10 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ast::ExprBox(ref place, ref base) => {\n-                self.consume_expr(&**place);\n+                match *place {\n+                    Some(ref place) => self.consume_expr(&**place),\n+                    None => {}\n+                }\n                 self.consume_expr(&**base);\n             }\n "}, {"sha": "e268160a42b8560552f1dd8a03e98af5970322b6", "filename": "src/librustc/middle/infer/coercion.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -552,17 +552,18 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                b.repr(self.get_ref().infcx.tcx));\n \n         let mt_a = match *sty_a {\n-            ty::ty_rptr(_, mt) => mt,\n+            ty::ty_rptr(_, mt) | ty::ty_ptr(mt) => mt,\n             _ => {\n                 return self.subtype(a, b);\n             }\n         };\n \n         // Check that the types which they point at are compatible.\n-        // Note that we don't adjust the mutability here. We cannot change\n-        // the mutability and the kind of pointer in a single coercion.\n-        let a_unsafe = ty::mk_ptr(self.get_ref().infcx.tcx, mt_a);\n+        let a_unsafe = ty::mk_ptr(self.get_ref().infcx.tcx, ty::mt{ mutbl: mutbl_b, ty: mt_a.ty });\n         try!(self.subtype(a_unsafe, b));\n+        if !can_coerce_mutbls(mt_a.mutbl, mutbl_b) {\n+            return Err(ty::terr_mutability);\n+        }\n \n         // Although references and unsafe ptrs have the same\n         // representation, we still register an AutoDerefRef so that"}, {"sha": "14153907ee76474a5e56688a55e5b294becd08d9", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -814,8 +814,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.region_vars.new_bound(debruijn)\n     }\n \n-    pub fn resolve_regions_and_report_errors(&self) {\n-        let errors = self.region_vars.resolve_regions();\n+    pub fn resolve_regions_and_report_errors(&self, subject_node_id: ast::NodeId) {\n+        let errors = self.region_vars.resolve_regions(subject_node_id);\n         self.report_region_errors(&errors); // see error_reporting.rs\n     }\n "}, {"sha": "720de357a273d9b155658a85c8cd3012bfb84be3", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -0,0 +1,227 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module provides linkage between libgraphviz traits and\n+//! `rustc::middle::typeck::infer::region_inference`, generating a\n+//! rendering of the graph represented by the list of `Constraint`\n+//! instances (which make up the edges of the graph), as well as the\n+//! origin for each constraint (which are attached to the labels on\n+//! each edge).\n+\n+/// For clarity, rename the graphviz crate locally to dot.\n+use graphviz as dot;\n+\n+use middle::ty;\n+use super::Constraint;\n+use middle::infer::SubregionOrigin;\n+use middle::infer::region_inference::RegionVarBindings;\n+use session::config;\n+use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::ppaux::Repr;\n+\n+use std::collections::hash_map::Vacant;\n+use std::io::{mod, File};\n+use std::os;\n+use std::sync::atomic;\n+use syntax::ast;\n+\n+fn print_help_message() {\n+    println!(\"\\\n+-Z print-region-graph by default prints a region constraint graph for every \\n\\\n+function body, to the path `/tmp/constraints.nodeXXX.dot`, where the XXX is \\n\\\n+replaced with the node id of the function under analysis.                   \\n\\\n+                                                                            \\n\\\n+To select one particular function body, set `RUST_REGION_GRAPH_NODE=XXX`,   \\n\\\n+where XXX is the node id desired.                                           \\n\\\n+                                                                            \\n\\\n+To generate output to some path other than the default                      \\n\\\n+`/tmp/constraints.nodeXXX.dot`, set `RUST_REGION_GRAPH=/path/desired.dot`;  \\n\\\n+occurrences of the character `%` in the requested path will be replaced with\\n\\\n+the node id of the function under analysis.                                 \\n\\\n+                                                                            \\n\\\n+(Since you requested help via RUST_REGION_GRAPH=help, no region constraint  \\n\\\n+graphs will be printed.                                                     \\n\\\n+\");\n+}\n+\n+pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a, 'tcx>,\n+                                             subject_node: ast::NodeId) {\n+    let tcx = region_vars.tcx;\n+\n+    if !region_vars.tcx.sess.debugging_opt(config::PRINT_REGION_GRAPH) {\n+        return;\n+    }\n+\n+    let requested_node : Option<ast::NodeId> =\n+        os::getenv(\"RUST_REGION_GRAPH_NODE\").and_then(|s|from_str(s.as_slice()));\n+\n+    if requested_node.is_some() && requested_node != Some(subject_node) {\n+        return;\n+    }\n+\n+    let requested_output = os::getenv(\"RUST_REGION_GRAPH\");\n+    debug!(\"requested_output: {} requested_node: {}\",\n+           requested_output, requested_node);\n+\n+    let output_path = {\n+        let output_template = match requested_output {\n+            Some(ref s) if s.as_slice() == \"help\" => {\n+                static PRINTED_YET : atomic::AtomicBool = atomic::INIT_ATOMIC_BOOL;\n+                if !PRINTED_YET.load(atomic::SeqCst) {\n+                    print_help_message();\n+                    PRINTED_YET.store(true, atomic::SeqCst);\n+                }\n+                return;\n+            }\n+\n+            Some(other_path) => other_path,\n+            None => \"/tmp/constraints.node%.dot\".to_string(),\n+        };\n+\n+        if output_template.len() == 0 {\n+            tcx.sess.bug(\"empty string provided as RUST_REGION_GRAPH\");\n+        }\n+\n+        if output_template.contains_char('%') {\n+            let mut new_str = String::new();\n+            for c in output_template.chars() {\n+                if c == '%' {\n+                    new_str.push_str(subject_node.to_string().as_slice());\n+                } else {\n+                    new_str.push(c);\n+                }\n+            }\n+            new_str\n+        } else {\n+            output_template\n+        }\n+    };\n+\n+    let constraints = &*region_vars.constraints.borrow();\n+    match dump_region_constraints_to(tcx, constraints, output_path.as_slice()) {\n+        Ok(()) => {}\n+        Err(e) => {\n+            let msg = format!(\"io error dumping region constraints: {}\", e);\n+            region_vars.tcx.sess.err(msg.as_slice())\n+        }\n+    }\n+}\n+\n+struct ConstraintGraph<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    graph_name: String,\n+    map: &'a FnvHashMap<Constraint, SubregionOrigin<'tcx>>,\n+    node_ids: FnvHashMap<Node, uint>,\n+}\n+\n+#[deriving(Clone, Hash, PartialEq, Eq, Show)]\n+enum Node {\n+    RegionVid(ty::RegionVid),\n+    Region(ty::Region),\n+}\n+\n+type Edge = Constraint;\n+\n+impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n+    fn new(tcx: &'a ty::ctxt<'tcx>,\n+           name: String,\n+           map: &'a ConstraintMap<'tcx>) -> ConstraintGraph<'a, 'tcx> {\n+        let mut i = 0;\n+        let mut node_ids = FnvHashMap::new();\n+        {\n+            let add_node = |node| {\n+                if let Vacant(e) = node_ids.entry(node) {\n+                    e.set(i);\n+                    i += 1;\n+                }\n+            };\n+\n+            for (n1, n2) in map.keys().map(|c|constraint_to_nodes(c)) {\n+                add_node(n1);\n+                add_node(n2);\n+            }\n+        }\n+\n+        ConstraintGraph { tcx: tcx,\n+                          graph_name: name,\n+                          map: map,\n+                          node_ids: node_ids }\n+    }\n+}\n+\n+impl<'a, 'tcx> dot::Labeller<'a, Node, Edge> for ConstraintGraph<'a, 'tcx> {\n+    fn graph_id(&self) -> dot::Id {\n+        dot::Id::new(self.graph_name.as_slice()).unwrap()\n+    }\n+    fn node_id(&self, n: &Node) -> dot::Id {\n+        dot::Id::new(format!(\"node_{}\", self.node_ids.get(n).unwrap())).unwrap()\n+    }\n+    fn node_label(&self, n: &Node) -> dot::LabelText {\n+        match *n {\n+            Node::RegionVid(n_vid) =>\n+                dot::LabelText::label(format!(\"{}\", n_vid)),\n+            Node::Region(n_rgn) =>\n+                dot::LabelText::label(format!(\"{}\", n_rgn.repr(self.tcx))),\n+        }\n+    }\n+    fn edge_label(&self, e: &Edge) -> dot::LabelText {\n+        dot::LabelText::label(format!(\"{}\", self.map.get(e).unwrap().repr(self.tcx)))\n+    }\n+}\n+\n+fn constraint_to_nodes(c: &Constraint) -> (Node, Node) {\n+    match *c {\n+        Constraint::ConstrainVarSubVar(rv_1, rv_2) => (Node::RegionVid(rv_1),\n+                                                       Node::RegionVid(rv_2)),\n+        Constraint::ConstrainRegSubVar(r_1, rv_2) => (Node::Region(r_1),\n+                                                      Node::RegionVid(rv_2)),\n+        Constraint::ConstrainVarSubReg(rv_1, r_2) => (Node::RegionVid(rv_1),\n+                                                      Node::Region(r_2)),\n+    }\n+}\n+\n+impl<'a, 'tcx> dot::GraphWalk<'a, Node, Edge> for ConstraintGraph<'a, 'tcx> {\n+    fn nodes(&self) -> dot::Nodes<Node> {\n+        let mut set = FnvHashSet::new();\n+        for constraint in self.map.keys() {\n+            let (n1, n2) = constraint_to_nodes(constraint);\n+            set.insert(n1);\n+            set.insert(n2);\n+        }\n+        debug!(\"constraint graph has {} nodes\", set.len());\n+        set.into_iter().collect()\n+    }\n+    fn edges(&self) -> dot::Edges<Edge> {\n+        debug!(\"constraint graph has {} edges\", self.map.len());\n+        self.map.keys().map(|e|*e).collect()\n+    }\n+    fn source(&self, edge: &Edge) -> Node {\n+        let (n1, _) = constraint_to_nodes(edge);\n+        debug!(\"edge {} has source {}\", edge, n1);\n+        n1\n+    }\n+    fn target(&self, edge: &Edge) -> Node {\n+        let (_, n2) = constraint_to_nodes(edge);\n+        debug!(\"edge {} has target {}\", edge, n2);\n+        n2\n+    }\n+}\n+\n+pub type ConstraintMap<'tcx> = FnvHashMap<Constraint, SubregionOrigin<'tcx>>;\n+\n+fn dump_region_constraints_to<'a, 'tcx:'a >(tcx: &'a ty::ctxt<'tcx>,\n+                                            map: &ConstraintMap<'tcx>,\n+                                            path: &str) -> io::IoResult<()> {\n+    debug!(\"dump_region_constraints map (len: {}) path: {}\", map.len(), path);\n+    let g = ConstraintGraph::new(tcx, format!(\"region_constraints\"), map);\n+    let mut f = File::create(&Path::new(path));\n+    debug!(\"dump_region_constraints calling render\");\n+    dot::render(&g, &mut f)\n+}"}, {"sha": "ca2860ae6b37cfc89fcfc32859aa9c90eeb63c19", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -37,9 +37,10 @@ use std::uint;\n use syntax::ast;\n \n mod doc;\n+mod graphviz;\n \n // A constraint that influences the inference process.\n-#[deriving(PartialEq, Eq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub enum Constraint {\n     // One region variable is subregion of another\n     ConstrainVarSubVar(RegionVid, RegionVid),\n@@ -706,10 +707,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     /// fixed-point iteration to find region values which satisfy all\n     /// constraints, assuming such values can be found; if they cannot,\n     /// errors are reported.\n-    pub fn resolve_regions(&self) -> Vec<RegionResolutionError<'tcx>> {\n+    pub fn resolve_regions(&self, subject_node: ast::NodeId) -> Vec<RegionResolutionError<'tcx>> {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n         let mut errors = vec!();\n-        let v = self.infer_variable_values(&mut errors);\n+        let v = self.infer_variable_values(&mut errors, subject_node);\n         *self.values.borrow_mut() = Some(v);\n         errors\n     }\n@@ -958,14 +959,15 @@ type RegionGraph = graph::Graph<(), Constraint>;\n \n impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn infer_variable_values(&self,\n-                             errors: &mut Vec<RegionResolutionError<'tcx>>)\n-                             -> Vec<VarValue>\n+                             errors: &mut Vec<RegionResolutionError<'tcx>>,\n+                             subject: ast::NodeId) -> Vec<VarValue>\n     {\n         let mut var_data = self.construct_var_data();\n \n         // Dorky hack to cause `dump_constraints` to only get called\n         // if debug mode is enabled:\n         debug!(\"----() End constraint listing {}---\", self.dump_constraints());\n+        graphviz::maybe_print_constraints_for(self, subject);\n \n         self.expansion(var_data.as_mut_slice());\n         self.contraction(var_data.as_mut_slice());"}, {"sha": "c76d9bc6b1faabf03a21ec1d5e9db4fd2b5d93d1", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -1199,7 +1199,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           ast::ExprIndex(ref l, ref r) |\n           ast::ExprBinary(_, ref l, ref r) |\n-          ast::ExprBox(ref l, ref r) => {\n+          ast::ExprBox(Some(ref l), ref r) => {\n             let r_succ = self.propagate_through_expr(&**r, succ);\n             self.propagate_through_expr(&**l, r_succ)\n           }\n@@ -1210,6 +1210,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&**e1, succ)\n           }\n \n+          ast::ExprBox(None, ref e) |\n           ast::ExprAddrOf(_, ref e) |\n           ast::ExprCast(ref e, _) |\n           ast::ExprUnary(_, ref e) |"}, {"sha": "f551ff061654a948e65ec688d9a8e88384ab9a0c", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -1209,6 +1209,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // is reserve judgement and then intertwine this\n                 // analysis with closure inference.\n                 assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n+\n+                // Unboxed closures shouldn't be\n+                // implicitly copyable\n+                if bound == ty::BoundCopy {\n+                    return Ok(ParameterBuiltin);\n+                }\n+\n                 match self.tcx().freevars.borrow().get(&def_id.node) {\n                     None => {\n                         // No upvars."}, {"sha": "84b69eb8471b6929b3ac3d6e5b2c674ac6097d70", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 160, "deletions": 115, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -4320,12 +4320,13 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n \n         ast::ExprLit(_) | // Note: LitStr is carved out above\n         ast::ExprUnary(..) |\n+        ast::ExprBox(None, _) |\n         ast::ExprAddrOf(..) |\n         ast::ExprBinary(..) => {\n             RvalueDatumExpr\n         }\n \n-        ast::ExprBox(ref place, _) => {\n+        ast::ExprBox(Some(ref place), _) => {\n             // Special case `Box<T>` for now:\n             let definition = match tcx.def_map.borrow().get(&place.id) {\n                 Some(&def) => def,\n@@ -5825,126 +5826,153 @@ pub fn trait_item_of_item(tcx: &ctxt, def_id: ast::DefId)\n /// context it's calculated within. This is used by the `type_id` intrinsic.\n pub fn hash_crate_independent(tcx: &ctxt, ty: Ty, svh: &Svh) -> u64 {\n     let mut state = sip::SipState::new();\n-    macro_rules! byte( ($b:expr) => { ($b as u8).hash(&mut state) } );\n-    macro_rules! hash( ($e:expr) => { $e.hash(&mut state) } );\n-\n-    let region = |_state: &mut sip::SipState, r: Region| {\n-        match r {\n-            ReStatic => {}\n-\n-            ReEmpty |\n-            ReEarlyBound(..) |\n-            ReLateBound(..) |\n-            ReFree(..) |\n-            ReScope(..) |\n-            ReInfer(..) => {\n-                tcx.sess.bug(\"non-static region found when hashing a type\")\n+    helper(tcx, ty, svh, &mut state);\n+    return state.result();\n+\n+    fn helper(tcx: &ctxt, ty: Ty, svh: &Svh, state: &mut sip::SipState) {\n+        macro_rules! byte( ($b:expr) => { ($b as u8).hash(state) } );\n+        macro_rules! hash( ($e:expr) => { $e.hash(state) } );\n+\n+        let region = |state: &mut sip::SipState, r: Region| {\n+            match r {\n+                ReStatic => {}\n+                ReLateBound(db, BrAnon(i)) => {\n+                    db.hash(state);\n+                    i.hash(state);\n+                }\n+                ReEmpty |\n+                ReEarlyBound(..) |\n+                ReLateBound(..) |\n+                ReFree(..) |\n+                ReScope(..) |\n+                ReInfer(..) => {\n+                    tcx.sess.bug(\"unexpected region found when hashing a type\")\n+                }\n             }\n-        }\n-    };\n-    let did = |state: &mut sip::SipState, did: DefId| {\n-        let h = if ast_util::is_local(did) {\n-            svh.clone()\n-        } else {\n-            tcx.sess.cstore.get_crate_hash(did.krate)\n         };\n-        h.as_str().hash(state);\n-        did.node.hash(state);\n-    };\n-    let mt = |state: &mut sip::SipState, mt: mt| {\n-        mt.mutbl.hash(state);\n-    };\n-    ty::walk_ty(ty, |ty| {\n-        match ty.sty {\n-            ty_bool => byte!(2),\n-            ty_char => byte!(3),\n-            ty_int(i) => {\n-                byte!(4);\n-                hash!(i);\n-            }\n-            ty_uint(u) => {\n-                byte!(5);\n-                hash!(u);\n-            }\n-            ty_float(f) => {\n-                byte!(6);\n-                hash!(f);\n-            }\n-            ty_str => {\n-                byte!(7);\n-            }\n-            ty_enum(d, _) => {\n-                byte!(8);\n-                did(&mut state, d);\n-            }\n-            ty_uniq(_) => {\n-                byte!(9);\n-            }\n-            ty_vec(_, Some(n)) => {\n-                byte!(10);\n-                n.hash(&mut state);\n-            }\n-            ty_vec(_, None) => {\n-                byte!(11);\n-            }\n-            ty_ptr(m) => {\n-                byte!(12);\n-                mt(&mut state, m);\n-            }\n-            ty_rptr(r, m) => {\n-                byte!(13);\n-                region(&mut state, r);\n-                mt(&mut state, m);\n-            }\n-            ty_bare_fn(ref b) => {\n-                byte!(14);\n-                hash!(b.unsafety);\n-                hash!(b.abi);\n+        let did = |state: &mut sip::SipState, did: DefId| {\n+            let h = if ast_util::is_local(did) {\n+                svh.clone()\n+            } else {\n+                tcx.sess.cstore.get_crate_hash(did.krate)\n+            };\n+            h.as_str().hash(state);\n+            did.node.hash(state);\n+        };\n+        let mt = |state: &mut sip::SipState, mt: mt| {\n+            mt.mutbl.hash(state);\n+        };\n+        let fn_sig = |state: &mut sip::SipState, sig: &FnSig| {\n+            let sig = anonymize_late_bound_regions(tcx, sig);\n+            for a in sig.inputs.iter() { helper(tcx, *a, svh, state); }\n+            if let ty::FnConverging(output) = sig.output {\n+                helper(tcx, output, svh, state);\n             }\n-            ty_closure(ref c) => {\n-                byte!(15);\n-                hash!(c.unsafety);\n-                hash!(c.onceness);\n-                hash!(c.bounds);\n-                match c.store {\n-                    UniqTraitStore => byte!(0),\n-                    RegionTraitStore(r, m) => {\n-                        byte!(1)\n-                        region(&mut state, r);\n-                        assert_eq!(m, ast::MutMutable);\n+        };\n+        maybe_walk_ty(ty, |ty| {\n+            match ty.sty {\n+                ty_bool => byte!(2),\n+                ty_char => byte!(3),\n+                ty_int(i) => {\n+                    byte!(4);\n+                    hash!(i);\n+                }\n+                ty_uint(u) => {\n+                    byte!(5);\n+                    hash!(u);\n+                }\n+                ty_float(f) => {\n+                    byte!(6);\n+                    hash!(f);\n+                }\n+                ty_str => {\n+                    byte!(7);\n+                }\n+                ty_enum(d, _) => {\n+                    byte!(8);\n+                    did(state, d);\n+                }\n+                ty_uniq(_) => {\n+                    byte!(9);\n+                }\n+                ty_vec(_, Some(n)) => {\n+                    byte!(10);\n+                    n.hash(state);\n+                }\n+                ty_vec(_, None) => {\n+                    byte!(11);\n+                }\n+                ty_ptr(m) => {\n+                    byte!(12);\n+                    mt(state, m);\n+                }\n+                ty_rptr(r, m) => {\n+                    byte!(13);\n+                    region(state, r);\n+                    mt(state, m);\n+                }\n+                ty_bare_fn(ref b) => {\n+                    byte!(14);\n+                    hash!(b.unsafety);\n+                    hash!(b.abi);\n+                    fn_sig(state, &b.sig);\n+                    return false;\n+                }\n+                ty_closure(ref c) => {\n+                    byte!(15);\n+                    hash!(c.unsafety);\n+                    hash!(c.onceness);\n+                    hash!(c.bounds);\n+                    match c.store {\n+                        UniqTraitStore => byte!(0),\n+                        RegionTraitStore(r, m) => {\n+                            byte!(1);\n+                            region(state, r);\n+                            assert_eq!(m, ast::MutMutable);\n+                        }\n                     }\n+\n+                    fn_sig(state, &c.sig);\n+\n+                    return false;\n                 }\n-            }\n-            ty_trait(box TyTrait { ref principal, bounds }) => {\n-                byte!(17);\n-                did(&mut state, principal.def_id);\n-                hash!(bounds);\n-            }\n-            ty_struct(d, _) => {\n-                byte!(18);\n-                did(&mut state, d);\n-            }\n-            ty_tup(ref inner) => {\n-                byte!(19);\n-                hash!(inner.len());\n-            }\n-            ty_param(p) => {\n-                byte!(20);\n-                hash!(p.idx);\n-                did(&mut state, p.def_id);\n-            }\n-            ty_open(_) => byte!(22),\n-            ty_infer(_) => unreachable!(),\n-            ty_err => byte!(23),\n-            ty_unboxed_closure(d, r, _) => {\n-                byte!(24);\n-                did(&mut state, d);\n-                region(&mut state, r);\n-            }\n-        }\n-    });\n+                ty_trait(box TyTrait { ref principal, bounds }) => {\n+                    byte!(17);\n+                    did(state, principal.def_id);\n+                    hash!(bounds);\n+\n+                    let principal = anonymize_late_bound_regions(tcx, principal);\n+                    for subty in principal.substs.types.iter() {\n+                        helper(tcx, *subty, svh, state);\n+                    }\n \n-    state.result()\n+                    return false;\n+                }\n+                ty_struct(d, _) => {\n+                    byte!(18);\n+                    did(state, d);\n+                }\n+                ty_tup(ref inner) => {\n+                    byte!(19);\n+                    hash!(inner.len());\n+                }\n+                ty_param(p) => {\n+                    byte!(20);\n+                    hash!(p.idx);\n+                    did(state, p.def_id);\n+                }\n+                ty_open(_) => byte!(22),\n+                ty_infer(_) => unreachable!(),\n+                ty_err => byte!(23),\n+                ty_unboxed_closure(d, r, _) => {\n+                    byte!(24);\n+                    did(state, d);\n+                    region(state, r);\n+                }\n+            }\n+            true\n+        });\n+    }\n }\n \n impl Variance {\n@@ -6284,6 +6312,23 @@ pub fn erase_late_bound_regions<'tcx, HR>(\n     replace_late_bound_regions(tcx, value, |_, _| ty::ReStatic).0\n }\n \n+/// Rewrite any late-bound regions so that they are anonymous.  Region numbers are\n+/// assigned starting at 1 and increasing monotonically in the order traversed\n+/// by the fold operation.\n+///\n+/// The chief purpose of this function is to canonicalize regions so that two\n+/// `FnSig`s or `TraitRef`s which are equivalent up to region naming will become\n+/// structurally identical.  For example, `for<'a, 'b> fn(&'a int, &'b int)` and\n+/// `for<'a, 'b> fn(&'b int, &'a int)` will become identical after anonymization.\n+pub fn anonymize_late_bound_regions<'tcx, HR>(tcx: &ctxt<'tcx>, sig: &HR) -> HR\n+                                              where HR: HigherRankedFoldable<'tcx> {\n+    let mut counter = 0;\n+    replace_late_bound_regions(tcx, sig, |_, db| {\n+        counter += 1;\n+        ReLateBound(db, BrAnon(counter))\n+    }).0\n+}\n+\n /// Replaces the late-bound-regions in `value` that are bound by `value`.\n pub fn replace_late_bound_regions<'tcx, HR, F>(\n     tcx: &ty::ctxt<'tcx>,"}, {"sha": "b3b44b60b6ead979a40dc9a97c759f78da4f2188", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -276,7 +276,8 @@ debugging_opts!(\n         FLOWGRAPH_PRINT_MOVES,\n         FLOWGRAPH_PRINT_ASSIGNS,\n         FLOWGRAPH_PRINT_ALL,\n-        PRINT_SYSROOT\n+        PRINT_SYSROOT,\n+        PRINT_REGION_GRAPH\n     ]\n     0\n )\n@@ -322,7 +323,10 @@ pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {\n      (\"flowgraph-print-all\", \"Include all dataflow analysis data in \\\n                        --pretty flowgraph output\", FLOWGRAPH_PRINT_ALL),\n      (\"print-sysroot\", \"Print the sysroot as used by this rustc invocation\",\n-      PRINT_SYSROOT)]\n+      PRINT_SYSROOT),\n+     (\"print-region-graph\", \"Prints region inference graph. \\\n+                             Use with RUST_REGION_GRAPH=help for more info\",\n+      PRINT_REGION_GRAPH)]\n }\n \n #[deriving(Clone)]"}, {"sha": "13b5c262bf7825e00f6df4f80b977597d98ad19b", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -428,17 +428,19 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n             let base = ty::item_path_str(cx, did);\n             let generics = ty::lookup_item_type(cx, did).generics;\n-            parameterized(cx, base.as_slice(), substs, &generics)\n+            parameterized(cx, base.as_slice(), substs, &generics, did)\n         }\n         ty_trait(box ty::TyTrait {\n             ref principal, ref bounds\n         }) => {\n             let base = ty::item_path_str(cx, principal.def_id);\n             let trait_def = ty::lookup_trait_def(cx, principal.def_id);\n+            let did = trait_def.trait_ref.def_id;\n             let ty = parameterized(cx, base.as_slice(),\n-                                   &principal.substs, &trait_def.generics);\n+                                   &principal.substs, &trait_def.generics,\n+                                   did);\n             let bound_str = bounds.user_string(cx);\n-            let bound_sep = if bound_str.is_empty() { \"\" } else { \"+\" };\n+            let bound_sep = if bound_str.is_empty() { \"\" } else { \" + \" };\n             format!(\"{}{}{}\",\n                     ty,\n                     bound_sep,\n@@ -484,7 +486,8 @@ pub fn explicit_self_category_to_str(category: &ty::ExplicitSelfCategory)\n pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n                            base: &str,\n                            substs: &subst::Substs<'tcx>,\n-                           generics: &ty::Generics<'tcx>)\n+                           generics: &ty::Generics<'tcx>,\n+                           did: ast::DefId)\n                            -> String\n {\n     if cx.sess.verbose() {\n@@ -537,7 +540,12 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n         strs.push(ty_to_string(cx, *t))\n     }\n \n-    if strs.len() > 0u {\n+    if cx.lang_items.fn_trait_kind(did).is_some() {\n+        format!(\"{}({}){}\",\n+                base,\n+                strs[0][1 .. strs[0].len() - (strs[0].ends_with(\",)\") as uint+1)],\n+                if &*strs[1] == \"()\" { String::new() } else { format!(\" -> {}\", strs[1]) })\n+    } else if strs.len() > 0 {\n         format!(\"{}<{}>\", base, strs.connect(\", \"))\n     } else {\n         format!(\"{}\", base)\n@@ -743,7 +751,7 @@ impl<'tcx> Repr<'tcx> for ty::TraitRef<'tcx> {\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n         format!(\"<{} : {}>\",\n                 self.substs.self_ty().repr(tcx),\n-                parameterized(tcx, base.as_slice(), &self.substs, &trait_def.generics))\n+                parameterized(tcx, base.as_slice(), &self.substs, &trait_def.generics, self.def_id))\n     }\n }\n \n@@ -1116,7 +1124,7 @@ impl<'tcx> UserString<'tcx> for ty::ParamBounds<'tcx> {\n         for n in self.trait_bounds.iter() {\n             result.push(n.user_string(tcx));\n         }\n-        result.connect(\"+\")\n+        result.connect(\" + \")\n     }\n }\n \n@@ -1189,7 +1197,8 @@ impl<'tcx> UserString<'tcx> for ty::TraitRef<'tcx> {\n             };\n \n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n-        parameterized(tcx, base.as_slice(), &trait_ref.substs, &trait_def.generics)\n+        let did = trait_def.trait_ref.def_id;\n+        parameterized(tcx, base.as_slice(), &trait_ref.substs, &trait_def.generics, did)\n     }\n }\n "}, {"sha": "e80e8dc5351041f7c9735eaca1c7e86594a8773b", "filename": "src/librustc/util/snapshot_vec.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -20,7 +20,6 @@\n //! those changes.\n use self::UndoLog::*;\n \n-use std::kinds::marker;\n use std::mem;\n \n #[deriving(PartialEq)]\n@@ -47,10 +46,9 @@ pub struct SnapshotVec<T,U,D> {\n     delegate: D\n }\n \n+// Snapshots are tokens that should be created/consumed linearly.\n+#[allow(missing_copy_implementations)]\n pub struct Snapshot {\n-    // Snapshots are tokens that should be created/consumed linearly.\n-    marker: marker::NoCopy,\n-\n     // Length of the undo log at the time the snapshot was taken.\n     length: uint,\n }\n@@ -112,8 +110,7 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n     pub fn start_snapshot(&mut self) -> Snapshot {\n         let length = self.undo_log.len();\n         self.undo_log.push(OpenSnapshot);\n-        Snapshot { length: length,\n-                   marker: marker::NoCopy }\n+        Snapshot { length: length }\n     }\n \n     fn assert_open_snapshot(&self, snapshot: &Snapshot) {"}, {"sha": "ffc5a3919b60f96605e9e867bcb6203229e21214", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -16,8 +16,8 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![feature(default_type_params, globs, if_let, import_shadowing, macro_rules, phase, quote)]\n-#![feature(slicing_syntax, tuple_indexing, unsafe_destructor)]\n+#![feature(default_type_params, globs, import_shadowing, macro_rules, phase, quote)]\n+#![feature(slicing_syntax, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(unboxed_closures)]\n #![allow(non_camel_case_types)]"}, {"sha": "57004d71c75e46065f7c43769662b3e1909f3817", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -325,7 +325,7 @@ impl FromStr for UserIdentifiedItem {\n }\n \n enum NodesMatchingUII<'a, 'ast: 'a> {\n-    NodesMatchingDirect(option::Item<ast::NodeId>),\n+    NodesMatchingDirect(option::IntoIter<ast::NodeId>),\n     NodesMatchingSuffix(ast_map::NodesMatchingSuffix<'a, 'ast, String>),\n }\n "}, {"sha": "508af4c28e66c1f0bfe8d658f1a8c12db4a11579", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -139,7 +139,7 @@ fn test_env<F>(source_string: &str,\n                           stability_index);\n     let infcx = infer::new_infer_ctxt(&tcx);\n     body(Env { infcx: &infcx });\n-    infcx.resolve_regions_and_report_errors();\n+    infcx.resolve_regions_and_report_errors(ast::CRATE_NODE_ID);\n     assert_eq!(tcx.sess.err_count(), expected_err_count);\n }\n "}, {"sha": "c97e6a09529ec897d977770b648a66fb81e6771d", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -3472,7 +3472,8 @@ fn populate_scope_map(cx: &CrateContext,\n                 walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n \n             ast::ExprBox(ref place, ref sub_expr) => {\n-                walk_expr(cx, &**place, scope_stack, scope_map);\n+                place.as_ref().map(\n+                    |e| walk_expr(cx, &**e, scope_stack, scope_map));\n                 walk_expr(cx, &**sub_expr, scope_stack, scope_map);\n             }\n "}, {"sha": "f3b9e98ad4830251af0a78ae5c37450ca5b72658", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -1188,7 +1188,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     // Finally, resolve all regions. This catches wily misuses of lifetime\n     // parameters.\n-    infcx.resolve_regions_and_report_errors();\n+    infcx.resolve_regions_and_report_errors(impl_m_body_id);\n \n     /// Check that region bounds on impl method are the same as those on the trait. In principle,\n     /// it could be ok for there to be fewer region bounds on the impl method, but this leads to an\n@@ -3662,22 +3662,25 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n     match expr.node {\n-      ast::ExprBox(ref place, ref subexpr) => {\n-          check_expr(fcx, &**place);\n+      ast::ExprBox(ref opt_place, ref subexpr) => {\n+          opt_place.as_ref().map(|place|check_expr(fcx, &**place));\n           check_expr(fcx, &**subexpr);\n \n           let mut checked = false;\n-          if let ast::ExprPath(ref path) = place.node {\n-              // FIXME(pcwalton): For now we hardcode the two permissible\n-              // places: the exchange heap and the managed heap.\n-              let definition = lookup_def(fcx, path.span, place.id);\n-              let def_id = definition.def_id();\n-              let referent_ty = fcx.expr_ty(&**subexpr);\n-              if tcx.lang_items.exchange_heap() == Some(def_id) {\n-                  fcx.write_ty(id, ty::mk_uniq(tcx, referent_ty));\n-                  checked = true\n+          opt_place.as_ref().map(|place| match place.node {\n+              ast::ExprPath(ref path) => {\n+                  // FIXME(pcwalton): For now we hardcode the two permissible\n+                  // places: the exchange heap and the managed heap.\n+                  let definition = lookup_def(fcx, path.span, place.id);\n+                  let def_id = definition.def_id();\n+                  let referent_ty = fcx.expr_ty(&**subexpr);\n+                  if tcx.lang_items.exchange_heap() == Some(def_id) {\n+                      fcx.write_ty(id, ty::mk_uniq(tcx, referent_ty));\n+                      checked = true\n+                  }\n               }\n-          }\n+              _ => {}\n+          });\n \n           if !checked {\n               span_err!(tcx.sess, expr.span, E0066,"}, {"sha": "6cfe24342e2be3549fefdde4cf4c3705d779cf08", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -139,27 +139,31 @@ use syntax::visit::Visitor;\n use std::cell::{RefCell};\n use std::collections::hash_map::{Vacant, Occupied};\n \n+use self::RepeatingScope::Repeating;\n+use self::SubjectNode::Subject;\n+\n+\n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS\n \n pub fn regionck_expr(fcx: &FnCtxt, e: &ast::Expr) {\n-    let mut rcx = Rcx::new(fcx, e.id);\n+    let mut rcx = Rcx::new(fcx, Repeating(e.id), Subject(e.id));\n     if fcx.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n         rcx.visit_expr(e);\n         rcx.visit_region_obligations(e.id);\n     }\n-    fcx.infcx().resolve_regions_and_report_errors();\n+    rcx.resolve_regions_and_report_errors();\n }\n \n pub fn regionck_item(fcx: &FnCtxt, item: &ast::Item) {\n-    let mut rcx = Rcx::new(fcx, item.id);\n+    let mut rcx = Rcx::new(fcx, Repeating(item.id), Subject(item.id));\n     rcx.visit_region_obligations(item.id);\n-    fcx.infcx().resolve_regions_and_report_errors();\n+    rcx.resolve_regions_and_report_errors();\n }\n \n pub fn regionck_fn(fcx: &FnCtxt, id: ast::NodeId, decl: &ast::FnDecl, blk: &ast::Block) {\n-    let mut rcx = Rcx::new(fcx, blk.id);\n+    let mut rcx = Rcx::new(fcx, Repeating(blk.id), Subject(id));\n     if fcx.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n         rcx.visit_fn_body(id, decl, blk);\n@@ -169,15 +173,15 @@ pub fn regionck_fn(fcx: &FnCtxt, id: ast::NodeId, decl: &ast::FnDecl, blk: &ast:\n     // particularly around closure bounds.\n     vtable::select_all_fcx_obligations_or_error(fcx);\n \n-    fcx.infcx().resolve_regions_and_report_errors();\n+    rcx.resolve_regions_and_report_errors();\n }\n \n /// Checks that the types in `component_tys` are well-formed. This will add constraints into the\n /// region graph. Does *not* run `resolve_regions_and_report_errors` and so forth.\n pub fn regionck_ensure_component_tys_wf<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   span: Span,\n                                                   component_tys: &[Ty<'tcx>]) {\n-    let mut rcx = Rcx::new(fcx, 0);\n+    let mut rcx = Rcx::new(fcx, Repeating(0), SubjectNode::None);\n     for &component_ty in component_tys.iter() {\n         // Check that each type outlives the empty region. Since the\n         // empty region is a subregion of all others, this can't fail\n@@ -225,6 +229,9 @@ pub struct Rcx<'a, 'tcx: 'a> {\n     // id of innermost fn or loop\n     repeating_scope: ast::NodeId,\n \n+    // id of AST node being analyzed (the subject of the analysis).\n+    subject: SubjectNode,\n+\n     // Possible region links we will establish if an upvar\n     // turns out to be unique/mutable\n     maybe_links: MaybeLinkMap<'tcx>\n@@ -251,11 +258,17 @@ fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n     }\n }\n \n+pub enum RepeatingScope { Repeating(ast::NodeId) }\n+pub enum SubjectNode { Subject(ast::NodeId), None }\n+\n impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     pub fn new(fcx: &'a FnCtxt<'a, 'tcx>,\n-               initial_repeating_scope: ast::NodeId) -> Rcx<'a, 'tcx> {\n+               initial_repeating_scope: RepeatingScope,\n+               subject: SubjectNode) -> Rcx<'a, 'tcx> {\n+        let Repeating(initial_repeating_scope) = initial_repeating_scope;\n         Rcx { fcx: fcx,\n               repeating_scope: initial_repeating_scope,\n+              subject: subject,\n               region_param_pairs: Vec::new(),\n               maybe_links: RefCell::new(FnvHashMap::new()) }\n     }\n@@ -425,6 +438,18 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n \n         debug!(\"<< relate_free_regions\");\n     }\n+\n+    fn resolve_regions_and_report_errors(&self) {\n+        let subject_node_id = match self.subject {\n+            Subject(s) => s,\n+            SubjectNode::None => {\n+                self.tcx().sess.bug(\"cannot resolve_regions_and_report_errors \\\n+                                     without subject node\");\n+            }\n+        };\n+\n+        self.fcx.infcx().resolve_regions_and_report_errors(subject_node_id);\n+    }\n }\n \n impl<'fcx, 'tcx> mc::Typer<'tcx> for Rcx<'fcx, 'tcx> {"}, {"sha": "91947f67dd7f5e81966e5ce99ac8b2c54971463b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -2237,6 +2237,6 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n                 format!(\"mismatched self type: expected `{}`\",\n                         ppaux::ty_to_string(crate_context.tcx, required_type))\n         }));\n-        infcx.resolve_regions_and_report_errors();\n+        infcx.resolve_regions_and_report_errors(body_id);\n     }\n }"}, {"sha": "02ca7d3ce6d45a412f7850149c17dbabb8ac44d4", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -128,5 +128,5 @@ pub mod shouldnt_be_public {\n \n #[cfg(not(test))]\n mod std {\n-    pub use core::{fmt, option, cmp};\n+    pub use core::{fmt, option, cmp, kinds};\n }"}, {"sha": "2feea7fa0a4382df63156ec8a48880fd160c86dc", "filename": "src/librustrt/libunwind.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustrt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustrt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flibunwind.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -25,6 +25,7 @@ use libc;\n \n #[cfg(any(not(target_arch = \"arm\"), target_os = \"ios\"))]\n #[repr(C)]\n+#[deriving(Copy)]\n pub enum _Unwind_Action {\n     _UA_SEARCH_PHASE = 1,\n     _UA_CLEANUP_PHASE = 2,"}, {"sha": "b942a3819cc41162b96cfc2eb3b1227446745653", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -20,7 +20,6 @@ use alloc::boxed::Box;\n use core::any::Any;\n use core::atomic::{AtomicUint, SeqCst};\n use core::iter::{IteratorExt, Take};\n-use core::kinds::marker;\n use core::ops::FnOnce;\n use core::mem;\n use core::ops::FnMut;\n@@ -95,7 +94,6 @@ pub enum BlockedTask {\n /// Per-task state related to task death, killing, panic, etc.\n pub struct Death {\n     pub on_exit: Option<Thunk<Result>>,\n-    marker: marker::NoCopy,\n }\n \n pub struct BlockedTasks {\n@@ -499,7 +497,7 @@ impl BlockedTask {\n \n impl Death {\n     pub fn new() -> Death {\n-        Death { on_exit: None, marker: marker::NoCopy }\n+        Death { on_exit: None }\n     }\n }\n "}, {"sha": "c811a16e2b160c031faf507b1d15ea7bf01b8ac8", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -367,8 +367,8 @@ fn escape_str(writer: &mut io::Writer, v: &str) -> Result<(), io::IoError> {\n \n fn escape_char(writer: &mut io::Writer, v: char) -> Result<(), io::IoError> {\n     let mut buf = [0, .. 4];\n-    v.encode_utf8(&mut buf);\n-    escape_bytes(writer, &mut buf)\n+    let len = v.encode_utf8(&mut buf).unwrap();\n+    escape_bytes(writer, buf[mut ..len])\n }\n \n fn spaces(wr: &mut io::Writer, mut n: uint) -> Result<(), io::IoError> {\n@@ -2082,8 +2082,9 @@ impl ::Decoder<DecoderError> for Decoder {\n         f(self)\n     }\n \n-    fn read_enum_variant<T, F>(&mut self, names: &[&str], f: F) -> DecodeResult<T> where\n-        F: FnOnce(&mut Decoder, uint) -> DecodeResult<T>,\n+    fn read_enum_variant<T, F>(&mut self, names: &[&str],\n+                               mut f: F) -> DecodeResult<T>\n+        where F: FnMut(&mut Decoder, uint) -> DecodeResult<T>,\n     {\n         debug!(\"read_enum_variant(names={})\", names);\n         let name = match self.pop() {\n@@ -2133,7 +2134,7 @@ impl ::Decoder<DecoderError> for Decoder {\n     }\n \n     fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F) -> DecodeResult<T> where\n-        F: FnOnce(&mut Decoder, uint) -> DecodeResult<T>,\n+        F: FnMut(&mut Decoder, uint) -> DecodeResult<T>,\n     {\n         debug!(\"read_enum_struct_variant(names={})\", names);\n         self.read_enum_variant(names, f)\n@@ -2230,8 +2231,8 @@ impl ::Decoder<DecoderError> for Decoder {\n         self.read_tuple_arg(idx, f)\n     }\n \n-    fn read_option<T, F>(&mut self, f: F) -> DecodeResult<T> where\n-        F: FnOnce(&mut Decoder, bool) -> DecodeResult<T>,\n+    fn read_option<T, F>(&mut self, mut f: F) -> DecodeResult<T> where\n+        F: FnMut(&mut Decoder, bool) -> DecodeResult<T>,\n     {\n         debug!(\"read_option()\");\n         match self.pop() {\n@@ -2729,37 +2730,39 @@ mod tests {\n         );\n     }\n \n+    macro_rules! check_encoder_for_simple(\n+        ($value:expr, $expected:expr) => ({\n+            let s = with_str_writer(|writer| {\n+                let mut encoder = Encoder::new(writer);\n+                $value.encode(&mut encoder).unwrap();\n+            });\n+            assert_eq!(s, $expected);\n+\n+            let s = with_str_writer(|writer| {\n+                let mut encoder = PrettyEncoder::new(writer);\n+                $value.encode(&mut encoder).unwrap();\n+            });\n+            assert_eq!(s, $expected);\n+        })\n+    )\n+\n     #[test]\n     fn test_write_some() {\n-        let value = Some(\"jodhpurs\".into_string());\n-        let s = with_str_writer(|writer| {\n-            let mut encoder = Encoder::new(writer);\n-            value.encode(&mut encoder).unwrap();\n-        });\n-        assert_eq!(s, \"\\\"jodhpurs\\\"\");\n-\n-        let value = Some(\"jodhpurs\".into_string());\n-        let s = with_str_writer(|writer| {\n-            let mut encoder = PrettyEncoder::new(writer);\n-            value.encode(&mut encoder).unwrap();\n-        });\n-        assert_eq!(s, \"\\\"jodhpurs\\\"\");\n+        check_encoder_for_simple!(Some(\"jodhpurs\".to_string()), \"\\\"jodhpurs\\\"\");\n     }\n \n     #[test]\n     fn test_write_none() {\n-        let value: Option<string::String> = None;\n-        let s = with_str_writer(|writer| {\n-            let mut encoder = Encoder::new(writer);\n-            value.encode(&mut encoder).unwrap();\n-        });\n-        assert_eq!(s, \"null\");\n+        check_encoder_for_simple!(None::<string::String>, \"null\");\n+    }\n \n-        let s = with_str_writer(|writer| {\n-            let mut encoder = Encoder::new(writer);\n-            value.encode(&mut encoder).unwrap();\n-        });\n-        assert_eq!(s, \"null\");\n+    #[test]\n+    fn test_write_char() {\n+        check_encoder_for_simple!('a', \"\\\"a\\\"\");\n+        check_encoder_for_simple!('\\t', \"\\\"\\\\t\\\"\");\n+        check_encoder_for_simple!('\\u00a0', \"\\\"\\u00a0\\\"\");\n+        check_encoder_for_simple!('\\uabcd', \"\\\"\\uabcd\\\"\");\n+        check_encoder_for_simple!('\\U0010ffff', \"\\\"\\U0010ffff\\\"\");\n     }\n \n     #[test]"}, {"sha": "0e0d3b4115bd76e52fc11b16b46f9554f935c94c", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -120,12 +120,12 @@ pub trait Decoder<E> {\n         F: FnOnce(&mut Self) -> Result<T, E>;\n \n     fn read_enum_variant<T, F>(&mut self, names: &[&str], f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self, uint) -> Result<T, E>;\n+        F: FnMut(&mut Self, uint) -> Result<T, E>;\n     fn read_enum_variant_arg<T, F>(&mut self, a_idx: uint, f: F) -> Result<T, E> where\n         F: FnOnce(&mut Self) -> Result<T, E>;\n \n     fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self, uint) -> Result<T, E>;\n+        F: FnMut(&mut Self, uint) -> Result<T, E>;\n     fn read_enum_struct_variant_field<T, F>(&mut self,\n                                             &f_name: &str,\n                                             f_idx: uint,\n@@ -154,7 +154,7 @@ pub trait Decoder<E> {\n \n     // Specialized types:\n     fn read_option<T, F>(&mut self, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self, bool) -> Result<T, E>;\n+        F: FnMut(&mut Self, bool) -> Result<T, E>;\n \n     fn read_seq<T, F>(&mut self, f: F) -> Result<T, E> where\n         F: FnOnce(&mut Self, uint) -> Result<T, E>;"}, {"sha": "0ff29a94f2f949775545a8fc6cc03f03435358cf", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 69, "deletions": 120, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -20,7 +20,7 @@ use cmp::{max, Eq, Equiv, PartialEq};\n use default::Default;\n use fmt::{mod, Show};\n use hash::{Hash, Hasher, RandomSipHasher};\n-use iter::{mod, Iterator, IteratorExt, FromIterator, Extend};\n+use iter::{mod, Iterator, IteratorExt, FromIterator, Extend, Map};\n use kinds::Sized;\n use mem::{mod, replace};\n use num::{Int, UnsignedInt};\n@@ -297,7 +297,7 @@ pub struct HashMap<K, V, H = RandomSipHasher> {\n \n /// Search for a pre-hashed key.\n fn search_hashed<K, V, M, F>(table: M,\n-                             hash: &SafeHash,\n+                             hash: SafeHash,\n                              mut is_match: F)\n                              -> SearchResult<K, V, M> where\n     M: Deref<RawTable<K, V>>,\n@@ -320,14 +320,9 @@ fn search_hashed<K, V, M, F>(table: M,\n         }\n \n         // If the hash doesn't match, it can't be this one..\n-        if *hash == full.hash() {\n-            let matched = {\n-                let (k, _) = full.read();\n-                is_match(k)\n-            };\n-\n+        if hash == full.hash() {\n             // If the key doesn't match, it can't be this one..\n-            if matched {\n+            if is_match(full.read().0) {\n                 return FoundExisting(full);\n             }\n         }\n@@ -353,7 +348,7 @@ fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n     }\n \n     // Now we've done all our shifting. Return the value we grabbed earlier.\n-    return (retkey, retval);\n+    (retkey, retval)\n }\n \n /// Perform robin hood bucket stealing at the given `bucket`. You must\n@@ -389,10 +384,11 @@ fn robin_hood<'a, K: 'a, V: 'a>(mut bucket: FullBucketMut<'a, K, V>,\n                     let b = bucket.put(old_hash, old_key, old_val);\n                     // Now that it's stolen, just read the value's pointer\n                     // right out of the table!\n-                    let (_, v) = Bucket::at_index(b.into_table(), starting_index).peek()\n-                                                                                 .expect_full()\n-                                                                                 .into_mut_refs();\n-                    return v;\n+                    return Bucket::at_index(b.into_table(), starting_index)\n+                               .peek()\n+                               .expect_full()\n+                               .into_mut_refs()\n+                               .1;\n                 },\n                 table::Full(bucket) => bucket\n             };\n@@ -441,14 +437,14 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     fn search_equiv<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a self, q: &Q)\n                     -> Option<FullBucketImm<'a, K, V>> {\n         let hash = self.make_hash(q);\n-        search_hashed(&self.table, &hash, |k| q.equiv(k)).into_option()\n+        search_hashed(&self.table, hash, |k| q.equiv(k)).into_option()\n     }\n \n     #[allow(deprecated)]\n     fn search_equiv_mut<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a mut self, q: &Q)\n                     -> Option<FullBucketMut<'a, K, V>> {\n         let hash = self.make_hash(q);\n-        search_hashed(&mut self.table, &hash, |k| q.equiv(k)).into_option()\n+        search_hashed(&mut self.table, hash, |k| q.equiv(k)).into_option()\n     }\n \n     /// Search for a key, yielding the index if it's found in the hashtable.\n@@ -458,22 +454,22 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         where Q: BorrowFrom<K> + Eq + Hash<S>\n     {\n         let hash = self.make_hash(q);\n-        search_hashed(&self.table, &hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n+        search_hashed(&self.table, hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n             .into_option()\n     }\n \n     fn search_mut<'a, Sized? Q>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n         where Q: BorrowFrom<K> + Eq + Hash<S>\n     {\n         let hash = self.make_hash(q);\n-        search_hashed(&mut self.table, &hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n+        search_hashed(&mut self.table, hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n             .into_option()\n     }\n \n     // The caller should ensure that invariants by Robin Hood Hashing hold.\n     fn insert_hashed_ordered(&mut self, hash: SafeHash, k: K, v: V) {\n         let cap = self.table.capacity();\n-        let mut buckets = Bucket::new(&mut self.table, &hash);\n+        let mut buckets = Bucket::new(&mut self.table, hash);\n         let ib = buckets.index();\n \n         while buckets.index() != ib + cap {\n@@ -762,26 +758,22 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     {\n         // Worst case, we'll find one empty bucket among `size + 1` buckets.\n         let size = self.table.size();\n-        let mut probe = Bucket::new(&mut self.table, &hash);\n+        let mut probe = Bucket::new(&mut self.table, hash);\n         let ib = probe.index();\n \n         loop {\n             let mut bucket = match probe.peek() {\n                 Empty(bucket) => {\n                     // Found a hole!\n-                    let bucket = bucket.put(hash, k, v);\n-                    let (_, val) = bucket.into_mut_refs();\n-                    return val;\n-                },\n+                    return bucket.put(hash, k, v).into_mut_refs().1;\n+                }\n                 Full(bucket) => bucket\n             };\n \n+            // hash matches?\n             if bucket.hash() == hash {\n-                let found_match = {\n-                    let (bucket_k, _) = bucket.read_mut();\n-                    k == *bucket_k\n-                };\n-                if found_match {\n+                // key matches?\n+                if k == *bucket.read_mut().0 {\n                     let (bucket_k, bucket_v) = bucket.into_mut_refs();\n                     debug_assert!(k == *bucket_k);\n                     // Key already exists. Get its reference.\n@@ -811,13 +803,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Deprecated: use `get` and `BorrowFrom` instead.\n     #[deprecated = \"use get and BorrowFrom instead\"]\n     pub fn find_equiv<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a self, k: &Q) -> Option<&'a V> {\n-        match self.search_equiv(k) {\n-            None      => None,\n-            Some(bucket) => {\n-                let (_, v_ref) = bucket.into_refs();\n-                Some(v_ref)\n-            }\n-        }\n+        self.search_equiv(k).map(|bucket| bucket.into_refs().1)\n     }\n \n     /// Deprecated: use `remove` and `BorrowFrom` instead.\n@@ -829,13 +815,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n         self.reserve(1);\n \n-        match self.search_equiv_mut(k) {\n-            Some(bucket) => {\n-                let (_k, val) = pop_internal(bucket);\n-                Some(val)\n-            }\n-            _ => None\n-        }\n+        self.search_equiv_mut(k).map(|bucket| pop_internal(bucket).1)\n     }\n \n     /// An iterator visiting all keys in arbitrary order.\n@@ -859,7 +839,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     pub fn keys(&self) -> Keys<K, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n \n-        self.iter().map(first)\n+        Keys { inner: self.iter().map(first) }\n     }\n \n     /// An iterator visiting all values in arbitrary order.\n@@ -883,7 +863,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     pub fn values(&self) -> Values<K, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n \n-        self.iter().map(second)\n+        Values { inner: self.iter().map(second) }\n     }\n \n     /// An iterator visiting all key-value pairs in arbitrary order.\n@@ -1022,11 +1002,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n         while buckets.index() != cap {\n             buckets = match buckets.peek() {\n-                Empty(b)  => b.next(),\n-                Full(full) => {\n-                    let (b, _, _) = full.take();\n-                    b.next()\n-                }\n+                Empty(b)   => b.next(),\n+                Full(full) => full.take().0.next(),\n             };\n         }\n     }\n@@ -1057,10 +1034,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     pub fn get<Sized? Q>(&self, k: &Q) -> Option<&V>\n         where Q: Hash<S> + Eq + BorrowFrom<K>\n     {\n-        self.search(k).map(|bucket| {\n-            let (_, v) = bucket.into_refs();\n-            v\n-        })\n+        self.search(k).map(|bucket| bucket.into_refs().1)\n     }\n \n     /// Returns true if the map contains a value for the specified key.\n@@ -1115,13 +1089,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     pub fn get_mut<Sized? Q>(&mut self, k: &Q) -> Option<&mut V>\n         where Q: Hash<S> + Eq + BorrowFrom<K>\n     {\n-        match self.search_mut(k) {\n-            Some(bucket) => {\n-                let (_, v) = bucket.into_mut_refs();\n-                Some(v)\n-            }\n-            _ => None\n-        }\n+        self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n     }\n \n     /// Deprecated: Renamed to `insert`.\n@@ -1189,18 +1157,15 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n             return None\n         }\n \n-        self.search_mut(k).map(|bucket| {\n-            let (_k, val) = pop_internal(bucket);\n-            val\n-        })\n+        self.search_mut(k).map(|bucket| pop_internal(bucket).1)\n     }\n }\n \n fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: K)\n         -> Entry<'a, K, V> {\n     // Worst case, we'll find one empty bucket among `size + 1` buckets.\n     let size = table.size();\n-    let mut probe = Bucket::new(table, &hash);\n+    let mut probe = Bucket::new(table, hash);\n     let ib = probe.index();\n \n     loop {\n@@ -1216,13 +1181,10 @@ fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHas\n             Full(bucket) => bucket\n         };\n \n+        // hash matches?\n         if bucket.hash() == hash {\n-            let is_eq = {\n-                let (bucket_k, _) = bucket.read();\n-                k == *bucket_k\n-            };\n-\n-            if is_eq {\n+            // key matches?\n+            if k == *bucket.read().0 {\n                 return Occupied(OccupiedEntry{\n                     elem: bucket,\n                 });\n@@ -1288,7 +1250,9 @@ impl<K: Eq + Hash<S> + Show, V: Show, S, H: Hasher<S>> Show for HashMap<K, V, H>\n     }\n }\n \n+#[stable]\n impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H> {\n+    #[stable]\n     fn default() -> HashMap<K, V, H> {\n         HashMap::with_hasher(Default::default())\n     }\n@@ -1308,10 +1272,7 @@ impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> IndexMut<Q, V> for HashMap<K\n {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, index: &Q) -> &'a mut V {\n-        match self.get_mut(index) {\n-            Some(v) => v,\n-            None => panic!(\"no entry found for key\")\n-        }\n+        self.get_mut(index).expect(\"no entry found for key\")\n     }\n }\n \n@@ -1335,6 +1296,16 @@ pub struct MoveEntries<K, V> {\n     >\n }\n \n+/// HashMap keys iterator\n+pub struct Keys<'a, K: 'a, V: 'a> {\n+    inner: Map<(&'a K, &'a V), &'a K, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n+}\n+\n+/// HashMap values iterator\n+pub struct Values<'a, K: 'a, V: 'a> {\n+    inner: Map<(&'a K, &'a V), &'a V, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n+}\n+\n /// A view into a single occupied location in a HashMap\n pub struct OccupiedEntry<'a, K:'a, V:'a> {\n     elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n@@ -1365,56 +1336,45 @@ enum VacantEntryState<K, V, M> {\n }\n \n impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n-    #[inline]\n-    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n-        self.inner.next()\n-    }\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.inner.size_hint()\n-    }\n+    #[inline] fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n+    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n-    #[inline]\n-    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        self.inner.next()\n-    }\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.inner.size_hint()\n-    }\n+    #[inline] fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n+    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n impl<K, V> Iterator<(K, V)> for MoveEntries<K, V> {\n-    #[inline]\n-    fn next(&mut self) -> Option<(K, V)> {\n-        self.inner.next()\n-    }\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.inner.size_hint()\n-    }\n+    #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n+    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+\n+impl<'a, K, V> Iterator<&'a K> for Keys<'a, K, V> {\n+    #[inline] fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n+    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+\n+impl<'a, K, V> Iterator<&'a V> for Values<'a, K, V> {\n+    #[inline] fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n+    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the value in the entry\n     pub fn get(&self) -> &V {\n-        let (_, v) = self.elem.read();\n-        v\n+        self.elem.read().1\n     }\n \n     /// Gets a mutable reference to the value in the entry\n     pub fn get_mut(&mut self) -> &mut V {\n-        let (_, v) = self.elem.read_mut();\n-        v\n+        self.elem.read_mut().1\n     }\n \n     /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n     /// with a lifetime bound to the map itself\n     pub fn into_mut(self) -> &'a mut V {\n-        let (_, v) = self.elem.into_mut_refs();\n-        v\n+        self.elem.into_mut_refs().1\n     }\n \n     /// Sets the value of the entry, and returns the entry's old value\n@@ -1426,8 +1386,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n \n     /// Takes the value out of the entry, and returns it\n     pub fn take(self) -> V {\n-        let (_, v) = pop_internal(self.elem);\n-        v\n+        pop_internal(self.elem).1\n     }\n }\n \n@@ -1440,25 +1399,15 @@ impl<'a, K, V> VacantEntry<'a, K, V> {\n                 robin_hood(bucket, ib, self.hash, self.key, value)\n             }\n             NoElem(bucket) => {\n-                let full = bucket.put(self.hash, self.key, value);\n-                let (_, v) = full.into_mut_refs();\n-                v\n+                bucket.put(self.hash, self.key, value).into_mut_refs().1\n             }\n         }\n     }\n }\n \n-/// HashMap keys iterator\n-pub type Keys<'a, K, V> =\n-    iter::Map<(&'a K, &'a V), &'a K, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>;\n-\n-/// HashMap values iterator\n-pub type Values<'a, K, V> =\n-    iter::Map<(&'a K, &'a V), &'a V, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>;\n-\n impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> FromIterator<(K, V)> for HashMap<K, V, H> {\n     fn from_iter<T: Iterator<(K, V)>>(iter: T) -> HashMap<K, V, H> {\n-        let (lower, _) = iter.size_hint();\n+        let lower = iter.size_hint().0;\n         let mut map = HashMap::with_capacity_and_hasher(lower, Default::default());\n         map.extend(iter);\n         map"}, {"sha": "67c0f887832fa08d62e9296bb8fefbe9a8df92f8", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 63, "deletions": 23, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -17,12 +17,11 @@ use default::Default;\n use fmt::Show;\n use fmt;\n use hash::{Hash, Hasher, RandomSipHasher};\n-use iter::{Iterator, IteratorExt, FromIterator, FilterMap, Chain, Repeat, Zip, Extend, repeat};\n-use iter;\n+use iter::{Iterator, IteratorExt, FromIterator, Map, FilterMap, Chain, Repeat, Zip, Extend, repeat};\n use option::Option::{Some, None, mod};\n use result::Result::{Ok, Err};\n \n-use super::map::{HashMap, Entries, MoveEntries, INITIAL_CAPACITY};\n+use super::map::{HashMap, MoveEntries, Keys, INITIAL_CAPACITY};\n \n // FIXME(conventions): implement BitOr, BitAnd, BitXor, and Sub\n \n@@ -252,7 +251,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n-        self.map.keys()\n+        SetItems { iter: self.map.keys() }\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each value out\n@@ -279,7 +278,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     pub fn into_iter(self) -> SetMoveItems<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n \n-        self.map.into_iter().map(first)\n+        SetMoveItems { iter: self.map.into_iter().map(first) }\n     }\n \n     /// Visit the values representing the difference.\n@@ -312,7 +311,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n             if !other.contains(elt) { Some(elt) } else { None }\n         }\n \n-        repeat(other).zip(self.iter()).filter_map(filter)\n+        SetAlgebraItems { iter: repeat(other).zip(self.iter()).filter_map(filter) }\n     }\n \n     /// Visit the values representing the symmetric difference.\n@@ -337,8 +336,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, H>)\n-        -> Chain<SetAlgebraItems<'a, T, H>, SetAlgebraItems<'a, T, H>> {\n-        self.difference(other).chain(other.difference(self))\n+        -> SymDifferenceItems<'a, T, H> {\n+        SymDifferenceItems { iter: self.difference(other).chain(other.difference(self)) }\n     }\n \n     /// Visit the values representing the intersection.\n@@ -366,7 +365,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n             if other.contains(elt) { Some(elt) } else { None }\n         }\n \n-        repeat(other).zip(self.iter()).filter_map(filter)\n+        SetAlgebraItems { iter: repeat(other).zip(self.iter()).filter_map(filter) }\n     }\n \n     /// Visit the values representing the union.\n@@ -387,9 +386,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(diff, [1i, 2, 3, 4].iter().map(|&x| x).collect());\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn union<'a>(&'a self, other: &'a HashSet<T, H>)\n-        -> Chain<SetItems<'a, T>, SetAlgebraItems<'a, T, H>> {\n-        self.iter().chain(other.difference(self))\n+    pub fn union<'a>(&'a self, other: &'a HashSet<T, H>) -> UnionItems<'a, T, H> {\n+        UnionItems { iter: self.iter().chain(other.difference(self)) }\n     }\n \n     /// Return the number of elements in the set\n@@ -595,7 +593,7 @@ impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n \n impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> FromIterator<T> for HashSet<T, H> {\n     fn from_iter<I: Iterator<T>>(iter: I) -> HashSet<T, H> {\n-        let (lower, _) = iter.size_hint();\n+        let lower = iter.size_hint().0;\n         let mut set = HashSet::with_capacity_and_hasher(lower, Default::default());\n         set.extend(iter);\n         set\n@@ -610,28 +608,70 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Extend<T> for HashSet<T, H> {\n     }\n }\n \n+#[stable]\n impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Default for HashSet<T, H> {\n+    #[stable]\n     fn default() -> HashSet<T, H> {\n         HashSet::with_hasher(Default::default())\n     }\n }\n \n /// HashSet iterator\n-pub type SetItems<'a, K> =\n-    iter::Map<(&'a K, &'a ()), &'a K, Entries<'a, K, ()>, fn((&'a K, &'a ())) -> &'a K>;\n+pub struct SetItems<'a, K: 'a> {\n+    iter: Keys<'a, K, ()>\n+}\n \n /// HashSet move iterator\n-pub type SetMoveItems<K> = iter::Map<(K, ()), K, MoveEntries<K, ()>, fn((K, ())) -> K>;\n+pub struct SetMoveItems<K> {\n+    iter: Map<(K, ()), K, MoveEntries<K, ()>, fn((K, ())) -> K>\n+}\n \n // `Repeat` is used to feed the filter closure an explicit capture\n // of a reference to the other set\n-/// Set operations iterator\n-pub type SetAlgebraItems<'a, T, H> = FilterMap<\n-    (&'a HashSet<T, H>, &'a T),\n-    &'a T,\n-    Zip<Repeat<&'a HashSet<T, H>>, SetItems<'a, T>>,\n-    for<'b> fn((&HashSet<T, H>, &'b T)) -> Option<&'b T>,\n->;\n+/// Set operations iterator, used directly for intersection and difference\n+pub struct SetAlgebraItems<'a, T: 'a, H: 'a> {\n+    iter: FilterMap<\n+        (&'a HashSet<T, H>, &'a T),\n+        &'a T,\n+        Zip<Repeat<&'a HashSet<T, H>>, SetItems<'a, T>>,\n+        for<'b> fn((&HashSet<T, H>, &'b T)) -> Option<&'b T>,\n+    >\n+}\n+\n+/// Symmetric difference iterator.\n+pub struct SymDifferenceItems<'a, T: 'a, H: 'a> {\n+    iter: Chain<SetAlgebraItems<'a, T, H>, SetAlgebraItems<'a, T, H>>\n+}\n+\n+/// Set union iterator.\n+pub struct UnionItems<'a, T: 'a, H: 'a> {\n+    iter: Chain<SetItems<'a, T>, SetAlgebraItems<'a, T, H>>\n+}\n+\n+impl<'a, K> Iterator<&'a K> for SetItems<'a, K> {\n+    fn next(&mut self) -> Option<&'a K> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n+impl<K> Iterator<K> for SetMoveItems<K> {\n+    fn next(&mut self) -> Option<K> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n+impl<'a, T, H> Iterator<&'a T> for SetAlgebraItems<'a, T, H> {\n+    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n+impl<'a, T, H> Iterator<&'a T> for SymDifferenceItems<'a, T, H> {\n+    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n+impl<'a, T, H> Iterator<&'a T> for UnionItems<'a, T, H> {\n+    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n \n #[cfg(test)]\n mod test_set {"}, {"sha": "da06387e9a5eb7b940de5ce7b4759e778d362bec", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -124,7 +124,7 @@ struct GapThenFull<K, V, M> {\n \n /// A hash that is not zero, since we use a hash of zero to represent empty\n /// buckets.\n-#[deriving(PartialEq)]\n+#[deriving(PartialEq, Copy)]\n pub struct SafeHash {\n     hash: u64,\n }\n@@ -211,7 +211,7 @@ impl<K, V, M> Bucket<K, V, M> {\n }\n \n impl<K, V, M: Deref<RawTable<K, V>>> Bucket<K, V, M> {\n-    pub fn new(table: M, hash: &SafeHash) -> Bucket<K, V, M> {\n+    pub fn new(table: M, hash: SafeHash) -> Bucket<K, V, M> {\n         Bucket::at_index(table, hash.inspect() as uint)\n     }\n "}, {"sha": "72ddbe19f54b210b3b07dc20a207cc94fb9aeb3c", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -81,7 +81,7 @@\n //! Shared usage:\n //!\n //! ```\n-//! // Create a shared channel which can be sent along from many tasks\n+//! // Create a shared channel that can be sent along from many tasks\n //! // where tx is the sending half (tx for transmission), and rx is the receiving\n //! // half (rx for receiving).\n //! let (tx, rx) = channel();\n@@ -176,7 +176,7 @@\n // The choice of implementation of all channels is to be built on lock-free data\n // structures. The channels themselves are then consequently also lock-free data\n // structures. As always with lock-free code, this is a very \"here be dragons\"\n-// territory, especially because I'm unaware of any academic papers which have\n+// territory, especially because I'm unaware of any academic papers that have\n // gone into great length about channels of these flavors.\n //\n // ## Flavors of channels\n@@ -190,7 +190,7 @@\n //              They contain as few atomics as possible and involve one and\n //              exactly one allocation.\n // * Streams - these channels are optimized for the non-shared use case. They\n-//             use a different concurrent queue which is more tailored for this\n+//             use a different concurrent queue that is more tailored for this\n //             use case. The initial allocation of this flavor of channel is not\n //             optimized.\n // * Shared - this is the most general form of channel that this module offers,\n@@ -205,7 +205,7 @@\n // shared and concurrent queue holding all of the actual data.\n //\n // With two flavors of channels, two flavors of queues are also used. We have\n-// chosen to use queues from a well-known author which are abbreviated as SPSC\n+// chosen to use queues from a well-known author that are abbreviated as SPSC\n // and MPSC (single producer, single consumer and multiple producer, single\n // consumer). SPSC queues are used for streams while MPSC queues are used for\n // shared channels.\n@@ -309,7 +309,7 @@\n //\n // Sadly this current implementation requires multiple allocations, so I have\n // seen the throughput of select() be much worse than it should be. I do not\n-// believe that there is anything fundamental which needs to change about these\n+// believe that there is anything fundamental that needs to change about these\n // channels, however, in order to support a more efficient select().\n //\n // # Conclusion\n@@ -910,7 +910,7 @@ impl<T: Send> Receiver<T> {\n         }\n     }\n \n-    /// Returns an iterator which will block waiting for messages, but never\n+    /// Returns an iterator that will block waiting for messages, but never\n     /// `panic!`. It will return `None` when the channel has hung up.\n     #[unstable]\n     pub fn iter<'a>(&'a self) -> Messages<'a, T> {"}, {"sha": "52e3c718b2d56d4222d21db92714161fbb71a597", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -95,7 +95,9 @@ impl Hasher<sip::SipState> for RandomSipHasher {\n     }\n }\n \n+#[stable]\n impl Default for RandomSipHasher {\n+    #[stable]\n     #[inline]\n     fn default() -> RandomSipHasher {\n         RandomSipHasher::new()"}, {"sha": "f8df7e9b1f3b266dbedde79fbe1dcf2c7b43c7e0", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -200,7 +200,7 @@ impl File {\n              .update_desc(\"couldn't create file\")\n     }\n \n-    /// Returns the original path which was used to open this file.\n+    /// Returns the original path that was used to open this file.\n     pub fn path<'a>(&'a self) -> &'a Path {\n         &self.path\n     }\n@@ -215,7 +215,7 @@ impl File {\n     }\n \n     /// This function is similar to `fsync`, except that it may not synchronize\n-    /// file metadata to the filesystem. This is intended for use case which\n+    /// file metadata to the filesystem. This is intended for use cases that\n     /// must synchronize content, but don't need the metadata on disk. The goal\n     /// of this method is to reduce disk operations.\n     pub fn datasync(&mut self) -> IoResult<()> {\n@@ -456,7 +456,7 @@ pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n /// # Error\n ///\n /// This function will return an error on failure. Failure conditions include\n-/// reading a file that does not exist or reading a file which is not a symlink.\n+/// reading a file that does not exist or reading a file that is not a symlink.\n pub fn readlink(path: &Path) -> IoResult<Path> {\n     fs_imp::readlink(path)\n            .update_err(\"couldn't resolve symlink for path\", |e|\n@@ -546,7 +546,7 @@ pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n                        |e| format!(\"{}; path={}\", e, path.display()))\n }\n \n-/// Returns an iterator which will recursively walk the directory structure\n+/// Returns an iterator that will recursively walk the directory structure\n /// rooted at `path`. The path given will not be iterated over, and this will\n /// perform iteration in some top-down order.  The contents of unreadable\n /// subdirectories are ignored.\n@@ -557,7 +557,7 @@ pub fn walk_dir(path: &Path) -> IoResult<Directories> {\n     })\n }\n \n-/// An iterator which walks over a directory\n+/// An iterator that walks over a directory\n pub struct Directories {\n     stack: Vec<Path>,\n }"}, {"sha": "6a6d467e86c048afb4c05659a6db89ac20027ab4", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -1911,7 +1911,9 @@ bitflags! {\n }\n \n \n+#[stable]\n impl Default for FilePermission {\n+    #[stable]\n     #[inline]\n     fn default() -> FilePermission { FilePermission::empty() }\n }"}, {"sha": "ce7e5ca5f5e9291ba4dcd6de3fe1b0eab2a63d34", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -557,11 +557,12 @@ mod test {\n         let addr1 = next_test_ip4();\n         let addr2 = next_test_ip4();\n         let mut a = UdpSocket::bind(addr1).unwrap();\n+        let a2 = UdpSocket::bind(addr2).unwrap();\n \n         let (tx, rx) = channel();\n         let (tx2, rx2) = channel();\n         spawn(move|| {\n-            let mut a = UdpSocket::bind(addr2).unwrap();\n+            let mut a = a2;\n             assert_eq!(a.recv_from(&mut [0]), Ok((1, addr1)));\n             assert_eq!(a.send_to(&[0], addr1), Ok(()));\n             rx.recv();"}, {"sha": "844814fbfddf194b6b58f0781a358947197a16b3", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -41,6 +41,7 @@ use option::Option;\n use option::Option::{Some, None};\n use ops::{Deref, DerefMut, FnOnce};\n use result::Result::{Ok, Err};\n+use rt;\n use rustrt;\n use rustrt::local::Local;\n use rustrt::task::Task;\n@@ -224,6 +225,12 @@ pub fn stdin() -> StdinReader {\n                 inner: Arc::new(Mutex::new(stdin))\n             };\n             STDIN = mem::transmute(box stdin);\n+\n+            // Make sure to free it at exit\n+            rt::at_exit(|| {\n+                mem::transmute::<_, Box<StdinReader>>(STDIN);\n+                STDIN = 0 as *const _;\n+            });\n         });\n \n         (*STDIN).clone()"}, {"sha": "6bccef07131518fc9ade18aa1186f0f164c59192", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -117,7 +117,8 @@ mod imp {\n     ///   `/dev/urandom`, or from `getrandom(2)` system call if available.\n     /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n     ///   service provider with the `PROV_RSA_FULL` type.\n-    /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed\n+    /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed.\n+    ///\n     /// This does not block.\n     pub struct OsRng {\n         inner: OsRngInner,\n@@ -184,10 +185,13 @@ mod imp {\n     ///   `/dev/urandom`, or from `getrandom(2)` system call if available.\n     /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n     ///   service provider with the `PROV_RSA_FULL` type.\n-    /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed\n+    /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed.\n+    ///\n     /// This does not block.\n+    #[allow(missing_copy_implementations)]\n     pub struct OsRng {\n-        marker: marker::NoCopy\n+        // dummy field to ensure that this struct cannot be constructed outside of this module\n+        _dummy: (),\n     }\n \n     #[repr(C)]\n@@ -205,7 +209,7 @@ mod imp {\n     impl OsRng {\n         /// Create a new `OsRng`.\n         pub fn new() -> IoResult<OsRng> {\n-            Ok(OsRng {marker: marker::NoCopy} )\n+            Ok(OsRng { _dummy: () })\n         }\n     }\n \n@@ -254,7 +258,8 @@ mod imp {\n     ///   `/dev/urandom`, or from `getrandom(2)` system call if available.\n     /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n     ///   service provider with the `PROV_RSA_FULL` type.\n-    /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed\n+    /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed.\n+    ///\n     /// This does not block.\n     pub struct OsRng {\n         hcryptprov: HCRYPTPROV"}, {"sha": "cf56a71d67acdbb7f83ba024814b00fe68bb00f4", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -58,7 +58,6 @@\n \n use prelude::*;\n \n-use kinds::marker;\n use rustrt::exclusive::Exclusive;\n use sync::atomic::{mod, AtomicUint};\n use sync::{Once, ONCE_INIT};\n@@ -100,7 +99,6 @@ pub struct StaticKey {\n /// Inner contents of `StaticKey`, created by the `INIT_INNER` constant.\n pub struct StaticKeyInner {\n     key: AtomicUint,\n-    nc: marker::NoCopy,\n }\n \n /// A type for a safely managed OS-based TLS slot.\n@@ -141,7 +139,6 @@ pub const INIT: StaticKey = StaticKey {\n /// This value allows specific configuration of the destructor for a TLS key.\n pub const INIT_INNER: StaticKeyInner = StaticKeyInner {\n     key: atomic::INIT_ATOMIC_UINT,\n-    nc: marker::NoCopy,\n };\n \n static INIT_KEYS: Once = ONCE_INIT;"}, {"sha": "324b594209a1e17afe87f1edd4787a9dc1c9d947", "filename": "src/libstd/task.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -49,7 +49,7 @@ use boxed::Box;\n use comm::channel;\n use core::ops::FnOnce;\n use io::{Writer, stdio};\n-use kinds::{Send, marker};\n+use kinds::Send;\n use option::Option;\n use option::Option::{None, Some};\n use result::Result;\n@@ -83,7 +83,6 @@ pub struct TaskBuilder {\n     stderr: Option<Box<Writer + Send>>,\n     // Optionally wrap the eventual task body\n     gen_body: Option<Thunk<Thunk, Thunk>>,\n-    nocopy: marker::NoCopy,\n }\n \n impl TaskBuilder {\n@@ -96,7 +95,6 @@ impl TaskBuilder {\n             stdout: None,\n             stderr: None,\n             gen_body: None,\n-            nocopy: marker::NoCopy,\n         }\n     }\n }\n@@ -137,7 +135,7 @@ impl TaskBuilder {\n         on_exit: Option<Thunk<task::Result>>)\n     {\n         let TaskBuilder {\n-            name, stack_size, stdout, stderr, mut gen_body, nocopy: _\n+            name, stack_size, stdout, stderr, mut gen_body\n         } = self;\n \n         let f = match gen_body.take() {"}, {"sha": "76fb703514b52106a7ae7f7af20bc5caabe38d7b", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -185,7 +185,6 @@ macro_rules! __thread_local_inner(\n                 inner: ::std::cell::UnsafeCell { value: $init },\n                 dtor_registered: ::std::cell::UnsafeCell { value: false },\n                 dtor_running: ::std::cell::UnsafeCell { value: false },\n-                marker: ::std::kinds::marker::NoCopy,\n             }\n         };\n \n@@ -247,7 +246,6 @@ mod imp {\n \n     use cell::UnsafeCell;\n     use intrinsics;\n-    use kinds::marker;\n     use ptr;\n \n     #[doc(hidden)]\n@@ -264,9 +262,6 @@ mod imp {\n         // these variables are thread-local, not global.\n         pub dtor_registered: UnsafeCell<bool>, // should be Cell\n         pub dtor_running: UnsafeCell<bool>, // should be Cell\n-\n-        // These shouldn't be copied around.\n-        pub marker: marker::NoCopy,\n     }\n \n     #[doc(hidden)]"}, {"sha": "98d858babb171417dbd5f7374aea069145129185", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -696,7 +696,7 @@ pub struct Expr {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Expr_ {\n     /// First expr is the place; second expr is the value.\n-    ExprBox(P<Expr>, P<Expr>),\n+    ExprBox(Option<P<Expr>>, P<Expr>),\n     ExprVec(Vec<P<Expr>>),\n     ExprCall(P<Expr>, Vec<P<Expr>>),\n     ExprMethodCall(SpannedIdent, Vec<P<Ty>>, Vec<P<Expr>>),"}, {"sha": "b31758e2d2a127cd5d81117fc6fa3f677ea0aabd", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -388,7 +388,7 @@ impl<'a> TraitDef<'a> {\n                            methods: Vec<P<ast::Method>>) -> P<ast::Item> {\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n-        let Generics { mut lifetimes, ty_params, where_clause: _ } =\n+        let Generics { mut lifetimes, ty_params, mut where_clause } =\n             self.generics.to_generics(cx, self.span, type_ident, generics);\n         let mut ty_params = ty_params.into_vec();\n \n@@ -420,13 +420,33 @@ impl<'a> TraitDef<'a> {\n                        ty_param.unbound.clone(),\n                        None)\n         }));\n+\n+        // and similarly for where clauses\n+        where_clause.predicates.extend(generics.where_clause.predicates.iter().map(|clause| {\n+            match *clause {\n+                ast::WherePredicate::BoundPredicate(ref wb) => {\n+                    ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: self.span,\n+                        ident: wb.ident,\n+                        bounds: OwnedSlice::from_vec(wb.bounds.iter().map(|b| b.clone()).collect())\n+                    })\n+                }\n+                ast::WherePredicate::EqPredicate(ref we) => {\n+                    ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: self.span,\n+                        path: we.path.clone(),\n+                        ty: we.ty.clone()\n+                    })\n+                }\n+            }\n+        }));\n+\n         let trait_generics = Generics {\n             lifetimes: lifetimes,\n             ty_params: OwnedSlice::from_vec(ty_params),\n-            where_clause: ast::WhereClause {\n-                id: ast::DUMMY_NODE_ID,\n-                predicates: Vec::new(),\n-            },\n+            where_clause: where_clause\n         };\n \n         // Create the reference to the trait."}, {"sha": "839e99c81d1ab08a965bc81bdf74104401e2bdef", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -70,8 +70,28 @@ pub fn expand_meta_deriving(cx: &mut ExtCtxt,\n \n                             \"Hash\" => expand!(hash::expand_deriving_hash),\n \n-                            \"Encodable\" => expand!(encodable::expand_deriving_encodable),\n-                            \"Decodable\" => expand!(decodable::expand_deriving_decodable),\n+                            \"RustcEncodable\" => {\n+                                expand!(encodable::expand_deriving_encodable)\n+                            }\n+                            \"RustcDecodable\" => {\n+                                expand!(decodable::expand_deriving_decodable)\n+                            }\n+                            \"Encodable\" => {\n+                                // NOTE: uncomment after a stage0 snap\n+                                // cx.span_warn(titem.span,\n+                                //              \"deriving(Encodable) is deprecated \\\n+                                //               in favor of deriving(RustcEncodable)\");\n+\n+                                expand!(encodable::expand_deriving_encodable)\n+                            }\n+                            \"Decodable\" => {\n+                                // NOTE: uncomment after a stage0 snap\n+                                // cx.span_warn(titem.span,\n+                                //              \"deriving(Decodable) is deprecated \\\n+                                //               in favor of deriving(RustcDecodable)\");\n+\n+                                expand!(decodable::expand_deriving_decodable)\n+                            }\n \n                             \"PartialEq\" => expand!(eq::expand_deriving_eq),\n                             \"Eq\" => expand!(totaleq::expand_deriving_totaleq),"}, {"sha": "7d2acd08d9430f6dc2204d9f1c86ff459f9db5ee", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -1282,7 +1282,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n         id: folder.new_id(id),\n         node: match node {\n             ExprBox(p, e) => {\n-                ExprBox(folder.fold_expr(p), folder.fold_expr(e))\n+                ExprBox(p.map(|e|folder.fold_expr(e)), folder.fold_expr(e))\n             }\n             ExprVec(exprs) => {\n                 ExprVec(exprs.move_map(|x| folder.fold_expr(x)))"}, {"sha": "6e3cfe5854a4020f4d52b26ca223f335046c7da7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -2888,14 +2888,17 @@ impl<'a> Parser<'a> {\n                     }\n                     let subexpression = self.parse_prefix_expr();\n                     hi = subexpression.span.hi;\n-                    ex = ExprBox(place, subexpression);\n+                    ex = ExprBox(Some(place), subexpression);\n                     return self.mk_expr(lo, hi, ex);\n                 }\n             }\n \n             // Otherwise, we use the unique pointer default.\n             let subexpression = self.parse_prefix_expr();\n             hi = subexpression.span.hi;\n+            // FIXME (pnkfelix): After working out kinks with box\n+            // desugaring, should be `ExprBox(None, subexpression)`\n+            // instead.\n             ex = self.mk_unary(UnUniq, subexpression);\n           }\n           _ => return self.parse_dot_or_call_expr()"}, {"sha": "cbbfcfef72ea62785a6f7a1a18d9f834f7e9c43c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -1005,8 +1005,13 @@ impl<'a> State<'a> {\n     fn print_poly_trait_ref(&mut self, t: &ast::PolyTraitRef) -> IoResult<()> {\n         if !t.bound_lifetimes.is_empty() {\n             try!(word(&mut self.s, \"for<\"));\n+            let mut comma = false;\n             for lifetime_def in t.bound_lifetimes.iter() {\n+                if comma {\n+                    try!(self.word_space(\",\"))\n+                }\n                 try!(self.print_lifetime_def(lifetime_def));\n+                comma = true;\n             }\n             try!(word(&mut self.s, \">\"));\n         }\n@@ -1057,6 +1062,7 @@ impl<'a> State<'a> {\n                         span: codemap::Span) -> IoResult<()> {\n         try!(self.print_ident(ident));\n         try!(self.print_generics(generics));\n+        try!(self.print_where_clause(generics));\n         if ast_util::struct_def_is_tuple_like(struct_def) {\n             if !struct_def.fields.is_empty() {\n                 try!(self.popen());\n@@ -1495,7 +1501,7 @@ impl<'a> State<'a> {\n             ast::ExprBox(ref p, ref e) => {\n                 try!(word(&mut self.s, \"box\"));\n                 try!(word(&mut self.s, \"(\"));\n-                try!(self.print_expr(&**p));\n+                try!(p.as_ref().map_or(Ok(()), |e|self.print_expr(&**e)));\n                 try!(self.word_space(\")\"));\n                 try!(self.print_expr(&**e));\n             }"}, {"sha": "95d7906b443544669577805f2cb183b3e36d3e9b", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -555,14 +555,18 @@ pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n     }\n }\n \n+pub fn walk_ty_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v TyParam) {\n+    visitor.visit_ident(param.span, param.ident);\n+    walk_ty_param_bounds_helper(visitor, &param.bounds);\n+    match param.default {\n+        Some(ref ty) => visitor.visit_ty(&**ty),\n+        None => {}\n+    }\n+}\n+\n pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n     for type_parameter in generics.ty_params.iter() {\n-        visitor.visit_ident(type_parameter.span, type_parameter.ident);\n-        walk_ty_param_bounds_helper(visitor, &type_parameter.bounds);\n-        match type_parameter.default {\n-            Some(ref ty) => visitor.visit_ty(&**ty),\n-            None => {}\n-        }\n+        walk_ty_param(visitor, type_parameter);\n     }\n     walk_lifetime_decls_helper(visitor, &generics.lifetimes);\n     for predicate in generics.where_clause.predicates.iter() {\n@@ -665,8 +669,7 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_method: &'v Tr\n         RequiredMethod(ref method_type) => visitor.visit_ty_method(method_type),\n         ProvidedMethod(ref method) => walk_method_helper(visitor, &**method),\n         TypeTraitItem(ref associated_type) => {\n-            visitor.visit_ident(associated_type.ty_param.span,\n-                                associated_type.ty_param.ident)\n+            walk_ty_param(visitor, &associated_type.ty_param);\n         }\n     }\n }\n@@ -739,7 +742,7 @@ pub fn walk_mac<'v, V: Visitor<'v>>(_: &mut V, _: &'v Mac) {\n pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n     match expression.node {\n         ExprBox(ref place, ref subexpression) => {\n-            visitor.visit_expr(&**place);\n+            place.as_ref().map(|e|visitor.visit_expr(&**e));\n             visitor.visit_expr(&**subexpression)\n         }\n         ExprVec(ref subexpressions) => {"}, {"sha": "aed73472416064642911af790b25d57c9390b6c7", "filename": "src/rust-installer", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frust-installer?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -0,0 +1 @@\n+Subproject commit aed73472416064642911af790b25d57c9390b6c7"}, {"sha": "fc7664c480fdbf7969a1ab89e63f6f3b2f435d9c", "filename": "src/test/compile-fail-fulldeps/macro-crate-cannot-read-embedded-ident.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-cannot-read-embedded-ident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-cannot-read-embedded-ident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-cannot-read-embedded-ident.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -11,7 +11,7 @@\n // aux-build:macro_crate_test.rs\n // ignore-stage1\n // ignore-android\n-// error-pattern: unknown start of token: \\x00\n+// error-pattern: unknown start of token: \\u{0}\n \n // Issue #15750 and #15962 : this test is checking that the standard\n // parser rejects embedded idents.  pnkfelix did not want to attempt"}, {"sha": "3eeb4c177cad60db4639b9034cea6c3c531f5cab", "filename": "src/test/compile-fail/fn-trait-formatting.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+fn needs_fn<F>(x: F) where F: Fn(int) -> int {}\n+\n+fn main() {\n+    let _: () = (box |:_: int| {}) as Box<FnOnce(int)>; //~ ERROR object-safe\n+    //~^ ERROR Box<core::ops::FnOnce(int)>\n+    let _: () = (box |&:_: int, int| {}) as Box<Fn(int, int)>;\n+    //~^ ERROR Box<core::ops::Fn(int, int)>\n+    let _: () = (box |&mut:| -> int unimplemented!()) as Box<FnMut() -> int>;\n+    //~^ ERROR Box<core::ops::FnMut() -> int>\n+\n+    needs_fn(1i); //~ ERROR `core::ops::Fn(int) -> int`\n+}"}, {"sha": "d9b20748a7a29c32ed7ef79e1490bd398e50025c", "filename": "src/test/compile-fail/ptr-coercion.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Fcompile-fail%2Fptr-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Fcompile-fail%2Fptr-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fptr-coercion.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test coercions between pointers which don't do anything fancy like unsizing.\n+// These are testing that we don't lose mutability when converting to raw pointers.\n+\n+pub fn main() {\n+    // *const -> *mut\n+    let x: *const int = &42i;\n+    let x: *mut int = x; //~ERROR values differ in mutability\n+\n+    // & -> *mut\n+    let x: *mut int = &42; //~ERROR values differ in mutability\n+\n+    let x: *const int = &42;\n+    let x: *mut int = x; //~ERROR values differ in mutability\n+}"}, {"sha": "182c632d062613977fbf2e9dd0394e90a9cc417f", "filename": "src/test/compile-fail/unboxed-closer-non-implicit-copyable.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Fcompile-fail%2Funboxed-closer-non-implicit-copyable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Fcompile-fail%2Funboxed-closer-non-implicit-copyable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closer-non-implicit-copyable.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+fn main() {\n+    let f = move|:| ();\n+    f();\n+    f(); //~ ERROR use of moved value\n+}"}, {"sha": "21160553f79ccffc63cb5e0c317185c133781835", "filename": "src/test/run-pass-valgrind/cleanup-stdin.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Frun-pass-valgrind%2Fcleanup-stdin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Frun-pass-valgrind%2Fcleanup-stdin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fcleanup-stdin.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let _ = std::io::stdin();\n+}"}, {"sha": "1be09e1e0680d114330eff766b4ce4af3c616a14", "filename": "src/test/run-pass/associated-types-resolve-lifetime.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Frun-pass%2Fassociated-types-resolve-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Frun-pass%2Fassociated-types-resolve-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-resolve-lifetime.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait Get<T> {\n+    fn get(&self) -> T;\n+}\n+\n+trait Trait<'a> {\n+    type T: 'static;\n+    type U: Get<&'a int>;\n+}\n+\n+fn main() {}"}, {"sha": "ef68daa8ce592a594d30e4b0b1fc1f5287b98024", "filename": "src/test/run-pass/issue-12677.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Frun-pass%2Fissue-12677.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Frun-pass%2Fissue-12677.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12677.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let s = \"Hello\";\n+    let first = s.bytes();\n+    let second = first.clone();\n+\n+    assert_eq!(first.collect::<Vec<u8>>(), second.collect::<Vec<u8>>())\n+}"}, {"sha": "eecc073b0478232c859533166238ebd71c3749f3", "filename": "src/test/run-pass/issue-19129-1.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Frun-pass%2Fissue-19129-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Frun-pass%2Fissue-19129-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19129-1.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait Trait<Input> {\n+    type Output;\n+\n+    fn method() -> <Self as Trait<Input>>::Output;\n+}\n+\n+impl<T> Trait<T> for () {\n+    type Output = ();\n+\n+    fn method() {}\n+}\n+\n+fn main() {}"}, {"sha": "aeaf5e3764459466139e5fc488a35f04bcb1cd5b", "filename": "src/test/run-pass/issue-19129-2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Frun-pass%2Fissue-19129-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Frun-pass%2Fissue-19129-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19129-2.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait Trait<Input> {\n+    type Output;\n+\n+    fn method() -> bool { false }\n+}\n+\n+fn main() {}"}, {"sha": "e4c190f41169edfc51e607bb35d2dc803668d9d0", "filename": "src/test/run-pass/issue-19358.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Frun-pass%2Fissue-19358.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Frun-pass%2Fissue-19358.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19358.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Trait {}\n+\n+#[deriving(Show)]\n+struct Foo<T: Trait> {\n+    foo: T,\n+}\n+\n+#[deriving(Show)]\n+struct Bar<T> where T: Trait {\n+    bar: T,\n+}\n+\n+impl Trait for int {}\n+\n+fn main() {\n+    let a = Foo { foo: 12i };\n+    let b = Bar { bar: 12i };\n+    println!(\"{} {}\", a, b);\n+}"}, {"sha": "1b77c1316ed282d54481e5a74b1a7d2179bfcc8e", "filename": "src/test/run-pass/ptr-coercion.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Frun-pass%2Fptr-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Frun-pass%2Fptr-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fptr-coercion.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test coercions between pointers which don't do anything fancy like unsizing.\n+\n+pub fn main() {\n+    // &mut -> &\n+    let x: &mut int = &mut 42i;\n+    let x: &int = x;\n+\n+    let x: &int = &mut 42i;\n+\n+    // & -> *const\n+    let x: &int = &42i;\n+    let x: *const int = x;\n+\n+    let x: *const int = &42i;\n+\n+    // &mut -> *const\n+    let x: &mut int = &mut 42i;\n+    let x: *const int = x;\n+\n+    let x: *const int = &mut 42i;\n+\n+    // *mut -> *const\n+    let x: *mut int = &mut 42i;\n+    let x: *const int = x;\n+}"}, {"sha": "efda7771403a393066a13bc24b6d609198d6dad2", "filename": "src/test/run-pass/type-id-higher-rank.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Frun-pass%2Ftype-id-higher-rank.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a9f250b5e2de64c13c0f056aec13eb086ef79d/src%2Ftest%2Frun-pass%2Ftype-id-higher-rank.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-id-higher-rank.rs?ref=22a9f250b5e2de64c13c0f056aec13eb086ef79d", "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that type IDs correctly account for higher-rank lifetimes\n+// Also acts as a regression test for an ICE (issue #19791)\n+\n+#![feature(unboxed_closures)]\n+\n+use std::intrinsics::TypeId;\n+\n+fn main() {\n+    // Bare fns\n+    {\n+        let a = TypeId::of::<fn(&'static int, &'static int)>();\n+        let b = TypeId::of::<for<'a> fn(&'static int, &'a int)>();\n+        let c = TypeId::of::<for<'a, 'b> fn(&'a int, &'b int)>();\n+        let d = TypeId::of::<for<'a, 'b> fn(&'b int, &'a int)>();\n+        assert!(a != b);\n+        assert!(a != c);\n+        assert!(a != d);\n+        assert!(b != c);\n+        assert!(b != d);\n+        assert_eq!(c, d);\n+\n+        // Make sure De Bruijn indices are handled correctly\n+        let e = TypeId::of::<for<'a> fn(fn(&'a int) -> &'a int)>();\n+        let f = TypeId::of::<fn(for<'a> fn(&'a int) -> &'a int)>();\n+        assert!(e != f);\n+    }\n+    // Stack closures\n+    {\n+        let a = TypeId::of::<|&'static int, &'static int|>();\n+        let b = TypeId::of::<for<'a> |&'static int, &'a int|>();\n+        let c = TypeId::of::<for<'a, 'b> |&'a int, &'b int|>();\n+        let d = TypeId::of::<for<'a, 'b> |&'b int, &'a int|>();\n+        assert!(a != b);\n+        assert!(a != c);\n+        assert!(a != d);\n+        assert!(b != c);\n+        assert!(b != d);\n+        assert_eq!(c, d);\n+\n+        // Make sure De Bruijn indices are handled correctly\n+        let e = TypeId::of::<for<'a> |(|&'a int| -> &'a int)|>();\n+        let f = TypeId::of::<|for<'a> |&'a int| -> &'a int|>();\n+        assert!(e != f);\n+    }\n+    // Boxed unboxed closures\n+    {\n+        let a = TypeId::of::<Box<Fn(&'static int, &'static int)>>();\n+        let b = TypeId::of::<Box<for<'a> Fn(&'static int, &'a int)>>();\n+        let c = TypeId::of::<Box<for<'a, 'b> Fn(&'a int, &'b int)>>();\n+        let d = TypeId::of::<Box<for<'a, 'b> Fn(&'b int, &'a int)>>();\n+        assert!(a != b);\n+        assert!(a != c);\n+        assert!(a != d);\n+        assert!(b != c);\n+        assert!(b != d);\n+        assert_eq!(c, d);\n+\n+        // Make sure De Bruijn indices are handled correctly\n+        let e = TypeId::of::<Box<for<'a> Fn(Box<Fn(&'a int) -> &'a int>)>>();\n+        let f = TypeId::of::<Box<Fn(Box<for<'a> Fn(&'a int) -> &'a int>)>>();\n+        assert!(e != f);\n+    }\n+    // Raw unboxed closures\n+    // Note that every unboxed closure has its own anonymous type,\n+    // so no two IDs should equal each other, even when compatible\n+    {\n+        let a = id(|&: _: &int, _: &int| {});\n+        let b = id(|&: _: &int, _: &int| {});\n+        assert!(a != b);\n+    }\n+\n+    fn id<T:'static>(_: T) -> TypeId {\n+        TypeId::of::<T>()\n+    }\n+}"}]}