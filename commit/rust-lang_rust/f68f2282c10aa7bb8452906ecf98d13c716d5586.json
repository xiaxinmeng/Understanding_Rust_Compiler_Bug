{"sha": "f68f2282c10aa7bb8452906ecf98d13c716d5586", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2OGYyMjgyYzEwYWE3YmI4NDUyOTA2ZWNmOThkMTNjNzE2ZDU1ODY=", "commit": {"author": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2013-03-21T08:10:57Z"}, "committer": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2013-03-21T08:10:57Z"}, "message": "Switch Module.import_resolutions from oldmap", "tree": {"sha": "0de05d4891504551ebe068869dbe2293f209fa00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0de05d4891504551ebe068869dbe2293f209fa00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f68f2282c10aa7bb8452906ecf98d13c716d5586", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f68f2282c10aa7bb8452906ecf98d13c716d5586", "html_url": "https://github.com/rust-lang/rust/commit/f68f2282c10aa7bb8452906ecf98d13c716d5586", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f68f2282c10aa7bb8452906ecf98d13c716d5586/comments", "author": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e84323e9b8a1175bf8b6e22754e24a54a77f9e71", "url": "https://api.github.com/repos/rust-lang/rust/commits/e84323e9b8a1175bf8b6e22754e24a54a77f9e71", "html_url": "https://github.com/rust-lang/rust/commit/e84323e9b8a1175bf8b6e22754e24a54a77f9e71"}], "stats": {"total": 26, "additions": 13, "deletions": 13}, "files": [{"sha": "84ebfa3eecc4cfe5b0dbbd42deb4f9dd616158ef", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f68f2282c10aa7bb8452906ecf98d13c716d5586/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f68f2282c10aa7bb8452906ecf98d13c716d5586/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=f68f2282c10aa7bb8452906ecf98d13c716d5586", "patch": "@@ -478,7 +478,7 @@ pub struct Module {\n     anonymous_children: @HashMap<node_id,@mut Module>,\n \n     // The status of resolving each import in this module.\n-    import_resolutions: @HashMap<ident,@mut ImportResolution>,\n+    import_resolutions: @mut LinearMap<ident, @mut ImportResolution>,\n \n     // The number of unresolved globs that this module exports.\n     glob_count: uint,\n@@ -498,7 +498,7 @@ pub fn Module(parent_link: ParentLink,\n         children: @mut LinearMap::new(),\n         imports: @mut ~[],\n         anonymous_children: @HashMap(),\n-        import_resolutions: @HashMap(),\n+        import_resolutions: @mut LinearMap::new(),\n         glob_count: 0,\n         resolved_import_count: 0\n     }\n@@ -2242,11 +2242,11 @@ pub impl Resolver {\n                         // The name is an import which has been fully\n                         // resolved. We can, therefore, just follow it.\n                         if value_result.is_unknown() {\n-                            value_result = get_binding(import_resolution,\n+                            value_result = get_binding(*import_resolution,\n                                                        ValueNS);\n                         }\n                         if type_result.is_unknown() {\n-                            type_result = get_binding(import_resolution,\n+                            type_result = get_binding(*import_resolution,\n                                                       TypeNS);\n                         }\n                     }\n@@ -2484,15 +2484,15 @@ pub impl Resolver {\n \n         // Add all resolved imports from the containing module.\n         for containing_module.import_resolutions.each\n-                |&ident, &target_import_resolution| {\n+                |&(ident, target_import_resolution)| {\n \n             debug!(\"(resolving glob import) writing module resolution \\\n                     %? into `%s`\",\n                    is_none(&mut target_import_resolution.type_target),\n                    self.module_to_str(module_));\n \n             // Here we merge two import resolutions.\n-            match module_.import_resolutions.find(&ident) {\n+            match module_.import_resolutions.find(ident) {\n                 None if target_import_resolution.privacy == Public => {\n                     // Simple: just copy the old import resolution.\n                     let new_import_resolution =\n@@ -2505,7 +2505,7 @@ pub impl Resolver {\n                         copy target_import_resolution.type_target;\n \n                     module_.import_resolutions.insert\n-                        (ident, new_import_resolution);\n+                        (*ident, new_import_resolution);\n                 }\n                 None => { /* continue ... */ }\n                 Some(dest_import_resolution) => {\n@@ -2547,7 +2547,7 @@ pub impl Resolver {\n                         (*ident, dest_import_resolution);\n                 }\n                 Some(existing_import_resolution) => {\n-                    dest_import_resolution = existing_import_resolution;\n+                    dest_import_resolution = *existing_import_resolution;\n                 }\n             }\n \n@@ -3205,7 +3205,7 @@ pub impl Resolver {\n                                              false);\n         }\n \n-        for module_.import_resolutions.each |ident, importresolution| {\n+        for module_.import_resolutions.each |&(ident, importresolution)| {\n             if importresolution.privacy != Public {\n                 debug!(\"(computing exports) not reexporting private `%s`\",\n                        *self.session.str_of(*ident));\n@@ -5308,9 +5308,9 @@ pub impl Resolver {\n         }\n \n         debug!(\"Import resolutions:\");\n-        for module_.import_resolutions.each |&name, &import_resolution| {\n+        for module_.import_resolutions.each |&(name, import_resolution)| {\n             let mut value_repr;\n-            match (*import_resolution).target_for_namespace(ValueNS) {\n+            match import_resolution.target_for_namespace(ValueNS) {\n                 None => { value_repr = ~\"\"; }\n                 Some(_) => {\n                     value_repr = ~\" value:?\";\n@@ -5319,15 +5319,15 @@ pub impl Resolver {\n             }\n \n             let mut type_repr;\n-            match (*import_resolution).target_for_namespace(TypeNS) {\n+            match import_resolution.target_for_namespace(TypeNS) {\n                 None => { type_repr = ~\"\"; }\n                 Some(_) => {\n                     type_repr = ~\" type:?\";\n                     // FIXME #4954\n                 }\n             }\n \n-            debug!(\"* %s:%s%s\", *self.session.str_of(name),\n+            debug!(\"* %s:%s%s\", *self.session.str_of(*name),\n                    value_repr, type_repr);\n         }\n     }"}]}