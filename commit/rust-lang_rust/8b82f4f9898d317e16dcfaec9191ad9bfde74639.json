{"sha": "8b82f4f9898d317e16dcfaec9191ad9bfde74639", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiODJmNGY5ODk4ZDMxN2UxNmRjZmFlYzkxOTFhZDliZmRlNzQ2Mzk=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-26T12:37:10Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-31T14:56:28Z"}, "message": "[WIP] Add stack2reg optimization pass", "tree": {"sha": "9ea7c5d8db340771a3a3ee0e757858a647713809", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ea7c5d8db340771a3a3ee0e757858a647713809"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b82f4f9898d317e16dcfaec9191ad9bfde74639", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b82f4f9898d317e16dcfaec9191ad9bfde74639", "html_url": "https://github.com/rust-lang/rust/commit/8b82f4f9898d317e16dcfaec9191ad9bfde74639", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b82f4f9898d317e16dcfaec9191ad9bfde74639/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7564a043d0349df2d92bc4962f1c824c4cee09d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7564a043d0349df2d92bc4962f1c824c4cee09d0", "html_url": "https://github.com/rust-lang/rust/commit/7564a043d0349df2d92bc4962f1c824c4cee09d0"}], "stats": {"total": 278, "additions": 256, "deletions": 22}, "files": [{"sha": "f649c945c059078dc56a99ca5ca0dc571d694512", "filename": "example/mini_core.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b82f4f9898d317e16dcfaec9191ad9bfde74639/example%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b82f4f9898d317e16dcfaec9191ad9bfde74639/example%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core.rs?ref=8b82f4f9898d317e16dcfaec9191ad9bfde74639", "patch": "@@ -394,6 +394,10 @@ pub trait FnMut<Args>: FnOnce<Args> {\n \n #[lang = \"panic\"]\n pub fn panic(&(_msg, _file, _line, _col): &(&'static str, &'static str, u32, u32)) -> ! {\n+    panic_inner(&_msg);\n+}\n+\n+pub fn panic_inner(_msg: &&str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         intrinsics::abort();"}, {"sha": "a59231141095baa4c60455c3f0dd16084276316b", "filename": "src/base.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b82f4f9898d317e16dcfaec9191ad9bfde74639/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b82f4f9898d317e16dcfaec9191ad9bfde74639/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=8b82f4f9898d317e16dcfaec9191ad9bfde74639", "patch": "@@ -66,7 +66,7 @@ pub fn trans_fn<'clif, 'tcx, B: Backend + 'static>(\n \n     // Recover all necessary data from fx, before accessing func will prevent future access to it.\n     let instance = fx.instance;\n-    let clif_comments = fx.clif_comments;\n+    let mut clif_comments = fx.clif_comments;\n     let source_info_set = fx.source_info_set;\n     let local_map = fx.local_map;\n \n@@ -76,6 +76,8 @@ pub fn trans_fn<'clif, 'tcx, B: Backend + 'static>(\n     // Verify function\n     verify_func(tcx, &clif_comments, &func);\n \n+    crate::optimize::optimize_function(cx.tcx, instance, &mut func, &mut clif_comments);\n+\n     // Define function\n     let context = &mut cx.caches.context;\n     context.func = func;\n@@ -108,7 +110,7 @@ pub fn trans_fn<'clif, 'tcx, B: Backend + 'static>(\n     context.clear();\n }\n \n-fn verify_func(tcx: TyCtxt, writer: &crate::pretty_clif::CommentWriter, func: &Function) {\n+pub fn verify_func(tcx: TyCtxt, writer: &crate::pretty_clif::CommentWriter, func: &Function) {\n     let flags = settings::Flags::new(settings::builder());\n     match ::cranelift_codegen::verify_function(&func, &flags) {\n         Ok(_) => {}\n@@ -265,7 +267,7 @@ fn trans_stmt<'tcx>(\n \n     fx.set_debug_loc(stmt.source_info);\n \n-    #[cfg(debug_assertions)]\n+    #[cfg(false_debug_assertions)]\n     match &stmt.kind {\n         StatementKind::StorageLive(..) | StatementKind::StorageDead(..) => {} // Those are not very useful\n         _ => {"}, {"sha": "02cfe160370e83d9d7fb36753026c595d537f32b", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b82f4f9898d317e16dcfaec9191ad9bfde74639/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b82f4f9898d317e16dcfaec9191ad9bfde74639/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=8b82f4f9898d317e16dcfaec9191ad9bfde74639", "patch": "@@ -47,6 +47,7 @@ mod linkage;\n mod main_shim;\n mod metadata;\n mod num;\n+mod optimize;\n mod pointer;\n mod pretty_clif;\n mod target_features_whitelist;"}, {"sha": "f1ced869d26dcd14a7d4cebf5b48989deefd0fa4", "filename": "src/optimize/mod.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8b82f4f9898d317e16dcfaec9191ad9bfde74639/src%2Foptimize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b82f4f9898d317e16dcfaec9191ad9bfde74639/src%2Foptimize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fmod.rs?ref=8b82f4f9898d317e16dcfaec9191ad9bfde74639", "patch": "@@ -0,0 +1,15 @@\n+use crate::prelude::*;\n+\n+mod stack2reg;\n+\n+pub fn optimize_function<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    instance: Instance<'tcx>,\n+    func: &mut Function,\n+    clif_comments: &mut crate::pretty_clif::CommentWriter,\n+) {\n+    self::stack2reg::optimize_function(func, clif_comments, format!(\"{:?}\", instance));\n+    #[cfg(debug_assertions)]\n+    crate::pretty_clif::write_clif_file(tcx, \"stack2reg\", instance, &*func, &*clif_comments, None);\n+    crate::base::verify_func(tcx, &*clif_comments, &*func);\n+}"}, {"sha": "1737696c13e3dc6983e18ca067746d65af530f4b", "filename": "src/optimize/stack2reg.rs", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/8b82f4f9898d317e16dcfaec9191ad9bfde74639/src%2Foptimize%2Fstack2reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b82f4f9898d317e16dcfaec9191ad9bfde74639/src%2Foptimize%2Fstack2reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fstack2reg.rs?ref=8b82f4f9898d317e16dcfaec9191ad9bfde74639", "patch": "@@ -0,0 +1,222 @@\n+use cranelift_codegen::cursor::{Cursor, FuncCursor};\n+use cranelift_codegen::ir::{Opcode, InstructionData, ValueDef};\n+use cranelift_codegen::ir::immediates::Offset32;\n+use cranelift_codegen::entity::SecondaryMap;\n+\n+use crate::prelude::*;\n+\n+pub(super) fn optimize_function(\n+    func: &mut Function,\n+    clif_comments: &mut crate::pretty_clif::CommentWriter,\n+    name: String, // FIXME remove\n+) {\n+    let mut stack_addr_insts = SecondaryMap::new();\n+    let mut stack_load_store_insts = SecondaryMap::new();\n+\n+    let mut cursor = FuncCursor::new(func);\n+    while let Some(_ebb) = cursor.next_ebb() {\n+        while let Some(inst) = cursor.next_inst() {\n+            match cursor.func.dfg[inst] {\n+                // Record all stack_addr, stack_load and stack_store instructions.\n+                InstructionData::StackLoad {\n+                    opcode: Opcode::StackAddr,\n+                    stack_slot: _,\n+                    offset: _,\n+                } => {\n+                    stack_addr_insts[inst] = true;\n+                }\n+                InstructionData::StackLoad {\n+                    opcode: Opcode::StackLoad,\n+                    stack_slot: _,\n+                    offset: _,\n+                } => {\n+                    stack_load_store_insts[inst] = true;\n+                }\n+                InstructionData::StackStore {\n+                    opcode: Opcode::StackStore,\n+                    arg: _,\n+                    stack_slot: _,\n+                    offset: _,\n+                } => {\n+                    stack_load_store_insts[inst] = true;\n+                }\n+\n+                // Turn load and store into stack_load and stack_store when possible.\n+                InstructionData::Load { opcode: Opcode::Load, arg: addr, flags: _, offset } => {\n+                    if cursor.func.dfg.ctrl_typevar(inst) == types::I128 || cursor.func.dfg.ctrl_typevar(inst).is_vector() {\n+                        continue; // WORKAROUD: stack_load.i128 not yet implemented\n+                    }\n+                    if let Some((stack_slot, stack_addr_offset)) = try_get_stack_slot_and_offset_for_addr(cursor.func, addr) {\n+                        if let Some(combined_offset) = offset.try_add_i64(stack_addr_offset.into()) {\n+                            let ty = cursor.func.dfg.ctrl_typevar(inst);\n+                            cursor.func.dfg.replace(inst).stack_load(ty, stack_slot, combined_offset);\n+                            stack_load_store_insts[inst] = true;\n+                        }\n+                    }\n+                }\n+                InstructionData::Store { opcode: Opcode::Store, args: [value, addr], flags: _, offset } => {\n+                    if cursor.func.dfg.ctrl_typevar(inst) == types::I128 || cursor.func.dfg.ctrl_typevar(inst).is_vector() {\n+                        continue; // WORKAROUND: stack_store.i128 not yet implemented\n+                    }\n+                    if let Some((stack_slot, stack_addr_offset)) = try_get_stack_slot_and_offset_for_addr(cursor.func, addr) {\n+                        if let Some(combined_offset) = offset.try_add_i64(stack_addr_offset.into()) {\n+                            cursor.func.dfg.replace(inst).stack_store(value, stack_slot, combined_offset);\n+                            stack_load_store_insts[inst] = true;\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    let mut used_stack_addr_insts = SecondaryMap::new();\n+\n+    let mut cursor = FuncCursor::new(func);\n+    while let Some(_ebb) = cursor.next_ebb() {\n+        while let Some(inst) = cursor.next_inst() {\n+            for &arg in cursor.func.dfg.inst_args(inst) {\n+                if let ValueDef::Result(arg_origin, 0) = cursor.func.dfg.value_def(arg) {\n+                    if cursor.func.dfg[arg_origin].opcode() == Opcode::StackAddr {\n+                        used_stack_addr_insts[arg_origin] = true;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /*println!(\n+        \"stack_addr: [{}] ([{}] used)\\nstack_load/stack_store: [{}]\",\n+        bool_secondary_map_to_string(&stack_addr_insts),\n+        bool_secondary_map_to_string(&used_stack_addr_insts),\n+        bool_secondary_map_to_string(&stack_load_store_insts),\n+    );*/\n+\n+    for inst in used_stack_addr_insts.keys().filter(|&inst| used_stack_addr_insts[inst]) {\n+        assert!(stack_addr_insts[inst]);\n+    }\n+\n+    // Replace all unused stack_addr instructions with nop.\n+    for inst in stack_addr_insts.keys() {\n+        if stack_addr_insts[inst] && !used_stack_addr_insts[inst] {\n+            func.dfg.detach_results(inst);\n+            func.dfg.replace(inst).nop();\n+            stack_addr_insts[inst] = false;\n+        }\n+    }\n+\n+    //println!(\"stack_addr (after): [{}]\", bool_secondary_map_to_string(&stack_addr_insts));\n+\n+    let mut stack_slot_usage_map: SecondaryMap<StackSlot, HashSet<Inst>> = SecondaryMap::new();\n+    for inst in stack_load_store_insts.keys().filter(|&inst| stack_load_store_insts[inst]) {\n+        match func.dfg[inst] {\n+            InstructionData::StackLoad {\n+                opcode: Opcode::StackLoad,\n+                stack_slot,\n+                offset: _,\n+            } => {\n+                stack_slot_usage_map[stack_slot].insert(inst);\n+            }\n+            InstructionData::StackStore {\n+                opcode: Opcode::StackStore,\n+                arg: _,\n+                stack_slot,\n+                offset: _,\n+            } => {\n+                stack_slot_usage_map[stack_slot].insert(inst);\n+            }\n+            ref data => unreachable!(\"{:?}\", data),\n+        }\n+    }\n+    for inst in stack_addr_insts.keys().filter(|&inst| stack_addr_insts[inst]) {\n+        match func.dfg[inst] {\n+            InstructionData::StackLoad {\n+                opcode: Opcode::StackAddr,\n+                stack_slot,\n+                offset: _,\n+            } => {\n+                stack_slot_usage_map[stack_slot].insert(inst);\n+            }\n+            ref data => unreachable!(\"{:?}\", data),\n+        }\n+    }\n+\n+    //println!(\"{:?}\\n\", stack_slot_usage_map);\n+\n+    for (stack_slot, users) in stack_slot_usage_map.iter_mut() {\n+        let mut is_addr_leaked = false;\n+        let mut is_loaded = false;\n+        let mut is_stored = false;\n+        for &user in users.iter() {\n+            match func.dfg[user] {\n+                InstructionData::StackLoad {\n+                    opcode: Opcode::StackAddr,\n+                    stack_slot,\n+                    offset: _,\n+                } => {\n+                    is_addr_leaked = true;\n+                }\n+                InstructionData::StackLoad {\n+                    opcode: Opcode::StackLoad,\n+                    stack_slot,\n+                    offset: _,\n+                } => {\n+                    is_loaded = true;\n+                }\n+                InstructionData::StackStore {\n+                    opcode: Opcode::StackStore,\n+                    arg: _,\n+                    stack_slot,\n+                    offset: _,\n+                } => {\n+                    is_stored = true;\n+                }\n+                ref data => unreachable!(\"{:?}\", data),\n+            }\n+        }\n+\n+        if is_addr_leaked || (is_loaded && is_stored) {\n+            continue;\n+        }\n+\n+        if is_loaded {\n+            println!(\"[{}] [BUG?] Reading uninitialized memory\", name);\n+        } else {\n+            // Stored value never read; just remove reads.\n+            for &user in users.iter() {\n+                println!(\"[{}] Remove dead stack store {} of {}\", name, user, stack_slot);\n+                func.dfg.replace(user).nop();\n+            }\n+        }\n+    }\n+}\n+\n+fn try_get_stack_slot_and_offset_for_addr(func: &Function, addr: Value) -> Option<(StackSlot, Offset32)> {\n+    if let ValueDef::Result(addr_inst, 0) = func.dfg.value_def(addr) {\n+        if let InstructionData::StackLoad {\n+            opcode: Opcode::StackAddr,\n+            stack_slot,\n+            offset,\n+        } = func.dfg[addr_inst] {\n+            return Some((stack_slot, offset));\n+        }\n+    }\n+    None\n+}\n+\n+fn bool_secondary_map_to_string<E>(map: &SecondaryMap<E, bool>) -> String\n+    where E: cranelift_codegen::entity::EntityRef + std::fmt::Display,\n+{\n+    map\n+        .keys()\n+        .filter_map(|inst| {\n+            // EntitySet::keys returns all possible entities until the last entity inserted.\n+            if map[inst] {\n+                Some(format!(\"{}\", inst))\n+            } else {\n+                None\n+            }\n+        })\n+        .collect::<Vec<String>>()\n+        .join(\", \")\n+}"}, {"sha": "6f0c615c9502ae217984d755789edf1a81170c41", "filename": "src/value_and_place.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8b82f4f9898d317e16dcfaec9191ad9bfde74639/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b82f4f9898d317e16dcfaec9191ad9bfde74639/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=8b82f4f9898d317e16dcfaec9191ad9bfde74639", "patch": "@@ -362,19 +362,6 @@ impl<'tcx> CPlace<'tcx> {\n     }\n \n     pub fn write_cvalue(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>, from: CValue<'tcx>) {\n-        #[cfg(debug_assertions)]\n-        {\n-            use cranelift_codegen::cursor::{Cursor, CursorPosition};\n-            let cur_ebb = match fx.bcx.cursor().position() {\n-                CursorPosition::After(ebb) => ebb,\n-                _ => unreachable!(),\n-            };\n-            fx.add_comment(\n-                fx.bcx.func.layout.last_inst(cur_ebb).unwrap(),\n-                format!(\"write_cvalue: {:?} <- {:?}\",self, from),\n-            );\n-        }\n-\n         let from_ty = from.layout().ty;\n         let to_ty = self.layout().ty;\n "}, {"sha": "98171bc0f6a3eb3558fb87b8e9c1b261eb10239e", "filename": "test.sh", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8b82f4f9898d317e16dcfaec9191ad9bfde74639/test.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8b82f4f9898d317e16dcfaec9191ad9bfde74639/test.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test.sh?ref=8b82f4f9898d317e16dcfaec9191ad9bfde74639", "patch": "@@ -4,10 +4,10 @@ set -e\n \n if [[ \"$1\" == \"--release\" ]]; then\n     export CHANNEL='release'\n-    cargo build --release $CG_CLIF_COMPILE_FLAGS\n+    cargo rustc --release $CG_CLIF_COMPILE_FLAGS -- -Clink-args=-fuse-ld=lld\n else\n     export CHANNEL='debug'\n-    cargo build $CG_CLIF_COMPILE_FLAGS\n+    cargo rustc $CG_CLIF_COMPILE_FLAGS -- -Clink-args=-fuse-ld=lld\n fi\n \n source config.sh\n@@ -28,6 +28,8 @@ mkdir -p target/out/clif\n echo \"[BUILD] mini_core\"\n $RUSTC example/mini_core.rs --crate-name mini_core --crate-type lib,dylib\n \n+#exit 1\n+\n echo \"[BUILD] example\"\n $RUSTC example/example.rs --crate-type lib\n \n@@ -69,15 +71,16 @@ $RUSTC example/mod_bench.rs --crate-type bin\n \n pushd simple-raytracer\n echo \"[BENCH COMPILE] ebobby/simple-raytracer\"\n-hyperfine --runs ${RUN_RUNS:-10} --warmup 1 --prepare \"rm -r target/*/debug || true\" \\\n-    \"RUSTFLAGS='' cargo build --target $TARGET_TRIPLE\" \\\n-    \"../cargo.sh build\"\n+rm -r target/x86_64*/\n+../cargo.sh build\n \n echo \"[BENCH RUN] ebobby/simple-raytracer\"\n cp ./target/*/debug/main ./raytracer_cg_clif\n-hyperfine --runs ${RUN_RUNS:-10} ./raytracer_cg_llvm ./raytracer_cg_clif\n+hyperfine --runs ${RUN_RUNS:-10} ./raytracer_*\n popd\n \n+exit 1\n+\n pushd build_sysroot/sysroot_src/src/libcore/tests\n rm -r ./target || true\n ../../../../../cargo.sh test"}]}