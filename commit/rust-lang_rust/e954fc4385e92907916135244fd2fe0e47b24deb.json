{"sha": "e954fc4385e92907916135244fd2fe0e47b24deb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5NTRmYzQzODVlOTI5MDc5MTYxMzUyNDRmZDJmZTBlNDdiMjRkZWI=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-12-04T21:44:51Z"}, "committer": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-12-29T00:40:46Z"}, "message": "librustc: Traverse arbitrarily deep for nullable enum opt.", "tree": {"sha": "382e1f857171753d482ef1ed43a84a27c0c608b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/382e1f857171753d482ef1ed43a84a27c0c608b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e954fc4385e92907916135244fd2fe0e47b24deb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e954fc4385e92907916135244fd2fe0e47b24deb", "html_url": "https://github.com/rust-lang/rust/commit/e954fc4385e92907916135244fd2fe0e47b24deb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e954fc4385e92907916135244fd2fe0e47b24deb/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "html_url": "https://github.com/rust-lang/rust/commit/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350"}], "stats": {"total": 181, "additions": 84, "deletions": 97}, "files": [{"sha": "44b86dc03c062c4a8150a779b4c6279d24b71dc2", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 76, "deletions": 90, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/e954fc4385e92907916135244fd2fe0e47b24deb/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e954fc4385e92907916135244fd2fe0e47b24deb/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=e954fc4385e92907916135244fd2fe0e47b24deb", "patch": "@@ -43,14 +43,13 @@\n \n #![allow(unsigned_negation)]\n \n-pub use self::PointerField::*;\n pub use self::Repr::*;\n \n use std::num::Int;\n use std::rc::Rc;\n \n use llvm::{ValueRef, True, IntEQ, IntNE};\n-use back::abi;\n+use back::abi::FAT_PTR_ADDR;\n use middle::subst;\n use middle::subst::Subst;\n use trans::_match;\n@@ -71,7 +70,6 @@ use util::ppaux::ty_to_string;\n \n type Hint = attr::ReprAttr;\n \n-\n /// Representations.\n #[deriving(Eq, PartialEq, Show)]\n pub enum Repr<'tcx> {\n@@ -101,7 +99,7 @@ pub enum Repr<'tcx> {\n         nullfields: Vec<Ty<'tcx>>\n     },\n     /// Two cases distinguished by a nullable pointer: the case with discriminant\n-    /// `nndiscr` is represented by the struct `nonnull`, where the `ptrfield`th\n+    /// `nndiscr` is represented by the struct `nonnull`, where the `discrfield`th\n     /// field is known to be nonnull due to its type; if that field is null, then\n     /// it represents the other case, which is inhabited by at most one value\n     /// (and all other fields are undefined/unused).\n@@ -112,7 +110,7 @@ pub enum Repr<'tcx> {\n     StructWrappedNullablePointer {\n         nonnull: Struct<'tcx>,\n         nndiscr: Disr,\n-        ptrfield: PointerField,\n+        discrfield: DiscrField,\n         nullfields: Vec<Ty<'tcx>>,\n     }\n }\n@@ -230,18 +228,20 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         let st = mk_struct(cx, cases[discr].tys[],\n                                            false, t);\n                         match cases[discr].find_ptr(cx) {\n-                            Some(ThinPointer(_)) if st.fields.len() == 1 => {\n+                            Some(ref pf) if pf.len() == 1 && st.fields.len() == 1 => {\n                                 return RawNullablePointer {\n                                     nndiscr: discr as Disr,\n                                     nnty: st.fields[0],\n                                     nullfields: cases[1 - discr].tys.clone()\n                                 };\n                             }\n-                            Some(ptrfield) => {\n+                            Some(pf) => {\n+                                let mut discrfield = vec![0];\n+                                discrfield.extend(pf.into_iter());\n                                 return StructWrappedNullablePointer {\n                                     nndiscr: discr as Disr,\n                                     nonnull: st,\n-                                    ptrfield: ptrfield,\n+                                    discrfield: discrfield,\n                                     nullfields: cases[1 - discr].tys.clone()\n                                 };\n                             }\n@@ -335,49 +335,67 @@ struct Case<'tcx> {\n     tys: Vec<Ty<'tcx>>\n }\n \n+/// This represents the (GEP) indices to follow to get to the discriminant field\n+pub type DiscrField = Vec<uint>;\n \n-#[deriving(Copy, Eq, PartialEq, Show)]\n-pub enum PointerField {\n-    ThinPointer(uint),\n-    FatPointer(uint)\n-}\n+fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Option<DiscrField> {\n+    match ty.sty {\n+        // &T/&mut T/Box<T> could either be a thin or fat pointer depending on T\n+        ty::ty_rptr(_, ty::mt { ty, .. }) | ty::ty_uniq(ty) => match ty.sty {\n+            // &[T] and &str are a pointer and length pair\n+            ty::ty_vec(_, None) | ty::ty_str => Some(vec![FAT_PTR_ADDR]),\n \n-impl<'tcx> Case<'tcx> {\n-    fn is_zerolen<'a>(&self, cx: &CrateContext<'a, 'tcx>, scapegoat: Ty<'tcx>)\n-                      -> bool {\n-        mk_struct(cx, self.tys[], false, scapegoat).size == 0\n-    }\n+            ty::ty_struct(..) if !ty::type_is_sized(tcx, ty) => Some(vec![FAT_PTR_ADDR]),\n \n-    fn find_ptr<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> Option<PointerField> {\n-        for (i, &ty) in self.tys.iter().enumerate() {\n-            match ty.sty {\n-                // &T/&mut T/Box<T> could either be a thin or fat pointer depending on T\n-                ty::ty_rptr(_, ty::mt { ty, .. }) | ty::ty_uniq(ty) => match ty.sty {\n-                    // &[T] and &str are a pointer and length pair\n-                    ty::ty_vec(_, None) | ty::ty_str => return Some(FatPointer(i)),\n+            // Any other &T is just a pointer\n+            _ => Some(vec![])\n+        },\n \n-                    // &Trait is a pair of pointers: the actual object and a vtable\n-                    ty::ty_trait(..) => return Some(FatPointer(i)),\n+        // Functions are just pointers\n+        ty::ty_bare_fn(..) => Some(vec![]),\n \n-                    ty::ty_struct(..) if !ty::type_is_sized(cx.tcx(), ty) => {\n-                        return Some(FatPointer(i))\n-                    }\n+        // Closures are a pair of pointers: the code and environment\n+        ty::ty_closure(..) => Some(vec![FAT_PTR_ADDR]),\n \n-                    // Any other &T is just a pointer\n-                    _ => return Some(ThinPointer(i))\n-                },\n+        // Perhaps one of the fields of this struct is non-null\n+        // let's recurse and find out\n+        ty::ty_struct(def_id, ref substs) => {\n+            let fields = ty::lookup_struct_fields(tcx, def_id);\n+            for (j, field) in fields.iter().enumerate() {\n+                let field_ty = ty::lookup_field_type(tcx, def_id, field.id, substs);\n+                match find_discr_field_candidate(tcx, field_ty) {\n+                    Some(v) => {\n+                        let mut discrfield = vec![j];\n+                        discrfield.extend(v.into_iter());\n+                        return Some(discrfield);\n+                    }\n+                    None => continue\n+                }\n+            }\n+            None\n+        },\n \n-                // Functions are just pointers\n-                ty::ty_bare_fn(..) => return Some(ThinPointer(i)),\n+        // Anything else is not a pointer\n+        _ => None\n+    }\n+}\n \n-                // Closures are a pair of pointers: the code and environment\n-                ty::ty_closure(..) => return Some(FatPointer(i)),\n+impl<'tcx> Case<'tcx> {\n+    fn is_zerolen<'a>(&self, cx: &CrateContext<'a, 'tcx>, scapegoat: Ty<'tcx>) -> bool {\n+        mk_struct(cx, self.tys[], false, scapegoat).size == 0\n+    }\n \n-                // Anything else is not a pointer\n-                _ => continue\n+    fn find_ptr<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> Option<DiscrField> {\n+        for (i, &ty) in self.tys.iter().enumerate() {\n+            match find_discr_field_candidate(cx.tcx(), ty) {\n+                Some(v) => {\n+                    let mut discrfield = vec![i];\n+                    discrfield.extend(v.into_iter());\n+                    return Some(discrfield);\n+                }\n+                None => continue\n             }\n         }\n-\n         None\n     }\n }\n@@ -709,8 +727,8 @@ pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n             val = ICmp(bcx, cmp, Load(bcx, scrutinee), C_null(llptrty));\n             signed = false;\n         }\n-        StructWrappedNullablePointer { nndiscr, ptrfield, .. } => {\n-            val = struct_wrapped_nullable_bitdiscr(bcx, nndiscr, ptrfield, scrutinee);\n+        StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n+            val = struct_wrapped_nullable_bitdiscr(bcx, nndiscr, discrfield, scrutinee);\n             signed = false;\n         }\n     }\n@@ -720,12 +738,9 @@ pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n     }\n }\n \n-fn struct_wrapped_nullable_bitdiscr(bcx: Block, nndiscr: Disr, ptrfield: PointerField,\n+fn struct_wrapped_nullable_bitdiscr(bcx: Block, nndiscr: Disr, discrfield: &DiscrField,\n                                     scrutinee: ValueRef) -> ValueRef {\n-    let llptrptr = match ptrfield {\n-        ThinPointer(field) => GEPi(bcx, scrutinee, &[0, field]),\n-        FatPointer(field) => GEPi(bcx, scrutinee, &[0, field, abi::FAT_PTR_ADDR])\n-    };\n+    let llptrptr = GEPi(bcx, scrutinee, discrfield[]);\n     let llptr = Load(bcx, llptrptr);\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     ICmp(bcx, cmp, llptr, C_null(val_ty(llptr)))\n@@ -811,17 +826,10 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n                 Store(bcx, C_null(llptrty), val)\n             }\n         }\n-        StructWrappedNullablePointer { ref nonnull, nndiscr, ptrfield, .. } => {\n+        StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n             if discr != nndiscr {\n-                let (llptrptr, llptrty) = match ptrfield {\n-                    ThinPointer(field) =>\n-                        (GEPi(bcx, val, &[0, field]),\n-                         type_of::type_of(bcx.ccx(), nonnull.fields[field])),\n-                    FatPointer(field) => {\n-                        let v = GEPi(bcx, val, &[0, field, abi::FAT_PTR_ADDR]);\n-                        (v, val_ty(v).element_type())\n-                    }\n-                };\n+                let llptrptr = GEPi(bcx, val, discrfield[]);\n+                let llptrty = val_ty(llptrptr).element_type();\n                 Store(bcx, C_null(llptrty), llptrptr)\n             }\n         }\n@@ -1041,7 +1049,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n                          false)\n             } else {\n                 let vals = nonnull.fields.iter().map(|&ty| {\n-                    // Always use null even if it's not the `ptrfield`th\n+                    // Always use null even if it's not the `discrfield`th\n                     // field; see #8506.\n                     C_null(type_of::sizing_type_of(ccx, ty))\n                 }).collect::<Vec<ValueRef>>();\n@@ -1121,9 +1129,8 @@ fn padding(ccx: &CrateContext, size: u64) -> ValueRef {\n #[inline]\n fn roundup(x: u64, a: u32) -> u64 { let a = a as u64; ((x + (a - 1)) / a) * a }\n \n-/// Get the discriminant of a constant value.  (Not currently used.)\n-pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef)\n-    -> Disr {\n+/// Get the discriminant of a constant value.\n+pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef) -> Disr {\n     match *r {\n         CEnum(ity, _, _) => {\n             match ity {\n@@ -1138,25 +1145,8 @@ pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef)\n             }\n         }\n         Univariant(..) => 0,\n-        RawNullablePointer { nndiscr, .. } => {\n-            if is_null(val) {\n-                /* subtraction as uint is ok because nndiscr is either 0 or 1 */\n-                (1 - nndiscr) as Disr\n-            } else {\n-                nndiscr\n-            }\n-        }\n-        StructWrappedNullablePointer { nndiscr, ptrfield, .. } => {\n-            let (idx, sub_idx) = match ptrfield {\n-                ThinPointer(field) => (field, None),\n-                FatPointer(field) => (field, Some(abi::FAT_PTR_ADDR))\n-            };\n-            if is_null(const_struct_field(ccx, val, idx, sub_idx)) {\n-                /* subtraction as uint is ok because nndiscr is either 0 or 1 */\n-                (1 - nndiscr) as Disr\n-            } else {\n-                nndiscr\n-            }\n+        RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => {\n+            ccx.sess().bug(\"const discrim access of non c-like enum\")\n         }\n     }\n }\n@@ -1170,29 +1160,25 @@ pub fn const_get_field(ccx: &CrateContext, r: &Repr, val: ValueRef,\n                        _discr: Disr, ix: uint) -> ValueRef {\n     match *r {\n         CEnum(..) => ccx.sess().bug(\"element access in C-like enum const\"),\n-        Univariant(..) => const_struct_field(ccx, val, ix, None),\n-        General(..) => const_struct_field(ccx, val, ix + 1, None),\n+        Univariant(..) => const_struct_field(ccx, val, ix),\n+        General(..) => const_struct_field(ccx, val, ix + 1),\n         RawNullablePointer { .. } => {\n             assert_eq!(ix, 0);\n             val\n-        }\n-        StructWrappedNullablePointer{ .. } => const_struct_field(ccx, val, ix, None)\n+        },\n+        StructWrappedNullablePointer{ .. } => const_struct_field(ccx, val, ix)\n     }\n }\n \n /// Extract field of struct-like const, skipping our alignment padding.\n-fn const_struct_field(ccx: &CrateContext, val: ValueRef, ix: uint, sub_idx: Option<uint>)\n-    -> ValueRef {\n+fn const_struct_field(ccx: &CrateContext, val: ValueRef, ix: uint) -> ValueRef {\n     // Get the ix-th non-undef element of the struct.\n     let mut real_ix = 0; // actual position in the struct\n     let mut ix = ix; // logical index relative to real_ix\n     let mut field;\n     loop {\n         loop {\n-            field = match sub_idx {\n-                Some(si) => const_get_elt(ccx, val, &[real_ix, si as u32]),\n-                None => const_get_elt(ccx, val, &[real_ix])\n-            };\n+            field = const_get_elt(ccx, val, &[real_ix]);\n             if !is_undef(field) {\n                 break;\n             }"}, {"sha": "d080cda4b819a8953109ed6e6c0671f79bed9af2", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e954fc4385e92907916135244fd2fe0e47b24deb/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e954fc4385e92907916135244fd2fe0e47b24deb/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=e954fc4385e92907916135244fd2fe0e47b24deb", "patch": "@@ -750,6 +750,7 @@ pub fn is_undef(val: ValueRef) -> bool {\n     }\n }\n \n+#[allow(dead_code)] // potentially useful\n pub fn is_null(val: ValueRef) -> bool {\n     unsafe {\n         llvm::LLVMIsNull(val) != False"}, {"sha": "b8c4a23b87accaf1b5945a298e07aa98f34c614f", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e954fc4385e92907916135244fd2fe0e47b24deb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e954fc4385e92907916135244fd2fe0e47b24deb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=e954fc4385e92907916135244fd2fe0e47b24deb", "patch": "@@ -2292,14 +2292,14 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n             },\n             adt::StructWrappedNullablePointer { nonnull: ref struct_def,\n                                                 nndiscr,\n-                                                ptrfield, ..} => {\n+                                                ref discrfield, ..} => {\n                 // Create a description of the non-null variant\n                 let (variant_type_metadata, variant_llvm_type, member_description_factory) =\n                     describe_enum_variant(cx,\n                                           self.enum_type,\n                                           struct_def,\n                                           &*(*self.variants)[nndiscr as uint],\n-                                          OptimizedDiscriminant(ptrfield),\n+                                          OptimizedDiscriminant,\n                                           self.containing_scope,\n                                           self.span);\n \n@@ -2315,10 +2315,10 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // member's name.\n                 let null_variant_index = (1 - nndiscr) as uint;\n                 let null_variant_name = token::get_name((*self.variants)[null_variant_index].name);\n-                let discrfield = match ptrfield {\n-                    adt::ThinPointer(field) => format!(\"{}\", field),\n-                    adt::FatPointer(field) => format!(\"{}\", field)\n-                };\n+                let discrfield = discrfield.iter()\n+                                           .skip(1)\n+                                           .map(|x| x.to_string())\n+                                           .collect::<Vec<_>>().connect(\"$\");\n                 let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n                                                 discrfield,\n                                                 null_variant_name);\n@@ -2367,7 +2367,7 @@ impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n #[deriving(Copy)]\n enum EnumDiscriminantInfo {\n     RegularDiscriminant(DIType),\n-    OptimizedDiscriminant(adt::PointerField),\n+    OptimizedDiscriminant,\n     NoDiscriminant\n }\n "}]}