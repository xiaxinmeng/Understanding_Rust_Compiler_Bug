{"sha": "56178d4259380e07dd4bcced502916326407e59f", "node_id": "C_kwDOAAsO6NoAKDU2MTc4ZDQyNTkzODBlMDdkZDRiY2NlZDUwMjkxNjMyNjQwN2U1OWY", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-08T05:16:14Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-11T04:09:17Z"}, "message": "Rename tag-related things.\n\nUse `tag` in names of things referring to tags, instead of the\nmysterious `vi`.\n\nAlso change `arg_N` in output to `argN`, which has the same length as\n`self` and so results in nicer vertical alignments.", "tree": {"sha": "6e68bf62ca81625b8bc17e5bd5aec29781f374fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e68bf62ca81625b8bc17e5bd5aec29781f374fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56178d4259380e07dd4bcced502916326407e59f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56178d4259380e07dd4bcced502916326407e59f", "html_url": "https://github.com/rust-lang/rust/commit/56178d4259380e07dd4bcced502916326407e59f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56178d4259380e07dd4bcced502916326407e59f/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96f09d73cd6ffc4a4e2719819e205b6e5a26718f", "url": "https://api.github.com/repos/rust-lang/rust/commits/96f09d73cd6ffc4a4e2719819e205b6e5a26718f", "html_url": "https://github.com/rust-lang/rust/commit/96f09d73cd6ffc4a4e2719819e205b6e5a26718f"}], "stats": {"total": 222, "additions": 109, "deletions": 113}, "files": [{"sha": "2e21d197cdf8e8dc98d35622b8381ec64faf3c68", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/56178d4259380e07dd4bcced502916326407e59f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56178d4259380e07dd4bcced502916326407e59f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=56178d4259380e07dd4bcced502916326407e59f", "patch": "@@ -146,12 +146,12 @@\n //!\n //! ```{.text}\n //! EnumNonMatchingCollapsed(\n-//!     &[<ident for self index value>, <ident of __arg_1 index value>])\n+//!     &[<ident for self index value>, <ident of __arg1 index value>])\n //! ```\n //!\n //! It is the same for when the arguments are flipped to `C1 {x}` and\n //! `C0(a)`; the only difference is what the values of the identifiers\n-//! <ident for self index value> and <ident of __arg_1 index value> will\n+//! <ident for self index value> and <ident of __arg1 index value> will\n //! be in the generated code.\n //!\n //! `EnumNonMatchingCollapsed` deliberately provides far less information\n@@ -1125,12 +1125,12 @@ impl<'a> MethodDef<'a> {\n     /// impl ::core::cmp::PartialEq for A {\n     ///     #[inline]\n     ///     fn eq(&self, other: &A) -> bool {\n-    ///         let __self_vi = ::core::intrinsics::discriminant_value(self);\n-    ///         let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n-    ///         if __self_vi == __arg_1_vi {\n+    ///         let __self_tag = ::core::intrinsics::discriminant_value(self);\n+    ///         let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n+    ///         if __self_tag == __arg1_tag {\n     ///             match (self, other) {\n-    ///                 (A::A2(__self_0), A::A2(__arg_1_0)) =>\n-    ///                     *__self_0 == *__arg_1_0,\n+    ///                 (A::A2(__self_0), A::A2(__arg1_0)) =>\n+    ///                     *__self_0 == *__arg1_0,\n     ///                 _ => true,\n     ///             }\n     ///         } else {\n@@ -1171,25 +1171,22 @@ impl<'a> MethodDef<'a> {\n                     .iter()\n                     .enumerate()\n                     .skip(1)\n-                    .map(|(arg_count, _selflike_arg)| format!(\"__arg_{}\", arg_count)),\n+                    .map(|(arg_count, _selflike_arg)| format!(\"__arg{}\", arg_count)),\n             )\n             .collect::<Vec<String>>();\n \n-        // The `vi_idents` will be bound, solely in the catch-all, to\n+        // The `tag_idents` will be bound, solely in the catch-all, to\n         // a series of let statements mapping each selflike_arg to an int\n         // value corresponding to its discriminant.\n-        let vi_idents = prefixes\n+        let tag_idents = prefixes\n             .iter()\n-            .map(|name| {\n-                let vi_suffix = format!(\"{}_vi\", name);\n-                Ident::from_str_and_span(&vi_suffix, span)\n-            })\n+            .map(|name| Ident::from_str_and_span(&format!(\"{}_tag\", name), span))\n             .collect::<Vec<Ident>>();\n \n         // Builds, via callback to call_substructure_method, the\n         // delegated expression that handles the catch-all case,\n         // using `__variants_tuple` to drive logic if necessary.\n-        let catch_all_substructure = EnumNonMatchingCollapsed(&vi_idents);\n+        let catch_all_substructure = EnumNonMatchingCollapsed(&tag_idents);\n \n         let first_fieldless = variants.iter().find(|v| v.data.fields().is_empty());\n \n@@ -1303,15 +1300,15 @@ impl<'a> MethodDef<'a> {\n             // i.e., for `enum E<T> { A, B(1), C(T, T) }` for `PartialEq::eq`,\n             // builds two statements:\n             // ```\n-            // let __self_vi = ::core::intrinsics::discriminant_value(self);\n-            // let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n+            // let __self_tag = ::core::intrinsics::discriminant_value(self);\n+            // let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n             // ```\n-            let mut index_let_stmts: Vec<ast::Stmt> = Vec::with_capacity(vi_idents.len() + 1);\n+            let mut index_let_stmts: Vec<ast::Stmt> = Vec::with_capacity(tag_idents.len() + 1);\n \n             // We also build an expression which checks whether all discriminants are equal, e.g.\n-            // `__self_vi == __arg_1_vi`.\n+            // `__self_tag == __arg1_tag`.\n             let mut discriminant_test = cx.expr_bool(span, true);\n-            for (i, (&ident, selflike_arg)) in iter::zip(&vi_idents, &selflike_args).enumerate() {\n+            for (i, (&ident, selflike_arg)) in iter::zip(&tag_idents, &selflike_args).enumerate() {\n                 let variant_value = deriving::call_intrinsic(\n                     cx,\n                     span,\n@@ -1322,7 +1319,7 @@ impl<'a> MethodDef<'a> {\n                 index_let_stmts.push(let_stmt);\n \n                 if i > 0 {\n-                    let id0 = cx.expr_ident(span, vi_idents[0]);\n+                    let id0 = cx.expr_ident(span, tag_idents[0]);\n                     let id = cx.expr_ident(span, ident);\n                     let test = cx.expr_binary(span, BinOpKind::Eq, id0, id);\n                     discriminant_test = if i == 1 {\n@@ -1346,7 +1343,7 @@ impl<'a> MethodDef<'a> {\n             let match_arg = cx.expr(span, ast::ExprKind::Tup(selflike_args));\n \n             // Lastly we create an expression which branches on all discriminants being equal, e.g.\n-            //  if __self_vi == _arg_1_vi {\n+            //  if __self_tag == _arg1_tag {\n             //      match (self, other) {\n             //          (Variant1, Variant1, ...) => Body1\n             //          (Variant2, Variant2, ...) => Body2,\n@@ -1355,7 +1352,7 @@ impl<'a> MethodDef<'a> {\n             //      }\n             //  }\n             //  else {\n-            //      <delegated expression referring to __self_vi, et al.>\n+            //      <delegated expression referring to __self_tag, et al.>\n             //  }\n             let all_match = cx.expr_match(span, match_arg, match_arms);\n             let arm_expr = cx.expr_if(span, discriminant_test, all_match, Some(arm_expr));"}, {"sha": "0337ca2634fb6ed5ac5b241b5e65fb7a68a97675", "filename": "src/test/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 89, "deletions": 90, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/56178d4259380e07dd4bcced502916326407e59f/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/56178d4259380e07dd4bcced502916326407e59f/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=56178d4259380e07dd4bcced502916326407e59f", "patch": "@@ -710,15 +710,15 @@ impl ::core::cmp::PartialEq for Enum1 {\n     #[inline]\n     fn eq(&self, other: &Enum1) -> bool {\n         match (self, other) {\n-            (Enum1::Single { x: __self_0 }, Enum1::Single { x: __arg_1_0 }) =>\n-                *__self_0 == *__arg_1_0,\n+            (Enum1::Single { x: __self_0 }, Enum1::Single { x: __arg1_0 }) =>\n+                *__self_0 == *__arg1_0,\n         }\n     }\n     #[inline]\n     fn ne(&self, other: &Enum1) -> bool {\n         match (self, other) {\n-            (Enum1::Single { x: __self_0 }, Enum1::Single { x: __arg_1_0 }) =>\n-                *__self_0 != *__arg_1_0,\n+            (Enum1::Single { x: __self_0 }, Enum1::Single { x: __arg1_0 }) =>\n+                *__self_0 != *__arg1_0,\n         }\n     }\n }\n@@ -740,8 +740,8 @@ impl ::core::cmp::PartialOrd for Enum1 {\n     fn partial_cmp(&self, other: &Enum1)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n         match (self, other) {\n-            (Enum1::Single { x: __self_0 }, Enum1::Single { x: __arg_1_0 }) =>\n-                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg_1_0),\n+            (Enum1::Single { x: __self_0 }, Enum1::Single { x: __arg1_0 }) =>\n+                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n         }\n     }\n }\n@@ -751,8 +751,8 @@ impl ::core::cmp::Ord for Enum1 {\n     #[inline]\n     fn cmp(&self, other: &Enum1) -> ::core::cmp::Ordering {\n         match (self, other) {\n-            (Enum1::Single { x: __self_0 }, Enum1::Single { x: __arg_1_0 }) =>\n-                ::core::cmp::Ord::cmp(__self_0, __arg_1_0),\n+            (Enum1::Single { x: __self_0 }, Enum1::Single { x: __arg1_0 }) =>\n+                ::core::cmp::Ord::cmp(__self_0, __arg1_0),\n         }\n     }\n }\n@@ -883,9 +883,9 @@ impl ::core::marker::StructuralPartialEq for Fieldless {}\n impl ::core::cmp::PartialEq for Fieldless {\n     #[inline]\n     fn eq(&self, other: &Fieldless) -> bool {\n-        let __self_vi = ::core::intrinsics::discriminant_value(self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n-        if __self_vi == __arg_1_vi {\n+        let __self_tag = ::core::intrinsics::discriminant_value(self);\n+        let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n+        if __self_tag == __arg1_tag {\n                 match (self, other) { _ => true, }\n             } else { false }\n     }\n@@ -905,15 +905,15 @@ impl ::core::cmp::PartialOrd for Fieldless {\n     #[inline]\n     fn partial_cmp(&self, other: &Fieldless)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        let __self_vi = ::core::intrinsics::discriminant_value(self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n-        if __self_vi == __arg_1_vi {\n+        let __self_tag = ::core::intrinsics::discriminant_value(self);\n+        let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n+        if __self_tag == __arg1_tag {\n                 match (self, other) {\n                     _ =>\n                         ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n                 }\n             } else {\n-               ::core::cmp::PartialOrd::partial_cmp(&__self_vi, &__arg_1_vi)\n+               ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)\n            }\n     }\n }\n@@ -922,11 +922,11 @@ impl ::core::cmp::PartialOrd for Fieldless {\n impl ::core::cmp::Ord for Fieldless {\n     #[inline]\n     fn cmp(&self, other: &Fieldless) -> ::core::cmp::Ordering {\n-        let __self_vi = ::core::intrinsics::discriminant_value(self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n-        if __self_vi == __arg_1_vi {\n+        let __self_tag = ::core::intrinsics::discriminant_value(self);\n+        let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n+        if __self_tag == __arg1_tag {\n                 match (self, other) { _ => ::core::cmp::Ordering::Equal, }\n-            } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n+            } else { ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) }\n     }\n }\n \n@@ -1005,30 +1005,30 @@ impl ::core::marker::StructuralPartialEq for Mixed {}\n impl ::core::cmp::PartialEq for Mixed {\n     #[inline]\n     fn eq(&self, other: &Mixed) -> bool {\n-        let __self_vi = ::core::intrinsics::discriminant_value(self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n-        if __self_vi == __arg_1_vi {\n+        let __self_tag = ::core::intrinsics::discriminant_value(self);\n+        let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n+        if __self_tag == __arg1_tag {\n                 match (self, other) {\n-                    (Mixed::R(__self_0), Mixed::R(__arg_1_0)) =>\n-                        *__self_0 == *__arg_1_0,\n+                    (Mixed::R(__self_0), Mixed::R(__arg1_0)) =>\n+                        *__self_0 == *__arg1_0,\n                     (Mixed::S { d1: __self_0, d2: __self_1 }, Mixed::S {\n-                        d1: __arg_1_0, d2: __arg_1_1 }) =>\n-                        *__self_0 == *__arg_1_0 && *__self_1 == *__arg_1_1,\n+                        d1: __arg1_0, d2: __arg1_1 }) =>\n+                        *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,\n                     _ => true,\n                 }\n             } else { false }\n     }\n     #[inline]\n     fn ne(&self, other: &Mixed) -> bool {\n-        let __self_vi = ::core::intrinsics::discriminant_value(self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n-        if __self_vi == __arg_1_vi {\n+        let __self_tag = ::core::intrinsics::discriminant_value(self);\n+        let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n+        if __self_tag == __arg1_tag {\n                 match (self, other) {\n-                    (Mixed::R(__self_0), Mixed::R(__arg_1_0)) =>\n-                        *__self_0 != *__arg_1_0,\n+                    (Mixed::R(__self_0), Mixed::R(__arg1_0)) =>\n+                        *__self_0 != *__arg1_0,\n                     (Mixed::S { d1: __self_0, d2: __self_1 }, Mixed::S {\n-                        d1: __arg_1_0, d2: __arg_1_1 }) =>\n-                        *__self_0 != *__arg_1_0 || *__self_1 != *__arg_1_1,\n+                        d1: __arg1_0, d2: __arg1_1 }) =>\n+                        *__self_0 != *__arg1_0 || *__self_1 != *__arg1_1,\n                     _ => false,\n                 }\n             } else { true }\n@@ -1051,26 +1051,25 @@ impl ::core::cmp::PartialOrd for Mixed {\n     #[inline]\n     fn partial_cmp(&self, other: &Mixed)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        let __self_vi = ::core::intrinsics::discriminant_value(self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n-        if __self_vi == __arg_1_vi {\n+        let __self_tag = ::core::intrinsics::discriminant_value(self);\n+        let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n+        if __self_tag == __arg1_tag {\n                 match (self, other) {\n-                    (Mixed::R(__self_0), Mixed::R(__arg_1_0)) =>\n-                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg_1_0),\n+                    (Mixed::R(__self_0), Mixed::R(__arg1_0)) =>\n+                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n                     (Mixed::S { d1: __self_0, d2: __self_1 }, Mixed::S {\n-                        d1: __arg_1_0, d2: __arg_1_1 }) =>\n+                        d1: __arg1_0, d2: __arg1_1 }) =>\n                         match ::core::cmp::PartialOrd::partial_cmp(__self_0,\n-                                __arg_1_0) {\n+                                __arg1_0) {\n                             ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                =>\n-                                ::core::cmp::PartialOrd::partial_cmp(__self_1, __arg_1_1),\n+                                => ::core::cmp::PartialOrd::partial_cmp(__self_1, __arg1_1),\n                             cmp => cmp,\n                         },\n                     _ =>\n                         ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n                 }\n             } else {\n-               ::core::cmp::PartialOrd::partial_cmp(&__self_vi, &__arg_1_vi)\n+               ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)\n            }\n     }\n }\n@@ -1079,22 +1078,22 @@ impl ::core::cmp::PartialOrd for Mixed {\n impl ::core::cmp::Ord for Mixed {\n     #[inline]\n     fn cmp(&self, other: &Mixed) -> ::core::cmp::Ordering {\n-        let __self_vi = ::core::intrinsics::discriminant_value(self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n-        if __self_vi == __arg_1_vi {\n+        let __self_tag = ::core::intrinsics::discriminant_value(self);\n+        let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n+        if __self_tag == __arg1_tag {\n                 match (self, other) {\n-                    (Mixed::R(__self_0), Mixed::R(__arg_1_0)) =>\n-                        ::core::cmp::Ord::cmp(__self_0, __arg_1_0),\n+                    (Mixed::R(__self_0), Mixed::R(__arg1_0)) =>\n+                        ::core::cmp::Ord::cmp(__self_0, __arg1_0),\n                     (Mixed::S { d1: __self_0, d2: __self_1 }, Mixed::S {\n-                        d1: __arg_1_0, d2: __arg_1_1 }) =>\n-                        match ::core::cmp::Ord::cmp(__self_0, __arg_1_0) {\n+                        d1: __arg1_0, d2: __arg1_1 }) =>\n+                        match ::core::cmp::Ord::cmp(__self_0, __arg1_0) {\n                             ::core::cmp::Ordering::Equal =>\n-                                ::core::cmp::Ord::cmp(__self_1, __arg_1_1),\n+                                ::core::cmp::Ord::cmp(__self_1, __arg1_1),\n                             cmp => cmp,\n                         },\n                     _ => ::core::cmp::Ordering::Equal,\n                 }\n-            } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n+            } else { ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) }\n     }\n }\n \n@@ -1162,32 +1161,32 @@ impl ::core::marker::StructuralPartialEq for Fielded {}\n impl ::core::cmp::PartialEq for Fielded {\n     #[inline]\n     fn eq(&self, other: &Fielded) -> bool {\n-        let __self_vi = ::core::intrinsics::discriminant_value(self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n-        if __self_vi == __arg_1_vi {\n+        let __self_tag = ::core::intrinsics::discriminant_value(self);\n+        let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n+        if __self_tag == __arg1_tag {\n                 match (self, other) {\n-                    (Fielded::X(__self_0), Fielded::X(__arg_1_0)) =>\n-                        *__self_0 == *__arg_1_0,\n-                    (Fielded::Y(__self_0), Fielded::Y(__arg_1_0)) =>\n-                        *__self_0 == *__arg_1_0,\n-                    (Fielded::Z(__self_0), Fielded::Z(__arg_1_0)) =>\n-                        *__self_0 == *__arg_1_0,\n+                    (Fielded::X(__self_0), Fielded::X(__arg1_0)) =>\n+                        *__self_0 == *__arg1_0,\n+                    (Fielded::Y(__self_0), Fielded::Y(__arg1_0)) =>\n+                        *__self_0 == *__arg1_0,\n+                    (Fielded::Z(__self_0), Fielded::Z(__arg1_0)) =>\n+                        *__self_0 == *__arg1_0,\n                     _ => unsafe { ::core::intrinsics::unreachable() }\n                 }\n             } else { false }\n     }\n     #[inline]\n     fn ne(&self, other: &Fielded) -> bool {\n-        let __self_vi = ::core::intrinsics::discriminant_value(self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n-        if __self_vi == __arg_1_vi {\n+        let __self_tag = ::core::intrinsics::discriminant_value(self);\n+        let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n+        if __self_tag == __arg1_tag {\n                 match (self, other) {\n-                    (Fielded::X(__self_0), Fielded::X(__arg_1_0)) =>\n-                        *__self_0 != *__arg_1_0,\n-                    (Fielded::Y(__self_0), Fielded::Y(__arg_1_0)) =>\n-                        *__self_0 != *__arg_1_0,\n-                    (Fielded::Z(__self_0), Fielded::Z(__arg_1_0)) =>\n-                        *__self_0 != *__arg_1_0,\n+                    (Fielded::X(__self_0), Fielded::X(__arg1_0)) =>\n+                        *__self_0 != *__arg1_0,\n+                    (Fielded::Y(__self_0), Fielded::Y(__arg1_0)) =>\n+                        *__self_0 != *__arg1_0,\n+                    (Fielded::Z(__self_0), Fielded::Z(__arg1_0)) =>\n+                        *__self_0 != *__arg1_0,\n                     _ => unsafe { ::core::intrinsics::unreachable() }\n                 }\n             } else { true }\n@@ -1212,20 +1211,20 @@ impl ::core::cmp::PartialOrd for Fielded {\n     #[inline]\n     fn partial_cmp(&self, other: &Fielded)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        let __self_vi = ::core::intrinsics::discriminant_value(self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n-        if __self_vi == __arg_1_vi {\n+        let __self_tag = ::core::intrinsics::discriminant_value(self);\n+        let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n+        if __self_tag == __arg1_tag {\n                 match (self, other) {\n-                    (Fielded::X(__self_0), Fielded::X(__arg_1_0)) =>\n-                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg_1_0),\n-                    (Fielded::Y(__self_0), Fielded::Y(__arg_1_0)) =>\n-                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg_1_0),\n-                    (Fielded::Z(__self_0), Fielded::Z(__arg_1_0)) =>\n-                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg_1_0),\n+                    (Fielded::X(__self_0), Fielded::X(__arg1_0)) =>\n+                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n+                    (Fielded::Y(__self_0), Fielded::Y(__arg1_0)) =>\n+                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n+                    (Fielded::Z(__self_0), Fielded::Z(__arg1_0)) =>\n+                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n                     _ => unsafe { ::core::intrinsics::unreachable() }\n                 }\n             } else {\n-               ::core::cmp::PartialOrd::partial_cmp(&__self_vi, &__arg_1_vi)\n+               ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)\n            }\n     }\n }\n@@ -1234,19 +1233,19 @@ impl ::core::cmp::PartialOrd for Fielded {\n impl ::core::cmp::Ord for Fielded {\n     #[inline]\n     fn cmp(&self, other: &Fielded) -> ::core::cmp::Ordering {\n-        let __self_vi = ::core::intrinsics::discriminant_value(self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n-        if __self_vi == __arg_1_vi {\n+        let __self_tag = ::core::intrinsics::discriminant_value(self);\n+        let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n+        if __self_tag == __arg1_tag {\n                 match (self, other) {\n-                    (Fielded::X(__self_0), Fielded::X(__arg_1_0)) =>\n-                        ::core::cmp::Ord::cmp(__self_0, __arg_1_0),\n-                    (Fielded::Y(__self_0), Fielded::Y(__arg_1_0)) =>\n-                        ::core::cmp::Ord::cmp(__self_0, __arg_1_0),\n-                    (Fielded::Z(__self_0), Fielded::Z(__arg_1_0)) =>\n-                        ::core::cmp::Ord::cmp(__self_0, __arg_1_0),\n+                    (Fielded::X(__self_0), Fielded::X(__arg1_0)) =>\n+                        ::core::cmp::Ord::cmp(__self_0, __arg1_0),\n+                    (Fielded::Y(__self_0), Fielded::Y(__arg1_0)) =>\n+                        ::core::cmp::Ord::cmp(__self_0, __arg1_0),\n+                    (Fielded::Z(__self_0), Fielded::Z(__arg1_0)) =>\n+                        ::core::cmp::Ord::cmp(__self_0, __arg1_0),\n                     _ => unsafe { ::core::intrinsics::unreachable() }\n                 }\n-            } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n+            } else { ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) }\n     }\n }\n "}]}