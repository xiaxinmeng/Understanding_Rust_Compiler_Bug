{"sha": "8bb3d9e94a74dec560e520659c45c82ab3ba0566", "node_id": "C_kwDOAAsO6NoAKDhiYjNkOWU5NGE3NGRlYzU2MGU1MjA2NTljNDVjODJhYjNiYTA1NjY", "commit": {"author": {"name": "Vanille-N", "email": "neven.villani@crans.org", "date": "2022-12-02T12:29:48Z"}, "committer": {"name": "Vanille-N", "email": "neven.villani@crans.org", "date": "2022-12-02T12:29:48Z"}, "message": "other renames, introduction of BorrowTrackerMethod and AllocExtra", "tree": {"sha": "be5a7da8a7e45e194e1c461f40a3a3015d0ee15d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be5a7da8a7e45e194e1c461f40a3a3015d0ee15d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bb3d9e94a74dec560e520659c45c82ab3ba0566", "comment_count": 0, "verification": {"verified": false, "reason": "invalid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCAAdFiEE1bhy5AfUOHIeWIegAOdl+n9PLt4FAmOJ78kACgkQAOdl+n9P\nLt4ACgv/TrdC4wEQ/KF+4wYaDGcXmUGqMyxwQgYzsVbcHKvkJ2w48d2077Iz/WOb\narx1WKe+TYREs0+5c0H7IPlJVOShB3QQEON90bBli5qKnBjO70A9cV4SOXCWInkJ\n6dPMKpBvcN+JBhn2X7hYbN/TSy2dmna2BHxTopYcuMVfkPReV8cJGn9KvNbB8iaA\nYyS0hqjvAgDwzk1NJGN2wa8pxMYULLD/atnHB6mZaG1do9dhUAvcY49WMS/01q3l\nr3H9Riru33U7RDILKLRZCfrcwj82hlCfY7RQDYVVUcE3pOrdqSP3s18dqVD1HFe4\nSeyl9hR+viGDMi0+vXTrh8/j6bZvYTz0whfaLGWxW6yHuPxQYpHJCRdjGlxe4HJ9\n/Wdy5dWMXhyPBTFkLLV2F/IPFlwsfo/Ae+qcKvglxleQ03Vg5MugkgEi3i82u4Cx\n4mPOEx+zWP0usjTAGFqxwr9SzU2oodIRVaOXM2lnASZwmtEtDlwwphxYGpMh2XfR\n7p5725yI\n=kVvz\n-----END PGP SIGNATURE-----", "payload": "tree be5a7da8a7e45e194e1c461f40a3a3015d0ee15d\nparent 3a0149343326b5002a2a5623d8f5360324bbe302\nauthor Vanille-N <neven.villani@crans.org> 1669984188 +0100\ncommitter Vanille-N <neven.villani@crans.org> 1669984188 +0100\n\nother renames, introduction of BorrowTrackerMethod and AllocExtra\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bb3d9e94a74dec560e520659c45c82ab3ba0566", "html_url": "https://github.com/rust-lang/rust/commit/8bb3d9e94a74dec560e520659c45c82ab3ba0566", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bb3d9e94a74dec560e520659c45c82ab3ba0566/comments", "author": {"login": "Vanille-N", "id": 58042063, "node_id": "MDQ6VXNlcjU4MDQyMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/58042063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vanille-N", "html_url": "https://github.com/Vanille-N", "followers_url": "https://api.github.com/users/Vanille-N/followers", "following_url": "https://api.github.com/users/Vanille-N/following{/other_user}", "gists_url": "https://api.github.com/users/Vanille-N/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vanille-N/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vanille-N/subscriptions", "organizations_url": "https://api.github.com/users/Vanille-N/orgs", "repos_url": "https://api.github.com/users/Vanille-N/repos", "events_url": "https://api.github.com/users/Vanille-N/events{/privacy}", "received_events_url": "https://api.github.com/users/Vanille-N/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Vanille-N", "id": 58042063, "node_id": "MDQ6VXNlcjU4MDQyMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/58042063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vanille-N", "html_url": "https://github.com/Vanille-N", "followers_url": "https://api.github.com/users/Vanille-N/followers", "following_url": "https://api.github.com/users/Vanille-N/following{/other_user}", "gists_url": "https://api.github.com/users/Vanille-N/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vanille-N/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vanille-N/subscriptions", "organizations_url": "https://api.github.com/users/Vanille-N/orgs", "repos_url": "https://api.github.com/users/Vanille-N/repos", "events_url": "https://api.github.com/users/Vanille-N/events{/privacy}", "received_events_url": "https://api.github.com/users/Vanille-N/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a0149343326b5002a2a5623d8f5360324bbe302", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a0149343326b5002a2a5623d8f5360324bbe302", "html_url": "https://github.com/rust-lang/rust/commit/3a0149343326b5002a2a5623d8f5360324bbe302"}], "stats": {"total": 132, "additions": 56, "deletions": 76}, "files": [{"sha": "9ac04c4930f266038447df0278a7aa50b12fc55c", "filename": "src/tools/miri/src/bin/miri.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb3d9e94a74dec560e520659c45c82ab3ba0566/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb3d9e94a74dec560e520659c45c82ab3ba0566/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs?ref=8bb3d9e94a74dec560e520659c45c82ab3ba0566", "patch": "@@ -317,7 +317,7 @@ fn main() {\n         } else if arg == \"-Zmiri-disable-validation\" {\n             miri_config.validate = false;\n         } else if arg == \"-Zmiri-disable-stacked-borrows\" {\n-            miri_config.stacked_borrows = false;\n+            miri_config.borrow_tracker = None;\n         } else if arg == \"-Zmiri-disable-data-race-detector\" {\n             miri_config.data_race_detector = false;\n             miri_config.weak_memory_emulation = false;"}, {"sha": "6c9c96eef623897833064108c7d95a6c9c1ebb28", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb3d9e94a74dec560e520659c45c82ab3ba0566/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb3d9e94a74dec560e520659c45c82ab3ba0566/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=8bb3d9e94a74dec560e520659c45c82ab3ba0566", "patch": "@@ -87,7 +87,7 @@ pub struct MiriConfig {\n     /// Determine if validity checking is enabled.\n     pub validate: bool,\n     /// Determines if Stacked Borrows is enabled.\n-    pub stacked_borrows: bool,\n+    pub borrow_tracker: Option<BorrowTrackerMethod>,\n     /// Controls alignment checking.\n     pub check_alignment: AlignmentCheck,\n     /// Controls function [ABI](Abi) checking.\n@@ -149,7 +149,7 @@ impl Default for MiriConfig {\n         MiriConfig {\n             env: vec![],\n             validate: true,\n-            stacked_borrows: true,\n+            borrow_tracker: Some(BorrowTrackerMethod::StackedBorrows),\n             check_alignment: AlignmentCheck::Int,\n             check_abi: true,\n             isolated_op: IsolatedOp::Reject(RejectOpWith::Abort),"}, {"sha": "c26828b11e0e1322e29fdb0d5069966f1237590f", "filename": "src/tools/miri/src/intptrcast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb3d9e94a74dec560e520659c45c82ab3ba0566/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb3d9e94a74dec560e520659c45c82ab3ba0566/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs?ref=8bb3d9e94a74dec560e520659c45c82ab3ba0566", "patch": "@@ -112,8 +112,8 @@ impl<'mir, 'tcx> GlobalStateInner {\n         if global_state.provenance_mode != ProvenanceMode::Strict {\n             trace!(\"Exposing allocation id {alloc_id:?}\");\n             global_state.exposed.insert(alloc_id);\n-            if ecx.machine.stacked_borrows.is_some() {\n-                ecx.expose_tag(alloc_id, sb)?;\n+            if ecx.machine.borrow_tracker.is_some() {\n+                ecx.expose_tag(alloc_id, tag)?;\n             }\n         }\n         Ok(())"}, {"sha": "920ee3e1ef1f492f8e39e7d8d802acd3b0fb06f2", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 46, "deletions": 62, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/8bb3d9e94a74dec560e520659c45c82ab3ba0566/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb3d9e94a74dec560e520659c45c82ab3ba0566/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=8bb3d9e94a74dec560e520659c45c82ab3ba0566", "patch": "@@ -39,7 +39,7 @@ pub const STACK_SIZE: u64 = 16 * PAGE_SIZE; // whatever\n /// Extra data stored with each stack frame\n pub struct FrameData<'tcx> {\n     /// Extra data for Stacked Borrows.\n-    pub stacked_borrows: Option<stacked_borrows::FrameExtra>,\n+    pub borrow_tracker: Option<borrow_tracker::FrameExtra>,\n \n     /// If this is Some(), then this is a special \"catch unwind\" frame (the frame of `try_fn`\n     /// called by `try`). When this frame is popped during unwinding a panic,\n@@ -61,20 +61,20 @@ pub struct FrameData<'tcx> {\n impl<'tcx> std::fmt::Debug for FrameData<'tcx> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         // Omitting `timing`, it does not support `Debug`.\n-        let FrameData { stacked_borrows, catch_unwind, timing: _, is_user_relevant: _ } = self;\n+        let FrameData { borrow_tracker, catch_unwind, timing: _, is_user_relevant: _ } = self;\n         f.debug_struct(\"FrameData\")\n-            .field(\"stacked_borrows\", stacked_borrows)\n+            .field(\"borrow_tracker\", borrow_tracker)\n             .field(\"catch_unwind\", catch_unwind)\n             .finish()\n     }\n }\n \n impl VisitTags for FrameData<'_> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n-        let FrameData { catch_unwind, stacked_borrows, timing: _, is_user_relevant: _ } = self;\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n+        let FrameData { catch_unwind, borrow_tracker, timing: _, is_user_relevant: _ } = self;\n \n         catch_unwind.visit_tags(visit);\n-        stacked_borrows.visit_tags(visit);\n+        borrow_tracker.visit_tags(visit);\n     }\n }\n \n@@ -254,8 +254,8 @@ impl ProvenanceExtra {\n /// Extra per-allocation data\n #[derive(Debug, Clone)]\n pub struct AllocExtra {\n-    /// Stacked Borrows state is only added if it is enabled.\n-    pub stacked_borrows: Option<stacked_borrows::AllocExtra>,\n+    /// Global state of the borrow tracker, if enabled.\n+    pub borrow_tracker: Option<borrow_tracker::AllocExtra>,\n     /// Data race detection via the use of a vector-clock,\n     ///  this is only added if it is enabled.\n     pub data_race: Option<data_race::AllocExtra>,\n@@ -265,10 +265,10 @@ pub struct AllocExtra {\n }\n \n impl VisitTags for AllocExtra {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n-        let AllocExtra { stacked_borrows, data_race, weak_memory } = self;\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n+        let AllocExtra { borrow_tracker, data_race, weak_memory } = self;\n \n-        stacked_borrows.visit_tags(visit);\n+        borrow_tracker.visit_tags(visit);\n         data_race.visit_tags(visit);\n         weak_memory.visit_tags(visit);\n     }\n@@ -350,8 +350,8 @@ pub struct MiriMachine<'mir, 'tcx> {\n     // We carry a copy of the global `TyCtxt` for convenience, so methods taking just `&Evaluator` have `tcx` access.\n     pub tcx: TyCtxt<'tcx>,\n \n-    /// Stacked Borrows global data.\n-    pub stacked_borrows: Option<stacked_borrows::GlobalState>,\n+    /// Global data for borrow tracking.\n+    pub borrow_tracker: Option<borrow_tracker::GlobalState>,\n \n     /// Data race detector global data.\n     pub data_race: Option<data_race::GlobalState>,\n@@ -480,17 +480,11 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n             measureme::Profiler::new(out).expect(\"Couldn't create `measureme` profiler\")\n         });\n         let rng = StdRng::seed_from_u64(config.seed.unwrap_or(0));\n-        let stacked_borrows = config.stacked_borrows.then(|| {\n-            RefCell::new(stacked_borrows::GlobalStateInner::new(\n-                config.tracked_pointer_tags.clone(),\n-                config.tracked_call_ids.clone(),\n-                config.retag_fields,\n-            ))\n-        });\n+        let borrow_tracker = config.borrow_tracker.map(|bt| bt.instanciate_global_state(config));\n         let data_race = config.data_race_detector.then(|| data_race::GlobalState::new(config));\n         MiriMachine {\n             tcx: layout_cx.tcx,\n-            stacked_borrows,\n+            borrow_tracker,\n             data_race,\n             intptrcast: RefCell::new(intptrcast::GlobalStateInner::new(config)),\n             // `env_vars` depends on a full interpreter so we cannot properly initialize it yet.\n@@ -668,7 +662,7 @@ impl VisitTags for MiriMachine<'_, '_> {\n             cmd_line,\n             extern_statics,\n             dir_handler,\n-            stacked_borrows,\n+            borrow_tracker,\n             data_race,\n             intptrcast,\n             file_handler,\n@@ -706,7 +700,7 @@ impl VisitTags for MiriMachine<'_, '_> {\n         dir_handler.visit_tags(visit);\n         file_handler.visit_tags(visit);\n         data_race.visit_tags(visit);\n-        stacked_borrows.visit_tags(visit);\n+        borrow_tracker.visit_tags(visit);\n         intptrcast.visit_tags(visit);\n         main_fn_ret_place.visit_tags(visit);\n         argc.visit_tags(visit);\n@@ -907,15 +901,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         }\n \n         let alloc = alloc.into_owned();\n-        let stacks = ecx.machine.stacked_borrows.as_ref().map(|stacked_borrows| {\n-            stacked_borrows::Stacks::new_allocation(\n-                id,\n-                alloc.size(),\n-                stacked_borrows,\n-                kind,\n-                &ecx.machine,\n-            )\n-        });\n+        let borrow_tracker = ecx\n+            .machine\n+            .borrow_tracker\n+            .as_ref()\n+            .map(|bt| bt.borrow_mut().new_allocation(id, alloc.size(), kind, &ecx.machine));\n+\n         let race_alloc = ecx.machine.data_race.as_ref().map(|data_race| {\n             data_race::AllocExtra::new_allocation(\n                 data_race,\n@@ -927,11 +918,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         let buffer_alloc = ecx.machine.weak_memory.then(weak_memory::AllocExtra::new_allocation);\n         let alloc: Allocation<Provenance, Self::AllocExtra> = alloc.adjust_from_tcx(\n             &ecx.tcx,\n-            AllocExtra {\n-                stacked_borrows: stacks.map(RefCell::new),\n-                data_race: race_alloc,\n-                weak_memory: buffer_alloc,\n-            },\n+            AllocExtra { borrow_tracker, data_race: race_alloc, weak_memory: buffer_alloc },\n             |ptr| ecx.global_base_pointer(ptr),\n         )?;\n         Ok(Cow::Owned(alloc))\n@@ -955,8 +942,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             }\n         }\n         let absolute_addr = intptrcast::GlobalStateInner::rel_ptr_to_addr(ecx, ptr);\n-        let sb_tag = if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n-            stacked_borrows.borrow_mut().base_ptr_tag(ptr.provenance, &ecx.machine)\n+        let tag = if let Some(borrow_tracker) = &ecx.machine.borrow_tracker {\n+            borrow_tracker.borrow_mut().base_ptr_tag(ptr.provenance, &ecx.machine)\n         } else {\n             // Value does not matter, SB is disabled\n             BorTag::default()\n@@ -1018,10 +1005,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         if let Some(data_race) = &alloc_extra.data_race {\n             data_race.read(alloc_id, range, machine)?;\n         }\n-        if let Some(stacked_borrows) = &alloc_extra.stacked_borrows {\n-            stacked_borrows\n-                .borrow_mut()\n-                .before_memory_read(alloc_id, prov_extra, range, machine)?;\n+        if let Some(borrow_tracker) = &alloc_extra.borrow_tracker {\n+            borrow_tracker.before_memory_read(alloc_id, prov_extra, range, machine)?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n             weak_memory.memory_accessed(range, machine.data_race.as_ref().unwrap());\n@@ -1040,8 +1025,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         if let Some(data_race) = &mut alloc_extra.data_race {\n             data_race.write(alloc_id, range, machine)?;\n         }\n-        if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n-            stacked_borrows.get_mut().before_memory_write(alloc_id, prov_extra, range, machine)?;\n+        if let Some(borrow_tracker) = &mut alloc_extra.borrow_tracker {\n+            borrow_tracker.before_memory_write(alloc_id, prov_extra, range, machine)?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n             weak_memory.memory_accessed(range, machine.data_race.as_ref().unwrap());\n@@ -1063,16 +1048,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         if let Some(data_race) = &mut alloc_extra.data_race {\n             data_race.deallocate(alloc_id, range, machine)?;\n         }\n-        if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n-            stacked_borrows.get_mut().before_memory_deallocation(\n-                alloc_id,\n-                prove_extra,\n-                range,\n-                machine,\n-            )\n-        } else {\n-            Ok(())\n+        if let Some(borrow_tracker) = &mut alloc_extra.borrow_tracker {\n+            borrow_tracker.before_memory_deallocation(alloc_id, prove_extra, range, machine)?;\n         }\n+        Ok(())\n     }\n \n     #[inline(always)]\n@@ -1081,7 +1060,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         kind: mir::RetagKind,\n         place: &PlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx> {\n-        if ecx.machine.stacked_borrows.is_some() { ecx.retag(kind, place) } else { Ok(()) }\n+        if ecx.machine.borrow_tracker.is_some() {\n+            ecx.retag(kind, place)?;\n+        }\n+        Ok(())\n     }\n \n     #[inline(always)]\n@@ -1104,10 +1086,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             None\n         };\n \n-        let stacked_borrows = ecx.machine.stacked_borrows.as_ref();\n+        let borrow_tracker = ecx.machine.borrow_tracker.as_ref();\n \n         let extra = FrameData {\n-            stacked_borrows: stacked_borrows.map(|sb| sb.borrow_mut().new_frame(&ecx.machine)),\n+            borrow_tracker: borrow_tracker.map(|bt| bt.borrow_mut().new_frame(&ecx.machine)),\n             catch_unwind: None,\n             timing,\n             is_user_relevant: ecx.machine.is_user_relevant(&frame),\n@@ -1140,7 +1122,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             }\n         }\n \n-        // Search for SbTags to find all live pointers, then remove all other tags from borrow\n+        // Search for BorTags to find all live pointers, then remove all other tags from borrow\n         // stacks.\n         // When debug assertions are enabled, run the GC as often as possible so that any cases\n         // where it mistakenly removes an important tag become visible.\n@@ -1166,8 +1148,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             let stack_len = ecx.active_thread_stack().len();\n             ecx.active_thread_mut().set_top_user_relevant_frame(stack_len - 1);\n         }\n-\n-        if ecx.machine.stacked_borrows.is_some() { ecx.retag_return_place() } else { Ok(()) }\n+        if ecx.machine.borrow_tracker.is_some() {\n+            ecx.retag_return_place()?;\n+        }\n+        Ok(())\n     }\n \n     #[inline(always)]\n@@ -1184,8 +1168,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             ecx.active_thread_mut().recompute_top_user_relevant_frame();\n         }\n         let timing = frame.extra.timing.take();\n-        if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n-            stacked_borrows.borrow_mut().end_call(&frame.extra);\n+        if let Some(borrow_tracker) = &ecx.machine.borrow_tracker {\n+            borrow_tracker.borrow_mut().end_call(&frame.extra);\n         }\n         let res = ecx.handle_stack_pop_unwind(frame.extra, unwinding);\n         if let Some(profiler) = ecx.machine.profiler.as_ref() {"}, {"sha": "c1194fe22163a65cbe8977e849e73161dcc0c48c", "filename": "src/tools/miri/src/tag_gc.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bb3d9e94a74dec560e520659c45c82ab3ba0566/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb3d9e94a74dec560e520659c45c82ab3ba0566/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs?ref=8bb3d9e94a74dec560e520659c45c82ab3ba0566", "patch": "@@ -154,7 +154,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n     fn garbage_collect_tags(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         // No reason to do anything at all if stacked borrows is off.\n-        if this.machine.stacked_borrows.is_none() {\n+        if this.machine.borrow_tracker.is_none() {\n             return Ok(());\n         }\n \n@@ -167,17 +167,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n         Ok(())\n     }\n \n-    fn remove_unreachable_tags(&mut self, tags: FxHashSet<SbTag>) {\n+    fn remove_unreachable_tags(&mut self, tags: FxHashSet<BorTag>) {\n         let this = self.eval_context_mut();\n         this.memory.alloc_map().iter(|it| {\n             for (_id, (_kind, alloc)) in it {\n-                alloc\n-                    .extra\n-                    .stacked_borrows\n-                    .as_ref()\n-                    .unwrap()\n-                    .borrow_mut()\n-                    .remove_unreachable_tags(&tags);\n+                if let Some(bt) = &alloc.extra.borrow_tracker {\n+                    bt.remove_unreachable_tags(&tags);\n+                }\n             }\n         });\n     }"}]}