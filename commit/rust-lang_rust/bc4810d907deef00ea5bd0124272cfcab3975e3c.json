{"sha": "bc4810d907deef00ea5bd0124272cfcab3975e3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjNDgxMGQ5MDdkZWVmMDBlYTViZDAxMjQyNzJjZmNhYjM5NzVlM2M=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2017-10-15T20:43:06Z"}, "committer": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2017-11-17T18:01:54Z"}, "message": "Fix impl Trait Lifetime Handling\n\nAfter this change, impl Trait existentials are\ndesugared to a new `abstract type` definition\npaired with a set of lifetimes to apply.\n\nIn-scope generics are included as parents of the\n`abstract type` generics. Parent regions are\nreplaced with static, and parent regions\nreferenced in the `impl Trait` type are duplicated\nat the end of the `abstract type`'s generics.", "tree": {"sha": "14291c299a2c2c03333500a0952d7512398488ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14291c299a2c2c03333500a0952d7512398488ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc4810d907deef00ea5bd0124272cfcab3975e3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc4810d907deef00ea5bd0124272cfcab3975e3c", "html_url": "https://github.com/rust-lang/rust/commit/bc4810d907deef00ea5bd0124272cfcab3975e3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc4810d907deef00ea5bd0124272cfcab3975e3c/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0f8e2913a93573c78cddfd297944cff4eb4c41a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0f8e2913a93573c78cddfd297944cff4eb4c41a", "html_url": "https://github.com/rust-lang/rust/commit/d0f8e2913a93573c78cddfd297944cff4eb4c41a"}], "stats": {"total": 1017, "additions": 884, "deletions": 133}, "files": [{"sha": "75ef3fc0c3d2d28399fbb1f9d332ed395224ee75", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -2019,4 +2019,5 @@ register_diagnostics! {\n     E0628, // generators cannot have explicit arguments\n     E0631, // type mismatch in closure arguments\n     E0637, // \"'_\" is not a valid lifetime bound\n+    E0657, // `impl Trait` can only capture lifetimes bound at the fn level\n }"}, {"sha": "c9d35158ed002c8565043fbcd0d04a2d791861bf", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -591,8 +591,11 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             }\n             visitor.visit_lifetime(lifetime);\n         }\n-        TyImplTraitExistential(ref bounds) => {\n+        TyImplTraitExistential(ref existty, ref lifetimes) => {\n+            let ExistTy { ref generics, ref bounds } = *existty;\n+            walk_generics(visitor, generics);\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_lifetime, lifetimes);\n         }\n         TyImplTraitUniversal(_, ref bounds) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);"}, {"sha": "3e527f43fec20d9673ec57dc4e33cc146d7bf883", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 127, "deletions": 4, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -42,8 +42,9 @@\n \n use dep_graph::DepGraph;\n use hir;\n-use hir::map::{Definitions, DefKey};\n-use hir::def_id::{DefIndex, DefId, CRATE_DEF_INDEX};\n+use hir::HirVec;\n+use hir::map::{Definitions, DefKey, DefPathData};\n+use hir::def_id::{DefIndex, DefId, CRATE_DEF_INDEX, DefIndexAddressSpace};\n use hir::def::{Def, PathResolution};\n use lint::builtin::PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES;\n use middle::cstore::CrateStore;\n@@ -52,7 +53,7 @@ use session::Session;\n use util::common::FN_OUTPUT_NAME;\n use util::nodemap::{DefIdMap, FxHashMap, NodeMap};\n \n-use std::collections::BTreeMap;\n+use std::collections::{BTreeMap, HashSet};\n use std::fmt::Debug;\n use std::iter;\n use std::mem;\n@@ -777,7 +778,24 @@ impl<'a> LoweringContext<'a> {\n                                              t.span, GateIssue::Language,\n                                              \"`impl Trait` in return position is experimental\");\n                         }\n-                        hir::TyImplTraitExistential(self.lower_bounds(bounds, itctx))\n+                        let def_index = self.resolver.definitions().opt_def_index(t.id).unwrap();\n+                        let hir_bounds = self.lower_bounds(bounds, itctx);\n+                        let (lifetimes, lifetime_defs) =\n+                            self.lifetimes_from_impl_trait_bounds(def_index, &hir_bounds);\n+\n+                        hir::TyImplTraitExistential(hir::ExistTy {\n+                            generics: hir::Generics {\n+                                lifetimes: lifetime_defs,\n+                                // Type parameters are taken from environment:\n+                                ty_params: Vec::new().into(),\n+                                where_clause: hir::WhereClause {\n+                                    id: self.next_id().node_id,\n+                                    predicates: Vec::new().into(),\n+                                },\n+                                span: t.span,\n+                            },\n+                            bounds: hir_bounds,\n+                        }, lifetimes)\n                     },\n                     ImplTraitContext::Universal(def_id) => {\n                         let has_feature = self.sess.features.borrow().universal_impl_trait;\n@@ -808,6 +826,111 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n+    fn lifetimes_from_impl_trait_bounds(\n+        &mut self,\n+        parent_index: DefIndex,\n+        bounds: &hir::TyParamBounds\n+    ) -> (HirVec<hir::Lifetime>, HirVec<hir::LifetimeDef>) {\n+\n+        // This visitor walks over impl trait bounds and creates defs for all lifetimes which\n+        // appear in the bounds, excluding lifetimes that are created within the bounds.\n+        // e.g. 'a, 'b, but not 'c in `impl for<'c> SomeTrait<'a, 'b, 'c>`\n+        struct ImplTraitLifetimeCollector<'r, 'a: 'r> {\n+            context: &'r mut LoweringContext<'a>,\n+            parent: DefIndex,\n+            currently_bound_lifetimes: Vec<Name>,\n+            already_defined_lifetimes: HashSet<Name>,\n+            output_lifetimes: Vec<hir::Lifetime>,\n+            output_lifetime_defs: Vec<hir::LifetimeDef>,\n+        }\n+\n+        impl<'r, 'a: 'r, 'v> hir::intravisit::Visitor<'v> for ImplTraitLifetimeCollector<'r, 'a> {\n+            fn nested_visit_map<'this>(&'this mut self)\n+                -> hir::intravisit::NestedVisitorMap<'this, 'v> {\n+                hir::intravisit::NestedVisitorMap::None\n+            }\n+\n+            fn visit_poly_trait_ref(&mut self,\n+                                    polytr: &'v hir::PolyTraitRef,\n+                                    _: hir::TraitBoundModifier) {\n+                let old_len = self.currently_bound_lifetimes.len();\n+\n+                // Record the introduction of 'a in `for<'a> ...`\n+                for lt_def in &polytr.bound_lifetimes {\n+                    // Introduce lifetimes one at a time so that we can handle\n+                    // cases like `fn foo<'d>() -> impl for<'a, 'b: 'a, 'c: 'b + 'd> ...`\n+                    if let hir::LifetimeName::Name(name) = lt_def.lifetime.name {\n+                        self.currently_bound_lifetimes.push(name);\n+                    }\n+\n+                    // Visit the lifetime bounds\n+                    for lt_bound in &lt_def.bounds {\n+                        self.visit_lifetime(&lt_bound);\n+                    }\n+                }\n+\n+                hir::intravisit::walk_trait_ref(self, &polytr.trait_ref);\n+\n+                self.currently_bound_lifetimes.truncate(old_len);\n+            }\n+\n+            fn visit_lifetime(&mut self, lifetime: &'v hir::Lifetime) {\n+                // Exclude '_, 'static, and elided lifetimes (there should be no elided lifetimes)\n+                if let hir::LifetimeName::Name(lifetime_name) = lifetime.name {\n+                    if !self.currently_bound_lifetimes.contains(&lifetime_name) &&\n+                       !self.already_defined_lifetimes.contains(&lifetime_name)\n+                    {\n+                        self.already_defined_lifetimes.insert(lifetime_name);\n+                        let name = hir::LifetimeName::Name(lifetime_name);\n+\n+                        self.output_lifetimes.push(hir::Lifetime {\n+                            id: self.context.next_id().node_id,\n+                            span: lifetime.span,\n+                            name,\n+                        });\n+\n+                        let def_node_id = self.context.next_id().node_id;\n+                        self.context.resolver.definitions().create_def_with_parent(\n+                            self.parent,\n+                            def_node_id,\n+                            DefPathData::LifetimeDef(lifetime_name.as_str()),\n+                            DefIndexAddressSpace::High,\n+                            Mark::root()\n+                        );\n+                        let def_lifetime = hir::Lifetime {\n+                            id: def_node_id,\n+                            span: lifetime.span,\n+                            name,\n+                        };\n+                        self.output_lifetime_defs.push(hir::LifetimeDef {\n+                            lifetime: def_lifetime,\n+                            bounds: Vec::new().into(),\n+                            pure_wrt_drop: false,\n+                        });\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut lifetime_collector = ImplTraitLifetimeCollector {\n+            context: self,\n+            parent: parent_index,\n+            currently_bound_lifetimes: Vec::new(),\n+            already_defined_lifetimes: HashSet::new(),\n+            output_lifetimes: Vec::new(),\n+            output_lifetime_defs: Vec::new(),\n+        };\n+\n+        for bound in bounds {\n+            hir::intravisit::walk_ty_param_bound(&mut lifetime_collector, &bound);\n+        }\n+\n+        (\n+            lifetime_collector.output_lifetimes.into(),\n+            lifetime_collector.output_lifetime_defs.into()\n+        )\n+    }\n+\n     fn lower_foreign_mod(&mut self, fm: &ForeignMod) -> hir::ForeignMod {\n         hir::ForeignMod {\n             abi: fm.abi,"}, {"sha": "563fba52aefca4b13331e6b300fdb891c1adb60b", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -1436,6 +1436,12 @@ pub struct BareFnTy {\n     pub arg_names: HirVec<Spanned<Name>>,\n }\n \n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct ExistTy {\n+    pub generics: Generics,\n+    pub bounds: TyParamBounds,\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n /// The different kinds of types recognized by the compiler\n pub enum Ty_ {\n@@ -1463,7 +1469,16 @@ pub enum Ty_ {\n     TyTraitObject(HirVec<PolyTraitRef>, Lifetime),\n     /// An exsitentially quantified (there exists a type satisfying) `impl\n     /// Bound1 + Bound2 + Bound3` type where `Bound` is a trait or a lifetime.\n-    TyImplTraitExistential(TyParamBounds),\n+    ///\n+    /// The `ExistTy` structure emulates an\n+    /// `abstract type Foo<'a, 'b>: MyTrait<'a, 'b>;`.\n+    ///\n+    /// The `HirVec<Lifetime>` is the list of lifetimes applied as parameters\n+    /// to the `abstract type`, e.g. the `'c` and `'d` in `-> Foo<'c, 'd>`.\n+    /// This list is only a list of lifetimes and not type parameters\n+    /// because all in-scope type parameters are captured by `impl Trait`,\n+    /// so they are resolved directly through the parent `Generics`.\n+    TyImplTraitExistential(ExistTy, HirVec<Lifetime>),\n     /// An universally quantified (for all types satisfying) `impl\n     /// Bound1 + Bound2 + Bound3` type where `Bound` is a trait or a lifetime.\n     TyImplTraitUniversal(DefId, TyParamBounds),"}, {"sha": "d94dd24af3edc74277110793b5c7a9e6449ee334", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -421,8 +421,10 @@ impl<'a> State<'a> {\n                     self.print_lifetime(lifetime)?;\n                 }\n             }\n-            hir::TyImplTraitExistential(ref bounds) |\n-                hir::TyImplTraitUniversal(_, ref bounds) => {\n+            hir::TyImplTraitExistential(ref existty, ref _lifetimes) => {\n+                self.print_bounds(\"impl\", &existty.bounds[..])?;\n+            }\n+            hir::TyImplTraitUniversal(_, ref bounds) => {\n                 self.print_bounds(\"impl\", &bounds[..])?;\n             }\n             hir::TyArray(ref ty, v) => {"}, {"sha": "8d4979dc8c2a07ca56b5083629ad5a12381851dc", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -277,6 +277,11 @@ impl_stable_hash_for!(struct hir::BareFnTy {\n     arg_names\n });\n \n+impl_stable_hash_for!(struct hir::ExistTy {\n+    generics,\n+    bounds\n+});\n+\n impl_stable_hash_for!(enum hir::Ty_ {\n     TySlice(t),\n     TyArray(t, body_id),\n@@ -287,7 +292,7 @@ impl_stable_hash_for!(enum hir::Ty_ {\n     TyTup(ts),\n     TyPath(qpath),\n     TyTraitObject(trait_refs, lifetime),\n-    TyImplTraitExistential(bounds),\n+    TyImplTraitExistential(existty, lifetimes),\n     TyImplTraitUniversal(def_id, bounds),\n     TyTypeof(body_id),\n     TyErr,"}, {"sha": "89c3f1668474a498906fce1aa87bc4b476c44068", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -84,7 +84,7 @@ impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n                 (&ty::ReFree(_), &ty::ReEarlyBound(_)) |\n                 (&ty::ReEarlyBound(_), &ty::ReFree(_)) |\n                 (&ty::ReFree(_), &ty::ReFree(_)) =>\n-                    self.free_regions.relation.contains(&sub_region, &super_region),\n+                    self.free_regions.sub_free_regions(&sub_region, &super_region),\n \n                 _ =>\n                     false,\n@@ -158,19 +158,39 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         }\n     }\n \n-    // Record that `'sup:'sub`. Or, put another way, `'sub <= 'sup`.\n-    // (with the exception that `'static: 'x` is not notable)\n+    /// Record that `'sup:'sub`. Or, put another way, `'sub <= 'sup`.\n+    /// (with the exception that `'static: 'x` is not notable)\n     pub fn relate_regions(&mut self, sub: Region<'tcx>, sup: Region<'tcx>) {\n+        debug!(\"relate_regions(sub={:?}, sup={:?})\", sub, sup);\n         if (is_free(sub) || *sub == ty::ReStatic) && is_free(sup) {\n             self.relation.add(sub, sup)\n         }\n     }\n \n+    /// True if `r_a <= r_b` is known to hold. Both `r_a` and `r_b`\n+    /// must be free regions from the function header.\n+    pub fn sub_free_regions<'a, 'gcx>(&self,\n+                                      r_a: Region<'tcx>,\n+                                      r_b: Region<'tcx>)\n+                                      -> bool {\n+        debug!(\"sub_free_regions(r_a={:?}, r_b={:?})\", r_a, r_b);\n+        assert!(is_free(r_a));\n+        assert!(is_free(r_b));\n+        let result = r_a == r_b || self.relation.contains(&r_a, &r_b);\n+        debug!(\"sub_free_regions: result={}\", result);\n+        result\n+    }\n+\n+    /// Compute the least-upper-bound of two free regions. In some\n+    /// cases, this is more conservative than necessary, in order to\n+    /// avoid making arbitrary choices. See\n+    /// `TransitiveRelation::postdom_upper_bound` for more details.\n     pub fn lub_free_regions<'a, 'gcx>(&self,\n                                       tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                       r_a: Region<'tcx>,\n                                       r_b: Region<'tcx>)\n                                       -> Region<'tcx> {\n+        debug!(\"lub_free_regions(r_a={:?}, r_b={:?})\", r_a, r_b);\n         assert!(is_free(r_a));\n         assert!(is_free(r_b));\n         let result = if r_a == r_b { r_a } else {"}, {"sha": "7ed646bb9dd756def3c835f087f2a67d20ccbbf0", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 103, "deletions": 9, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -52,6 +52,7 @@ impl Region {\n         let i = *index;\n         *index += 1;\n         let def_id = hir_map.local_def_id(def.lifetime.id);\n+        debug!(\"Region::early: index={} def_id={:?}\", i, def_id);\n         (def.lifetime.name, Region::EarlyBound(i, def_id))\n     }\n \n@@ -201,6 +202,11 @@ enum Scope<'a> {\n     /// declaration `Binder` and the location it's referenced from.\n     Binder {\n         lifetimes: FxHashMap<hir::LifetimeName, Region>,\n+\n+        /// if we extend this scope with another scope, what is the next index\n+        /// we should use for an early-bound region?\n+        next_early_index: u32,\n+\n         s: ScopeRef<'a>\n     },\n \n@@ -343,8 +349,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let lifetimes = generics.lifetimes.iter().map(|def| {\n                     Region::early(self.hir_map, &mut index, def)\n                 }).collect();\n+                let next_early_index = index + generics.ty_params.len() as u32;\n                 let scope = Scope::Binder {\n                     lifetimes,\n+                    next_early_index,\n                     s: ROOT_SCOPE\n                 };\n                 self.with(scope, |old_scope, this| {\n@@ -372,12 +380,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n+        debug!(\"visit_ty: ty={:?}\", ty);\n         match ty.node {\n             hir::TyBareFn(ref c) => {\n+                let next_early_index = self.next_early_index();\n                 let scope = Scope::Binder {\n                     lifetimes: c.lifetimes.iter().map(|def| {\n-                            Region::late(self.hir_map, def)\n-                        }).collect(),\n+                        Region::late(self.hir_map, def)\n+                    }).collect(),\n+                    next_early_index,\n                     s: self.scope\n                 };\n                 self.with(scope, |old_scope, this| {\n@@ -405,6 +416,60 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 };\n                 self.with(scope, |_, this| this.visit_ty(&mt.ty));\n             }\n+            hir::TyImplTraitExistential(ref exist_ty, ref lifetimes) => {\n+                // Resolve the lifetimes that are applied to the existential type.\n+                // These are resolved in the current scope.\n+                // `fn foo<'a>() -> impl MyTrait<'a> { ... }` desugars to\n+                // `fn foo<'a>() -> MyAnonTy<'a> { ... }`\n+                //          ^                 ^this gets resolved in the current scope\n+                for lifetime in lifetimes {\n+                    self.visit_lifetime(lifetime);\n+\n+                    // Check for predicates like `impl for<'a> SomeTrait<impl OtherTrait<'a>>`\n+                    // and ban them. Type variables instantiated inside binders aren't\n+                    // well-supported at the moment, so this doesn't work.\n+                    // In the future, this should be fixed and this error should be removed.\n+                    let def = self.map.defs.get(&lifetime.id);\n+                    if let Some(&Region::LateBound(_, def_id)) = def {\n+                        if let Some(node_id) = self.hir_map.as_local_node_id(def_id) {\n+                            // Ensure that the parent of the def is an item, not HRTB\n+                            let parent_id = self.hir_map.get_parent_node(node_id);\n+                            let parent_impl_id = hir::ImplItemId { node_id: parent_id };\n+                            let parent_trait_id = hir::TraitItemId { node_id: parent_id };\n+                            let krate = self.hir_map.forest.krate();\n+                            if !(krate.items.contains_key(&parent_id) ||\n+                                 krate.impl_items.contains_key(&parent_impl_id) ||\n+                                 krate.trait_items.contains_key(&parent_trait_id))\n+                            {\n+                                span_err!(self.sess, lifetime.span, E0657,\n+                                  \"`impl Trait` can only capture lifetimes \\\n+                                  bound at the fn or impl level\");\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // Resolve the lifetimes in the bounds to the lifetime defs in the generics.\n+                // `fn foo<'a>() -> impl MyTrait<'a> { ... }` desugars to\n+                // `abstract type MyAnonTy<'b>: MyTrait<'b>;`\n+                //                          ^            ^ this gets resolved in the scope of\n+                //                                         the exist_ty generics\n+                let hir::ExistTy { ref generics, ref bounds } = *exist_ty;\n+                let mut index = self.next_early_index();\n+                debug!(\"visit_ty: index = {}\", index);\n+                let lifetimes = generics.lifetimes.iter()\n+                    .map(|lt_def| Region::early(self.hir_map, &mut index, lt_def))\n+                    .collect();\n+\n+                let next_early_index = index + generics.ty_params.len() as u32;\n+                let scope = Scope::Binder { lifetimes, next_early_index, s: self.scope };\n+                self.with(scope, |_old_scope, this| {\n+                    this.visit_generics(generics);\n+                    for bound in bounds {\n+                        this.visit_ty_param_bound(bound);\n+                    }\n+                });\n+            }\n             _ => {\n                 intravisit::walk_ty(self, ty)\n             }\n@@ -477,10 +542,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                                                                .. }) => {\n                     if !bound_lifetimes.is_empty() {\n                         self.trait_ref_hack = true;\n+                        let next_early_index = self.next_early_index();\n                         let scope = Scope::Binder {\n                             lifetimes: bound_lifetimes.iter().map(|def| {\n                                     Region::late(self.hir_map, def)\n-                                }).collect(),\n+                            }).collect(),\n+                            next_early_index,\n                             s: self.scope\n                         };\n                         let result = self.with(scope, |old_scope, this| {\n@@ -524,10 +591,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 span_err!(self.sess, trait_ref.span, E0316,\n                           \"nested quantification of lifetimes\");\n             }\n+            let next_early_index = self.next_early_index();\n             let scope = Scope::Binder {\n                 lifetimes: trait_ref.bound_lifetimes.iter().map(|def| {\n                         Region::late(self.hir_map, def)\n-                    }).collect(),\n+                }).collect(),\n+                next_early_index,\n                 s: self.scope\n             };\n             self.with(scope, |old_scope, this| {\n@@ -659,7 +728,7 @@ fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n \n                 Scope::Root => { return; }\n \n-                Scope::Binder { ref lifetimes, s } => {\n+                Scope::Binder { ref lifetimes, s, next_early_index: _ } => {\n                     // FIXME (#24278): non-hygienic comparison\n                     if let Some(def) = lifetimes.get(&hir::LifetimeName::Name(label)) {\n                         let node_id = hir_map.as_local_node_id(def.id().unwrap())\n@@ -860,8 +929,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         }).collect();\n \n+        let next_early_index = index + generics.ty_params.len() as u32;\n+\n         let scope = Scope::Binder {\n             lifetimes,\n+            next_early_index,\n             s: self.scope\n         };\n         self.with(scope, move |old_scope, this| {\n@@ -870,7 +942,29 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         });\n     }\n \n+    /// Returns the next index one would use for an early-bound-region\n+    /// if extending the current scope.\n+    fn next_early_index(&self) -> u32 {\n+        let mut scope = self.scope;\n+        loop {\n+            match *scope {\n+                Scope::Root =>\n+                    return 0,\n+\n+                Scope::Binder { next_early_index, .. } =>\n+                    return next_early_index,\n+\n+                Scope::Body { s, .. } |\n+                Scope::Elision { s, .. } |\n+                Scope::ObjectLifetimeDefault { s, .. } =>\n+                    scope = s,\n+            }\n+        }\n+    }\n+\n     fn resolve_lifetime_ref(&mut self, lifetime_ref: &hir::Lifetime) {\n+        debug!(\"resolve_lifetime_ref(lifetime_ref={:?})\", lifetime_ref);\n+\n         // Walk up the scope chain, tracking the number of fn scopes\n         // that we pass through, until we find a lifetime with the\n         // given name or we run out of scopes.\n@@ -889,7 +983,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     break None;\n                 }\n \n-                Scope::Binder { ref lifetimes, s } => {\n+                Scope::Binder { ref lifetimes, s, next_early_index: _ } => {\n                     if let Some(&def) = lifetimes.get(&lifetime_ref.name) {\n                         break Some(def.shifted(late_depth));\n                     } else {\n@@ -1520,7 +1614,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     return;\n                 }\n \n-                Scope::Binder { ref lifetimes, s } => {\n+                Scope::Binder { ref lifetimes, s, next_early_index: _ } => {\n                     if let Some(&def) = lifetimes.get(&lifetime.name) {\n                         let node_id = self.hir_map\n                                           .as_local_node_id(def.id().unwrap())\n@@ -1549,7 +1643,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                        probably a bug in syntax::fold\");\n         }\n \n-        debug!(\"{} resolved to {:?} span={:?}\",\n+        debug!(\"insert_lifetime: {} resolved to {:?} span={:?}\",\n                self.hir_map.node_to_string(lifetime_ref.id),\n                def,\n                self.sess.codemap().span_to_string(lifetime_ref.span));\n@@ -1709,7 +1803,7 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n         }\n \n         fn visit_ty(&mut self, ty: &hir::Ty) {\n-            if let hir::TyImplTraitExistential(_) = ty.node {\n+            if let hir::TyImplTraitExistential(..) = ty.node {\n                 self.impl_trait = true;\n             }\n             intravisit::walk_ty(self, ty);"}, {"sha": "80b113dfdf5a5f2b6404ce66ed4ed53c47fc93a1", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -220,11 +220,11 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         tcx.intern_substs(&result)\n     }\n \n-    fn fill_item<FR, FT>(substs: &mut Vec<Kind<'tcx>>,\n-                         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                         defs: &ty::Generics,\n-                         mk_region: &mut FR,\n-                         mk_type: &mut FT)\n+    pub fn fill_item<FR, FT>(substs: &mut Vec<Kind<'tcx>>,\n+                             tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                             defs: &ty::Generics,\n+                             mk_region: &mut FR,\n+                             mk_type: &mut FT)\n     where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> ty::Region<'tcx>,\n           FT: FnMut(&ty::TypeParameterDef, &[Kind<'tcx>]) -> Ty<'tcx> {\n "}, {"sha": "4b0cf018cb52495bcbc9d5d8083e9aacb673b393", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -1015,6 +1015,10 @@ define_print! {\n                 TyForeign(def_id) => parameterized(f, subst::Substs::empty(), def_id, &[]),\n                 TyProjection(ref data) => data.print(f, cx),\n                 TyAnon(def_id, substs) => {\n+                    if cx.is_verbose {\n+                        return write!(f, \"TyAnon({:?}, {:?})\", def_id, substs);\n+                    }\n+\n                     ty::tls::with(|tcx| {\n                         // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                         // by looking up the projections associated with the def_id."}, {"sha": "d8bdd21a2a07701a7d9e06919d9c4de6a3aba7df", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -1487,7 +1487,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n \n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n         match ty.node {\n-            hir::TyImplTraitExistential(_) => {\n+            hir::TyImplTraitExistential(..) => {\n                 let def_id = self.tcx.hir.local_def_id(ty.id);\n                 self.record(def_id, IsolatedEncoder::encode_info_for_anon_ty, def_id);\n             }"}, {"sha": "2405461741daa7c75f4334df6f5e94e7837a63d3", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -21,7 +21,7 @@ use middle::resolve_lifetime as rl;\n use namespace::Namespace;\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits;\n-use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n+use rustc::ty::{self, RegionKind, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::wf::object_region_bounds;\n use rustc_back::slice;\n use require_c_abi_if_variadic;\n@@ -1034,9 +1034,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyTraitObject(ref bounds, ref lifetime) => {\n                 self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime)\n             }\n-            hir::TyImplTraitExistential(_) => {\n+            hir::TyImplTraitExistential(_, ref lifetimes) => {\n                 let def_id = tcx.hir.local_def_id(ast_ty.id);\n-                tcx.mk_anon(def_id, Substs::identity_for_item(tcx, def_id))\n+                self.impl_trait_ty_to_ty(def_id, lifetimes)\n             }\n             hir::TyImplTraitUniversal(fn_def_id, _) => {\n                 let impl_trait_def_id = tcx.hir.local_def_id(ast_ty.id);\n@@ -1097,6 +1097,43 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         result_ty\n     }\n \n+    pub fn impl_trait_ty_to_ty(&self, def_id: DefId, lifetimes: &[hir::Lifetime]) -> Ty<'tcx> {\n+        debug!(\"impl_trait_ty_to_ty(def_id={:?}, lifetimes={:?})\", def_id, lifetimes);\n+        let tcx = self.tcx();\n+        let generics = tcx.generics_of(def_id);\n+\n+        // Fill in the substs of the parent generics\n+        debug!(\"impl_trait_ty_to_ty: generics={:?}\", generics);\n+        let mut substs = Vec::with_capacity(generics.count());\n+        if let Some(parent_id) = generics.parent {\n+            let parent_generics = tcx.generics_of(parent_id);\n+            Substs::fill_item(\n+                &mut substs, tcx, parent_generics,\n+                &mut |def, _| tcx.mk_region(\n+                    ty::ReEarlyBound(def.to_early_bound_region_data())),\n+                &mut |def, _| tcx.mk_param_from_def(def)\n+            );\n+\n+            // Replace all lifetimes with 'static\n+            for subst in &mut substs {\n+                if let Some(_) = subst.as_region() {\n+                    *subst = Kind::from(&RegionKind::ReStatic);\n+                }\n+            }\n+            debug!(\"impl_trait_ty_to_ty: substs from parent = {:?}\", substs);\n+        }\n+        assert_eq!(substs.len(), generics.parent_count());\n+\n+        // Fill in our own generics with the resolved lifetimes\n+        assert_eq!(lifetimes.len(), generics.own_count());\n+        substs.extend(lifetimes.iter().map(|lt|\n+            Kind::from(self.ast_region_to_region(lt, None))));\n+\n+        debug!(\"impl_trait_ty_to_ty: final substs = {:?}\", substs);\n+\n+        tcx.mk_anon(def_id, tcx.intern_substs(&substs))\n+    }\n+\n     pub fn ty_of_arg(&self,\n                      ty: &hir::Ty,\n                      expected_ty: Option<Ty<'tcx>>)"}, {"sha": "0cb1408a450b511af17f57fbe00064177d6516b5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 65, "deletions": 8, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -213,7 +213,7 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // associated fresh inference variable. Writeback resolves these\n     // variables to get the concrete type, which can be used to\n     // deanonymize TyAnon, after typeck is done with all functions.\n-    anon_types: RefCell<NodeMap<Ty<'tcx>>>,\n+    anon_types: RefCell<DefIdMap<AnonTypeDecl<'tcx>>>,\n \n     /// Each type parameter has an implicit region bound that\n     /// indicates it must outlive at least the function body (the user\n@@ -226,6 +226,43 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     body_id: Option<hir::BodyId>,\n }\n \n+/// Information about the anonymous, abstract types whose values we\n+/// are inferring in this function (these are the `impl Trait` that\n+/// appear in the return type).\n+#[derive(Debug)]\n+struct AnonTypeDecl<'tcx> {\n+    /// The substitutions that we apply to the abstract that that this\n+    /// `impl Trait` desugars to. e.g., if:\n+    ///\n+    ///     fn foo<'a, 'b, T>() -> impl Trait<'a>\n+    ///\n+    /// winds up desugared to:\n+    ///\n+    ///     abstract type Foo<'x, T>: Trait<'x>\n+    ///     fn foo<'a, 'b, T>() -> Foo<'a, T>\n+    ///\n+    /// then `substs` would be `['a, T]`.\n+    substs: &'tcx Substs<'tcx>,\n+\n+    /// The type variable that represents the value of the abstract type\n+    /// that we require. In other words, after we compile this function,\n+    /// we will be created a constraint like:\n+    ///\n+    ///     Foo<'a, T> = ?C\n+    ///\n+    /// where `?C` is the value of this type variable. =) It may\n+    /// naturally refer to the type and lifetime parameters in scope\n+    /// in this function, though ultimately it should only reference\n+    /// those that are arguments to `Foo` in the constraint above. (In\n+    /// other words, `?C` should not include `'b`, even though it's a\n+    /// lifetime parameter on `foo`.)\n+    concrete_ty: Ty<'tcx>,\n+\n+    /// A list of all required region bounds on the impl Trait type,\n+    /// e.g. `'a` and `'b` in `fn foo<'a, 'b, 'c>() -> impl Trait<'c> + 'a + 'b`.\n+    required_region_bounds: Vec<ty::Region<'tcx>>,\n+}\n+\n impl<'a, 'gcx, 'tcx> Deref for Inherited<'a, 'gcx, 'tcx> {\n     type Target = InferCtxt<'a, 'gcx, 'tcx>;\n     fn deref(&self) -> &Self::Target {\n@@ -622,7 +659,7 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n             deferred_generator_interiors: RefCell::new(Vec::new()),\n-            anon_types: RefCell::new(NodeMap()),\n+            anon_types: RefCell::new(DefIdMap()),\n             implicit_region_bound,\n             body_id,\n         }\n@@ -870,7 +907,10 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                   param_env,\n                                                   &fn_sig);\n \n-            check_fn(&inh, param_env, fn_sig, decl, id, body, false).0\n+            let fcx = check_fn(&inh, param_env, fn_sig, decl, id, body, false).0;\n+            // Ensure anon_types have been instantiated prior to entering regionck\n+            fcx.instantiate_anon_types(&fn_sig.output());\n+            fcx\n         } else {\n             let fcx = FnCtxt::new(&inh, param_env, body.value.id);\n             let expected_type = tcx.type_of(def_id);\n@@ -1909,20 +1949,34 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// Replace all anonymized types with fresh inference variables\n     /// and record them for writeback.\n     fn instantiate_anon_types<T: TypeFoldable<'tcx>>(&self, value: &T) -> T {\n+        debug!(\"instantiate_anon_types(value={:?})\", value);\n         value.fold_with(&mut BottomUpFolder { tcx: self.tcx, fldop: |ty| {\n             if let ty::TyAnon(def_id, substs) = ty.sty {\n+                debug!(\"instantiate_anon_types: TyAnon(def_id={:?}, substs={:?})\", def_id, substs);\n+\n                 // Use the same type variable if the exact same TyAnon appears more\n                 // than once in the return type (e.g. if it's passed to a type alias).\n-                let id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n-                if let Some(ty_var) = self.anon_types.borrow().get(&id) {\n-                    return ty_var;\n+                if let Some(anon_defn) = self.anon_types.borrow().get(&def_id) {\n+                    return anon_defn.concrete_ty;\n                 }\n                 let span = self.tcx.def_span(def_id);\n                 let ty_var = self.next_ty_var(TypeVariableOrigin::TypeInference(span));\n-                self.anon_types.borrow_mut().insert(id, ty_var);\n \n                 let predicates_of = self.tcx.predicates_of(def_id);\n                 let bounds = predicates_of.instantiate(self.tcx, substs);\n+                debug!(\"instantiate_anon_types: bounds={:?}\", bounds);\n+\n+                let required_region_bounds =\n+                    self.tcx.required_region_bounds(ty, bounds.predicates.clone());\n+                debug!(\"instantiate_anon_types: required_region_bounds={:?}\",\n+                       required_region_bounds);\n+\n+                self.anon_types.borrow_mut().insert(def_id, AnonTypeDecl {\n+                    substs,\n+                    concrete_ty: ty_var,\n+                    required_region_bounds,\n+                });\n+                debug!(\"instantiate_anon_types: ty_var={:?}\", ty_var);\n \n                 for predicate in bounds.predicates {\n                     // Change the predicate to refer to the type variable,\n@@ -1931,8 +1985,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let predicate = self.instantiate_anon_types(&predicate);\n \n                     // Require that the predicate holds for the concrete type.\n-                    let cause = traits::ObligationCause::new(span, self.body_id,\n+                    let cause = traits::ObligationCause::new(span,\n+                                                             self.body_id,\n                                                              traits::SizedReturnType);\n+\n+                    debug!(\"instantiate_anon_types: predicate={:?}\", predicate);\n                     self.register_predicate(traits::Obligation::new(cause,\n                                                                     self.param_env,\n                                                                     predicate));"}, {"sha": "b91137aeb68a5c022a0cec820c9e4e2b107fa29a", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 193, "deletions": 1, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -92,6 +92,7 @@ use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n use rustc::infer::{self, OutlivesEnvironment};\n use rustc::ty::adjustment;\n+use rustc::ty::outlives::Component;\n \n use std::mem;\n use std::ops::Deref;\n@@ -135,7 +136,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          item_id: ast::NodeId,\n                          span: Span,\n                          wf_tys: &[Ty<'tcx>]) {\n-        debug!(\"regionck_item(item.id={:?}, wf_tys={:?}\", item_id, wf_tys);\n+        debug!(\"regionck_item(item.id={:?}, wf_tys={:?})\", item_id, wf_tys);\n         let subject = self.tcx.hir.local_def_id(item_id);\n         let mut rcx = RegionCtxt::new(self,\n                                       RepeatingScope(item_id),\n@@ -336,10 +337,13 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"visit_fn_body body.id {:?} call_site_scope: {:?}\",\n                body.id(), call_site_scope);\n         let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope));\n+\n         let body_hir_id = self.tcx.hir.node_to_hir_id(body_id.node_id);\n         self.type_of_node_must_outlive(infer::CallReturn(span),\n                                        body_hir_id,\n                                        call_site_region);\n+\n+        self.constrain_anon_types();\n     }\n \n     fn visit_region_obligations(&mut self, node_id: ast::NodeId)\n@@ -358,6 +362,194 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             self.body_id);\n     }\n \n+    /// Go through each of the existential `impl Trait` types that\n+    /// appear in the function signature. For example, if the current\n+    /// function is as follows:\n+    ///\n+    ///     fn foo<'a, 'b>(..) -> (impl Bar<'a>, impl Bar<'b>)\n+    ///\n+    /// we would iterate through the `impl Bar<'a>` and the\n+    /// `impl Bar<'b>` here. Remember that each of them has\n+    /// their own \"abstract type\" definition created for them. As\n+    /// we iterate, we have a `def_id` that corresponds to this\n+    /// definition, and a set of substitutions `substs` that are\n+    /// being supplied to this abstract typed definition in the\n+    /// signature:\n+    ///\n+    ///     abstract type Foo1<'x>: Bar<'x>;\n+    ///     abstract type Foo2<'x>: Bar<'x>;\n+    ///     fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n+    ///                            ^^^^ ^^ substs\n+    ///                            def_id\n+    ///\n+    /// In addition, for each of the types we will have a type\n+    /// variable `concrete_ty` containing the concrete type that\n+    /// this function uses for `Foo1` and `Foo2`. That is,\n+    /// conceptually, there is a constraint like:\n+    ///\n+    ///     for<'a> (Foo1<'a> = C)\n+    ///\n+    /// where `C` is `concrete_ty`. For this equation to be satisfiable,\n+    /// the type `C` can only refer to two regions: `'static` and `'a`.\n+    ///\n+    /// The problem is that this type `C` may contain arbitrary\n+    /// region variables. In fact, it is fairly likely that it\n+    /// does!  Consider this possible definition of `foo`:\n+    ///\n+    ///     fn foo<'a, 'b>(x: &'a i32, y: &'b i32) -> (impl Bar<'a>, impl Bar<'b>) {\n+    ///         (&*x, &*y)\n+    ///     }\n+    ///\n+    /// Here, the values for the concrete types of the two impl\n+    /// traits will include inference variables:\n+    ///\n+    ///     &'0 i32\n+    ///     &'1 i32\n+    ///\n+    /// Ordinarily, the subtyping rules would ensure that these are\n+    /// sufficiently large.  But since `impl Bar<'a>` isn't a specific\n+    /// type per se, we don't get such constraints by default.  This\n+    /// is where this function comes into play. It adds extra\n+    /// constraints to ensure that all the regions which appear in the\n+    /// inferred type are regions that could validly appear.\n+    ///\n+    /// This is actually a bit of a tricky constraint in general. We\n+    /// want to say that each variable (e.g., `'0``) can only take on\n+    /// values that were supplied as arguments to the abstract type\n+    /// (e.g., `'a` for `Foo1<'a>`) or `'static`, which is always in\n+    /// scope. We don't have a constraint quite of this kind in the current\n+    /// region checker.\n+    ///\n+    /// What we *do* have is the `<=` relation. So what we do is to\n+    /// find the LUB of all the arguments that appear in the substs:\n+    /// in this case, that would be `LUB('a) = 'a`, and then we apply\n+    /// that as a least bound to the variables (e.g., `'a <= '0`).\n+    ///\n+    /// In some cases this is pretty suboptimal. Consider this example:\n+    ///\n+    ///    fn baz<'a, 'b>() -> impl Trait<'a, 'b> { ... }\n+    ///\n+    /// Here, the regions `'a` and `'b` appear in the substitutions,\n+    /// so we would generate `LUB('a, 'b)` as a kind of \"minimal upper\n+    /// bound\", but that turns out be `'static` -- which is clearly\n+    /// too strict!\n+    fn constrain_anon_types(&mut self) {\n+        debug!(\"constrain_anon_types()\");\n+\n+        for (&def_id, anon_defn) in self.fcx.anon_types.borrow().iter() {\n+            let concrete_ty = self.resolve_type(anon_defn.concrete_ty);\n+\n+            debug!(\"constrain_anon_types: def_id={:?}\", def_id);\n+            debug!(\"constrain_anon_types: anon_defn={:#?}\", anon_defn);\n+            debug!(\"constrain_anon_types: concrete_ty={:?}\", concrete_ty);\n+\n+            let abstract_type_generics = self.tcx.generics_of(def_id);\n+\n+            let span = self.tcx.def_span(def_id);\n+\n+            // If there are required region bounds, we can just skip\n+            // ahead.  There will already be a registered region\n+            // obligation related `concrete_ty` to those regions.\n+            if anon_defn.required_region_bounds.len() != 0 {\n+                continue;\n+            }\n+\n+            // There were no `required_region_bounds`,\n+            // so we have to search for a `least_region`.\n+            // Go through all the regions used as arguments to the\n+            // abstract type. These are the parameters to the abstract\n+            // type; so in our example above, `substs` would contain\n+            // `['a]` for the first impl trait and `'b` for the\n+            // second.\n+            let mut least_region = None;\n+            for region_def in &abstract_type_generics.regions {\n+                // Find the index of this region in the list of substitutions.\n+                let index = region_def.index as usize;\n+\n+                // Get the value supplied for this region from the substs.\n+                let subst_arg = anon_defn.substs[index].as_region().unwrap();\n+\n+                // Compute the least upper bound of it with the other regions.\n+                debug!(\"constrain_anon_types: least_region={:?}\", least_region);\n+                debug!(\"constrain_anon_types: subst_arg={:?}\", subst_arg);\n+                match least_region {\n+                    None => least_region = Some(subst_arg),\n+                    Some(lr) => {\n+                        if self.outlives_environment\n+                               .free_region_map()\n+                               .sub_free_regions(lr, subst_arg) {\n+                            // keep the current least region\n+                        } else if self.outlives_environment\n+                                      .free_region_map()\n+                                      .sub_free_regions(subst_arg, lr) {\n+                            // switch to `subst_arg`\n+                            least_region = Some(subst_arg);\n+                        } else {\n+                            // There are two regions (`lr` and\n+                            // `subst_arg`) which are not relatable. We can't\n+                            // find a best choice.\n+                            self.tcx\n+                                .sess\n+                                .struct_span_err(span, \"ambiguous lifetime bound in `impl Trait`\")\n+                                .span_label(span,\n+                                            format!(\"neither `{}` nor `{}` outlives the other\",\n+                                                    lr, subst_arg))\n+                                .emit();\n+\n+                            least_region = Some(self.tcx.mk_region(ty::ReEmpty));\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            let least_region = least_region.unwrap_or(self.tcx.types.re_static);\n+            debug!(\"constrain_anon_types: least_region={:?}\", least_region);\n+\n+            // Require that the type `concrete_ty` outlives\n+            // `least_region`, modulo any type parameters that appear\n+            // in the type, which we ignore. This is because impl\n+            // trait values are assumed to capture all the in-scope\n+            // type parameters. This little loop here just invokes\n+            // `outlives` repeatedly, draining all the nested\n+            // obligations that result.\n+            let mut types = vec![concrete_ty];\n+            let bound_region = |r| self.sub_regions(infer::CallReturn(span), least_region, r);\n+            while let Some(ty) = types.pop() {\n+                let mut components = self.tcx.outlives_components(ty);\n+                while let Some(component) = components.pop() {\n+                    match component {\n+                        Component::Region(r) => {\n+                            bound_region(r);\n+                        }\n+\n+                        Component::Param(_) => {\n+                            // ignore type parameters like `T`, they are captured\n+                            // implicitly by the `impl Trait`\n+                        }\n+\n+                        Component::UnresolvedInferenceVariable(_) => {\n+                            // we should get an error that more type\n+                            // annotations are needed in this case\n+                            self.tcx.sess.delay_span_bug(span, \"unresolved inf var in anon\");\n+                        }\n+\n+                        Component::Projection(ty::ProjectionTy { substs, item_def_id: _ }) => {\n+                            for r in substs.regions() {\n+                                bound_region(r);\n+                            }\n+                            types.extend(substs.types());\n+                        }\n+\n+                        Component::EscapingProjection(more_components) => {\n+                            components.extend(more_components);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn resolve_regions_and_report_errors(&self) {\n         self.fcx.resolve_regions_and_report_errors(self.subject_def_id,\n                                                    &self.region_scope_tree,"}, {"sha": "6bb5a8399509e3398789e2905c0bc039910b504e", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 51, "deletions": 21, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -18,8 +18,9 @@ use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::infer::{InferCtxt};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::fold::{TypeFolder,TypeFoldable};\n-use rustc::util::nodemap::DefIdSet;\n+use rustc::ty::fold::{TypeFolder, TypeFoldable};\n+use rustc::ty::subst::{Kind, Substs};\n+use rustc::util::nodemap::{DefIdSet, FxHashMap};\n use syntax::ast;\n use syntax_pos::Span;\n use std::mem;\n@@ -285,8 +286,23 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n     fn visit_anon_types(&mut self) {\n         let gcx = self.tcx().global_tcx();\n-        for (&node_id, &concrete_ty) in self.fcx.anon_types.borrow().iter() {\n-            let inside_ty = self.resolve(&concrete_ty, &node_id);\n+        for (&def_id, anon_defn) in self.fcx.anon_types.borrow().iter() {\n+            let node_id = gcx.hir.as_local_node_id(def_id).unwrap();\n+            let inside_ty = self.resolve(&anon_defn.concrete_ty, &node_id);\n+\n+            // Use substs to build up a reverse map from regions\n+            // to their identity mappings.\n+            // This is necessary because of `impl Trait` lifetimes\n+            // are computed by replacing existing lifetimes with 'static\n+            // and remapping only those used in the `impl Trait` return type,\n+            // resulting in the parameters shifting.\n+            let id_substs = Substs::identity_for_item(gcx, def_id);\n+            let map: FxHashMap<Kind<'tcx>, Kind<'gcx>> =\n+                anon_defn.substs\n+                         .iter()\n+                         .enumerate()\n+                         .map(|(index, subst)| (*subst, id_substs[index]))\n+                         .collect();\n \n             // Convert the type from the function into a type valid outside\n             // the function, by replacing invalid regions with 'static,\n@@ -295,25 +311,39 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 match *r {\n                     // 'static and early-bound regions are valid.\n                     ty::ReStatic |\n-                    ty::ReEarlyBound(_) |\n                     ty::ReEmpty => r,\n \n-                    ty::ReFree(_) |\n-                    ty::ReLateBound(..) |\n-                    ty::ReScope(_) |\n-                    ty::ReSkolemized(..) => {\n-                        let span = node_id.to_span(&self.fcx.tcx);\n-                        span_err!(self.tcx().sess, span, E0564,\n-                                  \"only named lifetimes are allowed in `impl Trait`, \\\n-                                   but `{}` was found in the type `{}`\", r, inside_ty);\n-                        gcx.types.re_static\n-                    }\n-\n-                    ty::ReVar(_) |\n-                    ty::ReErased => {\n-                        let span = node_id.to_span(&self.fcx.tcx);\n-                        span_bug!(span, \"invalid region in impl Trait: {:?}\", r);\n-                    }\n+                    // All other regions, we map them appropriately to their adjusted\n+                    // indices, erroring if we find any lifetimes that were not mapped\n+                    // into the new set.\n+                    _ => if let Some(r1) =\n+                            map.get(&Kind::from(r)).and_then(|k| k.as_region()) { r1 } else\n+                        {\n+                            // No mapping was found. This means that\n+                            // it is either a disallowed lifetime,\n+                            // which will be caught by regionck, or it\n+                            // is a region in a non-upvar closure\n+                            // generic, which is explicitly\n+                            // allowed. If that surprises you, read\n+                            // on.\n+                            //\n+                            // The case of closure is a somewhat\n+                            // subtle (read: hacky) consideration. The\n+                            // problem is that our closure types\n+                            // currently include all the lifetime\n+                            // parameters declared on the enclosing\n+                            // function, even if they are unused by\n+                            // the closure itself. We can't readily\n+                            // filter them out, so here we replace\n+                            // those values with `'empty`. This can't\n+                            // really make a difference to the rest of\n+                            // the compiler; those regions are ignored\n+                            // for the outlives relation, and hence\n+                            // don't affect trait selection or auto\n+                            // traits, and they are erased during\n+                            // trans.\n+                            gcx.types.re_empty\n+                        },\n                 }\n             });\n "}, {"sha": "916fe3be58cfc38f92ebb8f69ce0ea234de06d2a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -935,6 +935,10 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         }\n \n+        NodeTy(&hir::Ty { node: hir::TyImplTraitExistential(ref exist_ty, _), .. }) => {\n+            (&exist_ty.generics, None)\n+        }\n+\n         _ => (&no_generics, None)\n     };\n \n@@ -1358,6 +1362,8 @@ fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     use rustc::hir::map::*;\n     use rustc::hir::*;\n \n+    debug!(\"explicit_predicates_of(def_id={:?})\", def_id);\n+\n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     let node = tcx.hir.get(node_id);\n \n@@ -1412,17 +1418,28 @@ fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         }\n \n-        NodeTy(&Ty { node: TyImplTraitExistential(ref bounds), span, .. }) => {\n+        NodeTy(&Ty { node: TyImplTraitExistential(ref exist_ty, _), span, .. }) => {\n             let substs = Substs::identity_for_item(tcx, def_id);\n             let anon_ty = tcx.mk_anon(def_id, substs);\n \n+            debug!(\"explicit_predicates_of: anon_ty={:?}\", anon_ty);\n+\n             // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n-            let bounds = compute_bounds(&icx, anon_ty, bounds,\n+            let bounds = compute_bounds(&icx,\n+                                        anon_ty,\n+                                        &exist_ty.bounds,\n                                         SizedByDefault::Yes,\n                                         span);\n+\n+            debug!(\"explicit_predicates_of: bounds={:?}\", bounds);\n+\n+            let predicates = bounds.predicates(tcx, anon_ty);\n+\n+            debug!(\"explicit_predicates_of: predicates={:?}\", predicates);\n+\n             return ty::GenericPredicates {\n                 parent: None,\n-                predicates: bounds.predicates(tcx, anon_ty)\n+                predicates: predicates\n             };\n         }\n "}, {"sha": "720e946d469336c534d6828159f853aaba5266be", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -1960,9 +1960,8 @@ impl Clean<Type> for hir::Ty {\n                 }\n             }\n             TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n-            TyImplTraitExistential(ref bounds) |\n-                TyImplTraitUniversal(_, ref bounds) =>\n-                    ImplTrait(bounds.clean(cx)),\n+            TyImplTraitExistential(ref exist_ty, ref _lts) => ImplTrait(exist_ty.bounds.clean(cx)),\n+            TyImplTraitUniversal(_, ref bounds) => ImplTrait(bounds.clean(cx)),\n             TyInfer | TyErr => Infer,\n             TyTypeof(..) => panic!(\"Unimplemented type {:?}\", self.node),\n         }"}, {"sha": "b72a8f03089b25deb78770ad61308b291f1f94ef", "filename": "src/test/compile-fail/E0657.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Ftest%2Fcompile-fail%2FE0657.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Ftest%2Fcompile-fail%2FE0657.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0657.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![allow(warnings)]\n+#![feature(conservative_impl_trait)]\n+\n+trait Id<T> {}\n+trait Lt<'a> {}\n+\n+impl<'a> Lt<'a> for () {}\n+impl<T> Id<T> for T {}\n+\n+fn free_fn_capture_hrtb_in_impl_trait()\n+    -> impl for<'a> Id<impl Lt<'a>>\n+        //~^ ERROR `impl Trait` can only capture lifetimes bound at the fn or impl level [E0657]\n+{\n+    ()\n+}\n+\n+struct Foo;\n+impl Foo {\n+    fn impl_fn_capture_hrtb_in_impl_trait()\n+        -> impl for<'a> Id<impl Lt<'a>>\n+            //~^ ERROR `impl Trait` can only capture lifetimes bound at the fn or impl level\n+    {\n+        ()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "9d9f6bf72974abf815e3b259df0a17f81d69b104", "filename": "src/test/compile-fail/impl-trait/lifetimes.rs", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Flifetimes.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -1,43 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(conservative_impl_trait)]\n-\n-// Helper creating a fake borrow, captured by the impl Trait.\n-fn borrow<'a, T>(_: &'a mut T) -> impl Copy { () }\n-\n-fn stack() -> impl Copy {\n-    //~^ ERROR only named lifetimes are allowed in `impl Trait`\n-    let x = 0;\n-    &x\n-}\n-\n-fn late_bound(x: &i32) -> impl Copy {\n-    //~^ ERROR only named lifetimes are allowed in `impl Trait`\n-    x\n-}\n-\n-// FIXME(#34511) Should work but doesn't at the moment,\n-// region-checking needs an overhault to support this.\n-fn early_bound<'a>(x: &'a i32) -> impl Copy {\n-    //~^ ERROR only named lifetimes are allowed in `impl Trait`\n-    x\n-}\n-\n-fn ambiguous<'a, 'b>(x: &'a [u32], y: &'b [u32]) -> impl Iterator<Item=u32> {\n-    //~^ ERROR only named lifetimes are allowed in `impl Trait`\n-    if x.len() < y.len() {\n-        x.iter().cloned()\n-    } else {\n-        y.iter().cloned()\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "837160bc2fcd99d9221d3d13b86da6ba937f9359", "filename": "src/test/compile-fail/impl-trait/must_outlive_least_region_or_bound.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait)]\n+\n+use std::fmt::Debug;\n+\n+fn elided(x: &i32) -> impl Copy { x }\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n+fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n+trait LifetimeTrait<'a> {}\n+impl<'a> LifetimeTrait<'a> for &'a i32 {}\n+\n+fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n+// Tests that a closure type contianing 'b cannot be returned from a type where\n+// only 'a was expected.\n+fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n+    //~^ ERROR lifetime mismatch\n+    move |_| println!(\"{}\", y)\n+}\n+\n+fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n+    //~^ ERROR the parameter type `T` may not live long enough\n+    x\n+}\n+\n+fn main() {}"}, {"sha": "2a06580fe605dc55c6b7fc79e82391786f8117ff", "filename": "src/test/compile-fail/impl-trait/needs_least_region_or_bound.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fneeds_least_region_or_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fneeds_least_region_or_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fneeds_least_region_or_bound.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait)]\n+\n+use std::fmt::Debug;\n+\n+trait MultiRegionTrait<'a, 'b> {}\n+impl<'a, 'b> MultiRegionTrait<'a, 'b> for (&'a u32, &'b u32) {}\n+\n+fn no_least_region<'a, 'b>(x: &'a u32, y: &'b u32) -> impl MultiRegionTrait<'a, 'b> {\n+//~^ ERROR ambiguous lifetime bound\n+    (x, y)\n+}\n+\n+fn main() {}"}, {"sha": "c6ff762b9050a74c7b822d111efbae8928ec694f", "filename": "src/test/compile-fail/impl-trait/type_parameters_captured.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Ftype_parameters_captured.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Ftype_parameters_captured.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Ftype_parameters_captured.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait)]\n+\n+use std::fmt::Debug;\n+\n+trait Any {}\n+impl<T> Any for T {}\n+\n+// Check that type parameters are captured and not considered 'static\n+fn foo<T>(x: T) -> impl Any + 'static {\n+    //~^ ERROR the parameter type `T` may not live long enough\n+    x\n+}\n+\n+fn main() {}"}, {"sha": "1e19e7f6a132ae1b7b38c39d738f341ffd634db4", "filename": "src/test/run-pass/impl-trait/lifetimes.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Ftest%2Frun-pass%2Fimpl-trait%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4810d907deef00ea5bd0124272cfcab3975e3c/src%2Ftest%2Frun-pass%2Fimpl-trait%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Flifetimes.rs?ref=bc4810d907deef00ea5bd0124272cfcab3975e3c", "patch": "@@ -0,0 +1,97 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait)]\n+#![allow(warnings)]\n+\n+use std::fmt::Debug;\n+\n+fn any_lifetime<'a>() -> &'a u32 { &5 }\n+\n+fn static_lifetime() -> &'static u32 { &5 }\n+\n+fn any_lifetime_as_static_impl_trait() -> impl Debug {\n+    any_lifetime()\n+}\n+\n+fn lifetimes_as_static_impl_trait() -> impl Debug {\n+    static_lifetime()\n+}\n+\n+fn no_params_or_lifetimes_is_static() -> impl Debug + 'static {\n+    lifetimes_as_static_impl_trait()\n+}\n+\n+fn static_input_type_is_static<T: Debug + 'static>(x: T) -> impl Debug + 'static { x }\n+\n+fn type_outlives_reference_lifetime<'a, T: Debug>(x: &'a T) -> impl Debug + 'a { x }\n+\n+trait SingleRegionTrait<'a> {}\n+impl<'a> SingleRegionTrait<'a> for u32 {}\n+\n+fn simple_type_hrtb<'b>() -> impl for<'a> SingleRegionTrait<'a> { 5 }\n+fn closure_hrtb() -> impl for<'a> Fn(&'a u32) { |_| () }\n+\n+fn mixed_lifetimes<'a>() -> impl for<'b: 'a> Fn(&'b u32) { |_| () }\n+fn mixed_as_static() -> impl Fn(&'static u32) { mixed_lifetimes() }\n+\n+trait MultiRegionTrait<'a, 'b>: Debug {}\n+\n+#[derive(Debug)]\n+struct MultiRegionStruct<'a, 'b>(&'a u32, &'b u32);\n+impl<'a, 'b> MultiRegionTrait<'a, 'b> for MultiRegionStruct<'a, 'b> {}\n+\n+#[derive(Debug)]\n+struct NoRegionStruct;\n+impl<'a, 'b> MultiRegionTrait<'a, 'b> for NoRegionStruct {}\n+\n+fn finds_least_region<'a: 'b, 'b>(x: &'a u32, y: &'b u32) -> impl MultiRegionTrait<'a, 'b> {\n+    MultiRegionStruct(x, y)\n+}\n+\n+fn finds_explicit_bound<'a: 'b, 'b>\n+    (x: &'a u32, y: &'b u32) -> impl MultiRegionTrait<'a, 'b> + 'b\n+{\n+    MultiRegionStruct(x, y)\n+}\n+\n+fn finds_explicit_bound_even_without_least_region<'a, 'b>\n+    (x: &'a u32, y: &'b u32) -> impl MultiRegionTrait<'a, 'b> + 'b\n+{\n+    NoRegionStruct\n+}\n+\n+/* FIXME: `impl Trait<'a> + 'b` should live as long as 'b, even if 'b outlives 'a\n+fn outlives_bounds_even_with_contained_regions<'a, 'b>\n+    (x: &'a u32, y: &'b u32) -> impl Debug + 'b\n+{\n+    finds_explicit_bound_even_without_least_region(x, y)\n+}\n+*/\n+\n+fn unnamed_lifetimes_arent_contained_in_impl_trait_and_will_unify<'a, 'b>\n+    (x: &'a u32, y: &'b u32) -> impl Debug\n+{\n+    fn deref<'lt>(x: &'lt u32) -> impl Debug { *x }\n+\n+    if true { deref(x) } else { deref(y) }\n+}\n+\n+fn can_add_region_bound_to_static_type<'a, 'b>(_: &'a u32) -> impl Debug + 'a { 5 }\n+\n+struct MyVec(Vec<Vec<u8>>);\n+\n+impl<'unnecessary_lifetime> MyVec {\n+    fn iter_doesnt_capture_unnecessary_lifetime<'s>(&'s self) -> impl Iterator<Item = &'s u8> {\n+        self.0.iter().flat_map(|inner_vec| inner_vec.iter())\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a4b951daab439f5fcdfab891dc414cbc8aa18142", "filename": "src/test/ui/span/loan-extend.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fui%2Fspan%2Floan-extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f8e2913a93573c78cddfd297944cff4eb4c41a/src%2Ftest%2Fui%2Fspan%2Floan-extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Floan-extend.rs?ref=d0f8e2913a93573c78cddfd297944cff4eb4c41a", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(conservative_impl_trait)]\n-\n-// Helper creating a fake borrow, captured by the impl Trait.\n-fn borrow<'a, T>(_: &'a mut T) -> impl Copy { () }\n-\n-fn main() {\n-    let long;\n-    let mut short = 0;\n-    long = borrow(&mut short);\n-    //~^ NOTE borrow occurs here\n-}\n-//~^ ERROR `short` does not live long enough\n-//~| NOTE `short` dropped here while still borrowed\n-//~| NOTE values in a scope are dropped in the opposite order they are created"}]}