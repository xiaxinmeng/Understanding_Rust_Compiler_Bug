{"sha": "45d3daece364e4cf6b6bc4668dcfd7670197b1e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ZDNkYWVjZTM2NGU0Y2Y2YjZiYzQ2NjhkY2ZkNzY3MDE5N2IxZTg=", "commit": {"author": {"name": "Justus K", "email": "justus.k@protonmail.com", "date": "2021-06-26T18:47:33Z"}, "committer": {"name": "Justus K", "email": "justus.k@protonmail.com", "date": "2021-07-05T17:51:51Z"}, "message": "rustdoc: Store DefId's in ItemId on heap for decreasing Item's size", "tree": {"sha": "6c6dad674e0b7ba6e4991f554b492f8b3ec6bef8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c6dad674e0b7ba6e4991f554b492f8b3ec6bef8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45d3daece364e4cf6b6bc4668dcfd7670197b1e8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEDDGYqKFKtc1ioGY0jGL+mKYvxGIFAmDjRrkACgkQjGL+mKYv\nxGLsdg//eEz5BgfaXc9FM9G7qnNzAT/JtHjwmyEMdJfGD/hws+yZY2lRBf772to9\nZpSzcypBi7riWFSYLVmXuVU9p9zgKuocCSZHDzf0/lz9lzqbom43cbbwl6KL2yb0\nBGVkNiFaXsoFvQOtyn2cd7JAkBbumOFY2LU8CT0eyx2A790bKo7MLEjIrZCdeX4J\n64c5o1g1woemr6fcu9l93mExWL5LVIJISJuvsgtPO2kE67khfSzjYm2y3oyGZujM\nrf0VcuoQiedDugvltOfydES55zzOsy1hK772MV9MStafUg4TkMAGZdl20AALG+FF\n5+5GLlTU9ohrP+eliWy/jVMsiV1qE4z8qAG33niCcc6MlaLQpAQ6jE5TEzpZYzuh\nl5lQhwkbkdLiHGARF5i//ra6UlI3ykf3r1uT+vM2xIT3FPUXuHebA7AALZFcAw09\ncmYrSTMoku5AIY2jobdjp7ASy8m08UQmshM46aRyXOruEfJ5+Geo+IXdSvj74wTi\nGUOtvAsFeRXDz6hUEKTPTThueJEL6+fW6MfhK8MuuOdN7z7zLgP3I15X9Z3eCPq7\nS28eKumIQm4ZjRpnS8fBJOSvn8eJeIFTlV13/5CTXzlWpM28dfkyQvPO9F9+/2Af\nn6aBJYuWzYsKf5OnStp5R4Lb3Z4gYjy+qdsrTYpBLjIK+C5JdeM=\n=2opd\n-----END PGP SIGNATURE-----", "payload": "tree 6c6dad674e0b7ba6e4991f554b492f8b3ec6bef8\nparent acd4dc2d0ca8676fbf105507504e24d44e5dd1f6\nauthor Justus K <justus.k@protonmail.com> 1624733253 +0200\ncommitter Justus K <justus.k@protonmail.com> 1625507511 +0200\n\nrustdoc: Store DefId's in ItemId on heap for decreasing Item's size\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45d3daece364e4cf6b6bc4668dcfd7670197b1e8", "html_url": "https://github.com/rust-lang/rust/commit/45d3daece364e4cf6b6bc4668dcfd7670197b1e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/comments", "author": {"login": "Stupremee", "id": 39732259, "node_id": "MDQ6VXNlcjM5NzMyMjU5", "avatar_url": "https://avatars.githubusercontent.com/u/39732259?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Stupremee", "html_url": "https://github.com/Stupremee", "followers_url": "https://api.github.com/users/Stupremee/followers", "following_url": "https://api.github.com/users/Stupremee/following{/other_user}", "gists_url": "https://api.github.com/users/Stupremee/gists{/gist_id}", "starred_url": "https://api.github.com/users/Stupremee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Stupremee/subscriptions", "organizations_url": "https://api.github.com/users/Stupremee/orgs", "repos_url": "https://api.github.com/users/Stupremee/repos", "events_url": "https://api.github.com/users/Stupremee/events{/privacy}", "received_events_url": "https://api.github.com/users/Stupremee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Stupremee", "id": 39732259, "node_id": "MDQ6VXNlcjM5NzMyMjU5", "avatar_url": "https://avatars.githubusercontent.com/u/39732259?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Stupremee", "html_url": "https://github.com/Stupremee", "followers_url": "https://api.github.com/users/Stupremee/followers", "following_url": "https://api.github.com/users/Stupremee/following{/other_user}", "gists_url": "https://api.github.com/users/Stupremee/gists{/gist_id}", "starred_url": "https://api.github.com/users/Stupremee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Stupremee/subscriptions", "organizations_url": "https://api.github.com/users/Stupremee/orgs", "repos_url": "https://api.github.com/users/Stupremee/repos", "events_url": "https://api.github.com/users/Stupremee/events{/privacy}", "received_events_url": "https://api.github.com/users/Stupremee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acd4dc2d0ca8676fbf105507504e24d44e5dd1f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6", "html_url": "https://github.com/rust-lang/rust/commit/acd4dc2d0ca8676fbf105507504e24d44e5dd1f6"}], "stats": {"total": 224, "additions": 115, "deletions": 109}, "files": [{"sha": "5564261492e92fe3b38ba2f2959e19c8adcf0a2f", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=45d3daece364e4cf6b6bc4668dcfd7670197b1e8", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             name: None,\n             attrs: Default::default(),\n             visibility: Inherited,\n-            def_id: ItemId::Auto { trait_: trait_def_id, for_: item_def_id },\n+            def_id: ItemId::Auto(box ImplId { trait_: trait_def_id, for_: item_def_id }),\n             kind: box ImplItem(Impl {\n                 span: Span::dummy(),\n                 unsafety: hir::Unsafety::Normal,"}, {"sha": "af8680fb40c3c2b64601aea3f484ef6fbf6bf243", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=45d3daece364e4cf6b6bc4668dcfd7670197b1e8", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                     name: None,\n                     attrs: Default::default(),\n                     visibility: Inherited,\n-                    def_id: ItemId::Blanket { trait_: trait_def_id, for_: item_def_id },\n+                    def_id: ItemId::Blanket(box ImplId { trait_: trait_def_id, for_: item_def_id }),\n                     kind: box ImplItem(Impl {\n                         span: self.cx.tcx.def_span(impl_def_id).clean(self.cx),\n                         unsafety: hir::Unsafety::Normal,"}, {"sha": "4fa1fde5f0b1828b2248932145ec449ff385b765", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=45d3daece364e4cf6b6bc4668dcfd7670197b1e8", "patch": "@@ -18,7 +18,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n+use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{BodyId, Mutability};\n use rustc_index::vec::IndexVec;\n@@ -50,61 +50,59 @@ use self::Type::*;\n \n crate type ItemIdSet = FxHashSet<ItemId>;\n \n-#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy)]\n+#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+crate struct ImplId {\n+    crate trait_: DefId,\n+    crate for_: DefId,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n crate enum ItemId {\n     /// A \"normal\" item that uses a [`DefId`] for identification.\n     DefId(DefId),\n     /// Identifier that is used for auto traits.\n-    Auto { trait_: DefId, for_: DefId },\n+    Auto(Box<ImplId>),\n     /// Identifier that is used for blanket implementations.\n-    Blanket { trait_: DefId, for_: DefId },\n+    Blanket(Box<ImplId>),\n     /// Identifier for primitive types.\n     Primitive(CrateNum),\n }\n \n impl ItemId {\n     #[inline]\n-    crate fn is_local(self) -> bool {\n+    crate fn is_local(&self) -> bool {\n         match self {\n-            ItemId::Auto { for_: id, .. }\n-            | ItemId::Blanket { for_: id, .. }\n+            ItemId::Auto(box ImplId { for_: id, .. })\n+            | ItemId::Blanket(box ImplId { for_: id, .. })\n             | ItemId::DefId(id) => id.is_local(),\n-            ItemId::Primitive(krate) => krate == LOCAL_CRATE,\n+            ItemId::Primitive(krate) => *krate == LOCAL_CRATE,\n         }\n     }\n \n     #[inline]\n     #[track_caller]\n-    crate fn expect_def_id(self) -> DefId {\n+    crate fn expect_def_id(&self) -> DefId {\n         self.as_def_id()\n             .unwrap_or_else(|| panic!(\"ItemId::expect_def_id: `{:?}` isn't a DefId\", self))\n     }\n \n     #[inline]\n-    crate fn as_def_id(self) -> Option<DefId> {\n+    crate fn as_def_id(&self) -> Option<DefId> {\n         match self {\n-            ItemId::DefId(id) => Some(id),\n+            ItemId::DefId(id) => Some(*id),\n             _ => None,\n         }\n     }\n \n     #[inline]\n-    crate fn krate(self) -> CrateNum {\n-        match self {\n-            ItemId::Auto { for_: id, .. }\n-            | ItemId::Blanket { for_: id, .. }\n+    crate fn krate(&self) -> CrateNum {\n+        match *self {\n+            ItemId::Auto(box ImplId { for_: id, .. })\n+            | ItemId::Blanket(box ImplId { for_: id, .. })\n             | ItemId::DefId(id) => id.krate,\n             ItemId::Primitive(krate) => krate,\n         }\n     }\n-\n-    #[inline]\n-    crate fn index(self) -> Option<DefIndex> {\n-        match self {\n-            ItemId::DefId(id) => Some(id.index),\n-            _ => None,\n-        }\n-    }\n }\n \n impl From<DefId> for ItemId {\n@@ -379,7 +377,7 @@ impl Item {\n         {\n             *span\n         } else {\n-            self.def_id.as_def_id().map(|did| rustc_span(did, tcx)).unwrap_or_else(|| Span::dummy())\n+            self.def_id.as_def_id().map(|did| rustc_span(did, tcx)).unwrap_or_else(Span::dummy)\n         }\n     }\n "}, {"sha": "a9f84e747b18a7c0d39ea82065b45b2626df2de4", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=45d3daece364e4cf6b6bc4668dcfd7670197b1e8", "patch": "@@ -128,8 +128,8 @@ impl<'tcx> DocContext<'tcx> {\n \n     /// Like `hir().local_def_id_to_hir_id()`, but skips calling it on fake DefIds.\n     /// (This avoids a slice-index-out-of-bounds panic.)\n-    crate fn as_local_hir_id(tcx: TyCtxt<'_>, def_id: ItemId) -> Option<HirId> {\n-        match def_id {\n+    crate fn as_local_hir_id(tcx: TyCtxt<'_>, def_id: &ItemId) -> Option<HirId> {\n+        match *def_id {\n             ItemId::DefId(real_id) => {\n                 real_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n             }\n@@ -432,7 +432,7 @@ crate fn run_global_ctxt(\n         );\n         tcx.struct_lint_node(\n             crate::lint::MISSING_CRATE_LEVEL_DOCS,\n-            DocContext::as_local_hir_id(tcx, krate.module.def_id).unwrap(),\n+            DocContext::as_local_hir_id(tcx, &krate.module.def_id).unwrap(),\n             |lint| {\n                 let mut diag =\n                     lint.build(\"no documentation found for this crate's top-level module\");"}, {"sha": "978ba501fd0bad92901f428cc29fc4de4d4f2c5e", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=45d3daece364e4cf6b6bc4668dcfd7670197b1e8", "patch": "@@ -290,7 +290,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                     // A crate has a module at its root, containing all items,\n                     // which should not be indexed. The crate-item itself is\n                     // inserted later on when serializing the search-index.\n-                    if item.def_id.index().map_or(false, |idx| idx != CRATE_DEF_INDEX) {\n+                    if item.def_id.as_def_id().map_or(false, |did| did.index != CRATE_DEF_INDEX) {\n                         let desc = item.doc_value().map_or_else(String::new, |x| {\n                             short_markdown_summary(&x.as_str(), &item.link_names(&self.cache))\n                         });"}, {"sha": "1cee68baff4db5451df3e37e2590be4604272882", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=45d3daece364e4cf6b6bc4668dcfd7670197b1e8", "patch": "@@ -753,7 +753,7 @@ fn assoc_const(\n         w,\n         \"{}{}const <a href=\\\"{}\\\" class=\\\"constant\\\"><b>{}</b></a>: {}\",\n         extra,\n-        it.visibility.print_with_space(it.def_id, cx),\n+        it.visibility.print_with_space(it.def_id.clone(), cx),\n         naive_assoc_href(it, link, cx),\n         it.name.as_ref().unwrap(),\n         ty.print(cx)\n@@ -872,7 +872,7 @@ fn render_assoc_item(\n                     .unwrap_or_else(|| format!(\"#{}.{}\", ty, name))\n             }\n         };\n-        let vis = meth.visibility.print_with_space(meth.def_id, cx).to_string();\n+        let vis = meth.visibility.print_with_space(meth.def_id.clone(), cx).to_string();\n         let constness =\n             print_constness_with_space(&header.constness, meth.const_stability(cx.tcx()));\n         let asyncness = header.asyncness.print_with_space();\n@@ -984,7 +984,7 @@ fn render_attributes_in_code(w: &mut Buffer, it: &clean::Item) {\n     }\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Clone)]\n enum AssocItemLink<'a> {\n     Anchor(Option<&'a str>),\n     GotoSource(ItemId, &'a FxHashSet<Symbol>),\n@@ -994,7 +994,7 @@ impl<'a> AssocItemLink<'a> {\n     fn anchor(&self, id: &'a str) -> Self {\n         match *self {\n             AssocItemLink::Anchor(_) => AssocItemLink::Anchor(Some(&id)),\n-            ref other => *other,\n+            ref other => other.clone(),\n         }\n     }\n }\n@@ -1306,7 +1306,14 @@ fn render_impl(\n                         } else {\n                             // In case the item isn't documented,\n                             // provide short documentation from the trait.\n-                            document_short(&mut doc_buffer, it, cx, link, parent, show_def_docs);\n+                            document_short(\n+                                &mut doc_buffer,\n+                                it,\n+                                cx,\n+                                link.clone(),\n+                                parent,\n+                                show_def_docs,\n+                            );\n                         }\n                     }\n                 } else {\n@@ -1317,7 +1324,7 @@ fn render_impl(\n                     }\n                 }\n             } else {\n-                document_short(&mut doc_buffer, item, cx, link, parent, show_def_docs);\n+                document_short(&mut doc_buffer, item, cx, link.clone(), parent, show_def_docs);\n             }\n         }\n         let w = if short_documented && trait_.is_some() { interesting } else { boring };\n@@ -1445,7 +1452,7 @@ fn render_impl(\n             trait_item,\n             if trait_.is_some() { &i.impl_item } else { parent },\n             parent,\n-            link,\n+            link.clone(),\n             render_mode,\n             false,\n             trait_.map(|t| &t.trait_),"}, {"sha": "70e80b20b2a5cee4bd988ce12648676adea2649c", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=45d3daece364e4cf6b6bc4668dcfd7670197b1e8", "patch": "@@ -245,7 +245,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n     // (which is the position in the vector).\n     indices.dedup_by_key(|i| {\n         (\n-            items[*i].def_id,\n+            items[*i].def_id.clone(),\n             if items[*i].name.as_ref().is_some() { Some(full_path(cx, &items[*i])) } else { None },\n             items[*i].type_(),\n             if items[*i].is_import() { *i } else { 0 },\n@@ -288,14 +288,14 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                     Some(ref src) => write!(\n                         w,\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {} as {};\",\n-                        myitem.visibility.print_with_space(myitem.def_id, cx),\n+                        myitem.visibility.print_with_space(myitem.def_id.clone(), cx),\n                         anchor(myitem.def_id.expect_def_id(), &*src.as_str(), cx),\n                         myitem.name.as_ref().unwrap(),\n                     ),\n                     None => write!(\n                         w,\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {};\",\n-                        myitem.visibility.print_with_space(myitem.def_id, cx),\n+                        myitem.visibility.print_with_space(myitem.def_id.clone(), cx),\n                         anchor(\n                             myitem.def_id.expect_def_id(),\n                             &*myitem.name.as_ref().unwrap().as_str(),\n@@ -336,7 +336,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                      <div class=\\\"item-right docblock-short\\\">{stab_tags}</div>\",\n                     stab = stab.unwrap_or_default(),\n                     add = add,\n-                    vis = myitem.visibility.print_with_space(myitem.def_id, cx),\n+                    vis = myitem.visibility.print_with_space(myitem.def_id.clone(), cx),\n                     imp = import.print(cx),\n                     stab_tags = stab_tags.unwrap_or_default(),\n                 );\n@@ -437,7 +437,7 @@ fn extra_info_tags(item: &clean::Item, parent: &clean::Item, tcx: TyCtxt<'_>) ->\n }\n \n fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::Function) {\n-    let vis = it.visibility.print_with_space(it.def_id, cx).to_string();\n+    let vis = it.visibility.print_with_space(it.def_id.clone(), cx).to_string();\n     let constness = print_constness_with_space(&f.header.constness, it.const_stability(cx.tcx()));\n     let asyncness = f.header.asyncness.print_with_space();\n     let unsafety = f.header.unsafety.print_with_space();\n@@ -489,7 +489,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         write!(\n             w,\n             \"{}{}{}trait {}{}{}\",\n-            it.visibility.print_with_space(it.def_id, cx),\n+            it.visibility.print_with_space(it.def_id.clone(), cx),\n             t.unsafety.print_with_space(),\n             if t.is_auto { \"auto \" } else { \"\" },\n             it.name.as_ref().unwrap(),\n@@ -710,8 +710,10 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n \n             for implementor in foreign {\n                 let provided_methods = implementor.inner_impl().provided_trait_methods(cx.tcx());\n-                let assoc_link =\n-                    AssocItemLink::GotoSource(implementor.impl_item.def_id, &provided_methods);\n+                let assoc_link = AssocItemLink::GotoSource(\n+                    implementor.impl_item.def_id.clone(),\n+                    &provided_methods,\n+                );\n                 render_impl(\n                     w,\n                     cx,\n@@ -915,7 +917,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n         write!(\n             w,\n             \"{}enum {}{}{}\",\n-            it.visibility.print_with_space(it.def_id, cx),\n+            it.visibility.print_with_space(it.def_id.clone(), cx),\n             it.name.as_ref().unwrap(),\n             e.generics.print(cx),\n             print_where_clause(&e.generics, cx, 0, true),\n@@ -1103,7 +1105,7 @@ fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::\n     write!(\n         w,\n         \"{vis}const {name}: {typ}\",\n-        vis = it.visibility.print_with_space(it.def_id, cx),\n+        vis = it.visibility.print_with_space(it.def_id.clone(), cx),\n         name = it.name.as_ref().unwrap(),\n         typ = c.type_.print(cx),\n     );\n@@ -1193,7 +1195,7 @@ fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n     write!(\n         w,\n         \"{vis}static {mutability}{name}: {typ}</pre>\",\n-        vis = it.visibility.print_with_space(it.def_id, cx),\n+        vis = it.visibility.print_with_space(it.def_id.clone(), cx),\n         mutability = s.mutability.print_with_space(),\n         name = it.name.as_ref().unwrap(),\n         typ = s.type_.print(cx)\n@@ -1207,7 +1209,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n     write!(\n         w,\n         \"    {}type {};\\n}}</pre>\",\n-        it.visibility.print_with_space(it.def_id, cx),\n+        it.visibility.print_with_space(it.def_id.clone(), cx),\n         it.name.as_ref().unwrap(),\n     );\n \n@@ -1362,7 +1364,7 @@ fn render_union(\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(it.def_id, cx),\n+        it.visibility.print_with_space(it.def_id.clone(), cx),\n         if structhead { \"union \" } else { \"\" },\n         it.name.as_ref().unwrap()\n     );\n@@ -1384,7 +1386,7 @@ fn render_union(\n             write!(\n                 w,\n                 \"    {}{}: {},\\n{}\",\n-                field.visibility.print_with_space(field.def_id, cx),\n+                field.visibility.print_with_space(field.def_id.clone(), cx),\n                 field.name.as_ref().unwrap(),\n                 ty.print(cx),\n                 tab\n@@ -1414,7 +1416,7 @@ fn render_struct(\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(it.def_id, cx),\n+        it.visibility.print_with_space(it.def_id.clone(), cx),\n         if structhead { \"struct \" } else { \"\" },\n         it.name.as_ref().unwrap()\n     );\n@@ -1440,7 +1442,7 @@ fn render_struct(\n                         w,\n                         \"\\n{}    {}{}: {},\",\n                         tab,\n-                        field.visibility.print_with_space(field.def_id, cx),\n+                        field.visibility.print_with_space(field.def_id.clone(), cx),\n                         field.name.as_ref().unwrap(),\n                         ty.print(cx),\n                     );\n@@ -1474,7 +1476,7 @@ fn render_struct(\n                         write!(\n                             w,\n                             \"{}{}\",\n-                            field.visibility.print_with_space(field.def_id, cx),\n+                            field.visibility.print_with_space(field.def_id.clone(), cx),\n                             ty.print(cx),\n                         )\n                     }"}, {"sha": "98c34ee8be7c4b091c744e5535a8d8237cdaac6e", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=45d3daece364e4cf6b6bc4668dcfd7670197b1e8", "patch": "@@ -30,7 +30,7 @@ impl JsonRenderer<'_> {\n             .into_iter()\n             .flatten()\n             .filter_map(|clean::ItemLink { link, did, .. }| {\n-                did.map(|did| (link.clone(), from_item_id(did.into())))\n+                did.map(|did| (link.clone(), from_item_id(&did.into())))\n             })\n             .collect();\n         let docs = item.attrs.collapsed_doc_value();\n@@ -41,14 +41,15 @@ impl JsonRenderer<'_> {\n             .map(rustc_ast_pretty::pprust::attribute_to_string)\n             .collect();\n         let span = item.span(self.tcx);\n-        let clean::Item { name, attrs: _, kind: _, visibility, def_id, cfg: _ } = item;\n+        let clean::Item { name, attrs: _, kind: _, visibility, ref def_id, cfg: _ } = item;\n+        let def_id = def_id.clone();\n         let inner = match *item.kind {\n             clean::StrippedItem(_) => return None,\n             _ => from_clean_item(item, self.tcx),\n         };\n         Some(Item {\n-            id: from_item_id(def_id),\n             crate_id: def_id.krate().as_u32(),\n+            id: from_item_id(&def_id),\n             name: name.map(|sym| sym.to_string()),\n             span: self.convert_span(span),\n             visibility: self.convert_visibility(visibility),\n@@ -86,7 +87,7 @@ impl JsonRenderer<'_> {\n             Inherited => Visibility::Default,\n             Restricted(did) if did.index == CRATE_DEF_INDEX => Visibility::Crate,\n             Restricted(did) => Visibility::Restricted {\n-                parent: from_item_id(did.into()),\n+                parent: from_item_id(&did.into()),\n                 path: self.tcx.def_path(did).to_string_no_crate_verbose(),\n             },\n         }\n@@ -170,7 +171,7 @@ impl FromWithTcx<clean::TypeBindingKind> for TypeBindingKind {\n     }\n }\n \n-crate fn from_item_id(did: ItemId) -> Id {\n+crate fn from_item_id(did: &ItemId) -> Id {\n     match did {\n         ItemId::DefId(did) => Id(format!(\"{}:{}\", did.krate.as_u32(), u32::from(did.index))),\n         _ => todo!(\"how should json ItemId's be represented?\"),\n@@ -373,7 +374,7 @@ impl FromWithTcx<clean::Type> for Type {\n         match ty {\n             ResolvedPath { path, did, is_generic: _ } => Type::ResolvedPath {\n                 name: path.whole_name(),\n-                id: from_item_id(did.into()),\n+                id: from_item_id(&did.into()),\n                 args: path.segments.last().map(|args| Box::new(args.clone().args.into_tcx(tcx))),\n                 param_names: Vec::new(),\n             },\n@@ -385,7 +386,7 @@ impl FromWithTcx<clean::Type> for Type {\n \n                 Type::ResolvedPath {\n                     name: path.whole_name(),\n-                    id: from_item_id(id.into()),\n+                    id: from_item_id(&id.into()),\n                     args: path\n                         .segments\n                         .last()\n@@ -566,13 +567,13 @@ impl FromWithTcx<clean::Import> for Import {\n             Simple(s) => Import {\n                 source: import.source.path.whole_name(),\n                 name: s.to_string(),\n-                id: import.source.did.map(ItemId::from).map(from_item_id),\n+                id: import.source.did.map(ItemId::from).as_ref().map(from_item_id),\n                 glob: false,\n             },\n             Glob => Import {\n                 source: import.source.path.whole_name(),\n                 name: import.source.path.last_name().to_string(),\n-                id: import.source.did.map(ItemId::from).map(from_item_id),\n+                id: import.source.did.map(ItemId::from).as_ref().map(from_item_id),\n                 glob: true,\n             },\n         }\n@@ -666,5 +667,5 @@ impl FromWithTcx<ItemType> for ItemKind {\n }\n \n fn ids(items: impl IntoIterator<Item = clean::Item>) -> Vec<Id> {\n-    items.into_iter().filter(|x| !x.is_stripped()).map(|i| from_item_id(i.def_id)).collect()\n+    items.into_iter().filter(|x| !x.is_stripped()).map(|i| from_item_id(&i.def_id)).collect()\n }"}, {"sha": "06c66ce55406e898a6cbd9b4f360895c1262b77b", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=45d3daece364e4cf6b6bc4668dcfd7670197b1e8", "patch": "@@ -53,7 +53,7 @@ impl JsonRenderer<'tcx> {\n                     .map(|i| {\n                         let item = &i.impl_item;\n                         self.item(item.clone()).unwrap();\n-                        from_item_id(item.def_id)\n+                        from_item_id(&item.def_id)\n                     })\n                     .collect()\n             })\n@@ -71,7 +71,7 @@ impl JsonRenderer<'tcx> {\n                         let item = &i.impl_item;\n                         if item.def_id.is_local() {\n                             self.item(item.clone()).unwrap();\n-                            Some(from_item_id(item.def_id))\n+                            Some(from_item_id(&item.def_id))\n                         } else {\n                             None\n                         }\n@@ -91,9 +91,9 @@ impl JsonRenderer<'tcx> {\n                     let trait_item = &trait_item.trait_;\n                     trait_item.items.clone().into_iter().for_each(|i| self.item(i).unwrap());\n                     Some((\n-                        from_item_id(id.into()),\n+                        from_item_id(&id.into()),\n                         types::Item {\n-                            id: from_item_id(id.into()),\n+                            id: from_item_id(&id.into()),\n                             crate_id: id.krate.as_u32(),\n                             name: self\n                                 .cache\n@@ -161,7 +161,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n         // Flatten items that recursively store other items\n         item.kind.inner_items().for_each(|i| self.item(i.clone()).unwrap());\n \n-        let id = item.def_id;\n+        let id = item.def_id.clone();\n         if let Some(mut new_item) = self.convert_item(item) {\n             if let types::ItemEnum::Trait(ref mut t) = new_item.inner {\n                 t.implementors = self.get_trait_implementors(id.expect_def_id())\n@@ -170,7 +170,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n             } else if let types::ItemEnum::Enum(ref mut e) = new_item.inner {\n                 e.impls = self.get_impls(id.expect_def_id())\n             }\n-            let removed = self.index.borrow_mut().insert(from_item_id(id), new_item.clone());\n+            let removed = self.index.borrow_mut().insert(from_item_id(&id), new_item.clone());\n \n             // FIXME(adotinthevoid): Currently, the index is duplicated. This is a sanity check\n             // to make sure the items are unique. The main place this happens is when an item, is\n@@ -207,7 +207,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                 .chain(self.cache.external_paths.clone().into_iter())\n                 .map(|(k, (path, kind))| {\n                     (\n-                        from_item_id(k.into()),\n+                        from_item_id(&k.into()),\n                         types::ItemSummary {\n                             crate_id: k.krate.as_u32(),\n                             path,"}, {"sha": "9d02ae2507290a9e1a8a7e827aeb4e557d8739a5", "filename": "src/librustdoc/passes/bare_urls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs?ref=45d3daece364e4cf6b6bc4668dcfd7670197b1e8", "patch": "@@ -58,7 +58,7 @@ crate fn check_bare_urls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n \n impl<'a, 'tcx> DocFolder for BareUrlsLinter<'a, 'tcx> {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n-        let hir_id = match DocContext::as_local_hir_id(self.cx.tcx, item.def_id) {\n+        let hir_id = match DocContext::as_local_hir_id(self.cx.tcx, &item.def_id) {\n             Some(hir_id) => hir_id,\n             None => {\n                 // If non-local, no need to check anything."}, {"sha": "61623bac27e7313f92ad5267eed994a4995af9c9", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=45d3daece364e4cf6b6bc4668dcfd7670197b1e8", "patch": "@@ -838,41 +838,34 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n         // find item's parent to resolve `Self` in item's docs below\n         debug!(\"looking for the `Self` type\");\n-        let self_id = match item.def_id.as_def_id() {\n-            None => None,\n-            Some(did)\n-                if (matches!(self.cx.tcx.def_kind(did), DefKind::Field)\n-                    && matches!(\n-                        self.cx.tcx.def_kind(self.cx.tcx.parent(did).unwrap()),\n-                        DefKind::Variant\n-                    )) =>\n+        let self_id = item.def_id.as_def_id().and_then(|did| {\n+            if (matches!(self.cx.tcx.def_kind(did), DefKind::Field)\n+                && matches!(\n+                    self.cx.tcx.def_kind(self.cx.tcx.parent(did).unwrap()),\n+                    DefKind::Variant\n+                ))\n             {\n                 self.cx.tcx.parent(did).and_then(|item_id| self.cx.tcx.parent(item_id))\n-            }\n-            Some(did)\n-                if matches!(\n-                    self.cx.tcx.def_kind(did),\n-                    DefKind::AssocConst\n-                        | DefKind::AssocFn\n-                        | DefKind::AssocTy\n-                        | DefKind::Variant\n-                        | DefKind::Field\n-                ) =>\n-            {\n+            } else if matches!(\n+                self.cx.tcx.def_kind(did),\n+                DefKind::AssocConst\n+                    | DefKind::AssocFn\n+                    | DefKind::AssocTy\n+                    | DefKind::Variant\n+                    | DefKind::Field\n+            ) {\n                 self.cx.tcx.parent(did)\n-            }\n-            Some(did) => match self.cx.tcx.parent(did) {\n+            } else if let Some(parent) = self.cx.tcx.parent(did) {\n                 // HACK(jynelson): `clean` marks associated types as `TypedefItem`, not as `AssocTypeItem`.\n                 // Fixing this breaks `fn render_deref_methods`.\n                 // As a workaround, see if the parent of the item is an `impl`; if so this must be an associated item,\n                 // regardless of what rustdoc wants to call it.\n-                Some(parent) => {\n-                    let parent_kind = self.cx.tcx.def_kind(parent);\n-                    Some(if parent_kind == DefKind::Impl { parent } else { did })\n-                }\n-                None => Some(did),\n-            },\n-        };\n+                let parent_kind = self.cx.tcx.def_kind(parent);\n+                Some(if parent_kind == DefKind::Impl { parent } else { did })\n+            } else {\n+                Some(did)\n+            }\n+        });\n \n         // FIXME(jynelson): this shouldn't go through stringification, rustdoc should just use the DefId directly\n         let self_name = self_id.and_then(|self_id| {\n@@ -916,7 +909,12 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             for md_link in markdown_links(&doc) {\n                 let link = self.resolve_link(&item, &doc, &self_name, parent_node, krate, md_link);\n                 if let Some(link) = link {\n-                    self.cx.cache.intra_doc_links.entry(item.def_id).or_default().push(link);\n+                    self.cx\n+                        .cache\n+                        .intra_doc_links\n+                        .entry(item.def_id.clone())\n+                        .or_default()\n+                        .push(link);\n                 }\n             }\n         }\n@@ -1712,7 +1710,7 @@ fn report_diagnostic(\n     DiagnosticInfo { item, ori_link: _, dox, link_range }: &DiagnosticInfo<'_>,\n     decorate: impl FnOnce(&mut DiagnosticBuilder<'_>, Option<rustc_span::Span>),\n ) {\n-    let hir_id = match DocContext::as_local_hir_id(tcx, item.def_id) {\n+    let hir_id = match DocContext::as_local_hir_id(tcx, &item.def_id) {\n         Some(hir_id) => hir_id,\n         None => {\n             // If non-local, no need to check anything."}, {"sha": "d589c697fa6a5a87ec33e85a9f05dccd9f409d3e", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=45d3daece364e4cf6b6bc4668dcfd7670197b1e8", "patch": "@@ -46,7 +46,7 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n                 // FIXME(eddyb) is this `doc(hidden)` check needed?\n                 if !cx.tcx.get_attrs(def_id).lists(sym::doc).has_word(sym::hidden) {\n                     let impls = get_auto_trait_and_blanket_impls(cx, def_id.into());\n-                    new_items.extend(impls.filter(|i| cx.inlined.insert(i.def_id)));\n+                    new_items.extend(impls.filter(|i| cx.inlined.insert(i.def_id.clone())));\n                 }\n             });\n         }\n@@ -165,7 +165,7 @@ impl ItemCollector {\n \n impl DocFolder for ItemCollector {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        self.items.insert(i.def_id);\n+        self.items.insert(i.def_id.clone());\n \n         Some(self.fold_item_recur(i))\n     }"}, {"sha": "c3a30661e50463004dcda0f861d01f5776dd79fe", "filename": "src/librustdoc/passes/doc_test_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs?ref=45d3daece364e4cf6b6bc4668dcfd7670197b1e8", "patch": "@@ -84,7 +84,7 @@ crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> boo\n }\n \n crate fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n-    let hir_id = match DocContext::as_local_hir_id(cx.tcx, item.def_id) {\n+    let hir_id = match DocContext::as_local_hir_id(cx.tcx, &item.def_id) {\n         Some(hir_id) => hir_id,\n         None => {\n             // If non-local, no need to check anything."}, {"sha": "ad9f80c2e6c1393a079181ffe878c5c385bede76", "filename": "src/librustdoc/passes/html_tags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs?ref=45d3daece364e4cf6b6bc4668dcfd7670197b1e8", "patch": "@@ -168,7 +168,7 @@ fn extract_tags(\n impl<'a, 'tcx> DocFolder for InvalidHtmlTagsLinter<'a, 'tcx> {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n         let tcx = self.cx.tcx;\n-        let hir_id = match DocContext::as_local_hir_id(tcx, item.def_id) {\n+        let hir_id = match DocContext::as_local_hir_id(tcx, &item.def_id) {\n             Some(hir_id) => hir_id,\n             None => {\n                 // If non-local, no need to check anything."}, {"sha": "b0c745edbba5b0e52edf25b2e6c6835940b5964e", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=45d3daece364e4cf6b6bc4668dcfd7670197b1e8", "patch": "@@ -52,7 +52,7 @@ impl<'a> DocFolder for Stripper<'a> {\n             }\n         } else {\n             if self.update_retained {\n-                self.retained.insert(i.def_id);\n+                self.retained.insert(i.def_id.clone());\n             }\n         }\n         Some(self.fold_item_recur(i))"}, {"sha": "6ee7179c5db844aed3604f0e8777e5178adbf32c", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d3daece364e4cf6b6bc4668dcfd7670197b1e8/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=45d3daece364e4cf6b6bc4668dcfd7670197b1e8", "patch": "@@ -100,15 +100,15 @@ impl<'a> DocFolder for Stripper<'a> {\n \n         let i = if fastreturn {\n             if self.update_retained {\n-                self.retained.insert(i.def_id);\n+                self.retained.insert(i.def_id.clone());\n             }\n             return Some(i);\n         } else {\n             self.fold_item_recur(i)\n         };\n \n         if self.update_retained {\n-            self.retained.insert(i.def_id);\n+            self.retained.insert(i.def_id.clone());\n         }\n         Some(i)\n     }"}]}