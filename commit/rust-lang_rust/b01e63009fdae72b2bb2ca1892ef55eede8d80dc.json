{"sha": "b01e63009fdae72b2bb2ca1892ef55eede8d80dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwMWU2MzAwOWZkYWU3MmIyYmIyY2ExODkyZWY1NWVlZGU4ZDgwZGM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-17T20:41:57Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-17T23:48:13Z"}, "message": "Refactor the per-module node map `module_children` into a per-resolver map.", "tree": {"sha": "20b6cf646378d342832f793ef04886b3627d1ca6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20b6cf646378d342832f793ef04886b3627d1ca6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b01e63009fdae72b2bb2ca1892ef55eede8d80dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b01e63009fdae72b2bb2ca1892ef55eede8d80dc", "html_url": "https://github.com/rust-lang/rust/commit/b01e63009fdae72b2bb2ca1892ef55eede8d80dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b01e63009fdae72b2bb2ca1892ef55eede8d80dc/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b12832012c4d92296889d03737f0705ac2d5698", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b12832012c4d92296889d03737f0705ac2d5698", "html_url": "https://github.com/rust-lang/rust/commit/5b12832012c4d92296889d03737f0705ac2d5698"}], "stats": {"total": 44, "additions": 22, "deletions": 22}, "files": [{"sha": "effc751c507593f6974d1cd1b6f3c656f8fac5fe", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b01e63009fdae72b2bb2ca1892ef55eede8d80dc/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01e63009fdae72b2bb2ca1892ef55eede8d80dc/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b01e63009fdae72b2bb2ca1892ef55eede8d80dc", "patch": "@@ -260,7 +260,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                 let def = Def::Mod(self.ast_map.local_def_id(item.id));\n                 let module = self.new_module(parent_link, Some(def), false, vis);\n                 self.define(parent, name, TypeNS, (module, sp));\n-                parent.module_children.borrow_mut().insert(item.id, module);\n+                self.module_map.insert(item.id, module);\n                 *parent_ref = module;\n             }\n \n@@ -398,7 +398,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n \n             let parent_link = BlockParentLink(parent, block_id);\n             let new_module = self.new_module(parent_link, None, false, parent.vis);\n-            parent.module_children.borrow_mut().insert(block_id, new_module);\n+            self.module_map.insert(block_id, new_module);\n             *parent = new_module;\n         }\n     }"}, {"sha": "d5e0d35950fa9a5fb039bb94dded871fea38841a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b01e63009fdae72b2bb2ca1892ef55eede8d80dc/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01e63009fdae72b2bb2ca1892ef55eede8d80dc/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b01e63009fdae72b2bb2ca1892ef55eede8d80dc", "patch": "@@ -827,22 +827,6 @@ pub struct ModuleS<'a> {\n     resolutions: RefCell<HashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n     unresolved_imports: RefCell<Vec<&'a ImportDirective<'a>>>,\n \n-    // The module children of this node, including normal modules and anonymous modules.\n-    // Anonymous children are pseudo-modules that are implicitly created around items\n-    // contained within blocks.\n-    //\n-    // For example, if we have this:\n-    //\n-    //  fn f() {\n-    //      fn g() {\n-    //          ...\n-    //      }\n-    //  }\n-    //\n-    // There will be an anonymous module created around `g` with the ID of the\n-    // entry block for `f`.\n-    module_children: RefCell<NodeMap<Module<'a>>>,\n-\n     prelude: RefCell<Option<Module<'a>>>,\n \n     glob_importers: RefCell<Vec<(Module<'a>, &'a ImportDirective<'a>)>>,\n@@ -871,7 +855,6 @@ impl<'a> ModuleS<'a> {\n             extern_crate_id: None,\n             resolutions: RefCell::new(HashMap::new()),\n             unresolved_imports: RefCell::new(Vec::new()),\n-            module_children: RefCell::new(NodeMap()),\n             prelude: RefCell::new(None),\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new((Vec::new())),\n@@ -1078,6 +1061,22 @@ pub struct Resolver<'a, 'tcx: 'a> {\n     export_map: ExportMap,\n     trait_map: TraitMap,\n \n+    // A map from nodes to modules, both normal (`mod`) modules and anonymous modules.\n+    // Anonymous modules are pseudo-modules that are implicitly created around items\n+    // contained within blocks.\n+    //\n+    // For example, if we have this:\n+    //\n+    //  fn f() {\n+    //      fn g() {\n+    //          ...\n+    //      }\n+    //  }\n+    //\n+    // There will be an anonymous module created around `g` with the ID of the\n+    // entry block for `f`.\n+    module_map: NodeMap<Module<'a>>,\n+\n     // Whether or not to print error messages. Can be set to true\n     // when getting additional info for error message suggestions,\n     // so as to avoid printing duplicate errors\n@@ -1179,6 +1178,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             freevars_seen: NodeMap(),\n             export_map: NodeMap(),\n             trait_map: NodeMap(),\n+            module_map: NodeMap(),\n             used_imports: HashSet::new(),\n             used_crates: HashSet::new(),\n \n@@ -1578,7 +1578,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn with_scope<F>(&mut self, id: NodeId, f: F)\n         where F: FnOnce(&mut Resolver)\n     {\n-        if let Some(module) = self.current_module.module_children.borrow().get(&id) {\n+        let module = self.module_map.get(&id).cloned(); // clones a reference\n+        if let Some(module) = module {\n             // Move down in the graph.\n             let orig_module = ::std::mem::replace(&mut self.current_module, module);\n             self.value_ribs.push(Rib::new(ModuleRibKind(module)));\n@@ -2129,8 +2130,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         debug!(\"(resolving block) entering block\");\n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module;\n-        let anonymous_module =\n-            orig_module.module_children.borrow().get(&block.id).map(|module| *module);\n+        let anonymous_module = self.module_map.get(&block.id).cloned(); // clones a reference\n \n         if let Some(anonymous_module) = anonymous_module {\n             debug!(\"(resolving block) found anonymous module, moving down\");"}]}