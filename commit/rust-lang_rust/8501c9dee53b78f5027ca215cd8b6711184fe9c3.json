{"sha": "8501c9dee53b78f5027ca215cd8b6711184fe9c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1MDFjOWRlZTUzYjc4ZjUwMjdjYTIxNWNkOGI2NzExMTg0ZmU5YzM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-23T21:24:41Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-24T12:16:02Z"}, "message": "rustc_typeck: unify the impl type with the UFCS path prefix type.", "tree": {"sha": "59466dafbbc2d716a8c6e93e8407303ae003e8be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59466dafbbc2d716a8c6e93e8407303ae003e8be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8501c9dee53b78f5027ca215cd8b6711184fe9c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8501c9dee53b78f5027ca215cd8b6711184fe9c3", "html_url": "https://github.com/rust-lang/rust/commit/8501c9dee53b78f5027ca215cd8b6711184fe9c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8501c9dee53b78f5027ca215cd8b6711184fe9c3/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0efa2d84347ed0081476f04f42efe4be85ae4d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0efa2d84347ed0081476f04f42efe4be85ae4d6", "html_url": "https://github.com/rust-lang/rust/commit/f0efa2d84347ed0081476f04f42efe4be85ae4d6"}], "stats": {"total": 39, "additions": 32, "deletions": 7}, "files": [{"sha": "d7a11b8a5152f933e4e6b05149f85b3838a8c111", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8501c9dee53b78f5027ca215cd8b6711184fe9c3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8501c9dee53b78f5027ca215cd8b6711184fe9c3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8501c9dee53b78f5027ca215cd8b6711184fe9c3", "patch": "@@ -4748,9 +4748,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     assert!(segments.len() >= 1);\n \n-    // In `<T as Trait<A, B>>::method`, `A` and `B` are mandatory.\n-    let mut require_type_space = opt_self_ty.is_some();\n-\n+    let mut ufcs_method = None;\n     let mut segment_spaces: Vec<_>;\n     match def {\n         // Case 1 and 1b. Reference to a *type* or *enum variant*.\n@@ -4777,8 +4775,8 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         // Case 3. Reference to a method.\n-        def::DefMethod(_, providence) => {\n-            match providence {\n+        def::DefMethod(_, provenance) => {\n+            match provenance {\n                 def::FromTrait(trait_did) => {\n                     callee::check_legal_trait_for_method_call(fcx.ccx, span, trait_did)\n                 }\n@@ -4791,9 +4789,9 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 segment_spaces.push(Some(subst::FnSpace));\n             } else {\n                 // `<T>::method` will end up here, and so can `T::method`.\n-                assert!(opt_self_ty.is_some());\n-                require_type_space = false;\n+                let self_ty = opt_self_ty.expect(\"UFCS sugared method missing Self\");\n                 segment_spaces = vec![Some(subst::FnSpace)];\n+                ufcs_method = Some((provenance, self_ty));\n             }\n         }\n \n@@ -4812,6 +4810,11 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n     assert_eq!(segment_spaces.len(), segments.len());\n \n+    // In `<T as Trait<A, B>>::method`, `A` and `B` are mandatory, but\n+    // `opt_self_ty` can also be Some for `Foo::method`, where Foo's\n+    // type parameters are not mandatory.\n+    let require_type_space = opt_self_ty.is_some() && ufcs_method.is_none();\n+\n     debug!(\"segment_spaces={:?}\", segment_spaces);\n \n     // Next, examine the definition, and determine how many type\n@@ -4879,6 +4882,28 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // the referenced item.\n     let ty_substituted = fcx.instantiate_type_scheme(span, &substs, &type_scheme.ty);\n \n+\n+    if let Some((def::FromImpl(impl_def_id), self_ty)) = ufcs_method {\n+        // In the case of `Foo<T>::method` and `<Foo<T>>::method`, if `method`\n+        // is inherent, there is no `Self` parameter, instead, the impl needs\n+        // type parameters, which we can infer by unifying the provided `Self`\n+        // with the substituted impl type.\n+        let impl_scheme = ty::lookup_item_type(fcx.tcx(), impl_def_id);\n+        assert_eq!(substs.types.len(subst::TypeSpace),\n+                   impl_scheme.generics.types.len(subst::TypeSpace));\n+        assert_eq!(substs.regions().len(subst::TypeSpace),\n+                   impl_scheme.generics.regions.len(subst::TypeSpace));\n+\n+        let impl_ty = fcx.instantiate_type_scheme(span, &substs, &impl_scheme.ty);\n+        if fcx.mk_subty(false, infer::Misc(span), self_ty, impl_ty).is_err() {\n+            fcx.tcx().sess.span_bug(span,\n+            &format!(\n+                \"instantiate_path: (UFCS) {} was a subtype of {} but now is not?\",\n+                self_ty.repr(fcx.tcx()),\n+                impl_ty.repr(fcx.tcx())));\n+        }\n+    }\n+\n     fcx.write_ty(node_id, ty_substituted);\n     fcx.write_substs(node_id, ty::ItemSubsts { substs: substs });\n     return;"}]}