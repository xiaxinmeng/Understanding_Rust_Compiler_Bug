{"sha": "a57aea88d4620008ff06ed8e23f093a2e88b33f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1N2FlYTg4ZDQ2MjAwMDhmZjA2ZWQ4ZTIzZjA5M2EyZTg4YjMzZjk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-12-03T10:55:58Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-12-03T11:04:28Z"}, "message": "rustc: expose the mir::Body reference lifetime from mir::ReadOnlyBodyCache (#64736 fallout).", "tree": {"sha": "6448aa8a7ff066c1068270c23b825398d1cde151", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6448aa8a7ff066c1068270c23b825398d1cde151"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a57aea88d4620008ff06ed8e23f093a2e88b33f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a57aea88d4620008ff06ed8e23f093a2e88b33f9", "html_url": "https://github.com/rust-lang/rust/commit/a57aea88d4620008ff06ed8e23f093a2e88b33f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a57aea88d4620008ff06ed8e23f093a2e88b33f9/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4810cf1d1b27377e9c3633e4c1e820e197b270ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/4810cf1d1b27377e9c3633e4c1e820e197b270ac", "html_url": "https://github.com/rust-lang/rust/commit/4810cf1d1b27377e9c3633e4c1e820e197b270ac"}], "stats": {"total": 132, "additions": 62, "deletions": 70}, "files": [{"sha": "95e9f098da3fb35649878448eaffba42b7d0208c", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=a57aea88d4620008ff06ed8e23f093a2e88b33f9", "patch": "@@ -279,18 +279,10 @@ impl<'a, 'b, 'tcx> graph::GraphSuccessors<'b> for ReadOnlyBodyCache<'a, 'tcx> {\n \n \n impl Deref for ReadOnlyBodyCache<'a, 'tcx> {\n-    type Target = Body<'tcx>;\n+    type Target = &'a Body<'tcx>;\n \n     fn deref(&self) -> &Self::Target {\n-        self.body\n-    }\n-}\n-\n-impl Index<BasicBlock> for ReadOnlyBodyCache<'a, 'tcx> {\n-    type Output = BasicBlockData<'tcx>;\n-\n-    fn index(&self, index: BasicBlock) -> &BasicBlockData<'tcx> {\n-        &self.body[index]\n+        &self.body\n     }\n }\n "}, {"sha": "6c627085b2ed8734c4b868d022f0764e7d38015f", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=a57aea88d4620008ff06ed8e23f093a2e88b33f9", "patch": "@@ -131,7 +131,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             };\n             if is_consume {\n                 let base_ty =\n-                    mir::Place::ty_from(place_ref.base, proj_base, &*self.fx.mir, cx.tcx());\n+                    mir::Place::ty_from(place_ref.base, proj_base, *self.fx.mir, cx.tcx());\n                 let base_ty = self.fx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access."}, {"sha": "1b0663e0d24dcb3a42e5ab3d4d21e11272dc4729", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=a57aea88d4620008ff06ed8e23f093a2e88b33f9", "patch": "@@ -324,7 +324,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         target: mir::BasicBlock,\n         unwind: Option<mir::BasicBlock>,\n     ) {\n-        let ty = location.ty(&*self.mir, bx.tcx()).ty;\n+        let ty = location.ty(*self.mir, bx.tcx()).ty;\n         let ty = self.monomorphize(&ty);\n         let drop_fn = Instance::resolve_drop_in_place(bx.tcx(), ty);\n \n@@ -510,7 +510,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         let extra_args = &args[sig.inputs().len()..];\n         let extra_args = extra_args.iter().map(|op_arg| {\n-            let op_ty = op_arg.ty(&*self.mir, bx.tcx());\n+            let op_ty = op_arg.ty(*self.mir, bx.tcx());\n             self.monomorphize(&op_ty)\n         }).collect::<Vec<_>>();\n "}, {"sha": "e2507394ce68170a8d610f4360a7c1eb1fe9d093", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=a57aea88d4620008ff06ed8e23f093a2e88b33f9", "patch": "@@ -594,7 +594,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let place_ty = mir::Place::ty_from(\n             place_ref.base,\n             place_ref.projection,\n-            &*self.mir,\n+            *self.mir,\n             tcx,\n         );\n         self.monomorphize(&place_ty.ty)"}, {"sha": "488ae8dbf9036c91701a4f3038564679b558851b", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=a57aea88d4620008ff06ed8e23f093a2e88b33f9", "patch": "@@ -460,7 +460,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::Discriminant(ref place) => {\n-                let discr_ty = rvalue.ty(&*self.mir, bx.tcx());\n+                let discr_ty = rvalue.ty(*self.mir, bx.tcx());\n                 let discr =  self.codegen_place(&mut bx, &place.as_ref())\n                     .codegen_get_discr(&mut bx, discr_ty);\n                 (bx, OperandRef {\n@@ -513,7 +513,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::Rvalue::Aggregate(..) => {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n-                let ty = rvalue.ty(&*self.mir, self.cx.tcx());\n+                let ty = rvalue.ty(*self.mir, self.cx.tcx());\n                 let operand = OperandRef::new_zst(\n                     &mut bx,\n                     self.cx.layout_of(self.monomorphize(&ty)),\n@@ -710,7 +710,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 true,\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) => {\n-                let ty = rvalue.ty(&*self.mir, self.cx.tcx());\n+                let ty = rvalue.ty(*self.mir, self.cx.tcx());\n                 let ty = self.monomorphize(&ty);\n                 self.cx.spanned_layout_of(ty, span).is_zst()\n             }"}, {"sha": "b1e327cdb0ef3c42d4d03ace8c5be38d574b09af", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=a57aea88d4620008ff06ed8e23f093a2e88b33f9", "patch": "@@ -208,7 +208,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let ty = Place::ty_from(\n                 used_place.base,\n                 used_place.projection,\n-                &*self.body,\n+                *self.body,\n                 self.infcx.tcx\n             ).ty;\n             let needs_note = match ty.kind {\n@@ -225,7 +225,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let mpi = self.move_data.moves[move_out_indices[0]].path;\n                 let place = &self.move_data.move_paths[mpi].place;\n \n-                let ty = place.ty(&*self.body, self.infcx.tcx).ty;\n+                let ty = place.ty(*self.body, self.infcx.tcx).ty;\n                 let opt_name =\n                     self.describe_place_with_options(place.as_ref(), IncludingDowncast(true));\n                 let note_msg = match opt_name {\n@@ -625,7 +625,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let ty = Place::ty_from(\n                 place_base,\n                 place_projection,\n-                &*self.body,\n+                *self.body,\n                 self.infcx.tcx\n             ).ty;\n             ty.ty_adt_def().filter(|adt| adt.is_union()).map(|_| ty)\n@@ -1635,7 +1635,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 Place::ty_from(\n                                     &place.base,\n                                     proj_base,\n-                                    &*self.body,\n+                                    *self.body,\n                                     tcx\n                                 ).ty.is_box(),\n                                 \"Drop of value behind a reference or raw pointer\"\n@@ -1648,7 +1648,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         let base_ty = Place::ty_from(\n                             &place.base,\n                             proj_base,\n-                            &*self.body,\n+                            *self.body,\n                             tcx\n                         ).ty;\n                         match base_ty.kind {"}, {"sha": "9953d2807437a31711b6d970c786c8bb9c1f486f", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=a57aea88d4620008ff06ed8e23f093a2e88b33f9", "patch": "@@ -372,7 +372,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     let base_ty = Place::ty_from(\n                         place.base,\n                         place.projection,\n-                        &*self.body,\n+                        *self.body,\n                         self.infcx.tcx).ty;\n                     self.describe_field_from_ty(&base_ty, field, Some(*variant_index))\n                 }\n@@ -502,7 +502,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         ..\n                     }) = bbd.terminator {\n                         if let Some(source) = BorrowedContentSource::from_call(\n-                            func.ty(&*self.body, tcx),\n+                            func.ty(*self.body, tcx),\n                             tcx\n                         ) {\n                             return source;\n@@ -519,7 +519,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let base_ty = Place::ty_from(\n             deref_base.base,\n             deref_base.projection,\n-            &*self.body,\n+            *self.body,\n             tcx\n         ).ty;\n         if base_ty.is_unsafe_ptr() {"}, {"sha": "bacff0b3e54d2eb446faf00e850351ffbb9d92ef", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=a57aea88d4620008ff06ed8e23f093a2e88b33f9", "patch": "@@ -646,7 +646,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n                 let tcx = self.infcx.tcx;\n \n                 // Compute the type with accurate region information.\n-                let drop_place_ty = drop_place.ty(&*self.body, self.infcx.tcx);\n+                let drop_place_ty = drop_place.ty(*self.body, self.infcx.tcx);\n \n                 // Erase the regions.\n                 let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty).ty;"}, {"sha": "fd779767d7a890a5b2cdb20762642d377eca3462", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=a57aea88d4620008ff06ed8e23f093a2e88b33f9", "patch": "@@ -300,7 +300,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         // Inspect the type of the content behind the\n         // borrow to provide feedback about why this\n         // was a move rather than a copy.\n-        let ty = deref_target_place.ty(&*self.body, self.infcx.tcx).ty;\n+        let ty = deref_target_place.ty(*self.body, self.infcx.tcx).ty;\n         let upvar_field = self.prefixes(move_place.as_ref(), PrefixSet::All)\n             .find_map(|p| self.is_upvar_field_projection(p));\n \n@@ -411,7 +411,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         };\n         let move_ty = format!(\n             \"{:?}\",\n-            move_place.ty(&*self.body, self.infcx.tcx).ty,\n+            move_place.ty(*self.body, self.infcx.tcx).ty,\n         );\n         if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n             let is_option = move_ty.starts_with(\"std::option::Option\");\n@@ -454,7 +454,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n \n                 if binds_to.is_empty() {\n-                    let place_ty = move_from.ty(&*self.body, self.infcx.tcx).ty;\n+                    let place_ty = move_from.ty(*self.body, self.infcx.tcx).ty;\n                     let place_desc = match self.describe_place(move_from.as_ref()) {\n                         Some(desc) => format!(\"`{}`\", desc),\n                         None => format!(\"value\"),\n@@ -482,7 +482,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // No binding. Nothing to suggest.\n             GroupedMoveError::OtherIllegalMove { ref original_path, use_spans, .. } => {\n                 let span = use_spans.var_or_use();\n-                let place_ty = original_path.ty(&*self.body, self.infcx.tcx).ty;\n+                let place_ty = original_path.ty(*self.body, self.infcx.tcx).ty;\n                 let place_desc = match self.describe_place(original_path.as_ref()) {\n                     Some(desc) => format!(\"`{}`\", desc),\n                     None => format!(\"value\"),"}, {"sha": "98a7b101d56f755386d243dfa979253b7d1a815e", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=a57aea88d4620008ff06ed8e23f093a2e88b33f9", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     Place::ty_from(\n                         &the_place_err.base,\n                         proj_base,\n-                        &*self.body,\n+                        *self.body,\n                         self.infcx.tcx\n                     ).ty));\n \n@@ -115,7 +115,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         Place::ty_from(\n                             the_place_err.base,\n                             the_place_err.projection,\n-                            &*self.body,\n+                            *self.body,\n                             self.infcx.tcx\n                         )\n                         .ty\n@@ -229,7 +229,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 if let Some((span, message)) = annotate_struct_field(\n                     self.infcx.tcx,\n-                    Place::ty_from(base, proj_base, &*self.body, self.infcx.tcx).ty,\n+                    Place::ty_from(base, proj_base, *self.body, self.infcx.tcx).ty,\n                     field,\n                 ) {\n                     err.span_suggestion(\n@@ -304,7 +304,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(base, proj_base, &*self.body, self.infcx.tcx).ty\n+                    Place::ty_from(base, proj_base, *self.body, self.infcx.tcx).ty\n                 ));\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));"}, {"sha": "de304202a08406ebda6507868dc39307dd5bd8c2", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=a57aea88d4620008ff06ed8e23f093a2e88b33f9", "patch": "@@ -1413,9 +1413,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     _ => ConstraintCategory::Assignment,\n                 };\n \n-                let place_ty = place.ty(&*body, tcx).ty;\n+                let place_ty = place.ty(*body, tcx).ty;\n                 let place_ty = self.normalize(place_ty, location);\n-                let rv_ty = rv.ty(&*body, tcx);\n+                let rv_ty = rv.ty(*body, tcx);\n                 let rv_ty = self.normalize(rv_ty, location);\n                 if let Err(terr) =\n                     self.sub_types_or_anon(rv_ty, place_ty, location.to_locations(), category)\n@@ -1467,7 +1467,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 ref place,\n                 variant_index,\n             } => {\n-                let place_type = place.ty(&*body, tcx).ty;\n+                let place_type = place.ty(*body, tcx).ty;\n                 let adt = match place_type.kind {\n                     ty::Adt(adt, _) if adt.is_enum() => adt,\n                     _ => {\n@@ -1489,7 +1489,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 };\n             }\n             StatementKind::AscribeUserType(box(ref place, ref projection), variance) => {\n-                let place_ty = place.ty(&*body, tcx).ty;\n+                let place_ty = place.ty(*body, tcx).ty;\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,\n                     variance,\n@@ -2010,7 +2010,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     // While this is located in `nll::typeck` this error is not an NLL error, it's\n                     // a required check to make sure that repeated elements implement `Copy`.\n                     let span = body.source_info(location).span;\n-                    let ty = operand.ty(&*body, tcx);\n+                    let ty = operand.ty(*body, tcx);\n                     if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n                         // To determine if `const_in_array_repeat_expressions` feature gate should\n                         // be mentioned, need to check if the rvalue is promotable.\n@@ -2064,7 +2064,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             Rvalue::Cast(cast_kind, op, ty) => {\n                 match cast_kind {\n                     CastKind::Pointer(PointerCast::ReifyFnPointer) => {\n-                        let fn_sig = op.ty(&*body, tcx).fn_sig(tcx);\n+                        let fn_sig = op.ty(*body, tcx).fn_sig(tcx);\n \n                         // The type that we see in the fcx is like\n                         // `foo::<'a, 'b>`, where `foo` is the path to a\n@@ -2093,7 +2093,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::ClosureFnPointer(unsafety)) => {\n-                        let sig = match op.ty(&*body, tcx).kind {\n+                        let sig = match op.ty(*body, tcx).kind {\n                             ty::Closure(def_id, substs) => {\n                                 substs.as_closure().sig_ty(def_id, tcx).fn_sig(tcx)\n                             }\n@@ -2119,7 +2119,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::UnsafeFnPointer) => {\n-                        let fn_sig = op.ty(&*body, tcx).fn_sig(tcx);\n+                        let fn_sig = op.ty(*body, tcx).fn_sig(tcx);\n \n                         // The type that we see in the fcx is like\n                         // `foo::<'a, 'b>`, where `foo` is the path to a\n@@ -2151,7 +2151,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let &ty = ty;\n                         let trait_ref = ty::TraitRef {\n                             def_id: tcx.lang_items().coerce_unsized_trait().unwrap(),\n-                            substs: tcx.mk_substs_trait(op.ty(&*body, tcx), &[ty.into()]),\n+                            substs: tcx.mk_substs_trait(op.ty(*body, tcx), &[ty.into()]),\n                         };\n \n                         self.prove_trait_ref(\n@@ -2162,7 +2162,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::MutToConstPointer) => {\n-                        let ty_from = match op.ty(&*body, tcx).kind {\n+                        let ty_from = match op.ty(*body, tcx).kind {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_from,\n                                 mutbl: hir::Mutability::Mutable,\n@@ -2210,7 +2210,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::ArrayToPointer)  => {\n-                        let ty_from = op.ty(&*body, tcx);\n+                        let ty_from = op.ty(*body, tcx);\n \n                         let opt_ty_elem = match ty_from.kind {\n                             ty::RawPtr(\n@@ -2272,7 +2272,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Misc => {\n-                        let ty_from = op.ty(&*body, tcx);\n+                        let ty_from = op.ty(*body, tcx);\n                         let cast_ty_from = CastTy::from_ty(ty_from);\n                         let cast_ty_to = CastTy::from_ty(ty);\n                         match (cast_ty_from, cast_ty_to) {\n@@ -2339,9 +2339,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             | Rvalue::BinaryOp(BinOp::Le, left, right)\n             | Rvalue::BinaryOp(BinOp::Gt, left, right)\n             | Rvalue::BinaryOp(BinOp::Ge, left, right) => {\n-                let ty_left = left.ty(&*body, tcx);\n+                let ty_left = left.ty(*body, tcx);\n                 if let ty::RawPtr(_) | ty::FnPtr(_) = ty_left.kind {\n-                    let ty_right = right.ty(&*body, tcx);\n+                    let ty_right = right.ty(*body, tcx);\n                     let common_ty = self.infcx.next_ty_var(\n                         TypeVariableOrigin {\n                             kind: TypeVariableOriginKind::MiscVariable,"}, {"sha": "b58bf737a3575313bbd89539395e560caad3404d", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=a57aea88d4620008ff06ed8e23f093a2e88b33f9", "patch": "@@ -143,7 +143,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                     // derefs, except we stop at the deref of a shared\n                     // reference.\n \n-                    let ty = Place::ty_from(cursor.base, proj_base, &*self.body, self.tcx).ty;\n+                    let ty = Place::ty_from(cursor.base, proj_base, *self.body, self.tcx).ty;\n                     match ty.kind {\n                         ty::RawPtr(_) |\n                         ty::Ref("}, {"sha": "223a5f8d605fcc518594a0fc0951c3d894e2bc2d", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=a57aea88d4620008ff06ed8e23f093a2e88b33f9", "patch": "@@ -51,7 +51,7 @@ pub trait Qualif {\n             });\n             let qualif = base_qualif && Self::in_any_value_of_ty(\n                 cx,\n-                Place::ty_from(place.base, proj_base, &*cx.body, cx.tcx)\n+                Place::ty_from(place.base, proj_base, *cx.body, cx.tcx)\n                     .projection_ty(cx.tcx, elem)\n                     .ty,\n             );\n@@ -155,7 +155,7 @@ pub trait Qualif {\n                 // Special-case reborrows to be more like a copy of the reference.\n                 if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n                     if ProjectionElem::Deref == elem {\n-                        let base_ty = Place::ty_from(&place.base, proj_base, &*cx.body, cx.tcx).ty;\n+                        let base_ty = Place::ty_from(&place.base, proj_base, *cx.body, cx.tcx).ty;\n                         if let ty::Ref(..) = base_ty.kind {\n                             return Self::in_place(cx, per_local, PlaceRef {\n                                 base: &place.base,\n@@ -221,7 +221,7 @@ impl Qualif for HasMutInterior {\n             Rvalue::Aggregate(ref kind, _) => {\n                 if let AggregateKind::Adt(def, ..) = **kind {\n                     if Some(def.did) == cx.tcx.lang_items().unsafe_cell_type() {\n-                        let ty = rvalue.ty(&*cx.body, cx.tcx);\n+                        let ty = rvalue.ty(*cx.body, cx.tcx);\n                         assert_eq!(Self::in_any_value_of_ty(cx, ty), true);\n                         return true;\n                     }"}, {"sha": "cb542484be6336c9d717771556cfa067a52d708c", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=a57aea88d4620008ff06ed8e23f093a2e88b33f9", "patch": "@@ -77,7 +77,7 @@ where\n         args: &[mir::Operand<'tcx>],\n         return_place: &mir::Place<'tcx>,\n     ) {\n-        let return_ty = return_place.ty(&*self.item.body, self.item.tcx).ty;\n+        let return_ty = return_place.ty(*self.item.body, self.item.tcx).ty;\n         let qualif = Q::in_call(\n             self.item,\n             &|l| self.qualifs_per_local.contains(l),"}, {"sha": "663a5243e8fe22dc15d137254feb11f11ca1660d", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=a57aea88d4620008ff06ed8e23f093a2e88b33f9", "patch": "@@ -304,7 +304,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         // Special-case reborrows to be more like a copy of a reference.\n         if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n-            if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, &*self.body, place) {\n+            if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, *self.body, place) {\n                 let ctx = match kind {\n                     BorrowKind::Shared => PlaceContext::NonMutatingUse(\n                         NonMutatingUseContext::SharedBorrow,\n@@ -342,7 +342,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             | Rvalue::Ref(_, kind @ BorrowKind::Mut { .. }, ref place)\n             | Rvalue::Ref(_, kind @ BorrowKind::Unique, ref place)\n             => {\n-                let ty = place.ty(&*self.body, self.tcx).ty;\n+                let ty = place.ty(*self.body, self.tcx).ty;\n                 let is_allowed = match ty.kind {\n                     // Inside a `static mut`, `&mut [...]` is allowed.\n                     ty::Array(..) | ty::Slice(_) if self.const_kind() == ConstKind::StaticMut\n@@ -390,7 +390,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             }\n \n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n-                let operand_ty = operand.ty(&*self.body, self.tcx);\n+                let operand_ty = operand.ty(*self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n \n@@ -401,7 +401,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(&*self.body, self.tcx).kind {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(*self.body, self.tcx).kind {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n                             op == BinOp::Ge || op == BinOp::Gt ||\n@@ -475,7 +475,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         match elem {\n             ProjectionElem::Deref => {\n-                let base_ty = Place::ty_from(place_base, proj_base, &*self.body, self.tcx).ty;\n+                let base_ty = Place::ty_from(place_base, proj_base, *self.body, self.tcx).ty;\n                 if let ty::RawPtr(_) = base_ty.kind {\n                     if proj_base.is_empty() {\n                         if let (PlaceBase::Local(local), []) = (place_base, proj_base) {\n@@ -499,7 +499,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             ProjectionElem::Subslice {..} |\n             ProjectionElem::Field(..) |\n             ProjectionElem::Index(_) => {\n-                let base_ty = Place::ty_from(place_base, proj_base, &*self.body, self.tcx).ty;\n+                let base_ty = Place::ty_from(place_base, proj_base, *self.body, self.tcx).ty;\n                 match base_ty.ty_adt_def() {\n                     Some(def) if def.is_union() => {\n                         self.check_op(ops::UnionAccess);\n@@ -548,7 +548,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         match kind {\n             TerminatorKind::Call { func, .. } => {\n-                let fn_ty = func.ty(&*self.body, self.tcx);\n+                let fn_ty = func.ty(*self.body, self.tcx);\n \n                 let def_id = match fn_ty.kind {\n                     ty::FnDef(def_id, _) => def_id,\n@@ -609,7 +609,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 // Check to see if the type of this place can ever have a drop impl. If not, this\n                 // `Drop` terminator is frivolous.\n                 let ty_needs_drop = dropped_place\n-                    .ty(&*self.body, self.tcx)\n+                    .ty(*self.body, self.tcx)\n                     .ty\n                     .needs_drop(self.tcx, self.param_env);\n "}, {"sha": "c758ccfd11d919e3e985bef10bff4d1852608971", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57aea88d4620008ff06ed8e23f093a2e88b33f9/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=a57aea88d4620008ff06ed8e23f093a2e88b33f9", "patch": "@@ -350,7 +350,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                                 let ty = Place::ty_from(\n                                         &place.base,\n                                         proj_base,\n-                                        &*self.body,\n+                                        *self.body,\n                                         self.tcx\n                                     )\n                                     .projection_ty(self.tcx, elem)\n@@ -373,7 +373,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                         }\n \n                         if let BorrowKind::Mut { .. } = kind {\n-                            let ty = place.ty(&*self.body, self.tcx).ty;\n+                            let ty = place.ty(*self.body, self.tcx).ty;\n \n                             // In theory, any zero-sized value could be borrowed\n                             // mutably without consequences. However, only &mut []\n@@ -522,7 +522,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     ProjectionElem::Field(..) => {\n                         if self.const_kind.is_none() {\n                             let base_ty =\n-                                Place::ty_from(place.base, proj_base, &*self.body, self.tcx).ty;\n+                                Place::ty_from(place.base, proj_base, *self.body, self.tcx).ty;\n                             if let Some(def) = base_ty.ty_adt_def() {\n                                 // No promotion of union field accesses.\n                                 if def.is_union() {\n@@ -571,7 +571,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n     fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n         match *rvalue {\n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if self.const_kind.is_none() => {\n-                let operand_ty = operand.ty(&*self.body, self.tcx);\n+                let operand_ty = operand.ty(*self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                 match (cast_in, cast_out) {\n@@ -585,7 +585,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) if self.const_kind.is_none() => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(&*self.body, self.tcx).kind {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(*self.body, self.tcx).kind {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n                             op == BinOp::Ge || op == BinOp::Gt ||\n@@ -620,7 +620,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n             Rvalue::Ref(_, kind, place) => {\n                 if let BorrowKind::Mut { .. } = kind {\n-                    let ty = place.ty(&*self.body, self.tcx).ty;\n+                    let ty = place.ty(*self.body, self.tcx).ty;\n \n                     // In theory, any zero-sized value could be borrowed\n                     // mutably without consequences. However, only &mut []\n@@ -647,7 +647,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 let mut place = place.as_ref();\n                 if let [proj_base @ .., ProjectionElem::Deref] = &place.projection {\n                     let base_ty =\n-                        Place::ty_from(&place.base, proj_base, &*self.body, self.tcx).ty;\n+                        Place::ty_from(&place.base, proj_base, *self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n                         place = PlaceRef {\n                             base: &place.base,\n@@ -673,7 +673,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     while let [proj_base @ .., elem] = place_projection {\n                         // FIXME(eddyb) this is probably excessive, with\n                         // the exception of `union` member accesses.\n-                        let ty = Place::ty_from(place.base, proj_base, &*self.body, self.tcx)\n+                        let ty = Place::ty_from(place.base, proj_base, *self.body, self.tcx)\n                             .projection_ty(self.tcx, elem)\n                             .ty;\n                         if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n@@ -706,7 +706,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n         callee: &Operand<'tcx>,\n         args: &[Operand<'tcx>],\n     ) -> Result<(), Unpromotable> {\n-        let fn_ty = callee.ty(&*self.body, self.tcx);\n+        let fn_ty = callee.ty(*self.body, self.tcx);\n \n         if !self.explicit && self.const_kind.is_none() {\n             if let ty::FnDef(def_id, _) = fn_ty.kind {"}]}