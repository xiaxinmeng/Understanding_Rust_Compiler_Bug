{"sha": "536e71b78f46acb75e08481708a93bd07c0a107a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNmU3MWI3OGY0NmFjYjc1ZTA4NDgxNzA4YTkzYmQwN2MwYTEwN2E=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-07-04T02:46:54Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-07-04T14:51:30Z"}, "message": "rustc: compute the vtable base of a supertrait during selection. Fixes #26339.", "tree": {"sha": "0f5bc860e5a9387359171dae943fd7f9ea4c0d31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f5bc860e5a9387359171dae943fd7f9ea4c0d31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/536e71b78f46acb75e08481708a93bd07c0a107a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/536e71b78f46acb75e08481708a93bd07c0a107a", "html_url": "https://github.com/rust-lang/rust/commit/536e71b78f46acb75e08481708a93bd07c0a107a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/536e71b78f46acb75e08481708a93bd07c0a107a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96d24a5c58718fbd1800fb56a49166a320f65556", "url": "https://api.github.com/repos/rust-lang/rust/commits/96d24a5c58718fbd1800fb56a49166a320f65556", "html_url": "https://github.com/rust-lang/rust/commit/96d24a5c58718fbd1800fb56a49166a320f65556"}], "stats": {"total": 218, "additions": 117, "deletions": 101}, "files": [{"sha": "b5f01ada7e1789d4467eb62ee88c06564c5c9d3d", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/536e71b78f46acb75e08481708a93bd07c0a107a/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/536e71b78f46acb75e08481708a93bd07c0a107a/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=536e71b78f46acb75e08481708a93bd07c0a107a", "patch": "@@ -291,11 +291,13 @@ pub struct VtableBuiltinData<N> {\n /// for the object type `Foo`.\n #[derive(PartialEq,Eq,Clone)]\n pub struct VtableObjectData<'tcx> {\n-    /// the object type `Foo`.\n-    pub object_ty: Ty<'tcx>,\n-\n     /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n     pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n+\n+    /// The vtable is formed by concatenating together the method lists of\n+    /// the base object trait and all supertraits; this is the start of\n+    /// `upcast_trait_ref`'s methods in that vtable.\n+    pub vtable_base: usize\n }\n \n /// Creates predicate obligations from the generic bounds."}, {"sha": "e29d9646509f9eac17bbe26a44620d8628e6143b", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/536e71b78f46acb75e08481708a93bd07c0a107a/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/536e71b78f46acb75e08481708a93bd07c0a107a/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=536e71b78f46acb75e08481708a93bd07c0a107a", "patch": "@@ -629,9 +629,10 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation:  &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n-    object_ty: Ty<'tcx>)\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n {\n+    let self_ty = obligation_trait_ref.self_ty();\n+    let object_ty = selcx.infcx().shallow_resolve(self_ty);\n     debug!(\"assemble_candidates_from_object_type(object_ty={:?})\",\n            object_ty);\n     let data = match object_ty.sty {\n@@ -684,10 +685,9 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n             candidate_set.vec.push(\n                 ProjectionTyCandidate::Impl(data));\n         }\n-        super::VtableObject(data) => {\n+        super::VtableObject(_) => {\n             assemble_candidates_from_object_type(\n-                selcx, obligation, obligation_trait_ref, candidate_set,\n-                data.object_ty);\n+                selcx, obligation, obligation_trait_ref, candidate_set);\n         }\n         super::VtableClosure(data) => {\n             candidate_set.vec.push("}, {"sha": "ad91f664af2db6ac7289cb2336be3eab7cefbb9f", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 32, "deletions": 41, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/536e71b78f46acb75e08481708a93bd07c0a107a/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/536e71b78f46acb75e08481708a93bd07c0a107a/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=536e71b78f46acb75e08481708a93bd07c0a107a", "patch": "@@ -1362,12 +1362,21 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={:?}\",\n                    poly_trait_ref);\n \n-            // see whether the object trait can be upcast to the trait we are looking for\n-            let upcast_trait_refs = self.upcast(poly_trait_ref, obligation);\n-            if upcast_trait_refs.len() > 1 {\n+            // Count only those upcast versions that match the trait-ref\n+            // we are looking for. Specifically, do not only check for the\n+            // correct trait, but also the correct type parameters.\n+            // For example, we may be trying to upcast `Foo` to `Bar<i32>`,\n+            // but `Foo` is declared as `trait Foo : Bar<u32>`.\n+            let upcast_trait_refs = util::supertraits(self.tcx(), poly_trait_ref)\n+                .filter(|upcast_trait_ref| self.infcx.probe(|_| {\n+                    let upcast_trait_ref = upcast_trait_ref.clone();\n+                    self.match_poly_trait_ref(obligation, upcast_trait_ref).is_ok()\n+                })).count();\n+\n+            if upcast_trait_refs > 1 {\n                 // can be upcast in many ways; need more type information\n                 candidates.ambiguous = true;\n-            } else if upcast_trait_refs.len() == 1 {\n+            } else if upcast_trait_refs == 1 {\n                 candidates.vec.push(ObjectCandidate);\n             }\n \n@@ -2305,20 +2314,28 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // be exactly one applicable trait-reference; if this were not\n         // the case, we would have reported an ambiguity error rather\n         // than successfully selecting one of the candidates.\n-        let upcast_trait_refs = self.upcast(poly_trait_ref.clone(), obligation);\n-        assert_eq!(upcast_trait_refs.len(), 1);\n-        let upcast_trait_ref = upcast_trait_refs.into_iter().next().unwrap();\n+        let mut upcast_trait_refs = util::supertraits(self.tcx(), poly_trait_ref)\n+            .map(|upcast_trait_ref| {\n+                (upcast_trait_ref.clone(), self.infcx.probe(|_| {\n+                    self.match_poly_trait_ref(obligation, upcast_trait_ref)\n+                }).is_ok())\n+            });\n+        let mut upcast_trait_ref = None;\n+        let mut vtable_base = 0;\n \n-        match self.match_poly_trait_ref(obligation, upcast_trait_ref.clone()) {\n-            Ok(()) => { }\n-            Err(()) => {\n-                self.tcx().sess.span_bug(obligation.cause.span,\n-                                         \"failed to match trait refs\");\n+        while let Some((supertrait, matches)) = upcast_trait_refs.next() {\n+            if matches {\n+                upcast_trait_ref = Some(supertrait);\n+                break;\n             }\n+            vtable_base += util::count_own_vtable_entries(self.tcx(), supertrait);\n         }\n+        assert!(upcast_trait_refs.all(|(_, matches)| !matches));\n \n-        VtableObjectData { object_ty: self_ty,\n-                           upcast_trait_ref: upcast_trait_ref }\n+        VtableObjectData {\n+            upcast_trait_ref: upcast_trait_ref.unwrap(),\n+            vtable_base: vtable_base\n+        }\n     }\n \n     fn confirm_fn_pointer_candidate(&mut self,\n@@ -2719,7 +2736,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     /// Returns `Ok` if `poly_trait_ref` being true implies that the\n     /// obligation is satisfied.\n-    fn match_poly_trait_ref(&mut self,\n+    fn match_poly_trait_ref(&self,\n                             obligation: &TraitObligation<'tcx>,\n                             poly_trait_ref: ty::PolyTraitRef<'tcx>)\n                             -> Result<(),()>\n@@ -2930,32 +2947,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             obligation.cause.clone()\n         }\n     }\n-\n-    /// Upcasts an object trait-reference into those that match the obligation.\n-    fn upcast(&mut self, obj_trait_ref: ty::PolyTraitRef<'tcx>, obligation: &TraitObligation<'tcx>)\n-              -> Vec<ty::PolyTraitRef<'tcx>>\n-    {\n-        debug!(\"upcast(obj_trait_ref={:?}, obligation={:?})\",\n-               obj_trait_ref,\n-               obligation);\n-\n-        let obligation_def_id = obligation.predicate.def_id();\n-        let mut upcast_trait_refs = util::upcast(self.tcx(), obj_trait_ref, obligation_def_id);\n-\n-        // Retain only those upcast versions that match the trait-ref\n-        // we are looking for.  In particular, we know that all of\n-        // `upcast_trait_refs` apply to the correct trait, but\n-        // possibly with incorrect type parameters. For example, we\n-        // may be trying to upcast `Foo` to `Bar<i32>`, but `Foo` is\n-        // declared as `trait Foo : Bar<u32>`.\n-        upcast_trait_refs.retain(|upcast_trait_ref| {\n-            let upcast_trait_ref = upcast_trait_ref.clone();\n-            self.infcx.probe(|_| self.match_poly_trait_ref(obligation, upcast_trait_ref)).is_ok()\n-        });\n-\n-        debug!(\"upcast: upcast_trait_refs={:?}\", upcast_trait_refs);\n-        upcast_trait_refs\n-    }\n }\n \n impl<'tcx> SelectionCache<'tcx> {"}, {"sha": "af9d5e5157d28e8567b3ecf2a72602e208184cbb", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/536e71b78f46acb75e08481708a93bd07c0a107a/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/536e71b78f46acb75e08481708a93bd07c0a107a/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=536e71b78f46acb75e08481708a93bd07c0a107a", "patch": "@@ -396,50 +396,45 @@ pub fn upcast<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .collect()\n }\n \n-/// Given an object of type `object_trait_ref`, returns the index of\n-/// the method `method_def_id` (which should be part of a supertrait\n-/// of `object_trait_ref`) within the vtable for `object_trait_ref`.\n-pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                               object_trait_ref: ty::PolyTraitRef<'tcx>,\n-                                               method_def_id: ast::DefId) -> usize {\n-    // We need to figure the \"real index\" of the method in a\n-    // listing of all the methods of an object. We do this by\n-    // iterating down the supertraits of the object's trait until\n-    // we find the trait the method came from, counting up the\n-    // methods from them.\n-    let mut method_count = 0;\n-\n-    let trait_def_id = tcx.impl_or_trait_item(method_def_id).container().id();\n-\n-    for bound_ref in transitive_bounds(tcx, &[object_trait_ref]) {\n-        if bound_ref.def_id() == trait_def_id {\n-            break;\n-        }\n-\n-        let trait_items = tcx.trait_items(bound_ref.def_id());\n-        for trait_item in trait_items.iter() {\n-            match *trait_item {\n-                ty::MethodTraitItem(_) => method_count += 1,\n-                _ => {}\n-            }\n+/// Given an trait `trait_ref`, returns the number of vtable entries\n+/// that come from `trait_ref`, excluding its supertraits. Used in\n+/// computing the vtable base for an upcast trait of a trait object.\n+pub fn count_own_vtable_entries<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                      trait_ref: ty::PolyTraitRef<'tcx>)\n+                                      -> usize {\n+    let mut entries = 0;\n+    // Count number of methods and add them to the total offset.\n+    // Skip over associated types and constants.\n+    for trait_item in &tcx.trait_items(trait_ref.def_id())[..] {\n+        if let ty::MethodTraitItem(_) = *trait_item {\n+            entries += 1;\n         }\n     }\n+    entries\n+}\n \n-    // count number of methods preceding the one we are selecting and\n-    // add them to the total offset; skip over associated types.\n-    for trait_item in &tcx.trait_items(trait_def_id)[..] {\n+/// Given an upcast trait object described by `object`, returns the\n+/// index of the method `method_def_id` (which should be part of\n+/// `object.upcast_trait_ref`) within the vtable for `object`.\n+pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                               object: &super::VtableObjectData<'tcx>,\n+                                               method_def_id: ast::DefId) -> usize {\n+    // Count number of methods preceding the one we are selecting and\n+    // add them to the total offset.\n+    // Skip over associated types and constants.\n+    let mut entries = object.vtable_base;\n+    for trait_item in &tcx.trait_items(object.upcast_trait_ref.def_id())[..] {\n         if trait_item.def_id() == method_def_id {\n             // The item with the ID we were given really ought to be a method.\n             assert!(match *trait_item {\n                 ty::MethodTraitItem(_) => true,\n                 _ => false\n             });\n \n-            return method_count;\n+            return entries;\n         }\n-        match *trait_item {\n-            ty::MethodTraitItem(_) => method_count += 1,\n-            _ => {}\n+        if let ty::MethodTraitItem(_) = *trait_item {\n+            entries += 1;\n         }\n     }\n \n@@ -493,7 +488,7 @@ impl<'tcx, N:fmt::Debug> fmt::Debug for super::Vtable<'tcx, N> {\n                 write!(f, \"VtableFnPointer({:?})\", d),\n \n             super::VtableObject(ref d) =>\n-                write!(f, \"VtableObject({:?})\", d),\n+                write!(f, \"{:?}\", d),\n \n             super::VtableParam(ref n) =>\n                 write!(f, \"VtableParam({:?})\", n),\n@@ -538,7 +533,9 @@ impl<'tcx, N:fmt::Debug> fmt::Debug for super::VtableDefaultImplData<N> {\n \n impl<'tcx> fmt::Debug for super::VtableObjectData<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableObject(object_ty={:?})\", self.object_ty)\n+        write!(f, \"VtableObject(upcast={:?}, vtable_base={})\",\n+               self.upcast_trait_ref,\n+               self.vtable_base)\n     }\n }\n "}, {"sha": "7016c1484659b7165da31aa66a5a778434824852", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/536e71b78f46acb75e08481708a93bd07c0a107a/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/536e71b78f46acb75e08481708a93bd07c0a107a/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=536e71b78f46acb75e08481708a93bd07c0a107a", "patch": "@@ -492,8 +492,8 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableObjectData<'tcx> {\n         traits::VtableObjectData {\n-            object_ty: self.object_ty.fold_with(folder),\n             upcast_trait_ref: self.upcast_trait_ref.fold_with(folder),\n+            vtable_base: self.vtable_base\n         }\n     }\n }"}, {"sha": "2cab7d2a1c84a396af6de90326687ca9901e6219", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/536e71b78f46acb75e08481708a93bd07c0a107a/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/536e71b78f46acb75e08481708a93bd07c0a107a/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=536e71b78f46acb75e08481708a93bd07c0a107a", "patch": "@@ -160,20 +160,6 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-fn method_offset_in_object_vtable<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                        object_ty: Ty<'tcx>,\n-                                        method_id: ast::DefId)\n-                                        -> usize {\n-    if let ty::TyTrait(ref data) = object_ty.sty {\n-        let trait_ref = data.principal_trait_ref_with_self_ty(tcx, object_ty);\n-        traits::get_vtable_index_of_object_method(tcx, trait_ref, method_id)\n-    } else {\n-        tcx.sess.bug(&format!(\n-            \"trans::methd::object_ty_to_trait_ref() called on non-object: {:?}\",\n-            object_ty));\n-    }\n-}\n-\n pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                             method_id: ast::DefId,\n                                             trait_id: ast::DefId,\n@@ -285,7 +271,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      callee_substs)\n         }\n         traits::VtableObject(ref data) => {\n-            let idx = method_offset_in_object_vtable(tcx, data.object_ty, method_id);\n+            let idx = traits::get_vtable_index_of_object_method(tcx, data, method_id);\n             trans_object_shim(ccx,\n                               data.upcast_trait_ref.clone(),\n                               method_id,\n@@ -384,7 +370,7 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         traits::VtableObject(ref data) => {\n-            let idx = method_offset_in_object_vtable(bcx.tcx(), data.object_ty, method_id);\n+            let idx = traits::get_vtable_index_of_object_method(bcx.tcx(), data, method_id);\n             if let Some(self_expr) = self_expr {\n                 if let ty::TyBareFn(_, ref fty) = monomorphize_type(bcx, method_ty).sty {\n                     let ty = bcx.tcx().mk_fn(None, opaque_method_ty(bcx.tcx(), fty));"}, {"sha": "f2cf1779d6241bd43ce98acdde2b85e7998b11cb", "filename": "src/test/run-pass/traits-issue-26339.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/536e71b78f46acb75e08481708a93bd07c0a107a/src%2Ftest%2Frun-pass%2Ftraits-issue-26339.rs", "raw_url": "https://github.com/rust-lang/rust/raw/536e71b78f46acb75e08481708a93bd07c0a107a/src%2Ftest%2Frun-pass%2Ftraits-issue-26339.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-issue-26339.rs?ref=536e71b78f46acb75e08481708a93bd07c0a107a", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the right implementation is called through a trait\n+// object when supertraits include multiple references to the\n+// same trait, with different type parameters.\n+\n+trait A: PartialEq<Foo> + PartialEq<Bar> { }\n+\n+struct Foo;\n+struct Bar;\n+\n+struct Aimpl;\n+\n+impl PartialEq<Foo> for Aimpl {\n+    fn eq(&self, _rhs: &Foo) -> bool {\n+        true\n+    }\n+}\n+\n+impl PartialEq<Bar> for Aimpl {\n+    fn eq(&self, _rhs: &Bar) -> bool {\n+        false\n+    }\n+}\n+\n+impl A for Aimpl { }\n+\n+fn main() {\n+    let a = &Aimpl as &A;\n+\n+    assert!(*a == Foo);\n+}"}]}