{"sha": "8defd152b35f6b397445ce420f22227a5e623a1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkZWZkMTUyYjM1ZjZiMzk3NDQ1Y2U0MjBmMjIyMjdhNWU2MjNhMWE=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-08-14T16:46:04Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-08-14T16:46:04Z"}, "message": "`{to,from}_{ne,le,be}_bytes` for unsigned integer types\n\nSame as https://github.com/rust-lang/rust/pull/51919 did for signed integers.\n\nTracking issue: https://github.com/rust-lang/rust/issues/52963", "tree": {"sha": "23f38b6314ff95144a0a6f901a55953a153043b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23f38b6314ff95144a0a6f901a55953a153043b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8defd152b35f6b397445ce420f22227a5e623a1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8defd152b35f6b397445ce420f22227a5e623a1a", "html_url": "https://github.com/rust-lang/rust/commit/8defd152b35f6b397445ce420f22227a5e623a1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8defd152b35f6b397445ce420f22227a5e623a1a/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bb923988f949639f11dba0c1ab1980fe8dfec3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bb923988f949639f11dba0c1ab1980fe8dfec3d", "html_url": "https://github.com/rust-lang/rust/commit/5bb923988f949639f11dba0c1ab1980fe8dfec3d"}], "stats": {"total": 104, "additions": 88, "deletions": 16}, "files": [{"sha": "feaedf4b909125f75e9388572e9a143e0daf61f5", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 88, "deletions": 16, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/8defd152b35f6b397445ce420f22227a5e623a1a/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8defd152b35f6b397445ce420f22227a5e623a1a/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=8defd152b35f6b397445ce420f22227a5e623a1a", "patch": "@@ -3568,47 +3568,119 @@ $EndFeature, \"\n             }\n         }\n \n-        /// Return the memory representation of this integer as a byte array.\n+        /// Return the memory representation of this integer as a byte array in\n+        /// big-endian (network) byte order.\n         ///\n-        /// The target platform\u2019s native endianness is used.\n-        /// Portable code likely wants to use this after [`to_be`] or [`to_le`].\n+        /// # Examples\n         ///\n-        /// [`to_be`]: #method.to_be\n-        /// [`to_le`]: #method.to_le\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n+        ///\n+        /// let bytes = 0x12345678i32.to_be_bytes();\n+        /// assert_eq!(bytes, [0x12, 0x34, 0x56, 0x78]);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        pub fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+            self.to_be().to_ne_bytes()\n+        }\n+\n+        /// Return the memory representation of this integer as a byte array in\n+        /// little-endian byte order.\n         ///\n         /// # Examples\n         ///\n         /// ```\n         /// #![feature(int_to_from_bytes)]\n         ///\n-        /// let bytes = 0x1234_5678_u32.to_be().to_bytes();\n-        /// assert_eq!(bytes, [0x12, 0x34, 0x56, 0x78]);\n+        /// let bytes = 0x12345678i32.to_le_bytes();\n+        /// assert_eq!(bytes, [0x78, 0x56, 0x34, 0x12]);\n         /// ```\n         #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n         #[inline]\n-        pub fn to_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+        pub fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+            self.to_le().to_ne_bytes()\n+        }\n+\n+        /// Return the memory representation of this integer as a byte array in\n+        /// native byte order.\n+        ///\n+        /// As the target platform's native endianness is used, portable code\n+        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n+        /// instead.\n+        ///\n+        /// [`to_be_bytes`]: #method.to_be_bytes\n+        /// [`to_le_bytes`]: #method.to_le_bytes\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n+        ///\n+        /// let bytes = i32::min_value().to_be().to_ne_bytes();\n+        /// assert_eq!(bytes, [0x80, 0, 0, 0]);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        pub fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n             unsafe { mem::transmute(self) }\n         }\n \n-        /// Create an integer value from its memory representation as a byte array.\n+        /// Create an integer value from its representation as a byte array in\n+        /// big endian.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n+        ///\n+        /// let int = i32::from_be_bytes([0x12, 0x34, 0x56, 0x78]);\n+        /// assert_eq!(int, 0x12_34_56_78);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        pub fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+            Self::from_be(Self::from_ne_bytes(bytes))\n+        }\n+\n+        /// Create an integer value from its representation as a byte array in\n+        /// little endian.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n+        ///\n+        /// let int = i32::from_le_bytes([0x12, 0x34, 0x56, 0x78]);\n+        /// assert_eq!(int, 0x78_56_34_12);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        pub fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+            Self::from_le(Self::from_ne_bytes(bytes))\n+        }\n+\n+        /// Create an integer value from its memory representation as a byte\n+        /// array in native endianness.\n         ///\n-        /// The target platform\u2019s native endianness is used.\n-        /// Portable code likely wants to use [`to_be`] or [`to_le`] after this.\n+        /// As the target platform's native endianness is used, portable code\n+        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n+        /// appropriate instead.\n         ///\n-        /// [`to_be`]: #method.to_be\n-        /// [`to_le`]: #method.to_le\n+        /// [`from_be_bytes`]: #method.from_be_bytes\n+        /// [`from_le_bytes`]: #method.from_le_bytes\n         ///\n         /// # Examples\n         ///\n         /// ```\n         /// #![feature(int_to_from_bytes)]\n         ///\n-        /// let int = u32::from_be(u32::from_bytes([0x12, 0x34, 0x56, 0x78]));\n-        /// assert_eq!(int, 0x1234_5678_u32);\n+        /// let int = i32::from_be(i32::from_ne_bytes([0x80, 0, 0, 0]));\n+        /// assert_eq!(int, i32::min_value());\n         /// ```\n         #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n         #[inline]\n-        pub fn from_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+        pub fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n             unsafe { mem::transmute(bytes) }\n         }\n     }"}]}