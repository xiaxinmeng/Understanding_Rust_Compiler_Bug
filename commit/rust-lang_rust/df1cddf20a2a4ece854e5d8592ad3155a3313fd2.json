{"sha": "df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmMWNkZGYyMGEyYTRlY2U4NTRlNWQ4NTkyYWQzMTU1YTMzMTNmZDI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-21T19:56:00Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-21T19:56:00Z"}, "message": "rollup merge of #20179: eddyb/blind-items\n\nConflicts:\n\tsrc/librustc/diagnostics.rs\n\tsrc/librustdoc/clean/mod.rs\n\tsrc/librustdoc/html/format.rs\n\tsrc/libsyntax/parse/parser.rs", "tree": {"sha": "50bdd6498e1378cbeb48e80e35157152920e9c56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50bdd6498e1378cbeb48e80e35157152920e9c56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "html_url": "https://github.com/rust-lang/rust/commit/df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "886c6f3534e6f03916eeff2ea8b235e85dd04b42", "url": "https://api.github.com/repos/rust-lang/rust/commits/886c6f3534e6f03916eeff2ea8b235e85dd04b42", "html_url": "https://github.com/rust-lang/rust/commit/886c6f3534e6f03916eeff2ea8b235e85dd04b42"}, {"sha": "2d17a33878f1af0aa500a4e1ff6aa5c8689ab249", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d17a33878f1af0aa500a4e1ff6aa5c8689ab249", "html_url": "https://github.com/rust-lang/rust/commit/2d17a33878f1af0aa500a4e1ff6aa5c8689ab249"}], "stats": {"total": 2620, "additions": 1099, "deletions": 1521}, "files": [{"sha": "9ec4708eb2f36b27c6e9857de3b13512eca1fa85", "filename": "src/doc/reference.md", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -803,8 +803,9 @@ Crates contain [items](#items), each of which may have some number of\n ## Items\n \n ```{.ebnf .gram}\n-item : mod_item | fn_item | type_item | struct_item | enum_item\n-     | static_item | trait_item | impl_item | extern_block ;\n+item : extern_crate_decl | use_decl | mod_item | fn_item | type_item\n+     | struct_item | enum_item | static_item | trait_item | impl_item\n+     | extern_block ;\n ```\n \n An _item_ is a component of a crate; some module items can be defined in crate\n@@ -818,6 +819,8 @@ execution, and may reside in read-only memory.\n \n There are several kinds of item:\n \n+* [`extern crate` declarations](#extern-crate-declarations)\n+* [`use` declarations](#use-declarations)\n * [modules](#modules)\n * [functions](#functions)\n * [type definitions](#type-definitions)\n@@ -854,13 +857,10 @@ no notion of type abstraction: there are no first-class \"forall\" types.\n \n ```{.ebnf .gram}\n mod_item : \"mod\" ident ( ';' | '{' mod '}' );\n-mod : [ view_item | item ] * ;\n+mod : item * ;\n ```\n \n-A module is a container for zero or more [view items](#view-items) and zero or\n-more [items](#items). The view items manage the visibility of the items defined\n-within the module, as well as the visibility of names from outside the module\n-when referenced from inside the module.\n+A module is a container for zero or more [items](#items).\n \n A _module item_ is a module, surrounded in braces, named, and prefixed with the\n keyword `mod`. A module item introduces a new, named module into the tree of\n@@ -918,19 +918,6 @@ mod thread {\n }\n ```\n \n-#### View items\n-\n-```{.ebnf .gram}\n-view_item : extern_crate_decl | use_decl ;\n-```\n-\n-A view item manages the namespace of a module. View items do not define new\n-items, but rather, simply change other items' visibility. There are two\n-kinds of view items:\n-\n-* [`extern crate` declarations](#extern-crate-declarations)\n-* [`use` declarations](#use-declarations)\n-\n ##### Extern crate declarations\n \n ```{.ebnf .gram}\n@@ -2887,13 +2874,12 @@ Point3d {y: 0, z: 10, .. base};\n ### Block expressions\n \n ```{.ebnf .gram}\n-block_expr : '{' [ view_item ] *\n-                 [ stmt ';' | item ] *\n+block_expr : '{' [ stmt ';' | item ] *\n                  [ expr ] '}' ;\n ```\n \n A _block expression_ is similar to a module in terms of the declarations that\n-are possible. Each block conceptually introduces a new namespace scope. View\n+are possible. Each block conceptually introduces a new namespace scope. Use\n items can bring new names into scopes and declared items are in scope for only\n the block itself.\n "}, {"sha": "04cfa16d2ed71ab0742bba92747d7eb826c7969f", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -77,6 +77,9 @@ register_diagnostics! {\n     E0138,\n     E0139,\n     E0152,\n+    E0153,\n+    E0154,\n+    E0157,\n     E0158,\n     E0161,\n     E0162,"}, {"sha": "fef1017b782858030bd90ac1e3e0a9635435bf1c", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -1202,17 +1202,17 @@ impl LintPass for UnusedImportBraces {\n         lint_array!(UNUSED_IMPORT_BRACES)\n     }\n \n-    fn check_view_item(&mut self, cx: &Context, view_item: &ast::ViewItem) {\n-        match view_item.node {\n-            ast::ViewItemUse(ref view_path) => {\n+    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n+        match item.node {\n+            ast::ItemUse(ref view_path) => {\n                 match view_path.node {\n-                    ast::ViewPathList(_, ref items, _) => {\n+                    ast::ViewPathList(_, ref items) => {\n                         if items.len() == 1 {\n                             match items[0].node {\n                                 ast::PathListIdent {ref name, ..} => {\n                                     let m = format!(\"braces around {} is unnecessary\",\n                                                     token::get_ident(*name).get());\n-                                    cx.span_lint(UNUSED_IMPORT_BRACES, view_item.span,\n+                                    cx.span_lint(UNUSED_IMPORT_BRACES, item.span,\n                                                  &m[]);\n                                 },\n                                 _ => ()\n@@ -1709,22 +1709,6 @@ impl LintPass for Stability {\n         }\n     }\n \n-    fn check_view_item(&mut self, cx: &Context, item: &ast::ViewItem) {\n-        // compiler-generated `extern crate` statements have a dummy span.\n-        if item.span == DUMMY_SP { return }\n-\n-        let id = match item.node {\n-            ast::ViewItemExternCrate(_, _, id) => id,\n-            ast::ViewItemUse(..) => return,\n-        };\n-        let cnum = match cx.tcx.sess.cstore.find_extern_mod_stmt_cnum(id) {\n-            Some(cnum) => cnum,\n-            None => return,\n-        };\n-        let id = ast::DefId { krate: cnum, node: ast::CRATE_NODE_ID };\n-        self.lint(cx, id, item.span);\n-    }\n-\n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         if self.is_internal(cx, e.span) { return; }\n \n@@ -1776,6 +1760,17 @@ impl LintPass for Stability {\n         if self.is_internal(cx, item.span) { return }\n \n         match item.node {\n+            ast::ItemExternCrate(_) => {\n+                // compiler-generated `extern crate` items have a dummy span.\n+                if item.span == DUMMY_SP { return }\n+\n+                let cnum = match cx.tcx.sess.cstore.find_extern_mod_stmt_cnum(item.id) {\n+                    Some(cnum) => cnum,\n+                    None => return,\n+                };\n+                let id = ast::DefId { krate: cnum, node: ast::CRATE_NODE_ID };\n+                self.lint(cx, id, item.span);\n+            }\n             ast::ItemTrait(_, _, ref supertraits, _) => {\n                 for t in supertraits.iter() {\n                     if let ast::TraitTyParamBound(ref t, _) = *t {"}, {"sha": "4cbfcf7e91ad1dd914507eaa2afcf4818f28ef54", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -580,14 +580,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n         })\n     }\n \n-    fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        self.with_lint_attrs(&i.attrs[], |cx| {\n-            run_lints!(cx, check_view_item, i);\n-            cx.visit_ids(|v| v.visit_view_item(i));\n-            visit::walk_view_item(cx, i);\n-        })\n-    }\n-\n     fn visit_pat(&mut self, p: &ast::Pat) {\n         run_lints!(self, check_pat, p);\n         visit::walk_pat(self, p);"}, {"sha": "a4a3f485af1d1034cfe4acc8d460ed8e00c31df4", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -128,7 +128,6 @@ pub trait LintPass {\n     fn check_crate(&mut self, _: &Context, _: &ast::Crate) { }\n     fn check_ident(&mut self, _: &Context, _: Span, _: ast::Ident) { }\n     fn check_mod(&mut self, _: &Context, _: &ast::Mod, _: Span, _: ast::NodeId) { }\n-    fn check_view_item(&mut self, _: &Context, _: &ast::ViewItem) { }\n     fn check_foreign_item(&mut self, _: &Context, _: &ast::ForeignItem) { }\n     fn check_item(&mut self, _: &Context, _: &ast::Item) { }\n     fn check_local(&mut self, _: &Context, _: &ast::Local) { }"}, {"sha": "7b71120ba64a6ea9807cb4f53dad5b3b7cc07904", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -40,10 +40,6 @@ pub struct CrateReader<'a> {\n }\n \n impl<'a, 'v> visit::Visitor<'v> for CrateReader<'a> {\n-    fn visit_view_item(&mut self, a: &ast::ViewItem) {\n-        self.process_view_item(a);\n-        visit::walk_view_item(self, a);\n-    }\n     fn visit_item(&mut self, a: &ast::Item) {\n         self.process_item(a);\n         visit::walk_item(self, a);\n@@ -64,9 +60,8 @@ fn dump_crates(cstore: &CStore) {\n     })\n }\n \n-fn should_link(i: &ast::ViewItem) -> bool {\n+fn should_link(i: &ast::Item) -> bool {\n     !attr::contains_name(&i.attrs[], \"no_link\")\n-\n }\n \n struct CrateInfo {\n@@ -181,29 +176,10 @@ impl<'a> CrateReader<'a> {\n         }\n     }\n \n-    fn process_view_item(&mut self, i: &ast::ViewItem) {\n-        if !should_link(i) {\n-            return;\n-        }\n-\n-        match self.extract_crate_info(i) {\n-            Some(info) => {\n-                let (cnum, _, _) = self.resolve_crate(&None,\n-                                                      &info.ident[],\n-                                                      &info.name[],\n-                                                      None,\n-                                                      i.span,\n-                                                      PathKind::Crate);\n-                self.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n-            }\n-            None => ()\n-        }\n-    }\n-\n-    fn extract_crate_info(&self, i: &ast::ViewItem) -> Option<CrateInfo> {\n+    fn extract_crate_info(&self, i: &ast::Item) -> Option<CrateInfo> {\n         match i.node {\n-            ast::ViewItemExternCrate(ident, ref path_opt, id) => {\n-                let ident = token::get_ident(ident);\n+            ast::ItemExternCrate(ref path_opt) => {\n+                let ident = token::get_ident(i.ident);\n                 debug!(\"resolving extern crate stmt. ident: {} path_opt: {:?}\",\n                        ident, path_opt);\n                 let name = match *path_opt {\n@@ -218,16 +194,34 @@ impl<'a> CrateReader<'a> {\n                 Some(CrateInfo {\n                     ident: ident.get().to_string(),\n                     name: name,\n-                    id: id,\n+                    id: i.id,\n                     should_link: should_link(i),\n                 })\n             }\n             _ => None\n         }\n     }\n \n-    fn process_item(&self, i: &ast::Item) {\n+    fn process_item(&mut self, i: &ast::Item) {\n         match i.node {\n+            ast::ItemExternCrate(_) => {\n+                if !should_link(i) {\n+                    return;\n+                }\n+\n+                match self.extract_crate_info(i) {\n+                    Some(info) => {\n+                        let (cnum, _, _) = self.resolve_crate(&None,\n+                                                              &info.ident[],\n+                                                              &info.name[],\n+                                                              None,\n+                                                              i.span,\n+                                                              PathKind::Crate);\n+                        self.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n+                    }\n+                    None => ()\n+                }\n+            }\n             ast::ItemForeignMod(ref fm) => {\n                 if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic {\n                     return;\n@@ -533,7 +527,7 @@ impl<'a> CrateReader<'a> {\n \n #[derive(Copy)]\n pub enum CrateOrString<'a> {\n-    Krate(&'a ast::ViewItem),\n+    Krate(&'a ast::Item),\n     Str(&'a str)\n }\n "}, {"sha": "d0989160488f2da416d39fef8a5fc143cab3092c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -1456,8 +1456,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             rbml_w.end_tag();\n         }\n       }\n-      ast::ItemMac(..) => {\n-        // macros are encoded separately\n+      ast::ItemExternCrate(_) | ast::ItemUse(_) |ast::ItemMac(..) => {\n+        // these are encoded separately\n       }\n     }\n }"}, {"sha": "537a2b3f545a2e4579e29beaa36897965b10a26f", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -332,8 +332,6 @@ impl Folder for NestedItemsDropper {\n                 }\n             }).collect();\n             let blk_sans_items = P(ast::Block {\n-                view_items: Vec::new(), // I don't know if we need the view_items\n-                                        // here, but it doesn't break tests!\n                 stmts: stmts_sans_items,\n                 expr: expr,\n                 id: id,"}, {"sha": "b93cde4bf646448b4c315279e1823cf1be0aaa49", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -297,6 +297,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     // These are normal, nothing reachable about these\n                     // inherently and their children are already in the\n                     // worklist, as determined by the privacy pass\n+                    ast::ItemExternCrate(_) | ast::ItemUse(_) |\n                     ast::ItemTy(..) | ast::ItemStatic(_, _, _) |\n                     ast::ItemMod(..) | ast::ItemForeignMod(..) |\n                     ast::ItemImpl(..) | ast::ItemTrait(..) |"}, {"sha": "030bf26699fb23778ee57f58f3d38ceb3724256c", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -94,6 +94,8 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                     // Fn lifetimes get added in visit_fn below:\n                     visit::walk_item(this, item);\n                 }\n+                ast::ItemExternCrate(_) |\n+                ast::ItemUse(_) |\n                 ast::ItemMod(..) |\n                 ast::ItemMac(..) |\n                 ast::ItemForeignMod(..) |"}, {"sha": "c420d1f15b43b1213691b3c7735ddb1635ef80b8", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -73,8 +73,10 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n     // We need to error on `#[macro_use] extern crate` when it isn't at the\n     // crate root, because `$crate` won't work properly. Identify these by\n     // spans, because the crate map isn't set up yet.\n-    for vi in krate.module.view_items.iter() {\n-        loader.span_whitelist.insert(vi.span);\n+    for item in krate.module.items.iter() {\n+        if let ast::ItemExternCrate(_) = item.node {\n+            loader.span_whitelist.insert(item.span);\n+        }\n     }\n \n     visit::walk_crate(&mut loader, krate);\n@@ -91,18 +93,21 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n \n // note that macros aren't expanded yet, and therefore macros can't add plugins.\n impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n-    fn visit_view_item(&mut self, vi: &ast::ViewItem) {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         // We're only interested in `extern crate`.\n-        match vi.node {\n-            ast::ViewItemExternCrate(..) => (),\n-            _ => return,\n+        match item.node {\n+            ast::ItemExternCrate(_) => {}\n+            _ => {\n+                visit::walk_item(self, item);\n+                return;\n+            }\n         }\n \n         // Parse the attributes relating to macro / plugin loading.\n         let mut plugin_attr = None;\n         let mut macro_selection = Some(HashSet::new());  // None => load all\n         let mut reexport = HashSet::new();\n-        for attr in vi.attrs.iter() {\n+        for attr in item.attrs.iter() {\n             let mut used = true;\n             match attr.name().get() {\n                 \"phase\" => {\n@@ -155,7 +160,10 @@ impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n             }\n         }\n \n-        self.load_plugin(CrateOrString::Krate(vi), plugin_attr, macro_selection, Some(reexport))\n+        self.load_plugin(CrateOrString::Krate(item),\n+                         plugin_attr,\n+                         macro_selection,\n+                         Some(reexport))\n     }\n \n     fn visit_mac(&mut self, _: &ast::Mac) {"}, {"sha": "ebeaf3e6e22d7e6a02d078fb09aa0734664399f4", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -182,7 +182,6 @@ mod svh_visitor {\n         SawLifetimeDef(token::InternedString),\n \n         SawMod,\n-        SawViewItem,\n         SawForeignItem,\n         SawItem,\n         SawDecl,\n@@ -430,19 +429,6 @@ mod svh_visitor {\n             SawStmt(saw_stmt(&s.node)).hash(self.st); visit::walk_stmt(self, s)\n         }\n \n-        fn visit_view_item(&mut self, i: &ViewItem) {\n-            // Two kinds of view items can affect the ABI for a crate:\n-            // exported `pub use` view items (since that may expose\n-            // items that downstream crates can call), and `use\n-            // foo::Trait`, since changing that may affect method\n-            // resolution.\n-            //\n-            // The simplest approach to handling both of the above is\n-            // just to adopt the same simple-minded (fine-grained)\n-            // hash that I am deploying elsewhere here.\n-            SawViewItem.hash(self.st); visit::walk_view_item(self, i)\n-        }\n-\n         fn visit_foreign_item(&mut self, i: &ForeignItem) {\n             // FIXME (#14132) ideally we would incorporate privacy (or\n             // perhaps reachability) somewhere here, so foreign items"}, {"sha": "582e10323248cfb80ea95f35bb78b75f052eeb83", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -477,7 +477,7 @@ impl fold::Folder for ReplaceBodyWithLoop {\n                          e: Option<P<ast::Expr>>) -> P<ast::Block> {\n             P(ast::Block {\n                 expr: e,\n-                view_items: vec![], stmts: vec![], rules: rules,\n+                stmts: vec![], rules: rules,\n                 id: ast::DUMMY_NODE_ID, span: codemap::DUMMY_SP,\n             })\n         }"}, {"sha": "cd28a27f9886bc80ccb3522f8d43ffc9d98af8e2", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -200,6 +200,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n             }\n \n             return match it.node {\n+                ast::ItemUse(..) | ast::ItemExternCrate(..) |\n                 ast::ItemConst(..) | ast::ItemStatic(..) | ast::ItemFn(..) |\n                 ast::ItemForeignMod(..) | ast::ItemTy(..) => {\n                     None"}, {"sha": "414dbb9626347598b19b54c2cdaef306cfb9baf3", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 37, "deletions": 59, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -830,6 +830,38 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n+        match item.node {\n+            ast::ItemUse(ref vpath) => {\n+                match vpath.node {\n+                    ast::ViewPathSimple(..) | ast::ViewPathGlob(..) => {}\n+                    ast::ViewPathList(ref prefix, ref list) => {\n+                        for pid in list.iter() {\n+                            match pid.node {\n+                                ast::PathListIdent { id, name } => {\n+                                    debug!(\"privacy - ident item {}\", id);\n+                                    let seg = ast::PathSegment {\n+                                        identifier: name,\n+                                        parameters: ast::PathParameters::none(),\n+                                    };\n+                                    let segs = vec![seg];\n+                                    let path = ast::Path {\n+                                        global: false,\n+                                        span: pid.span,\n+                                        segments: segs,\n+                                    };\n+                                    self.check_path(pid.span, id, &path);\n+                                }\n+                                ast::PathListMod { id } => {\n+                                    debug!(\"privacy - mod item {}\", id);\n+                                    self.check_path(pid.span, id, prefix);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n         let orig_curitem = replace(&mut self.curitem, item.id);\n         visit::walk_item(self, item);\n         self.curitem = orig_curitem;\n@@ -926,42 +958,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         visit::walk_expr(self, expr);\n     }\n \n-    fn visit_view_item(&mut self, a: &ast::ViewItem) {\n-        match a.node {\n-            ast::ViewItemExternCrate(..) => {}\n-            ast::ViewItemUse(ref vpath) => {\n-                match vpath.node {\n-                    ast::ViewPathSimple(..) | ast::ViewPathGlob(..) => {}\n-                    ast::ViewPathList(ref prefix, ref list, _) => {\n-                        for pid in list.iter() {\n-                            match pid.node {\n-                                ast::PathListIdent { id, name } => {\n-                                    debug!(\"privacy - ident item {}\", id);\n-                                    let seg = ast::PathSegment {\n-                                        identifier: name,\n-                                        parameters: ast::PathParameters::none(),\n-                                    };\n-                                    let segs = vec![seg];\n-                                    let path = ast::Path {\n-                                        global: false,\n-                                        span: pid.span,\n-                                        segments: segs,\n-                                    };\n-                                    self.check_path(pid.span, id, &path);\n-                                }\n-                                ast::PathListMod { id } => {\n-                                    debug!(\"privacy - mod item {}\", id);\n-                                    self.check_path(pid.span, id, prefix);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        visit::walk_view_item(self, a);\n-    }\n-\n     fn visit_pat(&mut self, pattern: &ast::Pat) {\n         // Foreign functions do not have their patterns mapped in the def_map,\n         // and there's nothing really relevant there anyway, so don't bother\n@@ -1069,23 +1065,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for SanePrivacyVisitor<'a, 'tcx> {\n         visit::walk_fn(self, fk, fd, b, s);\n         self.in_fn = orig_in_fn;\n     }\n-\n-    fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        match i.vis {\n-            ast::Inherited => {}\n-            ast::Public => {\n-                if self.in_fn {\n-                    self.tcx.sess.span_err(i.span, \"unnecessary `pub`, imports \\\n-                                                    in functions are never \\\n-                                                    reachable\");\n-                } else if let ast::ViewItemExternCrate(..) = i.node {\n-                    self.tcx.sess.span_err(i.span, \"`pub` visibility \\\n-                                                    is not allowed\");\n-                }\n-            }\n-        }\n-        visit::walk_view_item(self, i);\n-    }\n }\n \n impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n@@ -1162,7 +1141,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n \n             ast::ItemConst(..) | ast::ItemStatic(..) | ast::ItemStruct(..) |\n             ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n-            ast::ItemMac(..) => {}\n+            ast::ItemExternCrate(_) | ast::ItemUse(_) | ast::ItemMac(..) => {}\n         }\n     }\n \n@@ -1219,6 +1198,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n \n+            ast::ItemExternCrate(_) | ast::ItemUse(_) |\n             ast::ItemStatic(..) | ast::ItemConst(..) |\n             ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n             ast::ItemMac(..) => {}\n@@ -1521,11 +1501,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n \n     // we don't need to introspect into these at all: an\n-    // expression/block context can't possibly contain exported\n-    // things, and neither do view_items. (Making them no-ops stops us\n-    // from traversing the whole AST without having to be super\n-    // careful about our `walk_...` calls above.)\n-    fn visit_view_item(&mut self, _: &ast::ViewItem) {}\n+    // expression/block context can't possibly contain exported things.\n+    // (Making them no-ops stops us from traversing the whole AST without\n+    // having to be super careful about our `walk_...` calls above.)\n     fn visit_block(&mut self, _: &ast::Block) {}\n     fn visit_expr(&mut self, _: &ast::Expr) {}\n }"}, {"sha": "65bd83d7937fb5bc43c08c78f855562b7979653a", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 131, "deletions": 153, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -39,9 +39,9 @@ use rustc::middle::subst::FnSpace;\n use syntax::ast::{Block, Crate};\n use syntax::ast::{DeclItem, DefId};\n use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic};\n-use syntax::ast::{Item, ItemConst, ItemEnum, ItemFn};\n+use syntax::ast::{Item, ItemConst, ItemEnum, ItemExternCrate, ItemFn};\n use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n-use syntax::ast::{ItemStruct, ItemTrait, ItemTy};\n+use syntax::ast::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n use syntax::ast::{MethodImplItem, Name, NamedField, NodeId};\n use syntax::ast::{PathListIdent, PathListMod};\n use syntax::ast::{Public, SelfStatic};\n@@ -50,8 +50,7 @@ use syntax::ast::StructVariantKind;\n use syntax::ast::TupleVariantKind;\n use syntax::ast::TyObjectSum;\n use syntax::ast::{TypeImplItem, UnnamedField};\n-use syntax::ast::{Variant, ViewItem, ViewItemExternCrate};\n-use syntax::ast::{ViewItemUse, ViewPathGlob, ViewPathList, ViewPathSimple};\n+use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ast::{Visibility};\n use syntax::ast::TyPath;\n use syntax::ast;\n@@ -238,11 +237,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n-        // If the block has view items, we need an anonymous module.\n-        if block.view_items.len() > 0 {\n-            return true;\n-        }\n-\n         // Check each statement.\n         for statement in block.stmts.iter() {\n             match statement.node {\n@@ -262,7 +256,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             }\n         }\n \n-        // If we found neither view items nor items, we don't need to create\n+        // If we found no items, we don't need to create\n         // an anonymous module.\n \n         return false;\n@@ -280,6 +274,133 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n \n         match item.node {\n+            ItemUse(ref view_path) => {\n+                // Extract and intern the module part of the path. For\n+                // globs and lists, the path is found directly in the AST;\n+                // for simple paths we have to munge the path a little.\n+                let module_path = match view_path.node {\n+                    ViewPathSimple(_, ref full_path) => {\n+                        full_path.segments\n+                            .init()\n+                            .iter().map(|ident| ident.identifier.name)\n+                            .collect()\n+                    }\n+\n+                    ViewPathGlob(ref module_ident_path) |\n+                    ViewPathList(ref module_ident_path, _) => {\n+                        module_ident_path.segments\n+                            .iter().map(|ident| ident.identifier.name).collect()\n+                    }\n+                };\n+\n+                // Build up the import directives.\n+                let shadowable = item.attrs.iter().any(|attr| {\n+                    attr.name() == token::get_name(special_idents::prelude_import.name)\n+                });\n+                let shadowable = if shadowable {\n+                    Shadowable::Always\n+                } else {\n+                    Shadowable::Never\n+                };\n+\n+                match view_path.node {\n+                    ViewPathSimple(binding, ref full_path) => {\n+                        let source_name =\n+                            full_path.segments.last().unwrap().identifier.name;\n+                        if token::get_name(source_name).get() == \"mod\" ||\n+                           token::get_name(source_name).get() == \"self\" {\n+                            self.resolve_error(view_path.span,\n+                                \"`self` imports are only allowed within a { } list\");\n+                        }\n+\n+                        let subclass = SingleImport(binding.name,\n+                                                    source_name);\n+                        self.build_import_directive(&**parent,\n+                                                    module_path,\n+                                                    subclass,\n+                                                    view_path.span,\n+                                                    item.id,\n+                                                    is_public,\n+                                                    shadowable);\n+                    }\n+                    ViewPathList(_, ref source_items) => {\n+                        // Make sure there's at most one `mod` import in the list.\n+                        let mod_spans = source_items.iter().filter_map(|item| match item.node {\n+                            PathListMod { .. } => Some(item.span),\n+                            _ => None\n+                        }).collect::<Vec<Span>>();\n+                        if mod_spans.len() > 1 {\n+                            self.resolve_error(mod_spans[0],\n+                                \"`self` import can only appear once in the list\");\n+                            for other_span in mod_spans.iter().skip(1) {\n+                                self.session.span_note(*other_span,\n+                                    \"another `self` import appears here\");\n+                            }\n+                        }\n+\n+                        for source_item in source_items.iter() {\n+                            let (module_path, name) = match source_item.node {\n+                                PathListIdent { name, .. } =>\n+                                    (module_path.clone(), name.name),\n+                                PathListMod { .. } => {\n+                                    let name = match module_path.last() {\n+                                        Some(name) => *name,\n+                                        None => {\n+                                            self.resolve_error(source_item.span,\n+                                                \"`self` import can only appear in an import list \\\n+                                                 with a non-empty prefix\");\n+                                            continue;\n+                                        }\n+                                    };\n+                                    let module_path = module_path.init();\n+                                    (module_path.to_vec(), name)\n+                                }\n+                            };\n+                            self.build_import_directive(\n+                                &**parent,\n+                                module_path,\n+                                SingleImport(name, name),\n+                                source_item.span,\n+                                source_item.node.id(),\n+                                is_public,\n+                                shadowable);\n+                        }\n+                    }\n+                    ViewPathGlob(_) => {\n+                        self.build_import_directive(&**parent,\n+                                                    module_path,\n+                                                    GlobImport,\n+                                                    view_path.span,\n+                                                    item.id,\n+                                                    is_public,\n+                                                    shadowable);\n+                    }\n+                }\n+                parent.clone()\n+            }\n+\n+            ItemExternCrate(_) => {\n+                // n.b. we don't need to look at the path option here, because cstore already did\n+                for &crate_id in self.session.cstore\n+                                     .find_extern_mod_stmt_cnum(item.id).iter() {\n+                    let def_id = DefId { krate: crate_id, node: 0 };\n+                    self.external_exports.insert(def_id);\n+                    let parent_link = ModuleParentLink(parent.downgrade(), name);\n+                    let external_module = Rc::new(Module::new(parent_link,\n+                                                              Some(def_id),\n+                                                              NormalModuleKind,\n+                                                              false,\n+                                                              true));\n+                    debug!(\"(build reduced graph for item) found extern `{}`\",\n+                            self.module_to_string(&*external_module));\n+                    self.check_for_conflicts_between_external_crates(&**parent, name, sp);\n+                    parent.external_module_children.borrow_mut()\n+                          .insert(name, external_module.clone());\n+                    self.build_reduced_graph_for_external_crate(&external_module);\n+                }\n+                parent.clone()\n+            }\n+\n             ItemMod(..) => {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateModules, sp);\n \n@@ -650,145 +771,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                           variant.span, PUBLIC | IMPORTABLE);\n     }\n \n-    /// Constructs the reduced graph for one 'view item'. View items consist\n-    /// of imports and use directives.\n-    fn build_reduced_graph_for_view_item(&mut self, view_item: &ViewItem, parent: &Rc<Module>) {\n-        match view_item.node {\n-            ViewItemUse(ref view_path) => {\n-                // Extract and intern the module part of the path. For\n-                // globs and lists, the path is found directly in the AST;\n-                // for simple paths we have to munge the path a little.\n-                let module_path = match view_path.node {\n-                    ViewPathSimple(_, ref full_path, _) => {\n-                        full_path.segments\n-                            .init()\n-                            .iter().map(|ident| ident.identifier.name)\n-                            .collect()\n-                    }\n-\n-                    ViewPathGlob(ref module_ident_path, _) |\n-                    ViewPathList(ref module_ident_path, _, _) => {\n-                        module_ident_path.segments\n-                            .iter().map(|ident| ident.identifier.name).collect()\n-                    }\n-                };\n-\n-                // Build up the import directives.\n-                let is_public = view_item.vis == ast::Public;\n-                let shadowable =\n-                    view_item.attrs\n-                             .iter()\n-                             .any(|attr| {\n-                                 attr.name() == token::get_name(\n-                                    special_idents::prelude_import.name)\n-                             });\n-                let shadowable = if shadowable {\n-                    Shadowable::Always\n-                } else {\n-                    Shadowable::Never\n-                };\n-\n-                match view_path.node {\n-                    ViewPathSimple(binding, ref full_path, id) => {\n-                        let source_name =\n-                            full_path.segments.last().unwrap().identifier.name;\n-                        if token::get_name(source_name).get() == \"mod\" ||\n-                           token::get_name(source_name).get() == \"self\" {\n-                            self.resolve_error(view_path.span,\n-                                \"`self` imports are only allowed within a { } list\");\n-                        }\n-\n-                        let subclass = SingleImport(binding.name,\n-                                                    source_name);\n-                        self.build_import_directive(&**parent,\n-                                                    module_path,\n-                                                    subclass,\n-                                                    view_path.span,\n-                                                    id,\n-                                                    is_public,\n-                                                    shadowable);\n-                    }\n-                    ViewPathList(_, ref source_items, _) => {\n-                        // Make sure there's at most one `mod` import in the list.\n-                        let mod_spans = source_items.iter().filter_map(|item| match item.node {\n-                            PathListMod { .. } => Some(item.span),\n-                            _ => None\n-                        }).collect::<Vec<Span>>();\n-                        if mod_spans.len() > 1 {\n-                            self.resolve_error(mod_spans[0],\n-                                \"`self` import can only appear once in the list\");\n-                            for other_span in mod_spans.iter().skip(1) {\n-                                self.session.span_note(*other_span,\n-                                    \"another `self` import appears here\");\n-                            }\n-                        }\n-\n-                        for source_item in source_items.iter() {\n-                            let (module_path, name) = match source_item.node {\n-                                PathListIdent { name, .. } =>\n-                                    (module_path.clone(), name.name),\n-                                PathListMod { .. } => {\n-                                    let name = match module_path.last() {\n-                                        Some(name) => *name,\n-                                        None => {\n-                                            self.resolve_error(source_item.span,\n-                                                \"`self` import can only appear in an import list \\\n-                                                 with a non-empty prefix\");\n-                                            continue;\n-                                        }\n-                                    };\n-                                    let module_path = module_path.init();\n-                                    (module_path.to_vec(), name)\n-                                }\n-                            };\n-                            self.build_import_directive(\n-                                &**parent,\n-                                module_path,\n-                                SingleImport(name, name),\n-                                source_item.span,\n-                                source_item.node.id(),\n-                                is_public,\n-                                shadowable);\n-                        }\n-                    }\n-                    ViewPathGlob(_, id) => {\n-                        self.build_import_directive(&**parent,\n-                                                    module_path,\n-                                                    GlobImport,\n-                                                    view_path.span,\n-                                                    id,\n-                                                    is_public,\n-                                                    shadowable);\n-                    }\n-                }\n-            }\n-\n-            ViewItemExternCrate(name, _, node_id) => {\n-                // n.b. we don't need to look at the path option here, because cstore already did\n-                for &crate_id in self.session.cstore\n-                                     .find_extern_mod_stmt_cnum(node_id).iter() {\n-                    let def_id = DefId { krate: crate_id, node: 0 };\n-                    self.external_exports.insert(def_id);\n-                    let parent_link = ModuleParentLink(parent.downgrade(), name.name);\n-                    let external_module = Rc::new(Module::new(parent_link,\n-                                                              Some(def_id),\n-                                                              NormalModuleKind,\n-                                                              false,\n-                                                              true));\n-                    debug!(\"(build reduced graph for item) found extern `{}`\",\n-                            self.module_to_string(&*external_module));\n-                    self.check_for_conflicts_between_external_crates(\n-                        &**parent,\n-                        name.name,\n-                        view_item.span);\n-                    parent.external_module_children.borrow_mut()\n-                          .insert(name.name, external_module.clone());\n-                    self.build_reduced_graph_for_external_crate(&external_module);\n-                }\n-            }\n-        }\n-    }\n-\n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item<F>(&mut self,\n                                                foreign_item: &ForeignItem,\n@@ -1270,10 +1252,6 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         })\n     }\n \n-    fn visit_view_item(&mut self, view_item: &ViewItem) {\n-        self.builder.build_reduced_graph_for_view_item(view_item, &self.parent);\n-    }\n-\n     fn visit_block(&mut self, block: &Block) {\n         let np = self.builder.build_reduced_graph_for_block(block, &self.parent);\n         let old_parent = replace(&mut self.parent, np);"}, {"sha": "97370112ab40f422af7504dad50f23f71d84709a", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -25,7 +25,6 @@ use Namespace::{TypeNS, ValueNS};\n use rustc::lint;\n use rustc::middle::privacy::{DependsOn, LastImport, Used, Unused};\n use syntax::ast;\n-use syntax::ast::{ViewItem, ViewItemExternCrate, ViewItemUse};\n use syntax::ast::{ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::visit::{self, Visitor};\n@@ -109,53 +108,54 @@ impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n }\n \n impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n-    fn visit_view_item(&mut self, vi: &ViewItem) {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         // Ignore is_public import statements because there's no way to be sure\n         // whether they're used or not. Also ignore imports with a dummy span\n         // because this means that they were generated in some fashion by the\n         // compiler and we don't need to consider them.\n-        if vi.vis == ast::Public || vi.span == DUMMY_SP {\n-            visit::walk_view_item(self, vi);\n+        if item.vis == ast::Public || item.span == DUMMY_SP {\n+            visit::walk_item(self, item);\n             return;\n         }\n \n-        match vi.node {\n-            ViewItemExternCrate(_, _, id) => {\n-                if let Some(crate_num) = self.session.cstore.find_extern_mod_stmt_cnum(id) {\n+        match item.node {\n+            ast::ItemExternCrate(_) => {\n+                if let Some(crate_num) = self.session.cstore.find_extern_mod_stmt_cnum(item.id) {\n                     if !self.used_crates.contains(&crate_num) {\n                         self.session.add_lint(lint::builtin::UNUSED_EXTERN_CRATES,\n-                                              id,\n-                                              vi.span,\n+                                              item.id,\n+                                              item.span,\n                                               \"unused extern crate\".to_string());\n                     }\n                 }\n             },\n-            ViewItemUse(ref p) => {\n+            ast::ItemUse(ref p) => {\n                 match p.node {\n-                    ViewPathSimple(_, _, id) => {\n-                        self.finalize_import(id, p.span)\n+                    ViewPathSimple(_, _) => {\n+                        self.finalize_import(item.id, p.span)\n                     }\n \n-                    ViewPathList(_, ref list, _) => {\n+                    ViewPathList(_, ref list) => {\n                         for i in list.iter() {\n                             self.finalize_import(i.node.id(), i.span);\n                         }\n                     }\n-                    ViewPathGlob(_, id) => {\n-                        if !self.used_imports.contains(&(id, TypeNS)) &&\n-                           !self.used_imports.contains(&(id, ValueNS)) {\n+                    ViewPathGlob(_) => {\n+                        if !self.used_imports.contains(&(item.id, TypeNS)) &&\n+                           !self.used_imports.contains(&(item.id, ValueNS)) {\n                             self.session\n                                 .add_lint(lint::builtin::UNUSED_IMPORTS,\n-                                          id,\n+                                          item.id,\n                                           p.span,\n                                           \"unused import\".to_string());\n                         }\n                     }\n                 }\n             }\n+            _ => {}\n         }\n \n-        visit::walk_view_item(self, vi);\n+        visit::walk_item(self, item);\n     }\n }\n "}, {"sha": "94801545c2f03bb84097b0442bad9b5ff2f39394", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -65,10 +65,10 @@ use syntax::ast::{DefId, Expr, ExprAgain, ExprBreak, ExprField};\n use syntax::ast::{ExprClosure, ExprForLoop, ExprLoop, ExprWhile, ExprMethodCall};\n use syntax::ast::{ExprPath, ExprQPath, ExprStruct, FnDecl};\n use syntax::ast::{ForeignItemFn, ForeignItemStatic, Generics};\n-use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemFn};\n-use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n-use syntax::ast::{ItemStruct, ItemTrait, ItemTy, Local, LOCAL_CRATE};\n-use syntax::ast::{MethodImplItem, Mod, Name, NodeId};\n+use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemExternCrate};\n+use syntax::ast::{ItemFn, ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n+use syntax::ast::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n+use syntax::ast::{Local, MethodImplItem, Mod, Name, NodeId};\n use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n use syntax::ast::{PatRange, PatStruct, Path};\n use syntax::ast::{PolyTraitRef, PrimTy, SelfExplicit};\n@@ -1143,7 +1143,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn get_trait_name(&self, did: DefId) -> Name {\n-        if did.krate == LOCAL_CRATE {\n+        if did.krate == ast::LOCAL_CRATE {\n             self.ast_map.expect_item(did.node).ident.name\n         } else {\n             csearch::get_trait_name(&self.session.cstore, did)\n@@ -1752,10 +1752,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     import_span: Span,\n                                     name: Name,\n                                     namespace: Namespace) {\n-        if self.session.features.borrow().import_shadowing {\n-            return\n-        }\n-\n         debug!(\"check_for_conflicting_import: {}; target exists: {}\",\n                token::get_name(name).get(),\n                target.is_some());\n@@ -1795,10 +1791,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                      &ImportResolution,\n                                                      import_span: Span,\n                                                      name: Name) {\n-        if self.session.features.borrow().import_shadowing {\n-            return\n-        }\n-\n         // First, check for conflicts between imports and `extern crate`s.\n         if module.external_module_children\n                  .borrow()\n@@ -1892,10 +1884,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                    module: &Module,\n                                                    name: Name,\n                                                    span: Span) {\n-        if self.session.features.borrow().import_shadowing {\n-            return\n-        }\n-\n         if module.external_module_children.borrow().contains_key(&name) {\n                 span_err!(self.session, span, E0259,\n                           \"an external crate named `{}` has already \\\n@@ -1909,10 +1897,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                              module: &Module,\n                                                              name: Name,\n                                                              span: Span) {\n-        if self.session.features.borrow().import_shadowing {\n-            return\n-        }\n-\n         if module.external_module_children.borrow().contains_key(&name) {\n                 span_err!(self.session, span, E0260,\n                           \"the name `{}` conflicts with an external \\\n@@ -2984,9 +2968,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 });\n             }\n \n-           ItemMac(..) => {\n+            ItemExternCrate(_) | ItemUse(_) | ItemMac(..) => {\n                 // do nothing, these are just around to be encoded\n-           }\n+            }\n         }\n     }\n \n@@ -3527,6 +3511,26 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n+        // Check for imports appearing after non-item statements.\n+        let mut found_non_item = false;\n+        for statement in block.stmts.iter() {\n+            if let ast::StmtDecl(ref declaration, _) = statement.node {\n+                if let ast::DeclItem(ref i) = declaration.node {\n+                    match i.node {\n+                        ItemExternCrate(_) | ItemUse(_) if found_non_item => {\n+                            span_err!(self.session, i.span, E0154,\n+                                \"imports are not allowed after non-item statements\");\n+                        }\n+                        _ => {}\n+                    }\n+                } else {\n+                    found_non_item = true\n+                }\n+            } else {\n+                found_non_item = true;\n+            }\n+        }\n+\n         // Descend into the block.\n         visit::walk_block(self, block);\n "}, {"sha": "4aec53711ad8af02b250b6e40edfff9b522d3747", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 104, "deletions": 113, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -1037,6 +1037,110 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         }\n \n         match item.node {\n+            ast::ItemUse(ref use_item) => {\n+                match use_item.node {\n+                    ast::ViewPathSimple(ident, ref path) => {\n+                        let sub_span = self.span.span_for_last_ident(path.span);\n+                        let mod_id = match self.lookup_type_ref(item.id) {\n+                            Some(def_id) => {\n+                                match self.lookup_def_kind(item.id, path.span) {\n+                                    Some(kind) => self.fmt.ref_str(kind,\n+                                                                   path.span,\n+                                                                   sub_span,\n+                                                                   def_id,\n+                                                                   self.cur_scope),\n+                                    None => {},\n+                                }\n+                                Some(def_id)\n+                            },\n+                            None => None,\n+                        };\n+\n+                        // 'use' always introduces an alias, if there is not an explicit\n+                        // one, there is an implicit one.\n+                        let sub_span =\n+                            match self.span.sub_span_after_keyword(use_item.span, keywords::As) {\n+                                Some(sub_span) => Some(sub_span),\n+                                None => sub_span,\n+                            };\n+\n+                        self.fmt.use_alias_str(path.span,\n+                                               sub_span,\n+                                               item.id,\n+                                               mod_id,\n+                                               get_ident(ident).get(),\n+                                               self.cur_scope);\n+                        self.write_sub_paths_truncated(path);\n+                    }\n+                    ast::ViewPathGlob(ref path) => {\n+                        // Make a comma-separated list of names of imported modules.\n+                        let mut name_string = String::new();\n+                        let glob_map = &self.analysis.glob_map;\n+                        let glob_map = glob_map.as_ref().unwrap();\n+                        if glob_map.contains_key(&item.id) {\n+                            for n in glob_map[item.id].iter() {\n+                                if name_string.len() > 0 {\n+                                    name_string.push_str(\", \");\n+                                }\n+                                name_string.push_str(n.as_str());\n+                            }\n+                        }\n+\n+                        let sub_span = self.span.sub_span_of_token(path.span,\n+                                                                   token::BinOp(token::Star));\n+                        self.fmt.use_glob_str(path.span,\n+                                              sub_span,\n+                                              item.id,\n+                                              name_string.as_slice(),\n+                                              self.cur_scope);\n+                        self.write_sub_paths(path);\n+                    }\n+                    ast::ViewPathList(ref path, ref list) => {\n+                        for plid in list.iter() {\n+                            match plid.node {\n+                                ast::PathListIdent { id, .. } => {\n+                                    match self.lookup_type_ref(id) {\n+                                        Some(def_id) =>\n+                                            match self.lookup_def_kind(id, plid.span) {\n+                                                Some(kind) => {\n+                                                    self.fmt.ref_str(\n+                                                        kind, plid.span,\n+                                                        Some(plid.span),\n+                                                        def_id, self.cur_scope);\n+                                                }\n+                                                None => ()\n+                                            },\n+                                        None => ()\n+                                    }\n+                                },\n+                                ast::PathListMod { .. } => ()\n+                            }\n+                        }\n+\n+                        self.write_sub_paths(path);\n+                    }\n+                }\n+            }\n+            ast::ItemExternCrate(ref s) => {\n+                let name = get_ident(item.ident);\n+                let name = name.get();\n+                let s = match *s {\n+                    Some((ref s, _)) => s.get().to_string(),\n+                    None => name.to_string(),\n+                };\n+                let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Crate);\n+                let cnum = match self.sess.cstore.find_extern_mod_stmt_cnum(item.id) {\n+                    Some(cnum) => cnum,\n+                    None => 0,\n+                };\n+                self.fmt.extern_crate_str(item.span,\n+                                          sub_span,\n+                                          item.id,\n+                                          cnum,\n+                                          name,\n+                                          &s[],\n+                                          self.cur_scope);\n+            }\n             ast::ItemFn(ref decl, _, _, ref ty_params, ref body) =>\n                 self.process_fn(item, &**decl, ty_params, &**body),\n             ast::ItemStatic(ref typ, mt, ref expr) =>\n@@ -1160,119 +1264,6 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        if generated_code(i.span) {\n-            return\n-        }\n-\n-        match i.node {\n-            ast::ViewItemUse(ref item) => {\n-                match item.node {\n-                    ast::ViewPathSimple(ident, ref path, id) => {\n-                        let sub_span = self.span.span_for_last_ident(path.span);\n-                        let mod_id = match self.lookup_type_ref(id) {\n-                            Some(def_id) => {\n-                                match self.lookup_def_kind(id, path.span) {\n-                                    Some(kind) => self.fmt.ref_str(kind,\n-                                                                   path.span,\n-                                                                   sub_span,\n-                                                                   def_id,\n-                                                                   self.cur_scope),\n-                                    None => {},\n-                                }\n-                                Some(def_id)\n-                            },\n-                            None => None,\n-                        };\n-\n-                        // 'use' always introduces an alias, if there is not an explicit\n-                        // one, there is an implicit one.\n-                        let sub_span =\n-                            match self.span.sub_span_after_keyword(item.span, keywords::As) {\n-                                Some(sub_span) => Some(sub_span),\n-                                None => sub_span,\n-                            };\n-\n-                        self.fmt.use_alias_str(path.span,\n-                                               sub_span,\n-                                               id,\n-                                               mod_id,\n-                                               get_ident(ident).get(),\n-                                               self.cur_scope);\n-                        self.write_sub_paths_truncated(path);\n-                    }\n-                    ast::ViewPathGlob(ref path, id) => {\n-                        // Make a comma-separated list of names of imported modules.\n-                        let mut name_string = String::new();\n-                        let glob_map = &self.analysis.glob_map;\n-                        let glob_map = glob_map.as_ref().unwrap();\n-                        if glob_map.contains_key(&id) {\n-                            for n in glob_map[id].iter() {\n-                                if name_string.len() > 0 {\n-                                    name_string.push_str(\", \");\n-                                }\n-                                name_string.push_str(n.as_str());\n-                            }\n-                        }\n-\n-                        let sub_span = self.span.sub_span_of_token(path.span,\n-                                                                   token::BinOp(token::Star));\n-                        self.fmt.use_glob_str(path.span,\n-                                              sub_span,\n-                                              id,\n-                                              name_string.as_slice(),\n-                                              self.cur_scope);\n-                        self.write_sub_paths(path);\n-                    }\n-                    ast::ViewPathList(ref path, ref list, _) => {\n-                        for plid in list.iter() {\n-                            match plid.node {\n-                                ast::PathListIdent { id, .. } => {\n-                                    match self.lookup_type_ref(id) {\n-                                        Some(def_id) =>\n-                                            match self.lookup_def_kind(id, plid.span) {\n-                                                Some(kind) => {\n-                                                    self.fmt.ref_str(\n-                                                        kind, plid.span,\n-                                                        Some(plid.span),\n-                                                        def_id, self.cur_scope);\n-                                                }\n-                                                None => ()\n-                                            },\n-                                        None => ()\n-                                    }\n-                                },\n-                                ast::PathListMod { .. } => ()\n-                            }\n-                        }\n-\n-                        self.write_sub_paths(path);\n-                    }\n-                }\n-            },\n-            ast::ViewItemExternCrate(ident, ref s, id) => {\n-                let name = get_ident(ident);\n-                let name = name.get();\n-                let s = match *s {\n-                    Some((ref s, _)) => s.get().to_string(),\n-                    None => name.to_string(),\n-                };\n-                let sub_span = self.span.sub_span_after_keyword(i.span, keywords::Crate);\n-                let cnum = match self.sess.cstore.find_extern_mod_stmt_cnum(id) {\n-                    Some(cnum) => cnum,\n-                    None => 0,\n-                };\n-                self.fmt.extern_crate_str(i.span,\n-                                          sub_span,\n-                                          id,\n-                                          cnum,\n-                                          name,\n-                                          &s[],\n-                                          self.cur_scope);\n-            },\n-        }\n-    }\n-\n     fn visit_ty(&mut self, t: &ast::Ty) {\n         if generated_code(t.span) {\n             return"}, {"sha": "93076260349abd5c81aee5d5801823a800ec4a2d", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -274,7 +274,6 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ast_map::NodeArg(..) |\n         ast_map::NodeBlock(..) |\n         ast_map::NodePat(..) |\n-        ast_map::NodeViewItem(..) |\n         ast_map::NodeLocal(..) => {\n             ccx.sess().bug(&format!(\"can't monomorphize a {:?}\",\n                                    map_node)[])"}, {"sha": "8158b8da86dfd6f149da7c5b76c95dae73faa269", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -555,6 +555,7 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n     debug!(\"convert: item {} with id {}\", token::get_ident(it.ident), it.id);\n     match it.node {\n         // These don't define types.\n+        ast::ItemExternCrate(_) | ast::ItemUse(_) |\n         ast::ItemForeignMod(_) | ast::ItemMod(_) | ast::ItemMac(_) => {}\n         ast::ItemEnum(ref enum_definition, ref generics) => {\n             let scheme = ty_of_item(ccx, it);\n@@ -1004,6 +1005,7 @@ fn ty_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, it: &ast::Item)\n             tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n             return scheme;\n         }\n+        ast::ItemExternCrate(_) | ast::ItemUse(_) |\n         ast::ItemImpl(..) | ast::ItemMod(_) |\n         ast::ItemForeignMod(_) | ast::ItemMac(_) => panic!(),\n     }"}, {"sha": "6ed18368738e0b7985cc9bbeb62fcc2d62248a0f", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -380,6 +380,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n                 visit::walk_item(self, item);\n             }\n \n+            ast::ItemExternCrate(_) |\n+            ast::ItemUse(_) |\n             ast::ItemImpl(..) |\n             ast::ItemStatic(..) |\n             ast::ItemConst(..) |\n@@ -532,6 +534,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n                 }\n             }\n \n+            ast::ItemExternCrate(_) |\n+            ast::ItemUse(_) |\n             ast::ItemStatic(..) |\n             ast::ItemConst(..) |\n             ast::ItemFn(..) |"}, {"sha": "203d9758c579d5dfa0231338a0293eac3ef78de4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 78, "deletions": 111, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -18,8 +18,7 @@ pub use self::TypeKind::*;\n pub use self::StructField::*;\n pub use self::VariantKind::*;\n pub use self::Mutability::*;\n-pub use self::ViewItemInner::*;\n-pub use self::ViewPath::*;\n+pub use self::Import::*;\n pub use self::ItemEnum::*;\n pub use self::Attribute::*;\n pub use self::TyParamBound::*;\n@@ -315,6 +314,8 @@ impl Item {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub enum ItemEnum {\n+    ExternCrateItem(String, Option<String>),\n+    ImportItem(Import),\n     StructItem(Struct),\n     EnumItem(Enum),\n     FunctionItem(Function),\n@@ -324,8 +325,6 @@ pub enum ItemEnum {\n     ConstantItem(Constant),\n     TraitItem(Trait),\n     ImplItem(Impl),\n-    /// `use` and `extern crate`\n-    ViewItemItem(ViewItem),\n     /// A method signature only. Used for required methods in traits (ie,\n     /// non-default-methods).\n     TyMethodItem(TyMethod),\n@@ -355,27 +354,21 @@ impl Clean<Item> for doctree::Module {\n         } else {\n             \"\".to_string()\n         };\n-        let mut foreigns = Vec::new();\n-        for subforeigns in self.foreigns.clean(cx).into_iter() {\n-            for foreign in subforeigns.into_iter() {\n-                foreigns.push(foreign)\n-            }\n-        }\n-        let items: Vec<Vec<Item> > = vec!(\n-            self.structs.clean(cx),\n-            self.enums.clean(cx),\n-            self.fns.clean(cx),\n-            foreigns,\n-            self.mods.clean(cx),\n-            self.typedefs.clean(cx),\n-            self.statics.clean(cx),\n-            self.constants.clean(cx),\n-            self.traits.clean(cx),\n-            self.impls.clean(cx),\n-            self.view_items.clean(cx).into_iter()\n-                           .flat_map(|s| s.into_iter()).collect(),\n-            self.macros.clean(cx),\n-        );\n+        let items: Vec<Item> =\n+                   self.extern_crates.iter().map(|x| x.clean(cx))\n+            .chain(self.imports.iter().flat_map(|x| x.clean(cx).into_iter()))\n+            .chain(self.structs.iter().map(|x| x.clean(cx)))\n+            .chain(self.enums.iter().map(|x| x.clean(cx)))\n+            .chain(self.fns.iter().map(|x| x.clean(cx)))\n+            .chain(self.foreigns.iter().flat_map(|x| x.clean(cx).into_iter()))\n+            .chain(self.mods.iter().map(|x| x.clean(cx)))\n+            .chain(self.typedefs.iter().map(|x| x.clean(cx)))\n+            .chain(self.statics.iter().map(|x| x.clean(cx)))\n+            .chain(self.constants.iter().map(|x| x.clean(cx)))\n+            .chain(self.traits.iter().map(|x| x.clean(cx)))\n+            .chain(self.impls.iter().map(|x| x.clean(cx)))\n+            .chain(self.macros.iter().map(|x| x.clean(cx)))\n+            .collect();\n \n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n@@ -401,9 +394,7 @@ impl Clean<Item> for doctree::Module {\n             def_id: ast_util::local_def(self.id),\n             inner: ModuleItem(Module {\n                is_crate: self.is_crate,\n-               items: items.iter()\n-                           .flat_map(|x| x.iter().map(|x| (*x).clone()))\n-                           .collect(),\n+               items: items\n             })\n         }\n     }\n@@ -2143,12 +2134,21 @@ impl Clean<Item> for doctree::Impl {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n-pub struct ViewItem {\n-    pub inner: ViewItemInner,\n+impl Clean<Item> for doctree::ExternCrate {\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        Item {\n+            name: None,\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n+            def_id: ast_util::local_def(0),\n+            visibility: self.vis.clean(cx),\n+            stability: None,\n+            inner: ExternCrateItem(self.name.clean(cx), self.path.clone())\n+        }\n+    }\n }\n \n-impl Clean<Vec<Item>> for ast::ViewItem {\n+impl Clean<Vec<Item>> for doctree::Import {\n     fn clean(&self, cx: &DocContext) -> Vec<Item> {\n         // We consider inlining the documentation of `pub use` statements, but we\n         // forcefully don't inline if this is not public or if the\n@@ -2159,81 +2159,63 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                 None => false,\n             }\n         });\n-        let convert = |&: node: &ast::ViewItem_| {\n-            Item {\n-                name: None,\n-                attrs: self.attrs.clean(cx),\n-                source: self.span.clean(cx),\n-                def_id: ast_util::local_def(0),\n-                visibility: self.vis.clean(cx),\n-                stability: None,\n-                inner: ViewItemItem(ViewItem { inner: node.clean(cx) }),\n+        let (mut ret, inner) = match self.node {\n+            ast::ViewPathGlob(ref p) => {\n+                (vec![], GlobImport(resolve_use_source(cx, p.clean(cx), self.id)))\n             }\n-        };\n-        let mut ret = Vec::new();\n-        match self.node {\n-            ast::ViewItemUse(ref path) if !denied => {\n-                match path.node {\n-                    ast::ViewPathGlob(..) => ret.push(convert(&self.node)),\n-                    ast::ViewPathList(ref a, ref list, ref b) => {\n-                        // Attempt to inline all reexported items, but be sure\n-                        // to keep any non-inlineable reexports so they can be\n-                        // listed in the documentation.\n-                        let remaining = list.iter().filter(|path| {\n-                            match inline::try_inline(cx, path.node.id(), None) {\n-                                Some(items) => {\n-                                    ret.extend(items.into_iter()); false\n-                                }\n-                                None => true,\n+            ast::ViewPathList(ref p, ref list) => {\n+                // Attempt to inline all reexported items, but be sure\n+                // to keep any non-inlineable reexports so they can be\n+                // listed in the documentation.\n+                let mut ret = vec![];\n+                let remaining = if !denied {\n+                    let mut remaining = vec![];\n+                    for path in list.iter() {\n+                        match inline::try_inline(cx, path.node.id(), None) {\n+                            Some(items) => {\n+                                ret.extend(items.into_iter());\n+                            }\n+                            None => {\n+                                remaining.push(path.clean(cx));\n                             }\n-                        }).map(|a| a.clone()).collect::<Vec<ast::PathListItem>>();\n-                        if remaining.len() > 0 {\n-                            let path = ast::ViewPathList(a.clone(),\n-                                                         remaining,\n-                                                         b.clone());\n-                            let path = syntax::codemap::dummy_spanned(path);\n-                            ret.push(convert(&ast::ViewItemUse(P(path))));\n-                        }\n-                    }\n-                    ast::ViewPathSimple(ident, _, id) => {\n-                        match inline::try_inline(cx, id, Some(ident)) {\n-                            Some(items) => ret.extend(items.into_iter()),\n-                            None => ret.push(convert(&self.node)),\n                         }\n                     }\n-                }\n-            }\n-            ref n => ret.push(convert(n)),\n-        }\n-        return ret;\n-    }\n-}\n-\n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n-pub enum ViewItemInner {\n-    ExternCrate(String, Option<String>, ast::NodeId),\n-    Import(ViewPath)\n-}\n-\n-impl Clean<ViewItemInner> for ast::ViewItem_ {\n-    fn clean(&self, cx: &DocContext) -> ViewItemInner {\n-        match self {\n-            &ast::ViewItemExternCrate(ref i, ref p, ref id) => {\n-                let string = match *p {\n-                    None => None,\n-                    Some((ref x, _)) => Some(x.get().to_string()),\n+                    remaining\n+                } else {\n+                    list.clean(cx)\n                 };\n-                ExternCrate(i.clean(cx), string, *id)\n+                if remaining.is_empty() {\n+                    return ret;\n+                }\n+                (ret, ImportList(resolve_use_source(cx, p.clean(cx), self.id),\n+                                 remaining))\n             }\n-            &ast::ViewItemUse(ref vp) => {\n-                Import(vp.clean(cx))\n+            ast::ViewPathSimple(i, ref p) => {\n+                if !denied {\n+                    match inline::try_inline(cx, self.id, Some(i)) {\n+                        Some(items) => return items,\n+                        None => {}\n+                    }\n+                }\n+                (vec![], SimpleImport(i.clean(cx),\n+                                      resolve_use_source(cx, p.clean(cx), self.id)))\n             }\n-        }\n+        };\n+        ret.push(Item {\n+            name: None,\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n+            def_id: ast_util::local_def(0),\n+            visibility: self.vis.clean(cx),\n+            stability: None,\n+            inner: ImportItem(inner)\n+        });\n+        ret\n     }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n-pub enum ViewPath {\n+pub enum Import {\n     // use source as str;\n     SimpleImport(String, ImportSource),\n     // use source::*;\n@@ -2248,21 +2230,6 @@ pub struct ImportSource {\n     pub did: Option<ast::DefId>,\n }\n \n-impl Clean<ViewPath> for ast::ViewPath {\n-    fn clean(&self, cx: &DocContext) -> ViewPath {\n-        match self.node {\n-            ast::ViewPathSimple(ref i, ref p, id) =>\n-                SimpleImport(i.clean(cx), resolve_use_source(cx, p.clean(cx), id)),\n-            ast::ViewPathGlob(ref p, id) =>\n-                GlobImport(resolve_use_source(cx, p.clean(cx), id)),\n-            ast::ViewPathList(ref p, ref pl, id) => {\n-                ImportList(resolve_use_source(cx, p.clean(cx), id),\n-                           pl.clean(cx))\n-            }\n-        }\n-    }\n-}\n-\n #[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct ViewListIdent {\n     pub name: String,"}, {"sha": "0e8ab594c20c1e2125f75f67c52f21657da7aa2e", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -25,6 +25,8 @@ pub struct Module {\n     pub attrs: Vec<ast::Attribute>,\n     pub where_outer: Span,\n     pub where_inner: Span,\n+    pub extern_crates: Vec<ExternCrate>,\n+    pub imports: Vec<Import>,\n     pub structs: Vec<Struct>,\n     pub enums: Vec<Enum>,\n     pub fns: Vec<Function>,\n@@ -38,7 +40,6 @@ pub struct Module {\n     pub stab: Option<attr::Stability>,\n     pub impls: Vec<Impl>,\n     pub foreigns: Vec<ast::ForeignMod>,\n-    pub view_items: Vec<ast::ViewItem>,\n     pub macros: Vec<Macro>,\n     pub is_crate: bool,\n }\n@@ -53,6 +54,8 @@ impl Module {\n             where_outer: syntax::codemap::DUMMY_SP,\n             where_inner: syntax::codemap::DUMMY_SP,\n             attrs      : Vec::new(),\n+            extern_crates: Vec::new(),\n+            imports    : Vec::new(),\n             structs    : Vec::new(),\n             enums      : Vec::new(),\n             fns        : Vec::new(),\n@@ -62,7 +65,6 @@ impl Module {\n             constants  : Vec::new(),\n             traits     : Vec::new(),\n             impls      : Vec::new(),\n-            view_items : Vec::new(),\n             foreigns   : Vec::new(),\n             macros     : Vec::new(),\n             is_crate   : false,\n@@ -202,6 +204,22 @@ pub struct Macro {\n     pub stab: Option<attr::Stability>,\n }\n \n+pub struct ExternCrate {\n+    pub name: Ident,\n+    pub path: Option<String>,\n+    pub vis: ast::Visibility,\n+    pub attrs: Vec<ast::Attribute>,\n+    pub whence: Span,\n+}\n+\n+pub struct Import {\n+    pub id: NodeId,\n+    pub vis: ast::Visibility,\n+    pub attrs: Vec<ast::Attribute>,\n+    pub node: ast::ViewPath_,\n+    pub whence: Span,\n+}\n+\n pub fn struct_type_from_def(sd: &ast::StructDef) -> StructType {\n     if sd.ctor_id.is_some() {\n         // We are in a tuple-struct"}, {"sha": "b713032bc05776e29589f66f409aa6d4016bd23a", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -617,7 +617,7 @@ impl fmt::Display for UnsafetySpace {\n     }\n }\n \n-impl fmt::Display for clean::ViewPath {\n+impl fmt::Display for clean::Import {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::SimpleImport(ref name, ref src) => {"}, {"sha": "356be2ffeb04cf4bebaa3dc22425d8d0a282f509", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -22,29 +22,31 @@ use clean;\n #[derive(Copy, PartialEq, Clone)]\n pub enum ItemType {\n     Module          = 0,\n-    Struct          = 1,\n-    Enum            = 2,\n-    Function        = 3,\n-    Typedef         = 4,\n-    Static          = 5,\n-    Trait           = 6,\n-    Impl            = 7,\n-    ViewItem        = 8,\n-    TyMethod        = 9,\n-    Method          = 10,\n-    StructField     = 11,\n-    Variant         = 12,\n-    // we used to have ForeignFunction and ForeignStatic. they are retired now.\n-    Macro           = 15,\n-    Primitive       = 16,\n-    AssociatedType  = 17,\n-    Constant        = 18,\n+    ExternCrate     = 1,\n+    Import          = 2,\n+    Struct          = 3,\n+    Enum            = 4,\n+    Function        = 5,\n+    Typedef         = 6,\n+    Static          = 7,\n+    Trait           = 8,\n+    Impl            = 9,\n+    TyMethod        = 10,\n+    Method          = 11,\n+    StructField     = 12,\n+    Variant         = 13,\n+    Macro           = 14,\n+    Primitive       = 15,\n+    AssociatedType  = 16,\n+    Constant        = 17,\n }\n \n impl ItemType {\n     pub fn from_item(item: &clean::Item) -> ItemType {\n         match item.inner {\n             clean::ModuleItem(..)          => ItemType::Module,\n+            clean::ExternCrateItem(..)     => ItemType::ExternCrate,\n+            clean::ImportItem(..)          => ItemType::Import,\n             clean::StructItem(..)          => ItemType::Struct,\n             clean::EnumItem(..)            => ItemType::Enum,\n             clean::FunctionItem(..)        => ItemType::Function,\n@@ -53,7 +55,6 @@ impl ItemType {\n             clean::ConstantItem(..)        => ItemType::Constant,\n             clean::TraitItem(..)           => ItemType::Trait,\n             clean::ImplItem(..)            => ItemType::Impl,\n-            clean::ViewItemItem(..)        => ItemType::ViewItem,\n             clean::TyMethodItem(..)        => ItemType::TyMethod,\n             clean::MethodItem(..)          => ItemType::Method,\n             clean::StructFieldItem(..)     => ItemType::StructField,\n@@ -83,14 +84,15 @@ impl ItemType {\n     pub fn to_static_str(&self) -> &'static str {\n         match *self {\n             ItemType::Module          => \"mod\",\n+            ItemType::ExternCrate     => \"externcrate\",\n+            ItemType::Import          => \"import\",\n             ItemType::Struct          => \"struct\",\n             ItemType::Enum            => \"enum\",\n             ItemType::Function        => \"fn\",\n             ItemType::Typedef         => \"type\",\n             ItemType::Static          => \"static\",\n             ItemType::Trait           => \"trait\",\n             ItemType::Impl            => \"impl\",\n-            ItemType::ViewItem        => \"viewitem\",\n             ItemType::TyMethod        => \"tymethod\",\n             ItemType::Method          => \"method\",\n             ItemType::StructField     => \"structfield\","}, {"sha": "cd2ed5f0a974b12b0013c55a220e4b61163c39c4", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 36, "deletions": 52, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -35,7 +35,7 @@\n pub use self::ExternalLocation::*;\n \n use std::cell::RefCell;\n-use std::cmp::Ordering::{self, Less, Greater, Equal};\n+use std::cmp::Ordering;\n use std::collections::{HashMap, HashSet};\n use std::default::Default;\n use std::fmt;\n@@ -1497,18 +1497,19 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     // the order of item types in the listing\n     fn reorder(ty: ItemType) -> u8 {\n         match ty {\n-            ItemType::ViewItem        => 0,\n-            ItemType::Primitive       => 1,\n-            ItemType::Module          => 2,\n-            ItemType::Macro           => 3,\n-            ItemType::Struct          => 4,\n-            ItemType::Enum            => 5,\n-            ItemType::Constant        => 6,\n-            ItemType::Static          => 7,\n-            ItemType::Trait           => 8,\n-            ItemType::Function        => 9,\n-            ItemType::Typedef         => 10,\n-            _                         => 11 + ty as u8,\n+            ItemType::ExternCrate     => 0,\n+            ItemType::Import          => 1,\n+            ItemType::Primitive       => 2,\n+            ItemType::Module          => 3,\n+            ItemType::Macro           => 4,\n+            ItemType::Struct          => 5,\n+            ItemType::Enum            => 6,\n+            ItemType::Constant        => 7,\n+            ItemType::Static          => 8,\n+            ItemType::Trait           => 9,\n+            ItemType::Function        => 10,\n+            ItemType::Typedef         => 12,\n+            _                         => 13 + ty as u8,\n         }\n     }\n \n@@ -1518,25 +1519,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n         if ty1 == ty2 {\n             return i1.name.cmp(&i2.name);\n         }\n-\n-        let tycmp = reorder(ty1).cmp(&reorder(ty2));\n-        if let Equal = tycmp {\n-            // for reexports, `extern crate` takes precedence.\n-            match (&i1.inner, &i2.inner) {\n-                (&clean::ViewItemItem(ref a), &clean::ViewItemItem(ref b)) => {\n-                    match (&a.inner, &b.inner) {\n-                        (&clean::ExternCrate(..), _) => return Less,\n-                        (_, &clean::ExternCrate(..)) => return Greater,\n-                        _ => {}\n-                    }\n-                }\n-                (_, _) => {}\n-            }\n-\n-            idx1.cmp(&idx2)\n-        } else {\n-            tycmp\n-        }\n+        (reorder(ty1), idx1).cmp(&(reorder(ty2), idx2))\n     }\n \n     indices.sort_by(|&i1, &i2| cmp(&items[i1], &items[i2], i1, i2));\n@@ -1547,12 +1530,17 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n         let myitem = &items[idx];\n \n         let myty = Some(shortty(myitem));\n-        if myty != curty {\n+        if curty == Some(ItemType::ExternCrate) && myty == Some(ItemType::Import) {\n+            // Put `extern crate` and `use` re-exports in the same section.\n+            curty = myty;\n+        } else if myty != curty {\n             if curty.is_some() {\n                 try!(write!(w, \"</table>\"));\n             }\n             curty = myty;\n             let (short, name) = match myty.unwrap() {\n+                ItemType::ExternCrate |\n+                ItemType::Import          => (\"reexports\", \"Reexports\"),\n                 ItemType::Module          => (\"modules\", \"Modules\"),\n                 ItemType::Struct          => (\"structs\", \"Structs\"),\n                 ItemType::Enum            => (\"enums\", \"Enums\"),\n@@ -1562,7 +1550,6 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 ItemType::Constant        => (\"constants\", \"Constants\"),\n                 ItemType::Trait           => (\"traits\", \"Traits\"),\n                 ItemType::Impl            => (\"impls\", \"Implementations\"),\n-                ItemType::ViewItem        => (\"reexports\", \"Reexports\"),\n                 ItemType::TyMethod        => (\"tymethods\", \"Type Methods\"),\n                 ItemType::Method          => (\"methods\", \"Methods\"),\n                 ItemType::StructField     => (\"fields\", \"Struct Fields\"),\n@@ -1578,28 +1565,25 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n         }\n \n         match myitem.inner {\n-            clean::ViewItemItem(ref item) => {\n-                match item.inner {\n-                    clean::ExternCrate(ref name, ref src, _) => {\n-                        match *src {\n-                            Some(ref src) =>\n-                                try!(write!(w, \"<tr><td><code>extern crate \\\"{}\\\" as {}\",\n-                                            src.as_slice(),\n-                                            name.as_slice())),\n-                            None =>\n-                                try!(write!(w, \"<tr><td><code>extern crate {}\",\n-                                            name.as_slice())),\n-                        }\n-                        try!(write!(w, \";</code></td></tr>\"));\n+            clean::ExternCrateItem(ref name, ref src) => {\n+                match *src {\n+                    Some(ref src) => {\n+                        try!(write!(w, \"<tr><td><code>{}extern crate \\\"{}\\\" as {};\",\n+                                    VisSpace(myitem.visibility),\n+                                    src.as_slice(),\n+                                    name.as_slice()))\n                     }\n-\n-                    clean::Import(ref import) => {\n-                        try!(write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n-                                      VisSpace(myitem.visibility),\n-                                      *import));\n+                    None => {\n+                        try!(write!(w, \"<tr><td><code>{}extern crate {};\",\n+                                    VisSpace(myitem.visibility), name.as_slice()))\n                     }\n                 }\n+                try!(write!(w, \"</code></td></tr>\"));\n+            }\n \n+            clean::ImportItem(ref import) => {\n+                try!(write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n+                            VisSpace(myitem.visibility), *import));\n             }\n \n             _ => {"}, {"sha": "0914f93efd802b406a0f72cac14f4a174150d60b", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -245,7 +245,6 @@ nav.sub {\n .content .highlighted.method { background-color: #c6afb3; }\n .content .highlighted.tymethod { background-color: #c6afb3; }\n .content .highlighted.type { background-color: #c6afb3; }\n-.content .highlighted.ffi { background-color: #c6afb3; }\n \n .docblock.short.nowrap {\n     display: block;\n@@ -365,7 +364,6 @@ p a:hover { text-decoration: underline; }\n .content span.fn, .content a.fn, .block a.current.fn { color: #8c6067; }\n .content span.method, .content a.method, .block a.current.method { color: #8c6067; }\n .content span.tymethod, .content a.tymethod, .block a.current.tymethod { color: #8c6067; }\n-.content span.ffi, .content a.ffi, .block a.current.ffi { color: #8c6067; }\n .content .fnname { color: #8c6067; }\n \n .search-input {"}, {"sha": "1b0c3b006409952eebf2ce0559d20ea8d77eb14d", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -555,20 +555,19 @@\n         // This mapping table should match the discriminants of\n         // `rustdoc::html::item_type::ItemType` type in Rust.\n         var itemTypes = [\"mod\",\n+                         \"externcrate\",\n+                         \"import\",\n                          \"struct\",\n                          \"enum\",\n                          \"fn\",\n                          \"type\",\n                          \"static\",\n                          \"trait\",\n                          \"impl\",\n-                         \"viewitem\",\n                          \"tymethod\",\n                          \"method\",\n                          \"structfield\",\n                          \"variant\",\n-                         \"ffi\", // retained for backward compatibility\n-                         \"ffs\", // retained for backward compatibility\n                          \"macro\",\n                          \"primitive\",\n                          \"associatedtype\","}, {"sha": "30b2ad810f1db1ca67ef525cdb65de4437e76b5e", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -149,7 +149,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n                 }\n             }\n \n-            clean::ViewItemItem(..) => {\n+            clean::ExternCrateItem(..) | clean::ImportItem(_) => {\n                 if i.visibility != Some(ast::Public) {\n                     return None\n                 }"}, {"sha": "943bc6ec9963445f76f23b0eccfea369d1e68852", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -21,7 +21,7 @@ use syntax::ast::Public;\n \n use clean::{Crate, Item, ModuleItem, Module, EnumItem, Enum};\n use clean::{ImplItem, Impl, Trait, TraitItem, TraitMethod, ProvidedMethod, RequiredMethod};\n-use clean::{TypeTraitItem, ViewItemItem, PrimitiveItem, Stability};\n+use clean::{TypeTraitItem, ExternCrateItem, ImportItem, PrimitiveItem, Stability};\n \n use html::render::cache;\n \n@@ -199,7 +199,8 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n             }))\n         }\n         // no stability information for the following items:\n-        ViewItemItem(_) | PrimitiveItem(_) => (Counts::zero(), None),\n+        ExternCrateItem(..) | ImportItem(_) |\n+        PrimitiveItem(_) => (Counts::zero(), None),\n         _ => (item_counts, None)\n     }\n }"}, {"sha": "848205f589eda229e137e96d21ab2ade0edeafbc", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 62, "deletions": 57, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -20,7 +20,6 @@ use syntax::ast_map;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n-use syntax::ptr::P;\n \n use rustc::middle::stability;\n \n@@ -142,9 +141,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                               m: &ast::Mod,\n                               name: Option<ast::Ident>) -> Module {\n         let mut om = Module::new(name);\n-        for item in m.view_items.iter() {\n-            self.visit_view_item(item, &mut om);\n-        }\n         om.where_outer = span;\n         om.where_inner = m.inner;\n         om.attrs = attrs;\n@@ -157,68 +153,41 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om\n     }\n \n-    pub fn visit_view_item(&mut self, item: &ast::ViewItem, om: &mut Module) {\n-        if item.vis != ast::Public {\n-            return om.view_items.push(item.clone());\n-        }\n-        let please_inline = item.attrs.iter().any(|item| {\n-            match item.meta_item_list() {\n-                Some(list) => {\n-                    list.iter().any(|i| i.name().get() == \"inline\")\n-                }\n-                None => false,\n-            }\n-        });\n-        let item = match item.node {\n-            ast::ViewItemUse(ref vpath) => {\n-                match self.visit_view_path(&**vpath, om, please_inline) {\n-                    None => return,\n-                    Some(path) => {\n-                        ast::ViewItem {\n-                            node: ast::ViewItemUse(path),\n-                            .. item.clone()\n-                        }\n-                    }\n-                }\n-            }\n-            ast::ViewItemExternCrate(..) => item.clone()\n-        };\n-        om.view_items.push(item);\n-    }\n-\n-    fn visit_view_path(&mut self, path: &ast::ViewPath,\n+    fn visit_view_path(&mut self, path: ast::ViewPath_,\n                        om: &mut Module,\n-                       please_inline: bool) -> Option<P<ast::ViewPath>> {\n-        match path.node {\n-            ast::ViewPathSimple(dst, _, id) => {\n+                       id: ast::NodeId,\n+                       please_inline: bool) -> Option<ast::ViewPath_> {\n+        match path {\n+            ast::ViewPathSimple(dst, base) => {\n                 if self.resolve_id(id, Some(dst), false, om, please_inline) {\n-                    return None\n+                    None\n+                } else {\n+                    Some(ast::ViewPathSimple(dst, base))\n                 }\n             }\n-            ast::ViewPathList(ref p, ref paths, ref b) => {\n-                let mut mine = Vec::new();\n-                for path in paths.iter() {\n-                    if !self.resolve_id(path.node.id(), None, false, om,\n-                                        please_inline) {\n-                        mine.push(path.clone());\n-                    }\n-                }\n+            ast::ViewPathList(p, paths) => {\n+                let mine = paths.into_iter().filter(|path| {\n+                    !self.resolve_id(path.node.id(), None, false, om,\n+                                     please_inline)\n+                }).collect::<Vec<ast::PathListItem>>();\n \n-                if mine.len() == 0 { return None }\n-                return Some(P(::syntax::codemap::Spanned {\n-                    node: ast::ViewPathList(p.clone(), mine, b.clone()),\n-                    span: path.span,\n-                }))\n+                if mine.len() == 0 {\n+                    None\n+                } else {\n+                    Some(ast::ViewPathList(p, mine))\n+                }\n             }\n \n             // these are feature gated anyway\n-            ast::ViewPathGlob(_, id) => {\n+            ast::ViewPathGlob(base) => {\n                 if self.resolve_id(id, None, true, om, please_inline) {\n-                    return None\n+                    None\n+                } else {\n+                    Some(ast::ViewPathGlob(base))\n                 }\n             }\n         }\n-        Some(P(path.clone()))\n+\n     }\n \n     fn resolve_id(&mut self, id: ast::NodeId, renamed: Option<ast::Ident>,\n@@ -242,9 +211,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 if glob {\n                     match it.node {\n                         ast::ItemMod(ref m) => {\n-                            for vi in m.view_items.iter() {\n-                                self.visit_view_item(vi, om);\n-                            }\n                             for i in m.items.iter() {\n                                 self.visit_item(&**i, None, om);\n                             }\n@@ -268,6 +234,45 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         debug!(\"Visiting item {:?}\", item);\n         let name = renamed.unwrap_or(item.ident);\n         match item.node {\n+            ast::ItemExternCrate(ref p) => {\n+                let path = match *p {\n+                    None => None,\n+                    Some((ref x, _)) => Some(x.get().to_string()),\n+                };\n+                om.extern_crates.push(ExternCrate {\n+                    name: name,\n+                    path: path,\n+                    vis: item.vis,\n+                    attrs: item.attrs.clone(),\n+                    whence: item.span,\n+                })\n+            }\n+            ast::ItemUse(ref vpath) => {\n+                let node = vpath.node.clone();\n+                let node = if item.vis == ast::Public {\n+                    let please_inline = item.attrs.iter().any(|item| {\n+                        match item.meta_item_list() {\n+                            Some(list) => {\n+                                list.iter().any(|i| i.name().get() == \"inline\")\n+                            }\n+                            None => false,\n+                        }\n+                    });\n+                    match self.visit_view_path(node, om, item.id, please_inline) {\n+                        None => return,\n+                        Some(p) => p\n+                    }\n+                } else {\n+                    node\n+                };\n+                om.imports.push(Import {\n+                    id: item.id,\n+                    vis: item.vis,\n+                    attrs: item.attrs.clone(),\n+                    node: node,\n+                    whence: item.span,\n+                });\n+            }\n             ast::ItemMod(ref m) => {\n                 om.mods.push(self.visit_mod_contents(item.span,\n                                                      item.attrs.clone(),"}, {"sha": "7111fe3af1fa9e81814b055716997e0f38bbb81d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 38, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -53,7 +53,6 @@ pub use self::UnboxedClosureKind::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n pub use self::VariantKind::*;\n-pub use self::ViewItem_::*;\n pub use self::ViewPath_::*;\n pub use self::Visibility::*;\n pub use self::PathParameters::*;\n@@ -511,7 +510,6 @@ impl PartialEq for MetaItem_ {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n pub struct Block {\n-    pub view_items: Vec<ViewItem>,\n     pub stmts: Vec<P<Stmt>>,\n     pub expr: Option<P<Expr>>,\n     pub id: NodeId,\n@@ -1443,14 +1441,12 @@ pub struct Mod {\n     /// For `mod foo;`, the inner span ranges from the first token\n     /// to the last token in the external file.\n     pub inner: Span,\n-    pub view_items: Vec<ViewItem>,\n     pub items: Vec<P<Item>>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n pub struct ForeignMod {\n     pub abi: Abi,\n-    pub view_items: Vec<ViewItem>,\n     pub items: Vec<P<ForeignItem>>,\n }\n \n@@ -1509,44 +1505,13 @@ pub enum ViewPath_ {\n     /// or just\n     ///\n     /// `foo::bar::baz` (with `as baz` implicitly on the right)\n-    ViewPathSimple(Ident, Path, NodeId),\n+    ViewPathSimple(Ident, Path),\n \n     /// `foo::bar::*`\n-    ViewPathGlob(Path, NodeId),\n+    ViewPathGlob(Path),\n \n     /// `foo::bar::{a,b,c}`\n-    ViewPathList(Path, Vec<PathListItem> , NodeId)\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n-pub struct ViewItem {\n-    pub node: ViewItem_,\n-    pub attrs: Vec<Attribute>,\n-    pub vis: Visibility,\n-    pub span: Span,\n-}\n-\n-impl ViewItem {\n-    pub fn id(&self) -> NodeId {\n-        match self.node {\n-            ViewItemExternCrate(_, _, id) => id,\n-            ViewItemUse(ref vp) => match vp.node {\n-                ViewPathSimple(_, _, id) => id,\n-                ViewPathGlob(_, id) => id,\n-                ViewPathList(_, _, id) => id,\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n-pub enum ViewItem_ {\n-    /// Ident: name used to refer to this crate in the code\n-    /// optional (InternedString,StrStyle): if present, this is a location\n-    /// (containing arbitrary characters) from which to fetch the crate sources\n-    /// For example, extern crate whatever = \"github.com/rust-lang/rust\"\n-    ViewItemExternCrate(Ident, Option<(InternedString,StrStyle)>, NodeId),\n-    ViewItemUse(P<ViewPath>),\n+    ViewPathList(Path, Vec<PathListItem>)\n }\n \n /// Meta-data associated with an item\n@@ -1668,6 +1633,12 @@ pub struct Item {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n pub enum Item_ {\n+    // Optional location (containing arbitrary characters) from which\n+    // to fetch the crate sources.\n+    // For example, extern crate whatever = \"github.com/rust-lang/rust\".\n+    ItemExternCrate(Option<(InternedString, StrStyle)>),\n+    ItemUse(P<ViewPath>),\n+\n     ItemStatic(P<Ty>, Mutability, P<Expr>),\n     ItemConst(P<Ty>, P<Expr>),\n     ItemFn(P<FnDecl>, Unsafety, Abi, Generics, P<Block>),\n@@ -1694,6 +1665,8 @@ pub enum Item_ {\n impl Item_ {\n     pub fn descriptive_variant(&self) -> &str {\n         match *self {\n+            ItemExternCrate(..) => \"extern crate\",\n+            ItemUse(..) => \"use\",\n             ItemStatic(..) => \"static item\",\n             ItemConst(..) => \"constant item\",\n             ItemFn(..) => \"function\","}, {"sha": "8a114e4b7487de4ffc804bacd494a45fa01a0124", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -107,7 +107,6 @@ pub fn path_to_string<PI: Iterator<Item=PathElem>>(path: PI) -> String {\n #[derive(Copy, Show)]\n pub enum Node<'ast> {\n     NodeItem(&'ast Item),\n-    NodeViewItem(&'ast ViewItem),\n     NodeForeignItem(&'ast ForeignItem),\n     NodeTraitItem(&'ast TraitItem),\n     NodeImplItem(&'ast ImplItem),\n@@ -134,7 +133,6 @@ enum MapEntry<'ast> {\n \n     /// All the node types, with a parent ID.\n     EntryItem(NodeId, &'ast Item),\n-    EntryViewItem(NodeId, &'ast ViewItem),\n     EntryForeignItem(NodeId, &'ast ForeignItem),\n     EntryTraitItem(NodeId, &'ast TraitItem),\n     EntryImplItem(NodeId, &'ast ImplItem),\n@@ -169,7 +167,6 @@ impl<'ast> MapEntry<'ast> {\n     fn from_node(p: NodeId, node: Node<'ast>) -> MapEntry<'ast> {\n         match node {\n             NodeItem(n) => EntryItem(p, n),\n-            NodeViewItem(n) => EntryViewItem(p, n),\n             NodeForeignItem(n) => EntryForeignItem(p, n),\n             NodeTraitItem(n) => EntryTraitItem(p, n),\n             NodeImplItem(n) => EntryImplItem(p, n),\n@@ -188,7 +185,6 @@ impl<'ast> MapEntry<'ast> {\n     fn parent(self) -> Option<NodeId> {\n         Some(match self {\n             EntryItem(id, _) => id,\n-            EntryViewItem(id, _) => id,\n             EntryForeignItem(id, _) => id,\n             EntryTraitItem(id, _) => id,\n             EntryImplItem(id, _) => id,\n@@ -208,7 +204,6 @@ impl<'ast> MapEntry<'ast> {\n     fn to_node(self) -> Option<Node<'ast>> {\n         Some(match self {\n             EntryItem(_, n) => NodeItem(n),\n-            EntryViewItem(_, n) => NodeViewItem(n),\n             EntryForeignItem(_, n) => NodeForeignItem(n),\n             EntryTraitItem(_, n) => NodeTraitItem(n),\n             EntryImplItem(_, n) => NodeImplItem(n),\n@@ -341,13 +336,6 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn expect_view_item(&self, id: NodeId) -> &'ast ViewItem {\n-        match self.find(id) {\n-            Some(NodeViewItem(view_item)) => view_item,\n-            _ => panic!(\"expected view item, found {}\", self.node_to_string(id))\n-        }\n-    }\n-\n     pub fn expect_struct(&self, id: NodeId) -> &'ast StructDef {\n         match self.find(id) {\n             Some(NodeItem(i)) => {\n@@ -533,7 +521,6 @@ impl<'ast> Map<'ast> {\n     pub fn opt_span(&self, id: NodeId) -> Option<Span> {\n         let sp = match self.find(id) {\n             Some(NodeItem(item)) => item.span,\n-            Some(NodeViewItem(item)) => item.span,\n             Some(NodeForeignItem(foreign_item)) => foreign_item.span,\n             Some(NodeTraitItem(trait_method)) => {\n                 match *trait_method {\n@@ -826,11 +813,6 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.parent = parent;\n     }\n \n-    fn visit_view_item(&mut self, item: &'ast ViewItem) {\n-        self.insert(item.id(), NodeViewItem(item));\n-        visit::walk_view_item(self, item);\n-    }\n-\n     fn visit_pat(&mut self, pat: &'ast Pat) {\n         self.insert(pat.id, match pat.node {\n             // Note: this is at least *potentially* a pattern...\n@@ -904,7 +886,6 @@ pub fn map_crate<'ast, F: FoldOps>(forest: &'ast mut Forest, fold_ops: F) -> Map\n     let krate = mem::replace(&mut forest.krate, Crate {\n         module: Mod {\n             inner: DUMMY_SP,\n-            view_items: vec![],\n             items: vec![],\n         },\n         attrs: vec![],\n@@ -1036,7 +1017,6 @@ impl<'a> NodePrinter for pprust::State<'a> {\n     fn print_node(&mut self, node: &Node) -> IoResult<()> {\n         match *node {\n             NodeItem(a)        => self.print_item(&*a),\n-            NodeViewItem(a)    => self.print_view_item(&*a),\n             NodeForeignItem(a) => self.print_foreign_item(&*a),\n             NodeTraitItem(a)   => self.print_trait_method(&*a),\n             NodeImplItem(a)    => self.print_impl_item(&*a),\n@@ -1065,6 +1045,8 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeItem(item)) => {\n             let path_str = map.path_to_str_with_ident(id, item.ident);\n             let item_str = match item.node {\n+                ItemExternCrate(..) => \"extern crate\",\n+                ItemUse(..) => \"use\",\n                 ItemStatic(..) => \"static\",\n                 ItemConst(..) => \"const\",\n                 ItemFn(..) => \"fn\",\n@@ -1079,9 +1061,6 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n             };\n             format!(\"{} {}{}\", item_str, path_str, id_str)\n         }\n-        Some(NodeViewItem(item)) => {\n-            format!(\"view item {}{}\", pprust::view_item_to_string(&*item), id_str)\n-        }\n         Some(NodeForeignItem(item)) => {\n             let path_str = map.path_to_str_with_ident(id, item.ident);\n             format!(\"foreign item {}{}\", path_str, id_str)"}, {"sha": "892b3c1e7f2b7aee9cfdfffee53261d127de1559", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 17, "deletions": 65, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -410,37 +410,6 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         visit::walk_mod(self, module)\n     }\n \n-    fn visit_view_item(&mut self, view_item: &ViewItem) {\n-        if !self.pass_through_items {\n-            if self.visited_outermost {\n-                return;\n-            } else {\n-                self.visited_outermost = true;\n-            }\n-        }\n-        match view_item.node {\n-            ViewItemExternCrate(_, _, node_id) => {\n-                self.operation.visit_id(node_id)\n-            }\n-            ViewItemUse(ref view_path) => {\n-                match view_path.node {\n-                    ViewPathSimple(_, _, node_id) |\n-                    ViewPathGlob(_, node_id) => {\n-                        self.operation.visit_id(node_id)\n-                    }\n-                    ViewPathList(_, ref paths, node_id) => {\n-                        self.operation.visit_id(node_id);\n-                        for path in paths.iter() {\n-                            self.operation.visit_id(path.node.id())\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        visit::walk_view_item(self, view_item);\n-        self.visited_outermost = false;\n-    }\n-\n     fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n         self.operation.visit_id(foreign_item.id);\n         visit::walk_foreign_item(self, foreign_item)\n@@ -456,10 +425,24 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         }\n \n         self.operation.visit_id(item.id);\n-        if let ItemEnum(ref enum_definition, _) = item.node {\n-            for variant in enum_definition.variants.iter() {\n-                self.operation.visit_id(variant.node.id)\n+        match item.node {\n+            ItemUse(ref view_path) => {\n+                match view_path.node {\n+                    ViewPathSimple(_, _) |\n+                    ViewPathGlob(_) => {}\n+                    ViewPathList(_, ref paths) => {\n+                        for path in paths.iter() {\n+                            self.operation.visit_id(path.node.id())\n+                        }\n+                    }\n+                }\n+            }\n+            ItemEnum(ref enum_definition, _) => {\n+                for variant in enum_definition.variants.iter() {\n+                    self.operation.visit_id(variant.node.id)\n+                }\n             }\n+            _ => {}\n         }\n \n         visit::walk_item(self, item);\n@@ -662,37 +645,6 @@ pub fn walk_pat<F>(pat: &Pat, mut it: F) -> bool where F: FnMut(&Pat) -> bool {\n     walk_pat_(pat, &mut it)\n }\n \n-pub trait EachViewItem {\n-    fn each_view_item<F>(&self, f: F) -> bool where F: FnMut(&ast::ViewItem) -> bool;\n-}\n-\n-struct EachViewItemData<F> where F: FnMut(&ast::ViewItem) -> bool {\n-    callback: F,\n-}\n-\n-impl<'v, F> Visitor<'v> for EachViewItemData<F> where F: FnMut(&ast::ViewItem) -> bool {\n-    fn visit_view_item(&mut self, view_item: &ast::ViewItem) {\n-        let _ = (self.callback)(view_item);\n-    }\n-}\n-\n-impl EachViewItem for ast::Crate {\n-    fn each_view_item<F>(&self, f: F) -> bool where F: FnMut(&ast::ViewItem) -> bool {\n-        let mut visit = EachViewItemData {\n-            callback: f,\n-        };\n-        visit::walk_crate(&mut visit, self);\n-        true\n-    }\n-}\n-\n-pub fn view_path_id(p: &ViewPath) -> NodeId {\n-    match p.node {\n-        ViewPathSimple(_, _, id) | ViewPathGlob(_, id)\n-        | ViewPathList(_, _, id) => id\n-    }\n-}\n-\n /// Returns true if the given struct def is tuple-like; i.e. that its fields\n /// are unnamed.\n pub fn struct_def_is_tuple_like(struct_def: &ast::StructDef) -> bool {"}, {"sha": "3eaac0fe333e8e3026f69abd6ca6b0f7d8f52653", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 4, "deletions": 32, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -63,28 +63,13 @@ pub fn strip_items<F>(krate: ast::Crate, in_cfg: F) -> ast::Crate where\n     ctxt.fold_crate(krate)\n }\n \n-fn filter_view_item<F>(cx: &mut Context<F>,\n-                       view_item: ast::ViewItem)\n-                       -> Option<ast::ViewItem> where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    if view_item_in_cfg(cx, &view_item) {\n-        Some(view_item)\n-    } else {\n-        None\n-    }\n-}\n-\n fn fold_mod<F>(cx: &mut Context<F>,\n-               ast::Mod {inner,\n-               view_items, items}: ast::Mod) -> ast::Mod where\n+               ast::Mod {inner, items}: ast::Mod)\n+               -> ast::Mod where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n     ast::Mod {\n         inner: inner,\n-        view_items: view_items.into_iter().filter_map(|a| {\n-            filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n-        }).collect(),\n         items: items.into_iter().flat_map(|a| {\n             cx.fold_item(a).into_iter()\n         }).collect()\n@@ -104,15 +89,12 @@ fn filter_foreign_item<F>(cx: &mut Context<F>,\n }\n \n fn fold_foreign_mod<F>(cx: &mut Context<F>,\n-                       ast::ForeignMod {abi, view_items, items}: ast::ForeignMod)\n+                       ast::ForeignMod {abi, items}: ast::ForeignMod)\n                        -> ast::ForeignMod where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n     ast::ForeignMod {\n         abi: abi,\n-        view_items: view_items.into_iter().filter_map(|a| {\n-            filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n-        }).collect(),\n         items: items.into_iter()\n                     .filter_map(|a| filter_foreign_item(cx, a))\n                     .collect()\n@@ -216,18 +198,14 @@ fn retain_stmt<F>(cx: &mut Context<F>, stmt: &ast::Stmt) -> bool where\n fn fold_block<F>(cx: &mut Context<F>, b: P<ast::Block>) -> P<ast::Block> where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n-    b.map(|ast::Block {id, view_items, stmts, expr, rules, span}| {\n+    b.map(|ast::Block {id, stmts, expr, rules, span}| {\n         let resulting_stmts: Vec<P<ast::Stmt>> =\n             stmts.into_iter().filter(|a| retain_stmt(cx, &**a)).collect();\n         let resulting_stmts = resulting_stmts.into_iter()\n             .flat_map(|stmt| cx.fold_stmt(stmt).into_iter())\n             .collect();\n-        let filtered_view_items = view_items.into_iter().filter_map(|a| {\n-            filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n-        }).collect();\n         ast::Block {\n             id: id,\n-            view_items: filtered_view_items,\n             stmts: resulting_stmts,\n             expr: expr.map(|x| cx.fold_expr(x)),\n             rules: rules,\n@@ -267,12 +245,6 @@ fn foreign_item_in_cfg<F>(cx: &mut Context<F>, item: &ast::ForeignItem) -> bool\n     return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n-fn view_item_in_cfg<F>(cx: &mut Context<F>, item: &ast::ViewItem) -> bool where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    return (cx.in_cfg)(item.attrs.as_slice());\n-}\n-\n fn trait_method_in_cfg<F>(cx: &mut Context<F>, meth: &ast::TraitItem) -> bool where\n     F: FnMut(&[ast::Attribute]) -> bool\n {"}, {"sha": "92619cf42e4d197a517990dddd2f78abb5de6f6d", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 36, "deletions": 41, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -97,7 +97,6 @@ pub trait AstBuilder {\n              expr: Option<P<ast::Expr>>) -> P<ast::Block>;\n     fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block>;\n     fn block_all(&self, span: Span,\n-                 view_items: Vec<ast::ViewItem>,\n                  stmts: Vec<P<ast::Stmt>>,\n                  expr: Option<P<ast::Expr>>) -> P<ast::Block>;\n \n@@ -242,7 +241,7 @@ pub trait AstBuilder {\n \n     fn item_mod(&self, span: Span, inner_span: Span,\n                 name: Ident, attrs: Vec<ast::Attribute>,\n-                vi: Vec<ast::ViewItem> , items: Vec<P<ast::Item>> ) -> P<ast::Item>;\n+                items: Vec<P<ast::Item>>) -> P<ast::Item>;\n \n     fn item_static(&self,\n                    span: Span,\n@@ -280,15 +279,15 @@ pub trait AstBuilder {\n                        value: ast::Lit_)\n                        -> P<ast::MetaItem>;\n \n-    fn view_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: P<ast::ViewPath>) -> ast::ViewItem;\n-    fn view_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> ast::ViewItem;\n-    fn view_use_simple_(&self, sp: Span, vis: ast::Visibility,\n-                        ident: ast::Ident, path: ast::Path) -> ast::ViewItem;\n-    fn view_use_list(&self, sp: Span, vis: ast::Visibility,\n-                     path: Vec<ast::Ident> , imports: &[ast::Ident]) -> ast::ViewItem;\n-    fn view_use_glob(&self, sp: Span,\n-                     vis: ast::Visibility, path: Vec<ast::Ident> ) -> ast::ViewItem;\n+    fn item_use(&self, sp: Span,\n+                vis: ast::Visibility, vp: P<ast::ViewPath>) -> P<ast::Item>;\n+    fn item_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> P<ast::Item>;\n+    fn item_use_simple_(&self, sp: Span, vis: ast::Visibility,\n+                        ident: ast::Ident, path: ast::Path) -> P<ast::Item>;\n+    fn item_use_list(&self, sp: Span, vis: ast::Visibility,\n+                     path: Vec<ast::Ident>, imports: &[ast::Ident]) -> P<ast::Item>;\n+    fn item_use_glob(&self, sp: Span,\n+                     vis: ast::Visibility, path: Vec<ast::Ident>) -> P<ast::Item>;\n }\n \n impl<'a> AstBuilder for ExtCtxt<'a> {\n@@ -519,7 +518,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn block(&self, span: Span, stmts: Vec<P<ast::Stmt>>,\n              expr: Option<P<Expr>>) -> P<ast::Block> {\n-        self.block_all(span, Vec::new(), stmts, expr)\n+        self.block_all(span, stmts, expr)\n     }\n \n     fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> P<ast::Stmt> {\n@@ -528,15 +527,13 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block> {\n-        self.block_all(expr.span, Vec::new(), Vec::new(), Some(expr))\n+        self.block_all(expr.span, Vec::new(), Some(expr))\n     }\n     fn block_all(&self,\n                  span: Span,\n-                 view_items: Vec<ast::ViewItem>,\n                  stmts: Vec<P<ast::Stmt>>,\n                  expr: Option<P<ast::Expr>>) -> P<ast::Block> {\n             P(ast::Block {\n-               view_items: view_items,\n                stmts: stmts,\n                expr: expr,\n                id: ast::DUMMY_NODE_ID,\n@@ -1031,16 +1028,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn item_mod(&self, span: Span, inner_span: Span, name: Ident,\n-                attrs: Vec<ast::Attribute> ,\n-                vi: Vec<ast::ViewItem> ,\n-                items: Vec<P<ast::Item>> ) -> P<ast::Item> {\n+                attrs: Vec<ast::Attribute>,\n+                items: Vec<P<ast::Item>>) -> P<ast::Item> {\n         self.item(\n             span,\n             name,\n             attrs,\n             ast::ItemMod(ast::Mod {\n                 inner: inner_span,\n-                view_items: vi,\n                 items: items,\n             })\n         )\n@@ -1101,47 +1096,47 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         P(respan(sp, ast::MetaNameValue(name, respan(sp, value))))\n     }\n \n-    fn view_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: P<ast::ViewPath>) -> ast::ViewItem {\n-        ast::ViewItem {\n-            node: ast::ViewItemUse(vp),\n-            attrs: Vec::new(),\n+    fn item_use(&self, sp: Span,\n+                vis: ast::Visibility, vp: P<ast::ViewPath>) -> P<ast::Item> {\n+        P(ast::Item {\n+            id: ast::DUMMY_NODE_ID,\n+            ident: special_idents::invalid,\n+            attrs: vec![],\n+            node: ast::ItemUse(vp),\n             vis: vis,\n             span: sp\n-        }\n+        })\n     }\n \n-    fn view_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> ast::ViewItem {\n+    fn item_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> P<ast::Item> {\n         let last = path.segments.last().unwrap().identifier;\n-        self.view_use_simple_(sp, vis, last, path)\n+        self.item_use_simple_(sp, vis, last, path)\n     }\n \n-    fn view_use_simple_(&self, sp: Span, vis: ast::Visibility,\n-                        ident: ast::Ident, path: ast::Path) -> ast::ViewItem {\n-        self.view_use(sp, vis,\n+    fn item_use_simple_(&self, sp: Span, vis: ast::Visibility,\n+                        ident: ast::Ident, path: ast::Path) -> P<ast::Item> {\n+        self.item_use(sp, vis,\n                       P(respan(sp,\n                                ast::ViewPathSimple(ident,\n-                                                   path,\n-                                                   ast::DUMMY_NODE_ID))))\n+                                                   path))))\n     }\n \n-    fn view_use_list(&self, sp: Span, vis: ast::Visibility,\n-                     path: Vec<ast::Ident> , imports: &[ast::Ident]) -> ast::ViewItem {\n+    fn item_use_list(&self, sp: Span, vis: ast::Visibility,\n+                     path: Vec<ast::Ident>, imports: &[ast::Ident]) -> P<ast::Item> {\n         let imports = imports.iter().map(|id| {\n             respan(sp, ast::PathListIdent { name: *id, id: ast::DUMMY_NODE_ID })\n         }).collect();\n \n-        self.view_use(sp, vis,\n+        self.item_use(sp, vis,\n                       P(respan(sp,\n                                ast::ViewPathList(self.path(sp, path),\n-                                                 imports,\n-                                                 ast::DUMMY_NODE_ID))))\n+                                                 imports))))\n     }\n \n-    fn view_use_glob(&self, sp: Span,\n-                     vis: ast::Visibility, path: Vec<ast::Ident> ) -> ast::ViewItem {\n-        self.view_use(sp, vis,\n+    fn item_use_glob(&self, sp: Span,\n+                     vis: ast::Visibility, path: Vec<ast::Ident>) -> P<ast::Item> {\n+        self.item_use(sp, vis,\n                       P(respan(sp,\n-                               ast::ViewPathGlob(self.path(sp, path), ast::DUMMY_NODE_ID))))\n+                               ast::ViewPathGlob(self.path(sp, path)))))\n     }\n }"}, {"sha": "272b0464010114d0c708b19b461d300ff691c871", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -1073,7 +1073,7 @@ impl<'a> MethodDef<'a> {\n             //   <delegated expression referring to __self0_vi, et al.>\n             // }\n             let arm_expr = cx.expr_block(\n-                cx.block_all(sp, Vec::new(), index_let_stmts, Some(arm_expr)));\n+                cx.block_all(sp, index_let_stmts, Some(arm_expr)));\n \n             // Builds arm:\n             // _ => { let __self0_vi = ...;"}, {"sha": "629991799e73de2d4638eb849521244acad18cb5", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -206,7 +206,6 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n                     // wrap the if-let expr in a block\n                     let span = els.span;\n                     let blk = P(ast::Block {\n-                        view_items: vec![],\n                         stmts: vec![],\n                         expr: Some(P(els)),\n                         id: ast::DUMMY_NODE_ID,\n@@ -799,8 +798,7 @@ pub fn expand_block(blk: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n \n // expand the elements of a block.\n pub fn expand_block_elts(b: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n-    b.map(|Block {id, view_items, stmts, expr, rules, span}| {\n-        let new_view_items = view_items.into_iter().map(|x| fld.fold_view_item(x)).collect();\n+    b.map(|Block {id, stmts, expr, rules, span}| {\n         let new_stmts = stmts.into_iter().flat_map(|x| {\n             // perform all pending renames\n             let renamed_stmt = {\n@@ -821,7 +819,6 @@ pub fn expand_block_elts(b: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n         });\n         Block {\n             id: fld.new_id(id),\n-            view_items: new_view_items,\n             stmts: new_stmts,\n             expr: new_expr,\n             rules: rules,"}, {"sha": "7e345a2d078ffa1aff57d20a375d14763f9b90b3", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -352,18 +352,11 @@ pub mod rt {\n     impl<'a> ExtParseUtils for ExtCtxt<'a> {\n \n         fn parse_item(&self, s: String) -> P<ast::Item> {\n-            let res = parse::parse_item_from_source_str(\n+            parse::parse_item_from_source_str(\n                 \"<quote expansion>\".to_string(),\n                 s,\n                 self.cfg(),\n-                self.parse_sess());\n-            match res {\n-                Some(ast) => ast,\n-                None => {\n-                    error!(\"parse error\");\n-                    panic!()\n-                }\n-            }\n+                self.parse_sess()).expect(\"parse error\")\n         }\n \n         fn parse_stmt(&self, s: String) -> P<ast::Stmt> {\n@@ -767,7 +760,6 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     vector.extend(mk_tts(cx, &tts[]).into_iter());\n     let block = cx.expr_block(\n         cx.block_all(sp,\n-                     Vec::new(),\n                      vector,\n                      Some(cx.expr_ident(sp, id_ext(\"tt\")))));\n \n@@ -778,18 +770,18 @@ fn expand_wrapper(cx: &ExtCtxt,\n                   sp: Span,\n                   cx_expr: P<ast::Expr>,\n                   expr: P<ast::Expr>) -> P<ast::Expr> {\n-    let uses = [\n-        &[\"syntax\", \"ext\", \"quote\", \"rt\"],\n-    ].iter().map(|path| {\n-        let path = path.iter().map(|s| s.to_string()).collect();\n-        cx.view_use_glob(sp, ast::Inherited, ids_ext(path))\n-    }).collect();\n-\n     // Explicitly borrow to avoid moving from the invoker (#16992)\n     let cx_expr_borrow = cx.expr_addr_of(sp, cx.expr_deref(sp, cx_expr));\n     let stmt_let_ext_cx = cx.stmt_let(sp, false, id_ext(\"ext_cx\"), cx_expr_borrow);\n \n-    cx.expr_block(cx.block_all(sp, uses, vec!(stmt_let_ext_cx), Some(expr)))\n+    let stmts = [\n+        &[\"syntax\", \"ext\", \"quote\", \"rt\"],\n+    ].iter().map(|path| {\n+        let path = path.iter().map(|s| s.to_string()).collect();\n+        cx.stmt_item(sp, cx.item_use_glob(sp, ast::Inherited, ids_ext(path)))\n+    }).chain(Some(stmt_let_ext_cx).into_iter()).collect();\n+\n+    cx.expr_block(cx.block_all(sp, stmts, Some(expr)))\n }\n \n fn expand_parse_call(cx: &ExtCtxt,"}, {"sha": "762a1dcbfc34b7323e3b0fe5ba2b9b26efaeb0c3", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -64,7 +64,7 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n \n     (\"rustc_diagnostic_macros\", Active),\n     (\"unboxed_closures\", Active),\n-    (\"import_shadowing\", Active),\n+    (\"import_shadowing\", Removed),\n     (\"advanced_slice_patterns\", Active),\n     (\"tuple_indexing\", Accepted),\n     (\"associated_types\", Accepted),\n@@ -127,7 +127,6 @@ enum Status {\n pub struct Features {\n     pub unboxed_closures: bool,\n     pub rustc_diagnostic_macros: bool,\n-    pub import_shadowing: bool,\n     pub visible_private_types: bool,\n     pub quote: bool,\n     pub old_orphan_check: bool,\n@@ -139,7 +138,6 @@ impl Features {\n         Features {\n             unboxed_closures: false,\n             rustc_diagnostic_macros: false,\n-            import_shadowing: false,\n             visible_private_types: false,\n             quote: false,\n             old_orphan_check: false,\n@@ -228,22 +226,6 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n         }\n     }\n \n-    fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        match i.node {\n-            ast::ViewItemUse(..) => {}\n-            ast::ViewItemExternCrate(..) => {\n-                for attr in i.attrs.iter() {\n-                    if attr.check_name(\"plugin\") {\n-                        self.gate_feature(\"plugin\", attr.span,\n-                                          \"compiler plugins are experimental \\\n-                                           and possibly buggy\");\n-                    }\n-                }\n-            }\n-        }\n-        visit::walk_view_item(self, i)\n-    }\n-\n     fn visit_item(&mut self, i: &ast::Item) {\n         for attr in i.attrs.iter() {\n             if attr.name() == \"thread_local\" {\n@@ -262,6 +244,14 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n             }\n         }\n         match i.node {\n+            ast::ItemExternCrate(_) => {\n+                if attr::contains_name(&i.attrs[], \"plugin\") {\n+                    self.gate_feature(\"plugin\", i.span,\n+                                      \"compiler plugins are experimental \\\n+                                       and possibly buggy\");\n+                }\n+            }\n+\n             ast::ItemForeignMod(ref foreign_module) => {\n                 if attr::contains_name(&i.attrs[], \"link_args\") {\n                     self.gate_feature(\"link_args\", i.span,\n@@ -537,7 +527,6 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::C\n     (Features {\n         unboxed_closures: cx.has_feature(\"unboxed_closures\"),\n         rustc_diagnostic_macros: cx.has_feature(\"rustc_diagnostic_macros\"),\n-        import_shadowing: cx.has_feature(\"import_shadowing\"),\n         visible_private_types: cx.has_feature(\"visible_private_types\"),\n         quote: cx.has_feature(\"quote\"),\n         old_orphan_check: cx.has_feature(\"old_orphan_check\"),"}, {"sha": "9f8427cc8aed0f16b317f3ccbdcd9d57aa3e1907", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 15, "deletions": 41, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -78,10 +78,6 @@ pub trait Folder : Sized {\n         noop_fold_view_path(view_path, self)\n     }\n \n-    fn fold_view_item(&mut self, vi: ViewItem) -> ViewItem {\n-        noop_fold_view_item(vi, self)\n-    }\n-\n     fn fold_foreign_item(&mut self, ni: P<ForeignItem>) -> P<ForeignItem> {\n         noop_fold_foreign_item(ni, self)\n     }\n@@ -349,16 +345,13 @@ pub fn noop_fold_meta_items<T: Folder>(meta_items: Vec<P<MetaItem>>, fld: &mut T\n pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<ViewPath> {\n     view_path.map(|Spanned {node, span}| Spanned {\n         node: match node {\n-            ViewPathSimple(ident, path, node_id) => {\n-                let id = fld.new_id(node_id);\n-                ViewPathSimple(ident, fld.fold_path(path), id)\n+            ViewPathSimple(ident, path) => {\n+                ViewPathSimple(ident, fld.fold_path(path))\n             }\n-            ViewPathGlob(path, node_id) => {\n-                let id = fld.new_id(node_id);\n-                ViewPathGlob(fld.fold_path(path), id)\n+            ViewPathGlob(path) => {\n+                ViewPathGlob(fld.fold_path(path))\n             }\n-            ViewPathList(path, path_list_idents, node_id) => {\n-                let id = fld.new_id(node_id);\n+            ViewPathList(path, path_list_idents) => {\n                 ViewPathList(fld.fold_path(path),\n                              path_list_idents.move_map(|path_list_ident| {\n                                 Spanned {\n@@ -373,8 +366,7 @@ pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<\n                                     },\n                                     span: fld.new_span(path_list_ident.span)\n                                 }\n-                             }),\n-                             id)\n+                             }))\n             }\n         },\n         span: fld.new_span(span)\n@@ -470,11 +462,10 @@ pub fn noop_fold_qpath<T: Folder>(qpath: P<QPath>, fld: &mut T) -> P<QPath> {\n     })\n }\n \n-pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod {abi, view_items, items}: ForeignMod,\n+pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod {abi, items}: ForeignMod,\n                                         fld: &mut T) -> ForeignMod {\n     ForeignMod {\n         abi: abi,\n-        view_items: view_items.move_map(|x| fld.fold_view_item(x)),\n         items: items.move_map(|x| fld.fold_foreign_item(x)),\n     }\n }\n@@ -953,28 +944,9 @@ fn noop_fold_variant_arg<T: Folder>(VariantArg {id, ty}: VariantArg, folder: &mu\n     }\n }\n \n-pub fn noop_fold_view_item<T: Folder>(ViewItem {node, attrs, vis, span}: ViewItem,\n-                                      folder: &mut T) -> ViewItem {\n-    ViewItem {\n-        node: match node {\n-            ViewItemExternCrate(ident, string, node_id) => {\n-                ViewItemExternCrate(ident, string,\n-                                    folder.new_id(node_id))\n-            }\n-            ViewItemUse(view_path) => {\n-                ViewItemUse(folder.fold_view_path(view_path))\n-            }\n-        },\n-        attrs: attrs.move_map(|a| folder.fold_attribute(a)),\n-        vis: vis,\n-        span: folder.new_span(span)\n-    }\n-}\n-\n pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n-    b.map(|Block {id, view_items, stmts, expr, rules, span}| Block {\n+    b.map(|Block {id, stmts, expr, rules, span}| Block {\n         id: folder.new_id(id),\n-        view_items: view_items.move_map(|x| folder.fold_view_item(x)),\n         stmts: stmts.into_iter().flat_map(|s| folder.fold_stmt(s).into_iter()).collect(),\n         expr: expr.map(|x| folder.fold_expr(x)),\n         rules: rules,\n@@ -984,6 +956,10 @@ pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n \n pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n     match i {\n+        ItemExternCrate(string) => ItemExternCrate(string),\n+        ItemUse(view_path) => {\n+            ItemUse(folder.fold_view_path(view_path))\n+        }\n         ItemStatic(t, m, e) => {\n             ItemStatic(folder.fold_ty(t), m, folder.fold_expr(e))\n         }\n@@ -1103,10 +1079,9 @@ pub fn noop_fold_type_method<T: Folder>(m: TypeMethod, fld: &mut T) -> TypeMetho\n     }\n }\n \n-pub fn noop_fold_mod<T: Folder>(Mod {inner, view_items, items}: Mod, folder: &mut T) -> Mod {\n+pub fn noop_fold_mod<T: Folder>(Mod {inner, items}: Mod, folder: &mut T) -> Mod {\n     Mod {\n         inner: folder.new_span(inner),\n-        view_items: view_items.move_map(|x| folder.fold_view_item(x)),\n         items: items.into_iter().flat_map(|x| folder.fold_item(x).into_iter()).collect(),\n     }\n }\n@@ -1137,9 +1112,8 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, mut exported_mac\n         }\n         None => (ast::Mod {\n             inner: span,\n-            view_items: Vec::new(),\n-            items: Vec::new(),\n-        }, Vec::new(), span)\n+            items: vec![],\n+        }, vec![], span)\n     };\n \n     for def in exported_macros.iter_mut() {"}, {"sha": "8cb7ee5b33746e95ca8b43dd9d5d61a0f9cbbefd", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -757,11 +757,10 @@ mod test {\n     use attr::{first_attr_value_str_by_name, AttrMetaMethods};\n     use parse::parser::Parser;\n     use parse::token::{str_to_ident};\n-    use print::pprust::view_item_to_string;\n+    use print::pprust::item_to_string;\n     use ptr::P;\n     use util::parser_testing::{string_to_tts, string_to_parser};\n-    use util::parser_testing::{string_to_expr, string_to_item};\n-    use util::parser_testing::{string_to_stmt, string_to_view_item};\n+    use util::parser_testing::{string_to_expr, string_to_item, string_to_stmt};\n \n     // produce a codemap::span\n     fn sp(a: u32, b: u32) -> Span {\n@@ -1079,7 +1078,6 @@ mod test {\n                                         }\n                                     },\n                                     P(ast::Block {\n-                                        view_items: Vec::new(),\n                                         stmts: vec!(P(Spanned{\n                                             node: ast::StmtSemi(P(ast::Expr{\n                                                 id: ast::DUMMY_NODE_ID,\n@@ -1111,25 +1109,25 @@ mod test {\n \n     #[test] fn parse_use() {\n         let use_s = \"use foo::bar::baz;\";\n-        let vitem = string_to_view_item(use_s.to_string());\n-        let vitem_s = view_item_to_string(&vitem);\n+        let vitem = string_to_item(use_s.to_string()).unwrap();\n+        let vitem_s = item_to_string(&*vitem);\n         assert_eq!(&vitem_s[], use_s);\n \n         let use_s = \"use foo::bar as baz;\";\n-        let vitem = string_to_view_item(use_s.to_string());\n-        let vitem_s = view_item_to_string(&vitem);\n+        let vitem = string_to_item(use_s.to_string()).unwrap();\n+        let vitem_s = item_to_string(&*vitem);\n         assert_eq!(&vitem_s[], use_s);\n     }\n \n     #[test] fn parse_extern_crate() {\n         let ex_s = \"extern crate foo;\";\n-        let vitem = string_to_view_item(ex_s.to_string());\n-        let vitem_s = view_item_to_string(&vitem);\n+        let vitem = string_to_item(ex_s.to_string()).unwrap();\n+        let vitem_s = item_to_string(&*vitem);\n         assert_eq!(&vitem_s[], ex_s);\n \n         let ex_s = \"extern crate \\\"foo\\\" as bar;\";\n-        let vitem = string_to_view_item(ex_s.to_string());\n-        let vitem_s = view_item_to_string(&vitem);\n+        let vitem = string_to_item(ex_s.to_string()).unwrap();\n+        let vitem_s = item_to_string(&*vitem);\n         assert_eq!(&vitem_s[], ex_s);\n     }\n "}, {"sha": "fc02cb4acb82415146cfacb5e8d58903cb10db2e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 119, "deletions": 315, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n pub use self::PathParsingMode::*;\n-use self::ItemOrViewItem::*;\n \n use abi;\n use ast::{AssociatedType, BareFnTy};\n@@ -35,6 +34,7 @@ use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod, FunctionRet\n use ast::{Ident, Inherited, ImplItem, Item, Item_, ItemStatic};\n use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl, ItemConst};\n use ast::{ItemMac, ItemMod, ItemStruct, ItemTrait, ItemTy};\n+use ast::{ItemExternCrate, ItemUse};\n use ast::{LifetimeDef, Lit, Lit_};\n use ast::{LitBool, LitChar, LitByte, LitBinary};\n use ast::{LitStr, LitInt, Local, LocalLet};\n@@ -59,7 +59,6 @@ use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr, TyQPath\n use ast::{TyRptr, TyTup, TyU32, TyVec, UnUniq};\n use ast::{TypeImplItem, TypeTraitItem, Typedef, UnboxedClosureKind};\n use ast::{UnnamedField, UnsafeBlock};\n-use ast::{ViewItem, ViewItem_, ViewItemExternCrate, ViewItemUse};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n use ast;\n@@ -122,14 +121,9 @@ pub enum BoundParsingMode {\n     Modified,\n }\n \n-enum ItemOrViewItem {\n-    /// Indicates a failure to parse any kind of item. The attributes are\n-    /// returned.\n-    IoviNone(Vec<Attribute>),\n-    IoviItem(P<Item>),\n-    IoviForeignItem(P<ForeignItem>),\n-    IoviViewItem(ViewItem)\n-}\n+/// The `Err` case indicates a failure to parse any kind of item.\n+/// The attributes are returned.\n+type MaybeItem = Result<P<Item>, Vec<Attribute>>;\n \n \n /// Possibly accept an `token::Interpolated` expression (a pre-parsed expression\n@@ -231,19 +225,6 @@ macro_rules! maybe_whole {\n             }\n         }\n     );\n-    (iovi $p:expr, $constructor:ident) => (\n-        {\n-            let found = match ($p).token {\n-                token::Interpolated(token::$constructor(_)) => {\n-                    Some(($p).bump_and_get())\n-                }\n-                _ => None\n-            };\n-            if let Some(token::Interpolated(token::$constructor(x))) = found {\n-                return IoviItem(x.clone());\n-            }\n-        }\n-    );\n     (pair_empty $p:expr, $constructor:ident) => (\n         {\n             let found = match ($p).token {\n@@ -269,14 +250,6 @@ fn maybe_append(mut lhs: Vec<Attribute>, rhs: Option<Vec<Attribute>>)\n     lhs\n }\n \n-\n-struct ParsedItemsAndViewItems {\n-    attrs_remaining: Vec<Attribute>,\n-    view_items: Vec<ViewItem>,\n-    items: Vec<P<Item>> ,\n-    foreign_items: Vec<P<ForeignItem>>\n-}\n-\n /* ident is handled by common.rs */\n \n pub struct Parser<'a> {\n@@ -3032,8 +3005,7 @@ impl<'a> Parser<'a> {\n         let body = self.parse_expr();\n         let fakeblock = P(ast::Block {\n             id: ast::DUMMY_NODE_ID,\n-            view_items: Vec::new(),\n-            stmts: Vec::new(),\n+            stmts: vec![],\n             span: body.span,\n             expr: Some(body),\n             rules: DefaultBlock,\n@@ -3731,20 +3703,13 @@ impl<'a> Parser<'a> {\n         } else {\n             let found_attrs = !item_attrs.is_empty();\n             let item_err = Parser::expected_item_err(&item_attrs[]);\n-            match self.parse_item_or_view_item(item_attrs, false) {\n-                IoviItem(i) => {\n+            match self.parse_item_(item_attrs, false) {\n+                Ok(i) => {\n                     let hi = i.span.hi;\n                     let decl = P(spanned(lo, hi, DeclItem(i)));\n                     P(spanned(lo, hi, StmtDecl(decl, ast::DUMMY_NODE_ID)))\n                 }\n-                IoviViewItem(vi) => {\n-                    self.span_fatal(vi.span,\n-                                    \"view items must be declared at the top of the block\");\n-                }\n-                IoviForeignItem(_) => {\n-                    self.fatal(\"foreign items are not allowed here\");\n-                }\n-                IoviNone(_) => {\n+                Err(_) => {\n                     if found_attrs {\n                         let last_span = self.last_span;\n                         self.span_err(last_span, item_err);\n@@ -3794,36 +3759,17 @@ impl<'a> Parser<'a> {\n         (inner, self.parse_block_tail_(lo, DefaultBlock, next))\n     }\n \n-    /// Precondition: already parsed the '{' or '#{'\n-    /// I guess that also means \"already parsed the 'impure'\" if\n-    /// necessary, and this should take a qualifier.\n-    /// Some blocks start with \"#{\"...\n+    /// Precondition: already parsed the '{'.\n     fn parse_block_tail(&mut self, lo: BytePos, s: BlockCheckMode) -> P<Block> {\n         self.parse_block_tail_(lo, s, Vec::new())\n     }\n \n     /// Parse the rest of a block expression or function body\n     fn parse_block_tail_(&mut self, lo: BytePos, s: BlockCheckMode,\n-                         first_item_attrs: Vec<Attribute> ) -> P<Block> {\n-        let mut stmts = Vec::new();\n+                         first_item_attrs: Vec<Attribute>) -> P<Block> {\n+        let mut stmts = vec![];\n         let mut expr = None;\n-\n-        // wouldn't it be more uniform to parse view items only, here?\n-        let ParsedItemsAndViewItems {\n-            attrs_remaining,\n-            view_items,\n-            items,\n-            ..\n-        } = self.parse_items_and_view_items(first_item_attrs,\n-                                            false, false);\n-\n-        for item in items.into_iter() {\n-            let span = item.span;\n-            let decl = P(spanned(span.lo, span.hi, DeclItem(item)));\n-            stmts.push(P(spanned(span.lo, span.hi, StmtDecl(decl, ast::DUMMY_NODE_ID))));\n-        }\n-\n-        let mut attributes_box = attrs_remaining;\n+        let mut attributes_box = first_item_attrs;\n \n         while self.token != token::CloseDelim(token::Brace) {\n             // parsing items even when they're not allowed lets us give\n@@ -3932,7 +3878,6 @@ impl<'a> Parser<'a> {\n         let hi = self.span.hi;\n         self.bump();\n         P(ast::Block {\n-            view_items: view_items,\n             stmts: stmts,\n             expr: expr,\n             id: ast::DUMMY_NODE_ID,\n@@ -5031,56 +4976,50 @@ impl<'a> Parser<'a> {\n                        first_item_attrs: Vec<Attribute>,\n                        inner_lo: BytePos)\n                        -> Mod {\n-        // parse all of the items up to closing or an attribute.\n-        // view items are legal here.\n-        let ParsedItemsAndViewItems {\n-            attrs_remaining,\n-            view_items,\n-            items: starting_items,\n-            ..\n-        } = self.parse_items_and_view_items(first_item_attrs, true, true);\n-        let mut items: Vec<P<Item>> = starting_items;\n-        let attrs_remaining_len = attrs_remaining.len();\n+        // Parse all of the items up to closing or an attribute.\n+\n+        let mut attrs = first_item_attrs;\n+        attrs.push_all(&self.parse_outer_attributes()[]);\n+        let mut items = vec![];\n+\n+        loop {\n+            match self.parse_item_(attrs, true) {\n+                Err(returned_attrs) => {\n+                    attrs = returned_attrs;\n+                    break\n+                }\n+                Ok(item) => {\n+                    attrs = self.parse_outer_attributes();\n+                    items.push(item)\n+                }\n+            }\n+        }\n \n         // don't think this other loop is even necessary....\n \n-        let mut first = true;\n         while self.token != term {\n-            let mut attrs = self.parse_outer_attributes();\n-            if first {\n-                let mut tmp = attrs_remaining.clone();\n-                tmp.push_all(&attrs[]);\n-                attrs = tmp;\n-                first = false;\n-            }\n-            debug!(\"parse_mod_items: parse_item_or_view_item(attrs={:?})\",\n-                   attrs);\n-            match self.parse_item_or_view_item(attrs,\n-                                               true /* macros allowed */) {\n-              IoviItem(item) => items.push(item),\n-              IoviViewItem(view_item) => {\n-                self.span_fatal(view_item.span,\n-                                \"view items must be declared at the top of \\\n-                                 the module\");\n-              }\n-              _ => {\n+            let mut attrs = mem::replace(&mut attrs, vec![]);\n+            attrs.push_all(&self.parse_outer_attributes()[]);\n+            debug!(\"parse_mod_items: parse_item_(attrs={:?})\", attrs);\n+            match self.parse_item_(attrs, true /* macros allowed */) {\n+              Ok(item) => items.push(item),\n+              Err(_) => {\n                   let token_str = self.this_token_to_string();\n                   self.fatal(&format!(\"expected item, found `{}`\",\n                                      token_str)[])\n               }\n             }\n         }\n \n-        if first && attrs_remaining_len > 0us {\n+        if !attrs.is_empty() {\n             // We parsed attributes for the first item but didn't find it\n             let last_span = self.last_span;\n             self.span_err(last_span,\n-                          Parser::expected_item_err(&attrs_remaining[]));\n+                          Parser::expected_item_err(&attrs[]));\n         }\n \n         ast::Mod {\n             inner: mk_sp(inner_lo, self.span.lo),\n-            view_items: view_items,\n             items: items\n         }\n     }\n@@ -5298,23 +5237,12 @@ impl<'a> Parser<'a> {\n     /// parse_foreign_items.\n     fn parse_foreign_mod_items(&mut self,\n                                abi: abi::Abi,\n-                               first_item_attrs: Vec<Attribute> )\n+                               first_item_attrs: Vec<Attribute>)\n                                -> ForeignMod {\n-        let ParsedItemsAndViewItems {\n-            attrs_remaining,\n-            view_items,\n-            items: _,\n-            foreign_items,\n-        } = self.parse_foreign_items(first_item_attrs, true);\n-        if !attrs_remaining.is_empty() {\n-            let last_span = self.last_span;\n-            self.span_err(last_span,\n-                          Parser::expected_item_err(&attrs_remaining[]));\n-        }\n+        let foreign_items = self.parse_foreign_items(first_item_attrs);\n         assert!(self.token == token::CloseDelim(token::Brace));\n         ast::ForeignMod {\n             abi: abi,\n-            view_items: view_items,\n             items: foreign_items\n         }\n     }\n@@ -5329,8 +5257,8 @@ impl<'a> Parser<'a> {\n     fn parse_item_extern_crate(&mut self,\n                                 lo: BytePos,\n                                 visibility: Visibility,\n-                                attrs: Vec<Attribute> )\n-                                -> ItemOrViewItem {\n+                                attrs: Vec<Attribute>)\n+                                -> P<Item> {\n \n         let span = self.span;\n         let (maybe_path, ident) = match self.token {\n@@ -5374,12 +5302,13 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        IoviViewItem(ast::ViewItem {\n-                node: ViewItemExternCrate(ident, maybe_path, ast::DUMMY_NODE_ID),\n-                attrs: attrs,\n-                vis: visibility,\n-                span: mk_sp(lo, self.last_span.hi)\n-            })\n+        let last_span = self.last_span;\n+        self.mk_item(lo,\n+                     last_span.hi,\n+                     ident,\n+                     ItemExternCrate(maybe_path),\n+                     visibility,\n+                     attrs)\n     }\n \n     /// Parse `extern` for foreign ABIs\n@@ -5396,8 +5325,8 @@ impl<'a> Parser<'a> {\n                               lo: BytePos,\n                               opt_abi: Option<abi::Abi>,\n                               visibility: Visibility,\n-                              attrs: Vec<Attribute> )\n-                              -> ItemOrViewItem {\n+                              attrs: Vec<Attribute>)\n+                              -> P<Item> {\n \n         self.expect(&token::OpenDelim(token::Brace));\n \n@@ -5408,13 +5337,12 @@ impl<'a> Parser<'a> {\n         self.expect(&token::CloseDelim(token::Brace));\n \n         let last_span = self.last_span;\n-        let item = self.mk_item(lo,\n-                                last_span.hi,\n-                                special_idents::invalid,\n-                                ItemForeignMod(m),\n-                                visibility,\n-                                maybe_append(attrs, Some(inner)));\n-        return IoviItem(item);\n+        self.mk_item(lo,\n+                     last_span.hi,\n+                     special_idents::invalid,\n+                     ItemForeignMod(m),\n+                     visibility,\n+                     maybe_append(attrs, Some(inner)))\n     }\n \n     /// Parse type Foo = Bar;\n@@ -5556,14 +5484,12 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse one of the items or view items allowed by the\n-    /// flags; on failure, return IoviNone.\n+    /// Parse one of the items allowed by the flags; on failure,\n+    /// return `Err(remaining_attrs)`.\n     /// NB: this function no longer parses the items inside an\n     /// extern crate.\n-    fn parse_item_or_view_item(&mut self,\n-                               attrs: Vec<Attribute> ,\n-                               macros_allowed: bool)\n-                               -> ItemOrViewItem {\n+    fn parse_item_(&mut self, attrs: Vec<Attribute>,\n+                   macros_allowed: bool) -> MaybeItem {\n         let nt_item = match self.token {\n             token::Interpolated(token::NtItem(ref item)) => {\n                 Some((**item).clone())\n@@ -5576,7 +5502,7 @@ impl<'a> Parser<'a> {\n                 let mut attrs = attrs;\n                 mem::swap(&mut item.attrs, &mut attrs);\n                 item.attrs.extend(attrs.into_iter());\n-                return IoviItem(P(item));\n+                return Ok(P(item));\n             }\n             None => {}\n         }\n@@ -5585,22 +5511,24 @@ impl<'a> Parser<'a> {\n \n         let visibility = self.parse_visibility();\n \n-        // must be a view item:\n         if self.eat_keyword(keywords::Use) {\n-            // USE ITEM (IoviViewItem)\n-            let view_item = self.parse_use();\n+            // USE ITEM\n+            let item_ = ItemUse(self.parse_view_path());\n             self.expect(&token::Semi);\n-            return IoviViewItem(ast::ViewItem {\n-                node: view_item,\n-                attrs: attrs,\n-                vis: visibility,\n-                span: mk_sp(lo, self.last_span.hi)\n-            });\n+\n+            let last_span = self.last_span;\n+            let item = self.mk_item(lo,\n+                                    last_span.hi,\n+                                    token::special_idents::invalid,\n+                                    item_,\n+                                    visibility,\n+                                    attrs);\n+            return Ok(item);\n         }\n-        // either a view item or an item:\n+\n         if self.eat_keyword(keywords::Extern) {\n             if self.eat_keyword(keywords::Crate) {\n-                return self.parse_item_extern_crate(lo, visibility, attrs);\n+                return Ok(self.parse_item_extern_crate(lo, visibility, attrs));\n             }\n \n             let opt_abi = self.parse_opt_abi();\n@@ -5617,9 +5545,9 @@ impl<'a> Parser<'a> {\n                                         item_,\n                                         visibility,\n                                         maybe_append(attrs, extra_attrs));\n-                return IoviItem(item);\n+                return Ok(item);\n             } else if self.check(&token::OpenDelim(token::Brace)) {\n-                return self.parse_item_foreign_mod(lo, opt_abi, visibility, attrs);\n+                return Ok(self.parse_item_foreign_mod(lo, opt_abi, visibility, attrs));\n             }\n \n             let span = self.span;\n@@ -5634,7 +5562,6 @@ impl<'a> Parser<'a> {\n             self.span_err(span, \"`virtual` structs have been removed from the language\");\n         }\n \n-        // the rest are all guaranteed to be items:\n         if self.token.is_keyword(keywords::Static) {\n             // STATIC ITEM\n             self.bump();\n@@ -5647,7 +5574,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.token.is_keyword(keywords::Const) {\n             // CONST ITEM\n@@ -5665,7 +5592,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.token.is_keyword(keywords::Unsafe) &&\n             self.look_ahead(1us, |t| t.is_keyword(keywords::Trait))\n@@ -5682,7 +5609,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.token.is_keyword(keywords::Unsafe) &&\n             self.look_ahead(1us, |t| t.is_keyword(keywords::Impl))\n@@ -5698,7 +5625,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.token.is_keyword(keywords::Fn) {\n             // FUNCTION ITEM\n@@ -5712,7 +5639,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.token.is_keyword(keywords::Unsafe)\n             && self.look_ahead(1us, |t| *t != token::OpenDelim(token::Brace)) {\n@@ -5733,7 +5660,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.eat_keyword(keywords::Mod) {\n             // MODULE ITEM\n@@ -5746,7 +5673,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.eat_keyword(keywords::Type) {\n             // TYPE ITEM\n@@ -5758,7 +5685,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.eat_keyword(keywords::Enum) {\n             // ENUM ITEM\n@@ -5770,7 +5697,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.eat_keyword(keywords::Trait) {\n             // TRAIT ITEM\n@@ -5783,7 +5710,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.eat_keyword(keywords::Impl) {\n             // IMPL ITEM\n@@ -5795,7 +5722,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         if self.eat_keyword(keywords::Struct) {\n             // STRUCT ITEM\n@@ -5807,32 +5734,30 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n         self.parse_macro_use_or_failure(attrs,macros_allowed,lo,visibility)\n     }\n \n-    /// Parse a foreign item; on failure, return IoviNone.\n-    fn parse_foreign_item(&mut self,\n-                          attrs: Vec<Attribute> ,\n-                          macros_allowed: bool)\n-                          -> ItemOrViewItem {\n-        maybe_whole!(iovi self, NtItem);\n+    /// Parse a foreign item; on failure, return `Err(remaining_attrs)`.\n+    fn parse_foreign_item(&mut self, attrs: Vec<Attribute>)\n+                          -> Result<P<ForeignItem>, Vec<Attribute>> {\n         let lo = self.span.lo;\n \n         let visibility = self.parse_visibility();\n \n         if self.token.is_keyword(keywords::Static) {\n             // FOREIGN STATIC ITEM\n-            let item = self.parse_item_foreign_static(visibility, attrs);\n-            return IoviForeignItem(item);\n+            return Ok(self.parse_item_foreign_static(visibility, attrs));\n         }\n         if self.token.is_keyword(keywords::Fn) || self.token.is_keyword(keywords::Unsafe) {\n             // FOREIGN FUNCTION ITEM\n-            let item = self.parse_item_foreign_fn(visibility, attrs);\n-            return IoviForeignItem(item);\n+            return Ok(self.parse_item_foreign_fn(visibility, attrs));\n         }\n-        self.parse_macro_use_or_failure(attrs,macros_allowed,lo,visibility)\n+\n+        // FIXME #5668: this will occur for a macro invocation:\n+        let item = try!(self.parse_macro_use_or_failure(attrs, true, lo, visibility));\n+        self.span_fatal(item.span, \"macros cannot expand to foreign items\");\n     }\n \n     /// This is the fall-through for parsing items.\n@@ -5842,7 +5767,7 @@ impl<'a> Parser<'a> {\n         macros_allowed: bool,\n         lo: BytePos,\n         visibility: Visibility\n-    ) -> ItemOrViewItem {\n+    ) -> MaybeItem {\n         if macros_allowed && !self.token.is_any_keyword()\n                 && self.look_ahead(1, |t| *t == token::Not)\n                 && (self.look_ahead(2, |t| t.is_plain_ident())\n@@ -5891,7 +5816,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     attrs);\n-            return IoviItem(item);\n+            return Ok(item);\n         }\n \n         // FAILURE TO PARSE ITEM\n@@ -5902,7 +5827,7 @@ impl<'a> Parser<'a> {\n                 self.span_fatal(last_span, \"unmatched visibility `pub`\");\n             }\n         }\n-        return IoviNone(attrs);\n+        Err(attrs)\n     }\n \n     pub fn parse_item_with_outer_attributes(&mut self) -> Option<P<Item>> {\n@@ -5911,30 +5836,9 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_item(&mut self, attrs: Vec<Attribute>) -> Option<P<Item>> {\n-        match self.parse_item_or_view_item(attrs, true) {\n-            IoviNone(_) => None,\n-            IoviViewItem(_) =>\n-                self.fatal(\"view items are not allowed here\"),\n-            IoviForeignItem(_) =>\n-                self.fatal(\"foreign items are not allowed here\"),\n-            IoviItem(item) => Some(item)\n-        }\n+        self.parse_item_(attrs, true).ok()\n     }\n \n-    /// Parse a ViewItem, e.g. `use foo::bar` or `extern crate foo`\n-    pub fn parse_view_item(&mut self, attrs: Vec<Attribute>) -> ViewItem {\n-        match self.parse_item_or_view_item(attrs, false) {\n-            IoviViewItem(vi) => vi,\n-            _ => self.fatal(\"expected `use` or `extern crate`\"),\n-        }\n-    }\n-\n-    /// Parse, e.g., \"use a::b::{z,y}\"\n-    fn parse_use(&mut self) -> ViewItem_ {\n-        return ViewItemUse(self.parse_view_path());\n-    }\n-\n-\n     /// Matches view_path : MOD? non_global_path as IDENT\n     /// | MOD? non_global_path MOD_SEP LBRACE RBRACE\n     /// | MOD? non_global_path MOD_SEP LBRACE ident_seq RBRACE\n@@ -5959,8 +5863,7 @@ impl<'a> Parser<'a> {\n                 global: false,\n                 segments: Vec::new()\n             };\n-            return P(spanned(lo, self.span.hi,\n-                             ViewPathList(path, idents, ast::DUMMY_NODE_ID)));\n+            return P(spanned(lo, self.span.hi, ViewPathList(path, idents)));\n         }\n \n         let first_ident = self.parse_ident();\n@@ -5994,8 +5897,7 @@ impl<'a> Parser<'a> {\n                             }\n                         }).collect()\n                     };\n-                    return P(spanned(lo, self.span.hi,\n-                                     ViewPathList(path, idents, ast::DUMMY_NODE_ID)));\n+                    return P(spanned(lo, self.span.hi, ViewPathList(path, idents)));\n                   }\n \n                   // foo::bar::*\n@@ -6011,8 +5913,7 @@ impl<'a> Parser<'a> {\n                             }\n                         }).collect()\n                     };\n-                    return P(spanned(lo, self.span.hi,\n-                                     ViewPathGlob(path, ast::DUMMY_NODE_ID)));\n+                    return P(spanned(lo, self.span.hi, ViewPathGlob(path)));\n                   }\n \n                   _ => break\n@@ -6033,136 +5934,39 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::As) {\n             rename_to = self.parse_ident()\n         }\n-        P(spanned(lo,\n-                  self.last_span.hi,\n-                  ViewPathSimple(rename_to, path, ast::DUMMY_NODE_ID)))\n-    }\n-\n-    /// Parses a sequence of items. Stops when it finds program\n-    /// text that can't be parsed as an item\n-    /// - mod_items uses extern_mod_allowed = true\n-    /// - block_tail_ uses extern_mod_allowed = false\n-    fn parse_items_and_view_items(&mut self,\n-                                  first_item_attrs: Vec<Attribute> ,\n-                                  mut extern_mod_allowed: bool,\n-                                  macros_allowed: bool)\n-                                  -> ParsedItemsAndViewItems {\n-        let mut attrs = first_item_attrs;\n-        attrs.push_all(&self.parse_outer_attributes()[]);\n-        // First, parse view items.\n-        let mut view_items : Vec<ast::ViewItem> = Vec::new();\n-        let mut items = Vec::new();\n-\n-        // I think this code would probably read better as a single\n-        // loop with a mutable three-state-variable (for extern crates,\n-        // view items, and regular items) ... except that because\n-        // of macros, I'd like to delay that entire check until later.\n-        loop {\n-            match self.parse_item_or_view_item(attrs, macros_allowed) {\n-                IoviNone(attrs) => {\n-                    return ParsedItemsAndViewItems {\n-                        attrs_remaining: attrs,\n-                        view_items: view_items,\n-                        items: items,\n-                        foreign_items: Vec::new()\n-                    }\n-                }\n-                IoviViewItem(view_item) => {\n-                    match view_item.node {\n-                        ViewItemUse(..) => {\n-                            // `extern crate` must precede `use`.\n-                            extern_mod_allowed = false;\n-                        }\n-                        ViewItemExternCrate(..) if !extern_mod_allowed => {\n-                            self.span_err(view_item.span,\n-                                          \"\\\"extern crate\\\" declarations are \\\n-                                           not allowed here\");\n-                        }\n-                        ViewItemExternCrate(..) => {}\n-                    }\n-                    view_items.push(view_item);\n-                }\n-                IoviItem(item) => {\n-                    items.push(item);\n-                    attrs = self.parse_outer_attributes();\n-                    break;\n-                }\n-                IoviForeignItem(_) => {\n-                    panic!();\n-                }\n-            }\n-            attrs = self.parse_outer_attributes();\n-        }\n-\n-        // Next, parse items.\n-        loop {\n-            match self.parse_item_or_view_item(attrs, macros_allowed) {\n-                IoviNone(returned_attrs) => {\n-                    attrs = returned_attrs;\n-                    break\n-                }\n-                IoviViewItem(view_item) => {\n-                    attrs = self.parse_outer_attributes();\n-                    self.span_err(view_item.span,\n-                                  \"`use` and `extern crate` declarations must precede items\");\n-                }\n-                IoviItem(item) => {\n-                    attrs = self.parse_outer_attributes();\n-                    items.push(item)\n-                }\n-                IoviForeignItem(_) => {\n-                    panic!();\n-                }\n-            }\n-        }\n-\n-        ParsedItemsAndViewItems {\n-            attrs_remaining: attrs,\n-            view_items: view_items,\n-            items: items,\n-            foreign_items: Vec::new()\n-        }\n+        P(spanned(lo, self.last_span.hi, ViewPathSimple(rename_to, path)))\n     }\n \n     /// Parses a sequence of foreign items. Stops when it finds program\n     /// text that can't be parsed as an item\n-    fn parse_foreign_items(&mut self, first_item_attrs: Vec<Attribute> ,\n-                           macros_allowed: bool)\n-        -> ParsedItemsAndViewItems {\n+    fn parse_foreign_items(&mut self, first_item_attrs: Vec<Attribute>)\n+                           -> Vec<P<ForeignItem>> {\n         let mut attrs = first_item_attrs;\n         attrs.push_all(&self.parse_outer_attributes()[]);\n         let mut foreign_items = Vec::new();\n         loop {\n-            match self.parse_foreign_item(attrs, macros_allowed) {\n-                IoviNone(returned_attrs) => {\n+            match self.parse_foreign_item(attrs) {\n+                Ok(foreign_item) => {\n+                    foreign_items.push(foreign_item);\n+                }\n+                Err(returned_attrs) => {\n                     if self.check(&token::CloseDelim(token::Brace)) {\n                         attrs = returned_attrs;\n                         break\n                     }\n                     self.unexpected();\n-                },\n-                IoviViewItem(view_item) => {\n-                    // I think this can't occur:\n-                    self.span_err(view_item.span,\n-                                  \"`use` and `extern crate` declarations must precede items\");\n-                }\n-                IoviItem(item) => {\n-                    // FIXME #5668: this will occur for a macro invocation:\n-                    self.span_fatal(item.span, \"macros cannot expand to foreign items\");\n-                }\n-                IoviForeignItem(foreign_item) => {\n-                    foreign_items.push(foreign_item);\n                 }\n             }\n             attrs = self.parse_outer_attributes();\n         }\n \n-        ParsedItemsAndViewItems {\n-            attrs_remaining: attrs,\n-            view_items: Vec::new(),\n-            items: Vec::new(),\n-            foreign_items: foreign_items\n+        if !attrs.is_empty() {\n+            let last_span = self.last_span;\n+            self.span_err(last_span,\n+                          Parser::expected_item_err(&attrs[]));\n         }\n+\n+        foreign_items\n     }\n \n     /// Parses a source module as a crate. This is the main"}, {"sha": "42f156d6a112daa4be2ce5972520ee2d8ffcece1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 25, "deletions": 43, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -337,10 +337,6 @@ pub fn item_to_string(i: &ast::Item) -> String {\n     $to_string(|s| s.print_item(i))\n }\n \n-pub fn view_item_to_string(i: &ast::ViewItem) -> String {\n-    $to_string(|s| s.print_view_item(i))\n-}\n-\n pub fn generics_to_string(generics: &ast::Generics) -> String {\n     $to_string(|s| s.print_generics(generics))\n }\n@@ -638,9 +634,6 @@ impl<'a> State<'a> {\n     pub fn print_mod(&mut self, _mod: &ast::Mod,\n                      attrs: &[ast::Attribute]) -> IoResult<()> {\n         try!(self.print_inner_attributes(attrs));\n-        for vitem in _mod.view_items.iter() {\n-            try!(self.print_view_item(vitem));\n-        }\n         for item in _mod.items.iter() {\n             try!(self.print_item(&**item));\n         }\n@@ -650,9 +643,6 @@ impl<'a> State<'a> {\n     pub fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod,\n                              attrs: &[ast::Attribute]) -> IoResult<()> {\n         try!(self.print_inner_attributes(attrs));\n-        for vitem in nmod.view_items.iter() {\n-            try!(self.print_view_item(vitem));\n-        }\n         for item in nmod.items.iter() {\n             try!(self.print_foreign_item(&**item));\n         }\n@@ -809,6 +799,28 @@ impl<'a> State<'a> {\n         try!(self.print_outer_attributes(&item.attrs[]));\n         try!(self.ann.pre(self, NodeItem(item)));\n         match item.node {\n+            ast::ItemExternCrate(ref optional_path) => {\n+                try!(self.head(&visibility_qualified(item.vis,\n+                                                     \"extern crate\")[]));\n+                for &(ref p, style) in optional_path.iter() {\n+                    try!(self.print_string(p.get(), style));\n+                    try!(space(&mut self.s));\n+                    try!(word(&mut self.s, \"as\"));\n+                    try!(space(&mut self.s));\n+                }\n+                try!(self.print_ident(item.ident));\n+                try!(word(&mut self.s, \";\"));\n+                try!(self.end()); // end inner head-block\n+                try!(self.end()); // end outer head-block\n+            }\n+            ast::ItemUse(ref vp) => {\n+                try!(self.head(&visibility_qualified(item.vis,\n+                                                     \"use\")[]));\n+                try!(self.print_view_path(&**vp));\n+                try!(word(&mut self.s, \";\"));\n+                try!(self.end()); // end inner head-block\n+                try!(self.end()); // end outer head-block\n+            }\n             ast::ItemStatic(ref ty, m, ref expr) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                     \"static\")[]));\n@@ -1380,9 +1392,6 @@ impl<'a> State<'a> {\n \n         try!(self.print_inner_attributes(attrs));\n \n-        for vi in blk.view_items.iter() {\n-            try!(self.print_view_item(vi));\n-        }\n         for st in blk.stmts.iter() {\n             try!(self.print_stmt(&**st));\n         }\n@@ -2577,7 +2586,7 @@ impl<'a> State<'a> {\n \n     pub fn print_view_path(&mut self, vp: &ast::ViewPath) -> IoResult<()> {\n         match vp.node {\n-            ast::ViewPathSimple(ident, ref path, _) => {\n+            ast::ViewPathSimple(ident, ref path) => {\n                 try!(self.print_path(path, false));\n \n                 // FIXME(#6993) can't compare identifiers directly here\n@@ -2591,12 +2600,12 @@ impl<'a> State<'a> {\n                 Ok(())\n             }\n \n-            ast::ViewPathGlob(ref path, _) => {\n+            ast::ViewPathGlob(ref path) => {\n                 try!(self.print_path(path, false));\n                 word(&mut self.s, \"::*\")\n             }\n \n-            ast::ViewPathList(ref path, ref idents, _) => {\n+            ast::ViewPathList(ref path, ref idents) => {\n                 if path.segments.is_empty() {\n                     try!(word(&mut self.s, \"{\"));\n                 } else {\n@@ -2618,33 +2627,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_view_item(&mut self, item: &ast::ViewItem) -> IoResult<()> {\n-        try!(self.hardbreak_if_not_bol());\n-        try!(self.maybe_print_comment(item.span.lo));\n-        try!(self.print_outer_attributes(&item.attrs[]));\n-        try!(self.print_visibility(item.vis));\n-        match item.node {\n-            ast::ViewItemExternCrate(id, ref optional_path, _) => {\n-                try!(self.head(\"extern crate\"));\n-                for &(ref p, style) in optional_path.iter() {\n-                    try!(self.print_string(p.get(), style));\n-                    try!(space(&mut self.s));\n-                    try!(word(&mut self.s, \"as\"));\n-                    try!(space(&mut self.s));\n-                }\n-                try!(self.print_ident(id));\n-            }\n-\n-            ast::ViewItemUse(ref vp) => {\n-                try!(self.head(\"use\"));\n-                try!(self.print_view_path(&**vp));\n-            }\n-        }\n-        try!(word(&mut self.s, \";\"));\n-        try!(self.end()); // end inner head-block\n-        self.end() // end outer head-block\n-    }\n-\n     pub fn print_mutability(&mut self,\n                             mutbl: ast::Mutability) -> IoResult<()> {\n         match mutbl {"}, {"sha": "d75fbcf199dbe1d8b187dedf6ff4896ea08f4cb9", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 14, "deletions": 32, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -20,8 +20,6 @@ use parse::token;\n use ptr::P;\n use util::small_vector::SmallVector;\n \n-use std::mem;\n-\n pub fn maybe_inject_crates_ref(krate: ast::Crate, alt_std_name: Option<String>)\n                                -> ast::Crate {\n     if use_std(&krate) {\n@@ -60,20 +58,16 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n             None => token::intern_and_get_ident(\"std\"),\n         };\n \n-        let mut vis = vec!(ast::ViewItem {\n-            node: ast::ViewItemExternCrate(token::str_to_ident(\"std\"),\n-                                           Some((actual_crate_name, ast::CookedStr)),\n-                                           ast::DUMMY_NODE_ID),\n+        krate.module.items.insert(0, P(ast::Item {\n+            id: ast::DUMMY_NODE_ID,\n+            ident: token::str_to_ident(\"std\"),\n             attrs: vec!(\n                 attr::mk_attr_outer(attr::mk_attr_id(), attr::mk_word_item(\n                         InternedString::new(\"macro_use\")))),\n+            node: ast::ItemExternCrate(Some((actual_crate_name, ast::CookedStr))),\n             vis: ast::Inherited,\n             span: DUMMY_SP\n-        });\n-\n-        // `extern crate` must be precede `use` items\n-        mem::swap(&mut vis, &mut krate.module.view_items);\n-        krate.module.view_items.extend(vis.into_iter());\n+        }));\n \n         // don't add #![no_std] here, that will block the prelude injection later.\n         // Add it during the prelude injection instead.\n@@ -123,7 +117,7 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n         }\n     }\n \n-    fn fold_mod(&mut self, ast::Mod {inner, view_items, items}: ast::Mod) -> ast::Mod {\n+    fn fold_mod(&mut self, mut mod_: ast::Mod) -> ast::Mod {\n         let prelude_path = ast::Path {\n             span: DUMMY_SP,\n             global: false,\n@@ -143,18 +137,11 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n             ],\n         };\n \n-        let (crates, uses): (Vec<_>, _) = view_items.iter().cloned().partition(|x| {\n-            match x.node {\n-                ast::ViewItemExternCrate(..) => true,\n-                _ => false,\n-            }\n-        });\n-\n-        // add prelude after any `extern crate` but before any `use`\n-        let mut view_items = crates;\n-        let vp = P(codemap::dummy_spanned(ast::ViewPathGlob(prelude_path, ast::DUMMY_NODE_ID)));\n-        view_items.push(ast::ViewItem {\n-            node: ast::ViewItemUse(vp),\n+        let vp = P(codemap::dummy_spanned(ast::ViewPathGlob(prelude_path)));\n+        mod_.items.insert(0, P(ast::Item {\n+            id: ast::DUMMY_NODE_ID,\n+            ident: special_idents::invalid,\n+            node: ast::ItemUse(vp),\n             attrs: vec![ast::Attribute {\n                 span: DUMMY_SP,\n                 node: ast::Attribute_ {\n@@ -170,14 +157,9 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n             }],\n             vis: ast::Inherited,\n             span: DUMMY_SP,\n-        });\n-        view_items.extend(uses.into_iter());\n-\n-        fold::noop_fold_mod(ast::Mod {\n-            inner: inner,\n-            view_items: view_items,\n-            items: items\n-        }, self)\n+        }));\n+\n+        fold::noop_fold_mod(mod_, self)\n     }\n }\n "}, {"sha": "e5d8e4e5143a778a665b8a603fce4af62b6cb24e", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -105,11 +105,11 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         // Add a special __test module to the crate that will contain code\n         // generated for the test harness\n         let (mod_, reexport) = mk_test_module(&mut self.cx);\n-        folded.module.items.push(mod_);\n         match reexport {\n-            Some(re) => folded.module.view_items.push(re),\n+            Some(re) => folded.module.items.push(re),\n             None => {}\n         }\n+        folded.module.items.push(mod_);\n         folded\n     }\n \n@@ -205,22 +205,19 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n \n fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,\n                    tested_submods: Vec<(ast::Ident, ast::Ident)>) -> (P<ast::Item>, ast::Ident) {\n-    let mut view_items = Vec::new();\n     let super_ = token::str_to_ident(\"super\");\n \n-    view_items.extend(tests.into_iter().map(|r| {\n-        cx.ext_cx.view_use_simple(DUMMY_SP, ast::Public,\n+    let items = tests.into_iter().map(|r| {\n+        cx.ext_cx.item_use_simple(DUMMY_SP, ast::Public,\n                                   cx.ext_cx.path(DUMMY_SP, vec![super_, r]))\n-    }));\n-    view_items.extend(tested_submods.into_iter().map(|(r, sym)| {\n+    }).chain(tested_submods.into_iter().map(|(r, sym)| {\n         let path = cx.ext_cx.path(DUMMY_SP, vec![super_, r, sym]);\n-        cx.ext_cx.view_use_simple_(DUMMY_SP, ast::Public, r, path)\n+        cx.ext_cx.item_use_simple_(DUMMY_SP, ast::Public, r, path)\n     }));\n \n     let reexport_mod = ast::Mod {\n         inner: DUMMY_SP,\n-        view_items: view_items,\n-        items: Vec::new(),\n+        items: items.collect(),\n     };\n \n     let sym = token::gensym_ident(\"__test_reexports\");\n@@ -388,29 +385,29 @@ mod __test {\n \n */\n \n-fn mk_std(cx: &TestCtxt) -> ast::ViewItem {\n+fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n     let id_test = token::str_to_ident(\"test\");\n-    let (vi, vis) = if cx.is_test_crate {\n-        (ast::ViewItemUse(\n+    let (vi, vis, ident) = if cx.is_test_crate {\n+        (ast::ItemUse(\n             P(nospan(ast::ViewPathSimple(id_test,\n-                                         path_node(vec!(id_test)),\n-                                         ast::DUMMY_NODE_ID)))),\n-         ast::Public)\n+                                         path_node(vec!(id_test)))))),\n+         ast::Public, token::special_idents::invalid)\n     } else {\n-        (ast::ViewItemExternCrate(id_test, None, ast::DUMMY_NODE_ID),\n-         ast::Inherited)\n+        (ast::ItemExternCrate(None), ast::Inherited, id_test)\n     };\n-    ast::ViewItem {\n+    P(ast::Item {\n+        id: ast::DUMMY_NODE_ID,\n+        ident: ident,\n         node: vi,\n-        attrs: Vec::new(),\n+        attrs: vec![],\n         vis: vis,\n         span: DUMMY_SP\n-    }\n+    })\n }\n \n-fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<ast::ViewItem>) {\n+fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n     // Link to test crate\n-    let view_items = vec!(mk_std(cx));\n+    let import = mk_std(cx);\n \n     // A constant vector of test descriptors.\n     let tests = mk_tests(cx);\n@@ -427,8 +424,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<ast::ViewItem>) {\n \n     let testmod = ast::Mod {\n         inner: DUMMY_SP,\n-        view_items: view_items,\n-        items: vec!(mainfn, tests),\n+        items: vec![import, mainfn, tests],\n     };\n     let item_ = ast::ItemMod(testmod);\n \n@@ -439,34 +435,35 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<ast::ViewItem>) {\n                                            vec![unstable])));\n         attr::mk_attr_inner(attr::mk_attr_id(), allow)\n     };\n-    let item = ast::Item {\n-        ident: mod_ident,\n+    let item = P(ast::Item {\n         id: ast::DUMMY_NODE_ID,\n+        ident: mod_ident,\n+        attrs: vec![allow_unstable],\n         node: item_,\n         vis: ast::Public,\n         span: DUMMY_SP,\n-        attrs: vec![allow_unstable],\n-    };\n+    });\n     let reexport = cx.reexport_test_harness_main.as_ref().map(|s| {\n         // building `use <ident> = __test::main`\n         let reexport_ident = token::str_to_ident(s.get());\n \n         let use_path =\n             nospan(ast::ViewPathSimple(reexport_ident,\n-                                       path_node(vec![mod_ident, token::str_to_ident(\"main\")]),\n-                                       ast::DUMMY_NODE_ID));\n+                                       path_node(vec![mod_ident, token::str_to_ident(\"main\")])));\n \n-        ast::ViewItem {\n-            node: ast::ViewItemUse(P(use_path)),\n+        P(ast::Item {\n+            id: ast::DUMMY_NODE_ID,\n+            ident: token::special_idents::invalid,\n             attrs: vec![],\n+            node: ast::ItemUse(P(use_path)),\n             vis: ast::Inherited,\n             span: DUMMY_SP\n-        }\n+        })\n     });\n \n-    debug!(\"Synthetic test module:\\n{}\\n\", pprust::item_to_string(&item));\n+    debug!(\"Synthetic test module:\\n{}\\n\", pprust::item_to_string(&*item));\n \n-    (P(item), reexport)\n+    (item, reexport)\n }\n \n fn nospan<T>(t: T) -> codemap::Spanned<T> {"}, {"sha": "89854f5d979a159218c93a60595dff55f145f34d", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -69,13 +69,6 @@ pub fn string_to_stmt(source_str : String) -> P<ast::Stmt> {\n     })\n }\n \n-/// Parse a string, return a view item\n-pub fn string_to_view_item (source_str : String) -> ast::ViewItem {\n-    with_error_checking_parse(source_str, |p| {\n-        p.parse_view_item(Vec::new())\n-    })\n-}\n-\n /// Parse a string, return a pat. Uses \"irrefutable\"... which doesn't\n /// (currently) affect parsing.\n pub fn string_to_pat(source_str: String) -> P<ast::Pat> {"}, {"sha": "eb906788aa7f4125da1e1fece56bae7a6608a554", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 26, "deletions": 47, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -62,7 +62,6 @@ pub trait Visitor<'v> : Sized {\n         self.visit_name(span, ident.name);\n     }\n     fn visit_mod(&mut self, m: &'v Mod, _s: Span, _n: NodeId) { walk_mod(self, m) }\n-    fn visit_view_item(&mut self, i: &'v ViewItem) { walk_view_item(self, i) }\n     fn visit_foreign_item(&mut self, i: &'v ForeignItem) { walk_foreign_item(self, i) }\n     fn visit_item(&mut self, i: &'v Item) { walk_item(self, i) }\n     fn visit_local(&mut self, l: &'v Local) { walk_local(self, l) }\n@@ -166,51 +165,11 @@ pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n }\n \n pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod) {\n-    for view_item in module.view_items.iter() {\n-        visitor.visit_view_item(view_item)\n-    }\n-\n     for item in module.items.iter() {\n         visitor.visit_item(&**item)\n     }\n }\n \n-pub fn walk_view_item<'v, V: Visitor<'v>>(visitor: &mut V, vi: &'v ViewItem) {\n-    match vi.node {\n-        ViewItemExternCrate(name, _, _) => {\n-            visitor.visit_ident(vi.span, name)\n-        }\n-        ViewItemUse(ref vp) => {\n-            match vp.node {\n-                ViewPathSimple(ident, ref path, id) => {\n-                    visitor.visit_ident(vp.span, ident);\n-                    visitor.visit_path(path, id);\n-                }\n-                ViewPathGlob(ref path, id) => {\n-                    visitor.visit_path(path, id);\n-                }\n-                ViewPathList(ref prefix, ref list, _) => {\n-                    for id in list.iter() {\n-                        match id.node {\n-                            PathListIdent { name, .. } => {\n-                                visitor.visit_ident(id.span, name);\n-                            }\n-                            PathListMod { .. } => ()\n-                        }\n-                    }\n-\n-                    // Note that the `prefix` here is not a complete\n-                    // path, so we don't use `visit_path`.\n-                    walk_path(visitor, prefix);\n-                }\n-            }\n-        }\n-    }\n-    for attr in vi.attrs.iter() {\n-        visitor.visit_attribute(attr);\n-    }\n-}\n-\n pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n     visitor.visit_pat(&*local.pat);\n     walk_ty_opt(visitor, &local.ty);\n@@ -269,6 +228,32 @@ pub fn walk_trait_ref<'v,V>(visitor: &mut V,\n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     visitor.visit_ident(item.span, item.ident);\n     match item.node {\n+        ItemExternCrate(..) => {}\n+        ItemUse(ref vp) => {\n+            match vp.node {\n+                ViewPathSimple(ident, ref path) => {\n+                    visitor.visit_ident(vp.span, ident);\n+                    visitor.visit_path(path, item.id);\n+                }\n+                ViewPathGlob(ref path) => {\n+                    visitor.visit_path(path, item.id);\n+                }\n+                ViewPathList(ref prefix, ref list) => {\n+                    for id in list.iter() {\n+                        match id.node {\n+                            PathListIdent { name, .. } => {\n+                                visitor.visit_ident(id.span, name);\n+                            }\n+                            PathListMod { .. } => ()\n+                        }\n+                    }\n+\n+                    // Note that the `prefix` here is not a complete\n+                    // path, so we don't use `visit_path`.\n+                    walk_path(visitor, prefix);\n+                }\n+            }\n+        }\n         ItemStatic(ref typ, _, ref expr) |\n         ItemConst(ref typ, ref expr) => {\n             visitor.visit_ty(&**typ);\n@@ -285,9 +270,6 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_mod(module, item.span, item.id)\n         }\n         ItemForeignMod(ref foreign_module) => {\n-            for view_item in foreign_module.view_items.iter() {\n-                visitor.visit_view_item(view_item)\n-            }\n             for foreign_item in foreign_module.items.iter() {\n                 visitor.visit_foreign_item(&**foreign_item)\n             }\n@@ -732,9 +714,6 @@ pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V,\n }\n \n pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block) {\n-    for view_item in block.view_items.iter() {\n-        visitor.visit_view_item(view_item)\n-    }\n     for statement in block.stmts.iter() {\n         visitor.visit_stmt(&**statement)\n     }"}, {"sha": "f129b4b77bb9fca5937b16de164527e36c6ef5c1", "filename": "src/test/auxiliary/blind-item-mixed-crate-use-item-foo.rs", "status": "renamed", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Fauxiliary%2Fblind-item-mixed-crate-use-item-foo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Fauxiliary%2Fblind-item-mixed-crate-use-item-foo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fblind-item-mixed-crate-use-item-foo.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub extern crate core; //~ ERROR: `pub` visibility is not allowed\n+#![crate_type=\"lib\"]\n \n-fn main() {\n-    pub use std::usize; //~ ERROR: imports in functions are never reachable\n-}\n+pub const X: () = ();", "previous_filename": "src/test/compile-fail/issue-9957.rs"}, {"sha": "91fa912455109d658c09344263de1903c4830f44", "filename": "src/test/auxiliary/blind-item-mixed-crate-use-item-foo2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Fauxiliary%2Fblind-item-mixed-crate-use-item-foo2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Fauxiliary%2Fblind-item-mixed-crate-use-item-foo2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fblind-item-mixed-crate-use-item-foo2.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type=\"lib\"]\n+\n+pub const Y: () = ();"}, {"sha": "be9e57e2d195001a4c94b6ce66c9438b2024c4fc", "filename": "src/test/compile-fail-fulldeps/gated-plugin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-plugin.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -11,8 +11,7 @@\n // aux-build:macro_crate_test.rs\n // ignore-stage1\n \n-#[plugin] #[no_link]\n+#[plugin] #[no_link] extern crate macro_crate_test;\n //~^ ERROR compiler plugins are experimental and possibly buggy\n-extern crate macro_crate_test;\n \n fn main() {}"}, {"sha": "d4adaa042b2b55212ef369161d326a308e97c5f8", "filename": "src/test/compile-fail/blind-item-block-item-shadow.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Fcompile-fail%2Fblind-item-block-item-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Fcompile-fail%2Fblind-item-block-item-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblind-item-block-item-shadow.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod foo { pub struct Bar; }\n+\n+fn main() {\n+    {\n+        struct Bar;\n+        use foo::Bar;\n+        //~^ ERROR import `Bar` conflicts with type in this module\n+        //~^^ ERROR import `Bar` conflicts with value in this module\n+    }\n+}"}, {"sha": "fbb0730f014617085816387c49f7e8b206eff558", "filename": "src/test/compile-fail/blind-item-block-middle.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Fcompile-fail%2Fblind-item-block-middle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Fcompile-fail%2Fblind-item-block-middle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblind-item-block-middle.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod foo { struct bar; }\n+\n+fn main() {\n+    let bar = 5;\n+    //~^ ERROR declaration of `bar` shadows an enum variant or unit-like struct in scope\n+    use foo::bar;\n+    //~^ ERROR imports are not allowed after non-item statements\n+}"}, {"sha": "9f21d6a9234089a049ae13e8f4a343e54b80821a", "filename": "src/test/compile-fail/blind-item-item-shadow.rs", "status": "renamed", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Fcompile-fail%2Fblind-item-item-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Fcompile-fail%2Fblind-item-item-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblind-item-item-shadow.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,12 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate test;\n+mod foo { pub mod foo {  } }\n \n-fn f() {\n-}\n+use foo::foo; //~ ERROR import `foo` conflicts with existing submodule\n \n-use test::net;    //~ ERROR `use` and `extern crate` declarations must precede items\n-\n-fn main() {\n-}\n+fn main() {}", "previous_filename": "src/test/compile-fail/view-items-at-top.rs"}, {"sha": "a28f5f6e557150b53d02d50c032fd00d4fe24ebc", "filename": "src/test/compile-fail/blind-item-local-shadow.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Fcompile-fail%2Fblind-item-local-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Fcompile-fail%2Fblind-item-local-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblind-item-local-shadow.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod bar {\n+    pub fn foo() -> bool { true }\n+}\n+\n+fn main() {\n+    let foo = |&:| false;\n+    use bar::foo;\n+    //~^ ERROR imports are not allowed after non-item statements\n+    assert_eq!(foo(), false);\n+}"}, {"sha": "e3707292f2495e979f7029539de36b622ac34e13", "filename": "src/test/compile-fail/unnecessary-private.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Fcompile-fail%2Funnecessary-private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Fcompile-fail%2Funnecessary-private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funnecessary-private.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -9,6 +9,7 @@\n // except according to those terms.\n \n fn main() {\n+    pub use std::uint; //~ ERROR: visibility has no effect\n     pub struct A; //~ ERROR: visibility has no effect\n     pub enum B {} //~ ERROR: visibility has no effect\n     pub trait C { //~ ERROR: visibility has no effect"}, {"sha": "c18d076c0d3181b5a47966658075bd9f4ba1b12c", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -1,8 +1,8 @@\n #![no_std]\n-#[macro_use]\n-extern crate \"std\" as std;\n #[prelude_import]\n use std::prelude::v1::*;\n+#[macro_use]\n+extern crate \"std\" as std;\n // Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT."}, {"sha": "80c73e5e60b53ffe8a77023e911942a3f4939c81", "filename": "src/test/run-pass/blind-item-mixed-crate-use-item.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Frun-pass%2Fblind-item-mixed-crate-use-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Frun-pass%2Fblind-item-mixed-crate-use-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblind-item-mixed-crate-use-item.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:blind-item-mixed-crate-use-item-foo.rs\n+// aux-build:blind-item-mixed-crate-use-item-foo2.rs\n+\n+mod m {\n+    pub fn f<T>(_: T, _: (), _: ()) { }\n+    pub fn g<T>(_: T, _: (), _: ()) { }\n+}\n+\n+const BAR: () = ();\n+struct Data;\n+use m::f;\n+extern crate \"blind-item-mixed-crate-use-item-foo\" as foo;\n+\n+fn main() {\n+    const BAR2: () = ();\n+    struct Data2;\n+    use m::g;\n+\n+    extern crate \"blind-item-mixed-crate-use-item-foo2\" as foo2;\n+\n+    f(Data, BAR, foo::X);\n+    g(Data2, BAR2, foo2::Y);\n+}"}, {"sha": "a3dad01acf17b6c6a3eeb2dec84a9ea1ee959fe2", "filename": "src/test/run-pass/blind-item-mixed-use-item.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Frun-pass%2Fblind-item-mixed-use-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df1cddf20a2a4ece854e5d8592ad3155a3313fd2/src%2Ftest%2Frun-pass%2Fblind-item-mixed-use-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblind-item-mixed-use-item.rs?ref=df1cddf20a2a4ece854e5d8592ad3155a3313fd2", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod m {\n+    pub fn f<T>(_: T, _: ()) { }\n+    pub fn g<T>(_: T, _: ()) { }\n+}\n+\n+const BAR: () = ();\n+struct Data;\n+use m::f;\n+\n+fn main() {\n+    const BAR2: () = ();\n+    struct Data2;\n+    use m::g;\n+\n+    f(Data, BAR);\n+    g(Data2, BAR2);\n+}"}]}