{"sha": "818934b9b418e16e6d60fb061e1e712f48c33216", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxODkzNGI5YjQxOGUxNmU2ZDYwZmIwNjFlMWU3MTJmNDhjMzMyMTY=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-03-05T23:32:06Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-03-06T00:45:45Z"}, "message": "Model generator resumption in dataflow\n\nWe now have a way to apply an effect only *after* a `yield` resumes,\nsimilar to calls (which can either return or unwind).", "tree": {"sha": "eb82d03b89dcd4a25c17cdca0b289722df63368e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb82d03b89dcd4a25c17cdca0b289722df63368e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/818934b9b418e16e6d60fb061e1e712f48c33216", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/818934b9b418e16e6d60fb061e1e712f48c33216", "html_url": "https://github.com/rust-lang/rust/commit/818934b9b418e16e6d60fb061e1e712f48c33216", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/818934b9b418e16e6d60fb061e1e712f48c33216/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2070ea26e1747f9cb1fb8266bbfe48d79a5ada87", "url": "https://api.github.com/repos/rust-lang/rust/commits/2070ea26e1747f9cb1fb8266bbfe48d79a5ada87", "html_url": "https://github.com/rust-lang/rust/commit/2070ea26e1747f9cb1fb8266bbfe48d79a5ada87"}], "stats": {"total": 119, "additions": 88, "deletions": 31}, "files": [{"sha": "170157aca5ddd678391efc9083286821b27898d8", "filename": "src/librustc_mir/dataflow/generic/cursor.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/818934b9b418e16e6d60fb061e1e712f48c33216/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/818934b9b418e16e6d60fb061e1e712f48c33216/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fcursor.rs?ref=818934b9b418e16e6d60fb061e1e712f48c33216", "patch": "@@ -2,7 +2,7 @@\n \n use std::borrow::Borrow;\n \n-use rustc::mir::{self, BasicBlock, Location};\n+use rustc::mir::{self, BasicBlock, Location, TerminatorKind};\n use rustc_index::bit_set::BitSet;\n \n use super::{Analysis, Results};\n@@ -29,14 +29,14 @@ where\n \n     pos: CursorPosition,\n \n-    /// When this flag is set, the cursor is pointing at a `Call` terminator whose call return\n-    /// effect has been applied to `state`.\n+    /// When this flag is set, the cursor is pointing at a `Call` or `Yield` terminator whose call\n+    /// return or resume effect has been applied to `state`.\n     ///\n-    /// This flag helps to ensure that multiple calls to `seek_after_assume_call_returns` with the\n+    /// This flag helps to ensure that multiple calls to `seek_after_assume_success` with the\n     /// same target will result in exactly one invocation of `apply_call_return_effect`. It is\n     /// sufficient to clear this only in `seek_to_block_start`, since seeking away from a\n     /// terminator will always require a cursor reset.\n-    call_return_effect_applied: bool,\n+    success_effect_applied: bool,\n }\n \n impl<'mir, 'tcx, A, R> ResultsCursor<'mir, 'tcx, A, R>\n@@ -50,7 +50,7 @@ where\n             body,\n             pos: CursorPosition::BlockStart(mir::START_BLOCK),\n             state: results.borrow().entry_sets[mir::START_BLOCK].clone(),\n-            call_return_effect_applied: false,\n+            success_effect_applied: false,\n             results,\n         }\n     }\n@@ -76,14 +76,14 @@ where\n     pub fn seek_to_block_start(&mut self, block: BasicBlock) {\n         self.state.overwrite(&self.results.borrow().entry_sets[block]);\n         self.pos = CursorPosition::BlockStart(block);\n-        self.call_return_effect_applied = false;\n+        self.success_effect_applied = false;\n     }\n \n     /// Advances the cursor to hold all effects up to and including to the \"before\" effect of the\n     /// statement (or terminator) at the given location.\n     ///\n     /// If you wish to observe the full effect of a statement or terminator, not just the \"before\"\n-    /// effect, use `seek_after` or `seek_after_assume_call_returns`.\n+    /// effect, use `seek_after` or `seek_after_assume_success`.\n     pub fn seek_before(&mut self, target: Location) {\n         assert!(target <= self.body.terminator_loc(target.block));\n         self.seek_(target, false);\n@@ -93,15 +93,15 @@ where\n     /// terminators) up to and including the `target`.\n     ///\n     /// If the `target` is a `Call` terminator, any call return effect for that terminator will\n-    /// **not** be observed. Use `seek_after_assume_call_returns` if you wish to observe the call\n+    /// **not** be observed. Use `seek_after_assume_success` if you wish to observe the call\n     /// return effect.\n     pub fn seek_after(&mut self, target: Location) {\n         assert!(target <= self.body.terminator_loc(target.block));\n \n         // If we have already applied the call return effect, we are currently pointing at a `Call`\n         // terminator. Unconditionally reset the dataflow cursor, since there is no way to \"undo\"\n         // the call return effect.\n-        if self.call_return_effect_applied {\n+        if self.success_effect_applied {\n             self.seek_to_block_start(target.block);\n         }\n \n@@ -111,25 +111,25 @@ where\n     /// Advances the cursor to hold all effects up to and including of the statement (or\n     /// terminator) at the given location.\n     ///\n-    /// If the `target` is a `Call` terminator, any call return effect for that terminator will\n-    /// be observed. Use `seek_after` if you do **not** wish to observe the call return effect.\n-    pub fn seek_after_assume_call_returns(&mut self, target: Location) {\n+    /// If the `target` is a `Call` or `Yield` terminator, any call return or resume effect for that\n+    /// terminator will be observed. Use `seek_after` if you do **not** wish to observe the\n+    /// \"success\" effect.\n+    pub fn seek_after_assume_success(&mut self, target: Location) {\n         let terminator_loc = self.body.terminator_loc(target.block);\n         assert!(target.statement_index <= terminator_loc.statement_index);\n \n         self.seek_(target, true);\n \n-        if target != terminator_loc {\n+        if target != terminator_loc || self.success_effect_applied {\n             return;\n         }\n \n+        // Apply the effect of the \"success\" path of the terminator.\n+\n+        self.success_effect_applied = true;\n         let terminator = self.body.basic_blocks()[target.block].terminator();\n-        if let mir::TerminatorKind::Call {\n-            destination: Some((return_place, _)), func, args, ..\n-        } = &terminator.kind\n-        {\n-            if !self.call_return_effect_applied {\n-                self.call_return_effect_applied = true;\n+        match &terminator.kind {\n+            TerminatorKind::Call { destination: Some((return_place, _)), func, args, .. } => {\n                 self.results.borrow().analysis.apply_call_return_effect(\n                     &mut self.state,\n                     target.block,\n@@ -138,6 +138,14 @@ where\n                     return_place,\n                 );\n             }\n+            TerminatorKind::Yield { resume, resume_arg, .. } => {\n+                self.results.borrow().analysis.apply_yield_resume_effect(\n+                    &mut self.state,\n+                    *resume,\n+                    resume_arg,\n+                );\n+            }\n+            _ => {}\n         }\n     }\n \n@@ -172,7 +180,7 @@ where\n                 self.seek_to_block_start(target.block)\n             }\n \n-            // N.B., `call_return_effect_applied` is checked in `seek_after`, not here.\n+            // N.B., `success_effect_applied` is checked in `seek_after`, not here.\n             _ => (),\n         }\n "}, {"sha": "606e7eb52b5dd8e702d3bbf8df6684d54fa72e6f", "filename": "src/librustc_mir/dataflow/generic/engine.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/818934b9b418e16e6d60fb061e1e712f48c33216/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/818934b9b418e16e6d60fb061e1e712f48c33216/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs?ref=818934b9b418e16e6d60fb061e1e712f48c33216", "patch": "@@ -218,15 +218,18 @@ where\n \n             Goto { target }\n             | Assert { target, cleanup: None, .. }\n-            | Yield { resume: target, drop: None, .. }\n             | Drop { target, location: _, unwind: None }\n             | DropAndReplace { target, value: _, location: _, unwind: None } => {\n                 self.propagate_bits_into_entry_set_for(in_out, target, dirty_list)\n             }\n \n-            Yield { resume: target, drop: Some(drop), .. } => {\n+            Yield { resume: target, drop, resume_arg, .. } => {\n+                if let Some(drop) = drop {\n+                    self.propagate_bits_into_entry_set_for(in_out, drop, dirty_list);\n+                }\n+\n+                self.analysis.apply_yield_resume_effect(in_out, target, &resume_arg);\n                 self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-                self.propagate_bits_into_entry_set_for(in_out, drop, dirty_list);\n             }\n \n             Assert { target, cleanup: Some(unwind), .. }"}, {"sha": "d2aeba3644a25c6d007aa36e7cbe0ee8b0e68da6", "filename": "src/librustc_mir/dataflow/generic/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/818934b9b418e16e6d60fb061e1e712f48c33216/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/818934b9b418e16e6d60fb061e1e712f48c33216/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs?ref=818934b9b418e16e6d60fb061e1e712f48c33216", "patch": "@@ -241,7 +241,7 @@ where\n                     )?;\n \n                     let state_on_unwind = this.results.get().clone();\n-                    this.results.seek_after_assume_call_returns(terminator_loc);\n+                    this.results.seek_after_assume_success(terminator_loc);\n                     write_diff(w, this.results.analysis(), &state_on_unwind, this.results.get())?;\n \n                     write!(w, \"</td>\")"}, {"sha": "fb4b7b9c5be315b276c29eb249c178dc5a0ed00b", "filename": "src/librustc_mir/dataflow/generic/mod.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/818934b9b418e16e6d60fb061e1e712f48c33216/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/818934b9b418e16e6d60fb061e1e712f48c33216/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs?ref=818934b9b418e16e6d60fb061e1e712f48c33216", "patch": "@@ -191,6 +191,20 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n         return_place: &mir::Place<'tcx>,\n     );\n \n+    /// Updates the current dataflow state with the effect of resuming from a `Yield` terminator.\n+    ///\n+    /// This is similar to `apply_call_return_effect` in that it only takes place after the\n+    /// generator is resumed, not when it is dropped.\n+    ///\n+    /// By default, no effects happen.\n+    fn apply_yield_resume_effect(\n+        &self,\n+        _state: &mut BitSet<Self::Idx>,\n+        _resume_block: BasicBlock,\n+        _resume_place: &mir::Place<'tcx>,\n+    ) {\n+    }\n+\n     /// Updates the current dataflow state with the effect of taking a particular branch in a\n     /// `SwitchInt` terminator.\n     ///\n@@ -284,6 +298,15 @@ pub trait GenKillAnalysis<'tcx>: Analysis<'tcx> {\n         return_place: &mir::Place<'tcx>,\n     );\n \n+    /// See `Analysis::apply_yield_resume_effect`.\n+    fn yield_resume_effect(\n+        &self,\n+        _trans: &mut BitSet<Self::Idx>,\n+        _resume_block: BasicBlock,\n+        _resume_place: &mir::Place<'tcx>,\n+    ) {\n+    }\n+\n     /// See `Analysis::apply_discriminant_switch_effect`.\n     fn discriminant_switch_effect(\n         &self,\n@@ -347,6 +370,15 @@ where\n         self.call_return_effect(state, block, func, args, return_place);\n     }\n \n+    fn apply_yield_resume_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        resume_block: BasicBlock,\n+        resume_place: &mir::Place<'tcx>,\n+    ) {\n+        self.yield_resume_effect(state, resume_block, resume_place);\n+    }\n+\n     fn apply_discriminant_switch_effect(\n         &self,\n         state: &mut BitSet<Self::Idx>,"}, {"sha": "8f07a10e1b01ce11734a44859e60faceea5fe0be", "filename": "src/librustc_mir/dataflow/generic/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/818934b9b418e16e6d60fb061e1e712f48c33216/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/818934b9b418e16e6d60fb061e1e712f48c33216/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Ftests.rs?ref=818934b9b418e16e6d60fb061e1e712f48c33216", "patch": "@@ -294,7 +294,7 @@ fn cursor_seek() {\n \n     cursor.seek_after(call_terminator_loc);\n     assert!(!cursor.get().contains(call_return_effect));\n-    cursor.seek_after_assume_call_returns(call_terminator_loc);\n+    cursor.seek_after_assume_success(call_terminator_loc);\n     assert!(cursor.get().contains(call_return_effect));\n \n     let every_target = || {\n@@ -310,7 +310,7 @@ fn cursor_seek() {\n             BlockStart(block) => cursor.seek_to_block_start(block),\n             Before(loc) => cursor.seek_before(loc),\n             After(loc) => cursor.seek_after(loc),\n-            AfterAssumeCallReturns(loc) => cursor.seek_after_assume_call_returns(loc),\n+            AfterAssumeCallReturns(loc) => cursor.seek_after_assume_success(loc),\n         }\n \n         assert_eq!(cursor.get(), &cursor.analysis().expected_state_at_target(targ));"}, {"sha": "5341d661b1db62379e1fc424fdbbe36fedbb3254", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/818934b9b418e16e6d60fb061e1e712f48c33216/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/818934b9b418e16e6d60fb061e1e712f48c33216/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=818934b9b418e16e6d60fb061e1e712f48c33216", "patch": "@@ -161,11 +161,16 @@ impl<'mir, 'tcx> dataflow::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir,\n         self.borrowed_locals.borrow().analysis().terminator_effect(trans, terminator, loc);\n \n         match &terminator.kind {\n-            TerminatorKind::Call { destination: Some((place, _)), .. }\n-            | TerminatorKind::Yield { resume_arg: place, .. } => {\n+            TerminatorKind::Call { destination: Some((place, _)), .. } => {\n                 trans.gen(place.local);\n             }\n \n+            // Note that we do *not* gen the `resume_arg` of `Yield` terminators. The reason for\n+            // that is that a `yield` will return from the function, and `resume_arg` is written\n+            // only when the generator is later resumed. Unlike `Call`, this doesn't require the\n+            // place to have storage *before* the yield, only after.\n+            TerminatorKind::Yield { .. } => {}\n+\n             // Nothing to do for these. Match exhaustively so this fails to compile when new\n             // variants are added.\n             TerminatorKind::Call { destination: None, .. }\n@@ -230,6 +235,15 @@ impl<'mir, 'tcx> dataflow::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir,\n     ) {\n         trans.gen(return_place.local);\n     }\n+\n+    fn yield_resume_effect(\n+        &self,\n+        trans: &mut BitSet<Self::Idx>,\n+        _resume_block: BasicBlock,\n+        resume_place: &mir::Place<'tcx>,\n+    ) {\n+        trans.gen(resume_place.local);\n+    }\n }\n \n impl<'mir, 'tcx> MaybeRequiresStorage<'mir, 'tcx> {"}, {"sha": "ce17e8db3fdec0d40680eba90eefdcaaf7a82102", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/818934b9b418e16e6d60fb061e1e712f48c33216/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/818934b9b418e16e6d60fb061e1e712f48c33216/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=818934b9b418e16e6d60fb061e1e712f48c33216", "patch": "@@ -506,7 +506,7 @@ fn locals_live_across_suspend_points(\n \n     for (block, data) in body.basic_blocks().iter_enumerated() {\n         if let TerminatorKind::Yield { .. } = data.terminator().kind {\n-            let loc = Location { block: block, statement_index: data.statements.len() };\n+            let loc = Location { block, statement_index: data.statements.len() };\n \n             if !movable {\n                 // The `liveness` variable contains the liveness of MIR locals ignoring borrows.\n@@ -539,7 +539,7 @@ fn locals_live_across_suspend_points(\n             let mut live_locals_here = storage_required;\n             live_locals_here.intersect(&liveness.outs[block]);\n \n-            // The generator argument is ignored\n+            // The generator argument is ignored.\n             live_locals_here.remove(self_arg());\n \n             debug!(\"loc = {:?}, live_locals_here = {:?}\", loc, live_locals_here);"}]}