{"sha": "8ec348afdd35752677914ba28146d7b82e901817", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlYzM0OGFmZGQzNTc1MjY3NzkxNGJhMjgxNDZkN2I4MmU5MDE4MTc=", "commit": {"author": {"name": "Ivan Tham", "email": "pickfire@riseup.net", "date": "2020-07-20T15:02:28Z"}, "committer": {"name": "Ivan Tham", "email": "pickfire@riseup.net", "date": "2020-08-11T06:40:39Z"}, "message": "Remove branch in optimized is_ascii\n\nPerforms slightly better in short or medium bytes by eliminating\nthe last branch check on `byte_pos == len` and always check the\nlast byte as it is always at most one `usize`.\n\nBenchmark, before `libcore`, after `libcore_new`. It improves\nmedium and short by 1ns but regresses unaligned_tail by 2ns,\neither way we can get unaligned_tail have a tiny chance of 1/8\non a 64 bit machine. I don't think we should bet on that, the\nprobability is worse than dice.\n\ntest long::case00_libcore                     ... bench:          38 ns/iter (+/- 1) = 183947 MB/s\ntest long::case00_libcore_new                 ... bench:          38 ns/iter (+/- 1) = 183947 MB/s\ntest long::case01_iter_all                    ... bench:         227 ns/iter (+/- 6) = 30792 MB/s\ntest long::case02_align_to                    ... bench:          40 ns/iter (+/- 1) = 174750 MB/s\ntest long::case03_align_to_unrolled           ... bench:          19 ns/iter (+/- 1) = 367894 MB/s\ntest medium::case00_libcore                   ... bench:           5 ns/iter (+/- 0) = 6400 MB/s\ntest medium::case00_libcore_new               ... bench:           4 ns/iter (+/- 0) = 8000 MB/s\ntest medium::case01_iter_all                  ... bench:          20 ns/iter (+/- 1) = 1600 MB/s\ntest medium::case02_align_to                  ... bench:           6 ns/iter (+/- 0) = 5333 MB/s\ntest medium::case03_align_to_unrolled         ... bench:           5 ns/iter (+/- 0) = 6400 MB/s\ntest short::case00_libcore                    ... bench:           7 ns/iter (+/- 0) = 1000 MB/s\ntest short::case00_libcore_new                ... bench:           6 ns/iter (+/- 0) = 1166 MB/s\ntest short::case01_iter_all                   ... bench:           5 ns/iter (+/- 0) = 1400 MB/s\ntest short::case02_align_to                   ... bench:           5 ns/iter (+/- 0) = 1400 MB/s\ntest short::case03_align_to_unrolled          ... bench:           5 ns/iter (+/- 1) = 1400 MB/s\ntest unaligned_both::case00_libcore           ... bench:           4 ns/iter (+/- 0) = 7500 MB/s\ntest unaligned_both::case00_libcore_new       ... bench:           4 ns/iter (+/- 0) = 7500 MB/s\ntest unaligned_both::case01_iter_all          ... bench:          26 ns/iter (+/- 0) = 1153 MB/s\ntest unaligned_both::case02_align_to          ... bench:          13 ns/iter (+/- 2) = 2307 MB/s\ntest unaligned_both::case03_align_to_unrolled ... bench:          11 ns/iter (+/- 0) = 2727 MB/s\ntest unaligned_head::case00_libcore           ... bench:           5 ns/iter (+/- 0) = 6200 MB/s\ntest unaligned_head::case00_libcore_new       ... bench:           5 ns/iter (+/- 0) = 6200 MB/s\ntest unaligned_head::case01_iter_all          ... bench:          19 ns/iter (+/- 1) = 1631 MB/s\ntest unaligned_head::case02_align_to          ... bench:          10 ns/iter (+/- 0) = 3100 MB/s\ntest unaligned_head::case03_align_to_unrolled ... bench:          14 ns/iter (+/- 0) = 2214 MB/s\ntest unaligned_tail::case00_libcore           ... bench:           3 ns/iter (+/- 0) = 10333 MB/s\ntest unaligned_tail::case00_libcore_new       ... bench:           5 ns/iter (+/- 0) = 6200 MB/s\ntest unaligned_tail::case01_iter_all          ... bench:          19 ns/iter (+/- 0) = 1631 MB/s\ntest unaligned_tail::case02_align_to          ... bench:          10 ns/iter (+/- 0) = 3100 MB/s\ntest unaligned_tail::case03_align_to_unrolled ... bench:          13 ns/iter (+/- 0) = 2384 MB/s\n\nRough (unfair) maths on improvements for fun: 1ns * 7/8 - 2ns * 1/8 = 0.625ns\n\nInspired by fish and zsh clever trick to highlight missing linefeeds (\u23ce)\nand branchless implementation of binary_search in rust.", "tree": {"sha": "03abaebf8151e9e0c1be818cb58875a089a357d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03abaebf8151e9e0c1be818cb58875a089a357d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ec348afdd35752677914ba28146d7b82e901817", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ec348afdd35752677914ba28146d7b82e901817", "html_url": "https://github.com/rust-lang/rust/commit/8ec348afdd35752677914ba28146d7b82e901817", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ec348afdd35752677914ba28146d7b82e901817/comments", "author": {"login": "pickfire", "id": 4687791, "node_id": "MDQ6VXNlcjQ2ODc3OTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4687791?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pickfire", "html_url": "https://github.com/pickfire", "followers_url": "https://api.github.com/users/pickfire/followers", "following_url": "https://api.github.com/users/pickfire/following{/other_user}", "gists_url": "https://api.github.com/users/pickfire/gists{/gist_id}", "starred_url": "https://api.github.com/users/pickfire/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pickfire/subscriptions", "organizations_url": "https://api.github.com/users/pickfire/orgs", "repos_url": "https://api.github.com/users/pickfire/repos", "events_url": "https://api.github.com/users/pickfire/events{/privacy}", "received_events_url": "https://api.github.com/users/pickfire/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pickfire", "id": 4687791, "node_id": "MDQ6VXNlcjQ2ODc3OTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4687791?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pickfire", "html_url": "https://github.com/pickfire", "followers_url": "https://api.github.com/users/pickfire/followers", "following_url": "https://api.github.com/users/pickfire/following{/other_user}", "gists_url": "https://api.github.com/users/pickfire/gists{/gist_id}", "starred_url": "https://api.github.com/users/pickfire/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pickfire/subscriptions", "organizations_url": "https://api.github.com/users/pickfire/orgs", "repos_url": "https://api.github.com/users/pickfire/repos", "events_url": "https://api.github.com/users/pickfire/events{/privacy}", "received_events_url": "https://api.github.com/users/pickfire/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13290e83a6e20f3b408d177a9d64d8cf98fe4615", "url": "https://api.github.com/repos/rust-lang/rust/commits/13290e83a6e20f3b408d177a9d64d8cf98fe4615", "html_url": "https://github.com/rust-lang/rust/commit/13290e83a6e20f3b408d177a9d64d8cf98fe4615"}], "stats": {"total": 15, "additions": 6, "deletions": 9}, "files": [{"sha": "bedf871c024bc73ff1e7a3bdd7c45b4a48b2ac04", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8ec348afdd35752677914ba28146d7b82e901817/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec348afdd35752677914ba28146d7b82e901817/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=8ec348afdd35752677914ba28146d7b82e901817", "patch": "@@ -2902,7 +2902,7 @@ fn contains_nonascii(v: usize) -> bool {\n ///\n /// - Read the first word with an unaligned load.\n /// - Align the pointer, read subsequent words until end with aligned loads.\n-/// - If there's a tail, the last `usize` from `s` with an unaligned load.\n+/// - Read the last `usize` from `s` with an unaligned load.\n ///\n /// If any of these loads produces something for which `contains_nonascii`\n /// (above) returns true, then we know the answer is false.\n@@ -2949,7 +2949,10 @@ fn is_ascii(s: &[u8]) -> bool {\n     // `align_offset` though.\n     debug_assert_eq!((word_ptr as usize) % mem::align_of::<usize>(), 0);\n \n-    while byte_pos <= len - USIZE_SIZE {\n+    // Read subsequent words until the last aligned word, excluding the last\n+    // aligned word by itself to be done in tail check later, to ensure that\n+    // tail is always one `usize` at most to extra branch `byte_pos == len`.\n+    while byte_pos < len - USIZE_SIZE {\n         debug_assert!(\n             // Sanity check that the read is in bounds\n             (word_ptr as usize + USIZE_SIZE) <= (start.wrapping_add(len) as usize) &&\n@@ -2970,15 +2973,9 @@ fn is_ascii(s: &[u8]) -> bool {\n         word_ptr = unsafe { word_ptr.add(1) };\n     }\n \n-    // If we have anything left over, it should be at-most 1 usize worth of bytes,\n-    // which we check with a read_unaligned.\n-    if byte_pos == len {\n-        return true;\n-    }\n-\n     // Sanity check to ensure there really is only one `usize` left. This should\n     // be guaranteed by our loop condition.\n-    debug_assert!(byte_pos < len && len - byte_pos < USIZE_SIZE);\n+    debug_assert!(byte_pos <= len && len - byte_pos <= USIZE_SIZE);\n \n     // SAFETY: This relies on `len >= USIZE_SIZE`, which we check at the start.\n     let last_word = unsafe { (start.add(len - USIZE_SIZE) as *const usize).read_unaligned() };"}]}