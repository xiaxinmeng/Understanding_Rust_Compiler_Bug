{"sha": "9ff91ab2d3151078053bc3966f7163d048209d38", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmZjkxYWIyZDMxNTEwNzgwNTNiYzM5NjZmNzE2M2QwNDgyMDlkMzg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-22T17:11:28Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-22T17:11:28Z"}, "message": "fix reoccuring typo: dereferencable -> dereferenceable", "tree": {"sha": "8037c451cedc897cfeb62b9575395234e3c1fe06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8037c451cedc897cfeb62b9575395234e3c1fe06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ff91ab2d3151078053bc3966f7163d048209d38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ff91ab2d3151078053bc3966f7163d048209d38", "html_url": "https://github.com/rust-lang/rust/commit/9ff91ab2d3151078053bc3966f7163d048209d38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ff91ab2d3151078053bc3966f7163d048209d38/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "083b5a0a1bb3b2ee0873697ebf37e88d85faa3e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/083b5a0a1bb3b2ee0873697ebf37e88d85faa3e5", "html_url": "https://github.com/rust-lang/rust/commit/083b5a0a1bb3b2ee0873697ebf37e88d85faa3e5"}], "stats": {"total": 18, "additions": 9, "deletions": 9}, "files": [{"sha": "a66a49f103f68f0d6a4b66747a7b733c1e01f535", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ff91ab2d3151078053bc3966f7163d048209d38/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff91ab2d3151078053bc3966f7163d048209d38/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=9ff91ab2d3151078053bc3966f7163d048209d38", "patch": "@@ -81,7 +81,7 @@ impl<'tcx> PlaceTy<'tcx> {\n                 let ty = self.ty\n                              .builtin_deref(true)\n                              .unwrap_or_else(|| {\n-                                 bug!(\"deref projection of non-dereferencable ty {:?}\", self)\n+                                 bug!(\"deref projection of non-dereferenceable ty {:?}\", self)\n                              })\n                              .ty;\n                 PlaceTy::from_ty(ty)"}, {"sha": "842ef915ad2267025cfa1a5a6ba945eeadd58f75", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ff91ab2d3151078053bc3966f7163d048209d38/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff91ab2d3151078053bc3966f7163d048209d38/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=9ff91ab2d3151078053bc3966f7163d048209d38", "patch": "@@ -47,7 +47,7 @@ impl<T: MayLeak> MayLeak for MemoryKind<T> {\n #[derive(Debug, Copy, Clone)]\n pub enum AllocCheck {\n     /// Allocation must be live and not a function pointer.\n-    Dereferencable,\n+    Dereferenceable,\n     /// Allocations needs to be live, but may be a function pointer.\n     Live,\n     /// Allocation may be dead.\n@@ -365,7 +365,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             }\n             Err(ptr) => {\n                 let (allocation_size, alloc_align) =\n-                    self.get_size_and_align(ptr.alloc_id, AllocCheck::Dereferencable)?;\n+                    self.get_size_and_align(ptr.alloc_id, AllocCheck::Dereferenceable)?;\n                 // Test bounds. This also ensures non-NULL.\n                 // It is sufficient to check this for the end pointer. The addition\n                 // checks for overflow.\n@@ -569,7 +569,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // # Function pointers\n         // (both global from `alloc_map` and local from `extra_fn_ptr_map`)\n         if let Ok(_) = self.get_fn_alloc(id) {\n-            return if let AllocCheck::Dereferencable = liveness {\n+            return if let AllocCheck::Dereferenceable = liveness {\n                 // The caller requested no function pointers.\n                 throw_unsup!(DerefFunctionPointer)\n             } else {"}, {"sha": "e358df2f213ba3047a52bc7c5082baf4bd0e623d", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ff91ab2d3151078053bc3966f7163d048209d38/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff91ab2d3151078053bc3966f7163d048209d38/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=9ff91ab2d3151078053bc3966f7163d048209d38", "patch": "@@ -286,7 +286,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                     \"non-integer slice length in wide pointer\", self.path);\n                 // We do not check that `len * elem_size <= isize::MAX`:\n                 // that is only required for references, and there it falls out of the\n-                // \"dereferencable\" check performed by Stacked Borrows.\n+                // \"dereferenceable\" check performed by Stacked Borrows.\n             }\n             ty::Foreign(..) => {\n                 // Unsized, but not wide.\n@@ -404,7 +404,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 if place.layout.is_unsized() {\n                     self.check_wide_ptr_meta(place.meta, place.layout)?;\n                 }\n-                // Make sure this is dereferencable and all.\n+                // Make sure this is dereferenceable and all.\n                 let (size, align) = self.ecx.size_and_align_of(place.meta, place.layout)?\n                     // for the purpose of validity, consider foreign types to have\n                     // alignment and size determined by the layout (size will be 0,"}, {"sha": "9dd3bc624a51afc14cb320ab95144f4cc1fc26d4", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ff91ab2d3151078053bc3966f7163d048209d38/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff91ab2d3151078053bc3966f7163d048209d38/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=9ff91ab2d3151078053bc3966f7163d048209d38", "patch": "@@ -538,7 +538,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &Pat) -> bool {\n+    pub fn check_dereferenceable(&self, span: Span, expected: Ty<'tcx>, inner: &Pat) -> bool {\n         if let PatKind::Binding(..) = inner.kind {\n             if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n                 if let ty::Dynamic(..) = mt.ty.kind {\n@@ -1075,7 +1075,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         discrim_span: Option<Span>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n-        let (box_ty, inner_ty) = if self.check_dereferencable(span, expected, &inner) {\n+        let (box_ty, inner_ty) = if self.check_dereferenceable(span, expected, &inner) {\n             // Here, `demand::subtype` is good enough, but I don't\n             // think any errors can be introduced by using `demand::eqtype`.\n             let inner_ty = self.next_ty_var(TypeVariableOrigin {\n@@ -1103,7 +1103,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let expected = self.shallow_resolve(expected);\n-        let (rptr_ty, inner_ty) = if self.check_dereferencable(pat.span, expected, &inner) {\n+        let (rptr_ty, inner_ty) = if self.check_dereferenceable(pat.span, expected, &inner) {\n             // `demand::subtype` would be good enough, but using `eqtype` turns\n             // out to be equally general. See (note_1) for details.\n "}]}