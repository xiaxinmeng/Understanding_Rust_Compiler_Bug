{"sha": "48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ZDYwYWI3YzUwNWM2YzFlYmIwNDJlYWNhYWZkOGRjOWY3YTkyNjc=", "commit": {"author": {"name": "Commeownist", "email": "commeownist@yandex.ru", "date": "2021-09-17T21:19:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-17T21:19:25Z"}, "message": "Update to nightly-2021-09-11 (#79)\n\n* Implement `black_box` as intrinsic\r\n\r\nResponsibility of implementing the black box is now lies on backend\r\n\r\n* Remove some TODOs\r\n\r\n* Update to nightly-2021-09-17\r\n\r\n* CI: don't fail on warnings", "tree": {"sha": "c9fcac750edefb1fda6e2f5721cf1a4ee837e0e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9fcac750edefb1fda6e2f5721cf1a4ee837e0e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhRQZdCRBK7hj4Ov3rIwAA9tIIAALslQx/YKIKWRCTqPl8jTi0\nrcg0gVKlhT2fhjnWiSoFbSLkCzGThTEGQaUPD5b+QZy5xcVKGIVCxXJDwW8q51yJ\n34hxZ1js62sejOe5tnQXQy+MeY8HZ/gXpdxdnJ2Ur+NAccewhs+wBRDuf/nnnvXz\nWWu0A4dUMmzZpm6zMbm6gG7JcENkag2a5oxIIscsQbjVzT7+tCoNZhfHAjxOXtSW\n8oeXPH6myJKW3f/yxH9JNFialqrckSE84AWyvo2L+lzvNgVNnvEqy8tMUVqxLyoQ\nXRMgeR3ynkfuulNVP/UJux1xC0fXTU9FMQolmkr0FKJ1D6KIp2gzcqGGpZ3KqpQ=\n=z5k6\n-----END PGP SIGNATURE-----\n", "payload": "tree c9fcac750edefb1fda6e2f5721cf1a4ee837e0e5\nparent 8ec7976ced61c31dbcaeda3f52d7ecc197764f80\nauthor Commeownist <commeownist@yandex.ru> 1631913565 +0300\ncommitter GitHub <noreply@github.com> 1631913565 -0400\n\nUpdate to nightly-2021-09-11 (#79)\n\n* Implement `black_box` as intrinsic\r\n\r\nResponsibility of implementing the black box is now lies on backend\r\n\r\n* Remove some TODOs\r\n\r\n* Update to nightly-2021-09-17\r\n\r\n* CI: don't fail on warnings"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267", "html_url": "https://github.com/rust-lang/rust/commit/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/comments", "author": null, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ec7976ced61c31dbcaeda3f52d7ecc197764f80", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ec7976ced61c31dbcaeda3f52d7ecc197764f80", "html_url": "https://github.com/rust-lang/rust/commit/8ec7976ced61c31dbcaeda3f52d7ecc197764f80"}], "stats": {"total": 266, "additions": 117, "deletions": 149}, "files": [{"sha": "a03d26c0467e18aadccbc22c1ba417012ca15538", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267", "patch": "@@ -1 +1 @@\n-nightly-2021-08-12\n+nightly-2021-09-17"}, {"sha": "6378a31202c1b88b1e2d213b5518e28c422b52a8", "filename": "src/allocator.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fallocator.rs?ref=48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267", "patch": "@@ -6,7 +6,7 @@ use rustc_span::symbol::sym;\n \n use crate::GccContext;\n \n-pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, kind: AllocatorKind, has_alloc_error_handler: bool) {\n+pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_name: &str, kind: AllocatorKind, has_alloc_error_handler: bool) {\n     let context = &mods.context;\n     let usize =\n         match tcx.sess.target.pointer_width {\n@@ -77,6 +77,9 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, kind: Alloc\n         else {\n             block.end_with_void_return(None);\n         }\n+\n+        // TODO(@Commeownist): Check if we need to emit some extra debugging info in certain circumstances\n+        // as described in https://github.com/rust-lang/rust/commit/77a96ed5646f7c3ee8897693decc4626fe380643\n     }\n \n     let types = [usize, usize];"}, {"sha": "d749d763402b810ebd35508cbb5ec1b33ea2dfba", "filename": "src/archive.rs", "status": "modified", "additions": 21, "deletions": 73, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farchive.rs?ref=48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267", "patch": "@@ -2,16 +2,15 @@ use std::fs::File;\n use std::path::{Path, PathBuf};\n \n use rustc_session::Session;\n-use rustc_codegen_ssa::back::archive::{find_library, ArchiveBuilder};\n-use rustc_codegen_ssa::METADATA_FILENAME;\n+use rustc_codegen_ssa::back::archive::ArchiveBuilder;\n+\n use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_middle::middle::cstore::DllImport;\n-use rustc_span::symbol::Symbol;\n+\n \n struct ArchiveConfig<'a> {\n     sess: &'a Session,\n     dst: PathBuf,\n-    lib_search_paths: Vec<PathBuf>,\n     use_native_ar: bool,\n     use_gnu_style_archive: bool,\n }\n@@ -35,11 +34,9 @@ pub struct ArArchiveBuilder<'a> {\n \n impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n     fn new(sess: &'a Session, output: &Path, input: Option<&Path>) -> Self {\n-        use rustc_codegen_ssa::back::link::archive_search_paths;\n         let config = ArchiveConfig {\n             sess,\n             dst: output.to_path_buf(),\n-            lib_search_paths: archive_search_paths(sess),\n             use_native_ar: false,\n             // FIXME test for linux and System V derivatives instead\n             use_gnu_style_archive: sess.target.options.archive_format == \"gnu\",\n@@ -94,47 +91,27 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         ));\n     }\n \n-    fn add_native_library(&mut self, name: Symbol, verbatim: bool) {\n-        let location = find_library(name, verbatim, &self.config.lib_search_paths, self.config.sess);\n-        self.add_archive(location.clone(), |_| false)\n-            .unwrap_or_else(|e| {\n-                panic!(\n-                    \"failed to add native library {}: {}\",\n-                    location.to_string_lossy(),\n-                    e\n-                );\n-            });\n-    }\n-\n-    fn add_rlib(\n-        &mut self,\n-        rlib: &Path,\n-        name: &str,\n-        lto: bool,\n-        skip_objects: bool,\n-    ) -> std::io::Result<()> {\n-        let obj_start = name.to_owned();\n-\n-        self.add_archive(rlib.to_owned(), move |fname: &str| {\n-            // Ignore metadata files, no matter the name.\n-            if fname == METADATA_FILENAME {\n-                return true;\n-            }\n-\n-            // Don't include Rust objects if LTO is enabled\n-            if lto && fname.starts_with(&obj_start) && fname.ends_with(\".o\") {\n-                return true;\n-            }\n+    fn add_archive<F>(&mut self, archive_path: &Path, mut skip: F) -> std::io::Result<()>\n+    where\n+        F: FnMut(&str) -> bool + 'static,\n+    {\n+        let mut archive = ar::Archive::new(std::fs::File::open(&archive_path)?);\n+        let archive_index = self.src_archives.len();\n \n-            // Otherwise if this is *not* a rust object and we're skipping\n-            // objects then skip this file\n-            if skip_objects && (!fname.starts_with(&obj_start) || !fname.ends_with(\".o\")) {\n-                return true;\n+        let mut i = 0;\n+        while let Some(entry) = archive.next_entry() {\n+            let entry = entry?;\n+            let file_name = String::from_utf8(entry.header().identifier().to_vec())\n+                .map_err(|err| std::io::Error::new(std::io::ErrorKind::InvalidData, err))?;\n+            if !skip(&file_name) {\n+                self.entries\n+                    .push((file_name, ArchiveEntry::FromArchive { archive_index, entry_index: i }));\n             }\n+            i += 1;\n+        }\n \n-            // ok, don't skip this\n-            return false;\n-        })\n+        self.src_archives.push((archive_path.to_owned(), archive));\n+        Ok(())\n     }\n \n     fn update_symbols(&mut self) {\n@@ -239,32 +216,3 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         unimplemented!();\n     }\n }\n-\n-impl<'a> ArArchiveBuilder<'a> {\n-    fn add_archive<F>(&mut self, archive_path: PathBuf, mut skip: F) -> std::io::Result<()>\n-    where\n-        F: FnMut(&str) -> bool + 'static,\n-    {\n-        let mut archive = ar::Archive::new(std::fs::File::open(&archive_path)?);\n-        let archive_index = self.src_archives.len();\n-\n-        let mut i = 0;\n-        while let Some(entry) = archive.next_entry() {\n-            let entry = entry.unwrap();\n-            let file_name = String::from_utf8(entry.header().identifier().to_vec()).unwrap();\n-            if !skip(&file_name) {\n-                self.entries.push((\n-                    file_name,\n-                    ArchiveEntry::FromArchive {\n-                        archive_index,\n-                        entry_index: i,\n-                    },\n-                ));\n-            }\n-            i += 1;\n-        }\n-\n-        self.src_archives.push((archive_path, archive));\n-        Ok(())\n-    }\n-}"}, {"sha": "a684c34b644101d6ba1a31f25f4ab869063e4ecd", "filename": "src/asm.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fasm.rs?ref=48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267", "patch": "@@ -107,26 +107,10 @@ enum ConstraintOrRegister {\n \n \n impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n-    fn codegen_llvm_inline_asm(&mut self, ia: &LlvmInlineAsmInner, outputs: Vec<PlaceRef<'tcx, RValue<'gcc>>>, inputs: Vec<RValue<'gcc>>, span: Span) -> bool {\n-        if ia.asm.as_str().is_empty() && outputs.is_empty() {\n-            // TODO(@Commeownist): there's one use of `llvm_asm` in rustc sysroot we can't get rid of just yet.\n-            // Fortunately, it's used as a simple black box to make sure that inputs are not optimized away.\n-            // Let's just emulate it.\n-            let block = self.llbb();\n-            let extended_asm = block.add_extended_asm(None, \"\");\n-            for input in inputs {\n-                extended_asm.add_input_operand(None, \"r\", input);\n-            }\n-            extended_asm.add_clobber(\"memory\");\n-            extended_asm.set_volatile_flag(true);\n-        } \n-        else {\n-            // TODO(@Commeownist): switch to `struct_span_err_with_code` \n-            // once we get this merged into rustc\n-            self.sess().struct_span_err(span, \"GCC backend does not support `llvm_asm!`\")\n-                .help(\"consider using the `asm!` macro instead\")\n-                .emit();\n-        }\n+    fn codegen_llvm_inline_asm(&mut self, _ia: &LlvmInlineAsmInner, _outputs: Vec<PlaceRef<'tcx, RValue<'gcc>>>, _inputs: Vec<RValue<'gcc>>, span: Span) -> bool {\n+        self.sess().struct_span_err(span, \"GCC backend does not support `llvm_asm!`\")\n+            .help(\"consider using the `asm!` macro instead\")\n+            .emit();\n \n         // We return `true` even if we've failed to generate the asm\n         // because we want to suppress the \"malformed inline assembly\" error\n@@ -579,6 +563,10 @@ fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> ConstraintOrRegister {\n             InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg) => unimplemented!(),\n             InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg_nonzero) => unimplemented!(),\n             InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::freg) => unimplemented!(),\n+            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::cr)\n+            | InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::xer) => {\n+                unreachable!(\"clobber-only\")\n+            },\n             InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => unimplemented!(),\n             InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => unimplemented!(),\n             InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => unimplemented!(),\n@@ -596,6 +584,8 @@ fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> ConstraintOrRegister {\n             InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n                 bug!(\"GCC backend does not support SPIR-V\")\n             }\n+            InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => unimplemented!(),\n+            InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => unimplemented!(),\n             InlineAsmRegClass::Err => unreachable!(),\n         }\n     };\n@@ -635,6 +625,10 @@ fn dummy_output_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, reg: InlineAsmRegCl\n         InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg_nonzero) => cx.type_i32(),\n         InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::freg) => cx.type_f64(),\n+        InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::cr)\n+        | InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::xer) => {\n+            unreachable!(\"clobber-only\")\n+        },\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => cx.type_f32(),\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => cx.type_f32(),\n@@ -651,6 +645,8 @@ fn dummy_output_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, reg: InlineAsmRegCl\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         },\n+        InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => cx.type_f64(),\n         InlineAsmRegClass::Err => unreachable!(),\n     }\n }\n@@ -765,6 +761,8 @@ fn modifier_to_gcc(arch: InlineAsmArch, reg: InlineAsmRegClass, modifier: Option\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         },\n+        InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => unimplemented!(),\n+        InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => unimplemented!(),\n         InlineAsmRegClass::Err => unreachable!(),\n     }\n }"}, {"sha": "5d06d71953c6675408de6caed1b5bd7fe52e4c65", "filename": "src/builder.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267", "patch": "@@ -1,7 +1,7 @@\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::convert::TryFrom;\n-use std::ops::{Deref, Range};\n+use std::ops::Deref;\n \n use gccjit::FunctionType;\n use gccjit::{\n@@ -31,16 +31,16 @@ use rustc_codegen_ssa::traits::{\n     StaticBuilderMethods,\n };\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n-use rustc_middle::ty::layout::{HasParamEnv, HasTyCtxt, TyAndLayout};\n+use rustc_middle::ty::layout::{HasParamEnv, HasTyCtxt, LayoutError, LayoutOfHelpers, TyAndLayout};\n use rustc_span::Span;\n use rustc_span::def_id::DefId;\n use rustc_target::abi::{\n     self,\n     Align,\n     HasDataLayout,\n-    LayoutOf,\n     Size,\n     TargetDataLayout,\n+    WrappingRange,\n };\n use rustc_target::spec::{HasTargetSpec, Target};\n \n@@ -338,12 +338,12 @@ impl HasDataLayout for Builder<'_, '_, '_> {\n     }\n }\n \n-impl<'tcx> LayoutOf for Builder<'_, '_, 'tcx> {\n-    type Ty = Ty<'tcx>;\n-    type TyAndLayout = TyAndLayout<'tcx>;\n+impl<'tcx> LayoutOfHelpers<'tcx> for Builder<'_, '_, 'tcx> {\n+    type LayoutOfResult = TyAndLayout<'tcx>;\n \n-    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n-        self.cx.layout_of(ty)\n+    #[inline]\n+    fn handle_layout_err(&self, err: LayoutError<'tcx>, span: Span, ty: Ty<'tcx>) -> ! {\n+        self.cx.handle_layout_err(err, span, ty)\n     }\n }\n \n@@ -818,12 +818,11 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n             let vr = scalar.valid_range.clone();\n             match scalar.value {\n                 abi::Int(..) => {\n-                    let range = scalar.valid_range_exclusive(bx);\n-                    if range.start != range.end {\n-                        bx.range_metadata(load, range);\n+                    if !scalar.is_always_valid(bx) {\n+                        bx.range_metadata(load, scalar.valid_range);\n                     }\n                 }\n-                abi::Pointer if vr.start() < vr.end() && !vr.contains(&0) => {\n+                abi::Pointer if vr.start < vr.end && !vr.contains(0) => {\n                     bx.nonnull_metadata(load);\n                 }\n                 _ => {}\n@@ -894,7 +893,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         next_bx\n     }\n \n-    fn range_metadata(&mut self, _load: RValue<'gcc>, _range: Range<u128>) {\n+    fn range_metadata(&mut self, _load: RValue<'gcc>, _range: WrappingRange) {\n         // TODO(antoyo)\n     }\n \n@@ -1378,7 +1377,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         }\n     }\n \n-    fn to_immediate_scalar(&mut self, val: Self::Value, scalar: &abi::Scalar) -> Self::Value {\n+    fn to_immediate_scalar(&mut self, val: Self::Value, scalar: abi::Scalar) -> Self::Value {\n         if scalar.is_bool() {\n             return self.trunc(val, self.cx().type_i1());\n         }"}, {"sha": "e402e0e91f13359b73edac08a6853f0083555d8b", "filename": "src/callee.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcallee.rs?ref=48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267", "patch": "@@ -19,7 +19,6 @@ pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>)\n \n     assert!(!instance.substs.needs_infer());\n     assert!(!instance.substs.has_escaping_bound_vars());\n-    assert!(!instance.substs.has_param_types_or_consts());\n \n     if let Some(&func) = cx.instances.borrow().get(&instance) {\n         return func;"}, {"sha": "a24fe0df911a6db3344d0d256c8e05d7f3b4cc05", "filename": "src/common.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267", "patch": "@@ -12,10 +12,11 @@ use rustc_codegen_ssa::traits::{\n };\n use rustc_middle::bug;\n use rustc_middle::mir::Mutability;\n-use rustc_middle::ty::{layout::TyAndLayout, ScalarInt};\n-use rustc_mir::interpret::{Allocation, GlobalAlloc, Scalar};\n+use rustc_middle::ty::ScalarInt;\n+use rustc_middle::ty::layout::{TyAndLayout, LayoutOf};\n+use rustc_middle::mir::interpret::{Allocation, GlobalAlloc, Scalar};\n use rustc_span::Symbol;\n-use rustc_target::abi::{self, HasDataLayout, LayoutOf, Pointer, Size};\n+use rustc_target::abi::{self, HasDataLayout, Pointer, Size};\n \n use crate::consts::const_alloc_to_gcc;\n use crate::context::CodegenCx;\n@@ -212,7 +213,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         None\n     }\n \n-    fn scalar_to_backend(&self, cv: Scalar, layout: &abi::Scalar, ty: Type<'gcc>) -> RValue<'gcc> {\n+    fn scalar_to_backend(&self, cv: Scalar, layout: abi::Scalar, ty: Type<'gcc>) -> RValue<'gcc> {\n         let bitsize = if layout.is_bool() { 1 } else { layout.value.size(self).bits() };\n         match cv {\n             Scalar::Int(ScalarInt::ZST) => {"}, {"sha": "df13fa79f0696dd1e52ccbeec77adfb9971c7e54", "filename": "src/consts.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267", "patch": "@@ -6,10 +6,11 @@ use rustc_middle::{bug, span_bug};\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n-use rustc_mir::interpret::{self, Allocation, ErrorHandled, Scalar as InterpScalar, read_target_uint};\n+use rustc_middle::ty::layout::LayoutOf;\n+use rustc_middle::mir::interpret::{self, Allocation, ErrorHandled, Scalar as InterpScalar, read_target_uint};\n use rustc_span::Span;\n use rustc_span::def_id::DefId;\n-use rustc_target::abi::{self, Align, HasDataLayout, LayoutOf, Primitive, Size};\n+use rustc_target::abi::{self, Align, HasDataLayout, Primitive, Size, WrappingRange};\n \n use crate::base;\n use crate::context::CodegenCx;\n@@ -182,6 +183,10 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n     fn add_used_global(&self, _global: RValue<'gcc>) {\n         // TODO(antoyo)\n     }\n+\n+    fn add_compiler_used_global(&self, _global: RValue<'gcc>) {\n+        // TODO(antoyo)\n+    }\n }\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -350,7 +355,7 @@ pub fn const_alloc_to_gcc<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, alloc: &Alloca\n                 interpret::Pointer::new(alloc_id, Size::from_bytes(ptr_offset)),\n                 &cx.tcx,\n             ),\n-            &abi::Scalar { value: Primitive::Pointer, valid_range: 0..=!0 },\n+            abi::Scalar { value: Primitive::Pointer, valid_range: WrappingRange { start: 0, end: !0 } },\n             cx.type_i8p(),\n         ));\n         next_offset = offset + pointer_size;"}, {"sha": "ef687dd22c6da2c7fd6462dd45021bf2853a7ffd", "filename": "src/context.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcontext.rs?ref=48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267", "patch": "@@ -18,13 +18,13 @@ use rustc_codegen_ssa::traits::{\n };\n use rustc_data_structures::base_n;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_middle::bug;\n+use rustc_middle::span_bug;\n use rustc_middle::mir::mono::CodegenUnit;\n use rustc_middle::ty::{self, Instance, ParamEnv, PolyExistentialTraitRef, Ty, TyCtxt};\n-use rustc_middle::ty::layout::{HasParamEnv, HasTyCtxt, LayoutError, TyAndLayout};\n+use rustc_middle::ty::layout::{HasParamEnv, HasTyCtxt, LayoutError, TyAndLayout, LayoutOfHelpers};\n use rustc_session::Session;\n-use rustc_span::{Span, Symbol, DUMMY_SP};\n-use rustc_target::abi::{HasDataLayout, LayoutOf, PointeeInfo, Size, TargetDataLayout, VariantIdx};\n+use rustc_span::{Span, Symbol};\n+use rustc_target::abi::{HasDataLayout, PointeeInfo, Size, TargetDataLayout, VariantIdx};\n use rustc_target::spec::{HasTargetSpec, Target, TlsModel};\n \n use crate::callee::get_fn;\n@@ -395,6 +395,14 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             None\n         }\n     }\n+\n+    fn compiler_used_statics(&self) -> &RefCell<Vec<RValue<'gcc>>> {\n+        unimplemented!()\n+    }\n+\n+    fn create_compiler_used_variable(&self) {\n+        unimplemented!()\n+    }\n }\n \n impl<'gcc, 'tcx> HasTyCtxt<'tcx> for CodegenCx<'gcc, 'tcx> {\n@@ -415,22 +423,16 @@ impl<'gcc, 'tcx> HasTargetSpec for CodegenCx<'gcc, 'tcx> {\n     }\n }\n \n-impl<'gcc, 'tcx> LayoutOf for CodegenCx<'gcc, 'tcx> {\n-    type Ty = Ty<'tcx>;\n-    type TyAndLayout = TyAndLayout<'tcx>;\n+impl<'gcc, 'tcx> LayoutOfHelpers<'tcx> for CodegenCx<'gcc, 'tcx> {\n+    type LayoutOfResult = TyAndLayout<'tcx>;\n \n-    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n-        self.spanned_layout_of(ty, DUMMY_SP)\n-    }\n-\n-    fn spanned_layout_of(&self, ty: Ty<'tcx>, span: Span) -> Self::TyAndLayout {\n-        self.tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap_or_else(|e| {\n-            if let LayoutError::SizeOverflow(_) = e {\n-                self.sess().span_fatal(span, &e.to_string())\n-            } else {\n-                bug!(\"failed to get layout for `{}`: {}\", ty, e)\n-            }\n-        })\n+    #[inline]\n+    fn handle_layout_err(&self, err: LayoutError<'tcx>, span: Span, ty: Ty<'tcx>) -> ! {\n+        if let LayoutError::SizeOverflow(_) = err {\n+            self.sess().span_fatal(span, &err.to_string())\n+        } else {\n+            span_bug!(span, \"failed to get layout for `{}`: {}\", ty, err)\n+        }\n     }\n }\n "}, {"sha": "3dc4f61a7ac3cd819f62cfb7300940e6f384e2b0", "filename": "src/intrinsic/mod.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fmod.rs?ref=48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267", "patch": "@@ -10,8 +10,9 @@ use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{ArgAbiMethods, BaseTypeMethods, BuilderMethods, ConstMethods, IntrinsicCallMethods};\n use rustc_middle::bug;\n use rustc_middle::ty::{self, Instance, Ty};\n+use rustc_middle::ty::layout::LayoutOf;\n use rustc_span::{Span, Symbol, symbol::kw, sym};\n-use rustc_target::abi::{HasDataLayout, LayoutOf};\n+use rustc_target::abi::HasDataLayout;\n use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n use rustc_target::spec::PanicStrategy;\n \n@@ -176,7 +177,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                                     let result = func.new_local(None, arg.get_type(), \"zeros\");\n                                     let zero = self.cx.context.new_rvalue_zero(arg.get_type());\n                                     let cond = self.cx.context.new_comparison(None, ComparisonOp::Equals, arg, zero);\n-                                    self.block.expect(\"block\").end_with_conditional(None, cond, then_block, else_block);\n+                                    self.llbb().end_with_conditional(None, cond, then_block, else_block);\n \n                                     let zero_result = self.cx.context.new_rvalue_from_long(arg.get_type(), width as i64);\n                                     then_block.add_assignment(None, result, zero_result);\n@@ -307,6 +308,19 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     }\n                 }\n \n+                sym::black_box => {\n+                    args[0].val.store(self, result);\n+\n+                    let block = self.llbb();\n+                    let extended_asm = block.add_extended_asm(None, \"\");\n+                    extended_asm.add_input_operand(None, \"r\", result.llval);\n+                    extended_asm.add_clobber(\"memory\");\n+                    extended_asm.set_volatile_flag(true);\n+                    \n+                    // We have copied the value to `result` already.\n+                    return;\n+                }\n+\n                 _ if name_str.starts_with(\"simd_\") => {\n                     match generic_simd_intrinsic(self, name, callee_ty, args, ret_ty, llret_ty, span) {\n                         Ok(llval) => llval,\n@@ -935,7 +949,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             then_block.add_assignment(None, res, self.context.new_cast(None, shifted + int_max, result_type));\n             then_block.end_with_jump(None, after_block);\n \n-            self.block.expect(\"block\").end_with_conditional(None, overflow, then_block, after_block);\n+            self.llbb().end_with_conditional(None, overflow, then_block, after_block);\n \n             // NOTE: since jumps were added in a place rustc does not\n             // expect, the current blocks in the state need to be updated.\n@@ -985,7 +999,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             then_block.add_assignment(None, res, self.context.new_cast(None, shifted + int_max, result_type));\n             then_block.end_with_jump(None, after_block);\n \n-            self.block.expect(\"block\").end_with_conditional(None, overflow, then_block, after_block);\n+            self.llbb().end_with_conditional(None, overflow, then_block, after_block);\n \n             // NOTE: since jumps were added in a place rustc does not\n             // expect, the current blocks in the state need to be updated."}, {"sha": "793e5c48d0a365abe81b907585621c553b93a6dd", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267", "patch": "@@ -18,7 +18,6 @@ extern crate rustc_errors;\n extern crate rustc_hir;\n extern crate rustc_metadata;\n extern crate rustc_middle;\n-extern crate rustc_mir;\n extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_symbol_mangling;\n@@ -144,8 +143,8 @@ impl ExtraBackendMethods for GccCodegenBackend {\n         base::write_compressed_metadata(tcx, metadata, gcc_module)\n     }\n \n-    fn codegen_allocator<'tcx>(&self, tcx: TyCtxt<'tcx>, mods: &mut Self::Module, kind: AllocatorKind, has_alloc_error_handler: bool) {\n-        unsafe { allocator::codegen(tcx, mods, kind, has_alloc_error_handler) }\n+    fn codegen_allocator<'tcx>(&self, tcx: TyCtxt<'tcx>, mods: &mut Self::Module, module_name: &str, kind: AllocatorKind, has_alloc_error_handler: bool) {\n+        unsafe { allocator::codegen(tcx, mods, module_name, kind, has_alloc_error_handler) }\n     }\n \n     fn compile_codegen_unit<'tcx>(&self, tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (ModuleCodegen<Self::Module>, u64) {"}, {"sha": "cedeb54f60bf2e0ffa307676cc29ab4799d21fbd", "filename": "src/mono_item.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmono_item.rs?ref=48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267", "patch": "@@ -2,9 +2,8 @@ use rustc_codegen_ssa::traits::PreDefineMethods;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n use rustc_middle::ty::{self, Instance, TypeFoldable};\n-use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_middle::ty::layout::{FnAbiExt, LayoutOf};\n use rustc_span::def_id::DefId;\n-use rustc_target::abi::LayoutOf;\n use rustc_target::abi::call::FnAbi;\n \n use crate::base;\n@@ -31,7 +30,7 @@ impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn predefine_fn(&self, instance: Instance<'tcx>, linkage: Linkage, _visibility: Visibility, symbol_name: &str) {\n-        assert!(!instance.substs.needs_infer() && !instance.substs.has_param_types_or_consts());\n+        assert!(!instance.substs.needs_infer());\n \n         let fn_abi = FnAbi::of_instance(self, instance, &[]);\n         self.linkage.set(base::linkage_to_gcc(linkage));"}, {"sha": "2ff2ee7b8522651b28b851a90c15cdb84686ce04", "filename": "src/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/src%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftype_of.rs?ref=48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267", "patch": "@@ -4,9 +4,9 @@ use gccjit::{Struct, Type};\n use crate::rustc_codegen_ssa::traits::{BaseTypeMethods, DerivedTypeMethods, LayoutTypeMethods};\n use rustc_middle::bug;\n use rustc_middle::ty::{self, Ty, TypeFoldable};\n-use rustc_middle::ty::layout::{FnAbiExt, TyAndLayout};\n+use rustc_middle::ty::layout::{FnAbiExt, LayoutOf, TyAndLayout};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_target::abi::{self, Abi, F32, F64, FieldsShape, Int, Integer, LayoutOf, Pointer, PointeeInfo, Size, TyAndLayoutMethods, Variants};\n+use rustc_target::abi::{self, Abi, F32, F64, FieldsShape, Int, Integer, Pointer, PointeeInfo, Size, TyAbiInterface, Variants};\n use rustc_target::abi::call::{CastTarget, FnAbi, Reg};\n \n use crate::abi::{FnAbiGccExt, GccType};\n@@ -308,7 +308,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n             return pointee;\n         }\n \n-        let result = Ty::pointee_info_at(*self, cx, offset);\n+        let result = Ty::ty_and_layout_pointee_info_at(*self, cx, offset);\n \n         cx.pointee_infos.borrow_mut().insert((self.ty, offset), result);\n         result"}, {"sha": "12df1f8af2f0b2be40d274c4e44809fe8365b4fb", "filename": "test.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/test.sh", "raw_url": "https://github.com/rust-lang/rust/raw/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267/test.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test.sh?ref=48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267", "patch": "@@ -146,6 +146,7 @@ rm config.toml || true\n cat > config.toml <<EOF\n [rust]\n codegen-backends = []\n+deny-warnings = false\n \n [build]\n cargo = \"$(which cargo)\""}]}