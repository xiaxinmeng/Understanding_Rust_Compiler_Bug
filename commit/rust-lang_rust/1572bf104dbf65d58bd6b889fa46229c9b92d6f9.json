{"sha": "1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NzJiZjEwNGRiZjY1ZDU4YmQ2Yjg4OWZhNDYyMjljOWI5MmQ2Zjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-25T12:29:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-25T12:29:32Z"}, "message": "Auto merge of #40091 - eddyb:rollup, r=eddyb\n\nRollup of 28 pull requests\n\n- Successful merges: #39859, #39864, #39888, #39903, #39905, #39914, #39945, #39950, #39953, #39961, #39980, #39988, #39993, #39995, #40019, #40020, #40022, #40024, #40025, #40026, #40027, #40031, #40035, #40037, #40038, #40064, #40069, #40086\n- Failed merges: #39927, #40008, #40047", "tree": {"sha": "0cd0f02c7a7634ab5e86d2e14f74aeaf4758382e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cd0f02c7a7634ab5e86d2e14f74aeaf4758382e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "html_url": "https://github.com/rust-lang/rust/commit/1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e78aa5d7546d5db493ec12328368ab0c249c2a94", "url": "https://api.github.com/repos/rust-lang/rust/commits/e78aa5d7546d5db493ec12328368ab0c249c2a94", "html_url": "https://github.com/rust-lang/rust/commit/e78aa5d7546d5db493ec12328368ab0c249c2a94"}, {"sha": "207c76306037776c0e72456d5a0497e430c6753c", "url": "https://api.github.com/repos/rust-lang/rust/commits/207c76306037776c0e72456d5a0497e430c6753c", "html_url": "https://github.com/rust-lang/rust/commit/207c76306037776c0e72456d5a0497e430c6753c"}], "stats": {"total": 2056, "additions": 1520, "deletions": 536}, "files": [{"sha": "a996240f61650fa4e1af52feb76da79d2d9e2c65", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -68,6 +68,7 @@ fn main() {\n     };\n     let stage = env::var(\"RUSTC_STAGE\").expect(\"RUSTC_STAGE was not set\");\n     let sysroot = env::var_os(\"RUSTC_SYSROOT\").expect(\"RUSTC_SYSROOT was not set\");\n+    let mut on_fail = env::var_os(\"RUSTC_ON_FAIL\").map(|of| Command::new(of));\n \n     let rustc = env::var_os(rustc).unwrap_or_else(|| panic!(\"{:?} was not set\", rustc));\n     let libdir = env::var_os(libdir).unwrap_or_else(|| panic!(\"{:?} was not set\", libdir));\n@@ -217,9 +218,20 @@ fn main() {\n     }\n \n     // Actually run the compiler!\n-    std::process::exit(match exec_cmd(&mut cmd) {\n-        Ok(s) => s.code().unwrap_or(0xfe),\n-        Err(e) => panic!(\"\\n\\nfailed to run {:?}: {}\\n\\n\", cmd, e),\n+    std::process::exit(if let Some(ref mut on_fail) = on_fail {\n+        match cmd.status() {\n+            Ok(s) if s.success() => 0,\n+            _ => {\n+                println!(\"\\nDid not run successfully:\\n{:?}\\n-------------\", cmd);\n+                exec_cmd(on_fail).expect(\"could not run the backup command\");\n+                1\n+            }\n+        }\n+    } else {\n+        std::process::exit(match exec_cmd(&mut cmd) {\n+            Ok(s) => s.code().unwrap_or(0xfe),\n+            Err(e) => panic!(\"\\n\\nfailed to run {:?}: {}\\n\\n\", cmd, e),\n+        })\n     })\n }\n "}, {"sha": "c1ee0c29ac981376a42e09e0554dd90266c3dc40", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -355,8 +355,12 @@ def build_bootstrap(self):\n         env = os.environ.copy()\n         env[\"CARGO_TARGET_DIR\"] = build_dir\n         env[\"RUSTC\"] = self.rustc()\n-        env[\"LD_LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\")\n-        env[\"DYLD_LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\")\n+        env[\"LD_LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\") + \\\n+                                 (os.pathsep + env[\"LD_LIBRARY_PATH\"]) \\\n+                                 if \"LD_LIBRARY_PATH\" in env else \"\"\n+        env[\"DYLD_LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\") + \\\n+                                   (os.pathsep + env[\"DYLD_LIBRARY_PATH\"]) \\\n+                                   if \"DYLD_LIBRARY_PATH\" in env else \"\"\n         env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n                       os.pathsep + env[\"PATH\"]\n         if not os.path.isfile(self.cargo()):\n@@ -485,6 +489,8 @@ def build_triple(self):\n             ostype += 'abi64'\n         elif cputype in {'powerpc', 'ppc', 'ppc64'}:\n             cputype = 'powerpc'\n+        elif cputype == 'sparcv9':\n+            pass\n         elif cputype in {'amd64', 'x86_64', 'x86-64', 'x64'}:\n             cputype = 'x86_64'\n         else:"}, {"sha": "b55f3d710ca7bfcee4643dd40d4e6836dc495503", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -28,6 +28,7 @@ use step;\n /// Deserialized version of all flags for this compile.\n pub struct Flags {\n     pub verbose: usize, // verbosity level: 0 == not verbose, 1 == verbose, 2 == very verbose\n+    pub on_fail: Option<String>,\n     pub stage: Option<u32>,\n     pub keep_stage: Option<u32>,\n     pub build: String,\n@@ -81,6 +82,7 @@ impl Flags {\n         opts.optopt(\"\", \"build\", \"build target of the stage0 compiler\", \"BUILD\");\n         opts.optmulti(\"\", \"host\", \"host targets to build\", \"HOST\");\n         opts.optmulti(\"\", \"target\", \"target targets to build\", \"TARGET\");\n+        opts.optopt(\"\", \"on-fail\", \"command to run on failure\", \"CMD\");\n         opts.optopt(\"\", \"stage\", \"stage to build\", \"N\");\n         opts.optopt(\"\", \"keep-stage\", \"stage to keep without recompiling\", \"N\");\n         opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n@@ -283,6 +285,7 @@ To learn more about a subcommand, run `./x.py <command> -h`\n         Flags {\n             verbose: m.opt_count(\"v\"),\n             stage: stage,\n+            on_fail: m.opt_str(\"on-fail\"),\n             keep_stage: m.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),\n             build: m.opt_str(\"build\").unwrap_or_else(|| {\n                 env::var(\"BUILD\").unwrap()"}, {"sha": "2b34142b3b0f37681fff0214262f6a106419078d", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -499,6 +499,10 @@ impl Build {\n             cargo.env(\"RUSTC_INCREMENTAL\", incr_dir);\n         }\n \n+        if let Some(ref on_fail) = self.flags.on_fail {\n+            cargo.env(\"RUSTC_ON_FAIL\", on_fail);\n+        }\n+\n         let verbose = cmp::max(self.config.verbose, self.flags.verbose);\n         cargo.env(\"RUSTC_VERBOSE\", format!(\"{}\", verbose));\n \n@@ -828,17 +832,6 @@ impl Build {\n         if target.contains(\"apple-darwin\") {\n             base.push(\"-stdlib=libc++\".into());\n         }\n-        // This is a hack, because newer binutils broke things on some vms/distros\n-        // (i.e., linking against unknown relocs disabled by the following flag)\n-        // See: https://github.com/rust-lang/rust/issues/34978\n-        match target {\n-            \"i586-unknown-linux-gnu\" |\n-            \"i686-unknown-linux-musl\" |\n-            \"x86_64-unknown-linux-musl\" => {\n-                base.push(\"-Wa,-mrelax-relocations=no\".into());\n-            },\n-            _ => {},\n-        }\n         return base\n     }\n "}, {"sha": "e935226e361fbdd765151ced072e9c0e0e79320d", "filename": "src/ci/docker/linux-tested-targets/Dockerfile", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Fci%2Fdocker%2Flinux-tested-targets%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Fci%2Fdocker%2Flinux-tested-targets%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Flinux-tested-targets%2FDockerfile?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -34,6 +34,14 @@ ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-x86_64=/musl-x86_64 \\\n       --musl-root-i686=/musl-i686\n \n+# Newer binutils broke things on some vms/distros (i.e., linking against\n+# unknown relocs disabled by the following flag), so we need to go out of our\n+# way to produce \"super compatible\" binaries.\n+#\n+# See: https://github.com/rust-lang/rust/issues/34978\n+ENV CFLAGS_i686_unknown_linux_gnu=-Wa,-mrelax-relocations=no \\\n+    CFLAGS_x86_64_unknown_linux_gnu=-Wa,-mrelax-relocations=no\n+\n ENV SCRIPT \\\n       python2.7 ../x.py test \\\n           --target x86_64-unknown-linux-musl \\"}, {"sha": "ce62c392241d8306ee5c4f543453d2def07a1f07", "filename": "src/ci/docker/linux-tested-targets/build-musl.sh", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Fci%2Fdocker%2Flinux-tested-targets%2Fbuild-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Fci%2Fdocker%2Flinux-tested-targets%2Fbuild-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Flinux-tested-targets%2Fbuild-musl.sh?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -11,7 +11,10 @@\n \n set -ex\n \n-export CFLAGS=\"-fPIC\"\n+# We need to mitigate rust-lang/rust#34978 when compiling musl itself as well\n+export CFLAGS=\"-fPIC -Wa,-mrelax-relocations=no\"\n+export CXXFLAGS=\"-Wa,-mrelax-relocations=no\"\n+\n MUSL=musl-1.1.14\n curl https://www.musl-libc.org/releases/$MUSL.tar.gz | tar xzf -\n cd $MUSL"}, {"sha": "32539c2d01f6dcd9e9488cfae80f02f0be929db6", "filename": "src/doc/nomicon/src/phantom-data.md", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Fdoc%2Fnomicon%2Fsrc%2Fphantom-data.md", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Fdoc%2Fnomicon%2Fsrc%2Fphantom-data.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Fphantom-data.md?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -82,5 +82,23 @@ standard library made a utility for itself called `Unique<T>` which:\n \n * wraps a `*const T` for variance\n * includes a `PhantomData<T>`\n-* auto-derives Send/Sync as if T was contained\n-* marks the pointer as NonZero for the null-pointer optimization\n+* auto-derives `Send`/`Sync` as if T was contained\n+* marks the pointer as `NonZero` for the null-pointer optimization\n+\n+## Table of `PhantomData` patterns\n+\n+Here\u2019s a table of all the wonderful ways `PhantomData` could be used:\n+\n+| Phantom type                | `'a`      | `T`                       |\n+|-----------------------------|-----------|---------------------------|\n+| `PhantomData<T>`            | -         | variant (with drop check) |\n+| `PhantomData<&'a T>`        | variant   | variant                   |\n+| `PhantomData<&'a mut T>`    | variant   | invariant                 |\n+| `PhantomData<*const T>`     | -         | variant                   |\n+| `PhantomData<*mut T>`       | -         | invariant                 |\n+| `PhantomData<fn(T)>`        | -         | contravariant (*)         |\n+| `PhantomData<fn() -> T>`    | -         | variant                   |\n+| `PhantomData<fn(T) -> T>`   | -         | invariant                 |\n+| `PhantomData<Cell<&'a ()>>` | invariant | -                         |\n+\n+(*) If contravariance gets scrapped, this would be invariant."}, {"sha": "16ecf88256670233c9f1f543ebe05f46f11abd61", "filename": "src/libcompiler_builtins/build.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibcompiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibcompiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Fbuild.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -92,7 +92,15 @@ fn main() {\n         // compiler-rt's build system already\n         cfg.flag(\"-fno-builtin\");\n         cfg.flag(\"-fvisibility=hidden\");\n-        cfg.flag(\"-fomit-frame-pointer\");\n+        // Accepted practice on Solaris is to never omit frame pointer so that\n+        // system observability tools work as expected.  In addition, at least\n+        // on Solaris, -fomit-frame-pointer on sparcv9 appears to generate\n+        // references to data outside of the current stack frame.  A search of\n+        // the gcc bug database provides a variety of issues surrounding\n+        // -fomit-frame-pointer on non-x86 platforms.\n+        if !target.contains(\"solaris\") && !target.contains(\"sparc\") {\n+            cfg.flag(\"-fomit-frame-pointer\");\n+        }\n         cfg.flag(\"-ffreestanding\");\n         cfg.define(\"VISIBILITY_HIDDEN\", None);\n     }"}, {"sha": "64d954c6a76e896fbf7ed5c17e77c40e388abe84", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -1 +1 @@\n-Subproject commit 7a3754f2bb5e65eb39adacb189c3626173032177\n+Subproject commit 64d954c6a76e896fbf7ed5c17e77c40e388abe84"}, {"sha": "122543aee40eca45178cf1b84ab1cf77d0bb269c", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -220,15 +220,24 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 // Note that `break` and `continue` statements\n                 // may cause additional edges.\n \n-                // Is the condition considered part of the loop?\n                 let loopback = self.add_dummy_node(&[pred]);              // 1\n-                let cond_exit = self.expr(&cond, loopback);             // 2\n-                let expr_exit = self.add_ast_node(expr.id, &[cond_exit]); // 3\n+\n+                // Create expr_exit without pred (cond_exit)\n+                let expr_exit = self.add_ast_node(expr.id, &[]);         // 3\n+\n+                // The LoopScope needs to be on the loop_scopes stack while evaluating the\n+                // condition and the body of the loop (both can break out of the loop)\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     continue_index: loopback,\n                     break_index: expr_exit\n                 });\n+\n+                let cond_exit = self.expr(&cond, loopback);             // 2\n+\n+                // Add pred (cond_exit) to expr_exit\n+                self.add_contained_edge(cond_exit, expr_exit);\n+\n                 let body_exit = self.block(&body, cond_exit);          // 4\n                 self.add_contained_edge(body_exit, loopback);            // 5\n                 self.loop_scopes.pop();\n@@ -294,17 +303,17 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_unreachable_node()\n             }\n \n-            hir::ExprBreak(label, ref opt_expr) => {\n+            hir::ExprBreak(destination, ref opt_expr) => {\n                 let v = self.opt_expr(opt_expr, pred);\n-                let loop_scope = self.find_scope(expr, label);\n+                let loop_scope = self.find_scope(expr, destination);\n                 let b = self.add_ast_node(expr.id, &[v]);\n                 self.add_exiting_edge(expr, b,\n                                       loop_scope, loop_scope.break_index);\n                 self.add_unreachable_node()\n             }\n \n-            hir::ExprAgain(label) => {\n-                let loop_scope = self.find_scope(expr, label);\n+            hir::ExprAgain(destination) => {\n+                let loop_scope = self.find_scope(expr, destination);\n                 let a = self.add_ast_node(expr.id, &[pred]);\n                 self.add_exiting_edge(expr, a,\n                                       loop_scope, loop_scope.continue_index);\n@@ -579,17 +588,18 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n     fn find_scope(&self,\n                   expr: &hir::Expr,\n-                  label: Option<hir::Label>) -> LoopScope {\n-        match label {\n-            None => *self.loop_scopes.last().unwrap(),\n-            Some(label) => {\n+                  destination: hir::Destination) -> LoopScope {\n+\n+        match destination.loop_id.into() {\n+            Ok(loop_id) => {\n                 for l in &self.loop_scopes {\n-                    if l.loop_id == label.loop_id {\n+                    if l.loop_id == loop_id {\n                         return *l;\n                     }\n                 }\n-                span_bug!(expr.span, \"no loop scope for id {}\", label.loop_id);\n+                span_bug!(expr.span, \"no loop scope for id {}\", loop_id);\n             }\n+            Err(err) => span_bug!(expr.span, \"loop scope error: {}\",  err)\n         }\n     }\n }"}, {"sha": "aedb8fef2885cf461cca140334147a030940e891", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -11,6 +11,7 @@\n use hir::def_id::DefId;\n use util::nodemap::NodeMap;\n use syntax::ast;\n+use syntax::ext::base::MacroKind;\n use hir;\n \n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -53,7 +54,7 @@ pub enum Def {\n     Label(ast::NodeId),\n \n     // Macro namespace\n-    Macro(DefId),\n+    Macro(DefId, MacroKind),\n \n     // Both namespaces\n     Err,\n@@ -141,7 +142,7 @@ impl Def {\n             Def::Variant(id) | Def::VariantCtor(id, ..) | Def::Enum(id) | Def::TyAlias(id) |\n             Def::AssociatedTy(id) | Def::TyParam(id) | Def::Struct(id) | Def::StructCtor(id, ..) |\n             Def::Union(id) | Def::Trait(id) | Def::Method(id) | Def::Const(id) |\n-            Def::AssociatedConst(id) | Def::Local(id) | Def::Upvar(id, ..) | Def::Macro(id) => {\n+            Def::AssociatedConst(id) | Def::Local(id) | Def::Upvar(id, ..) | Def::Macro(id, ..) => {\n                 id\n             }\n "}, {"sha": "fd6796ccc0bf2b0cd6b7957281a960c99322ff4c", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -1006,18 +1006,22 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprPath(ref qpath) => {\n             visitor.visit_qpath(qpath, expression.id, expression.span);\n         }\n-        ExprBreak(None, ref opt_expr) => {\n+        ExprBreak(label, ref opt_expr) => {\n+            label.ident.map(|ident| {\n+                if let Ok(loop_id) = label.loop_id.into() {\n+                    visitor.visit_def_mention(Def::Label(loop_id));\n+                }\n+                visitor.visit_name(ident.span, ident.node.name);\n+            });\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n-        ExprBreak(Some(label), ref opt_expr) => {\n-            visitor.visit_def_mention(Def::Label(label.loop_id));\n-            visitor.visit_name(label.span, label.name);\n-            walk_list!(visitor, visit_expr, opt_expr);\n-        }\n-        ExprAgain(None) => {}\n-        ExprAgain(Some(label)) => {\n-            visitor.visit_def_mention(Def::Label(label.loop_id));\n-            visitor.visit_name(label.span, label.name);\n+        ExprAgain(label) => {\n+            label.ident.map(|ident| {\n+                if let Ok(loop_id) = label.loop_id.into() {\n+                    visitor.visit_def_mention(Def::Label(loop_id));\n+                }\n+                visitor.visit_name(ident.span, ident.node.name);\n+            });\n         }\n         ExprRet(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);"}, {"sha": "8572119e9891691d43220f4d57d5bd916bccada4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 134, "deletions": 38, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -50,6 +50,7 @@ use util::nodemap::{DefIdMap, NodeMap, FxHashMap};\n \n use std::collections::BTreeMap;\n use std::iter;\n+use std::mem;\n \n use syntax::attr;\n use syntax::ast::*;\n@@ -79,6 +80,9 @@ pub struct LoweringContext<'a> {\n     impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n     bodies: FxHashMap<hir::BodyId, hir::Body>,\n \n+    loop_scopes: Vec<NodeId>,\n+    is_in_loop_condition: bool,\n+\n     type_def_lifetime_params: DefIdMap<usize>,\n }\n \n@@ -112,6 +116,8 @@ pub fn lower_crate(sess: &Session,\n         trait_items: BTreeMap::new(),\n         impl_items: BTreeMap::new(),\n         bodies: FxHashMap(),\n+        loop_scopes: Vec::new(),\n+        is_in_loop_condition: false,\n         type_def_lifetime_params: DefIdMap(),\n     }.lower_crate(krate)\n }\n@@ -244,6 +250,55 @@ impl<'a> LoweringContext<'a> {\n         span\n     }\n \n+    fn with_loop_scope<T, F>(&mut self, loop_id: NodeId, f: F) -> T\n+        where F: FnOnce(&mut LoweringContext) -> T\n+    {\n+        // We're no longer in the base loop's condition; we're in another loop.\n+        let was_in_loop_condition = self.is_in_loop_condition;\n+        self.is_in_loop_condition = false;\n+\n+        let len = self.loop_scopes.len();\n+        self.loop_scopes.push(loop_id);\n+\n+        let result = f(self);\n+        assert_eq!(len + 1, self.loop_scopes.len(),\n+            \"Loop scopes should be added and removed in stack order\");\n+\n+        self.loop_scopes.pop().unwrap();\n+\n+        self.is_in_loop_condition = was_in_loop_condition;\n+\n+        result\n+    }\n+\n+    fn with_loop_condition_scope<T, F>(&mut self, f: F) -> T\n+        where F: FnOnce(&mut LoweringContext) -> T\n+    {\n+        let was_in_loop_condition = self.is_in_loop_condition;\n+        self.is_in_loop_condition = true;\n+\n+        let result = f(self);\n+\n+        self.is_in_loop_condition = was_in_loop_condition;\n+\n+        result\n+    }\n+\n+    fn with_new_loop_scopes<T, F>(&mut self, f: F) -> T\n+        where F: FnOnce(&mut LoweringContext) -> T\n+    {\n+        let was_in_loop_condition = self.is_in_loop_condition;\n+        self.is_in_loop_condition = false;\n+\n+        let loop_scopes = mem::replace(&mut self.loop_scopes, Vec::new());\n+        let result = f(self);\n+        mem::replace(&mut self.loop_scopes, loop_scopes);\n+\n+        self.is_in_loop_condition = was_in_loop_condition;\n+\n+        result\n+    }\n+\n     fn with_parent_def<T, F>(&mut self, parent_id: NodeId, f: F) -> T\n         where F: FnOnce(&mut LoweringContext) -> T\n     {\n@@ -271,17 +326,24 @@ impl<'a> LoweringContext<'a> {\n         o_id.map(|sp_ident| respan(sp_ident.span, sp_ident.node.name))\n     }\n \n-    fn lower_label(&mut self, id: NodeId, label: Option<Spanned<Ident>>) -> Option<hir::Label> {\n-        label.map(|sp_ident| {\n-            hir::Label {\n-                span: sp_ident.span,\n-                name: sp_ident.node.name,\n-                loop_id: match self.expect_full_def(id) {\n-                    Def::Label(loop_id) => loop_id,\n-                    _ => DUMMY_NODE_ID\n+    fn lower_destination(&mut self, destination: Option<(NodeId, Spanned<Ident>)>)\n+        -> hir::Destination\n+    {\n+        match destination {\n+            Some((id, label_ident)) => hir::Destination {\n+                ident: Some(label_ident),\n+                loop_id: if let Def::Label(loop_id) = self.expect_full_def(id) {\n+                    hir::LoopIdResult::Ok(loop_id)\n+                } else {\n+                    hir::LoopIdResult::Err(hir::LoopIdError::UnresolvedLabel)\n                 }\n+            },\n+            None => hir::Destination {\n+                ident: None,\n+                loop_id: self.loop_scopes.last().map(|innermost_loop_id| Ok(*innermost_loop_id))\n+                            .unwrap_or(Err(hir::LoopIdError::OutsideLoopScope)).into()\n             }\n-        })\n+        }\n     }\n \n     fn lower_attrs(&mut self, attrs: &Vec<Attribute>) -> hir::HirVec<Attribute> {\n@@ -992,15 +1054,17 @@ impl<'a> LoweringContext<'a> {\n                                self.record_body(value, None))\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n-                let body = self.lower_block(body);\n-                let body = self.expr_block(body, ThinVec::new());\n-                let body_id = self.record_body(body, Some(decl));\n-                hir::ItemFn(self.lower_fn_decl(decl),\n-                            self.lower_unsafety(unsafety),\n-                            self.lower_constness(constness),\n-                            abi,\n-                            self.lower_generics(generics),\n-                            body_id)\n+                self.with_new_loop_scopes(|this| {\n+                    let body = this.lower_block(body);\n+                    let body = this.expr_block(body, ThinVec::new());\n+                    let body_id = this.record_body(body, Some(decl));\n+                    hir::ItemFn(this.lower_fn_decl(decl),\n+                                              this.lower_unsafety(unsafety),\n+                                              this.lower_constness(constness),\n+                                              abi,\n+                                              this.lower_generics(generics),\n+                                              body_id)\n+                })\n             }\n             ItemKind::Mod(ref m) => hir::ItemMod(self.lower_mod(m)),\n             ItemKind::ForeignMod(ref nm) => hir::ItemForeignMod(self.lower_foreign_mod(nm)),\n@@ -1562,26 +1626,32 @@ impl<'a> LoweringContext<'a> {\n                     hir::ExprIf(P(self.lower_expr(cond)), self.lower_block(blk), else_opt)\n                 }\n                 ExprKind::While(ref cond, ref body, opt_ident) => {\n-                    hir::ExprWhile(P(self.lower_expr(cond)), self.lower_block(body),\n-                                   self.lower_opt_sp_ident(opt_ident))\n+                    self.with_loop_scope(e.id, |this|\n+                        hir::ExprWhile(\n+                            this.with_loop_condition_scope(|this| P(this.lower_expr(cond))),\n+                            this.lower_block(body),\n+                            this.lower_opt_sp_ident(opt_ident)))\n                 }\n                 ExprKind::Loop(ref body, opt_ident) => {\n-                    hir::ExprLoop(self.lower_block(body),\n-                                  self.lower_opt_sp_ident(opt_ident),\n-                                  hir::LoopSource::Loop)\n+                    self.with_loop_scope(e.id, |this|\n+                        hir::ExprLoop(this.lower_block(body),\n+                                      this.lower_opt_sp_ident(opt_ident),\n+                                      hir::LoopSource::Loop))\n                 }\n                 ExprKind::Match(ref expr, ref arms) => {\n                     hir::ExprMatch(P(self.lower_expr(expr)),\n                                    arms.iter().map(|x| self.lower_arm(x)).collect(),\n                                    hir::MatchSource::Normal)\n                 }\n                 ExprKind::Closure(capture_clause, ref decl, ref body, fn_decl_span) => {\n-                    self.with_parent_def(e.id, |this| {\n-                        let expr = this.lower_expr(body);\n-                        hir::ExprClosure(this.lower_capture_clause(capture_clause),\n-                                         this.lower_fn_decl(decl),\n-                                         this.record_body(expr, Some(decl)),\n-                                         fn_decl_span)\n+                    self.with_new_loop_scopes(|this| {\n+                        this.with_parent_def(e.id, |this| {\n+                            let expr = this.lower_expr(body);\n+                            hir::ExprClosure(this.lower_capture_clause(capture_clause),\n+                                             this.lower_fn_decl(decl),\n+                                             this.record_body(expr, Some(decl)),\n+                                             fn_decl_span)\n+                        })\n                     })\n                 }\n                 ExprKind::Block(ref blk) => hir::ExprBlock(self.lower_block(blk)),\n@@ -1660,10 +1730,29 @@ impl<'a> LoweringContext<'a> {\n                     hir::ExprPath(self.lower_qpath(e.id, qself, path, ParamMode::Optional))\n                 }\n                 ExprKind::Break(opt_ident, ref opt_expr) => {\n-                    hir::ExprBreak(self.lower_label(e.id, opt_ident),\n-                                   opt_expr.as_ref().map(|x| P(self.lower_expr(x))))\n+                    let label_result = if self.is_in_loop_condition && opt_ident.is_none() {\n+                        hir::Destination {\n+                            ident: opt_ident,\n+                            loop_id: Err(hir::LoopIdError::UnlabeledCfInWhileCondition).into(),\n+                        }\n+                    } else {\n+                        self.lower_destination(opt_ident.map(|ident| (e.id, ident)))\n+                    };\n+                    hir::ExprBreak(\n+                            label_result,\n+                            opt_expr.as_ref().map(|x| P(self.lower_expr(x))))\n                 }\n-                ExprKind::Continue(opt_ident) => hir::ExprAgain(self.lower_label(e.id, opt_ident)),\n+                ExprKind::Continue(opt_ident) =>\n+                    hir::ExprAgain(\n+                        if self.is_in_loop_condition && opt_ident.is_none() {\n+                            hir::Destination {\n+                                ident: opt_ident,\n+                                loop_id: Err(\n+                                    hir::LoopIdError::UnlabeledCfInWhileCondition).into(),\n+                            }\n+                        } else {\n+                            self.lower_destination(opt_ident.map( |ident| (e.id, ident)))\n+                        }),\n                 ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| P(self.lower_expr(x)))),\n                 ExprKind::InlineAsm(ref asm) => {\n                     let hir_asm = hir::InlineAsm {\n@@ -1804,9 +1893,16 @@ impl<'a> LoweringContext<'a> {\n                     //     }\n                     //   }\n \n+                    // Note that the block AND the condition are evaluated in the loop scope.\n+                    // This is done to allow `break` from inside the condition of the loop.\n+                    let (body, break_expr, sub_expr) = self.with_loop_scope(e.id, |this| (\n+                        this.lower_block(body),\n+                        this.expr_break(e.span, ThinVec::new()),\n+                        this.with_loop_condition_scope(|this| P(this.lower_expr(sub_expr))),\n+                    ));\n+\n                     // `<pat> => <body>`\n                     let pat_arm = {\n-                        let body = self.lower_block(body);\n                         let body_expr = P(self.expr_block(body, ThinVec::new()));\n                         let pat = self.lower_pat(pat);\n                         self.arm(hir_vec![pat], body_expr)\n@@ -1815,13 +1911,11 @@ impl<'a> LoweringContext<'a> {\n                     // `_ => break`\n                     let break_arm = {\n                         let pat_under = self.pat_wild(e.span);\n-                        let break_expr = self.expr_break(e.span, ThinVec::new());\n                         self.arm(hir_vec![pat_under], break_expr)\n                     };\n \n                     // `match <sub_expr> { ... }`\n                     let arms = hir_vec![pat_arm, break_arm];\n-                    let sub_expr = P(self.lower_expr(sub_expr));\n                     let match_expr = self.expr(e.span,\n                                                hir::ExprMatch(sub_expr,\n                                                               arms,\n@@ -1863,7 +1957,7 @@ impl<'a> LoweringContext<'a> {\n \n                     // `::std::option::Option::Some(<pat>) => <body>`\n                     let pat_arm = {\n-                        let body_block = self.lower_block(body);\n+                        let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body));\n                         let body_expr = P(self.expr_block(body_block, ThinVec::new()));\n                         let pat = self.lower_pat(pat);\n                         let some_pat = self.pat_some(e.span, pat);\n@@ -1873,7 +1967,8 @@ impl<'a> LoweringContext<'a> {\n \n                     // `::std::option::Option::None => break`\n                     let break_arm = {\n-                        let break_expr = self.expr_break(e.span, ThinVec::new());\n+                        let break_expr = self.with_loop_scope(e.id, |this|\n+                            this.expr_break(e.span, ThinVec::new()));\n                         let pat = self.pat_none(e.span);\n                         self.arm(hir_vec![pat], break_expr)\n                     };\n@@ -2151,7 +2246,8 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr_break(&mut self, span: Span, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n-        P(self.expr(span, hir::ExprBreak(None, None), attrs))\n+        let expr_break = hir::ExprBreak(self.lower_destination(None), None);\n+        P(self.expr(span, expr_break, attrs))\n     }\n \n     fn expr_call(&mut self, span: Span, e: P<hir::Expr>, args: hir::HirVec<hir::Expr>)"}, {"sha": "e8c5f2447cd6f5a15ffd9e62b4a267f2b798e16a", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 51, "deletions": 7, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -36,7 +36,7 @@ use util::nodemap::{NodeMap, FxHashMap, FxHashSet};\n use syntax_pos::{Span, ExpnId, DUMMY_SP};\n use syntax::codemap::{self, Spanned};\n use syntax::abi::Abi;\n-use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n+use syntax::ast::{Ident, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n@@ -959,9 +959,9 @@ pub enum Expr_ {\n     /// A referencing operation (`&a` or `&mut a`)\n     ExprAddrOf(Mutability, P<Expr>),\n     /// A `break`, with an optional label to break\n-    ExprBreak(Option<Label>, Option<P<Expr>>),\n+    ExprBreak(Destination, Option<P<Expr>>),\n     /// A `continue`, with an optional label\n-    ExprAgain(Option<Label>),\n+    ExprAgain(Destination),\n     /// A `return`, with an optional value to be returned\n     ExprRet(Option<P<Expr>>),\n \n@@ -1030,12 +1030,56 @@ pub enum LoopSource {\n     ForLoop,\n }\n \n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum LoopIdError {\n+    OutsideLoopScope,\n+    UnlabeledCfInWhileCondition,\n+    UnresolvedLabel,\n+}\n+\n+impl fmt::Display for LoopIdError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(match *self {\n+            LoopIdError::OutsideLoopScope => \"not inside loop scope\",\n+            LoopIdError::UnlabeledCfInWhileCondition =>\n+                \"unlabeled control flow (break or continue) in while condition\",\n+            LoopIdError::UnresolvedLabel => \"label not found\",\n+        }, f)\n+    }\n+}\n \n+// FIXME(cramertj) this should use `Result` once master compiles w/ a vesion of Rust where\n+// `Result` implements `Encodable`/`Decodable`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub struct Label {\n-    pub span: Span,\n-    pub name: Name,\n-    pub loop_id: NodeId\n+pub enum LoopIdResult {\n+    Ok(NodeId),\n+    Err(LoopIdError),\n+}\n+impl Into<Result<NodeId, LoopIdError>> for LoopIdResult {\n+    fn into(self) -> Result<NodeId, LoopIdError> {\n+        match self {\n+            LoopIdResult::Ok(ok) => Ok(ok),\n+            LoopIdResult::Err(err) => Err(err),\n+        }\n+    }\n+}\n+impl From<Result<NodeId, LoopIdError>> for LoopIdResult {\n+    fn from(res: Result<NodeId, LoopIdError>) -> Self {\n+        match res {\n+            Ok(ok) => LoopIdResult::Ok(ok),\n+            Err(err) => LoopIdResult::Err(err),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub struct Destination {\n+    // This is `Some(_)` iff there is an explicit user-specified `label\n+    pub ident: Option<Spanned<Ident>>,\n+\n+    // These errors are caught and then reported during the diagnostics pass in\n+    // librustc_passes/loops.rs\n+    pub loop_id: LoopIdResult,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]"}, {"sha": "3411de9bb5df11356b753f08bb2c49c5946c74f4", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -1354,23 +1354,23 @@ impl<'a> State<'a> {\n             hir::ExprPath(ref qpath) => {\n                 self.print_qpath(qpath, true)?\n             }\n-            hir::ExprBreak(opt_label, ref opt_expr) => {\n+            hir::ExprBreak(label, ref opt_expr) => {\n                 word(&mut self.s, \"break\")?;\n                 space(&mut self.s)?;\n-                if let Some(label) = opt_label {\n-                    self.print_name(label.name)?;\n+                if let Some(label_ident) = label.ident {\n+                    self.print_name(label_ident.node.name)?;\n                     space(&mut self.s)?;\n                 }\n                 if let Some(ref expr) = *opt_expr {\n                     self.print_expr(expr)?;\n                     space(&mut self.s)?;\n                 }\n             }\n-            hir::ExprAgain(opt_label) => {\n+            hir::ExprAgain(label) => {\n                 word(&mut self.s, \"continue\")?;\n                 space(&mut self.s)?;\n-                if let Some(label) = opt_label {\n-                    self.print_name(label.name)?;\n+                if let Some(label_ident) = label.ident {\n+                    self.print_name(label_ident.node.name)?;\n                     space(&mut self.s)?\n                 }\n             }"}, {"sha": "f48ff87689fb0a375b171d9faf31cc2e09f8dfb0", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -379,40 +379,41 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                          values: Option<ValuePairs<'tcx>>,\n                          terr: &TypeError<'tcx>)\n     {\n-        let expected_found = match values {\n-            None => None,\n-            Some(values) => match self.values_str(&values) {\n-                Some((expected, found)) => Some((expected, found)),\n-                None => {\n-                    // Derived error. Cancel the emitter.\n-                    self.tcx.sess.diagnostic().cancel(diag);\n-                    return\n-                }\n+        let (expected_found, is_simple_error) = match values {\n+            None => (None, false),\n+            Some(values) => {\n+                let is_simple_error = match values {\n+                    ValuePairs::Types(exp_found) => {\n+                        exp_found.expected.is_primitive() && exp_found.found.is_primitive()\n+                    }\n+                    _ => false,\n+                };\n+                let vals = match self.values_str(&values) {\n+                    Some((expected, found)) => Some((expected, found)),\n+                    None => {\n+                        // Derived error. Cancel the emitter.\n+                        self.tcx.sess.diagnostic().cancel(diag);\n+                        return\n+                    }\n+                };\n+                (vals, is_simple_error)\n             }\n         };\n \n         let span = cause.span;\n \n         if let Some((expected, found)) = expected_found {\n-            let is_simple_error = if let &TypeError::Sorts(ref values) = terr {\n-                values.expected.is_primitive() && values.found.is_primitive()\n-            } else {\n-                false\n-            };\n-\n-            if !is_simple_error {\n-                if expected == found {\n-                    if let &TypeError::Sorts(ref values) = terr {\n-                        diag.note_expected_found_extra(\n-                            &\"type\", &expected, &found,\n-                            &format!(\" ({})\", values.expected.sort_string(self.tcx)),\n-                            &format!(\" ({})\", values.found.sort_string(self.tcx)));\n-                    } else {\n-                        diag.note_expected_found(&\"type\", &expected, &found);\n-                    }\n-                } else {\n+            match (terr, is_simple_error, expected == found) {\n+                (&TypeError::Sorts(ref values), false,  true) => {\n+                    diag.note_expected_found_extra(\n+                        &\"type\", &expected, &found,\n+                        &format!(\" ({})\", values.expected.sort_string(self.tcx)),\n+                        &format!(\" ({})\", values.found.sort_string(self.tcx)));\n+                }\n+                (_, false,  _) => {\n                     diag.note_expected_found(&\"type\", &expected, &found);\n                 }\n+                _ => (),\n             }\n         }\n "}, {"sha": "a44679b0b3e0e5cab0389ca356159c4960e46c29", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -715,6 +715,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 adjustment::Adjust::NeverToAny |\n                 adjustment::Adjust::ReifyFnPointer |\n                 adjustment::Adjust::UnsafeFnPointer |\n+                adjustment::Adjust::ClosureFnPointer |\n                 adjustment::Adjust::MutToConstPointer => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue."}, {"sha": "b7f7c49d7b0e36bb2cc007b13103c927ab005d54", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -675,23 +675,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn find_loop_scope(&self,\n-                       opt_label: Option<hir::Label>,\n-                       sp: Span)\n-                       -> NodeId {\n-        match opt_label {\n-            Some(label) => label.loop_id,\n-            None => {\n-                // Vanilla 'break' or 'continue', so use the enclosing\n-                // loop scope\n-                if self.loop_scope.is_empty() {\n-                    span_bug!(sp, \"break outside loop\");\n-                } else {\n-                    *self.loop_scope.last().unwrap()\n-                }\n-            }\n-        }\n-    }\n \n     #[allow(unused_must_use)]\n     fn ln_str(&self, ln: LiveNode) -> String {\n@@ -1018,9 +1001,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_opt_expr(o_e.as_ref().map(|e| &**e), exit_ln)\n           }\n \n-          hir::ExprBreak(opt_label, ref opt_expr) => {\n+          hir::ExprBreak(label, ref opt_expr) => {\n               // Find which label this break jumps to\n-              let sc = self.find_loop_scope(opt_label, expr.span);\n+              let sc = match label.loop_id.into() {\n+                  Ok(loop_id) => loop_id,\n+                  Err(err) => span_bug!(expr.span, \"loop scope error: {}\", err),\n+              };\n \n               // Now that we know the label we're going to,\n               // look it up in the break loop nodes table\n@@ -1031,9 +1017,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               }\n           }\n \n-          hir::ExprAgain(opt_label) => {\n+          hir::ExprAgain(label) => {\n               // Find which label this expr continues to\n-              let sc = self.find_loop_scope(opt_label, expr.span);\n+              let sc = match label.loop_id.into() {\n+                  Ok(loop_id) => loop_id,\n+                  Err(err) => span_bug!(expr.span, \"loop scope error: {}\", err),\n+              };\n+\n \n               // Now that we know the label we're going to,\n               // look it up in the continue loop nodes table\n@@ -1297,12 +1287,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         debug!(\"propagate_through_loop: using id for loop body {} {}\",\n                expr.id, self.ir.tcx.hir.node_to_pretty_string(body.id));\n \n-        let cond_ln = match kind {\n-            LoopLoop => ln,\n-            WhileLoop(ref cond) => self.propagate_through_expr(&cond, ln),\n-        };\n-        let body_ln = self.with_loop_nodes(expr.id, succ, ln, |this| {\n-            this.propagate_through_block(body, cond_ln)\n+        let (cond_ln, body_ln) = self.with_loop_nodes(expr.id, succ, ln, |this| {\n+            let cond_ln = match kind {\n+                LoopLoop => ln,\n+                WhileLoop(ref cond) => this.propagate_through_expr(&cond, ln),\n+            };\n+            let body_ln = this.propagate_through_block(body, cond_ln);\n+            (cond_ln, body_ln)\n         });\n \n         // repeat until fixed point is reached:"}, {"sha": "b0c85e2ef4cd48438df7796f250cc04dd45ad477", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -464,6 +464,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                     adjustment::Adjust::NeverToAny |\n                     adjustment::Adjust::ReifyFnPointer |\n                     adjustment::Adjust::UnsafeFnPointer |\n+                    adjustment::Adjust::ClosureFnPointer |\n                     adjustment::Adjust::MutToConstPointer |\n                     adjustment::Adjust::DerefRef {..} => {\n                         debug!(\"cat_expr({:?}): {:?}\","}, {"sha": "d2a657e35b54ad6351cb672c4e16013bb6860b57", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -1022,6 +1022,9 @@ pub enum CastKind {\n     /// Convert unique, zero-sized type for a fn to fn()\n     ReifyFnPointer,\n \n+    /// Convert non capturing closure to fn()\n+    ClosureFnPointer,\n+\n     /// Convert safe fn() to unsafe fn()\n     UnsafeFnPointer,\n "}, {"sha": "5fff03dabcecef2f41fe9cb57169f51db6eae4d9", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 41, "deletions": 32, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -51,7 +51,7 @@ pub struct Config {\n     pub uint_type: UintTy,\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Hash)]\n pub enum Sanitizer {\n     Address,\n     Leak,\n@@ -288,7 +288,7 @@ top_level_options!(\n         //            much sense: The search path can stay the same while the\n         //            things discovered there might have changed on disk.\n         search_paths: SearchPaths [TRACKED],\n-        libs: Vec<(String, Option<String>, cstore::NativeLibraryKind)> [TRACKED],\n+        libs: Vec<(String, Option<String>, Option<cstore::NativeLibraryKind>)> [TRACKED],\n         maybe_sysroot: Option<PathBuf> [TRACKED],\n \n         target_triple: String [TRACKED],\n@@ -804,6 +804,8 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n         \"save all temporary output files during compilation\"),\n     rpath: bool = (false, parse_bool, [UNTRACKED],\n         \"set rpath values in libs/exes\"),\n+    overflow_checks: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"use overflow checks for integer arithmetic\"),\n     no_prepopulate_passes: bool = (false, parse_bool, [TRACKED],\n         \"don't pre-populate the pass manager with a list of passes\"),\n     no_vectorize_loops: bool = (false, parse_bool, [TRACKED],\n@@ -970,7 +972,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"encode MIR of all functions into the crate metadata\"),\n     osx_rpath_install_name: bool = (false, parse_bool, [TRACKED],\n           \"pass `-install_name @rpath/...` to the OSX linker\"),\n-    sanitizer: Option<Sanitizer> = (None, parse_sanitizer, [UNTRACKED],\n+    sanitizer: Option<Sanitizer> = (None, parse_sanitizer, [TRACKED],\n                                    \"Use a sanitizer\"),\n }\n \n@@ -1495,18 +1497,18 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         let mut parts = s.splitn(2, '=');\n         let kind = parts.next().unwrap();\n         let (name, kind) = match (parts.next(), kind) {\n-            (None, name) |\n-            (Some(name), \"dylib\") => (name, cstore::NativeUnknown),\n-            (Some(name), \"framework\") => (name, cstore::NativeFramework),\n-            (Some(name), \"static\") => (name, cstore::NativeStatic),\n-            (Some(name), \"static-nobundle\") => (name, cstore::NativeStaticNobundle),\n+            (None, name) => (name, None),\n+            (Some(name), \"dylib\") => (name, Some(cstore::NativeUnknown)),\n+            (Some(name), \"framework\") => (name, Some(cstore::NativeFramework)),\n+            (Some(name), \"static\") => (name, Some(cstore::NativeStatic)),\n+            (Some(name), \"static-nobundle\") => (name, Some(cstore::NativeStaticNobundle)),\n             (_, s) => {\n                 early_error(error_format, &format!(\"unknown library kind `{}`, expected \\\n                                                   one of dylib, framework, or static\",\n                                                  s));\n             }\n         };\n-        if kind == cstore::NativeStaticNobundle && !nightly_options::is_nightly_build() {\n+        if kind == Some(cstore::NativeStaticNobundle) && !nightly_options::is_nightly_build() {\n             early_error(error_format, &format!(\"the library kind 'static-nobundle' is only \\\n                                                 accepted on the nightly compiler\"));\n         }\n@@ -1728,7 +1730,7 @@ mod dep_tracking {\n     use std::path::PathBuf;\n     use std::collections::hash_map::DefaultHasher;\n     use super::{Passes, CrateType, OptLevel, DebugInfoLevel,\n-                OutputTypes, Externs, ErrorOutputType};\n+                OutputTypes, Externs, ErrorOutputType, Sanitizer};\n     use syntax::feature_gate::UnstableFeatures;\n     use rustc_back::PanicStrategy;\n \n@@ -1772,6 +1774,7 @@ mod dep_tracking {\n     impl_dep_tracking_hash_via_hash!(Option<PanicStrategy>);\n     impl_dep_tracking_hash_via_hash!(Option<lint::Level>);\n     impl_dep_tracking_hash_via_hash!(Option<PathBuf>);\n+    impl_dep_tracking_hash_via_hash!(Option<cstore::NativeLibraryKind>);\n     impl_dep_tracking_hash_via_hash!(CrateType);\n     impl_dep_tracking_hash_via_hash!(PanicStrategy);\n     impl_dep_tracking_hash_via_hash!(Passes);\n@@ -1781,12 +1784,14 @@ mod dep_tracking {\n     impl_dep_tracking_hash_via_hash!(Externs);\n     impl_dep_tracking_hash_via_hash!(OutputTypes);\n     impl_dep_tracking_hash_via_hash!(cstore::NativeLibraryKind);\n+    impl_dep_tracking_hash_via_hash!(Sanitizer);\n+    impl_dep_tracking_hash_via_hash!(Option<Sanitizer>);\n \n     impl_dep_tracking_hash_for_sortable_vec_of!(String);\n     impl_dep_tracking_hash_for_sortable_vec_of!(CrateType);\n     impl_dep_tracking_hash_for_sortable_vec_of!((String, lint::Level));\n     impl_dep_tracking_hash_for_sortable_vec_of!((String, Option<String>,\n-                                                 cstore::NativeLibraryKind));\n+                                                 Option<cstore::NativeLibraryKind>));\n     impl DepTrackingHash for SearchPaths {\n         fn hash(&self, hasher: &mut DefaultHasher, _: ErrorOutputType) {\n             let mut elems: Vec<_> = self\n@@ -2230,24 +2235,24 @@ mod tests {\n         let mut v4 = super::basic_options();\n \n         // Reference\n-        v1.libs = vec![(String::from(\"a\"), None, cstore::NativeStatic),\n-                       (String::from(\"b\"), None, cstore::NativeFramework),\n-                       (String::from(\"c\"), None, cstore::NativeUnknown)];\n+        v1.libs = vec![(String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+                       (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n+                       (String::from(\"c\"), None, Some(cstore::NativeUnknown))];\n \n         // Change label\n-        v2.libs = vec![(String::from(\"a\"), None, cstore::NativeStatic),\n-                       (String::from(\"X\"), None, cstore::NativeFramework),\n-                       (String::from(\"c\"), None, cstore::NativeUnknown)];\n+        v2.libs = vec![(String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+                       (String::from(\"X\"), None, Some(cstore::NativeFramework)),\n+                       (String::from(\"c\"), None, Some(cstore::NativeUnknown))];\n \n         // Change kind\n-        v3.libs = vec![(String::from(\"a\"), None, cstore::NativeStatic),\n-                       (String::from(\"b\"), None, cstore::NativeStatic),\n-                       (String::from(\"c\"), None, cstore::NativeUnknown)];\n+        v3.libs = vec![(String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+                       (String::from(\"b\"), None, Some(cstore::NativeStatic)),\n+                       (String::from(\"c\"), None, Some(cstore::NativeUnknown))];\n \n         // Change new-name\n-        v4.libs = vec![(String::from(\"a\"), None, cstore::NativeStatic),\n-                       (String::from(\"b\"), Some(String::from(\"X\")), cstore::NativeFramework),\n-                       (String::from(\"c\"), None, cstore::NativeUnknown)];\n+        v4.libs = vec![(String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+                       (String::from(\"b\"), Some(String::from(\"X\")), Some(cstore::NativeFramework)),\n+                       (String::from(\"c\"), None, Some(cstore::NativeUnknown))];\n \n         assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n         assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n@@ -2267,17 +2272,17 @@ mod tests {\n         let mut v3 = super::basic_options();\n \n         // Reference\n-        v1.libs = vec![(String::from(\"a\"), None, cstore::NativeStatic),\n-                       (String::from(\"b\"), None, cstore::NativeFramework),\n-                       (String::from(\"c\"), None, cstore::NativeUnknown)];\n+        v1.libs = vec![(String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+                       (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n+                       (String::from(\"c\"), None, Some(cstore::NativeUnknown))];\n \n-        v2.libs = vec![(String::from(\"b\"), None, cstore::NativeFramework),\n-                       (String::from(\"a\"), None, cstore::NativeStatic),\n-                       (String::from(\"c\"), None, cstore::NativeUnknown)];\n+        v2.libs = vec![(String::from(\"b\"), None, Some(cstore::NativeFramework)),\n+                       (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+                       (String::from(\"c\"), None, Some(cstore::NativeUnknown))];\n \n-        v3.libs = vec![(String::from(\"c\"), None, cstore::NativeUnknown),\n-                       (String::from(\"a\"), None, cstore::NativeStatic),\n-                       (String::from(\"b\"), None, cstore::NativeFramework)];\n+        v3.libs = vec![(String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+                       (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+                       (String::from(\"b\"), None, Some(cstore::NativeFramework))];\n \n         assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n         assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());\n@@ -2345,6 +2350,10 @@ mod tests {\n         opts.cg.llvm_args = vec![String::from(\"1\"), String::from(\"2\")];\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n \n+        opts = reference.clone();\n+        opts.cg.overflow_checks = Some(true);\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n         opts = reference.clone();\n         opts.cg.no_prepopulate_passes = true;\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());"}, {"sha": "68edcc60779a10d86be6cc85e8ebdc9428e3453b", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -372,6 +372,11 @@ impl Session {\n     pub fn nonzeroing_move_hints(&self) -> bool {\n         self.opts.debugging_opts.enable_nonzeroing_move_hints\n     }\n+    pub fn overflow_checks(&self) -> bool {\n+        self.opts.cg.overflow_checks\n+            .or(self.opts.debugging_opts.force_overflow_checks)\n+            .unwrap_or(self.opts.debug_assertions)\n+    }\n \n     pub fn must_not_eliminate_frame_pointers(&self) -> bool {\n         self.opts.debuginfo != DebugInfoLevel::NoDebugInfo ||"}, {"sha": "34977822bc69d8c8600105e7989ce5eed8e7c01f", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -33,6 +33,9 @@ pub enum Adjust<'tcx> {\n     /// Go from a safe fn pointer to an unsafe fn pointer.\n     UnsafeFnPointer,\n \n+    // Go from a non-capturing closure to an fn pointer.\n+    ClosureFnPointer,\n+\n     /// Go from a mut raw pointer to a const raw pointer.\n     MutToConstPointer,\n \n@@ -120,6 +123,7 @@ impl<'tcx> Adjustment<'tcx> {\n \n             Adjust::ReifyFnPointer |\n             Adjust::UnsafeFnPointer |\n+            Adjust::ClosureFnPointer |\n             Adjust::MutToConstPointer |\n             Adjust::DerefRef {..} => false,\n         }"}, {"sha": "0c179469448fef7a917db711b8a5f4c01c49e944", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -200,6 +200,7 @@ supported_targets! {\n     (\"armv7s-apple-ios\", armv7s_apple_ios),\n \n     (\"x86_64-sun-solaris\", x86_64_sun_solaris),\n+    (\"sparcv9-sun-solaris\", sparcv9_sun_solaris),\n \n     (\"x86_64-pc-windows-gnu\", x86_64_pc_windows_gnu),\n     (\"i686-pc-windows-gnu\", i686_pc_windows_gnu),"}, {"sha": "c88e5a402f2f545e0719b0178848d9314730368d", "filename": "src/librustc_back/target/sparcv9_sun_solaris.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_back%2Ftarget%2Fsparcv9_sun_solaris.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_back%2Ftarget%2Fsparcv9_sun_solaris.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fsparcv9_sun_solaris.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::{Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::solaris_base::opts();\n+    base.pre_link_args.push(\"-m64\".to_string());\n+    // llvm calls this \"v9\"\n+    base.cpu = \"v9\".to_string();\n+    base.max_atomic_width = Some(64);\n+\n+    Ok(Target {\n+        llvm_target: \"sparcv9-sun-solaris\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        data_layout: \"E-m:e-i64:64-n32:64-S128\".to_string(),\n+        // Use \"sparc64\" instead of \"sparcv9\" here, since the former is already\n+        // used widely in the source base.  If we ever needed ABI\n+        // differentiation from the sparc64, we could, but that would probably\n+        // just be confusing.\n+        arch: \"sparc64\".to_string(),\n+        target_os: \"solaris\".to_string(),\n+        target_env: \"\".to_string(),\n+        target_vendor: \"sun\".to_string(),\n+        options: base,\n+    })\n+}"}, {"sha": "5a9f885719c8fd8ab52e425218d1621600bb513a", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 62, "deletions": 30, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -196,6 +196,28 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n             }\n         }).clone()\n     }\n+\n+    fn is_uninhabited(&self, ty: Ty<'tcx>) -> bool {\n+        if self.tcx.sess.features.borrow().never_type {\n+            ty.is_uninhabited_from(self.module, self.tcx)\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn is_variant_uninhabited(&self,\n+                              variant: &'tcx ty::VariantDef,\n+                              substs: &'tcx ty::subst::Substs<'tcx>) -> bool\n+    {\n+        if self.tcx.sess.features.borrow().never_type {\n+            let forest = variant.uninhabited_from(\n+                &mut FxHashMap::default(), self.tcx, substs, AdtKind::Enum\n+            );\n+            forest.contains(self.tcx, self.module)\n+        } else {\n+            false\n+        }\n+    }\n }\n \n #[derive(Clone, Debug, PartialEq)]\n@@ -379,48 +401,32 @@ impl<'tcx> Witness<'tcx> {\n fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                   pcx: PatternContext<'tcx>) -> Vec<Constructor>\n {\n-    let check_inhabited = cx.tcx.sess.features.borrow().never_type;\n     debug!(\"all_constructors({:?})\", pcx.ty);\n     match pcx.ty.sty {\n         ty::TyBool =>\n             [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n         ty::TySlice(ref sub_ty) => {\n-            if sub_ty.is_uninhabited_from(cx.module, cx.tcx)\n-                && check_inhabited\n-            {\n+            if cx.is_uninhabited(sub_ty) {\n                 vec![Slice(0)]\n             } else {\n                 (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect()\n             }\n         }\n         ty::TyArray(ref sub_ty, length) => {\n-            if length == 0 || !(sub_ty.is_uninhabited_from(cx.module, cx.tcx)\n-                                && check_inhabited)\n-            {\n-                vec![Slice(length)]\n-            } else {\n+            if length > 0 && cx.is_uninhabited(sub_ty) {\n                 vec![]\n+            } else {\n+                vec![Slice(length)]\n             }\n         }\n         ty::TyAdt(def, substs) if def.is_enum() && def.variants.len() != 1 => {\n-            def.variants.iter().filter_map(|v| {\n-                let mut visited = FxHashMap::default();\n-                let forest = v.uninhabited_from(&mut visited,\n-                                                cx.tcx, substs,\n-                                                AdtKind::Enum);\n-                if forest.contains(cx.tcx, cx.module)\n-                    && check_inhabited\n-                {\n-                    None\n-                } else {\n-                    Some(Variant(v.did))\n-                }\n-            }).collect()\n+            def.variants.iter()\n+                .filter(|v| !cx.is_variant_uninhabited(v, substs))\n+                .map(|v| Variant(v.did))\n+                .collect()\n         }\n         _ => {\n-            if pcx.ty.is_uninhabited_from(cx.module, cx.tcx)\n-                    && check_inhabited\n-            {\n+            if cx.is_uninhabited(pcx.ty) {\n                 vec![]\n             } else {\n                 vec![Single]\n@@ -564,7 +570,6 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n \n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n-\n     let pcx = PatternContext {\n         ty: rows.iter().map(|r| r[0].ty).find(|ty| !ty.references_error())\n             .unwrap_or(v[0].ty),\n@@ -590,7 +595,6 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         let missing_ctors: Vec<Constructor> = all_ctors.iter().filter(|c| {\n             !used_ctors.contains(*c)\n         }).cloned().collect();\n-        debug!(\"missing_ctors = {:?}\", missing_ctors);\n \n         // `missing_ctors` is the set of constructors from the same type as the\n         // first column of `matrix` that are matched only by wildcard patterns\n@@ -599,8 +603,23 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         // Therefore, if there is some pattern that is unmatched by `matrix`,\n         // it will still be unmatched if the first constructor is replaced by\n         // any of the constructors in `missing_ctors`\n-\n-        if missing_ctors.is_empty() {\n+        //\n+        // However, if our scrutinee is *privately* an empty enum, we\n+        // must treat it as though it had an \"unknown\" constructor (in\n+        // that case, all other patterns obviously can't be variants)\n+        // to avoid exposing its emptyness. See the `match_privately_empty`\n+        // test for details.\n+        //\n+        // FIXME: currently the only way I know of something can\n+        // be a privately-empty enum is when the never_type\n+        // feature flag is not present, so this is only\n+        // needed for that case.\n+\n+        let is_privately_empty =\n+            all_ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n+        debug!(\"missing_ctors={:?} is_privately_empty={:?}\", missing_ctors,\n+               is_privately_empty);\n+        if missing_ctors.is_empty() && !is_privately_empty {\n             all_ctors.into_iter().map(|c| {\n                 is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n             }).find(|result| result.is_useful()).unwrap_or(NotUseful)\n@@ -649,6 +668,7 @@ fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n     lty: Ty<'tcx>,\n     witness: WitnessPreference) -> Usefulness<'tcx>\n {\n+    debug!(\"is_useful_specialized({:?}, {:?}, {:?})\", v, ctor, lty);\n     let sub_pat_tys = constructor_sub_pattern_tys(cx, &ctor, lty);\n     let wild_patterns_owned: Vec<_> = sub_pat_tys.iter().map(|ty| {\n         Pattern {\n@@ -754,7 +774,19 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n         ty::TyRef(_, ref ty_and_mut) => vec![ty_and_mut.ty],\n         ty::TyAdt(adt, substs) => {\n             adt.variants[ctor.variant_index_for_adt(adt)].fields.iter().map(|field| {\n-                field.ty(cx.tcx, substs)\n+                let is_visible = adt.is_enum()\n+                    || field.vis.is_accessible_from(cx.module, cx.tcx);\n+                if is_visible {\n+                    field.ty(cx.tcx, substs)\n+                } else {\n+                    // Treat all non-visible fields as nil. They\n+                    // can't appear in any other pattern from\n+                    // this match (because they are private),\n+                    // so their type does not matter - but\n+                    // we don't want to know they are\n+                    // uninhabited.\n+                    cx.tcx.mk_nil()\n+                }\n             }).collect()\n         }\n         _ => vec![],"}, {"sha": "9b30946c0bebbc1d834cd9cdd045352dbd76be28", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -177,6 +177,31 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             // Fourth, check for unreachable arms.\n             check_arms(cx, &inlined_arms, source);\n \n+            // Then, if the match has no arms, check whether the scrutinee\n+            // is uninhabited.\n+            let pat_ty = self.tables.node_id_to_type(scrut.id);\n+            let module = self.tcx.hir.local_def_id(self.tcx.hir.get_module_parent(scrut.id));\n+            if inlined_arms.is_empty() {\n+                let scrutinee_is_uninhabited = if self.tcx.sess.features.borrow().never_type {\n+                    pat_ty.is_uninhabited_from(module, self.tcx)\n+                } else {\n+                    self.conservative_is_uninhabited(pat_ty)\n+                };\n+                if !scrutinee_is_uninhabited {\n+                    // We know the type is inhabited, so this must be wrong\n+                    let mut err = create_e0004(self.tcx.sess, scrut.span,\n+                                               format!(\"non-exhaustive patterns: type {} \\\n+                                                        is non-empty\",\n+                                                       pat_ty));\n+                    span_help!(&mut err, scrut.span,\n+                               \"Please ensure that all possible cases are being handled; \\\n+                                possibly adding wildcards or more match arms.\");\n+                    err.emit();\n+                }\n+                // If the type *is* uninhabited, it's vacuously exhaustive\n+                return;\n+            }\n+\n             let matrix: Matrix = inlined_arms\n                 .iter()\n                 .filter(|&&(_, guard)| guard.is_none())\n@@ -188,6 +213,15 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n         })\n     }\n \n+    fn conservative_is_uninhabited(&self, scrutinee_ty: Ty<'tcx>) -> bool {\n+        // \"rustc-1.0-style\" uncontentious uninhabitableness check\n+        match scrutinee_ty.sty {\n+            ty::TyNever => true,\n+            ty::TyAdt(def, _) => def.variants.is_empty(),\n+            _ => false\n+        }\n+    }\n+\n     fn check_irrefutable(&self, pat: &Pat, is_fn_arg: bool) {\n         let origin = if is_fn_arg {\n             \"function argument\""}, {"sha": "486900fc2fed5a21adb731d9e416f1294c4d5d00", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -63,8 +63,7 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n                hash_spans: bool,\n                hash_bodies: bool)\n                -> Self {\n-        let check_overflow = tcx.sess.opts.debugging_opts.force_overflow_checks\n-            .unwrap_or(tcx.sess.opts.debug_assertions);\n+        let check_overflow = tcx.sess.overflow_checks();\n \n         StrictVersionHashVisitor {\n             st: st,\n@@ -338,8 +337,10 @@ fn saw_expr<'a>(node: &'a Expr_,\n         ExprIndex(..)            => (SawExprIndex, true),\n         ExprPath(_)              => (SawExprPath, false),\n         ExprAddrOf(m, _)         => (SawExprAddrOf(m), false),\n-        ExprBreak(label, _)      => (SawExprBreak(label.map(|l| l.name.as_str())), false),\n-        ExprAgain(label)         => (SawExprAgain(label.map(|l| l.name.as_str())), false),\n+        ExprBreak(label, _)      => (SawExprBreak(label.ident.map(|i|\n+                                                    i.node.name.as_str())), false),\n+        ExprAgain(label)         => (SawExprAgain(label.ident.map(|i|\n+                                                    i.node.name.as_str())), false),\n         ExprRet(..)              => (SawExprRet, false),\n         ExprInlineAsm(ref a,..)  => (SawExprInlineAsm(StableInlineAsm(a)), false),\n         ExprStruct(..)           => (SawExprStruct, false),"}, {"sha": "673f1ae10843cc4c70bdae676192ff8ee7d0a755", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -23,6 +23,11 @@ use super::directory::DefPathIndex;\n pub struct SerializedDepGraph {\n     pub edges: Vec<SerializedEdgeSet>,\n \n+    /// These are output nodes that have no incoming edges. We track\n+    /// these separately so that when we reload all edges, we don't\n+    /// lose track of these nodes.\n+    pub bootstrap_outputs: Vec<DepNode<DefPathIndex>>,\n+\n     /// These are hashes of two things:\n     /// - the HIR nodes in this crate\n     /// - the metadata nodes from dependent crates we use"}, {"sha": "03411e01a57980e4be577309158eaa431dff956e", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -184,6 +184,18 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n+    // Recreate bootstrap outputs, which are outputs that have no incoming edges (and hence cannot\n+    // be dirty).\n+    for bootstrap_output in &serialized_dep_graph.bootstrap_outputs {\n+        if let Some(n) = retraced.map(bootstrap_output) {\n+            if let DepNode::WorkProduct(ref wp) = n {\n+                clean_work_products.insert(wp.clone());\n+            }\n+\n+            tcx.dep_graph.with_task(n, || ()); // create the node with no inputs\n+        }\n+    }\n+\n     // Subtle. Sometimes we have intermediate nodes that we can't recreate in the new graph.\n     // This is pretty unusual but it arises in a scenario like this:\n     //"}, {"sha": "f6a37c7a12265469ec0fe9319c3cc814406ba66c", "filename": "src/librustc_incremental/persist/preds/mod.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -11,7 +11,7 @@\n use rustc::dep_graph::{DepGraphQuery, DepNode};\n use rustc::hir::def_id::DefId;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::graph::Graph;\n+use rustc_data_structures::graph::{Graph, NodeIndex};\n \n use super::hash::*;\n use ich::Fingerprint;\n@@ -28,6 +28,14 @@ pub struct Predecessors<'query> {\n     // of the graph down.\n     pub reduced_graph: Graph<&'query DepNode<DefId>, ()>,\n \n+    // These are output nodes that have no incoming edges. We have to\n+    // track these specially because, when we load the data back up\n+    // again, we want to make sure and recreate these nodes (we want\n+    // to recreate the nodes where all incoming edges are clean; but\n+    // since we ordinarily just serialize edges, we wind up just\n+    // forgetting that bootstrap outputs even exist in that case.)\n+    pub bootstrap_outputs: Vec<&'query DepNode<DefId>>,\n+\n     // For the inputs (hir/foreign-metadata), we include hashes.\n     pub hashes: FxHashMap<&'query DepNode<DefId>, Fingerprint>,\n }\n@@ -57,7 +65,7 @@ impl<'q> Predecessors<'q> {\n \n         // Reduce the graph to the most important nodes.\n         let compress::Reduction { graph, input_nodes } =\n-            compress::reduce_graph(&query.graph, HashContext::is_hashable, is_output);\n+            compress::reduce_graph(&query.graph, HashContext::is_hashable, |n| is_output(n));\n \n         let mut hashes = FxHashMap();\n         for input_index in input_nodes {\n@@ -67,8 +75,17 @@ impl<'q> Predecessors<'q> {\n                   .or_insert_with(|| hcx.hash(input).unwrap());\n         }\n \n+        let bootstrap_outputs: Vec<&'q DepNode<DefId>> =\n+            (0 .. graph.len_nodes())\n+            .map(NodeIndex)\n+            .filter(|&n| graph.incoming_edges(n).next().is_none())\n+            .map(|n| *graph.node_data(n))\n+            .filter(|n| is_output(n))\n+            .collect();\n+\n         Predecessors {\n             reduced_graph: graph,\n+            bootstrap_outputs: bootstrap_outputs,\n             hashes: hashes,\n         }\n     }"}, {"sha": "dfa6bf6bbb5e721d4a1596b109cffd314e4e7ccd", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -204,11 +204,15 @@ pub fn encode_dep_graph(preds: &Predecessors,\n     }\n \n     // Create the serialized dep-graph.\n+    let bootstrap_outputs = preds.bootstrap_outputs.iter()\n+                                                   .map(|n| builder.map(n))\n+                                                   .collect();\n     let edges = edges.into_iter()\n                      .map(|(k, v)| SerializedEdgeSet { source: k, targets: v })\n                      .collect();\n     let graph = SerializedDepGraph {\n-        edges: edges,\n+        bootstrap_outputs,\n+        edges,\n         hashes: preds.hashes\n             .iter()\n             .map(|(&dep_node, &hash)| {\n@@ -221,6 +225,7 @@ pub fn encode_dep_graph(preds: &Predecessors,\n     };\n \n     if tcx.sess.opts.debugging_opts.incremental_info {\n+        println!(\"incremental: {} nodes in reduced dep-graph\", preds.reduced_graph.len_nodes());\n         println!(\"incremental: {} edges in serialized dep-graph\", graph.edges.len());\n         println!(\"incremental: {} hashes in serialized dep-graph\", graph.hashes.len());\n     }"}, {"sha": "4477488f6cb38bf68b52ef7a345bd107774cf7d6", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -1077,10 +1077,20 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n             let mut found = false;\n             for lib in self.cstore.get_used_libraries().borrow_mut().iter_mut() {\n                 if lib.name == name as &str {\n-                    lib.kind = kind;\n+                    let mut changed = false;\n+                    if let Some(k) = kind {\n+                        lib.kind = k;\n+                        changed = true;\n+                    }\n                     if let &Some(ref new_name) = new_name {\n                         lib.name = Symbol::intern(new_name);\n+                        changed = true;\n+                    }\n+                    if !changed {\n+                        self.sess.warn(&format!(\"redundant linker flag specified for library `{}`\",\n+                                                name));\n                     }\n+\n                     found = true;\n                 }\n             }\n@@ -1089,7 +1099,7 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n                 let new_name = new_name.as_ref().map(|s| &**s); // &Option<String> -> Option<&str>\n                 let lib = NativeLibrary {\n                     name: Symbol::intern(new_name.unwrap_or(name)),\n-                    kind: kind,\n+                    kind: if let Some(k) = kind { k } else { cstore::NativeUnknown },\n                     cfg: None,\n                     foreign_items: Vec::new(),\n                 };"}, {"sha": "53883e50a5be283e5b0c1e92fef21f6531e72c6b", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -39,6 +39,7 @@ use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n use syntax::ast;\n use syntax::codemap;\n+use syntax::ext::base::MacroKind;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP};\n \n pub struct DecodeContext<'a, 'tcx: 'a> {\n@@ -434,7 +435,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Variant(_) => Def::Variant(did),\n             EntryKind::Trait(_) => Def::Trait(did),\n             EntryKind::Enum(..) => Def::Enum(did),\n-            EntryKind::MacroDef(_) => Def::Macro(did),\n+            EntryKind::MacroDef(_) => Def::Macro(did, MacroKind::Bang),\n \n             EntryKind::ForeignMod |\n             EntryKind::Impl(_) |\n@@ -483,9 +484,11 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_def(&self, index: DefIndex) -> Option<Def> {\n-        match self.is_proc_macro(index) {\n-            true => Some(Def::Macro(self.local_def_id(index))),\n-            false => self.entry(index).kind.to_def(self.local_def_id(index)),\n+        if !self.is_proc_macro(index) {\n+            self.entry(index).kind.to_def(self.local_def_id(index))\n+        } else {\n+            let kind = self.proc_macros.as_ref().unwrap()[index.as_usize() - 1].1.kind();\n+            Some(Def::Macro(self.local_def_id(index), kind))\n         }\n     }\n \n@@ -688,8 +691,14 @@ impl<'a, 'tcx> CrateMetadata {\n     {\n         if let Some(ref proc_macros) = self.proc_macros {\n             if id == CRATE_DEF_INDEX {\n-                for (id, &(name, _)) in proc_macros.iter().enumerate() {\n-                    let def = Def::Macro(DefId { krate: self.cnum, index: DefIndex::new(id + 1) });\n+                for (id, &(name, ref ext)) in proc_macros.iter().enumerate() {\n+                    let def = Def::Macro(\n+                        DefId {\n+                            krate: self.cnum,\n+                            index: DefIndex::new(id + 1)\n+                        },\n+                        ext.kind()\n+                    );\n                     callback(def::Export { name: name, def: def });\n                 }\n             }"}, {"sha": "5abfe084f22581b646aaec8cecbdcd2b55d363a9", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -99,6 +99,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Use { .. } |\n             ExprKind::NeverToAny { .. } |\n             ExprKind::ReifyFnPointer { .. } |\n+            ExprKind::ClosureFnPointer { .. } |\n             ExprKind::UnsafeFnPointer { .. } |\n             ExprKind::Unsize { .. } |\n             ExprKind::Repeat { .. } |"}, {"sha": "7f5d9c36ecedf3221c93521987e8cd249dcb1b91", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -112,6 +112,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let source = unpack!(block = this.as_operand(block, source));\n                 block.and(Rvalue::Cast(CastKind::UnsafeFnPointer, source, expr.ty))\n             }\n+            ExprKind::ClosureFnPointer { source } => {\n+                let source = unpack!(block = this.as_operand(block, source));\n+                block.and(Rvalue::Cast(CastKind::ClosureFnPointer, source, expr.ty))\n+            }\n             ExprKind::Unsize { source } => {\n                 let source = unpack!(block = this.as_operand(block, source));\n                 block.and(Rvalue::Cast(CastKind::Unsize, source, expr.ty))"}, {"sha": "35173bb598c7cfc0384a81a487a4c57ab3f13173", "filename": "src/librustc_mir/build/expr/category.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -70,6 +70,7 @@ impl Category {\n             ExprKind::Cast { .. } |\n             ExprKind::Use { .. } |\n             ExprKind::ReifyFnPointer { .. } |\n+            ExprKind::ClosureFnPointer { .. } |\n             ExprKind::UnsafeFnPointer { .. } |\n             ExprKind::Unsize { .. } |\n             ExprKind::Repeat { .. } |"}, {"sha": "d9f71e36e211861592102781070c3f92e0e0f8d2", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -244,6 +244,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Cast { .. } |\n             ExprKind::Use { .. } |\n             ExprKind::ReifyFnPointer { .. } |\n+            ExprKind::ClosureFnPointer { .. } |\n             ExprKind::UnsafeFnPointer { .. } |\n             ExprKind::Unsize { .. } |\n             ExprKind::Repeat { .. } |"}, {"sha": "282361fc13e27054f37a759ff1793de2004cead4", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -385,22 +385,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// resolving `break` and `continue`.\n     pub fn find_loop_scope(&mut self,\n                            span: Span,\n-                           label: Option<CodeExtent>)\n+                           label: CodeExtent)\n                            -> &mut LoopScope<'tcx> {\n-        let loop_scopes = &mut self.loop_scopes;\n-        match label {\n-            None => {\n-                // no label? return the innermost loop scope\n-                loop_scopes.iter_mut().rev().next()\n-            }\n-            Some(label) => {\n-                // otherwise, find the loop-scope with the correct id\n-                loop_scopes.iter_mut()\n-                           .rev()\n-                           .filter(|loop_scope| loop_scope.extent == label)\n-                           .next()\n-            }\n-        }.unwrap_or_else(|| span_bug!(span, \"no enclosing loop scope found?\"))\n+        // find the loop-scope with the correct id\n+        self.loop_scopes.iter_mut()\n+            .rev()\n+            .filter(|loop_scope| loop_scope.extent == label)\n+            .next()\n+            .unwrap_or_else(|| span_bug!(span, \"no enclosing loop scope found?\"))\n     }\n \n     /// Given a span and the current visibility scope, make a SourceInfo."}, {"sha": "dd45b1b48960713737da584cb52cc252dabe786c", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -60,6 +60,15 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     kind: ExprKind::UnsafeFnPointer { source: expr.to_ref() },\n                 };\n             }\n+            Some((ty::adjustment::Adjust::ClosureFnPointer, adjusted_ty)) => {\n+                expr = Expr {\n+                    temp_lifetime: temp_lifetime,\n+                    temp_lifetime_was_shrunk: was_shrunk,\n+                    ty: adjusted_ty,\n+                    span: self.span,\n+                    kind: ExprKind::ClosureFnPointer { source: expr.to_ref() },\n+                };\n+            }\n             Some((ty::adjustment::Adjust::NeverToAny, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n@@ -605,14 +614,21 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n         hir::ExprRet(ref v) => ExprKind::Return { value: v.to_ref() },\n         hir::ExprBreak(label, ref value) => {\n-            ExprKind::Break {\n-                label: label.map(|label| cx.tcx.region_maps.node_extent(label.loop_id)),\n-                value: value.to_ref(),\n+            match label.loop_id.into() {\n+                Ok(loop_id) => ExprKind::Break {\n+                    label: cx.tcx.region_maps.node_extent(loop_id),\n+                    value: value.to_ref(),\n+                },\n+                Err(err) => bug!(\"invalid loop id for break: {}\", err)\n             }\n+\n         }\n         hir::ExprAgain(label) => {\n-            ExprKind::Continue {\n-                label: label.map(|label| cx.tcx.region_maps.node_extent(label.loop_id)),\n+            match label.loop_id.into() {\n+                Ok(loop_id) => ExprKind::Continue {\n+                    label: cx.tcx.region_maps.node_extent(loop_id),\n+                },\n+                Err(err) => bug!(\"invalid loop id for continue: {}\", err)\n             }\n         }\n         hir::ExprMatch(ref discr, ref arms, _) => {"}, {"sha": "852c34a544a97acc2a3be7db561d021bf2c8598c", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -59,13 +59,8 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         let mut check_overflow = attrs.iter()\n             .any(|item| item.check_name(\"rustc_inherit_overflow_checks\"));\n \n-        // Respect -Z force-overflow-checks=on and -C debug-assertions.\n-        check_overflow |= infcx.tcx\n-            .sess\n-            .opts\n-            .debugging_opts\n-            .force_overflow_checks\n-            .unwrap_or(infcx.tcx.sess.opts.debug_assertions);\n+        // Respect -C overflow-checks.\n+        check_overflow |= infcx.tcx.sess.overflow_checks();\n \n         // Constants and const fn's always need overflow checks.\n         check_overflow |= constness == hir::Constness::Const;"}, {"sha": "9c7ee6a9ce883baf1bcce988bec811892befd0ad", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -152,6 +152,9 @@ pub enum ExprKind<'tcx> {\n     ReifyFnPointer {\n         source: ExprRef<'tcx>,\n     },\n+    ClosureFnPointer {\n+        source: ExprRef<'tcx>,\n+    },\n     UnsafeFnPointer {\n         source: ExprRef<'tcx>,\n     },\n@@ -205,11 +208,11 @@ pub enum ExprKind<'tcx> {\n         arg: ExprRef<'tcx>,\n     },\n     Break {\n-        label: Option<CodeExtent>,\n+        label: CodeExtent,\n         value: Option<ExprRef<'tcx>>,\n     },\n     Continue {\n-        label: Option<CodeExtent>,\n+        label: CodeExtent,\n     },\n     Return {\n         value: Option<ExprRef<'tcx>>,"}, {"sha": "04e809ef9d839bc3846faba74c8e24c0c08ebcaf", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -619,6 +619,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             Rvalue::CheckedBinaryOp(..) |\n             Rvalue::Cast(CastKind::ReifyFnPointer, ..) |\n             Rvalue::Cast(CastKind::UnsafeFnPointer, ..) |\n+            Rvalue::Cast(CastKind::ClosureFnPointer, ..) |\n             Rvalue::Cast(CastKind::Unsize, ..) => {}\n \n             Rvalue::Len(_) => {"}, {"sha": "e3772a09968ec467bb0b7f38ecd4ea112a9f50a2", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -447,6 +447,7 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n         Some(Adjust::NeverToAny) |\n         Some(Adjust::ReifyFnPointer) |\n         Some(Adjust::UnsafeFnPointer) |\n+        Some(Adjust::ClosureFnPointer) |\n         Some(Adjust::MutToConstPointer) => {}\n \n         Some(Adjust::DerefRef { autoderefs, .. }) => {"}, {"sha": "5f06eadb84a9248f13e6bbf3592423f79b91f68f", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -241,6 +241,22 @@ match 5u32 {\n }\n ```\n \"##,\n+\n+E0590: r##\"\n+`break` or `continue` must include a label when used in the condition of a\n+`while` loop.\n+\n+Example of erroneous code:\n+\n+```compile_fail\n+while break {}\n+```\n+\n+To fix this, add a label specifying which loop is being broken out of:\n+```\n+`foo: while break `foo {}\n+```\n+\"##\n }\n \n register_diagnostics! {"}, {"sha": "b2d51be5bf72095bc3b4199dec8af37c285ae3e9", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -87,23 +87,26 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                 self.with_context(Closure, |v| v.visit_nested_body(b));\n             }\n             hir::ExprBreak(label, ref opt_expr) => {\n+                let loop_id = match label.loop_id.into() {\n+                    Ok(loop_id) => loop_id,\n+                    Err(hir::LoopIdError::OutsideLoopScope) => ast::DUMMY_NODE_ID,\n+                    Err(hir::LoopIdError::UnlabeledCfInWhileCondition) => {\n+                        self.emit_unlabled_cf_in_while_condition(e.span, \"break\");\n+                        ast::DUMMY_NODE_ID\n+                    },\n+                    Err(hir::LoopIdError::UnresolvedLabel) => ast::DUMMY_NODE_ID,\n+                };\n+\n                 if opt_expr.is_some() {\n-                    let loop_kind = if let Some(label) = label {\n-                        if label.loop_id == ast::DUMMY_NODE_ID {\n-                            None\n-                        } else {\n-                            Some(match self.hir_map.expect_expr(label.loop_id).node {\n-                                hir::ExprWhile(..) => LoopKind::WhileLoop,\n-                                hir::ExprLoop(_, _, source) => LoopKind::Loop(source),\n-                                ref r => span_bug!(e.span,\n-                                                   \"break label resolved to a non-loop: {:?}\", r),\n-                            })\n-                        }\n-                    } else if let Loop(kind) = self.cx {\n-                        Some(kind)\n-                    } else {\n-                        // `break` outside a loop - caught below\n+                    let loop_kind = if loop_id == ast::DUMMY_NODE_ID {\n                         None\n+                    } else {\n+                        Some(match self.hir_map.expect_expr(loop_id).node {\n+                            hir::ExprWhile(..) => LoopKind::WhileLoop,\n+                            hir::ExprLoop(_, _, source) => LoopKind::Loop(source),\n+                            ref r => span_bug!(e.span,\n+                                               \"break label resolved to a non-loop: {:?}\", r),\n+                        })\n                     };\n                     match loop_kind {\n                         None | Some(LoopKind::Loop(hir::LoopSource::Loop)) => (),\n@@ -117,9 +120,15 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                         }\n                     }\n                 }\n+\n                 self.require_loop(\"break\", e.span);\n             }\n-            hir::ExprAgain(_) => self.require_loop(\"continue\", e.span),\n+            hir::ExprAgain(label) => {\n+                if let Err(hir::LoopIdError::UnlabeledCfInWhileCondition) = label.loop_id.into() {\n+                    self.emit_unlabled_cf_in_while_condition(e.span, \"continue\");\n+                }\n+                self.require_loop(\"continue\", e.span)\n+            },\n             _ => intravisit::walk_expr(self, e),\n         }\n     }\n@@ -150,4 +159,12 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n             }\n         }\n     }\n+\n+    fn emit_unlabled_cf_in_while_condition(&mut self, span: Span, cf_type: &str) {\n+        struct_span_err!(self.sess, span, E0590,\n+                         \"`break` or `continue` with no label in the condition of a `while` loop\")\n+            .span_label(span,\n+                        &format!(\"unlabeled `{}` in the condition of a `while` loop\", cf_type))\n+            .emit();\n+    }\n }"}, {"sha": "fc05471ead30b02040f85d148369f7b2f5169d9e", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -18,7 +18,6 @@ use rustc::hir::def::{Def, CtorKind};\n use rustc::util::nodemap::{NodeMap, NodeSet};\n \n use syntax::ast;\n-use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax_pos::Span;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir;\n@@ -43,7 +42,7 @@ impl<'a, 'hir: 'a> Visitor<'hir> for CheckCrateVisitor<'a, 'hir> {\n         match it.node {\n             hir::ItemStatic(..) |\n             hir::ItemConst(..) => {\n-                let mut recursion_visitor = CheckItemRecursionVisitor::new(self, &it.span);\n+                let mut recursion_visitor = CheckItemRecursionVisitor::new(self);\n                 recursion_visitor.visit_item(it);\n             }\n             hir::ItemEnum(ref enum_def, ref generics) => {\n@@ -52,8 +51,7 @@ impl<'a, 'hir: 'a> Visitor<'hir> for CheckCrateVisitor<'a, 'hir> {\n                 // less redundant output.\n                 for variant in &enum_def.variants {\n                     if let Some(_) = variant.node.disr_expr {\n-                        let mut recursion_visitor = CheckItemRecursionVisitor::new(self,\n-                                                                                   &variant.span);\n+                        let mut recursion_visitor = CheckItemRecursionVisitor::new(self);\n                         recursion_visitor.populate_enum_discriminants(enum_def);\n                         recursion_visitor.visit_variant(variant, generics, it.id);\n                     }\n@@ -68,7 +66,7 @@ impl<'a, 'hir: 'a> Visitor<'hir> for CheckCrateVisitor<'a, 'hir> {\n         match ti.node {\n             hir::TraitItemKind::Const(_, ref default) => {\n                 if let Some(_) = *default {\n-                    let mut recursion_visitor = CheckItemRecursionVisitor::new(self, &ti.span);\n+                    let mut recursion_visitor = CheckItemRecursionVisitor::new(self);\n                     recursion_visitor.visit_trait_item(ti);\n                 }\n             }\n@@ -80,7 +78,7 @@ impl<'a, 'hir: 'a> Visitor<'hir> for CheckCrateVisitor<'a, 'hir> {\n     fn visit_impl_item(&mut self, ii: &'hir hir::ImplItem) {\n         match ii.node {\n             hir::ImplItemKind::Const(..) => {\n-                let mut recursion_visitor = CheckItemRecursionVisitor::new(self, &ii.span);\n+                let mut recursion_visitor = CheckItemRecursionVisitor::new(self);\n                 recursion_visitor.visit_impl_item(ii);\n             }\n             _ => {}\n@@ -105,7 +103,6 @@ pub fn check_crate<'hir>(sess: &Session, hir_map: &hir_map::Map<'hir>) -> Compil\n }\n \n struct CheckItemRecursionVisitor<'a, 'b: 'a, 'hir: 'b> {\n-    root_span: &'b Span,\n     sess: &'b Session,\n     hir_map: &'b hir_map::Map<'hir>,\n     discriminant_map: &'a mut NodeMap<Option<hir::BodyId>>,\n@@ -114,9 +111,8 @@ struct CheckItemRecursionVisitor<'a, 'b: 'a, 'hir: 'b> {\n }\n \n impl<'a, 'b: 'a, 'hir: 'b> CheckItemRecursionVisitor<'a, 'b, 'hir> {\n-    fn new(v: &'a mut CheckCrateVisitor<'b, 'hir>, span: &'b Span) -> Self {\n+    fn new(v: &'a mut CheckCrateVisitor<'b, 'hir>) -> Self {\n         CheckItemRecursionVisitor {\n-            root_span: span,\n             sess: v.sess,\n             hir_map: v.hir_map,\n             discriminant_map: &mut v.discriminant_map,\n@@ -143,15 +139,7 @@ impl<'a, 'b: 'a, 'hir: 'b> CheckItemRecursionVisitor<'a, 'b, 'hir> {\n                     false\n                 }\n             });\n-            if any_static {\n-                if !self.sess.features.borrow().static_recursion {\n-                    emit_feature_err(&self.sess.parse_sess,\n-                                     \"static_recursion\",\n-                                     *self.root_span,\n-                                     GateIssue::Language,\n-                                     \"recursive static\");\n-                }\n-            } else {\n+            if !any_static {\n                 struct_span_err!(self.sess, span, E0265, \"recursive constant\")\n                     .span_label(span, &format!(\"recursion not allowed in constant\"))\n                     .emit();"}, {"sha": "ec02e9235beaf93b2b26fc14b3de68a0d316bc84", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -495,7 +495,7 @@ impl<'a> Resolver<'a> {\n \n     pub fn get_macro(&mut self, def: Def) -> Rc<SyntaxExtension> {\n         let def_id = match def {\n-            Def::Macro(def_id) => def_id,\n+            Def::Macro(def_id, ..) => def_id,\n             _ => panic!(\"Expected Def::Macro(..)\"),\n         };\n         if let Some(ext) = self.macro_map.get(&def_id) {\n@@ -537,7 +537,6 @@ impl<'a> Resolver<'a> {\n                            binding: &'a NameBinding<'a>,\n                            span: Span,\n                            allow_shadowing: bool) {\n-        self.macro_names.insert(name);\n         if self.builtin_macros.insert(name, binding).is_some() && !allow_shadowing {\n             let msg = format!(\"`{}` is already in scope\", name);\n             let note ="}, {"sha": "eefe83d7da6f59b20d2ed0f26ba1e4e2cbce073a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -1265,7 +1265,7 @@ impl<'a> Resolver<'a> {\n             ribs: PerNS {\n                 value_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n                 type_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n-                macro_ns: None,\n+                macro_ns: Some(vec![Rib::new(ModuleRibKind(graph_root))]),\n             },\n             label_ribs: Vec::new(),\n \n@@ -2328,10 +2328,13 @@ impl<'a> Resolver<'a> {\n                 };\n             }\n         }\n-        if primary_ns != MacroNS && path.len() == 1 &&\n-                self.macro_names.contains(&path[0].name) {\n+        let is_builtin = self.builtin_macros.get(&path[0].name).cloned()\n+            .map(|binding| binding.get_macro(self).kind() == MacroKind::Bang).unwrap_or(false);\n+        if primary_ns != MacroNS && (is_builtin || self.macro_names.contains(&path[0].name)) {\n             // Return some dummy definition, it's enough for error reporting.\n-            return Some(PathResolution::new(Def::Macro(DefId::local(CRATE_DEF_INDEX))));\n+            return Some(\n+                PathResolution::new(Def::Macro(DefId::local(CRATE_DEF_INDEX), MacroKind::Bang))\n+            );\n         }\n         fin_res\n     }\n@@ -2768,18 +2771,24 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn resolve_labeled_block(&mut self, label: Option<SpannedIdent>, id: NodeId, block: &Block) {\n+    fn with_resolved_label<F>(&mut self, label: Option<SpannedIdent>, id: NodeId, f: F)\n+        where F: FnOnce(&mut Resolver)\n+    {\n         if let Some(label) = label {\n             let def = Def::Label(id);\n             self.with_label_rib(|this| {\n                 this.label_ribs.last_mut().unwrap().bindings.insert(label.node, def);\n-                this.visit_block(block);\n+                f(this);\n             });\n         } else {\n-            self.visit_block(block);\n+            f(self);\n         }\n     }\n \n+    fn resolve_labeled_block(&mut self, label: Option<SpannedIdent>, id: NodeId, block: &Block) {\n+        self.with_resolved_label(label, id, |this| this.visit_block(block));\n+    }\n+\n     fn resolve_expr(&mut self, expr: &Expr, parent: Option<&ExprKind>) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n@@ -2833,18 +2842,18 @@ impl<'a> Resolver<'a> {\n             ExprKind::Loop(ref block, label) => self.resolve_labeled_block(label, expr.id, &block),\n \n             ExprKind::While(ref subexpression, ref block, label) => {\n-                self.visit_expr(subexpression);\n-                self.resolve_labeled_block(label, expr.id, &block);\n+                self.with_resolved_label(label, expr.id, |this| {\n+                    this.visit_expr(subexpression);\n+                    this.visit_block(block);\n+                });\n             }\n \n             ExprKind::WhileLet(ref pattern, ref subexpression, ref block, label) => {\n-                self.visit_expr(subexpression);\n-                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::WhileLet, &mut FxHashMap());\n-\n-                self.resolve_labeled_block(label, expr.id, block);\n-\n-                self.ribs[ValueNS].pop();\n+                self.with_resolved_label(label, expr.id, |this| {\n+                    this.visit_expr(subexpression);\n+                    this.resolve_pattern(pattern, PatternSource::WhileLet, &mut FxHashMap());\n+                    this.visit_block(block);\n+                });\n             }\n \n             ExprKind::ForLoop(ref pattern, ref subexpression, ref block, label) => {"}, {"sha": "b7068f4b09f5fcca3359b955d6e1d279736755c7", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -23,7 +23,7 @@ use syntax::ast::{self, Name, Ident};\n use syntax::attr;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n-use syntax::ext::base::{NormalTT, Resolver as SyntaxResolver, SyntaxExtension};\n+use syntax::ext::base::{Resolver as SyntaxResolver, SyntaxExtension};\n use syntax::ext::base::MacroKind;\n use syntax::ext::expand::{Expansion, mark_tts};\n use syntax::ext::hygiene::Mark;\n@@ -152,16 +152,14 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn add_ext(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>) {\n-        if let NormalTT(..) = *ext {\n-            self.macro_names.insert(ident.name);\n-        }\n         let def_id = DefId {\n             krate: BUILTIN_MACROS_CRATE,\n             index: DefIndex::new(self.macro_map.len()),\n         };\n+        let kind = ext.kind();\n         self.macro_map.insert(def_id, ext);\n         let binding = self.arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Def(Def::Macro(def_id)),\n+            kind: NameBindingKind::Def(Def::Macro(def_id, kind)),\n             span: DUMMY_SP,\n             vis: ty::Visibility::Invisible,\n             expansion: Mark::root(),\n@@ -470,24 +468,40 @@ impl<'a> Resolver<'a> {\n \n     fn suggest_macro_name(&mut self, name: &str, kind: MacroKind,\n                           err: &mut DiagnosticBuilder<'a>) {\n-        let suggestion = match kind {\n-            MacroKind::Bang =>\n-                find_best_match_for_name(self.macro_names.iter(), name, None),\n-            MacroKind::Attr |\n-            MacroKind::Derive => {\n-                // Find a suggestion from the legacy namespace.\n-                // FIXME: get_macro needs an &mut Resolver, can we do it without cloning?\n-                let builtin_macros = self.builtin_macros.clone();\n-                let names = builtin_macros.iter().filter_map(|(name, binding)| {\n-                    if binding.get_macro(self).kind() == kind {\n-                        Some(name)\n-                    } else {\n-                        None\n-                    }\n-                });\n-                find_best_match_for_name(names, name, None)\n+        // First check if this is a locally-defined bang macro.\n+        let suggestion = if let MacroKind::Bang = kind {\n+            find_best_match_for_name(self.macro_names.iter(), name, None)\n+        } else {\n+            None\n+        // Then check builtin macros.\n+        }.or_else(|| {\n+            // FIXME: get_macro needs an &mut Resolver, can we do it without cloning?\n+            let builtin_macros = self.builtin_macros.clone();\n+            let names = builtin_macros.iter().filter_map(|(name, binding)| {\n+                if binding.get_macro(self).kind() == kind {\n+                    Some(name)\n+                } else {\n+                    None\n+                }\n+            });\n+            find_best_match_for_name(names, name, None)\n+        // Then check modules.\n+        }).or_else(|| {\n+            if !self.use_extern_macros {\n+                return None;\n             }\n-        };\n+            let is_macro = |def| {\n+                if let Def::Macro(_, def_kind) = def {\n+                    def_kind == kind\n+                } else {\n+                    false\n+                }\n+            };\n+            let ident = Ident::from_str(name);\n+            self.lookup_typo_candidate(&vec![ident], MacroNS, is_macro)\n+                .as_ref().map(|s| Symbol::intern(s))\n+        });\n+\n         if let Some(suggestion) = suggestion {\n             if suggestion != name {\n                 if let MacroKind::Bang = kind {\n@@ -566,7 +580,7 @@ impl<'a> Resolver<'a> {\n             });\n             self.macro_exports.push(Export {\n                 name: def.ident.name,\n-                def: Def::Macro(self.definitions.local_def_id(def.id)),\n+                def: Def::Macro(self.definitions.local_def_id(def.id), MacroKind::Bang),\n             });\n             self.exported_macros.push(def);\n         }"}, {"sha": "6667a3199a8096ef5f4dd603d91465b8fa3d9c3d", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -336,7 +336,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             Def::AssociatedTy(..) |\n             Def::AssociatedConst(..) |\n             Def::PrimTy(_) |\n-            Def::Macro(_) |\n+            Def::Macro(..) |\n             Def::Err => {\n                span_bug!(span,\n                          \"process_def_kind for unexpected item: {:?}\","}, {"sha": "f742cca5b980a28cbbc9481b87a9a2a92a6a5bad", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -506,7 +506,11 @@ impl FnType {\n                 if let Some(inner) = rust_ptr_attrs(ty, &mut data) {\n                     data.attrs.set(ArgAttribute::NonNull);\n                     if ccx.tcx().struct_tail(inner).is_trait() {\n+                        // vtables can be safely marked non-null, readonly\n+                        // and noalias.\n                         info.attrs.set(ArgAttribute::NonNull);\n+                        info.attrs.set(ArgAttribute::ReadOnly);\n+                        info.attrs.set(ArgAttribute::NoAlias);\n                     }\n                 }\n                 args.push(data);"}, {"sha": "ca746c58e7f6ad8a421fa2c1b65456c101720e5e", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -472,8 +472,15 @@ pub fn load_fat_ptr<'a, 'tcx>(\n         b.load(ptr, alignment.to_align())\n     };\n \n-    // FIXME: emit metadata on `meta`.\n-    let meta = b.load(get_meta(b, src), alignment.to_align());\n+    let meta = get_meta(b, src);\n+    let meta_ty = val_ty(meta);\n+    // If the 'meta' field is a pointer, it's a vtable, so use load_nonnull\n+    // instead\n+    let meta = if meta_ty.element_type().kind() == llvm::TypeKind::Pointer {\n+        b.load_nonnull(meta, None)\n+    } else {\n+        b.load(meta, None)\n+    };\n \n     (ptr, meta)\n }\n@@ -1132,11 +1139,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let ty::CrateAnalysis { export_map, reachable, name, .. } = analysis;\n     let exported_symbols = find_exported_symbols(tcx, reachable);\n \n-    let check_overflow = if let Some(v) = tcx.sess.opts.debugging_opts.force_overflow_checks {\n-        v\n-    } else {\n-        tcx.sess.opts.debug_assertions\n-    };\n+    let check_overflow = tcx.sess.overflow_checks();\n \n     let link_meta = link::build_link_meta(incremental_hashes_map, &name);\n "}, {"sha": "a62f07042a7035749ba970c1d685e2ca6957fed1", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -1149,6 +1149,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    pub fn set_invariant_load(&self, load: ValueRef) {\n+        unsafe {\n+            llvm::LLVMSetMetadata(load, llvm::MD_invariant_load as c_uint,\n+                                  llvm::LLVMMDNodeInContext(self.ccx.llcx(), ptr::null(), 0));\n+        }\n+    }\n+\n     /// Returns the ptr value that should be used for storing `val`.\n     fn check_store<'b>(&self,\n                        val: ValueRef,\n@@ -1181,7 +1188,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         assert!(fn_ty.kind() == llvm::TypeKind::Function,\n-                \"builder::{} not passed a function\", typ);\n+                \"builder::{} not passed a function, but {:?}\", typ, fn_ty);\n \n         let param_tys = fn_ty.func_params();\n "}, {"sha": "83a38a529d006a36772eed0a54361dc932461b8d", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -489,6 +489,20 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                                                           self.output);\n                 }\n             }\n+            mir::Rvalue::Cast(mir::CastKind::ClosureFnPointer, ref operand, _) => {\n+                let source_ty = operand.ty(self.mir, self.scx.tcx());\n+                match source_ty.sty {\n+                    ty::TyClosure(def_id, substs) => {\n+                        let closure_trans_item =\n+                            create_fn_trans_item(self.scx,\n+                                                 def_id,\n+                                                 substs.substs,\n+                                                 self.param_substs);\n+                        self.output.push(closure_trans_item);\n+                    }\n+                    _ => bug!(),\n+                }\n+            }\n             mir::Rvalue::Box(..) => {\n                 let exchange_malloc_fn_def_id =\n                     self.scx\n@@ -615,19 +629,13 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                                               def_id: DefId)\n                                               -> bool {\n             match tcx.item_type(def_id).sty {\n-                ty::TyFnDef(def_id, _, f) => {\n+                ty::TyFnDef(def_id, _, _) => {\n                     // Some constructors also have type TyFnDef but they are\n                     // always instantiated inline and don't result in a\n                     // translation item. Same for FFI functions.\n                     if let Some(hir_map::NodeForeignItem(_)) = tcx.hir.get_if_local(def_id) {\n                         return false;\n                     }\n-\n-                    if let Some(adt_def) = f.sig.output().skip_binder().ty_adt_def() {\n-                        if adt_def.variants.iter().any(|v| def_id == v.did) {\n-                            return false;\n-                        }\n-                    }\n                 }\n                 ty::TyClosure(..) => {}\n                 _ => return false\n@@ -689,6 +697,16 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   def_id: DefId)\n                                   -> bool {\n+    if let ty::TyFnDef(_, _, f) = tcx.item_type(def_id).sty {\n+        if let Some(adt_def) = f.sig.output().skip_binder().ty_adt_def() {\n+            if adt_def.variants.iter().any(|v| def_id == v.did) {\n+                // HACK: ADT constructors are translated in-place and\n+                // do not have a trans-item.\n+                return false;\n+            }\n+        }\n+    }\n+\n     if def_id.is_local() {\n         true\n     } else {"}, {"sha": "9963514acd73619b0b939b488e03d0a7fe16bf87", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -386,7 +386,15 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             let info = bcx.pointercast(info, Type::int(bcx.ccx).ptr_to());\n             let size_ptr = bcx.gepi(info, &[1]);\n             let align_ptr = bcx.gepi(info, &[2]);\n-            (bcx.load(size_ptr, None), bcx.load(align_ptr, None))\n+\n+            let size = bcx.load(size_ptr, None);\n+            let align = bcx.load(align_ptr, None);\n+\n+            // Vtable loads are invariant\n+            bcx.set_invariant_load(size);\n+            bcx.set_invariant_load(align);\n+\n+            (size, align)\n         }\n         ty::TySlice(_) | ty::TyStr => {\n             let unit_ty = t.sequence_element_type(bcx.tcx());"}, {"sha": "a3f4168e96f2a0c5e2bdc13d824a0846e34c7a5b", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -30,13 +30,15 @@ const VTABLE_OFFSET: usize = 3;\n /// Extracts a method from a trait object's vtable, at the specified index.\n pub fn get_virtual_method<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                     llvtable: ValueRef,\n-                                    vtable_index: usize)\n-                                    -> ValueRef {\n+                                    vtable_index: usize) -> ValueRef {\n     // Load the data pointer from the object.\n     debug!(\"get_virtual_method(vtable_index={}, llvtable={:?})\",\n            vtable_index, Value(llvtable));\n \n-    bcx.load(bcx.gepi(llvtable, &[vtable_index + VTABLE_OFFSET]), None)\n+    let ptr = bcx.load_nonnull(bcx.gepi(llvtable, &[vtable_index + VTABLE_OFFSET]), None);\n+    // Vtable loads are invariant\n+    bcx.set_invariant_load(ptr);\n+    ptr\n }\n \n /// Generate a shim function that allows an object type like `SomeTrait` to"}, {"sha": "e6cae2f9f3296dba5297a733f11012105762a627", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -20,7 +20,7 @@ use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc::ty::{self, layout, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::cast::{CastTy, IntTy};\n-use rustc::ty::subst::Substs;\n+use rustc::ty::subst::{Kind, Substs};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use {abi, adt, base, Disr, machine};\n use callee::Callee;\n@@ -578,6 +578,27 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                             }\n                         }\n                     }\n+                    mir::CastKind::ClosureFnPointer => {\n+                        match operand.ty.sty {\n+                            ty::TyClosure(def_id, substs) => {\n+                                // Get the def_id for FnOnce::call_once\n+                                let fn_once = tcx.lang_items.fn_once_trait().unwrap();\n+                                let call_once = tcx\n+                                    .global_tcx().associated_items(fn_once)\n+                                    .find(|it| it.kind == ty::AssociatedKind::Method)\n+                                    .unwrap().def_id;\n+                                // Now create its substs [Closure, Tuple]\n+                                let input = tcx.closure_type(def_id, substs).sig.input(0);\n+                                let substs = tcx.mk_substs([operand.ty, input.skip_binder()]\n+                                    .iter().cloned().map(Kind::from));\n+                                Callee::def(self.ccx, call_once, substs)\n+                                    .reify(self.ccx)\n+                            }\n+                            _ => {\n+                                bug!(\"{} cannot be cast to a fn ptr\", operand.ty)\n+                            }\n+                        }\n+                    }\n                     mir::CastKind::UnsafeFnPointer => {\n                         // this is a no-op at the LLVM level\n                         operand.llval"}, {"sha": "6f6d81a25350fe229c20c891c3c4ad4f6b319d49", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -12,6 +12,7 @@ use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::layout::Layout;\n+use rustc::ty::subst::Kind;\n use rustc::mir::tcx::LvalueTy;\n use rustc::mir;\n use middle::lang_items::ExchangeMallocFnLangItem;\n@@ -190,6 +191,28 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             }\n                         }\n                     }\n+                    mir::CastKind::ClosureFnPointer => {\n+                        match operand.ty.sty {\n+                            ty::TyClosure(def_id, substs) => {\n+                                // Get the def_id for FnOnce::call_once\n+                                let fn_once = bcx.tcx().lang_items.fn_once_trait().unwrap();\n+                                let call_once = bcx.tcx()\n+                                    .global_tcx().associated_items(fn_once)\n+                                    .find(|it| it.kind == ty::AssociatedKind::Method)\n+                                    .unwrap().def_id;\n+                                // Now create its substs [Closure, Tuple]\n+                                let input = bcx.tcx().closure_type(def_id, substs).sig.input(0);\n+                                let substs = bcx.tcx().mk_substs([operand.ty, input.skip_binder()]\n+                                    .iter().cloned().map(Kind::from));\n+                                OperandValue::Immediate(\n+                                    Callee::def(bcx.ccx, call_once, substs)\n+                                        .reify(bcx.ccx))\n+                            }\n+                            _ => {\n+                                bug!(\"{} cannot be cast to a fn ptr\", operand.ty)\n+                            }\n+                        }\n+                    }\n                     mir::CastKind::UnsafeFnPointer => {\n                         // this is a no-op at the LLVM level\n                         operand.val"}, {"sha": "424e3143929f4d8d2265f05d22a0908c5dc53dc3", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 64, "deletions": 1, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -63,13 +63,17 @@\n use check::FnCtxt;\n \n use rustc::hir;\n+use rustc::hir::def_id::DefId;\n use rustc::infer::{Coercion, InferOk, TypeTrace};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n-use rustc::ty::{self, LvaluePreference, TypeAndMut, Ty};\n+use rustc::ty::{self, LvaluePreference, TypeAndMut,\n+                Ty, ClosureSubsts};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n use rustc::ty::relate::RelateResult;\n+use syntax::abi;\n+use syntax::feature_gate;\n use util::common::indent;\n \n use std::cell::RefCell;\n@@ -196,6 +200,11 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 // unsafe qualifier.\n                 self.coerce_from_fn_pointer(a, a_f, b)\n             }\n+            ty::TyClosure(def_id_a, substs_a) => {\n+                // Non-capturing closures are coercible to\n+                // function pointers\n+                self.coerce_closure_to_fn(a, def_id_a, substs_a, b)\n+            }\n             _ => {\n                 // Otherwise, just use unification rules.\n                 self.unify_and_identity(a, b)\n@@ -551,6 +560,60 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn coerce_closure_to_fn(&self,\n+                           a: Ty<'tcx>,\n+                           def_id_a: DefId,\n+                           substs_a: ClosureSubsts<'tcx>,\n+                           b: Ty<'tcx>)\n+                           -> CoerceResult<'tcx> {\n+        //! Attempts to coerce from the type of a non-capturing closure\n+        //! into a function pointer.\n+        //!\n+\n+        let b = self.shallow_resolve(b);\n+\n+        let node_id_a = self.tcx.hir.as_local_node_id(def_id_a).unwrap();\n+        match b.sty {\n+            ty::TyFnPtr(_) if self.tcx.with_freevars(node_id_a, |v| v.is_empty()) => {\n+                if !self.tcx.sess.features.borrow().closure_to_fn_coercion {\n+                    feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n+                                                   \"closure_to_fn_coercion\",\n+                                                   self.cause.span,\n+                                                   feature_gate::GateIssue::Language,\n+                                                   feature_gate::CLOSURE_TO_FN_COERCION);\n+                    return self.unify_and_identity(a, b);\n+                }\n+                // We coerce the closure, which has fn type\n+                //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n+                // to\n+                //     `fn(arg0,arg1,...) -> _`\n+                let sig = self.closure_type(def_id_a, substs_a).sig;\n+                let converted_sig = sig.map_bound(|s| {\n+                    let params_iter = match s.inputs()[0].sty {\n+                        ty::TyTuple(params, _) => {\n+                            params.into_iter().cloned()\n+                        }\n+                        _ => bug!(),\n+                    };\n+                    self.tcx.mk_fn_sig(params_iter,\n+                                       s.output(),\n+                                       s.variadic)\n+                });\n+                let fn_ty = self.tcx.mk_bare_fn(ty::BareFnTy {\n+                    unsafety: hir::Unsafety::Normal,\n+                    abi: abi::Abi::Rust,\n+                    sig: converted_sig,\n+                });\n+                let pointer_ty = self.tcx.mk_fn_ptr(&fn_ty);\n+                debug!(\"coerce_closure_to_fn(a={:?}, b={:?}, pty={:?})\",\n+                       a, b, pointer_ty);\n+                self.unify_and_identity(pointer_ty, b)\n+                    .map(|(ty, _)| (ty, Adjust::ClosureFnPointer))\n+            }\n+            _ => self.unify_and_identity(a, b),\n+        }\n+    }\n+\n     fn coerce_unsafe_ptr(&self,\n                          a: Ty<'tcx>,\n                          b: Ty<'tcx>,"}, {"sha": "14dacb0ca97cb93f490fd262827be6cd0991264b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -425,15 +425,12 @@ pub struct EnclosingLoops<'gcx, 'tcx> {\n }\n \n impl<'gcx, 'tcx> EnclosingLoops<'gcx, 'tcx> {\n-    fn find_loop(&mut self, id: Option<ast::NodeId>) -> Option<&mut LoopCtxt<'gcx, 'tcx>> {\n-        if let Some(id) = id {\n-            if let Some(ix) = self.by_id.get(&id).cloned() {\n-                Some(&mut self.stack[ix])\n-            } else {\n-                None\n-            }\n+    fn find_loop(&mut self, id: hir::LoopIdResult) -> Option<&mut LoopCtxt<'gcx, 'tcx>> {\n+        let id_res: Result<_,_> = id.into();\n+        if let Some(ix) = id_res.ok().and_then(|id| self.by_id.get(&id).cloned()) {\n+            Some(&mut self.stack[ix])\n         } else {\n-            self.stack.last_mut()\n+            None\n         }\n     }\n }\n@@ -3596,10 +3593,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               tcx.mk_nil()\n           }\n           hir::ExprBreak(label, ref expr_opt) => {\n-            let loop_id = label.map(|l| l.loop_id);\n             let coerce_to = {\n                 let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n-                enclosing_loops.find_loop(loop_id).map(|ctxt| ctxt.coerce_to)\n+                enclosing_loops.find_loop(label.loop_id).map(|ctxt| ctxt.coerce_to)\n             };\n             if let Some(coerce_to) = coerce_to {\n                 let e_ty;\n@@ -3614,8 +3610,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     e_ty = tcx.mk_nil();\n                     cause = self.misc(expr.span);\n                 }\n+\n                 let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n-                let ctxt = enclosing_loops.find_loop(loop_id).unwrap();\n+                let ctxt = enclosing_loops.find_loop(label.loop_id).unwrap();\n \n                 let result = if let Some(ref e) = *expr_opt {\n                     // Special-case the first element, as it has no \"previous expressions\"."}, {"sha": "a25e5f3f283dd1520d966b474619e4440f246641", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -412,6 +412,10 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                         adjustment::Adjust::MutToConstPointer\n                     }\n \n+                    adjustment::Adjust::ClosureFnPointer => {\n+                        adjustment::Adjust::ClosureFnPointer\n+                    }\n+\n                     adjustment::Adjust::UnsafeFnPointer => {\n                         adjustment::Adjust::UnsafeFnPointer\n                     }"}, {"sha": "c7000ee1e40e764f5a79837cd2149cc24d891a71", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -12,7 +12,7 @@ use std::env;\n use std::ffi::OsString;\n use std::io::prelude::*;\n use std::io;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use std::panic::{self, AssertUnwindSafe};\n use std::process::Command;\n use std::rc::Rc;\n@@ -485,7 +485,15 @@ impl Collector {\n \n     pub fn get_filename(&self) -> String {\n         if let Some(ref codemap) = self.codemap {\n-            codemap.span_to_filename(self.position)\n+            let filename = codemap.span_to_filename(self.position);\n+            if let Ok(cur_dir) = env::current_dir() {\n+                if let Ok(path) = Path::new(&filename).strip_prefix(&cur_dir) {\n+                    if let Some(path) = path.to_str() {\n+                        return path.to_owned();\n+                    }\n+                }\n+            }\n+            filename\n         } else if let Some(ref filename) = self.filename {\n             filename.clone()\n         } else {"}, {"sha": "64f37925a98e283c797fdc32de2dee5a03f15cf6", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -199,7 +199,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         self.inside_public_path = orig_inside_public_path;\n         if let Some(exports) = self.cx.export_map.get(&id) {\n             for export in exports {\n-                if let Def::Macro(def_id) = export.def {\n+                if let Def::Macro(def_id, ..) = export.def {\n                     if def_id.krate == LOCAL_CRATE {\n                         continue // These are `krate.exported_macros`, handled in `self.visit()`.\n                     }"}, {"sha": "038dea77f3ead8d570483a299e02a99059ece819", "filename": "src/libstd/build.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -59,6 +59,10 @@ fn main() {\n         println!(\"cargo:rustc-link-lib=userenv\");\n         println!(\"cargo:rustc-link-lib=shell32\");\n     } else if target.contains(\"fuchsia\") {\n+        // use system-provided libbacktrace\n+        if cfg!(feature = \"backtrace\") {\n+            println!(\"cargo:rustc-link-lib=backtrace\");\n+        }\n         println!(\"cargo:rustc-link-lib=magenta\");\n         println!(\"cargo:rustc-link-lib=mxio\");\n         println!(\"cargo:rustc-link-lib=launchpad\"); // for std::process"}, {"sha": "f0738fe9b7033fea50795eaccb0dbe33238f4760", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -182,46 +182,37 @@ impl DefaultResizePolicy {\n // ----------------------\n // To protect against degenerate performance scenarios (including DOS attacks),\n // the implementation includes an adaptive behavior that can resize the map\n-// early (before its capacity is exceeded) when suspiciously long probe or\n-// forward shifts sequences are encountered.\n+// early (before its capacity is exceeded) when suspiciously long probe sequences\n+// are encountered.\n //\n // With this algorithm in place it would be possible to turn a CPU attack into\n // a memory attack due to the aggressive resizing. To prevent that the\n-// adaptive behavior only triggers when the map occupancy is half the maximum occupancy.\n+// adaptive behavior only triggers when the map is at least half full.\n // This reduces the effectiveness of the algorithm but also makes it completely safe.\n //\n // The previous safety measure also prevents degenerate interactions with\n // really bad quality hash algorithms that can make normal inputs look like a\n // DOS attack.\n //\n const DISPLACEMENT_THRESHOLD: usize = 128;\n-const FORWARD_SHIFT_THRESHOLD: usize = 512;\n //\n-// The thresholds of 128 and 512 are chosen to minimize the chance of exceeding them.\n+// The threshold of 128 is chosen to minimize the chance of exceeding it.\n // In particular, we want that chance to be less than 10^-8 with a load of 90%.\n // For displacement, the smallest constant that fits our needs is 90,\n-// so we round that up to 128. For the number of forward-shifted buckets,\n-// we choose k=512. Keep in mind that the run length is a sum of the displacement and\n-// the number of forward-shifted buckets, so its threshold is 128+512=640.\n-// Even though the probability of having a run length of more than 640 buckets may be\n-// higher than the probability we want, it should be low enough.\n+// so we round that up to 128.\n //\n // At a load factor of \u03b1, the odds of finding the target bucket after exactly n\n // unsuccesful probes[1] are\n //\n // Pr_\u03b1{displacement = n} =\n // (1 - \u03b1) / \u03b1 * \u2211_{k\u22651} e^(-k\u03b1) * (k\u03b1)^(k+n) / (k + n)! * (1 - k\u03b1 / (k + n + 1))\n //\n-// We use this formula to find the probability of loading half of triggering the adaptive behavior\n+// We use this formula to find the probability of triggering the adaptive behavior\n //\n // Pr_0.909{displacement > 128} = 1.601 * 10^-11\n //\n-// FIXME: Extend with math for shift threshold in [2]\n-//\n // 1. Alfredo Viola (2005). Distributional analysis of Robin Hood linear probing\n //    hashing with buckets.\n-// 2. http://www.cs.tau.ac.il/~zwick/Adv-Alg-2015/Linear-Probing.pdf\n-\n \n /// A hash map implementation which uses linear probing with Robin Hood bucket\n /// stealing.\n@@ -494,7 +485,7 @@ fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n                                 mut hash: SafeHash,\n                                 mut key: K,\n                                 mut val: V)\n-                                -> (usize, &'a mut V) {\n+                                -> &'a mut V {\n     let start_index = bucket.index();\n     let size = bucket.table().size();\n     // Save the *starting point*.\n@@ -519,15 +510,14 @@ fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n                 Empty(bucket) => {\n                     // Found a hole!\n                     let bucket = bucket.put(hash, key, val);\n-                    let end_index = bucket.index();\n                     // Now that it's stolen, just read the value's pointer\n                     // right out of the table! Go back to the *starting point*.\n                     //\n                     // This use of `into_table` is misleading. It turns the\n                     // bucket, which is a FullBucket on top of a\n                     // FullBucketMut, into just one FullBucketMut. The \"table\"\n                     // refers to the inner FullBucketMut in this context.\n-                    return (end_index - start_index, bucket.into_table().into_mut_refs().1);\n+                    return bucket.into_table().into_mut_refs().1;\n                 }\n                 Full(bucket) => bucket,\n             };\n@@ -2128,18 +2118,16 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     pub fn insert(self, value: V) -> &'a mut V {\n         match self.elem {\n             NeqElem(bucket, disp) => {\n-                let (shift, v_ref) = robin_hood(bucket, disp, self.hash, self.key, value);\n-                if disp >= DISPLACEMENT_THRESHOLD || shift >= FORWARD_SHIFT_THRESHOLD {\n+                if disp >= DISPLACEMENT_THRESHOLD {\n                     *self.long_probes = true;\n                 }\n-                v_ref\n+                robin_hood(bucket, disp, self.hash, self.key, value)\n             },\n             NoElem(bucket, disp) => {\n                 if disp >= DISPLACEMENT_THRESHOLD {\n                     *self.long_probes = true;\n                 }\n-                let bucket = bucket.put(self.hash, self.key, value);\n-                bucket.into_mut_refs().1\n+                bucket.put(self.hash, self.key, value).into_mut_refs().1\n             },\n         }\n     }"}, {"sha": "f99634ecac23f4261405be0dc3d101cb8f8386a5", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -198,7 +198,7 @@ impl<T: RefUnwindSafe + ?Sized> UnwindSafe for *const T {}\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n impl<T: RefUnwindSafe + ?Sized> UnwindSafe for *mut T {}\n #[unstable(feature = \"unique\", issue = \"27730\")]\n-impl<T: UnwindSafe> UnwindSafe for Unique<T> {}\n+impl<T: UnwindSafe + ?Sized> UnwindSafe for Unique<T> {}\n #[unstable(feature = \"shared\", issue = \"27730\")]\n impl<T: RefUnwindSafe + ?Sized> UnwindSafe for Shared<T> {}\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]"}, {"sha": "31c40ea58b1de103a979647e24b66034798c1858", "filename": "src/libstd/sys/redox/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -13,7 +13,7 @@\n use io::{self, ErrorKind};\n \n pub mod args;\n-#[cfg(any(not(cargobuild), feature = \"backtrace\"))]\n+#[cfg(feature = \"backtrace\")]\n pub mod backtrace;\n pub mod condvar;\n pub mod env;"}, {"sha": "936097d7fb2a602264f32294bd343170bf67326a", "filename": "src/libstd/sys/redox/net/tcp.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -63,6 +63,10 @@ impl TcpStream {\n         Ok(path_to_local_addr(path.to_str().unwrap_or(\"\")))\n     }\n \n+    pub fn peek(&self, _buf: &mut [u8]) -> Result<usize> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::peek not implemented\"))\n+    }\n+\n     pub fn shutdown(&self, _how: Shutdown) -> Result<()> {\n         Err(Error::new(ErrorKind::Other, \"TcpStream::shutdown not implemented\"))\n     }"}, {"sha": "93ebcc95fd0f87e0c70fa6584678ec2cab778a8a", "filename": "src/libstd/sys/redox/net/udp.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -87,6 +87,14 @@ impl UdpSocket {\n         Ok(path_to_local_addr(path.to_str().unwrap_or(\"\")))\n     }\n \n+    pub fn peek(&self, _buf: &mut [u8]) -> Result<usize> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::peek not implemented\"))\n+    }\n+\n+    pub fn peek_from(&self, _buf: &mut [u8]) -> Result<(usize, SocketAddr)> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::peek_from not implemented\"))\n+    }\n+\n     pub fn broadcast(&self) -> Result<bool> {\n         Err(Error::new(ErrorKind::Other, \"UdpSocket::broadcast not implemented\"))\n     }"}, {"sha": "d0fb96b1ff15dffe98412dd745c32e9821669d2c", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -35,7 +35,8 @@ use libc::{stat as stat64, fstat as fstat64, lstat as lstat64, off_t as off64_t,\n            ftruncate as ftruncate64, lseek as lseek64, dirent as dirent64, open as open64};\n #[cfg(not(any(target_os = \"linux\",\n               target_os = \"emscripten\",\n-              target_os = \"solaris\")))]\n+              target_os = \"solaris\",\n+              target_os = \"fuchsia\")))]\n use libc::{readdir_r as readdir64_r};\n \n pub struct File(FileDesc);\n@@ -59,10 +60,10 @@ pub struct DirEntry {\n     entry: dirent64,\n     root: Arc<PathBuf>,\n     // We need to store an owned copy of the directory name\n-    // on Solaris because a) it uses a zero-length array to\n-    // store the name, b) its lifetime between readdir calls\n-    // is not guaranteed.\n-    #[cfg(target_os = \"solaris\")]\n+    // on Solaris and Fuchsia because a) it uses a zero-length\n+    // array to store the name, b) its lifetime between readdir\n+    // calls is not guaranteed.\n+    #[cfg(any(target_os = \"solaris\", target_os = \"fuchsia\"))]\n     name: Box<[u8]>\n }\n \n@@ -205,14 +206,14 @@ impl fmt::Debug for ReadDir {\n impl Iterator for ReadDir {\n     type Item = io::Result<DirEntry>;\n \n-    #[cfg(target_os = \"solaris\")]\n+    #[cfg(any(target_os = \"solaris\", target_os = \"fuchsia\"))]\n     fn next(&mut self) -> Option<io::Result<DirEntry>> {\n         unsafe {\n             loop {\n                 // Although readdir_r(3) would be a correct function to use here because\n-                // of the thread safety, on Illumos the readdir(3C) function is safe to use\n-                // in threaded applications and it is generally preferred over the\n-                // readdir_r(3C) function.\n+                // of the thread safety, on Illumos and Fuchsia the readdir(3C) function\n+                // is safe to use in threaded applications and it is generally preferred\n+                // over the readdir_r(3C) function.\n                 super::os::set_errno(0);\n                 let entry_ptr = libc::readdir(self.dirp.0);\n                 if entry_ptr.is_null() {\n@@ -240,7 +241,7 @@ impl Iterator for ReadDir {\n         }\n     }\n \n-    #[cfg(not(target_os = \"solaris\"))]\n+    #[cfg(not(any(target_os = \"solaris\", target_os = \"fuchsia\")))]\n     fn next(&mut self) -> Option<io::Result<DirEntry>> {\n         unsafe {\n             let mut ret = DirEntry {\n@@ -344,14 +345,14 @@ impl DirEntry {\n     #[cfg(any(target_os = \"android\",\n               target_os = \"linux\",\n               target_os = \"emscripten\",\n-              target_os = \"haiku\",\n-              target_os = \"fuchsia\"))]\n+              target_os = \"haiku\"))]\n     fn name_bytes(&self) -> &[u8] {\n         unsafe {\n             CStr::from_ptr(self.entry.d_name.as_ptr()).to_bytes()\n         }\n     }\n-    #[cfg(target_os = \"solaris\")]\n+    #[cfg(any(target_os = \"solaris\",\n+              target_os = \"fuchsia\"))]\n     fn name_bytes(&self) -> &[u8] {\n         &*self.name\n     }"}, {"sha": "36928696c4059089bfffcbbca9c4e72a1e989c2a", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -64,7 +64,7 @@ pub fn errno() -> i32 {\n }\n \n /// Sets the platform-specific value of errno\n-#[cfg(target_os = \"solaris\")] // only needed for readdir so far\n+#[cfg(any(target_os = \"solaris\", target_os = \"fuchsia\"))] // only needed for readdir so far\n pub fn set_errno(e: i32) {\n     unsafe {\n         *errno_location() = e as c_int"}, {"sha": "08a827ce08142ee9ad208a7da71d25d39a07dc50", "filename": "src/libstd/sys/unix/process/magenta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmagenta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmagenta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmagenta.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -111,7 +111,7 @@ extern {\n     pub fn mx_handle_duplicate(handle: mx_handle_t, rights: mx_rights_t,\n                                out: *const mx_handle_t) -> mx_handle_t;\n \n-    pub fn mx_handle_wait_one(handle: mx_handle_t, signals: mx_signals_t, timeout: mx_time_t,\n+    pub fn mx_object_wait_one(handle: mx_handle_t, signals: mx_signals_t, timeout: mx_time_t,\n                               pending: *mut mx_signals_t) -> mx_status_t;\n \n     pub fn mx_object_get_info(handle: mx_handle_t, topic: u32, buffer: *mut c_void,"}, {"sha": "608e44ca9e86e1641ac957b2c36a7ebf46bfb5ff", "filename": "src/libstd/sys/unix/process/process_fuchsia.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -151,7 +151,7 @@ impl Process {\n         let mut avail: mx_size_t = 0;\n \n         unsafe {\n-            mx_cvt(mx_handle_wait_one(self.handle.raw(), MX_TASK_TERMINATED,\n+            mx_cvt(mx_object_wait_one(self.handle.raw(), MX_TASK_TERMINATED,\n                                       MX_TIME_INFINITE, ptr::null_mut()))?;\n             mx_cvt(mx_object_get_info(self.handle.raw(), MX_INFO_PROCESS,\n                                       &mut proc_info as *mut _ as *mut libc::c_void,\n@@ -174,7 +174,7 @@ impl Process {\n         let mut avail: mx_size_t = 0;\n \n         unsafe {\n-            let status = mx_handle_wait_one(self.handle.raw(), MX_TASK_TERMINATED,\n+            let status = mx_object_wait_one(self.handle.raw(), MX_TASK_TERMINATED,\n                                             0, ptr::null_mut());\n             match status {\n                 0 => { }, // Success"}, {"sha": "666e2205b4a2680722ef2d340cb0f2b54dd98253", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -475,7 +475,7 @@ pub type BuiltinDeriveFn =\n     for<'cx> fn(&'cx mut ExtCtxt, Span, &MetaItem, &Annotatable, &mut FnMut(Annotatable));\n \n /// Represents different kinds of macro invocations that can be resolved.\n-#[derive(Clone, Copy, PartialEq, Eq)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum MacroKind {\n     /// A bang macro - foo!()\n     Bang,"}, {"sha": "c2b72edb66c6cbadbf0707d2243f04b13ae68736", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -200,9 +200,6 @@ declare_features! (\n     // rustc internal\n     (active, prelude_import, \"1.2.0\", None),\n \n-    // Allows the definition recursive static items.\n-    (active, static_recursion, \"1.3.0\", Some(29719)),\n-\n     // Allows default type parameters to influence type inference.\n     (active, default_type_parameter_fallback, \"1.3.0\", Some(27336)),\n \n@@ -326,6 +323,10 @@ declare_features! (\n     // `extern \"msp430-interrupt\" fn()`\n     (active, abi_msp430_interrupt, \"1.16.0\", Some(38487)),\n \n+    // Used to identify crates that contain sanitizer runtimes\n+    // rustc internal\n+    (active, closure_to_fn_coercion, \"1.17.0\", Some(39817)),\n+\n     // Used to identify crates that contain sanitizer runtimes\n     // rustc internal\n     (active, sanitizer_runtime, \"1.17.0\", None),\n@@ -387,6 +388,8 @@ declare_features! (\n     (accepted, static_in_const, \"1.17.0\", Some(35897)),\n     // Allows field shorthands (`x` meaning `x: x`) in struct literal expressions.\n     (accepted, field_init_shorthand, \"1.17.0\", Some(37340)),\n+    // Allows the definition recursive static items.\n+    (accepted, static_recursion, \"1.17.0\", Some(29719)),\n );\n // If you change this, please modify src/doc/unstable-book as well. You must\n // move that documentation into the relevant place in the other docs, and\n@@ -982,6 +985,9 @@ pub const EXPLAIN_DERIVE_UNDERSCORE: &'static str =\n pub const EXPLAIN_PLACEMENT_IN: &'static str =\n     \"placement-in expression syntax is experimental and subject to change.\";\n \n+pub const CLOSURE_TO_FN_COERCION: &'static str =\n+    \"non-capturing closure to fn coercion is experimental\";\n+\n struct PostExpansionVisitor<'a> {\n     context: &'a Context<'a>,\n }"}, {"sha": "58df1aae6d3f099815f5751b009e15745440d656", "filename": "src/test/COMPILER_TESTS.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2FCOMPILER_TESTS.md", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2FCOMPILER_TESTS.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2FCOMPILER_TESTS.md?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "previous_filename": "COMPILER_TESTS.md"}, {"sha": "76313b158ab1109422938a7368706a81838b5d9f", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -121,13 +121,13 @@ pub fn unsafe_slice(_: &[UnsafeInner]) {\n fn str(_: &[u8]) {\n }\n \n-// CHECK: @trait_borrow(i8* nonnull, void (i8*)** nonnull)\n+// CHECK: @trait_borrow(i8* nonnull, void (i8*)** noalias nonnull readonly)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n fn trait_borrow(_: &Drop) {\n }\n \n-// CHECK: @trait_box(i8* noalias nonnull, void (i8*)** nonnull)\n+// CHECK: @trait_box(i8* noalias nonnull, void (i8*)** noalias nonnull readonly)\n #[no_mangle]\n fn trait_box(_: Box<Drop>) {\n }"}, {"sha": "eac0be6f84874ca8fdf9e81259ed1dc16df56848", "filename": "src/test/compile-fail-fulldeps/proc-macro/resolve-error.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fresolve-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fresolve-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fresolve-error.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -22,15 +22,24 @@ extern crate attr_proc_macro;\n \n use attr_proc_macro::attr_proc_macro;\n \n-#[derive(FooWithLongNam)]\n-//~^ ERROR cannot find derive macro `FooWithLongNam` in this scope\n+macro_rules! FooWithLongNam {\n+    () => {}\n+}\n+\n+#[derive(FooWithLongNan)]\n+//~^ ERROR cannot find derive macro `FooWithLongNan` in this scope\n //~^^ HELP did you mean `FooWithLongName`?\n struct Foo;\n \n #[attr_proc_macra]\n //~^ ERROR cannot find attribute macro `attr_proc_macra` in this scope\n+//~^^ HELP did you mean `attr_proc_macro`?\n struct Bar;\n \n+#[FooWithLongNan]\n+//~^ ERROR cannot find attribute macro `FooWithLongNan` in this scope\n+struct Asdf;\n+\n #[derive(Dlone)]\n //~^ ERROR cannot find derive macro `Dlone` in this scope\n //~^^ HELP did you mean `Clone`?\n@@ -41,4 +50,18 @@ struct A;\n //~^^ HELP did you mean `Clona`?\n struct B;\n \n-fn main() {}\n+#[derive(attr_proc_macra)]\n+//~^ ERROR cannot find derive macro `attr_proc_macra` in this scope\n+struct C;\n+\n+fn main() {\n+    FooWithLongNama!();\n+    //~^ ERROR cannot find macro `FooWithLongNama!` in this scope\n+    //~^^ HELP did you mean `FooWithLongNam!`?\n+\n+    attr_proc_macra!();\n+    //~^ ERROR cannot find macro `attr_proc_macra!` in this scope\n+\n+    Dlona!();\n+    //~^ ERROR cannot find macro `Dlona!` in this scope\n+}"}, {"sha": "145662fd87c9e398881b1a65dcc7d576b2749166", "filename": "src/test/compile-fail/asm-bad-clobber.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fasm-bad-clobber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fasm-bad-clobber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-bad-clobber.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -13,6 +13,7 @@\n // ignore-aarch64\n // ignore-s390x\n // ignore-emscripten\n+// ignore-powerpc\n \n #![feature(asm, rustc_attrs)]\n "}, {"sha": "f0467e75223be992a2e03617299993646d1f89fe", "filename": "src/test/compile-fail/asm-in-bad-modifier.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fasm-in-bad-modifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fasm-in-bad-modifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-in-bad-modifier.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -10,6 +10,7 @@\n \n // ignore-s390x\n // ignore-emscripten\n+// ignore-powerpc\n \n #![feature(asm)]\n "}, {"sha": "37a267535317c2acdbb8bd1f56fdad110a785668", "filename": "src/test/compile-fail/asm-misplaced-option.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fasm-misplaced-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fasm-misplaced-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-misplaced-option.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -13,6 +13,7 @@\n // ignore-aarch64\n // ignore-s390x\n // ignore-emscripten\n+// ignore-powerpc\n \n #![feature(asm, rustc_attrs)]\n "}, {"sha": "3c4a5dcb7b038356947fdcc613734e2cd6884bec", "filename": "src/test/compile-fail/asm-out-assign-imm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fasm-out-assign-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fasm-out-assign-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-out-assign-imm.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -10,6 +10,7 @@\n \n // ignore-s390x\n // ignore-emscripten\n+// ignore-powerpc\n \n #![feature(asm)]\n "}, {"sha": "acf575c003a7df35acba97b33e1c02138f0b8819", "filename": "src/test/compile-fail/asm-out-no-modifier.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fasm-out-no-modifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fasm-out-no-modifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-out-no-modifier.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -10,6 +10,7 @@\n \n // ignore-s390x\n // ignore-emscripten\n+// ignore-powerpc\n \n #![feature(asm)]\n "}, {"sha": "bd180f6e5ebd945eaafb86673a8d9f48099fd443", "filename": "src/test/compile-fail/asm-out-read-uninit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fasm-out-read-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fasm-out-read-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-out-read-uninit.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -10,6 +10,7 @@\n \n // ignore-s390x\n // ignore-emscripten\n+// ignore-powerpc\n \n #![feature(asm)]\n "}, {"sha": "fe179e8a48f16e897879b57554d450e4740025bd", "filename": "src/test/compile-fail/closure-no-fn.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fclosure-no-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fclosure-no-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-no-fn.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ensure that capturing closures are never coerced to fns\n+// Especially interesting as non-capturing closures can be.\n+\n+fn main() {\n+    let mut a = 0u8;\n+    let foo: fn(u8) -> u8 = |v: u8| { a += v; a };\n+    //~^ ERROR mismatched types\n+    let b = 0u8;\n+    let bar: fn() -> u8 = || { b };\n+    //~^ ERROR mismatched types\n+    let baz: fn() -> u8 = || { b } as fn() -> u8;\n+    //~^ ERROR mismatched types\n+    //~^^ ERROR non-scalar cast\n+}"}, {"sha": "8cde239ca6edf0c8c3126d6de4e4a7b540dad199", "filename": "src/test/compile-fail/default_ty_param_conflict.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -23,8 +23,6 @@ fn main() {\n     // Here, F is instantiated with $0=uint\n     let x = foo();\n     //~^ ERROR: mismatched types\n-    //~| expected type `usize`\n-    //~| found type `isize`\n     //~| NOTE: conflicting type parameter defaults `usize` and `isize`\n     //~| NOTE: conflicting type parameter defaults `usize` and `isize`\n     //~| NOTE: ...that was applied to an unconstrained type variable here"}, {"sha": "e5b035e50aa931c625e36761098f26cd85a5f161", "filename": "src/test/compile-fail/default_ty_param_conflict_cross_crate.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict_cross_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict_cross_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict_cross_crate.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -29,6 +29,4 @@ fn main() {\n     //~| NOTE: conflicting type parameter defaults `bool` and `char`\n     //~| a second default is defined on `default_param_test::bleh`\n     //~| NOTE:  ...that was applied to an unconstrained type variable here\n-    //~| expected type `bool`\n-    //~| found type `char`\n }"}, {"sha": "d074a35628ea876994255253b5639923308f3175", "filename": "src/test/compile-fail/feature-gate-closure_to_fn_coercion.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Ffeature-gate-closure_to_fn_coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Ffeature-gate-closure_to_fn_coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-closure_to_fn_coercion.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-stage0: new feature, remove this when SNAP\n+// revisions: a b\n+\n+#[cfg(a)]\n+mod a {\n+    const FOO: fn(u8) -> u8 = |v: u8| { v };\n+    //[a]~^ ERROR non-capturing closure to fn coercion is experimental\n+    //[a]~^^ ERROR mismatched types\n+\n+    const BAR: [fn(&mut u32); 1] = [\n+        |v: &mut u32| *v += 1,\n+    //[a]~^ ERROR non-capturing closure to fn coercion is experimental\n+    //[a]~^^ ERROR mismatched types\n+    ];\n+}\n+\n+#[cfg(b)]\n+mod b {\n+    fn func_specific() -> (fn() -> u32) {\n+        || return 42\n+        //[b]~^ ERROR non-capturing closure to fn coercion is experimental\n+        //[b]~^^ ERROR mismatched types\n+    }\n+    fn foo() {\n+        // Items\n+        assert_eq!(func_specific()(), 42);\n+        let foo: fn(u8) -> u8 = |v: u8| { v };\n+        //[b]~^ ERROR non-capturing closure to fn coercion is experimental\n+        //[b]~^^ ERROR mismatched types\n+    }\n+\n+}\n+\n+\n+"}, {"sha": "bd20c891d8ed3f2a01a7b8fad162ceba0a5e8b14", "filename": "src/test/compile-fail/feature-gate-static_recursion.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e78aa5d7546d5db493ec12328368ab0c249c2a94/src%2Ftest%2Fcompile-fail%2Ffeature-gate-static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78aa5d7546d5db493ec12328368ab0c249c2a94/src%2Ftest%2Fcompile-fail%2Ffeature-gate-static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-static_recursion.rs?ref=e78aa5d7546d5db493ec12328368ab0c249c2a94", "patch": "@@ -1,49 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-static mut S: *const u8 = unsafe { &S as *const *const u8 as *const u8 };\n-//~^ ERROR recursive static (see issue #29719)\n-\n-struct StaticDoubleLinked {\n-    prev: &'static StaticDoubleLinked,\n-    next: &'static StaticDoubleLinked,\n-    data: i32,\n-    head: bool,\n-}\n-\n-static L1: StaticDoubleLinked = StaticDoubleLinked{prev: &L3, next: &L2, data: 1, head: true};\n-//~^ ERROR recursive static (see issue #29719)\n-//~^^ ERROR recursive static (see issue #29719)\n-//~^^^ ERROR recursive static (see issue #29719)\n-static L2: StaticDoubleLinked = StaticDoubleLinked{prev: &L1, next: &L3, data: 2, head: false};\n-static L3: StaticDoubleLinked = StaticDoubleLinked{prev: &L2, next: &L1, data: 3, head: false};\n-\n-\n-pub fn main() {\n-    unsafe { assert_eq!(S, *(S as *const *const u8)); }\n-\n-    let mut test_vec = Vec::new();\n-    let mut cur = &L1;\n-    loop {\n-        test_vec.push(cur.data);\n-        cur = cur.next;\n-        if cur.head { break }\n-    }\n-    assert_eq!(&test_vec, &[1,2,3]);\n-\n-    let mut test_vec = Vec::new();\n-    let mut cur = &L1;\n-    loop {\n-        cur = cur.prev;\n-        test_vec.push(cur.data);\n-        if cur.head { break }\n-    }\n-    assert_eq!(&test_vec, &[3,2,1]);\n-}"}, {"sha": "3bc8413cbca73b1a16a9ca3137e576bfdebb6e9b", "filename": "src/test/compile-fail/issue-3008-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(static_recursion)]\n-\n enum foo { foo_(bar) }\n struct bar { x: bar }\n //~^ ERROR E0072"}, {"sha": "d1d6390cce35b2347f91255033657c6559434bea", "filename": "src/test/compile-fail/issue-35869.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fissue-35869.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fissue-35869.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-35869.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -23,15 +23,19 @@ impl Foo for Bar {\n     fn foo(_: fn(u16) -> ()) {}\n     //~^ ERROR method `foo` has an incompatible type for trait\n     //~| NOTE expected u8\n+    //~| NOTE expected type `fn(fn(u8))`\n     fn bar(_: Option<u16>) {}\n     //~^ ERROR method `bar` has an incompatible type for trait\n     //~| NOTE expected u8\n+    //~| NOTE expected type `fn(std::option::Option<u8>)`\n     fn baz(_: (u16, u16)) {}\n     //~^ ERROR method `baz` has an incompatible type for trait\n     //~| NOTE expected u8\n+    //~| NOTE expected type `fn((u8, u16))`\n     fn qux() -> u16 { 5u16 }\n     //~^ ERROR method `qux` has an incompatible type for trait\n     //~| NOTE expected u8\n+    //~| NOTE expected type `fn() -> u8`\n }\n \n fn main() {}"}, {"sha": "efb0b249a8a59cbc84795eeebe51de8ef0026885", "filename": "src/test/compile-fail/issue-37131.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fissue-37131.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fissue-37131.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-37131.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -11,8 +11,8 @@\n // Tests that compiling for a target which is not installed will result in a helpful\n // error message.\n \n-// compile-flags: --target=s390x-unknown-linux-gnu\n-// ignore s390x\n+// compile-flags: --target=thumbv6m-none-eabi\n+// ignore-arm\n \n // error-pattern:target may not be installed\n fn main() { }"}, {"sha": "e3c1ada878df593d9e2367441b4c8cad61339a18", "filename": "src/test/compile-fail/issue-37576.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fissue-37576.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fissue-37576.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-37576.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    'test_1: while break 'test_1 {}\n+    while break {}\n+    //~^ ERROR `break` or `continue` with no label\n+\n+    'test_2: while let true = break 'test_2 {}\n+    while let true = break {}\n+    //~^ ERROR `break` or `continue` with no label\n+\n+    loop { 'test_3: while break 'test_3 {} }\n+    loop { while break {} }\n+    //~^ ERROR `break` or `continue` with no label\n+\n+    loop {\n+        'test_4: while break 'test_4 {}\n+        break;\n+    }\n+    loop {\n+        while break {}\n+        //~^ ERROR `break` or `continue` with no label\n+        break;\n+    }\n+\n+    'test_5: while continue 'test_5 {}\n+    while continue {}\n+    //~^ ERROR `break` or `continue` with no label\n+\n+    'test_6: while let true = continue 'test_6 {}\n+    while let true = continue {}\n+    //~^ ERROR `break` or `continue` with no label\n+\n+    loop { 'test_7: while continue 'test_7 {} }\n+    loop { while continue {} }\n+    //~^ ERROR `break` or `continue` with no label\n+\n+    loop {\n+        'test_8: while continue 'test_8 {}\n+        continue;\n+    }\n+    loop {\n+        while continue {}\n+        //~^ ERROR `break` or `continue` with no label\n+        continue;\n+    }\n+}"}, {"sha": "3affb1c03e952ab3bc8276794cbcb2acd8299148", "filename": "src/test/compile-fail/match-privately-empty.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fmatch-privately-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fmatch-privately-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-privately-empty.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(never_type)]\n+\n+mod private {\n+    pub struct Private {\n+        _bot: !,\n+        pub misc: bool,\n+    }\n+    pub const DATA: Option<Private> = None;\n+}\n+\n+fn main() {\n+    match private::DATA {\n+    //~^ ERROR non-exhaustive patterns: `Some(Private { misc: true, .. })` not covered\n+        None => {}\n+        Some(private::Private {\n+            misc: false,\n+            ..\n+        }) => {}\n+    }\n+}"}, {"sha": "6695e972f333731caa591f8d2c27f4c08b458580", "filename": "src/test/compile-fail/resolve-label.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fresolve-label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Fresolve-label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-label.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -17,8 +17,7 @@ fn f() {\n         }\n     }\n \n-    // issue #37353\n-    loop { 'w: while break 'w { } } //~ ERROR use of undeclared label\n+    loop { 'w: while break 'w { } }\n }\n \n fn main() {}"}, {"sha": "0c3ea53a903ae9062c03098e6ee2838a975b4a1a", "filename": "src/test/compile-fail/uninhabited-matches-feature-gated.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Funinhabited-matches-feature-gated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fcompile-fail%2Funinhabited-matches-feature-gated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funinhabited-matches-feature-gated.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -19,16 +19,13 @@ fn main() {\n     };\n \n     let x: &Void = unsafe { std::mem::uninitialized() };\n-    let _ = match x {};\n-    //~^ ERROR non-exhaustive\n+    let _ = match x {}; //~ ERROR non-exhaustive\n \n     let x: (Void,) = unsafe { std::mem::uninitialized() };\n-    let _ = match x {};\n-    //~^ ERROR non-exhaustive\n+    let _ = match x {}; //~ ERROR non-exhaustive\n \n     let x: [Void; 1] = unsafe { std::mem::uninitialized() };\n-    let _ = match x {};\n-    //~^ ERROR non-exhaustive\n+    let _ = match x {}; //~ ERROR non-exhaustive\n \n     let x: &[Void] = unsafe { std::mem::uninitialized() };\n     let _ = match x {   //~ ERROR non-exhaustive\n@@ -47,4 +44,3 @@ fn main() {\n     let Ok(x) = x;\n     //~^ ERROR refutable\n }\n-"}, {"sha": "a562eab1768f3d163358aed9d1a44d6d8849bdca", "filename": "src/test/incremental/issue-39828/auxiliary/generic.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fincremental%2Fissue-39828%2Fauxiliary%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fincremental%2Fissue-39828%2Fauxiliary%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-39828%2Fauxiliary%2Fgeneric.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions:rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n+\n+#![rustc_partition_reused(module=\"__rustc_fallback_codegen_unit\", cfg=\"rpass2\")]\n+#![feature(rustc_attrs)]\n+\n+#![crate_type=\"rlib\"]\n+pub fn foo<T>() { }"}, {"sha": "c729380bd5a31d764f6902387f5f68e42080d96f", "filename": "src/test/incremental/issue-39828/issue-39828.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fincremental%2Fissue-39828%2Fissue-39828.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fincremental%2Fissue-39828%2Fissue-39828.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-39828%2Fissue-39828.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #39828. If you make use of a module that\n+// consists only of generics, no code is generated, just a dummy\n+// module. The reduced graph consists of a single node (for that\n+// module) with no inputs. Since we only serialize edges, when we\n+// reload, we would consider that node dirty since it is not recreated\n+// (it is not the target of any edges).\n+\n+// revisions:rpass1 rpass2\n+// aux-build:generic.rs\n+\n+extern crate generic;\n+fn main() { }"}, {"sha": "30dc6fc5b20a028955ca4528de5e1db5f0abdd01", "filename": "src/test/parse-fail/range_inclusive_gate.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fparse-fail%2Frange_inclusive_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fparse-fail%2Frange_inclusive_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Frange_inclusive_gate.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// gate-test-inclusive_range_syntax\n+\n // Make sure that #![feature(inclusive_range_syntax)] is required.\n \n // #![feature(inclusive_range_syntax, inclusive_range)]"}, {"sha": "07b9c744a71711c33f87bad824fbdd4746dc8140", "filename": "src/test/run-make/graphviz-flowgraph/f10.dot-expected.dot", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff10.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff10.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff10.dot-expected.dot?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -5,10 +5,10 @@ digraph block {\n     N3[label=\"local mut x\"];\n     N4[label=\"stmt let mut x = 10;\"];\n     N5[label=\"(dummy_node)\"];\n-    N6[label=\"expr x\"];\n-    N7[label=\"expr 0\"];\n-    N8[label=\"expr x > 0\"];\n-    N9[label=\"expr while x > 0 { x -= 1; }\"];\n+    N6[label=\"expr while x > 0 { x -= 1; }\"];\n+    N7[label=\"expr x\"];\n+    N8[label=\"expr 0\"];\n+    N9[label=\"expr x > 0\"];\n     N10[label=\"expr 1\"];\n     N11[label=\"expr x\"];\n     N12[label=\"expr x -= 1\"];\n@@ -20,17 +20,17 @@ digraph block {\n     N2 -> N3;\n     N3 -> N4;\n     N4 -> N5;\n-    N5 -> N6;\n-    N6 -> N7;\n+    N5 -> N7;\n     N7 -> N8;\n     N8 -> N9;\n-    N8 -> N10;\n+    N9 -> N6;\n+    N9 -> N10;\n     N10 -> N11;\n     N11 -> N12;\n     N12 -> N13;\n     N13 -> N14;\n     N14 -> N5;\n-    N9 -> N15;\n+    N6 -> N15;\n     N15 -> N16;\n     N16 -> N1;\n }"}, {"sha": "c8bfcd6510b30054fd02295cc34bd62e033d5e94", "filename": "src/test/run-make/graphviz-flowgraph/f23.dot-expected.dot", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -11,28 +11,28 @@ digraph block {\n     N9[label=\"local mut z\"];\n     N10[label=\"stmt let mut z = 23;\"];\n     N11[label=\"(dummy_node)\"];\n-    N12[label=\"expr x\"];\n-    N13[label=\"expr 0\"];\n-    N14[label=\"expr x > 0\"];\n-    N15[label=\"expr while x > 0 {\\l    x -= 1;\\l    while y > 0 {\\l        y -= 1;\\l        while z > 0 { z -= 1; }\\l        if x > 10 { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N12[label=\"expr while x > 0 {\\l    x -= 1;\\l    while y > 0 {\\l        y -= 1;\\l        while z > 0 { z -= 1; }\\l        if x > 10 { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N13[label=\"expr x\"];\n+    N14[label=\"expr 0\"];\n+    N15[label=\"expr x > 0\"];\n     N16[label=\"expr 1\"];\n     N17[label=\"expr x\"];\n     N18[label=\"expr x -= 1\"];\n     N19[label=\"stmt x -= 1;\"];\n     N20[label=\"(dummy_node)\"];\n-    N21[label=\"expr y\"];\n-    N22[label=\"expr 0\"];\n-    N23[label=\"expr y > 0\"];\n-    N24[label=\"expr while y > 0 {\\l    y -= 1;\\l    while z > 0 { z -= 1; }\\l    if x > 10 { return; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N21[label=\"expr while y > 0 {\\l    y -= 1;\\l    while z > 0 { z -= 1; }\\l    if x > 10 { return; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N22[label=\"expr y\"];\n+    N23[label=\"expr 0\"];\n+    N24[label=\"expr y > 0\"];\n     N25[label=\"expr 1\"];\n     N26[label=\"expr y\"];\n     N27[label=\"expr y -= 1\"];\n     N28[label=\"stmt y -= 1;\"];\n     N29[label=\"(dummy_node)\"];\n-    N30[label=\"expr z\"];\n-    N31[label=\"expr 0\"];\n-    N32[label=\"expr z > 0\"];\n-    N33[label=\"expr while z > 0 { z -= 1; }\"];\n+    N30[label=\"expr while z > 0 { z -= 1; }\"];\n+    N31[label=\"expr z\"];\n+    N32[label=\"expr 0\"];\n+    N33[label=\"expr z > 0\"];\n     N34[label=\"expr 1\"];\n     N35[label=\"expr z\"];\n     N36[label=\"expr z -= 1\"];\n@@ -63,35 +63,35 @@ digraph block {\n     N8 -> N9;\n     N9 -> N10;\n     N10 -> N11;\n-    N11 -> N12;\n-    N12 -> N13;\n+    N11 -> N13;\n     N13 -> N14;\n     N14 -> N15;\n-    N14 -> N16;\n+    N15 -> N12;\n+    N15 -> N16;\n     N16 -> N17;\n     N17 -> N18;\n     N18 -> N19;\n     N19 -> N20;\n-    N20 -> N21;\n-    N21 -> N22;\n+    N20 -> N22;\n     N22 -> N23;\n     N23 -> N24;\n-    N23 -> N25;\n+    N24 -> N21;\n+    N24 -> N25;\n     N25 -> N26;\n     N26 -> N27;\n     N27 -> N28;\n     N28 -> N29;\n-    N29 -> N30;\n-    N30 -> N31;\n+    N29 -> N31;\n     N31 -> N32;\n     N32 -> N33;\n-    N32 -> N34;\n+    N33 -> N30;\n+    N33 -> N34;\n     N34 -> N35;\n     N35 -> N36;\n     N36 -> N37;\n     N37 -> N38;\n     N38 -> N29;\n-    N33 -> N39;\n+    N30 -> N39;\n     N39 -> N40;\n     N40 -> N41;\n     N41 -> N42;\n@@ -105,9 +105,9 @@ digraph block {\n     N48 -> N49;\n     N49 -> N50;\n     N50 -> N20;\n-    N24 -> N51;\n+    N21 -> N51;\n     N51 -> N11;\n-    N15 -> N52;\n+    N12 -> N52;\n     N52 -> N53;\n     N53 -> N1;\n }"}, {"sha": "7438ba21bfc4a064a7303e047ef553ef72fd28e4", "filename": "src/test/run-pass/auxiliary/clibrary.rs", "status": "renamed", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Fauxiliary%2Fclibrary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Fauxiliary%2Fclibrary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fclibrary.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static mut S: *const u8 = unsafe { &S as *const *const u8 as *const u8 };\n-//~^ ERROR recursive static\n+// no-prefer-dynamic\n+#![crate_type = \"staticlib\"]\n \n-pub fn main() {\n-    unsafe { assert_eq!(S, *(S as *const *const u8)); }\n-}\n+#[no_mangle]\n+pub extern \"C\" fn foo(x:i32) -> i32 { x }", "previous_filename": "src/test/compile-fail/static-recursion-gate.rs"}, {"sha": "5342601ac14ff9a937b00a9732eb8b04e6f868c9", "filename": "src/test/run-pass/auxiliary/issue_39823.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue_39823.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue_39823.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue_39823.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type=\"rlib\"]\n+\n+#[derive(Debug, PartialEq)]\n+pub struct RemoteC(pub u32);\n+\n+#[derive(Debug, PartialEq)]\n+pub struct RemoteG<T>(pub T);"}, {"sha": "13d1d6aa13900cf63193f7ba824c9dfa484c99f2", "filename": "src/test/run-pass/closure-to-fn-coercion.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Fclosure-to-fn-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Fclosure-to-fn-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-to-fn-coercion.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-stage0: new feature, remove this when SNAP\n+\n+#![feature(closure_to_fn_coercion)]\n+\n+const FOO: fn(u8) -> u8 = |v: u8| { v };\n+\n+const BAR: [fn(&mut u32); 5] = [\n+    |_: &mut u32| {},\n+    |v: &mut u32| *v += 1,\n+    |v: &mut u32| *v += 2,\n+    |v: &mut u32| *v += 3,\n+    |v: &mut u32| *v += 4,\n+];\n+fn func_specific() -> (fn() -> u32) {\n+    || return 42\n+}\n+\n+fn main() {\n+    // Items\n+    assert_eq!(func_specific()(), 42);\n+    let foo: fn(u8) -> u8 = |v: u8| { v };\n+    assert_eq!(foo(31), 31);\n+    // Constants\n+    assert_eq!(FOO(31), 31);\n+    let mut a: u32 = 0;\n+    assert_eq!({ BAR[0](&mut a); a }, 0);\n+    assert_eq!({ BAR[1](&mut a); a }, 1);\n+    assert_eq!({ BAR[2](&mut a); a }, 3);\n+    assert_eq!({ BAR[3](&mut a); a }, 6);\n+    assert_eq!({ BAR[4](&mut a); a }, 10);\n+}"}, {"sha": "c3a0dc67e83edf189a810ef6a053d3fe02cc42a8", "filename": "src/test/run-pass/issue-2063-resource.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Fissue-2063-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Fissue-2063-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2063-resource.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(static_recursion)]\n-\n // test that autoderef of a type like this does not\n // cause compiler to loop.  Note that no instances\n // of such a type could ever be constructed."}, {"sha": "5be4f8e8e73848813eeb780607f25fb646dec75d", "filename": "src/test/run-pass/issue-2063.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Fissue-2063.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Fissue-2063.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2063.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(static_recursion)]\n-\n // test that autoderef of a type like this does not\n // cause compiler to loop.  Note that no instances\n // of such a type could ever be constructed."}, {"sha": "d5df84e0fb083d9f51952cdb11341ce84706cb5c", "filename": "src/test/run-pass/issue-38972.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Fissue-38972.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Fissue-38972.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-38972.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This issue tracks a regression (a new warning) without\n+// feature(never_type). When we make that the default, please\n+// remove this test.\n+\n+enum Foo { }\n+\n+fn make_foo() -> Option<Foo> { None }\n+\n+#[deny(warnings)]\n+fn main() {\n+    match make_foo() {\n+        None => {},\n+        Some(_) => {}\n+    }\n+}"}, {"sha": "061a55b03b21884ba097dc0ea71dcff9c4a39f03", "filename": "src/test/run-pass/issue-39823.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Fissue-39823.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Fissue-39823.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-39823.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue_39823.rs\n+\n+extern crate issue_39823;\n+use issue_39823::{RemoteC, RemoteG};\n+\n+#[derive(Debug, PartialEq)]\n+struct LocalC(u32);\n+\n+#[derive(Debug, PartialEq)]\n+struct LocalG<T>(T);\n+\n+fn main() {\n+    let virtual_localc : &Fn(_) -> LocalC = &LocalC;\n+    assert_eq!(virtual_localc(1), LocalC(1));\n+\n+    let virtual_localg : &Fn(_) -> LocalG<u32> = &LocalG;\n+    assert_eq!(virtual_localg(1), LocalG(1));\n+\n+    let virtual_remotec : &Fn(_) -> RemoteC = &RemoteC;\n+    assert_eq!(virtual_remotec(1), RemoteC(1));\n+\n+    let virtual_remoteg : &Fn(_) -> RemoteG<u32> = &RemoteG;\n+    assert_eq!(virtual_remoteg(1), RemoteG(1));\n+}"}, {"sha": "a3a7179fb71127737106cf7d4cdca2dce365d272", "filename": "src/test/run-pass/iter-sum-overflow-overflow-checks.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Fiter-sum-overflow-overflow-checks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Fiter-sum-overflow-overflow-checks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-sum-overflow-overflow-checks.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C overflow-checks\n+\n+use std::panic;\n+\n+fn main() {\n+    let r = panic::catch_unwind(|| {\n+        [1, i32::max_value()].iter().sum::<i32>();\n+    });\n+    assert!(r.is_err());\n+\n+    let r = panic::catch_unwind(|| {\n+        [2, i32::max_value()].iter().product::<i32>();\n+    });\n+    assert!(r.is_err());\n+\n+    let r = panic::catch_unwind(|| {\n+        [1, i32::max_value()].iter().cloned().sum::<i32>();\n+    });\n+    assert!(r.is_err());\n+\n+    let r = panic::catch_unwind(|| {\n+        [2, i32::max_value()].iter().cloned().product::<i32>();\n+    });\n+    assert!(r.is_err());\n+}"}, {"sha": "a38080f8cfe75f6de210ae8ffadc0c1c9f793c35", "filename": "src/test/run-pass/lib-defaults.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Flib-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Flib-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-defaults.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:clibrary.rs\n+// compile-flags: -lclibrary\n+\n+#[link(name = \"clibrary\", kind = \"static\")]\n+extern \"C\" {\n+    pub fn foo(x:i32) -> i32;\n+}\n+\n+fn main() {\n+    unsafe {\n+        foo(42);\n+    }\n+}"}, {"sha": "4906a8e71d7a4fad61a4d5b57bbedb7e4d5f7500", "filename": "src/test/run-pass/loop-break-value.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Floop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Floop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Floop-break-value.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -124,10 +124,18 @@ pub fn main() {\n     assert_eq!(nested_break_value, \"hello\");\n \n     let break_from_while_cond = loop {\n-        while break {\n+        'inner_loop: while break 'inner_loop {\n             panic!();\n         }\n         break 123;\n     };\n     assert_eq!(break_from_while_cond, 123);\n+\n+    let break_from_while_to_outer = 'outer_loop: loop {\n+        while break 'outer_loop 567 {\n+            panic!(\"from_inner\");\n+        }\n+        panic!(\"from outer\");\n+    };\n+    assert_eq!(break_from_while_to_outer, 567);\n }"}, {"sha": "9bda07f077f062f0165950e3b162f940c69b68f6", "filename": "src/test/run-pass/panic-safe.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Fpanic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Fpanic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-safe.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![allow(dead_code)]\n-#![feature(recover)]\n \n use std::panic::{UnwindSafe, AssertUnwindSafe};\n use std::cell::RefCell;\n@@ -40,6 +39,10 @@ fn main() {\n     assert::<&RwLock<i32>>();\n     assert::<Rc<i32>>();\n     assert::<Arc<i32>>();\n+    assert::<Box<[u8]>>();\n+\n+    trait Trait: UnwindSafe {}\n+    assert::<Box<Trait>>();\n \n     fn bar<T>() {\n         assert::<Mutex<T>>();"}, {"sha": "4a6ba984eef0a085ecb5f4d33a76d9fd4db8392e", "filename": "src/test/run-pass/static-recursive.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Fstatic-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Frun-pass%2Fstatic-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-recursive.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(static_recursion)]\n-\n static mut S: *const u8 = unsafe { &S as *const *const u8 as *const u8 };\n \n struct StaticDoubleLinked {"}, {"sha": "d9871b8970c5cf22b1cd32b70b5b34bbc8f4c32d", "filename": "src/test/ui/mismatched_types/E0053.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fui%2Fmismatched_types%2FE0053.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fui%2Fmismatched_types%2FE0053.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2FE0053.stderr?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -6,6 +6,9 @@ error[E0053]: method `foo` has an incompatible type for trait\n ...\n 19 |     fn foo(x: i16) { }\n    |               ^^^ expected u16, found i16\n+   |\n+   = note: expected type `fn(u16)`\n+              found type `fn(i16)`\n \n error[E0053]: method `bar` has an incompatible type for trait\n   --> $DIR/E0053.rs:22:12"}, {"sha": "349432f64bbc20cf4af4839fe604639f2c6f7124", "filename": "src/test/ui/mismatched_types/trait-impl-fn-incompatibility.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fui%2Fmismatched_types%2Ftrait-impl-fn-incompatibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftest%2Fui%2Fmismatched_types%2Ftrait-impl-fn-incompatibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Ftrait-impl-fn-incompatibility.stderr?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -6,6 +6,9 @@ error[E0053]: method `foo` has an incompatible type for trait\n ...\n 21 |     fn foo(x: i16) { }\n    |               ^^^ expected u16, found i16\n+   |\n+   = note: expected type `fn(u16)`\n+              found type `fn(i16)`\n \n error[E0053]: method `bar` has an incompatible type for trait\n   --> $DIR/trait-impl-fn-incompatibility.rs:22:28"}, {"sha": "6d40dcacdba432df9c702f50424237f77f1778cb", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -215,6 +215,10 @@ impl Builder {\n         self.package(\"rust-docs\", &mut manifest.pkg, TARGETS);\n         self.package(\"rust-src\", &mut manifest.pkg, &[\"*\"]);\n \n+        if self.channel == \"rust-nightly\" {\n+            self.package(\"analysis\", &mut manifest.pkg, TARGETS);\n+        }\n+\n         let mut pkg = Package {\n             version: self.cached_version(\"rust\").to_string(),\n             target: HashMap::new(),\n@@ -264,6 +268,12 @@ impl Builder {\n                         target: target.to_string(),\n                     });\n                 }\n+                if self.channel == \"nightly\" {\n+                    extensions.push(Component {\n+                        pkg: \"rust-analysis\".to_string(),\n+                        target: target.to_string(),\n+                    });\n+                }\n             }\n             extensions.push(Component {\n                 pkg: \"rust-src\".to_string(),"}, {"sha": "1ec0838d45f7640a884a08e9cb6f2b021998cedc", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -1987,12 +1987,22 @@ actual:\\n\\\n     fn check_rustdoc_test_option(&self, res: ProcRes) {\n         let mut other_files = Vec::new();\n         let mut files: HashMap<String, Vec<usize>> = HashMap::new();\n-        files.insert(self.testpaths.file.to_str().unwrap().to_owned(),\n+        let cwd = env::current_dir().unwrap();\n+        files.insert(self.testpaths.file.strip_prefix(&cwd)\n+                                        .unwrap_or(&self.testpaths.file)\n+                                        .to_str()\n+                                        .unwrap()\n+                                        .replace('\\\\', \"/\"),\n                      self.get_lines(&self.testpaths.file, Some(&mut other_files)));\n         for other_file in other_files {\n             let mut path = self.testpaths.file.clone();\n             path.set_file_name(&format!(\"{}.rs\", other_file));\n-            files.insert(path.to_str().unwrap().to_owned(), self.get_lines(&path, None));\n+            files.insert(path.strip_prefix(&cwd)\n+                             .unwrap_or(&path)\n+                             .to_str()\n+                             .unwrap()\n+                             .replace('\\\\', \"/\"),\n+                         self.get_lines(&path, None));\n         }\n \n         let mut tested = 0;\n@@ -2002,7 +2012,8 @@ actual:\\n\\\n                                let tmp: Vec<&str> = s.split(\" - \").collect();\n                                if tmp.len() == 2 {\n                                    let path = tmp[0].rsplit(\"test \").next().unwrap();\n-                                   if let Some(ref mut v) = files.get_mut(path) {\n+                                   if let Some(ref mut v) = files.get_mut(\n+                                                                &path.replace('\\\\', \"/\")) {\n                                        tested += 1;\n                                        let mut iter = tmp[1].split(\"(line \");\n                                        iter.next();"}, {"sha": "2c81382bc9b08820b9f398b2ef56619610a0df54", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1572bf104dbf65d58bd6b889fa46229c9b92d6f9/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=1572bf104dbf65d58bd6b889fa46229c9b92d6f9", "patch": "@@ -116,7 +116,8 @@ pub fn check(path: &Path, bad: &mut bool) {\n     });\n \n     super::walk_many(&[&path.join(\"test/compile-fail\"),\n-                       &path.join(\"test/compile-fail-fulldeps\")],\n+                       &path.join(\"test/compile-fail-fulldeps\"),\n+                       &path.join(\"test/parse-fail\"),],\n                      &mut |path| super::filter_dirs(path),\n                      &mut |file| {\n         let filename = file.file_name().unwrap().to_string_lossy();\n@@ -169,8 +170,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n         \"abi_ptx\", \"simd\",\n         \"cfg_target_has_atomic\",\n         \"unboxed_closures\", \"stmt_expr_attributes\",\n-        \"cfg_target_thread_local\", \"unwind_attributes\",\n-        \"inclusive_range_syntax\"\n+        \"cfg_target_thread_local\", \"unwind_attributes\"\n     ];\n \n     // Only check the number of lang features."}]}