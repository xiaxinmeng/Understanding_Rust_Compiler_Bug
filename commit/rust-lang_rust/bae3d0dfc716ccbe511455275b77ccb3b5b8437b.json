{"sha": "bae3d0dfc716ccbe511455275b77ccb3b5b8437b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhZTNkMGRmYzcxNmNjYmU1MTE0NTUyNzViNzdjY2IzYjViODQzN2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-04T10:58:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-04T10:58:45Z"}, "message": "Auto merge of #68804 - ecstatic-morse:qualif-cursor-lazy, r=estebank\n\nAlways use lazy qualif getters during const-checking\n\n`has_mut_interior_eager_seek` was needed to work around an overly restrictive bound on the `per_local` argument to the `Qualif` trait. This PR makes that bound `FnMut` instead of `Fn` so we can seek cursors inside of it, resolving a FIXME in the const-checking code.", "tree": {"sha": "12a6f3230ec94b20d67dba7eade26d009480149a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12a6f3230ec94b20d67dba7eade26d009480149a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bae3d0dfc716ccbe511455275b77ccb3b5b8437b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bae3d0dfc716ccbe511455275b77ccb3b5b8437b", "html_url": "https://github.com/rust-lang/rust/commit/bae3d0dfc716ccbe511455275b77ccb3b5b8437b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bae3d0dfc716ccbe511455275b77ccb3b5b8437b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc07615c49259b16e1d1789e23050e71b744c652", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc07615c49259b16e1d1789e23050e71b744c652", "html_url": "https://github.com/rust-lang/rust/commit/fc07615c49259b16e1d1789e23050e71b744c652"}, {"sha": "21a040e7acd769038f392360aa785141b821ffa5", "url": "https://api.github.com/repos/rust-lang/rust/commits/21a040e7acd769038f392360aa785141b821ffa5", "html_url": "https://github.com/rust-lang/rust/commit/21a040e7acd769038f392360aa785141b821ffa5"}], "stats": {"total": 89, "additions": 36, "deletions": 53}, "files": [{"sha": "e509e8267cc1aa9172c166c8d00b82f26599db85", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bae3d0dfc716ccbe511455275b77ccb3b5b8437b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae3d0dfc716ccbe511455275b77ccb3b5b8437b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=bae3d0dfc716ccbe511455275b77ccb3b5b8437b", "patch": "@@ -34,7 +34,7 @@ pub trait Qualif {\n \n     fn in_projection_structurally(\n         cx: &ConstCx<'_, 'tcx>,\n-        per_local: &impl Fn(Local) -> bool,\n+        per_local: &mut impl FnMut(Local) -> bool,\n         place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n         if let [proj_base @ .., elem] = place.projection {\n@@ -66,15 +66,15 @@ pub trait Qualif {\n \n     fn in_projection(\n         cx: &ConstCx<'_, 'tcx>,\n-        per_local: &impl Fn(Local) -> bool,\n+        per_local: &mut impl FnMut(Local) -> bool,\n         place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n         Self::in_projection_structurally(cx, per_local, place)\n     }\n \n     fn in_place(\n         cx: &ConstCx<'_, 'tcx>,\n-        per_local: &impl Fn(Local) -> bool,\n+        per_local: &mut impl FnMut(Local) -> bool,\n         place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n         match place {\n@@ -85,7 +85,7 @@ pub trait Qualif {\n \n     fn in_operand(\n         cx: &ConstCx<'_, 'tcx>,\n-        per_local: &impl Fn(Local) -> bool,\n+        per_local: &mut impl FnMut(Local) -> bool,\n         operand: &Operand<'tcx>,\n     ) -> bool {\n         match *operand {\n@@ -126,7 +126,7 @@ pub trait Qualif {\n \n     fn in_rvalue_structurally(\n         cx: &ConstCx<'_, 'tcx>,\n-        per_local: &impl Fn(Local) -> bool,\n+        per_local: &mut impl FnMut(Local) -> bool,\n         rvalue: &Rvalue<'tcx>,\n     ) -> bool {\n         match *rvalue {\n@@ -170,15 +170,15 @@ pub trait Qualif {\n \n     fn in_rvalue(\n         cx: &ConstCx<'_, 'tcx>,\n-        per_local: &impl Fn(Local) -> bool,\n+        per_local: &mut impl FnMut(Local) -> bool,\n         rvalue: &Rvalue<'tcx>,\n     ) -> bool {\n         Self::in_rvalue_structurally(cx, per_local, rvalue)\n     }\n \n     fn in_call(\n         cx: &ConstCx<'_, 'tcx>,\n-        _per_local: &impl Fn(Local) -> bool,\n+        _per_local: &mut impl FnMut(Local) -> bool,\n         _callee: &Operand<'tcx>,\n         _args: &[Operand<'tcx>],\n         return_ty: Ty<'tcx>,\n@@ -208,7 +208,7 @@ impl Qualif for HasMutInterior {\n \n     fn in_rvalue(\n         cx: &ConstCx<'_, 'tcx>,\n-        per_local: &impl Fn(Local) -> bool,\n+        per_local: &mut impl FnMut(Local) -> bool,\n         rvalue: &Rvalue<'tcx>,\n     ) -> bool {\n         match *rvalue {\n@@ -249,7 +249,7 @@ impl Qualif for NeedsDrop {\n \n     fn in_rvalue(\n         cx: &ConstCx<'_, 'tcx>,\n-        per_local: &impl Fn(Local) -> bool,\n+        per_local: &mut impl FnMut(Local) -> bool,\n         rvalue: &Rvalue<'tcx>,\n     ) -> bool {\n         if let Rvalue::Aggregate(ref kind, _) = *rvalue {"}, {"sha": "b804dc4b5b6786ed9fa628539d5095143f2ac446", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bae3d0dfc716ccbe511455275b77ccb3b5b8437b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae3d0dfc716ccbe511455275b77ccb3b5b8437b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=bae3d0dfc716ccbe511455275b77ccb3b5b8437b", "patch": "@@ -71,8 +71,13 @@ where\n         return_place: &mir::Place<'tcx>,\n     ) {\n         let return_ty = return_place.ty(*self.item.body, self.item.tcx).ty;\n-        let qualif =\n-            Q::in_call(self.item, &|l| self.qualifs_per_local.contains(l), func, args, return_ty);\n+        let qualif = Q::in_call(\n+            self.item,\n+            &mut |l| self.qualifs_per_local.contains(l),\n+            func,\n+            args,\n+            return_ty,\n+        );\n         if !return_place.is_indirect() {\n             self.assign_qualif_direct(return_place, qualif);\n         }\n@@ -105,7 +110,7 @@ where\n         rvalue: &mir::Rvalue<'tcx>,\n         location: Location,\n     ) {\n-        let qualif = Q::in_rvalue(self.item, &|l| self.qualifs_per_local.contains(l), rvalue);\n+        let qualif = Q::in_rvalue(self.item, &mut |l| self.qualifs_per_local.contains(l), rvalue);\n         if !place.is_indirect() {\n             self.assign_qualif_direct(place, qualif);\n         }\n@@ -120,7 +125,8 @@ where\n         // here; that occurs in `apply_call_return_effect`.\n \n         if let mir::TerminatorKind::DropAndReplace { value, location: dest, .. } = kind {\n-            let qualif = Q::in_operand(self.item, &|l| self.qualifs_per_local.contains(l), value);\n+            let qualif =\n+                Q::in_operand(self.item, &mut |l| self.qualifs_per_local.contains(l), value);\n             if !dest.is_indirect() {\n                 self.assign_qualif_direct(dest, qualif);\n             }"}, {"sha": "35107a31aa122ca21119cf589d3e6ad1cf8e763f", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 16, "deletions": 39, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bae3d0dfc716ccbe511455275b77ccb3b5b8437b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae3d0dfc716ccbe511455275b77ccb3b5b8437b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=bae3d0dfc716ccbe511455275b77ccb3b5b8437b", "patch": "@@ -64,7 +64,7 @@ impl Qualifs<'a, 'mir, 'tcx> {\n     /// Returns `true` if `local` is `NeedsDrop` at the given `Location`.\n     ///\n     /// Only updates the cursor if absolutely necessary\n-    fn needs_drop_lazy_seek(&mut self, local: Local, location: Location) -> bool {\n+    fn needs_drop(&mut self, local: Local, location: Location) -> bool {\n         if !self.needs_drop.in_any_value_of_ty.contains(local) {\n             return false;\n         }\n@@ -76,7 +76,7 @@ impl Qualifs<'a, 'mir, 'tcx> {\n     /// Returns `true` if `local` is `HasMutInterior` at the given `Location`.\n     ///\n     /// Only updates the cursor if absolutely necessary.\n-    fn has_mut_interior_lazy_seek(&mut self, local: Local, location: Location) -> bool {\n+    fn has_mut_interior(&mut self, local: Local, location: Location) -> bool {\n         if !self.has_mut_interior.in_any_value_of_ty.contains(local) {\n             return false;\n         }\n@@ -86,17 +86,6 @@ impl Qualifs<'a, 'mir, 'tcx> {\n             || self.indirectly_mutable(local, location)\n     }\n \n-    /// Returns `true` if `local` is `HasMutInterior`, but requires the `has_mut_interior` and\n-    /// `indirectly_mutable` cursors to be updated beforehand.\n-    fn has_mut_interior_eager_seek(&self, local: Local) -> bool {\n-        if !self.has_mut_interior.in_any_value_of_ty.contains(local) {\n-            return false;\n-        }\n-\n-        self.has_mut_interior.cursor.get().contains(local)\n-            || self.indirectly_mutable.get().contains(local)\n-    }\n-\n     fn in_return_place(&mut self, item: &Item<'_, 'tcx>) -> ConstQualifs {\n         // Find the `Return` terminator if one exists.\n         //\n@@ -120,8 +109,8 @@ impl Qualifs<'a, 'mir, 'tcx> {\n         let return_loc = item.body.terminator_loc(return_block);\n \n         ConstQualifs {\n-            needs_drop: self.needs_drop_lazy_seek(RETURN_PLACE, return_loc),\n-            has_mut_interior: self.has_mut_interior_lazy_seek(RETURN_PLACE, return_loc),\n+            needs_drop: self.needs_drop(RETURN_PLACE, return_loc),\n+            has_mut_interior: self.has_mut_interior(RETURN_PLACE, return_loc),\n         }\n     }\n }\n@@ -244,23 +233,6 @@ impl Validator<'a, 'mir, 'tcx> {\n             self.check_op_spanned(ops::StaticAccess, span)\n         }\n     }\n-\n-    fn check_immutable_borrow_like(&mut self, location: Location, place: &Place<'tcx>) {\n-        // FIXME: Change the `in_*` methods to take a `FnMut` so we don't have to manually\n-        // seek the cursors beforehand.\n-        self.qualifs.has_mut_interior.cursor.seek_before(location);\n-        self.qualifs.indirectly_mutable.seek(location);\n-\n-        let borrowed_place_has_mut_interior = HasMutInterior::in_place(\n-            &self.item,\n-            &|local| self.qualifs.has_mut_interior_eager_seek(local),\n-            place.as_ref(),\n-        );\n-\n-        if borrowed_place_has_mut_interior {\n-            self.check_op(ops::CellBorrow);\n-        }\n-    }\n }\n \n impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n@@ -366,12 +338,17 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             Rvalue::AddressOf(Mutability::Mut, _) => self.check_op(ops::MutAddressOf),\n \n             Rvalue::Ref(_, BorrowKind::Shared, ref place)\n-            | Rvalue::Ref(_, BorrowKind::Shallow, ref place) => {\n-                self.check_immutable_borrow_like(location, place)\n-            }\n-\n-            Rvalue::AddressOf(Mutability::Not, ref place) => {\n-                self.check_immutable_borrow_like(location, place)\n+            | Rvalue::Ref(_, BorrowKind::Shallow, ref place)\n+            | Rvalue::AddressOf(Mutability::Not, ref place) => {\n+                let borrowed_place_has_mut_interior = HasMutInterior::in_place(\n+                    &self.item,\n+                    &mut |local| self.qualifs.has_mut_interior(local, location),\n+                    place.as_ref(),\n+                );\n+\n+                if borrowed_place_has_mut_interior {\n+                    self.check_op(ops::CellBorrow);\n+                }\n             }\n \n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n@@ -571,7 +548,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 let needs_drop = if let Some(local) = dropped_place.as_local() {\n                     // Use the span where the local was declared as the span of the drop error.\n                     err_span = self.body.local_decls[local].source_info.span;\n-                    self.qualifs.needs_drop_lazy_seek(local, location)\n+                    self.qualifs.needs_drop(local, location)\n                 } else {\n                     true\n                 };"}, {"sha": "9a7f3f86a6fcdf1b87792a2ab2b784f5fda272e6", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bae3d0dfc716ccbe511455275b77ccb3b5b8437b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae3d0dfc716ccbe511455275b77ccb3b5b8437b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=bae3d0dfc716ccbe511455275b77ccb3b5b8437b", "patch": "@@ -407,7 +407,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n     // FIXME(eddyb) maybe cache this?\n     fn qualif_local<Q: qualifs::Qualif>(&self, local: Local) -> bool {\n-        let per_local = &|l| self.qualif_local::<Q>(l);\n+        let per_local = &mut |l| self.qualif_local::<Q>(l);\n \n         if let TempState::Defined { location: loc, .. } = self.temps[local] {\n             let num_stmts = self.body[loc.block].statements.len();"}]}