{"sha": "9faef77b237baf8cf9908c799be162ab28a9aa84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmYWVmNzdiMjM3YmFmOGNmOTkwOGM3OTliZTE2MmFiMjhhOWFhODQ=", "commit": {"author": {"name": "Yuri Kunde Schlesner", "email": "yuriks@yuriks.net", "date": "2014-04-18T11:44:30Z"}, "committer": {"name": "Yuri Kunde Schlesner", "email": "yuriks@yuriks.net", "date": "2014-04-20T00:12:02Z"}, "message": "Eliminate the need for Options in LruEntry.\n\nLruEntry nodes previously used Option to encapsulate the key and value\nfields. This was used merely as a way avoid having values for the sigil\nnode. Apart from wasting a few bytes for the discriminant, this\ncluttered the rest of the code, since these fields always contained\nSome on regular nodes as a class invariant.\n\nThe Option wrapping was removed, and the values in the sigil field are\ninitialized using mem::init, so that they don't contain any real data.", "tree": {"sha": "5d3e7218853203d1705446234cedbb2503178792", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d3e7218853203d1705446234cedbb2503178792"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9faef77b237baf8cf9908c799be162ab28a9aa84", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9faef77b237baf8cf9908c799be162ab28a9aa84", "html_url": "https://github.com/rust-lang/rust/commit/9faef77b237baf8cf9908c799be162ab28a9aa84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9faef77b237baf8cf9908c799be162ab28a9aa84/comments", "author": {"login": "yuriks", "id": 341401, "node_id": "MDQ6VXNlcjM0MTQwMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/341401?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yuriks", "html_url": "https://github.com/yuriks", "followers_url": "https://api.github.com/users/yuriks/followers", "following_url": "https://api.github.com/users/yuriks/following{/other_user}", "gists_url": "https://api.github.com/users/yuriks/gists{/gist_id}", "starred_url": "https://api.github.com/users/yuriks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yuriks/subscriptions", "organizations_url": "https://api.github.com/users/yuriks/orgs", "repos_url": "https://api.github.com/users/yuriks/repos", "events_url": "https://api.github.com/users/yuriks/events{/privacy}", "received_events_url": "https://api.github.com/users/yuriks/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yuriks", "id": 341401, "node_id": "MDQ6VXNlcjM0MTQwMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/341401?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yuriks", "html_url": "https://github.com/yuriks", "followers_url": "https://api.github.com/users/yuriks/followers", "following_url": "https://api.github.com/users/yuriks/following{/other_user}", "gists_url": "https://api.github.com/users/yuriks/gists{/gist_id}", "starred_url": "https://api.github.com/users/yuriks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yuriks/subscriptions", "organizations_url": "https://api.github.com/users/yuriks/orgs", "repos_url": "https://api.github.com/users/yuriks/repos", "events_url": "https://api.github.com/users/yuriks/events{/privacy}", "received_events_url": "https://api.github.com/users/yuriks/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad4062e8af18b9631291e2c50bf0370ad2768e19", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad4062e8af18b9631291e2c50bf0370ad2768e19", "html_url": "https://github.com/rust-lang/rust/commit/ad4062e8af18b9631291e2c50bf0370ad2768e19"}], "stats": {"total": 63, "additions": 21, "deletions": 42}, "files": [{"sha": "0b7199661f8e3de96ef8ab6dd9a7ccf00f8bf40b", "filename": "src/libcollections/lru_cache.rs", "status": "modified", "additions": 21, "deletions": 42, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9faef77b237baf8cf9908c799be162ab28a9aa84/src%2Flibcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faef77b237baf8cf9908c799be162ab28a9aa84/src%2Flibcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flru_cache.rs?ref=9faef77b237baf8cf9908c799be162ab28a9aa84", "patch": "@@ -41,17 +41,18 @@ use std::cast;\n use std::container::Container;\n use std::hash::Hash;\n use std::fmt;\n+use std::mem;\n use std::ptr;\n \n use HashMap;\n \n struct KeyRef<K> { k: *K }\n \n struct LruEntry<K, V> {\n-    key: Option<K>,\n-    value: Option<V>,\n     next: *mut LruEntry<K, V>,\n     prev: *mut LruEntry<K, V>,\n+    key: K,\n+    value: V,\n }\n \n /// An LRU Cache.\n@@ -76,19 +77,10 @@ impl<K: Eq> Eq for KeyRef<K> {\n impl<K: TotalEq> TotalEq for KeyRef<K> {}\n \n impl<K, V> LruEntry<K, V> {\n-    fn new() -> LruEntry<K, V> {\n+    fn new(k: K, v: V) -> LruEntry<K, V> {\n         LruEntry {\n-            key: None,\n-            value: None,\n-            next: ptr::mut_null(),\n-            prev: ptr::mut_null(),\n-        }\n-    }\n-\n-    fn with_key_value(k: K, v: V) -> LruEntry<K, V> {\n-        LruEntry {\n-            key: Some(k),\n-            value: Some(v),\n+            key: k,\n+            value: v,\n             next: ptr::mut_null(),\n             prev: ptr::mut_null(),\n         }\n@@ -101,7 +93,7 @@ impl<K: Hash + TotalEq, V> LruCache<K, V> {\n         let cache = LruCache {\n             map: HashMap::new(),\n             max_size: capacity,\n-            head: unsafe{ cast::transmute(~LruEntry::<K, V>::new()) },\n+            head: unsafe{ cast::transmute(~mem::uninit::<LruEntry<K, V>>()) },\n         };\n         unsafe {\n             (*cache.head).next = cache.head;\n@@ -114,23 +106,24 @@ impl<K: Hash + TotalEq, V> LruCache<K, V> {\n     pub fn put(&mut self, k: K, v: V) {\n         let (node_ptr, node_opt) = match self.map.find_mut(&KeyRef{k: &k}) {\n             Some(node) => {\n-                node.value = Some(v);\n+                node.value = v;\n                 let node_ptr: *mut LruEntry<K, V> = &mut **node;\n                 (node_ptr, None)\n             }\n             None => {\n-                let mut node = ~LruEntry::with_key_value(k, v);\n+                let mut node = ~LruEntry::new(k, v);\n                 let node_ptr: *mut LruEntry<K, V> = &mut *node;\n                 (node_ptr, Some(node))\n             }\n         };\n         match node_opt {\n             None => {\n+                // Existing node, just update LRU position\n                 self.detach(node_ptr);\n                 self.attach(node_ptr);\n             }\n             Some(node) => {\n-                let keyref = unsafe { (*node_ptr).key.as_ref().unwrap() };\n+                let keyref = unsafe { &(*node_ptr).key };\n                 self.map.swap(KeyRef{k: keyref}, node);\n                 self.attach(node_ptr);\n                 if self.len() > self.capacity() {\n@@ -146,12 +139,7 @@ impl<K: Hash + TotalEq, V> LruCache<K, V> {\n             None => (None, None),\n             Some(node) => {\n                 let node_ptr: *mut LruEntry<K, V> = &mut **node;\n-                unsafe {\n-                    match (*node_ptr).value {\n-                        None => (None, None),\n-                        Some(ref value) => (Some(value), Some(node_ptr))\n-                    }\n-                }\n+                (Some(unsafe { &(*node_ptr).value }), Some(node_ptr))\n             }\n         };\n         match node_ptr_opt {\n@@ -168,7 +156,7 @@ impl<K: Hash + TotalEq, V> LruCache<K, V> {\n     pub fn pop(&mut self, k: &K) -> Option<V> {\n         match self.map.pop(&KeyRef{k: k}) {\n             None => None,\n-            Some(lru_entry) => lru_entry.value\n+            Some(lru_entry) => Some(lru_entry.value)\n         }\n     }\n \n@@ -191,12 +179,7 @@ impl<K: Hash + TotalEq, V> LruCache<K, V> {\n         if self.len() > 0 {\n             let lru = unsafe { (*self.head).prev };\n             self.detach(lru);\n-            unsafe {\n-                match (*lru).key {\n-                    None => (),\n-                    Some(ref k) => { self.map.pop(&KeyRef{k: k}); }\n-                }\n-            }\n+            self.map.pop(&KeyRef{k: unsafe { &(*lru).key }});\n         }\n     }\n \n@@ -229,19 +212,11 @@ impl<A: fmt::Show + Hash + TotalEq, B: fmt::Show> fmt::Show for LruCache<A, B> {\n             if i > 0 { try!(write!(f.buf, \", \")) }\n             unsafe {\n                 cur = (*cur).next;\n-                match (*cur).key {\n-                    // should never print nil\n-                    None => try!(write!(f.buf, \"nil\")),\n-                    Some(ref k) => try!(write!(f.buf, \"{}\", *k)),\n-                }\n+                try!(write!(f.buf, \"{}\", (*cur).key));\n             }\n             try!(write!(f.buf, \": \"));\n             unsafe {\n-                match (*cur).value {\n-                    // should never print nil\n-                    None => try!(write!(f.buf, \"nil\")),\n-                    Some(ref value) => try!(write!(f.buf, \"{}\", *value)),\n-                }\n+                try!(write!(f.buf, \"{}\", (*cur).value));\n             }\n         }\n         write!(f.buf, r\"\\}\")\n@@ -266,7 +241,11 @@ impl<K: Hash + TotalEq, V> Mutable for LruCache<K, V> {\n impl<K, V> Drop for LruCache<K, V> {\n     fn drop(&mut self) {\n         unsafe {\n-            let _: ~LruEntry<K, V> = cast::transmute(self.head);\n+            let node: ~LruEntry<K, V> = cast::transmute(self.head);\n+            // Prevent compiler from trying to drop the un-initialized field in the sigil node.\n+            let ~LruEntry { key: k, value: v, .. } = node;\n+            cast::forget(k);\n+            cast::forget(v);\n         }\n     }\n }"}]}