{"sha": "a5bca7df8842fe816a0288e1dd13226ceb9ec6fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1YmNhN2RmODg0MmZlODE2YTAyODhlMWRkMTMyMjZjZWI5ZWM2ZmI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-15T22:14:30Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-15T22:38:12Z"}, "message": "Refactor data structures representing constraints (again...)\n\nI added a \"resolved\" version of the ast::constr type -- ty::constr_def\n-- that has a def_id field instead of an ann_field. This is more\nconsistent with other types and eliminates some checking.\n\nIncidentally, I removed the def_map argument to the top-level function\nin middle::alias, since the ty::ctxt already has a def_map field.", "tree": {"sha": "6e7a9c7f219b9af97650d29d3807b2721aa7b232", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e7a9c7f219b9af97650d29d3807b2721aa7b232"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb", "html_url": "https://github.com/rust-lang/rust/commit/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52d4f48144e864b9b8e8d82b757bd8969f1fa8a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/52d4f48144e864b9b8e8d82b757bd8969f1fa8a8", "html_url": "https://github.com/rust-lang/rust/commit/52d4f48144e864b9b8e8d82b757bd8969f1fa8a8"}], "stats": {"total": 498, "additions": 265, "deletions": 233}, "files": [{"sha": "e0a6d28f2b7ef897aacc3c7ab7c44574191918a8", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=a5bca7df8842fe816a0288e1dd13226ceb9ec6fb", "patch": "@@ -81,18 +81,18 @@ fn compile_input(session::session sess, eval::env env, str input,\n     auto crate =\n         time(time_passes, \"parsing\", bind parse_input(sess, p, input));\n     if (sess.get_opts().output_type == link::output_type_none) { ret; }\n-    auto def_map =\n+    auto d =\n         time(time_passes, \"resolution\",\n              bind resolve::resolve_crate(sess, crate));\n-    auto ty_cx = ty::mk_ctxt(sess, def_map);\n+    auto ty_cx = ty::mk_ctxt(sess, d._0, d._1);\n     time[()](time_passes, \"typechecking\",\n              bind typeck::check_crate(ty_cx, crate));\n     if (sess.get_opts().run_typestate) {\n         time(time_passes, \"typestate checking\",\n              bind middle::tstate::ck::check_crate(ty_cx, crate));\n     }\n     time(time_passes, \"alias checking\",\n-         bind middle::alias::check_crate(@ty_cx, def_map, crate));\n+         bind middle::alias::check_crate(@ty_cx, crate));\n     auto llmod =\n         time[llvm::llvm::ModuleRef](time_passes, \"translation\",\n                                     bind trans::trans_crate(sess, crate,\n@@ -109,8 +109,8 @@ fn pretty_print_input(session::session sess, eval::env env, str input,\n     auto mode;\n     alt (ppm) {\n         case (ppm_typed) {\n-            auto def_map = resolve::resolve_crate(sess, crate);\n-            auto ty_cx = ty::mk_ctxt(sess, def_map);\n+            auto d = resolve::resolve_crate(sess, crate);\n+            auto ty_cx = ty::mk_ctxt(sess, d._0, d._1);\n             typeck::check_crate(ty_cx, crate);\n             mode = ppaux::mo_typed(ty_cx);\n         }"}, {"sha": "b66c286f32596a462fa3f478950b03b360c892fa", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=a5bca7df8842fe816a0288e1dd13226ceb9ec6fb", "patch": "@@ -359,19 +359,17 @@ tag constr_arg_general_[T] { carg_base; carg_ident(T); carg_lit(@lit); }\n \n type constr_arg = constr_arg_general[uint];\n \n-type constr_arg_use = constr_arg_general[ident];\n-\n type constr_arg_general[T] = spanned[constr_arg_general_[T]];\n \n+type constr_ = rec(path path,\n+                   vec[@constr_arg_general[uint]] args,\n+                   ann ann);\n \n-// The ann field is there so that using the def_map in the type\n-// context, we can get the def_id for the path.\n-type constr_general[T] =\n-    rec(path path, vec[@constr_arg_general[T]] args, ann ann);\n-\n-type constr = spanned[constr_general[uint]];\n+type constr = spanned[constr_];\n \n-type constr_use = spanned[constr_general[ident]];\n+/* The parser generates ast::constrs; resolve generates\n+ a mapping from each function to a list of ty::constr_defs,\n+ corresponding to these. */\n \n type arg = rec(mode mode, @ty ty, ident ident, def_id id);\n "}, {"sha": "98004bf6961b0c31ee0ec694d48cb9afa455f249", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=a5bca7df8842fe816a0288e1dd13226ceb9ec6fb", "patch": "@@ -78,8 +78,8 @@ fn parse_ty_or_bang(@pstate st, str_def sd) -> ty_or_bang {\n     }\n }\n \n-fn parse_constrs(@pstate st, str_def sd) -> vec[@ast::constr] {\n-    let vec[@ast::constr] res = [];\n+fn parse_constrs(@pstate st, str_def sd) -> vec[@ty::constr_def] {\n+    let vec[@ty::constr_def] res = [];\n     alt (peek(st) as char) {\n         case (':') {\n             do  {\n@@ -92,7 +92,7 @@ fn parse_constrs(@pstate st, str_def sd) -> vec[@ast::constr] {\n     ret res;\n }\n \n-fn parse_constr(@pstate st, str_def sd) -> @ast::constr {\n+fn parse_constr(@pstate st, str_def sd) -> @ty::constr_def {\n     st.tcx.sess.unimpl(\"Reading constraints \" + \" isn't implemented\");\n     /*\n     let vec[@ast::constr_arg] args = [];\n@@ -318,7 +318,7 @@ fn parse_hex(@pstate st) -> uint {\n }\n \n fn parse_ty_fn(@pstate st, str_def sd) ->\n-   tup(vec[ty::arg], ty::t, ast::controlflow, vec[@ast::constr]) {\n+   tup(vec[ty::arg], ty::t, ast::controlflow, vec[@ty::constr_def]) {\n     assert (next(st) as char == '[');\n     let vec[ty::arg] inputs = [];\n     while (peek(st) as char != ']') {"}, {"sha": "57cb33b8af60f5a25dbcf7d1ddf968126e7d5d5c", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=a5bca7df8842fe816a0288e1dd13226ceb9ec6fb", "patch": "@@ -35,14 +35,11 @@ tag local_info { arg(ast::mode); objfield(ast::mutability); }\n \n type ctx =\n     rec(@ty::ctxt tcx,\n-        resolve::def_map dm,\n         std::map::hashmap[def_num, local_info] local_map);\n \n-fn check_crate(@ty::ctxt tcx, resolve::def_map dm, &@ast::crate crate) {\n+fn check_crate(@ty::ctxt tcx, &@ast::crate crate) {\n     auto cx =\n         @rec(tcx=tcx,\n-             dm=dm,\n-\n              // Stores information about object fields and function\n              // arguments that's otherwise not easily available.\n              local_map=util::common::new_int_hash());\n@@ -173,7 +170,7 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n     if (vec::len(unsafe_ts) > 0u) {\n         alt (f.node) {\n             case (ast::expr_path(_, ?ann)) {\n-                if (def_is_local(cx.dm.get(ann.id), true)) {\n+                if (def_is_local(cx.tcx.def_map.get(ann.id), true)) {\n                     cx.tcx.sess.span_err\n                         (f.span, #fmt(\"function may alias with argument \\\n                          %u, which is not immutably rooted\",\n@@ -231,7 +228,7 @@ fn check_tail_call(&ctx cx, &@ast::expr call) {\n             auto ok = true;\n             alt (args.(i).node) {\n                 case (ast::expr_path(_, ?ann)) {\n-                    auto def = cx.dm.get(ann.id);\n+                    auto def = cx.tcx.def_map.get(ann.id);\n                     auto dnum = ast::def_id_of_def(def)._1;\n                     alt (cx.local_map.find(dnum)) {\n                         case (some(arg(ast::alias(?mut)))) {\n@@ -353,7 +350,7 @@ fn check_for(&ctx cx, &@ast::local local, &@ast::expr seq, &ast::block block,\n \n fn check_var(&ctx cx, &@ast::expr ex, &ast::path p, ast::ann ann, bool assign,\n              &scope sc) {\n-    auto def = cx.dm.get(ann.id);\n+    auto def = cx.tcx.def_map.get(ann.id);\n     if (!def_is_local(def, true)) { ret; }\n     auto my_defnum = ast::def_id_of_def(def)._1;\n     auto var_t = ty::expr_ty(*cx.tcx, ex);\n@@ -379,7 +376,7 @@ fn check_assign(&@ctx cx, &@ast::expr dest, &@ast::expr src, &scope sc,\n     visit_expr(cx, src, sc, v);\n     alt (dest.node) {\n         case (ast::expr_path(?p, ?ann)) {\n-            auto dnum = ast::def_id_of_def(cx.dm.get(ann.id))._1;\n+            auto dnum = ast::def_id_of_def(cx.tcx.def_map.get(ann.id))._1;\n             if (is_immutable_alias(cx, sc, dnum)) {\n                 cx.tcx.sess.span_err(dest.span,\n                                      \"assigning to immutable alias\");\n@@ -566,7 +563,7 @@ fn inner_mut(&vec[deref] ds) -> option::t[ty::t] {\n fn path_def_id(&ctx cx, &@ast::expr ex) -> option::t[ast::def_id] {\n     alt (ex.node) {\n         case (ast::expr_path(_, ?ann)) {\n-            ret some(ast::def_id_of_def(cx.dm.get(ann.id)));\n+            ret some(ast::def_id_of_def(cx.tcx.def_map.get(ann.id)));\n         }\n         case (_) { ret none; }\n     }"}, {"sha": "dc2acfa6ca74e536bdd225c5a92804a853aee3f1", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=a5bca7df8842fe816a0288e1dd13226ceb9ec6fb", "patch": "@@ -221,8 +221,7 @@ mod Encode {\n                     case (ast::native_abi_cdecl) { w.write_char('c'); }\n                     case (ast::native_abi_llvm) { w.write_char('l'); }\n                 }\n-                let vec[@constr] res_constrs = [];\n-                enc_ty_fn(w, cx, args, out, ast::return, res_constrs);\n+                enc_ty_fn(w, cx, args, out, ast::return, []);\n             }\n             case (ty::ty_obj(?methods)) {\n                 w.write_str(\"O[\");\n@@ -253,7 +252,7 @@ mod Encode {\n         }\n     }\n     fn enc_ty_fn(&io::writer w, &@ctxt cx, &vec[ty::arg] args, &ty::t out,\n-                 &ast::controlflow cf, &vec[@ast::constr] constrs) {\n+                 &ast::controlflow cf, &vec[@ty::constr_def] constrs) {\n         w.write_char('[');\n         for (ty::arg arg in args) {\n             alt (arg.mode) {\n@@ -271,15 +270,15 @@ mod Encode {\n             case (_) { enc_ty(w, cx, out); }\n         }\n         auto colon = true;\n-        for (@ast::constr c in constrs) {\n+        for (@ty::constr_def c in constrs) {\n             if (colon) {\n                 w.write_char(':');\n                 colon = false;\n             } else { w.write_char(','); }\n             enc_constr(w, cx, c);\n         }\n     }\n-    fn enc_constr(&io::writer w, &@ctxt cx, &@ast::constr c) {\n+    fn enc_constr(&io::writer w, &@ctxt cx, &@ty::constr_def c) {\n         w.write_str(path_to_str(c.node.path));\n         w.write_char('(');\n         // FIXME"}, {"sha": "4d20216564ca575f61801165b4bce87fc515cf72", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 57, "deletions": 15, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=a5bca7df8842fe816a0288e1dd13226ceb9ec6fb", "patch": "@@ -11,7 +11,8 @@ import util::common::new_int_hash;\n import util::common::new_uint_hash;\n import util::common::new_str_hash;\n import util::common::span;\n-import middle::tstate::ann::ts_ann;\n+import util::common::respan;\n+import middle::ty::constr_table;\n import visit::vt;\n import std::map::hashmap;\n import std::list;\n@@ -111,24 +112,26 @@ type def_map = hashmap[uint, def];\n type env =\n     rec(crate_map crate_map,\n         def_map def_map,\n+        constr_table fn_constrs,\n         hashmap[def_id, @ast::item] ast_map,\n         hashmap[ast::def_num, import_state] imports,\n         hashmap[ast::def_num, @indexed_mod] mod_map,\n         hashmap[def_id, vec[ident]] ext_map,\n         ext_hash ext_cache,\n         session sess);\n \n-\n // Used to distinguish between lookups from outside and from inside modules,\n // since export restrictions should only be applied for the former.\n tag dir { inside; outside; }\n \n tag namespace { ns_value; ns_type; ns_module; }\n \n-fn resolve_crate(session sess, @ast::crate crate) -> def_map {\n+fn resolve_crate(session sess, @ast::crate crate)\n+    -> tup(def_map, constr_table) {\n     auto e =\n         @rec(crate_map=new_uint_hash[ast::crate_num](),\n              def_map=new_uint_hash[def](),\n+             fn_constrs = new_def_hash[vec[ty::constr_def]](),\n              ast_map=new_def_hash[@ast::item](),\n              imports=new_int_hash[import_state](),\n              mod_map=new_int_hash[@indexed_mod](),\n@@ -140,7 +143,7 @@ fn resolve_crate(session sess, @ast::crate crate) -> def_map {\n     resolve_imports(*e);\n     check_for_collisions(e, *crate);\n     resolve_names(e, crate);\n-    ret e.def_map;\n+    ret tup(e.def_map, e.fn_constrs);\n }\n \n \n@@ -266,8 +269,9 @@ fn resolve_names(&@env e, &@ast::crate c) {\n              visit_arm=bind walk_arm(e, _, _, _),\n              visit_expr=bind walk_expr(e, _, _, _),\n              visit_ty=bind walk_ty(e, _, _, _),\n-             visit_fn=visit_fn_with_scope,\n-             visit_constr=bind walk_constr(e, _, _, _)\n+             visit_constr = bind walk_constr(e, _, _, _),\n+             visit_fn=bind visit_fn_with_scope\n+                        (e, _, _, _, _, _, _, _, _)\n              with *visit::default_visitor());\n     visit::visit_crate(*c, cons(scope_crate(c), @nil), visit::vtor(v));\n     fn walk_expr(@env e, &@ast::expr exp, &scopes sc, &vt[scopes] v) {\n@@ -282,12 +286,7 @@ fn resolve_names(&@env e, &@ast::crate c) {\n             case (_) { }\n         }\n     }\n-    fn walk_constr(@env e, &@ast::constr c, &scopes sc, &vt[scopes] v) {\n-        auto new_def =\n-            lookup_path_strict(*e, sc, c.span, c.node.path.node.idents,\n-                               ns_value);\n-        e.def_map.insert(c.node.ann.id, new_def);\n-    }\n+\n     fn walk_ty(@env e, &@ast::ty t, &scopes sc, &vt[scopes] v) {\n         visit::visit_ty(t, sc, v);\n         alt (t.node) {\n@@ -300,6 +299,13 @@ fn resolve_names(&@env e, &@ast::crate c) {\n             case (_) { }\n         }\n     }\n+\n+    fn walk_constr(@env e, &@ast::constr c, &scopes sc, &vt[scopes] v) {\n+        auto new_def = lookup_path_strict(*e, sc, c.span,\n+                                          c.node.path.node.idents, ns_value);\n+        e.def_map.insert(c.node.ann.id, new_def);\n+    }\n+\n     fn walk_arm(@env e, &ast::arm a, &scopes sc, &vt[scopes] v) {\n         walk_pat(*e, sc, a.pat);\n         visit_arm_with_scope(a, sc, v);\n@@ -338,11 +344,16 @@ fn visit_native_item_with_scope(&@ast::native_item ni, &scopes sc,\n     visit::visit_native_item(ni, cons(scope_native_item(ni), @sc), v);\n }\n \n-fn visit_fn_with_scope(&ast::_fn f, &vec[ast::ty_param] tp, &span sp,\n+fn visit_fn_with_scope(&@env e, &ast::_fn f, &vec[ast::ty_param] tp, &span sp,\n                        &ident name, &def_id d_id, &ann a, &scopes sc,\n                        &vt[scopes] v) {\n-    visit::visit_fn(f, tp, sp, name, d_id, a, cons(scope_fn(f.decl, tp), @sc),\n-                    v);\n+    // here's where we need to set up the mapping\n+    // for f's constrs in the table.\n+    for (@ast::constr c in f.decl.constraints) {\n+        resolve_constr(e, d_id, c, sc, v); \n+    }\n+    visit::visit_fn(f, tp, sp, name, d_id, a,\n+                    cons(scope_fn(f.decl, tp), @sc), v);\n }\n \n fn visit_block_with_scope(&ast::block b, &scopes sc, &vt[scopes] v) {\n@@ -389,6 +400,37 @@ fn follow_import(&env e, &scopes sc, vec[ident] path, &span sp) -> def {\n     }\n }\n \n+fn resolve_constr(@env e, &def_id d_id, &@ast::constr c, &scopes sc,\n+                  &vt[scopes] v) {\n+    let def new_def = lookup_path_strict(*e, sc, c.span,\n+                                         c.node.path.node.idents,\n+                                         ns_value);\n+    alt (new_def) {\n+        case (ast::def_fn(?pred_id)) {\n+            let ty::constr_general[uint] c_ = rec(path=c.node.path,\n+                                                  args=c.node.args,\n+                                                  id=pred_id);\n+            let ty::constr_def new_constr = respan(c.span, c_);\n+            add_constr(e, d_id, new_constr);\n+        }\n+        case (_) {\n+            e.sess.span_err(c.span, \"Non-predicate in constraint: \"\n+                            + ty::path_to_str(c.node.path));\n+        }\n+    }\n+}\n+\n+fn add_constr(&@env e, &def_id d_id, &ty::constr_def c) {\n+    e.fn_constrs.insert(d_id,\n+       alt (e.fn_constrs.find(d_id)) {\n+          case (none) {\n+              [c]\n+          }\n+          case (some(?cs)) {\n+              cs + [c]\n+          }\n+       });\n+}\n \n // Import resolution\n fn resolve_import(&env e, &@ast::view_item it, &scopes sc) {"}, {"sha": "db61c9be18986f19a74ccf640068a9551504d41a", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=a5bca7df8842fe816a0288e1dd13226ceb9ec6fb", "patch": "@@ -198,8 +198,9 @@ to represent predicate *arguments* however. This type\n Both types store an ident and span, for error-logging purposes.\n */\n type pred_desc_ = rec(vec[@constr_arg_use] args, uint bit_num);\n-\n type pred_desc = spanned[pred_desc_];\n+type constr_arg_use = constr_arg_general[ident];\n+\n \n tag constraint {\n     cinit(uint, span, ident);\n@@ -456,7 +457,7 @@ fn controlflow_expr(&crate_ctxt ccx, @expr e) -> controlflow {\n     }\n }\n \n-fn constraints_expr(&ty::ctxt cx, @expr e) -> vec[@ast::constr] {\n+fn constraints_expr(&ty::ctxt cx, @expr e) -> vec[@ty::constr_def] {\n     alt (ty::struct(cx, ty::ann_to_type(cx, expr_ann(e)))) {\n         case (ty::ty_fn(_, _, _, _, ?cs)) { ret cs; }\n         case (_) { ret []; }\n@@ -511,9 +512,11 @@ fn constraints(&fn_ctxt fcx) -> vec[norm_constraint] {\n // FIXME:\n // this probably doesn't handle name shadowing well (or at all)\n // variables should really always be id'd by def_id and not ident\n+\n fn match_args(&fn_ctxt fcx, vec[pred_desc] occs, vec[@constr_arg_use] occ) ->\n    uint {\n-    log \"match_args: looking at \" + pretty::ppaux::constr_args_to_str_1(occ);\n+    log (\"match_args: looking at \" +\n+         pretty::ppaux::constr_args_to_str(std::util::id[str], occ));\n     for (pred_desc pd in occs) {\n         log \"match_args: candidate \" + pred_desc_to_str(pd);\n         if (ty::args_eq(str::eq, pd.node.args, occ)) { ret pd.node.bit_num; }\n@@ -586,11 +589,13 @@ fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n \n fn pred_desc_to_str(&pred_desc p) -> str {\n     ret \"<\" + uistr(p.node.bit_num) + \", \" +\n-            pretty::ppaux::constr_args_to_str_1(p.node.args) + \">\";\n+         pretty::ppaux::constr_args_to_str(std::util::id[str], p.node.args)\n+         + \">\";\n }\n \n-fn substitute_constr_args(&ty::ctxt cx, &vec[@expr] actuals, &@ast::constr c)\n-   -> constr__ {\n+fn substitute_constr_args(&ty::ctxt cx,\n+                          &vec[@expr] actuals, &@ty::constr_def c)\n+    -> constr__ {\n     let vec[@constr_arg_use] res = [];\n     for (@constr_arg a in c.node.args) {\n         res += [substitute_arg(cx, actuals, a)];"}, {"sha": "f669afa965dd73fdfbc4a2acb1c82c27fb2f0aa2", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=a5bca7df8842fe816a0288e1dd13226ceb9ec6fb", "patch": "@@ -37,30 +37,16 @@ fn collect_pred(&ctxt cx, &@expr e) {\n         case (expr_check(?e, _)) {\n             vec::push(*cx.cs, expr_to_constr(cx.tcx, e));\n         }\n-        case (\n-             // If it's a call, generate appropriate instances of the\n-             // call's constraints.\n-             expr_call(?operator, ?operands, ?a)) {\n-            for (@ast::constr c in constraints_expr(cx.tcx, operator)) {\n-                auto d_id = ann_to_def_strict(cx.tcx, c.node.ann);\n-                alt (d_id) {\n-                    case (def_fn(?an_id)) {\n-                        let aux::constr ct =\n-                            respan(c.span,\n-                                   rec(id=an_id,\n-                                       c=aux::substitute_constr_args(cx.tcx,\n-                                                                     operands,\n-                                                                     c)));\n-                        vec::push(*cx.cs, ct);\n-                    }\n-                    case (_) {\n-                        cx.tcx.sess.span_err(c.span,\n-                                             \"Non-pred in constraint\");\n-                    }\n-                }\n+        // If it's a call, generate appropriate instances of the\n+        // call's constraints.\n+        case (expr_call(?operator, ?operands, ?a)) {\n+            for (@ty::constr_def c in constraints_expr(cx.tcx, operator)) {\n+                let aux::constr ct = respan(c.span,\n+                      rec(id=c.node.id,\n+                          c=aux::substitute_constr_args(cx.tcx,\n+                                                        operands, c)));\n+                vec::push(*cx.cs, ct);\n             }\n-            // FIXME: constraints on result type\n-\n         }\n         case (_) { }\n     }"}, {"sha": "a355c9f3f12174d91841838faa7dc63691fc4eb3", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 7, "deletions": 29, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=a5bca7df8842fe816a0288e1dd13226ceb9ec6fb", "patch": "@@ -208,38 +208,16 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             auto args = vec::clone[@expr](operands);\n             vec::push[@expr](args, operator);\n             find_pre_post_exprs(fcx, args, a);\n-            /* should test higher-order constrained functions */\n-\n-            /* FIXME */\n-\n-            /* see if the call has any constraints on its in type */\n-\n-            log \"a function: \";\n+            /* see if the call has any constraints on its type */\n+            log(\"a function: \" );\n             log_expr(*operator);\n             auto pp = expr_pp(fcx.ccx, e);\n-            for (@constr c in constraints_expr(fcx.ccx.tcx, operator)) {\n-                auto id = ann_to_def(fcx.ccx, c.node.ann);\n-                alt (id) {\n-                    case (some(def_fn(?d_id))) {\n-                        auto i =\n-                            bit_num(fcx,\n-                                    rec(id=d_id,\n-                                        c=substitute_constr_args(fcx.ccx.tcx,\n-                                                                 operands,\n-                                                                 c)));\n-                        require(i, pp);\n-                    }\n-                    case (_) {\n-                        fcx.ccx.tcx.sess.span_err(c.span,\n-                                                  \"Unbound pred \" +\n-                                                      \" or pred that's not \\\n-                                                        bound to a function\");\n-                    }\n-                }\n+            for (@ty::constr_def c in \n+                     constraints_expr(fcx.ccx.tcx, operator)) {\n+                auto i = bit_num(fcx, rec(id=c.node.id,\n+                  c=substitute_constr_args(fcx.ccx.tcx, operands, c)));\n+                require(i, pp);\n             }\n-\n-            // FIXME: constraints on result type\n-\n             /* if this is a failing call, its postcondition sets everything */\n             alt (controlflow_expr(fcx.ccx, operator)) {\n                 case (noreturn) { set_postcond_false(fcx.ccx, a); }"}, {"sha": "6ef2384d8f145a721d969a4c1eb833e5fe33b668", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 57, "deletions": 59, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=a5bca7df8842fe816a0288e1dd13226ceb9ec6fb", "patch": "@@ -13,23 +13,14 @@ import std::option::some;\n import std::smallintmap;\n import driver::session;\n import front::ast;\n+import front::ast::def_id;\n+import front::ast::constr_arg_general;\n import front::ast::mutability;\n import front::ast::controlflow;\n import front::creader;\n import middle::metadata;\n-import util::common;\n-import util::common::ty_u8;\n-import util::common::ty_u16;\n-import util::common::ty_u32;\n-import util::common::ty_u64;\n-import util::common::ty_i8;\n-import util::common::ty_i16;\n-import util::common::ty_i32;\n-import util::common::ty_i64;\n-import util::common::ty_f32;\n-import util::common::ty_f64;\n-import util::common::new_def_hash;\n-import util::common::span;\n+import util::common::*;\n+\n import util::data::interner;\n \n \n@@ -46,20 +37,22 @@ type method =\n         vec[arg] inputs,\n         t output,\n         controlflow cf,\n-        vec[@ast::constr] constrs);\n+        vec[@constr_def] constrs);\n \n tag any_item {\n     any_item_rust(@ast::item);\n     any_item_native(@ast::native_item, ast::native_abi);\n }\n \n type item_table = hashmap[ast::def_id, any_item];\n+type constr_table = hashmap[ast::def_id, vec[constr_def]]; \n \n type mt = rec(t ty, ast::mutability mut);\n \n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n+\n type creader_cache = hashmap[tup(int, uint, uint), ty::t];\n \n type ctxt =\n@@ -68,7 +61,7 @@ type ctxt =\n         resolve::def_map def_map,\n         node_type_table node_types,\n         item_table items, // Only contains type items\n-\n+        constr_table fn_constrs,\n         type_cache tcache,\n         creader_cache rcache,\n         hashmap[t, str] short_names_cache,\n@@ -83,7 +76,6 @@ type ty_ctxt = ctxt;\n      ret mk_fn(cx, m.proto, m.inputs, m.output, m.cf, m.constrs);\n  }\n \n-\n // Never construct these manually. These are interned.\n //\n // TODO: It'd be really nice to be able to hide this definition from the\n@@ -107,11 +99,11 @@ tag sty {\n     ty_int;\n     ty_float;\n     ty_uint;\n-    ty_machine(util::common::ty_mach);\n+    ty_machine(ty_mach);\n     ty_char;\n     ty_str;\n     ty_istr;\n-    ty_tag(ast::def_id, vec[t]);\n+    ty_tag(def_id, vec[t]);\n     ty_box(mt);\n     ty_vec(mt);\n     ty_ivec(mt);\n@@ -121,7 +113,7 @@ tag sty {\n     ty_task;\n     ty_tup(vec[mt]);\n     ty_rec(vec[field]);\n-    ty_fn(ast::proto, vec[arg], t, controlflow, vec[@ast::constr]);\n+    ty_fn(ast::proto, vec[arg], t, controlflow, vec[@constr_def]);\n     ty_native_fn(ast::native_abi, vec[arg], t);\n     ty_obj(vec[method]);\n     ty_var(int); // type variable\n@@ -134,6 +126,10 @@ tag sty {\n \n }\n \n+type constr_def = spanned[constr_general[uint]];\n+type constr_general[T] =  rec(path path,\n+                              vec[@constr_arg_general[T]] args,\n+                              def_id id);\n \n // Data structures used in type unification\n tag type_err {\n@@ -247,19 +243,21 @@ fn mk_rcache() -> creader_cache {\n     ret map::mk_hashmap[tup(int, uint, uint), t](h, e);\n }\n \n-fn mk_ctxt(session::session s, resolve::def_map dm) -> ctxt {\n+fn mk_ctxt(session::session s, resolve::def_map dm, constr_table cs) -> ctxt {\n+\n     let vec[mutable option::t[ty::ty_param_substs_opt_and_ty]] ntt_sub =\n         [mutable ];\n     let node_type_table ntt = @mutable ntt_sub;\n-    auto tcache = common::new_def_hash[ty::ty_param_count_and_ty]();\n-    auto items = common::new_def_hash[any_item]();\n+    auto tcache = new_def_hash[ty::ty_param_count_and_ty]();\n+    auto items = new_def_hash[any_item]();\n     auto ts = @interner::mk[raw_t](hash_raw_ty, eq_raw_ty);\n     auto cx =\n         rec(ts=ts,\n             sess=s,\n             def_map=dm,\n             node_types=ntt,\n             items=items,\n+            fn_constrs = cs,\n             tcache=tcache,\n             rcache=mk_rcache(),\n             short_names_cache=map::mk_hashmap[ty::t,\n@@ -379,7 +377,7 @@ fn mk_float(&ctxt cx) -> t { ret idx_float; }\n \n fn mk_uint(&ctxt cx) -> t { ret idx_uint; }\n \n-fn mk_mach(&ctxt cx, &util::common::ty_mach tm) -> t {\n+fn mk_mach(&ctxt cx, &ty_mach tm) -> t {\n     alt (tm) {\n         case (ty_u8) { ret idx_u8; }\n         case (ty_u16) { ret idx_u16; }\n@@ -439,7 +437,7 @@ fn mk_imm_tup(&ctxt cx, &vec[t] tys) -> t {\n fn mk_rec(&ctxt cx, &vec[field] fs) -> t { ret gen_ty(cx, ty_rec(fs)); }\n \n fn mk_fn(&ctxt cx, &ast::proto proto, &vec[arg] args, &t ty, &controlflow cf,\n-         &vec[@ast::constr] constrs) -> t {\n+         &vec[@constr_def] constrs) -> t {\n     ret gen_ty(cx, ty_fn(proto, args, ty, cf, constrs));\n }\n \n@@ -759,8 +757,8 @@ fn sequence_is_interior(&ctxt cx, &t ty) -> bool {\n \n fn sequence_element_type(&ctxt cx, &t ty) -> t {\n     alt (struct(cx, ty)) {\n-        case (ty_str) { ret mk_mach(cx, common::ty_u8); }\n-        case (ty_istr) { ret mk_mach(cx, common::ty_u8); }\n+        case (ty_str) { ret mk_mach(cx, ty_u8); }\n+        case (ty_istr) { ret mk_mach(cx, ty_u8); }\n         case (ty_vec(?mt)) { ret mt.ty; }\n         case (ty_ivec(?mt)) { ret mt.ty; }\n         case (_) {\n@@ -915,14 +913,14 @@ fn type_is_integral(&ctxt cx, &t ty) -> bool {\n         case (ty_uint) { ret true; }\n         case (ty_machine(?m)) {\n             alt (m) {\n-                case (common::ty_i8) { ret true; }\n-                case (common::ty_i16) { ret true; }\n-                case (common::ty_i32) { ret true; }\n-                case (common::ty_i64) { ret true; }\n-                case (common::ty_u8) { ret true; }\n-                case (common::ty_u16) { ret true; }\n-                case (common::ty_u32) { ret true; }\n-                case (common::ty_u64) { ret true; }\n+                case (ty_i8) { ret true; }\n+                case (ty_i16) { ret true; }\n+                case (ty_i32) { ret true; }\n+                case (ty_i64) { ret true; }\n+                case (ty_u8) { ret true; }\n+                case (ty_u16) { ret true; }\n+                case (ty_u32) { ret true; }\n+                case (ty_u64) { ret true; }\n                 case (_) { ret false; }\n             }\n         }\n@@ -935,8 +933,8 @@ fn type_is_fp(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_machine(?tm)) {\n             alt (tm) {\n-                case (common::ty_f32) { ret true; }\n-                case (common::ty_f64) { ret true; }\n+                case (ty_f32) { ret true; }\n+                case (ty_f64) { ret true; }\n                 case (_) { ret false; }\n             }\n         }\n@@ -950,10 +948,10 @@ fn type_is_signed(&ctxt cx, &t ty) -> bool {\n         case (ty_int) { ret true; }\n         case (ty_machine(?tm)) {\n             alt (tm) {\n-                case (common::ty_i8) { ret true; }\n-                case (common::ty_i16) { ret true; }\n-                case (common::ty_i32) { ret true; }\n-                case (common::ty_i64) { ret true; }\n+                case (ty_i8) { ret true; }\n+                case (ty_i16) { ret true; }\n+                case (ty_i32) { ret true; }\n+                case (ty_i64) { ret true; }\n                 case (_) { ret false; }\n             }\n         }\n@@ -1005,16 +1003,16 @@ fn hash_type_structure(&sty st) -> uint {\n         case (ty_uint) { ret 4u; }\n         case (ty_machine(?tm)) {\n             alt (tm) {\n-                case (common::ty_i8) { ret 5u; }\n-                case (common::ty_i16) { ret 6u; }\n-                case (common::ty_i32) { ret 7u; }\n-                case (common::ty_i64) { ret 8u; }\n-                case (common::ty_u8) { ret 9u; }\n-                case (common::ty_u16) { ret 10u; }\n-                case (common::ty_u32) { ret 11u; }\n-                case (common::ty_u64) { ret 12u; }\n-                case (common::ty_f32) { ret 13u; }\n-                case (common::ty_f64) { ret 14u; }\n+                case (ty_i8) { ret 5u; }\n+                case (ty_i16) { ret 6u; }\n+                case (ty_i32) { ret 7u; }\n+                case (ty_i64) { ret 8u; }\n+                case (ty_u8) { ret 9u; }\n+                case (ty_u16) { ret 10u; }\n+                case (ty_u32) { ret 11u; }\n+                case (ty_u64) { ret 12u; }\n+                case (ty_f32) { ret 13u; }\n+                case (ty_f64) { ret 14u; }\n             }\n         }\n         case (ty_char) { ret 15u; }\n@@ -1096,7 +1094,7 @@ fn arg_eq[T](&fn(&T, &T) -> bool  eq, @ast::constr_arg_general[T] a,\n         }\n         case (ast::carg_lit(?l)) {\n             alt (b.node) {\n-                case (ast::carg_lit(?m)) { ret util::common::lit_eq(l, m); }\n+                case (ast::carg_lit(?m)) { ret lit_eq(l, m); }\n                 case (_) { ret false; }\n             }\n         }\n@@ -1113,18 +1111,18 @@ fn args_eq[T](fn(&T, &T) -> bool  eq, vec[@ast::constr_arg_general[T]] a,\n     ret true;\n }\n \n-fn constr_eq(&@ast::constr c, &@ast::constr d) -> bool {\n+fn constr_eq(&@constr_def c, &@constr_def d) -> bool {\n     ret path_to_str(c.node.path) == path_to_str(d.node.path) &&\n              // FIXME: hack\n             args_eq(eq_int, c.node.args, d.node.args);\n }\n \n-fn constrs_eq(&vec[@ast::constr] cs, &vec[@ast::constr] ds) -> bool {\n+fn constrs_eq(&vec[@constr_def] cs, &vec[@constr_def] ds) -> bool {\n     if (vec::len(cs) != vec::len(ds)) { ret false; }\n-    auto i = 0;\n-    for (@ast::constr c in cs) {\n+    auto i = 0u;\n+    for (@constr_def c in cs) {\n         if (!constr_eq(c, ds.(i))) { ret false; }\n-        i += 1;\n+        i += 1u;\n     }\n     ret true;\n }\n@@ -1829,8 +1827,8 @@ mod unify {\n                 &t expected, &t actual, &vec[arg] expected_inputs,\n                 &t expected_output, &vec[arg] actual_inputs, &t actual_output,\n                 &controlflow expected_cf, &controlflow actual_cf,\n-                &vec[@ast::constr] expected_constrs,\n-                &vec[@ast::constr] actual_constrs) -> result {\n+                &vec[@constr_def] expected_constrs,\n+                &vec[@constr_def] actual_constrs) -> result {\n         if (e_proto != a_proto) { ret ures_err(terr_mismatch); }\n         alt (expected_cf) {\n             case (ast::return) { }\n@@ -2473,7 +2471,7 @@ fn tag_variant_with_id(&ctxt cx, &ast::def_id tag_id, &ast::def_id variant_id)\n     auto i = 0u;\n     while (i < vec::len[variant_info](variants)) {\n         auto variant = variants.(i);\n-        if (common::def_eq(variant.id, variant_id)) { ret variant; }\n+        if (def_eq(variant.id, variant_id)) { ret variant; }\n         i += 1u;\n     }\n     cx.sess.bug(\"tag_variant_with_id(): no variant exists with that ID\");"}, {"sha": "c53d280830b6c28ed5cb447476188a4bf743a5e6", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 49, "deletions": 30, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=a5bca7df8842fe816a0288e1dd13226ceb9ec6fb", "patch": "@@ -6,6 +6,7 @@ import front::creader;\n import driver::session;\n import util::common;\n import util::common::span;\n+import util::common::respan;\n import util::common::new_def_hash;\n import util::common::log_expr_err;\n import middle::ty;\n@@ -312,7 +313,10 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n             auto f = bind ast_arg_to_arg(tcx, getter, _);\n             auto i = vec::map[ast::ty_arg, arg](f, inputs);\n             auto out_ty = ast_ty_to_ty(tcx, getter, output);\n-            typ = ty::mk_fn(tcx, proto, i, out_ty, cf, constrs);\n+            let fn(&@ast::constr) -> @ty::constr_def g =\n+                bind ast_constr_to_constr(tcx, _);\n+            let vec[@ty::constr_def] out_constrs = vec::map(g, constrs);\n+            typ = ty::mk_fn(tcx, proto, i, out_ty, cf, out_constrs);\n         }\n         case (ast::ty_path(?path, ?ann)) {\n             alt (tcx.def_map.get(ann.id)) {\n@@ -341,13 +345,17 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n             for (ast::ty_method m in meths) {\n                 auto ins = vec::map[ast::ty_arg, arg](f, m.node.inputs);\n                 auto out = ast_ty_to_ty(tcx, getter, m.node.output);\n+                let fn(&@ast::constr) -> @ty::constr_def g =\n+                    bind ast_constr_to_constr(tcx, _);\n+                let vec[@ty::constr_def] out_constrs =\n+                       vec::map(g, m.node.constrs);\n                 let ty::method new_m =\n                     rec(proto=m.node.proto,\n                         ident=m.node.ident,\n                         inputs=ins,\n                         output=out,\n                         cf=m.node.cf,\n-                        constrs=m.node.constrs);\n+                        constrs=out_constrs);\n                 vec::push[ty::method](tmeths, new_m);\n             }\n             typ = ty::mk_obj(tcx, ty::sort_methods(tmeths));\n@@ -449,9 +457,12 @@ mod collect {\n        ty::ty_param_count_and_ty {\n         auto input_tys = vec::map[ast::arg, arg](ty_of_arg, decl.inputs);\n         auto output_ty = convert(decl.output);\n+        let fn(&@ast::constr) -> @ty::constr_def g =\n+            bind ast_constr_to_constr(cx.tcx, _);\n+        let vec[@ty::constr_def] out_constrs = vec::map(g, decl.constraints);\n         auto t_fn =\n             ty::mk_fn(cx.tcx, proto, input_tys, output_ty, decl.cf,\n-                      decl.constraints);\n+                      out_constrs);\n         auto ty_param_count = vec::len[ast::ty_param](ty_params);\n         auto tpt = tup(ty_param_count, t_fn);\n         alt (def_id) {\n@@ -512,12 +523,13 @@ mod collect {\n         auto f = bind ty_of_arg(cx, _);\n         auto inputs = vec::map[ast::arg, arg](f, m.node.meth.decl.inputs);\n         auto output = convert(m.node.meth.decl.output);\n-        ret rec(proto=m.node.meth.proto,\n-                ident=m.node.ident,\n-                inputs=inputs,\n-                output=output,\n-                cf=m.node.meth.decl.cf,\n-                constrs=m.node.meth.decl.constraints);\n+        let fn(&@ast::constr) -> @ty::constr_def g =\n+            bind ast_constr_to_constr(cx.tcx, _);\n+        let vec[@ty::constr_def] out_constrs =\n+            vec::map(g, m.node.meth.decl.constraints);\n+        ret rec(proto=m.node.meth.proto, ident=m.node.ident,\n+                inputs=inputs, output=output, cf=m.node.meth.decl.cf,\n+                constrs=out_constrs);\n     }\n     fn ty_of_obj(@ctxt cx, &ast::ident id, &ast::_obj obj_info,\n                  &vec[ast::ty_param] ty_params) -> ty::ty_param_count_and_ty {\n@@ -537,10 +549,8 @@ mod collect {\n             auto t_field = ast_ty_to_ty(cx.tcx, g, f.ty);\n             vec::push(t_inputs, rec(mode=ty::mo_alias(false), ty=t_field));\n         }\n-        let vec[@ast::constr] constrs = [];\n-        auto t_fn =\n-            ty::mk_fn(cx.tcx, ast::proto_fn, t_inputs, t_obj._1, ast::return,\n-                      constrs);\n+        auto t_fn = ty::mk_fn(cx.tcx, ast::proto_fn, t_inputs, t_obj._1,\n+                              ast::return, []);\n         auto tpt = tup(t_obj._0, t_fn);\n         cx.tcx.tcache.insert(ctor_id, tpt);\n         ret tpt;\n@@ -652,11 +662,8 @@ mod collect {\n                 }\n                 auto tag_t = ty::mk_tag(cx.tcx, tag_id, ty_param_tys);\n                 // FIXME: this will be different for constrained types\n-\n-                let vec[@ast::constr] res_constrs = [];\n-                result_ty =\n-                    ty::mk_fn(cx.tcx, ast::proto_fn, args, tag_t, ast::return,\n-                              res_constrs);\n+                result_ty = ty::mk_fn(cx.tcx, ast::proto_fn, args, tag_t,\n+                                      ast::return, []);\n             }\n             auto tpt = tup(ty_param_count, result_ty);\n             cx.tcx.tcache.insert(variant.node.id, tpt);\n@@ -752,12 +759,8 @@ mod collect {\n                 alt (object.dtor) {\n                     case (none) {/* nothing to do */ }\n                     case (some(?m)) {\n-                        let vec[@ast::constr] constrs = [];\n-                        let vec[arg] res_inputs = [];\n-                        auto t =\n-                            ty::mk_fn(cx.tcx, ast::proto_fn, res_inputs,\n-                                      ty::mk_nil(cx.tcx), ast::return,\n-                                      constrs);\n+                        auto t = ty::mk_fn(cx.tcx, ast::proto_fn, [],\n+                                   ty::mk_nil(cx.tcx), ast::return, []);\n                         write::ty_only(cx.tcx, m.node.ann.id, t);\n                     }\n                 }\n@@ -2123,12 +2126,13 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 auto inputs =\n                     vec::map[ast::arg, arg](f, m.node.meth.decl.inputs);\n                 auto output = convert(m.node.meth.decl.output);\n-                ret rec(proto=m.node.meth.proto,\n-                        ident=m.node.ident,\n-                        inputs=inputs,\n-                        output=output,\n-                        cf=m.node.meth.decl.cf,\n-                        constrs=m.node.meth.decl.constraints);\n+                let fn(&@ast::constr) -> @ty::constr_def g =\n+                    bind ast_constr_to_constr(ccx.tcx, _);\n+                let vec[@ty::constr_def] out_constrs =\n+                    vec::map(g, m.node.meth.decl.constraints);\n+                ret rec(proto=m.node.meth.proto, ident=m.node.ident,\n+                        inputs=inputs, output=output, cf=m.node.meth.decl.cf,\n+                        constrs=out_constrs);\n             }\n             fn get_anon_obj_method_types(@crate_ctxt ccx,\n                                          &ast::anon_obj anon_obj) ->\n@@ -2180,6 +2184,21 @@ fn get_obj_info(&@crate_ctxt ccx) -> option::t[obj_info] {\n     ret vec::last[obj_info](ccx.obj_infos);\n }\n \n+fn ast_constr_to_constr(ty::ctxt tcx, &@ast::constr c)\n+    -> @ty::constr_def {\n+    alt (tcx.def_map.find(c.node.ann.id)) {\n+        case (some(ast::def_fn(?pred_id))) {\n+            ret @respan(c.span, rec(path=c.node.path, args=c.node.args,\n+                                    id=pred_id));\n+        }\n+        case (_) {\n+            tcx.sess.span_err(c.span, \"Predicate \"\n+                              + path_to_str(c.node.path)\n+                              + \" is unbound or bound to a non-function\");\n+        }\n+    }\n+}\n+\n fn check_decl_initializer(&@fn_ctxt fcx, &ast::def_id lid,\n                           &ast::initializer init) {\n     check_expr(fcx, init.expr);"}, {"sha": "929bfdcc25c3689a4491d75d46553554c61d4c81", "filename": "src/comp/pretty/ppaux.rs", "status": "modified", "additions": 46, "deletions": 36, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fpretty%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fpretty%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fppaux.rs?ref=a5bca7df8842fe816a0288e1dd13226ceb9ec6fb", "patch": "@@ -1,7 +1,6 @@\n \n import std::io;\n import middle::ty::*;\n-import front::ast::constr_arg;\n import front::lexer;\n import pp::word;\n import pp::eof;\n@@ -21,9 +20,10 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n             };\n         ret s + ty_to_str(cx, input.ty);\n     }\n+\n     fn fn_to_str(&ctxt cx, ast::proto proto, option::t[ast::ident] ident,\n                  vec[arg] inputs, t output, ast::controlflow cf,\n-                 &vec[@ast::constr] constrs) -> str {\n+                 &vec[@constr_def] constrs) -> str {\n         auto f = bind fn_input_to_str(cx, _);\n         auto s;\n         alt (proto) {\n@@ -69,7 +69,7 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n         case (ty_int) { s += \"int\"; }\n         case (ty_float) { s += \"float\"; }\n         case (ty_uint) { s += \"uint\"; }\n-        case (ty_machine(?tm)) { s += common::ty_mach_to_str(tm); }\n+        case (ty_machine(?tm)) { s += ty_mach_to_str(tm); }\n         case (ty_char) { s += \"char\"; }\n         case (ty_str) { s += \"str\"; }\n         case (ty_istr) { s += \"istr\"; }\n@@ -92,10 +92,8 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n         }\n         case (ty_tag(?id, ?tps)) {\n             // The user should never see this if the cname is set properly!\n-\n             s +=\n-                \"<tag#\" + util::common::istr(id._0) + \":\" +\n-                    util::common::istr(id._1) + \">\";\n+                \"<tag#\" + istr(id._0) + \":\" + istr(id._1) + \">\";\n             if (vec::len[t](tps) > 0u) {\n                 auto f = bind ty_to_str(cx, _);\n                 auto strs = vec::map[t, str](f, tps);\n@@ -104,21 +102,20 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n         }\n         case (ty_fn(?proto, ?inputs, ?output, ?cf, ?constrs)) {\n             s +=\n-                fn_to_str(cx, proto, none[ast::ident], inputs, output, cf,\n+                fn_to_str(cx, proto, none, inputs, output, cf,\n                           constrs);\n         }\n         case (ty_native_fn(_, ?inputs, ?output)) {\n-            let vec[@ast::constr] constrs = [];\n             s +=\n-                fn_to_str(cx, ast::proto_fn, none[ast::ident], inputs, output,\n-                          ast::return, constrs);\n+                fn_to_str(cx, ast::proto_fn, none, inputs, output,\n+                          ast::return, []);\n         }\n         case (ty_obj(?meths)) {\n             auto f = bind method_to_str(cx, _);\n             auto m = vec::map[method, str](f, meths);\n             s += \"obj {\\n\\t\" + str::connect(m, \"\\n\\t\") + \"\\n}\";\n         }\n-        case (ty_var(?v)) { s += \"<T\" + util::common::istr(v) + \">\"; }\n+        case (ty_var(?v)) { s += \"<T\" + istr(v) + \">\"; }\n         case (ty_param(?id)) {\n             s += \"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)]);\n         }\n@@ -144,7 +141,7 @@ fn constr_arg_to_str[T](fn(&T) -> str  f, &ast::constr_arg_general_[T] c) ->\n     }\n }\n \n-fn constr_arg_to_str_1(&ast::constr_arg_general_[str] c) -> str {\n+fn constr_arg_to_str_1(&front::ast::constr_arg_general_[str] c) -> str {\n     alt (c) {\n         case (ast::carg_base) { ret \"*\"; }\n         case (ast::carg_ident(?i)) { ret i; }\n@@ -164,18 +161,7 @@ fn constr_args_to_str[T](fn(&T) -> str  f,\n     ret s;\n }\n \n-fn constr_args_to_str_1(&vec[@ast::constr_arg_use] args) -> str {\n-    auto comma = false;\n-    auto s = \"(\";\n-    for (@ast::constr_arg_use a in args) {\n-        if (comma) { s += \", \"; } else { comma = true; }\n-        s += constr_arg_to_str_1(a.node);\n-    }\n-    s += \")\";\n-    ret s;\n-}\n-\n-fn print_literal(&ps s, &@ast::lit lit) {\n+fn print_literal(&ps s, &@front::ast::lit lit) {\n     maybe_print_comment(s, lit.span.lo);\n     alt (next_lit(s)) {\n         case (some(?lt)) {\n@@ -196,18 +182,18 @@ fn print_literal(&ps s, &@ast::lit lit) {\n             word(s.s,\n                  \"'\" + escape_str(str::from_bytes([ch as u8]), '\\'') + \"'\");\n         }\n-        case (ast::lit_int(?val)) { word(s.s, common::istr(val)); }\n-        case (ast::lit_uint(?val)) { word(s.s, common::uistr(val) + \"u\"); }\n+        case (ast::lit_int(?val)) { word(s.s, istr(val)); }\n+        case (ast::lit_uint(?val)) { word(s.s, uistr(val) + \"u\"); }\n         case (ast::lit_float(?fstr)) { word(s.s, fstr); }\n         case (ast::lit_mach_int(?mach, ?val)) {\n-            word(s.s, common::istr(val as int));\n-            word(s.s, common::ty_mach_to_str(mach));\n+            word(s.s, istr(val as int));\n+            word(s.s, ty_mach_to_str(mach));\n         }\n         case (ast::lit_mach_float(?mach, ?val)) {\n             // val is already a str\n \n             word(s.s, val);\n-            word(s.s, common::ty_mach_to_str(mach));\n+            word(s.s, ty_mach_to_str(mach));\n         }\n         case (ast::lit_nil) { word(s.s, \"()\"); }\n         case (ast::lit_bool(?val)) {\n@@ -216,7 +202,7 @@ fn print_literal(&ps s, &@ast::lit lit) {\n     }\n }\n \n-fn lit_to_str(&@ast::lit l) -> str { be to_str(l, print_literal); }\n+fn lit_to_str(&@front::ast::lit l) -> str { be to_str(l, print_literal); }\n \n fn next_lit(&ps s) -> option::t[lexer::lit] {\n     alt (s.literals) {\n@@ -360,22 +346,46 @@ const uint default_columns = 78u;\n // needed b/c constr_args_to_str needs\n // something that takes an alias\n // (argh)\n-fn uint_to_str(&uint i) -> str { ret util::common::uistr(i); }\n \n-fn constr_to_str(&@ast::constr c) -> str {\n-    ret path_to_str(c.node.path) +\n-            constr_args_to_str(uint_to_str, c.node.args);\n+fn uint_to_str(&uint i) -> str { ret uistr(i); }\n+\n+fn constr_to_str(&@constr_def c) -> str {\n+  ret path_to_str(c.node.path)\n+      + constr_args_to_str(uint_to_str, c.node.args);\n }\n \n-fn constrs_str(&vec[@ast::constr] constrs) -> str {\n+\n+fn ast_constr_to_str(&@front::ast::constr c) -> str {\n+  ret path_to_str(c.node.path)\n+      + constr_args_to_str(uint_to_str, c.node.args);\n+}\n+\n+fn constrs_str(&vec[@constr_def] constrs) -> str {\n     auto s = \"\";\n     auto colon = true;\n-    for (@ast::constr c in constrs) {\n+    for (@constr_def c in constrs) {\n         if (colon) { s += \" : \"; colon = false; } else { s += \", \"; }\n         s += constr_to_str(c);\n     }\n     ret s;\n }\n+\n+fn ast_constrs_str(&vec[@ast::constr] constrs) -> str {\n+  auto s = \"\";\n+  auto colon = true;\n+  for (@ast::constr c in constrs) {\n+    if (colon) {\n+      s += \" : \";\n+      colon = false;\n+    }\n+    else {\n+      s += \", \";\n+    }\n+    s += ast_constr_to_str(c);\n+  }\n+  ret s;\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "8db88541c2fc57ac53cd319037bec905ebd9d458", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=a5bca7df8842fe816a0288e1dd13226ceb9ec6fb", "patch": "@@ -1094,7 +1094,7 @@ fn print_ty_fn(&ps s, &ast::proto proto, &option::t[str] id,\n         }\n         end(s);\n     }\n-    word_space(s, constrs_str(constrs));\n+    word_space(s, ast_constrs_str(constrs));\n     end(s);\n }\n "}, {"sha": "ae8068d05e16ee232f3e4e7d7019311679e1c582", "filename": "src/test/compile-fail/not-a-pred.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5bca7df8842fe816a0288e1dd13226ceb9ec6fb/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs?ref=a5bca7df8842fe816a0288e1dd13226ceb9ec6fb", "patch": "@@ -1,6 +1,6 @@\n // -*- rust -*-\n-\n-// error-pattern: mismatched types\n+// xfail-stage0\n+// error-pattern: Non-predicate in constraint: lt\n \n fn f(int a, int b) : lt(a,b) {\n }"}]}