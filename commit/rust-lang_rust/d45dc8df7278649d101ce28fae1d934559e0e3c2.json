{"sha": "d45dc8df7278649d101ce28fae1d934559e0e3c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0NWRjOGRmNzI3ODY0OWQxMDFjZTI4ZmFlMWQ5MzQ1NTllMGUzYzI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-13T23:56:16Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-15T19:19:16Z"}, "message": "core::rt: More work on Reader extensions and error handling", "tree": {"sha": "cec223c46d3e288a1a486e9d8b8f71e8fa32de27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cec223c46d3e288a1a486e9d8b8f71e8fa32de27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d45dc8df7278649d101ce28fae1d934559e0e3c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d45dc8df7278649d101ce28fae1d934559e0e3c2", "html_url": "https://github.com/rust-lang/rust/commit/d45dc8df7278649d101ce28fae1d934559e0e3c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d45dc8df7278649d101ce28fae1d934559e0e3c2/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28a13ec8d76ba9a4f9645991e1260882a3b7dc68", "url": "https://api.github.com/repos/rust-lang/rust/commits/28a13ec8d76ba9a4f9645991e1260882a3b7dc68", "html_url": "https://github.com/rust-lang/rust/commit/28a13ec8d76ba9a4f9645991e1260882a3b7dc68"}], "stats": {"total": 192, "additions": 127, "deletions": 65}, "files": [{"sha": "4a5193f086b33b53592128f383f7f2202a7c9c8a", "filename": "src/libcore/rt/io/extensions.rs", "status": "modified", "additions": 121, "deletions": 63, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/d45dc8df7278649d101ce28fae1d934559e0e3c2/src%2Flibcore%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45dc8df7278649d101ce28fae1d934559e0e3c2/src%2Flibcore%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fextensions.rs?ref=d45dc8df7278649d101ce28fae1d934559e0e3c2", "patch": "@@ -14,7 +14,7 @@\n // XXX: Iteration should probably be considered separately\n \n use vec;\n-use rt::io::{Reader, read_error, standard_error, EndOfFile};\n+use rt::io::{Reader, read_error, standard_error, EndOfFile, DEFAULT_BUF_SIZE};\n use option::{Option, Some, None};\n use unstable::finally::Finally;\n use util;\n@@ -37,18 +37,17 @@ pub trait ReaderUtil {\n     /// # Failure\n     ///\n     /// Raises the same conditions as `read`. Additionally raises `read_error`\n-    /// on EOF. If `read_error` is handled then `push_bytes` returns without\n-    /// pushing any bytes onto `buf` - that is, `buf` has the same length\n-    /// upon exit as it did on entry.\n+    /// on EOF. If `read_error` is handled then `push_bytes` may push less\n+    /// than the requested number of bytes.\n     fn push_bytes(&mut self, buf: &mut ~[u8], len: uint);\n \n     /// Reads `len` bytes and gives you back a new vector of length `len`\n     ///\n     /// # Failure\n     ///\n     /// Raises the same conditions as `read`. Additionally raises `read_error`\n-    /// on EOF. If `read_error` is handled then the returned vector has\n-    /// length 0.\n+    /// on EOF. If `read_error` is handled then the returned vector may\n+    /// contain less than the requested number of bytes.\n     fn read_bytes(&mut self, len: uint) -> ~[u8];\n \n     /// Reads all remaining bytes from the stream.\n@@ -60,60 +59,6 @@ pub trait ReaderUtil {\n \n }\n \n-impl<T: Reader> ReaderUtil for T {\n-    fn read_byte(&mut self) -> Option<u8> {\n-        let mut buf = [0];\n-        match self.read(buf) {\n-            Some(0) => {\n-                debug!(\"read 0 bytes. trying again\");\n-                self.read_byte()\n-            }\n-            Some(1) => Some(buf[0]),\n-            Some(_) => util::unreachable(),\n-            None => None\n-        }\n-    }\n-\n-    fn push_bytes(&mut self, buf: &mut ~[u8], len: uint) {\n-        unsafe {\n-            let start_len = buf.len();\n-            let mut total_read = 0;\n-\n-            vec::reserve_at_least(buf, start_len + len);\n-            vec::raw::set_len(buf, start_len + len);\n-\n-            do (|| {\n-                while total_read < len {\n-                    let slice = vec::mut_slice(*buf, start_len + total_read, buf.len());\n-                    match self.read(slice) {\n-                        Some(nread) => {\n-                            total_read += nread;\n-                        }\n-                        None => {\n-                            read_error::cond.raise(standard_error(EndOfFile));\n-                            // Reset the vector length as though we didn't read anything\n-                            total_read = 0;\n-                            break;\n-                        }\n-                    }\n-                }\n-            }).finally {\n-                vec::raw::set_len(buf, start_len + total_read);\n-            }\n-        }\n-    }\n-\n-    fn read_bytes(&mut self, len: uint) -> ~[u8] {\n-        let mut buf = vec::with_capacity(len);\n-        self.push_bytes(&mut buf, len);\n-        return buf;\n-    }\n-\n-    fn read_to_end(&mut self) -> ~[u8] {\n-        fail!()\n-    }\n-}\n-\n pub trait ReaderByteConversions {\n     /// Reads `n` little-endian unsigned integer bytes.\n     ///\n@@ -323,6 +268,71 @@ pub trait WriterByteConversions {\n     fn write_i8(&mut self, n: i8);\n }\n \n+impl<T: Reader> ReaderUtil for T {\n+    fn read_byte(&mut self) -> Option<u8> {\n+        let mut buf = [0];\n+        match self.read(buf) {\n+            Some(0) => {\n+                debug!(\"read 0 bytes. trying again\");\n+                self.read_byte()\n+            }\n+            Some(1) => Some(buf[0]),\n+            Some(_) => util::unreachable(),\n+            None => None\n+        }\n+    }\n+\n+    fn push_bytes(&mut self, buf: &mut ~[u8], len: uint) {\n+        unsafe {\n+            let start_len = buf.len();\n+            let mut total_read = 0;\n+\n+            vec::reserve_at_least(buf, start_len + len);\n+            vec::raw::set_len(buf, start_len + len);\n+\n+            do (|| {\n+                while total_read < len {\n+                    let slice = vec::mut_slice(*buf, start_len + total_read, buf.len());\n+                    match self.read(slice) {\n+                        Some(nread) => {\n+                            total_read += nread;\n+                        }\n+                        None => {\n+                            read_error::cond.raise(standard_error(EndOfFile));\n+                            break;\n+                        }\n+                    }\n+                }\n+            }).finally {\n+                vec::raw::set_len(buf, start_len + total_read);\n+            }\n+        }\n+    }\n+\n+    fn read_bytes(&mut self, len: uint) -> ~[u8] {\n+        let mut buf = vec::with_capacity(len);\n+        self.push_bytes(&mut buf, len);\n+        return buf;\n+    }\n+\n+    fn read_to_end(&mut self) -> ~[u8] {\n+        let mut buf = vec::with_capacity(DEFAULT_BUF_SIZE);\n+        let mut keep_reading = true;\n+        do read_error::cond.trap(|e| {\n+            if e.kind == EndOfFile {\n+                keep_reading = false;\n+            } else {\n+                read_error::cond.raise(e)\n+            }\n+        }).in {\n+            while keep_reading {\n+                self.push_bytes(&mut buf, DEFAULT_BUF_SIZE)\n+            }\n+        }\n+        return buf;\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::*;\n@@ -414,7 +424,7 @@ mod test {\n         let mut reader = MemReader::new(~[10, 11]);\n         do read_error::cond.trap(|_| {\n         }).in {\n-            assert!(reader.read_bytes(4) == ~[]);\n+            assert!(reader.read_bytes(4) == ~[10, 11]);\n         }\n     }\n \n@@ -456,7 +466,7 @@ mod test {\n         do read_error::cond.trap(|_| {\n         }).in {\n             reader.push_bytes(&mut buf, 4);\n-            assert!(buf == ~[8, 9]);\n+            assert!(buf == ~[8, 9, 10, 11]);\n         }\n     }\n \n@@ -480,7 +490,7 @@ mod test {\n         do read_error::cond.trap(|_| { } ).in {\n             reader.push_bytes(&mut buf, 4);\n         }\n-        assert!(buf == ~[8, 9]);\n+        assert!(buf == ~[8, 9, 10]);\n     }\n \n     #[test]\n@@ -514,4 +524,52 @@ mod test {\n         }\n     }\n \n+    #[test]\n+    fn read_to_end() {\n+        let mut reader = MockReader::new();\n+        let count = Cell(0);\n+        reader.read = |buf| {\n+            do count.with_mut_ref |count| {\n+                if *count == 0 {\n+                    *count = 1;\n+                    buf[0] = 10;\n+                    buf[1] = 11;\n+                    Some(2)\n+                } else if *count == 1 {\n+                    *count = 2;\n+                    buf[0] = 12;\n+                    buf[1] = 13;\n+                    Some(2)\n+                } else {\n+                    None\n+                }\n+            }\n+        };\n+        let buf = reader.read_to_end();\n+        assert!(buf == ~[10, 11, 12, 13]);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn read_to_end_error() {\n+        let mut reader = MockReader::new();\n+        let count = Cell(0);\n+        reader.read = |buf| {\n+            do count.with_mut_ref |count| {\n+                if *count == 0 {\n+                    *count = 1;\n+                    buf[0] = 10;\n+                    buf[1] = 11;\n+                    Some(2)\n+                } else {\n+                    read_error::cond.raise(placeholder_error());\n+                    None\n+                }\n+            }\n+        };\n+        let buf = reader.read_to_end();\n+        assert!(buf == ~[10, 11]);\n+    }\n+\n }"}, {"sha": "14784fa95672e7e9075c93a1258fe738479c650c", "filename": "src/libcore/rt/io/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d45dc8df7278649d101ce28fae1d934559e0e3c2/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45dc8df7278649d101ce28fae1d934559e0e3c2/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmod.rs?ref=d45dc8df7278649d101ce28fae1d934559e0e3c2", "patch": "@@ -187,7 +187,7 @@ In particular code written to ignore errors and expect conditions to be unhandle\n will start passing around null or zero objects when wrapped in a condition handler.\n \n * XXX: How should we use condition handlers that return values?\n-\n+* XXX: Should EOF raise default conditions when EOF is not an error?\n \n # Issues withi/o scheduler affinity, work stealing, task pinning\n \n@@ -323,6 +323,10 @@ pub mod native {\n /// Mock implementations for testing\n mod mock;\n \n+/// The default buffer size for various I/O operations\n+/// XXX: Not pub\n+pub static DEFAULT_BUF_SIZE: uint = 1024 * 64;\n+\n /// The type passed to I/O condition handlers to indicate error\n ///\n /// # XXX\n@@ -375,7 +379,7 @@ pub trait Reader {\n     ///\n     /// # XXX\n     ///\n-    /// * Should raise error on eof\n+    /// * Should raise_default error on eof?\n     /// * If the condition is handled it should still return the bytes read,\n     ///   in which case there's no need to return Option - but then you *have*\n     ///   to install a handler to detect eof."}]}