{"sha": "6a09b6f0c325dcef72fd623b89064df868c96412", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhMDliNmYwYzMyNWRjZWY3MmZkNjIzYjg5MDY0ZGY4NjhjOTY0MTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-06T22:43:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-06T22:43:35Z"}, "message": "auto merge of #6981 : jbclements/rust/fold-traverses-macros, r=catamorphism\n\nFixes bug #2888 . Includes test cases\r\n\r\nr? @catamorphism", "tree": {"sha": "ee8f6c6c4673efbabc687398ff46866e00f9d849", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee8f6c6c4673efbabc687398ff46866e00f9d849"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a09b6f0c325dcef72fd623b89064df868c96412", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a09b6f0c325dcef72fd623b89064df868c96412", "html_url": "https://github.com/rust-lang/rust/commit/6a09b6f0c325dcef72fd623b89064df868c96412", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a09b6f0c325dcef72fd623b89064df868c96412/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "145279709dde6b5576185902c8731cb6e6d1b7f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/145279709dde6b5576185902c8731cb6e6d1b7f1", "html_url": "https://github.com/rust-lang/rust/commit/145279709dde6b5576185902c8731cb6e6d1b7f1"}, {"sha": "eff49fc48b96b2d1ab30060499a8f2d6aeb97f9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/eff49fc48b96b2d1ab30060499a8f2d6aeb97f9e", "html_url": "https://github.com/rust-lang/rust/commit/eff49fc48b96b2d1ab30060499a8f2d6aeb97f9e"}], "stats": {"total": 191, "additions": 188, "deletions": 3}, "files": [{"sha": "9796fcd8baca01e6b787882a67ecd5c4ea86fdec", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 110, "deletions": 3, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/6a09b6f0c325dcef72fd623b89064df868c96412/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a09b6f0c325dcef72fd623b89064df868c96412/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=6a09b6f0c325dcef72fd623b89064df868c96412", "patch": "@@ -13,6 +13,7 @@ use core::prelude::*;\n use ast::*;\n use ast;\n use codemap::{span, spanned};\n+use parse::token;\n use opt_vec::OptVec;\n \n use core::vec;\n@@ -115,11 +116,43 @@ fn fold_arg_(a: arg, fld: @ast_fold) -> arg {\n         id: fld.new_id(a.id),\n     }\n }\n+\n //used in noop_fold_expr, and possibly elsewhere in the future\n fn fold_mac_(m: &mac, fld: @ast_fold) -> mac {\n     spanned {\n-        node: match m.node { mac_invoc_tt(*) => copy m.node },\n-        span: fld.new_span(m.span),\n+        node: match m.node {\n+            mac_invoc_tt(p,ref tts) =>\n+            mac_invoc_tt(fld.fold_path(p),\n+                         fold_tts(*tts,fld))\n+        },\n+        span: fld.new_span(m.span)\n+    }\n+}\n+\n+fn fold_tts(tts : &[token_tree], fld: @ast_fold) -> ~[token_tree] {\n+    do tts.map |tt| {\n+        match *tt {\n+            tt_tok(span, ref tok) =>\n+            tt_tok(span,maybe_fold_ident(tok,fld)),\n+            tt_delim(ref tts) =>\n+            tt_delim(fold_tts(*tts,fld)),\n+            tt_seq(span, ref pattern, ref sep, is_optional) =>\n+            tt_seq(span,\n+                   fold_tts(*pattern,fld),\n+                   sep.map(|tok|maybe_fold_ident(tok,fld)),\n+                   is_optional),\n+            tt_nonterminal(sp,ref ident) =>\n+            tt_nonterminal(sp,fld.fold_ident(*ident))\n+        }\n+    }\n+}\n+\n+// apply ident folder if it's an ident, otherwise leave it alone\n+fn maybe_fold_ident(t : &token::Token, fld: @ast_fold) -> token::Token {\n+    match *t {\n+        token::IDENT(id,followed_by_colons) =>\n+        token::IDENT(fld.fold_ident(id),followed_by_colons),\n+        _ => copy *t\n     }\n }\n \n@@ -290,7 +323,10 @@ pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n         }\n         item_mac(ref m) => {\n             // FIXME #2888: we might actually want to do something here.\n-            item_mac(copy *m)\n+            // ... okay, we're doing something. It would probably be nicer\n+            // to add something to the ast_fold trait, but I'll defer\n+            // that work.\n+            item_mac(fold_mac_(m,fld))\n         }\n     }\n }\n@@ -904,3 +940,74 @@ impl AstFoldExtensions for @ast_fold {\n pub fn make_fold(afp: ast_fold_fns) -> @ast_fold {\n     afp as @ast_fold\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use ast;\n+    use util::parser_testing::{string_to_crate, matches_codepattern};\n+    use parse::token;\n+    use print::pprust;\n+    use super::*;\n+\n+    // taken from expand\n+    // given a function from idents to idents, produce\n+    // an ast_fold that applies that function:\n+    pub fn fun_to_ident_folder(f: @fn(ast::ident)->ast::ident) -> @ast_fold{\n+        let afp = default_ast_fold();\n+        let f_pre = @AstFoldFns{\n+            fold_ident : |id, _| f(id),\n+            .. *afp\n+        };\n+        make_fold(f_pre)\n+    }\n+\n+    // this version doesn't care about getting comments or docstrings in.\n+    fn fake_print_crate(s: @pprust::ps, crate: ast::crate) {\n+        pprust::print_mod(s, &crate.node.module, crate.node.attrs);\n+    }\n+\n+    // change every identifier to \"zz\"\n+    pub fn to_zz() -> @fn(ast::ident)->ast::ident {\n+        let zz_id = token::str_to_ident(\"zz\");\n+        |id| {zz_id}\n+    }\n+\n+    // maybe add to expand.rs...\n+    macro_rules! assert_pred (\n+        ($pred:expr, $predname:expr, $a:expr , $b:expr) => (\n+            {\n+                let pred_val = $pred;\n+                let a_val = $a;\n+                let b_val = $b;\n+                if !(pred_val(a_val,b_val)) {\n+                    fail!(\"expected args satisfying %s, got %? and %?\",\n+                          $predname, a_val, b_val);\n+                }\n+            }\n+        )\n+    )\n+\n+    // make sure idents get transformed everywhere\n+    #[test] fn ident_transformation () {\n+        let zz_fold = fun_to_ident_folder(to_zz());\n+        let ast = string_to_crate(@~\"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\");\n+        assert_pred!(matches_codepattern,\n+                     \"matches_codepattern\",\n+                     pprust::to_str(zz_fold.fold_crate(ast),fake_print_crate,\n+                                    token::get_ident_interner()),\n+                     ~\"#[a]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\");\n+    }\n+\n+    // even inside macro defs....\n+    #[test] fn ident_transformation_in_defs () {\n+        let zz_fold = fun_to_ident_folder(to_zz());\n+        let ast = string_to_crate(@~\"macro_rules! a {(b $c:expr $(d $e:token)f+\n+=> (g $(d $d $e)+))} \");\n+        assert_pred!(matches_codepattern,\n+                     \"matches_codepattern\",\n+                     pprust::to_str(zz_fold.fold_crate(ast),fake_print_crate,\n+                                    token::get_ident_interner()),\n+                     ~\"zz!zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)))\");\n+    }\n+\n+}"}, {"sha": "76055ca7914e729be822c339b03d431f2693c0ee", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/6a09b6f0c325dcef72fd623b89064df868c96412/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a09b6f0c325dcef72fd623b89064df868c96412/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=6a09b6f0c325dcef72fd623b89064df868c96412", "patch": "@@ -69,3 +69,81 @@ pub fn string_to_pat(source_str : @~str) -> @ast::pat {\n pub fn strs_to_idents(ids: ~[&str]) -> ~[ast::ident] {\n     ids.map(|u| token::str_to_ident(*u))\n }\n+\n+// does the given string match the pattern? whitespace in the first string\n+// may be deleted or replaced with other whitespace to match the pattern.\n+// this function is unicode-ignorant; fortunately, the careful design of\n+// UTF-8 mitigates this ignorance.  In particular, this function only collapses\n+// sequences of \\n, \\r, ' ', and \\t, but it should otherwise tolerate unicode\n+// chars. Unsurprisingly, it doesn't do NKF-normalization(?).\n+pub fn matches_codepattern(a : &str, b : &str) -> bool {\n+    let mut idx_a = 0;\n+    let mut idx_b = 0;\n+    loop {\n+        if (idx_a == a.len() && idx_b == b.len()) {\n+            return true;\n+        }\n+        else if (idx_a == a.len()) {return false;}\n+        else if (idx_b == b.len()) {\n+            // maybe the stuff left in a is all ws?\n+            if (is_whitespace(a.char_at(idx_a))) {\n+                return (scan_for_non_ws_or_end(a,idx_a) == a.len());\n+            } else {\n+                return false;\n+            }\n+        }\n+        // ws in both given and pattern:\n+        else if (is_whitespace(a.char_at(idx_a))\n+           && is_whitespace(b.char_at(idx_b))) {\n+            idx_a = scan_for_non_ws_or_end(a,idx_a);\n+            idx_b = scan_for_non_ws_or_end(b,idx_b);\n+        }\n+        // ws in given only:\n+        else if (is_whitespace(a.char_at(idx_a))) {\n+            idx_a = scan_for_non_ws_or_end(a,idx_a);\n+        }\n+        // *don't* silently eat ws in expected only.\n+        else if (a.char_at(idx_a) == b.char_at(idx_b)) {\n+            idx_a += 1;\n+            idx_b += 1;\n+        }\n+        else {\n+            return false;\n+        }\n+    }\n+}\n+\n+// given a string and an index, return the first uint >= idx\n+// that is a non-ws-char or is outside of the legal range of\n+// the string.\n+fn scan_for_non_ws_or_end(a : &str, idx: uint) -> uint {\n+    let mut i = idx;\n+    let len = a.len();\n+    while ((i < len) && (is_whitespace(a.char_at(i)))) {\n+        i += 1;\n+    }\n+    i\n+}\n+\n+// copied from lexer.\n+pub fn is_whitespace(c: char) -> bool {\n+    return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test] fn eqmodws() {\n+        assert_eq!(matches_codepattern(\"\",\"\"),true);\n+        assert_eq!(matches_codepattern(\"\",\"a\"),false);\n+        assert_eq!(matches_codepattern(\"a\",\"\"),false);\n+        assert_eq!(matches_codepattern(\"a\",\"a\"),true);\n+        assert_eq!(matches_codepattern(\"a b\",\"a   \\n\\t\\r  b\"),true);\n+        assert_eq!(matches_codepattern(\"a b \",\"a   \\n\\t\\r  b\"),true);\n+        assert_eq!(matches_codepattern(\"a b\",\"a   \\n\\t\\r  b \"),false);\n+        assert_eq!(matches_codepattern(\"a   b\",\"a b\"),true);\n+        assert_eq!(matches_codepattern(\"ab\",\"a b\"),false);\n+        assert_eq!(matches_codepattern(\"a   b\",\"ab\"),true);\n+    }\n+}"}]}