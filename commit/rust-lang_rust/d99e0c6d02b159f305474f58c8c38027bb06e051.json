{"sha": "d99e0c6d02b159f305474f58c8c38027bb06e051", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5OWUwYzZkMDJiMTU5ZjMwNTQ3NGY1OGM4YzM4MDI3YmIwNmUwNTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-29T14:51:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-29T14:51:59Z"}, "message": "Auto merge of #66697 - petrochenkov:nocstore, r=eddyb\n\nrustc_metadata: Privatize more things and a couple of other refactorings\n\nThis PR continues https://github.com/rust-lang/rust/pull/66496 and hits the point of diminishing returns.\nAll fields of `CrateRoot` and `CrateMetadata` are privatized.\nFor read-only fields this certainly makes sense, but for a few fields updateable from outside of `rmeta.rs` (mostly `creader.rs`) it was done mostly for consistency, I can make them `pub(crate)` again if requested.\n\n`cstore.rs` (which became small after #66496) was merged into `creader.rs`.\n\nA few things noticed while making the privacy changes were addressed in the remaining refactoring commits.\n\nFixes https://github.com/rust-lang/rust/issues/66550\nr? @eddyb @Mark-Simulacrum", "tree": {"sha": "669f3ce8eae2b58f129fdb237764ce9ff3389291", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/669f3ce8eae2b58f129fdb237764ce9ff3389291"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d99e0c6d02b159f305474f58c8c38027bb06e051", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d99e0c6d02b159f305474f58c8c38027bb06e051", "html_url": "https://github.com/rust-lang/rust/commit/d99e0c6d02b159f305474f58c8c38027bb06e051", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d99e0c6d02b159f305474f58c8c38027bb06e051/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4375c9dfdd7f31de909f6e9384bac1bf37b44da", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4375c9dfdd7f31de909f6e9384bac1bf37b44da", "html_url": "https://github.com/rust-lang/rust/commit/c4375c9dfdd7f31de909f6e9384bac1bf37b44da"}, {"sha": "e84c926d4758ba8600a3841d442e888fd2c25f6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e84c926d4758ba8600a3841d442e888fd2c25f6b", "html_url": "https://github.com/rust-lang/rust/commit/e84c926d4758ba8600a3841d442e888fd2c25f6b"}], "stats": {"total": 662, "additions": 338, "deletions": 324}, "files": [{"sha": "44c6f6b07f56cc7eecd54c273767ca3dab0a900e", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=d99e0c6d02b159f305474f58c8c38027bb06e051", "patch": "@@ -146,6 +146,13 @@ impl ExternCrate {\n     pub fn is_direct(&self) -> bool {\n         self.dependency_of == LOCAL_CRATE\n     }\n+\n+    pub fn rank(&self) -> impl PartialOrd {\n+        // Prefer:\n+        // - direct extern crate to indirect\n+        // - shorter paths to longer\n+        (self.is_direct(), !self.path_len)\n+    }\n }\n \n #[derive(Copy, Clone, Debug, HashStable)]\n@@ -204,7 +211,7 @@ pub type MetadataLoaderDyn = dyn MetadataLoader + Sync;\n /// (it'd break incremental compilation) and should only be called pre-HIR (e.g.\n /// during resolve)\n pub trait CrateStore {\n-    fn crate_data_as_any(&self, cnum: CrateNum) -> &dyn Any;\n+    fn as_any(&self) -> &dyn Any;\n \n     // resolve\n     fn def_key(&self, def: DefId) -> DefKey;\n@@ -217,9 +224,7 @@ pub trait CrateStore {\n     fn crate_is_private_dep_untracked(&self, cnum: CrateNum) -> bool;\n     fn crate_disambiguator_untracked(&self, cnum: CrateNum) -> CrateDisambiguator;\n     fn crate_hash_untracked(&self, cnum: CrateNum) -> Svh;\n-    fn crate_host_hash_untracked(&self, cnum: CrateNum) -> Option<Svh>;\n     fn item_generics_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::Generics;\n-    fn postorder_cnums_untracked(&self) -> Vec<CrateNum>;\n \n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n@@ -228,7 +233,6 @@ pub trait CrateStore {\n     // utility functions\n     fn encode_metadata(&self, tcx: TyCtxt<'_>) -> EncodedMetadata;\n     fn metadata_encoding_version(&self) -> &[u8];\n-    fn injected_panic_runtime(&self) -> Option<CrateNum>;\n     fn allocator_kind(&self) -> Option<AllocatorKind>;\n }\n "}, {"sha": "0b9d04ca6a3b5d504e6e781ecedafa735b8b728c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=d99e0c6d02b159f305474f58c8c38027bb06e051", "patch": "@@ -133,9 +133,6 @@ pub struct Session {\n     /// false positives about a job server in our environment.\n     pub jobserver: Client,\n \n-    /// Metadata about the allocators for the current crate being compiled.\n-    pub has_global_allocator: Once<bool>,\n-\n     /// Cap lint level specified by a driver specifically.\n     pub driver_lint_caps: FxHashMap<lint::LintId, lint::Level>,\n \n@@ -1180,7 +1177,6 @@ fn build_session_(\n         print_fuel_crate,\n         print_fuel,\n         jobserver: jobserver::client(),\n-        has_global_allocator: Once::new(),\n         driver_lint_caps,\n         trait_methods_not_found: Lock::new(Default::default()),\n         confused_type_with_std_module: Lock::new(Default::default()),"}, {"sha": "5a7078cdb261239b0c05129a8ba0645cc4d115de", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=d99e0c6d02b159f305474f58c8c38027bb06e051", "patch": "@@ -1307,10 +1307,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.all_crate_nums(LOCAL_CRATE)\n     }\n \n-    pub fn injected_panic_runtime(self) -> Option<CrateNum> {\n-        self.cstore.injected_panic_runtime()\n-    }\n-\n     pub fn allocator_kind(self) -> Option<AllocatorKind> {\n         self.cstore.allocator_kind()\n     }\n@@ -1391,8 +1387,8 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     // Note that this is *untracked* and should only be used within the query\n     // system if the result is otherwise tracked through queries\n-    pub fn crate_data_as_any(self, cnum: CrateNum) -> &'tcx dyn Any {\n-        self.cstore.crate_data_as_any(cnum)\n+    pub fn cstore_as_any(self) -> &'tcx dyn Any {\n+        self.cstore.as_any()\n     }\n \n     #[inline(always)]\n@@ -2999,14 +2995,6 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         assert_eq!(cnum, LOCAL_CRATE);\n         tcx.arena.alloc_slice(&tcx.cstore.crates_untracked())\n     };\n-    providers.crate_host_hash = |tcx, cnum| {\n-        assert_ne!(cnum, LOCAL_CRATE);\n-        tcx.cstore.crate_host_hash_untracked(cnum)\n-    };\n-    providers.postorder_cnums = |tcx, cnum| {\n-        assert_eq!(cnum, LOCAL_CRATE);\n-        tcx.arena.alloc_slice(&tcx.cstore.postorder_cnums_untracked())\n-    };\n     providers.output_filenames = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n         tcx.output_filenames.clone()"}, {"sha": "5f00bebced35a30293e8c49a6b0593d41c426a46", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=d99e0c6d02b159f305474f58c8c38027bb06e051", "patch": "@@ -25,7 +25,6 @@ use rustc_data_structures::{box_region_allow_access, declare_box_region_type, pa\n use rustc_data_structures::sync::{Lrc, ParallelIterator, par_iter};\n use rustc_errors::PResult;\n use rustc_incremental;\n-use rustc_metadata::cstore;\n use rustc_mir as mir;\n use rustc_parse::{parse_crate_from_file, parse_crate_from_source_str};\n use rustc_passes::{self, ast_validation, hir_stats, layout_test};\n@@ -728,15 +727,15 @@ pub fn default_provide(providers: &mut ty::query::Providers<'_>) {\n     rustc_passes::provide(providers);\n     rustc_traits::provide(providers);\n     middle::region::provide(providers);\n-    cstore::provide(providers);\n+    rustc_metadata::provide(providers);\n     lint::provide(providers);\n     rustc_lint::provide(providers);\n     rustc_codegen_utils::provide(providers);\n     rustc_codegen_ssa::provide(providers);\n }\n \n pub fn default_provide_extern(providers: &mut ty::query::Providers<'_>) {\n-    cstore::provide_extern(providers);\n+    rustc_metadata::provide_extern(providers);\n     rustc_codegen_ssa::provide_extern(providers);\n }\n "}, {"sha": "dbf2dcf1c0aea461d6be050c33deaf806f453dc5", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 170, "deletions": 132, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=d99e0c6d02b159f305474f58c8c38027bb06e051", "patch": "@@ -1,38 +1,47 @@\n //! Validates all used crates and extern libraries and loads their metadata\n \n-use crate::cstore::CStore;\n use crate::locator::{CrateLocator, CratePaths};\n use crate::rmeta::{CrateMetadata, CrateNumMap, CrateRoot, CrateDep, MetadataBlob};\n \n use rustc::hir::def_id::CrateNum;\n use rustc_data_structures::svh::Svh;\n+use rustc_data_structures::sync::Lrc;\n+use rustc_index::vec::IndexVec;\n use rustc::middle::cstore::DepKind;\n use rustc::session::{Session, CrateDisambiguator};\n use rustc::session::config::{Sanitizer, self};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n use rustc::session::search_paths::PathKind;\n use rustc::middle::cstore::{CrateSource, ExternCrate, ExternCrateSource, MetadataLoaderDyn};\n-use rustc::util::nodemap::FxHashSet;\n use rustc::hir::map::Definitions;\n use rustc::hir::def_id::LOCAL_CRATE;\n+use rustc::ty::TyCtxt;\n \n use std::path::Path;\n use std::{cmp, fs};\n \n use syntax::ast;\n use syntax::attr;\n+use syntax::edition::Edition;\n use syntax::expand::allocator::{global_allocator_spans, AllocatorKind};\n use syntax::symbol::{Symbol, sym};\n use syntax::span_fatal;\n+use syntax_expand::base::SyntaxExtension;\n use syntax_pos::{Span, DUMMY_SP};\n use log::{debug, info, log_enabled};\n use proc_macro::bridge::client::ProcMacro;\n \n use rustc_error_codes::*;\n \n-crate struct Library {\n-    pub source: CrateSource,\n-    pub metadata: MetadataBlob,\n+#[derive(Clone)]\n+pub struct CStore {\n+    metas: IndexVec<CrateNum, Option<Lrc<CrateMetadata>>>,\n+    injected_panic_runtime: Option<CrateNum>,\n+    /// This crate needs an allocator and either provides it itself, or finds it in a dependency.\n+    /// If the above is true, then this field denotes the kind of the found allocator.\n+    allocator_kind: Option<AllocatorKind>,\n+    /// This crate has a `#[global_allocator]` item.\n+    has_global_allocator: bool,\n }\n \n pub struct CrateLoader<'a> {\n@@ -44,18 +53,14 @@ pub struct CrateLoader<'a> {\n     cstore: CStore,\n }\n \n-fn dump_crates(cstore: &CStore) {\n-    info!(\"resolved crates:\");\n-    cstore.iter_crate_data(|cnum, data| {\n-        info!(\"  name: {}\", data.root.name);\n-        info!(\"  cnum: {}\", cnum);\n-        info!(\"  hash: {}\", data.root.hash);\n-        info!(\"  reqd: {:?}\", *data.dep_kind.lock());\n-        let CrateSource { dylib, rlib, rmeta } = data.source.clone();\n-        dylib.map(|dl| info!(\"  dylib: {}\", dl.0.display()));\n-        rlib.map(|rl|  info!(\"   rlib: {}\", rl.0.display()));\n-        rmeta.map(|rl| info!(\"   rmeta: {}\", rl.0.display()));\n-    });\n+pub enum LoadedMacro {\n+    MacroDef(ast::Item, Edition),\n+    ProcMacro(SyntaxExtension),\n+}\n+\n+crate struct Library {\n+    pub source: CrateSource,\n+    pub metadata: MetadataBlob,\n }\n \n enum LoadResult {\n@@ -75,6 +80,90 @@ impl<'a> LoadError<'a> {\n     }\n }\n \n+fn dump_crates(cstore: &CStore) {\n+    info!(\"resolved crates:\");\n+    cstore.iter_crate_data(|cnum, data| {\n+        info!(\"  name: {}\", data.name());\n+        info!(\"  cnum: {}\", cnum);\n+        info!(\"  hash: {}\", data.hash());\n+        info!(\"  reqd: {:?}\", data.dep_kind());\n+        let CrateSource { dylib, rlib, rmeta } = data.source();\n+        dylib.as_ref().map(|dl| info!(\"  dylib: {}\", dl.0.display()));\n+        rlib.as_ref().map(|rl|  info!(\"   rlib: {}\", rl.0.display()));\n+        rmeta.as_ref().map(|rl| info!(\"   rmeta: {}\", rl.0.display()));\n+    });\n+}\n+\n+impl CStore {\n+    crate fn from_tcx(tcx: TyCtxt<'_>) -> &CStore {\n+        tcx.cstore_as_any().downcast_ref::<CStore>().expect(\"`tcx.cstore` is not a `CStore`\")\n+    }\n+\n+    fn alloc_new_crate_num(&mut self) -> CrateNum {\n+        self.metas.push(None);\n+        CrateNum::new(self.metas.len() - 1)\n+    }\n+\n+    crate fn get_crate_data(&self, cnum: CrateNum) -> &CrateMetadata {\n+        self.metas[cnum].as_ref()\n+            .unwrap_or_else(|| panic!(\"Failed to get crate data for {:?}\", cnum))\n+    }\n+\n+    fn set_crate_data(&mut self, cnum: CrateNum, data: CrateMetadata) {\n+        assert!(self.metas[cnum].is_none(), \"Overwriting crate metadata entry\");\n+        self.metas[cnum] = Some(Lrc::new(data));\n+    }\n+\n+    crate fn iter_crate_data(&self, mut f: impl FnMut(CrateNum, &CrateMetadata)) {\n+        for (cnum, data) in self.metas.iter_enumerated() {\n+            if let Some(data) = data {\n+                f(cnum, data);\n+            }\n+        }\n+    }\n+\n+    fn push_dependencies_in_postorder(&self, deps: &mut Vec<CrateNum>, cnum: CrateNum) {\n+        if !deps.contains(&cnum) {\n+            let data = self.get_crate_data(cnum);\n+            for &dep in data.dependencies().iter() {\n+                if dep != cnum {\n+                    self.push_dependencies_in_postorder(deps, dep);\n+                }\n+            }\n+\n+            deps.push(cnum);\n+        }\n+    }\n+\n+    crate fn crate_dependencies_in_postorder(&self, cnum: CrateNum) -> Vec<CrateNum> {\n+        let mut deps = Vec::new();\n+        if cnum == LOCAL_CRATE {\n+            self.iter_crate_data(|cnum, _| self.push_dependencies_in_postorder(&mut deps, cnum));\n+        } else {\n+            self.push_dependencies_in_postorder(&mut deps, cnum);\n+        }\n+        deps\n+    }\n+\n+    fn crate_dependencies_in_reverse_postorder(&self, cnum: CrateNum) -> Vec<CrateNum> {\n+        let mut deps = self.crate_dependencies_in_postorder(cnum);\n+        deps.reverse();\n+        deps\n+    }\n+\n+    crate fn injected_panic_runtime(&self) -> Option<CrateNum> {\n+        self.injected_panic_runtime\n+    }\n+\n+    crate fn allocator_kind(&self) -> Option<AllocatorKind> {\n+        self.allocator_kind\n+    }\n+\n+    crate fn has_global_allocator(&self) -> bool {\n+        self.has_global_allocator\n+    }\n+}\n+\n impl<'a> CrateLoader<'a> {\n     pub fn new(\n         sess: &'a Session,\n@@ -85,7 +174,16 @@ impl<'a> CrateLoader<'a> {\n             sess,\n             metadata_loader,\n             local_crate_name: Symbol::intern(local_crate_name),\n-            cstore: Default::default(),\n+            cstore: CStore {\n+                // We add an empty entry for LOCAL_CRATE (which maps to zero) in\n+                // order to make array indices in `metas` match with the\n+                // corresponding `CrateNum`. This first entry will always remain\n+                // `None`.\n+                metas: IndexVec::from_elem_n(None, 1),\n+                injected_panic_runtime: None,\n+                allocator_kind: None,\n+                has_global_allocator: false,\n+            }\n         }\n     }\n \n@@ -97,14 +195,13 @@ impl<'a> CrateLoader<'a> {\n         self.cstore\n     }\n \n-    fn existing_match(&self, name: Symbol, hash: Option<&Svh>, kind: PathKind)\n-                      -> Option<CrateNum> {\n+    fn existing_match(&self, name: Symbol, hash: Option<Svh>, kind: PathKind) -> Option<CrateNum> {\n         let mut ret = None;\n         self.cstore.iter_crate_data(|cnum, data| {\n-            if data.root.name != name { return }\n+            if data.name() != name { return }\n \n             match hash {\n-                Some(hash) if *hash == data.root.hash => { ret = Some(cnum); return }\n+                Some(hash) if hash == data.hash() => { ret = Some(cnum); return }\n                 Some(..) => return,\n                 None => {}\n             }\n@@ -118,7 +215,7 @@ impl<'a> CrateLoader<'a> {\n             // We're also sure to compare *paths*, not actual byte slices. The\n             // `source` stores paths which are normalized which may be different\n             // from the strings on the command line.\n-            let source = &self.cstore.get_crate_data(cnum).source;\n+            let source = self.cstore.get_crate_data(cnum).source();\n             if let Some(entry) = self.sess.opts.externs.get(&name.as_str()) {\n                 // Only use `--extern crate_name=path` here, not `--extern crate_name`.\n                 let found = entry.locations.iter().filter_map(|l| l.as_ref()).any(|l| {\n@@ -152,26 +249,26 @@ impl<'a> CrateLoader<'a> {\n                                   span: Span,\n                                   root: &CrateRoot<'_>) {\n         // Check for (potential) conflicts with the local crate\n-        if self.local_crate_name == root.name &&\n-           self.sess.local_crate_disambiguator() == root.disambiguator {\n+        if self.local_crate_name == root.name() &&\n+           self.sess.local_crate_disambiguator() == root.disambiguator() {\n             span_fatal!(self.sess, span, E0519,\n                         \"the current crate is indistinguishable from one of its \\\n                          dependencies: it has the same crate-name `{}` and was \\\n                          compiled with the same `-C metadata` arguments. This \\\n                          will result in symbol conflicts between the two.\",\n-                        root.name)\n+                        root.name())\n         }\n \n         // Check for conflicts with any crate loaded so far\n         self.cstore.iter_crate_data(|_, other| {\n-            if other.root.name == root.name && // same crate-name\n-               other.root.disambiguator == root.disambiguator &&  // same crate-disambiguator\n-               other.root.hash != root.hash { // but different SVH\n+            if other.name() == root.name() && // same crate-name\n+               other.disambiguator() == root.disambiguator() &&  // same crate-disambiguator\n+               other.hash() != root.hash() { // but different SVH\n                 span_fatal!(self.sess, span, E0523,\n                         \"found two different crates with name `{}` that are \\\n                          not distinguished by differing `-C metadata`. This \\\n                          will result in symbol conflicts between the two.\",\n-                        root.name)\n+                        root.name())\n             }\n         });\n     }\n@@ -189,14 +286,14 @@ impl<'a> CrateLoader<'a> {\n \n         let Library { source, metadata } = lib;\n         let crate_root = metadata.get_root();\n-        let host_hash = host_lib.as_ref().map(|lib| lib.metadata.get_root().hash);\n+        let host_hash = host_lib.as_ref().map(|lib| lib.metadata.get_root().hash());\n         self.verify_no_symbol_conflicts(span, &crate_root);\n \n         let private_dep = self.sess.opts.externs.get(&name.as_str())\n             .map(|e| e.is_private_dep)\n             .unwrap_or(false);\n \n-        info!(\"register crate `{}` (private_dep = {})\", crate_root.name, private_dep);\n+        info!(\"register crate `{}` (private_dep = {})\", crate_root.name(), private_dep);\n \n         // Claim this crate number and cache it\n         let cnum = self.cstore.alloc_new_crate_num();\n@@ -207,7 +304,7 @@ impl<'a> CrateLoader<'a> {\n         let root = if let Some(root) = root {\n             root\n         } else {\n-            crate_paths = CratePaths::new(crate_root.name, source.clone());\n+            crate_paths = CratePaths::new(crate_root.name(), source.clone());\n             &crate_paths\n         };\n \n@@ -221,7 +318,7 @@ impl<'a> CrateLoader<'a> {\n                 None => (&source, &crate_root),\n             };\n             let dlsym_dylib = dlsym_source.dylib.as_ref().expect(\"no dylib for a proc-macro crate\");\n-            Some(self.dlsym_proc_macros(&dlsym_dylib.0, dlsym_root.disambiguator, span))\n+            Some(self.dlsym_proc_macros(&dlsym_dylib.0, dlsym_root.disambiguator(), span))\n         } else {\n             None\n         };\n@@ -316,10 +413,10 @@ impl<'a> CrateLoader<'a> {\n         let (root, hash, host_hash, extra_filename, path_kind) = match dep {\n             Some((root, dep)) => (\n                 Some(root),\n-                Some(&dep.hash),\n-                dep.host_hash.as_ref(),\n+                Some(dep.hash),\n+                dep.host_hash,\n                 Some(&dep.extra_filename[..]),\n-                PathKind::Dependency\n+                PathKind::Dependency,\n             ),\n             None => (None, None, None, None, PathKind::Crate),\n         };\n@@ -350,12 +447,10 @@ impl<'a> CrateLoader<'a> {\n         match result {\n             (LoadResult::Previous(cnum), None) => {\n                 let data = self.cstore.get_crate_data(cnum);\n-                if data.root.is_proc_macro_crate() {\n+                if data.is_proc_macro_crate() {\n                     dep_kind = DepKind::UnexportedMacrosOnly;\n                 }\n-                data.dep_kind.with_lock(|data_dep_kind| {\n-                    *data_dep_kind = cmp::max(*data_dep_kind, dep_kind);\n-                });\n+                data.update_dep_kind(|data_dep_kind| cmp::max(data_dep_kind, dep_kind));\n                 Ok(cnum)\n             }\n             (LoadResult::Loaded(library), host_library) => {\n@@ -380,7 +475,7 @@ impl<'a> CrateLoader<'a> {\n         if locator.triple == self.sess.opts.target_triple {\n             let mut result = LoadResult::Loaded(library);\n             self.cstore.iter_crate_data(|cnum, data| {\n-                if data.root.name == root.name && root.hash == data.root.hash {\n+                if data.name() == root.name() && root.hash() == data.hash() {\n                     assert!(locator.hash.is_none());\n                     info!(\"load success, going to previous cnum: {}\", cnum);\n                     result = LoadResult::Previous(cnum);\n@@ -392,44 +487,14 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn update_extern_crate(&self,\n-                           cnum: CrateNum,\n-                           mut extern_crate: ExternCrate,\n-                           visited: &mut FxHashSet<(CrateNum, bool)>)\n-    {\n-        if !visited.insert((cnum, extern_crate.is_direct())) { return }\n-\n+    fn update_extern_crate(&self, cnum: CrateNum, extern_crate: ExternCrate) {\n         let cmeta = self.cstore.get_crate_data(cnum);\n-        let mut old_extern_crate = cmeta.extern_crate.borrow_mut();\n-\n-        // Prefer:\n-        // - something over nothing (tuple.0);\n-        // - direct extern crate to indirect (tuple.1);\n-        // - shorter paths to longer (tuple.2).\n-        let new_rank = (\n-            true,\n-            extern_crate.is_direct(),\n-            cmp::Reverse(extern_crate.path_len),\n-        );\n-        let old_rank = match *old_extern_crate {\n-            None => (false, false, cmp::Reverse(usize::max_value())),\n-            Some(ref c) => (\n-                true,\n-                c.is_direct(),\n-                cmp::Reverse(c.path_len),\n-            ),\n-        };\n-        if old_rank >= new_rank {\n-            return; // no change needed\n-        }\n-\n-        *old_extern_crate = Some(extern_crate);\n-        drop(old_extern_crate);\n-\n-        // Propagate the extern crate info to dependencies.\n-        extern_crate.dependency_of = cnum;\n-        for &dep_cnum in cmeta.dependencies.borrow().iter() {\n-            self.update_extern_crate(dep_cnum, extern_crate, visited);\n+        if cmeta.update_extern_crate(extern_crate) {\n+            // Propagate the extern crate info to dependencies if it was updated.\n+            let extern_crate = ExternCrate { dependency_of: cnum, ..extern_crate };\n+            for &dep_cnum in cmeta.dependencies().iter() {\n+                self.update_extern_crate(dep_cnum, extern_crate);\n+            }\n         }\n     }\n \n@@ -503,7 +568,6 @@ impl<'a> CrateLoader<'a> {\n         });\n         if !any_non_rlib {\n             info!(\"panic runtime injection skipped, only generating rlib\");\n-            self.cstore.injected_panic_runtime = None;\n             return\n         }\n \n@@ -520,22 +584,20 @@ impl<'a> CrateLoader<'a> {\n                                                           sym::needs_panic_runtime);\n \n         self.cstore.iter_crate_data(|cnum, data| {\n-            needs_panic_runtime = needs_panic_runtime ||\n-                                  data.root.needs_panic_runtime;\n-            if data.root.panic_runtime {\n+            needs_panic_runtime = needs_panic_runtime || data.needs_panic_runtime();\n+            if data.is_panic_runtime() {\n                 // Inject a dependency from all #![needs_panic_runtime] to this\n                 // #![panic_runtime] crate.\n                 self.inject_dependency_if(cnum, \"a panic runtime\",\n-                                          &|data| data.root.needs_panic_runtime);\n-                runtime_found = runtime_found || *data.dep_kind.lock() == DepKind::Explicit;\n+                                          &|data| data.needs_panic_runtime());\n+                runtime_found = runtime_found || data.dep_kind() == DepKind::Explicit;\n             }\n         });\n \n         // If an explicitly linked and matching panic runtime was found, or if\n         // we just don't need one at all, then we're done here and there's\n         // nothing else to do.\n         if !needs_panic_runtime || runtime_found {\n-            self.cstore.injected_panic_runtime = None;\n             return\n         }\n \n@@ -562,19 +624,19 @@ impl<'a> CrateLoader<'a> {\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n-        if !data.root.panic_runtime {\n+        if !data.is_panic_runtime() {\n             self.sess.err(&format!(\"the crate `{}` is not a panic runtime\",\n                                    name));\n         }\n-        if data.root.panic_strategy != desired_strategy {\n+        if data.panic_strategy() != desired_strategy {\n             self.sess.err(&format!(\"the crate `{}` does not have the panic \\\n                                     strategy `{}`\",\n                                    name, desired_strategy.desc()));\n         }\n \n         self.cstore.injected_panic_runtime = Some(cnum);\n         self.inject_dependency_if(cnum, \"a panic runtime\",\n-                                  &|data| data.root.needs_panic_runtime);\n+                                  &|data| data.needs_panic_runtime());\n     }\n \n     fn inject_sanitizer_runtime(&mut self) {\n@@ -648,7 +710,7 @@ impl<'a> CrateLoader<'a> {\n \n             let mut uses_std = false;\n             self.cstore.iter_crate_data(|_, data| {\n-                if data.root.name == sym::std {\n+                if data.name() == sym::std {\n                     uses_std = true;\n                 }\n             });\n@@ -666,7 +728,7 @@ impl<'a> CrateLoader<'a> {\n                 let data = self.cstore.get_crate_data(cnum);\n \n                 // Sanity check the loaded crate to ensure it is indeed a sanitizer runtime\n-                if !data.root.sanitizer_runtime {\n+                if !data.is_sanitizer_runtime() {\n                     self.sess.err(&format!(\"the crate `{}` is not a sanitizer runtime\",\n                                            name));\n                 }\n@@ -687,15 +749,15 @@ impl<'a> CrateLoader<'a> {\n             let data = self.cstore.get_crate_data(cnum);\n \n             // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n-            if !data.root.profiler_runtime {\n+            if !data.is_profiler_runtime() {\n                 self.sess.err(&format!(\"the crate `profiler_builtins` is not \\\n                                         a profiler runtime\"));\n             }\n         }\n     }\n \n     fn inject_allocator_crate(&mut self, krate: &ast::Crate) {\n-        let has_global_allocator = match &*global_allocator_spans(krate) {\n+        self.cstore.has_global_allocator = match &*global_allocator_spans(krate) {\n             [span1, span2, ..] => {\n                 self.sess.struct_span_err(*span2, \"cannot define multiple global allocators\")\n                     .span_label(*span2, \"cannot define a new global allocator\")\n@@ -705,18 +767,16 @@ impl<'a> CrateLoader<'a> {\n             }\n             spans => !spans.is_empty()\n         };\n-        self.sess.has_global_allocator.set(has_global_allocator);\n \n         // Check to see if we actually need an allocator. This desire comes\n         // about through the `#![needs_allocator]` attribute and is typically\n         // written down in liballoc.\n         let mut needs_allocator = attr::contains_name(&krate.attrs,\n                                                       sym::needs_allocator);\n         self.cstore.iter_crate_data(|_, data| {\n-            needs_allocator = needs_allocator || data.root.needs_allocator;\n+            needs_allocator = needs_allocator || data.needs_allocator();\n         });\n         if !needs_allocator {\n-            self.cstore.allocator_kind = None;\n             return\n         }\n \n@@ -732,7 +792,6 @@ impl<'a> CrateLoader<'a> {\n                 }\n             });\n         if all_rlib {\n-            self.cstore.allocator_kind = None;\n             return\n         }\n \n@@ -743,29 +802,24 @@ impl<'a> CrateLoader<'a> {\n         // First up we check for global allocators. Look at the crate graph here\n         // and see what's a global allocator, including if we ourselves are a\n         // global allocator.\n-        let mut global_allocator = if has_global_allocator {\n-            Some(None)\n+        let mut global_allocator = if self.cstore.has_global_allocator {\n+            Some(Symbol::intern(\"this crate\"))\n         } else {\n             None\n         };\n         self.cstore.iter_crate_data(|_, data| {\n-            if !data.root.has_global_allocator {\n+            if !data.has_global_allocator() {\n                 return\n             }\n             match global_allocator {\n-                Some(Some(other_crate)) => {\n+                Some(other_crate) => {\n                     self.sess.err(&format!(\"the `#[global_allocator]` in {} \\\n-                                            conflicts with this global \\\n+                                            conflicts with global \\\n                                             allocator in: {}\",\n                                            other_crate,\n-                                           data.root.name));\n+                                           data.name()));\n                 }\n-                Some(None) => {\n-                    self.sess.err(&format!(\"the `#[global_allocator]` in this \\\n-                                            crate conflicts with global \\\n-                                            allocator in: {}\", data.root.name));\n-                }\n-                None => global_allocator = Some(Some(data.root.name)),\n+                None => global_allocator = Some(data.name()),\n             }\n         });\n         if global_allocator.is_some() {\n@@ -779,7 +833,7 @@ impl<'a> CrateLoader<'a> {\n         // attribute.\n         let mut has_default = attr::contains_name(&krate.attrs, sym::default_lib_allocator);\n         self.cstore.iter_crate_data(|_, data| {\n-            if data.root.has_default_lib_allocator {\n+            if data.has_default_lib_allocator() {\n                 has_default = true;\n             }\n         });\n@@ -790,7 +844,7 @@ impl<'a> CrateLoader<'a> {\n                            add `#[global_allocator]` to a static item \\\n                            that implements the GlobalAlloc trait.\");\n         }\n-        self.cstore.allocator_kind = Some(AllocatorKind::DefaultLib);\n+        self.cstore.allocator_kind = Some(AllocatorKind::Default);\n     }\n \n     fn inject_dependency_if(&self,\n@@ -807,15 +861,15 @@ impl<'a> CrateLoader<'a> {\n         // Before we inject any dependencies, make sure we don't inject a\n         // circular dependency by validating that this crate doesn't\n         // transitively depend on any crates satisfying `needs_dep`.\n-        for dep in self.cstore.crate_dependencies_in_rpo(krate) {\n+        for dep in self.cstore.crate_dependencies_in_reverse_postorder(krate) {\n             let data = self.cstore.get_crate_data(dep);\n             if needs_dep(&data) {\n                 self.sess.err(&format!(\"the crate `{}` cannot depend \\\n                                         on a crate that needs {}, but \\\n                                         it depends on `{}`\",\n-                                       self.cstore.get_crate_data(krate).root.name,\n+                                       self.cstore.get_crate_data(krate).name(),\n                                        what,\n-                                       data.root.name));\n+                                       data.name()));\n             }\n         }\n \n@@ -829,7 +883,7 @@ impl<'a> CrateLoader<'a> {\n             }\n \n             info!(\"injecting a dep from {} to {}\", cnum, krate);\n-            data.dependencies.borrow_mut().push(krate);\n+            data.add_dependency(krate);\n         });\n     }\n \n@@ -879,7 +933,6 @@ impl<'a> CrateLoader<'a> {\n                         path_len,\n                         dependency_of: LOCAL_CRATE,\n                     },\n-                    &mut FxHashSet::default(),\n                 );\n                 cnum\n             }\n@@ -899,27 +952,12 @@ impl<'a> CrateLoader<'a> {\n                 path_len: usize::max_value(),\n                 dependency_of: LOCAL_CRATE,\n             },\n-            &mut FxHashSet::default(),\n         );\n \n         cnum\n     }\n \n     pub fn maybe_process_path_extern(&mut self, name: Symbol, span: Span) -> Option<CrateNum> {\n-        let cnum = self.maybe_resolve_crate(name, span, DepKind::Explicit, None).ok()?;\n-\n-        self.update_extern_crate(\n-            cnum,\n-            ExternCrate {\n-                src: ExternCrateSource::Path,\n-                span,\n-                // to have the least priority in `update_extern_crate`\n-                path_len: usize::max_value(),\n-                dependency_of: LOCAL_CRATE,\n-            },\n-            &mut FxHashSet::default(),\n-        );\n-\n-        Some(cnum)\n+        self.maybe_resolve_crate(name, span, DepKind::Explicit, None).ok()\n     }\n }"}, {"sha": "48cf0b982f2902192775ab755f8aff95d852c59c", "filename": "src/librustc_metadata/cstore.rs", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/c4375c9dfdd7f31de909f6e9384bac1bf37b44da/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4375c9dfdd7f31de909f6e9384bac1bf37b44da/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=c4375c9dfdd7f31de909f6e9384bac1bf37b44da", "patch": "@@ -1,99 +0,0 @@\n-// The crate store - a central repo for information collected about external\n-// crates and libraries\n-\n-use crate::rmeta::CrateMetadata;\n-\n-use rustc_data_structures::sync::Lrc;\n-use rustc_index::vec::IndexVec;\n-use rustc::hir::def_id::CrateNum;\n-use syntax::ast;\n-use syntax::edition::Edition;\n-use syntax::expand::allocator::AllocatorKind;\n-use syntax_expand::base::SyntaxExtension;\n-\n-pub use crate::rmeta::{provide, provide_extern};\n-\n-#[derive(Clone)]\n-pub struct CStore {\n-    metas: IndexVec<CrateNum, Option<Lrc<CrateMetadata>>>,\n-    crate injected_panic_runtime: Option<CrateNum>,\n-    crate allocator_kind: Option<AllocatorKind>,\n-}\n-\n-pub enum LoadedMacro {\n-    MacroDef(ast::Item, Edition),\n-    ProcMacro(SyntaxExtension),\n-}\n-\n-impl Default for CStore {\n-    fn default() -> Self {\n-        CStore {\n-            // We add an empty entry for LOCAL_CRATE (which maps to zero) in\n-            // order to make array indices in `metas` match with the\n-            // corresponding `CrateNum`. This first entry will always remain\n-            // `None`.\n-            metas: IndexVec::from_elem_n(None, 1),\n-            injected_panic_runtime: None,\n-            allocator_kind: None,\n-        }\n-    }\n-}\n-\n-impl CStore {\n-    crate fn alloc_new_crate_num(&mut self) -> CrateNum {\n-        self.metas.push(None);\n-        CrateNum::new(self.metas.len() - 1)\n-    }\n-\n-    crate fn get_crate_data(&self, cnum: CrateNum) -> &CrateMetadata {\n-        self.metas[cnum].as_ref()\n-            .unwrap_or_else(|| panic!(\"Failed to get crate data for {:?}\", cnum))\n-    }\n-\n-    crate fn set_crate_data(&mut self, cnum: CrateNum, data: CrateMetadata) {\n-        assert!(self.metas[cnum].is_none(), \"Overwriting crate metadata entry\");\n-        self.metas[cnum] = Some(Lrc::new(data));\n-    }\n-\n-    crate fn iter_crate_data<I>(&self, mut i: I)\n-        where I: FnMut(CrateNum, &CrateMetadata)\n-    {\n-        for (k, v) in self.metas.iter_enumerated() {\n-            if let &Some(ref v) = v {\n-                i(k, v);\n-            }\n-        }\n-    }\n-\n-    crate fn crate_dependencies_in_rpo(&self, krate: CrateNum) -> Vec<CrateNum> {\n-        let mut ordering = Vec::new();\n-        self.push_dependencies_in_postorder(&mut ordering, krate);\n-        ordering.reverse();\n-        ordering\n-    }\n-\n-    crate fn push_dependencies_in_postorder(&self, ordering: &mut Vec<CrateNum>, krate: CrateNum) {\n-        if ordering.contains(&krate) {\n-            return;\n-        }\n-\n-        let data = self.get_crate_data(krate);\n-        for &dep in data.dependencies.borrow().iter() {\n-            if dep != krate {\n-                self.push_dependencies_in_postorder(ordering, dep);\n-            }\n-        }\n-\n-        ordering.push(krate);\n-    }\n-\n-    crate fn do_postorder_cnums_untracked(&self) -> Vec<CrateNum> {\n-        let mut ordering = Vec::new();\n-        for (num, v) in self.metas.iter_enumerated() {\n-            if let &Some(_) = v {\n-                self.push_dependencies_in_postorder(&mut ordering, num);\n-            }\n-        }\n-        return ordering\n-    }\n-}"}, {"sha": "d6d722c47b3a7e39f56b9eb87765c7fefd64c769", "filename": "src/librustc_metadata/dependency_format.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_metadata%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_metadata%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdependency_format.rs?ref=d99e0c6d02b159f305474f58c8c38027bb06e051", "patch": "@@ -51,6 +51,8 @@\n //! Additionally, the algorithm is geared towards finding *any* solution rather\n //! than finding a number of solutions (there are normally quite a few).\n \n+use crate::creader::CStore;\n+\n use rustc::hir::def_id::CrateNum;\n use rustc::middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n use rustc::middle::cstore::{self, DepKind};\n@@ -184,7 +186,7 @@ fn calculate_type(tcx: TyCtxt<'_>, ty: config::CrateType) -> DependencyList {\n     //\n     // Things like allocators and panic runtimes may not have been activated\n     // quite yet, so do so here.\n-    activate_injected_dep(tcx.injected_panic_runtime(), &mut ret,\n+    activate_injected_dep(CStore::from_tcx(tcx).injected_panic_runtime(), &mut ret,\n                           &|cnum| tcx.is_panic_runtime(cnum));\n \n     // When dylib B links to dylib A, then when using B we must also link to A.\n@@ -263,7 +265,7 @@ fn attempt_static(tcx: TyCtxt<'_>) -> Option<DependencyList> {\n     // Our allocator/panic runtime may not have been linked above if it wasn't\n     // explicitly linked, which is the case for any injected dependency. Handle\n     // that here and activate them.\n-    activate_injected_dep(tcx.injected_panic_runtime(), &mut ret,\n+    activate_injected_dep(CStore::from_tcx(tcx).injected_panic_runtime(), &mut ret,\n                           &|cnum| tcx.is_panic_runtime(cnum));\n \n     Some(ret)"}, {"sha": "8c0b7345e1e8aa0a81cea3b9b5acf345f98d08ca", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=d99e0c6d02b159f305474f58c8c38027bb06e051", "patch": "@@ -24,14 +24,15 @@ extern crate rustc;\n #[macro_use]\n extern crate rustc_data_structures;\n \n+pub use rmeta::{provide, provide_extern};\n+\n mod dependency_format;\n mod foreign_modules;\n mod link_args;\n mod native_libs;\n mod rmeta;\n \n pub mod creader;\n-pub mod cstore;\n pub mod dynamic_lib;\n pub mod locator;\n "}, {"sha": "c6fb80eca055ad98cce36d9faa0cbc2028b4c4ff", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=d99e0c6d02b159f305474f58c8c38027bb06e051", "patch": "@@ -262,8 +262,8 @@ crate struct CrateLocator<'a> {\n     // Immutable per-search configuration.\n     crate_name: Symbol,\n     exact_paths: Vec<PathBuf>,\n-    pub hash: Option<&'a Svh>,\n-    pub host_hash: Option<&'a Svh>,\n+    pub hash: Option<Svh>,\n+    pub host_hash: Option<Svh>,\n     extra_filename: Option<&'a str>,\n     pub target: &'a Target,\n     pub triple: TargetTriple,\n@@ -313,8 +313,8 @@ impl<'a> CrateLocator<'a> {\n         sess: &'a Session,\n         metadata_loader: &'a dyn MetadataLoader,\n         crate_name: Symbol,\n-        hash: Option<&'a Svh>,\n-        host_hash: Option<&'a Svh>,\n+        hash: Option<Svh>,\n+        host_hash: Option<Svh>,\n         extra_filename: Option<&'a str>,\n         is_host: bool,\n         path_kind: PathKind,\n@@ -597,7 +597,7 @@ impl<'a> CrateLocator<'a> {\n                                                \"multiple matching crates for `{}`\",\n                                                self.crate_name);\n                 let candidates = libraries.iter().filter_map(|(_, lib)| {\n-                    let crate_name = &lib.metadata.get_root().name.as_str();\n+                    let crate_name = &lib.metadata.get_root().name().as_str();\n                     match &(&lib.source.dylib, &lib.source.rlib) {\n                         &(&Some((ref pd, _)), &Some((ref pr, _))) => {\n                             Some(format!(\"\\ncrate `{}`: {}\\n{:>padding$}\",\n@@ -774,35 +774,36 @@ impl<'a> CrateLocator<'a> {\n         }\n \n         if self.exact_paths.is_empty() {\n-            if self.crate_name != root.name {\n+            if self.crate_name != root.name() {\n                 info!(\"Rejecting via crate name\");\n                 return None;\n             }\n         }\n \n-        if root.triple != self.triple {\n+        if root.triple() != &self.triple {\n             info!(\"Rejecting via crate triple: expected {} got {}\",\n                   self.triple,\n-                  root.triple);\n+                  root.triple());\n             self.rejected_via_triple.push(CrateMismatch {\n                 path: libpath.to_path_buf(),\n-                got: root.triple.to_string(),\n+                got: root.triple().to_string(),\n             });\n             return None;\n         }\n \n-        if let Some(myhash) = self.hash {\n-            if *myhash != root.hash {\n-                info!(\"Rejecting via hash: expected {} got {}\", *myhash, root.hash);\n+        let hash = root.hash();\n+        if let Some(expected_hash) = self.hash {\n+            if hash != expected_hash {\n+                info!(\"Rejecting via hash: expected {} got {}\", expected_hash, hash);\n                 self.rejected_via_hash.push(CrateMismatch {\n                     path: libpath.to_path_buf(),\n-                    got: myhash.to_string(),\n+                    got: hash.to_string(),\n                 });\n                 return None;\n             }\n         }\n \n-        Some(root.hash)\n+        Some(hash)\n     }\n \n \n@@ -1021,7 +1022,7 @@ pub fn find_plugin_registrar(\n \n     match library.source.dylib {\n         Some(dylib) => {\n-            Some((dylib.0, library.metadata.get_root().disambiguator))\n+            Some((dylib.0, library.metadata.get_root().disambiguator()))\n         }\n         None => {\n             span_err!(sess, span, E0457,"}, {"sha": "820783bab6d276047a3e6c5b4d89bd30316a4324", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 99, "deletions": 6, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=d99e0c6d02b159f305474f58c8c38027bb06e051", "patch": "@@ -4,7 +4,7 @@ use crate::rmeta::*;\n use crate::rmeta::table::{FixedSizeEncoding, Table};\n \n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_data_structures::sync::{Lrc, Lock, Once, AtomicCell};\n+use rustc_data_structures::sync::{Lrc, Lock, LockGuard, Once, AtomicCell};\n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc::hir;\n@@ -66,7 +66,7 @@ crate struct CrateMetadata {\n     /// lifetime is only used behind `Lazy`, and therefore acts like an\n     /// universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n     /// is being used to decode those values.\n-    crate root: CrateRoot<'static>,\n+    root: CrateRoot<'static>,\n     /// For each definition in this crate, we encode a key. When the\n     /// crate is loaded, we read all the keys and put them in this\n     /// hashmap, which gives the reverse mapping. This allows us to\n@@ -97,11 +97,11 @@ crate struct CrateMetadata {\n     /// IDs as they are seen from the current compilation session.\n     cnum_map: CrateNumMap,\n     /// Same ID set as `cnum_map` plus maybe some injected crates like panic runtime.\n-    crate dependencies: Lock<Vec<CrateNum>>,\n+    dependencies: Lock<Vec<CrateNum>>,\n     /// How to link (or not link) this crate to the currently compiled crate.\n-    crate dep_kind: Lock<DepKind>,\n+    dep_kind: Lock<DepKind>,\n     /// Filesystem location of this crate.\n-    crate source: CrateSource,\n+    source: CrateSource,\n     /// Whether or not this crate should be consider a private dependency\n     /// for purposes of the 'exported_private_dependencies' lint\n     private_dep: bool,\n@@ -112,7 +112,7 @@ crate struct CrateMetadata {\n \n     /// Information about the `extern crate` item or path that caused this crate to be loaded.\n     /// If this is `None`, then the crate was injected (e.g., by the allocator).\n-    crate extern_crate: Lock<Option<ExternCrate>>,\n+    extern_crate: Lock<Option<ExternCrate>>,\n }\n \n /// Holds information about a syntax_pos::SourceFile imported from another crate.\n@@ -558,6 +558,22 @@ impl CrateRoot<'_> {\n         self.proc_macro_data.is_some()\n     }\n \n+    crate fn name(&self) -> Symbol {\n+        self.name\n+    }\n+\n+    crate fn disambiguator(&self) -> CrateDisambiguator {\n+        self.disambiguator\n+    }\n+\n+    crate fn hash(&self) -> Svh {\n+        self.hash\n+    }\n+\n+    crate fn triple(&self) -> &TargetTriple {\n+        &self.triple\n+    }\n+\n     crate fn decode_crate_deps(\n         &self,\n         metadata: &'a MetadataBlob,\n@@ -1517,6 +1533,83 @@ impl<'a, 'tcx> CrateMetadata {\n \n         dep_node_index\n     }\n+\n+    crate fn dependencies(&self) -> LockGuard<'_, Vec<CrateNum>> {\n+        self.dependencies.borrow()\n+    }\n+\n+    crate fn add_dependency(&self, cnum: CrateNum) {\n+        self.dependencies.borrow_mut().push(cnum);\n+    }\n+\n+    crate fn update_extern_crate(&self, new_extern_crate: ExternCrate) -> bool {\n+        let mut extern_crate = self.extern_crate.borrow_mut();\n+        let update = Some(new_extern_crate.rank()) > extern_crate.as_ref().map(ExternCrate::rank);\n+        if update {\n+            *extern_crate = Some(new_extern_crate);\n+        }\n+        update\n+    }\n+\n+    crate fn source(&self) -> &CrateSource {\n+        &self.source\n+    }\n+\n+    crate fn dep_kind(&self) -> DepKind {\n+        *self.dep_kind.lock()\n+    }\n+\n+    crate fn update_dep_kind(&self, f: impl FnOnce(DepKind) -> DepKind) {\n+        self.dep_kind.with_lock(|dep_kind| *dep_kind = f(*dep_kind))\n+    }\n+\n+    crate fn panic_strategy(&self) -> PanicStrategy {\n+        self.root.panic_strategy\n+    }\n+\n+    crate fn needs_panic_runtime(&self) -> bool {\n+        self.root.needs_panic_runtime\n+    }\n+\n+    crate fn is_panic_runtime(&self) -> bool {\n+        self.root.panic_runtime\n+    }\n+\n+    crate fn is_sanitizer_runtime(&self) -> bool {\n+        self.root.sanitizer_runtime\n+    }\n+\n+    crate fn is_profiler_runtime(&self) -> bool {\n+        self.root.profiler_runtime\n+    }\n+\n+    crate fn needs_allocator(&self) -> bool {\n+        self.root.needs_allocator\n+    }\n+\n+    crate fn has_global_allocator(&self) -> bool {\n+        self.root.has_global_allocator\n+    }\n+\n+    crate fn has_default_lib_allocator(&self) -> bool {\n+        self.root.has_default_lib_allocator\n+    }\n+\n+    crate fn is_proc_macro_crate(&self) -> bool {\n+        self.root.is_proc_macro_crate()\n+    }\n+\n+    crate fn name(&self) -> Symbol {\n+        self.root.name\n+    }\n+\n+    crate fn disambiguator(&self) -> CrateDisambiguator {\n+        self.root.disambiguator\n+    }\n+\n+    crate fn hash(&self) -> Svh {\n+        self.root.hash\n+    }\n }\n \n // Cannot be implemented on 'ProcMacro', as libproc_macro"}, {"sha": "8214153f153f1ac27378b29461ce0281e00ad9d5", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=d99e0c6d02b159f305474f58c8c38027bb06e051", "patch": "@@ -1,4 +1,4 @@\n-use crate::cstore::{self, LoadedMacro};\n+use crate::creader::{CStore, LoadedMacro};\n use crate::link_args;\n use crate::native_libs;\n use crate::foreign_modules;\n@@ -51,9 +51,7 @@ macro_rules! provide {\n                 let ($def_id, $other) = def_id_arg.into_args();\n                 assert!(!$def_id.is_local());\n \n-                let $cdata = $tcx.crate_data_as_any($def_id.krate);\n-                let $cdata = $cdata.downcast_ref::<rmeta::CrateMetadata>()\n-                    .expect(\"CrateStore created data is not a CrateMetadata\");\n+                let $cdata = CStore::from_tcx($tcx).get_crate_data($def_id.krate);\n \n                 if $tcx.dep_graph.is_fully_enabled() {\n                     let crate_dep_node_index = $cdata.get_crate_dep_node_index($tcx);\n@@ -192,6 +190,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     }\n     crate_disambiguator => { cdata.root.disambiguator }\n     crate_hash => { cdata.root.hash }\n+    crate_host_hash => { cdata.host_hash }\n     original_crate_name => { cdata.root.name }\n \n     extra_filename => { cdata.root.extra_filename.clone() }\n@@ -377,12 +376,20 @@ pub fn provide(providers: &mut Providers<'_>) {\n             assert_eq!(cnum, LOCAL_CRATE);\n             Lrc::new(crate::dependency_format::calculate(tcx))\n         },\n+        has_global_allocator: |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            CStore::from_tcx(tcx).has_global_allocator()\n+        },\n+        postorder_cnums: |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            tcx.arena.alloc_slice(&CStore::from_tcx(tcx).crate_dependencies_in_postorder(cnum))\n+        },\n \n         ..*providers\n     };\n }\n \n-impl cstore::CStore {\n+impl CStore {\n     pub fn export_macros_untracked(&self, cnum: CrateNum) {\n         let data = self.get_crate_data(cnum);\n         let mut dep_kind = data.dep_kind.lock();\n@@ -458,9 +465,9 @@ impl cstore::CStore {\n     }\n }\n \n-impl CrateStore for cstore::CStore {\n-    fn crate_data_as_any(&self, cnum: CrateNum) -> &dyn Any {\n-        self.get_crate_data(cnum)\n+impl CrateStore for CStore {\n+    fn as_any(&self) -> &dyn Any {\n+        self\n     }\n \n     fn item_generics_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::Generics {\n@@ -486,10 +493,6 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(cnum).root.hash\n     }\n \n-    fn crate_host_hash_untracked(&self, cnum: CrateNum) -> Option<Svh> {\n-        self.get_crate_data(cnum).host_hash\n-    }\n-\n     /// Returns the `DefKey` for a given `DefId`. This indicates the\n     /// parent `DefId` as well as some idea of what kind of data the\n     /// `DefId` refers to.\n@@ -516,10 +519,6 @@ impl CrateStore for cstore::CStore {\n         result\n     }\n \n-    fn postorder_cnums_untracked(&self) -> Vec<CrateNum> {\n-        self.do_postorder_cnums_untracked()\n-    }\n-\n     fn encode_metadata(&self, tcx: TyCtxt<'_>) -> EncodedMetadata {\n         encoder::encode_metadata(tcx)\n     }\n@@ -529,11 +528,7 @@ impl CrateStore for cstore::CStore {\n         rmeta::METADATA_HEADER\n     }\n \n-    fn injected_panic_runtime(&self) -> Option<CrateNum> {\n-        self.injected_panic_runtime\n-    }\n-\n     fn allocator_kind(&self) -> Option<AllocatorKind> {\n-        self.allocator_kind\n+        self.allocator_kind()\n     }\n }"}, {"sha": "3a318ddc1e13a5bf61d073c3da154a8d8b54d5f5", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=d99e0c6d02b159f305474f58c8c38027bb06e051", "patch": "@@ -496,7 +496,6 @@ impl<'tcx> EncodeContext<'tcx> {\n \n         let attrs = tcx.hir().krate_attrs();\n         let has_default_lib_allocator = attr::contains_name(&attrs, sym::default_lib_allocator);\n-        let has_global_allocator = *tcx.sess.has_global_allocator.get();\n \n         let root = self.lazy(CrateRoot {\n             name: tcx.crate_name(LOCAL_CRATE),\n@@ -506,7 +505,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             disambiguator: tcx.sess.local_crate_disambiguator(),\n             panic_strategy: tcx.sess.panic_strategy(),\n             edition: tcx.sess.edition(),\n-            has_global_allocator: has_global_allocator,\n+            has_global_allocator: tcx.has_global_allocator(LOCAL_CRATE),\n             has_panic_handler: tcx.has_panic_handler(LOCAL_CRATE),\n             has_default_lib_allocator: has_default_lib_allocator,\n             plugin_registrar_fn: tcx.plugin_registrar_fn(LOCAL_CRATE).map(|id| id.index),"}, {"sha": "4ea562fced304a756946eca01a319a35d881439f", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=d99e0c6d02b159f305474f58c8c38027bb06e051", "patch": "@@ -173,16 +173,16 @@ macro_rules! Lazy {\n \n #[derive(RustcEncodable, RustcDecodable)]\n crate struct CrateRoot<'tcx> {\n-    pub name: Symbol,\n-    pub triple: TargetTriple,\n+    name: Symbol,\n+    triple: TargetTriple,\n     extra_filename: String,\n-    pub hash: Svh,\n-    pub disambiguator: CrateDisambiguator,\n-    pub panic_strategy: PanicStrategy,\n+    hash: Svh,\n+    disambiguator: CrateDisambiguator,\n+    panic_strategy: PanicStrategy,\n     edition: Edition,\n-    pub has_global_allocator: bool,\n+    has_global_allocator: bool,\n     has_panic_handler: bool,\n-    pub has_default_lib_allocator: bool,\n+    has_default_lib_allocator: bool,\n     plugin_registrar_fn: Option<DefIndex>,\n     proc_macro_decls_static: Option<DefIndex>,\n     proc_macro_stability: Option<attr::Stability>,\n@@ -207,12 +207,12 @@ crate struct CrateRoot<'tcx> {\n     proc_macro_data: Option<Lazy<[DefIndex]>>,\n \n     compiler_builtins: bool,\n-    pub needs_allocator: bool,\n-    pub needs_panic_runtime: bool,\n+    needs_allocator: bool,\n+    needs_panic_runtime: bool,\n     no_builtins: bool,\n-    pub panic_runtime: bool,\n-    pub profiler_runtime: bool,\n-    pub sanitizer_runtime: bool,\n+    panic_runtime: bool,\n+    profiler_runtime: bool,\n+    sanitizer_runtime: bool,\n     symbol_mangling_version: SymbolManglingVersion,\n }\n "}, {"sha": "eb7265cb9ccd1920f44339dd4c965ceb8088055c", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=d99e0c6d02b159f305474f58c8c38027bb06e051", "patch": "@@ -19,7 +19,7 @@ use rustc::hir::def::{self, *};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::ty;\n use rustc::middle::cstore::CrateStore;\n-use rustc_metadata::cstore::LoadedMacro;\n+use rustc_metadata::creader::LoadedMacro;\n \n use std::cell::Cell;\n use std::ptr;"}, {"sha": "be36e02f5b5b1e17fc8659c2d5092a98890f3b91", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d99e0c6d02b159f305474f58c8c38027bb06e051", "patch": "@@ -32,8 +32,7 @@ use rustc::ty::{self, DefIdTree, ResolverOutputs};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n use rustc::span_bug;\n \n-use rustc_metadata::creader::CrateLoader;\n-use rustc_metadata::cstore::CStore;\n+use rustc_metadata::creader::{CrateLoader, CStore};\n \n use syntax::{struct_span_err, unwrap_or};\n use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};"}, {"sha": "4b5fc7c2a1e541490b21791e35fc99fa49a14f85", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=d99e0c6d02b159f305474f58c8c38027bb06e051", "patch": "@@ -10,7 +10,7 @@ use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::def::{Res, DefKind, CtorKind};\n use rustc::hir::def_id::DefId;\n-use rustc_metadata::cstore::LoadedMacro;\n+use rustc_metadata::creader::LoadedMacro;\n use rustc::ty;\n use rustc::util::nodemap::FxHashSet;\n "}, {"sha": "cc3eeed04a603145dfab479c458cadf3402f4261", "filename": "src/libsyntax/expand/allocator.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibsyntax%2Fexpand%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Flibsyntax%2Fexpand%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fexpand%2Fallocator.rs?ref=d99e0c6d02b159f305474f58c8c38027bb06e051", "patch": "@@ -5,16 +5,14 @@ use syntax_pos::Span;\n #[derive(Clone, Copy)]\n pub enum AllocatorKind {\n     Global,\n-    DefaultLib,\n-    DefaultExe,\n+    Default,\n }\n \n impl AllocatorKind {\n     pub fn fn_name(&self, base: &str) -> String {\n         match *self {\n             AllocatorKind::Global => format!(\"__rg_{}\", base),\n-            AllocatorKind::DefaultLib => format!(\"__rdl_{}\", base),\n-            AllocatorKind::DefaultExe => format!(\"__rde_{}\", base),\n+            AllocatorKind::Default => format!(\"__rdl_{}\", base),\n         }\n     }\n }"}, {"sha": "a3079113d01cfa29ef828e9b0821bb6b7d7d098c", "filename": "src/test/ui/allocator/two-allocators3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d99e0c6d02b159f305474f58c8c38027bb06e051/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators3.stderr?ref=d99e0c6d02b159f305474f58c8c38027bb06e051", "patch": "@@ -1,4 +1,4 @@\n-error: the `#[global_allocator]` in system_allocator conflicts with this global allocator in: system_allocator2\n+error: the `#[global_allocator]` in system_allocator conflicts with global allocator in: system_allocator2\n \n error: aborting due to previous error\n "}]}