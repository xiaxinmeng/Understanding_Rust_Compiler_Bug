{"sha": "3e98220a1cc9059807961472a9132157cdf3c047", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlOTgyMjBhMWNjOTA1OTgwNzk2MTQ3MmE5MTMyMTU3Y2RmM2MwNDc=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-08T12:40:37Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T19:51:54Z"}, "message": "mir: Translate intrinsics, via old trans where possible.", "tree": {"sha": "e9a187c9c49eb1c92b70d789b7d427c7b788d0f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9a187c9c49eb1c92b70d789b7d427c7b788d0f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e98220a1cc9059807961472a9132157cdf3c047", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e98220a1cc9059807961472a9132157cdf3c047", "html_url": "https://github.com/rust-lang/rust/commit/3e98220a1cc9059807961472a9132157cdf3c047", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e98220a1cc9059807961472a9132157cdf3c047/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee7687a5e5063dd57e7c790523c2ffea1cf49c5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee7687a5e5063dd57e7c790523c2ffea1cf49c5e", "html_url": "https://github.com/rust-lang/rust/commit/ee7687a5e5063dd57e7c790523c2ffea1cf49c5e"}], "stats": {"total": 137, "additions": 106, "deletions": 31}, "files": [{"sha": "17d08cd6c2f292a756cebdd5799d9846fab995dc", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e98220a1cc9059807961472a9132157cdf3c047/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e98220a1cc9059807961472a9132157cdf3c047/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=3e98220a1cc9059807961472a9132157cdf3c047", "patch": "@@ -36,7 +36,7 @@ use trans::build::*;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n use trans::closure;\n-use trans::common::{self, Block, Result, NodeIdAndSpan, CrateContext, FunctionContext};\n+use trans::common::{self, Block, Result, CrateContext, FunctionContext};\n use trans::common::{C_uint, C_undef};\n use trans::consts;\n use trans::datum::*;\n@@ -56,7 +56,6 @@ use trans::Disr;\n use middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_front::hir;\n \n-use syntax::ast;\n use syntax::codemap::DUMMY_SP;\n use syntax::errors;\n use syntax::ptr::P;\n@@ -624,18 +623,9 @@ fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             assert!(abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic);\n             assert!(dest.is_some());\n \n-            let call_info = match debug_loc {\n-                DebugLoc::At(id, span) => NodeIdAndSpan { id: id, span: span },\n-                DebugLoc::None => {\n-                    bcx.sess().bug(\"No call info for intrinsic call?\")\n-                }\n-            };\n-\n-            let arg_cleanup_scope = fcx.push_custom_cleanup_scope();\n             return intrinsic::trans_intrinsic_call(bcx, callee.ty, &fn_ty,\n-                                                   arg_cleanup_scope, args,\n-                                                   dest.unwrap(),\n-                                                   call_info);\n+                                                   args, dest.unwrap(),\n+                                                   debug_loc);\n         }\n         NamedTupleConstructor(disr) => {\n             assert!(dest.is_some());"}, {"sha": "b99cb2b63311c3f2613fd7c7b608a09870b49ae2", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3e98220a1cc9059807961472a9132157cdf3c047/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e98220a1cc9059807961472a9132157cdf3c047/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=3e98220a1cc9059807961472a9132157cdf3c047", "patch": "@@ -47,7 +47,7 @@ use syntax::parse::token;\n \n use rustc::lint;\n use rustc::session::Session;\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, DUMMY_SP};\n \n use std::cmp::Ordering;\n \n@@ -173,10 +173,9 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                             callee_ty: Ty<'tcx>,\n                                             fn_ty: &FnType,\n-                                            cleanup_scope: cleanup::CustomScopeIndex,\n                                             args: callee::CallArgs<'a, 'tcx>,\n                                             dest: expr::Dest,\n-                                            call_info: NodeIdAndSpan)\n+                                            call_debug_location: DebugLoc)\n                                             -> Result<'blk, 'tcx> {\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n@@ -195,7 +194,12 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let ret_ty = sig.output;\n     let name = tcx.item_name(def_id).as_str();\n \n-    let call_debug_location = DebugLoc::At(call_info.id, call_info.span);\n+    let span = match call_debug_location {\n+        DebugLoc::At(_, span) => span,\n+        DebugLoc::None => fcx.span.unwrap_or(DUMMY_SP)\n+    };\n+\n+    let cleanup_scope = fcx.push_custom_cleanup_scope();\n \n     // For `transmute` we can just trans the input expr directly into dest\n     if name == \"transmute\" {\n@@ -644,7 +648,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     },\n                 None => {\n                     span_invalid_monomorphization_error(\n-                        tcx.sess, call_info.span,\n+                        tcx.sess, span,\n                         &format!(\"invalid monomorphization of `{}` intrinsic: \\\n                                   expected basic integer type, found `{}`\", name, sty));\n                         C_null(llret_ty)\n@@ -656,7 +660,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n         (_, \"return_address\") => {\n             if !fcx.fn_ty.ret.is_indirect() {\n-                span_err!(tcx.sess, call_info.span, E0510,\n+                span_err!(tcx.sess, span, E0510,\n                           \"invalid use of `return_address` intrinsic: function \\\n                            does not use out pointer\");\n                 C_null(Type::i8p(ccx))\n@@ -684,7 +688,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                    &llargs,\n                                    ret_ty, llret_ty,\n                                    call_debug_location,\n-                                   call_info)\n+                                   span)\n         }\n         // This requires that atomic intrinsics follow a specific naming pattern:\n         // \"atomic_<operation>[_<ordering>]\", and no ordering means SeqCst\n@@ -1404,7 +1408,7 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n      ret_ty: Ty<'tcx>,\n      llret_ty: Type,\n      call_debug_location: DebugLoc,\n-     call_info: NodeIdAndSpan) -> ValueRef\n+     span: Span) -> ValueRef\n {\n     // macros for error handling:\n     macro_rules! emit_error {\n@@ -1413,7 +1417,7 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n         };\n         ($msg: tt, $($fmt: tt)*) => {\n             span_invalid_monomorphization_error(\n-                bcx.sess(), call_info.span,\n+                bcx.sess(), span,\n                 &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \",\n                                  $msg),\n                          name, $($fmt)*));\n@@ -1482,7 +1486,7 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n     if name.starts_with(\"simd_shuffle\") {\n         let n: usize = match name[\"simd_shuffle\".len()..].parse() {\n             Ok(n) => n,\n-            Err(_) => tcx.sess.span_bug(call_info.span,\n+            Err(_) => tcx.sess.span_bug(span,\n                                         \"bad `simd_shuffle` instruction only caught in trans?\")\n         };\n \n@@ -1502,14 +1506,14 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n \n         let vector = match args {\n             Some(args) => &args[2],\n-            None => bcx.sess().span_bug(call_info.span,\n+            None => bcx.sess().span_bug(span,\n                                         \"intrinsic call with unexpected argument shape\"),\n         };\n         let vector = match consts::const_expr(bcx.ccx(), vector, substs, None,\n             consts::TrueConst::Yes, // this should probably help simd error reporting\n         ) {\n             Ok((vector, _)) => vector,\n-            Err(err) => bcx.sess().span_fatal(call_info.span, &err.description()),\n+            Err(err) => bcx.sess().span_fatal(span, &err.description()),\n         };\n \n         let indices: Option<Vec<_>> = (0..n)\n@@ -1652,7 +1656,7 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n         simd_or: TyUint, TyInt => Or;\n         simd_xor: TyUint, TyInt => Xor;\n     }\n-    bcx.sess().span_bug(call_info.span, \"unknown SIMD intrinsic\");\n+    bcx.sess().span_bug(span, \"unknown SIMD intrinsic\");\n }\n \n // Returns the width of an int TypeVariant, and if it's signed or not"}, {"sha": "547382daab37c6eb08d490d8aaa918da40e44bc0", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 86, "deletions": 5, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/3e98220a1cc9059807961472a9132157cdf3c047/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e98220a1cc9059807961472a9132157cdf3c047/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=3e98220a1cc9059807961472a9132157cdf3c047", "patch": "@@ -15,18 +15,19 @@ use trans::abi::{Abi, FnType};\n use trans::adt;\n use trans::base;\n use trans::build;\n-use trans::callee::{Callee, CalleeData, Fn, Virtual};\n+use trans::callee::{Callee, CalleeData, Fn, Intrinsic, NamedTupleConstructor, Virtual};\n use trans::common::{self, Block, BlockAndBuilder, C_undef};\n use trans::debuginfo::DebugLoc;\n use trans::Disr;\n-use trans::machine::llalign_of_min;\n+use trans::machine::{llalign_of_min, llbitsize_of_real};\n use trans::meth;\n use trans::type_of;\n use trans::glue;\n use trans::type_::Type;\n \n use super::{MirContext, drop};\n use super::lvalue::LvalueRef;\n+use super::operand::OperandRef;\n use super::operand::OperandValue::{self, FatPtr, Immediate, Ref};\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n@@ -168,8 +169,51 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     _ => unreachable!(\"{} is not callable\", callee.ty)\n                 };\n \n-                // We do not translate intrinsics here (they shouldn\u2019t be functions)\n-                assert!(abi != Abi::RustIntrinsic && abi != Abi::PlatformIntrinsic);\n+                // Handle intrinsics old trans wants Expr's for, ourselves.\n+                let intrinsic = match (&callee.ty.sty, &callee.data) {\n+                    (&ty::TyFnDef(def_id, _, _), &Intrinsic) => {\n+                        Some(bcx.tcx().item_name(def_id).as_str())\n+                    }\n+                    _ => None\n+                };\n+                let intrinsic = intrinsic.as_ref().map(|s| &s[..]);\n+\n+                if intrinsic == Some(\"move_val_init\") {\n+                    let &(_, target) = destination.as_ref().unwrap();\n+                    // The first argument is a thin destination pointer.\n+                    let llptr = self.trans_operand(&bcx, &args[0]).immediate();\n+                    let val = self.trans_operand(&bcx, &args[1]);\n+                    self.store_operand(&bcx, llptr, val);\n+                    self.set_operand_dropped(&bcx, &args[1]);\n+                    funclet_br(bcx, self.llblock(target));\n+                    return;\n+                }\n+\n+                if intrinsic == Some(\"transmute\") {\n+                    let &(ref dest, target) = destination.as_ref().unwrap();\n+                    let dst = self.trans_lvalue(&bcx, dest);\n+                    let mut val = self.trans_operand(&bcx, &args[0]);\n+                    if let ty::TyFnDef(def_id, substs, _) = val.ty.sty {\n+                        let llouttype = type_of::type_of(bcx.ccx(), dst.ty.to_ty(bcx.tcx()));\n+                        let out_type_size = llbitsize_of_real(bcx.ccx(), llouttype);\n+                        if out_type_size != 0 {\n+                            // FIXME #19925 Remove this hack after a release cycle.\n+                            let f = Callee::def(bcx.ccx(), def_id, substs);\n+                            let datum = f.reify(bcx.ccx());\n+                            val = OperandRef {\n+                                val: OperandValue::Immediate(datum.val),\n+                                ty: datum.ty\n+                            };\n+                        }\n+                    }\n+\n+                    let llty = type_of::type_of(bcx.ccx(), val.ty);\n+                    let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n+                    self.store_operand(&bcx, cast_ptr, val);\n+                    self.set_operand_dropped(&bcx, &args[0]);\n+                    funclet_br(bcx, self.llblock(target));\n+                    return;\n+                }\n \n                 let extra_args = &args[sig.0.inputs.len()..];\n                 let extra_args = extra_args.iter().map(|op_arg| {\n@@ -215,7 +259,44 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                   &mut idx, &mut callee.data)\n                 }\n \n-                let fn_ptr = callee.reify(bcx.ccx()).val;\n+                let fn_ptr = match callee.data {\n+                    NamedTupleConstructor(_) => {\n+                        // FIXME translate this like mir::Rvalue::Aggregate.\n+                        callee.reify(bcx.ccx()).val\n+                    }\n+                    Intrinsic => {\n+                        use trans::callee::ArgVals;\n+                        use trans::expr::{Ignore, SaveIn};\n+                        use trans::intrinsic::trans_intrinsic_call;\n+\n+                        let (dest, llargs) = if fn_ty.ret.is_indirect() {\n+                            (SaveIn(llargs[0]), &llargs[1..])\n+                        } else if let Some(dest) = ret_dest {\n+                            (SaveIn(dest.llval), &llargs[..])\n+                        } else {\n+                            (Ignore, &llargs[..])\n+                        };\n+\n+                        bcx.with_block(|bcx| {\n+                            let res = trans_intrinsic_call(bcx, callee.ty, &fn_ty,\n+                                                           ArgVals(llargs), dest,\n+                                                           DebugLoc::None);\n+                            let bcx = res.bcx.build();\n+                            if let Some((_, target)) = *destination {\n+                                for op in args {\n+                                    self.set_operand_dropped(&bcx, op);\n+                                }\n+                                funclet_br(bcx, self.llblock(target));\n+                            } else {\n+                                // trans_intrinsic_call already used Unreachable.\n+                                // bcx.unreachable();\n+                            }\n+                        });\n+                        return;\n+                    }\n+                    Fn(f) => f,\n+                    Virtual(_) => unreachable!(\"Virtual fn ptr not extracted\")\n+                };\n \n                 // Many different ways to call a function handled here\n                 if let Some(cleanup) = cleanup.map(|bb| self.bcx(bb)) {"}]}