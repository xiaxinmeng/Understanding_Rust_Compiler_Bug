{"sha": "e2b3fec778453d06be6a07494eeaa66da57e4f82", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyYjNmZWM3Nzg0NTNkMDZiZTZhMDc0OTRlZWFhNjZkYTU3ZTRmODI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-03T08:23:59Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-03T23:48:24Z"}, "message": "Avoid recontructing the `Parser` in `macro_parser.rs`.", "tree": {"sha": "59c04557919baec443a9773b2f17665686ce62b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59c04557919baec443a9773b2f17665686ce62b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2b3fec778453d06be6a07494eeaa66da57e4f82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2b3fec778453d06be6a07494eeaa66da57e4f82", "html_url": "https://github.com/rust-lang/rust/commit/e2b3fec778453d06be6a07494eeaa66da57e4f82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2b3fec778453d06be6a07494eeaa66da57e4f82/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b60bcba9e4229cb6efbb31538aa0fd74a98c32f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b60bcba9e4229cb6efbb31538aa0fd74a98c32f0", "html_url": "https://github.com/rust-lang/rust/commit/b60bcba9e4229cb6efbb31538aa0fd74a98c32f0"}], "stats": {"total": 58, "additions": 16, "deletions": 42}, "files": [{"sha": "2ea01599006e7b3244f6fa6a3500cef9d6860d44", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e2b3fec778453d06be6a07494eeaa66da57e4f82/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b3fec778453d06be6a07494eeaa66da57e4f82/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=e2b3fec778453d06be6a07494eeaa66da57e4f82", "patch": "@@ -278,17 +278,16 @@ pub fn token_name_eq(t1 : &Token, t2 : &Token) -> bool {\n     }\n }\n \n-pub fn parse(sess: &ParseSess, mut rdr: TtReader, ms: &[TokenTree]) -> NamedParseResult {\n-    let mut cur_eis = SmallVector::one(initial_matcher_pos(ms.to_owned(),\n-                                                           None,\n-                                                           rdr.peek().sp.lo));\n+pub fn parse(sess: &ParseSess, rdr: TtReader, ms: &[TokenTree]) -> NamedParseResult {\n+    let mut parser = Parser::new(sess, Box::new(rdr));\n+    let mut cur_eis = SmallVector::one(initial_matcher_pos(ms.to_owned(), None, parser.span.lo));\n \n     loop {\n         let mut bb_eis = Vec::new(); // black-box parsed by parser.rs\n         let mut next_eis = Vec::new(); // or proceed normally\n         let mut eof_eis = Vec::new();\n \n-        let TokenAndSpan { tok, sp } = rdr.peek();\n+        let (sp, tok) = (parser.span, parser.token.clone());\n \n         /* we append new items to this while we go */\n         loop {\n@@ -473,23 +472,19 @@ pub fn parse(sess: &ParseSess, mut rdr: TtReader, ms: &[TokenTree]) -> NamedPars\n                 while !next_eis.is_empty() {\n                     cur_eis.push(next_eis.pop().unwrap());\n                 }\n-                rdr.next_token();\n+                parser.bump();\n             } else /* bb_eis.len() == 1 */ {\n-                rdr.next_tok = {\n-                    let mut rust_parser = Parser::new(sess, Box::new(&mut rdr));\n-                    let mut ei = bb_eis.pop().unwrap();\n-                    if let TokenTree::Token(span, MatchNt(_, ident)) = ei.top_elts.get_tt(ei.idx) {\n-                        let match_cur = ei.match_cur;\n-                        (&mut ei.matches[match_cur]).push(Rc::new(MatchedNonterminal(\n-                            Rc::new(parse_nt(&mut rust_parser, span, &ident.name.as_str())))));\n-                        ei.idx += 1;\n-                        ei.match_cur += 1;\n-                    } else {\n-                        unreachable!()\n-                    }\n-                    cur_eis.push(ei);\n-                    Some(TokenAndSpan { tok: rust_parser.token, sp: rust_parser.span })\n-                };\n+                let mut ei = bb_eis.pop().unwrap();\n+                if let TokenTree::Token(span, MatchNt(_, ident)) = ei.top_elts.get_tt(ei.idx) {\n+                    let match_cur = ei.match_cur;\n+                    (&mut ei.matches[match_cur]).push(Rc::new(MatchedNonterminal(\n+                        Rc::new(parse_nt(&mut parser, span, &ident.name.as_str())))));\n+                    ei.idx += 1;\n+                    ei.match_cur += 1;\n+                } else {\n+                    unreachable!()\n+                }\n+                cur_eis.push(ei);\n             }\n         }\n "}, {"sha": "3d5dec31d2a37ddbab08ce27feae39030def2776", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e2b3fec778453d06be6a07494eeaa66da57e4f82/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b3fec778453d06be6a07494eeaa66da57e4f82/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=e2b3fec778453d06be6a07494eeaa66da57e4f82", "patch": "@@ -178,27 +178,6 @@ impl<'a> Reader for TtReader<'a> {\n     }\n }\n \n-impl<'a, 'b> Reader for &'b mut TtReader<'a> {\n-    fn is_eof(&self) -> bool {\n-        (**self).is_eof()\n-    }\n-    fn try_next_token(&mut self) -> Result<TokenAndSpan, ()> {\n-        (**self).try_next_token()\n-    }\n-    fn fatal(&self, m: &str) -> FatalError {\n-        (**self).fatal(m)\n-    }\n-    fn err(&self, m: &str) {\n-        (**self).err(m)\n-    }\n-    fn emit_fatal_errors(&mut self) {\n-        (**self).emit_fatal_errors()\n-    }\n-    fn peek(&self) -> TokenAndSpan {\n-        (**self).peek()\n-    }\n-}\n-\n impl<'a> StringReader<'a> {\n     /// For comments.rs, which hackily pokes into next_pos and ch\n     pub fn new_raw<'b>(span_diagnostic: &'b Handler,"}]}