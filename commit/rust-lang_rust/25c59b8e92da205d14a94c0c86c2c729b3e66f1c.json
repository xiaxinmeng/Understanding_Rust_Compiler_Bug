{"sha": "25c59b8e92da205d14a94c0c86c2c729b3e66f1c", "node_id": "C_kwDOAAsO6NoAKDI1YzU5YjhlOTJkYTIwNWQxNGE5NGMwYzg2YzJjNzI5YjNlNjZmMWM", "commit": {"author": {"name": "David Barsky", "email": "me@davidbarsky.com", "date": "2023-03-29T19:29:32Z"}, "committer": {"name": "David Barsky", "email": "me@davidbarsky.com", "date": "2023-03-29T19:29:32Z"}, "message": "address PR comments", "tree": {"sha": "03cfa44373dc827a3f0b4a0579f2bc9ee9a80479", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03cfa44373dc827a3f0b4a0579f2bc9ee9a80479"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25c59b8e92da205d14a94c0c86c2c729b3e66f1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25c59b8e92da205d14a94c0c86c2c729b3e66f1c", "html_url": "https://github.com/rust-lang/rust/commit/25c59b8e92da205d14a94c0c86c2c729b3e66f1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25c59b8e92da205d14a94c0c86c2c729b3e66f1c/comments", "author": {"login": "davidbarsky", "id": 2067774, "node_id": "MDQ6VXNlcjIwNjc3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2067774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidbarsky", "html_url": "https://github.com/davidbarsky", "followers_url": "https://api.github.com/users/davidbarsky/followers", "following_url": "https://api.github.com/users/davidbarsky/following{/other_user}", "gists_url": "https://api.github.com/users/davidbarsky/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidbarsky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidbarsky/subscriptions", "organizations_url": "https://api.github.com/users/davidbarsky/orgs", "repos_url": "https://api.github.com/users/davidbarsky/repos", "events_url": "https://api.github.com/users/davidbarsky/events{/privacy}", "received_events_url": "https://api.github.com/users/davidbarsky/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidbarsky", "id": 2067774, "node_id": "MDQ6VXNlcjIwNjc3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2067774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidbarsky", "html_url": "https://github.com/davidbarsky", "followers_url": "https://api.github.com/users/davidbarsky/followers", "following_url": "https://api.github.com/users/davidbarsky/following{/other_user}", "gists_url": "https://api.github.com/users/davidbarsky/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidbarsky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidbarsky/subscriptions", "organizations_url": "https://api.github.com/users/davidbarsky/orgs", "repos_url": "https://api.github.com/users/davidbarsky/repos", "events_url": "https://api.github.com/users/davidbarsky/events{/privacy}", "received_events_url": "https://api.github.com/users/davidbarsky/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5bfd7ef0ac992e25716a4bb2646b331a5a31fc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5bfd7ef0ac992e25716a4bb2646b331a5a31fc4", "html_url": "https://github.com/rust-lang/rust/commit/e5bfd7ef0ac992e25716a4bb2646b331a5a31fc4"}], "stats": {"total": 77, "additions": 19, "deletions": 58}, "files": [{"sha": "3a8c0c385a4846698b079d329d734cf7eb86d02d", "filename": "crates/base-db/src/input.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25c59b8e92da205d14a94c0c86c2c729b3e66f1c/crates%2Fbase-db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c59b8e92da205d14a94c0c86c2c729b3e66f1c/crates%2Fbase-db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase-db%2Fsrc%2Finput.rs?ref=25c59b8e92da205d14a94c0c86c2c729b3e66f1c", "patch": "@@ -17,7 +17,7 @@ use vfs::{file_set::FileSet, AbsPathBuf, AnchoredPath, FileId, VfsPath};\n \n // Map from crate id to the name of the crate and path of the proc-macro. If the value is `None`,\n // then the crate for the proc-macro hasn't been build yet as the build data is missing.\n-pub type ProcMacroPaths = FxHashMap<CrateId, Option<(Option<String>, AbsPathBuf)>>;\n+pub type ProcMacroPaths = FxHashMap<CrateId, Result<(Option<String>, AbsPathBuf), String>>;\n pub type ProcMacros = FxHashMap<CrateId, ProcMacroLoadResult>;\n \n /// Files are grouped into source roots. A source root is a directory on the"}, {"sha": "b6f79b46227729a6b1ebf22471d7da19ff574951", "filename": "crates/project-model/src/workspace.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/25c59b8e92da205d14a94c0c86c2c729b3e66f1c/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c59b8e92da205d14a94c0c86c2c729b3e66f1c/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=25c59b8e92da205d14a94c0c86c2c729b3e66f1c", "patch": "@@ -691,7 +691,7 @@ fn project_json_to_crate_graph(\n     target_layout: TargetLayoutLoadResult,\n ) -> (CrateGraph, ProcMacroPaths) {\n     let mut crate_graph = CrateGraph::default();\n-    let mut proc_macros = FxHashMap::default();\n+    let mut proc_macros: ProcMacroPaths = FxHashMap::default();\n     let sysroot_deps = sysroot.as_ref().map(|sysroot| {\n         sysroot_to_crate_graph(\n             &mut crate_graph,\n@@ -743,13 +743,11 @@ fn project_json_to_crate_graph(\n             );\n             if krate.is_proc_macro {\n                 if let Some(path) = krate.proc_macro_dylib_path.clone() {\n-                    proc_macros.insert(\n-                        crate_graph_crate_id,\n-                        Some((\n-                            krate.display_name.as_ref().map(|it| it.canonical_name().to_owned()),\n-                            path,\n-                        )),\n-                    );\n+                    let node = Ok((\n+                        krate.display_name.as_ref().map(|it| it.canonical_name().to_owned()),\n+                        path,\n+                    ));\n+                    proc_macros.insert(crate_graph_crate_id, node);\n                 }\n             }\n             (crate_id, crate_graph_crate_id)\n@@ -1193,8 +1191,8 @@ fn add_target_crate_root(\n     );\n     if is_proc_macro {\n         let proc_macro = match build_data.as_ref().map(|it| it.proc_macro_dylib_path.as_ref()) {\n-            Some(it) => it.cloned().map(|path| Some((Some(cargo_name.to_owned()), path))),\n-            None => Some(None),\n+            Some(it) => it.cloned().map(|path| Ok((Some(cargo_name.to_owned()), path))),\n+            None => Some(Err(\"crate has not yet been build\".to_owned())),\n         };\n         if let Some(proc_macro) = proc_macro {\n             proc_macros.insert(crate_id, proc_macro);"}, {"sha": "f644bdc7b18579daea7d9f3a0fd3bb4cc4dd2ea5", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25c59b8e92da205d14a94c0c86c2c729b3e66f1c/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c59b8e92da205d14a94c0c86c2c729b3e66f1c/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=25c59b8e92da205d14a94c0c86c2c729b3e66f1c", "patch": "@@ -102,7 +102,7 @@ pub fn load_workspace(\n                 (\n                     crate_id,\n                     path.map_or_else(\n-                        || Err(\"proc macro crate is missing dylib\".to_owned()),\n+                        |_| Err(\"proc macro crate is missing dylib\".to_owned()),\n                         |(_, path)| load_proc_macro(proc_macro_server, &path, &[]),\n                     ),\n                 )"}, {"sha": "c6bd3f0d9cc54adb810ede2fef5b3906839d7020", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 9, "deletions": 46, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/25c59b8e92da205d14a94c0c86c2c729b3e66f1c/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c59b8e92da205d14a94c0c86c2c729b3e66f1c/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=25c59b8e92da205d14a94c0c86c2c729b3e66f1c", "patch": "@@ -251,7 +251,7 @@ impl GlobalState {\n                     (\n                         crate_id,\n                         res.map_or_else(\n-                            || Err(\"proc macro crate is missing dylib\".to_owned()),\n+                            |_| Err(\"proc macro crate is missing dylib\".to_owned()),\n                             |(crate_name, path)| {\n                                 progress(path.display().to_string());\n                                 load_proc_macro(\n@@ -296,25 +296,11 @@ impl GlobalState {\n         let workspaces =\n             workspaces.iter().filter_map(|res| res.as_ref().ok().cloned()).collect::<Vec<_>>();\n \n-        // `different_workspaces` is used to determine whether to spawn a a new proc macro server for\n-        // a newly-added rust workspace (most commonly sourced from a `rust-project.json`). While the\n-        // algorithm to find the new workspaces is quadratic, we generally expect that the number of total\n-        // workspaces to remain in the low single digits. the `cloned_workspace` is needed for borrowck\n-        // reasons.\n-        let cloned_workspaces = workspaces.clone();\n-        let different_workspaces = cloned_workspaces\n-            .iter()\n-            .filter(|ws| {\n-                !self\n-                    .workspaces\n-                    .iter()\n-                    .find(|existing_ws| ws.eq_ignore_build_data(&existing_ws))\n-                    .is_some()\n-            })\n-            .collect::<Vec<_>>();\n-        let same_workspaces = different_workspaces.is_empty();\n-\n-        tracing::debug!(current_workspaces = ?self.workspaces, new_workspaces = ?workspaces, ?same_workspaces, \"comparing workspaces\");\n+        let same_workspaces = workspaces.len() == self.workspaces.len()\n+            && workspaces\n+                .iter()\n+                .zip(self.workspaces.iter())\n+                .all(|(l, r)| l.eq_ignore_build_data(r));\n \n         if same_workspaces {\n             let (workspaces, build_scripts) = self.fetch_build_data_queue.last_op_result();\n@@ -384,7 +370,7 @@ impl GlobalState {\n         let files_config = self.config.files();\n         let project_folders = ProjectFolders::new(&self.workspaces, &files_config.exclude);\n \n-        if self.proc_macro_clients.is_empty() || !different_workspaces.is_empty() {\n+        if self.proc_macro_clients.is_empty() || !same_workspaces {\n             if let Some((path, path_manually_set)) = self.config.proc_macro_srv() {\n                 tracing::info!(\"Spawning proc-macro servers\");\n                 self.proc_macro_clients = self\n@@ -462,31 +448,8 @@ impl GlobalState {\n         };\n         let mut change = Change::new();\n \n-        // `self.fetch_proc_macros_queue.request_op(cause, proc_macro_paths)` is only called in\n-        // when `switch_workspaces` is called _without_ changing workspaces. This typically occurs\n-        // when build scripts have finishing building, but when rust-analyzer is used with a\n-        // rust-project.json, the build scripts have already been built by the external build system\n-        // that generated the `rust-project.json`.\n-\n-        // Therefore, in order to allow _new_ workspaces added via rust-project.json (e.g., after\n-        // a workspace was already added), we check whether this is the same workspace _or_\n-        // if any of the new workspaces is a `rust-project.json`.\n-        //\n-        // The else branch is used to provide better diagnostics to users while procedural macros\n-        // are still being built.\n-        if same_workspaces || different_workspaces.iter().any(|ws| ws.is_json()) {\n-            if self.config.expand_proc_macros() {\n-                self.fetch_proc_macros_queue.request_op(cause, proc_macro_paths);\n-            }\n-        } else {\n-            // Set up errors for proc-macros upfront that we haven't run build scripts yet\n-            let mut proc_macros = FxHashMap::default();\n-            for paths in proc_macro_paths {\n-                proc_macros.extend(paths.into_iter().map(move |(crate_id, _)| {\n-                    (crate_id, Err(\"crate has not yet been build\".to_owned()))\n-                }));\n-            }\n-            change.set_proc_macros(proc_macros);\n+        if self.config.expand_proc_macros() {\n+            self.fetch_proc_macros_queue.request_op(cause, proc_macro_paths);\n         }\n         change.set_crate_graph(crate_graph);\n         self.analysis_host.apply_change(change);"}]}