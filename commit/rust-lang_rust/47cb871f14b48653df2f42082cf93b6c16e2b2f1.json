{"sha": "47cb871f14b48653df2f42082cf93b6c16e2b2f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3Y2I4NzFmMTRiNDg2NTNkZjJmNDIwODJjZjkzYjZjMTZlMmIyZjE=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-10-23T13:04:12Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-10-23T13:04:12Z"}, "message": "review", "tree": {"sha": "863456cce6bf26756881548468df5566cbb25952", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/863456cce6bf26756881548468df5566cbb25952"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47cb871f14b48653df2f42082cf93b6c16e2b2f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47cb871f14b48653df2f42082cf93b6c16e2b2f1", "html_url": "https://github.com/rust-lang/rust/commit/47cb871f14b48653df2f42082cf93b6c16e2b2f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47cb871f14b48653df2f42082cf93b6c16e2b2f1/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ad140ca197a1147e476f34908c2b69a60cc6d2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ad140ca197a1147e476f34908c2b69a60cc6d2f", "html_url": "https://github.com/rust-lang/rust/commit/6ad140ca197a1147e476f34908c2b69a60cc6d2f"}], "stats": {"total": 80, "additions": 45, "deletions": 35}, "files": [{"sha": "c79b2624f8cb0256d003fd53ae9e4ede270c1c34", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/47cb871f14b48653df2f42082cf93b6c16e2b2f1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb871f14b48653df2f42082cf93b6c16e2b2f1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=47cb871f14b48653df2f42082cf93b6c16e2b2f1", "patch": "@@ -223,6 +223,13 @@ impl AbstractConst<'tcx> {\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+struct WorkNode<'tcx> {\n+    node: Node<'tcx>,\n+    span: Span,\n+    used: bool,\n+}\n+\n struct AbstractConstBuilder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n@@ -232,7 +239,7 @@ struct AbstractConstBuilder<'a, 'tcx> {\n     /// so we store this here. Note that we also consider nodes as used\n     /// if they are mentioned in an assert, so some used nodes are never\n     /// actually reachable by walking the [`AbstractConst`].\n-    nodes: IndexVec<NodeId, (Node<'tcx>, bool)>,\n+    nodes: IndexVec<NodeId, WorkNode<'tcx>>,\n     locals: IndexVec<mir::Local, NodeId>,\n     /// We only allow field accesses if they access\n     /// the result of a checked operation.\n@@ -279,25 +286,25 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         Ok(Some(builder))\n     }\n \n-    fn add_node(&mut self, n: Node<'tcx>) -> NodeId {\n+    fn add_node(&mut self, node: Node<'tcx>, span: Span) -> NodeId {\n         // Mark used nodes.\n-        match n {\n+        match node {\n             Node::Leaf(_) => (),\n             Node::Binop(_, lhs, rhs) => {\n-                self.nodes[lhs].1 = true;\n-                self.nodes[rhs].1 = true;\n+                self.nodes[lhs].used = true;\n+                self.nodes[rhs].used = true;\n             }\n             Node::UnaryOp(_, input) => {\n-                self.nodes[input].1 = true;\n+                self.nodes[input].used = true;\n             }\n             Node::FunctionCall(func, nodes) => {\n-                self.nodes[func].1 = true;\n-                nodes.iter().for_each(|&n| self.nodes[n].1 = true);\n+                self.nodes[func].used = true;\n+                nodes.iter().for_each(|&n| self.nodes[n].used = true);\n             }\n         }\n \n         // Nodes start as unused.\n-        self.nodes.push((n, false))\n+        self.nodes.push(WorkNode { node, span, used: false })\n     }\n \n     fn place_to_local(\n@@ -337,7 +344,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 let local = self.place_to_local(span, p)?;\n                 Ok(self.locals[local])\n             }\n-            mir::Operand::Constant(ct) => Ok(self.add_node(Node::Leaf(ct.literal))),\n+            mir::Operand::Constant(ct) => Ok(self.add_node(Node::Leaf(ct.literal), span)),\n         }\n     }\n \n@@ -362,38 +369,38 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n \n     fn build_statement(&mut self, stmt: &mir::Statement<'tcx>) -> Result<(), ErrorReported> {\n         debug!(\"AbstractConstBuilder: stmt={:?}\", stmt);\n+        let span = stmt.source_info.span;\n         match stmt.kind {\n             StatementKind::Assign(box (ref place, ref rvalue)) => {\n-                let local = self.place_to_local(stmt.source_info.span, place)?;\n+                let local = self.place_to_local(span, place)?;\n                 match *rvalue {\n                     Rvalue::Use(ref operand) => {\n-                        self.locals[local] =\n-                            self.operand_to_node(stmt.source_info.span, operand)?;\n+                        self.locals[local] = self.operand_to_node(span, operand)?;\n                         Ok(())\n                     }\n                     Rvalue::BinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n-                        let lhs = self.operand_to_node(stmt.source_info.span, lhs)?;\n-                        let rhs = self.operand_to_node(stmt.source_info.span, rhs)?;\n-                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs));\n+                        let lhs = self.operand_to_node(span, lhs)?;\n+                        let rhs = self.operand_to_node(span, rhs)?;\n+                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs), span);\n                         if op.is_checkable() {\n                             bug!(\"unexpected unchecked checkable binary operation\");\n                         } else {\n                             Ok(())\n                         }\n                     }\n                     Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n-                        let lhs = self.operand_to_node(stmt.source_info.span, lhs)?;\n-                        let rhs = self.operand_to_node(stmt.source_info.span, rhs)?;\n-                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs));\n+                        let lhs = self.operand_to_node(span, lhs)?;\n+                        let rhs = self.operand_to_node(span, rhs)?;\n+                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs), span);\n                         self.checked_op_locals.insert(local);\n                         Ok(())\n                     }\n                     Rvalue::UnaryOp(op, ref operand) if Self::check_unop(op) => {\n-                        let operand = self.operand_to_node(stmt.source_info.span, operand)?;\n-                        self.locals[local] = self.add_node(Node::UnaryOp(op, operand));\n+                        let operand = self.operand_to_node(span, operand)?;\n+                        self.locals[local] = self.add_node(Node::UnaryOp(op, operand), span);\n                         Ok(())\n                     }\n-                    _ => self.error(Some(stmt.source_info.span), \"unsupported rvalue\")?,\n+                    _ => self.error(Some(span), \"unsupported rvalue\")?,\n                 }\n             }\n             // These are not actually relevant for us here, so we can ignore them.\n@@ -441,7 +448,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                         .map(|arg| self.operand_to_node(terminator.source_info.span, arg))\n                         .collect::<Result<Vec<NodeId>, _>>()?,\n                 );\n-                self.locals[local] = self.add_node(Node::FunctionCall(func, args));\n+                self.locals[local] = self.add_node(Node::FunctionCall(func, args), fn_span);\n                 Ok(Some(target))\n             }\n             TerminatorKind::Assert { ref cond, expected: false, target, .. } => {\n@@ -458,7 +465,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                     //\n                     // This is needed because division does not use `CheckedBinop` but instead\n                     // adds an explicit assert for `divisor != 0`.\n-                    self.nodes[self.locals[p]].1 = true;\n+                    self.nodes[self.locals[p]].used = true;\n                     return Ok(Some(target));\n                 } else if let &[mir::ProjectionElem::Field(ONE_FIELD, _)] = p.projection.as_ref() {\n                     // Only allow asserts checking the result of a checked operation.\n@@ -487,16 +494,13 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             if let Some(next) = self.build_terminator(block.terminator())? {\n                 block = &self.body.basic_blocks()[next];\n             } else {\n-                assert_eq!(self.locals[mir::Local::from_usize(0)], self.nodes.last().unwrap());\n-                self.nodes[self.locals[mir::Local::from_usize(0)]].1 = true;\n-                if !self.nodes.iter().all(|n| n.1) {\n-                    self.error(None, \"unused node\")?;\n+                assert_eq!(self.locals[mir::RETURN_PLACE], self.nodes.last().unwrap());\n+                self.nodes[self.locals[mir::RETURN_PLACE]].used = true;\n+                if let Some(&unused) = self.nodes.iter().find(|n| !n.used) {\n+                    self.error(Some(unused.span), \"dead code\")?;\n                 }\n \n-                return Ok(self\n-                    .tcx\n-                    .arena\n-                    .alloc_from_iter(self.nodes.into_iter().map(|(n, _used)| n)));\n+                return Ok(self.tcx.arena.alloc_from_iter(self.nodes.into_iter().map(|n| n.node)));\n             }\n         }\n     }"}, {"sha": "1687dbbcbe3f8c3fedef497409a5aec01dfb0586", "filename": "src/test/ui/const-generics/const_evaluatable_checked/unused_expr.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/47cb871f14b48653df2f42082cf93b6c16e2b2f1/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funused_expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/47cb871f14b48653df2f42082cf93b6c16e2b2f1/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funused_expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funused_expr.stderr?ref=47cb871f14b48653df2f42082cf93b6c16e2b2f1", "patch": "@@ -2,23 +2,29 @@ error: overly complex generic constant\n   --> $DIR/unused_expr.rs:4:34\n    |\n LL | fn add<const N: usize>() -> [u8; { N + 1; 5 }] {\n-   |                                  ^^^^^^^^^^^^ unused node\n+   |                                  ^^-----^^^^^\n+   |                                    |\n+   |                                    dead code\n    |\n    = help: consider moving this anonymous constant into a `const` function\n \n error: overly complex generic constant\n   --> $DIR/unused_expr.rs:9:34\n    |\n LL | fn div<const N: usize>() -> [u8; { N / 1; 5 }] {\n-   |                                  ^^^^^^^^^^^^ unused node\n+   |                                  ^^-----^^^^^\n+   |                                    |\n+   |                                    dead code\n    |\n    = help: consider moving this anonymous constant into a `const` function\n \n error: overly complex generic constant\n   --> $DIR/unused_expr.rs:16:38\n    |\n LL | fn fn_call<const N: usize>() -> [u8; { foo(N); 5 }] {\n-   |                                      ^^^^^^^^^^^^^ unused node\n+   |                                      ^^------^^^^^\n+   |                                        |\n+   |                                        dead code\n    |\n    = help: consider moving this anonymous constant into a `const` function\n "}]}