{"sha": "b9f1f77622c7a52b0eba39eb05c7841f5407f938", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5ZjFmNzc2MjJjN2E1MmIwZWJhMzllYjA1Yzc4NDFmNTQwN2Y5Mzg=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-08-12T23:36:17Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-08-15T16:26:51Z"}, "message": "Fixed memory accounting and task stack creation bugs.", "tree": {"sha": "685923e8a2fa4e2796a54280a878b540b0ab169e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/685923e8a2fa4e2796a54280a878b540b0ab169e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9f1f77622c7a52b0eba39eb05c7841f5407f938", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9f1f77622c7a52b0eba39eb05c7841f5407f938", "html_url": "https://github.com/rust-lang/rust/commit/b9f1f77622c7a52b0eba39eb05c7841f5407f938", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9f1f77622c7a52b0eba39eb05c7841f5407f938/comments", "author": null, "committer": null, "parents": [{"sha": "2f23405a6079745663b9a4462410aa509f281aa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f23405a6079745663b9a4462410aa509f281aa1", "html_url": "https://github.com/rust-lang/rust/commit/2f23405a6079745663b9a4462410aa509f281aa1"}], "stats": {"total": 116, "additions": 81, "deletions": 35}, "files": [{"sha": "a99598fa5739fa18869f512ad97879ee1d003242", "filename": "src/lib/task.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9f1f77622c7a52b0eba39eb05c7841f5407f938/src%2Flib%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9f1f77622c7a52b0eba39eb05c7841f5407f938/src%2Flib%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftask.rs?ref=b9f1f77622c7a52b0eba39eb05c7841f5407f938", "patch": "@@ -21,6 +21,8 @@ native \"rust\" mod rustrt {\n     fn start_task(id : task_id);\n     fn get_task_trampoline() -> u32;\n \n+    fn migrate_alloc(alloc : *u8, target : task_id);\n+\n     fn leak[@T](thing : -T);\n }\n \n@@ -104,6 +106,7 @@ fn _spawn(thunk : fn() -> ()) -> task_id {\n     *env = raw_thunk.env;\n     *ra = rustrt::get_task_trampoline();\n \n+    rustrt::migrate_alloc(cast(raw_thunk.env), id);\n     rustrt::start_task(id);\n \n     rustrt::leak(thunk);"}, {"sha": "7b38f65caafad3b22933e80452b0d2243f4cd130", "filename": "src/rt/memory_region.cpp", "status": "modified", "additions": 48, "deletions": 29, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/b9f1f77622c7a52b0eba39eb05c7841f5407f938/src%2Frt%2Fmemory_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b9f1f77622c7a52b0eba39eb05c7841f5407f938/src%2Frt%2Fmemory_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.cpp?ref=b9f1f77622c7a52b0eba39eb05c7841f5407f938", "patch": "@@ -4,7 +4,7 @@\n // NB: please do not commit code with this uncommented. It's\n // hugely expensive and should only be used as a last resort.\n //\n-#define TRACK_ALLOCATIONS\n+// #define TRACK_ALLOCATIONS\n \n #define MAGIC 0xbadc0ffe\n \n@@ -25,13 +25,13 @@ memory_region::memory_region(memory_region *parent) :\n }\n \n void memory_region::add_alloc() {\n-    _live_allocations++;\n-    //sync::increment(_live_allocations);\n+    //_live_allocations++;\n+    sync::increment(_live_allocations);\n }\n \n void memory_region::dec_alloc() {\n-    _live_allocations--;\n-    //sync::decrement(_live_allocations);\n+    //_live_allocations--;\n+    sync::decrement(_live_allocations);\n }\n \n void memory_region::free(void *mem) {\n@@ -40,21 +40,10 @@ void memory_region::free(void *mem) {\n     if (_synchronized) { _lock.lock(); }\n     alloc_header *alloc = get_header(mem);\n     assert(alloc->magic == MAGIC);\n-#ifdef TRACK_ALLOCATIONS\n-    if (_allocation_list[alloc->index] != alloc) {\n-        printf(\"free: ptr 0x%\" PRIxPTR \" (%s) is not in allocation_list\\n\",\n-               (uintptr_t) &alloc->data, alloc->tag);\n-        _srv->fatal(\"not in allocation_list\", __FILE__, __LINE__, \"\");\n-    }\n-    else {\n-        // printf(\"freed index %d\\n\", index);\n-        _allocation_list[alloc->index] = NULL;\n-    }\n-#endif\n     if (_live_allocations < 1) {\n         _srv->fatal(\"live_allocs < 1\", __FILE__, __LINE__, \"\");\n     }\n-    dec_alloc();\n+    release_alloc(mem);\n     _srv->free(alloc);\n     if (_synchronized) { _lock.unlock(); }\n }\n@@ -90,18 +79,13 @@ memory_region::realloc(void *mem, size_t size) {\n void *\n memory_region::malloc(size_t size, const char *tag, bool zero) {\n     if (_synchronized) { _lock.lock(); }\n-    add_alloc();\n     size_t old_size = size;\n     size += sizeof(alloc_header);\n     alloc_header *mem = (alloc_header *)_srv->malloc(size);\n     mem->magic = MAGIC;\n     mem->tag = tag;\n-#ifdef TRACK_ALLOCATIONS\n-    mem->index = _allocation_list.append(mem);\n-    // printf(\"malloc: stored %p at index %d\\n\", mem, index);\n-#endif\n-    // printf(\"malloc: ptr 0x%\" PRIxPTR \" region=%p\\n\",\n-    //        (uintptr_t) mem, this);\n+    mem->index = -1;\n+    claim_alloc(mem->data);\n \n     if(zero) {\n         memset(mem->data, 0, old_size);\n@@ -118,27 +102,32 @@ memory_region::calloc(size_t size, const char *tag) {\n \n memory_region::~memory_region() {\n     if (_synchronized) { _lock.lock(); }\n-    if (_live_allocations == 0) {\n+    if (_live_allocations == 0 && !_detailed_leaks) {\n         if (_synchronized) { _lock.unlock(); }\n         return;\n     }\n     char msg[128];\n-    snprintf(msg, sizeof(msg),\n-             \"leaked memory in rust main loop (%\" PRIuPTR \" objects)\",\n-             _live_allocations);\n+    if(_live_allocations > 0) {\n+        snprintf(msg, sizeof(msg),\n+                 \"leaked memory in rust main loop (%d objects)\",\n+                 _live_allocations);\n+    }\n #ifdef TRACK_ALLOCATIONS\n     if (_detailed_leaks) {\n+        unsigned int leak_count = 0;\n         for (size_t i = 0; i < _allocation_list.size(); i++) {\n             if (_allocation_list[i] != NULL) {\n                 alloc_header *header = (alloc_header*)_allocation_list[i];\n                 printf(\"allocation (%s) 0x%\" PRIxPTR \" was not freed\\n\",\n                        header->tag,\n                        (uintptr_t) &header->data);\n+                ++leak_count;\n             }\n         }\n+        assert(leak_count == _live_allocations);\n     }\n #endif\n-    if (!_hack_allow_leaks) {\n+    if (!_hack_allow_leaks && _live_allocations > 0) {\n         _srv->fatal(msg, __FILE__, __LINE__,\n                     \"%d objects\", _live_allocations);\n     }\n@@ -150,6 +139,36 @@ memory_region::hack_allow_leaks() {\n     _hack_allow_leaks = true;\n }\n \n+void\n+memory_region::release_alloc(void *mem) {\n+    alloc_header *alloc = get_header(mem);\n+    assert(alloc->magic == MAGIC);\n+\n+#ifdef TRACK_ALLOCATIONS\n+    if (_allocation_list[alloc->index] != alloc) {\n+        printf(\"free: ptr 0x%\" PRIxPTR \" (%s) is not in allocation_list\\n\",\n+               (uintptr_t) &alloc->data, alloc->tag);\n+        _srv->fatal(\"not in allocation_list\", __FILE__, __LINE__, \"\");\n+    }\n+    else {\n+        // printf(\"freed index %d\\n\", index);\n+        _allocation_list[alloc->index] = NULL;\n+        alloc->index = -1;\n+    }\n+#endif\n+    dec_alloc();\n+}\n+\n+void\n+memory_region::claim_alloc(void *mem) {\n+    alloc_header *alloc = get_header(mem);\n+    assert(alloc->magic == MAGIC);\n+#ifdef TRACK_ALLOCATIONS\n+    alloc->index = _allocation_list.append(alloc);\n+#endif\n+    add_alloc();\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "26a21f45028953a5e982c06e699227c0ba64947c", "filename": "src/rt/memory_region.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b9f1f77622c7a52b0eba39eb05c7841f5407f938/src%2Frt%2Fmemory_region.h", "raw_url": "https://github.com/rust-lang/rust/raw/b9f1f77622c7a52b0eba39eb05c7841f5407f938/src%2Frt%2Fmemory_region.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.h?ref=b9f1f77622c7a52b0eba39eb05c7841f5407f938", "patch": "@@ -27,7 +27,7 @@ class memory_region {\n \n     rust_srv *_srv;\n     memory_region *_parent;\n-    size_t _live_allocations;\n+    int _live_allocations;\n     array_list<alloc_header *> _allocation_list;\n     const bool _detailed_leaks;\n     const bool _synchronized;\n@@ -48,6 +48,9 @@ class memory_region {\n     // to not kill the entire process, which the test runner needs. Please\n     // kill with prejudice once unwinding works.\n     void hack_allow_leaks();\n+\n+    void release_alloc(void *mem);\n+    void claim_alloc(void *mem);\n };\n \n inline void *operator new(size_t size, memory_region &region,"}, {"sha": "77a4e8d2b09044edd2e676285072b45ac38d2234", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b9f1f77622c7a52b0eba39eb05c7841f5407f938/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b9f1f77622c7a52b0eba39eb05c7841f5407f938/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=b9f1f77622c7a52b0eba39eb05c7841f5407f938", "patch": "@@ -289,7 +289,7 @@ task_yield(rust_task *task) {\n extern \"C\" CDECL intptr_t\n task_join(rust_task *task, rust_task_id tid) {\n     // If the other task is already dying, we don't have to wait for it.\n-    smart_ptr<rust_task> join_task = task->kernel->get_task_by_id(tid);\n+    rust_task *join_task = task->kernel->get_task_by_id(tid);\n     // FIXME: find task exit status and return that.\n     if(!join_task) return 0;\n     join_task->lock.lock();\n@@ -720,10 +720,11 @@ new_task(rust_task *task) {\n \n extern \"C\" CDECL registers_t *\n get_task_context(rust_task *task, rust_task_id id) {\n-    registers_t *regs = &task->kernel->get_task_by_id(id)->ctx.regs;\n+    rust_task *target = task->kernel->get_task_by_id(id);\n+    registers_t *regs = &target->ctx.regs;\n     // This next line is a little dangerous.. It means we can only safely call\n     // this when starting a task.\n-    regs->esp = task->rust_sp;\n+    regs->esp = target->rust_sp;\n     return regs;\n }\n \n@@ -746,6 +747,20 @@ get_task_trampoline(rust_task *task) {\n     return &task_trampoline;\n }\n \n+extern \"C\" CDECL void\n+migrate_alloc(rust_task *task, void *alloc, rust_task_id tid) {\n+    if(!alloc) return;\n+    rust_task *target = task->kernel->get_task_by_id(tid);\n+    if(target) {\n+        task->local_region.release_alloc(alloc);\n+        target->local_region.claim_alloc(alloc);\n+    }\n+    else {\n+        // We couldn't find the target. Maybe we should just free?\n+        task->fail();\n+    }\n+}\n+\n extern \"C\" CDECL rust_chan *\n clone_chan(rust_task *task, rust_chan *chan) {\n     return chan->clone(task);"}, {"sha": "1a28e6fb947ba7691856cfa4a911dbc87d3b8e28", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b9f1f77622c7a52b0eba39eb05c7841f5407f938/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b9f1f77622c7a52b0eba39eb05c7841f5407f938/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=b9f1f77622c7a52b0eba39eb05c7841f5407f938", "patch": "@@ -108,8 +108,13 @@ struct spawn_args {\n };\n \n extern \"C\" CDECL\n-void task_exit(void *env, int rval, rust_task *task) {\n+void task_exit(intptr_t *env, int rval, rust_task *task) {\n     LOG(task, task, \"task exited with value %d\", rval);\n+    if(env) {\n+        // free the environment.\n+        I(task->sched, 1 == *env); // the ref count better be 1\n+        task->free(env);\n+    }\n     task->die();\n     task->lock.lock();\n     task->notify_tasks_waiting_to_join();"}, {"sha": "db31ef68067157743d4061ae6b77c4c95d67b812", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b9f1f77622c7a52b0eba39eb05c7841f5407f938/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/b9f1f77622c7a52b0eba39eb05c7841f5407f938/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=b9f1f77622c7a52b0eba39eb05c7841f5407f938", "patch": "@@ -41,6 +41,7 @@ ivec_reserve_shared\n ivec_to_ptr\n last_os_error\n leak\n+migrate_alloc\n nano_time\n new_chan\n new_port"}, {"sha": "1c48b6308fac38ae9061c7b5a54db47b12c22032", "filename": "src/test/stdtest/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9f1f77622c7a52b0eba39eb05c7841f5407f938/src%2Ftest%2Fstdtest%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9f1f77622c7a52b0eba39eb05c7841f5407f938/src%2Ftest%2Fstdtest%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftask.rs?ref=b9f1f77622c7a52b0eba39eb05c7841f5407f938", "patch": "@@ -43,4 +43,4 @@ fn test_lib_spawn() {\n fn test_lib_spawn2() {\n     fn foo(x : int) { assert(x == 42); }\n     task::_spawn(bind foo(42));\n-}\n\\ No newline at end of file\n+}"}]}