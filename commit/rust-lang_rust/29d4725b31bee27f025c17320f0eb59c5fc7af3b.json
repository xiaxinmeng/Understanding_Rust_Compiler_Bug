{"sha": "29d4725b31bee27f025c17320f0eb59c5fc7af3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5ZDQ3MjViMzFiZWUyN2YwMjVjMTczMjBmMGViNTljNWZjN2FmM2I=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-21T15:15:18Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-31T12:55:13Z"}, "message": "async-llvm(2): Decouple diagnostics emission from LLVM worker coordination.", "tree": {"sha": "7b6b94b74eef7fc16ad72a5df73f011414304ad9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b6b94b74eef7fc16ad72a5df73f011414304ad9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29d4725b31bee27f025c17320f0eb59c5fc7af3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29d4725b31bee27f025c17320f0eb59c5fc7af3b", "html_url": "https://github.com/rust-lang/rust/commit/29d4725b31bee27f025c17320f0eb59c5fc7af3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29d4725b31bee27f025c17320f0eb59c5fc7af3b/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4adeceb37e4bdf9be3b70ff2454b121531466ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4adeceb37e4bdf9be3b70ff2454b121531466ce", "html_url": "https://github.com/rust-lang/rust/commit/c4adeceb37e4bdf9be3b70ff2454b121531466ce"}], "stats": {"total": 392, "additions": 238, "deletions": 154}, "files": [{"sha": "28d255d420455902c33fbd26f77904419456737a", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 211, "deletions": 139, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/29d4725b31bee27f025c17320f0eb59c5fc7af3b/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d4725b31bee27f025c17320f0eb59c5fc7af3b/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=29d4725b31bee27f025c17320f0eb59c5fc7af3b", "patch": "@@ -23,7 +23,7 @@ use rustc::hir::def_id::CrateNum;\n use rustc::util::common::{time, time_depth, set_time_depth, path2cstr};\n use rustc::util::fs::link_or_copy;\n use errors::{self, Handler, Level, DiagnosticBuilder, FatalError};\n-use errors::emitter::Emitter;\n+use errors::emitter::{Emitter};\n use syntax::ext::hygiene::Mark;\n use syntax_pos::MultiSpan;\n use context::{is_pie_binary, get_reloc_model};\n@@ -38,7 +38,7 @@ use std::io;\n use std::io::Write;\n use std::path::{Path, PathBuf};\n use std::str;\n-use std::sync::mpsc::{channel, Sender};\n+use std::sync::mpsc::{channel, Sender, Receiver};\n use std::slice;\n use libc::{c_uint, c_void, c_char, size_t};\n \n@@ -304,6 +304,9 @@ pub struct CodegenContext<'a> {\n     pub incr_comp_session_dir: Option<PathBuf>,\n     // Channel back to the main control thread to send messages to\n     pub tx: Sender<Message>,\n+\n+    // Error messages...\n+    pub shared_emitter: SharedEmitter,\n }\n \n struct HandlerFreeVars<'a> {\n@@ -313,7 +316,7 @@ struct HandlerFreeVars<'a> {\n unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext<'a>,\n                                                msg: &'b str,\n                                                cookie: c_uint) {\n-    drop(cgcx.tx.send(Message::InlineAsmError(cookie as u32, msg.to_string())));\n+    cgcx.shared_emitter.inline_asm_error(cookie as u32, msg.to_string());\n }\n \n unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n@@ -613,8 +616,17 @@ pub fn cleanup_llvm(trans: &CrateTranslation) {\n     }\n }\n \n+pub struct RunLLVMPassesResult {\n+    pub modules: Vec<ModuleTranslation>,\n+    pub metadata_module: ModuleTranslation,\n+    pub allocator_module: Option<ModuleTranslation>,\n+}\n+\n pub fn run_passes(sess: &Session,\n                   trans: &OngoingCrateTranslation,\n+                  modules: Vec<ModuleTranslation>,\n+                  metadata_module: ModuleTranslation,\n+                  allocator_module: Option<ModuleTranslation>,\n                   output_types: &OutputTypes,\n                   crate_output: &OutputFilenames) {\n     // It's possible that we have `codegen_units > 1` but only one item in\n@@ -631,7 +643,7 @@ pub fn run_passes(sess: &Session,\n     }\n \n     // Sanity check\n-    assert!(trans.modules.len() == sess.opts.cg.codegen_units ||\n+    assert!(modules.len() == sess.opts.cg.codegen_units ||\n             sess.opts.debugging_opts.incremental.is_some() ||\n             !sess.opts.output_types.should_trans() ||\n             sess.opts.debugging_opts.no_trans);\n@@ -722,25 +734,25 @@ pub fn run_passes(sess: &Session,\n     // Populate a buffer with a list of codegen threads.  Items are processed in\n     // LIFO order, just because it's a tiny bit simpler that way.  (The order\n     // doesn't actually matter.)\n-    let mut work_items = Vec::with_capacity(1 + trans.modules.len());\n+    let mut work_items = Vec::with_capacity(1 + modules.len());\n \n     {\n         let work = build_work_item(sess,\n-                                   trans.metadata_module.clone(),\n+                                   metadata_module.clone(),\n                                    metadata_config.clone(),\n                                    crate_output.clone());\n         work_items.push(work);\n     }\n \n-    if let Some(allocator) = trans.allocator_module.clone() {\n+    if let Some(allocator) = allocator_module.clone() {\n         let work = build_work_item(sess,\n                                    allocator,\n                                    allocator_config.clone(),\n                                    crate_output.clone());\n         work_items.push(work);\n     }\n \n-    for mtrans in trans.modules.iter() {\n+    for mtrans in modules.iter() {\n         let work = build_work_item(sess,\n                                    mtrans.clone(),\n                                    modules_config.clone(),\n@@ -760,7 +772,7 @@ pub fn run_passes(sess: &Session,\n     });\n \n     // If in incr. comp. mode, preserve the `.o` files for potential re-use\n-    for mtrans in trans.modules.iter() {\n+    for mtrans in modules.iter() {\n         let mut files = vec![];\n \n         if modules_config.emit_obj {\n@@ -781,80 +793,82 @@ pub fn run_passes(sess: &Session,\n         llvm::LLVMRustDisposeTargetMachine(tm);\n     }\n \n-    // Produce final compile outputs.\n-    let copy_gracefully = |from: &Path, to: &Path| {\n-        if let Err(e) = fs::copy(from, to) {\n-            sess.err(&format!(\"could not copy {:?} to {:?}: {}\", from, to, e));\n-        }\n-    };\n-\n-    let copy_if_one_unit = |output_type: OutputType,\n-                            keep_numbered: bool| {\n-        if trans.modules.len() == 1 {\n-            // 1) Only one codegen unit.  In this case it's no difficulty\n-            //    to copy `foo.0.x` to `foo.x`.\n-            let module_name = Some(&trans.modules[0].name[..]);\n-            let path = crate_output.temp_path(output_type, module_name);\n-            copy_gracefully(&path,\n-                            &crate_output.path(output_type));\n-            if !sess.opts.cg.save_temps && !keep_numbered {\n-                // The user just wants `foo.x`, not `foo.#module-name#.x`.\n-                remove(sess, &path);\n-            }\n-        } else {\n-            let ext = crate_output.temp_path(output_type, None)\n-                                  .extension()\n-                                  .unwrap()\n-                                  .to_str()\n-                                  .unwrap()\n-                                  .to_owned();\n-\n-            if crate_output.outputs.contains_key(&output_type) {\n-                // 2) Multiple codegen units, with `--emit foo=some_name`.  We have\n-                //    no good solution for this case, so warn the user.\n-                sess.warn(&format!(\"ignoring emit path because multiple .{} files \\\n-                                    were produced\", ext));\n-            } else if crate_output.single_output_file.is_some() {\n-                // 3) Multiple codegen units, with `-o some_name`.  We have\n-                //    no good solution for this case, so warn the user.\n-                sess.warn(&format!(\"ignoring -o because multiple .{} files \\\n-                                    were produced\", ext));\n-            } else {\n-                // 4) Multiple codegen units, but no explicit name.  We\n-                //    just leave the `foo.0.x` files in place.\n-                // (We don't have to do any work in this case.)\n-            }\n-        }\n-    };\n-\n-    // Flag to indicate whether the user explicitly requested bitcode.\n-    // Otherwise, we produced it only as a temporary output, and will need\n-    // to get rid of it.\n     let mut user_wants_bitcode = false;\n     let mut user_wants_objects = false;\n-    for output_type in output_types.keys() {\n-        match *output_type {\n-            OutputType::Bitcode => {\n-                user_wants_bitcode = true;\n-                // Copy to .bc, but always keep the .0.bc.  There is a later\n-                // check to figure out if we should delete .0.bc files, or keep\n-                // them for making an rlib.\n-                copy_if_one_unit(OutputType::Bitcode, true);\n-            }\n-            OutputType::LlvmAssembly => {\n-                copy_if_one_unit(OutputType::LlvmAssembly, false);\n+    {\n+        // Produce final compile outputs.\n+        let copy_gracefully = |from: &Path, to: &Path| {\n+            if let Err(e) = fs::copy(from, to) {\n+                sess.err(&format!(\"could not copy {:?} to {:?}: {}\", from, to, e));\n             }\n-            OutputType::Assembly => {\n-                copy_if_one_unit(OutputType::Assembly, false);\n+        };\n+\n+        let copy_if_one_unit = |output_type: OutputType,\n+                                keep_numbered: bool| {\n+            if modules.len() == 1 {\n+                // 1) Only one codegen unit.  In this case it's no difficulty\n+                //    to copy `foo.0.x` to `foo.x`.\n+                let module_name = Some(&modules[0].name[..]);\n+                let path = crate_output.temp_path(output_type, module_name);\n+                copy_gracefully(&path,\n+                                &crate_output.path(output_type));\n+                if !sess.opts.cg.save_temps && !keep_numbered {\n+                    // The user just wants `foo.x`, not `foo.#module-name#.x`.\n+                    remove(sess, &path);\n+                }\n+            } else {\n+                let ext = crate_output.temp_path(output_type, None)\n+                                      .extension()\n+                                      .unwrap()\n+                                      .to_str()\n+                                      .unwrap()\n+                                      .to_owned();\n+\n+                if crate_output.outputs.contains_key(&output_type) {\n+                    // 2) Multiple codegen units, with `--emit foo=some_name`.  We have\n+                    //    no good solution for this case, so warn the user.\n+                    sess.warn(&format!(\"ignoring emit path because multiple .{} files \\\n+                                        were produced\", ext));\n+                } else if crate_output.single_output_file.is_some() {\n+                    // 3) Multiple codegen units, with `-o some_name`.  We have\n+                    //    no good solution for this case, so warn the user.\n+                    sess.warn(&format!(\"ignoring -o because multiple .{} files \\\n+                                        were produced\", ext));\n+                } else {\n+                    // 4) Multiple codegen units, but no explicit name.  We\n+                    //    just leave the `foo.0.x` files in place.\n+                    // (We don't have to do any work in this case.)\n+                }\n             }\n-            OutputType::Object => {\n-                user_wants_objects = true;\n-                copy_if_one_unit(OutputType::Object, true);\n+        };\n+\n+        // Flag to indicate whether the user explicitly requested bitcode.\n+        // Otherwise, we produced it only as a temporary output, and will need\n+        // to get rid of it.\n+        for output_type in output_types.keys() {\n+            match *output_type {\n+                OutputType::Bitcode => {\n+                    user_wants_bitcode = true;\n+                    // Copy to .bc, but always keep the .0.bc.  There is a later\n+                    // check to figure out if we should delete .0.bc files, or keep\n+                    // them for making an rlib.\n+                    copy_if_one_unit(OutputType::Bitcode, true);\n+                }\n+                OutputType::LlvmAssembly => {\n+                    copy_if_one_unit(OutputType::LlvmAssembly, false);\n+                }\n+                OutputType::Assembly => {\n+                    copy_if_one_unit(OutputType::Assembly, false);\n+                }\n+                OutputType::Object => {\n+                    user_wants_objects = true;\n+                    copy_if_one_unit(OutputType::Object, true);\n+                }\n+                OutputType::Mir |\n+                OutputType::Metadata |\n+                OutputType::Exe |\n+                OutputType::DepInfo => {}\n             }\n-            OutputType::Mir |\n-            OutputType::Metadata |\n-            OutputType::Exe |\n-            OutputType::DepInfo => {}\n         }\n     }\n     let user_wants_bitcode = user_wants_bitcode;\n@@ -895,7 +909,7 @@ pub fn run_passes(sess: &Session,\n         let keep_numbered_objects = needs_crate_object ||\n                 (user_wants_objects && sess.opts.cg.codegen_units > 1);\n \n-        for module_name in trans.modules.iter().map(|m| Some(&m.name[..])) {\n+        for module_name in modules.iter().map(|m| Some(&m.name[..])) {\n             if modules_config.emit_obj && !keep_numbered_objects {\n                 let path = crate_output.temp_path(OutputType::Object, module_name);\n                 remove(sess, &path);\n@@ -909,11 +923,11 @@ pub fn run_passes(sess: &Session,\n \n         if metadata_config.emit_bc && !user_wants_bitcode {\n             let path = crate_output.temp_path(OutputType::Bitcode,\n-                                              Some(&trans.metadata_module.name));\n+                                              Some(&metadata_module.name));\n             remove(sess, &path);\n         }\n         if allocator_config.emit_bc && !user_wants_bitcode {\n-            if let Some(ref module) = trans.allocator_module {\n+            if let Some(ref module) = allocator_module {\n                 let path = crate_output.temp_path(OutputType::Bitcode,\n                                                   Some(&module.name));\n                 remove(sess, &path);\n@@ -932,6 +946,14 @@ pub fn run_passes(sess: &Session,\n     if sess.opts.cg.codegen_units == 1 && sess.time_llvm_passes() {\n         unsafe { llvm::LLVMRustPrintPassTimings(); }\n     }\n+\n+    *trans.result.borrow_mut() = Some(\n+        RunLLVMPassesResult {\n+            modules,\n+            metadata_module,\n+            allocator_module,\n+        }\n+    );\n }\n \n pub fn dump_incremental_data(trans: &CrateTranslation) {\n@@ -1011,10 +1033,7 @@ fn execute_work_item(cgcx: &CodegenContext, work_item: WorkItem)\n \n pub enum Message {\n     Token(io::Result<Acquired>),\n-    Diagnostic(Diagnostic),\n     Done { success: bool },\n-    InlineAsmError(u32, String),\n-    AbortIfErrors,\n }\n \n pub struct Diagnostic {\n@@ -1048,6 +1067,8 @@ fn execute_work<'a>(sess: &'a Session,\n         helper.request_token();\n     }\n \n+    let (shared_emitter, shared_emitter_main) = SharedEmitter::new();\n+\n     // This is the \"main loop\" of parallel work happening for parallel codegen.\n     // It's here that we manage parallelism, schedule work, and work with\n     // messages coming from clients.\n@@ -1112,7 +1133,13 @@ fn execute_work<'a>(sess: &'a Session,\n         while work_items.len() > 0 && running < tokens.len() + 1 {\n             let item = work_items.pop().unwrap();\n             let index = work_items.len();\n-            spawn_work(sess, exported_symbols, scope, tx.clone(), item, index);\n+            spawn_work(sess,\n+                       exported_symbols,\n+                       scope,\n+                       tx.clone(),\n+                       shared_emitter.clone(),\n+                       item,\n+                       index);\n             running += 1;\n         }\n \n@@ -1140,70 +1167,22 @@ fn execute_work<'a>(sess: &'a Session,\n                 running -= 1;\n             }\n             Message::Done { success: false } => {\n-                sess.fatal(\"aborting due to worker thread panic\");\n-            }\n-\n-            // Our worker wants us to emit an error message, so get ahold of our\n-            // `sess` and print it out\n-            Message::Diagnostic(diag) => {\n-                let handler = sess.diagnostic();\n-                match diag.code {\n-                    Some(ref code) => {\n-                        handler.emit_with_code(&MultiSpan::new(),\n-                                               &diag.msg,\n-                                               &code,\n-                                               diag.lvl);\n-                    }\n-                    None => {\n-                        handler.emit(&MultiSpan::new(),\n-                                     &diag.msg,\n-                                     diag.lvl);\n-                    }\n-                }\n-            }\n-            Message::InlineAsmError(cookie, msg) => {\n-                match Mark::from_u32(cookie).expn_info() {\n-                    Some(ei) => sess.span_err(ei.call_site, &msg),\n-                    None     => sess.err(&msg),\n-                }\n+                shared_emitter.fatal(\"aborting due to worker thread panic\".to_string());\n             }\n-\n-            // Sent to us after a worker sends us a batch of error messages, and\n-            // it's the point at which we check for errors.\n-            Message::AbortIfErrors => sess.diagnostic().abort_if_errors(),\n         }\n+\n+        shared_emitter_main.check(sess);\n     }\n \n     // Just in case, check this on the way out.\n     sess.diagnostic().abort_if_errors();\n }\n \n-struct SharedEmitter {\n-    tx: Sender<Message>,\n-}\n-\n-impl Emitter for SharedEmitter {\n-    fn emit(&mut self, db: &DiagnosticBuilder) {\n-        drop(self.tx.send(Message::Diagnostic(Diagnostic {\n-            msg: db.message(),\n-            code: db.code.clone(),\n-            lvl: db.level,\n-        })));\n-        for child in &db.children {\n-            drop(self.tx.send(Message::Diagnostic(Diagnostic {\n-                msg: child.message(),\n-                code: None,\n-                lvl: child.level,\n-            })));\n-        }\n-        drop(self.tx.send(Message::AbortIfErrors));\n-    }\n-}\n-\n fn spawn_work<'a>(sess: &'a Session,\n                   exported_symbols: &'a ExportedSymbols,\n                   scope: &Scope<'a>,\n                   tx: Sender<Message>,\n+                  emitter: SharedEmitter,\n                   work: WorkItem,\n                   idx: usize) {\n     let plugin_passes = sess.plugin_llvm_passes.borrow().clone();\n@@ -1244,8 +1223,8 @@ fn spawn_work<'a>(sess: &'a Session,\n \n         // Set up our non-`Send` `CodegenContext` now that we're in a helper\n         // thread and have all our info available to us.\n-        let emitter = SharedEmitter { tx: tx.clone() };\n-        let diag_handler = Handler::with_emitter(true, false, Box::new(emitter));\n+        // let emitter = SharedEmitter { tx: tx.clone() };\n+        let diag_handler = Handler::with_emitter(true, false, Box::new(emitter.clone()));\n \n         let cgcx = CodegenContext {\n             crate_types: crate_types,\n@@ -1261,6 +1240,7 @@ fn spawn_work<'a>(sess: &'a Session,\n             worker: idx,\n             incr_comp_session_dir: incr_comp_session_dir,\n             tx: tx.clone(),\n+            shared_emitter: emitter,\n         };\n \n         // Execute the work itself, and if it finishes successfully then flag\n@@ -1371,3 +1351,95 @@ pub unsafe fn with_llvm_pmb(llmod: ModuleRef,\n     f(builder);\n     llvm::LLVMPassManagerBuilderDispose(builder);\n }\n+\n+\n+enum SharedEmitterMessage {\n+    Diagnostic(Diagnostic),\n+    InlineAsmError(u32, String),\n+    AbortIfErrors,\n+    Fatal(String),\n+}\n+\n+#[derive(Clone)]\n+pub struct SharedEmitter {\n+    sender: Sender<SharedEmitterMessage>,\n+}\n+\n+pub struct SharedEmitterMain {\n+    receiver: Receiver<SharedEmitterMessage>,\n+}\n+\n+impl SharedEmitter {\n+    pub fn new() -> (SharedEmitter, SharedEmitterMain) {\n+        let (sender, receiver) = channel();\n+\n+        (SharedEmitter { sender }, SharedEmitterMain { receiver })\n+    }\n+\n+    fn inline_asm_error(&self, cookie: u32, msg: String) {\n+        drop(self.sender.send(SharedEmitterMessage::InlineAsmError(cookie, msg)));\n+    }\n+\n+    fn fatal(&self, msg: String) {\n+        drop(self.sender.send(SharedEmitterMessage::Fatal(msg)));\n+    }\n+}\n+\n+impl Emitter for SharedEmitter {\n+    fn emit(&mut self, db: &DiagnosticBuilder) {\n+        drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n+            msg: db.message(),\n+            code: db.code.clone(),\n+            lvl: db.level,\n+        })));\n+        for child in &db.children {\n+            drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n+                msg: child.message(),\n+                code: None,\n+                lvl: child.level,\n+            })));\n+        }\n+        drop(self.sender.send(SharedEmitterMessage::AbortIfErrors));\n+    }\n+}\n+\n+impl SharedEmitterMain {\n+    pub fn check(&self, sess: &Session) {\n+        loop {\n+            match self.receiver.try_recv() {\n+                Ok(SharedEmitterMessage::Diagnostic(diag)) => {\n+                    let handler = sess.diagnostic();\n+                    match diag.code {\n+                        Some(ref code) => {\n+                            handler.emit_with_code(&MultiSpan::new(),\n+                                                   &diag.msg,\n+                                                   &code,\n+                                                   diag.lvl);\n+                        }\n+                        None => {\n+                            handler.emit(&MultiSpan::new(),\n+                                         &diag.msg,\n+                                         diag.lvl);\n+                        }\n+                    }\n+                }\n+                Ok(SharedEmitterMessage::InlineAsmError(cookie, msg)) => {\n+                    match Mark::from_u32(cookie).expn_info() {\n+                        Some(ei) => sess.span_err(ei.call_site, &msg),\n+                        None     => sess.err(&msg),\n+                    }\n+                }\n+                Ok(SharedEmitterMessage::AbortIfErrors) => {\n+                    sess.abort_if_errors();\n+                }\n+                Ok(SharedEmitterMessage::Fatal(msg)) => {\n+                    sess.fatal(&msg);\n+                }\n+                Err(_) => {\n+                    break;\n+                }\n+            }\n+\n+        }\n+    }\n+}"}, {"sha": "5582079c78f1346f326f90fbe219f4e4d50c5fe2", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/29d4725b31bee27f025c17320f0eb59c5fc7af3b/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d4725b31bee27f025c17320f0eb59c5fc7af3b/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=29d4725b31bee27f025c17320f0eb59c5fc7af3b", "patch": "@@ -963,16 +963,18 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let linker_info = LinkerInfo::new(&shared_ccx, &empty_exported_symbols);\n         return OngoingCrateTranslation {\n             crate_name: tcx.crate_name(LOCAL_CRATE),\n-            modules: vec![],\n-            metadata_module: metadata_module,\n-            allocator_module: None,\n             link: link_meta,\n             metadata: metadata,\n             exported_symbols: Arc::new(empty_exported_symbols),\n             no_builtins: no_builtins,\n             linker_info: linker_info,\n             windows_subsystem: None,\n             no_integrated_as: false,\n+            result: ::std::cell::RefCell::new(Some(::back::write::RunLLVMPassesResult {\n+                modules: vec![],\n+                metadata_module: metadata_module,\n+                allocator_module: None,\n+            })),\n         };\n     }\n \n@@ -1228,9 +1230,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         windows_subsystem,\n         no_integrated_as,\n \n-        modules,\n-        metadata_module,\n-        allocator_module,\n+        result: ::std::cell::RefCell::new(None),\n     };\n \n     time(sess.time_passes(),\n@@ -1249,11 +1249,23 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let output_types = OutputTypes::new(&[(OutputType::Assembly, None)]);\n         time(sess.time_passes(),\n              \"LLVM passes\",\n-             || ::back::write::run_passes(sess, &crate_translation, &output_types, outputs))\n+             || ::back::write::run_passes(sess,\n+                                          &crate_translation,\n+                                          modules,\n+                                          metadata_module,\n+                                          allocator_module,\n+                                          &output_types,\n+                                          outputs))\n     } else {\n         time(sess.time_passes(),\n              \"LLVM passes\",\n-             || ::back::write::run_passes(sess, &crate_translation, &sess.opts.output_types, outputs))\n+             || ::back::write::run_passes(sess,\n+                                          &crate_translation,\n+                                          modules,\n+                                          metadata_module,\n+                                          allocator_module,\n+                                          &sess.opts.output_types,\n+                                          outputs))\n     };\n \n     crate_translation"}, {"sha": "e7debe3919b4fc88db12b01b65ebf399195fef00", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/29d4725b31bee27f025c17320f0eb59c5fc7af3b/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d4725b31bee27f025c17320f0eb59c5fc7af3b/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=29d4725b31bee27f025c17320f0eb59c5fc7af3b", "patch": "@@ -188,10 +188,8 @@ pub struct OngoingCrateTranslation {\n     pub linker_info: back::linker::LinkerInfo,\n     pub no_integrated_as: bool,\n \n-    // These will be replaced by a Future.\n-    pub modules: Vec<ModuleTranslation>,\n-    pub metadata_module: ModuleTranslation,\n-    pub allocator_module: Option<ModuleTranslation>,\n+    // This will be replaced by a Future.\n+    pub result: ::std::cell::RefCell<Option<back::write::RunLLVMPassesResult>>,\n }\n \n impl OngoingCrateTranslation {\n@@ -200,6 +198,8 @@ impl OngoingCrateTranslation {\n                 outputs: &OutputFilenames)\n                 -> CrateTranslation {\n \n+        let result = self.result.borrow_mut().take().unwrap();\n+\n         let trans = CrateTranslation {\n             crate_name: self.crate_name,\n             link: self.link,\n@@ -209,9 +209,9 @@ impl OngoingCrateTranslation {\n             windows_subsystem: self.windows_subsystem,\n             linker_info: self.linker_info,\n \n-            modules: self.modules,\n-            metadata_module: self.metadata_module,\n-            allocator_module: self.allocator_module,\n+            modules: result.modules,\n+            metadata_module: result.metadata_module,\n+            allocator_module: result.allocator_module,\n         };\n \n         if self.no_integrated_as {"}]}