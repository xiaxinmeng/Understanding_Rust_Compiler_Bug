{"sha": "4bcf8c8c68bd791f295aa06ef7903c006be3f356", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiY2Y4YzhjNjhiZDc5MWYyOTVhYTA2ZWY3OTAzYzAwNmJlM2YzNTY=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-09T15:32:42Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-10T10:38:58Z"}, "message": "Add an FST index to `ImportMap`", "tree": {"sha": "4bb9425b04484fcdedcc32f03728e60a438c0fbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bb9425b04484fcdedcc32f03728e60a438c0fbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bcf8c8c68bd791f295aa06ef7903c006be3f356", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bcf8c8c68bd791f295aa06ef7903c006be3f356", "html_url": "https://github.com/rust-lang/rust/commit/4bcf8c8c68bd791f295aa06ef7903c006be3f356", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bcf8c8c68bd791f295aa06ef7903c006be3f356/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54936e8aa212ea5fdf737d8e1b0a02c231ed89eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/54936e8aa212ea5fdf737d8e1b0a02c231ed89eb", "html_url": "https://github.com/rust-lang/rust/commit/54936e8aa212ea5fdf737d8e1b0a02c231ed89eb"}], "stats": {"total": 264, "additions": 261, "deletions": 3}, "files": [{"sha": "4c55519681eb45336f5344c9e7dd4e2c96e0ec28", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcf8c8c68bd791f295aa06ef7903c006be3f356/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4bcf8c8c68bd791f295aa06ef7903c006be3f356/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=4bcf8c8c68bd791f295aa06ef7903c006be3f356", "patch": "@@ -981,7 +981,9 @@ dependencies = [\n  \"anymap\",\n  \"drop_bomb\",\n  \"either\",\n+ \"fst\",\n  \"insta\",\n+ \"itertools\",\n  \"log\",\n  \"once_cell\",\n  \"ra_arena\","}, {"sha": "bd69abfc752e9ec07aa8333e42cfa85a9daba310", "filename": "crates/ra_hir_def/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcf8c8c68bd791f295aa06ef7903c006be3f356/crates%2Fra_hir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4bcf8c8c68bd791f295aa06ef7903c006be3f356/crates%2Fra_hir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2FCargo.toml?ref=4bcf8c8c68bd791f295aa06ef7903c006be3f356", "patch": "@@ -14,6 +14,8 @@ rustc-hash = \"1.1.0\"\n either = \"1.5.3\"\n anymap = \"0.12.1\"\n drop_bomb = \"0.1.4\"\n+fst = { version = \"0.4\", default-features = false }\n+itertools = \"0.9.0\"\n \n stdx = { path = \"../stdx\" }\n "}, {"sha": "e9b2fe26ed274276135f95b774bb781f06302d8a", "filename": "crates/ra_hir_def/src/import_map.rs", "status": "modified", "additions": 250, "deletions": 3, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/4bcf8c8c68bd791f295aa06ef7903c006be3f356/crates%2Fra_hir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcf8c8c68bd791f295aa06ef7903c006be3f356/crates%2Fra_hir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fimport_map.rs?ref=4bcf8c8c68bd791f295aa06ef7903c006be3f356", "patch": "@@ -1,7 +1,10 @@\n //! A map of all publicly exported items in a crate.\n \n+use std::cmp::Ordering;\n use std::{collections::hash_map::Entry, fmt, sync::Arc};\n \n+use fst::{self, Streamer};\n+use itertools::Itertools;\n use ra_db::CrateId;\n use rustc_hash::FxHashMap;\n \n@@ -21,9 +24,17 @@ use crate::{\n ///\n /// Note that all paths are relative to the containing crate's root, so the crate name still needs\n /// to be prepended to the `ModPath` before the path is valid.\n-#[derive(Eq, PartialEq)]\n pub struct ImportMap {\n     map: FxHashMap<ItemInNs, ModPath>,\n+\n+    /// List of keys stored in `map`, sorted lexicographically by their `ModPath`. Indexed by the\n+    /// values returned by running `fst`.\n+    ///\n+    /// Since a path can refer to multiple items due to namespacing, we store all items with the\n+    /// same path right after each other. This allows us to find all items after the FST gives us\n+    /// the index of the first one.\n+    importables: Vec<ItemInNs>,\n+    fst: fst::Map<Vec<u8>>,\n }\n \n impl ImportMap {\n@@ -88,7 +99,34 @@ impl ImportMap {\n             }\n         }\n \n-        Arc::new(Self { map: import_map })\n+        let mut importables = import_map.iter().collect::<Vec<_>>();\n+\n+        importables.sort_by(cmp);\n+\n+        // Build the FST, taking care not to insert duplicate values.\n+\n+        let mut builder = fst::MapBuilder::memory();\n+        let mut last_batch_start = 0;\n+\n+        for idx in 0..importables.len() {\n+            if let Some(next_item) = importables.get(idx + 1) {\n+                if cmp(&importables[last_batch_start], next_item) == Ordering::Equal {\n+                    continue;\n+                }\n+            }\n+\n+            let start = last_batch_start;\n+            last_batch_start = idx + 1;\n+\n+            let key: String = fst_path(&importables[start].1).collect();\n+\n+            builder.insert(key, start as u64).unwrap();\n+        }\n+\n+        let fst = fst::Map::new(builder.into_inner().unwrap()).unwrap();\n+        let importables = importables.iter().map(|(item, _)| **item).collect();\n+\n+        Arc::new(Self { map: import_map, fst, importables })\n     }\n \n     /// Returns the `ModPath` needed to import/mention `item`, relative to this crate's root.\n@@ -97,6 +135,14 @@ impl ImportMap {\n     }\n }\n \n+impl PartialEq for ImportMap {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.importables == other.importables\n+    }\n+}\n+\n+impl Eq for ImportMap {}\n+\n impl fmt::Debug for ImportMap {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut importable_paths: Vec<_> = self\n@@ -117,13 +163,97 @@ impl fmt::Debug for ImportMap {\n     }\n }\n \n+fn fst_path(path: &ModPath) -> impl Iterator<Item = char> + '_ {\n+    path.segments\n+        .iter()\n+        .map(|name| name.as_text().unwrap())\n+        .intersperse(\"::\")\n+        .flat_map(|s| s.chars().map(|c| c.to_ascii_lowercase()))\n+}\n+\n+fn cmp((_, lhs): &(&ItemInNs, &ModPath), (_, rhs): &(&ItemInNs, &ModPath)) -> Ordering {\n+    let lhs_chars = fst_path(lhs);\n+    let rhs_chars = fst_path(rhs);\n+    lhs_chars.cmp(rhs_chars)\n+}\n+\n+#[derive(Debug)]\n+pub struct Query {\n+    query: String,\n+    anchor_end: bool,\n+}\n+\n+impl Query {\n+    pub fn new(query: impl AsRef<str>) -> Self {\n+        Self { query: query.as_ref().to_lowercase(), anchor_end: false }\n+    }\n+\n+    /// Only returns items whose paths end with the (case-insensitive) query string as their last\n+    /// segment.\n+    pub fn anchor_end(self) -> Self {\n+        Self { anchor_end: true, ..self }\n+    }\n+}\n+\n+/// Searches dependencies of `krate` for an importable path matching `query`.\n+///\n+/// This returns all items that could be imported from within `krate`, excluding paths inside\n+/// `krate` itself.\n+pub fn search_dependencies<'a>(\n+    db: &'a dyn DefDatabase,\n+    krate: CrateId,\n+    query: Query,\n+) -> Vec<ItemInNs> {\n+    let _p = ra_prof::profile(\"import_map::global_search\").detail(|| format!(\"{:?}\", query));\n+\n+    let graph = db.crate_graph();\n+    let import_maps: Vec<_> =\n+        graph[krate].dependencies.iter().map(|dep| db.import_map(dep.crate_id)).collect();\n+\n+    let automaton = fst::automaton::Subsequence::new(&query.query);\n+\n+    let mut op = fst::map::OpBuilder::new();\n+    for map in &import_maps {\n+        op = op.add(map.fst.search(&automaton));\n+    }\n+\n+    let mut stream = op.union();\n+    let mut res = Vec::new();\n+    while let Some((_, indexed_values)) = stream.next() {\n+        for indexed_value in indexed_values {\n+            let import_map = &import_maps[indexed_value.index];\n+            let importables = &import_map.importables[indexed_value.value as usize..];\n+\n+            // Path shared by the importable items in this group.\n+            let path = &import_map.map[&importables[0]];\n+\n+            if query.anchor_end {\n+                // Last segment must match query.\n+                let last = path.segments.last().unwrap().to_string();\n+                if last.to_lowercase() != query.query {\n+                    continue;\n+                }\n+            }\n+\n+            // Add the items from this `ModPath` group. Those are all subsequent items in\n+            // `importables` whose paths match `path`.\n+            res.extend(importables.iter().copied().take_while(|item| {\n+                let item_path = &import_map.map[item];\n+                fst_path(item_path).eq(fst_path(path))\n+            }));\n+        }\n+    }\n+\n+    res\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n     use crate::test_db::TestDB;\n     use insta::assert_snapshot;\n     use ra_db::fixture::WithFixture;\n-    use ra_db::SourceDatabase;\n+    use ra_db::{SourceDatabase, Upcast};\n \n     fn import_map(ra_fixture: &str) -> String {\n         let db = TestDB::with_files(ra_fixture);\n@@ -144,6 +274,40 @@ mod tests {\n         import_maps.join(\"\\n\")\n     }\n \n+    fn search_dependencies_of(ra_fixture: &str, krate_name: &str, query: Query) -> String {\n+        let db = TestDB::with_files(ra_fixture);\n+        let crate_graph = db.crate_graph();\n+        let krate = crate_graph\n+            .iter()\n+            .find(|krate| {\n+                crate_graph[*krate].display_name.as_ref().map(|n| n.to_string())\n+                    == Some(krate_name.to_string())\n+            })\n+            .unwrap();\n+\n+        search_dependencies(db.upcast(), krate, query)\n+            .into_iter()\n+            .filter_map(|item| {\n+                let mark = match item {\n+                    ItemInNs::Types(_) => \"t\",\n+                    ItemInNs::Values(_) => \"v\",\n+                    ItemInNs::Macros(_) => \"m\",\n+                };\n+                item.krate(db.upcast()).map(|krate| {\n+                    let map = db.import_map(krate);\n+                    let path = map.path_of(item).unwrap();\n+                    format!(\n+                        \"{}::{} ({})\",\n+                        crate_graph[krate].display_name.as_ref().unwrap(),\n+                        path,\n+                        mark\n+                    )\n+                })\n+            })\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\")\n+    }\n+\n     #[test]\n     fn smoke() {\n         let map = import_map(\n@@ -328,4 +492,87 @@ mod tests {\n         lib:\n         \"###);\n     }\n+\n+    #[test]\n+    fn namespacing() {\n+        let map = import_map(\n+            r\"\n+            //- /lib.rs crate:lib\n+            pub struct Thing;     // t + v\n+            #[macro_export]\n+            macro_rules! Thing {  // m\n+                () => {};\n+            }\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        lib:\n+        - Thing (m)\n+        - Thing (t)\n+        - Thing (v)\n+        \"###);\n+\n+        let map = import_map(\n+            r\"\n+            //- /lib.rs crate:lib\n+            pub mod Thing {}      // t\n+            #[macro_export]\n+            macro_rules! Thing {  // m\n+                () => {};\n+            }\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        lib:\n+        - Thing (m)\n+        - Thing (t)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn search() {\n+        let ra_fixture = r#\"\n+            //- /main.rs crate:main deps:dep\n+            //- /dep.rs crate:dep deps:tdep\n+            use tdep::fmt as fmt_dep;\n+            pub mod fmt {\n+                pub trait Display {\n+                    fn fmt();\n+                }\n+            }\n+            #[macro_export]\n+            macro_rules! Fmt {\n+                () => {};\n+            }\n+            pub struct Fmt;\n+\n+            pub fn format() {}\n+            pub fn no() {}\n+\n+            //- /tdep.rs crate:tdep\n+            pub mod fmt {\n+                pub struct NotImportableFromMain;\n+            }\n+        \"#;\n+\n+        let res = search_dependencies_of(ra_fixture, \"main\", Query::new(\"fmt\"));\n+        assert_snapshot!(res, @r###\"\n+        dep::Fmt (v)\n+        dep::fmt (t)\n+        dep::Fmt (t)\n+        dep::Fmt (m)\n+        dep::fmt::Display (t)\n+        dep::format (v)\n+        \"###);\n+\n+        let res = search_dependencies_of(ra_fixture, \"main\", Query::new(\"fmt\").anchor_end());\n+        assert_snapshot!(res, @r###\"\n+        dep::Fmt (v)\n+        dep::fmt (t)\n+        dep::Fmt (t)\n+        dep::Fmt (m)\n+        \"###);\n+    }\n }"}, {"sha": "f306d96412b12757f4d1c0ce638263848cad43cb", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4bcf8c8c68bd791f295aa06ef7903c006be3f356/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcf8c8c68bd791f295aa06ef7903c006be3f356/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=4bcf8c8c68bd791f295aa06ef7903c006be3f356", "patch": "@@ -67,6 +67,13 @@ impl Name {\n             _ => None,\n         }\n     }\n+\n+    pub fn as_text(&self) -> Option<&str> {\n+        match &self.0 {\n+            Repr::Text(s) => Some(s.as_str()),\n+            _ => None,\n+        }\n+    }\n }\n \n pub trait AsName {"}]}