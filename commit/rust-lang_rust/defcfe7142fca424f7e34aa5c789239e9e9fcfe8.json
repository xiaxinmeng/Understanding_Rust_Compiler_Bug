{"sha": "defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZmNmZTcxNDJmY2E0MjRmN2UzNGFhNWM3ODkyMzllOWU5ZmNmZTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-13T01:43:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-13T01:43:09Z"}, "message": "Auto merge of #49718 - petrochenkov:fieldcmp, r=eddyb\n\nHygiene 2.0: Avoid comparing fields by name\n\nThere are two separate commits here (not counting tests):\n- The first one unifies named (`obj.name`) and numeric (`obj.0`) field access expressions in AST and HIR. Before field references in these expressions are resolved it doesn't matter whether the field is named or numeric (it's just a symbol) and 99% of code is common. After field references are resolved we work with\nthem by index for all fields (see the second commit), so it's again not important whether the field was named or numeric (this includes MIR where all fields were already by index).\n(This refactoring actually fixed some bugs in HIR-based borrow checker where borrows through names (`S {\n0: ref x }`) and indices (`&s.0`) weren't considered overlapping.)\n- The second commit removes all by-name field comparison and instead resolves field references to their indices  once, and then uses those resolutions. (There are still a few name comparisons in save-analysis, because save-analysis is weird, but they are made correctly hygienic).\nThus we are fixing a bunch of \"secondary\" field hygiene bugs (in borrow checker, lints).\n\nFixes https://github.com/rust-lang/rust/issues/46314", "tree": {"sha": "8b6e479ea80191563607ff243cd46699c53ce56e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b6e479ea80191563607ff243cd46699c53ce56e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "html_url": "https://github.com/rust-lang/rust/commit/defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "html_url": "https://github.com/rust-lang/rust/commit/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a"}, {"sha": "fcf48520a0d63828190217ea59849f9098177427", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcf48520a0d63828190217ea59849f9098177427", "html_url": "https://github.com/rust-lang/rust/commit/fcf48520a0d63828190217ea59849f9098177427"}], "stats": {"total": 1435, "additions": 759, "deletions": 676}, "files": [{"sha": "118125a19ddef673865af95fe944f6039a2b28d3", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -389,7 +389,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             hir::ExprType(ref e, _) |\n             hir::ExprUnary(_, ref e) |\n             hir::ExprField(ref e, _) |\n-            hir::ExprTupField(ref e, _) |\n             hir::ExprYield(ref e) |\n             hir::ExprRepeat(ref e, _) => {\n                 self.straightline(expr, pred, Some(&**e).into_iter())"}, {"sha": "be9f8b8dac5c05bbced574cf89dacc6d2191eba8", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -658,6 +658,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n         PatKind::Struct(ref qpath, ref fields, _) => {\n             visitor.visit_qpath(qpath, pattern.id, pattern.span);\n             for field in fields {\n+                visitor.visit_id(field.node.id);\n                 visitor.visit_name(field.span, field.node.name);\n                 visitor.visit_pat(&field.node.pat)\n             }\n@@ -959,6 +960,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprStruct(ref qpath, ref fields, ref optional_base) => {\n             visitor.visit_qpath(qpath, expression.id, expression.span);\n             for field in fields {\n+                visitor.visit_id(field.id);\n                 visitor.visit_name(field.name.span, field.name.node);\n                 visitor.visit_expr(&field.expr)\n             }\n@@ -1025,9 +1027,6 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(subexpression);\n             visitor.visit_name(name.span, name.node);\n         }\n-        ExprTupField(ref subexpression, _) => {\n-            visitor.visit_expr(subexpression);\n-        }\n         ExprIndex(ref main_expression, ref index_expression) => {\n             visitor.visit_expr(main_expression);\n             visitor.visit_expr(index_expression)"}, {"sha": "fee076acb207eadde431c66a51b1095eb65f9385", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -2100,6 +2100,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_field(&mut self, f: &Field) -> hir::Field {\n         hir::Field {\n+            id: self.next_id().node_id,\n             name: respan(f.ident.span, self.lower_ident(f.ident)),\n             expr: P(self.lower_expr(&f.expr)),\n             span: f.span,\n@@ -2863,6 +2864,7 @@ impl<'a> LoweringContext<'a> {\n                     .map(|f| Spanned {\n                         span: f.span,\n                         node: hir::FieldPat {\n+                            id: self.next_id().node_id,\n                             name: self.lower_ident(f.node.ident),\n                             pat: self.lower_pat(&f.node.pat),\n                             is_shorthand: f.node.is_shorthand,\n@@ -3095,7 +3097,6 @@ impl<'a> LoweringContext<'a> {\n                 P(self.lower_expr(el)),\n                 respan(ident.span, self.lower_ident(ident)),\n             ),\n-            ExprKind::TupField(ref el, ident) => hir::ExprTupField(P(self.lower_expr(el)), ident),\n             ExprKind::Index(ref el, ref er) => {\n                 hir::ExprIndex(P(self.lower_expr(el)), P(self.lower_expr(er)))\n             }\n@@ -3742,6 +3743,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn field(&mut self, name: Name, expr: P<hir::Expr>, span: Span) -> hir::Field {\n         hir::Field {\n+            id: self.next_id().node_id,\n             name: Spanned { node: name, span },\n             span,\n             expr,"}, {"sha": "e6080fad91d597f60410ffd2e989951490c1b835", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -827,6 +827,7 @@ impl Pat {\n /// except is_shorthand is true\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct FieldPat {\n+    pub id: NodeId,\n     /// The identifier for the field\n     pub name: Name,\n     /// The pattern the field is destructured to\n@@ -1172,6 +1173,7 @@ pub struct Arm {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Field {\n+    pub id: NodeId,\n     pub name: Spanned<Name>,\n     pub expr: P<Expr>,\n     pub span: Span,\n@@ -1276,7 +1278,6 @@ impl Expr {\n             ExprAssign(..) => ExprPrecedence::Assign,\n             ExprAssignOp(..) => ExprPrecedence::AssignOp,\n             ExprField(..) => ExprPrecedence::Field,\n-            ExprTupField(..) => ExprPrecedence::TupField,\n             ExprIndex(..) => ExprPrecedence::Index,\n             ExprPath(..) => ExprPrecedence::Path,\n             ExprAddrOf(..) => ExprPrecedence::AddrOf,\n@@ -1363,12 +1364,8 @@ pub enum Expr_ {\n     ///\n     /// For example, `a += 1`.\n     ExprAssignOp(BinOp, P<Expr>, P<Expr>),\n-    /// Access of a named struct field (`obj.foo`)\n+    /// Access of a named (`obj.foo`) or unnamed (`obj.0`) struct or tuple field\n     ExprField(P<Expr>, Spanned<Name>),\n-    /// Access of an unnamed field of a struct or tuple-struct\n-    ///\n-    /// For example, `foo.0`.\n-    ExprTupField(P<Expr>, Spanned<usize>),\n     /// An indexing operation (`foo[2]`)\n     ExprIndex(P<Expr>, P<Expr>),\n "}, {"sha": "d3f2458ef87c7d2667d35946379b7aacfce9ec34", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -1201,8 +1201,7 @@ impl<'a> State<'a> {\n     fn print_expr_call(&mut self, func: &hir::Expr, args: &[hir::Expr]) -> io::Result<()> {\n         let prec =\n             match func.node {\n-                hir::ExprField(..) |\n-                hir::ExprTupField(..) => parser::PREC_FORCE_PAREN,\n+                hir::ExprField(..) => parser::PREC_FORCE_PAREN,\n                 _ => parser::PREC_POSTFIX,\n             };\n \n@@ -1405,11 +1404,6 @@ impl<'a> State<'a> {\n                 self.s.word(\".\")?;\n                 self.print_name(name.node)?;\n             }\n-            hir::ExprTupField(ref expr, id) => {\n-                self.print_expr_maybe_paren(&expr, parser::PREC_POSTFIX)?;\n-                self.s.word(\".\")?;\n-                self.print_usize(id.node)?;\n-            }\n             hir::ExprIndex(ref expr, ref index) => {\n                 self.print_expr_maybe_paren(&expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\"[\")?;\n@@ -2376,7 +2370,6 @@ fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n         hir::ExprCast(ref x, _) |\n         hir::ExprType(ref x, _) |\n         hir::ExprField(ref x, _) |\n-        hir::ExprTupField(ref x, _) |\n         hir::ExprIndex(ref x, _) => {\n             // &X { y: 1 }, X { y: 1 }.y\n             contains_exterior_struct_lit(&x)"}, {"sha": "4a001802eacb48c889fa1546418056da900cdea4", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -420,11 +420,23 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Pat {\n }\n \n impl_stable_hash_for_spanned!(hir::FieldPat);\n-impl_stable_hash_for!(struct hir::FieldPat {\n-    name,\n-    pat,\n-    is_shorthand\n-});\n+\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::FieldPat {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::FieldPat {\n+            id: _,\n+            name,\n+            ref pat,\n+            is_shorthand,\n+        } = *self;\n+\n+        name.hash_stable(hcx, hasher);\n+        pat.hash_stable(hcx, hasher);\n+        is_shorthand.hash_stable(hcx, hasher);\n+    }\n+}\n \n impl_stable_hash_for!(enum hir::BindingAnnotation {\n     Unannotated,\n@@ -507,12 +519,24 @@ impl_stable_hash_for!(struct hir::Arm {\n     body\n });\n \n-impl_stable_hash_for!(struct hir::Field {\n-    name,\n-    expr,\n-    span,\n-    is_shorthand\n-});\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Field {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::Field {\n+            id: _,\n+            name,\n+            ref expr,\n+            span,\n+            is_shorthand,\n+        } = *self;\n+\n+        name.hash_stable(hcx, hasher);\n+        expr.hash_stable(hcx, hasher);\n+        span.hash_stable(hcx, hasher);\n+        is_shorthand.hash_stable(hcx, hasher);\n+    }\n+}\n \n impl_stable_hash_for_spanned!(ast::Name);\n \n@@ -569,7 +593,6 @@ impl_stable_hash_for!(enum hir::Expr_ {\n     ExprAssign(lhs, rhs),\n     ExprAssignOp(op, lhs, rhs),\n     ExprField(owner, field_name),\n-    ExprTupField(owner, idx),\n     ExprIndex(lhs, rhs),\n     ExprPath(path),\n     ExprAddrOf(mutability, sub),"}, {"sha": "9ec3d2e2460e944ba41900309cf4e92929e812ce", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 16, "deletions": 35, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -13,7 +13,7 @@\n // from live codes are live, and everything else is dead.\n \n use hir::map as hir_map;\n-use hir::{self, Item_, PatKind};\n+use hir::{self, PatKind};\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::itemlikevisit::ItemLikeVisitor;\n \n@@ -99,22 +99,14 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         self.check_def_id(self.tables.type_dependent_defs()[id].def_id());\n     }\n \n-    fn handle_field_access(&mut self, lhs: &hir::Expr, name: ast::Name) {\n+    fn handle_field_access(&mut self, lhs: &hir::Expr, node_id: ast::NodeId) {\n         match self.tables.expr_ty_adjusted(lhs).sty {\n             ty::TyAdt(def, _) => {\n-                self.insert_def_id(def.non_enum_variant().field_named(name).did);\n-            }\n-            _ => span_bug!(lhs.span, \"named field access on non-ADT\"),\n-        }\n-    }\n-\n-    fn handle_tup_field_access(&mut self, lhs: &hir::Expr, idx: usize) {\n-        match self.tables.expr_ty_adjusted(lhs).sty {\n-            ty::TyAdt(def, _) => {\n-                self.insert_def_id(def.non_enum_variant().fields[idx].did);\n+                let index = self.tcx.field_index(node_id, self.tables);\n+                self.insert_def_id(def.non_enum_variant().fields[index].did);\n             }\n             ty::TyTuple(..) => {}\n-            _ => span_bug!(lhs.span, \"numeric field access on non-ADT\"),\n+            _ => span_bug!(lhs.span, \"named field access on non-ADT\"),\n         }\n     }\n \n@@ -128,7 +120,8 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             if let PatKind::Wild = pat.node.pat.node {\n                 continue;\n             }\n-            self.insert_def_id(variant.field_named(pat.node.name).did);\n+            let index = self.tcx.field_index(pat.node.id, self.tables);\n+            self.insert_def_id(variant.fields[index].did);\n         }\n     }\n \n@@ -191,18 +184,11 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         self.inherited_pub_visibility = had_inherited_pub_visibility;\n     }\n \n-    fn mark_as_used_if_union(&mut self, did: DefId, fields: &hir::HirVec<hir::Field>) {\n-        if let Some(node_id) = self.tcx.hir.as_local_node_id(did) {\n-            if let Some(hir_map::NodeItem(item)) = self.tcx.hir.find(node_id) {\n-                if let Item_::ItemUnion(ref variant, _) = item.node {\n-                    if variant.fields().len() > 1 {\n-                        for field in variant.fields() {\n-                            if fields.iter().find(|x| x.name.node == field.name).is_some() {\n-                                self.live_symbols.insert(field.id);\n-                            }\n-                        }\n-                    }\n-                }\n+    fn mark_as_used_if_union(&mut self, adt: &ty::AdtDef, fields: &hir::HirVec<hir::Field>) {\n+        if adt.is_union() && adt.non_enum_variant().fields.len() > 1 && adt.did.is_local() {\n+            for field in fields {\n+                let index = self.tcx.field_index(field.id, self.tables);\n+                self.insert_def_id(adt.non_enum_variant().fields[index].did);\n             }\n         }\n     }\n@@ -242,17 +228,12 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n             hir::ExprMethodCall(..) => {\n                 self.lookup_and_handle_method(expr.hir_id);\n             }\n-            hir::ExprField(ref lhs, ref name) => {\n-                self.handle_field_access(&lhs, name.node);\n-            }\n-            hir::ExprTupField(ref lhs, idx) => {\n-                self.handle_tup_field_access(&lhs, idx.node);\n+            hir::ExprField(ref lhs, ..) => {\n+                self.handle_field_access(&lhs, expr.id);\n             }\n             hir::ExprStruct(_, ref fields, _) => {\n-                if let ty::TypeVariants::TyAdt(ref def, _) = self.tables.expr_ty(expr).sty {\n-                    if def.is_union() {\n-                        self.mark_as_used_if_union(def.did, fields);\n-                    }\n+                if let ty::TypeVariants::TyAdt(ref adt, _) = self.tables.expr_ty(expr).sty {\n+                    self.mark_as_used_if_union(adt, fields);\n                 }\n             }\n             _ => ()"}, {"sha": "2cc5a4a8fe639f33d9ed125cd19083064f6bee4d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -404,10 +404,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.select_from_expr(&base);\n             }\n \n-            hir::ExprTupField(ref base, _) => {         // base.<n>\n-                self.select_from_expr(&base);\n-            }\n-\n             hir::ExprIndex(ref lhs, ref rhs) => {       // lhs[rhs]\n                 self.select_from_expr(&lhs);\n                 self.consume_expr(&rhs);\n@@ -663,11 +659,15 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         match with_cmt.ty.sty {\n             ty::TyAdt(adt, substs) if adt.is_struct() => {\n                 // Consume those fields of the with expression that are needed.\n-                for with_field in &adt.non_enum_variant().fields {\n-                    if !contains_field_named(with_field, fields) {\n+                for (f_index, with_field) in adt.non_enum_variant().fields.iter().enumerate() {\n+                    let is_mentioned = fields.iter().any(|f| {\n+                        self.tcx().field_index(f.id, self.mc.tables) == f_index\n+                    });\n+                    if !is_mentioned {\n                         let cmt_field = self.mc.cat_field(\n                             &*with_expr,\n                             with_cmt.clone(),\n+                            f_index,\n                             with_field.name,\n                             with_field.ty(self.tcx(), substs)\n                         );\n@@ -691,14 +691,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // walk the with expression so that complex expressions\n         // are properly handled.\n         self.walk_expr(with_expr);\n-\n-        fn contains_field_named(field: &ty::FieldDef,\n-                                fields: &[hir::Field])\n-                                -> bool\n-        {\n-            fields.iter().any(\n-                |f| f.name.node == field.name)\n-        }\n     }\n \n     // Invoke the appropriate delegate calls for anything that gets"}, {"sha": "11dc2a8188505119ac6a3a4d9ca58ec7ffff00ce", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -476,7 +476,7 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n       }\n \n       // otherwise, live nodes are not required:\n-      hir::ExprIndex(..) | hir::ExprField(..) | hir::ExprTupField(..) |\n+      hir::ExprIndex(..) | hir::ExprField(..) |\n       hir::ExprArray(..) | hir::ExprCall(..) | hir::ExprMethodCall(..) |\n       hir::ExprTup(..) | hir::ExprBinary(..) | hir::ExprAddrOf(..) |\n       hir::ExprCast(..) | hir::ExprUnary(..) | hir::ExprBreak(..) |\n@@ -912,10 +912,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               self.propagate_through_expr(&e, succ)\n           }\n \n-          hir::ExprTupField(ref e, _) => {\n-              self.propagate_through_expr(&e, succ)\n-          }\n-\n           hir::ExprClosure(.., blk_id, _, _) => {\n               debug!(\"{} is an ExprClosure\", self.ir.tcx.hir.node_to_pretty_string(expr.id));\n \n@@ -1226,7 +1222,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         match expr.node {\n             hir::ExprPath(_) => succ,\n             hir::ExprField(ref e, _) => self.propagate_through_expr(&e, succ),\n-            hir::ExprTupField(ref e, _) => self.propagate_through_expr(&e, succ),\n             _ => self.propagate_through_expr(expr, succ)\n         }\n     }\n@@ -1419,7 +1414,7 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n       // no correctness conditions related to liveness\n       hir::ExprCall(..) | hir::ExprMethodCall(..) | hir::ExprIf(..) |\n       hir::ExprMatch(..) | hir::ExprWhile(..) | hir::ExprLoop(..) |\n-      hir::ExprIndex(..) | hir::ExprField(..) | hir::ExprTupField(..) |\n+      hir::ExprIndex(..) | hir::ExprField(..) |\n       hir::ExprArray(..) | hir::ExprTup(..) | hir::ExprBinary(..) |\n       hir::ExprCast(..) | hir::ExprUnary(..) | hir::ExprRet(..) |\n       hir::ExprBreak(..) | hir::ExprAgain(..) | hir::ExprLit(_) |"}, {"sha": "6f41f07dce8a779efe6e602ae1f70dc5260f99d3", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 35, "deletions": 52, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -62,7 +62,6 @@\n \n pub use self::PointerKind::*;\n pub use self::InteriorKind::*;\n-pub use self::FieldName::*;\n pub use self::MutabilityCategory::*;\n pub use self::AliasableReason::*;\n pub use self::Note::*;\n@@ -81,10 +80,11 @@ use ty::fold::TypeFoldable;\n use hir::{MutImmutable, MutMutable, PatKind};\n use hir::pat_util::EnumerateAndAdjustIterator;\n use hir;\n-use syntax::ast;\n+use syntax::ast::{self, Name};\n use syntax_pos::Span;\n \n use std::fmt;\n+use std::hash::{Hash, Hasher};\n use rustc_data_structures::sync::Lrc;\n use std::rc::Rc;\n use util::nodemap::ItemLocalSet;\n@@ -129,14 +129,25 @@ pub enum PointerKind<'tcx> {\n // base without a pointer dereference\", e.g. a field\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum InteriorKind {\n-    InteriorField(FieldName),\n+    InteriorField(FieldIndex),\n     InteriorElement(InteriorOffsetKind),\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub enum FieldName {\n-    NamedField(ast::Name),\n-    PositionalField(usize)\n+// Contains index of a field that is actually used for loan path comparisons and\n+// string representation of the field that should be used only for diagnostics.\n+#[derive(Clone, Copy, Eq)]\n+pub struct FieldIndex(pub usize, pub Name);\n+\n+impl PartialEq for FieldIndex {\n+    fn eq(&self, rhs: &Self) -> bool {\n+        self.0 == rhs.0\n+    }\n+}\n+\n+impl Hash for FieldIndex {\n+    fn hash<H: Hasher>(&self, h: &mut H) {\n+        self.0.hash(h)\n+    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n@@ -198,7 +209,7 @@ pub enum ImmutabilityBlame<'tcx> {\n }\n \n impl<'tcx> cmt_<'tcx> {\n-    fn resolve_field(&self, field_name: FieldName) -> Option<(&'tcx ty::AdtDef, &'tcx ty::FieldDef)>\n+    fn resolve_field(&self, field_index: usize) -> Option<(&'tcx ty::AdtDef, &'tcx ty::FieldDef)>\n     {\n         let adt_def = match self.ty.sty {\n             ty::TyAdt(def, _) => def,\n@@ -215,11 +226,7 @@ impl<'tcx> cmt_<'tcx> {\n                 &adt_def.variants[0]\n             }\n         };\n-        let field_def = match field_name {\n-            NamedField(name) => variant_def.field_named(name),\n-            PositionalField(idx) => &variant_def.fields[idx]\n-        };\n-        Some((adt_def, field_def))\n+        Some((adt_def, &variant_def.fields[field_index]))\n     }\n \n     pub fn immutability_blame(&self) -> Option<ImmutabilityBlame<'tcx>> {\n@@ -230,8 +237,8 @@ impl<'tcx> cmt_<'tcx> {\n                 match base_cmt.cat {\n                     Categorization::Local(node_id) =>\n                         Some(ImmutabilityBlame::LocalDeref(node_id)),\n-                    Categorization::Interior(ref base_cmt, InteriorField(field_name)) => {\n-                        base_cmt.resolve_field(field_name).map(|(adt_def, field_def)| {\n+                    Categorization::Interior(ref base_cmt, InteriorField(field_index)) => {\n+                        base_cmt.resolve_field(field_index.0).map(|(adt_def, field_def)| {\n                             ImmutabilityBlame::AdtFieldDeref(adt_def, field_def)\n                         })\n                     }\n@@ -646,12 +653,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                    expr.id,\n                    expr,\n                    base_cmt);\n-            Ok(self.cat_field(expr, base_cmt, f_name.node, expr_ty))\n-          }\n-\n-          hir::ExprTupField(ref base, idx) => {\n-            let base_cmt = self.cat_expr(&base)?;\n-            Ok(self.cat_tup_field(expr, base_cmt, idx.node, expr_ty))\n+            let f_index = self.tcx.field_index(expr.id, self.tables);\n+            Ok(self.cat_field(expr, base_cmt, f_index, f_name.node, expr_ty))\n           }\n \n           hir::ExprIndex(ref base, _) => {\n@@ -979,39 +982,22 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     pub fn cat_field<N:ast_node>(&self,\n                                  node: &N,\n                                  base_cmt: cmt<'tcx>,\n-                                 f_name: ast::Name,\n+                                 f_index: usize,\n+                                 f_name: Name,\n                                  f_ty: Ty<'tcx>)\n                                  -> cmt<'tcx> {\n         let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n-            cat: Categorization::Interior(base_cmt, InteriorField(NamedField(f_name))),\n+            cat: Categorization::Interior(base_cmt, InteriorField(FieldIndex(f_index, f_name))),\n             ty: f_ty,\n             note: NoteNone\n         });\n         debug!(\"cat_field ret {:?}\", ret);\n         ret\n     }\n \n-    pub fn cat_tup_field<N:ast_node>(&self,\n-                                     node: &N,\n-                                     base_cmt: cmt<'tcx>,\n-                                     f_idx: usize,\n-                                     f_ty: Ty<'tcx>)\n-                                     -> cmt<'tcx> {\n-        let ret = Rc::new(cmt_ {\n-            id: node.id(),\n-            span: node.span(),\n-            mutbl: base_cmt.mutbl.inherit(),\n-            cat: Categorization::Interior(base_cmt, InteriorField(PositionalField(f_idx))),\n-            ty: f_ty,\n-            note: NoteNone\n-        });\n-        debug!(\"cat_tup_field ret {:?}\", ret);\n-        ret\n-    }\n-\n     fn cat_overloaded_place(&self,\n                              expr: &hir::Expr,\n                              base: &hir::Expr,\n@@ -1292,8 +1278,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n             for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n                 let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n-                let subcmt = self.cat_imm_interior(pat, cmt.clone(), subpat_ty,\n-                                                   InteriorField(PositionalField(i)));\n+                let interior = InteriorField(FieldIndex(i, Name::intern(&i.to_string())));\n+                let subcmt = self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior);\n                 self.cat_pattern_(subcmt, &subpat, op)?;\n             }\n           }\n@@ -1315,7 +1301,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n             for fp in field_pats {\n                 let field_ty = self.pat_ty(&fp.node.pat)?; // see (*2)\n-                let cmt_field = self.cat_field(pat, cmt.clone(), fp.node.name, field_ty);\n+                let f_index = self.tcx.field_index(fp.node.id, self.tables);\n+                let cmt_field = self.cat_field(pat, cmt.clone(), f_index, fp.node.name, field_ty);\n                 self.cat_pattern_(cmt_field, &fp.node.pat, op)?;\n             }\n           }\n@@ -1332,8 +1319,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n                 let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n-                let subcmt = self.cat_imm_interior(pat, cmt.clone(), subpat_ty,\n-                                                   InteriorField(PositionalField(i)));\n+                let interior = InteriorField(FieldIndex(i, Name::intern(&i.to_string())));\n+                let subcmt = self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior);\n                 self.cat_pattern_(subcmt, &subpat, op)?;\n             }\n           }\n@@ -1516,12 +1503,9 @@ impl<'tcx> cmt_<'tcx> {\n                     }\n                 }\n             }\n-            Categorization::Interior(_, InteriorField(NamedField(_))) => {\n+            Categorization::Interior(_, InteriorField(..)) => {\n                 \"field\".to_string()\n             }\n-            Categorization::Interior(_, InteriorField(PositionalField(_))) => {\n-                \"anonymous field\".to_string()\n-            }\n             Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Index)) => {\n                 \"indexed content\".to_string()\n             }\n@@ -1554,8 +1538,7 @@ pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n impl fmt::Debug for InteriorKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            InteriorField(NamedField(fld)) => write!(f, \"{}\", fld),\n-            InteriorField(PositionalField(i)) => write!(f, \"#{}\", i),\n+            InteriorField(FieldIndex(_, info)) => write!(f, \"{}\", info),\n             InteriorElement(..) => write!(f, \"[]\"),\n         }\n     }"}, {"sha": "42483c83f4ba27f4b277133da09ba329bb7dd2ab", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -1307,7 +1307,6 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n                 hir::ExprAddrOf(_, ref subexpr) |\n                 hir::ExprUnary(hir::UnDeref, ref subexpr) |\n                 hir::ExprField(ref subexpr, _) |\n-                hir::ExprTupField(ref subexpr, _) |\n                 hir::ExprIndex(ref subexpr, _) => {\n                     expr = &subexpr;\n                 }"}, {"sha": "76ec8c21743e06653118aa839bf7a741d01eb455", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -346,6 +346,12 @@ pub struct TypeckTables<'tcx> {\n     /// method calls, including those of overloaded operators.\n     type_dependent_defs: ItemLocalMap<Def>,\n \n+    /// Resolved field indices for field accesses in expressions (`S { field }`, `obj.field`)\n+    /// or patterns (`S { field }`). The index is often useful by itself, but to learn more\n+    /// about the field you also need definition of the variant to which the field\n+    /// belongs, but it may not exist if it's a tuple field (`tuple.0`).\n+    field_indices: ItemLocalMap<usize>,\n+\n     /// Stores the canonicalized types provided by the user. See also `UserAssertTy` statement in\n     /// MIR.\n     user_provided_tys: ItemLocalMap<CanonicalTy<'tcx>>,\n@@ -426,6 +432,7 @@ impl<'tcx> TypeckTables<'tcx> {\n         TypeckTables {\n             local_id_root,\n             type_dependent_defs: ItemLocalMap(),\n+            field_indices: ItemLocalMap(),\n             user_provided_tys: ItemLocalMap(),\n             node_types: ItemLocalMap(),\n             node_substs: ItemLocalMap(),\n@@ -468,6 +475,20 @@ impl<'tcx> TypeckTables<'tcx> {\n         }\n     }\n \n+    pub fn field_indices(&self) -> LocalTableInContext<usize> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.field_indices\n+        }\n+    }\n+\n+    pub fn field_indices_mut(&mut self) -> LocalTableInContextMut<usize> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.field_indices\n+        }\n+    }\n+\n     pub fn user_provided_tys(&self) -> LocalTableInContext<CanonicalTy<'tcx>> {\n         LocalTableInContext {\n             local_id_root: self.local_id_root,\n@@ -706,6 +727,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n         let ty::TypeckTables {\n             local_id_root,\n             ref type_dependent_defs,\n+            ref field_indices,\n             ref user_provided_tys,\n             ref node_types,\n             ref node_substs,\n@@ -726,6 +748,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n             type_dependent_defs.hash_stable(hcx, hasher);\n+            field_indices.hash_stable(hcx, hasher);\n             user_provided_tys.hash_stable(hcx, hasher);\n             node_types.hash_stable(hcx, hasher);\n             node_substs.hash_stable(hcx, hasher);"}, {"sha": "6618f9bc2f5dd04cba73039ccdf7d67e9868f74b", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -50,7 +50,7 @@ use std::vec::IntoIter;\n use std::mem;\n use syntax::ast::{self, DUMMY_NODE_ID, Name, Ident, NodeId};\n use syntax::attr;\n-use syntax::ext::hygiene::{Mark, SyntaxContext};\n+use syntax::ext::hygiene::Mark;\n use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n \n@@ -2107,32 +2107,6 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> VariantDef {\n-    #[inline]\n-    pub fn find_field_named(&self, name: ast::Name) -> Option<&FieldDef> {\n-        self.index_of_field_named(name).map(|index| &self.fields[index])\n-    }\n-\n-    pub fn index_of_field_named(&self, name: ast::Name) -> Option<usize> {\n-        if let Some(index) = self.fields.iter().position(|f| f.name == name) {\n-            return Some(index);\n-        }\n-        let mut ident = name.to_ident();\n-        while ident.span.ctxt() != SyntaxContext::empty() {\n-            ident.span.remove_mark();\n-            if let Some(field) = self.fields.iter().position(|f| f.name.to_ident() == ident) {\n-                return Some(field);\n-            }\n-        }\n-        None\n-    }\n-\n-    #[inline]\n-    pub fn field_named(&self, name: ast::Name) -> &FieldDef {\n-        self.find_field_named(name).unwrap()\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> FieldDef {\n     pub fn ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, subst: &Substs<'tcx>) -> Ty<'tcx> {\n         tcx.type_of(self.did).subst(tcx, subst)\n@@ -2399,6 +2373,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn field_index(self, node_id: NodeId, tables: &TypeckTables) -> usize {\n+        let hir_id = self.hir.node_to_hir_id(node_id);\n+        tables.field_indices().get(hir_id).cloned().expect(\"no index for a field\")\n+    }\n+\n+    pub fn find_field_index(self, ident: Ident, variant: &VariantDef) -> Option<usize> {\n+        variant.fields.iter().position(|field| {\n+            self.adjust_ident(ident.modern(), variant.did, DUMMY_NODE_ID).0 == field.name.to_ident()\n+        })\n+    }\n+\n     pub fn associated_items(\n         self,\n         def_id: DefId,"}, {"sha": "77eff49d19ff615d505efc553416a8e391f803cc", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 37, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -33,7 +33,7 @@ use rustc_data_structures::fx::FxHashMap;\n use std::{cmp, fmt};\n use std::hash::Hash;\n use std::intrinsics;\n-use syntax::ast::{self, Name};\n+use syntax::ast;\n use syntax::attr::{self, SignedInt, UnsignedInt};\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -270,42 +270,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         false\n     }\n \n-    /// Returns the type of element at index `i` in tuple or tuple-like type `t`.\n-    /// For an enum `t`, `variant` is None only if `t` is a univariant enum.\n-    pub fn positional_element_ty(self,\n-                                 ty: Ty<'tcx>,\n-                                 i: usize,\n-                                 variant: Option<DefId>) -> Option<Ty<'tcx>> {\n-        match (&ty.sty, variant) {\n-            (&TyAdt(adt, substs), Some(vid)) => {\n-                adt.variant_with_id(vid).fields.get(i).map(|f| f.ty(self, substs))\n-            }\n-            (&TyAdt(adt, substs), None) => {\n-                // Don't use `non_enum_variant`, this may be a univariant enum.\n-                adt.variants[0].fields.get(i).map(|f| f.ty(self, substs))\n-            }\n-            (&TyTuple(ref v), None) => v.get(i).cloned(),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Returns the type of element at field `n` in struct or struct-like type `t`.\n-    /// For an enum `t`, `variant` must be some def id.\n-    pub fn named_element_ty(self,\n-                            ty: Ty<'tcx>,\n-                            n: Name,\n-                            variant: Option<DefId>) -> Option<Ty<'tcx>> {\n-        match (&ty.sty, variant) {\n-            (&TyAdt(adt, substs), Some(vid)) => {\n-                adt.variant_with_id(vid).find_field_named(n).map(|f| f.ty(self, substs))\n-            }\n-            (&TyAdt(adt, substs), None) => {\n-                adt.non_enum_variant().find_field_named(n).map(|f| f.ty(self, substs))\n-            }\n-            _ => return None\n-        }\n-    }\n-\n     /// Returns the deeply last field of nested structures, or the same type,\n     /// if not a structure at all. Corresponds to the only possible unsized\n     /// field, and its type can be used to determine unsizing strategy."}, {"sha": "e3adb51433b252a959c25ef1ec796f68e815bf66", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -107,8 +107,9 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                     ty::TyAdt(adt_def, _) if adt_def.is_union() => match result {\n                         RestrictionResult::Safe => RestrictionResult::Safe,\n                         RestrictionResult::SafeIf(base_lp, mut base_vec) => {\n-                            for field in &adt_def.non_enum_variant().fields {\n-                                let field = InteriorKind::InteriorField(mc::NamedField(field.name));\n+                            for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {\n+                                let field =\n+                                    InteriorKind::InteriorField(mc::FieldIndex(i, field.name));\n                                 let field_ty = if field == interior {\n                                     cmt.ty\n                                 } else {"}, {"sha": "6d832d4060a1fc7d46653a3587f5aec47e9a05b3", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -370,7 +370,7 @@ const DOWNCAST_PRINTED_OPERATOR: &'static str = \" as \";\n // is tracked is irrelevant here.)\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum InteriorKind {\n-    InteriorField(mc::FieldName),\n+    InteriorField(mc::FieldIndex),\n     InteriorElement,\n }\n \n@@ -1336,18 +1336,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push(')');\n             }\n \n-            LpExtend(ref lp_base, _, LpInterior(_, InteriorField(fname))) => {\n+            LpExtend(ref lp_base, _, LpInterior(_, InteriorField(mc::FieldIndex(_, info)))) => {\n                 self.append_autoderefd_loan_path_to_string(&lp_base, out);\n-                match fname {\n-                    mc::NamedField(fname) => {\n-                        out.push('.');\n-                        out.push_str(&fname.as_str());\n-                    }\n-                    mc::PositionalField(idx) => {\n-                        out.push('.');\n-                        out.push_str(&idx.to_string());\n-                    }\n-                }\n+                out.push('.');\n+                out.push_str(&info.as_str());\n             }\n \n             LpExtend(ref lp_base, _, LpInterior(_, InteriorElement)) => {\n@@ -1422,8 +1414,7 @@ impl DataFlowOperator for LoanDataFlowOperator {\n impl<'tcx> fmt::Debug for InteriorKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            InteriorField(mc::NamedField(fld)) => write!(f, \"{}\", fld),\n-            InteriorField(mc::PositionalField(i)) => write!(f, \"#{}\", i),\n+            InteriorField(mc::FieldIndex(_, info)) => write!(f, \"{}\", info),\n             InteriorElement => write!(f, \"[]\"),\n         }\n     }"}, {"sha": "1f4050a5b3624dd91654e261e91a6c608a392138", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -21,7 +21,6 @@ use rustc::middle::dataflow::DataFlowOperator;\n use rustc::middle::dataflow::KillFrom;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::expr_use_visitor::MutateMode;\n-use rustc::middle::mem_categorization as mc;\n use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n@@ -343,8 +342,8 @@ impl<'a, 'tcx> MoveData<'tcx> {\n             if let (&ty::TyAdt(adt_def, _), LpInterior(opt_variant_id, interior))\n                     = (&base_lp.ty.sty, lp_elem) {\n                 if adt_def.is_union() {\n-                    for field in &adt_def.non_enum_variant().fields {\n-                        let field = InteriorKind::InteriorField(mc::NamedField(field.name));\n+                    for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {\n+                        let field = InteriorKind::InteriorField(mc::FieldIndex(i, field.name));\n                         if field != interior {\n                             let sibling_lp_kind =\n                                 LpExtend(base_lp.clone(), mutbl, LpInterior(opt_variant_id, field));\n@@ -395,8 +394,8 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         if let LpExtend(ref base_lp, mutbl, LpInterior(opt_variant_id, interior)) = lp.kind {\n             if let ty::TyAdt(adt_def, _) = base_lp.ty.sty {\n                 if adt_def.is_union() {\n-                    for field in &adt_def.non_enum_variant().fields {\n-                        let field = InteriorKind::InteriorField(mc::NamedField(field.name));\n+                    for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {\n+                        let field = InteriorKind::InteriorField(mc::FieldIndex(i, field.name));\n                         let field_ty = if field == interior {\n                             lp.ty\n                         } else {"}, {"sha": "6f2c51b0f1899afaadaf2dcb99e6e43859819878", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -166,19 +166,24 @@ impl LintPass for NonShorthandFieldPatterns {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n     fn check_pat(&mut self, cx: &LateContext, pat: &hir::Pat) {\n-        if let PatKind::Struct(_, ref field_pats, _) = pat.node {\n+        if let PatKind::Struct(ref qpath, ref field_pats, _) = pat.node {\n+            let variant = cx.tables.pat_ty(pat).ty_adt_def()\n+                                   .expect(\"struct pattern type is not an ADT\")\n+                                   .variant_of_def(cx.tables.qpath_def(qpath, pat.hir_id));\n             for fieldpat in field_pats {\n                 if fieldpat.node.is_shorthand {\n                     continue;\n                 }\n+                if fieldpat.span.ctxt().outer().expn_info().is_some() {\n+                    // Don't lint if this is a macro expansion: macro authors\n+                    // shouldn't have to worry about this kind of style issue\n+                    // (Issue #49588)\n+                    continue;\n+                }\n                 if let PatKind::Binding(_, _, name, None) = fieldpat.node.pat.node {\n-                    if name.node == fieldpat.node.name {\n-                        if let Some(_) = fieldpat.span.ctxt().outer().expn_info() {\n-                            // Don't lint if this is a macro expansion: macro authors\n-                            // shouldn't have to worry about this kind of style issue\n-                            // (Issue #49588)\n-                            return;\n-                        }\n+                    let binding_ident = ast::Ident::new(name.node, name.span);\n+                    if cx.tcx.find_field_index(binding_ident, &variant) ==\n+                       Some(cx.tcx.field_index(fieldpat.node.id, cx.tables)) {\n                         let mut err = cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS,\n                                      fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant\","}, {"sha": "c0d2828094695999d1b259eea6cd9c5aede7a24a", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 9, "deletions": 25, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -16,7 +16,7 @@ use hair::cx::to_ref::ToRef;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::interpret::{GlobalId, Value, PrimVal};\n-use rustc::ty::{self, AdtKind, VariantDef, Ty};\n+use rustc::ty::{self, AdtKind, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::hir;\n@@ -420,12 +420,11 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 ty::TyAdt(adt, substs) => {\n                     match adt.adt_kind() {\n                         AdtKind::Struct | AdtKind::Union => {\n-                            let field_refs = field_refs(&adt.variants[0], fields);\n                             ExprKind::Adt {\n                                 adt_def: adt,\n                                 variant_index: 0,\n                                 substs,\n-                                fields: field_refs,\n+                                fields: field_refs(cx, fields),\n                                 base: base.as_ref().map(|base| {\n                                     FruInfo {\n                                         base: base.to_ref(),\n@@ -446,12 +445,11 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                     assert!(base.is_none());\n \n                                     let index = adt.variant_index_with_id(variant_id);\n-                                    let field_refs = field_refs(&adt.variants[index], fields);\n                                     ExprKind::Adt {\n                                         adt_def: adt,\n                                         variant_index: index,\n                                         substs,\n-                                        fields: field_refs,\n+                                        fields: field_refs(cx, fields),\n                                         base: None,\n                                     }\n                                 }\n@@ -581,24 +579,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 body: block::to_expr_ref(cx, body),\n             }\n         }\n-        hir::ExprField(ref source, name) => {\n-            let index = match cx.tables().expr_ty_adjusted(source).sty {\n-                ty::TyAdt(adt_def, _) => adt_def.variants[0].index_of_field_named(name.node),\n-                ref ty => span_bug!(expr.span, \"field of non-ADT: {:?}\", ty),\n-            };\n-            let index =\n-                index.unwrap_or_else(|| {\n-                    span_bug!(expr.span, \"no index found for field `{}`\", name.node)\n-                });\n-            ExprKind::Field {\n-                lhs: source.to_ref(),\n-                name: Field::new(index),\n-            }\n-        }\n-        hir::ExprTupField(ref source, index) => {\n+        hir::ExprField(ref source, ..) => {\n             ExprKind::Field {\n                 lhs: source.to_ref(),\n-                name: Field::new(index.node as usize),\n+                name: Field::new(cx.tcx.field_index(expr.id, cx.tables)),\n             }\n         }\n         hir::ExprCast(ref source, _) => {\n@@ -999,13 +983,13 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n }\n \n /// Converts a list of named fields (i.e. for struct-like struct/enum ADTs) into FieldExprRef.\n-fn field_refs<'tcx>(variant: &'tcx VariantDef,\n-                    fields: &'tcx [hir::Field])\n-                    -> Vec<FieldExprRef<'tcx>> {\n+fn field_refs<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                              fields: &'tcx [hir::Field])\n+                              -> Vec<FieldExprRef<'tcx>> {\n     fields.iter()\n         .map(|field| {\n             FieldExprRef {\n-                name: Field::new(variant.index_of_field_named(field.name.node).unwrap()),\n+                name: Field::new(cx.tcx.field_index(field.id, cx.tables)),\n                 expr: field.expr.to_ref(),\n             }\n         })"}, {"sha": "8d2b73d6ba033842693aa3dd6827c1575864e8e5", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -528,28 +528,12 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n             PatKind::Struct(ref qpath, ref fields, _) => {\n                 let def = self.tables.qpath_def(qpath, pat.hir_id);\n-                let adt_def = match ty.sty {\n-                    ty::TyAdt(adt_def, _) => adt_def,\n-                    _ => {\n-                        span_bug!(\n-                            pat.span,\n-                            \"struct pattern not applied to an ADT\");\n-                    }\n-                };\n-                let variant_def = adt_def.variant_of_def(def);\n-\n                 let subpatterns =\n                     fields.iter()\n                           .map(|field| {\n-                              let index = variant_def.index_of_field_named(field.node.name);\n-                              let index = index.unwrap_or_else(|| {\n-                                  span_bug!(\n-                                      pat.span,\n-                                      \"no field with name {:?}\",\n-                                      field.node.name);\n-                              });\n                               FieldPattern {\n-                                  field: Field::new(index),\n+                                  field: Field::new(self.tcx.field_index(field.node.id,\n+                                                                         self.tables)),\n                                   pattern: self.lower_pattern(&field.node.pat),\n                               }\n                           })"}, {"sha": "c5d2f0041a0f2867b9aa41c4e2a92a20238e04f4", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -407,7 +407,6 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         hir::ExprBlock(_) |\n         hir::ExprIndex(..) |\n         hir::ExprField(..) |\n-        hir::ExprTupField(..) |\n         hir::ExprArray(_) |\n         hir::ExprType(..) |\n         hir::ExprTup(..) => {}"}, {"sha": "ee08e6223903e39e9079c332d73189d08072c947", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -568,8 +568,10 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                     // If the expression uses FRU we need to make sure all the unmentioned fields\n                     // are checked for privacy (RFC 736). Rather than computing the set of\n                     // unmentioned fields, just check them all.\n-                    for variant_field in &variant.fields {\n-                        let field = fields.iter().find(|f| f.name.node == variant_field.name);\n+                    for (vf_index, variant_field) in variant.fields.iter().enumerate() {\n+                        let field = fields.iter().find(|f| {\n+                            self.tcx.field_index(f.id, self.tables) == vf_index\n+                        });\n                         let (use_ctxt, span) = match field {\n                             Some(field) => (field.name.node.to_ident().span, field.span),\n                             None => (base.span, base.span),\n@@ -579,8 +581,8 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                 } else {\n                     for field in fields {\n                         let use_ctxt = field.name.node.to_ident().span;\n-                        let field_def = variant.field_named(field.name.node);\n-                        self.check_field(use_ctxt, field.span, adt, field_def);\n+                        let index = self.tcx.field_index(field.id, self.tables);\n+                        self.check_field(use_ctxt, field.span, adt, &variant.fields[index]);\n                     }\n                 }\n             }\n@@ -598,8 +600,8 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                 let variant = adt.variant_of_def(def);\n                 for field in fields {\n                     let use_ctxt = field.node.name.to_ident().span;\n-                    let field_def = variant.field_named(field.node.name);\n-                    self.check_field(use_ctxt, field.span, adt, field_def);\n+                    let index = self.tcx.field_index(field.node.id, self.tables);\n+                    self.check_field(use_ctxt, field.span, adt, &variant.fields[index]);\n                 }\n             }\n             _ => {}"}, {"sha": "abaa02a856e9cae181944eda5a8fed471205c308", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 3, "deletions": 54, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -25,7 +25,6 @@\n \n use rustc::hir::def::Def as HirDef;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::map::Node;\n use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n \n@@ -1006,20 +1005,16 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 };\n                 let variant = adt.variant_of_def(self.save_ctxt.get_path_def(p.id));\n \n-                for &Spanned {\n-                    node: ref field,\n-                    span,\n-                } in fields\n-                {\n+                for &Spanned { node: ref field, span } in fields {\n                     let sub_span = self.span.span_for_first_ident(span);\n-                    if let Some(f) = variant.find_field_named(field.ident.name) {\n+                    if let Some(index) = self.tcx.find_field_index(field.ident, variant) {\n                         if !self.span.filter_generated(sub_span, span) {\n                             let span =\n                                 self.span_from_span(sub_span.expect(\"No span fund for var ref\"));\n                             self.dumper.dump_ref(Ref {\n                                 kind: RefKind::Variable,\n                                 span,\n-                                ref_id: ::id_from_def_id(f.did),\n+                                ref_id: ::id_from_def_id(variant.fields[index].did),\n                             });\n                         }\n                     }\n@@ -1638,52 +1633,6 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     }\n                 }\n             }\n-            ast::ExprKind::TupField(ref sub_ex, idx) => {\n-                self.visit_expr(&sub_ex);\n-\n-                let hir_node = match self.save_ctxt.tcx.hir.find(sub_ex.id) {\n-                    Some(Node::NodeExpr(expr)) => expr,\n-                    _ => {\n-                        debug!(\n-                            \"Missing or weird node for sub-expression {} in {:?}\",\n-                            sub_ex.id,\n-                            ex\n-                        );\n-                        return;\n-                    }\n-                };\n-                let ty = match self.save_ctxt.tables.expr_ty_adjusted_opt(&hir_node) {\n-                    Some(ty) => &ty.sty,\n-                    None => {\n-                        visit::walk_expr(self, ex);\n-                        return;\n-                    }\n-                };\n-                match *ty {\n-                    ty::TyAdt(def, _) => {\n-                        let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n-                        if !self.span.filter_generated(sub_span, ex.span) {\n-                            let span =\n-                                self.span_from_span(sub_span.expect(\"No span found for var ref\"));\n-                            if let Some(field) = def.non_enum_variant().fields.get(idx.node) {\n-                                let ref_id = ::id_from_def_id(field.did);\n-                                self.dumper.dump_ref(Ref {\n-                                    kind: RefKind::Variable,\n-                                    span,\n-                                    ref_id,\n-                                });\n-                            } else {\n-                                return;\n-                            }\n-                        }\n-                    }\n-                    ty::TyTuple(..) => {}\n-                    _ => {\n-                        debug!(\"Expected struct or tuple type, found {:?}\", ty);\n-                        return;\n-                    }\n-                }\n-            }\n             ast::ExprKind::Closure(_, _, ref decl, ref body, _fn_decl_span) => {\n                 let mut id = String::from(\"$\");\n                 id.push_str(&ex.id.to_string());"}, {"sha": "ca19ed0df67d1ab9efa4657867dff7a861d844e3", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -553,16 +553,18 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 };\n                 match self.tables.expr_ty_adjusted(&hir_node).sty {\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n-                        let f = def.non_enum_variant().field_named(ident.name);\n+                        let variant = &def.non_enum_variant();\n+                        let index = self.tcx.find_field_index(ident, variant).unwrap();\n                         let sub_span = self.span_utils.span_for_last_ident(expr.span);\n                         filter!(self.span_utils, sub_span, expr.span, None);\n                         let span = self.span_from_span(sub_span.unwrap());\n                         return Some(Data::RefData(Ref {\n                             kind: RefKind::Variable,\n                             span,\n-                            ref_id: id_from_def_id(f.did),\n+                            ref_id: id_from_def_id(variant.fields[index].did),\n                         }));\n                     }\n+                    ty::TyTuple(..) => None,\n                     _ => {\n                         debug!(\"Expected struct or union type, found {:?}\", ty);\n                         None\n@@ -816,15 +818,15 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         field_ref: &ast::Field,\n         variant: &ty::VariantDef,\n     ) -> Option<Ref> {\n-        let f = variant.find_field_named(field_ref.ident.name)?;\n+        let index = self.tcx.find_field_index(field_ref.ident, variant).unwrap();\n         // We don't really need a sub-span here, but no harm done\n         let sub_span = self.span_utils.span_for_last_ident(field_ref.ident.span);\n         filter!(self.span_utils, sub_span, field_ref.ident.span, None);\n         let span = self.span_from_span(sub_span.unwrap());\n         Some(Ref {\n             kind: RefKind::Variable,\n             span,\n-            ref_id: id_from_def_id(f.did),\n+            ref_id: id_from_def_id(variant.fields[index].did),\n         })\n     }\n "}, {"sha": "4d93e81a78fa128b09bb66cb10d594ff203b6976", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -202,10 +202,6 @@ impl<'a> SpanUtils<'a> {\n         self.sub_span_after(span, |t| t.is_keyword(keyword))\n     }\n \n-    pub fn sub_span_after_token(&self, span: Span, tok: Token) -> Option<Span> {\n-        self.sub_span_after(span, |t| t == tok)\n-    }\n-\n     fn sub_span_after<F: Fn(Token) -> bool>(&self, span: Span, f: F) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n         loop {"}, {"sha": "7b4dc60409b122b89cc35d2702795ab349784c6c", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -860,7 +860,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         // Index the struct fields' types.\n         let field_map = variant.fields\n             .iter()\n-            .map(|field| (field.name, field))\n+            .enumerate()\n+            .map(|(i, field)| (field.name.to_ident(), (i, field)))\n             .collect::<FxHashMap<_, _>>();\n \n         // Keep track of which fields have already appeared in the pattern.\n@@ -869,7 +870,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let mut inexistent_fields = vec![];\n         // Typecheck each field.\n         for &Spanned { node: ref field, span } in fields {\n-            let field_ty = match used_fields.entry(field.name) {\n+            let ident = tcx.adjust(field.name, variant.did, self.body_id).0;\n+            let field_ty = match used_fields.entry(ident) {\n                 Occupied(occupied) => {\n                     struct_span_err!(tcx.sess, span, E0025,\n                                      \"field `{}` bound multiple times \\\n@@ -883,10 +885,10 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 }\n                 Vacant(vacant) => {\n                     vacant.insert(span);\n-                    field_map.get(&field.name)\n-                        .map(|f| {\n+                    field_map.get(&ident)\n+                        .map(|(i, f)| {\n+                            self.write_field_index(field.id, *i);\n                             self.tcx.check_stability(f.did, Some(pat_id), span);\n-\n                             self.field_ty(span, f, substs)\n                         })\n                         .unwrap_or_else(|| {\n@@ -958,8 +960,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         } else if !etc {\n             let unmentioned_fields = variant.fields\n                 .iter()\n-                .map(|field| field.name)\n-                .filter(|field| !used_fields.contains_key(&field))\n+                .map(|field| field.name.to_ident())\n+                .filter(|ident| !used_fields.contains_key(&ident))\n                 .collect::<Vec<_>>();\n             if unmentioned_fields.len() > 0 {\n                 let field_names = if unmentioned_fields.len() == 1 {"}, {"sha": "7569bdccd5a107a1e26edf416730a749df866014", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -433,7 +433,6 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             let last = exprs[exprs.len() - 1];\n             match last.node {\n                 hir::ExprField(ref expr, _) |\n-                hir::ExprTupField(ref expr, _) |\n                 hir::ExprIndex(ref expr, _) |\n                 hir::ExprUnary(hir::UnDeref, ref expr) => exprs.push(&expr),\n                 _ => break,"}, {"sha": "d8907866467ba0b0478cd0390cae8223628ee371", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -304,8 +304,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     for (ty, _) in self.autoderef(span, rcvr_ty) {\n                         match ty.sty {\n                             ty::TyAdt(def, substs) if !def.is_enum() => {\n-                                if let Some(field) = def.non_enum_variant()\n-                                    .find_field_named(item_name) {\n+                                let variant = &def.non_enum_variant();\n+                                if let Some(index) =\n+                                        self.tcx.find_field_index(item_name.to_ident(), variant) {\n+                                    let field = &variant.fields[index];\n                                     let snippet = tcx.sess.codemap().span_to_snippet(expr.span);\n                                     let expr_string = match snippet {\n                                         Ok(expr_string) => expr_string,"}, {"sha": "ca35153d571dbd0048cf8ada21af03d6d5832a04", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 33, "deletions": 90, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -85,7 +85,7 @@ use self::method::MethodCallee;\n use self::TupleArgumentsFlag::*;\n \n use astconv::AstConv;\n-use hir::def::{Def, CtorKind};\n+use hir::def::Def;\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use std::slice;\n use namespace::Namespace;\n@@ -121,7 +121,7 @@ use std::ops::{self, Deref};\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n-use syntax::codemap::{self, original_sp, Spanned};\n+use syntax::codemap::{original_sp, Spanned};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, InternedString, keywords};\n@@ -1938,6 +1938,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn write_field_index(&self, node_id: ast::NodeId, index: usize) {\n+        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+        self.tables.borrow_mut().field_indices_mut().insert(hir_id, index);\n+    }\n+\n     // The NodeId and the ItemLocalId must identify the same item. We just pass\n     // both of them for consistency checking.\n     pub fn write_method_call(&self,\n@@ -2266,7 +2271,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             hir::ExprUnary(hir::UnDeref, _) |\n             hir::ExprField(..) |\n-            hir::ExprTupField(..) |\n             hir::ExprIndex(..) => {\n                 true\n             }\n@@ -3070,20 +3074,36 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let (ident, def_scope) =\n                         self.tcx.adjust(field.node, base_def.did, self.body_id);\n                     let fields = &base_def.non_enum_variant().fields;\n-                    if let Some(field) = fields.iter().find(|f| f.name.to_ident() == ident) {\n+                    if let Some(index) = fields.iter().position(|f| f.name.to_ident() == ident) {\n+                        let field = &fields[index];\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         if field.vis.is_accessible_from(def_scope, self.tcx) {\n                             let adjustments = autoderef.adjust_steps(needs);\n                             self.apply_adjustments(base, adjustments);\n                             autoderef.finalize();\n \n+                            self.write_field_index(expr.id, index);\n                             self.tcx.check_stability(field.did, Some(expr.id), expr.span);\n-\n                             return field_ty;\n                         }\n                         private_candidate = Some((base_def.did, field_ty));\n                     }\n                 }\n+                ty::TyTuple(ref tys) => {\n+                    let fstr = field.node.as_str();\n+                    if let Ok(index) = fstr.parse::<usize>() {\n+                        if fstr == index.to_string() {\n+                            if let Some(field_ty) = tys.get(index) {\n+                                let adjustments = autoderef.adjust_steps(needs);\n+                                self.apply_adjustments(base, adjustments);\n+                                autoderef.finalize();\n+\n+                                self.write_field_index(expr.id, index);\n+                                return field_ty;\n+                            }\n+                        }\n+                    }\n+                }\n                 _ => {}\n             }\n         }\n@@ -3189,78 +3209,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         display\n     }\n \n-    // Check tuple index expressions\n-    fn check_tup_field(&self,\n-                       expr: &'gcx hir::Expr,\n-                       needs: Needs,\n-                       base: &'gcx hir::Expr,\n-                       idx: codemap::Spanned<usize>) -> Ty<'tcx> {\n-        let expr_t = self.check_expr_with_needs(base, needs);\n-        let expr_t = self.structurally_resolved_type(expr.span,\n-                                                     expr_t);\n-        let mut private_candidate = None;\n-        let mut tuple_like = false;\n-        let mut autoderef = self.autoderef(expr.span, expr_t);\n-        while let Some((base_t, _)) = autoderef.next() {\n-            let field = match base_t.sty {\n-                ty::TyAdt(base_def, substs) if base_def.is_struct() => {\n-                    tuple_like = base_def.non_enum_variant().ctor_kind == CtorKind::Fn;\n-                    if !tuple_like { continue }\n-\n-                    debug!(\"tuple struct named {:?}\",  base_t);\n-                    let ident =\n-                        ast::Ident::new(Symbol::intern(&idx.node.to_string()), idx.span.modern());\n-                    let (ident, def_scope) =\n-                        self.tcx.adjust_ident(ident, base_def.did, self.body_id);\n-                    let fields = &base_def.non_enum_variant().fields;\n-                    if let Some(field) = fields.iter().find(|f| f.name.to_ident() == ident) {\n-                        let field_ty = self.field_ty(expr.span, field, substs);\n-                        if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                            self.tcx.check_stability(field.did, Some(expr.id), expr.span);\n-                            Some(field_ty)\n-                        } else {\n-                            private_candidate = Some((base_def.did, field_ty));\n-                            None\n-                        }\n-                    } else {\n-                        None\n-                    }\n-                }\n-                ty::TyTuple(ref v) => {\n-                    tuple_like = true;\n-                    v.get(idx.node).cloned()\n-                }\n-                _ => continue\n-            };\n-\n-            if let Some(field_ty) = field {\n-                let adjustments = autoderef.adjust_steps(needs);\n-                self.apply_adjustments(base, adjustments);\n-                autoderef.finalize();\n-                return field_ty;\n-            }\n-        }\n-        autoderef.unambiguous_final_ty();\n-\n-        if let Some((did, field_ty)) = private_candidate {\n-            let struct_path = self.tcx().item_path_str(did);\n-            struct_span_err!(self.tcx().sess, expr.span, E0611,\n-                             \"field `{}` of tuple-struct `{}` is private\",\n-                             idx.node, struct_path).emit();\n-            return field_ty;\n-        }\n-\n-        if tuple_like {\n-            type_error_struct!(self.tcx().sess, expr.span, expr_t, E0612,\n-                \"attempted out-of-bounds tuple index `{}` on type `{}`\",\n-                idx.node, expr_t).emit();\n-        } else {\n-            self.no_such_field_err(expr.span, idx.node, expr_t).emit();\n-        }\n-\n-        self.tcx().types.err\n-    }\n-\n     fn no_such_field_err<T: Display>(&self, span: Span, field: T, expr_t: &ty::TyS)\n         -> DiagnosticBuilder {\n         type_error_struct!(self.tcx().sess, span, expr_t, E0609,\n@@ -3343,8 +3291,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         let mut remaining_fields = FxHashMap();\n-        for field in &variant.fields {\n-            remaining_fields.insert(field.name.to_ident(), field);\n+        for (i, field) in variant.fields.iter().enumerate() {\n+            remaining_fields.insert(field.name.to_ident(), (i, field));\n         }\n \n         let mut seen_fields = FxHashMap();\n@@ -3354,8 +3302,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Typecheck each field.\n         for field in ast_fields {\n             let ident = tcx.adjust(field.name.node, variant.did, self.body_id).0;\n-            let field_type = if let Some(v_field) = remaining_fields.remove(&ident) {\n-                seen_fields.insert(field.name.node, field.span);\n+            let field_type = if let Some((i, v_field)) = remaining_fields.remove(&ident) {\n+                seen_fields.insert(ident, field.span);\n+                self.write_field_index(field.id, i);\n \n                 // we don't look at stability attributes on\n                 // struct-like enums (yet...), but it's definitely not\n@@ -3367,18 +3316,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.field_ty(field.span, v_field, substs)\n             } else {\n                 error_happened = true;\n-                if let Some(_) = variant.find_field_named(field.name.node) {\n+                if let Some(prev_span) = seen_fields.get(&ident) {\n                     let mut err = struct_span_err!(self.tcx.sess,\n                                                 field.name.span,\n                                                 E0062,\n                                                 \"field `{}` specified more than once\",\n-                                                field.name.node);\n+                                                ident);\n \n                     err.span_label(field.name.span, \"used more than once\");\n-\n-                    if let Some(prev_span) = seen_fields.get(&field.name.node) {\n-                        err.span_label(*prev_span, format!(\"first use of `{}`\", field.name.node));\n-                    }\n+                    err.span_label(*prev_span, format!(\"first use of `{}`\", ident));\n \n                     err.emit();\n                 } else {\n@@ -4121,9 +4067,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprField(ref base, ref field) => {\n             self.check_field(expr, needs, &base, field)\n           }\n-          hir::ExprTupField(ref base, idx) => {\n-            self.check_tup_field(expr, needs, &base, idx)\n-          }\n           hir::ExprIndex(ref base, ref idx) => {\n               let base_t = self.check_expr_with_needs(&base, needs);\n               let idx_t = self.check_expr(&idx);"}, {"sha": "6e0d7dd8508775719988da59e7af640fbdb57bac", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -226,13 +226,24 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n \n         self.visit_node_id(e.span, e.hir_id);\n \n-        if let hir::ExprClosure(_, _, body, _, _) = e.node {\n-            let body = self.fcx.tcx.hir.body(body);\n-            for arg in &body.arguments {\n-                self.visit_node_id(e.span, arg.hir_id);\n-            }\n+        match e.node {\n+            hir::ExprClosure(_, _, body, _, _) => {\n+                let body = self.fcx.tcx.hir.body(body);\n+                for arg in &body.arguments {\n+                    self.visit_node_id(e.span, arg.hir_id);\n+                }\n \n-            self.visit_body(body);\n+                self.visit_body(body);\n+            }\n+            hir::ExprStruct(_, ref fields, _) => {\n+                for field in fields {\n+                    self.visit_field_id(field.id);\n+                }\n+            }\n+            hir::ExprField(..) => {\n+                self.visit_field_id(e.id);\n+            }\n+            _ => {}\n         }\n \n         intravisit::walk_expr(self, e);\n@@ -254,6 +265,11 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n                     .expect(\"missing binding mode\");\n                 self.tables.pat_binding_modes_mut().insert(p.hir_id, bm);\n             }\n+            hir::PatKind::Struct(_, ref fields, _) => {\n+                for field in fields {\n+                    self.visit_field_id(field.node.id);\n+                }\n+            }\n             _ => {}\n         };\n \n@@ -384,6 +400,13 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn visit_field_id(&mut self, node_id: ast::NodeId) {\n+        let hir_id = self.tcx().hir.node_to_hir_id(node_id);\n+        if let Some(index) = self.fcx.tables.borrow_mut().field_indices_mut().remove(hir_id) {\n+            self.tables.field_indices_mut().insert(hir_id, index);\n+        }\n+    }\n+\n     fn visit_node_id(&mut self, span: Span, hir_id: hir::HirId) {\n         // Export associated path extensions and method resultions.\n         if let Some(def) = self.fcx"}, {"sha": "3939c3a06270e3c19d6cf5eb670b93f5c83ee27f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -514,11 +514,11 @@ fn convert_struct_variant<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     discr: ty::VariantDiscr,\n                                     def: &hir::VariantData)\n                                     -> ty::VariantDef {\n-    let mut seen_fields: FxHashMap<ast::Name, Span> = FxHashMap();\n+    let mut seen_fields: FxHashMap<ast::Ident, Span> = FxHashMap();\n     let node_id = tcx.hir.as_local_node_id(did).unwrap();\n     let fields = def.fields().iter().map(|f| {\n         let fid = tcx.hir.local_def_id(f.id);\n-        let dup_span = seen_fields.get(&f.name).cloned();\n+        let dup_span = seen_fields.get(&f.name.to_ident()).cloned();\n         if let Some(prev_span) = dup_span {\n             struct_span_err!(tcx.sess, f.span, E0124,\n                              \"field `{}` is already declared\",\n@@ -527,7 +527,7 @@ fn convert_struct_variant<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 .span_label(prev_span, format!(\"`{}` first declared here\", f.name))\n                 .emit();\n         } else {\n-            seen_fields.insert(f.name, f.span);\n+            seen_fields.insert(f.name.to_ident(), f.span);\n         }\n \n         ty::FieldDef {"}, {"sha": "ae3b2b22ea114c198218bc5c54d46e1907fe9aa7", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 80, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -4138,86 +4138,6 @@ https://doc.rust-lang.org/book/first-edition/primitive-types.html\n https://doc.rust-lang.org/book/first-edition/structs.html\n \"##,\n \n-E0611: r##\"\n-Attempted to access a private field on a tuple-struct.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0611\n-mod some_module {\n-    pub struct Foo(u32);\n-\n-    impl Foo {\n-        pub fn new() -> Foo { Foo(0) }\n-    }\n-}\n-\n-let y = some_module::Foo::new();\n-println!(\"{}\", y.0); // error: field `0` of tuple-struct `some_module::Foo`\n-                     //        is private\n-```\n-\n-Since the field is private, you have two solutions:\n-\n-1) Make the field public:\n-\n-```\n-mod some_module {\n-    pub struct Foo(pub u32); // The field is now public.\n-\n-    impl Foo {\n-        pub fn new() -> Foo { Foo(0) }\n-    }\n-}\n-\n-let y = some_module::Foo::new();\n-println!(\"{}\", y.0); // So we can access it directly.\n-```\n-\n-2) Add a getter function to keep the field private but allow for accessing its\n-value:\n-\n-```\n-mod some_module {\n-    pub struct Foo(u32);\n-\n-    impl Foo {\n-        pub fn new() -> Foo { Foo(0) }\n-\n-        // We add the getter function.\n-        pub fn get(&self) -> &u32 { &self.0 }\n-    }\n-}\n-\n-let y = some_module::Foo::new();\n-println!(\"{}\", y.get()); // So we can get the value through the function.\n-```\n-\"##,\n-\n-E0612: r##\"\n-Attempted out-of-bounds tuple index.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0612\n-struct Foo(u32);\n-\n-let y = Foo(0);\n-println!(\"{}\", y.1); // error: attempted out-of-bounds tuple index `1`\n-                     //        on type `Foo`\n-```\n-\n-If a tuple/tuple-struct type has n fields, you can only try to access these n\n-fields from 0 to (n - 1). So in this case, you can only index `0`. Example:\n-\n-```\n-struct Foo(u32);\n-\n-let y = Foo(0);\n-println!(\"{}\", y.0); // ok!\n-```\n-\"##,\n-\n E0614: r##\"\n Attempted to dereference a variable which cannot be dereferenced.\n \n@@ -4839,6 +4759,8 @@ register_diagnostics! {\n     E0587, // type has conflicting packed and align representation hints\n     E0588, // packed type cannot transitively contain a `[repr(align)]` type\n     E0592, // duplicate definitions with name `{}`\n+//  E0611, // merged into E0616\n+//  E0612, // merged into E0609\n //  E0613, // Removed (merged with E0609)\n     E0627, // yield statement outside of generator literal\n     E0632, // cannot provide explicit type parameters when `impl Trait` is used in"}, {"sha": "91c9a1524e1442274235a80e90a0533abe67fa32", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -1018,7 +1018,6 @@ impl Expr {\n             ExprKind::Assign(..) => ExprPrecedence::Assign,\n             ExprKind::AssignOp(..) => ExprPrecedence::AssignOp,\n             ExprKind::Field(..) => ExprPrecedence::Field,\n-            ExprKind::TupField(..) => ExprPrecedence::TupField,\n             ExprKind::Index(..) => ExprPrecedence::Index,\n             ExprKind::Range(..) => ExprPrecedence::Range,\n             ExprKind::Path(..) => ExprPrecedence::Path,\n@@ -1133,12 +1132,8 @@ pub enum ExprKind {\n     ///\n     /// For example, `a += 1`.\n     AssignOp(BinOp, P<Expr>, P<Expr>),\n-    /// Access of a named struct field (`obj.foo`)\n+    /// Access of a named (`obj.foo`) or unnamed (`obj.0`) struct field\n     Field(P<Expr>, Ident),\n-    /// Access of an unnamed field of a struct or tuple-struct\n-    ///\n-    /// For example, `foo.0`.\n-    TupField(P<Expr>, Spanned<usize>),\n     /// An indexing operation (`foo[2]`)\n     Index(P<Expr>, P<Expr>),\n     /// A range (`1..2`, `1..`, `..2`, `1...2`, `1...`, `...2`)"}, {"sha": "36244f0a3c43874df3b5f637be258a43ac155f0b", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -636,8 +636,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr(sp, ast::ExprKind::Field(expr, ident.with_span_pos(sp)))\n     }\n     fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>, idx: usize) -> P<ast::Expr> {\n-        let id = Spanned { node: idx, span: sp };\n-        self.expr(sp, ast::ExprKind::TupField(expr, id))\n+        let ident = Ident::from_str(&idx.to_string()).with_span_pos(sp);\n+        self.expr(sp, ast::ExprKind::Field(expr, ident))\n     }\n     fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::AddrOf(ast::Mutability::Immutable, e))"}, {"sha": "a0cd831a9ba080cb5ae532fa869c0ec9e0739036", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -1267,11 +1267,6 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n             ExprKind::Field(el, ident) => {\n                 ExprKind::Field(folder.fold_expr(el), folder.fold_ident(ident))\n             }\n-            ExprKind::TupField(el, index) => {\n-                ExprKind::TupField(folder.fold_expr(el),\n-                             respan(folder.new_span(index.span),\n-                                    folder.fold_usize(index.node)))\n-            }\n             ExprKind::Index(el, er) => {\n                 ExprKind::Index(folder.fold_expr(el), folder.fold_expr(er))\n             }"}, {"sha": "a7a9ce745122c36612eecdbf51ffc331cf1e16e6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 33, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -2144,10 +2144,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn mk_tup_field(&mut self, expr: P<Expr>, idx: codemap::Spanned<usize>) -> ast::ExprKind {\n-        ExprKind::TupField(expr, idx)\n-    }\n-\n     pub fn mk_assign_op(&mut self, binop: ast::BinOp,\n                         lhs: P<Expr>, rhs: P<Expr>) -> ast::ExprKind {\n         ExprKind::AssignOp(binop, lhs, rhs)\n@@ -2605,35 +2601,11 @@ impl<'a> Parser<'a> {\n                   token::Ident(..) => {\n                     e = self.parse_dot_suffix(e, lo)?;\n                   }\n-                  token::Literal(token::Integer(index_ident), suf) => {\n-                    let sp = self.span;\n-\n-                    // A tuple index may not have a suffix\n-                    self.expect_no_suffix(sp, \"tuple index\", suf);\n-\n-                    let idx_span = self.span;\n+                  token::Literal(token::Integer(name), _) => {\n+                    let span = self.span;\n                     self.bump();\n-\n-                    let invalid_msg = \"invalid tuple or struct index\";\n-\n-                    let index = index_ident.as_str().parse::<usize>().ok();\n-                    match index {\n-                        Some(n) => {\n-                            if n.to_string() != index_ident.as_str() {\n-                                let mut err = self.struct_span_err(self.prev_span, invalid_msg);\n-                                err.span_suggestion(self.prev_span,\n-                                                    \"try simplifying the index\",\n-                                                    n.to_string());\n-                                err.emit();\n-                            }\n-                            let field = self.mk_tup_field(e, respan(idx_span, n));\n-                            e = self.mk_expr(lo.to(idx_span), field, ThinVec::new());\n-                        }\n-                        None => {\n-                            let prev_span = self.prev_span;\n-                            self.span_err(prev_span, invalid_msg);\n-                        }\n-                    }\n+                    let field = ExprKind::Field(e, Ident::new(name, span));\n+                    e = self.mk_expr(lo.to(span), field, ThinVec::new());\n                   }\n                   token::Literal(token::Float(n), _suf) => {\n                     self.bump();\n@@ -7058,7 +7030,7 @@ impl<'a> Parser<'a> {\n             match self.token {\n                 token::Ident(ident, false) if ident.name == keywords::Underscore.name() => {\n                     self.bump(); // `_`\n-                    Ok(Some(Ident { name: ident.name.gensymed(), ..ident }))\n+                    Ok(Some(Ident::new(ident.name.gensymed(), ident.span)))\n                 }\n                 _ => self.parse_ident().map(Some),\n             }"}, {"sha": "3741850b8a974a7e78fac7583a9b94efd9d712b4", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -1966,8 +1966,7 @@ impl<'a> State<'a> {\n                        args: &[P<ast::Expr>]) -> io::Result<()> {\n         let prec =\n             match func.node {\n-                ast::ExprKind::Field(..) |\n-                ast::ExprKind::TupField(..) => parser::PREC_FORCE_PAREN,\n+                ast::ExprKind::Field(..) => parser::PREC_FORCE_PAREN,\n                 _ => parser::PREC_POSTFIX,\n             };\n \n@@ -2203,11 +2202,6 @@ impl<'a> State<'a> {\n                 self.s.word(\".\")?;\n                 self.print_ident(ident)?;\n             }\n-            ast::ExprKind::TupField(ref expr, id) => {\n-                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX)?;\n-                self.s.word(\".\")?;\n-                self.print_usize(id.node)?;\n-            }\n             ast::ExprKind::Index(ref expr, ref index) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\"[\")?;"}, {"sha": "524f9f127f57b1abbd60a796fe8143a7916cdcee", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -251,7 +251,6 @@ pub enum ExprPrecedence {\n     Call,\n     MethodCall,\n     Field,\n-    TupField,\n     Index,\n     Try,\n     InlineAsm,\n@@ -320,7 +319,6 @@ impl ExprPrecedence {\n             ExprPrecedence::Call |\n             ExprPrecedence::MethodCall |\n             ExprPrecedence::Field |\n-            ExprPrecedence::TupField |\n             ExprPrecedence::Index |\n             ExprPrecedence::Try |\n             ExprPrecedence::InlineAsm |\n@@ -365,7 +363,6 @@ pub fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n         ast::ExprKind::Cast(ref x, _) |\n         ast::ExprKind::Type(ref x, _) |\n         ast::ExprKind::Field(ref x, _) |\n-        ast::ExprKind::TupField(ref x, _) |\n         ast::ExprKind::Index(ref x, _) => {\n             // &X { y: 1 }, X { y: 1 }.y\n             contains_exterior_struct_lit(&x)"}, {"sha": "8743840e44393977795ee065a042aa841c848ec2", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -749,9 +749,6 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ident(ident);\n         }\n-        ExprKind::TupField(ref subexpression, _) => {\n-            visitor.visit_expr(subexpression);\n-        }\n         ExprKind::Index(ref main_expression, ref index_expression) => {\n             visitor.visit_expr(main_expression);\n             visitor.visit_expr(index_expression)"}, {"sha": "eec7df84c82f7f8eced3cbb13bece589cece0891", "filename": "src/test/compile-fail/borrowck/borrowck-uninit-field-access.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-field-access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-field-access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-field-access.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -36,7 +36,7 @@ fn main() {\n \n     let mut line1 = Line::default();\n     let _moved = line1.origin;\n-    let _ = line1.origin.x + 1; //[ast]~ ERROR use of collaterally moved value: `line1.origin.x`\n+    let _ = line1.origin.x + 1; //[ast]~ ERROR use of moved value: `line1.origin.x`\n                                 //[mir]~^ [E0382]\n \n     let mut line2 = Line::default();"}, {"sha": "df34aab4b8f6683e6de1c3a64fdaba3585637dbe", "filename": "src/test/compile-fail/issue-19244-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fcompile-fail%2Fissue-19244-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fcompile-fail%2Fissue-19244-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19244-1.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -12,5 +12,5 @@ const TUP: (usize,) = (42,);\n \n fn main() {\n     let a: [isize; TUP.1];\n-    //~^ ERROR attempted out-of-bounds tuple index\n+    //~^ ERROR no field `1` on type `(usize,)`\n }"}, {"sha": "f487ef62aa435d22887b120fc595ceca5fb80436", "filename": "src/test/compile-fail/struct-field-privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fcompile-fail%2Fstruct-field-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fcompile-fail%2Fstruct-field-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-field-privacy.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -42,7 +42,7 @@ fn test(a: A, b: inner::A, c: inner::B, d: xc::A, e: xc::B, z: inner::Z) {\n     e.b; //~ ERROR: field `b` of struct `xc::B` is private\n \n     z.0;\n-    z.1; //~ ERROR: field `1` of tuple-struct `inner::Z` is private\n+    z.1; //~ ERROR: field `1` of struct `inner::Z` is private\n }\n \n fn main() {}"}, {"sha": "35b843676b4f1d79c8e3cc8edc644309e3bba811", "filename": "src/test/compile-fail/tuple-index-out-of-bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fcompile-fail%2Ftuple-index-out-of-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fcompile-fail%2Ftuple-index-out-of-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftuple-index-out-of-bounds.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -15,10 +15,10 @@ fn main() {\n     origin.0;\n     origin.1;\n     origin.2;\n-    //~^ ERROR attempted out-of-bounds tuple index `2` on type `Point`\n+    //~^ ERROR no field `2` on type `Point`\n     let tuple = (0, 0);\n     tuple.0;\n     tuple.1;\n     tuple.2;\n-    //~^ ERROR attempted out-of-bounds tuple index `2` on type `({integer}, {integer})`\n+    //~^ ERROR no field `2` on type `({integer}, {integer})`\n }"}, {"sha": "9c939d0d2fbaddbe1f0e373c04ec325b384f5d53", "filename": "src/test/mir-opt/end_region_cyclic.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fmir-opt%2Fend_region_cyclic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fmir-opt%2Fend_region_cyclic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_cyclic.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -40,29 +40,29 @@ fn query() -> bool { true }\n \n // END RUST SOURCE\n // START rustc.main.SimplifyCfg-qualify-consts.after.mir\n-// fn main() -> () {\n+// fn main() -> (){\n //     let mut _0: ();\n //     scope 1 {\n-//         let _2: S<'35_0rs>;\n+//         let _2: S<'36_0rs>;\n+//     }\n+//     scope 2 {\n //     }\n-//     ...\n //     let mut _1: ();\n-//     let mut _3: std::cell::Cell<std::option::Option<&'35_0rs S<'35_0rs>>>;\n-//     let mut _4: std::option::Option<&'35_0rs S<'35_0rs>>;\n+//     let mut _3: std::cell::Cell<std::option::Option<&'36_0rs S<'36_0rs>>>;\n+//     let mut _4: std::option::Option<&'36_0rs S<'36_0rs>>;\n //     let mut _5: ();\n-//     let mut _6: &'16s std::cell::Cell<std::option::Option<&'35_0rs S<'35_0rs>>>;\n-//     let mut _7: std::option::Option<&'35_0rs S<'35_0rs>>;\n-//     let mut _8: &'35_0rs S<'35_0rs>;\n-//     let mut _9: &'35_0rs S<'35_0rs>;\n+//     let mut _6: &'17s std::cell::Cell<std::option::Option<&'36_0rs S<'36_0rs>>>;\n+//     let mut _7: std::option::Option<&'36_0rs S<'36_0rs>>;\n+//     let mut _8: &'36_0rs S<'36_0rs>;\n+//     let mut _9: &'36_0rs S<'36_0rs>;\n //     let mut _10: ();\n //     let mut _11: bool;\n //     let mut _12: !;\n //     let mut _13: ();\n-//     let mut _14: &'33s std::cell::Cell<std::option::Option<&'35_0rs S<'35_0rs>>>;\n-//     let mut _15: std::option::Option<&'35_0rs S<'35_0rs>>;\n-//     let mut _16: &'35_0rs S<'35_0rs>;\n-//     let mut _17: &'35_0rs S<'35_0rs>;\n-//\n+//     let mut _14: &'34s std::cell::Cell<std::option::Option<&'36_0rs S<'36_0rs>>>;\n+//     let mut _15: std::option::Option<&'36_0rs S<'36_0rs>>;\n+//     let mut _16: &'36_0rs S<'36_0rs>;\n+//     let mut _17: &'36_0rs S<'36_0rs>;\n //     bb0: {\n //         goto -> bb1;\n //     }\n@@ -73,29 +73,29 @@ fn query() -> bool { true }\n //         StorageLive(_2);\n //         StorageLive(_3);\n //         StorageLive(_4);\n-//         _4 = std::option::Option<&'35_0rs S<'35_0rs>>::None;\n+//         _4 = std::option::Option<&'36_0rs S<'36_0rs>>::None;\n //         _3 = const <std::cell::Cell<T>>::new(move _4) -> [return: bb4, unwind: bb3];\n //     }\n //     bb3: {\n //         resume;\n //     }\n //     bb4: {\n //         StorageDead(_4);\n-//         _2 = S<'35_0rs> { r: move _3 };\n+//         _2 = S<'36_0rs> { r: move _3 };\n //         StorageDead(_3);\n //         StorageLive(_6);\n-//         _6 = &'16s (_2.0: std::cell::Cell<std::option::Option<&'35_0rs S<'35_0rs>>>);\n+//         _6 = &'17s (_2.0: std::cell::Cell<std::option::Option<&'36_0rs S<'36_0rs>>>);\n //         StorageLive(_7);\n //         StorageLive(_8);\n //         StorageLive(_9);\n-//         _9 = &'35_0rs _2;\n-//         _8 = &'35_0rs (*_9);\n-//         _7 = std::option::Option<&'35_0rs S<'35_0rs>>::Some(move _8,);\n+//         _9 = &'36_0rs _2;\n+//         _8 = &'36_0rs (*_9);\n+//         _7 = std::option::Option<&'36_0rs S<'36_0rs>>::Some(move _8,);\n //         StorageDead(_8);\n //         _5 = const <std::cell::Cell<T>>::set(move _6, move _7) -> [return: bb5, unwind: bb3];\n //     }\n //     bb5: {\n-//         EndRegion('16s);\n+//         EndRegion('17s);\n //         StorageDead(_7);\n //         StorageDead(_6);\n //         StorageDead(_9);\n@@ -108,31 +108,31 @@ fn query() -> bool { true }\n //     bb7: {\n //         _0 = ();\n //         StorageDead(_11);\n-//         EndRegion('35_0rs);\n+//         EndRegion('36_0rs);\n //         StorageDead(_2);\n //         return;\n //     }\n //     bb8: {\n //         _10 = ();\n //         StorageDead(_11);\n //         StorageLive(_14);\n-//         _14 = &'33s (_2.0: std::cell::Cell<std::option::Option<&'35_0rs S<'35_0rs>>>);\n+//         _14 = &'34s (_2.0: std::cell::Cell<std::option::Option<&'36_0rs S<'36_0rs>>>);\n //         StorageLive(_15);\n //         StorageLive(_16);\n //         StorageLive(_17);\n-//         _17 = &'35_0rs _2;\n-//         _16 = &'35_0rs (*_17);\n-//         _15 = std::option::Option<&'35_0rs S<'35_0rs>>::Some(move _16,);\n+//         _17 = &'36_0rs _2;\n+//         _16 = &'36_0rs (*_17);\n+//         _15 = std::option::Option<&'36_0rs S<'36_0rs>>::Some(move _16,);\n //         StorageDead(_16);\n //         _13 = const <std::cell::Cell<T>>::set(move _14, move _15) -> [return: bb9, unwind: bb3];\n //     }\n //     bb9: {\n-//         EndRegion('33s);\n+//         EndRegion('34s);\n //         StorageDead(_15);\n //         StorageDead(_14);\n //         StorageDead(_17);\n //         _1 = ();\n-//         EndRegion('35_0rs);\n+//         EndRegion('36_0rs);\n //         StorageDead(_2);\n //         goto -> bb1;\n //     }"}, {"sha": "79645bd36000a66cdfff2eadb8f4716631a71cbb", "filename": "src/test/mir-opt/validate_3.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -29,34 +29,46 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.EraseRegions.after.mir\n-// fn main() -> () {\n-//     ...\n+// fn main() -> (){\n+//     let mut _0: ();\n+//     scope 1 {\n+//         let _1: Test;\n+//         scope 3 {\n+//             let _2: &ReErased Test;\n+//         }\n+//         scope 4 {\n+//         }\n+//     }\n+//     scope 2 {\n+//     }\n+//     let mut _3: ();\n+//     let mut _4: &ReErased i32;\n //     let mut _5: &ReErased i32;\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = Test { x: const 0i32 };\n //         StorageLive(_2);\n-//         Validate(Suspend(ReScope(Remainder(BlockRemainder { block: ItemLocalId(19), first_statement_index: 3 }))), [_1: Test]);\n+//         Validate(Suspend(ReScope(Remainder(BlockRemainder { block: ItemLocalId(20), first_statement_index: 3 }))), [_1: Test]);\n //         _2 = &ReErased _1;\n-//         Validate(Acquire, [(*_2): Test/ReScope(Remainder(BlockRemainder { block: ItemLocalId(19), first_statement_index: 3 })) (imm)]);\n+//         Validate(Acquire, [(*_2): Test/ReScope(Remainder(BlockRemainder { block: ItemLocalId(20), first_statement_index: 3 })) (imm)]);\n //         StorageLive(_4);\n //         StorageLive(_5);\n-//         Validate(Suspend(ReScope(Node(ItemLocalId(17)))), [((*_2).0: i32): i32/ReScope(Remainder(BlockRemainder { block: ItemLocalId(19), first_statement_index: 3 })) (imm)]);\n+//         Validate(Suspend(ReScope(Node(ItemLocalId(18)))), [((*_2).0: i32): i32/ReScope(Remainder(BlockRemainder { block: ItemLocalId(20), first_statement_index: 3 })) (imm)]);\n //         _5 = &ReErased ((*_2).0: i32);\n-//         Validate(Acquire, [(*_5): i32/ReScope(Node(ItemLocalId(17))) (imm)]);\n-//         Validate(Suspend(ReScope(Node(ItemLocalId(17)))), [(*_5): i32/ReScope(Node(ItemLocalId(17))) (imm)]);\n+//         Validate(Acquire, [(*_5): i32/ReScope(Node(ItemLocalId(18))) (imm)]);\n+//         Validate(Suspend(ReScope(Node(ItemLocalId(18)))), [(*_5): i32/ReScope(Node(ItemLocalId(18))) (imm)]);\n //         _4 = &ReErased (*_5);\n-//         Validate(Acquire, [(*_4): i32/ReScope(Node(ItemLocalId(17))) (imm)]);\n-//         Validate(Release, [_3: (), _4: &ReScope(Node(ItemLocalId(17))) i32]);\n+//         Validate(Acquire, [(*_4): i32/ReScope(Node(ItemLocalId(18))) (imm)]);\n+//         Validate(Release, [_3: (), _4: &ReScope(Node(ItemLocalId(18))) i32]);\n //         _3 = const foo(move _4) -> bb1;\n //     }\n //     bb1: {\n //         Validate(Acquire, [_3: ()]);\n-//         EndRegion(ReScope(Node(ItemLocalId(17))));\n+//         EndRegion(ReScope(Node(ItemLocalId(18))));\n //         StorageDead(_4);\n //         StorageDead(_5);\n //         _0 = ();\n-//         EndRegion(ReScope(Remainder(BlockRemainder { block: ItemLocalId(19), first_statement_index: 3 })));\n+//         EndRegion(ReScope(Remainder(BlockRemainder { block: ItemLocalId(20), first_statement_index: 3 })));\n //         StorageDead(_2);\n //         StorageDead(_1);\n //         return;"}, {"sha": "dd793b29febef4a063f63a5b81d5639c119ca517", "filename": "src/test/ui/error-codes/E0609.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Ferror-codes%2FE0609.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Ferror-codes%2FE0609.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0609.stderr?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -7,10 +7,10 @@ LL |     let _ = x.foo; //~ ERROR E0609\n    = note: available fields are: `x`\n \n error[E0609]: no field `1` on type `Bar`\n-  --> $DIR/E0609.rs:21:5\n+  --> $DIR/E0609.rs:21:7\n    |\n LL |     y.1; //~ ERROR E0609\n-   |     ^^^\n+   |       ^ unknown field\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c4b86e76c14e49039e54047e0547d64b9105e0a2", "filename": "src/test/ui/error-codes/E0611.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Ferror-codes%2FE0611.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Ferror-codes%2FE0611.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0611.stderr?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -1,9 +0,0 @@\n-error[E0611]: field `0` of tuple-struct `a::Foo` is private\n-  --> $DIR/E0611.rs:21:4\n-   |\n-LL |    y.0; //~ ERROR E0611\n-   |    ^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0611`."}, {"sha": "18013697a83384cdd2557a8ebd3a308db63b7b87", "filename": "src/test/ui/error-codes/E0612.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Ferror-codes%2FE0612.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Ferror-codes%2FE0612.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0612.stderr?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -1,9 +0,0 @@\n-error[E0612]: attempted out-of-bounds tuple index `1` on type `Foo`\n-  --> $DIR/E0612.rs:15:4\n-   |\n-LL |    y.1; //~ ERROR E0612\n-   |    ^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0612`."}, {"sha": "4e580242e641e4432348c09f597599344be98682", "filename": "src/test/ui/error-codes/ex-E0611.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0611.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0611.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0611.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -18,5 +18,5 @@ mod a {\n \n fn main() {\n    let y = a::Foo::new();\n-   y.0; //~ ERROR E0611\n+   y.0; //~ ERROR field `0` of struct `a::Foo` is private\n }", "previous_filename": "src/test/ui/error-codes/E0611.rs"}, {"sha": "2f5066542db76f9d384947075b268800b50a4d33", "filename": "src/test/ui/error-codes/ex-E0611.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0611.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0611.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0611.stderr?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -0,0 +1,9 @@\n+error[E0616]: field `0` of struct `a::Foo` is private\n+  --> $DIR/ex-E0611.rs:21:4\n+   |\n+LL |    y.0; //~ ERROR field `0` of struct `a::Foo` is private\n+   |    ^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0616`."}, {"sha": "46e26c87e5f340321a00385771fc094f6c2c090d", "filename": "src/test/ui/error-codes/ex-E0612.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0612.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0612.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0612.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -12,5 +12,5 @@ struct Foo(u32);\n \n fn main() {\n    let y = Foo(0);\n-   y.1; //~ ERROR E0612\n+   y.1; //~ ERROR no field `1` on type `Foo`\n }", "previous_filename": "src/test/ui/error-codes/E0612.rs"}, {"sha": "a07efc939ab470d0b7325fbd352ac1fa8287f6dd", "filename": "src/test/ui/error-codes/ex-E0612.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0612.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0612.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0612.stderr?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -0,0 +1,9 @@\n+error[E0609]: no field `1` on type `Foo`\n+  --> $DIR/ex-E0612.rs:15:6\n+   |\n+LL |    y.1; //~ ERROR no field `1` on type `Foo`\n+   |      ^ did you mean `0`?\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0609`."}, {"sha": "e336b0df13fea71336343756b130dfef66d88645", "filename": "src/test/ui/hygiene/assoc_item_ctxt.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fassoc_item_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fassoc_item_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fassoc_item_ctxt.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "previous_filename": "src/test/compile-fail/hygiene/assoc_item_ctxt.rs"}, {"sha": "8b410405ae5ca59891a4ebe56932825c0d9bf729", "filename": "src/test/ui/hygiene/assoc_item_ctxt.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fassoc_item_ctxt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fassoc_item_ctxt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fassoc_item_ctxt.stderr?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -0,0 +1,25 @@\n+error[E0407]: method `method` is not a member of trait `Tr`\n+  --> $DIR/assoc_item_ctxt.rs:45:13\n+   |\n+LL |             fn method() {} //~ ERROR method `method` is not a member of trait `Tr`\n+   |             ^^^^^^^^^^^^^^ not a member of trait `Tr`\n+...\n+LL |     mac_trait_impl!();\n+   |     ------------------ in this macro invocation\n+\n+error[E0046]: not all trait items implemented, missing: `method`\n+  --> $DIR/assoc_item_ctxt.rs:44:9\n+   |\n+LL |         fn method();\n+   |         ------------ `method` from trait\n+...\n+LL |         impl Tr for u8 { //~ ERROR not all trait items implemented, missing: `method`\n+   |         ^^^^^^^^^^^^^^ missing `method` in implementation\n+...\n+LL |     mac_trait_impl!();\n+   |     ------------------ in this macro invocation\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0046, E0407.\n+For more information about an error, try `rustc --explain E0046`."}, {"sha": "46a138749ff176e4e521e60cd22ad2e8ece949dd", "filename": "src/test/ui/hygiene/assoc_ty_bindings.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fassoc_ty_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fassoc_ty_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fassoc_ty_bindings.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "previous_filename": "src/test/compile-fail/hygiene/assoc_ty_bindings.rs"}, {"sha": "0adf80994f7fc63f0bdff42829f3307139c3a177", "filename": "src/test/ui/hygiene/assoc_ty_bindings.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fassoc_ty_bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fassoc_ty_bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fassoc_ty_bindings.stderr?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -0,0 +1,8 @@\n+error: compilation successful\n+  --> $DIR/assoc_ty_bindings.rs:49:1\n+   |\n+LL | fn main() {} //~ ERROR compilation successful\n+   | ^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "aa67e5c5f4db7bcaf1d43feb2d228b63982cca6e", "filename": "src/test/ui/hygiene/auxiliary/intercrate.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fintercrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fintercrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fintercrate.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "previous_filename": "src/test/compile-fail/hygiene/auxiliary/intercrate.rs"}, {"sha": "c92bf55a72381a9849046356dd4a300d4e67290a", "filename": "src/test/ui/hygiene/fields-definition.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ffields-definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ffields-definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ffields-definition.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(decl_macro)]\n+\n+macro modern($a: ident) {\n+    struct Modern {\n+        a: u8,\n+        $a: u8, // OK\n+    }\n+}\n+\n+macro_rules! legacy {\n+    ($a: ident) => {\n+        struct Legacy {\n+            a: u8,\n+            $a: u8, //~ ERROR field `a` is already declared\n+        }\n+    }\n+}\n+\n+modern!(a);\n+legacy!(a);\n+\n+fn main() {}"}, {"sha": "73f524b7d2a7f03e27e1e27c5fd908d4acff4e82", "filename": "src/test/ui/hygiene/fields-definition.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ffields-definition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ffields-definition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ffields-definition.stderr?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -0,0 +1,14 @@\n+error[E0124]: field `a` is already declared\n+  --> $DIR/fields-definition.rs:24:17\n+   |\n+LL |             a: u8,\n+   |             ----- `a` first declared here\n+LL |             $a: u8, //~ ERROR field `a` is already declared\n+   |                 ^^ field already declared\n+...\n+LL | legacy!(a);\n+   | ----------- in this macro invocation\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0124`."}, {"sha": "a6e3b2b2d8b474fbf5fdf474dfdbb855db6ac2f1", "filename": "src/test/ui/hygiene/fields-move.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ffields-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ffields-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ffields-move.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// issue #46314\n+\n+#![feature(decl_macro)]\n+\n+#[derive(Debug)]\n+struct NonCopy(String);\n+\n+struct Foo {\n+    x: NonCopy,\n+}\n+\n+macro copy_modern($foo: ident) {\n+   $foo.x\n+}\n+\n+macro_rules! copy_legacy {\n+    ($foo: ident) => {\n+        $foo.x //~ ERROR use of moved value: `foo.x`\n+    }\n+}\n+\n+fn assert_two_copies(a: NonCopy, b: NonCopy) {\n+   println!(\"Got two copies: {:?}, {:?}\", a, b);\n+}\n+\n+fn main() {\n+    let foo = Foo { x: NonCopy(\"foo\".into()) };\n+    assert_two_copies(copy_modern!(foo), foo.x); //~ ERROR use of moved value: `foo.x`\n+    assert_two_copies(copy_legacy!(foo), foo.x); //~ ERROR use of moved value: `foo.x`\n+}"}, {"sha": "ba9de09f9d2f1f02c3f9384d6be4560e504e1a94", "filename": "src/test/ui/hygiene/fields-move.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ffields-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ffields-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ffields-move.stderr?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -0,0 +1,39 @@\n+error[E0382]: use of moved value: `foo.x`\n+  --> $DIR/fields-move.rs:38:42\n+   |\n+LL |    $foo.x\n+   |    ------ value moved here\n+...\n+LL |     assert_two_copies(copy_modern!(foo), foo.x); //~ ERROR use of moved value: `foo.x`\n+   |                                          ^^^^^ value used here after move\n+   |\n+   = note: move occurs because `foo.x` has type `NonCopy`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `foo.x`\n+  --> $DIR/fields-move.rs:28:9\n+   |\n+LL |    $foo.x\n+   |    ------ value moved here\n+...\n+LL |         $foo.x //~ ERROR use of moved value: `foo.x`\n+   |         ^^^^^^ value used here after move\n+...\n+LL |     assert_two_copies(copy_legacy!(foo), foo.x); //~ ERROR use of moved value: `foo.x`\n+   |                       ----------------- in this macro invocation\n+   |\n+   = note: move occurs because `foo.x` has type `NonCopy`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `foo.x`\n+  --> $DIR/fields-move.rs:39:42\n+   |\n+LL |    $foo.x\n+   |    ------ value moved here\n+...\n+LL |     assert_two_copies(copy_legacy!(foo), foo.x); //~ ERROR use of moved value: `foo.x`\n+   |                                          ^^^^^ value used here after move\n+   |\n+   = note: move occurs because `foo.x` has type `NonCopy`, which does not implement the `Copy` trait\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "50ace39e70939cf88c222c4a00e0bfbec33dbf07", "filename": "src/test/ui/hygiene/fields-numeric-borrowck.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ffields-numeric-borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ffields-numeric-borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ffields-numeric-borrowck.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S(u8);\n+\n+fn main() {\n+    let mut s = S(0);\n+    let borrow1 = &mut s.0;\n+    let S { 0: ref mut borrow2 } = s;\n+    //~^ ERROR cannot borrow `s.0` as mutable more than once at a time\n+}"}, {"sha": "ccd898fff27b7df54837f952fe4cf08810c431cf", "filename": "src/test/ui/hygiene/fields-numeric-borrowck.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ffields-numeric-borrowck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ffields-numeric-borrowck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ffields-numeric-borrowck.stderr?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -0,0 +1,14 @@\n+error[E0499]: cannot borrow `s.0` as mutable more than once at a time\n+  --> $DIR/fields-numeric-borrowck.rs:16:16\n+   |\n+LL |     let borrow1 = &mut s.0;\n+   |                        --- first mutable borrow occurs here\n+LL |     let S { 0: ref mut borrow2 } = s;\n+   |                ^^^^^^^^^^^^^^^ second mutable borrow occurs here\n+LL |     //~^ ERROR cannot borrow `s.0` as mutable more than once at a time\n+LL | }\n+   | - first borrow ends here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0499`."}, {"sha": "64217770b13c9ad278b1381f4697ba86dde7e3ec", "filename": "src/test/ui/hygiene/fields.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ffields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ffields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ffields.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "previous_filename": "src/test/compile-fail/hygiene/fields.rs"}, {"sha": "c4be1834c04f8d60fa262e1e56b4ea7a93c197e2", "filename": "src/test/ui/hygiene/fields.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ffields.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ffields.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ffields.stderr?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -0,0 +1,38 @@\n+error: type `foo::S` is private\n+  --> $DIR/fields.rs:25:17\n+   |\n+LL |         let s = S { x: 0 }; //~ ERROR type `foo::S` is private\n+   |                 ^^^^^^^^^^\n+...\n+LL |     let s = foo::m!(S, x);\n+   |             ------------- in this macro invocation\n+\n+error: type `foo::S` is private\n+  --> $DIR/fields.rs:26:17\n+   |\n+LL |         let _ = s.x; //~ ERROR type `foo::S` is private\n+   |                 ^\n+...\n+LL |     let s = foo::m!(S, x);\n+   |             ------------- in this macro invocation\n+\n+error: type `foo::T` is private\n+  --> $DIR/fields.rs:28:17\n+   |\n+LL |         let t = T(0); //~ ERROR type `foo::T` is private\n+   |                 ^^^^\n+...\n+LL |     let s = foo::m!(S, x);\n+   |             ------------- in this macro invocation\n+\n+error: type `foo::T` is private\n+  --> $DIR/fields.rs:29:17\n+   |\n+LL |         let _ = t.0; //~ ERROR type `foo::T` is private\n+   |                 ^\n+...\n+LL |     let s = foo::m!(S, x);\n+   |             ------------- in this macro invocation\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "d938642197092a8c432793af3a7455eb09b08260", "filename": "src/test/ui/hygiene/for-loop.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ffor-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ffor-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ffor-loop.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "previous_filename": "src/test/compile-fail/for-loop-hygiene.rs"}, {"sha": "7e606b2358c142768fa57933ff7cb1fe7138face", "filename": "src/test/ui/hygiene/for-loop.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ffor-loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ffor-loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ffor-loop.stderr?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -0,0 +1,9 @@\n+error[E0425]: cannot find value `iter` in this scope\n+  --> $DIR/for-loop.rs:16:9\n+   |\n+LL |         iter.next();  //~ ERROR cannot find value `iter` in this scope\n+   |         ^^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "7ba217061c66ee986911556a844bc7a0a52b94a0", "filename": "src/test/ui/hygiene/globs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fglobs.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "previous_filename": "src/test/compile-fail/hygiene/globs.rs"}, {"sha": "d77242e135ddec03b20fcf351460d2385ceffd61", "filename": "src/test/ui/hygiene/globs.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fglobs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fglobs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fglobs.stderr?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -0,0 +1,49 @@\n+error[E0425]: cannot find function `f` in this scope\n+  --> $DIR/globs.rs:32:9\n+   |\n+LL |         f(); //~ ERROR cannot find function `f` in this scope\n+   |         ^ not found in this scope\n+help: possible candidates are found in other modules, you can import them into scope\n+   |\n+LL | use foo::f;\n+   |\n+LL | use foo::f;\n+   |\n+LL | use foo::f;\n+   |\n+\n+error[E0425]: cannot find function `g` in this scope\n+  --> $DIR/globs.rs:25:5\n+   |\n+LL |       g(); //~ ERROR cannot find function `g` in this scope\n+   |       ^ not found in this scope\n+...\n+LL | /     m! {\n+LL | |         use bar::*;\n+LL | |         g();\n+LL | |         f(); //~ ERROR cannot find function `f` in this scope\n+LL | |     }\n+   | |_____- in this macro invocation\n+help: possible candidates are found in other modules, you can import them into scope\n+   |\n+LL | use bar::g;\n+   |\n+LL | use foo::test2::test::g;\n+   |\n+LL | use foo::test::g;\n+   |\n+LL | use foo::test::g;\n+   |\n+\n+error[E0425]: cannot find function `f` in this scope\n+  --> $DIR/globs.rs:64:17\n+   |\n+LL | n!(f);\n+   | ------ in this macro invocation\n+...\n+LL |                 f //~ ERROR cannot find function `f` in this scope\n+   |                 ^ not found in this scope\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "cdba559445d195be1a4636a496ed0b57fa8467b0", "filename": "src/test/ui/hygiene/impl_items.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fimpl_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fimpl_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fimpl_items.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "previous_filename": "src/test/compile-fail/hygiene/impl_items.rs"}, {"sha": "dbcf53554cf258896736ff8f44eaa7dab70cb62e", "filename": "src/test/ui/hygiene/impl_items.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fimpl_items.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fimpl_items.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fimpl_items.stderr?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -0,0 +1,11 @@\n+error: type `for<'r> fn(&'r foo::S) {foo::S::f}` is private\n+  --> $DIR/impl_items.rs:22:23\n+   |\n+LL |         let _: () = S.f(); //~ ERROR type `for<'r> fn(&'r foo::S) {foo::S::f}` is private\n+   |                       ^\n+...\n+LL |     foo::m!();\n+   |     ---------- in this macro invocation\n+\n+error: aborting due to previous error\n+"}, {"sha": "50fc985ba34faea982f93aa51efb5f468af4f073", "filename": "src/test/ui/hygiene/intercrate.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fintercrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fintercrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fintercrate.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "previous_filename": "src/test/compile-fail/hygiene/intercrate.rs"}, {"sha": "ecbc6e7b1472c29b8127297ba7cbae373548fbd9", "filename": "src/test/ui/hygiene/intercrate.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fintercrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fintercrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fintercrate.stderr?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -0,0 +1,10 @@\n+error: type `fn() -> u32 {intercrate::foo::bar::f}` is private\n+  --> $DIR/intercrate.rs:22:16\n+   |\n+LL |     assert_eq!(intercrate::foo::m!(), 1);\n+   |                ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}, {"sha": "6612359649c194cd660655ff18126b038db90ebd", "filename": "src/test/ui/hygiene/nested_macro_privacy.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fnested_macro_privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fnested_macro_privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fnested_macro_privacy.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "previous_filename": "src/test/compile-fail/hygiene/nested_macro_privacy.rs"}, {"sha": "1179065b94cd8a99ab95b6bc951ff39a352a6f45", "filename": "src/test/ui/hygiene/nested_macro_privacy.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fnested_macro_privacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fnested_macro_privacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fnested_macro_privacy.stderr?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -0,0 +1,9 @@\n+error[E0616]: field `i` of struct `foo::S` is private\n+  --> $DIR/nested_macro_privacy.rs:25:5\n+   |\n+LL |     S::default().i; //~ ERROR field `i` of struct `foo::S` is private\n+   |     ^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0616`."}, {"sha": "c90c7b3093c9f0e5d04a15371b082d4cf05dbf38", "filename": "src/test/ui/hygiene/no_implicit_prelude.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "previous_filename": "src/test/compile-fail/hygiene/no_implicit_prelude.rs"}, {"sha": "5753d1a32f74fc864cb0c8a6fbe21c32889ce0f6", "filename": "src/test/ui/hygiene/no_implicit_prelude.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -0,0 +1,30 @@\n+error[E0433]: failed to resolve. Use of undeclared type or module `Vec`\n+  --> $DIR/no_implicit_prelude.rs:21:9\n+   |\n+LL |     fn f() { ::bar::m!(); }\n+   |              ------------ in this macro invocation\n+...\n+LL |         Vec::new(); //~ ERROR failed to resolve\n+   |         ^^^ Use of undeclared type or module `Vec`\n+\n+error[E0601]: `main` function not found in crate `no_implicit_prelude`\n+   |\n+   = note: consider adding a `main` function to `$DIR/no_implicit_prelude.rs`\n+\n+error[E0599]: no method named `clone` found for type `()` in the current scope\n+  --> $DIR/no_implicit_prelude.rs:22:12\n+   |\n+LL |     fn f() { ::bar::m!(); }\n+   |              ------------ in this macro invocation\n+...\n+LL |         ().clone() //~ ERROR no method named `clone` found\n+   |            ^^^^^\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+   = note: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+           candidate #1: `use std::clone::Clone;`\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors occurred: E0433, E0599, E0601.\n+For more information about an error, try `rustc --explain E0433`."}, {"sha": "26d411c915482bdd89dcd78b20ead5376abd075e", "filename": "src/test/ui/hygiene/pattern-macro.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fpattern-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fpattern-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fpattern-macro.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "previous_filename": "src/test/compile-fail/pattern-macro-hygiene.rs"}, {"sha": "b26084db02e966ec2709fd5cd15829ed6864fa4e", "filename": "src/test/ui/hygiene/pattern-macro.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fpattern-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fpattern-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fpattern-macro.stderr?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -0,0 +1,9 @@\n+error[E0425]: cannot find value `x` in this scope\n+  --> $DIR/pattern-macro.rs:15:5\n+   |\n+LL |     x + 1; //~ ERROR cannot find value `x` in this scope\n+   |     ^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "987cad187d428c7dcf719df625bc4ec736a3f755", "filename": "src/test/ui/hygiene/privacy.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fprivacy.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "previous_filename": "src/test/compile-fail/hygiene/privacy.rs"}, {"sha": "808d244e9cdb6ae485958ee0f9454590ffa74069", "filename": "src/test/ui/hygiene/privacy.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fprivacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Fprivacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fprivacy.stderr?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -0,0 +1,9 @@\n+error[E0603]: function `f` is private\n+  --> $DIR/privacy.rs:26:9\n+   |\n+LL |         foo::f() //~ ERROR `f` is private\n+   |         ^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0603`."}, {"sha": "3bd19cbc0ac67cbf48b4138d0118a906bc799d05", "filename": "src/test/ui/hygiene/trait_items.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ftrait_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ftrait_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ftrait_items.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "previous_filename": "src/test/compile-fail/hygiene/trait_items.rs"}, {"sha": "56d9c585d6f85e2a86b4f4fd824f84571ca18eab", "filename": "src/test/ui/hygiene/trait_items.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ftrait_items.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fhygiene%2Ftrait_items.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ftrait_items.stderr?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -0,0 +1,16 @@\n+error[E0599]: no method named `f` found for type `()` in the current scope\n+  --> $DIR/trait_items.rs:27:24\n+   |\n+LL |     fn f() { ::baz::m!(); }\n+   |              ------------ in this macro invocation\n+...\n+LL |     pub macro m() { ().f() } //~ ERROR no method named `f` found for type `()` in the current scope\n+   |                        ^\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+   = note: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+           candidate #1: `use foo::T;`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "c59a9bc4170bd51a6691eee676de73a8702f3fea", "filename": "src/test/ui/issue-47073-zero-padded-tuple-struct-indices.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fissue-47073-zero-padded-tuple-struct-indices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fissue-47073-zero-padded-tuple-struct-indices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-47073-zero-padded-tuple-struct-indices.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -16,7 +16,7 @@ struct Verdict(Guilty, Option<FineDollars>);\n fn main() {\n     let justice = Verdict(true, Some(2718));\n     let _condemned = justice.00;\n-    //~^ ERROR invalid tuple or struct index\n+    //~^ ERROR no field `00` on type `Verdict`\n     let _punishment = justice.001;\n-    //~^ ERROR invalid tuple or struct index\n+    //~^ ERROR no field `001` on type `Verdict`\n }"}, {"sha": "4a1c9b554a9319adcbecfe5f4584b1e122a72aaa", "filename": "src/test/ui/issue-47073-zero-padded-tuple-struct-indices.stderr", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fissue-47073-zero-padded-tuple-struct-indices.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fissue-47073-zero-padded-tuple-struct-indices.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-47073-zero-padded-tuple-struct-indices.stderr?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -1,14 +1,17 @@\n-error: invalid tuple or struct index\n+error[E0609]: no field `00` on type `Verdict`\n   --> $DIR/issue-47073-zero-padded-tuple-struct-indices.rs:18:30\n    |\n LL |     let _condemned = justice.00;\n-   |                              ^^ help: try simplifying the index: `0`\n+   |                              ^^ did you mean `0`?\n \n-error: invalid tuple or struct index\n+error[E0609]: no field `001` on type `Verdict`\n   --> $DIR/issue-47073-zero-padded-tuple-struct-indices.rs:20:31\n    |\n LL |     let _punishment = justice.001;\n-   |                               ^^^ help: try simplifying the index: `1`\n+   |                               ^^^ unknown field\n+   |\n+   = note: available fields are: `0`, `1`\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0609`."}, {"sha": "bff64ad489210a0f1fd33f55194da91921c86624", "filename": "src/test/ui/macros/macro-backtrace-invalid-internals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.rs?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -24,7 +24,7 @@ macro_rules! fake_field_stmt {\n \n macro_rules! fake_anon_field_stmt {\n      () => {\n-          (1).0 //~ ERROR no field\n+          (1).0 //~ ERROR doesn't have fields\n      }\n }\n \n@@ -42,7 +42,7 @@ macro_rules! fake_field_expr {\n \n macro_rules! fake_anon_field_expr {\n      () => {\n-          (1).0 //~ ERROR no field\n+          (1).0 //~ ERROR doesn't have fields\n      }\n }\n "}, {"sha": "cb7d422b7f3ed73d3d82339b572cd4fc9dd2cc20", "filename": "src/test/ui/macros/macro-backtrace-invalid-internals.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/defcfe7142fca424f7e34aa5c789239e9e9fcfe8/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.stderr?ref=defcfe7142fca424f7e34aa5c789239e9e9fcfe8", "patch": "@@ -16,11 +16,11 @@ LL |           1.fake //~ ERROR doesn't have fields\n LL |     fake_field_stmt!();\n    |     ------------------- in this macro invocation\n \n-error[E0609]: no field `0` on type `{integer}`\n-  --> $DIR/macro-backtrace-invalid-internals.rs:27:11\n+error[E0610]: `{integer}` is a primitive type and therefore doesn't have fields\n+  --> $DIR/macro-backtrace-invalid-internals.rs:27:15\n    |\n-LL |           (1).0 //~ ERROR no field\n-   |           ^^^^^\n+LL |           (1).0 //~ ERROR doesn't have fields\n+   |               ^\n ...\n LL |     fake_anon_field_stmt!();\n    |     ------------------------ in this macro invocation\n@@ -56,11 +56,11 @@ LL |           1.fake //~ ERROR doesn't have fields\n LL |     let _ = fake_field_expr!();\n    |             ------------------ in this macro invocation\n \n-error[E0609]: no field `0` on type `{integer}`\n-  --> $DIR/macro-backtrace-invalid-internals.rs:45:11\n+error[E0610]: `{integer}` is a primitive type and therefore doesn't have fields\n+  --> $DIR/macro-backtrace-invalid-internals.rs:45:15\n    |\n-LL |           (1).0 //~ ERROR no field\n-   |           ^^^^^\n+LL |           (1).0 //~ ERROR doesn't have fields\n+   |               ^\n ...\n LL |     let _ = fake_anon_field_expr!();\n    |             ----------------------- in this macro invocation\n@@ -80,5 +80,5 @@ LL |           2.0_f32.powi(2) //~ ERROR can't call method `powi` on ambiguous n\n \n error: aborting due to 8 previous errors\n \n-Some errors occurred: E0599, E0609, E0610, E0689.\n+Some errors occurred: E0599, E0610, E0689.\n For more information about an error, try `rustc --explain E0599`."}]}