{"sha": "c1132434a7cf580a09d08a274bbfd2e776b324f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxMTMyNDM0YTdjZjU4MGEwOWQwOGEyNzRiYmZkMmU3NzZiMzI0Zjg=", "commit": {"author": {"name": "ThibsG", "email": "Thibs@debian.com", "date": "2020-01-26T18:48:30Z"}, "committer": {"name": "ThibsG", "email": "Thibs@debian.com", "date": "2020-04-15T15:18:12Z"}, "message": "Report using stmts and expr + tests", "tree": {"sha": "d2a15da2708d4e2cc7d5c2087aa25cd5b9694ef6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2a15da2708d4e2cc7d5c2087aa25cd5b9694ef6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1132434a7cf580a09d08a274bbfd2e776b324f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1132434a7cf580a09d08a274bbfd2e776b324f8", "html_url": "https://github.com/rust-lang/rust/commit/c1132434a7cf580a09d08a274bbfd2e776b324f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1132434a7cf580a09d08a274bbfd2e776b324f8/comments", "author": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b4ab827469529f4eda5f1e9492abcb9ad9d209a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b4ab827469529f4eda5f1e9492abcb9ad9d209a", "html_url": "https://github.com/rust-lang/rust/commit/6b4ab827469529f4eda5f1e9492abcb9ad9d209a"}], "stats": {"total": 216, "additions": 148, "deletions": 68}, "files": [{"sha": "9022617ebfc17a556e28892bee2e05cfd409ae8b", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 100, "deletions": 38, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/c1132434a7cf580a09d08a274bbfd2e776b324f8/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1132434a7cf580a09d08a274bbfd2e776b324f8/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=c1132434a7cf580a09d08a274bbfd2e776b324f8", "patch": "@@ -1,9 +1,11 @@\n-use rustc_hir::{Expr, ExprKind, QPath};\n+use crate::utils::{get_parent_expr, method_calls, snippet, span_lint_and_sugg};\n+use if_chain::if_chain;\n use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::{Expr, ExprKind, QPath, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_tool_lint, declare_lint_pass};\n-use crate::utils::{in_macro, span_lint_and_sugg};\n-use if_chain::if_chain;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for explicit `deref()` or `deref_mut()` method calls.\n@@ -21,7 +23,7 @@ declare_clippy_lint! {\n     /// let b = &*a;\n     /// let c = &mut *a;\n     /// ```\n-    /// \n+    ///\n     /// This lint excludes\n     /// ```rust\n     /// let e = d.unwrap().deref();\n@@ -36,45 +38,105 @@ declare_lint_pass!(Dereferencing => [\n ]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Dereferencing {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n-        if in_macro(expr.span) {\n-            return;\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx hir::Stmt<'_>) {\n+        if_chain! {\n+            if let StmtKind::Local(ref local) = stmt.kind;\n+            if let Some(ref init) = local.init;\n+\n+            then {\n+                match init.kind {\n+                    ExprKind::Call(ref _method, args) => {\n+                        for arg in args {\n+                            if_chain! {\n+                                // Caller must call only one other function (deref or deref_mut)\n+                                // otherwise it can lead to error prone suggestions (ex: &*a.len())\n+                                let (method_names, arg_list, _) = method_calls(arg, 2);\n+                                if method_names.len() == 1;\n+                                // Caller must be a variable\n+                                let variables = arg_list[0];\n+                                if variables.len() == 1;\n+                                if let ExprKind::Path(QPath::Resolved(None, _)) = variables[0].kind;\n+\n+                                then {\n+                                    let name = method_names[0].as_str();\n+                                    lint_deref(cx, &*name, variables[0].span, arg.span);\n+                                }\n+                            }\n+                        }\n+                    }\n+                    ExprKind::MethodCall(ref method_name, _, ref args) => {\n+                        if init.span.from_expansion() {\n+                            return;\n+                        }\n+                        if_chain! {\n+                            if args.len() == 1;\n+                            if let ExprKind::Path(QPath::Resolved(None, _)) = args[0].kind;\n+                            // Caller must call only one other function (deref or deref_mut)\n+                            // otherwise it can lead to error prone suggestions (ex: &*a.len())\n+                            let (method_names, arg_list, _) = method_calls(init, 2);\n+                            if method_names.len() == 1;\n+                            // Caller must be a variable\n+                            let variables = arg_list[0];\n+                            if variables.len() == 1;\n+                            if let ExprKind::Path(QPath::Resolved(None, _)) = variables[0].kind;\n+\n+                            then {\n+                                let name = method_name.ident.as_str();\n+                                lint_deref(cx, &*name, args[0].span, init.span);\n+                            }\n+                        }\n+                    }\n+                    _ => ()\n+                }\n+            }\n         }\n+    }\n \n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            // if this is a method call\n             if let ExprKind::MethodCall(ref method_name, _, ref args) = &expr.kind;\n-            // on a Path (i.e. a variable/name, not another method)\n-            if let ExprKind::Path(QPath::Resolved(None, path)) = &args[0].kind;\n+            if args.len() == 1;\n+            if let Some(parent) = get_parent_expr(cx, &expr);\n+\n             then {\n-                let name = method_name.ident.as_str();\n-                // alter help slightly to account for _mut\n-                match &*name {\n-                    \"deref\" => {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            EXPLICIT_DEREF_METHOD,\n-                            expr.span,\n-                            \"explicit deref method call\",\n-                            \"try this\",\n-                            format!(\"&*{}\", path),\n-                            Applicability::MachineApplicable\n-                        );\n-                    },\n-                    \"deref_mut\" => {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            EXPLICIT_DEREF_METHOD,\n-                            expr.span,\n-                            \"explicit deref_mut method call\",\n-                            \"try this\",\n-                            format!(\"&mut *{}\", path),\n-                            Applicability::MachineApplicable\n-                        );\n-                    },\n-                    _ => ()\n-                };\n+                // Call and MethodCall exprs are better reported using statements\n+                match parent.kind {\n+                    ExprKind::Call(_, _) => return,\n+                    ExprKind::MethodCall(_, _, _) => return,\n+                    _ => {\n+                        let name = method_name.ident.as_str();\n+                        lint_deref(cx, &*name, args[0].span, expr.span);\n+                    }\n+                }\n             }\n         }\n     }\n }\n+\n+fn lint_deref(cx: &LateContext<'_, '_>, fn_name: &str, var_span: Span, expr_span: Span) {\n+    match fn_name {\n+        \"deref\" => {\n+            span_lint_and_sugg(\n+                cx,\n+                EXPLICIT_DEREF_METHOD,\n+                expr_span,\n+                \"explicit deref method call\",\n+                \"try this\",\n+                format!(\"&*{}\", &snippet(cx, var_span, \"..\")),\n+                Applicability::MachineApplicable,\n+            );\n+        },\n+        \"deref_mut\" => {\n+            span_lint_and_sugg(\n+                cx,\n+                EXPLICIT_DEREF_METHOD,\n+                expr_span,\n+                \"explicit deref_mut method call\",\n+                \"try this\",\n+                format!(\"&mut *{}\", &snippet(cx, var_span, \"..\")),\n+                Applicability::MachineApplicable,\n+            );\n+        },\n+        _ => (),\n+    }\n+}"}, {"sha": "5de201fb22f0b6e56f7d4cef0723906b50efae2e", "filename": "tests/ui/dereference.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c1132434a7cf580a09d08a274bbfd2e776b324f8/tests%2Fui%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1132434a7cf580a09d08a274bbfd2e776b324f8/tests%2Fui%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdereference.rs?ref=c1132434a7cf580a09d08a274bbfd2e776b324f8", "patch": "@@ -3,28 +3,49 @@\n \n use std::ops::{Deref, DerefMut};\n \n+fn concat(deref_str: &str) -> String {\n+    format!(\"{}bar\", deref_str)\n+}\n+\n+fn just_return(deref_str: &str) -> &str {\n+    deref_str\n+}\n+\n fn main() {\n     let a: &mut String = &mut String::from(\"foo\");\n \n     // these should require linting\n+\n     let b: &str = a.deref();\n \n     let b: &mut str = a.deref_mut();\n \n+    // both derefs should get linted here\n+    let b: String = format!(\"{}, {}\", a.deref(), a.deref());\n+\n+    println!(\"{}\", a.deref());\n+\n+    #[allow(clippy::match_single_binding)]\n+    match a.deref() {\n+        _ => (),\n+    }\n+\n+    let b: String = concat(a.deref());\n+\n+    // following should not require linting\n+\n+    let b = just_return(a).deref();\n+\n+    let b: String = concat(just_return(a).deref());\n+\n     let b: String = a.deref().clone();\n \n     let b: usize = a.deref_mut().len();\n \n     let b: &usize = &a.deref().len();\n \n-    // only first deref should get linted here\n     let b: &str = a.deref().deref();\n \n-    // both derefs should get linted here\n-    let b: String = format!(\"{}, {}\", a.deref(), a.deref());\n-\n-    // these should not require linting\n-\n     let b: &str = &*a;\n \n     let b: &mut str = &mut *a;\n@@ -35,4 +56,7 @@ fn main() {\n         };\n     }\n     let b: &str = expr_deref!(a);\n+\n+    let opt_a = Some(a);\n+    let b = opt_a.unwrap().deref();\n }"}, {"sha": "7e10add40b180e2ffd73788a4694836760af80b8", "filename": "tests/ui/dereference.stderr", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c1132434a7cf580a09d08a274bbfd2e776b324f8/tests%2Fui%2Fdereference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1132434a7cf580a09d08a274bbfd2e776b324f8/tests%2Fui%2Fdereference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdereference.stderr?ref=c1132434a7cf580a09d08a274bbfd2e776b324f8", "patch": "@@ -1,52 +1,46 @@\n error: explicit deref method call\n-  --> $DIR/dereference.rs:10:19\n+  --> $DIR/dereference.rs:19:19\n    |\n LL |     let b: &str = a.deref();\n    |                   ^^^^^^^^^ help: try this: `&*a`\n    |\n    = note: `-D clippy::explicit-deref-method` implied by `-D warnings`\n \n error: explicit deref_mut method call\n-  --> $DIR/dereference.rs:12:23\n+  --> $DIR/dereference.rs:21:23\n    |\n LL |     let b: &mut str = a.deref_mut();\n    |                       ^^^^^^^^^^^^^ help: try this: `&mut *a`\n \n error: explicit deref method call\n-  --> $DIR/dereference.rs:14:21\n-   |\n-LL |     let b: String = a.deref().clone();\n-   |                     ^^^^^^^^^ help: try this: `&*a`\n-\n-error: explicit deref_mut method call\n-  --> $DIR/dereference.rs:16:20\n+  --> $DIR/dereference.rs:24:39\n    |\n-LL |     let b: usize = a.deref_mut().len();\n-   |                    ^^^^^^^^^^^^^ help: try this: `&mut *a`\n+LL |     let b: String = format!(\"{}, {}\", a.deref(), a.deref());\n+   |                                       ^^^^^^^^^ help: try this: `&*a`\n \n error: explicit deref method call\n-  --> $DIR/dereference.rs:18:22\n+  --> $DIR/dereference.rs:24:50\n    |\n-LL |     let b: &usize = &a.deref().len();\n-   |                      ^^^^^^^^^ help: try this: `&*a`\n+LL |     let b: String = format!(\"{}, {}\", a.deref(), a.deref());\n+   |                                                  ^^^^^^^^^ help: try this: `&*a`\n \n error: explicit deref method call\n-  --> $DIR/dereference.rs:21:19\n+  --> $DIR/dereference.rs:26:20\n    |\n-LL |     let b: &str = a.deref().deref();\n-   |                   ^^^^^^^^^ help: try this: `&*a`\n+LL |     println!(\"{}\", a.deref());\n+   |                    ^^^^^^^^^ help: try this: `&*a`\n \n error: explicit deref method call\n-  --> $DIR/dereference.rs:24:39\n+  --> $DIR/dereference.rs:29:11\n    |\n-LL |     let b: String = format!(\"{}, {}\", a.deref(), a.deref());\n-   |                                       ^^^^^^^^^ help: try this: `&*a`\n+LL |     match a.deref() {\n+   |           ^^^^^^^^^ help: try this: `&*a`\n \n error: explicit deref method call\n-  --> $DIR/dereference.rs:24:50\n+  --> $DIR/dereference.rs:33:28\n    |\n-LL |     let b: String = format!(\"{}, {}\", a.deref(), a.deref());\n-   |                                                  ^^^^^^^^^ help: try this: `&*a`\n+LL |     let b: String = concat(a.deref());\n+   |                            ^^^^^^^^^ help: try this: `&*a`\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 7 previous errors\n "}]}