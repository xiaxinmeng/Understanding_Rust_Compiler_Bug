{"sha": "af0e54a566ab8c8be9b39a628aaa4992f161695c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmMGU1NGE1NjZhYjhjOGJlOWIzOWE2MjhhYWE0OTkyZjE2MTY5NWM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-10-06T11:43:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-06T11:43:08Z"}, "message": "Merge #6139\n\n6139: Make find_path_prefixed configurable r=matklad a=Veykril\n\nThis makes `find_path_prefixed` more configurable allowing one to choose whether it always returns absolute paths, self-prefixed paths or to ignore local imports when building the path. \r\n\r\nThe config names are just thrown in here, taking better names if they exist :)\r\n\r\nThis should fix #6131 as well?\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "6b12b51c50d64cd5412271101692d9e39282988f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b12b51c50d64cd5412271101692d9e39282988f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af0e54a566ab8c8be9b39a628aaa4992f161695c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJffFhNCRBK7hj4Ov3rIwAAdHIIAIg8A6KPKfuTSaPgl5XXJD8n\nJRX6/KFZPgWKR1qK1VF6AYkGtBYKipqKFaxLi+cUcKctCfBz8rXrouc2ofir0p6l\n4/wqGS7YJn4+qeC74yG0imKVUPh4f3GYKbcuhjZaEF/w4Fu25YQNYPMiv8KqnVBF\n/RH4+IdW5a9jngbuWhpj/MXSgitGKBLgke2gCBJ2oVZYjXiJ/f+xnjt+HEXNe6/Q\nKmFn/yHZAYT130ZQEWlPAZcU9uNq1luBhrPWQSzaXnWIg8Z0qDICeFTMxl4zGvIm\n3/k8M1qnbO2QHGzqA/cv1VT9/siQE92USg8dToJ3ab3gG9fCO0easYC+K304YQg=\n=UwQK\n-----END PGP SIGNATURE-----\n", "payload": "tree 6b12b51c50d64cd5412271101692d9e39282988f\nparent 69512dae26278f06b5ac96a7b6093abb69cdd040\nparent 86993310143c1347db6308a66c1f31a7a5644f56\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1601984588 +0000\ncommitter GitHub <noreply@github.com> 1601984588 +0000\n\nMerge #6139\n\n6139: Make find_path_prefixed configurable r=matklad a=Veykril\n\nThis makes `find_path_prefixed` more configurable allowing one to choose whether it always returns absolute paths, self-prefixed paths or to ignore local imports when building the path. \r\n\r\nThe config names are just thrown in here, taking better names if they exist :)\r\n\r\nThis should fix #6131 as well?\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af0e54a566ab8c8be9b39a628aaa4992f161695c", "html_url": "https://github.com/rust-lang/rust/commit/af0e54a566ab8c8be9b39a628aaa4992f161695c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af0e54a566ab8c8be9b39a628aaa4992f161695c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69512dae26278f06b5ac96a7b6093abb69cdd040", "url": "https://api.github.com/repos/rust-lang/rust/commits/69512dae26278f06b5ac96a7b6093abb69cdd040", "html_url": "https://github.com/rust-lang/rust/commit/69512dae26278f06b5ac96a7b6093abb69cdd040"}, {"sha": "86993310143c1347db6308a66c1f31a7a5644f56", "url": "https://api.github.com/repos/rust-lang/rust/commits/86993310143c1347db6308a66c1f31a7a5644f56", "html_url": "https://github.com/rust-lang/rust/commit/86993310143c1347db6308a66c1f31a7a5644f56"}], "stats": {"total": 307, "additions": 188, "deletions": 119}, "files": [{"sha": "b24527ec4d43c38aa52acb9eed0db3aabf897203", "filename": "crates/assists/src/assist_config.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af0e54a566ab8c8be9b39a628aaa4992f161695c/crates%2Fassists%2Fsrc%2Fassist_config.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0e54a566ab8c8be9b39a628aaa4992f161695c/crates%2Fassists%2Fsrc%2Fassist_config.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fassist_config.rs?ref=af0e54a566ab8c8be9b39a628aaa4992f161695c", "patch": "@@ -4,6 +4,8 @@\n //! module, and we use to statically check that we only produce snippet\n //! assists if we are allowed to.\n \n+use hir::PrefixKind;\n+\n use crate::{utils::MergeBehaviour, AssistKind};\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n@@ -37,10 +39,11 @@ impl Default for AssistConfig {\n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub struct InsertUseConfig {\n     pub merge: Option<MergeBehaviour>,\n+    pub prefix_kind: PrefixKind,\n }\n \n impl Default for InsertUseConfig {\n     fn default() -> Self {\n-        InsertUseConfig { merge: Some(MergeBehaviour::Full) }\n+        InsertUseConfig { merge: Some(MergeBehaviour::Full), prefix_kind: PrefixKind::Plain }\n     }\n }"}, {"sha": "357ff63920a499994eb76651405542d2320c2cd3", "filename": "crates/assists/src/handlers/auto_import.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af0e54a566ab8c8be9b39a628aaa4992f161695c/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0e54a566ab8c8be9b39a628aaa4992f161695c/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=af0e54a566ab8c8be9b39a628aaa4992f161695c", "patch": "@@ -191,12 +191,16 @@ impl AutoImportAssets {\n                 _ => Some(candidate),\n             })\n             .filter_map(|candidate| match candidate {\n-                Either::Left(module_def) => {\n-                    self.module_with_name_to_import.find_use_path_prefixed(db, module_def)\n-                }\n-                Either::Right(macro_def) => {\n-                    self.module_with_name_to_import.find_use_path_prefixed(db, macro_def)\n-                }\n+                Either::Left(module_def) => self.module_with_name_to_import.find_use_path_prefixed(\n+                    db,\n+                    module_def,\n+                    ctx.config.insert_use.prefix_kind,\n+                ),\n+                Either::Right(macro_def) => self.module_with_name_to_import.find_use_path_prefixed(\n+                    db,\n+                    macro_def,\n+                    ctx.config.insert_use.prefix_kind,\n+                ),\n             })\n             .filter(|use_path| !use_path.segments.is_empty())\n             .take(20)"}, {"sha": "a445a97b30bc71e08077058c260966e9d5177c2e", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af0e54a566ab8c8be9b39a628aaa4992f161695c/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0e54a566ab8c8be9b39a628aaa4992f161695c/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=af0e54a566ab8c8be9b39a628aaa4992f161695c", "patch": "@@ -4,6 +4,7 @@ use std::{iter, sync::Arc};\n use arrayvec::ArrayVec;\n use base_db::{CrateId, Edition, FileId};\n use either::Either;\n+use hir_def::find_path::PrefixKind;\n use hir_def::{\n     adt::ReprKind,\n     adt::StructKind,\n@@ -390,8 +391,9 @@ impl Module {\n         self,\n         db: &dyn DefDatabase,\n         item: impl Into<ItemInNs>,\n+        prefix_kind: PrefixKind,\n     ) -> Option<ModPath> {\n-        hir_def::find_path::find_path_prefixed(db, item.into(), self.into())\n+        hir_def::find_path::find_path_prefixed(db, item.into(), self.into(), prefix_kind)\n     }\n }\n "}, {"sha": "87084fa13259f5c5c2d0c23e516db78f0c52aae7", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0e54a566ab8c8be9b39a628aaa4992f161695c/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0e54a566ab8c8be9b39a628aaa4992f161695c/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=af0e54a566ab8c8be9b39a628aaa4992f161695c", "patch": "@@ -48,6 +48,7 @@ pub use hir_def::{\n     body::scope::ExprScopes,\n     builtin_type::BuiltinType,\n     docs::Documentation,\n+    find_path::PrefixKind,\n     item_scope::ItemInNs,\n     nameres::ModuleSource,\n     path::ModPath,"}, {"sha": "9106ed45fac1f23fccfbf94a484ce391c35caef5", "filename": "crates/hir_def/src/find_path.rs", "status": "modified", "additions": 138, "deletions": 109, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/af0e54a566ab8c8be9b39a628aaa4992f161695c/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0e54a566ab8c8be9b39a628aaa4992f161695c/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ffind_path.rs?ref=af0e54a566ab8c8be9b39a628aaa4992f161695c", "patch": "@@ -19,12 +19,17 @@ use crate::{\n /// *from where* you're referring to the item, hence the `from` parameter.\n pub fn find_path(db: &dyn DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n     let _p = profile::span(\"find_path\");\n-    find_path_inner(db, item, from, MAX_PATH_LEN, Prefixed::Not)\n+    find_path_inner(db, item, from, MAX_PATH_LEN, None)\n }\n \n-pub fn find_path_prefixed(db: &dyn DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n-    let _p = profile::span(\"find_path_absolute\");\n-    find_path_inner(db, item, from, MAX_PATH_LEN, Prefixed::Plain)\n+pub fn find_path_prefixed(\n+    db: &dyn DefDatabase,\n+    item: ItemInNs,\n+    from: ModuleId,\n+    prefix_kind: PrefixKind,\n+) -> Option<ModPath> {\n+    let _p = profile::span(\"find_path_prefixed\");\n+    find_path_inner(db, item, from, MAX_PATH_LEN, Some(prefix_kind))\n }\n \n const MAX_PATH_LEN: usize = 15;\n@@ -42,58 +47,52 @@ impl ModPath {\n     }\n }\n \n-fn check_crate_self_super(\n-    def_map: &CrateDefMap,\n-    item: ItemInNs,\n-    from: ModuleId,\n-) -> Option<ModPath> {\n-    // - if the item is the crate root, return `crate`\n-    if item\n-        == ItemInNs::Types(ModuleDefId::ModuleId(ModuleId {\n-            krate: from.krate,\n-            local_id: def_map.root,\n-        }))\n-    {\n-        Some(ModPath::from_segments(PathKind::Crate, Vec::new()))\n-    } else if item == ItemInNs::Types(from.into()) {\n+fn check_self_super(def_map: &CrateDefMap, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n+    if item == ItemInNs::Types(from.into()) {\n         // - if the item is the module we're in, use `self`\n         Some(ModPath::from_segments(PathKind::Super(0), Vec::new()))\n-    } else {\n-        if let Some(parent_id) = def_map.modules[from.local_id].parent {\n-            // - if the item is the parent module, use `super` (this is not used recursively, since `super::super` is ugly)\n-            if item\n-                == ItemInNs::Types(ModuleDefId::ModuleId(ModuleId {\n-                    krate: from.krate,\n-                    local_id: parent_id,\n-                }))\n-            {\n-                return Some(ModPath::from_segments(PathKind::Super(1), Vec::new()));\n-            }\n+    } else if let Some(parent_id) = def_map.modules[from.local_id].parent {\n+        // - if the item is the parent module, use `super` (this is not used recursively, since `super::super` is ugly)\n+        if item\n+            == ItemInNs::Types(ModuleDefId::ModuleId(ModuleId {\n+                krate: from.krate,\n+                local_id: parent_id,\n+            }))\n+        {\n+            Some(ModPath::from_segments(PathKind::Super(1), Vec::new()))\n+        } else {\n+            None\n         }\n+    } else {\n         None\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq)]\n-pub enum Prefixed {\n-    Not,\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum PrefixKind {\n+    /// Causes paths to always start with either `self`, `super`, `crate` or a crate-name.\n+    /// This is the same as plain, just that paths will start with `self` iprepended f the path\n+    /// starts with an identifier that is not a crate.\n     BySelf,\n+    /// Causes paths to ignore imports in the local module.\n     Plain,\n+    /// Causes paths to start with `crate` where applicable, effectively forcing paths to be absolute.\n+    ByCrate,\n }\n \n-impl Prefixed {\n+impl PrefixKind {\n     #[inline]\n-    fn prefix(self) -> Option<PathKind> {\n+    fn prefix(self) -> PathKind {\n         match self {\n-            Prefixed::Not => None,\n-            Prefixed::BySelf => Some(PathKind::Super(0)),\n-            Prefixed::Plain => Some(PathKind::Plain),\n+            PrefixKind::BySelf => PathKind::Super(0),\n+            PrefixKind::Plain => PathKind::Plain,\n+            PrefixKind::ByCrate => PathKind::Crate,\n         }\n     }\n \n     #[inline]\n-    fn prefixed(self) -> bool {\n-        self != Prefixed::Not\n+    fn is_absolute(&self) -> bool {\n+        self == &PrefixKind::ByCrate\n     }\n }\n \n@@ -102,7 +101,7 @@ fn find_path_inner(\n     item: ItemInNs,\n     from: ModuleId,\n     max_len: usize,\n-    prefixed: Prefixed,\n+    prefixed: Option<PrefixKind>,\n ) -> Option<ModPath> {\n     if max_len == 0 {\n         return None;\n@@ -115,13 +114,25 @@ fn find_path_inner(\n     let from_scope: &crate::item_scope::ItemScope = &def_map.modules[from.local_id].scope;\n     let scope_name =\n         if let Some((name, _)) = from_scope.name_of(item) { Some(name.clone()) } else { None };\n-    if !prefixed.prefixed() && scope_name.is_some() {\n+    if prefixed.is_none() && scope_name.is_some() {\n         return scope_name\n             .map(|scope_name| ModPath::from_segments(PathKind::Plain, vec![scope_name]));\n     }\n \n-    if let modpath @ Some(_) = check_crate_self_super(&def_map, item, from) {\n-        return modpath;\n+    // - if the item is the crate root, return `crate`\n+    if item\n+        == ItemInNs::Types(ModuleDefId::ModuleId(ModuleId {\n+            krate: from.krate,\n+            local_id: def_map.root,\n+        }))\n+    {\n+        return Some(ModPath::from_segments(PathKind::Crate, Vec::new()));\n+    }\n+\n+    if prefixed.filter(PrefixKind::is_absolute).is_none() {\n+        if let modpath @ Some(_) = check_self_super(&def_map, item, from) {\n+            return modpath;\n+        }\n     }\n \n     // - if the item is the crate root of a dependency crate, return the name from the extern prelude\n@@ -226,7 +237,7 @@ fn find_path_inner(\n         }\n     }\n \n-    if let Some(prefix) = prefixed.prefix() {\n+    if let Some(prefix) = prefixed.map(PrefixKind::prefix) {\n         best_path.or_else(|| {\n             scope_name.map(|scope_name| ModPath::from_segments(prefix, vec![scope_name]))\n         })\n@@ -355,7 +366,7 @@ mod tests {\n     /// `code` needs to contain a cursor marker; checks that `find_path` for the\n     /// item the `path` refers to returns that same path when called from the\n     /// module the cursor is in.\n-    fn check_found_path_(ra_fixture: &str, path: &str, absolute: bool) {\n+    fn check_found_path_(ra_fixture: &str, path: &str, prefix_kind: Option<PrefixKind>) {\n         let (db, pos) = TestDB::with_position(ra_fixture);\n         let module = db.module_for_file(pos.file_id);\n         let parsed_path_file = syntax::SourceFile::parse(&format!(\"use {};\", path));\n@@ -375,20 +386,22 @@ mod tests {\n             .take_types()\n             .unwrap();\n \n-        let found_path = if absolute { find_path_prefixed } else { find_path }(\n-            &db,\n-            ItemInNs::Types(resolved),\n-            module,\n-        );\n-        assert_eq!(found_path, Some(mod_path), \"absolute {}\", absolute);\n+        let found_path =\n+            find_path_inner(&db, ItemInNs::Types(resolved), module, MAX_PATH_LEN, prefix_kind);\n+        assert_eq!(found_path, Some(mod_path), \"{:?}\", prefix_kind);\n     }\n \n-    fn check_found_path(ra_fixture: &str, path: &str) {\n-        check_found_path_(ra_fixture, path, false);\n-    }\n-\n-    fn check_found_path_abs(ra_fixture: &str, path: &str) {\n-        check_found_path_(ra_fixture, path, true);\n+    fn check_found_path(\n+        ra_fixture: &str,\n+        unprefixed: &str,\n+        prefixed: &str,\n+        absolute: &str,\n+        self_prefixed: &str,\n+    ) {\n+        check_found_path_(ra_fixture, unprefixed, None);\n+        check_found_path_(ra_fixture, prefixed, Some(PrefixKind::Plain));\n+        check_found_path_(ra_fixture, absolute, Some(PrefixKind::ByCrate));\n+        check_found_path_(ra_fixture, self_prefixed, Some(PrefixKind::BySelf));\n     }\n \n     #[test]\n@@ -398,8 +411,7 @@ mod tests {\n             struct S;\n             <|>\n         \"#;\n-        check_found_path(code, \"S\");\n-        check_found_path_abs(code, \"S\");\n+        check_found_path(code, \"S\", \"S\", \"crate::S\", \"self::S\");\n     }\n \n     #[test]\n@@ -409,8 +421,7 @@ mod tests {\n             enum E { A }\n             <|>\n         \"#;\n-        check_found_path(code, \"E::A\");\n-        check_found_path_abs(code, \"E::A\");\n+        check_found_path(code, \"E::A\", \"E::A\", \"E::A\", \"E::A\");\n     }\n \n     #[test]\n@@ -422,8 +433,7 @@ mod tests {\n             }\n             <|>\n         \"#;\n-        check_found_path(code, \"foo::S\");\n-        check_found_path_abs(code, \"foo::S\");\n+        check_found_path(code, \"foo::S\", \"foo::S\", \"crate::foo::S\", \"self::foo::S\");\n     }\n \n     #[test]\n@@ -437,8 +447,7 @@ mod tests {\n             //- /foo/bar.rs\n             <|>\n         \"#;\n-        check_found_path(code, \"super::S\");\n-        check_found_path_abs(code, \"super::S\");\n+        check_found_path(code, \"super::S\", \"super::S\", \"crate::foo::S\", \"super::S\");\n     }\n \n     #[test]\n@@ -449,8 +458,7 @@ mod tests {\n             //- /foo.rs\n             <|>\n         \"#;\n-        check_found_path(code, \"self\");\n-        check_found_path_abs(code, \"self\");\n+        check_found_path(code, \"self\", \"self\", \"crate::foo\", \"self\");\n     }\n \n     #[test]\n@@ -461,8 +469,7 @@ mod tests {\n             //- /foo.rs\n             <|>\n         \"#;\n-        check_found_path(code, \"crate\");\n-        check_found_path_abs(code, \"crate\");\n+        check_found_path(code, \"crate\", \"crate\", \"crate\", \"crate\");\n     }\n \n     #[test]\n@@ -474,8 +481,7 @@ mod tests {\n             //- /foo.rs\n             <|>\n         \"#;\n-        check_found_path(code, \"crate::S\");\n-        check_found_path_abs(code, \"crate::S\");\n+        check_found_path(code, \"crate::S\", \"crate::S\", \"crate::S\", \"crate::S\");\n     }\n \n     #[test]\n@@ -486,8 +492,7 @@ mod tests {\n             //- /std.rs crate:std\n             pub struct S;\n         \"#;\n-        check_found_path(code, \"std::S\");\n-        check_found_path_abs(code, \"std::S\");\n+        check_found_path(code, \"std::S\", \"std::S\", \"std::S\", \"std::S\");\n     }\n \n     #[test]\n@@ -499,8 +504,13 @@ mod tests {\n             //- /std.rs crate:std\n             pub struct S;\n         \"#;\n-        check_found_path(code, \"std_renamed::S\");\n-        check_found_path_abs(code, \"std_renamed::S\");\n+        check_found_path(\n+            code,\n+            \"std_renamed::S\",\n+            \"std_renamed::S\",\n+            \"std_renamed::S\",\n+            \"std_renamed::S\",\n+        );\n     }\n \n     #[test]\n@@ -520,8 +530,13 @@ mod tests {\n                 }\n             }\n         \"#;\n-        check_found_path(code, \"ast::ModuleItem\");\n-        check_found_path_abs(code, \"syntax::ast::ModuleItem\");\n+        check_found_path(\n+            code,\n+            \"ast::ModuleItem\",\n+            \"syntax::ast::ModuleItem\",\n+            \"syntax::ast::ModuleItem\",\n+            \"syntax::ast::ModuleItem\",\n+        );\n \n         let code = r#\"\n             //- /main.rs crate:main deps:syntax\n@@ -535,8 +550,13 @@ mod tests {\n                 }\n             }\n         \"#;\n-        check_found_path(code, \"syntax::ast::ModuleItem\");\n-        check_found_path_abs(code, \"syntax::ast::ModuleItem\");\n+        check_found_path(\n+            code,\n+            \"syntax::ast::ModuleItem\",\n+            \"syntax::ast::ModuleItem\",\n+            \"syntax::ast::ModuleItem\",\n+            \"syntax::ast::ModuleItem\",\n+        );\n     }\n \n     #[test]\n@@ -549,8 +569,7 @@ mod tests {\n             }\n             <|>\n         \"#;\n-        check_found_path(code, \"bar::S\");\n-        check_found_path_abs(code, \"bar::S\");\n+        check_found_path(code, \"bar::S\", \"bar::S\", \"crate::bar::S\", \"self::bar::S\");\n     }\n \n     #[test]\n@@ -563,8 +582,7 @@ mod tests {\n             }\n             <|>\n         \"#;\n-        check_found_path(code, \"bar::U\");\n-        check_found_path_abs(code, \"bar::U\");\n+        check_found_path(code, \"bar::U\", \"bar::U\", \"crate::bar::U\", \"self::bar::U\");\n     }\n \n     #[test]\n@@ -577,8 +595,7 @@ mod tests {\n             //- /core.rs crate:core\n             pub struct S;\n         \"#;\n-        check_found_path(code, \"std::S\");\n-        check_found_path_abs(code, \"std::S\");\n+        check_found_path(code, \"std::S\", \"std::S\", \"std::S\", \"std::S\");\n     }\n \n     #[test]\n@@ -591,8 +608,7 @@ mod tests {\n             #[prelude_import]\n             pub use prelude::*;\n         \"#;\n-        check_found_path(code, \"S\");\n-        check_found_path_abs(code, \"S\");\n+        check_found_path(code, \"S\", \"S\", \"S\", \"S\");\n     }\n \n     #[test]\n@@ -608,10 +624,8 @@ mod tests {\n             #[prelude_import]\n             pub use prelude::*;\n         \"#;\n-        check_found_path(code, \"None\");\n-        check_found_path(code, \"Some\");\n-        check_found_path_abs(code, \"None\");\n-        check_found_path_abs(code, \"Some\");\n+        check_found_path(code, \"None\", \"None\", \"None\", \"None\");\n+        check_found_path(code, \"Some\", \"Some\", \"Some\", \"Some\");\n     }\n \n     #[test]\n@@ -627,8 +641,7 @@ mod tests {\n             //- /baz.rs\n             pub use crate::foo::bar::S;\n         \"#;\n-        check_found_path(code, \"baz::S\");\n-        check_found_path_abs(code, \"baz::S\");\n+        check_found_path(code, \"baz::S\", \"baz::S\", \"crate::baz::S\", \"self::baz::S\");\n     }\n \n     #[test]\n@@ -642,8 +655,7 @@ mod tests {\n             <|>\n         \"#;\n         // crate::S would be shorter, but using private imports seems wrong\n-        check_found_path(code, \"crate::bar::S\");\n-        check_found_path_abs(code, \"crate::bar::S\");\n+        check_found_path(code, \"crate::bar::S\", \"crate::bar::S\", \"crate::bar::S\", \"crate::bar::S\");\n     }\n \n     #[test]\n@@ -661,8 +673,7 @@ mod tests {\n             //- /baz.rs\n             pub use super::foo;\n         \"#;\n-        check_found_path(code, \"crate::foo::S\");\n-        check_found_path_abs(code, \"crate::foo::S\");\n+        check_found_path(code, \"crate::foo::S\", \"crate::foo::S\", \"crate::foo::S\", \"crate::foo::S\");\n     }\n \n     #[test]\n@@ -682,8 +693,13 @@ mod tests {\n             pub struct Arc;\n         }\n         \"#;\n-        check_found_path(code, \"std::sync::Arc\");\n-        check_found_path_abs(code, \"std::sync::Arc\");\n+        check_found_path(\n+            code,\n+            \"std::sync::Arc\",\n+            \"std::sync::Arc\",\n+            \"std::sync::Arc\",\n+            \"std::sync::Arc\",\n+        );\n     }\n \n     #[test]\n@@ -707,8 +723,13 @@ mod tests {\n             pub struct Error;\n         }\n         \"#;\n-        check_found_path(code, \"core::fmt::Error\");\n-        check_found_path_abs(code, \"core::fmt::Error\");\n+        check_found_path(\n+            code,\n+            \"core::fmt::Error\",\n+            \"core::fmt::Error\",\n+            \"core::fmt::Error\",\n+            \"core::fmt::Error\",\n+        );\n     }\n \n     #[test]\n@@ -731,8 +752,13 @@ mod tests {\n             pub struct Arc;\n         }\n         \"#;\n-        check_found_path(code, \"alloc::sync::Arc\");\n-        check_found_path_abs(code, \"alloc::sync::Arc\");\n+        check_found_path(\n+            code,\n+            \"alloc::sync::Arc\",\n+            \"alloc::sync::Arc\",\n+            \"alloc::sync::Arc\",\n+            \"alloc::sync::Arc\",\n+        );\n     }\n \n     #[test]\n@@ -749,8 +775,13 @@ mod tests {\n         //- /zzz.rs crate:megaalloc\n         pub struct Arc;\n         \"#;\n-        check_found_path(code, \"megaalloc::Arc\");\n-        check_found_path_abs(code, \"megaalloc::Arc\");\n+        check_found_path(\n+            code,\n+            \"megaalloc::Arc\",\n+            \"megaalloc::Arc\",\n+            \"megaalloc::Arc\",\n+            \"megaalloc::Arc\",\n+        );\n     }\n \n     #[test]\n@@ -763,9 +794,7 @@ mod tests {\n             pub use u8;\n         }\n         \"#;\n-        check_found_path(code, \"u8\");\n-        check_found_path(code, \"u16\");\n-        check_found_path_abs(code, \"u8\");\n-        check_found_path_abs(code, \"u16\");\n+        check_found_path(code, \"u8\", \"u8\", \"u8\", \"u8\");\n+        check_found_path(code, \"u16\", \"u16\", \"u16\", \"u16\");\n     }\n }"}, {"sha": "dcbc11c14e6ac4e3f26c95bd91af7afcd6320ebd", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/af0e54a566ab8c8be9b39a628aaa4992f161695c/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0e54a566ab8c8be9b39a628aaa4992f161695c/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=af0e54a566ab8c8be9b39a628aaa4992f161695c", "patch": "@@ -10,6 +10,7 @@\n use std::{ffi::OsString, path::PathBuf};\n \n use flycheck::FlycheckConfig;\n+use hir::PrefixKind;\n use ide::{\n     AssistConfig, CompletionConfig, DiagnosticsConfig, HoverConfig, InlayHintsConfig,\n     MergeBehaviour,\n@@ -289,6 +290,11 @@ impl Config {\n             MergeBehaviourDef::Full => Some(MergeBehaviour::Full),\n             MergeBehaviourDef::Last => Some(MergeBehaviour::Last),\n         };\n+        self.assist.insert_use.prefix_kind = match data.assist_importPrefix {\n+            ImportPrefixDef::Plain => PrefixKind::Plain,\n+            ImportPrefixDef::ByCrate => PrefixKind::ByCrate,\n+            ImportPrefixDef::BySelf => PrefixKind::BySelf,\n+        };\n \n         self.call_info_full = data.callInfo_full;\n \n@@ -403,13 +409,21 @@ enum ManifestOrProjectJson {\n }\n \n #[derive(Deserialize)]\n-#[serde(rename_all = \"lowercase\")]\n+#[serde(rename_all = \"snake_case\")]\n enum MergeBehaviourDef {\n     None,\n     Full,\n     Last,\n }\n \n+#[derive(Deserialize)]\n+#[serde(rename_all = \"snake_case\")]\n+enum ImportPrefixDef {\n+    Plain,\n+    BySelf,\n+    ByCrate,\n+}\n+\n macro_rules! config_data {\n     (struct $name:ident { $($field:ident: $ty:ty = $default:expr,)*}) => {\n         #[allow(non_snake_case)]\n@@ -434,6 +448,7 @@ macro_rules! config_data {\n config_data! {\n     struct ConfigData {\n         assist_importMergeBehaviour: MergeBehaviourDef = MergeBehaviourDef::None,\n+        assist_importPrefix: ImportPrefixDef           = ImportPrefixDef::Plain,\n \n         callInfo_full: bool = true,\n "}, {"sha": "1f0e7550b5e486aae3e12fae49c9acdefd5e26b7", "filename": "editors/code/package.json", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/af0e54a566ab8c8be9b39a628aaa4992f161695c/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/af0e54a566ab8c8be9b39a628aaa4992f161695c/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=af0e54a566ab8c8be9b39a628aaa4992f161695c", "patch": "@@ -652,6 +652,21 @@\n                     \"default\": \"full\",\n                     \"description\": \"The strategy to use when inserting new imports or merging imports.\"\n                 },\n+                \"rust-analyzer.assist.importPrefix\": {\n+                    \"type\": \"string\",\n+                    \"enum\": [\n+                        \"plain\",\n+                        \"by_self\",\n+                        \"by_crate\"\n+                    ],\n+                    \"enumDescriptions\": [\n+                        \"Insert import paths relative to the current module, using up to one `super` prefix if the parent module contains the requested item.\",\n+                        \"Prefix all import paths with `self` if they don't begin with `self`, `super`, `crate` or a crate name\",\n+                        \"Force import paths to be absolute by always starting them with `crate` or the crate name they refer to.\"\n+                    ],\n+                    \"default\": \"plain\",\n+                    \"description\": \"The path structure for newly inserted paths to use.\"\n+                },\n                 \"rust-analyzer.runnables.overrideCargo\": {\n                     \"type\": [\n                         \"null\",\n@@ -1033,4 +1048,4 @@\n             ]\n         }\n     }\n-}\n+}\n\\ No newline at end of file"}]}