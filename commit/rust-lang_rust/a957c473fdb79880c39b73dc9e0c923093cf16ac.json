{"sha": "a957c473fdb79880c39b73dc9e0c923093cf16ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5NTdjNDczZmRiNzk4ODBjMzliNzNkYzllMGM5MjMwOTNjZjE2YWM=", "commit": {"author": {"name": "Kevin DeLorey", "email": "2295721+kdelorey@users.noreply.github.com", "date": "2020-02-09T16:25:47Z"}, "committer": {"name": "Kevin DeLorey", "email": "2295721+kdelorey@users.noreply.github.com", "date": "2020-02-09T16:37:43Z"}, "message": "Merge branch 'master' into kdelorey/complete-trait-impl", "tree": {"sha": "f998b548f530ce604651e0e6af314ed2ec74b3b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f998b548f530ce604651e0e6af314ed2ec74b3b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a957c473fdb79880c39b73dc9e0c923093cf16ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a957c473fdb79880c39b73dc9e0c923093cf16ac", "html_url": "https://github.com/rust-lang/rust/commit/a957c473fdb79880c39b73dc9e0c923093cf16ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a957c473fdb79880c39b73dc9e0c923093cf16ac/comments", "author": {"login": "kdelorey", "id": 2295721, "node_id": "MDQ6VXNlcjIyOTU3MjE=", "avatar_url": "https://avatars.githubusercontent.com/u/2295721?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kdelorey", "html_url": "https://github.com/kdelorey", "followers_url": "https://api.github.com/users/kdelorey/followers", "following_url": "https://api.github.com/users/kdelorey/following{/other_user}", "gists_url": "https://api.github.com/users/kdelorey/gists{/gist_id}", "starred_url": "https://api.github.com/users/kdelorey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kdelorey/subscriptions", "organizations_url": "https://api.github.com/users/kdelorey/orgs", "repos_url": "https://api.github.com/users/kdelorey/repos", "events_url": "https://api.github.com/users/kdelorey/events{/privacy}", "received_events_url": "https://api.github.com/users/kdelorey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kdelorey", "id": 2295721, "node_id": "MDQ6VXNlcjIyOTU3MjE=", "avatar_url": "https://avatars.githubusercontent.com/u/2295721?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kdelorey", "html_url": "https://github.com/kdelorey", "followers_url": "https://api.github.com/users/kdelorey/followers", "following_url": "https://api.github.com/users/kdelorey/following{/other_user}", "gists_url": "https://api.github.com/users/kdelorey/gists{/gist_id}", "starred_url": "https://api.github.com/users/kdelorey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kdelorey/subscriptions", "organizations_url": "https://api.github.com/users/kdelorey/orgs", "repos_url": "https://api.github.com/users/kdelorey/repos", "events_url": "https://api.github.com/users/kdelorey/events{/privacy}", "received_events_url": "https://api.github.com/users/kdelorey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22caf982b99c54058e2e9200aeea0e61cada284a", "url": "https://api.github.com/repos/rust-lang/rust/commits/22caf982b99c54058e2e9200aeea0e61cada284a", "html_url": "https://github.com/rust-lang/rust/commit/22caf982b99c54058e2e9200aeea0e61cada284a"}, {"sha": "1b9b13b4b4a75b5531c3f046ce6bf72d681f2732", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b9b13b4b4a75b5531c3f046ce6bf72d681f2732", "html_url": "https://github.com/rust-lang/rust/commit/1b9b13b4b4a75b5531c3f046ce6bf72d681f2732"}], "stats": {"total": 11907, "additions": 7355, "deletions": 4552}, "files": [{"sha": "77c92512a98e3af15480638bdb0f3ebeb93cc585", "filename": ".github/workflows/release.yaml", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/.github%2Fworkflows%2Frelease.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/.github%2Fworkflows%2Frelease.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Frelease.yaml?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,4 +1,4 @@\n-name: CI-Release\n+name: release\n on:\n   push:\n     branches:\n@@ -132,7 +132,9 @@ jobs:\n \n       - name: Create Release\n         id: create_release\n-        uses: actions/create-release@v1\n+        # uses: actions/create-release@v1\n+        # https://github.com/actions/create-release/pull/32\n+        uses: fleskesvor/create-release@1a72e235c178bf2ae6c51a8ae36febc24568c5fe\n         env:\n           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n         with:"}, {"sha": "e29ff898d715a1ccbac8b79fe03444124b9920f0", "filename": "Cargo.lock", "status": "modified", "additions": 739, "deletions": 735, "changes": 1474, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac"}, {"sha": "e5620b1b7dc2917f8145a062787dac796e241ae9", "filename": "Cargo.toml", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -10,5 +10,24 @@ debug = 0\n incremental = true\n debug = 0 # set this to 1 or 2 to get more useful backtraces in debugger\n \n+# ideally, we would use `build-override` here, but some crates are also\n+# needed at run-time and we end up compiling them twice\n+[profile.release.package.proc-macro2]\n+opt-level = 0\n+[profile.release.package.quote]\n+opt-level = 0\n+[profile.release.package.syn]\n+opt-level = 0\n+[profile.release.package.serde_derive]\n+opt-level = 0\n+[profile.release.package.chalk-derive]\n+opt-level = 0\n+[profile.release.package.chalk-macros]\n+opt-level = 0\n+[profile.release.package.salsa-macros]\n+opt-level = 0\n+[profile.release.package.xtask]\n+opt-level = 0\n+\n [patch.'crates-io']\n # rowan = { path = \"../rowan\" }"}, {"sha": "fabb8479d410d4d3f14daef30522160f341ee8a2", "filename": "README.md", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -2,32 +2,31 @@\n   <img src=\"https://user-images.githubusercontent.com/1711539/72443316-5a79f280-37ae-11ea-858f-035209ece2dd.png\" alt=\"rust-analyzer logo\">\n </p>\n \n-Rust Analyzer is an **experimental** modular compiler frontend for the Rust\n+rust-analyzer is an **experimental** modular compiler frontend for the Rust\n language. It is a part of a larger rls-2.0 effort to create excellent IDE\n-support for Rust. If you want to get involved, check the rls-2.0 working group\n-in the compiler-team repository:\n+support for Rust. If you want to get involved, check the rls-2.0 working group:\n \n-https://github.com/rust-lang/compiler-team/tree/master/content/working-groups/rls-2.0\n+https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0\n \n-Work on the Rust Analyzer is sponsored by\n+Work on rust-analyzer is sponsored by\n \n [<img src=\"https://user-images.githubusercontent.com/1711539/58105231-cf306900-7bee-11e9-83d8-9f1102e59d29.png\" alt=\"Ferrous Systems\" width=\"300\">](https://ferrous-systems.com/)\n - [Mozilla](https://www.mozilla.org/en-US/)\n - [freiheit.com](https://www.freiheit.com)\n \n ## Language Server Quick Start\n \n-Rust Analyzer is a work-in-progress, so you'll have to build it from source, and\n-you might encounter critical bugs. That said, it is complete enough to provide a\n-useful IDE experience and some people use it as a daily driver.\n+rust-analyzer is a work-in-progress, so you might encounter critical bugs. That\n+said, it is complete enough to provide a useful IDE experience and some people\n+use it as a daily driver.\n \n To build rust-analyzer, you need:\n \n-* latest stable rust for language server itself\n+* latest stable Rust for the language server itself\n * latest stable npm and VS Code for VS Code extension\n \n-To quickly install rust-analyzer with VS Code extension with standard setup\n-(`code` and `cargo` in `$PATH`, etc), use this:\n+To quickly install the rust-analyzer language server and VS Code extension with\n+standard setup (`code` and `cargo` in `$PATH`, etc), use this:\n \n ```\n # clone the repo\n@@ -45,8 +44,8 @@ cannot start, see [./docs/user](./docs/user).\n \n ## Documentation\n \n-If you want to **contribute** to rust-analyzer or just curious about how things work\n-under the hood, check the [./docs/dev](./docs/dev) folder.\n+If you want to **contribute** to rust-analyzer or are just curious about how\n+things work under the hood, check the [./docs/dev](./docs/dev) folder.\n \n If you want to **use** rust-analyzer's language server with your editor of\n choice, check [./docs/user](./docs/user) folder. It also contains some tips & tricks to help"}, {"sha": "0bc71860f2a91add5b2d12c4eeabeee37d3e9e72", "filename": "bors.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/bors.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/bors.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/bors.toml?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,6 +1,6 @@\n status = [\n     \"Rust (ubuntu-latest)\",\n-    # \"Rust (windows-latest)\",\n+    \"Rust (windows-latest)\",\n     \"Rust (macos-latest)\",\n     \"TypeScript\"\n ]"}, {"sha": "6973038d4e99dc3c8551d8f140646a54d331340e", "filename": "crates/ra_assists/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2FCargo.toml?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -16,6 +16,8 @@ either = \"1.5\"\n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }\n ra_fmt = { path = \"../ra_fmt\" }\n+ra_prof = { path = \"../ra_prof\" }\n ra_db = { path = \"../ra_db\" }\n+ra_ide_db = { path = \"../ra_ide_db\" }\n hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n test_utils = { path = \"../test_utils\" }"}, {"sha": "5aab5fb8b673dd71f007a4f62ad6c6cf62ec2561", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 81, "deletions": 59, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,23 +1,49 @@\n //! This module defines `AssistCtx` -- the API surface that is exposed to assists.\n-use either::Either;\n-use hir::{db::HirDatabase, InFile, SourceAnalyzer, SourceBinder};\n-use ra_db::FileRange;\n+use hir::{InFile, SourceAnalyzer, SourceBinder};\n+use ra_db::{FileRange, SourceDatabase};\n use ra_fmt::{leading_indent, reindent};\n+use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo::{self, find_covering_element, find_node_at_offset},\n     AstNode, SourceFile, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange, TextUnit,\n     TokenAtOffset,\n };\n use ra_text_edit::TextEditBuilder;\n \n-use crate::{AssistAction, AssistId, AssistLabel, ResolvedAssist};\n+use crate::{AssistAction, AssistId, AssistLabel, GroupLabel, ResolvedAssist};\n \n #[derive(Clone, Debug)]\n-pub(crate) enum Assist {\n-    Unresolved { label: AssistLabel },\n-    Resolved { assist: ResolvedAssist },\n+pub(crate) struct Assist(pub(crate) Vec<AssistInfo>);\n+\n+#[derive(Clone, Debug)]\n+pub(crate) struct AssistInfo {\n+    pub(crate) label: AssistLabel,\n+    pub(crate) group_label: Option<GroupLabel>,\n+    pub(crate) action: Option<AssistAction>,\n+}\n+\n+impl AssistInfo {\n+    fn new(label: AssistLabel) -> AssistInfo {\n+        AssistInfo { label, group_label: None, action: None }\n+    }\n+\n+    fn resolved(self, action: AssistAction) -> AssistInfo {\n+        AssistInfo { action: Some(action), ..self }\n+    }\n+\n+    fn with_group(self, group_label: GroupLabel) -> AssistInfo {\n+        AssistInfo { group_label: Some(group_label), ..self }\n+    }\n+\n+    pub(crate) fn into_resolved(self) -> Option<ResolvedAssist> {\n+        let label = self.label;\n+        let group_label = self.group_label;\n+        self.action.map(|action| ResolvedAssist { label, group_label, action })\n+    }\n }\n \n+pub(crate) type AssistHandler = fn(AssistCtx) -> Option<Assist>;\n+\n /// `AssistCtx` allows to apply an assist or check if it could be applied.\n ///\n /// Assists use a somewhat over-engineered approach, given the current needs. The\n@@ -49,14 +75,14 @@ pub(crate) enum Assist {\n /// moment, because the LSP API is pretty awkward in this place, and it's much\n /// easier to just compute the edit eagerly :-)\n #[derive(Debug)]\n-pub(crate) struct AssistCtx<'a, DB> {\n-    pub(crate) db: &'a DB,\n+pub(crate) struct AssistCtx<'a> {\n+    pub(crate) db: &'a RootDatabase,\n     pub(crate) frange: FileRange,\n     source_file: SourceFile,\n     should_compute_edit: bool,\n }\n \n-impl<'a, DB> Clone for AssistCtx<'a, DB> {\n+impl Clone for AssistCtx<'_> {\n     fn clone(&self) -> Self {\n         AssistCtx {\n             db: self.db,\n@@ -67,15 +93,10 @@ impl<'a, DB> Clone for AssistCtx<'a, DB> {\n     }\n }\n \n-impl<'a, DB: HirDatabase> AssistCtx<'a, DB> {\n-    pub(crate) fn with_ctx<F, T>(db: &DB, frange: FileRange, should_compute_edit: bool, f: F) -> T\n-    where\n-        F: FnOnce(AssistCtx<DB>) -> T,\n-    {\n+impl<'a> AssistCtx<'a> {\n+    pub fn new(db: &RootDatabase, frange: FileRange, should_compute_edit: bool) -> AssistCtx {\n         let parse = db.parse(frange.file_id);\n-\n-        let ctx = AssistCtx { db, frange, source_file: parse.tree(), should_compute_edit };\n-        f(ctx)\n+        AssistCtx { db, frange, source_file: parse.tree(), should_compute_edit }\n     }\n \n     pub(crate) fn add_assist(\n@@ -84,48 +105,23 @@ impl<'a, DB: HirDatabase> AssistCtx<'a, DB> {\n         label: impl Into<String>,\n         f: impl FnOnce(&mut ActionBuilder),\n     ) -> Option<Assist> {\n-        let label = AssistLabel { label: label.into(), id };\n-        assert!(label.label.chars().nth(0).unwrap().is_uppercase());\n+        let label = AssistLabel::new(label.into(), id);\n \n-        let assist = if self.should_compute_edit {\n+        let mut info = AssistInfo::new(label);\n+        if self.should_compute_edit {\n             let action = {\n                 let mut edit = ActionBuilder::default();\n                 f(&mut edit);\n                 edit.build()\n             };\n-            Assist::Resolved { assist: ResolvedAssist { label, action_data: Either::Left(action) } }\n-        } else {\n-            Assist::Unresolved { label }\n+            info = info.resolved(action)\n         };\n \n-        Some(assist)\n+        Some(Assist(vec![info]))\n     }\n \n-    #[allow(dead_code)] // will be used for auto import assist with multiple actions\n-    pub(crate) fn add_assist_group(\n-        self,\n-        id: AssistId,\n-        label: impl Into<String>,\n-        f: impl FnOnce() -> Vec<ActionBuilder>,\n-    ) -> Option<Assist> {\n-        let label = AssistLabel { label: label.into(), id };\n-        let assist = if self.should_compute_edit {\n-            let actions = f();\n-            assert!(!actions.is_empty(), \"Assist cannot have no\");\n-\n-            Assist::Resolved {\n-                assist: ResolvedAssist {\n-                    label,\n-                    action_data: Either::Right(\n-                        actions.into_iter().map(ActionBuilder::build).collect(),\n-                    ),\n-                },\n-            }\n-        } else {\n-            Assist::Unresolved { label }\n-        };\n-\n-        Some(assist)\n+    pub(crate) fn add_assist_group(self, group_name: impl Into<String>) -> AssistGroup<'a> {\n+        AssistGroup { ctx: self, group_name: group_name.into(), assists: Vec::new() }\n     }\n \n     pub(crate) fn token_at_offset(&self) -> TokenAtOffset<SyntaxToken> {\n@@ -142,7 +138,7 @@ impl<'a, DB: HirDatabase> AssistCtx<'a, DB> {\n     pub(crate) fn covering_element(&self) -> SyntaxElement {\n         find_covering_element(self.source_file.syntax(), self.frange.range)\n     }\n-    pub(crate) fn source_binder(&self) -> SourceBinder<'a, DB> {\n+    pub(crate) fn source_binder(&self) -> SourceBinder<'a, RootDatabase> {\n         SourceBinder::new(self.db)\n     }\n     pub(crate) fn source_analyzer(\n@@ -159,21 +155,48 @@ impl<'a, DB: HirDatabase> AssistCtx<'a, DB> {\n     }\n }\n \n+pub(crate) struct AssistGroup<'a> {\n+    ctx: AssistCtx<'a>,\n+    group_name: String,\n+    assists: Vec<AssistInfo>,\n+}\n+\n+impl<'a> AssistGroup<'a> {\n+    pub(crate) fn add_assist(\n+        &mut self,\n+        id: AssistId,\n+        label: impl Into<String>,\n+        f: impl FnOnce(&mut ActionBuilder),\n+    ) {\n+        let label = AssistLabel::new(label.into(), id);\n+\n+        let mut info = AssistInfo::new(label).with_group(GroupLabel(self.group_name.clone()));\n+        if self.ctx.should_compute_edit {\n+            let action = {\n+                let mut edit = ActionBuilder::default();\n+                f(&mut edit);\n+                edit.build()\n+            };\n+            info = info.resolved(action)\n+        };\n+\n+        self.assists.push(info)\n+    }\n+\n+    pub(crate) fn finish(self) -> Option<Assist> {\n+        assert!(!self.assists.is_empty());\n+        Some(Assist(self.assists))\n+    }\n+}\n+\n #[derive(Default)]\n pub(crate) struct ActionBuilder {\n     edit: TextEditBuilder,\n     cursor_position: Option<TextUnit>,\n     target: Option<TextRange>,\n-    label: Option<String>,\n }\n \n impl ActionBuilder {\n-    #[allow(dead_code)]\n-    /// Adds a custom label to the action, if it needs to be different from the assist label\n-    pub(crate) fn label(&mut self, label: impl Into<String>) {\n-        self.label = Some(label.into())\n-    }\n-\n     /// Replaces specified `range` of text with a given string.\n     pub(crate) fn replace(&mut self, range: TextRange, replace_with: impl Into<String>) {\n         self.edit.replace(range, replace_with.into())\n@@ -232,7 +255,6 @@ impl ActionBuilder {\n             edit: self.edit.finish(),\n             cursor_position: self.cursor_position,\n             target: self.target,\n-            label: self.label,\n         }\n     }\n }"}, {"sha": "c0f9bc1fbe75e25bf04dbc0a44c23f326cef52cc", "filename": "crates/ra_assists/src/doc_tests.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -5,31 +5,31 @@\n \n mod generated;\n \n-use ra_db::{fixture::WithFixture, FileRange};\n+use ra_db::FileRange;\n use test_utils::{assert_eq_text, extract_range_or_offset};\n \n-use crate::test_db::TestDB;\n+use crate::resolved_assists;\n \n fn check(assist_id: &str, before: &str, after: &str) {\n     let (selection, before) = extract_range_or_offset(before);\n-    let (db, file_id) = TestDB::with_single_file(&before);\n+    let (db, file_id) = crate::helpers::with_single_file(&before);\n     let frange = FileRange { file_id, range: selection.into() };\n \n-    let assist = crate::assists(&db, frange)\n+    let assist = resolved_assists(&db, frange)\n         .into_iter()\n         .find(|assist| assist.label.id.0 == assist_id)\n         .unwrap_or_else(|| {\n             panic!(\n                 \"\\n\\nAssist is not applicable: {}\\nAvailable assists: {}\",\n                 assist_id,\n-                crate::assists(&db, frange)\n+                resolved_assists(&db, frange)\n                     .into_iter()\n                     .map(|assist| assist.label.id.0)\n                     .collect::<Vec<_>>()\n                     .join(\", \")\n             )\n         });\n \n-    let actual = assist.get_first_action().edit.apply(&before);\n+    let actual = assist.action.edit.apply(&before);\n     assert_eq_text!(after, &actual);\n }"}, {"sha": "4ab09b167b5f28de2960c9a3313e2de9a8c29885", "filename": "crates/ra_assists/src/doc_tests/generated.rs", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,4 +1,4 @@\n-//! Generated file, do not edit by hand, see `crate/ra_tools/src/codegen`\n+//! Generated file, do not edit by hand, see `xtask/src/codegen`\n \n use super::check;\n \n@@ -160,21 +160,6 @@ impl Trait<u32> for () {\n     )\n }\n \n-#[test]\n-fn doctest_add_import() {\n-    check(\n-        \"add_import\",\n-        r#####\"\n-fn process(map: std::collections::<|>HashMap<String, String>) {}\n-\"#####,\n-        r#####\"\n-use std::collections::HashMap;\n-\n-fn process(map: HashMap<String, String>) {}\n-\"#####,\n-    )\n-}\n-\n #[test]\n fn doctest_add_new() {\n     check(\n@@ -214,6 +199,27 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_auto_import() {\n+    check(\n+        \"auto_import\",\n+        r#####\"\n+fn main() {\n+    let map = HashMap<|>::new();\n+}\n+pub mod std { pub mod collections { pub struct HashMap { } } }\n+\"#####,\n+        r#####\"\n+use std::collections::HashMap;\n+\n+fn main() {\n+    let map = HashMap::new();\n+}\n+pub mod std { pub mod collections { pub struct HashMap { } } }\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_change_visibility() {\n     check(\n@@ -570,6 +576,21 @@ fn handle(action: Action) {\n     )\n }\n \n+#[test]\n+fn doctest_replace_qualified_name_with_use() {\n+    check(\n+        \"replace_qualified_name_with_use\",\n+        r#####\"\n+fn process(map: std::collections::<|>HashMap<String, String>) {}\n+\"#####,\n+        r#####\"\n+use std::collections::HashMap;\n+\n+fn process(map: HashMap<String, String>) {}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_split_import() {\n     check("}, {"sha": "7fdd816bf82e9af08f0542ab2e94d8bef7b31679", "filename": "crates/ra_assists/src/handlers/add_custom_impl.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,7 +1,7 @@\n //! FIXME: write short doc here\n \n use crate::{Assist, AssistCtx, AssistId};\n-use hir::db::HirDatabase;\n+\n use join_to_string::join;\n use ra_syntax::{\n     ast::{self, AstNode},\n@@ -29,7 +29,7 @@ const DERIVE_TRAIT: &str = \"derive\";\n //\n // }\n // ```\n-pub(crate) fn add_custom_impl(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn add_custom_impl(ctx: AssistCtx) -> Option<Assist> {\n     let input = ctx.find_node_at_offset::<ast::AttrInput>()?;\n     let attr = input.syntax().parent().and_then(ast::Attr::cast)?;\n ", "previous_filename": "crates/ra_assists/src/assists/add_custom_impl.rs"}, {"sha": "b0d1a0a80dbafde6aafe55d2073a147a4c5b0dc5", "filename": "crates/ra_assists/src/handlers/add_derive.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_derive.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,4 +1,3 @@\n-use hir::db::HirDatabase;\n use ra_syntax::{\n     ast::{self, AstNode, AttrsOwner},\n     SyntaxKind::{COMMENT, WHITESPACE},\n@@ -25,7 +24,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     y: u32,\n // }\n // ```\n-pub(crate) fn add_derive(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn add_derive(ctx: AssistCtx) -> Option<Assist> {\n     let nominal = ctx.find_node_at_offset::<ast::NominalDef>()?;\n     let node_start = derive_insertion_offset(&nominal)?;\n     ctx.add_assist(AssistId(\"add_derive\"), \"Add `#[derive]`\", |edit| {", "previous_filename": "crates/ra_assists/src/assists/add_derive.rs"}, {"sha": "2cb9d2f48ebf4e0b5527e0767b338a711641f896", "filename": "crates/ra_assists/src/handlers/add_explicit_type.rs", "status": "renamed", "additions": 50, "deletions": 8, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,7 +1,7 @@\n-use hir::{db::HirDatabase, HirDisplay};\n+use hir::HirDisplay;\n use ra_syntax::{\n-    ast::{self, AstNode, LetStmt, NameOwner},\n-    TextRange, T,\n+    ast::{self, AstNode, LetStmt, NameOwner, TypeAscriptionOwner},\n+    TextRange,\n };\n \n use crate::{Assist, AssistCtx, AssistId};\n@@ -21,7 +21,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     let x: i32 = 92;\n // }\n // ```\n-pub(crate) fn add_explicit_type(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn add_explicit_type(ctx: AssistCtx) -> Option<Assist> {\n     let stmt = ctx.find_node_at_offset::<LetStmt>()?;\n     let expr = stmt.initializer()?;\n     let pat = stmt.pat()?;\n@@ -34,17 +34,21 @@ pub(crate) fn add_explicit_type(ctx: AssistCtx<impl HirDatabase>) -> Option<Assi\n     // The binding must have a name\n     let name = pat.name()?;\n     let name_range = name.syntax().text_range();\n-    // Assist should only be applicable if cursor is between 'let' and '='\n     let stmt_range = stmt.syntax().text_range();\n     let eq_range = stmt.eq_token()?.text_range();\n+    // Assist should only be applicable if cursor is between 'let' and '='\n     let let_range = TextRange::from_to(stmt_range.start(), eq_range.start());\n     let cursor_in_range = ctx.frange.range.is_subrange(&let_range);\n     if !cursor_in_range {\n         return None;\n     }\n     // Assist not applicable if the type has already been specified\n-    if stmt.syntax().children_with_tokens().any(|child| child.kind() == T![:]) {\n-        return None;\n+    // and it has no placeholders\n+    let ascribed_ty = stmt.ascribed_type();\n+    if let Some(ref ty) = ascribed_ty {\n+        if ty.syntax().descendants().find_map(ast::PlaceholderType::cast).is_none() {\n+            return None;\n+        }\n     }\n     // Infer type\n     let db = ctx.db;\n@@ -60,7 +64,11 @@ pub(crate) fn add_explicit_type(ctx: AssistCtx<impl HirDatabase>) -> Option<Assi\n         format!(\"Insert explicit type '{}'\", ty.display(db)),\n         |edit| {\n             edit.target(pat_range);\n-            edit.insert(name_range.end(), format!(\": {}\", ty.display(db)));\n+            if let Some(ascribed_ty) = ascribed_ty {\n+                edit.replace(ascribed_ty.syntax().text_range(), format!(\"{}\", ty.display(db)));\n+            } else {\n+                edit.insert(name_range.end(), format!(\": {}\", ty.display(db)));\n+            }\n         },\n     )\n }\n@@ -85,6 +93,40 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn add_explicit_type_works_for_underscore() {\n+        check_assist(\n+            add_explicit_type,\n+            \"fn f() { let a<|>: _ = 1; }\",\n+            \"fn f() { let a<|>: i32 = 1; }\",\n+        );\n+    }\n+\n+    #[test]\n+    fn add_explicit_type_works_for_nested_underscore() {\n+        check_assist(\n+            add_explicit_type,\n+            r#\"\n+            enum Option<T> {\n+                Some(T),\n+                None\n+            }\n+\n+            fn f() {\n+                let a<|>: Option<_> = Option::Some(1);\n+            }\"#,\n+            r#\"\n+            enum Option<T> {\n+                Some(T),\n+                None\n+            }\n+\n+            fn f() {\n+                let a<|>: Option<i32> = Option::Some(1);\n+            }\"#,\n+        );\n+    }\n+\n     #[test]\n     fn add_explicit_type_works_for_macro_call() {\n         check_assist(", "previous_filename": "crates/ra_assists/src/assists/add_explicit_type.rs"}, {"sha": "241b085fd2265648c6e098ea26d94b8e90c3bf55", "filename": "crates/ra_assists/src/handlers/add_impl.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,5 +1,5 @@\n use format_buf::format;\n-use hir::db::HirDatabase;\n+\n use join_to_string::join;\n use ra_syntax::{\n     ast::{self, AstNode, NameOwner, TypeParamsOwner},\n@@ -27,7 +27,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //\n // }\n // ```\n-pub(crate) fn add_impl(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn add_impl(ctx: AssistCtx) -> Option<Assist> {\n     let nominal = ctx.find_node_at_offset::<ast::NominalDef>()?;\n     let name = nominal.name()?;\n     ctx.add_assist(AssistId(\"add_impl\"), format!(\"Implement {}\", name.text().as_str()), |edit| {", "previous_filename": "crates/ra_assists/src/assists/add_impl.rs"}, {"sha": "448697d3151749f9d5c98eb33744373a8206a939", "filename": "crates/ra_assists/src/handlers/add_missing_impl_members.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -43,7 +43,7 @@ enum AddMissingImplMembersMode {\n //\n // }\n // ```\n-pub(crate) fn add_missing_impl_members(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn add_missing_impl_members(ctx: AssistCtx) -> Option<Assist> {\n     add_missing_impl_members_inner(\n         ctx,\n         AddMissingImplMembersMode::NoDefaultMethods,\n@@ -84,7 +84,7 @@ pub(crate) fn add_missing_impl_members(ctx: AssistCtx<impl HirDatabase>) -> Opti\n //\n // }\n // ```\n-pub(crate) fn add_missing_default_members(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn add_missing_default_members(ctx: AssistCtx) -> Option<Assist> {\n     add_missing_impl_members_inner(\n         ctx,\n         AddMissingImplMembersMode::DefaultMethodsOnly,\n@@ -94,11 +94,12 @@ pub(crate) fn add_missing_default_members(ctx: AssistCtx<impl HirDatabase>) -> O\n }\n \n fn add_missing_impl_members_inner(\n-    ctx: AssistCtx<impl HirDatabase>,\n+    ctx: AssistCtx,\n     mode: AddMissingImplMembersMode,\n     assist_id: &'static str,\n     label: &'static str,\n ) -> Option<Assist> {\n+    let _p = ra_prof::profile(\"add_missing_impl_members_inner\");\n     let impl_node = ctx.find_node_at_offset::<ast::ImplBlock>()?;\n     let impl_item_list = impl_node.item_list()?;\n ", "previous_filename": "crates/ra_assists/src/assists/add_missing_impl_members.rs"}, {"sha": "2701eddb80c53a043244bd589c07813101668457", "filename": "crates/ra_assists/src/handlers/add_new.rs", "status": "renamed", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,5 +1,5 @@\n use format_buf::format;\n-use hir::{db::HirDatabase, InFile};\n+use hir::{Adt, InFile};\n use join_to_string::join;\n use ra_syntax::{\n     ast::{\n@@ -31,7 +31,7 @@ use crate::{Assist, AssistCtx, AssistId};\n // }\n //\n // ```\n-pub(crate) fn add_new(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn add_new(ctx: AssistCtx) -> Option<Assist> {\n     let strukt = ctx.find_node_at_offset::<ast::StructDef>()?;\n \n     // We want to only apply this to non-union structs with named fields\n@@ -128,26 +128,29 @@ fn generate_impl_text(strukt: &ast::StructDef, code: &str) -> String {\n //\n // FIXME: change the new fn checking to a more semantic approach when that's more\n // viable (e.g. we process proc macros, etc)\n-fn find_struct_impl(\n-    ctx: &AssistCtx<impl HirDatabase>,\n-    strukt: &ast::StructDef,\n-) -> Option<Option<ast::ImplBlock>> {\n+fn find_struct_impl(ctx: &AssistCtx, strukt: &ast::StructDef) -> Option<Option<ast::ImplBlock>> {\n     let db = ctx.db;\n     let module = strukt.syntax().ancestors().find(|node| {\n         ast::Module::can_cast(node.kind()) || ast::SourceFile::can_cast(node.kind())\n     })?;\n     let mut sb = ctx.source_binder();\n \n-    let struct_ty = {\n+    let struct_def = {\n         let src = InFile { file_id: ctx.frange.file_id.into(), value: strukt.clone() };\n-        sb.to_def(src)?.ty(db)\n+        sb.to_def(src)?\n     };\n \n     let block = module.descendants().filter_map(ast::ImplBlock::cast).find_map(|impl_blk| {\n         let src = InFile { file_id: ctx.frange.file_id.into(), value: impl_blk.clone() };\n         let blk = sb.to_def(src)?;\n \n-        let same_ty = blk.target_ty(db) == struct_ty;\n+        // FIXME: handle e.g. `struct S<T>; impl<U> S<U> {}`\n+        // (we currently use the wrong type parameter)\n+        // also we wouldn't want to use e.g. `impl S<u32>`\n+        let same_ty = match blk.target_ty(db).as_adt() {\n+            Some(def) => def == Adt::Struct(struct_def),\n+            None => false,\n+        };\n         let not_trait_impl = blk.target_trait(db).is_none();\n \n         if !(same_ty && not_trait_impl) {", "previous_filename": "crates/ra_assists/src/assists/add_new.rs"}, {"sha": "239807e2431de32bd2a67c24a5321f4913398c0d", "filename": "crates/ra_assists/src/handlers/apply_demorgan.rs", "status": "renamed", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,8 +1,6 @@\n-use super::invert_if::invert_boolean_expression;\n-use hir::db::HirDatabase;\n use ra_syntax::ast::{self, AstNode};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{utils::invert_boolean_expression, Assist, AssistCtx, AssistId};\n \n // Assist: apply_demorgan\n //\n@@ -23,7 +21,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     if !(x == 4 && y) {}\n // }\n // ```\n-pub(crate) fn apply_demorgan(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn apply_demorgan(ctx: AssistCtx) -> Option<Assist> {\n     let expr = ctx.find_node_at_offset::<ast::BinExpr>()?;\n     let op = expr.op_kind()?;\n     let op_range = expr.op_token()?.text_range();\n@@ -32,12 +30,14 @@ pub(crate) fn apply_demorgan(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist>\n     if !cursor_in_range {\n         return None;\n     }\n+\n     let lhs = expr.lhs()?;\n     let lhs_range = lhs.syntax().text_range();\n+    let not_lhs = invert_boolean_expression(lhs);\n+\n     let rhs = expr.rhs()?;\n     let rhs_range = rhs.syntax().text_range();\n-    let not_lhs = invert_boolean_expression(&lhs)?;\n-    let not_rhs = invert_boolean_expression(&rhs)?;\n+    let not_rhs = invert_boolean_expression(rhs);\n \n     ctx.add_assist(AssistId(\"apply_demorgan\"), \"Apply De Morgan's law\", |edit| {\n         edit.target(op_range);\n@@ -78,12 +78,12 @@ mod tests {\n     }\n \n     #[test]\n-    fn demorgan_doesnt_apply_with_cursor_not_on_op() {\n-        check_assist_not_applicable(apply_demorgan, \"fn f() { <|> !x || !x }\")\n+    fn demorgan_general_case() {\n+        check_assist(apply_demorgan, \"fn f() { x ||<|> x }\", \"fn f() { !(!x &&<|> !x) }\")\n     }\n \n     #[test]\n-    fn demorgan_doesnt_apply_when_operands_arent_negated_already() {\n-        check_assist_not_applicable(apply_demorgan, \"fn f() { x ||<|> x }\")\n+    fn demorgan_doesnt_apply_with_cursor_not_on_op() {\n+        check_assist_not_applicable(apply_demorgan, \"fn f() { <|> !x || !x }\")\n     }\n }", "previous_filename": "crates/ra_assists/src/assists/apply_demorgan.rs"}, {"sha": "1fb701da5f7f90ba4b8122406a6a096c40cd74d8", "filename": "crates/ra_assists/src/handlers/auto_import.rs", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,293 @@\n+use ra_ide_db::imports_locator::ImportsLocator;\n+use ra_syntax::ast::{self, AstNode};\n+\n+use crate::{\n+    assist_ctx::{Assist, AssistCtx},\n+    insert_use_statement, AssistId,\n+};\n+use std::collections::BTreeSet;\n+\n+// Assist: auto_import\n+//\n+// If the name is unresolved, provides all possible imports for it.\n+//\n+// ```\n+// fn main() {\n+//     let map = HashMap<|>::new();\n+// }\n+// # pub mod std { pub mod collections { pub struct HashMap { } } }\n+// ```\n+// ->\n+// ```\n+// use std::collections::HashMap;\n+//\n+// fn main() {\n+//     let map = HashMap::new();\n+// }\n+// # pub mod std { pub mod collections { pub struct HashMap { } } }\n+// ```\n+pub(crate) fn auto_import(ctx: AssistCtx) -> Option<Assist> {\n+    let path_under_caret: ast::Path = ctx.find_node_at_offset()?;\n+    if path_under_caret.syntax().ancestors().find_map(ast::UseItem::cast).is_some() {\n+        return None;\n+    }\n+\n+    let module = path_under_caret.syntax().ancestors().find_map(ast::Module::cast);\n+    let position = match module.and_then(|it| it.item_list()) {\n+        Some(item_list) => item_list.syntax().clone(),\n+        None => {\n+            let current_file =\n+                path_under_caret.syntax().ancestors().find_map(ast::SourceFile::cast)?;\n+            current_file.syntax().clone()\n+        }\n+    };\n+    let source_analyzer = ctx.source_analyzer(&position, None);\n+    let module_with_name_to_import = source_analyzer.module()?;\n+\n+    let name_ref_to_import =\n+        path_under_caret.syntax().descendants().find_map(ast::NameRef::cast)?;\n+    if source_analyzer\n+        .resolve_path(ctx.db, &name_ref_to_import.syntax().ancestors().find_map(ast::Path::cast)?)\n+        .is_some()\n+    {\n+        return None;\n+    }\n+\n+    let name_to_import = name_ref_to_import.syntax().to_string();\n+    let proposed_imports = ImportsLocator::new(ctx.db)\n+        .find_imports(&name_to_import)\n+        .into_iter()\n+        .filter_map(|module_def| module_with_name_to_import.find_use_path(ctx.db, module_def))\n+        .filter(|use_path| !use_path.segments.is_empty())\n+        .take(20)\n+        .collect::<BTreeSet<_>>();\n+\n+    if proposed_imports.is_empty() {\n+        return None;\n+    }\n+\n+    let mut group = ctx.add_assist_group(format!(\"Import {}\", name_to_import));\n+    for import in proposed_imports {\n+        group.add_assist(AssistId(\"auto_import\"), format!(\"Import `{}`\", &import), |edit| {\n+            edit.target(path_under_caret.syntax().text_range());\n+            insert_use_statement(\n+                &position,\n+                path_under_caret.syntax(),\n+                &import,\n+                edit.text_edit_builder(),\n+            );\n+        });\n+    }\n+    group.finish()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn applicable_when_found_an_import() {\n+        check_assist(\n+            auto_import,\n+            r\"\n+            <|>PubStruct\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\n+            \",\n+            r\"\n+            <|>use PubMod::PubStruct;\n+\n+            PubStruct\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn auto_imports_are_merged() {\n+        check_assist(\n+            auto_import,\n+            r\"\n+            use PubMod::PubStruct1;\n+\n+            struct Test {\n+                test: Pub<|>Struct2<u8>,\n+            }\n+\n+            pub mod PubMod {\n+                pub struct PubStruct1;\n+                pub struct PubStruct2<T> {\n+                    _t: T,\n+                }\n+            }\n+            \",\n+            r\"\n+            use PubMod::{PubStruct2, PubStruct1};\n+\n+            struct Test {\n+                test: Pub<|>Struct2<u8>,\n+            }\n+\n+            pub mod PubMod {\n+                pub struct PubStruct1;\n+                pub struct PubStruct2<T> {\n+                    _t: T,\n+                }\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn applicable_when_found_multiple_imports() {\n+        check_assist(\n+            auto_import,\n+            r\"\n+            PubSt<|>ruct\n+\n+            pub mod PubMod1 {\n+                pub struct PubStruct;\n+            }\n+            pub mod PubMod2 {\n+                pub struct PubStruct;\n+            }\n+            pub mod PubMod3 {\n+                pub struct PubStruct;\n+            }\n+            \",\n+            r\"\n+            use PubMod1::PubStruct;\n+\n+            PubSt<|>ruct\n+\n+            pub mod PubMod1 {\n+                pub struct PubStruct;\n+            }\n+            pub mod PubMod2 {\n+                pub struct PubStruct;\n+            }\n+            pub mod PubMod3 {\n+                pub struct PubStruct;\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_already_imported_types() {\n+        check_assist_not_applicable(\n+            auto_import,\n+            r\"\n+            use PubMod::PubStruct;\n+\n+            PubStruct<|>\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_types_with_private_paths() {\n+        check_assist_not_applicable(\n+            auto_import,\n+            r\"\n+            PrivateStruct<|>\n+\n+            pub mod PubMod {\n+                struct PrivateStruct;\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_when_no_imports_found() {\n+        check_assist_not_applicable(\n+            auto_import,\n+            \"\n+            PubStruct<|>\",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_in_import_statements() {\n+        check_assist_not_applicable(\n+            auto_import,\n+            r\"\n+            use PubStruct<|>;\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\",\n+        );\n+    }\n+\n+    #[test]\n+    fn function_import() {\n+        check_assist(\n+            auto_import,\n+            r\"\n+            test_function<|>\n+\n+            pub mod PubMod {\n+                pub fn test_function() {};\n+            }\n+            \",\n+            r\"\n+            use PubMod::test_function;\n+\n+            test_function<|>\n+\n+            pub mod PubMod {\n+                pub fn test_function() {};\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn auto_import_target() {\n+        check_assist_target(\n+            auto_import,\n+            r\"\n+            struct AssistInfo {\n+                group_label: Option<<|>GroupLabel>,\n+            }\n+\n+            mod m { pub struct GroupLabel; }\n+            \",\n+            \"GroupLabel\",\n+        )\n+    }\n+\n+    #[test]\n+    fn not_applicable_when_path_start_is_imported() {\n+        check_assist_not_applicable(\n+            auto_import,\n+            r\"\n+            pub mod mod1 {\n+                pub mod mod2 {\n+                    pub mod mod3 {\n+                        pub struct TestStruct;\n+                    }\n+                }\n+            }\n+\n+            use mod1::mod2;\n+            fn main() {\n+                mod2::mod3::TestStruct<|>\n+            }\n+            \",\n+        );\n+    }\n+}"}, {"sha": "f325b6f9225bf92290255b228bbee215d76ed932", "filename": "crates/ra_assists/src/handlers/change_visibility.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,4 +1,3 @@\n-use hir::db::HirDatabase;\n use ra_syntax::{\n     ast::{self, NameOwner, VisibilityOwner},\n     AstNode,\n@@ -22,14 +21,14 @@ use crate::{Assist, AssistCtx, AssistId};\n // ```\n // pub(crate) fn frobnicate() {}\n // ```\n-pub(crate) fn change_visibility(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn change_visibility(ctx: AssistCtx) -> Option<Assist> {\n     if let Some(vis) = ctx.find_node_at_offset::<ast::Visibility>() {\n         return change_vis(ctx, vis);\n     }\n     add_vis(ctx)\n }\n \n-fn add_vis(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+fn add_vis(ctx: AssistCtx) -> Option<Assist> {\n     let item_keyword = ctx.token_at_offset().find(|leaf| match leaf.kind() {\n         T![fn] | T![mod] | T![struct] | T![enum] | T![trait] => true,\n         _ => false,\n@@ -75,7 +74,7 @@ fn vis_offset(node: &SyntaxNode) -> TextUnit {\n         .unwrap_or_else(|| node.text_range().start())\n }\n \n-fn change_vis(ctx: AssistCtx<impl HirDatabase>, vis: ast::Visibility) -> Option<Assist> {\n+fn change_vis(ctx: AssistCtx, vis: ast::Visibility) -> Option<Assist> {\n     if vis.syntax().text() == \"pub\" {\n         return ctx.add_assist(\n             AssistId(\"change_visibility\"),", "previous_filename": "crates/ra_assists/src/assists/change_visibility.rs"}, {"sha": "22f88884f4a17774671c516e251f8f7c031ddf84", "filename": "crates/ra_assists/src/handlers/early_return.rs", "status": "renamed", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,6 +1,5 @@\n use std::{iter::once, ops::RangeInclusive};\n \n-use hir::db::HirDatabase;\n use ra_syntax::{\n     algo::replace_children,\n     ast::{self, edit::IndentLevel, make, Block, Pat::TupleStructPat},\n@@ -11,6 +10,7 @@ use ra_syntax::{\n \n use crate::{\n     assist_ctx::{Assist, AssistCtx},\n+    utils::invert_boolean_expression,\n     AssistId,\n };\n \n@@ -36,7 +36,7 @@ use crate::{\n //     bar();\n // }\n // ```\n-pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn convert_to_guarded_return(ctx: AssistCtx) -> Option<Assist> {\n     let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;\n     if if_expr.else_branch().is_some() {\n         return None;\n@@ -100,9 +100,13 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Opt\n         let new_block = match if_let_pat {\n             None => {\n                 // If.\n-                let early_expression = &(early_expression.syntax().to_string() + \";\");\n-                let new_expr = if_indent_level\n-                    .increase_indent(make::if_expression(&cond_expr, early_expression));\n+                let new_expr = {\n+                    let then_branch =\n+                        make::block_expr(once(make::expr_stmt(early_expression).into()), None);\n+                    let cond = invert_boolean_expression(cond_expr);\n+                    let e = make::expr_if(cond, then_branch);\n+                    if_indent_level.increase_indent(e)\n+                };\n                 replace(new_expr.syntax(), &then_block, &parent_block, &if_expr)\n             }\n             Some((path, bound_ident)) => {", "previous_filename": "crates/ra_assists/src/assists/early_return.rs"}, {"sha": "0908fc2469f70217e28d1ff3f7f5f708048cbbea", "filename": "crates/ra_assists/src/handlers/fill_match_arms.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -31,7 +31,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     }\n // }\n // ```\n-pub(crate) fn fill_match_arms(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n     let match_expr = ctx.find_node_at_offset::<ast::MatchExpr>()?;\n     let match_arm_list = match_expr.match_arm_list()?;\n ", "previous_filename": "crates/ra_assists/src/assists/fill_match_arms.rs"}, {"sha": "bfcc09e909779d08a9b5ff6578182e80a45e0d60", "filename": "crates/ra_assists/src/handlers/flip_binexpr.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,4 +1,3 @@\n-use hir::db::HirDatabase;\n use ra_syntax::ast::{AstNode, BinExpr, BinOp};\n \n use crate::{Assist, AssistCtx, AssistId};\n@@ -18,7 +17,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     let _ = 2 + 90;\n // }\n // ```\n-pub(crate) fn flip_binexpr(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn flip_binexpr(ctx: AssistCtx) -> Option<Assist> {\n     let expr = ctx.find_node_at_offset::<BinExpr>()?;\n     let lhs = expr.lhs()?.syntax().clone();\n     let rhs = expr.rhs()?.syntax().clone();", "previous_filename": "crates/ra_assists/src/assists/flip_binexpr.rs"}, {"sha": "1dacf29f834280f3f0c0197a21a76ad94cdf4c57", "filename": "crates/ra_assists/src/handlers/flip_comma.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_comma.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,4 +1,3 @@\n-use hir::db::HirDatabase;\n use ra_syntax::{algo::non_trivia_sibling, Direction, T};\n \n use crate::{Assist, AssistCtx, AssistId};\n@@ -18,7 +17,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     ((3, 4), (1, 2));\n // }\n // ```\n-pub(crate) fn flip_comma(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn flip_comma(ctx: AssistCtx) -> Option<Assist> {\n     let comma = ctx.find_token_at_offset(T![,])?;\n     let prev = non_trivia_sibling(comma.clone().into(), Direction::Prev)?;\n     let next = non_trivia_sibling(comma.clone().into(), Direction::Next)?;", "previous_filename": "crates/ra_assists/src/assists/flip_comma.rs"}, {"sha": "f56769624e7fcaf70b628648f77f7df47dff078f", "filename": "crates/ra_assists/src/handlers/flip_trait_bound.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,4 +1,3 @@\n-use hir::db::HirDatabase;\n use ra_syntax::{\n     algo::non_trivia_sibling,\n     ast::{self, AstNode},\n@@ -18,7 +17,7 @@ use crate::{Assist, AssistCtx, AssistId};\n // ```\n // fn foo<T: Copy + Clone>() { }\n // ```\n-pub(crate) fn flip_trait_bound(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn flip_trait_bound(ctx: AssistCtx) -> Option<Assist> {\n     // We want to replicate the behavior of `flip_binexpr` by only suggesting\n     // the assist when the cursor is on a `+`\n     let plus = ctx.find_token_at_offset(T![+])?;", "previous_filename": "crates/ra_assists/src/assists/flip_trait_bound.rs"}, {"sha": "91b588243eb4f40ec82f71bc19b2f219639337a5", "filename": "crates/ra_assists/src/handlers/inline_local_variable.rs", "status": "renamed", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,4 +1,3 @@\n-use hir::db::HirDatabase;\n use ra_syntax::{\n     ast::{self, AstNode, AstToken},\n     TextRange,\n@@ -23,7 +22,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     (1 + 2) * 4;\n // }\n // ```\n-pub(crate) fn inline_local_variable(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn inline_local_variable(ctx: AssistCtx) -> Option<Assist> {\n     let let_stmt = ctx.find_node_at_offset::<ast::LetStmt>()?;\n     let bind_pat = match let_stmt.pat()? {\n         ast::Pat::BindPat(pat) => pat,\n@@ -47,6 +46,9 @@ pub(crate) fn inline_local_variable(ctx: AssistCtx<impl HirDatabase>) -> Option<\n     };\n     let analyzer = ctx.source_analyzer(bind_pat.syntax(), None);\n     let refs = analyzer.find_all_refs(&bind_pat);\n+    if refs.is_empty() {\n+        return None;\n+    };\n \n     let mut wrap_in_parens = vec![true; refs.len()];\n \n@@ -645,4 +647,16 @@ fn foo() {\n }\",\n         );\n     }\n+\n+    #[test]\n+    fn test_not_applicable_if_variable_unused() {\n+        check_assist_not_applicable(\n+            inline_local_variable,\n+            \"\n+fn foo() {\n+    let <|>a = 0;\n+}\n+            \",\n+        )\n+    }\n }", "previous_filename": "crates/ra_assists/src/assists/inline_local_variable.rs"}, {"sha": "7312ce6871e0e64ad54200a597c6c1aa8656b922", "filename": "crates/ra_assists/src/handlers/introduce_variable.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,5 +1,4 @@\n use format_buf::format;\n-use hir::db::HirDatabase;\n use ra_syntax::{\n     ast::{self, AstNode},\n     SyntaxKind::{\n@@ -28,7 +27,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     var_name * 4;\n // }\n // ```\n-pub(crate) fn introduce_variable(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn introduce_variable(ctx: AssistCtx) -> Option<Assist> {\n     if ctx.frange.range.is_empty() {\n         return None;\n     }", "previous_filename": "crates/ra_assists/src/assists/introduce_variable.rs"}, {"sha": "a594e7e0c38ac049ef30d1d50a8490f61c213a6b", "filename": "crates/ra_assists/src/handlers/invert_if.rs", "status": "renamed", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,8 +1,7 @@\n-use hir::db::HirDatabase;\n use ra_syntax::ast::{self, AstNode};\n use ra_syntax::T;\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{utils::invert_boolean_expression, Assist, AssistCtx, AssistId};\n \n // Assist: invert_if\n //\n@@ -23,7 +22,7 @@ use crate::{Assist, AssistCtx, AssistId};\n // }\n // ```\n \n-pub(crate) fn invert_if(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn invert_if(ctx: AssistCtx) -> Option<Assist> {\n     let if_keyword = ctx.find_token_at_offset(T![if])?;\n     let expr = ast::IfExpr::cast(if_keyword.parent())?;\n     let if_range = if_keyword.text_range();\n@@ -36,8 +35,8 @@ pub(crate) fn invert_if(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let then_node = expr.then_branch()?.syntax().clone();\n \n     if let ast::ElseBranch::Block(else_block) = expr.else_branch()? {\n-        let flip_cond = invert_boolean_expression(&cond)?;\n         let cond_range = cond.syntax().text_range();\n+        let flip_cond = invert_boolean_expression(cond);\n         let else_node = else_block.syntax();\n         let else_range = else_node.text_range();\n         let then_range = then_node.text_range();\n@@ -52,20 +51,6 @@ pub(crate) fn invert_if(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     None\n }\n \n-pub(crate) fn invert_boolean_expression(expr: &ast::Expr) -> Option<ast::Expr> {\n-    match expr {\n-        ast::Expr::BinExpr(bin) => match bin.op_kind()? {\n-            ast::BinOp::NegatedEqualityTest => bin.replace_op(T![==]).map(|it| it.into()),\n-            _ => None,\n-        },\n-        ast::Expr::PrefixExpr(pe) => match pe.op_kind()? {\n-            ast::PrefixOp::Not => pe.expr(),\n-            _ => None,\n-        },\n-        _ => None,\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -91,12 +76,16 @@ mod tests {\n     }\n \n     #[test]\n-    fn invert_if_doesnt_apply_with_cursor_not_on_if() {\n-        check_assist_not_applicable(invert_if, \"fn f() { if !<|>cond { 3 * 2 } else { 1 } }\")\n+    fn invert_if_general_case() {\n+        check_assist(\n+            invert_if,\n+            \"fn f() { i<|>f cond { 3 * 2 } else { 1 } }\",\n+            \"fn f() { i<|>f !cond { 1 } else { 3 * 2 } }\",\n+        )\n     }\n \n     #[test]\n-    fn invert_if_doesnt_apply_without_negated() {\n-        check_assist_not_applicable(invert_if, \"fn f() { i<|>f cond { 3 * 2 } else { 1 } }\")\n+    fn invert_if_doesnt_apply_with_cursor_not_on_if() {\n+        check_assist_not_applicable(invert_if, \"fn f() { if !<|>cond { 3 * 2 } else { 1 } }\")\n     }\n }", "previous_filename": "crates/ra_assists/src/assists/invert_if.rs"}, {"sha": "670614dd83df1b7aee8a717f62d30e0a3f5d3300", "filename": "crates/ra_assists/src/handlers/merge_match_arms.rs", "status": "renamed", "additions": 92, "deletions": 38, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,6 +1,11 @@\n-use crate::{Assist, AssistCtx, AssistId, TextRange, TextUnit};\n-use hir::db::HirDatabase;\n-use ra_syntax::ast::{AstNode, MatchArm};\n+use std::iter::successors;\n+\n+use ra_syntax::{\n+    ast::{self, AstNode},\n+    Direction, TextUnit,\n+};\n+\n+use crate::{Assist, AssistCtx, AssistId, TextRange};\n \n // Assist: merge_match_arms\n //\n@@ -26,63 +31,81 @@ use ra_syntax::ast::{AstNode, MatchArm};\n //     }\n // }\n // ```\n-pub(crate) fn merge_match_arms(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let current_arm = ctx.find_node_at_offset::<MatchArm>()?;\n-\n-    // We check if the following match arm matches this one. We could, but don't,\n-    // compare to the previous match arm as well.\n-    let next = current_arm.syntax().next_sibling();\n-    let next_arm = MatchArm::cast(next?)?;\n-\n+pub(crate) fn merge_match_arms(ctx: AssistCtx) -> Option<Assist> {\n+    let current_arm = ctx.find_node_at_offset::<ast::MatchArm>()?;\n     // Don't try to handle arms with guards for now - can add support for this later\n-    if current_arm.guard().is_some() || next_arm.guard().is_some() {\n+    if current_arm.guard().is_some() {\n         return None;\n     }\n-\n     let current_expr = current_arm.expr()?;\n-    let next_expr = next_arm.expr()?;\n+    let current_text_range = current_arm.syntax().text_range();\n \n-    // Check for match arm equality by comparing lengths and then string contents\n-    if current_expr.syntax().text_range().len() != next_expr.syntax().text_range().len() {\n-        return None;\n+    enum CursorPos {\n+        InExpr(TextUnit),\n+        InPat(TextUnit),\n     }\n-    if current_expr.syntax().text() != next_expr.syntax().text() {\n+    let cursor_pos = ctx.frange.range.start();\n+    let cursor_pos = if current_expr.syntax().text_range().contains(cursor_pos) {\n+        CursorPos::InExpr(current_text_range.end() - cursor_pos)\n+    } else {\n+        CursorPos::InPat(cursor_pos)\n+    };\n+\n+    // We check if the following match arms match this one. We could, but don't,\n+    // compare to the previous match arm as well.\n+    let arms_to_merge = successors(Some(current_arm), next_arm)\n+        .take_while(|arm| {\n+            if arm.guard().is_some() {\n+                return false;\n+            }\n+            match arm.expr() {\n+                Some(expr) => expr.syntax().text() == current_expr.syntax().text(),\n+                None => false,\n+            }\n+        })\n+        .collect::<Vec<_>>();\n+\n+    if arms_to_merge.len() <= 1 {\n         return None;\n     }\n \n-    let cursor_to_end = current_arm.syntax().text_range().end() - ctx.frange.range.start();\n-\n     ctx.add_assist(AssistId(\"merge_match_arms\"), \"Merge match arms\", |edit| {\n-        fn contains_placeholder(a: &MatchArm) -> bool {\n-            a.pats().any(|x| match x {\n-                ra_syntax::ast::Pat::PlaceholderPat(..) => true,\n-                _ => false,\n-            })\n-        }\n-\n-        let pats = if contains_placeholder(&current_arm) || contains_placeholder(&next_arm) {\n+        let pats = if arms_to_merge.iter().any(contains_placeholder) {\n             \"_\".into()\n         } else {\n-            let ps: Vec<String> = current_arm\n-                .pats()\n+            arms_to_merge\n+                .iter()\n+                .flat_map(ast::MatchArm::pats)\n                 .map(|x| x.syntax().to_string())\n-                .chain(next_arm.pats().map(|x| x.syntax().to_string()))\n-                .collect();\n-            ps.join(\" | \")\n+                .collect::<Vec<String>>()\n+                .join(\" | \")\n         };\n \n         let arm = format!(\"{} => {}\", pats, current_expr.syntax().text());\n-        let offset = TextUnit::from_usize(arm.len()) - cursor_to_end;\n \n-        let start = current_arm.syntax().text_range().start();\n-        let end = next_arm.syntax().text_range().end();\n+        let start = arms_to_merge.first().unwrap().syntax().text_range().start();\n+        let end = arms_to_merge.last().unwrap().syntax().text_range().end();\n \n-        edit.target(current_arm.syntax().text_range());\n+        edit.target(current_text_range);\n+        edit.set_cursor(match cursor_pos {\n+            CursorPos::InExpr(back_offset) => start + TextUnit::from_usize(arm.len()) - back_offset,\n+            CursorPos::InPat(offset) => offset,\n+        });\n         edit.replace(TextRange::from_to(start, end), arm);\n-        edit.set_cursor(start + offset);\n     })\n }\n \n+fn contains_placeholder(a: &ast::MatchArm) -> bool {\n+    a.pats().any(|x| match x {\n+        ra_syntax::ast::Pat::PlaceholderPat(..) => true,\n+        _ => false,\n+    })\n+}\n+\n+fn next_arm(arm: &ast::MatchArm) -> Option<ast::MatchArm> {\n+    arm.syntax().siblings(Direction::Next).skip(1).find_map(ast::MatchArm::cast)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::merge_match_arms;\n@@ -184,6 +207,37 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn merges_all_subsequent_arms() {\n+        check_assist(\n+            merge_match_arms,\n+            r#\"\n+            enum X { A, B, C, D, E }\n+\n+            fn main() {\n+                match X::A {\n+                    X::A<|> => 92,\n+                    X::B => 92,\n+                    X::C => 92,\n+                    X::D => 62,\n+                    _ => panic!(),\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            enum X { A, B, C, D, E }\n+\n+            fn main() {\n+                match X::A {\n+                    X::A<|> | X::B | X::C => 92,\n+                    X::D => 62,\n+                    _ => panic!(),\n+                }\n+            }\n+            \"#,\n+        )\n+    }\n+\n     #[test]\n     fn merge_match_arms_rejects_guards() {\n         check_assist_not_applicable(", "previous_filename": "crates/ra_assists/src/assists/merge_match_arms.rs"}, {"sha": "90793b5fc3a16fbb89d593f3f7fc9267be7d6e85", "filename": "crates/ra_assists/src/handlers/move_bounds.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,4 +1,3 @@\n-use hir::db::HirDatabase;\n use ra_syntax::{\n     ast::{self, edit, make, AstNode, NameOwner, TypeBoundsOwner},\n     SyntaxElement,\n@@ -22,7 +21,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     f(x)\n // }\n // ```\n-pub(crate) fn move_bounds_to_where_clause(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn move_bounds_to_where_clause(ctx: AssistCtx) -> Option<Assist> {\n     let type_param_list = ctx.find_node_at_offset::<ast::TypeParamList>()?;\n \n     let mut type_params = type_param_list.type_params();", "previous_filename": "crates/ra_assists/src/assists/move_bounds.rs"}, {"sha": "2b91ce7c4dc7836a9491f79da4419e2a4597900f", "filename": "crates/ra_assists/src/handlers/move_guard.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,4 +1,3 @@\n-use hir::db::HirDatabase;\n use ra_syntax::{\n     ast,\n     ast::{AstNode, AstToken, IfExpr, MatchArm},\n@@ -32,7 +31,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     }\n // }\n // ```\n-pub(crate) fn move_guard_to_arm_body(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn move_guard_to_arm_body(ctx: AssistCtx) -> Option<Assist> {\n     let match_arm = ctx.find_node_at_offset::<MatchArm>()?;\n     let guard = match_arm.guard()?;\n     let space_before_guard = guard.syntax().prev_sibling_or_token();\n@@ -89,7 +88,7 @@ pub(crate) fn move_guard_to_arm_body(ctx: AssistCtx<impl HirDatabase>) -> Option\n //     }\n // }\n // ```\n-pub(crate) fn move_arm_cond_to_match_guard(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn move_arm_cond_to_match_guard(ctx: AssistCtx) -> Option<Assist> {\n     let match_arm: MatchArm = ctx.find_node_at_offset::<MatchArm>()?;\n     let last_match_pat = match_arm.pats().last()?;\n ", "previous_filename": "crates/ra_assists/src/assists/move_guard.rs"}, {"sha": "2c0a1e12656de1b191ccdeb2358c10d780310d70", "filename": "crates/ra_assists/src/handlers/raw_string.rs", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,4 +1,3 @@\n-use hir::db::HirDatabase;\n use ra_syntax::{\n     ast, AstToken,\n     SyntaxKind::{RAW_STRING, STRING},\n@@ -22,7 +21,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     r#\"Hello, World!\"#;\n // }\n // ```\n-pub(crate) fn make_raw_string(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn make_raw_string(ctx: AssistCtx) -> Option<Assist> {\n     let token = ctx.find_token_at_offset(STRING).and_then(ast::String::cast)?;\n     let value = token.value()?;\n     ctx.add_assist(AssistId(\"make_raw_string\"), \"Rewrite as raw string\", |edit| {\n@@ -51,7 +50,7 @@ pub(crate) fn make_raw_string(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist\n //     \"Hello, \\\"World!\\\"\";\n // }\n // ```\n-pub(crate) fn make_usual_string(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn make_usual_string(ctx: AssistCtx) -> Option<Assist> {\n     let token = ctx.find_token_at_offset(RAW_STRING).and_then(ast::RawString::cast)?;\n     let value = token.value()?;\n     ctx.add_assist(AssistId(\"make_usual_string\"), \"Rewrite as regular string\", |edit| {\n@@ -77,7 +76,7 @@ pub(crate) fn make_usual_string(ctx: AssistCtx<impl HirDatabase>) -> Option<Assi\n //     r##\"Hello, World!\"##;\n // }\n // ```\n-pub(crate) fn add_hash(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn add_hash(ctx: AssistCtx) -> Option<Assist> {\n     let token = ctx.find_token_at_offset(RAW_STRING)?;\n     ctx.add_assist(AssistId(\"add_hash\"), \"Add # to raw string\", |edit| {\n         edit.target(token.text_range());\n@@ -101,7 +100,7 @@ pub(crate) fn add_hash(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n //     r\"Hello, World!\";\n // }\n // ```\n-pub(crate) fn remove_hash(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn remove_hash(ctx: AssistCtx) -> Option<Assist> {\n     let token = ctx.find_token_at_offset(RAW_STRING)?;\n     let text = token.text().as_str();\n     if text.starts_with(\"r\\\"\") {", "previous_filename": "crates/ra_assists/src/assists/raw_string.rs"}, {"sha": "5085649b42aaa05652f1cb76616d48c97f62db9f", "filename": "crates/ra_assists/src/handlers/remove_dbg.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,4 +1,3 @@\n-use hir::db::HirDatabase;\n use ra_syntax::{\n     ast::{self, AstNode},\n     TextUnit, T,\n@@ -21,7 +20,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     92;\n // }\n // ```\n-pub(crate) fn remove_dbg(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn remove_dbg(ctx: AssistCtx) -> Option<Assist> {\n     let macro_call = ctx.find_node_at_offset::<ast::MacroCall>()?;\n \n     if !is_valid_macrocall(&macro_call, \"dbg\")? {", "previous_filename": "crates/ra_assists/src/assists/remove_dbg.rs"}, {"sha": "e6cd50bc1236ae3b6d6219b181442f0b7f61011f", "filename": "crates/ra_assists/src/handlers/replace_if_let_with_match.rs", "status": "renamed", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,9 +1,11 @@\n-use format_buf::format;\n-use hir::db::HirDatabase;\n-use ra_fmt::extract_trivial_expression;\n-use ra_syntax::{ast, AstNode};\n+use ra_fmt::unwrap_trivial_block;\n+use ra_syntax::{\n+    ast::{self, make},\n+    AstNode,\n+};\n \n use crate::{Assist, AssistCtx, AssistId};\n+use ast::edit::IndentLevel;\n \n // Assist: replace_if_let_with_match\n //\n@@ -31,7 +33,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     }\n // }\n // ```\n-pub(crate) fn replace_if_let_with_match(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn replace_if_let_with_match(ctx: AssistCtx) -> Option<Assist> {\n     let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;\n     let cond = if_expr.condition()?;\n     let pat = cond.pat()?;\n@@ -43,32 +45,24 @@ pub(crate) fn replace_if_let_with_match(ctx: AssistCtx<impl HirDatabase>) -> Opt\n     };\n \n     ctx.add_assist(AssistId(\"replace_if_let_with_match\"), \"Replace with match\", |edit| {\n-        let match_expr = build_match_expr(expr, pat, then_block, else_block);\n-        edit.target(if_expr.syntax().text_range());\n-        edit.replace_node_and_indent(if_expr.syntax(), match_expr);\n-        edit.set_cursor(if_expr.syntax().text_range().start())\n-    })\n-}\n+        let match_expr = {\n+            let then_arm = {\n+                let then_expr = unwrap_trivial_block(then_block);\n+                make::match_arm(vec![pat], then_expr)\n+            };\n+            let else_arm = {\n+                let else_expr = unwrap_trivial_block(else_block);\n+                make::match_arm(vec![make::placeholder_pat().into()], else_expr)\n+            };\n+            make::expr_match(expr, make::match_arm_list(vec![then_arm, else_arm]))\n+        };\n \n-fn build_match_expr(\n-    expr: ast::Expr,\n-    pat1: ast::Pat,\n-    arm1: ast::BlockExpr,\n-    arm2: ast::BlockExpr,\n-) -> String {\n-    let mut buf = String::new();\n-    format!(buf, \"match {} {{\\n\", expr.syntax().text());\n-    format!(buf, \"    {} => {}\\n\", pat1.syntax().text(), format_arm(&arm1));\n-    format!(buf, \"    _ => {}\\n\", format_arm(&arm2));\n-    buf.push_str(\"}\");\n-    buf\n-}\n+        let match_expr = IndentLevel::from_node(if_expr.syntax()).increase_indent(match_expr);\n \n-fn format_arm(block: &ast::BlockExpr) -> String {\n-    match extract_trivial_expression(block) {\n-        Some(e) if !e.syntax().text().contains_char('\\n') => format!(\"{},\", e.syntax().text()),\n-        _ => block.syntax().text().to_string(),\n-    }\n+        edit.target(if_expr.syntax().text_range());\n+        edit.set_cursor(if_expr.syntax().text_range().start());\n+        edit.replace_ast::<ast::Expr>(if_expr.into(), match_expr.into());\n+    })\n }\n \n #[cfg(test)]", "previous_filename": "crates/ra_assists/src/assists/replace_if_let_with_match.rs"}, {"sha": "b70c88ec29af85ae6652b04bf16ae7cd8215ff69", "filename": "crates/ra_assists/src/handlers/replace_qualified_name_with_use.rs", "status": "renamed", "additions": 61, "deletions": 63, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,4 +1,4 @@\n-use hir::{self, db::HirDatabase};\n+use hir::{self, ModPath};\n use ra_syntax::{\n     ast::{self, NameOwner},\n     AstNode, Direction, SmolStr,\n@@ -12,18 +12,18 @@ use crate::{\n     AssistId,\n };\n \n-/// This function produces sequence of text edits into edit\n-/// to import the target path in the most appropriate scope given\n-/// the cursor position\n-pub fn auto_import_text_edit(\n+/// Creates and inserts a use statement for the given path to import.\n+/// The use statement is inserted in the scope most appropriate to the\n+/// the cursor position given, additionally merged with the existing use imports.\n+pub fn insert_use_statement(\n     // Ideally the position of the cursor, used to\n     position: &SyntaxNode,\n     // The statement to use as anchor (last resort)\n     anchor: &SyntaxNode,\n-    // The path to import as a sequence of strings\n-    target: &[SmolStr],\n+    path_to_import: &ModPath,\n     edit: &mut TextEditBuilder,\n ) {\n+    let target = path_to_import.to_string().split(\"::\").map(SmolStr::new).collect::<Vec<_>>();\n     let container = position.ancestors().find_map(|n| {\n         if let Some(module) = ast::Module::cast(n.clone()) {\n             return module.item_list().map(|it| it.syntax().clone());\n@@ -32,14 +32,14 @@ pub fn auto_import_text_edit(\n     });\n \n     if let Some(container) = container {\n-        let action = best_action_for_target(container, anchor.clone(), target);\n-        make_assist(&action, target, edit);\n+        let action = best_action_for_target(container, anchor.clone(), &target);\n+        make_assist(&action, &target, edit);\n     }\n }\n \n-// Assist: add_import\n+// Assist: replace_qualified_name_with_use\n //\n-// Adds a use statement for a given fully-qualified path.\n+// Adds a use statement for a given fully-qualified name.\n //\n // ```\n // fn process(map: std::collections::<|>HashMap<String, String>) {}\n@@ -50,7 +50,7 @@ pub fn auto_import_text_edit(\n //\n // fn process(map: HashMap<String, String>) {}\n // ```\n-pub(crate) fn add_import(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn replace_qualified_name_with_use(ctx: AssistCtx) -> Option<Assist> {\n     let path: ast::Path = ctx.find_node_at_offset()?;\n     // We don't want to mess with use statements\n     if path.syntax().ancestors().find_map(ast::UseItem::cast).is_some() {\n@@ -72,9 +72,13 @@ pub(crate) fn add_import(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n         }\n     };\n \n-    ctx.add_assist(AssistId(\"add_import\"), format!(\"Import {}\", fmt_segments(&segments)), |edit| {\n-        apply_auto_import(&position, &path, &segments, edit.text_edit_builder());\n-    })\n+    ctx.add_assist(\n+        AssistId(\"replace_qualified_name_with_use\"),\n+        \"Replace qualified path with use\",\n+        |edit| {\n+            replace_with_use(&position, &path, &segments, edit.text_edit_builder());\n+        },\n+    )\n }\n \n fn collect_path_segments_raw(\n@@ -107,12 +111,6 @@ fn collect_path_segments_raw(\n     Some(segments.len() - oldlen)\n }\n \n-fn fmt_segments(segments: &[SmolStr]) -> String {\n-    let mut buf = String::new();\n-    fmt_segments_raw(segments, &mut buf);\n-    buf\n-}\n-\n fn fmt_segments_raw(segments: &[SmolStr], buf: &mut String) {\n     let mut iter = segments.iter();\n     if let Some(s) = iter.next() {\n@@ -558,7 +556,7 @@ fn make_assist_add_nested_import(\n     }\n }\n \n-fn apply_auto_import(\n+fn replace_with_use(\n     container: &SyntaxNode,\n     path: &ast::Path,\n     target: &[SmolStr],\n@@ -567,7 +565,7 @@ fn apply_auto_import(\n     let action = best_action_for_target(container.clone(), path.syntax().clone(), target);\n     make_assist(&action, target, edit);\n     if let Some(last) = path.segment() {\n-        // Here we are assuming the assist will provide a  correct use statement\n+        // Here we are assuming the assist will provide a correct use statement\n         // so we can delete the path qualifier\n         edit.delete(TextRange::from_to(\n             path.syntax().text_range().start(),\n@@ -603,9 +601,9 @@ mod tests {\n     use super::*;\n \n     #[test]\n-    fn test_auto_import_add_use_no_anchor() {\n+    fn test_replace_add_use_no_anchor() {\n         check_assist(\n-            add_import,\n+            replace_qualified_name_with_use,\n             \"\n std::fmt::Debug<|>\n     \",\n@@ -617,9 +615,9 @@ Debug<|>\n         );\n     }\n     #[test]\n-    fn test_auto_import_add_use_no_anchor_with_item_below() {\n+    fn test_replace_add_use_no_anchor_with_item_below() {\n         check_assist(\n-            add_import,\n+            replace_qualified_name_with_use,\n             \"\n std::fmt::Debug<|>\n \n@@ -638,9 +636,9 @@ fn main() {\n     }\n \n     #[test]\n-    fn test_auto_import_add_use_no_anchor_with_item_above() {\n+    fn test_replace_add_use_no_anchor_with_item_above() {\n         check_assist(\n-            add_import,\n+            replace_qualified_name_with_use,\n             \"\n fn main() {\n }\n@@ -659,9 +657,9 @@ Debug<|>\n     }\n \n     #[test]\n-    fn test_auto_import_add_use_no_anchor_2seg() {\n+    fn test_replace_add_use_no_anchor_2seg() {\n         check_assist(\n-            add_import,\n+            replace_qualified_name_with_use,\n             \"\n std::fmt<|>::Debug\n     \",\n@@ -674,9 +672,9 @@ fmt<|>::Debug\n     }\n \n     #[test]\n-    fn test_auto_import_add_use() {\n+    fn test_replace_add_use() {\n         check_assist(\n-            add_import,\n+            replace_qualified_name_with_use,\n             \"\n use stdx;\n \n@@ -694,9 +692,9 @@ impl Debug<|> for Foo {\n     }\n \n     #[test]\n-    fn test_auto_import_file_use_other_anchor() {\n+    fn test_replace_file_use_other_anchor() {\n         check_assist(\n-            add_import,\n+            replace_qualified_name_with_use,\n             \"\n impl std::fmt::Debug<|> for Foo {\n }\n@@ -711,9 +709,9 @@ impl Debug<|> for Foo {\n     }\n \n     #[test]\n-    fn test_auto_import_add_use_other_anchor_indent() {\n+    fn test_replace_add_use_other_anchor_indent() {\n         check_assist(\n-            add_import,\n+            replace_qualified_name_with_use,\n             \"\n     impl std::fmt::Debug<|> for Foo {\n     }\n@@ -728,9 +726,9 @@ impl Debug<|> for Foo {\n     }\n \n     #[test]\n-    fn test_auto_import_split_different() {\n+    fn test_replace_split_different() {\n         check_assist(\n-            add_import,\n+            replace_qualified_name_with_use,\n             \"\n use std::fmt;\n \n@@ -747,9 +745,9 @@ impl io<|> for Foo {\n     }\n \n     #[test]\n-    fn test_auto_import_split_self_for_use() {\n+    fn test_replace_split_self_for_use() {\n         check_assist(\n-            add_import,\n+            replace_qualified_name_with_use,\n             \"\n use std::fmt;\n \n@@ -766,9 +764,9 @@ impl Debug<|> for Foo {\n     }\n \n     #[test]\n-    fn test_auto_import_split_self_for_target() {\n+    fn test_replace_split_self_for_target() {\n         check_assist(\n-            add_import,\n+            replace_qualified_name_with_use,\n             \"\n use std::fmt::Debug;\n \n@@ -785,9 +783,9 @@ impl fmt<|> for Foo {\n     }\n \n     #[test]\n-    fn test_auto_import_add_to_nested_self_nested() {\n+    fn test_replace_add_to_nested_self_nested() {\n         check_assist(\n-            add_import,\n+            replace_qualified_name_with_use,\n             \"\n use std::fmt::{Debug, nested::{Display}};\n \n@@ -804,9 +802,9 @@ impl nested<|> for Foo {\n     }\n \n     #[test]\n-    fn test_auto_import_add_to_nested_self_already_included() {\n+    fn test_replace_add_to_nested_self_already_included() {\n         check_assist(\n-            add_import,\n+            replace_qualified_name_with_use,\n             \"\n use std::fmt::{Debug, nested::{self, Display}};\n \n@@ -823,9 +821,9 @@ impl nested<|> for Foo {\n     }\n \n     #[test]\n-    fn test_auto_import_add_to_nested_nested() {\n+    fn test_replace_add_to_nested_nested() {\n         check_assist(\n-            add_import,\n+            replace_qualified_name_with_use,\n             \"\n use std::fmt::{Debug, nested::{Display}};\n \n@@ -842,9 +840,9 @@ impl Debug<|> for Foo {\n     }\n \n     #[test]\n-    fn test_auto_import_split_common_target_longer() {\n+    fn test_replace_split_common_target_longer() {\n         check_assist(\n-            add_import,\n+            replace_qualified_name_with_use,\n             \"\n use std::fmt::Debug;\n \n@@ -861,9 +859,9 @@ impl Display<|> for Foo {\n     }\n \n     #[test]\n-    fn test_auto_import_split_common_use_longer() {\n+    fn test_replace_split_common_use_longer() {\n         check_assist(\n-            add_import,\n+            replace_qualified_name_with_use,\n             \"\n use std::fmt::nested::Debug;\n \n@@ -880,9 +878,9 @@ impl Display<|> for Foo {\n     }\n \n     #[test]\n-    fn test_auto_import_use_nested_import() {\n+    fn test_replace_use_nested_import() {\n         check_assist(\n-            add_import,\n+            replace_qualified_name_with_use,\n             \"\n use crate::{\n     ty::{Substs, Ty},\n@@ -903,9 +901,9 @@ fn foo() { lower<|>::trait_env() }\n     }\n \n     #[test]\n-    fn test_auto_import_alias() {\n+    fn test_replace_alias() {\n         check_assist(\n-            add_import,\n+            replace_qualified_name_with_use,\n             \"\n use std::fmt as foo;\n \n@@ -922,9 +920,9 @@ impl Debug<|> for Foo {\n     }\n \n     #[test]\n-    fn test_auto_import_not_applicable_one_segment() {\n+    fn test_replace_not_applicable_one_segment() {\n         check_assist_not_applicable(\n-            add_import,\n+            replace_qualified_name_with_use,\n             \"\n impl foo<|> for Foo {\n }\n@@ -933,19 +931,19 @@ impl foo<|> for Foo {\n     }\n \n     #[test]\n-    fn test_auto_import_not_applicable_in_use() {\n+    fn test_replace_not_applicable_in_use() {\n         check_assist_not_applicable(\n-            add_import,\n+            replace_qualified_name_with_use,\n             \"\n use std::fmt<|>;\n \",\n         );\n     }\n \n     #[test]\n-    fn test_auto_import_add_use_no_anchor_in_mod_mod() {\n+    fn test_replace_add_use_no_anchor_in_mod_mod() {\n         check_assist(\n-            add_import,\n+            replace_qualified_name_with_use,\n             \"\n mod foo {\n     mod bar {", "previous_filename": "crates/ra_assists/src/assists/add_import.rs"}, {"sha": "2c3f07a79dff4489727dc4da325988a992f682f4", "filename": "crates/ra_assists/src/handlers/split_import.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,6 +1,5 @@\n use std::iter::successors;\n \n-use hir::db::HirDatabase;\n use ra_syntax::{ast, AstNode, TextUnit, T};\n \n use crate::{Assist, AssistCtx, AssistId};\n@@ -16,7 +15,7 @@ use crate::{Assist, AssistCtx, AssistId};\n // ```\n // use std::{collections::HashMap};\n // ```\n-pub(crate) fn split_import(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+pub(crate) fn split_import(ctx: AssistCtx) -> Option<Assist> {\n     let colon_colon = ctx.find_token_at_offset(T![::])?;\n     let path = ast::Path::cast(colon_colon.parent())?;\n     let top_path = successors(Some(path), |it| it.parent_path()).last()?;", "previous_filename": "crates/ra_assists/src/assists/split_import.rs"}, {"sha": "828a8e9e827cbe3496670f51564162057ec13749", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 85, "deletions": 124, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -9,18 +9,16 @@ mod assist_ctx;\n mod marks;\n #[cfg(test)]\n mod doc_tests;\n-#[cfg(test)]\n-mod test_db;\n+mod utils;\n pub mod ast_transform;\n \n-use either::Either;\n-use hir::db::HirDatabase;\n use ra_db::FileRange;\n+use ra_ide_db::RootDatabase;\n use ra_syntax::{TextRange, TextUnit};\n use ra_text_edit::TextEdit;\n \n-pub(crate) use crate::assist_ctx::{Assist, AssistCtx};\n-pub use crate::assists::add_import::auto_import_text_edit;\n+pub(crate) use crate::assist_ctx::{Assist, AssistCtx, AssistHandler};\n+pub use crate::handlers::replace_qualified_name_with_use::insert_use_statement;\n \n /// Unique identifier of the assist, should not be shown to the user\n /// directly.\n@@ -34,88 +32,72 @@ pub struct AssistLabel {\n     pub id: AssistId,\n }\n \n+#[derive(Clone, Debug)]\n+pub struct GroupLabel(pub String);\n+\n+impl AssistLabel {\n+    pub(crate) fn new(label: String, id: AssistId) -> AssistLabel {\n+        // FIXME: make fields private, so that this invariant can't be broken\n+        assert!(label.chars().nth(0).unwrap().is_uppercase());\n+        AssistLabel { label: label.into(), id }\n+    }\n+}\n+\n #[derive(Debug, Clone)]\n pub struct AssistAction {\n-    pub label: Option<String>,\n     pub edit: TextEdit,\n     pub cursor_position: Option<TextUnit>,\n+    // FIXME: This belongs to `AssistLabel`\n     pub target: Option<TextRange>,\n }\n \n #[derive(Debug, Clone)]\n pub struct ResolvedAssist {\n     pub label: AssistLabel,\n-    pub action_data: Either<AssistAction, Vec<AssistAction>>,\n-}\n-\n-impl ResolvedAssist {\n-    pub fn get_first_action(&self) -> AssistAction {\n-        match &self.action_data {\n-            Either::Left(action) => action.clone(),\n-            Either::Right(actions) => actions[0].clone(),\n-        }\n-    }\n+    pub group_label: Option<GroupLabel>,\n+    pub action: AssistAction,\n }\n \n /// Return all the assists applicable at the given position.\n ///\n /// Assists are returned in the \"unresolved\" state, that is only labels are\n /// returned, without actual edits.\n-pub fn applicable_assists<H>(db: &H, range: FileRange) -> Vec<AssistLabel>\n-where\n-    H: HirDatabase + 'static,\n-{\n-    AssistCtx::with_ctx(db, range, false, |ctx| {\n-        assists::all()\n-            .iter()\n-            .filter_map(|f| f(ctx.clone()))\n-            .map(|a| match a {\n-                Assist::Unresolved { label } => label,\n-                Assist::Resolved { .. } => unreachable!(),\n-            })\n-            .collect()\n-    })\n+pub fn unresolved_assists(db: &RootDatabase, range: FileRange) -> Vec<AssistLabel> {\n+    let ctx = AssistCtx::new(db, range, false);\n+    handlers::all()\n+        .iter()\n+        .filter_map(|f| f(ctx.clone()))\n+        .flat_map(|it| it.0)\n+        .map(|a| a.label)\n+        .collect()\n }\n \n /// Return all the assists applicable at the given position.\n ///\n /// Assists are returned in the \"resolved\" state, that is with edit fully\n /// computed.\n-pub fn assists<H>(db: &H, range: FileRange) -> Vec<ResolvedAssist>\n-where\n-    H: HirDatabase + 'static,\n-{\n-    use std::cmp::Ordering;\n-\n-    AssistCtx::with_ctx(db, range, true, |ctx| {\n-        let mut a = assists::all()\n-            .iter()\n-            .filter_map(|f| f(ctx.clone()))\n-            .map(|a| match a {\n-                Assist::Resolved { assist } => assist,\n-                Assist::Unresolved { .. } => unreachable!(),\n-            })\n-            .collect::<Vec<_>>();\n-        a.sort_by(|a, b| match (a.get_first_action().target, b.get_first_action().target) {\n-            (Some(a), Some(b)) => a.len().cmp(&b.len()),\n-            (Some(_), None) => Ordering::Less,\n-            (None, Some(_)) => Ordering::Greater,\n-            (None, None) => Ordering::Equal,\n-        });\n-        a\n-    })\n+pub fn resolved_assists(db: &RootDatabase, range: FileRange) -> Vec<ResolvedAssist> {\n+    let ctx = AssistCtx::new(db, range, true);\n+    let mut a = handlers::all()\n+        .iter()\n+        .filter_map(|f| f(ctx.clone()))\n+        .flat_map(|it| it.0)\n+        .map(|it| it.into_resolved().unwrap())\n+        .collect::<Vec<_>>();\n+    a.sort_by_key(|it| it.action.target.map_or(TextUnit::from(!0u32), |it| it.len()));\n+    a\n }\n \n-mod assists {\n-    use crate::{Assist, AssistCtx};\n-    use hir::db::HirDatabase;\n+mod handlers {\n+    use crate::AssistHandler;\n \n     mod add_derive;\n     mod add_explicit_type;\n     mod add_impl;\n     mod add_custom_impl;\n     mod add_new;\n     mod apply_demorgan;\n+    mod auto_import;\n     mod invert_if;\n     mod flip_comma;\n     mod flip_binexpr;\n@@ -129,13 +111,13 @@ mod assists {\n     mod replace_if_let_with_match;\n     mod split_import;\n     mod remove_dbg;\n-    pub(crate) mod add_import;\n+    pub(crate) mod replace_qualified_name_with_use;\n     mod add_missing_impl_members;\n     mod move_guard;\n     mod move_bounds;\n     mod early_return;\n \n-    pub(crate) fn all<DB: HirDatabase>() -> &'static [fn(AssistCtx<DB>) -> Option<Assist>] {\n+    pub(crate) fn all() -> &'static [AssistHandler] {\n         &[\n             add_derive::add_derive,\n             add_explicit_type::add_explicit_type,\n@@ -154,7 +136,7 @@ mod assists {\n             replace_if_let_with_match::replace_if_let_with_match,\n             split_import::split_import,\n             remove_dbg::remove_dbg,\n-            add_import::add_import,\n+            replace_qualified_name_with_use::replace_qualified_name_with_use,\n             add_missing_impl_members::add_missing_impl_members,\n             add_missing_impl_members::add_missing_default_members,\n             inline_local_variable::inline_local_variable,\n@@ -166,33 +148,39 @@ mod assists {\n             raw_string::make_usual_string,\n             raw_string::remove_hash,\n             early_return::convert_to_guarded_return,\n+            auto_import::auto_import,\n         ]\n     }\n }\n \n #[cfg(test)]\n mod helpers {\n-    use ra_db::{fixture::WithFixture, FileRange};\n+    use std::sync::Arc;\n+\n+    use ra_db::{fixture::WithFixture, FileId, FileRange, SourceDatabaseExt};\n+    use ra_ide_db::{symbol_index::SymbolsDatabase, RootDatabase};\n     use ra_syntax::TextRange;\n     use test_utils::{add_cursor, assert_eq_text, extract_offset, extract_range};\n \n-    use crate::{test_db::TestDB, Assist, AssistCtx};\n+    use crate::{AssistCtx, AssistHandler};\n+\n+    pub(crate) fn with_single_file(text: &str) -> (RootDatabase, FileId) {\n+        let (mut db, file_id) = RootDatabase::with_single_file(text);\n+        // FIXME: ideally, this should be done by the above `RootDatabase::with_single_file`,\n+        // but it looks like this might need specialization? :(\n+        let local_roots = vec![db.file_source_root(file_id)];\n+        db.set_local_roots(Arc::new(local_roots));\n+        (db, file_id)\n+    }\n \n-    pub(crate) fn check_assist(\n-        assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n-        before: &str,\n-        after: &str,\n-    ) {\n+    pub(crate) fn check_assist(assist: AssistHandler, before: &str, after: &str) {\n         let (before_cursor_pos, before) = extract_offset(before);\n-        let (db, file_id) = TestDB::with_single_file(&before);\n+        let (db, file_id) = with_single_file(&before);\n         let frange =\n             FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n         let assist =\n-            AssistCtx::with_ctx(&db, frange, true, assist).expect(\"code action is not applicable\");\n-        let action = match assist {\n-            Assist::Unresolved { .. } => unreachable!(),\n-            Assist::Resolved { assist } => assist.get_first_action(),\n-        };\n+            assist(AssistCtx::new(&db, frange, true)).expect(\"code action is not applicable\");\n+        let action = assist.0[0].action.clone().unwrap();\n \n         let actual = action.edit.apply(&before);\n         let actual_cursor_pos = match action.cursor_position {\n@@ -206,20 +194,13 @@ mod helpers {\n         assert_eq_text!(after, &actual);\n     }\n \n-    pub(crate) fn check_assist_range(\n-        assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n-        before: &str,\n-        after: &str,\n-    ) {\n+    pub(crate) fn check_assist_range(assist: AssistHandler, before: &str, after: &str) {\n         let (range, before) = extract_range(before);\n-        let (db, file_id) = TestDB::with_single_file(&before);\n+        let (db, file_id) = with_single_file(&before);\n         let frange = FileRange { file_id, range };\n         let assist =\n-            AssistCtx::with_ctx(&db, frange, true, assist).expect(\"code action is not applicable\");\n-        let action = match assist {\n-            Assist::Unresolved { .. } => unreachable!(),\n-            Assist::Resolved { assist } => assist.get_first_action(),\n-        };\n+            assist(AssistCtx::new(&db, frange, true)).expect(\"code action is not applicable\");\n+        let action = assist.0[0].action.clone().unwrap();\n \n         let mut actual = action.edit.apply(&before);\n         if let Some(pos) = action.cursor_position {\n@@ -228,85 +209,65 @@ mod helpers {\n         assert_eq_text!(after, &actual);\n     }\n \n-    pub(crate) fn check_assist_target(\n-        assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n-        before: &str,\n-        target: &str,\n-    ) {\n+    pub(crate) fn check_assist_target(assist: AssistHandler, before: &str, target: &str) {\n         let (before_cursor_pos, before) = extract_offset(before);\n-        let (db, file_id) = TestDB::with_single_file(&before);\n+        let (db, file_id) = with_single_file(&before);\n         let frange =\n             FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n         let assist =\n-            AssistCtx::with_ctx(&db, frange, true, assist).expect(\"code action is not applicable\");\n-        let action = match assist {\n-            Assist::Unresolved { .. } => unreachable!(),\n-            Assist::Resolved { assist } => assist.get_first_action(),\n-        };\n+            assist(AssistCtx::new(&db, frange, true)).expect(\"code action is not applicable\");\n+        let action = assist.0[0].action.clone().unwrap();\n \n         let range = action.target.expect(\"expected target on action\");\n         assert_eq_text!(&before[range.start().to_usize()..range.end().to_usize()], target);\n     }\n \n-    pub(crate) fn check_assist_range_target(\n-        assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n-        before: &str,\n-        target: &str,\n-    ) {\n+    pub(crate) fn check_assist_range_target(assist: AssistHandler, before: &str, target: &str) {\n         let (range, before) = extract_range(before);\n-        let (db, file_id) = TestDB::with_single_file(&before);\n+        let (db, file_id) = with_single_file(&before);\n         let frange = FileRange { file_id, range };\n         let assist =\n-            AssistCtx::with_ctx(&db, frange, true, assist).expect(\"code action is not applicable\");\n-        let action = match assist {\n-            Assist::Unresolved { .. } => unreachable!(),\n-            Assist::Resolved { assist } => assist.get_first_action(),\n-        };\n+            assist(AssistCtx::new(&db, frange, true)).expect(\"code action is not applicable\");\n+        let action = assist.0[0].action.clone().unwrap();\n \n         let range = action.target.expect(\"expected target on action\");\n         assert_eq_text!(&before[range.start().to_usize()..range.end().to_usize()], target);\n     }\n \n-    pub(crate) fn check_assist_not_applicable(\n-        assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n-        before: &str,\n-    ) {\n+    pub(crate) fn check_assist_not_applicable(assist: AssistHandler, before: &str) {\n         let (before_cursor_pos, before) = extract_offset(before);\n-        let (db, file_id) = TestDB::with_single_file(&before);\n+        let (db, file_id) = with_single_file(&before);\n         let frange =\n             FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n-        let assist = AssistCtx::with_ctx(&db, frange, true, assist);\n+        let assist = assist(AssistCtx::new(&db, frange, true));\n         assert!(assist.is_none());\n     }\n \n-    pub(crate) fn check_assist_range_not_applicable(\n-        assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n-        before: &str,\n-    ) {\n+    pub(crate) fn check_assist_range_not_applicable(assist: AssistHandler, before: &str) {\n         let (range, before) = extract_range(before);\n-        let (db, file_id) = TestDB::with_single_file(&before);\n+        let (db, file_id) = with_single_file(&before);\n         let frange = FileRange { file_id, range };\n-        let assist = AssistCtx::with_ctx(&db, frange, true, assist);\n+        let assist = assist(AssistCtx::new(&db, frange, true));\n         assert!(assist.is_none());\n     }\n }\n \n #[cfg(test)]\n mod tests {\n-    use ra_db::{fixture::WithFixture, FileRange};\n+    use ra_db::FileRange;\n     use ra_syntax::TextRange;\n     use test_utils::{extract_offset, extract_range};\n \n-    use crate::test_db::TestDB;\n+    use crate::{helpers, resolved_assists};\n \n     #[test]\n     fn assist_order_field_struct() {\n         let before = \"struct Foo { <|>bar: u32 }\";\n         let (before_cursor_pos, before) = extract_offset(before);\n-        let (db, file_id) = TestDB::with_single_file(&before);\n+        let (db, file_id) = helpers::with_single_file(&before);\n         let frange =\n             FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n-        let assists = super::assists(&db, frange);\n+        let assists = resolved_assists(&db, frange);\n         let mut assists = assists.iter();\n \n         assert_eq!(\n@@ -327,9 +288,9 @@ mod tests {\n             }\n         }\";\n         let (range, before) = extract_range(before);\n-        let (db, file_id) = TestDB::with_single_file(&before);\n+        let (db, file_id) = helpers::with_single_file(&before);\n         let frange = FileRange { file_id, range };\n-        let assists = super::assists(&db, frange);\n+        let assists = resolved_assists(&db, frange);\n         let mut assists = assists.iter();\n \n         assert_eq!(assists.next().expect(\"expected assist\").label.label, \"Extract into variable\");"}, {"sha": "d5249f3088597a484f04f491bb26f2c66f3ba8af", "filename": "crates/ra_assists/src/test_db.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/22caf982b99c54058e2e9200aeea0e61cada284a/crates%2Fra_assists%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22caf982b99c54058e2e9200aeea0e61cada284a/crates%2Fra_assists%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftest_db.rs?ref=22caf982b99c54058e2e9200aeea0e61cada284a", "patch": "@@ -1,45 +0,0 @@\n-//! Database used for testing `ra_assists`.\n-\n-use std::sync::Arc;\n-\n-use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, RelativePath};\n-\n-#[salsa::database(\n-    ra_db::SourceDatabaseExtStorage,\n-    ra_db::SourceDatabaseStorage,\n-    hir::db::InternDatabaseStorage,\n-    hir::db::AstDatabaseStorage,\n-    hir::db::DefDatabaseStorage,\n-    hir::db::HirDatabaseStorage\n-)]\n-#[derive(Debug, Default)]\n-pub struct TestDB {\n-    runtime: salsa::Runtime<TestDB>,\n-}\n-\n-impl salsa::Database for TestDB {\n-    fn salsa_runtime(&self) -> &salsa::Runtime<Self> {\n-        &self.runtime\n-    }\n-    fn salsa_runtime_mut(&mut self) -> &mut salsa::Runtime<Self> {\n-        &mut self.runtime\n-    }\n-}\n-\n-impl std::panic::RefUnwindSafe for TestDB {}\n-\n-impl FileLoader for TestDB {\n-    fn file_text(&self, file_id: FileId) -> Arc<String> {\n-        FileLoaderDelegate(self).file_text(file_id)\n-    }\n-    fn resolve_relative_path(\n-        &self,\n-        anchor: FileId,\n-        relative_path: &RelativePath,\n-    ) -> Option<FileId> {\n-        FileLoaderDelegate(self).resolve_relative_path(anchor, relative_path)\n-    }\n-    fn relevant_crates(&self, file_id: FileId) -> Arc<Vec<CrateId>> {\n-        FileLoaderDelegate(self).relevant_crates(file_id)\n-    }\n-}"}, {"sha": "0d57222956f02c7e84d0007b857e26b78c6bc449", "filename": "crates/ra_assists/src/utils.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Futils.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,27 @@\n+//! Assorted functions shared by several assists.\n+\n+use ra_syntax::{\n+    ast::{self, make},\n+    T,\n+};\n+\n+pub(crate) fn invert_boolean_expression(expr: ast::Expr) -> ast::Expr {\n+    if let Some(expr) = invert_special_case(&expr) {\n+        return expr;\n+    }\n+    make::expr_prefix(T![!], expr)\n+}\n+\n+fn invert_special_case(expr: &ast::Expr) -> Option<ast::Expr> {\n+    match expr {\n+        ast::Expr::BinExpr(bin) => match bin.op_kind()? {\n+            ast::BinOp::NegatedEqualityTest => bin.replace_op(T![==]).map(|it| it.into()),\n+            ast::BinOp::EqualityTest => bin.replace_op(T![!=]).map(|it| it.into()),\n+            _ => None,\n+        },\n+        ast::Expr::PrefixExpr(pe) if pe.op_kind()? == ast::PrefixOp::Not => pe.expr(),\n+        // FIXME:\n+        // ast::Expr::Literal(true | false )\n+        _ => None,\n+    }\n+}"}, {"sha": "dd814fc9d9acadcedd993e7f5dc0eea834c656b6", "filename": "crates/ra_cargo_watch/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cargo_watch%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cargo_watch%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2FCargo.toml?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -11,7 +11,8 @@ log = \"0.4.3\"\n cargo_metadata = \"0.9.1\"\n jod-thread = \"0.1.0\"\n parking_lot = \"0.10.0\"\n+serde_json = \"1.0.45\"\n \n [dev-dependencies]\n-insta = \"0.12.0\"\n+insta = \"0.13.0\"\n serde_json = \"1.0\"\n\\ No newline at end of file"}, {"sha": "506370535f72a3b339dd2da44f28d4ca1da786b4", "filename": "crates/ra_cargo_watch/src/conv.rs", "status": "modified", "additions": 21, "deletions": 45, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cargo_watch%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cargo_watch%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Fconv.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,12 +1,11 @@\n //! This module provides the functionality needed to convert diagnostics from\n //! `cargo check` json format to the LSP diagnostic format.\n use cargo_metadata::diagnostic::{\n-    Applicability, Diagnostic as RustDiagnostic, DiagnosticLevel, DiagnosticSpan,\n-    DiagnosticSpanMacroExpansion,\n+    Diagnostic as RustDiagnostic, DiagnosticLevel, DiagnosticSpan, DiagnosticSpanMacroExpansion,\n };\n use lsp_types::{\n-    Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, Location,\n-    NumberOrString, Position, Range, Url,\n+    CodeAction, Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag,\n+    Location, NumberOrString, Position, Range, TextEdit, Url, WorkspaceEdit,\n };\n use std::{\n     fmt::Write,\n@@ -117,38 +116,9 @@ fn is_deprecated(rd: &RustDiagnostic) -> bool {\n     }\n }\n \n-#[derive(Debug)]\n-pub struct SuggestedFix {\n-    pub title: String,\n-    pub location: Location,\n-    pub replacement: String,\n-    pub applicability: Applicability,\n-    pub diagnostics: Vec<Diagnostic>,\n-}\n-\n-impl std::cmp::PartialEq<SuggestedFix> for SuggestedFix {\n-    fn eq(&self, other: &SuggestedFix) -> bool {\n-        if self.title == other.title\n-            && self.location == other.location\n-            && self.replacement == other.replacement\n-        {\n-            // Applicability doesn't impl PartialEq...\n-            match (&self.applicability, &other.applicability) {\n-                (Applicability::MachineApplicable, Applicability::MachineApplicable) => true,\n-                (Applicability::HasPlaceholders, Applicability::HasPlaceholders) => true,\n-                (Applicability::MaybeIncorrect, Applicability::MaybeIncorrect) => true,\n-                (Applicability::Unspecified, Applicability::Unspecified) => true,\n-                _ => false,\n-            }\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n enum MappedRustChildDiagnostic {\n     Related(DiagnosticRelatedInformation),\n-    SuggestedFix(SuggestedFix),\n+    SuggestedFix(CodeAction),\n     MessageLine(String),\n }\n \n@@ -176,12 +146,20 @@ fn map_rust_child_diagnostic(\n             rd.message.clone()\n         };\n \n-        MappedRustChildDiagnostic::SuggestedFix(SuggestedFix {\n+        let edit = {\n+            let edits = vec![TextEdit::new(location.range, suggested_replacement.clone())];\n+            let mut edit_map = std::collections::HashMap::new();\n+            edit_map.insert(location.uri, edits);\n+            WorkspaceEdit::new(edit_map)\n+        };\n+\n+        MappedRustChildDiagnostic::SuggestedFix(CodeAction {\n             title,\n-            location,\n-            replacement: suggested_replacement.clone(),\n-            applicability: span.suggestion_applicability.clone().unwrap_or(Applicability::Unknown),\n-            diagnostics: vec![],\n+            kind: Some(\"quickfix\".to_string()),\n+            diagnostics: None,\n+            edit: Some(edit),\n+            command: None,\n+            is_preferred: None,\n         })\n     } else {\n         MappedRustChildDiagnostic::Related(DiagnosticRelatedInformation {\n@@ -195,7 +173,7 @@ fn map_rust_child_diagnostic(\n pub(crate) struct MappedRustDiagnostic {\n     pub location: Location,\n     pub diagnostic: Diagnostic,\n-    pub suggested_fixes: Vec<SuggestedFix>,\n+    pub fixes: Vec<CodeAction>,\n }\n \n /// Converts a Rust root diagnostic to LSP form\n@@ -250,15 +228,13 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n         }\n     }\n \n-    let mut suggested_fixes = vec![];\n+    let mut fixes = vec![];\n     let mut message = rd.message.clone();\n     for child in &rd.children {\n         let child = map_rust_child_diagnostic(&child, workspace_root);\n         match child {\n             MappedRustChildDiagnostic::Related(related) => related_information.push(related),\n-            MappedRustChildDiagnostic::SuggestedFix(suggested_fix) => {\n-                suggested_fixes.push(suggested_fix)\n-            }\n+            MappedRustChildDiagnostic::SuggestedFix(code_action) => fixes.push(code_action.into()),\n             MappedRustChildDiagnostic::MessageLine(message_line) => {\n                 write!(&mut message, \"\\n{}\", message_line).unwrap();\n \n@@ -295,7 +271,7 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n         tags: if !tags.is_empty() { Some(tags) } else { None },\n     };\n \n-    Some(MappedRustDiagnostic { location, diagnostic, suggested_fixes })\n+    Some(MappedRustDiagnostic { location, diagnostic, fixes })\n }\n \n /// Returns a `Url` object from a given path, will lowercase drive letters if present."}, {"sha": "95ca163dcee255a13d1081dc53461a19fa5c2ba7", "filename": "crates/ra_cargo_watch/src/conv/snapshots/ra_cargo_watch__conv__test__snap_clippy_pass_by_ref.snap", "status": "renamed", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Fra_cargo_watch__conv__test__snap_clippy_pass_by_ref.snap", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Fra_cargo_watch__conv__test__snap_clippy_pass_by_ref.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Fra_cargo_watch__conv__test__snap_clippy_pass_by_ref.snap?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -61,25 +61,39 @@ MappedRustDiagnostic {\n         ),\n         tags: None,\n     },\n-    suggested_fixes: [\n-        SuggestedFix {\n+    fixes: [\n+        CodeAction {\n             title: \"consider passing by value instead: \\'self\\'\",\n-            location: Location {\n-                uri: \"file:///test/compiler/mir/tagset.rs\",\n-                range: Range {\n-                    start: Position {\n-                        line: 41,\n-                        character: 23,\n-                    },\n-                    end: Position {\n-                        line: 41,\n-                        character: 28,\n-                    },\n+            kind: Some(\n+                \"quickfix\",\n+            ),\n+            diagnostics: None,\n+            edit: Some(\n+                WorkspaceEdit {\n+                    changes: Some(\n+                        {\n+                            \"file:///test/compiler/mir/tagset.rs\": [\n+                                TextEdit {\n+                                    range: Range {\n+                                        start: Position {\n+                                            line: 41,\n+                                            character: 23,\n+                                        },\n+                                        end: Position {\n+                                            line: 41,\n+                                            character: 28,\n+                                        },\n+                                    },\n+                                    new_text: \"self\",\n+                                },\n+                            ],\n+                        },\n+                    ),\n+                    document_changes: None,\n                 },\n-            },\n-            replacement: \"self\",\n-            applicability: Unspecified,\n-            diagnostics: [],\n+            ),\n+            command: None,\n+            is_preferred: None,\n         },\n     ],\n }", "previous_filename": "crates/ra_cargo_watch/src/conv/snapshots/test__snap_clippy_pass_by_ref.snap"}, {"sha": "12eb32df48bd347229391e7ab875aa3f120f1317", "filename": "crates/ra_cargo_watch/src/conv/snapshots/ra_cargo_watch__conv__test__snap_handles_macro_location.snap", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Fra_cargo_watch__conv__test__snap_handles_macro_location.snap", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Fra_cargo_watch__conv__test__snap_handles_macro_location.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Fra_cargo_watch__conv__test__snap_handles_macro_location.snap?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -42,5 +42,5 @@ MappedRustDiagnostic {\n         related_information: None,\n         tags: None,\n     },\n-    suggested_fixes: [],\n+    fixes: [],\n }", "previous_filename": "crates/ra_cargo_watch/src/conv/snapshots/test__snap_handles_macro_location.snap"}, {"sha": "7b83a7cd04a3e76c1854dc88e290e30cd3e04190", "filename": "crates/ra_cargo_watch/src/conv/snapshots/ra_cargo_watch__conv__test__snap_macro_compiler_error.snap", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Fra_cargo_watch__conv__test__snap_macro_compiler_error.snap", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Fra_cargo_watch__conv__test__snap_macro_compiler_error.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Fra_cargo_watch__conv__test__snap_macro_compiler_error.snap?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -57,5 +57,5 @@ MappedRustDiagnostic {\n         ),\n         tags: None,\n     },\n-    suggested_fixes: [],\n+    fixes: [],\n }", "previous_filename": "crates/ra_cargo_watch/src/conv/snapshots/test__snap_macro_compiler_error.snap"}, {"sha": "54679c5db49735b8b93c1a1181648001bb95ac33", "filename": "crates/ra_cargo_watch/src/conv/snapshots/ra_cargo_watch__conv__test__snap_rustc_incompatible_type_for_trait.snap", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Fra_cargo_watch__conv__test__snap_rustc_incompatible_type_for_trait.snap", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Fra_cargo_watch__conv__test__snap_rustc_incompatible_type_for_trait.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Fra_cargo_watch__conv__test__snap_rustc_incompatible_type_for_trait.snap?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -42,5 +42,5 @@ MappedRustDiagnostic {\n         related_information: None,\n         tags: None,\n     },\n-    suggested_fixes: [],\n+    fixes: [],\n }", "previous_filename": "crates/ra_cargo_watch/src/conv/snapshots/test__snap_rustc_incompatible_type_for_trait.snap"}, {"sha": "57df4ceaf7be30f69a4f138742100b30c80bee75", "filename": "crates/ra_cargo_watch/src/conv/snapshots/ra_cargo_watch__conv__test__snap_rustc_mismatched_type.snap", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Fra_cargo_watch__conv__test__snap_rustc_mismatched_type.snap", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Fra_cargo_watch__conv__test__snap_rustc_mismatched_type.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Fra_cargo_watch__conv__test__snap_rustc_mismatched_type.snap?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -42,5 +42,5 @@ MappedRustDiagnostic {\n         related_information: None,\n         tags: None,\n     },\n-    suggested_fixes: [],\n+    fixes: [],\n }", "previous_filename": "crates/ra_cargo_watch/src/conv/snapshots/test__snap_rustc_mismatched_type.snap"}, {"sha": "3e1fe736c05bbc200ecc3dbc5bea01588d40bc8a", "filename": "crates/ra_cargo_watch/src/conv/snapshots/ra_cargo_watch__conv__test__snap_rustc_unused_variable.snap", "status": "renamed", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Fra_cargo_watch__conv__test__snap_rustc_unused_variable.snap", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Fra_cargo_watch__conv__test__snap_rustc_unused_variable.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Fra_cargo_watch__conv__test__snap_rustc_unused_variable.snap?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -46,25 +46,39 @@ MappedRustDiagnostic {\n             ],\n         ),\n     },\n-    suggested_fixes: [\n-        SuggestedFix {\n+    fixes: [\n+        CodeAction {\n             title: \"consider prefixing with an underscore: \\'_foo\\'\",\n-            location: Location {\n-                uri: \"file:///test/driver/subcommand/repl.rs\",\n-                range: Range {\n-                    start: Position {\n-                        line: 290,\n-                        character: 8,\n-                    },\n-                    end: Position {\n-                        line: 290,\n-                        character: 11,\n-                    },\n+            kind: Some(\n+                \"quickfix\",\n+            ),\n+            diagnostics: None,\n+            edit: Some(\n+                WorkspaceEdit {\n+                    changes: Some(\n+                        {\n+                            \"file:///test/driver/subcommand/repl.rs\": [\n+                                TextEdit {\n+                                    range: Range {\n+                                        start: Position {\n+                                            line: 290,\n+                                            character: 8,\n+                                        },\n+                                        end: Position {\n+                                            line: 290,\n+                                            character: 11,\n+                                        },\n+                                    },\n+                                    new_text: \"_foo\",\n+                                },\n+                            ],\n+                        },\n+                    ),\n+                    document_changes: None,\n                 },\n-            },\n-            replacement: \"_foo\",\n-            applicability: MachineApplicable,\n-            diagnostics: [],\n+            ),\n+            command: None,\n+            is_preferred: None,\n         },\n     ],\n }", "previous_filename": "crates/ra_cargo_watch/src/conv/snapshots/test__snap_rustc_unused_variable.snap"}, {"sha": "69301078d99415c413becf7c73bbc49fb3304079", "filename": "crates/ra_cargo_watch/src/conv/snapshots/ra_cargo_watch__conv__test__snap_rustc_wrong_number_of_parameters.snap", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Fra_cargo_watch__conv__test__snap_rustc_wrong_number_of_parameters.snap", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Fra_cargo_watch__conv__test__snap_rustc_wrong_number_of_parameters.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Fconv%2Fsnapshots%2Fra_cargo_watch__conv__test__snap_rustc_wrong_number_of_parameters.snap?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -61,5 +61,5 @@ MappedRustDiagnostic {\n         ),\n         tags: None,\n     },\n-    suggested_fixes: [],\n+    fixes: [],\n }", "previous_filename": "crates/ra_cargo_watch/src/conv/snapshots/test__snap_rustc_wrong_number_of_parameters.snap"}, {"sha": "f07c3454996dd764823893b3fa1ae375d921e2d5", "filename": "crates/ra_cargo_watch/src/lib.rs", "status": "modified", "additions": 55, "deletions": 98, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -4,22 +4,20 @@\n use cargo_metadata::Message;\n use crossbeam_channel::{never, select, unbounded, Receiver, RecvError, Sender};\n use lsp_types::{\n-    Diagnostic, Url, WorkDoneProgress, WorkDoneProgressBegin, WorkDoneProgressEnd,\n-    WorkDoneProgressReport,\n+    CodeAction, CodeActionOrCommand, Diagnostic, Url, WorkDoneProgress, WorkDoneProgressBegin,\n+    WorkDoneProgressEnd, WorkDoneProgressReport,\n };\n-use parking_lot::RwLock;\n use std::{\n-    collections::HashMap,\n+    io::{BufRead, BufReader},\n     path::PathBuf,\n     process::{Command, Stdio},\n-    sync::Arc,\n     thread::JoinHandle,\n     time::Instant,\n };\n \n mod conv;\n \n-use crate::conv::{map_rust_diagnostic_to_lsp, MappedRustDiagnostic, SuggestedFix};\n+use crate::conv::{map_rust_diagnostic_to_lsp, MappedRustDiagnostic};\n \n pub use crate::conv::url_from_path_with_drive_lowercasing;\n \n@@ -38,29 +36,26 @@ pub struct CheckOptions {\n #[derive(Debug)]\n pub struct CheckWatcher {\n     pub task_recv: Receiver<CheckTask>,\n-    pub state: Arc<RwLock<CheckState>>,\n     cmd_send: Option<Sender<CheckCommand>>,\n     handle: Option<JoinHandle<()>>,\n }\n \n impl CheckWatcher {\n     pub fn new(options: &CheckOptions, workspace_root: PathBuf) -> CheckWatcher {\n         let options = options.clone();\n-        let state = Arc::new(RwLock::new(CheckState::new()));\n \n         let (task_send, task_recv) = unbounded::<CheckTask>();\n         let (cmd_send, cmd_recv) = unbounded::<CheckCommand>();\n         let handle = std::thread::spawn(move || {\n             let mut check = CheckWatcherThread::new(options, workspace_root);\n             check.run(&task_send, &cmd_recv);\n         });\n-        CheckWatcher { task_recv, cmd_send: Some(cmd_send), handle: Some(handle), state }\n+        CheckWatcher { task_recv, cmd_send: Some(cmd_send), handle: Some(handle) }\n     }\n \n     /// Returns a CheckWatcher that doesn't actually do anything\n     pub fn dummy() -> CheckWatcher {\n-        let state = Arc::new(RwLock::new(CheckState::new()));\n-        CheckWatcher { task_recv: never(), cmd_send: None, handle: None, state }\n+        CheckWatcher { task_recv: never(), cmd_send: None, handle: None }\n     }\n \n     /// Schedule a re-start of the cargo check worker.\n@@ -87,84 +82,13 @@ impl std::ops::Drop for CheckWatcher {\n     }\n }\n \n-#[derive(Debug)]\n-pub struct CheckState {\n-    diagnostic_collection: HashMap<Url, Vec<Diagnostic>>,\n-    suggested_fix_collection: HashMap<Url, Vec<SuggestedFix>>,\n-}\n-\n-impl CheckState {\n-    fn new() -> CheckState {\n-        CheckState {\n-            diagnostic_collection: HashMap::new(),\n-            suggested_fix_collection: HashMap::new(),\n-        }\n-    }\n-\n-    /// Clear the cached diagnostics, and schedule updating diagnostics by the\n-    /// server, to clear stale results.\n-    pub fn clear(&mut self) -> Vec<Url> {\n-        let cleared_files: Vec<Url> = self.diagnostic_collection.keys().cloned().collect();\n-        self.diagnostic_collection.clear();\n-        self.suggested_fix_collection.clear();\n-        cleared_files\n-    }\n-\n-    pub fn diagnostics_for(&self, uri: &Url) -> Option<&[Diagnostic]> {\n-        self.diagnostic_collection.get(uri).map(|d| d.as_slice())\n-    }\n-\n-    pub fn fixes_for(&self, uri: &Url) -> Option<&[SuggestedFix]> {\n-        self.suggested_fix_collection.get(uri).map(|d| d.as_slice())\n-    }\n-\n-    pub fn add_diagnostic_with_fixes(&mut self, file_uri: Url, diagnostic: DiagnosticWithFixes) {\n-        for fix in diagnostic.suggested_fixes {\n-            self.add_suggested_fix_for_diagnostic(fix, &diagnostic.diagnostic);\n-        }\n-        self.add_diagnostic(file_uri, diagnostic.diagnostic);\n-    }\n-\n-    fn add_diagnostic(&mut self, file_uri: Url, diagnostic: Diagnostic) {\n-        let diagnostics = self.diagnostic_collection.entry(file_uri).or_default();\n-\n-        // If we're building multiple targets it's possible we've already seen this diagnostic\n-        let is_duplicate = diagnostics.iter().any(|d| are_diagnostics_equal(d, &diagnostic));\n-        if is_duplicate {\n-            return;\n-        }\n-\n-        diagnostics.push(diagnostic);\n-    }\n-\n-    fn add_suggested_fix_for_diagnostic(\n-        &mut self,\n-        mut suggested_fix: SuggestedFix,\n-        diagnostic: &Diagnostic,\n-    ) {\n-        let file_uri = suggested_fix.location.uri.clone();\n-        let file_suggestions = self.suggested_fix_collection.entry(file_uri).or_default();\n-\n-        let existing_suggestion: Option<&mut SuggestedFix> =\n-            file_suggestions.iter_mut().find(|s| s == &&suggested_fix);\n-        if let Some(existing_suggestion) = existing_suggestion {\n-            // The existing suggestion also applies to this new diagnostic\n-            existing_suggestion.diagnostics.push(diagnostic.clone());\n-        } else {\n-            // We haven't seen this suggestion before\n-            suggested_fix.diagnostics.push(diagnostic.clone());\n-            file_suggestions.push(suggested_fix);\n-        }\n-    }\n-}\n-\n #[derive(Debug)]\n pub enum CheckTask {\n     /// Request a clearing of all cached diagnostics from the check watcher\n     ClearDiagnostics,\n \n     /// Request adding a diagnostic with fixes included to a file\n-    AddDiagnostic(Url, DiagnosticWithFixes),\n+    AddDiagnostic { url: Url, diagnostic: Diagnostic, fixes: Vec<CodeActionOrCommand> },\n \n     /// Request check progress notification to client\n     Status(WorkDoneProgress),\n@@ -216,8 +140,10 @@ impl CheckWatcherThread {\n                 self.last_update_req.take();\n                 task_send.send(CheckTask::ClearDiagnostics).unwrap();\n \n-                // By replacing the watcher, we drop the previous one which\n-                // causes it to shut down automatically.\n+                // Replace with a dummy watcher first so we drop the original and wait for completion\n+                std::mem::replace(&mut self.watcher, WatchThread::dummy());\n+\n+                // Then create the actual new watcher\n                 self.watcher = WatchThread::new(&self.options, &self.workspace_root);\n             }\n         }\n@@ -277,10 +203,17 @@ impl CheckWatcherThread {\n                         None => return,\n                     };\n \n-                let MappedRustDiagnostic { location, diagnostic, suggested_fixes } = map_result;\n+                let MappedRustDiagnostic { location, diagnostic, fixes } = map_result;\n+                let fixes = fixes\n+                    .into_iter()\n+                    .map(|fix| {\n+                        CodeAction { diagnostics: Some(vec![diagnostic.clone()]), ..fix }.into()\n+                    })\n+                    .collect();\n \n-                let diagnostic = DiagnosticWithFixes { diagnostic, suggested_fixes };\n-                task_send.send(CheckTask::AddDiagnostic(location.uri, diagnostic)).unwrap();\n+                task_send\n+                    .send(CheckTask::AddDiagnostic { url: location.uri, diagnostic, fixes })\n+                    .unwrap();\n             }\n \n             CheckEvent::Msg(Message::BuildScriptExecuted(_msg)) => {}\n@@ -292,7 +225,7 @@ impl CheckWatcherThread {\n #[derive(Debug)]\n pub struct DiagnosticWithFixes {\n     diagnostic: Diagnostic,\n-    suggested_fixes: Vec<SuggestedFix>,\n+    fixes: Vec<CodeAction>,\n }\n \n /// WatchThread exists to wrap around the communication needed to be able to\n@@ -341,22 +274,53 @@ impl WatchThread {\n                 .args(&args)\n                 .stdout(Stdio::piped())\n                 .stderr(Stdio::null())\n+                .stdin(Stdio::null())\n                 .spawn()\n                 .expect(\"couldn't launch cargo\");\n \n             // If we trigger an error here, we will do so in the loop instead,\n             // which will break out of the loop, and continue the shutdown\n             let _ = message_send.send(CheckEvent::Begin);\n \n-            for message in cargo_metadata::parse_messages(command.stdout.take().unwrap()) {\n+            // We manually read a line at a time, instead of using serde's\n+            // stream deserializers, because the deserializer cannot recover\n+            // from an error, resulting in it getting stuck, because we try to\n+            // be resillient against failures.\n+            //\n+            // Because cargo only outputs one JSON object per line, we can\n+            // simply skip a line if it doesn't parse, which just ignores any\n+            // erroneus output.\n+            let stdout = BufReader::new(command.stdout.take().unwrap());\n+            for line in stdout.lines() {\n+                let line = match line {\n+                    Ok(line) => line,\n+                    Err(err) => {\n+                        log::error!(\"Couldn't read line from cargo: {}\", err);\n+                        continue;\n+                    }\n+                };\n+\n+                let message = serde_json::from_str::<cargo_metadata::Message>(&line);\n                 let message = match message {\n                     Ok(message) => message,\n                     Err(err) => {\n-                        log::error!(\"Invalid json from cargo check, ignoring: {}\", err);\n+                        log::error!(\n+                            \"Invalid json from cargo check, ignoring ({}): {:?} \",\n+                            err,\n+                            line\n+                        );\n                         continue;\n                     }\n                 };\n \n+                // Skip certain kinds of messages to only spend time on what's useful\n+                match &message {\n+                    Message::CompilerArtifact(artifact) if artifact.fresh => continue,\n+                    Message::BuildScriptExecuted(_) => continue,\n+                    Message::Unknown => continue,\n+                    _ => {}\n+                }\n+\n                 match message_send.send(CheckEvent::Msg(message)) {\n                     Ok(()) => {}\n                     Err(_err) => {\n@@ -396,10 +360,3 @@ impl std::ops::Drop for WatchThread {\n         }\n     }\n }\n-\n-fn are_diagnostics_equal(left: &Diagnostic, right: &Diagnostic) -> bool {\n-    left.source == right.source\n-        && left.severity == right.severity\n-        && left.range == right.range\n-        && left.message == right.message\n-}"}, {"sha": "bcd408421a0e7e0c7732f900574e6e2a925aed6f", "filename": "crates/ra_cli/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cli%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cli%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2FCargo.toml?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -7,7 +7,7 @@ publish = false\n \n [dependencies]\n pico-args = \"0.3.0\"\n-env_logger = { version = \"0.7.1\", default-features = false, features = [\"humantime\"] }\n+env_logger = { version = \"0.7.1\", default-features = false }\n \n ra_syntax = { path = \"../ra_syntax\" }\n ra_ide = { path = \"../ra_ide\" }"}, {"sha": "833235bffdaedec6f4213d013b3d29fea67251cd", "filename": "crates/ra_cli/src/analysis_stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -171,12 +171,12 @@ pub fn run(\n     println!(\n         \"Expressions of unknown type: {} ({}%)\",\n         num_exprs_unknown,\n-        if num_exprs > 0 { (num_exprs_unknown * 100 / num_exprs) } else { 100 }\n+        if num_exprs > 0 { num_exprs_unknown * 100 / num_exprs } else { 100 }\n     );\n     println!(\n         \"Expressions of partially unknown type: {} ({}%)\",\n         num_exprs_partially_unknown,\n-        if num_exprs > 0 { (num_exprs_partially_unknown * 100 / num_exprs) } else { 100 }\n+        if num_exprs > 0 { num_exprs_partially_unknown * 100 / num_exprs } else { 100 }\n     );\n     println!(\"Type mismatches: {}\", num_type_mismatches);\n     println!(\"Inference: {:?}, {}\", inference_time.elapsed(), ra_prof::memory_usage());"}, {"sha": "17cd138c20fed9d239145c146bef123cb3d9d5d4", "filename": "crates/ra_db/src/fixture.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Ffixture.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -8,8 +8,8 @@ use rustc_hash::FxHashMap;\n use test_utils::{extract_offset, parse_fixture, CURSOR_MARKER};\n \n use crate::{\n-    CrateGraph, CrateId, Edition, Env, FileId, FilePosition, RelativePathBuf, SourceDatabaseExt,\n-    SourceRoot, SourceRootId,\n+    input::CrateName, CrateGraph, CrateId, Edition, Env, FileId, FilePosition, RelativePathBuf,\n+    SourceDatabaseExt, SourceRoot, SourceRootId,\n };\n \n pub const WORKSPACE: SourceRootId = SourceRootId(0);\n@@ -139,7 +139,7 @@ fn with_files(db: &mut dyn SourceDatabaseExt, fixture: &str) -> Option<FilePosit\n         for (from, to) in crate_deps {\n             let from_id = crates[&from];\n             let to_id = crates[&to];\n-            crate_graph.add_dep(from_id, to.into(), to_id).unwrap();\n+            crate_graph.add_dep(from_id, CrateName::new(&to).unwrap(), to_id).unwrap();\n         }\n     }\n "}, {"sha": "1f1dcea429f7a8cecdb1a3d0a0d6146f5b287a03", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -83,6 +83,26 @@ pub struct CrateGraph {\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct CrateId(pub u32);\n \n+pub struct CrateName(SmolStr);\n+\n+impl CrateName {\n+    /// Crates a crate name, checking for dashes in the string provided.\n+    /// Dashes are not allowed in the crate names,\n+    /// hence the input string is returned as `Err` for those cases.\n+    pub fn new(name: &str) -> Result<CrateName, &str> {\n+        if name.contains('-') {\n+            Err(name)\n+        } else {\n+            Ok(Self(SmolStr::new(name)))\n+        }\n+    }\n+\n+    /// Crates a crate name, unconditionally replacing the dashes with underscores.\n+    pub fn normalize_dashes(name: &str) -> CrateName {\n+        Self(SmolStr::new(name.replace('-', \"_\")))\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n struct CrateData {\n     file_id: FileId,\n@@ -131,13 +151,13 @@ impl CrateGraph {\n     pub fn add_dep(\n         &mut self,\n         from: CrateId,\n-        name: SmolStr,\n+        name: CrateName,\n         to: CrateId,\n     ) -> Result<(), CyclicDependenciesError> {\n         if self.dfs_find(from, to, &mut FxHashSet::default()) {\n             return Err(CyclicDependenciesError);\n         }\n-        self.arena.get_mut(&from).unwrap().add_dep(name, to);\n+        self.arena.get_mut(&from).unwrap().add_dep(name.0, to);\n         Ok(())\n     }\n \n@@ -268,7 +288,7 @@ pub struct CyclicDependenciesError;\n \n #[cfg(test)]\n mod tests {\n-    use super::{CfgOptions, CrateGraph, Edition::Edition2018, Env, FileId, SmolStr};\n+    use super::{CfgOptions, CrateGraph, CrateName, Dependency, Edition::Edition2018, Env, FileId};\n \n     #[test]\n     fn it_should_panic_because_of_cycle_dependencies() {\n@@ -279,9 +299,9 @@ mod tests {\n             graph.add_crate_root(FileId(2u32), Edition2018, CfgOptions::default(), Env::default());\n         let crate3 =\n             graph.add_crate_root(FileId(3u32), Edition2018, CfgOptions::default(), Env::default());\n-        assert!(graph.add_dep(crate1, SmolStr::new(\"crate2\"), crate2).is_ok());\n-        assert!(graph.add_dep(crate2, SmolStr::new(\"crate3\"), crate3).is_ok());\n-        assert!(graph.add_dep(crate3, SmolStr::new(\"crate1\"), crate1).is_err());\n+        assert!(graph.add_dep(crate1, CrateName::new(\"crate2\").unwrap(), crate2).is_ok());\n+        assert!(graph.add_dep(crate2, CrateName::new(\"crate3\").unwrap(), crate3).is_ok());\n+        assert!(graph.add_dep(crate3, CrateName::new(\"crate1\").unwrap(), crate1).is_err());\n     }\n \n     #[test]\n@@ -293,7 +313,23 @@ mod tests {\n             graph.add_crate_root(FileId(2u32), Edition2018, CfgOptions::default(), Env::default());\n         let crate3 =\n             graph.add_crate_root(FileId(3u32), Edition2018, CfgOptions::default(), Env::default());\n-        assert!(graph.add_dep(crate1, SmolStr::new(\"crate2\"), crate2).is_ok());\n-        assert!(graph.add_dep(crate2, SmolStr::new(\"crate3\"), crate3).is_ok());\n+        assert!(graph.add_dep(crate1, CrateName::new(\"crate2\").unwrap(), crate2).is_ok());\n+        assert!(graph.add_dep(crate2, CrateName::new(\"crate3\").unwrap(), crate3).is_ok());\n+    }\n+\n+    #[test]\n+    fn dashes_are_normalized() {\n+        let mut graph = CrateGraph::default();\n+        let crate1 =\n+            graph.add_crate_root(FileId(1u32), Edition2018, CfgOptions::default(), Env::default());\n+        let crate2 =\n+            graph.add_crate_root(FileId(2u32), Edition2018, CfgOptions::default(), Env::default());\n+        assert!(graph\n+            .add_dep(crate1, CrateName::normalize_dashes(\"crate-name-with-dashes\"), crate2)\n+            .is_ok());\n+        assert_eq!(\n+            graph.dependencies(crate1).collect::<Vec<_>>(),\n+            vec![&Dependency { crate_id: crate2, name: \"crate_name_with_dashes\".into() }]\n+        );\n     }\n }"}, {"sha": "fb002d717d9f2f05ddbdfca7d40bc7d634c26f86", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -10,7 +10,9 @@ use ra_syntax::{ast, Parse, SourceFile, TextRange, TextUnit};\n \n pub use crate::{\n     cancellation::Canceled,\n-    input::{CrateGraph, CrateId, Dependency, Edition, Env, FileId, SourceRoot, SourceRootId},\n+    input::{\n+        CrateGraph, CrateId, CrateName, Dependency, Edition, Env, FileId, SourceRoot, SourceRootId,\n+    },\n };\n pub use relative_path::{RelativePath, RelativePathBuf};\n pub use salsa;"}, {"sha": "4bca27b5c702b4fe68bb4ef9a02057faafcc7c59", "filename": "crates/ra_fmt/src/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_fmt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_fmt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_fmt%2Fsrc%2Flib.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -35,8 +35,14 @@ fn prev_tokens(token: SyntaxToken) -> impl Iterator<Item = SyntaxToken> {\n     successors(token.prev_token(), |token| token.prev_token())\n }\n \n-pub fn extract_trivial_expression(expr: &ast::BlockExpr) -> Option<ast::Expr> {\n-    let block = expr.block()?;\n+pub fn unwrap_trivial_block(block: ast::BlockExpr) -> ast::Expr {\n+    extract_trivial_expression(&block)\n+        .filter(|expr| !expr.syntax().text().contains_char('\\n'))\n+        .unwrap_or_else(|| block.into())\n+}\n+\n+pub fn extract_trivial_expression(block: &ast::BlockExpr) -> Option<ast::Expr> {\n+    let block = block.block()?;\n     let expr = block.expr()?;\n     let non_trivial_children = block.syntax().children().filter(|it| match it.kind() {\n         WHITESPACE | T!['{'] | T!['}'] => false,"}, {"sha": "4d96417285420cdb1e60862e97d6560491aee445", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -10,9 +10,9 @@ use hir_def::{\n     per_ns::PerNs,\n     resolver::HasResolver,\n     type_ref::{Mutability, TypeRef},\n-    AdtId, ConstId, DefWithBodyId, EnumId, FunctionId, HasModule, ImplId, LocalEnumVariantId,\n-    LocalModuleId, LocalStructFieldId, Lookup, ModuleId, StaticId, StructId, TraitId, TypeAliasId,\n-    TypeParamId, UnionId,\n+    AdtId, ConstId, DefWithBodyId, EnumId, FunctionId, GenericDefId, HasModule, ImplId,\n+    LocalEnumVariantId, LocalModuleId, LocalStructFieldId, Lookup, ModuleId, StaticId, StructId,\n+    TraitId, TypeAliasId, TypeParamId, UnionId,\n };\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n@@ -21,7 +21,7 @@ use hir_expand::{\n };\n use hir_ty::{\n     autoderef, display::HirFormatter, expr::ExprValidator, method_resolution, ApplicationTy,\n-    Canonical, InEnvironment, TraitEnvironment, Ty, TyDefId, TypeCtor, TypeWalk,\n+    Canonical, InEnvironment, Substs, TraitEnvironment, Ty, TyDefId, TypeCtor,\n };\n use ra_db::{CrateId, Edition, FileId};\n use ra_prof::profile;\n@@ -119,7 +119,7 @@ impl_froms!(\n     BuiltinType\n );\n \n-pub use hir_def::{attr::Attrs, visibility::Visibility, AssocItemId};\n+pub use hir_def::{attr::Attrs, item_scope::ItemInNs, visibility::Visibility, AssocItemId};\n use rustc_hash::FxHashSet;\n \n impl Module {\n@@ -238,11 +238,16 @@ impl Module {\n         item: ModuleDef,\n     ) -> Option<hir_def::path::ModPath> {\n         // FIXME expose namespace choice\n-        hir_def::find_path::find_path(\n-            db,\n-            hir_def::item_scope::ItemInNs::Types(item.into()),\n-            self.into(),\n-        )\n+        hir_def::find_path::find_path(db, determine_item_namespace(item), self.into())\n+    }\n+}\n+\n+fn determine_item_namespace(module_def: ModuleDef) -> ItemInNs {\n+    match module_def {\n+        ModuleDef::Static(_) | ModuleDef::Const(_) | ModuleDef::Function(_) => {\n+            ItemInNs::Values(module_def.into())\n+        }\n+        _ => ItemInNs::Types(module_def.into()),\n     }\n }\n \n@@ -265,7 +270,13 @@ impl StructField {\n \n     pub fn ty(&self, db: &impl HirDatabase) -> Type {\n         let var_id = self.parent.into();\n-        let ty = db.field_types(var_id)[self.id].clone();\n+        let generic_def_id: GenericDefId = match self.parent {\n+            VariantDef::Struct(it) => it.id.into(),\n+            VariantDef::Union(it) => it.id.into(),\n+            VariantDef::EnumVariant(it) => it.parent.id.into(),\n+        };\n+        let substs = Substs::type_params(db, generic_def_id);\n+        let ty = db.field_types(var_id)[self.id].clone().subst(&substs);\n         Type::new(db, self.parent.module(db).id.krate.into(), var_id, ty)\n     }\n \n@@ -750,7 +761,7 @@ pub struct TypeParam {\n impl TypeParam {\n     pub fn name(self, db: &impl HirDatabase) -> Name {\n         let params = db.generic_params(self.id.parent);\n-        params.types[self.id.local_id].name.clone()\n+        params.types[self.id.local_id].name.clone().unwrap_or_else(Name::missing)\n     }\n \n     pub fn module(self, db: &impl HirDatabase) -> Module {\n@@ -784,8 +795,9 @@ impl ImplBlock {\n     pub fn target_ty(&self, db: &impl HirDatabase) -> Type {\n         let impl_data = db.impl_data(self.id);\n         let resolver = self.id.resolver(db);\n+        let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n         let environment = TraitEnvironment::lower(db, &resolver);\n-        let ty = Ty::from_hir(db, &resolver, &impl_data.target_type);\n+        let ty = Ty::from_hir(&ctx, &impl_data.target_type);\n         Type {\n             krate: self.id.lookup(db).container.module(db).krate,\n             ty: InEnvironment { value: ty, environment },\n@@ -846,9 +858,10 @@ impl Type {\n     fn from_def(\n         db: &impl HirDatabase,\n         krate: CrateId,\n-        def: impl HasResolver + Into<TyDefId>,\n+        def: impl HasResolver + Into<TyDefId> + Into<GenericDefId>,\n     ) -> Type {\n-        let ty = db.ty(def.into());\n+        let substs = Substs::type_params(db, def);\n+        let ty = db.ty(def.into()).subst(&substs);\n         Type::new(db, krate, def, ty)\n     }\n \n@@ -945,7 +958,7 @@ impl Type {\n             match a_ty.ctor {\n                 TypeCtor::Tuple { .. } => {\n                     for ty in a_ty.parameters.iter() {\n-                        let ty = ty.clone().subst(&a_ty.parameters);\n+                        let ty = ty.clone();\n                         res.push(self.derived(ty));\n                     }\n                 }"}, {"sha": "a77bf6de6c5c16d2687a727ad21e28f242b23adb", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,20 +1,24 @@\n //! FIXME: write short doc here\n \n pub use hir_def::db::{\n-    BodyQuery, BodyWithSourceMapQuery, ComputeCrateDefMapQuery, ConstDataQuery,\n+    AttrsQuery, BodyQuery, BodyWithSourceMapQuery, ComputeCrateDefMapQuery, ConstDataQuery,\n     CrateLangItemsQuery, DefDatabase, DefDatabaseStorage, DocumentationQuery, EnumDataQuery,\n-    ExprScopesQuery, FunctionDataQuery, GenericParamsQuery, ImplDataQuery, InternDatabase,\n-    InternDatabaseStorage, LangItemQuery, ModuleLangItemsQuery, RawItemsQuery, StaticDataQuery,\n-    StructDataQuery, TraitDataQuery, TypeAliasDataQuery,\n+    ExprScopesQuery, FunctionDataQuery, GenericParamsQuery, ImplDataQuery, InternConstQuery,\n+    InternDatabase, InternDatabaseStorage, InternEnumQuery, InternFunctionQuery, InternImplQuery,\n+    InternStaticQuery, InternStructQuery, InternTraitQuery, InternTypeAliasQuery, InternUnionQuery,\n+    LangItemQuery, ModuleLangItemsQuery, RawItemsQuery, StaticDataQuery, StructDataQuery,\n+    TraitDataQuery, TypeAliasDataQuery, UnionDataQuery,\n };\n pub use hir_expand::db::{\n-    AstDatabase, AstDatabaseStorage, AstIdMapQuery, MacroArgQuery, MacroDefQuery, MacroExpandQuery,\n-    ParseMacroQuery,\n+    AstDatabase, AstDatabaseStorage, AstIdMapQuery, InternMacroQuery, MacroArgQuery, MacroDefQuery,\n+    MacroExpandQuery, ParseMacroQuery,\n };\n pub use hir_ty::db::{\n-    AssociatedTyDataQuery, CallableItemSignatureQuery, DoInferQuery, FieldTypesQuery,\n-    GenericDefaultsQuery, GenericPredicatesQuery, HirDatabase, HirDatabaseStorage, ImplDatumQuery,\n-    ImplsForTraitQuery, ImplsInCrateQuery, StructDatumQuery, TraitDatumQuery, TraitSolveQuery,\n+    AssociatedTyDataQuery, AssociatedTyValueQuery, CallableItemSignatureQuery, DoInferQuery,\n+    FieldTypesQuery, GenericDefaultsQuery, GenericPredicatesForParamQuery, GenericPredicatesQuery,\n+    HirDatabase, HirDatabaseStorage, ImplDatumQuery, ImplSelfTyQuery, ImplTraitQuery,\n+    ImplsForTraitQuery, ImplsInCrateQuery, InternAssocTyValueQuery, InternChalkImplQuery,\n+    InternTypeCtorQuery, StructDatumQuery, TraitDatumQuery, TraitSolveQuery, TraitSolverQuery,\n     TyQuery, ValueTyQuery,\n };\n "}, {"sha": "bb9a35c5d1224de747bca1bf29fb4d52e0bb6c0e", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -178,6 +178,10 @@ impl SourceAnalyzer {\n         }\n     }\n \n+    fn trait_env(&self, db: &impl HirDatabase) -> Arc<TraitEnvironment> {\n+        TraitEnvironment::lower(db, &self.resolver)\n+    }\n+\n     pub fn type_of(&self, db: &impl HirDatabase, expr: &ast::Expr) -> Option<Type> {\n         let expr_id = if let Some(expr) = self.expand_expr(db, InFile::new(self.file_id, expr)) {\n             self.body_source_map.as_ref()?.node_expr(expr.as_ref())?\n@@ -186,14 +190,14 @@ impl SourceAnalyzer {\n         };\n \n         let ty = self.infer.as_ref()?[expr_id].clone();\n-        let environment = TraitEnvironment::lower(db, &self.resolver);\n+        let environment = self.trait_env(db);\n         Some(Type { krate: self.resolver.krate()?, ty: InEnvironment { value: ty, environment } })\n     }\n \n     pub fn type_of_pat(&self, db: &impl HirDatabase, pat: &ast::Pat) -> Option<Type> {\n         let pat_id = self.pat_id(pat)?;\n         let ty = self.infer.as_ref()?[pat_id].clone();\n-        let environment = TraitEnvironment::lower(db, &self.resolver);\n+        let environment = self.trait_env(db);\n         Some(Type { krate: self.resolver.krate()?, ty: InEnvironment { value: ty, environment } })\n     }\n "}, {"sha": "1efa00fe005ec2315c3f7f165f71f732838e8db9", "filename": "crates/ra_hir_def/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2FCargo.toml?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -26,4 +26,4 @@ ra_cfg = { path = \"../ra_cfg\" }\n tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n \n [dev-dependencies]\n-insta = \"0.12.0\"\n+insta = \"0.13.0\""}, {"sha": "43b9b124a2d403a27595eab5894ab57153ce2868", "filename": "crates/ra_hir_def/src/find_path.rs", "status": "modified", "additions": 85, "deletions": 14, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -7,10 +7,39 @@ use crate::{\n     visibility::Visibility,\n     CrateId, ModuleDefId, ModuleId,\n };\n-use hir_expand::name::Name;\n+use hir_expand::name::{known, Name};\n+use test_utils::tested_by;\n \n const MAX_PATH_LEN: usize = 15;\n \n+impl ModPath {\n+    fn starts_with_std(&self) -> bool {\n+        self.segments.first().filter(|&first_segment| first_segment == &known::std).is_some()\n+    }\n+\n+    // When std library is present, paths starting with `std::`\n+    // should be preferred over paths starting with `core::` and `alloc::`\n+    fn should_start_with_std(&self) -> bool {\n+        self.segments\n+            .first()\n+            .filter(|&first_segment| {\n+                first_segment == &known::alloc || first_segment == &known::core\n+            })\n+            .is_some()\n+    }\n+\n+    fn len(&self) -> usize {\n+        self.segments.len()\n+            + match self.kind {\n+                PathKind::Plain => 0,\n+                PathKind::Super(i) => i as usize,\n+                PathKind::Crate => 1,\n+                PathKind::Abs => 0,\n+                PathKind::DollarCrate(_) => 1,\n+            }\n+    }\n+}\n+\n // FIXME: handle local items\n \n /// Find a path that can be used to refer to a certain item. This can depend on\n@@ -112,23 +141,27 @@ fn find_path_inner(\n             Some(path) => path,\n         };\n         path.segments.push(name);\n-        if path_len(&path) < best_path_len {\n-            best_path_len = path_len(&path);\n-            best_path = Some(path);\n-        }\n+\n+        let new_path =\n+            if let Some(best_path) = best_path { select_best_path(best_path, path) } else { path };\n+        best_path_len = new_path.len();\n+        best_path = Some(new_path);\n     }\n     best_path\n }\n \n-fn path_len(path: &ModPath) -> usize {\n-    path.segments.len()\n-        + match path.kind {\n-            PathKind::Plain => 0,\n-            PathKind::Super(i) => i as usize,\n-            PathKind::Crate => 1,\n-            PathKind::Abs => 0,\n-            PathKind::DollarCrate(_) => 1,\n-        }\n+fn select_best_path(old_path: ModPath, new_path: ModPath) -> ModPath {\n+    if old_path.starts_with_std() && new_path.should_start_with_std() {\n+        tested_by!(prefer_std_paths);\n+        old_path\n+    } else if new_path.starts_with_std() && old_path.should_start_with_std() {\n+        tested_by!(prefer_std_paths);\n+        new_path\n+    } else if new_path.len() < old_path.len() {\n+        new_path\n+    } else {\n+        old_path\n+    }\n }\n \n fn find_importable_locations(\n@@ -201,6 +234,7 @@ mod tests {\n     use hir_expand::hygiene::Hygiene;\n     use ra_db::fixture::WithFixture;\n     use ra_syntax::ast::AstNode;\n+    use test_utils::covers;\n \n     /// `code` needs to contain a cursor marker; checks that `find_path` for the\n     /// item the `path` refers to returns that same path when called from the\n@@ -452,4 +486,41 @@ mod tests {\n         \"#;\n         check_found_path(code, \"crate::foo::S\");\n     }\n+\n+    #[test]\n+    fn prefer_std_paths_over_alloc() {\n+        covers!(prefer_std_paths);\n+        let code = r#\"\n+        //- /main.rs crate:main deps:alloc,std\n+        <|>\n+\n+        //- /std.rs crate:std deps:alloc\n+        pub mod sync {\n+            pub use alloc::sync::Arc;\n+        }\n+\n+        //- /zzz.rs crate:alloc\n+        pub mod sync {\n+            pub struct Arc;\n+        }\n+        \"#;\n+        check_found_path(code, \"std::sync::Arc\");\n+    }\n+\n+    #[test]\n+    fn prefer_shorter_paths_if_not_alloc() {\n+        let code = r#\"\n+        //- /main.rs crate:main deps:megaalloc,std\n+        <|>\n+\n+        //- /std.rs crate:std deps:megaalloc\n+        pub mod sync {\n+            pub use megaalloc::sync::Arc;\n+        }\n+\n+        //- /zzz.rs crate:megaalloc\n+        pub struct Arc;\n+        \"#;\n+        check_found_path(code, \"megaalloc::Arc\");\n+    }\n }"}, {"sha": "f765e6edc202b84e38543ea5ec8d45e3262a3835", "filename": "crates/ra_hir_def/src/generics.rs", "status": "modified", "additions": 66, "deletions": 7, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -27,8 +27,16 @@ use crate::{\n /// Data about a generic parameter (to a function, struct, impl, ...).\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct TypeParamData {\n-    pub name: Name,\n+    pub name: Option<Name>,\n     pub default: Option<TypeRef>,\n+    pub provenance: TypeParamProvenance,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum TypeParamProvenance {\n+    TypeParamList,\n+    TraitSelf,\n+    ArgumentImplTrait,\n }\n \n /// Data about the generic parameters of a function, struct, impl, etc.\n@@ -45,10 +53,17 @@ pub struct GenericParams {\n /// associated type bindings like `Iterator<Item = u32>`.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct WherePredicate {\n-    pub type_ref: TypeRef,\n+    pub target: WherePredicateTarget,\n     pub bound: TypeBound,\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum WherePredicateTarget {\n+    TypeRef(TypeRef),\n+    /// For desugared where predicates that can directly refer to a type param.\n+    TypeParam(LocalTypeParamId),\n+}\n+\n type SourceMap = ArenaMap<LocalTypeParamId, Either<ast::TraitDef, ast::TypeParam>>;\n \n impl GenericParams {\n@@ -68,6 +83,11 @@ impl GenericParams {\n             GenericDefId::FunctionId(it) => {\n                 let src = it.lookup(db).source(db);\n                 generics.fill(&mut sm, &src.value);\n+                // lower `impl Trait` in arguments\n+                let data = db.function_data(it);\n+                for param in &data.params {\n+                    generics.fill_implicit_impl_trait_args(param);\n+                }\n                 src.file_id\n             }\n             GenericDefId::AdtId(AdtId::StructId(it)) => {\n@@ -89,8 +109,11 @@ impl GenericParams {\n                 let src = it.lookup(db).source(db);\n \n                 // traits get the Self type as an implicit first type parameter\n-                let self_param_id =\n-                    generics.types.alloc(TypeParamData { name: name![Self], default: None });\n+                let self_param_id = generics.types.alloc(TypeParamData {\n+                    name: Some(name![Self]),\n+                    default: None,\n+                    provenance: TypeParamProvenance::TraitSelf,\n+                });\n                 sm.insert(self_param_id, Either::Left(src.value.clone()));\n                 // add super traits as bounds on Self\n                 // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n@@ -142,7 +165,11 @@ impl GenericParams {\n             let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n             // FIXME: Use `Path::from_src`\n             let default = type_param.default_type().map(TypeRef::from_ast);\n-            let param = TypeParamData { name: name.clone(), default };\n+            let param = TypeParamData {\n+                name: Some(name.clone()),\n+                default,\n+                provenance: TypeParamProvenance::TypeParamList,\n+            };\n             let param_id = self.types.alloc(param);\n             sm.insert(param_id, Either::Right(type_param.clone()));\n \n@@ -170,11 +197,43 @@ impl GenericParams {\n             return;\n         }\n         let bound = TypeBound::from_ast(bound);\n-        self.where_predicates.push(WherePredicate { type_ref, bound });\n+        self.where_predicates\n+            .push(WherePredicate { target: WherePredicateTarget::TypeRef(type_ref), bound });\n+    }\n+\n+    fn fill_implicit_impl_trait_args(&mut self, type_ref: &TypeRef) {\n+        type_ref.walk(&mut |type_ref| {\n+            if let TypeRef::ImplTrait(bounds) = type_ref {\n+                let param = TypeParamData {\n+                    name: None,\n+                    default: None,\n+                    provenance: TypeParamProvenance::ArgumentImplTrait,\n+                };\n+                let param_id = self.types.alloc(param);\n+                for bound in bounds {\n+                    self.where_predicates.push(WherePredicate {\n+                        target: WherePredicateTarget::TypeParam(param_id),\n+                        bound: bound.clone(),\n+                    });\n+                }\n+            }\n+        });\n     }\n \n     pub fn find_by_name(&self, name: &Name) -> Option<LocalTypeParamId> {\n-        self.types.iter().find_map(|(id, p)| if &p.name == name { Some(id) } else { None })\n+        self.types\n+            .iter()\n+            .find_map(|(id, p)| if p.name.as_ref() == Some(name) { Some(id) } else { None })\n+    }\n+\n+    pub fn find_trait_self_param(&self) -> Option<LocalTypeParamId> {\n+        self.types.iter().find_map(|(id, p)| {\n+            if p.provenance == TypeParamProvenance::TraitSelf {\n+                Some(id)\n+            } else {\n+                None\n+            }\n+        })\n     }\n }\n "}, {"sha": "daa49d5f1040b6e792127d3299261fe685b76322", "filename": "crates/ra_hir_def/src/marks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fmarks.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -13,4 +13,5 @@ test_utils::marks!(\n     macro_dollar_crate_self\n     macro_dollar_crate_other\n     infer_resolve_while_let\n+    prefer_std_paths\n );"}, {"sha": "852304dd0c6f197dcd57d57620702fb23f760578", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -229,6 +229,46 @@ impl CrateDefMap {\n             self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path, shadow);\n         (res.resolved_def, res.segment_index)\n     }\n+\n+    // FIXME: this can use some more human-readable format (ideally, an IR\n+    // even), as this should be a great debugging aid.\n+    pub fn dump(&self) -> String {\n+        let mut buf = String::new();\n+        go(&mut buf, self, \"\\ncrate\", self.root);\n+        return buf.trim().to_string();\n+\n+        fn go(buf: &mut String, map: &CrateDefMap, path: &str, module: LocalModuleId) {\n+            *buf += path;\n+            *buf += \"\\n\";\n+\n+            let mut entries: Vec<_> = map.modules[module].scope.resolutions().collect();\n+            entries.sort_by_key(|(name, _)| name.clone());\n+\n+            for (name, def) in entries {\n+                *buf += &format!(\"{}:\", name);\n+\n+                if def.types.is_some() {\n+                    *buf += \" t\";\n+                }\n+                if def.values.is_some() {\n+                    *buf += \" v\";\n+                }\n+                if def.macros.is_some() {\n+                    *buf += \" m\";\n+                }\n+                if def.is_none() {\n+                    *buf += \" _\";\n+                }\n+\n+                *buf += \"\\n\";\n+            }\n+\n+            for (name, child) in map.modules[module].children.iter() {\n+                let path = path.to_string() + &format!(\"::{}\", name);\n+                go(buf, map, &path, *child);\n+            }\n+        }\n+    }\n }\n \n impl ModuleData {"}, {"sha": "6352c71ef18c387866ce06842c510e1a774d704f", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -22,7 +22,7 @@ use crate::{\n         diagnostics::DefDiagnostic, mod_resolution::ModDir, path_resolution::ReachedFixedPoint,\n         raw, BuiltinShadowMode, CrateDefMap, ModuleData, ModuleOrigin, ResolveMode,\n     },\n-    path::{ModPath, PathKind},\n+    path::{ImportAlias, ModPath, PathKind},\n     per_ns::PerNs,\n     visibility::Visibility,\n     AdtId, AstId, ConstLoc, ContainerId, EnumLoc, EnumVariantId, FunctionLoc, ImplLoc, Intern,\n@@ -438,7 +438,11 @@ where\n         } else {\n             match import.path.segments.last() {\n                 Some(last_segment) => {\n-                    let name = import.alias.clone().unwrap_or_else(|| last_segment.clone());\n+                    let name = match &import.alias {\n+                        Some(ImportAlias::Alias(name)) => name.clone(),\n+                        Some(ImportAlias::Underscore) => last_segment.clone(), // FIXME rust-analyzer#2736\n+                        None => last_segment.clone(),\n+                    };\n                     log::debug!(\"resolved import {:?} ({:?}) to {:?}\", name, import, def);\n \n                     // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658"}, {"sha": "650cf1f98b0b10407bfd62785d04f0da9e5370ca", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -22,8 +22,11 @@ use ra_syntax::{\n use test_utils::tested_by;\n \n use crate::{\n-    attr::Attrs, db::DefDatabase, path::ModPath, visibility::RawVisibility, FileAstId, HirFileId,\n-    InFile,\n+    attr::Attrs,\n+    db::DefDatabase,\n+    path::{ImportAlias, ModPath},\n+    visibility::RawVisibility,\n+    FileAstId, HirFileId, InFile,\n };\n \n /// `RawItems` is a set of top-level items in a file (except for impls).\n@@ -145,7 +148,7 @@ impl_arena_id!(Import);\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ImportData {\n     pub(super) path: ModPath,\n-    pub(super) alias: Option<Name>,\n+    pub(super) alias: Option<ImportAlias>,\n     pub(super) is_glob: bool,\n     pub(super) is_prelude: bool,\n     pub(super) is_extern_crate: bool,\n@@ -353,7 +356,11 @@ impl RawItemsCollector {\n             let path = ModPath::from_name_ref(&name_ref);\n             let visibility =\n                 RawVisibility::from_ast_with_hygiene(extern_crate.visibility(), &self.hygiene);\n-            let alias = extern_crate.alias().and_then(|a| a.name()).map(|it| it.as_name());\n+            let alias = extern_crate.alias().map(|a| {\n+                a.name()\n+                    .map(|it| it.as_name())\n+                    .map_or(ImportAlias::Underscore, |a| ImportAlias::Alias(a))\n+            });\n             let attrs = self.parse_attrs(&extern_crate);\n             // FIXME: cfg_attr\n             let is_macro_use = extern_crate.has_atom_attr(\"macro_use\");"}, {"sha": "82f0f835c8038b6a6bedae0fb34e8882370eba50", "filename": "crates/ra_hir_def/src/nameres/tests.rs", "status": "modified", "additions": 2, "deletions": 41, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -10,11 +10,10 @@ use insta::assert_snapshot;\n use ra_db::{fixture::WithFixture, SourceDatabase};\n use test_utils::covers;\n \n-use crate::{db::DefDatabase, nameres::*, test_db::TestDB, LocalModuleId};\n+use crate::{db::DefDatabase, nameres::*, test_db::TestDB};\n \n fn def_map(fixture: &str) -> String {\n-    let dm = compute_crate_def_map(fixture);\n-    render_crate_def_map(&dm)\n+    compute_crate_def_map(fixture).dump()\n }\n \n fn compute_crate_def_map(fixture: &str) -> Arc<CrateDefMap> {\n@@ -23,44 +22,6 @@ fn compute_crate_def_map(fixture: &str) -> Arc<CrateDefMap> {\n     db.crate_def_map(krate)\n }\n \n-fn render_crate_def_map(map: &CrateDefMap) -> String {\n-    let mut buf = String::new();\n-    go(&mut buf, map, \"\\ncrate\", map.root);\n-    return buf.trim().to_string();\n-\n-    fn go(buf: &mut String, map: &CrateDefMap, path: &str, module: LocalModuleId) {\n-        *buf += path;\n-        *buf += \"\\n\";\n-\n-        let mut entries: Vec<_> = map.modules[module].scope.resolutions().collect();\n-        entries.sort_by_key(|(name, _)| name.clone());\n-\n-        for (name, def) in entries {\n-            *buf += &format!(\"{}:\", name);\n-\n-            if def.types.is_some() {\n-                *buf += \" t\";\n-            }\n-            if def.values.is_some() {\n-                *buf += \" v\";\n-            }\n-            if def.macros.is_some() {\n-                *buf += \" m\";\n-            }\n-            if def.is_none() {\n-                *buf += \" _\";\n-            }\n-\n-            *buf += \"\\n\";\n-        }\n-\n-        for (name, child) in map.modules[module].children.iter() {\n-            let path = path.to_string() + &format!(\"::{}\", name);\n-            go(buf, map, &path, *child);\n-        }\n-    }\n-}\n-\n #[test]\n fn crate_def_map_smoke_test() {\n     let map = def_map("}, {"sha": "246032c13fc79a13e22ee9a8382c607981526337", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -16,13 +16,13 @@ use ra_syntax::ast;\n \n use crate::{type_ref::TypeRef, InFile};\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct ModPath {\n     pub kind: PathKind,\n     pub segments: Vec<Name>,\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub enum PathKind {\n     Plain,\n     /// `self::` is `Super(0)`\n@@ -34,6 +34,14 @@ pub enum PathKind {\n     DollarCrate(CrateId),\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum ImportAlias {\n+    /// Unnamed alias, as in `use Foo as _;`\n+    Underscore,\n+    /// Named alias\n+    Alias(Name),\n+}\n+\n impl ModPath {\n     pub fn from_src(path: ast::Path, hygiene: &Hygiene) -> Option<ModPath> {\n         lower::lower_path(path, hygiene).map(|it| it.mod_path)\n@@ -57,7 +65,7 @@ impl ModPath {\n     pub(crate) fn expand_use_item(\n         item_src: InFile<ast::UseItem>,\n         hygiene: &Hygiene,\n-        mut cb: impl FnMut(ModPath, &ast::UseTree, /* is_glob */ bool, Option<Name>),\n+        mut cb: impl FnMut(ModPath, &ast::UseTree, /* is_glob */ bool, Option<ImportAlias>),\n     ) {\n         if let Some(tree) = item_src.value.use_tree() {\n             lower::lower_use_tree(None, tree, hygiene, &mut cb);"}, {"sha": "d2bc9d1934547f761b9ca2fc50017ae129ae9179", "filename": "crates/ra_hir_def/src/path/lower/lower_use.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -4,20 +4,17 @@\n use std::iter;\n \n use either::Either;\n-use hir_expand::{\n-    hygiene::Hygiene,\n-    name::{AsName, Name},\n-};\n+use hir_expand::{hygiene::Hygiene, name::AsName};\n use ra_syntax::ast::{self, NameOwner};\n use test_utils::tested_by;\n \n-use crate::path::{ModPath, PathKind};\n+use crate::path::{ImportAlias, ModPath, PathKind};\n \n pub(crate) fn lower_use_tree(\n     prefix: Option<ModPath>,\n     tree: ast::UseTree,\n     hygiene: &Hygiene,\n-    cb: &mut dyn FnMut(ModPath, &ast::UseTree, bool, Option<Name>),\n+    cb: &mut dyn FnMut(ModPath, &ast::UseTree, bool, Option<ImportAlias>),\n ) {\n     if let Some(use_tree_list) = tree.use_tree_list() {\n         let prefix = match tree.path() {\n@@ -34,7 +31,11 @@ pub(crate) fn lower_use_tree(\n             lower_use_tree(prefix.clone(), child_tree, hygiene, cb);\n         }\n     } else {\n-        let alias = tree.alias().and_then(|a| a.name()).map(|a| a.as_name());\n+        let alias = tree.alias().map(|a| {\n+            a.name()\n+                .map(|it| it.as_name())\n+                .map_or(ImportAlias::Underscore, |a| ImportAlias::Alias(a))\n+        });\n         let is_glob = tree.has_star();\n         if let Some(ast_path) = tree.path() {\n             // Handle self in a path."}, {"sha": "05cf4646a897ab16ea2ce26a7c1f7676818dc7f3", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -490,10 +490,12 @@ impl Scope {\n             }\n             Scope::GenericParams { params, def } => {\n                 for (local_id, param) in params.types.iter() {\n-                    f(\n-                        param.name.clone(),\n-                        ScopeDef::GenericParam(TypeParamId { local_id, parent: *def }),\n-                    )\n+                    if let Some(name) = &param.name {\n+                        f(\n+                            name.clone(),\n+                            ScopeDef::GenericParam(TypeParamId { local_id, parent: *def }),\n+                        )\n+                    }\n                 }\n             }\n             Scope::ImplBlockScope(i) => {"}, {"sha": "102fdb13d72f5ed70e1f20e6100ac10739328b32", "filename": "crates/ra_hir_def/src/type_ref.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -124,6 +124,48 @@ impl TypeRef {\n     pub(crate) fn unit() -> TypeRef {\n         TypeRef::Tuple(Vec::new())\n     }\n+\n+    pub fn walk(&self, f: &mut impl FnMut(&TypeRef)) {\n+        go(self, f);\n+\n+        fn go(type_ref: &TypeRef, f: &mut impl FnMut(&TypeRef)) {\n+            f(type_ref);\n+            match type_ref {\n+                TypeRef::Fn(types) | TypeRef::Tuple(types) => types.iter().for_each(|t| go(t, f)),\n+                TypeRef::RawPtr(type_ref, _)\n+                | TypeRef::Reference(type_ref, _)\n+                | TypeRef::Array(type_ref)\n+                | TypeRef::Slice(type_ref) => go(&type_ref, f),\n+                TypeRef::ImplTrait(bounds) | TypeRef::DynTrait(bounds) => {\n+                    for bound in bounds {\n+                        match bound {\n+                            TypeBound::Path(path) => go_path(path, f),\n+                            TypeBound::Error => (),\n+                        }\n+                    }\n+                }\n+                TypeRef::Path(path) => go_path(path, f),\n+                TypeRef::Never | TypeRef::Placeholder | TypeRef::Error => {}\n+            };\n+        }\n+\n+        fn go_path(path: &Path, f: &mut impl FnMut(&TypeRef)) {\n+            if let Some(type_ref) = path.type_anchor() {\n+                go(type_ref, f);\n+            }\n+            for segment in path.segments().iter() {\n+                if let Some(args_and_bindings) = segment.args_and_bindings {\n+                    for arg in &args_and_bindings.args {\n+                        let crate::path::GenericArg::Type(type_ref) = arg;\n+                        go(type_ref, f);\n+                    }\n+                    for (_, type_ref) in &args_and_bindings.bindings {\n+                        go(type_ref, f);\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n pub(crate) fn type_bounds_from_ast(type_bounds_opt: Option<ast::TypeBoundList>) -> Vec<TypeBound> {"}, {"sha": "b2e10f445f3360d19126e7f61766e96ec2361a92", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -141,6 +141,8 @@ pub mod known {\n         macro_rules,\n         // Components of known path (value or mod name)\n         std,\n+        core,\n+        alloc,\n         iter,\n         ops,\n         future,"}, {"sha": "f5484bf70a4c6c24c2618e3bd99b366af4ca0e9d", "filename": "crates/ra_hir_ty/Cargo.toml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2FCargo.toml?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -21,11 +21,11 @@ ra_prof = { path = \"../ra_prof\" }\n ra_syntax = { path = \"../ra_syntax\" }\n test_utils = { path = \"../test_utils\" }\n \n-chalk-solve =   { git = \"https://github.com/rust-lang/chalk.git\", rev = \"ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5\" }\n-chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5\" }\n-chalk-ir =      { git = \"https://github.com/rust-lang/chalk.git\", rev = \"ff65b5ac9860f3c36bd892c865ab23d5ff0bbae5\" }\n+chalk-solve =   { git = \"https://github.com/rust-lang/chalk.git\", rev = \"af48f302a1f571b3ca418f7c5aa639a144a34f75\" }\n+chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"af48f302a1f571b3ca418f7c5aa639a144a34f75\" }\n+chalk-ir =      { git = \"https://github.com/rust-lang/chalk.git\", rev = \"af48f302a1f571b3ca418f7c5aa639a144a34f75\" }\n \n lalrpop-intern = \"0.15.1\"\n \n [dev-dependencies]\n-insta = \"0.12.0\"\n+insta = \"0.13.0\""}, {"sha": "e9bfcfa176808b661bbfb310c6abba6253656d14", "filename": "crates/ra_hir_ty/src/db.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -3,17 +3,18 @@\n use std::sync::Arc;\n \n use hir_def::{\n-    db::DefDatabase, DefWithBodyId, GenericDefId, ImplId, LocalStructFieldId, TraitId, VariantId,\n+    db::DefDatabase, DefWithBodyId, GenericDefId, ImplId, LocalStructFieldId, TraitId, TypeParamId,\n+    VariantId,\n };\n use ra_arena::map::ArenaMap;\n-use ra_db::{salsa, CrateId};\n+use ra_db::{impl_intern_key, salsa, CrateId};\n use ra_prof::profile;\n \n use crate::{\n     method_resolution::CrateImplBlocks,\n     traits::{chalk, AssocTyValue, Impl},\n-    CallableDef, FnSig, GenericPredicate, InferenceResult, Substs, TraitRef, Ty, TyDefId, TypeCtor,\n-    ValueTyDefId,\n+    Binders, CallableDef, GenericPredicate, InferenceResult, PolyFnSig, Substs, TraitRef, Ty,\n+    TyDefId, TypeCtor, ValueTyDefId,\n };\n \n #[salsa::query_group(HirDatabaseStorage)]\n@@ -27,34 +28,33 @@ pub trait HirDatabase: DefDatabase {\n \n     #[salsa::invoke(crate::lower::ty_query)]\n     #[salsa::cycle(crate::lower::ty_recover)]\n-    fn ty(&self, def: TyDefId) -> Ty;\n+    fn ty(&self, def: TyDefId) -> Binders<Ty>;\n \n     #[salsa::invoke(crate::lower::value_ty_query)]\n-    fn value_ty(&self, def: ValueTyDefId) -> Ty;\n+    fn value_ty(&self, def: ValueTyDefId) -> Binders<Ty>;\n \n     #[salsa::invoke(crate::lower::impl_self_ty_query)]\n     #[salsa::cycle(crate::lower::impl_self_ty_recover)]\n-    fn impl_self_ty(&self, def: ImplId) -> Ty;\n+    fn impl_self_ty(&self, def: ImplId) -> Binders<Ty>;\n \n     #[salsa::invoke(crate::lower::impl_trait_query)]\n-    fn impl_trait(&self, def: ImplId) -> Option<TraitRef>;\n+    fn impl_trait(&self, def: ImplId) -> Option<Binders<TraitRef>>;\n \n     #[salsa::invoke(crate::lower::field_types_query)]\n-    fn field_types(&self, var: VariantId) -> Arc<ArenaMap<LocalStructFieldId, Ty>>;\n+    fn field_types(&self, var: VariantId) -> Arc<ArenaMap<LocalStructFieldId, Binders<Ty>>>;\n \n     #[salsa::invoke(crate::callable_item_sig)]\n-    fn callable_item_signature(&self, def: CallableDef) -> FnSig;\n+    fn callable_item_signature(&self, def: CallableDef) -> PolyFnSig;\n \n     #[salsa::invoke(crate::lower::generic_predicates_for_param_query)]\n     #[salsa::cycle(crate::lower::generic_predicates_for_param_recover)]\n     fn generic_predicates_for_param(\n         &self,\n-        def: GenericDefId,\n-        param_idx: u32,\n-    ) -> Arc<[GenericPredicate]>;\n+        param_id: TypeParamId,\n+    ) -> Arc<[Binders<GenericPredicate>]>;\n \n     #[salsa::invoke(crate::lower::generic_predicates_query)]\n-    fn generic_predicates(&self, def: GenericDefId) -> Arc<[GenericPredicate]>;\n+    fn generic_predicates(&self, def: GenericDefId) -> Arc<[Binders<GenericPredicate>]>;\n \n     #[salsa::invoke(crate::lower::generic_defaults_query)]\n     fn generic_defaults(&self, def: GenericDefId) -> Substs;\n@@ -77,6 +77,8 @@ pub trait HirDatabase: DefDatabase {\n     #[salsa::interned]\n     fn intern_type_ctor(&self, type_ctor: TypeCtor) -> crate::TypeCtorId;\n     #[salsa::interned]\n+    fn intern_type_param_id(&self, param_id: TypeParamId) -> GlobalTypeParamId;\n+    #[salsa::interned]\n     fn intern_chalk_impl(&self, impl_: Impl) -> crate::traits::GlobalImplId;\n     #[salsa::interned]\n     fn intern_assoc_ty_value(&self, assoc_ty_value: AssocTyValue) -> crate::traits::AssocTyValueId;\n@@ -117,3 +119,7 @@ fn infer(db: &impl HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult> {\n fn hir_database_is_object_safe() {\n     fn _assert_object_safe(_: &dyn HirDatabase) {}\n }\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct GlobalTypeParamId(salsa::InternId);\n+impl_intern_key!(GlobalTypeParamId);"}, {"sha": "a9d958c8bcdad9f1689ab5d427905b22ed60a386", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 28, "deletions": 38, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -34,15 +34,16 @@ use hir_expand::{diagnostics::DiagnosticSink, name::name};\n use ra_arena::map::ArenaMap;\n use ra_prof::profile;\n use ra_syntax::SmolStr;\n-use test_utils::tested_by;\n \n use super::{\n     primitive::{FloatTy, IntTy},\n     traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n     ApplicationTy, GenericPredicate, InEnvironment, ProjectionTy, Substs, TraitEnvironment,\n     TraitRef, Ty, TypeCtor, TypeWalk, Uncertain,\n };\n-use crate::{db::HirDatabase, infer::diagnostics::InferenceDiagnostic};\n+use crate::{\n+    db::HirDatabase, infer::diagnostics::InferenceDiagnostic, lower::ImplTraitLoweringMode,\n+};\n \n pub(crate) use unify::unify;\n \n@@ -271,38 +272,21 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.result.diagnostics.push(diagnostic);\n     }\n \n-    fn make_ty(&mut self, type_ref: &TypeRef) -> Ty {\n-        let ty = Ty::from_hir(\n-            self.db,\n-            // FIXME use right resolver for block\n-            &self.resolver,\n-            type_ref,\n-        );\n+    fn make_ty_with_mode(\n+        &mut self,\n+        type_ref: &TypeRef,\n+        impl_trait_mode: ImplTraitLoweringMode,\n+    ) -> Ty {\n+        // FIXME use right resolver for block\n+        let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver)\n+            .with_impl_trait_mode(impl_trait_mode);\n+        let ty = Ty::from_hir(&ctx, type_ref);\n         let ty = self.insert_type_vars(ty);\n         self.normalize_associated_types_in(ty)\n     }\n \n-    /// Replaces `impl Trait` in `ty` by type variables and obligations for\n-    /// those variables. This is done for function arguments when calling a\n-    /// function, and for return types when inside the function body, i.e. in\n-    /// the cases where the `impl Trait` is 'transparent'. In other cases, `impl\n-    /// Trait` is represented by `Ty::Opaque`.\n-    fn insert_vars_for_impl_trait(&mut self, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| match ty {\n-            Ty::Opaque(preds) => {\n-                tested_by!(insert_vars_for_impl_trait);\n-                let var = self.table.new_type_var();\n-                let var_subst = Substs::builder(1).push(var.clone()).build();\n-                self.obligations.extend(\n-                    preds\n-                        .iter()\n-                        .map(|pred| pred.clone().subst_bound_vars(&var_subst))\n-                        .filter_map(Obligation::from_predicate),\n-                );\n-                var\n-            }\n-            _ => ty,\n-        })\n+    fn make_ty(&mut self, type_ref: &TypeRef) -> Ty {\n+        self.make_ty_with_mode(type_ref, ImplTraitLoweringMode::Disallowed)\n     }\n \n     /// Replaces Ty::Unknown by a new type var, so we can maybe still infer it.\n@@ -446,19 +430,20 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             None => return (Ty::Unknown, None),\n         };\n         let resolver = &self.resolver;\n+        let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n         // FIXME: this should resolve assoc items as well, see this example:\n         // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n         match resolver.resolve_path_in_type_ns_fully(self.db, path.mod_path()) {\n             Some(TypeNs::AdtId(AdtId::StructId(strukt))) => {\n-                let substs = Ty::substs_from_path(self.db, resolver, path, strukt.into());\n+                let substs = Ty::substs_from_path(&ctx, path, strukt.into());\n                 let ty = self.db.ty(strukt.into());\n-                let ty = self.insert_type_vars(ty.apply_substs(substs));\n+                let ty = self.insert_type_vars(ty.subst(&substs));\n                 (ty, Some(strukt.into()))\n             }\n             Some(TypeNs::EnumVariantId(var)) => {\n-                let substs = Ty::substs_from_path(self.db, resolver, path, var.into());\n+                let substs = Ty::substs_from_path(&ctx, path, var.into());\n                 let ty = self.db.ty(var.parent.into());\n-                let ty = self.insert_type_vars(ty.apply_substs(substs));\n+                let ty = self.insert_type_vars(ty.subst(&substs));\n                 (ty, Some(var.into()))\n             }\n             Some(_) | None => (Ty::Unknown, None),\n@@ -471,13 +456,18 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     fn collect_fn(&mut self, data: &FunctionData) {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n-        for (type_ref, pat) in data.params.iter().zip(body.params.iter()) {\n-            let ty = self.make_ty(type_ref);\n+        let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver)\n+            .with_impl_trait_mode(ImplTraitLoweringMode::Param);\n+        let param_tys =\n+            data.params.iter().map(|type_ref| Ty::from_hir(&ctx, type_ref)).collect::<Vec<_>>();\n+        for (ty, pat) in param_tys.into_iter().zip(body.params.iter()) {\n+            let ty = self.insert_type_vars(ty);\n+            let ty = self.normalize_associated_types_in(ty);\n \n             self.infer_pat(*pat, &ty, BindingMode::default());\n         }\n-        let return_ty = self.make_ty(&data.ret_type);\n-        self.return_ty = self.insert_vars_for_impl_trait(return_ty);\n+        let return_ty = self.make_ty_with_mode(&data.ret_type, ImplTraitLoweringMode::Disallowed); // FIXME implement RPIT\n+        self.return_ty = return_ty;\n     }\n \n     fn infer_body(&mut self) {"}, {"sha": "f68a1439f8f132ae86bcd2cdd1dd348b21a9a508", "filename": "crates/ra_hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -57,18 +57,16 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let trait_ref = db.impl_trait(impl_id)?;\n \n                 // `CoerseUnsized` has one generic parameter for the target type.\n-                let cur_from_ty = trait_ref.substs.0.get(0)?;\n-                let cur_to_ty = trait_ref.substs.0.get(1)?;\n+                let cur_from_ty = trait_ref.value.substs.0.get(0)?;\n+                let cur_to_ty = trait_ref.value.substs.0.get(1)?;\n \n                 match (&cur_from_ty, cur_to_ty) {\n                     (ty_app!(ctor1, st1), ty_app!(ctor2, st2)) => {\n                         // FIXME: We return the first non-equal bound as the type parameter to coerce to unsized type.\n                         // This works for smart-pointer-like coercion, which covers all impls from std.\n                         st1.iter().zip(st2.iter()).enumerate().find_map(|(i, (ty1, ty2))| {\n                             match (ty1, ty2) {\n-                                (Ty::Param { idx: p1, .. }, Ty::Param { idx: p2, .. })\n-                                    if p1 != p2 =>\n-                                {\n+                                (Ty::Bound(idx1), Ty::Bound(idx2)) if idx1 != idx2 => {\n                                     Some(((*ctor1, *ctor2), i))\n                                 }\n                                 _ => None,\n@@ -256,8 +254,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let unsize_generic_index = {\n                     let mut index = None;\n                     let mut multiple_param = false;\n-                    field_tys[last_field_id].walk(&mut |ty| match ty {\n-                        &Ty::Param { idx, .. } => {\n+                    field_tys[last_field_id].value.walk(&mut |ty| match ty {\n+                        &Ty::Bound(idx) => {\n                             if index.is_none() {\n                                 index = Some(idx);\n                             } else if Some(idx) != index {\n@@ -276,10 +274,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 // Check other fields do not involve it.\n                 let mut multiple_used = false;\n                 fields.for_each(|(field_id, _data)| {\n-                    field_tys[field_id].walk(&mut |ty| match ty {\n-                        &Ty::Param { idx, .. } if idx == unsize_generic_index => {\n-                            multiple_used = true\n-                        }\n+                    field_tys[field_id].value.walk(&mut |ty| match ty {\n+                        &Ty::Bound(idx) if idx == unsize_generic_index => multiple_used = true,\n                         _ => {}\n                     })\n                 });"}, {"sha": "3c9c02d03ed516bce3a4ff12ef9c9547da644697", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -10,7 +10,7 @@ use hir_def::{\n     resolver::resolver_for_expr,\n     AdtId, AssocContainerId, Lookup, StructFieldId,\n };\n-use hir_expand::name::{name, Name};\n+use hir_expand::name::Name;\n use ra_syntax::ast::RangeOp;\n \n use crate::{\n@@ -19,8 +19,8 @@ use crate::{\n     method_resolution, op,\n     traits::InEnvironment,\n     utils::{generics, variant_data, Generics},\n-    ApplicationTy, CallableDef, InferTy, IntTy, Mutability, Obligation, Substs, TraitRef, Ty,\n-    TypeCtor, TypeWalk, Uncertain,\n+    ApplicationTy, Binders, CallableDef, InferTy, IntTy, Mutability, Obligation, Substs, TraitRef,\n+    Ty, TypeCtor, Uncertain,\n };\n \n use super::{BindingMode, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch};\n@@ -236,8 +236,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         self.result.record_field_resolutions.insert(field.expr, field_def);\n                     }\n                     let field_ty = field_def\n-                        .map_or(Ty::Unknown, |it| field_types[it.local_id].clone())\n-                        .subst(&substs);\n+                        .map_or(Ty::Unknown, |it| field_types[it.local_id].clone().subst(&substs));\n                     self.infer_expr_coerce(field.expr, &Expectation::has_type(field_ty));\n                 }\n                 if let Some(expr) = spread {\n@@ -588,10 +587,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 self.write_method_resolution(tgt_expr, func);\n                 (ty, self.db.value_ty(func.into()), Some(generics(self.db, func.into())))\n             }\n-            None => (receiver_ty, Ty::Unknown, None),\n+            None => (receiver_ty, Binders::new(0, Ty::Unknown), None),\n         };\n         let substs = self.substs_for_method_call(def_generics, generic_args, &derefed_receiver_ty);\n-        let method_ty = method_ty.apply_substs(substs);\n+        let method_ty = method_ty.subst(&substs);\n         let method_ty = self.insert_type_vars(method_ty);\n         self.register_obligations_for_call(&method_ty);\n         let (expected_receiver_ty, param_tys, ret_ty) = match method_ty.callable_sig(self.db) {\n@@ -635,7 +634,6 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     continue;\n                 }\n \n-                let param_ty = self.insert_vars_for_impl_trait(param_ty);\n                 let param_ty = self.normalize_associated_types_in(param_ty);\n                 self.infer_expr_coerce(arg, &Expectation::has_type(param_ty.clone()));\n             }\n@@ -648,13 +646,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         generic_args: Option<&GenericArgs>,\n         receiver_ty: &Ty,\n     ) -> Substs {\n-        let (total_len, _parent_len, child_len) =\n-            def_generics.as_ref().map_or((0, 0, 0), |g| g.len_split());\n+        let (parent_params, self_params, type_params, impl_trait_params) =\n+            def_generics.as_ref().map_or((0, 0, 0, 0), |g| g.provenance_split());\n+        assert_eq!(self_params, 0); // method shouldn't have another Self param\n+        let total_len = parent_params + type_params + impl_trait_params;\n         let mut substs = Vec::with_capacity(total_len);\n         // Parent arguments are unknown, except for the receiver type\n         if let Some(parent_generics) = def_generics.as_ref().map(|p| p.iter_parent()) {\n             for (_id, param) in parent_generics {\n-                if param.name == name![Self] {\n+                if param.provenance == hir_def::generics::TypeParamProvenance::TraitSelf {\n                     substs.push(receiver_ty.clone());\n                 } else {\n                     substs.push(Ty::Unknown);\n@@ -664,7 +664,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         // handle provided type arguments\n         if let Some(generic_args) = generic_args {\n             // if args are provided, it should be all of them, but we can't rely on that\n-            for arg in generic_args.args.iter().take(child_len) {\n+            for arg in generic_args.args.iter().take(type_params) {\n                 match arg {\n                     GenericArg::Type(type_ref) => {\n                         let ty = self.make_ty(type_ref);"}, {"sha": "e7283f24cd35ef71ddbf0f4fc48d1583cb52a95f", "filename": "crates/ra_hir_ty/src/infer/pat.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -12,7 +12,7 @@ use hir_expand::name::Name;\n use test_utils::tested_by;\n \n use super::{BindingMode, InferenceContext};\n-use crate::{db::HirDatabase, utils::variant_data, Substs, Ty, TypeCtor, TypeWalk};\n+use crate::{db::HirDatabase, utils::variant_data, Substs, Ty, TypeCtor};\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn infer_tuple_struct_pat(\n@@ -34,8 +34,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             let expected_ty = var_data\n                 .as_ref()\n                 .and_then(|d| d.field(&Name::new_tuple_field(i)))\n-                .map_or(Ty::Unknown, |field| field_tys[field].clone())\n-                .subst(&substs);\n+                .map_or(Ty::Unknown, |field| field_tys[field].clone().subst(&substs));\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat, &expected_ty, default_bm);\n         }\n@@ -65,7 +64,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         for subpat in subpats {\n             let matching_field = var_data.as_ref().and_then(|it| it.field(&subpat.name));\n             let expected_ty =\n-                matching_field.map_or(Ty::Unknown, |field| field_tys[field].clone()).subst(&substs);\n+                matching_field.map_or(Ty::Unknown, |field| field_tys[field].clone().subst(&substs));\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat.pat, &expected_ty, default_bm);\n         }"}, {"sha": "686ce7a218b2d4ca50fd8b45670b38be800bebdc", "filename": "crates/ra_hir_ty/src/infer/path.rs", "status": "modified", "additions": 24, "deletions": 36, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -9,9 +9,9 @@ use hir_def::{\n };\n use hir_expand::name::Name;\n \n-use crate::{db::HirDatabase, method_resolution, Substs, Ty, TypeWalk, ValueTyDefId};\n+use crate::{db::HirDatabase, method_resolution, Substs, Ty, ValueTyDefId};\n \n-use super::{ExprOrPatId, InferenceContext, TraitEnvironment, TraitRef};\n+use super::{ExprOrPatId, InferenceContext, TraitRef};\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     pub(super) fn infer_path(\n@@ -39,7 +39,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             let ty = self.make_ty(type_ref);\n             let remaining_segments_for_ty = path.segments().take(path.segments().len() - 1);\n-            let ty = Ty::from_type_relative_path(self.db, resolver, ty, remaining_segments_for_ty);\n+            let ctx = crate::lower::TyLoweringContext::new(self.db, &resolver);\n+            let ty = Ty::from_type_relative_path(&ctx, ty, remaining_segments_for_ty);\n             self.resolve_ty_assoc_item(\n                 ty,\n                 &path.segments().last().expect(\"path had at least one segment\").name,\n@@ -69,12 +70,16 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             ValueNs::EnumVariantId(it) => it.into(),\n         };\n \n-        let mut ty = self.db.value_ty(typable);\n-        if let Some(self_subst) = self_subst {\n-            ty = ty.subst(&self_subst);\n-        }\n-        let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n-        let ty = ty.subst(&substs);\n+        let ty = self.db.value_ty(typable);\n+        // self_subst is just for the parent\n+        let parent_substs = self_subst.unwrap_or_else(Substs::empty);\n+        let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n+        let substs = Ty::substs_from_path(&ctx, path, typable);\n+        let full_substs = Substs::builder(substs.len())\n+            .use_parent_substs(&parent_substs)\n+            .fill(substs.0[parent_substs.len()..].iter().cloned())\n+            .build();\n+        let ty = ty.subst(&full_substs);\n         Some(ty)\n     }\n \n@@ -98,13 +103,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             (TypeNs::TraitId(trait_), true) => {\n                 let segment =\n                     remaining_segments.last().expect(\"there should be at least one segment here\");\n-                let trait_ref = TraitRef::from_resolved_path(\n-                    self.db,\n-                    &self.resolver,\n-                    trait_.into(),\n-                    resolved_segment,\n-                    None,\n-                );\n+                let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n+                let trait_ref =\n+                    TraitRef::from_resolved_path(&ctx, trait_.into(), resolved_segment, None);\n                 self.resolve_trait_assoc_item(trait_ref, segment, id)\n             }\n             (def, _) => {\n@@ -114,9 +115,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 // as Iterator>::Item::default`)\n                 let remaining_segments_for_ty =\n                     remaining_segments.take(remaining_segments.len() - 1);\n+                let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n                 let ty = Ty::from_partly_resolved_hir_path(\n-                    self.db,\n-                    &self.resolver,\n+                    &ctx,\n                     def,\n                     resolved_segment,\n                     remaining_segments_for_ty,\n@@ -173,13 +174,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             AssocItemId::ConstId(c) => ValueNs::ConstId(c),\n             AssocItemId::TypeAliasId(_) => unreachable!(),\n         };\n-        let substs = Substs::build_for_def(self.db, item)\n-            .use_parent_substs(&trait_ref.substs)\n-            .fill_with_params()\n-            .build();\n \n         self.write_assoc_resolution(id, item);\n-        Some((def, Some(substs)))\n+        Some((def, Some(trait_ref.substs)))\n     }\n \n     fn resolve_ty_assoc_item(\n@@ -193,14 +190,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n \n         let canonical_ty = self.canonicalizer().canonicalize_ty(ty.clone());\n-        let env = TraitEnvironment::lower(self.db, &self.resolver);\n         let krate = self.resolver.krate()?;\n         let traits_in_scope = self.resolver.traits_in_scope(self.db);\n \n         method_resolution::iterate_method_candidates(\n             &canonical_ty.value,\n             self.db,\n-            env,\n+            self.trait_env.clone(),\n             krate,\n             &traits_in_scope,\n             Some(name),\n@@ -219,28 +215,20 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             .fill(iter::repeat_with(|| self.table.new_type_var()))\n                             .build();\n                         let impl_self_ty = self.db.impl_self_ty(impl_id).subst(&impl_substs);\n-                        let substs = Substs::build_for_def(self.db, item)\n-                            .use_parent_substs(&impl_substs)\n-                            .fill_with_params()\n-                            .build();\n                         self.unify(&impl_self_ty, &ty);\n-                        Some(substs)\n+                        Some(impl_substs)\n                     }\n                     AssocContainerId::TraitId(trait_) => {\n                         // we're picking this method\n                         let trait_substs = Substs::build_for_def(self.db, trait_)\n                             .push(ty.clone())\n                             .fill(std::iter::repeat_with(|| self.table.new_type_var()))\n                             .build();\n-                        let substs = Substs::build_for_def(self.db, item)\n-                            .use_parent_substs(&trait_substs)\n-                            .fill_with_params()\n-                            .build();\n                         self.obligations.push(super::Obligation::Trait(TraitRef {\n                             trait_,\n-                            substs: trait_substs,\n+                            substs: trait_substs.clone(),\n                         }));\n-                        Some(substs)\n+                        Some(trait_substs)\n                     }\n                     AssocContainerId::ContainerId(_) => None,\n                 };"}, {"sha": "c5fe18c8550d3468c1c8e162d829079c42524153", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 155, "deletions": 109, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -44,8 +44,8 @@ use std::sync::Arc;\n use std::{fmt, iter, mem};\n \n use hir_def::{\n-    expr::ExprId, type_ref::Mutability, AdtId, AssocContainerId, DefWithBodyId, GenericDefId,\n-    HasModule, Lookup, TraitId, TypeAliasId,\n+    expr::ExprId, generics::TypeParamProvenance, type_ref::Mutability, AdtId, AssocContainerId,\n+    DefWithBodyId, GenericDefId, HasModule, Lookup, TraitId, TypeAliasId, TypeParamId,\n };\n use hir_expand::name::Name;\n use ra_db::{impl_intern_key, salsa, CrateId};\n@@ -60,7 +60,9 @@ use display::{HirDisplay, HirFormatter};\n pub use autoderef::autoderef;\n pub use infer::{do_infer_query, InferTy, InferenceResult};\n pub use lower::CallableDef;\n-pub use lower::{callable_item_sig, TyDefId, ValueTyDefId};\n+pub use lower::{\n+    callable_item_sig, ImplTraitLoweringMode, TyDefId, TyLoweringContext, ValueTyDefId,\n+};\n pub use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironment};\n \n /// A type constructor or type name: this might be something like the primitive\n@@ -285,22 +287,20 @@ pub enum Ty {\n     /// trait and all its parameters are fully known.\n     Projection(ProjectionTy),\n \n-    /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n-    Param {\n-        /// The index of the parameter (starting with parameters from the\n-        /// surrounding impl, then the current function).\n-        idx: u32,\n-        /// The name of the parameter, for displaying.\n-        // FIXME get rid of this\n-        name: Name,\n-    },\n-\n-    /// A bound type variable. Used during trait resolution to represent Chalk\n-    /// variables, and in `Dyn` and `Opaque` bounds to represent the `Self` type.\n+    /// A placeholder for a type parameter; for example, `T` in `fn f<T>(x: T)\n+    /// {}` when we're type-checking the body of that function. In this\n+    /// situation, we know this stands for *some* type, but don't know the exact\n+    /// type.\n+    Param(TypeParamId),\n+\n+    /// A bound type variable. This is used in various places: when representing\n+    /// some polymorphic type like the type of function `fn f<T>`, the type\n+    /// parameters get turned into variables; during trait resolution, inference\n+    /// variables get turned into bound variables and back; and in `Dyn` the\n+    /// `Self` type is represented with a bound variable as well.\n     Bound(u32),\n \n-    /// A type variable used during type checking. Not to be confused with a\n-    /// type parameter.\n+    /// A type variable used during type checking.\n     Infer(InferTy),\n \n     /// A trait object (`dyn Trait` or bare `Trait` in pre-2018 Rust).\n@@ -364,15 +364,19 @@ impl Substs {\n     }\n \n     /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n-    pub(crate) fn identity(generic_params: &Generics) -> Substs {\n-        Substs(\n-            generic_params.iter().map(|(idx, p)| Ty::Param { idx, name: p.name.clone() }).collect(),\n-        )\n+    pub(crate) fn type_params_for_generics(generic_params: &Generics) -> Substs {\n+        Substs(generic_params.iter().map(|(id, _)| Ty::Param(id)).collect())\n+    }\n+\n+    /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n+    pub fn type_params(db: &impl HirDatabase, def: impl Into<GenericDefId>) -> Substs {\n+        let params = generics(db, def.into());\n+        Substs::type_params_for_generics(&params)\n     }\n \n     /// Return Substs that replace each parameter by a bound variable.\n     pub(crate) fn bound_vars(generic_params: &Generics) -> Substs {\n-        Substs(generic_params.iter().map(|(idx, _p)| Ty::Bound(idx)).collect())\n+        Substs(generic_params.iter().enumerate().map(|(idx, _)| Ty::Bound(idx as u32)).collect())\n     }\n \n     pub fn build_for_def(db: &impl HirDatabase, def: impl Into<GenericDefId>) -> SubstsBuilder {\n@@ -420,11 +424,6 @@ impl SubstsBuilder {\n         self.fill((starting_from..).map(Ty::Bound))\n     }\n \n-    pub fn fill_with_params(self) -> Self {\n-        let start = self.vec.len() as u32;\n-        self.fill((start..).map(|idx| Ty::Param { idx, name: Name::missing() }))\n-    }\n-\n     pub fn fill_with_unknown(self) -> Self {\n         self.fill(iter::repeat(Ty::Unknown))\n     }\n@@ -451,6 +450,32 @@ impl Deref for Substs {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct Binders<T> {\n+    pub num_binders: usize,\n+    pub value: T,\n+}\n+\n+impl<T> Binders<T> {\n+    pub fn new(num_binders: usize, value: T) -> Self {\n+        Self { num_binders, value }\n+    }\n+}\n+\n+impl<T: TypeWalk> Binders<T> {\n+    /// Substitutes all variables.\n+    pub fn subst(self, subst: &Substs) -> T {\n+        assert_eq!(subst.len(), self.num_binders);\n+        self.value.subst_bound_vars(subst)\n+    }\n+\n+    /// Substitutes just a prefix of the variables (shifting the rest).\n+    pub fn subst_prefix(self, subst: &Substs) -> Binders<T> {\n+        assert!(subst.len() < self.num_binders);\n+        Binders::new(self.num_binders - subst.len(), self.value.subst_bound_vars(subst))\n+    }\n+}\n+\n /// A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait.\n /// Name to be bikeshedded: TraitBound? TraitImplements?\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n@@ -551,6 +576,9 @@ pub struct FnSig {\n     params_and_return: Arc<[Ty]>,\n }\n \n+/// A polymorphic function signature.\n+pub type PolyFnSig = Binders<FnSig>;\n+\n impl FnSig {\n     pub fn from_params_and_return(mut params: Vec<Ty>, ret: Ty) -> FnSig {\n         params.push(ret);\n@@ -730,22 +758,7 @@ pub trait TypeWalk {\n         self\n     }\n \n-    /// Replaces type parameters in this type using the given `Substs`. (So e.g.\n-    /// if `self` is `&[T]`, where type parameter T has index 0, and the\n-    /// `Substs` contain `u32` at index 0, we'll have `&[u32]` afterwards.)\n-    fn subst(self, substs: &Substs) -> Self\n-    where\n-        Self: Sized,\n-    {\n-        self.fold(&mut |ty| match ty {\n-            Ty::Param { idx, name } => {\n-                substs.get(idx as usize).cloned().unwrap_or(Ty::Param { idx, name })\n-            }\n-            ty => ty,\n-        })\n-    }\n-\n-    /// Substitutes `Ty::Bound` vars (as opposed to type parameters).\n+    /// Substitutes `Ty::Bound` vars with the given substitution.\n     fn subst_bound_vars(mut self, substs: &Substs) -> Self\n     where\n         Self: Sized,\n@@ -755,6 +768,9 @@ pub trait TypeWalk {\n                 &mut Ty::Bound(idx) => {\n                     if idx as usize >= binders && (idx as usize - binders) < substs.len() {\n                         *ty = substs.0[idx as usize - binders].clone();\n+                    } else if idx as usize >= binders + substs.len() {\n+                        // shift free binders\n+                        *ty = Ty::Bound(idx - substs.len() as u32);\n                     }\n                 }\n                 _ => {}\n@@ -847,7 +863,7 @@ impl HirDisplay for ApplicationTy {\n             }\n             TypeCtor::Array => {\n                 let t = self.parameters.as_single();\n-                write!(f, \"[{};_]\", t.display(f.db))?;\n+                write!(f, \"[{}; _]\", t.display(f.db))?;\n             }\n             TypeCtor::RawPtr(m) => {\n                 let t = self.parameters.as_single();\n@@ -880,7 +896,7 @@ impl HirDisplay for ApplicationTy {\n                 write!(f, \") -> {}\", sig.ret().display(f.db))?;\n             }\n             TypeCtor::FnDef(def) => {\n-                let sig = f.db.callable_item_signature(def);\n+                let sig = f.db.callable_item_signature(def).subst(&self.parameters);\n                 let name = match def {\n                     CallableDef::FunctionId(ff) => f.db.function_data(ff).name.clone(),\n                     CallableDef::StructId(s) => f.db.struct_data(s).name.clone(),\n@@ -896,9 +912,16 @@ impl HirDisplay for ApplicationTy {\n                     }\n                 }\n                 if self.parameters.len() > 0 {\n-                    write!(f, \"<\")?;\n-                    f.write_joined(&*self.parameters.0, \", \")?;\n-                    write!(f, \">\")?;\n+                    let generics = generics(f.db, def.into());\n+                    let (parent_params, self_param, type_params, _impl_trait_params) =\n+                        generics.provenance_split();\n+                    let total_len = parent_params + self_param + type_params;\n+                    // We print all params except implicit impl Trait params. Still a bit weird; should we leave out parent and self?\n+                    if total_len > 0 {\n+                        write!(f, \"<\")?;\n+                        f.write_joined(&self.parameters.0[..total_len], \", \")?;\n+                        write!(f, \">\")?;\n+                    }\n                 }\n                 write!(f, \"(\")?;\n                 f.write_joined(sig.params(), \", \")?;\n@@ -1009,74 +1032,32 @@ impl HirDisplay for Ty {\n         match self {\n             Ty::Apply(a_ty) => a_ty.hir_fmt(f)?,\n             Ty::Projection(p_ty) => p_ty.hir_fmt(f)?,\n-            Ty::Param { name, .. } => write!(f, \"{}\", name)?,\n+            Ty::Param(id) => {\n+                let generics = generics(f.db, id.parent);\n+                let param_data = &generics.params.types[id.local_id];\n+                match param_data.provenance {\n+                    TypeParamProvenance::TypeParamList | TypeParamProvenance::TraitSelf => {\n+                        write!(f, \"{}\", param_data.name.clone().unwrap_or_else(Name::missing))?\n+                    }\n+                    TypeParamProvenance::ArgumentImplTrait => {\n+                        write!(f, \"impl \")?;\n+                        let bounds = f.db.generic_predicates_for_param(*id);\n+                        let substs = Substs::type_params_for_generics(&generics);\n+                        write_bounds_like_dyn_trait(\n+                            &bounds.iter().map(|b| b.clone().subst(&substs)).collect::<Vec<_>>(),\n+                            f,\n+                        )?;\n+                    }\n+                }\n+            }\n             Ty::Bound(idx) => write!(f, \"?{}\", idx)?,\n             Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n                 match self {\n                     Ty::Dyn(_) => write!(f, \"dyn \")?,\n                     Ty::Opaque(_) => write!(f, \"impl \")?,\n                     _ => unreachable!(),\n                 };\n-                // Note: This code is written to produce nice results (i.e.\n-                // corresponding to surface Rust) for types that can occur in\n-                // actual Rust. It will have weird results if the predicates\n-                // aren't as expected (i.e. self types = $0, projection\n-                // predicates for a certain trait come after the Implemented\n-                // predicate for that trait).\n-                let mut first = true;\n-                let mut angle_open = false;\n-                for p in predicates.iter() {\n-                    match p {\n-                        GenericPredicate::Implemented(trait_ref) => {\n-                            if angle_open {\n-                                write!(f, \">\")?;\n-                            }\n-                            if !first {\n-                                write!(f, \" + \")?;\n-                            }\n-                            // We assume that the self type is $0 (i.e. the\n-                            // existential) here, which is the only thing that's\n-                            // possible in actual Rust, and hence don't print it\n-                            write!(f, \"{}\", f.db.trait_data(trait_ref.trait_).name.clone())?;\n-                            if trait_ref.substs.len() > 1 {\n-                                write!(f, \"<\")?;\n-                                f.write_joined(&trait_ref.substs[1..], \", \")?;\n-                                // there might be assoc type bindings, so we leave the angle brackets open\n-                                angle_open = true;\n-                            }\n-                        }\n-                        GenericPredicate::Projection(projection_pred) => {\n-                            // in types in actual Rust, these will always come\n-                            // after the corresponding Implemented predicate\n-                            if angle_open {\n-                                write!(f, \", \")?;\n-                            } else {\n-                                write!(f, \"<\")?;\n-                                angle_open = true;\n-                            }\n-                            let name =\n-                                f.db.type_alias_data(projection_pred.projection_ty.associated_ty)\n-                                    .name\n-                                    .clone();\n-                            write!(f, \"{} = \", name)?;\n-                            projection_pred.ty.hir_fmt(f)?;\n-                        }\n-                        GenericPredicate::Error => {\n-                            if angle_open {\n-                                // impl Trait<X, {error}>\n-                                write!(f, \", \")?;\n-                            } else if !first {\n-                                // impl Trait + {error}\n-                                write!(f, \" + \")?;\n-                            }\n-                            p.hir_fmt(f)?;\n-                        }\n-                    }\n-                    first = false;\n-                }\n-                if angle_open {\n-                    write!(f, \">\")?;\n-                }\n+                write_bounds_like_dyn_trait(&predicates, f)?;\n             }\n             Ty::Unknown => write!(f, \"{{unknown}}\")?,\n             Ty::Infer(..) => write!(f, \"_\")?,\n@@ -1085,6 +1066,71 @@ impl HirDisplay for Ty {\n     }\n }\n \n+fn write_bounds_like_dyn_trait(\n+    predicates: &[GenericPredicate],\n+    f: &mut HirFormatter<impl HirDatabase>,\n+) -> fmt::Result {\n+    // Note: This code is written to produce nice results (i.e.\n+    // corresponding to surface Rust) for types that can occur in\n+    // actual Rust. It will have weird results if the predicates\n+    // aren't as expected (i.e. self types = $0, projection\n+    // predicates for a certain trait come after the Implemented\n+    // predicate for that trait).\n+    let mut first = true;\n+    let mut angle_open = false;\n+    for p in predicates.iter() {\n+        match p {\n+            GenericPredicate::Implemented(trait_ref) => {\n+                if angle_open {\n+                    write!(f, \">\")?;\n+                }\n+                if !first {\n+                    write!(f, \" + \")?;\n+                }\n+                // We assume that the self type is $0 (i.e. the\n+                // existential) here, which is the only thing that's\n+                // possible in actual Rust, and hence don't print it\n+                write!(f, \"{}\", f.db.trait_data(trait_ref.trait_).name.clone())?;\n+                if trait_ref.substs.len() > 1 {\n+                    write!(f, \"<\")?;\n+                    f.write_joined(&trait_ref.substs[1..], \", \")?;\n+                    // there might be assoc type bindings, so we leave the angle brackets open\n+                    angle_open = true;\n+                }\n+            }\n+            GenericPredicate::Projection(projection_pred) => {\n+                // in types in actual Rust, these will always come\n+                // after the corresponding Implemented predicate\n+                if angle_open {\n+                    write!(f, \", \")?;\n+                } else {\n+                    write!(f, \"<\")?;\n+                    angle_open = true;\n+                }\n+                let name =\n+                    f.db.type_alias_data(projection_pred.projection_ty.associated_ty).name.clone();\n+                write!(f, \"{} = \", name)?;\n+                projection_pred.ty.hir_fmt(f)?;\n+            }\n+            GenericPredicate::Error => {\n+                if angle_open {\n+                    // impl Trait<X, {error}>\n+                    write!(f, \", \")?;\n+                } else if !first {\n+                    // impl Trait + {error}\n+                    write!(f, \" + \")?;\n+                }\n+                p.hir_fmt(f)?;\n+            }\n+        }\n+        first = false;\n+    }\n+    if angle_open {\n+        write!(f, \">\")?;\n+    }\n+    Ok(())\n+}\n+\n impl TraitRef {\n     fn hir_fmt_ext(&self, f: &mut HirFormatter<impl HirDatabase>, use_as: bool) -> fmt::Result {\n         if f.should_truncate() {"}, {"sha": "c68c5852be77bba8828a4b93c737327d27cd3518", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 370, "deletions": 207, "changes": 577, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -10,12 +10,13 @@ use std::sync::Arc;\n \n use hir_def::{\n     builtin_type::BuiltinType,\n-    generics::WherePredicate,\n+    generics::{TypeParamProvenance, WherePredicate, WherePredicateTarget},\n     path::{GenericArg, Path, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TypeBound, TypeRef},\n     AdtId, ConstId, EnumId, EnumVariantId, FunctionId, GenericDefId, HasModule, ImplId,\n-    LocalStructFieldId, Lookup, StaticId, StructId, TraitId, TypeAliasId, UnionId, VariantId,\n+    LocalStructFieldId, Lookup, StaticId, StructId, TraitId, TypeAliasId, TypeParamId, UnionId,\n+    VariantId,\n };\n use ra_arena::map::ArenaMap;\n use ra_db::CrateId;\n@@ -27,63 +28,158 @@ use crate::{\n         all_super_traits, associated_type_by_name_including_super_traits, generics, make_mut_slice,\n         variant_data,\n     },\n-    FnSig, GenericPredicate, ProjectionPredicate, ProjectionTy, Substs, TraitEnvironment, TraitRef,\n-    Ty, TypeCtor, TypeWalk,\n+    Binders, FnSig, GenericPredicate, PolyFnSig, ProjectionPredicate, ProjectionTy, Substs,\n+    TraitEnvironment, TraitRef, Ty, TypeCtor,\n };\n \n+#[derive(Debug)]\n+pub struct TyLoweringContext<'a, DB: HirDatabase> {\n+    pub db: &'a DB,\n+    pub resolver: &'a Resolver,\n+    /// Note: Conceptually, it's thinkable that we could be in a location where\n+    /// some type params should be represented as placeholders, and others\n+    /// should be converted to variables. I think in practice, this isn't\n+    /// possible currently, so this should be fine for now.\n+    pub type_param_mode: TypeParamLoweringMode,\n+    pub impl_trait_mode: ImplTraitLoweringMode,\n+    pub impl_trait_counter: std::cell::Cell<u16>,\n+}\n+\n+impl<'a, DB: HirDatabase> TyLoweringContext<'a, DB> {\n+    pub fn new(db: &'a DB, resolver: &'a Resolver) -> Self {\n+        let impl_trait_counter = std::cell::Cell::new(0);\n+        let impl_trait_mode = ImplTraitLoweringMode::Disallowed;\n+        let type_param_mode = TypeParamLoweringMode::Placeholder;\n+        Self { db, resolver, impl_trait_mode, impl_trait_counter, type_param_mode }\n+    }\n+\n+    pub fn with_impl_trait_mode(self, impl_trait_mode: ImplTraitLoweringMode) -> Self {\n+        Self { impl_trait_mode, ..self }\n+    }\n+\n+    pub fn with_type_param_mode(self, type_param_mode: TypeParamLoweringMode) -> Self {\n+        Self { type_param_mode, ..self }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum ImplTraitLoweringMode {\n+    /// `impl Trait` gets lowered into an opaque type that doesn't unify with\n+    /// anything except itself. This is used in places where values flow 'out',\n+    /// i.e. for arguments of the function we're currently checking, and return\n+    /// types of functions we're calling.\n+    Opaque,\n+    /// `impl Trait` gets lowered into a type variable. Used for argument\n+    /// position impl Trait when inside the respective function, since it allows\n+    /// us to support that without Chalk.\n+    Param,\n+    /// `impl Trait` gets lowered into a variable that can unify with some\n+    /// type. This is used in places where values flow 'in', i.e. for arguments\n+    /// of functions we're calling, and the return type of the function we're\n+    /// currently checking.\n+    Variable,\n+    /// `impl Trait` is disallowed and will be an error.\n+    Disallowed,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum TypeParamLoweringMode {\n+    Placeholder,\n+    Variable,\n+}\n+\n impl Ty {\n-    pub fn from_hir(db: &impl HirDatabase, resolver: &Resolver, type_ref: &TypeRef) -> Self {\n+    pub fn from_hir(ctx: &TyLoweringContext<'_, impl HirDatabase>, type_ref: &TypeRef) -> Self {\n         match type_ref {\n             TypeRef::Never => Ty::simple(TypeCtor::Never),\n             TypeRef::Tuple(inner) => {\n-                let inner_tys: Arc<[Ty]> =\n-                    inner.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect();\n+                let inner_tys: Arc<[Ty]> = inner.iter().map(|tr| Ty::from_hir(ctx, tr)).collect();\n                 Ty::apply(\n                     TypeCtor::Tuple { cardinality: inner_tys.len() as u16 },\n                     Substs(inner_tys),\n                 )\n             }\n-            TypeRef::Path(path) => Ty::from_hir_path(db, resolver, path),\n+            TypeRef::Path(path) => Ty::from_hir_path(ctx, path),\n             TypeRef::RawPtr(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, resolver, inner);\n+                let inner_ty = Ty::from_hir(ctx, inner);\n                 Ty::apply_one(TypeCtor::RawPtr(*mutability), inner_ty)\n             }\n             TypeRef::Array(inner) => {\n-                let inner_ty = Ty::from_hir(db, resolver, inner);\n+                let inner_ty = Ty::from_hir(ctx, inner);\n                 Ty::apply_one(TypeCtor::Array, inner_ty)\n             }\n             TypeRef::Slice(inner) => {\n-                let inner_ty = Ty::from_hir(db, resolver, inner);\n+                let inner_ty = Ty::from_hir(ctx, inner);\n                 Ty::apply_one(TypeCtor::Slice, inner_ty)\n             }\n             TypeRef::Reference(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, resolver, inner);\n+                let inner_ty = Ty::from_hir(ctx, inner);\n                 Ty::apply_one(TypeCtor::Ref(*mutability), inner_ty)\n             }\n             TypeRef::Placeholder => Ty::Unknown,\n             TypeRef::Fn(params) => {\n-                let sig = Substs(params.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect());\n+                let sig = Substs(params.iter().map(|tr| Ty::from_hir(ctx, tr)).collect());\n                 Ty::apply(TypeCtor::FnPtr { num_args: sig.len() as u16 - 1 }, sig)\n             }\n             TypeRef::DynTrait(bounds) => {\n                 let self_ty = Ty::Bound(0);\n                 let predicates = bounds\n                     .iter()\n-                    .flat_map(|b| {\n-                        GenericPredicate::from_type_bound(db, resolver, b, self_ty.clone())\n-                    })\n+                    .flat_map(|b| GenericPredicate::from_type_bound(ctx, b, self_ty.clone()))\n                     .collect();\n                 Ty::Dyn(predicates)\n             }\n             TypeRef::ImplTrait(bounds) => {\n-                let self_ty = Ty::Bound(0);\n-                let predicates = bounds\n-                    .iter()\n-                    .flat_map(|b| {\n-                        GenericPredicate::from_type_bound(db, resolver, b, self_ty.clone())\n-                    })\n-                    .collect();\n-                Ty::Opaque(predicates)\n+                match ctx.impl_trait_mode {\n+                    ImplTraitLoweringMode::Opaque => {\n+                        let self_ty = Ty::Bound(0);\n+                        let predicates = bounds\n+                            .iter()\n+                            .flat_map(|b| {\n+                                GenericPredicate::from_type_bound(ctx, b, self_ty.clone())\n+                            })\n+                            .collect();\n+                        Ty::Opaque(predicates)\n+                    }\n+                    ImplTraitLoweringMode::Param => {\n+                        let idx = ctx.impl_trait_counter.get();\n+                        ctx.impl_trait_counter.set(idx + 1);\n+                        if let Some(def) = ctx.resolver.generic_def() {\n+                            let generics = generics(ctx.db, def);\n+                            let param = generics\n+                                .iter()\n+                                .filter(|(_, data)| {\n+                                    data.provenance == TypeParamProvenance::ArgumentImplTrait\n+                                })\n+                                .nth(idx as usize)\n+                                .map_or(Ty::Unknown, |(id, _)| Ty::Param(id));\n+                            param\n+                        } else {\n+                            Ty::Unknown\n+                        }\n+                    }\n+                    ImplTraitLoweringMode::Variable => {\n+                        let idx = ctx.impl_trait_counter.get();\n+                        ctx.impl_trait_counter.set(idx + 1);\n+                        let (parent_params, self_params, list_params, _impl_trait_params) =\n+                            if let Some(def) = ctx.resolver.generic_def() {\n+                                let generics = generics(ctx.db, def);\n+                                generics.provenance_split()\n+                            } else {\n+                                (0, 0, 0, 0)\n+                            };\n+                        Ty::Bound(\n+                            idx as u32\n+                                + parent_params as u32\n+                                + self_params as u32\n+                                + list_params as u32,\n+                        )\n+                    }\n+                    ImplTraitLoweringMode::Disallowed => {\n+                        // FIXME: report error\n+                        Ty::Unknown\n+                    }\n+                }\n             }\n             TypeRef::Error => Ty::Unknown,\n         }\n@@ -93,10 +189,9 @@ impl Ty {\n     /// lower the self types of the predicates since that could lead to cycles.\n     /// So we just check here if the `type_ref` resolves to a generic param, and which.\n     fn from_hir_only_param(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         type_ref: &TypeRef,\n-    ) -> Option<u32> {\n+    ) -> Option<TypeParamId> {\n         let path = match type_ref {\n             TypeRef::Path(path) => path,\n             _ => return None,\n@@ -107,29 +202,26 @@ impl Ty {\n         if path.segments().len() > 1 {\n             return None;\n         }\n-        let resolution = match resolver.resolve_path_in_type_ns(db, path.mod_path()) {\n+        let resolution = match ctx.resolver.resolve_path_in_type_ns(ctx.db, path.mod_path()) {\n             Some((it, None)) => it,\n             _ => return None,\n         };\n         if let TypeNs::GenericParam(param_id) = resolution {\n-            let generics = generics(db, resolver.generic_def().expect(\"generics in scope\"));\n-            let idx = generics.param_idx(param_id);\n-            Some(idx)\n+            Some(param_id)\n         } else {\n             None\n         }\n     }\n \n     pub(crate) fn from_type_relative_path(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         ty: Ty,\n         remaining_segments: PathSegments<'_>,\n     ) -> Ty {\n         if remaining_segments.len() == 1 {\n             // resolve unselected assoc types\n             let segment = remaining_segments.first().unwrap();\n-            Ty::select_associated_type(db, resolver, ty, segment)\n+            Ty::select_associated_type(ctx, ty, segment)\n         } else if remaining_segments.len() > 1 {\n             // FIXME report error (ambiguous associated type)\n             Ty::Unknown\n@@ -139,20 +231,18 @@ impl Ty {\n     }\n \n     pub(crate) fn from_partly_resolved_hir_path(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         resolution: TypeNs,\n         resolved_segment: PathSegment<'_>,\n         remaining_segments: PathSegments<'_>,\n     ) -> Ty {\n         let ty = match resolution {\n             TypeNs::TraitId(trait_) => {\n-                let trait_ref =\n-                    TraitRef::from_resolved_path(db, resolver, trait_, resolved_segment, None);\n+                let trait_ref = TraitRef::from_resolved_path(ctx, trait_, resolved_segment, None);\n                 return if remaining_segments.len() == 1 {\n                     let segment = remaining_segments.first().unwrap();\n                     let associated_ty = associated_type_by_name_including_super_traits(\n-                        db,\n+                        ctx.db,\n                         trait_ref.trait_,\n                         &segment.name,\n                     );\n@@ -177,37 +267,55 @@ impl Ty {\n                 };\n             }\n             TypeNs::GenericParam(param_id) => {\n-                let generics = generics(db, resolver.generic_def().expect(\"generics in scope\"));\n-                let idx = generics.param_idx(param_id);\n-                // FIXME: maybe return name in resolution?\n-                let name = generics.param_name(param_id);\n-                Ty::Param { idx, name }\n+                let generics =\n+                    generics(ctx.db, ctx.resolver.generic_def().expect(\"generics in scope\"));\n+                match ctx.type_param_mode {\n+                    TypeParamLoweringMode::Placeholder => Ty::Param(param_id),\n+                    TypeParamLoweringMode::Variable => {\n+                        let idx = generics.param_idx(param_id).expect(\"matching generics\");\n+                        Ty::Bound(idx)\n+                    }\n+                }\n             }\n-            TypeNs::SelfType(impl_id) => db.impl_self_ty(impl_id).clone(),\n-            TypeNs::AdtSelfType(adt) => db.ty(adt.into()),\n-\n-            TypeNs::AdtId(it) => Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into()),\n-            TypeNs::BuiltinType(it) => {\n-                Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into())\n+            TypeNs::SelfType(impl_id) => {\n+                let generics = generics(ctx.db, impl_id.into());\n+                let substs = match ctx.type_param_mode {\n+                    TypeParamLoweringMode::Placeholder => {\n+                        Substs::type_params_for_generics(&generics)\n+                    }\n+                    TypeParamLoweringMode::Variable => Substs::bound_vars(&generics),\n+                };\n+                ctx.db.impl_self_ty(impl_id).subst(&substs)\n             }\n-            TypeNs::TypeAliasId(it) => {\n-                Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into())\n+            TypeNs::AdtSelfType(adt) => {\n+                let generics = generics(ctx.db, adt.into());\n+                let substs = match ctx.type_param_mode {\n+                    TypeParamLoweringMode::Placeholder => {\n+                        Substs::type_params_for_generics(&generics)\n+                    }\n+                    TypeParamLoweringMode::Variable => Substs::bound_vars(&generics),\n+                };\n+                ctx.db.ty(adt.into()).subst(&substs)\n             }\n+\n+            TypeNs::AdtId(it) => Ty::from_hir_path_inner(ctx, resolved_segment, it.into()),\n+            TypeNs::BuiltinType(it) => Ty::from_hir_path_inner(ctx, resolved_segment, it.into()),\n+            TypeNs::TypeAliasId(it) => Ty::from_hir_path_inner(ctx, resolved_segment, it.into()),\n             // FIXME: report error\n             TypeNs::EnumVariantId(_) => return Ty::Unknown,\n         };\n \n-        Ty::from_type_relative_path(db, resolver, ty, remaining_segments)\n+        Ty::from_type_relative_path(ctx, ty, remaining_segments)\n     }\n \n-    pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Ty {\n+    pub(crate) fn from_hir_path(ctx: &TyLoweringContext<'_, impl HirDatabase>, path: &Path) -> Ty {\n         // Resolve the path (in type namespace)\n         if let Some(type_ref) = path.type_anchor() {\n-            let ty = Ty::from_hir(db, resolver, &type_ref);\n-            return Ty::from_type_relative_path(db, resolver, ty, path.segments());\n+            let ty = Ty::from_hir(ctx, &type_ref);\n+            return Ty::from_type_relative_path(ctx, ty, path.segments());\n         }\n         let (resolution, remaining_index) =\n-            match resolver.resolve_path_in_type_ns(db, path.mod_path()) {\n+            match ctx.resolver.resolve_path_in_type_ns(ctx.db, path.mod_path()) {\n                 Some(it) => it,\n                 None => return Ty::Unknown,\n             };\n@@ -218,39 +326,44 @@ impl Ty {\n             ),\n             Some(i) => (path.segments().get(i - 1).unwrap(), path.segments().skip(i)),\n         };\n-        Ty::from_partly_resolved_hir_path(\n-            db,\n-            resolver,\n-            resolution,\n-            resolved_segment,\n-            remaining_segments,\n-        )\n+        Ty::from_partly_resolved_hir_path(ctx, resolution, resolved_segment, remaining_segments)\n     }\n \n     fn select_associated_type(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         self_ty: Ty,\n         segment: PathSegment<'_>,\n     ) -> Ty {\n-        let param_idx = match self_ty {\n-            Ty::Param { idx, .. } => idx,\n-            _ => return Ty::Unknown, // Error: Ambiguous associated type\n-        };\n-        let def = match resolver.generic_def() {\n+        let def = match ctx.resolver.generic_def() {\n             Some(def) => def,\n             None => return Ty::Unknown, // this can't actually happen\n         };\n-        let predicates = db.generic_predicates_for_param(def.into(), param_idx);\n-        let traits_from_env = predicates.iter().filter_map(|pred| match pred {\n-            GenericPredicate::Implemented(tr) if tr.self_ty() == &self_ty => Some(tr.trait_),\n+        let param_id = match self_ty {\n+            Ty::Param(id) if ctx.type_param_mode == TypeParamLoweringMode::Placeholder => id,\n+            Ty::Bound(idx) if ctx.type_param_mode == TypeParamLoweringMode::Variable => {\n+                let generics = generics(ctx.db, def);\n+                let param_id = if let Some((id, _)) = generics.iter().nth(idx as usize) {\n+                    id\n+                } else {\n+                    return Ty::Unknown;\n+                };\n+                param_id\n+            }\n+            _ => return Ty::Unknown, // Error: Ambiguous associated type\n+        };\n+        let predicates = ctx.db.generic_predicates_for_param(param_id);\n+        let traits_from_env = predicates.iter().filter_map(|pred| match &pred.value {\n+            GenericPredicate::Implemented(tr) => Some(tr.trait_),\n             _ => None,\n         });\n-        let traits = traits_from_env.flat_map(|t| all_super_traits(db, t));\n+        let traits = traits_from_env.flat_map(|t| all_super_traits(ctx.db, t));\n         for t in traits {\n-            if let Some(associated_ty) = db.trait_data(t).associated_type_by_name(&segment.name) {\n-                let substs =\n-                    Substs::build_for_def(db, t).push(self_ty.clone()).fill_with_unknown().build();\n+            if let Some(associated_ty) = ctx.db.trait_data(t).associated_type_by_name(&segment.name)\n+            {\n+                let substs = Substs::build_for_def(ctx.db, t)\n+                    .push(self_ty.clone())\n+                    .fill_with_unknown()\n+                    .build();\n                 // FIXME handle type parameters on the segment\n                 return Ty::Projection(ProjectionTy { associated_ty, parameters: substs });\n             }\n@@ -259,8 +372,7 @@ impl Ty {\n     }\n \n     fn from_hir_path_inner(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         segment: PathSegment<'_>,\n         typable: TyDefId,\n     ) -> Ty {\n@@ -269,15 +381,14 @@ impl Ty {\n             TyDefId::AdtId(it) => Some(it.into()),\n             TyDefId::TypeAliasId(it) => Some(it.into()),\n         };\n-        let substs = substs_from_path_segment(db, resolver, segment, generic_def, false);\n-        db.ty(typable).subst(&substs)\n+        let substs = substs_from_path_segment(ctx, segment, generic_def, false);\n+        ctx.db.ty(typable).subst(&substs)\n     }\n \n     /// Collect generic arguments from a path into a `Substs`. See also\n     /// `create_substs_for_ast_path` and `def_to_ty` in rustc.\n     pub(super) fn substs_from_path(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         path: &Path,\n         // Note that we don't call `db.value_type(resolved)` here,\n         // `ValueTyDefId` is just a convenient way to pass generics and\n@@ -305,52 +416,49 @@ impl Ty {\n                 (segment, Some(var.parent.into()))\n             }\n         };\n-        substs_from_path_segment(db, resolver, segment, generic_def, false)\n+        substs_from_path_segment(ctx, segment, generic_def, false)\n     }\n }\n \n pub(super) fn substs_from_path_segment(\n-    db: &impl HirDatabase,\n-    resolver: &Resolver,\n+    ctx: &TyLoweringContext<'_, impl HirDatabase>,\n     segment: PathSegment<'_>,\n     def_generic: Option<GenericDefId>,\n-    add_self_param: bool,\n+    _add_self_param: bool,\n ) -> Substs {\n     let mut substs = Vec::new();\n-    let def_generics = def_generic.map(|def| generics(db, def.into()));\n-\n-    let (total_len, parent_len, child_len) = def_generics.map_or((0, 0, 0), |g| g.len_split());\n-    substs.extend(iter::repeat(Ty::Unknown).take(parent_len));\n-    if add_self_param {\n-        // FIXME this add_self_param argument is kind of a hack: Traits have the\n-        // Self type as an implicit first type parameter, but it can't be\n-        // actually provided in the type arguments\n-        // (well, actually sometimes it can, in the form of type-relative paths: `<Foo as Default>::default()`)\n-        substs.push(Ty::Unknown);\n-    }\n+    let def_generics = def_generic.map(|def| generics(ctx.db, def.into()));\n+\n+    let (parent_params, self_params, type_params, impl_trait_params) =\n+        def_generics.map_or((0, 0, 0, 0), |g| g.provenance_split());\n+    substs.extend(iter::repeat(Ty::Unknown).take(parent_params));\n     if let Some(generic_args) = &segment.args_and_bindings {\n+        if !generic_args.has_self_type {\n+            substs.extend(iter::repeat(Ty::Unknown).take(self_params));\n+        }\n+        let expected_num =\n+            if generic_args.has_self_type { self_params + type_params } else { type_params };\n+        let skip = if generic_args.has_self_type && self_params == 0 { 1 } else { 0 };\n         // if args are provided, it should be all of them, but we can't rely on that\n-        let self_param_correction = if add_self_param { 1 } else { 0 };\n-        let child_len = child_len - self_param_correction;\n-        for arg in generic_args.args.iter().take(child_len) {\n+        for arg in generic_args.args.iter().skip(skip).take(expected_num) {\n             match arg {\n                 GenericArg::Type(type_ref) => {\n-                    let ty = Ty::from_hir(db, resolver, type_ref);\n+                    let ty = Ty::from_hir(ctx, type_ref);\n                     substs.push(ty);\n                 }\n             }\n         }\n     }\n+    let total_len = parent_params + self_params + type_params + impl_trait_params;\n     // add placeholders for args that were not provided\n-    let supplied_params = substs.len();\n-    for _ in supplied_params..total_len {\n+    for _ in substs.len()..total_len {\n         substs.push(Ty::Unknown);\n     }\n     assert_eq!(substs.len(), total_len);\n \n     // handle defaults\n     if let Some(def_generic) = def_generic {\n-        let default_substs = db.generic_defaults(def_generic.into());\n+        let default_substs = ctx.db.generic_defaults(def_generic.into());\n         assert_eq!(substs.len(), default_substs.len());\n \n         for (i, default_ty) in default_substs.iter().enumerate() {\n@@ -365,99 +473,105 @@ pub(super) fn substs_from_path_segment(\n \n impl TraitRef {\n     fn from_path(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         path: &Path,\n         explicit_self_ty: Option<Ty>,\n     ) -> Option<Self> {\n-        let resolved = match resolver.resolve_path_in_type_ns_fully(db, path.mod_path())? {\n+        let resolved = match ctx.resolver.resolve_path_in_type_ns_fully(ctx.db, path.mod_path())? {\n             TypeNs::TraitId(tr) => tr,\n             _ => return None,\n         };\n         let segment = path.segments().last().expect(\"path should have at least one segment\");\n-        Some(TraitRef::from_resolved_path(db, resolver, resolved.into(), segment, explicit_self_ty))\n+        Some(TraitRef::from_resolved_path(ctx, resolved.into(), segment, explicit_self_ty))\n     }\n \n     pub(crate) fn from_resolved_path(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         resolved: TraitId,\n         segment: PathSegment<'_>,\n         explicit_self_ty: Option<Ty>,\n     ) -> Self {\n-        let mut substs = TraitRef::substs_from_path(db, resolver, segment, resolved);\n+        let mut substs = TraitRef::substs_from_path(ctx, segment, resolved);\n         if let Some(self_ty) = explicit_self_ty {\n             make_mut_slice(&mut substs.0)[0] = self_ty;\n         }\n         TraitRef { trait_: resolved, substs }\n     }\n \n     fn from_hir(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         type_ref: &TypeRef,\n         explicit_self_ty: Option<Ty>,\n     ) -> Option<Self> {\n         let path = match type_ref {\n             TypeRef::Path(path) => path,\n             _ => return None,\n         };\n-        TraitRef::from_path(db, resolver, path, explicit_self_ty)\n+        TraitRef::from_path(ctx, path, explicit_self_ty)\n     }\n \n     fn substs_from_path(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         segment: PathSegment<'_>,\n         resolved: TraitId,\n     ) -> Substs {\n         let has_self_param =\n             segment.args_and_bindings.as_ref().map(|a| a.has_self_type).unwrap_or(false);\n-        substs_from_path_segment(db, resolver, segment, Some(resolved.into()), !has_self_param)\n+        substs_from_path_segment(ctx, segment, Some(resolved.into()), !has_self_param)\n     }\n \n     pub(crate) fn from_type_bound(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         bound: &TypeBound,\n         self_ty: Ty,\n     ) -> Option<TraitRef> {\n         match bound {\n-            TypeBound::Path(path) => TraitRef::from_path(db, resolver, path, Some(self_ty)),\n+            TypeBound::Path(path) => TraitRef::from_path(ctx, path, Some(self_ty)),\n             TypeBound::Error => None,\n         }\n     }\n }\n \n impl GenericPredicate {\n     pub(crate) fn from_where_predicate<'a>(\n-        db: &'a impl HirDatabase,\n-        resolver: &'a Resolver,\n+        ctx: &'a TyLoweringContext<'a, impl HirDatabase>,\n         where_predicate: &'a WherePredicate,\n     ) -> impl Iterator<Item = GenericPredicate> + 'a {\n-        let self_ty = Ty::from_hir(db, resolver, &where_predicate.type_ref);\n-        GenericPredicate::from_type_bound(db, resolver, &where_predicate.bound, self_ty)\n+        let self_ty = match &where_predicate.target {\n+            WherePredicateTarget::TypeRef(type_ref) => Ty::from_hir(ctx, type_ref),\n+            WherePredicateTarget::TypeParam(param_id) => {\n+                let generic_def = ctx.resolver.generic_def().expect(\"generics in scope\");\n+                let generics = generics(ctx.db, generic_def);\n+                let param_id = hir_def::TypeParamId { parent: generic_def, local_id: *param_id };\n+                match ctx.type_param_mode {\n+                    TypeParamLoweringMode::Placeholder => Ty::Param(param_id),\n+                    TypeParamLoweringMode::Variable => {\n+                        let idx = generics.param_idx(param_id).expect(\"matching generics\");\n+                        Ty::Bound(idx)\n+                    }\n+                }\n+            }\n+        };\n+        GenericPredicate::from_type_bound(ctx, &where_predicate.bound, self_ty)\n     }\n \n     pub(crate) fn from_type_bound<'a>(\n-        db: &'a impl HirDatabase,\n-        resolver: &'a Resolver,\n+        ctx: &'a TyLoweringContext<'a, impl HirDatabase>,\n         bound: &'a TypeBound,\n         self_ty: Ty,\n     ) -> impl Iterator<Item = GenericPredicate> + 'a {\n-        let trait_ref = TraitRef::from_type_bound(db, &resolver, bound, self_ty);\n+        let trait_ref = TraitRef::from_type_bound(ctx, bound, self_ty);\n         iter::once(trait_ref.clone().map_or(GenericPredicate::Error, GenericPredicate::Implemented))\n             .chain(\n-                trait_ref.into_iter().flat_map(move |tr| {\n-                    assoc_type_bindings_from_type_bound(db, resolver, bound, tr)\n-                }),\n+                trait_ref\n+                    .into_iter()\n+                    .flat_map(move |tr| assoc_type_bindings_from_type_bound(ctx, bound, tr)),\n             )\n     }\n }\n \n fn assoc_type_bindings_from_type_bound<'a>(\n-    db: &'a impl HirDatabase,\n-    resolver: &'a Resolver,\n+    ctx: &'a TyLoweringContext<'a, impl HirDatabase>,\n     bound: &'a TypeBound,\n     trait_ref: TraitRef,\n ) -> impl Iterator<Item = GenericPredicate> + 'a {\n@@ -471,21 +585,21 @@ fn assoc_type_bindings_from_type_bound<'a>(\n         .flat_map(|args_and_bindings| args_and_bindings.bindings.iter())\n         .map(move |(name, type_ref)| {\n             let associated_ty =\n-                associated_type_by_name_including_super_traits(db, trait_ref.trait_, &name);\n+                associated_type_by_name_including_super_traits(ctx.db, trait_ref.trait_, &name);\n             let associated_ty = match associated_ty {\n                 None => return GenericPredicate::Error,\n                 Some(t) => t,\n             };\n             let projection_ty =\n                 ProjectionTy { associated_ty, parameters: trait_ref.substs.clone() };\n-            let ty = Ty::from_hir(db, resolver, type_ref);\n+            let ty = Ty::from_hir(ctx, type_ref);\n             let projection_predicate = ProjectionPredicate { projection_ty, ty };\n             GenericPredicate::Projection(projection_predicate)\n         })\n }\n \n /// Build the signature of a callable item (function, struct or enum variant).\n-pub fn callable_item_sig(db: &impl HirDatabase, def: CallableDef) -> FnSig {\n+pub fn callable_item_sig(db: &impl HirDatabase, def: CallableDef) -> PolyFnSig {\n     match def {\n         CallableDef::FunctionId(f) => fn_sig_for_fn(db, f),\n         CallableDef::StructId(s) => fn_sig_for_struct_constructor(db, s),\n@@ -497,16 +611,19 @@ pub fn callable_item_sig(db: &impl HirDatabase, def: CallableDef) -> FnSig {\n pub(crate) fn field_types_query(\n     db: &impl HirDatabase,\n     variant_id: VariantId,\n-) -> Arc<ArenaMap<LocalStructFieldId, Ty>> {\n+) -> Arc<ArenaMap<LocalStructFieldId, Binders<Ty>>> {\n     let var_data = variant_data(db, variant_id);\n-    let resolver = match variant_id {\n-        VariantId::StructId(it) => it.resolver(db),\n-        VariantId::UnionId(it) => it.resolver(db),\n-        VariantId::EnumVariantId(it) => it.parent.resolver(db),\n+    let (resolver, def): (_, GenericDefId) = match variant_id {\n+        VariantId::StructId(it) => (it.resolver(db), it.into()),\n+        VariantId::UnionId(it) => (it.resolver(db), it.into()),\n+        VariantId::EnumVariantId(it) => (it.parent.resolver(db), it.parent.into()),\n     };\n+    let generics = generics(db, def);\n     let mut res = ArenaMap::default();\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     for (field_id, field_data) in var_data.fields().iter() {\n-        res.insert(field_id, Ty::from_hir(db, &resolver, &field_data.type_ref))\n+        res.insert(field_id, Binders::new(generics.len(), Ty::from_hir(&ctx, &field_data.type_ref)))\n     }\n     Arc::new(res)\n }\n@@ -521,32 +638,43 @@ pub(crate) fn field_types_query(\n /// these are fine: `T: Foo<U::Item>, U: Foo<()>`.\n pub(crate) fn generic_predicates_for_param_query(\n     db: &impl HirDatabase,\n-    def: GenericDefId,\n-    param_idx: u32,\n-) -> Arc<[GenericPredicate]> {\n-    let resolver = def.resolver(db);\n+    param_id: TypeParamId,\n+) -> Arc<[Binders<GenericPredicate>]> {\n+    let resolver = param_id.parent.resolver(db);\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n+    let generics = generics(db, param_id.parent);\n     resolver\n         .where_predicates_in_scope()\n         // we have to filter out all other predicates *first*, before attempting to lower them\n-        .filter(|pred| Ty::from_hir_only_param(db, &resolver, &pred.type_ref) == Some(param_idx))\n-        .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n+        .filter(|pred| match &pred.target {\n+            WherePredicateTarget::TypeRef(type_ref) => {\n+                Ty::from_hir_only_param(&ctx, type_ref) == Some(param_id)\n+            }\n+            WherePredicateTarget::TypeParam(local_id) => *local_id == param_id.local_id,\n+        })\n+        .flat_map(|pred| {\n+            GenericPredicate::from_where_predicate(&ctx, pred)\n+                .map(|p| Binders::new(generics.len(), p))\n+        })\n         .collect()\n }\n \n pub(crate) fn generic_predicates_for_param_recover(\n     _db: &impl HirDatabase,\n     _cycle: &[String],\n-    _def: &GenericDefId,\n-    _param_idx: &u32,\n-) -> Arc<[GenericPredicate]> {\n+    _param_id: &TypeParamId,\n+) -> Arc<[Binders<GenericPredicate>]> {\n     Arc::new([])\n }\n \n impl TraitEnvironment {\n     pub fn lower(db: &impl HirDatabase, resolver: &Resolver) -> Arc<TraitEnvironment> {\n+        let ctx = TyLoweringContext::new(db, &resolver)\n+            .with_type_param_mode(TypeParamLoweringMode::Placeholder);\n         let predicates = resolver\n             .where_predicates_in_scope()\n-            .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n+            .flat_map(|pred| GenericPredicate::from_where_predicate(&ctx, pred))\n             .collect::<Vec<_>>();\n \n         Arc::new(TraitEnvironment { predicates })\n@@ -557,57 +685,74 @@ impl TraitEnvironment {\n pub(crate) fn generic_predicates_query(\n     db: &impl HirDatabase,\n     def: GenericDefId,\n-) -> Arc<[GenericPredicate]> {\n+) -> Arc<[Binders<GenericPredicate>]> {\n     let resolver = def.resolver(db);\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n+    let generics = generics(db, def);\n     resolver\n         .where_predicates_in_scope()\n-        .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n+        .flat_map(|pred| {\n+            GenericPredicate::from_where_predicate(&ctx, pred)\n+                .map(|p| Binders::new(generics.len(), p))\n+        })\n         .collect()\n }\n \n /// Resolve the default type params from generics\n pub(crate) fn generic_defaults_query(db: &impl HirDatabase, def: GenericDefId) -> Substs {\n     let resolver = def.resolver(db);\n+    let ctx = TyLoweringContext::new(db, &resolver);\n     let generic_params = generics(db, def.into());\n \n     let defaults = generic_params\n         .iter()\n-        .map(|(_idx, p)| p.default.as_ref().map_or(Ty::Unknown, |t| Ty::from_hir(db, &resolver, t)))\n+        .map(|(_idx, p)| p.default.as_ref().map_or(Ty::Unknown, |t| Ty::from_hir(&ctx, t)))\n         .collect();\n \n     Substs(defaults)\n }\n \n-fn fn_sig_for_fn(db: &impl HirDatabase, def: FunctionId) -> FnSig {\n+fn fn_sig_for_fn(db: &impl HirDatabase, def: FunctionId) -> PolyFnSig {\n     let data = db.function_data(def);\n     let resolver = def.resolver(db);\n-    let params = data.params.iter().map(|tr| Ty::from_hir(db, &resolver, tr)).collect::<Vec<_>>();\n-    let ret = Ty::from_hir(db, &resolver, &data.ret_type);\n-    FnSig::from_params_and_return(params, ret)\n+    let ctx_params = TyLoweringContext::new(db, &resolver)\n+        .with_impl_trait_mode(ImplTraitLoweringMode::Variable)\n+        .with_type_param_mode(TypeParamLoweringMode::Variable);\n+    let params = data.params.iter().map(|tr| Ty::from_hir(&ctx_params, tr)).collect::<Vec<_>>();\n+    let ctx_ret = ctx_params.with_impl_trait_mode(ImplTraitLoweringMode::Opaque);\n+    let ret = Ty::from_hir(&ctx_ret, &data.ret_type);\n+    let generics = generics(db, def.into());\n+    let num_binders = generics.len();\n+    Binders::new(num_binders, FnSig::from_params_and_return(params, ret))\n }\n \n /// Build the declared type of a function. This should not need to look at the\n /// function body.\n-fn type_for_fn(db: &impl HirDatabase, def: FunctionId) -> Ty {\n+fn type_for_fn(db: &impl HirDatabase, def: FunctionId) -> Binders<Ty> {\n     let generics = generics(db, def.into());\n-    let substs = Substs::identity(&generics);\n-    Ty::apply(TypeCtor::FnDef(def.into()), substs)\n+    let substs = Substs::bound_vars(&generics);\n+    Binders::new(substs.len(), Ty::apply(TypeCtor::FnDef(def.into()), substs))\n }\n \n /// Build the declared type of a const.\n-fn type_for_const(db: &impl HirDatabase, def: ConstId) -> Ty {\n+fn type_for_const(db: &impl HirDatabase, def: ConstId) -> Binders<Ty> {\n     let data = db.const_data(def);\n+    let generics = generics(db, def.into());\n     let resolver = def.resolver(db);\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n \n-    Ty::from_hir(db, &resolver, &data.type_ref)\n+    Binders::new(generics.len(), Ty::from_hir(&ctx, &data.type_ref))\n }\n \n /// Build the declared type of a static.\n-fn type_for_static(db: &impl HirDatabase, def: StaticId) -> Ty {\n+fn type_for_static(db: &impl HirDatabase, def: StaticId) -> Binders<Ty> {\n     let data = db.static_data(def);\n     let resolver = def.resolver(db);\n+    let ctx = TyLoweringContext::new(db, &resolver);\n \n-    Ty::from_hir(db, &resolver, &data.type_ref)\n+    Binders::new(0, Ty::from_hir(&ctx, &data.type_ref))\n }\n \n /// Build the declared type of a static.\n@@ -621,68 +766,69 @@ fn type_for_builtin(def: BuiltinType) -> Ty {\n     })\n }\n \n-fn fn_sig_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> FnSig {\n+fn fn_sig_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> PolyFnSig {\n     let struct_data = db.struct_data(def.into());\n     let fields = struct_data.variant_data.fields();\n     let resolver = def.resolver(db);\n-    let params = fields\n-        .iter()\n-        .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n-        .collect::<Vec<_>>();\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n+    let params =\n+        fields.iter().map(|(_, field)| Ty::from_hir(&ctx, &field.type_ref)).collect::<Vec<_>>();\n     let ret = type_for_adt(db, def.into());\n-    FnSig::from_params_and_return(params, ret)\n+    Binders::new(ret.num_binders, FnSig::from_params_and_return(params, ret.value))\n }\n \n /// Build the type of a tuple struct constructor.\n-fn type_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> Ty {\n+fn type_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> Binders<Ty> {\n     let struct_data = db.struct_data(def.into());\n     if struct_data.variant_data.is_unit() {\n         return type_for_adt(db, def.into()); // Unit struct\n     }\n     let generics = generics(db, def.into());\n-    let substs = Substs::identity(&generics);\n-    Ty::apply(TypeCtor::FnDef(def.into()), substs)\n+    let substs = Substs::bound_vars(&generics);\n+    Binders::new(substs.len(), Ty::apply(TypeCtor::FnDef(def.into()), substs))\n }\n \n-fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId) -> FnSig {\n+fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId) -> PolyFnSig {\n     let enum_data = db.enum_data(def.parent);\n     let var_data = &enum_data.variants[def.local_id];\n     let fields = var_data.variant_data.fields();\n     let resolver = def.parent.resolver(db);\n-    let params = fields\n-        .iter()\n-        .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n-        .collect::<Vec<_>>();\n-    let generics = generics(db, def.parent.into());\n-    let substs = Substs::identity(&generics);\n-    let ret = type_for_adt(db, def.parent.into()).subst(&substs);\n-    FnSig::from_params_and_return(params, ret)\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n+    let params =\n+        fields.iter().map(|(_, field)| Ty::from_hir(&ctx, &field.type_ref)).collect::<Vec<_>>();\n+    let ret = type_for_adt(db, def.parent.into());\n+    Binders::new(ret.num_binders, FnSig::from_params_and_return(params, ret.value))\n }\n \n /// Build the type of a tuple enum variant constructor.\n-fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId) -> Ty {\n+fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId) -> Binders<Ty> {\n     let enum_data = db.enum_data(def.parent);\n     let var_data = &enum_data.variants[def.local_id].variant_data;\n     if var_data.is_unit() {\n         return type_for_adt(db, def.parent.into()); // Unit variant\n     }\n     let generics = generics(db, def.parent.into());\n-    let substs = Substs::identity(&generics);\n-    Ty::apply(TypeCtor::FnDef(EnumVariantId::from(def).into()), substs)\n+    let substs = Substs::bound_vars(&generics);\n+    Binders::new(substs.len(), Ty::apply(TypeCtor::FnDef(EnumVariantId::from(def).into()), substs))\n }\n \n-fn type_for_adt(db: &impl HirDatabase, adt: AdtId) -> Ty {\n+fn type_for_adt(db: &impl HirDatabase, adt: AdtId) -> Binders<Ty> {\n     let generics = generics(db, adt.into());\n-    Ty::apply(TypeCtor::Adt(adt), Substs::identity(&generics))\n+    let substs = Substs::bound_vars(&generics);\n+    Binders::new(substs.len(), Ty::apply(TypeCtor::Adt(adt), substs))\n }\n \n-fn type_for_type_alias(db: &impl HirDatabase, t: TypeAliasId) -> Ty {\n+fn type_for_type_alias(db: &impl HirDatabase, t: TypeAliasId) -> Binders<Ty> {\n     let generics = generics(db, t.into());\n     let resolver = t.resolver(db);\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     let type_ref = &db.type_alias_data(t).type_ref;\n-    let substs = Substs::identity(&generics);\n-    let inner = Ty::from_hir(db, &resolver, type_ref.as_ref().unwrap_or(&TypeRef::Error));\n-    inner.subst(&substs)\n+    let substs = Substs::bound_vars(&generics);\n+    let inner = Ty::from_hir(&ctx, type_ref.as_ref().unwrap_or(&TypeRef::Error));\n+    Binders::new(substs.len(), inner)\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n@@ -736,19 +882,24 @@ impl_froms!(ValueTyDefId: FunctionId, StructId, EnumVariantId, ConstId, StaticId\n /// `struct Foo(usize)`, we have two types: The type of the struct itself, and\n /// the constructor function `(usize) -> Foo` which lives in the values\n /// namespace.\n-pub(crate) fn ty_query(db: &impl HirDatabase, def: TyDefId) -> Ty {\n+pub(crate) fn ty_query(db: &impl HirDatabase, def: TyDefId) -> Binders<Ty> {\n     match def {\n-        TyDefId::BuiltinType(it) => type_for_builtin(it),\n+        TyDefId::BuiltinType(it) => Binders::new(0, type_for_builtin(it)),\n         TyDefId::AdtId(it) => type_for_adt(db, it),\n         TyDefId::TypeAliasId(it) => type_for_type_alias(db, it),\n     }\n }\n \n-pub(crate) fn ty_recover(_db: &impl HirDatabase, _cycle: &[String], _def: &TyDefId) -> Ty {\n-    Ty::Unknown\n+pub(crate) fn ty_recover(db: &impl HirDatabase, _cycle: &[String], def: &TyDefId) -> Binders<Ty> {\n+    let num_binders = match *def {\n+        TyDefId::BuiltinType(_) => 0,\n+        TyDefId::AdtId(it) => generics(db, it.into()).len(),\n+        TyDefId::TypeAliasId(it) => generics(db, it.into()).len(),\n+    };\n+    Binders::new(num_binders, Ty::Unknown)\n }\n \n-pub(crate) fn value_ty_query(db: &impl HirDatabase, def: ValueTyDefId) -> Ty {\n+pub(crate) fn value_ty_query(db: &impl HirDatabase, def: ValueTyDefId) -> Binders<Ty> {\n     match def {\n         ValueTyDefId::FunctionId(it) => type_for_fn(db, it),\n         ValueTyDefId::StructId(it) => type_for_struct_constructor(db, it),\n@@ -758,24 +909,36 @@ pub(crate) fn value_ty_query(db: &impl HirDatabase, def: ValueTyDefId) -> Ty {\n     }\n }\n \n-pub(crate) fn impl_self_ty_query(db: &impl HirDatabase, impl_id: ImplId) -> Ty {\n+pub(crate) fn impl_self_ty_query(db: &impl HirDatabase, impl_id: ImplId) -> Binders<Ty> {\n     let impl_data = db.impl_data(impl_id);\n     let resolver = impl_id.resolver(db);\n-    Ty::from_hir(db, &resolver, &impl_data.target_type)\n+    let generics = generics(db, impl_id.into());\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n+    Binders::new(generics.len(), Ty::from_hir(&ctx, &impl_data.target_type))\n }\n \n pub(crate) fn impl_self_ty_recover(\n-    _db: &impl HirDatabase,\n+    db: &impl HirDatabase,\n     _cycle: &[String],\n-    _impl_id: &ImplId,\n-) -> Ty {\n-    Ty::Unknown\n+    impl_id: &ImplId,\n+) -> Binders<Ty> {\n+    let generics = generics(db, (*impl_id).into());\n+    Binders::new(generics.len(), Ty::Unknown)\n }\n \n-pub(crate) fn impl_trait_query(db: &impl HirDatabase, impl_id: ImplId) -> Option<TraitRef> {\n+pub(crate) fn impl_trait_query(\n+    db: &impl HirDatabase,\n+    impl_id: ImplId,\n+) -> Option<Binders<TraitRef>> {\n     let impl_data = db.impl_data(impl_id);\n     let resolver = impl_id.resolver(db);\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     let self_ty = db.impl_self_ty(impl_id);\n     let target_trait = impl_data.target_trait.as_ref()?;\n-    TraitRef::from_hir(db, &resolver, target_trait, Some(self_ty.clone()))\n+    Some(Binders::new(\n+        self_ty.num_binders,\n+        TraitRef::from_hir(&ctx, target_trait, Some(self_ty.value.clone()))?,\n+    ))\n }"}, {"sha": "0f754eb9c75515c3ed8767723127102802a6da16", "filename": "crates/ra_hir_ty/src/marks.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -6,5 +6,4 @@ test_utils::marks!(\n     type_var_resolves_to_int_var\n     match_ergonomics_ref\n     coerce_merge_fail_fallback\n-    insert_vars_for_impl_trait\n );"}, {"sha": "5283bff28f3ab4e2b1635f4364a2f39cc626230d", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -61,11 +61,11 @@ impl CrateImplBlocks {\n             for impl_id in module_data.scope.impls() {\n                 match db.impl_trait(impl_id) {\n                     Some(tr) => {\n-                        res.impls_by_trait.entry(tr.trait_).or_default().push(impl_id);\n+                        res.impls_by_trait.entry(tr.value.trait_).or_default().push(impl_id);\n                     }\n                     None => {\n                         let self_ty = db.impl_self_ty(impl_id);\n-                        if let Some(self_ty_fp) = TyFingerprint::for_impl(&self_ty) {\n+                        if let Some(self_ty_fp) = TyFingerprint::for_impl(&self_ty.value) {\n                             res.impls.entry(self_ty_fp).or_default().push(impl_id);\n                         }\n                     }\n@@ -496,7 +496,7 @@ fn transform_receiver_ty(\n         AssocContainerId::ContainerId(_) => unreachable!(),\n     };\n     let sig = db.callable_item_signature(function_id.into());\n-    Some(sig.params()[0].clone().subst(&substs))\n+    Some(sig.value.params()[0].clone().subst_bound_vars(&substs))\n }\n \n pub fn implements_trait("}, {"sha": "fc5ef36a59f5ae0d1c5019999214a57e312b5f2c", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -71,42 +71,42 @@ fn test2() {\n     [82; 93) '{ loop {} }': T\n     [84; 91) 'loop {}': !\n     [89; 91) '{}': ()\n-    [122; 133) '{ loop {} }': *mut [T;_]\n+    [122; 133) '{ loop {} }': *mut [T; _]\n     [124; 131) 'loop {}': !\n     [129; 131) '{}': ()\n     [160; 173) '{     gen() }': *mut [U]\n-    [166; 169) 'gen': fn gen<U>() -> *mut [T;_]\n-    [166; 171) 'gen()': *mut [U;_]\n+    [166; 169) 'gen': fn gen<U>() -> *mut [U; _]\n+    [166; 171) 'gen()': *mut [U; _]\n     [186; 420) '{     ...rr); }': ()\n-    [196; 199) 'arr': &[u8;_]\n-    [212; 216) '&[1]': &[u8;_]\n-    [213; 216) '[1]': [u8;_]\n+    [196; 199) 'arr': &[u8; _]\n+    [212; 216) '&[1]': &[u8; _]\n+    [213; 216) '[1]': [u8; _]\n     [214; 215) '1': u8\n     [227; 228) 'a': &[u8]\n-    [237; 240) 'arr': &[u8;_]\n+    [237; 240) 'arr': &[u8; _]\n     [250; 251) 'b': u8\n-    [254; 255) 'f': fn f<u8>(&[T]) -> T\n+    [254; 255) 'f': fn f<u8>(&[u8]) -> u8\n     [254; 260) 'f(arr)': u8\n-    [256; 259) 'arr': &[u8;_]\n+    [256; 259) 'arr': &[u8; _]\n     [270; 271) 'c': &[u8]\n     [280; 287) '{ arr }': &[u8]\n-    [282; 285) 'arr': &[u8;_]\n+    [282; 285) 'arr': &[u8; _]\n     [297; 298) 'd': u8\n-    [301; 302) 'g': fn g<u8>(S<&[T]>) -> T\n+    [301; 302) 'g': fn g<u8>(S<&[u8]>) -> u8\n     [301; 316) 'g(S { a: arr })': u8\n     [303; 315) 'S { a: arr }': S<&[u8]>\n-    [310; 313) 'arr': &[u8;_]\n-    [326; 327) 'e': [&[u8];_]\n-    [341; 346) '[arr]': [&[u8];_]\n-    [342; 345) 'arr': &[u8;_]\n-    [356; 357) 'f': [&[u8];_]\n-    [371; 379) '[arr; 2]': [&[u8];_]\n-    [372; 375) 'arr': &[u8;_]\n+    [310; 313) 'arr': &[u8; _]\n+    [326; 327) 'e': [&[u8]; _]\n+    [341; 346) '[arr]': [&[u8]; _]\n+    [342; 345) 'arr': &[u8; _]\n+    [356; 357) 'f': [&[u8]; _]\n+    [371; 379) '[arr; 2]': [&[u8]; _]\n+    [372; 375) 'arr': &[u8; _]\n     [377; 378) '2': usize\n     [389; 390) 'g': (&[u8], &[u8])\n     [407; 417) '(arr, arr)': (&[u8], &[u8])\n-    [408; 411) 'arr': &[u8;_]\n-    [413; 416) 'arr': &[u8;_]\n+    [408; 411) 'arr': &[u8; _]\n+    [413; 416) 'arr': &[u8; _]\n     \"###\n     );\n }\n@@ -122,8 +122,8 @@ fn test() {\n         @r###\"\n     [11; 40) '{     ...[1]; }': ()\n     [21; 22) 'x': &[i32]\n-    [33; 37) '&[1]': &[i32;_]\n-    [34; 37) '[1]': [i32;_]\n+    [33; 37) '&[1]': &[i32; _]\n+    [34; 37) '[1]': [i32; _]\n     [35; 36) '1': i32\n     \"###);\n }\n@@ -159,22 +159,22 @@ fn test(a: A<[u8; 2]>, b: B<[u8; 2]>, c: C<[u8; 2]>) {\n     [334; 335) 'x': C<[T]>\n     [355; 360) '{ x }': C<[T]>\n     [357; 358) 'x': C<[T]>\n-    [370; 371) 'a': A<[u8;_]>\n-    [385; 386) 'b': B<[u8;_]>\n-    [400; 401) 'c': C<[u8;_]>\n+    [370; 371) 'a': A<[u8; _]>\n+    [385; 386) 'b': B<[u8; _]>\n+    [400; 401) 'c': C<[u8; _]>\n     [415; 481) '{     ...(c); }': ()\n     [425; 426) 'd': A<[{unknown}]>\n-    [429; 433) 'foo1': fn foo1<{unknown}>(A<[T]>) -> A<[T]>\n+    [429; 433) 'foo1': fn foo1<{unknown}>(A<[{unknown}]>) -> A<[{unknown}]>\n     [429; 436) 'foo1(a)': A<[{unknown}]>\n-    [434; 435) 'a': A<[u8;_]>\n+    [434; 435) 'a': A<[u8; _]>\n     [446; 447) 'e': B<[u8]>\n-    [450; 454) 'foo2': fn foo2<u8>(B<[T]>) -> B<[T]>\n+    [450; 454) 'foo2': fn foo2<u8>(B<[u8]>) -> B<[u8]>\n     [450; 457) 'foo2(b)': B<[u8]>\n-    [455; 456) 'b': B<[u8;_]>\n+    [455; 456) 'b': B<[u8; _]>\n     [467; 468) 'f': C<[u8]>\n-    [471; 475) 'foo3': fn foo3<u8>(C<[T]>) -> C<[T]>\n+    [471; 475) 'foo3': fn foo3<u8>(C<[u8]>) -> C<[u8]>\n     [471; 478) 'foo3(c)': C<[u8]>\n-    [476; 477) 'c': C<[u8;_]>\n+    [476; 477) 'c': C<[u8; _]>\n     \"###\n     );\n }\n@@ -202,14 +202,14 @@ fn test() {\n     [64; 123) 'if tru...     }': &[i32]\n     [67; 71) 'true': bool\n     [72; 97) '{     ...     }': &[i32]\n-    [82; 85) 'foo': fn foo<i32>(&[T]) -> &[T]\n+    [82; 85) 'foo': fn foo<i32>(&[i32]) -> &[i32]\n     [82; 91) 'foo(&[1])': &[i32]\n-    [86; 90) '&[1]': &[i32;_]\n-    [87; 90) '[1]': [i32;_]\n+    [86; 90) '&[1]': &[i32; _]\n+    [87; 90) '[1]': [i32; _]\n     [88; 89) '1': i32\n-    [103; 123) '{     ...     }': &[i32;_]\n-    [113; 117) '&[1]': &[i32;_]\n-    [114; 117) '[1]': [i32;_]\n+    [103; 123) '{     ...     }': &[i32; _]\n+    [113; 117) '&[1]': &[i32; _]\n+    [114; 117) '[1]': [i32; _]\n     [115; 116) '1': i32\n     \"###\n     );\n@@ -237,15 +237,15 @@ fn test() {\n     [60; 61) 'x': &[i32]\n     [64; 123) 'if tru...     }': &[i32]\n     [67; 71) 'true': bool\n-    [72; 92) '{     ...     }': &[i32;_]\n-    [82; 86) '&[1]': &[i32;_]\n-    [83; 86) '[1]': [i32;_]\n+    [72; 92) '{     ...     }': &[i32; _]\n+    [82; 86) '&[1]': &[i32; _]\n+    [83; 86) '[1]': [i32; _]\n     [84; 85) '1': i32\n     [98; 123) '{     ...     }': &[i32]\n-    [108; 111) 'foo': fn foo<i32>(&[T]) -> &[T]\n+    [108; 111) 'foo': fn foo<i32>(&[i32]) -> &[i32]\n     [108; 117) 'foo(&[1])': &[i32]\n-    [112; 116) '&[1]': &[i32;_]\n-    [113; 116) '[1]': [i32;_]\n+    [112; 116) '&[1]': &[i32; _]\n+    [113; 116) '[1]': [i32; _]\n     [114; 115) '1': i32\n     \"###\n     );\n@@ -275,18 +275,18 @@ fn test(i: i32) {\n     [70; 147) 'match ...     }': &[i32]\n     [76; 77) 'i': i32\n     [88; 89) '2': i32\n-    [93; 96) 'foo': fn foo<i32>(&[T]) -> &[T]\n+    [93; 96) 'foo': fn foo<i32>(&[i32]) -> &[i32]\n     [93; 102) 'foo(&[2])': &[i32]\n-    [97; 101) '&[2]': &[i32;_]\n-    [98; 101) '[2]': [i32;_]\n+    [97; 101) '&[2]': &[i32; _]\n+    [98; 101) '[2]': [i32; _]\n     [99; 100) '2': i32\n     [112; 113) '1': i32\n-    [117; 121) '&[1]': &[i32;_]\n-    [118; 121) '[1]': [i32;_]\n+    [117; 121) '&[1]': &[i32; _]\n+    [118; 121) '[1]': [i32; _]\n     [119; 120) '1': i32\n     [131; 132) '_': i32\n-    [136; 140) '&[3]': &[i32;_]\n-    [137; 140) '[3]': [i32;_]\n+    [136; 140) '&[3]': &[i32; _]\n+    [137; 140) '[3]': [i32; _]\n     [138; 139) '3': i32\n     \"###\n     );\n@@ -316,18 +316,18 @@ fn test(i: i32) {\n     [70; 147) 'match ...     }': &[i32]\n     [76; 77) 'i': i32\n     [88; 89) '1': i32\n-    [93; 97) '&[1]': &[i32;_]\n-    [94; 97) '[1]': [i32;_]\n+    [93; 97) '&[1]': &[i32; _]\n+    [94; 97) '[1]': [i32; _]\n     [95; 96) '1': i32\n     [107; 108) '2': i32\n-    [112; 115) 'foo': fn foo<i32>(&[T]) -> &[T]\n+    [112; 115) 'foo': fn foo<i32>(&[i32]) -> &[i32]\n     [112; 121) 'foo(&[2])': &[i32]\n-    [116; 120) '&[2]': &[i32;_]\n-    [117; 120) '[2]': [i32;_]\n+    [116; 120) '&[2]': &[i32; _]\n+    [117; 120) '[2]': [i32; _]\n     [118; 119) '2': i32\n     [131; 132) '_': i32\n-    [136; 140) '&[3]': &[i32;_]\n-    [137; 140) '[3]': [i32;_]\n+    [136; 140) '&[3]': &[i32; _]\n+    [137; 140) '[3]': [i32; _]\n     [138; 139) '3': i32\n     \"###\n     );\n@@ -438,16 +438,16 @@ fn test() {\n     [43; 45) '*x': T\n     [44; 45) 'x': &T\n     [58; 127) '{     ...oo); }': ()\n-    [64; 73) 'takes_ref': fn takes_ref<Foo>(&T) -> T\n+    [64; 73) 'takes_ref': fn takes_ref<Foo>(&Foo) -> Foo\n     [64; 79) 'takes_ref(&Foo)': Foo\n     [74; 78) '&Foo': &Foo\n     [75; 78) 'Foo': Foo\n-    [85; 94) 'takes_ref': fn takes_ref<&Foo>(&T) -> T\n+    [85; 94) 'takes_ref': fn takes_ref<&Foo>(&&Foo) -> &Foo\n     [85; 101) 'takes_...&&Foo)': &Foo\n     [95; 100) '&&Foo': &&Foo\n     [96; 100) '&Foo': &Foo\n     [97; 100) 'Foo': Foo\n-    [107; 116) 'takes_ref': fn takes_ref<&&Foo>(&T) -> T\n+    [107; 116) 'takes_ref': fn takes_ref<&&Foo>(&&&Foo) -> &&Foo\n     [107; 124) 'takes_...&&Foo)': &&Foo\n     [117; 123) '&&&Foo': &&&Foo\n     [118; 123) '&&Foo': &&Foo"}, {"sha": "1722563aa15d8a8de1d00af38470c519080ff4ff", "filename": "crates/ra_hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -27,7 +27,7 @@ fn test() {\n     [66; 73) 'loop {}': !\n     [71; 73) '{}': ()\n     [133; 160) '{     ...o\"); }': ()\n-    [139; 149) '<[_]>::foo': fn foo<u8>(&[T]) -> T\n+    [139; 149) '<[_]>::foo': fn foo<u8>(&[u8]) -> u8\n     [139; 157) '<[_]>:...\"foo\")': u8\n     [150; 156) 'b\"foo\"': &[u8]\n     \"###\n@@ -175,7 +175,7 @@ fn test() {\n     [98; 101) 'val': T\n     [123; 155) '{     ...32); }': ()\n     [133; 134) 'a': Gen<u32>\n-    [137; 146) 'Gen::make': fn make<u32>(T) -> Gen<T>\n+    [137; 146) 'Gen::make': fn make<u32>(u32) -> Gen<u32>\n     [137; 152) 'Gen::make(0u32)': Gen<u32>\n     [147; 151) '0u32': u32\n     \"###\n@@ -206,7 +206,7 @@ fn test() {\n     [95; 98) '{ }': ()\n     [118; 146) '{     ...e(); }': ()\n     [128; 129) 'a': Gen<u32>\n-    [132; 141) 'Gen::make': fn make<u32>() -> Gen<T>\n+    [132; 141) 'Gen::make': fn make<u32>() -> Gen<u32>\n     [132; 143) 'Gen::make()': Gen<u32>\n     \"###\n     );\n@@ -260,7 +260,7 @@ fn test() {\n     [91; 94) '{ }': ()\n     [114; 149) '{     ...e(); }': ()\n     [124; 125) 'a': Gen<u32>\n-    [128; 144) 'Gen::<...::make': fn make<u32>() -> Gen<T>\n+    [128; 144) 'Gen::<...::make': fn make<u32>() -> Gen<u32>\n     [128; 146) 'Gen::<...make()': Gen<u32>\n     \"###\n     );\n@@ -291,7 +291,7 @@ fn test() {\n     [117; 120) '{ }': ()\n     [140; 180) '{     ...e(); }': ()\n     [150; 151) 'a': Gen<u32, u64>\n-    [154; 175) 'Gen::<...::make': fn make<u64>() -> Gen<u32, T>\n+    [154; 175) 'Gen::<...::make': fn make<u64>() -> Gen<u32, u64>\n     [154; 177) 'Gen::<...make()': Gen<u32, u64>\n     \"###\n     );\n@@ -475,7 +475,7 @@ fn test() {\n         @r###\"\n     [33; 37) 'self': &Self\n     [102; 127) '{     ...d(); }': ()\n-    [108; 109) 'S': S<u32>(T) -> S<T>\n+    [108; 109) 'S': S<u32>(u32) -> S<u32>\n     [108; 115) 'S(1u32)': S<u32>\n     [108; 124) 'S(1u32...thod()': u32\n     [110; 114) '1u32': u32\n@@ -501,13 +501,13 @@ fn test() {\n         @r###\"\n     [87; 193) '{     ...t(); }': ()\n     [97; 99) 's1': S\n-    [105; 121) 'Defaul...efault': fn default<S>() -> Self\n+    [105; 121) 'Defaul...efault': fn default<S>() -> S\n     [105; 123) 'Defaul...ault()': S\n     [133; 135) 's2': S\n-    [138; 148) 'S::default': fn default<S>() -> Self\n+    [138; 148) 'S::default': fn default<S>() -> S\n     [138; 150) 'S::default()': S\n     [160; 162) 's3': S\n-    [165; 188) '<S as ...efault': fn default<S>() -> Self\n+    [165; 188) '<S as ...efault': fn default<S>() -> S\n     [165; 190) '<S as ...ault()': S\n     \"###\n     );\n@@ -533,13 +533,13 @@ fn test() {\n         @r###\"\n     [127; 211) '{     ...e(); }': ()\n     [137; 138) 'a': u32\n-    [141; 148) 'S::make': fn make<S, u32>() -> T\n+    [141; 148) 'S::make': fn make<S, u32>() -> u32\n     [141; 150) 'S::make()': u32\n     [160; 161) 'b': u64\n-    [164; 178) 'G::<u64>::make': fn make<G<u64>, u64>() -> T\n+    [164; 178) 'G::<u64>::make': fn make<G<u64>, u64>() -> u64\n     [164; 180) 'G::<u6...make()': u64\n     [190; 191) 'c': f64\n-    [199; 206) 'G::make': fn make<G<f64>, f64>() -> T\n+    [199; 206) 'G::make': fn make<G<f64>, f64>() -> f64\n     [199; 208) 'G::make()': f64\n     \"###\n     );\n@@ -567,19 +567,19 @@ fn test() {\n         @r###\"\n     [135; 313) '{     ...e(); }': ()\n     [145; 146) 'a': (u32, i64)\n-    [149; 163) 'S::make::<i64>': fn make<S, u32, i64>() -> (T, U)\n+    [149; 163) 'S::make::<i64>': fn make<S, u32, i64>() -> (u32, i64)\n     [149; 165) 'S::mak...i64>()': (u32, i64)\n     [175; 176) 'b': (u32, i64)\n-    [189; 196) 'S::make': fn make<S, u32, i64>() -> (T, U)\n+    [189; 196) 'S::make': fn make<S, u32, i64>() -> (u32, i64)\n     [189; 198) 'S::make()': (u32, i64)\n     [208; 209) 'c': (u32, i64)\n-    [212; 233) 'G::<u3...:<i64>': fn make<G<u32>, u32, i64>() -> (T, U)\n+    [212; 233) 'G::<u3...:<i64>': fn make<G<u32>, u32, i64>() -> (u32, i64)\n     [212; 235) 'G::<u3...i64>()': (u32, i64)\n     [245; 246) 'd': (u32, i64)\n-    [259; 273) 'G::make::<i64>': fn make<G<u32>, u32, i64>() -> (T, U)\n+    [259; 273) 'G::make::<i64>': fn make<G<u32>, u32, i64>() -> (u32, i64)\n     [259; 275) 'G::mak...i64>()': (u32, i64)\n     [285; 286) 'e': (u32, i64)\n-    [301; 308) 'G::make': fn make<G<u32>, u32, i64>() -> (T, U)\n+    [301; 308) 'G::make': fn make<G<u32>, u32, i64>() -> (u32, i64)\n     [301; 310) 'G::make()': (u32, i64)\n     \"###\n     );\n@@ -601,7 +601,7 @@ fn test() {\n         @r###\"\n     [101; 127) '{     ...e(); }': ()\n     [111; 112) 'a': (S<i32>, i64)\n-    [115; 122) 'S::make': fn make<S<i32>, i64>() -> (Self, T)\n+    [115; 122) 'S::make': fn make<S<i32>, i64>() -> (S<i32>, i64)\n     [115; 124) 'S::make()': (S<i32>, i64)\n     \"###\n     );\n@@ -625,10 +625,10 @@ fn test() {\n         @r###\"\n     [131; 203) '{     ...e(); }': ()\n     [141; 142) 'a': (S<u64>, i64)\n-    [158; 165) 'S::make': fn make<S<u64>, i64>() -> (Self, T)\n+    [158; 165) 'S::make': fn make<S<u64>, i64>() -> (S<u64>, i64)\n     [158; 167) 'S::make()': (S<u64>, i64)\n     [177; 178) 'b': (S<u32>, i32)\n-    [191; 198) 'S::make': fn make<S<u32>, i32>() -> (Self, T)\n+    [191; 198) 'S::make': fn make<S<u32>, i32>() -> (S<u32>, i32)\n     [191; 200) 'S::make()': (S<u32>, i32)\n     \"###\n     );\n@@ -651,10 +651,10 @@ fn test() {\n         @r###\"\n     [107; 211) '{     ...>(); }': ()\n     [117; 118) 'a': (S<u64>, i64, u8)\n-    [121; 150) '<S as ...::<u8>': fn make<S<u64>, i64, u8>() -> (Self, T, U)\n+    [121; 150) '<S as ...::<u8>': fn make<S<u64>, i64, u8>() -> (S<u64>, i64, u8)\n     [121; 152) '<S as ...<u8>()': (S<u64>, i64, u8)\n     [162; 163) 'b': (S<u64>, i64, u8)\n-    [182; 206) 'Trait:...::<u8>': fn make<S<u64>, i64, u8>() -> (Self, T, U)\n+    [182; 206) 'Trait:...::<u8>': fn make<S<u64>, i64, u8>() -> (S<u64>, i64, u8)\n     [182; 208) 'Trait:...<u8>()': (S<u64>, i64, u8)\n     \"###\n     );\n@@ -697,7 +697,7 @@ fn test<U, T: Trait<U>>(t: T) {\n     [71; 72) 't': T\n     [77; 96) '{     ...d(); }': ()\n     [83; 84) 't': T\n-    [83; 93) 't.method()': [missing name]\n+    [83; 93) 't.method()': U\n     \"###\n     );\n }\n@@ -728,7 +728,7 @@ fn test() {\n     [157; 158) 'S': S\n     [157; 165) 'S.into()': u64\n     [175; 176) 'z': u64\n-    [179; 196) 'Into::...::into': fn into<S, u64>(Self) -> T\n+    [179; 196) 'Into::...::into': fn into<S, u64>(S) -> u64\n     [179; 199) 'Into::...nto(S)': u64\n     [197; 198) 'S': S\n     \"###"}, {"sha": "e25d6dbc43d46b32f092c401e8f4db7f631a0596", "filename": "crates/ra_hir_ty/src/tests/patterns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -96,13 +96,13 @@ fn test() {\n     [38; 42) 'A(n)': A<i32>\n     [40; 41) 'n': &i32\n     [45; 50) '&A(1)': &A<i32>\n-    [46; 47) 'A': A<i32>(T) -> A<T>\n+    [46; 47) 'A': A<i32>(i32) -> A<i32>\n     [46; 50) 'A(1)': A<i32>\n     [48; 49) '1': i32\n     [60; 64) 'A(n)': A<i32>\n     [62; 63) 'n': &mut i32\n     [67; 76) '&mut A(1)': &mut A<i32>\n-    [72; 73) 'A': A<i32>(T) -> A<T>\n+    [72; 73) 'A': A<i32>(i32) -> A<i32>\n     [72; 76) 'A(1)': A<i32>\n     [74; 75) '1': i32\n     \"###"}, {"sha": "14c8ed3a9b7a942ebe00731fb43db7f6d3792e62", "filename": "crates/ra_hir_ty/src/tests/regression.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -102,7 +102,7 @@ fn test() {\n     [11; 48) '{     ...&y]; }': ()\n     [21; 22) 'y': &{unknown}\n     [25; 32) 'unknown': &{unknown}\n-    [38; 45) '[y, &y]': [&&{unknown};_]\n+    [38; 45) '[y, &y]': [&&{unknown}; _]\n     [39; 40) 'y': &{unknown}\n     [42; 44) '&y': &&{unknown}\n     [43; 44) 'y': &{unknown}\n@@ -128,7 +128,7 @@ fn test() {\n     [25; 32) 'unknown': &&{unknown}\n     [42; 43) 'y': &&{unknown}\n     [46; 53) 'unknown': &&{unknown}\n-    [59; 77) '[(x, y..., &x)]': [(&&&{unknown}, &&&{unknown});_]\n+    [59; 77) '[(x, y..., &x)]': [(&&&{unknown}, &&&{unknown}); _]\n     [60; 66) '(x, y)': (&&&{unknown}, &&&{unknown})\n     [61; 62) 'x': &&{unknown}\n     [64; 65) 'y': &&{unknown}\n@@ -180,8 +180,8 @@ fn test_line_buffer() {\n \"#),\n         @r###\"\n     [23; 53) '{     ...n']; }': ()\n-    [29; 50) '&[0, b...b'\\n']': &[u8;_]\n-    [30; 50) '[0, b'...b'\\n']': [u8;_]\n+    [29; 50) '&[0, b...b'\\n']': &[u8; _]\n+    [30; 50) '[0, b'...b'\\n']': [u8; _]\n     [31; 32) '0': u8\n     [34; 39) 'b'\\n'': u8\n     [41; 42) '1': u8\n@@ -346,7 +346,7 @@ pub fn main_loop() {\n     @r###\"\n     [144; 146) '{}': ()\n     [169; 198) '{     ...t(); }': ()\n-    [175; 193) 'FxHash...efault': fn default<{unknown}, FxHasher>() -> HashSet<T, H>\n+    [175; 193) 'FxHash...efault': fn default<{unknown}, FxHasher>() -> HashSet<{unknown}, FxHasher>\n     [175; 195) 'FxHash...ault()': HashSet<{unknown}, FxHasher>\n     \"###\n     );"}, {"sha": "3803f5938cfa75bd546a7ef32c4598208e3c5ead", "filename": "crates/ra_hir_ty/src/tests/simple.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -28,7 +28,7 @@ mod boxed {\n \n \"#,\n     );\n-    assert_eq!(\"(Box<i32>, Box<Box<i32>>, Box<&i32>, Box<[i32;_]>)\", type_at_pos(&db, pos));\n+    assert_eq!(\"(Box<i32>, Box<Box<i32>>, Box<&i32>, Box<[i32; _]>)\", type_at_pos(&db, pos));\n }\n \n #[test]\n@@ -754,15 +754,15 @@ fn test() {\n     [289; 295) 'self.0': T\n     [315; 353) '{     ...))); }': ()\n     [325; 326) 't': &i32\n-    [329; 335) 'A::foo': fn foo<i32>(&A<T>) -> &T\n+    [329; 335) 'A::foo': fn foo<i32>(&A<i32>) -> &i32\n     [329; 350) 'A::foo...42))))': &i32\n     [336; 349) '&&B(B(A(42)))': &&B<B<A<i32>>>\n     [337; 349) '&B(B(A(42)))': &B<B<A<i32>>>\n-    [338; 339) 'B': B<B<A<i32>>>(T) -> B<T>\n+    [338; 339) 'B': B<B<A<i32>>>(B<A<i32>>) -> B<B<A<i32>>>\n     [338; 349) 'B(B(A(42)))': B<B<A<i32>>>\n-    [340; 341) 'B': B<A<i32>>(T) -> B<T>\n+    [340; 341) 'B': B<A<i32>>(A<i32>) -> B<A<i32>>\n     [340; 348) 'B(A(42))': B<A<i32>>\n-    [342; 343) 'A': A<i32>(T) -> A<T>\n+    [342; 343) 'A': A<i32>(i32) -> A<i32>\n     [342; 347) 'A(42)': A<i32>\n     [344; 346) '42': i32\n     \"###\n@@ -817,16 +817,16 @@ fn test(a: A<i32>) {\n     [326; 327) 'a': A<i32>\n     [337; 383) '{     ...))); }': ()\n     [347; 348) 't': &i32\n-    [351; 352) 'A': A<i32>(*mut T) -> A<T>\n+    [351; 352) 'A': A<i32>(*mut i32) -> A<i32>\n     [351; 365) 'A(0 as *mut _)': A<i32>\n     [351; 380) 'A(0 as...B(a)))': &i32\n     [353; 354) '0': i32\n     [353; 364) '0 as *mut _': *mut i32\n     [370; 379) '&&B(B(a))': &&B<B<A<i32>>>\n     [371; 379) '&B(B(a))': &B<B<A<i32>>>\n-    [372; 373) 'B': B<B<A<i32>>>(T) -> B<T>\n+    [372; 373) 'B': B<B<A<i32>>>(B<A<i32>>) -> B<B<A<i32>>>\n     [372; 379) 'B(B(a))': B<B<A<i32>>>\n-    [374; 375) 'B': B<A<i32>>(T) -> B<T>\n+    [374; 375) 'B': B<A<i32>>(A<i32>) -> B<A<i32>>\n     [374; 378) 'B(a)': B<A<i32>>\n     [376; 377) 'a': A<i32>\n     \"###\n@@ -1061,55 +1061,55 @@ fn test(x: &str, y: isize) {\n     [9; 10) 'x': &str\n     [18; 19) 'y': isize\n     [28; 293) '{     ... []; }': ()\n-    [38; 39) 'a': [&str;_]\n-    [42; 45) '[x]': [&str;_]\n+    [38; 39) 'a': [&str; _]\n+    [42; 45) '[x]': [&str; _]\n     [43; 44) 'x': &str\n-    [55; 56) 'b': [[&str;_];_]\n-    [59; 65) '[a, a]': [[&str;_];_]\n-    [60; 61) 'a': [&str;_]\n-    [63; 64) 'a': [&str;_]\n-    [75; 76) 'c': [[[&str;_];_];_]\n-    [79; 85) '[b, b]': [[[&str;_];_];_]\n-    [80; 81) 'b': [[&str;_];_]\n-    [83; 84) 'b': [[&str;_];_]\n-    [96; 97) 'd': [isize;_]\n-    [100; 112) '[y, 1, 2, 3]': [isize;_]\n+    [55; 56) 'b': [[&str; _]; _]\n+    [59; 65) '[a, a]': [[&str; _]; _]\n+    [60; 61) 'a': [&str; _]\n+    [63; 64) 'a': [&str; _]\n+    [75; 76) 'c': [[[&str; _]; _]; _]\n+    [79; 85) '[b, b]': [[[&str; _]; _]; _]\n+    [80; 81) 'b': [[&str; _]; _]\n+    [83; 84) 'b': [[&str; _]; _]\n+    [96; 97) 'd': [isize; _]\n+    [100; 112) '[y, 1, 2, 3]': [isize; _]\n     [101; 102) 'y': isize\n     [104; 105) '1': isize\n     [107; 108) '2': isize\n     [110; 111) '3': isize\n-    [122; 123) 'd': [isize;_]\n-    [126; 138) '[1, y, 2, 3]': [isize;_]\n+    [122; 123) 'd': [isize; _]\n+    [126; 138) '[1, y, 2, 3]': [isize; _]\n     [127; 128) '1': isize\n     [130; 131) 'y': isize\n     [133; 134) '2': isize\n     [136; 137) '3': isize\n-    [148; 149) 'e': [isize;_]\n-    [152; 155) '[y]': [isize;_]\n+    [148; 149) 'e': [isize; _]\n+    [152; 155) '[y]': [isize; _]\n     [153; 154) 'y': isize\n-    [165; 166) 'f': [[isize;_];_]\n-    [169; 175) '[d, d]': [[isize;_];_]\n-    [170; 171) 'd': [isize;_]\n-    [173; 174) 'd': [isize;_]\n-    [185; 186) 'g': [[isize;_];_]\n-    [189; 195) '[e, e]': [[isize;_];_]\n-    [190; 191) 'e': [isize;_]\n-    [193; 194) 'e': [isize;_]\n-    [206; 207) 'h': [i32;_]\n-    [210; 216) '[1, 2]': [i32;_]\n+    [165; 166) 'f': [[isize; _]; _]\n+    [169; 175) '[d, d]': [[isize; _]; _]\n+    [170; 171) 'd': [isize; _]\n+    [173; 174) 'd': [isize; _]\n+    [185; 186) 'g': [[isize; _]; _]\n+    [189; 195) '[e, e]': [[isize; _]; _]\n+    [190; 191) 'e': [isize; _]\n+    [193; 194) 'e': [isize; _]\n+    [206; 207) 'h': [i32; _]\n+    [210; 216) '[1, 2]': [i32; _]\n     [211; 212) '1': i32\n     [214; 215) '2': i32\n-    [226; 227) 'i': [&str;_]\n-    [230; 240) '[\"a\", \"b\"]': [&str;_]\n+    [226; 227) 'i': [&str; _]\n+    [230; 240) '[\"a\", \"b\"]': [&str; _]\n     [231; 234) '\"a\"': &str\n     [236; 239) '\"b\"': &str\n-    [251; 252) 'b': [[&str;_];_]\n-    [255; 265) '[a, [\"b\"]]': [[&str;_];_]\n-    [256; 257) 'a': [&str;_]\n-    [259; 264) '[\"b\"]': [&str;_]\n+    [251; 252) 'b': [[&str; _]; _]\n+    [255; 265) '[a, [\"b\"]]': [[&str; _]; _]\n+    [256; 257) 'a': [&str; _]\n+    [259; 264) '[\"b\"]': [&str; _]\n     [260; 263) '\"b\"': &str\n-    [275; 276) 'x': [u8;_]\n-    [288; 290) '[]': [u8;_]\n+    [275; 276) 'x': [u8; _]\n+    [288; 290) '[]': [u8; _]\n     \"###\n     );\n }\n@@ -1169,16 +1169,16 @@ fn test() {\n \"#),\n         @r###\"\n     [76; 184) '{     ...one; }': ()\n-    [82; 83) 'A': A<i32>(T) -> A<T>\n+    [82; 83) 'A': A<i32>(i32) -> A<i32>\n     [82; 87) 'A(42)': A<i32>\n     [84; 86) '42': i32\n-    [93; 94) 'A': A<u128>(T) -> A<T>\n+    [93; 94) 'A': A<u128>(u128) -> A<u128>\n     [93; 102) 'A(42u128)': A<u128>\n     [95; 101) '42u128': u128\n-    [108; 112) 'Some': Some<&str>(T) -> Option<T>\n+    [108; 112) 'Some': Some<&str>(&str) -> Option<&str>\n     [108; 117) 'Some(\"x\")': Option<&str>\n     [113; 116) '\"x\"': &str\n-    [123; 135) 'Option::Some': Some<&str>(T) -> Option<T>\n+    [123; 135) 'Option::Some': Some<&str>(&str) -> Option<&str>\n     [123; 140) 'Option...e(\"x\")': Option<&str>\n     [136; 139) '\"x\"': &str\n     [146; 150) 'None': Option<{unknown}>\n@@ -1205,22 +1205,22 @@ fn test() {\n     [21; 26) '{ t }': T\n     [23; 24) 't': T\n     [38; 98) '{     ...(1); }': ()\n-    [44; 46) 'id': fn id<u32>(T) -> T\n+    [44; 46) 'id': fn id<u32>(u32) -> u32\n     [44; 52) 'id(1u32)': u32\n     [47; 51) '1u32': u32\n-    [58; 68) 'id::<i128>': fn id<i128>(T) -> T\n+    [58; 68) 'id::<i128>': fn id<i128>(i128) -> i128\n     [58; 71) 'id::<i128>(1)': i128\n     [69; 70) '1': i128\n     [81; 82) 'x': u64\n-    [90; 92) 'id': fn id<u64>(T) -> T\n+    [90; 92) 'id': fn id<u64>(u64) -> u64\n     [90; 95) 'id(1)': u64\n     [93; 94) '1': u64\n     \"###\n     );\n }\n \n #[test]\n-fn infer_impl_generics() {\n+fn infer_impl_generics_basic() {\n     assert_snapshot!(\n         infer(r#\"\n struct A<T1, T2> {\n@@ -1349,16 +1349,16 @@ fn test() -> i128 {\n     [146; 147) 'x': i128\n     [150; 151) '1': i128\n     [162; 163) 'y': i128\n-    [166; 168) 'id': fn id<i128>(T) -> T\n+    [166; 168) 'id': fn id<i128>(i128) -> i128\n     [166; 171) 'id(x)': i128\n     [169; 170) 'x': i128\n     [182; 183) 'a': A<i128>\n     [186; 200) 'A { x: id(y) }': A<i128>\n-    [193; 195) 'id': fn id<i128>(T) -> T\n+    [193; 195) 'id': fn id<i128>(i128) -> i128\n     [193; 198) 'id(y)': i128\n     [196; 197) 'y': i128\n     [211; 212) 'z': i128\n-    [215; 217) 'id': fn id<i128>(T) -> T\n+    [215; 217) 'id': fn id<i128>(i128) -> i128\n     [215; 222) 'id(a.x)': i128\n     [218; 219) 'a': A<i128>\n     [218; 221) 'a.x': i128\n@@ -1502,14 +1502,14 @@ fn test() {\n     [78; 158) '{     ...(1); }': ()\n     [88; 89) 'y': u32\n     [92; 97) '10u32': u32\n-    [103; 105) 'id': fn id<u32>(T) -> T\n+    [103; 105) 'id': fn id<u32>(u32) -> u32\n     [103; 108) 'id(y)': u32\n     [106; 107) 'y': u32\n     [118; 119) 'x': bool\n-    [128; 133) 'clone': fn clone<bool>(&T) -> T\n+    [128; 133) 'clone': fn clone<bool>(&bool) -> bool\n     [128; 136) 'clone(z)': bool\n     [134; 135) 'z': &bool\n-    [142; 152) 'id::<i128>': fn id<i128>(T) -> T\n+    [142; 152) 'id::<i128>': fn id<i128>(i128) -> i128\n     [142; 155) 'id::<i128>(1)': i128\n     [153; 154) '1': i128\n     \"###"}, {"sha": "17611ddbfa4217338b6792ee31ac43f17c20b199", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 260, "deletions": 56, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,7 +1,6 @@\n use insta::assert_snapshot;\n \n use ra_db::fixture::WithFixture;\n-use test_utils::covers;\n \n use super::{infer, infer_with_mismatches, type_at, type_at_pos};\n use crate::test_db::TestDB;\n@@ -261,10 +260,10 @@ fn test() {\n     [92; 94) '{}': ()\n     [105; 144) '{     ...(s); }': ()\n     [115; 116) 's': S<u32>\n-    [119; 120) 'S': S<u32>(T) -> S<T>\n+    [119; 120) 'S': S<u32>(u32) -> S<u32>\n     [119; 129) 'S(unknown)': S<u32>\n     [121; 128) 'unknown': u32\n-    [135; 138) 'foo': fn foo<S<u32>>(T) -> ()\n+    [135; 138) 'foo': fn foo<S<u32>>(S<u32>) -> ()\n     [135; 141) 'foo(s)': ()\n     [139; 140) 's': S<u32>\n     \"###\n@@ -289,11 +288,11 @@ fn test() {\n     [98; 100) '{}': ()\n     [111; 163) '{     ...(s); }': ()\n     [121; 122) 's': S<u32>\n-    [125; 126) 'S': S<u32>(T) -> S<T>\n+    [125; 126) 'S': S<u32>(u32) -> S<u32>\n     [125; 135) 'S(unknown)': S<u32>\n     [127; 134) 'unknown': u32\n     [145; 146) 'x': u32\n-    [154; 157) 'foo': fn foo<u32, S<u32>>(T) -> U\n+    [154; 157) 'foo': fn foo<u32, S<u32>>(S<u32>) -> u32\n     [154; 160) 'foo(s)': u32\n     [158; 159) 's': S<u32>\n     \"###\n@@ -358,15 +357,15 @@ fn test() {\n     [221; 223) '{}': ()\n     [234; 300) '{     ...(S); }': ()\n     [244; 245) 'x': u32\n-    [248; 252) 'foo1': fn foo1<S>(T) -> <T as Iterable>::Item\n+    [248; 252) 'foo1': fn foo1<S>(S) -> <S as Iterable>::Item\n     [248; 255) 'foo1(S)': u32\n     [253; 254) 'S': S\n     [265; 266) 'y': u32\n-    [269; 273) 'foo2': fn foo2<S>(T) -> <T as Iterable>::Item\n+    [269; 273) 'foo2': fn foo2<S>(S) -> <S as Iterable>::Item\n     [269; 276) 'foo2(S)': u32\n     [274; 275) 'S': S\n     [286; 287) 'z': u32\n-    [290; 294) 'foo3': fn foo3<S>(T) -> <T as Iterable>::Item\n+    [290; 294) 'foo3': fn foo3<S>(S) -> <S as Iterable>::Item\n     [290; 297) 'foo3(S)': u32\n     [295; 296) 'S': S\n     \"###\n@@ -479,7 +478,7 @@ fn indexing_arrays() {\n         @r###\"\n     [10; 26) '{ &mut...[2]; }': ()\n     [12; 23) '&mut [9][2]': &mut {unknown}\n-    [17; 20) '[9]': [i32;_]\n+    [17; 20) '[9]': [i32; _]\n     [17; 23) '[9][2]': {unknown}\n     [18; 19) '9': i32\n     [21; 22) '2': i32\n@@ -822,8 +821,7 @@ fn test<T: ApplyL>() {\n \"#,\n     );\n     // inside the generic function, the associated type gets normalized to a placeholder `ApplL::Out<T>` [https://rust-lang.github.io/rustc-guide/traits/associated-types.html#placeholder-associated-types].\n-    // FIXME: fix type parameter names going missing when going through Chalk\n-    assert_eq!(t, \"ApplyL::Out<[missing name]>\");\n+    assert_eq!(t, \"ApplyL::Out<T>\");\n }\n \n #[test]\n@@ -850,6 +848,198 @@ fn test<T: ApplyL>(t: T) {\n }\n \n #[test]\n+fn argument_impl_trait() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+trait Trait<T> {\n+    fn foo(&self) -> T;\n+    fn foo2(&self) -> i64;\n+}\n+fn bar(x: impl Trait<u16>) {}\n+struct S<T>(T);\n+impl<T> Trait<T> for S<T> {}\n+\n+fn test(x: impl Trait<u64>, y: &impl Trait<u32>) {\n+    x;\n+    y;\n+    let z = S(1);\n+    bar(z);\n+    x.foo();\n+    y.foo();\n+    z.foo();\n+    x.foo2();\n+    y.foo2();\n+    z.foo2();\n+}\n+\"#, true),\n+        @r###\"\n+    [30; 34) 'self': &Self\n+    [55; 59) 'self': &Self\n+    [78; 79) 'x': impl Trait<u16>\n+    [98; 100) '{}': ()\n+    [155; 156) 'x': impl Trait<u64>\n+    [175; 176) 'y': &impl Trait<u32>\n+    [196; 324) '{     ...2(); }': ()\n+    [202; 203) 'x': impl Trait<u64>\n+    [209; 210) 'y': &impl Trait<u32>\n+    [220; 221) 'z': S<u16>\n+    [224; 225) 'S': S<u16>(u16) -> S<u16>\n+    [224; 228) 'S(1)': S<u16>\n+    [226; 227) '1': u16\n+    [234; 237) 'bar': fn bar(S<u16>) -> ()\n+    [234; 240) 'bar(z)': ()\n+    [238; 239) 'z': S<u16>\n+    [246; 247) 'x': impl Trait<u64>\n+    [246; 253) 'x.foo()': u64\n+    [259; 260) 'y': &impl Trait<u32>\n+    [259; 266) 'y.foo()': u32\n+    [272; 273) 'z': S<u16>\n+    [272; 279) 'z.foo()': u16\n+    [285; 286) 'x': impl Trait<u64>\n+    [285; 293) 'x.foo2()': i64\n+    [299; 300) 'y': &impl Trait<u32>\n+    [299; 307) 'y.foo2()': i64\n+    [313; 314) 'z': S<u16>\n+    [313; 321) 'z.foo2()': i64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn argument_impl_trait_type_args_1() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+trait Trait {}\n+trait Foo {\n+    // this function has an implicit Self param, an explicit type param,\n+    // and an implicit impl Trait param!\n+    fn bar<T>(x: impl Trait) -> T { loop {} }\n+}\n+fn foo<T>(x: impl Trait) -> T { loop {} }\n+struct S;\n+impl Trait for S {}\n+struct F;\n+impl Foo for F {}\n+\n+fn test() {\n+    Foo::bar(S);\n+    <F as Foo>::bar(S);\n+    F::bar(S);\n+    Foo::bar::<u32>(S);\n+    <F as Foo>::bar::<u32>(S);\n+\n+    foo(S);\n+    foo::<u32>(S);\n+    foo::<u32, i32>(S); // we should ignore the extraneous i32\n+}\n+\"#, true),\n+        @r###\"\n+    [156; 157) 'x': impl Trait\n+    [176; 187) '{ loop {} }': T\n+    [178; 185) 'loop {}': !\n+    [183; 185) '{}': ()\n+    [200; 201) 'x': impl Trait\n+    [220; 231) '{ loop {} }': T\n+    [222; 229) 'loop {}': !\n+    [227; 229) '{}': ()\n+    [301; 510) '{     ... i32 }': ()\n+    [307; 315) 'Foo::bar': fn bar<{unknown}, {unknown}>(S) -> {unknown}\n+    [307; 318) 'Foo::bar(S)': {unknown}\n+    [316; 317) 'S': S\n+    [324; 339) '<F as Foo>::bar': fn bar<F, {unknown}>(S) -> {unknown}\n+    [324; 342) '<F as ...bar(S)': {unknown}\n+    [340; 341) 'S': S\n+    [348; 354) 'F::bar': fn bar<F, {unknown}>(S) -> {unknown}\n+    [348; 357) 'F::bar(S)': {unknown}\n+    [355; 356) 'S': S\n+    [363; 378) 'Foo::bar::<u32>': fn bar<{unknown}, u32>(S) -> u32\n+    [363; 381) 'Foo::b...32>(S)': u32\n+    [379; 380) 'S': S\n+    [387; 409) '<F as ...:<u32>': fn bar<F, u32>(S) -> u32\n+    [387; 412) '<F as ...32>(S)': u32\n+    [410; 411) 'S': S\n+    [419; 422) 'foo': fn foo<{unknown}>(S) -> {unknown}\n+    [419; 425) 'foo(S)': {unknown}\n+    [423; 424) 'S': S\n+    [431; 441) 'foo::<u32>': fn foo<u32>(S) -> u32\n+    [431; 444) 'foo::<u32>(S)': u32\n+    [442; 443) 'S': S\n+    [450; 465) 'foo::<u32, i32>': fn foo<u32>(S) -> u32\n+    [450; 468) 'foo::<...32>(S)': u32\n+    [466; 467) 'S': S\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn argument_impl_trait_type_args_2() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+trait Trait {}\n+struct S;\n+impl Trait for S {}\n+struct F<T>;\n+impl<T> F<T> {\n+    fn foo<U>(self, x: impl Trait) -> (T, U) { loop {} }\n+}\n+\n+fn test() {\n+    F.foo(S);\n+    F::<u32>.foo(S);\n+    F::<u32>.foo::<i32>(S);\n+    F::<u32>.foo::<i32, u32>(S); // extraneous argument should be ignored\n+}\n+\"#, true),\n+        @r###\"\n+    [88; 92) 'self': F<T>\n+    [94; 95) 'x': impl Trait\n+    [119; 130) '{ loop {} }': (T, U)\n+    [121; 128) 'loop {}': !\n+    [126; 128) '{}': ()\n+    [144; 284) '{     ...ored }': ()\n+    [150; 151) 'F': F<{unknown}>\n+    [150; 158) 'F.foo(S)': ({unknown}, {unknown})\n+    [156; 157) 'S': S\n+    [164; 172) 'F::<u32>': F<u32>\n+    [164; 179) 'F::<u32>.foo(S)': (u32, {unknown})\n+    [177; 178) 'S': S\n+    [185; 193) 'F::<u32>': F<u32>\n+    [185; 207) 'F::<u3...32>(S)': (u32, i32)\n+    [205; 206) 'S': S\n+    [213; 221) 'F::<u32>': F<u32>\n+    [213; 240) 'F::<u3...32>(S)': (u32, i32)\n+    [238; 239) 'S': S\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn argument_impl_trait_to_fn_pointer() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+trait Trait {}\n+fn foo(x: impl Trait) { loop {} }\n+struct S;\n+impl Trait for S {}\n+\n+fn test() {\n+    let f: fn(S) -> () = foo;\n+}\n+\"#, true),\n+        @r###\"\n+    [23; 24) 'x': impl Trait\n+    [38; 49) '{ loop {} }': ()\n+    [40; 47) 'loop {}': !\n+    [45; 47) '{}': ()\n+    [91; 124) '{     ...foo; }': ()\n+    [101; 102) 'f': fn(S) -> ()\n+    [118; 121) 'foo': fn foo(S) -> ()\n+    \"###\n+    );\n+}\n+\n+#[test]\n+#[ignore]\n fn impl_trait() {\n     assert_snapshot!(\n         infer(r#\"\n@@ -993,34 +1183,23 @@ fn weird_bounds() {\n     assert_snapshot!(\n         infer(r#\"\n trait Trait {}\n-fn test() {\n-    let a: impl Trait + 'lifetime = foo;\n-    let b: impl 'lifetime = foo;\n-    let b: impl (Trait) = foo;\n-    let b: impl ('lifetime) = foo;\n-    let d: impl ?Sized = foo;\n-    let e: impl Trait + ?Sized = foo;\n+fn test(a: impl Trait + 'lifetime, b: impl 'lifetime, c: impl (Trait), d: impl ('lifetime), e: impl ?Sized, f: impl Trait + ?Sized) {\n }\n \"#),\n         @r###\"\n-    [26; 237) '{     ...foo; }': ()\n-    [36; 37) 'a': impl Trait + {error}\n-    [64; 67) 'foo': impl Trait + {error}\n-    [77; 78) 'b': impl {error}\n-    [97; 100) 'foo': impl {error}\n-    [110; 111) 'b': impl Trait\n-    [128; 131) 'foo': impl Trait\n-    [141; 142) 'b': impl {error}\n-    [163; 166) 'foo': impl {error}\n-    [176; 177) 'd': impl {error}\n-    [193; 196) 'foo': impl {error}\n-    [206; 207) 'e': impl Trait + {error}\n-    [231; 234) 'foo': impl Trait + {error}\n+    [24; 25) 'a': impl Trait + {error}\n+    [51; 52) 'b': impl {error}\n+    [70; 71) 'c': impl Trait\n+    [87; 88) 'd': impl {error}\n+    [108; 109) 'e': impl {error}\n+    [124; 125) 'f': impl Trait + {error}\n+    [148; 151) '{ }': ()\n     \"###\n     );\n }\n \n #[test]\n+#[ignore]\n fn error_bound_chalk() {\n     let t = type_at(\n         r#\"\n@@ -1076,26 +1255,26 @@ fn test<T: Trait<Type = u32>>(x: T, y: impl Trait<Type = i64>) {\n     [296; 299) 'get': fn get<T>(T) -> <T as Trait>::Type\n     [296; 302) 'get(x)': {unknown}\n     [300; 301) 'x': T\n-    [308; 312) 'get2': fn get2<{unknown}, T>(T) -> U\n+    [308; 312) 'get2': fn get2<{unknown}, T>(T) -> {unknown}\n     [308; 315) 'get2(x)': {unknown}\n     [313; 314) 'x': T\n-    [321; 324) 'get': fn get<impl Trait<Type = i64>>(T) -> <T as Trait>::Type\n+    [321; 324) 'get': fn get<impl Trait<Type = i64>>(impl Trait<Type = i64>) -> <impl Trait<Type = i64> as Trait>::Type\n     [321; 327) 'get(y)': {unknown}\n     [325; 326) 'y': impl Trait<Type = i64>\n-    [333; 337) 'get2': fn get2<{unknown}, impl Trait<Type = i64>>(T) -> U\n+    [333; 337) 'get2': fn get2<{unknown}, impl Trait<Type = i64>>(impl Trait<Type = i64>) -> {unknown}\n     [333; 340) 'get2(y)': {unknown}\n     [338; 339) 'y': impl Trait<Type = i64>\n-    [346; 349) 'get': fn get<S<u64>>(T) -> <T as Trait>::Type\n+    [346; 349) 'get': fn get<S<u64>>(S<u64>) -> <S<u64> as Trait>::Type\n     [346; 357) 'get(set(S))': u64\n-    [350; 353) 'set': fn set<S<u64>>(T) -> T\n+    [350; 353) 'set': fn set<S<u64>>(S<u64>) -> S<u64>\n     [350; 356) 'set(S)': S<u64>\n     [354; 355) 'S': S<u64>\n-    [363; 367) 'get2': fn get2<u64, S<u64>>(T) -> U\n+    [363; 367) 'get2': fn get2<u64, S<u64>>(S<u64>) -> u64\n     [363; 375) 'get2(set(S))': u64\n-    [368; 371) 'set': fn set<S<u64>>(T) -> T\n+    [368; 371) 'set': fn set<S<u64>>(S<u64>) -> S<u64>\n     [368; 374) 'set(S)': S<u64>\n     [372; 373) 'S': S<u64>\n-    [381; 385) 'get2': fn get2<str, S<str>>(T) -> U\n+    [381; 385) 'get2': fn get2<str, S<str>>(S<str>) -> str\n     [381; 395) 'get2(S::<str>)': str\n     [386; 394) 'S::<str>': S<str>\n     \"###\n@@ -1222,6 +1401,32 @@ fn test<T: Trait1, U: Trait2>(x: T, y: U) {\n     );\n }\n \n+#[test]\n+fn super_trait_impl_trait_method_resolution() {\n+    assert_snapshot!(\n+        infer(r#\"\n+mod foo {\n+    trait SuperTrait {\n+        fn foo(&self) -> u32 {}\n+    }\n+}\n+trait Trait1: foo::SuperTrait {}\n+\n+fn test(x: &impl Trait1) {\n+    x.foo();\n+}\n+\"#),\n+        @r###\"\n+    [50; 54) 'self': &Self\n+    [63; 65) '{}': ()\n+    [116; 117) 'x': &impl Trait1\n+    [133; 149) '{     ...o(); }': ()\n+    [139; 140) 'x': &impl Trait1\n+    [139; 146) 'x.foo()': u32\n+    \"###\n+    );\n+}\n+\n #[test]\n fn super_trait_cycle() {\n     // This just needs to not crash\n@@ -1268,9 +1473,9 @@ fn test() {\n     [157; 160) '{t}': T\n     [158; 159) 't': T\n     [259; 280) '{     ...S)); }': ()\n-    [265; 269) 'get2': fn get2<u64, S<u64>>(T) -> U\n+    [265; 269) 'get2': fn get2<u64, S<u64>>(S<u64>) -> u64\n     [265; 277) 'get2(set(S))': u64\n-    [270; 273) 'set': fn set<S<u64>>(T) -> T\n+    [270; 273) 'set': fn set<S<u64>>(S<u64>) -> S<u64>\n     [270; 276) 'set(S)': S<u64>\n     [274; 275) 'S': S<u64>\n     \"###\n@@ -1332,7 +1537,7 @@ fn test() {\n     [173; 175) '{}': ()\n     [189; 308) '{     ... 1); }': ()\n     [199; 200) 'x': Option<u32>\n-    [203; 215) 'Option::Some': Some<u32>(T) -> Option<T>\n+    [203; 215) 'Option::Some': Some<u32>(u32) -> Option<u32>\n     [203; 221) 'Option...(1u32)': Option<u32>\n     [216; 220) '1u32': u32\n     [227; 228) 'x': Option<u32>\n@@ -1442,15 +1647,15 @@ fn test() {\n     [340; 342) '{}': ()\n     [356; 515) '{     ... S); }': ()\n     [366; 368) 'x1': u64\n-    [371; 375) 'foo1': fn foo1<S, u64, |S| -> u64>(T, F) -> U\n+    [371; 375) 'foo1': fn foo1<S, u64, |S| -> u64>(S, |S| -> u64) -> u64\n     [371; 394) 'foo1(S...hod())': u64\n     [376; 377) 'S': S\n     [379; 393) '|s| s.method()': |S| -> u64\n     [380; 381) 's': S\n     [383; 384) 's': S\n     [383; 393) 's.method()': u64\n     [404; 406) 'x2': u64\n-    [409; 413) 'foo2': fn foo2<S, u64, |S| -> u64>(F, T) -> U\n+    [409; 413) 'foo2': fn foo2<S, u64, |S| -> u64>(|S| -> u64, S) -> u64\n     [409; 432) 'foo2(|...(), S)': u64\n     [414; 428) '|s| s.method()': |S| -> u64\n     [415; 416) 's': S\n@@ -1603,7 +1808,6 @@ fn test<T, U>() where T: Trait<U::Item>, U: Trait<T::Item> {\n \n #[test]\n fn unify_impl_trait() {\n-    covers!(insert_vars_for_impl_trait);\n     assert_snapshot!(\n         infer_with_mismatches(r#\"\n trait Trait<T> {}\n@@ -1635,26 +1839,26 @@ fn test() -> impl Trait<i32> {\n     [172; 183) '{ loop {} }': T\n     [174; 181) 'loop {}': !\n     [179; 181) '{}': ()\n-    [214; 310) '{     ...t()) }': S<i32>\n+    [214; 310) '{     ...t()) }': S<{unknown}>\n     [224; 226) 's1': S<u32>\n-    [229; 230) 'S': S<u32>(T) -> S<T>\n+    [229; 230) 'S': S<u32>(u32) -> S<u32>\n     [229; 241) 'S(default())': S<u32>\n-    [231; 238) 'default': fn default<u32>() -> T\n+    [231; 238) 'default': fn default<u32>() -> u32\n     [231; 240) 'default()': u32\n-    [247; 250) 'foo': fn foo(impl Trait<u32>) -> ()\n+    [247; 250) 'foo': fn foo(S<u32>) -> ()\n     [247; 254) 'foo(s1)': ()\n     [251; 253) 's1': S<u32>\n     [264; 265) 'x': i32\n-    [273; 276) 'bar': fn bar<i32>(impl Trait<T>) -> T\n+    [273; 276) 'bar': fn bar<i32>(S<i32>) -> i32\n     [273; 290) 'bar(S(...lt()))': i32\n-    [277; 278) 'S': S<i32>(T) -> S<T>\n+    [277; 278) 'S': S<i32>(i32) -> S<i32>\n     [277; 289) 'S(default())': S<i32>\n-    [279; 286) 'default': fn default<i32>() -> T\n+    [279; 286) 'default': fn default<i32>() -> i32\n     [279; 288) 'default()': i32\n-    [296; 297) 'S': S<i32>(T) -> S<T>\n-    [296; 308) 'S(default())': S<i32>\n-    [298; 305) 'default': fn default<i32>() -> T\n-    [298; 307) 'default()': i32\n+    [296; 297) 'S': S<{unknown}>({unknown}) -> S<{unknown}>\n+    [296; 308) 'S(default())': S<{unknown}>\n+    [298; 305) 'default': fn default<{unknown}>() -> {unknown}\n+    [298; 307) 'default()': {unknown}\n     \"###\n     );\n }"}, {"sha": "88af61e87a17637799eca646752fa1ec2d9b5c90", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -50,10 +50,19 @@ impl TraitSolver {\n             Err(_) => ra_db::Canceled::throw(),\n         };\n \n+        let fuel = std::cell::Cell::new(CHALK_SOLVER_FUEL);\n+\n         let solution = panic::catch_unwind({\n             let solver = panic::AssertUnwindSafe(&mut solver);\n             let context = panic::AssertUnwindSafe(&context);\n-            move || solver.0.solve(context.0, goal)\n+            move || {\n+                solver.0.solve_limited(context.0, goal, || {\n+                    context.0.db.check_canceled();\n+                    let remaining = fuel.get();\n+                    fuel.set(remaining - 1);\n+                    remaining > 0\n+                })\n+            }\n         });\n \n         let solution = match solution {\n@@ -78,7 +87,9 @@ impl TraitSolver {\n /// This controls the maximum size of types Chalk considers. If we set this too\n /// high, we can run into slow edge cases; if we set it too low, Chalk won't\n /// find some solutions.\n-const CHALK_SOLVER_MAX_SIZE: usize = 4;\n+const CHALK_SOLVER_MAX_SIZE: usize = 10;\n+/// This controls how much 'time' we give the Chalk solver before giving up.\n+const CHALK_SOLVER_FUEL: i32 = 100;\n \n #[derive(Debug, Copy, Clone)]\n struct ChalkContext<'a, DB> {\n@@ -97,7 +108,8 @@ pub(crate) fn trait_solver_query(\n }\n \n fn create_chalk_solver() -> chalk_solve::Solver<TypeFamily> {\n-    let solver_choice = chalk_solve::SolverChoice::SLG { max_size: CHALK_SOLVER_MAX_SIZE };\n+    let solver_choice =\n+        chalk_solve::SolverChoice::SLG { max_size: CHALK_SOLVER_MAX_SIZE, expected_answers: None };\n     solver_choice.into_solver()\n }\n \n@@ -232,7 +244,6 @@ fn solution_from_chalk(\n     let convert_subst = |subst: chalk_ir::Canonical<chalk_ir::Substitution<TypeFamily>>| {\n         let value = subst\n             .value\n-            .parameters\n             .into_iter()\n             .map(|p| {\n                 let ty = match p.ty() {"}, {"sha": "4974c565be18e2eb03c6edc7e72a1da8f515c0f7", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 72, "deletions": 69, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -3,7 +3,7 @@ use std::{fmt, sync::Arc};\n \n use log::debug;\n \n-use chalk_ir::{cast::Cast, Parameter, PlaceholderIndex, TypeName, UniverseIndex};\n+use chalk_ir::{cast::Cast, GoalData, Parameter, PlaceholderIndex, TypeName, UniverseIndex};\n \n use hir_def::{AssocContainerId, AssocItemId, GenericDefId, HasModule, Lookup, TypeAliasId};\n use ra_db::{\n@@ -14,7 +14,7 @@ use ra_db::{\n use super::{builtin, AssocTyValue, Canonical, ChalkContext, Impl, Obligation};\n use crate::{\n     db::HirDatabase, display::HirDisplay, utils::generics, ApplicationTy, GenericPredicate,\n-    ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n+    ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n };\n \n #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]\n@@ -24,6 +24,8 @@ impl chalk_ir::family::TypeFamily for TypeFamily {\n     type InternedType = Box<chalk_ir::TyData<Self>>;\n     type InternedLifetime = chalk_ir::LifetimeData<Self>;\n     type InternedParameter = chalk_ir::ParameterData<Self>;\n+    type InternedGoal = Arc<GoalData<Self>>;\n+    type InternedSubstitution = Vec<Parameter<Self>>;\n     type DefId = InternId;\n \n     // FIXME: implement these\n@@ -48,8 +50,8 @@ impl chalk_ir::family::TypeFamily for TypeFamily {\n         None\n     }\n \n-    fn debug_projection(\n-        _projection: &chalk_ir::ProjectionTy<Self>,\n+    fn debug_alias(\n+        _projection: &chalk_ir::AliasTy<Self>,\n         _fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n         None\n@@ -78,6 +80,24 @@ impl chalk_ir::family::TypeFamily for TypeFamily {\n     fn parameter_data(parameter: &chalk_ir::ParameterData<Self>) -> &chalk_ir::ParameterData<Self> {\n         parameter\n     }\n+\n+    fn intern_goal(goal: GoalData<Self>) -> Arc<GoalData<Self>> {\n+        Arc::new(goal)\n+    }\n+\n+    fn goal_data(goal: &Arc<GoalData<Self>>) -> &GoalData<Self> {\n+        goal\n+    }\n+\n+    fn intern_substitution<E>(\n+        data: impl IntoIterator<Item = Result<Parameter<Self>, E>>,\n+    ) -> Result<Vec<Parameter<Self>>, E> {\n+        data.into_iter().collect()\n+    }\n+\n+    fn substitution_data(substitution: &Vec<Parameter<Self>>) -> &[Parameter<Self>] {\n+        substitution\n+    }\n }\n \n impl chalk_ir::family::HasTypeFamily for TypeFamily {\n@@ -114,17 +134,21 @@ impl ToChalk for Ty {\n         match self {\n             Ty::Apply(apply_ty) => {\n                 let name = apply_ty.ctor.to_chalk(db);\n-                let parameters = apply_ty.parameters.to_chalk(db);\n-                chalk_ir::ApplicationTy { name, parameters }.cast().intern()\n+                let substitution = apply_ty.parameters.to_chalk(db);\n+                chalk_ir::ApplicationTy { name, substitution }.cast().intern()\n             }\n             Ty::Projection(proj_ty) => {\n                 let associated_ty_id = proj_ty.associated_ty.to_chalk(db);\n-                let parameters = proj_ty.parameters.to_chalk(db);\n-                chalk_ir::ProjectionTy { associated_ty_id, parameters }.cast().intern()\n+                let substitution = proj_ty.parameters.to_chalk(db);\n+                chalk_ir::AliasTy { associated_ty_id, substitution }.cast().intern()\n             }\n-            Ty::Param { idx, .. } => {\n-                PlaceholderIndex { ui: UniverseIndex::ROOT, idx: idx as usize }\n-                    .to_ty::<TypeFamily>()\n+            Ty::Param(id) => {\n+                let interned_id = db.intern_type_param_id(id);\n+                PlaceholderIndex {\n+                    ui: UniverseIndex::ROOT,\n+                    idx: interned_id.as_intern_id().as_usize(),\n+                }\n+                .to_ty::<TypeFamily>()\n             }\n             Ty::Bound(idx) => chalk_ir::TyData::BoundVar(idx as usize).intern(),\n             Ty::Infer(_infer_ty) => panic!(\"uncanonicalized infer ty\"),\n@@ -135,23 +159,13 @@ impl ToChalk for Ty {\n                     .cloned()\n                     .map(|p| p.to_chalk(db))\n                     .collect();\n-                let bounded_ty = chalk_ir::BoundedTy { bounds: make_binders(where_clauses, 1) };\n+                let bounded_ty = chalk_ir::DynTy { bounds: make_binders(where_clauses, 1) };\n                 chalk_ir::TyData::Dyn(bounded_ty).intern()\n             }\n-            Ty::Opaque(predicates) => {\n-                let where_clauses = predicates\n-                    .iter()\n-                    .filter(|p| !p.is_error())\n-                    .cloned()\n-                    .map(|p| p.to_chalk(db))\n-                    .collect();\n-                let bounded_ty = chalk_ir::BoundedTy { bounds: make_binders(where_clauses, 1) };\n-                chalk_ir::TyData::Opaque(bounded_ty).intern()\n-            }\n-            Ty::Unknown => {\n-                let parameters = Vec::new();\n+            Ty::Opaque(_) | Ty::Unknown => {\n+                let substitution = chalk_ir::Substitution::empty();\n                 let name = TypeName::Error;\n-                chalk_ir::ApplicationTy { name, parameters }.cast().intern()\n+                chalk_ir::ApplicationTy { name, substitution }.cast().intern()\n             }\n         }\n     }\n@@ -161,20 +175,23 @@ impl ToChalk for Ty {\n                 TypeName::Error => Ty::Unknown,\n                 _ => {\n                     let ctor = from_chalk(db, apply_ty.name);\n-                    let parameters = from_chalk(db, apply_ty.parameters);\n+                    let parameters = from_chalk(db, apply_ty.substitution);\n                     Ty::Apply(ApplicationTy { ctor, parameters })\n                 }\n             },\n             chalk_ir::TyData::Placeholder(idx) => {\n                 assert_eq!(idx.ui, UniverseIndex::ROOT);\n-                Ty::Param { idx: idx.idx as u32, name: crate::Name::missing() }\n+                let interned_id = crate::db::GlobalTypeParamId::from_intern_id(\n+                    crate::salsa::InternId::from(idx.idx),\n+                );\n+                Ty::Param(db.lookup_intern_type_param_id(interned_id))\n             }\n-            chalk_ir::TyData::Projection(proj) => {\n+            chalk_ir::TyData::Alias(proj) => {\n                 let associated_ty = from_chalk(db, proj.associated_ty_id);\n-                let parameters = from_chalk(db, proj.parameters);\n+                let parameters = from_chalk(db, proj.substitution);\n                 Ty::Projection(ProjectionTy { associated_ty, parameters })\n             }\n-            chalk_ir::TyData::ForAll(_) => unimplemented!(),\n+            chalk_ir::TyData::Function(_) => unimplemented!(),\n             chalk_ir::TyData::BoundVar(idx) => Ty::Bound(idx as u32),\n             chalk_ir::TyData::InferenceVar(_iv) => Ty::Unknown,\n             chalk_ir::TyData::Dyn(where_clauses) => {\n@@ -183,27 +200,18 @@ impl ToChalk for Ty {\n                     where_clauses.bounds.value.into_iter().map(|c| from_chalk(db, c)).collect();\n                 Ty::Dyn(predicates)\n             }\n-            chalk_ir::TyData::Opaque(where_clauses) => {\n-                assert_eq!(where_clauses.bounds.binders.len(), 1);\n-                let predicates =\n-                    where_clauses.bounds.value.into_iter().map(|c| from_chalk(db, c)).collect();\n-                Ty::Opaque(predicates)\n-            }\n         }\n     }\n }\n \n impl ToChalk for Substs {\n-    type Chalk = Vec<chalk_ir::Parameter<TypeFamily>>;\n+    type Chalk = chalk_ir::Substitution<TypeFamily>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> Vec<Parameter<TypeFamily>> {\n-        self.iter().map(|ty| ty.clone().to_chalk(db).cast()).collect()\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Substitution<TypeFamily> {\n+        chalk_ir::Substitution::from(self.iter().map(|ty| ty.clone().to_chalk(db)))\n     }\n \n-    fn from_chalk(\n-        db: &impl HirDatabase,\n-        parameters: Vec<chalk_ir::Parameter<TypeFamily>>,\n-    ) -> Substs {\n+    fn from_chalk(db: &impl HirDatabase, parameters: chalk_ir::Substitution<TypeFamily>) -> Substs {\n         let tys = parameters\n             .into_iter()\n             .map(|p| match p.ty() {\n@@ -220,13 +228,13 @@ impl ToChalk for TraitRef {\n \n     fn to_chalk(self: TraitRef, db: &impl HirDatabase) -> chalk_ir::TraitRef<TypeFamily> {\n         let trait_id = self.trait_.to_chalk(db);\n-        let parameters = self.substs.to_chalk(db);\n-        chalk_ir::TraitRef { trait_id, parameters }\n+        let substitution = self.substs.to_chalk(db);\n+        chalk_ir::TraitRef { trait_id, substitution }\n     }\n \n     fn from_chalk(db: &impl HirDatabase, trait_ref: chalk_ir::TraitRef<TypeFamily>) -> Self {\n         let trait_ = from_chalk(db, trait_ref.trait_id);\n-        let substs = from_chalk(db, trait_ref.parameters);\n+        let substs = from_chalk(db, trait_ref.substitution);\n         TraitRef { trait_, substs }\n     }\n }\n@@ -317,8 +325,8 @@ impl ToChalk for GenericPredicate {\n                 make_binders(chalk_ir::WhereClause::Implemented(trait_ref.to_chalk(db)), 0)\n             }\n             GenericPredicate::Projection(projection_pred) => make_binders(\n-                chalk_ir::WhereClause::ProjectionEq(chalk_ir::ProjectionEq {\n-                    projection: projection_pred.projection_ty.to_chalk(db),\n+                chalk_ir::WhereClause::AliasEq(chalk_ir::AliasEq {\n+                    alias: projection_pred.projection_ty.to_chalk(db),\n                     ty: projection_pred.ty.to_chalk(db),\n                 }),\n                 0,\n@@ -335,8 +343,8 @@ impl ToChalk for GenericPredicate {\n             chalk_ir::WhereClause::Implemented(tr) => {\n                 GenericPredicate::Implemented(from_chalk(db, tr))\n             }\n-            chalk_ir::WhereClause::ProjectionEq(projection_eq) => {\n-                let projection_ty = from_chalk(db, projection_eq.projection);\n+            chalk_ir::WhereClause::AliasEq(projection_eq) => {\n+                let projection_ty = from_chalk(db, projection_eq.alias);\n                 let ty = from_chalk(db, projection_eq.ty);\n                 GenericPredicate::Projection(super::ProjectionPredicate { projection_ty, ty })\n             }\n@@ -345,22 +353,22 @@ impl ToChalk for GenericPredicate {\n }\n \n impl ToChalk for ProjectionTy {\n-    type Chalk = chalk_ir::ProjectionTy<TypeFamily>;\n+    type Chalk = chalk_ir::AliasTy<TypeFamily>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::ProjectionTy<TypeFamily> {\n-        chalk_ir::ProjectionTy {\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::AliasTy<TypeFamily> {\n+        chalk_ir::AliasTy {\n             associated_ty_id: self.associated_ty.to_chalk(db),\n-            parameters: self.parameters.to_chalk(db),\n+            substitution: self.parameters.to_chalk(db),\n         }\n     }\n \n     fn from_chalk(\n         db: &impl HirDatabase,\n-        projection_ty: chalk_ir::ProjectionTy<TypeFamily>,\n+        projection_ty: chalk_ir::AliasTy<TypeFamily>,\n     ) -> ProjectionTy {\n         ProjectionTy {\n             associated_ty: from_chalk(db, projection_ty.associated_ty_id),\n-            parameters: from_chalk(db, projection_ty.parameters),\n+            parameters: from_chalk(db, projection_ty.substitution),\n         }\n     }\n }\n@@ -369,10 +377,7 @@ impl ToChalk for super::ProjectionPredicate {\n     type Chalk = chalk_ir::Normalize<TypeFamily>;\n \n     fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Normalize<TypeFamily> {\n-        chalk_ir::Normalize {\n-            projection: self.projection_ty.to_chalk(db),\n-            ty: self.ty.to_chalk(db),\n-        }\n+        chalk_ir::Normalize { alias: self.projection_ty.to_chalk(db), ty: self.ty.to_chalk(db) }\n     }\n \n     fn from_chalk(_db: &impl HirDatabase, _normalize: chalk_ir::Normalize<TypeFamily>) -> Self {\n@@ -522,7 +527,7 @@ fn convert_where_clauses(\n     let generic_predicates = db.generic_predicates(def);\n     let mut result = Vec::with_capacity(generic_predicates.len());\n     for pred in generic_predicates.iter() {\n-        if pred.is_error() {\n+        if pred.value.is_error() {\n             // skip errored predicates completely\n             continue;\n         }\n@@ -711,12 +716,12 @@ fn impl_block_datum(\n     let trait_ref = db\n         .impl_trait(impl_id)\n         // ImplIds for impls where the trait ref can't be resolved should never reach Chalk\n-        .expect(\"invalid impl passed to Chalk\");\n+        .expect(\"invalid impl passed to Chalk\")\n+        .value;\n     let impl_data = db.impl_data(impl_id);\n \n     let generic_params = generics(db, impl_id.into());\n     let bound_vars = Substs::bound_vars(&generic_params);\n-    let trait_ref = trait_ref.subst(&bound_vars);\n     let trait_ = trait_ref.trait_;\n     let impl_type = if impl_id.lookup(db).container.module(db).krate == krate {\n         chalk_rust_ir::ImplType::Local\n@@ -791,20 +796,18 @@ fn type_alias_associated_ty_value(\n         _ => panic!(\"assoc ty value should be in impl\"),\n     };\n \n-    let trait_ref = db.impl_trait(impl_id).expect(\"assoc ty value should not exist\"); // we don't return any assoc ty values if the impl'd trait can't be resolved\n+    let trait_ref = db.impl_trait(impl_id).expect(\"assoc ty value should not exist\").value; // we don't return any assoc ty values if the impl'd trait can't be resolved\n \n     let assoc_ty = db\n         .trait_data(trait_ref.trait_)\n         .associated_type_by_name(&type_alias_data.name)\n         .expect(\"assoc ty value should not exist\"); // validated when building the impl data as well\n-    let generic_params = generics(db, impl_id.into());\n-    let bound_vars = Substs::bound_vars(&generic_params);\n-    let ty = db.ty(type_alias.into()).subst(&bound_vars);\n-    let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: ty.to_chalk(db) };\n+    let ty = db.ty(type_alias.into());\n+    let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: ty.value.to_chalk(db) };\n     let value = chalk_rust_ir::AssociatedTyValue {\n         impl_id: Impl::ImplBlock(impl_id.into()).to_chalk(db),\n         associated_ty_id: assoc_ty.to_chalk(db),\n-        value: make_binders(value_bound, bound_vars.len()),\n+        value: make_binders(value_bound, ty.num_binders),\n     };\n     Arc::new(value)\n }"}, {"sha": "508ae90465d7a9f8fcaa2547713fe7cef0b9001f", "filename": "crates/ra_hir_ty/src/utils.rs", "status": "modified", "additions": 68, "deletions": 23, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Futils.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -2,10 +2,11 @@\n //! query, but can't be computed directly from `*Data` (ie, which need a `db`).\n use std::sync::Arc;\n \n+use hir_def::generics::WherePredicateTarget;\n use hir_def::{\n     adt::VariantData,\n     db::DefDatabase,\n-    generics::{GenericParams, TypeParamData},\n+    generics::{GenericParams, TypeParamData, TypeParamProvenance},\n     path::Path,\n     resolver::{HasResolver, TypeNs},\n     type_ref::TypeRef,\n@@ -19,11 +20,18 @@ fn direct_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n     // lifetime problems, but since there usually shouldn't be more than a\n     // few direct traits this should be fine (we could even use some kind of\n     // SmallVec if performance is a concern)\n-    db.generic_params(trait_.into())\n+    let generic_params = db.generic_params(trait_.into());\n+    let trait_self = generic_params.find_trait_self_param();\n+    generic_params\n         .where_predicates\n         .iter()\n-        .filter_map(|pred| match &pred.type_ref {\n-            TypeRef::Path(p) if p == &Path::from(name![Self]) => pred.bound.as_path(),\n+        .filter_map(|pred| match &pred.target {\n+            WherePredicateTarget::TypeRef(TypeRef::Path(p)) if p == &Path::from(name![Self]) => {\n+                pred.bound.as_path()\n+            }\n+            WherePredicateTarget::TypeParam(local_id) if Some(*local_id) == trait_self => {\n+                pred.bound.as_path()\n+            }\n             _ => None,\n         })\n         .filter_map(|path| match resolver.resolve_path_in_type_ns_fully(db, path.mod_path()) {\n@@ -95,41 +103,77 @@ pub(crate) struct Generics {\n }\n \n impl Generics {\n-    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = (u32, &'a TypeParamData)> + 'a {\n+    pub(crate) fn iter<'a>(\n+        &'a self,\n+    ) -> impl Iterator<Item = (TypeParamId, &'a TypeParamData)> + 'a {\n         self.parent_generics\n             .as_ref()\n             .into_iter()\n-            .flat_map(|it| it.params.types.iter())\n-            .chain(self.params.types.iter())\n-            .enumerate()\n-            .map(|(i, (_local_id, p))| (i as u32, p))\n+            .flat_map(|it| {\n+                it.params\n+                    .types\n+                    .iter()\n+                    .map(move |(local_id, p)| (TypeParamId { parent: it.def, local_id }, p))\n+            })\n+            .chain(\n+                self.params\n+                    .types\n+                    .iter()\n+                    .map(move |(local_id, p)| (TypeParamId { parent: self.def, local_id }, p)),\n+            )\n     }\n \n-    pub(crate) fn iter_parent<'a>(&'a self) -> impl Iterator<Item = (u32, &'a TypeParamData)> + 'a {\n-        self.parent_generics\n-            .as_ref()\n-            .into_iter()\n-            .flat_map(|it| it.params.types.iter())\n-            .enumerate()\n-            .map(|(i, (_local_id, p))| (i as u32, p))\n+    pub(crate) fn iter_parent<'a>(\n+        &'a self,\n+    ) -> impl Iterator<Item = (TypeParamId, &'a TypeParamData)> + 'a {\n+        self.parent_generics.as_ref().into_iter().flat_map(|it| {\n+            it.params\n+                .types\n+                .iter()\n+                .map(move |(local_id, p)| (TypeParamId { parent: it.def, local_id }, p))\n+        })\n     }\n \n     pub(crate) fn len(&self) -> usize {\n         self.len_split().0\n     }\n+\n     /// (total, parents, child)\n     pub(crate) fn len_split(&self) -> (usize, usize, usize) {\n         let parent = self.parent_generics.as_ref().map_or(0, |p| p.len());\n         let child = self.params.types.len();\n         (parent + child, parent, child)\n     }\n-    pub(crate) fn param_idx(&self, param: TypeParamId) -> u32 {\n-        self.find_param(param).0\n+\n+    /// (parent total, self param, type param list, impl trait)\n+    pub(crate) fn provenance_split(&self) -> (usize, usize, usize, usize) {\n+        let parent = self.parent_generics.as_ref().map_or(0, |p| p.len());\n+        let self_params = self\n+            .params\n+            .types\n+            .iter()\n+            .filter(|(_, p)| p.provenance == TypeParamProvenance::TraitSelf)\n+            .count();\n+        let list_params = self\n+            .params\n+            .types\n+            .iter()\n+            .filter(|(_, p)| p.provenance == TypeParamProvenance::TypeParamList)\n+            .count();\n+        let impl_trait_params = self\n+            .params\n+            .types\n+            .iter()\n+            .filter(|(_, p)| p.provenance == TypeParamProvenance::ArgumentImplTrait)\n+            .count();\n+        (parent, self_params, list_params, impl_trait_params)\n     }\n-    pub(crate) fn param_name(&self, param: TypeParamId) -> Name {\n-        self.find_param(param).1.name.clone()\n+\n+    pub(crate) fn param_idx(&self, param: TypeParamId) -> Option<u32> {\n+        Some(self.find_param(param)?.0)\n     }\n-    fn find_param(&self, param: TypeParamId) -> (u32, &TypeParamData) {\n+\n+    fn find_param(&self, param: TypeParamId) -> Option<(u32, &TypeParamData)> {\n         if param.parent == self.def {\n             let (idx, (_local_id, data)) = self\n                 .params\n@@ -139,9 +183,10 @@ impl Generics {\n                 .find(|(_, (idx, _))| *idx == param.local_id)\n                 .unwrap();\n             let (_total, parent_len, _child) = self.len_split();\n-            return ((parent_len + idx) as u32, data);\n+            Some(((parent_len + idx) as u32, data))\n+        } else {\n+            self.parent_generics.as_ref().and_then(|g| g.find_param(param))\n         }\n-        self.parent_generics.as_ref().unwrap().find_param(param)\n     }\n }\n "}, {"sha": "9ace35229da7867fdc61efcbc6d9d188e3466190", "filename": "crates/ra_ide/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2FCargo.toml?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -28,6 +28,7 @@ once_cell = \"1.2.0\"\n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }\n ra_db = { path = \"../ra_db\" }\n+ra_ide_db = { path = \"../ra_ide_db\" }\n ra_cfg = { path = \"../ra_cfg\" }\n ra_fmt = { path = \"../ra_fmt\" }\n ra_prof = { path = \"../ra_prof\" }\n@@ -39,7 +40,7 @@ ra_assists = { path = \"../ra_assists\" }\n hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n \n [dev-dependencies]\n-insta = \"0.12.0\"\n+insta = \"0.13.0\"\n \n [dev-dependencies.proptest]\n version = \"0.9.0\""}, {"sha": "40d56a4f7b5382e6c0ccbe86a98a728552493918", "filename": "crates/ra_ide/src/assists.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fassists.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,40 +1,32 @@\n //! FIXME: write short doc here\n \n+use ra_assists::{resolved_assists, AssistAction, AssistLabel};\n use ra_db::{FilePosition, FileRange};\n+use ra_ide_db::RootDatabase;\n \n-use crate::{db::RootDatabase, FileId, SourceChange, SourceFileEdit};\n+use crate::{FileId, SourceChange, SourceFileEdit};\n \n-use either::Either;\n pub use ra_assists::AssistId;\n-use ra_assists::{AssistAction, AssistLabel};\n \n #[derive(Debug)]\n pub struct Assist {\n     pub id: AssistId,\n     pub label: String,\n-    pub change_data: Either<SourceChange, Vec<SourceChange>>,\n+    pub group_label: Option<String>,\n+    pub source_change: SourceChange,\n }\n \n pub(crate) fn assists(db: &RootDatabase, frange: FileRange) -> Vec<Assist> {\n-    ra_assists::assists(db, frange)\n+    resolved_assists(db, frange)\n         .into_iter()\n         .map(|assist| {\n             let file_id = frange.file_id;\n             let assist_label = &assist.label;\n             Assist {\n                 id: assist_label.id,\n                 label: assist_label.label.clone(),\n-                change_data: match assist.action_data {\n-                    Either::Left(action) => {\n-                        Either::Left(action_to_edit(action, file_id, assist_label))\n-                    }\n-                    Either::Right(actions) => Either::Right(\n-                        actions\n-                            .into_iter()\n-                            .map(|action| action_to_edit(action, file_id, assist_label))\n-                            .collect(),\n-                    ),\n-                },\n+                group_label: assist.group_label.map(|it| it.0),\n+                source_change: action_to_edit(assist.action, file_id, assist_label),\n             }\n         })\n         .collect()\n@@ -46,9 +38,6 @@ fn action_to_edit(\n     assist_label: &AssistLabel,\n ) -> SourceChange {\n     let file_edit = SourceFileEdit { file_id, edit: action.edit };\n-    SourceChange::source_file_edit(\n-        action.label.unwrap_or_else(|| assist_label.label.clone()),\n-        file_edit,\n-    )\n-    .with_cursor_opt(action.cursor_position.map(|offset| FilePosition { offset, file_id }))\n+    SourceChange::source_file_edit(assist_label.label.clone(), file_edit)\n+        .with_cursor_opt(action.cursor_position.map(|offset| FilePosition { offset, file_id }))\n }"}, {"sha": "f984f40ad70f26fd1eedb5c8ffa1646976fb34cc", "filename": "crates/ra_ide/src/call_hierarchy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_hierarchy.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -3,14 +3,14 @@\n use indexmap::IndexMap;\n \n use hir::db::AstDatabase;\n+use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     ast::{self, DocCommentsOwner},\n     match_ast, AstNode, TextRange,\n };\n \n use crate::{\n     call_info::FnCallNode,\n-    db::RootDatabase,\n     display::{ShortLabel, ToNav},\n     expand::descend_into_macros,\n     goto_definition, references, FilePosition, NavigationTarget, RangeInfo,"}, {"sha": "f2b29306e63eaae366c4107c25b27c17692572ee", "filename": "crates/ra_ide/src/call_info.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_info.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,15 +1,13 @@\n //! FIXME: write short doc here\n use hir::db::AstDatabase;\n+use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     ast::{self, ArgListOwner},\n     match_ast, AstNode, SyntaxNode,\n };\n-\n use test_utils::tested_by;\n \n-use crate::{\n-    db::RootDatabase, expand::descend_into_macros, CallInfo, FilePosition, FunctionSignature,\n-};\n+use crate::{expand::descend_into_macros, CallInfo, FilePosition, FunctionSignature};\n \n /// Computes parameter information for the given call expression.\n pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<CallInfo> {"}, {"sha": "4f24cd1f924d7b38aaae764e54821718adbf61c0", "filename": "crates/ra_ide/src/completion.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -18,6 +18,7 @@ mod complete_macro_in_item_position;\n mod complete_trait_impl;\n \n use ra_db::SourceDatabase;\n+use ra_ide_db::RootDatabase;\n \n #[cfg(test)]\n use crate::completion::completion_item::do_completion;\n@@ -26,7 +27,7 @@ use crate::{\n         completion_context::CompletionContext,\n         completion_item::{CompletionKind, Completions},\n     },\n-    db, FilePosition,\n+    FilePosition,\n };\n \n pub use crate::completion::completion_item::{\n@@ -55,7 +56,7 @@ pub use crate::completion::completion_item::{\n /// `foo` *should* be present among the completion variants. Filtering by\n /// identifier prefix/fuzzy match should be done higher in the stack, together\n /// with ordering of completions (currently this is done by the client).\n-pub(crate) fn completions(db: &db::RootDatabase, position: FilePosition) -> Option<Completions> {\n+pub(crate) fn completions(db: &RootDatabase, position: FilePosition) -> Option<Completions> {\n     let original_parse = db.parse(position.file_id);\n     let ctx = CompletionContext::new(db, &original_parse, position)?;\n "}, {"sha": "e2ee86dd15dd2c555d954834bdd2418f6881a10c", "filename": "crates/ra_ide/src/completion/complete_scope.rs", "status": "modified", "additions": 3, "deletions": 114, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,11 +1,6 @@\n //! FIXME: write short doc here\n \n-use ra_assists::auto_import_text_edit;\n-use ra_syntax::{ast, AstNode, SmolStr};\n-use ra_text_edit::TextEditBuilder;\n-use rustc_hash::FxHashMap;\n-\n-use crate::completion::{CompletionContext, CompletionItem, CompletionKind, Completions};\n+use crate::completion::{CompletionContext, Completions};\n \n pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) {\n     if !ctx.is_trivial_path {\n@@ -15,120 +10,14 @@ pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) {\n     ctx.analyzer.process_all_names(ctx.db, &mut |name, res| {\n         acc.add_resolution(ctx, name.to_string(), &res)\n     });\n-\n-    // auto-import\n-    // We fetch ident from the original file, because we need to pre-filter auto-imports\n-    if ast::NameRef::cast(ctx.token.parent()).is_some() {\n-        let import_resolver = ImportResolver::new();\n-        let import_names = import_resolver.all_names(ctx.token.text());\n-        import_names.into_iter().for_each(|(name, path)| {\n-            let edit = {\n-                let mut builder = TextEditBuilder::default();\n-                builder.replace(ctx.source_range(), name.to_string());\n-                auto_import_text_edit(\n-                    &ctx.token.parent(),\n-                    &ctx.token.parent(),\n-                    &path,\n-                    &mut builder,\n-                );\n-                builder.finish()\n-            };\n-\n-            // Hack: copied this check form conv.rs beacause auto import can produce edits\n-            // that invalidate assert in conv_with.\n-            if edit\n-                .as_atoms()\n-                .iter()\n-                .filter(|atom| !ctx.source_range().is_subrange(&atom.delete))\n-                .all(|atom| ctx.source_range().intersection(&atom.delete).is_none())\n-            {\n-                CompletionItem::new(\n-                    CompletionKind::Reference,\n-                    ctx.source_range(),\n-                    build_import_label(&name, &path),\n-                )\n-                .text_edit(edit)\n-                .add_to(acc);\n-            }\n-        });\n-    }\n-}\n-\n-fn build_import_label(name: &str, path: &[SmolStr]) -> String {\n-    let mut buf = String::with_capacity(64);\n-    buf.push_str(name);\n-    buf.push_str(\" (\");\n-    fmt_import_path(path, &mut buf);\n-    buf.push_str(\")\");\n-    buf\n-}\n-\n-fn fmt_import_path(path: &[SmolStr], buf: &mut String) {\n-    let mut segments = path.iter();\n-    if let Some(s) = segments.next() {\n-        buf.push_str(&s);\n-    }\n-    for s in segments {\n-        buf.push_str(\"::\");\n-        buf.push_str(&s);\n-    }\n-}\n-\n-#[derive(Debug, Clone, Default)]\n-pub(crate) struct ImportResolver {\n-    // todo: use fst crate or something like that\n-    dummy_names: Vec<(SmolStr, Vec<SmolStr>)>,\n-}\n-\n-impl ImportResolver {\n-    pub(crate) fn new() -> Self {\n-        let dummy_names = vec![\n-            (SmolStr::new(\"fmt\"), vec![SmolStr::new(\"std\"), SmolStr::new(\"fmt\")]),\n-            (SmolStr::new(\"io\"), vec![SmolStr::new(\"std\"), SmolStr::new(\"io\")]),\n-            (SmolStr::new(\"iter\"), vec![SmolStr::new(\"std\"), SmolStr::new(\"iter\")]),\n-            (SmolStr::new(\"hash\"), vec![SmolStr::new(\"std\"), SmolStr::new(\"hash\")]),\n-            (\n-                SmolStr::new(\"Debug\"),\n-                vec![SmolStr::new(\"std\"), SmolStr::new(\"fmt\"), SmolStr::new(\"Debug\")],\n-            ),\n-            (\n-                SmolStr::new(\"Display\"),\n-                vec![SmolStr::new(\"std\"), SmolStr::new(\"fmt\"), SmolStr::new(\"Display\")],\n-            ),\n-            (\n-                SmolStr::new(\"Hash\"),\n-                vec![SmolStr::new(\"std\"), SmolStr::new(\"hash\"), SmolStr::new(\"Hash\")],\n-            ),\n-            (\n-                SmolStr::new(\"Hasher\"),\n-                vec![SmolStr::new(\"std\"), SmolStr::new(\"hash\"), SmolStr::new(\"Hasher\")],\n-            ),\n-            (\n-                SmolStr::new(\"Iterator\"),\n-                vec![SmolStr::new(\"std\"), SmolStr::new(\"iter\"), SmolStr::new(\"Iterator\")],\n-            ),\n-        ];\n-\n-        ImportResolver { dummy_names }\n-    }\n-\n-    // Returns a map of importable items filtered by name.\n-    // The map associates item name with its full path.\n-    // todo: should return Resolutions\n-    pub(crate) fn all_names(&self, name: &str) -> FxHashMap<SmolStr, Vec<SmolStr>> {\n-        if name.len() > 1 {\n-            self.dummy_names.iter().filter(|(n, _)| n.contains(name)).cloned().collect()\n-        } else {\n-            FxHashMap::default()\n-        }\n-    }\n }\n \n #[cfg(test)]\n mod tests {\n-    use crate::completion::{do_completion, CompletionItem, CompletionKind};\n     use insta::assert_debug_snapshot;\n \n+    use crate::completion::{do_completion, CompletionItem, CompletionKind};\n+\n     fn do_reference_completion(code: &str) -> Vec<CompletionItem> {\n         do_completion(code, CompletionKind::Reference)\n     }"}, {"sha": "0175f5e55d61fbcd24df648d8356472004758561", "filename": "crates/ra_ide/src/completion/complete_trait_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -2,7 +2,7 @@ use crate::completion::{CompletionContext, Completions, CompletionItem, Completi\n \n use ra_syntax::ast::{self, NameOwner, AstNode};\n \n-use hir::{self, db::HirDatabase};\n+use hir::{self, db::HirDatabase, Docs};\n \n \n pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext) {"}, {"sha": "8678a3234f14f489e3eda4e6ce3019897f6d3f79", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,5 +1,6 @@\n //! FIXME: write short doc here\n \n+use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo::{find_covering_element, find_node_at_offset},\n     ast, AstNode, Parse, SourceFile,\n@@ -8,13 +9,13 @@ use ra_syntax::{\n };\n use ra_text_edit::AtomTextEdit;\n \n-use crate::{db, FilePosition};\n+use crate::FilePosition;\n \n /// `CompletionContext` is created early during completion to figure out, where\n /// exactly is the cursor, syntax-wise.\n #[derive(Debug)]\n pub(crate) struct CompletionContext<'a> {\n-    pub(super) db: &'a db::RootDatabase,\n+    pub(super) db: &'a RootDatabase,\n     pub(super) analyzer: hir::SourceAnalyzer,\n     pub(super) offset: TextUnit,\n     pub(super) token: SyntaxToken,\n@@ -49,7 +50,7 @@ pub(crate) struct CompletionContext<'a> {\n \n impl<'a> CompletionContext<'a> {\n     pub(super) fn new(\n-        db: &'a db::RootDatabase,\n+        db: &'a RootDatabase,\n         original_parse: &'a Parse<ast::SourceFile>,\n         position: FilePosition,\n     ) -> Option<CompletionContext<'a>> {"}, {"sha": "22bd497231afd258415726d32ea7f143a2bf6f43", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -5,6 +5,7 @@ use std::cell::RefCell;\n use hir::diagnostics::{AstDiagnostic, Diagnostic as _, DiagnosticSink};\n use itertools::Itertools;\n use ra_db::{RelativePath, SourceDatabase, SourceDatabaseExt};\n+use ra_ide_db::RootDatabase;\n use ra_prof::profile;\n use ra_syntax::{\n     algo,\n@@ -13,7 +14,7 @@ use ra_syntax::{\n };\n use ra_text_edit::{TextEdit, TextEditBuilder};\n \n-use crate::{db::RootDatabase, Diagnostic, FileId, FileSystemEdit, SourceChange, SourceFileEdit};\n+use crate::{Diagnostic, FileId, FileSystemEdit, SourceChange, SourceFileEdit};\n \n #[derive(Debug, Copy, Clone)]\n pub enum Severity {"}, {"sha": "c23e08e9a31cf32dab16cd7a317c7b5f667e2cbb", "filename": "crates/ra_ide/src/display/function_signature.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -4,13 +4,11 @@ use std::fmt::{self, Display};\n \n use hir::{Docs, Documentation, HasSource, HirDisplay};\n use join_to_string::join;\n+use ra_ide_db::RootDatabase;\n use ra_syntax::ast::{self, AstNode, NameOwner, VisibilityOwner};\n use std::convert::From;\n \n-use crate::{\n-    db,\n-    display::{generic_parameters, where_predicates},\n-};\n+use crate::display::{generic_parameters, where_predicates};\n \n #[derive(Debug)]\n pub enum CallableKind {\n@@ -48,13 +46,13 @@ impl FunctionSignature {\n         self\n     }\n \n-    pub(crate) fn from_hir(db: &db::RootDatabase, function: hir::Function) -> Self {\n+    pub(crate) fn from_hir(db: &RootDatabase, function: hir::Function) -> Self {\n         let doc = function.docs(db);\n         let ast_node = function.source(db).value;\n         FunctionSignature::from(&ast_node).with_doc_opt(doc)\n     }\n \n-    pub(crate) fn from_struct(db: &db::RootDatabase, st: hir::Struct) -> Option<Self> {\n+    pub(crate) fn from_struct(db: &RootDatabase, st: hir::Struct) -> Option<Self> {\n         let node: ast::StructDef = st.source(db).value;\n         match node.kind() {\n             ast::StructKind::Record(_) => return None,\n@@ -86,10 +84,7 @@ impl FunctionSignature {\n         )\n     }\n \n-    pub(crate) fn from_enum_variant(\n-        db: &db::RootDatabase,\n-        variant: hir::EnumVariant,\n-    ) -> Option<Self> {\n+    pub(crate) fn from_enum_variant(db: &RootDatabase, variant: hir::EnumVariant) -> Option<Self> {\n         let node: ast::EnumVariant = variant.source(db).value;\n         match node.kind() {\n             ast::StructKind::Record(_) | ast::StructKind::Unit => return None,\n@@ -126,7 +121,7 @@ impl FunctionSignature {\n         )\n     }\n \n-    pub(crate) fn from_macro(db: &db::RootDatabase, macro_def: hir::MacroDef) -> Option<Self> {\n+    pub(crate) fn from_macro(db: &RootDatabase, macro_def: hir::MacroDef) -> Option<Self> {\n         let node: ast::MacroCall = macro_def.source(db).value;\n \n         let params = vec![];"}, {"sha": "906aab1eba92b0f9d07eb4c4605d3c61617a1755", "filename": "crates/ra_ide/src/display/navigation_target.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -3,14 +3,15 @@\n use either::Either;\n use hir::{AssocItem, FieldSource, HasSource, InFile, ModuleSource};\n use ra_db::{FileId, SourceDatabase};\n+use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     ast::{self, DocCommentsOwner, NameOwner},\n     match_ast, AstNode, SmolStr,\n     SyntaxKind::{self, BIND_PAT, TYPE_PARAM},\n     TextRange,\n };\n \n-use crate::{db::RootDatabase, expand::original_range, FileSymbol};\n+use crate::{expand::original_range, FileSymbol};\n \n use super::short_label::ShortLabel;\n "}, {"sha": "9f3aaa3a3fcca75effa1056c944f10612a72b292", "filename": "crates/ra_ide/src/expand.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fexpand.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -3,9 +3,10 @@ use std::iter::successors;\n \n use hir::{InFile, Origin};\n use ra_db::FileId;\n+use ra_ide_db::RootDatabase;\n use ra_syntax::{ast, AstNode, SyntaxNode, SyntaxToken, TextRange};\n \n-use crate::{db::RootDatabase, FileRange};\n+use crate::FileRange;\n \n pub(crate) fn original_range(db: &RootDatabase, node: InFile<&SyntaxNode>) -> FileRange {\n     if let Some((range, Origin::Call)) = original_range_and_origin(db, node) {\n@@ -79,6 +80,14 @@ pub(crate) fn descend_into_macros(\n     let source_analyzer =\n         hir::SourceAnalyzer::new(db, src.with_value(src.value.parent()).as_ref(), None);\n \n+    descend_into_macros_with_analyzer(db, &source_analyzer, src)\n+}\n+\n+pub(crate) fn descend_into_macros_with_analyzer(\n+    db: &RootDatabase,\n+    source_analyzer: &hir::SourceAnalyzer,\n+    src: InFile<SyntaxToken>,\n+) -> InFile<SyntaxToken> {\n     successors(Some(src), |token| {\n         let macro_call = token.value.ancestors().find_map(ast::MacroCall::cast)?;\n         let tt = macro_call.token_tree()?;"}, {"sha": "af2783befb3d1e3f123fdcfa2b838f2248d8d283", "filename": "crates/ra_ide/src/expand_macro.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,14 +1,15 @@\n //! This modules implements \"expand macro\" functionality in the IDE\n \n-use crate::{db::RootDatabase, FilePosition};\n use hir::db::AstDatabase;\n use ra_db::SourceDatabase;\n-use rustc_hash::FxHashMap;\n-\n+use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo::{find_node_at_offset, replace_descendants},\n     ast, AstNode, NodeOrToken, SyntaxElement, SyntaxKind, SyntaxNode, WalkEvent, T,\n };\n+use rustc_hash::FxHashMap;\n+\n+use crate::FilePosition;\n \n pub struct ExpandedMacro {\n     pub name: String,\n@@ -185,15 +186,15 @@ fn some_thing() -> u32 {\n         //- /lib.rs\n         macro_rules! match_ast {\n             (match $node:ident { $($tt:tt)* }) => { match_ast!(match ($node) { $($tt)* }) };\n-        \n+\n             (match ($node:expr) {\n                 $( ast::$ast:ident($it:ident) => $res:block, )*\n                 _ => $catch_all:expr $(,)?\n             }) => {{\n                 $( if let Some($it) = ast::$ast::cast($node.clone()) $res else )*\n                 { $catch_all }\n             }};\n-        }        \n+        }\n \n         fn main() {\n             mat<|>ch_ast! {\n@@ -227,11 +228,11 @@ fn some_thing() -> u32 {\n             r#\"\n         //- /lib.rs\n         macro_rules! match_ast {\n-            (match $node:ident { $($tt:tt)* }) => { match_ast!(match ($node) { $($tt)* }) };        \n+            (match $node:ident { $($tt:tt)* }) => { match_ast!(match ($node) { $($tt)* }) };\n             (match ($node:expr) {}) => {{}};\n-        }        \n+        }\n \n-        fn main() {        \n+        fn main() {\n             let p = f(|it| {\n                 let res = mat<|>ch_ast! { match c {}};\n                 Some(res)\n@@ -254,9 +255,9 @@ fn some_thing() -> u32 {\n         }\n         macro_rules! foo {\n             () => {bar!()};\n-        }        \n+        }\n \n-        fn main() {        \n+        fn main() {\n             let res = fo<|>o!();\n         }\n         \"#,\n@@ -277,9 +278,9 @@ fn some_thing() -> u32 {\n         }\n         macro_rules! foo {\n             () => {$crate::bar!()};\n-        }        \n+        }\n \n-        fn main() {        \n+        fn main() {\n             let res = fo<|>o!();\n         }\n         \"#,"}, {"sha": "726963a33e33fc2f7505f6f301624a64054d6c07", "filename": "crates/ra_ide/src/extend_selection.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,6 +1,10 @@\n //! FIXME: write short doc here\n \n+use std::iter::successors;\n+\n+use hir::db::AstDatabase;\n use ra_db::SourceDatabase;\n+use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo::find_covering_element,\n     ast::{self, AstNode, AstToken},\n@@ -9,9 +13,7 @@ use ra_syntax::{\n     SyntaxNode, SyntaxToken, TextRange, TextUnit, TokenAtOffset, T,\n };\n \n-use crate::{db::RootDatabase, expand::descend_into_macros, FileId, FileRange};\n-use hir::db::AstDatabase;\n-use std::iter::successors;\n+use crate::{expand::descend_into_macros, FileId, FileRange};\n \n pub(crate) fn extend_selection(db: &RootDatabase, frange: FileRange) -> TextRange {\n     let src = db.parse(frange.file_id).tree();\n@@ -512,8 +514,8 @@ fn bar(){}\n     fn test_extend_trait_bounds_list_in_where_clause() {\n         do_check(\n             r#\"\n-fn foo<R>() \n-    where \n+fn foo<R>()\n+    where\n         R: req::Request + 'static,\n         R::Params: DeserializeOwned<|> + panic::UnwindSafe + 'static,\n         R::Result: Serialize + 'static,"}, {"sha": "de5551a4c75df791e9d5436b54c255259c17332a", "filename": "crates/ra_ide/src/goto_definition.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,6 +1,7 @@\n //! FIXME: write short doc here\n \n use hir::{db::AstDatabase, InFile, SourceBinder};\n+use ra_ide_db::{symbol_index, RootDatabase};\n use ra_syntax::{\n     ast::{self, DocCommentsOwner},\n     match_ast, AstNode,\n@@ -9,7 +10,6 @@ use ra_syntax::{\n };\n \n use crate::{\n-    db::RootDatabase,\n     display::{ShortLabel, ToNav},\n     expand::descend_into_macros,\n     references::{classify_name_ref, NameKind::*},\n@@ -76,11 +76,10 @@ pub(crate) fn reference_definition(\n     let name_kind = classify_name_ref(sb, name_ref).map(|d| d.kind);\n     match name_kind {\n         Some(Macro(it)) => return Exact(it.to_nav(sb.db)),\n-        Some(Field(it)) => return Exact(it.to_nav(sb.db)),\n+        Some(StructField(it)) => return Exact(it.to_nav(sb.db)),\n         Some(TypeParam(it)) => return Exact(it.to_nav(sb.db)),\n-        Some(AssocItem(it)) => return Exact(it.to_nav(sb.db)),\n         Some(Local(it)) => return Exact(it.to_nav(sb.db)),\n-        Some(Def(def)) => match NavigationTarget::from_def(sb.db, def) {\n+        Some(ModuleDef(def)) => match NavigationTarget::from_def(sb.db, def) {\n             Some(nav) => return Exact(nav),\n             None => return Approximate(vec![]),\n         },\n@@ -94,7 +93,7 @@ pub(crate) fn reference_definition(\n     };\n \n     // Fallback index based approach:\n-    let navs = crate::symbol_index::index_resolve(sb.db, name_ref.value)\n+    let navs = symbol_index::index_resolve(sb.db, name_ref.value)\n         .into_iter()\n         .map(|s| s.to_nav(sb.db))\n         .collect();"}, {"sha": "11ad6d137213767afdc76d7dcf493bcbd6c96632", "filename": "crates/ra_ide/src/goto_type_definition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,11 +1,11 @@\n //! FIXME: write short doc here\n \n use hir::db::AstDatabase;\n+use ra_ide_db::RootDatabase;\n use ra_syntax::{ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset};\n \n use crate::{\n-    db::RootDatabase, display::ToNav, expand::descend_into_macros, FilePosition, NavigationTarget,\n-    RangeInfo,\n+    display::ToNav, expand::descend_into_macros, FilePosition, NavigationTarget, RangeInfo,\n };\n \n pub(crate) fn goto_type_definition("}, {"sha": "3f88bb260681dc2a768c3b56821f37f86d393645", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -2,6 +2,7 @@\n \n use hir::{db::AstDatabase, Adt, HasSource, HirDisplay, SourceBinder};\n use ra_db::SourceDatabase;\n+use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo::find_covering_element,\n     ast::{self, DocCommentsOwner},\n@@ -11,7 +12,6 @@ use ra_syntax::{\n };\n \n use crate::{\n-    db::RootDatabase,\n     display::{macro_label, rust_code_markup, rust_code_markup_with_doc, ShortLabel},\n     expand::descend_into_macros,\n     references::{classify_name, classify_name_ref, NameKind, NameKind::*},\n@@ -98,19 +98,14 @@ fn hover_text_from_name_kind(db: &RootDatabase, name_kind: NameKind) -> Option<S\n             let src = it.source(db);\n             hover_text(src.value.doc_comment_text(), Some(macro_label(&src.value)))\n         }\n-        Field(it) => {\n+        StructField(it) => {\n             let src = it.source(db);\n             match src.value {\n                 hir::FieldSource::Named(it) => hover_text(it.doc_comment_text(), it.short_label()),\n                 _ => None,\n             }\n         }\n-        AssocItem(it) => match it {\n-            hir::AssocItem::Function(it) => from_def_source(db, it),\n-            hir::AssocItem::Const(it) => from_def_source(db, it),\n-            hir::AssocItem::TypeAlias(it) => from_def_source(db, it),\n-        },\n-        Def(it) => match it {\n+        ModuleDef(it) => match it {\n             hir::ModuleDef::Module(it) => match it.definition_source(db).value {\n                 hir::ModuleSource::Module(it) => {\n                     hover_text(it.doc_comment_text(), it.short_label())"}, {"sha": "64a2dadc85eb603757a1cf4fe65efd1d598ccd88", "filename": "crates/ra_ide/src/impls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fimpls.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -2,9 +2,10 @@\n \n use hir::{Crate, ImplBlock, SourceBinder};\n use ra_db::SourceDatabase;\n+use ra_ide_db::RootDatabase;\n use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n \n-use crate::{db::RootDatabase, display::ToNav, FilePosition, NavigationTarget, RangeInfo};\n+use crate::{display::ToNav, FilePosition, NavigationTarget, RangeInfo};\n \n pub(crate) fn goto_implementation(\n     db: &RootDatabase,"}, {"sha": "6b0d3d996fac2c5e49f7ec977d3b20b749f00f8b", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -2,13 +2,14 @@\n \n use hir::{HirDisplay, SourceAnalyzer, SourceBinder};\n use once_cell::unsync::Lazy;\n+use ra_ide_db::RootDatabase;\n use ra_prof::profile;\n use ra_syntax::{\n     ast::{self, ArgListOwner, AstNode, TypeAscriptionOwner},\n     match_ast, SmolStr, SourceFile, SyntaxKind, SyntaxNode, TextRange,\n };\n \n-use crate::{db::RootDatabase, FileId, FunctionSignature};\n+use crate::{FileId, FunctionSignature};\n \n #[derive(Debug, PartialEq, Eq)]\n pub enum InlayKind {\n@@ -376,7 +377,7 @@ fn main() {\n     let mut start = 0;\n     (0..2).for_each(|increment| {\n         start += increment;\n-    })\n+    });\n \n     let multiply = |a, b, c, d| a * b * c * d;\n     let _: i32 = multiply(1, 2, 3, 4);\n@@ -399,37 +400,37 @@ fn main() {\n                 label: \"i32\",\n             },\n             InlayHint {\n-                range: [114; 122),\n+                range: [115; 123),\n                 kind: TypeHint,\n                 label: \"|\u2026| -> i32\",\n             },\n             InlayHint {\n-                range: [126; 127),\n+                range: [127; 128),\n                 kind: TypeHint,\n                 label: \"i32\",\n             },\n             InlayHint {\n-                range: [129; 130),\n+                range: [130; 131),\n                 kind: TypeHint,\n                 label: \"i32\",\n             },\n             InlayHint {\n-                range: [132; 133),\n+                range: [133; 134),\n                 kind: TypeHint,\n                 label: \"i32\",\n             },\n             InlayHint {\n-                range: [135; 136),\n+                range: [136; 137),\n                 kind: TypeHint,\n                 label: \"i32\",\n             },\n             InlayHint {\n-                range: [200; 212),\n+                range: [201; 213),\n                 kind: TypeHint,\n                 label: \"&|\u2026| -> i32\",\n             },\n             InlayHint {\n-                range: [235; 244),\n+                range: [236; 245),\n                 kind: TypeHint,\n                 label: \"|| -> i32\",\n             },"}, {"sha": "689921f3f235666208d7f666d689ee2308db6a6a", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 94, "deletions": 56, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -10,12 +10,8 @@\n // For proving that RootDatabase is RefUnwindSafe.\n #![recursion_limit = \"128\"]\n \n-mod db;\n pub mod mock_analysis;\n-mod symbol_index;\n-mod change;\n mod source_change;\n-mod feature_flags;\n \n mod status;\n mod completion;\n@@ -34,14 +30,11 @@ mod assists;\n mod diagnostics;\n mod syntax_tree;\n mod folding_ranges;\n-mod line_index;\n-mod line_index_utils;\n mod join_lines;\n mod typing;\n mod matching_brace;\n mod display;\n mod inlay_hints;\n-mod wasm_shims;\n mod expand;\n mod expand_macro;\n \n@@ -57,24 +50,24 @@ use ra_db::{\n     salsa::{self, ParallelDatabase},\n     CheckCanceled, Env, FileLoader, SourceDatabase,\n };\n+use ra_ide_db::{\n+    symbol_index::{self, FileSymbol},\n+    LineIndexDatabase,\n+};\n use ra_syntax::{SourceFile, TextRange, TextUnit};\n \n-use crate::{db::LineIndexDatabase, display::ToNav, symbol_index::FileSymbol};\n+use crate::display::ToNav;\n \n pub use crate::{\n     assists::{Assist, AssistId},\n     call_hierarchy::CallItem,\n-    change::{AnalysisChange, LibraryData},\n     completion::{CompletionItem, CompletionItemKind, InsertTextFormat},\n     diagnostics::Severity,\n     display::{file_structure, FunctionSignature, NavigationTarget, StructureNode},\n     expand_macro::ExpandedMacro,\n-    feature_flags::FeatureFlags,\n     folding_ranges::{Fold, FoldKind},\n     hover::HoverResult,\n     inlay_hints::{InlayHint, InlayKind},\n-    line_index::{LineCol, LineIndex},\n-    line_index_utils::translate_offset_with_edit,\n     references::{\n         Declaration, Reference, ReferenceAccess, ReferenceKind, ReferenceSearchResult, SearchScope,\n     },\n@@ -87,6 +80,14 @@ pub use hir::Documentation;\n pub use ra_db::{\n     Canceled, CrateGraph, CrateId, Edition, FileId, FilePosition, FileRange, SourceRootId,\n };\n+pub use ra_ide_db::{\n+    change::{AnalysisChange, LibraryData},\n+    feature_flags::FeatureFlags,\n+    line_index::{LineCol, LineIndex},\n+    line_index_utils::translate_offset_with_edit,\n+    symbol_index::Query,\n+    RootDatabase,\n+};\n \n pub type Cancelable<T> = Result<T, Canceled>;\n \n@@ -98,46 +99,6 @@ pub struct Diagnostic {\n     pub severity: Severity,\n }\n \n-#[derive(Debug)]\n-pub struct Query {\n-    query: String,\n-    lowercased: String,\n-    only_types: bool,\n-    libs: bool,\n-    exact: bool,\n-    limit: usize,\n-}\n-\n-impl Query {\n-    pub fn new(query: String) -> Query {\n-        let lowercased = query.to_lowercase();\n-        Query {\n-            query,\n-            lowercased,\n-            only_types: false,\n-            libs: false,\n-            exact: false,\n-            limit: usize::max_value(),\n-        }\n-    }\n-\n-    pub fn only_types(&mut self) {\n-        self.only_types = true;\n-    }\n-\n-    pub fn libs(&mut self) {\n-        self.libs = true;\n-    }\n-\n-    pub fn exact(&mut self) {\n-        self.exact = true;\n-    }\n-\n-    pub fn limit(&mut self, limit: usize) {\n-        self.limit = limit\n-    }\n-}\n-\n /// Info associated with a text range.\n #[derive(Debug)]\n pub struct RangeInfo<T> {\n@@ -162,7 +123,7 @@ pub struct CallInfo {\n /// `AnalysisHost` stores the current state of the world.\n #[derive(Debug)]\n pub struct AnalysisHost {\n-    db: db::RootDatabase,\n+    db: RootDatabase,\n }\n \n impl Default for AnalysisHost {\n@@ -173,7 +134,7 @@ impl Default for AnalysisHost {\n \n impl AnalysisHost {\n     pub fn new(lru_capcity: Option<usize>, feature_flags: FeatureFlags) -> AnalysisHost {\n-        AnalysisHost { db: db::RootDatabase::new(lru_capcity, feature_flags) }\n+        AnalysisHost { db: RootDatabase::new(lru_capcity, feature_flags) }\n     }\n     /// Returns a snapshot of the current state, which you can query for\n     /// semantic information.\n@@ -202,6 +163,9 @@ impl AnalysisHost {\n     pub fn per_query_memory_usage(&mut self) -> Vec<(String, ra_prof::Bytes)> {\n         self.db.per_query_memory_usage()\n     }\n+    pub fn request_cancellation(&mut self) {\n+        self.db.request_cancellation();\n+    }\n     pub fn raw_database(\n         &self,\n     ) -> &(impl hir::db::HirDatabase + salsa::Database + ra_db::SourceDatabaseExt) {\n@@ -220,7 +184,7 @@ impl AnalysisHost {\n /// `Analysis` are canceled (most method return `Err(Canceled)`).\n #[derive(Debug)]\n pub struct Analysis {\n-    db: salsa::Snapshot<db::RootDatabase>,\n+    db: salsa::Snapshot<RootDatabase>,\n }\n \n // As a general design guideline, `Analysis` API are intended to be independent\n@@ -501,7 +465,7 @@ impl Analysis {\n     }\n \n     /// Performs an operation on that may be Canceled.\n-    fn with_db<F: FnOnce(&db::RootDatabase) -> T + std::panic::UnwindSafe, T>(\n+    fn with_db<F: FnOnce(&RootDatabase) -> T + std::panic::UnwindSafe, T>(\n         &self,\n         f: F,\n     ) -> Cancelable<T> {\n@@ -514,3 +478,77 @@ fn analysis_is_send() {\n     fn is_send<T: Send>() {}\n     is_send::<Analysis>();\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{display::NavigationTarget, mock_analysis::single_file, Query};\n+    use ra_syntax::{\n+        SmolStr,\n+        SyntaxKind::{FN_DEF, STRUCT_DEF},\n+    };\n+\n+    #[test]\n+    fn test_world_symbols_with_no_container() {\n+        let code = r#\"\n+    enum FooInner { }\n+    \"#;\n+\n+        let mut symbols = get_symbols_matching(code, \"FooInner\");\n+\n+        let s = symbols.pop().unwrap();\n+\n+        assert_eq!(s.name(), \"FooInner\");\n+        assert!(s.container_name().is_none());\n+    }\n+\n+    #[test]\n+    fn test_world_symbols_include_container_name() {\n+        let code = r#\"\n+fn foo() {\n+    enum FooInner { }\n+}\n+    \"#;\n+\n+        let mut symbols = get_symbols_matching(code, \"FooInner\");\n+\n+        let s = symbols.pop().unwrap();\n+\n+        assert_eq!(s.name(), \"FooInner\");\n+        assert_eq!(s.container_name(), Some(&SmolStr::new(\"foo\")));\n+\n+        let code = r#\"\n+mod foo {\n+    struct FooInner;\n+}\n+    \"#;\n+\n+        let mut symbols = get_symbols_matching(code, \"FooInner\");\n+\n+        let s = symbols.pop().unwrap();\n+\n+        assert_eq!(s.name(), \"FooInner\");\n+        assert_eq!(s.container_name(), Some(&SmolStr::new(\"foo\")));\n+    }\n+\n+    #[test]\n+    fn test_world_symbols_are_case_sensitive() {\n+        let code = r#\"\n+fn foo() {}\n+\n+struct Foo;\n+        \"#;\n+\n+        let symbols = get_symbols_matching(code, \"Foo\");\n+\n+        let fn_match = symbols.iter().find(|s| s.name() == \"foo\").map(|s| s.kind());\n+        let struct_match = symbols.iter().find(|s| s.name() == \"Foo\").map(|s| s.kind());\n+\n+        assert_eq!(fn_match, Some(FN_DEF));\n+        assert_eq!(struct_match, Some(STRUCT_DEF));\n+    }\n+\n+    fn get_symbols_matching(text: &str, query: &str) -> Vec<NavigationTarget> {\n+        let (analysis, _) = single_file(text);\n+        analysis.symbol_search(Query::new(query.into())).unwrap()\n+    }\n+}"}, {"sha": "5bf4d20625210abe84796ce6cbabdbb71cfaa8f7", "filename": "crates/ra_ide/src/marks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmarks.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -11,4 +11,5 @@ test_utils::marks!(\n     call_info_bad_offset\n     dont_complete_current_use\n     dont_complete_primitive_in_use\n+    test_resolve_parent_module_on_module_decl\n );"}, {"sha": "081aaee8c92270c732483b407b9ffbe0636615f8", "filename": "crates/ra_ide/src/mock_analysis.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -3,7 +3,7 @@\n use std::sync::Arc;\n \n use ra_cfg::CfgOptions;\n-use ra_db::{Env, RelativePathBuf};\n+use ra_db::{CrateName, Env, RelativePathBuf};\n use test_utils::{extract_offset, extract_range, parse_fixture, CURSOR_MARKER};\n \n use crate::{\n@@ -107,7 +107,9 @@ impl MockAnalysis {\n                     crate_graph.add_crate_root(file_id, Edition2018, cfg_options, Env::default());\n                 let crate_name = path.parent().unwrap().file_name().unwrap();\n                 if let Some(root_crate) = root_crate {\n-                    crate_graph.add_dep(root_crate, crate_name.into(), other_crate).unwrap();\n+                    crate_graph\n+                        .add_dep(root_crate, CrateName::new(crate_name).unwrap(), other_crate)\n+                        .unwrap();\n                 }\n             }\n             change.add_file(source_root, file_id, path, Arc::new(contents));"}, {"sha": "af14d6ab3a620f8771bb537b7e5f651dd2e908a6", "filename": "crates/ra_ide/src/parent_module.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fparent_module.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,19 +1,35 @@\n //! FIXME: write short doc here\n \n use ra_db::{CrateId, FileId, FilePosition, SourceDatabase};\n+use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo::find_node_at_offset,\n     ast::{self, AstNode},\n };\n+use test_utils::tested_by;\n \n-use crate::{db::RootDatabase, NavigationTarget};\n+use crate::NavigationTarget;\n \n /// This returns `Vec` because a module may be included from several places. We\n /// don't handle this case yet though, so the Vec has length at most one.\n pub(crate) fn parent_module(db: &RootDatabase, position: FilePosition) -> Vec<NavigationTarget> {\n     let mut sb = hir::SourceBinder::new(db);\n     let parse = db.parse(position.file_id);\n-    let module = match find_node_at_offset::<ast::Module>(parse.tree().syntax(), position.offset) {\n+\n+    let mut module = find_node_at_offset::<ast::Module>(parse.tree().syntax(), position.offset);\n+\n+    // If cursor is literally on `mod foo`, go to the grandpa.\n+    if let Some(m) = &module {\n+        if !m\n+            .item_list()\n+            .map_or(false, |it| it.syntax().text_range().contains_inclusive(position.offset))\n+        {\n+            tested_by!(test_resolve_parent_module_on_module_decl);\n+            module = m.syntax().ancestors().skip(1).find_map(ast::Module::cast);\n+        }\n+    }\n+\n+    let module = match module {\n         Some(module) => sb.to_def(hir::InFile::new(position.file_id.into(), module)),\n         None => sb.to_module_def(position.file_id),\n     };\n@@ -40,6 +56,7 @@ pub(crate) fn crate_for(db: &RootDatabase, file_id: FileId) -> Vec<CrateId> {\n mod tests {\n     use ra_cfg::CfgOptions;\n     use ra_db::Env;\n+    use test_utils::covers;\n \n     use crate::{\n         mock_analysis::{analysis_and_position, MockAnalysis},\n@@ -61,6 +78,25 @@ mod tests {\n         nav.assert_match(\"foo MODULE FileId(1) [0; 8)\");\n     }\n \n+    #[test]\n+    fn test_resolve_parent_module_on_module_decl() {\n+        covers!(test_resolve_parent_module_on_module_decl);\n+        let (analysis, pos) = analysis_and_position(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+\n+            //- /foo.rs\n+            mod <|>bar;\n+\n+            //- /foo/bar.rs\n+            // empty\n+            \",\n+        );\n+        let nav = analysis.parent_module(pos).unwrap().pop().unwrap();\n+        nav.assert_match(\"foo MODULE FileId(1) [0; 8)\");\n+    }\n+\n     #[test]\n     fn test_resolve_parent_module_for_inline() {\n         let (analysis, pos) = analysis_and_position("}, {"sha": "a6320bd2f5701b93fae09f31001cb4b483f92ec8", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 119, "deletions": 38, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -10,29 +10,27 @@\n //! resolved to the search element definition, we get a reference.\n \n mod classify;\n-mod name_definition;\n mod rename;\n mod search_scope;\n \n use hir::{InFile, SourceBinder};\n use once_cell::unsync::Lazy;\n use ra_db::{SourceDatabase, SourceDatabaseExt};\n+use ra_ide_db::RootDatabase;\n use ra_prof::profile;\n use ra_syntax::{\n     algo::find_node_at_offset,\n     ast::{self, NameOwner},\n     match_ast, AstNode, SourceFile, SyntaxKind, SyntaxNode, TextRange, TextUnit, TokenAtOffset,\n };\n \n-use crate::{\n-    db::RootDatabase, display::ToNav, FilePosition, FileRange, NavigationTarget, RangeInfo,\n-};\n+use crate::{display::ToNav, FilePosition, FileRange, NavigationTarget, RangeInfo};\n \n pub(crate) use self::{\n     classify::{classify_name, classify_name_ref},\n-    name_definition::{NameDefinition, NameKind},\n     rename::rename,\n };\n+pub(crate) use ra_ide_db::defs::{NameDefinition, NameKind};\n \n pub use self::search_scope::SearchScope;\n \n@@ -112,38 +110,32 @@ impl IntoIterator for ReferenceSearchResult {\n \n pub(crate) fn find_all_refs(\n     db: &RootDatabase,\n-    mut position: FilePosition,\n+    position: FilePosition,\n     search_scope: Option<SearchScope>,\n ) -> Option<RangeInfo<ReferenceSearchResult>> {\n     let parse = db.parse(position.file_id);\n     let syntax = parse.tree().syntax().clone();\n \n-    let token = syntax.token_at_offset(position.offset);\n-    let mut search_kind = ReferenceKind::Other;\n+    let (opt_name, search_kind) =\n+        if let Some(name) = get_struct_def_name_for_struc_litetal_search(&syntax, position) {\n+            (Some(name), ReferenceKind::StructLiteral)\n+        } else {\n+            (find_node_at_offset::<ast::Name>(&syntax, position.offset), ReferenceKind::Other)\n+        };\n \n-    if let TokenAtOffset::Between(ref left, ref right) = token {\n-        if (right.kind() == SyntaxKind::L_CURLY || right.kind() == SyntaxKind::L_PAREN)\n-            && left.kind() != SyntaxKind::IDENT\n-        {\n-            position = FilePosition { offset: left.text_range().start(), ..position };\n-            search_kind = ReferenceKind::StructLiteral;\n-        }\n-    }\n-\n-    let RangeInfo { range, info: (name, def) } = find_name(db, &syntax, position)?;\n+    let RangeInfo { range, info: (name, def) } = find_name(db, &syntax, position, opt_name)?;\n \n     let declaration = match def.kind {\n         NameKind::Macro(mac) => mac.to_nav(db),\n-        NameKind::Field(field) => field.to_nav(db),\n-        NameKind::AssocItem(assoc) => assoc.to_nav(db),\n-        NameKind::Def(def) => NavigationTarget::from_def(db, def)?,\n+        NameKind::StructField(field) => field.to_nav(db),\n+        NameKind::ModuleDef(def) => NavigationTarget::from_def(db, def)?,\n         NameKind::SelfType(imp) => imp.to_nav(db),\n         NameKind::Local(local) => local.to_nav(db),\n         NameKind::TypeParam(_) => return None,\n     };\n \n     let search_scope = {\n-        let base = def.search_scope(db);\n+        let base = SearchScope::for_def(&def, db);\n         match search_scope {\n             None => base,\n             Some(scope) => base.intersection(&scope),\n@@ -170,9 +162,10 @@ fn find_name(\n     db: &RootDatabase,\n     syntax: &SyntaxNode,\n     position: FilePosition,\n+    opt_name: Option<ast::Name>,\n ) -> Option<RangeInfo<(String, NameDefinition)>> {\n     let mut sb = SourceBinder::new(db);\n-    if let Some(name) = find_node_at_offset::<ast::Name>(&syntax, position.offset) {\n+    if let Some(name) = opt_name {\n         let def = classify_name(&mut sb, InFile::new(position.file_id.into(), &name))?;\n         let range = name.syntax().text_range();\n         return Some(RangeInfo::new(range, (name.text().to_string(), def)));\n@@ -218,15 +211,8 @@ fn process_definition(\n                 if let Some(d) = classify_name_ref(&mut sb, InFile::new(file_id.into(), &name_ref))\n                 {\n                     if d == def {\n-                        let kind = if name_ref\n-                            .syntax()\n-                            .ancestors()\n-                            .find_map(ast::RecordLit::cast)\n-                            .and_then(|l| l.path())\n-                            .and_then(|p| p.segment())\n-                            .and_then(|p| p.name_ref())\n-                            .map(|n| n == name_ref)\n-                            .unwrap_or(false)\n+                        let kind = if is_record_lit_name_ref(&name_ref)\n+                            || is_call_expr_name_ref(&name_ref)\n                         {\n                             ReferenceKind::StructLiteral\n                         } else {\n@@ -253,7 +239,7 @@ fn decl_access(\n     range: TextRange,\n ) -> Option<ReferenceAccess> {\n     match kind {\n-        NameKind::Local(_) | NameKind::Field(_) => {}\n+        NameKind::Local(_) | NameKind::StructField(_) => {}\n         _ => return None,\n     };\n \n@@ -273,7 +259,7 @@ fn decl_access(\n fn reference_access(kind: &NameKind, name_ref: &ast::NameRef) -> Option<ReferenceAccess> {\n     // Only Locals and Fields have accesses for now.\n     match kind {\n-        NameKind::Local(_) | NameKind::Field(_) => {}\n+        NameKind::Local(_) | NameKind::StructField(_) => {}\n         _ => return None,\n     };\n \n@@ -301,6 +287,49 @@ fn reference_access(kind: &NameKind, name_ref: &ast::NameRef) -> Option<Referenc\n     mode.or(Some(ReferenceAccess::Read))\n }\n \n+fn is_record_lit_name_ref(name_ref: &ast::NameRef) -> bool {\n+    name_ref\n+        .syntax()\n+        .ancestors()\n+        .find_map(ast::RecordLit::cast)\n+        .and_then(|l| l.path())\n+        .and_then(|p| p.segment())\n+        .map(|p| p.name_ref().as_ref() == Some(name_ref))\n+        .unwrap_or(false)\n+}\n+\n+fn get_struct_def_name_for_struc_litetal_search(\n+    syntax: &SyntaxNode,\n+    position: FilePosition,\n+) -> Option<ast::Name> {\n+    if let TokenAtOffset::Between(ref left, ref right) = syntax.token_at_offset(position.offset) {\n+        if right.kind() != SyntaxKind::L_CURLY && right.kind() != SyntaxKind::L_PAREN {\n+            return None;\n+        }\n+        if let Some(name) = find_node_at_offset::<ast::Name>(&syntax, left.text_range().start()) {\n+            return name.syntax().ancestors().find_map(ast::StructDef::cast).and_then(|l| l.name());\n+        }\n+        if find_node_at_offset::<ast::TypeParamList>(&syntax, left.text_range().start()).is_some() {\n+            return left.ancestors().find_map(ast::StructDef::cast).and_then(|l| l.name());\n+        }\n+    }\n+    None\n+}\n+\n+fn is_call_expr_name_ref(name_ref: &ast::NameRef) -> bool {\n+    name_ref\n+        .syntax()\n+        .ancestors()\n+        .find_map(ast::CallExpr::cast)\n+        .and_then(|c| match c.expr()? {\n+            ast::Expr::PathExpr(p) => {\n+                Some(p.path()?.segment()?.name_ref().as_ref() == Some(name_ref))\n+            }\n+            _ => None,\n+        })\n+        .unwrap_or(false)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::{\n@@ -309,7 +338,7 @@ mod tests {\n     };\n \n     #[test]\n-    fn test_struct_literal() {\n+    fn test_struct_literal_after_space() {\n         let code = r#\"\n     struct Foo <|>{\n         a: i32,\n@@ -330,6 +359,58 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_struct_literal_befor_space() {\n+        let code = r#\"\n+    struct Foo<|> {}\n+        fn main() {\n+        let f: Foo;\n+        f = Foo {};\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        check_result(\n+            refs,\n+            \"Foo STRUCT_DEF FileId(1) [5; 18) [12; 15) Other\",\n+            &[\"FileId(1) [54; 57) Other\", \"FileId(1) [71; 74) StructLiteral\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_struct_literal_with_generic_type() {\n+        let code = r#\"\n+    struct Foo<T> <|>{}\n+        fn main() {\n+        let f: Foo::<i32>;\n+        f = Foo {};\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        check_result(\n+            refs,\n+            \"Foo STRUCT_DEF FileId(1) [5; 21) [12; 15) Other\",\n+            &[\"FileId(1) [81; 84) StructLiteral\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_struct_literal_for_tuple() {\n+        let code = r#\"\n+    struct Foo<|>(i32);\n+\n+    fn main() {\n+        let f: Foo;\n+        f = Foo(1);\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        check_result(\n+            refs,\n+            \"Foo STRUCT_DEF FileId(1) [5; 21) [12; 15) Other\",\n+            &[\"FileId(1) [71; 74) StructLiteral\"],\n+        );\n+    }\n+\n     #[test]\n     fn test_find_all_refs_for_local() {\n         let code = r#\"\n@@ -564,15 +645,15 @@ mod tests {\n         check_result(\n             refs,\n             \"quux FN_DEF FileId(1) [18; 34) [25; 29) Other\",\n-            &[\"FileId(2) [16; 20) Other\", \"FileId(3) [16; 20) Other\"],\n+            &[\"FileId(2) [16; 20) StructLiteral\", \"FileId(3) [16; 20) StructLiteral\"],\n         );\n \n         let refs =\n             analysis.find_all_refs(pos, Some(SearchScope::single_file(bar))).unwrap().unwrap();\n         check_result(\n             refs,\n             \"quux FN_DEF FileId(1) [18; 34) [25; 29) Other\",\n-            &[\"FileId(3) [16; 20) Other\"],\n+            &[\"FileId(3) [16; 20) StructLiteral\"],\n         );\n     }\n \n@@ -591,7 +672,7 @@ mod tests {\n         check_result(\n             refs,\n             \"m1 MACRO_CALL FileId(1) [9; 63) [46; 48) Other\",\n-            &[\"FileId(1) [96; 98) Other\", \"FileId(1) [114; 116) Other\"],\n+            &[\"FileId(1) [96; 98) StructLiteral\", \"FileId(1) [114; 116) StructLiteral\"],\n         );\n     }\n "}, {"sha": "d0f03d8a89a88aa2284f1a4ee6e58eb6dd401ab9", "filename": "crates/ra_ide/src/references/classify.rs", "status": "modified", "additions": 21, "deletions": 119, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -2,119 +2,13 @@\n \n use hir::{InFile, PathResolution, SourceBinder};\n use ra_prof::profile;\n-use ra_syntax::{ast, match_ast, AstNode};\n+use ra_syntax::{ast, AstNode};\n use test_utils::tested_by;\n \n-use super::{\n-    name_definition::{from_assoc_item, from_module_def, from_struct_field},\n-    NameDefinition, NameKind,\n-};\n-use crate::db::RootDatabase;\n+use super::{NameDefinition, NameKind};\n+use ra_ide_db::RootDatabase;\n \n-pub(crate) fn classify_name(\n-    sb: &mut SourceBinder<RootDatabase>,\n-    name: InFile<&ast::Name>,\n-) -> Option<NameDefinition> {\n-    let _p = profile(\"classify_name\");\n-    let parent = name.value.syntax().parent()?;\n-\n-    match_ast! {\n-        match parent {\n-            ast::BindPat(it) => {\n-                let src = name.with_value(it);\n-                let local = sb.to_def(src)?;\n-                Some(NameDefinition {\n-                    visibility: None,\n-                    container: local.module(sb.db),\n-                    kind: NameKind::Local(local),\n-                })\n-            },\n-            ast::RecordFieldDef(it) => {\n-                let src = name.with_value(it);\n-                let field: hir::StructField = sb.to_def(src)?;\n-                Some(from_struct_field(sb.db, field))\n-            },\n-            ast::Module(it) => {\n-                let def = sb.to_def(name.with_value(it))?;\n-                Some(from_module_def(sb.db, def.into(), None))\n-            },\n-            ast::StructDef(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::Struct = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n-            },\n-            ast::EnumDef(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::Enum = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n-            },\n-            ast::TraitDef(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::Trait = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n-            },\n-            ast::StaticDef(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::Static = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n-            },\n-            ast::EnumVariant(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::EnumVariant = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n-            },\n-            ast::FnDef(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::Function = sb.to_def(src)?;\n-                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n-                    Some(from_assoc_item(sb.db, def.into()))\n-                } else {\n-                    Some(from_module_def(sb.db, def.into(), None))\n-                }\n-            },\n-            ast::ConstDef(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::Const = sb.to_def(src)?;\n-                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n-                    Some(from_assoc_item(sb.db, def.into()))\n-                } else {\n-                    Some(from_module_def(sb.db, def.into(), None))\n-                }\n-            },\n-            ast::TypeAliasDef(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::TypeAlias = sb.to_def(src)?;\n-                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n-                    Some(from_assoc_item(sb.db, def.into()))\n-                } else {\n-                    Some(from_module_def(sb.db, def.into(), None))\n-                }\n-            },\n-            ast::MacroCall(it) => {\n-                let src = name.with_value(it);\n-                let def = sb.to_def(src.clone())?;\n-\n-                let module = sb.to_module_def(src.file_id.original_file(sb.db))?;\n-\n-                Some(NameDefinition {\n-                    visibility: None,\n-                    container: module,\n-                    kind: NameKind::Macro(def),\n-                })\n-            },\n-            ast::TypeParam(it) => {\n-                let src = name.with_value(it);\n-                let def = sb.to_def(src)?;\n-                Some(NameDefinition {\n-                    visibility: None,\n-                    container: def.module(sb.db),\n-                    kind: NameKind::TypeParam(def),\n-                })\n-            },\n-            _ => None,\n-        }\n-    }\n-}\n+pub use ra_ide_db::defs::{classify_name, from_module_def, from_struct_field};\n \n pub(crate) fn classify_name_ref(\n     sb: &mut SourceBinder<RootDatabase>,\n@@ -128,7 +22,7 @@ pub(crate) fn classify_name_ref(\n     if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n         tested_by!(goto_def_for_methods);\n         if let Some(func) = analyzer.resolve_method_call(&method_call) {\n-            return Some(from_assoc_item(sb.db, func.into()));\n+            return Some(from_module_def(sb.db, func.into(), None));\n         }\n     }\n \n@@ -163,27 +57,35 @@ pub(crate) fn classify_name_ref(\n \n     let path = name_ref.value.syntax().ancestors().find_map(ast::Path::cast)?;\n     let resolved = analyzer.resolve_path(sb.db, &path)?;\n-    match resolved {\n-        PathResolution::Def(def) => Some(from_module_def(sb.db, def, Some(container))),\n-        PathResolution::AssocItem(item) => Some(from_assoc_item(sb.db, item)),\n+    let res = match resolved {\n+        PathResolution::Def(def) => from_module_def(sb.db, def, Some(container)),\n+        PathResolution::AssocItem(item) => {\n+            let def = match item {\n+                hir::AssocItem::Function(it) => it.into(),\n+                hir::AssocItem::Const(it) => it.into(),\n+                hir::AssocItem::TypeAlias(it) => it.into(),\n+            };\n+            from_module_def(sb.db, def, Some(container))\n+        }\n         PathResolution::Local(local) => {\n             let kind = NameKind::Local(local);\n             let container = local.module(sb.db);\n-            Some(NameDefinition { kind, container, visibility: None })\n+            NameDefinition { kind, container, visibility: None }\n         }\n         PathResolution::TypeParam(par) => {\n             let kind = NameKind::TypeParam(par);\n             let container = par.module(sb.db);\n-            Some(NameDefinition { kind, container, visibility })\n+            NameDefinition { kind, container, visibility }\n         }\n         PathResolution::Macro(def) => {\n             let kind = NameKind::Macro(def);\n-            Some(NameDefinition { kind, container, visibility })\n+            NameDefinition { kind, container, visibility }\n         }\n         PathResolution::SelfType(impl_block) => {\n             let kind = NameKind::SelfType(impl_block);\n             let container = impl_block.module(sb.db);\n-            Some(NameDefinition { kind, container, visibility })\n+            NameDefinition { kind, container, visibility }\n         }\n-    }\n+    };\n+    Some(res)\n }"}, {"sha": "1e4226ab9acaef200b21552fbd108161682b4baf", "filename": "crates/ra_ide/src/references/name_definition.rs", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/22caf982b99c54058e2e9200aeea0e61cada284a/crates%2Fra_ide%2Fsrc%2Freferences%2Fname_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22caf982b99c54058e2e9200aeea0e61cada284a/crates%2Fra_ide%2Fsrc%2Freferences%2Fname_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fname_definition.rs?ref=22caf982b99c54058e2e9200aeea0e61cada284a", "patch": "@@ -1,85 +0,0 @@\n-//! `NameDefinition` keeps information about the element we want to search references for.\n-//! The element is represented by `NameKind`. It's located inside some `container` and\n-//! has a `visibility`, which defines a search scope.\n-//! Note that the reference search is possible for not all of the classified items.\n-\n-use hir::{\n-    Adt, AssocItem, HasSource, ImplBlock, Local, MacroDef, Module, ModuleDef, StructField,\n-    TypeParam, VariantDef,\n-};\n-use ra_syntax::{ast, ast::VisibilityOwner};\n-\n-use crate::db::RootDatabase;\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub enum NameKind {\n-    Macro(MacroDef),\n-    Field(StructField),\n-    AssocItem(AssocItem),\n-    Def(ModuleDef),\n-    SelfType(ImplBlock),\n-    Local(Local),\n-    TypeParam(TypeParam),\n-}\n-\n-#[derive(PartialEq, Eq)]\n-pub(crate) struct NameDefinition {\n-    pub visibility: Option<ast::Visibility>,\n-    /// FIXME: this doesn't really make sense. For example, builtin types don't\n-    /// really have a module.\n-    pub container: Module,\n-    pub kind: NameKind,\n-}\n-\n-pub(super) fn from_assoc_item(db: &RootDatabase, item: AssocItem) -> NameDefinition {\n-    let container = item.module(db);\n-    let visibility = match item {\n-        AssocItem::Function(f) => f.source(db).value.visibility(),\n-        AssocItem::Const(c) => c.source(db).value.visibility(),\n-        AssocItem::TypeAlias(a) => a.source(db).value.visibility(),\n-    };\n-    let kind = NameKind::AssocItem(item);\n-    NameDefinition { kind, container, visibility }\n-}\n-\n-pub(super) fn from_struct_field(db: &RootDatabase, field: StructField) -> NameDefinition {\n-    let kind = NameKind::Field(field);\n-    let parent = field.parent_def(db);\n-    let container = parent.module(db);\n-    let visibility = match parent {\n-        VariantDef::Struct(s) => s.source(db).value.visibility(),\n-        VariantDef::Union(e) => e.source(db).value.visibility(),\n-        VariantDef::EnumVariant(e) => e.source(db).value.parent_enum().visibility(),\n-    };\n-    NameDefinition { kind, container, visibility }\n-}\n-\n-pub(super) fn from_module_def(\n-    db: &RootDatabase,\n-    def: ModuleDef,\n-    module: Option<Module>,\n-) -> NameDefinition {\n-    let kind = NameKind::Def(def);\n-    let (container, visibility) = match def {\n-        ModuleDef::Module(it) => {\n-            let container = it.parent(db).or_else(|| Some(it)).unwrap();\n-            let visibility = it.declaration_source(db).and_then(|s| s.value.visibility());\n-            (container, visibility)\n-        }\n-        ModuleDef::EnumVariant(it) => {\n-            let container = it.module(db);\n-            let visibility = it.source(db).value.parent_enum().visibility();\n-            (container, visibility)\n-        }\n-        ModuleDef::Function(it) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Const(it) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Static(it) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Trait(it) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::TypeAlias(it) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Adt(Adt::Struct(it)) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Adt(Adt::Union(it)) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Adt(Adt::Enum(it)) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::BuiltinType(..) => (module.unwrap(), None),\n-    };\n-    NameDefinition { kind, container, visibility }\n-}"}, {"sha": "08e77c01fbd0ef1f24bc0c2ff3023d5440ed909c", "filename": "crates/ra_ide/src/references/rename.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -2,12 +2,14 @@\n \n use hir::ModuleSource;\n use ra_db::{RelativePath, RelativePathBuf, SourceDatabase, SourceDatabaseExt};\n-use ra_syntax::{algo::find_node_at_offset, ast, tokenize, AstNode, SyntaxKind, SyntaxNode};\n+use ra_ide_db::RootDatabase;\n+use ra_syntax::{\n+    algo::find_node_at_offset, ast, lex_single_valid_syntax_kind, AstNode, SyntaxKind, SyntaxNode,\n+};\n use ra_text_edit::TextEdit;\n \n use crate::{\n-    db::RootDatabase, FileId, FilePosition, FileSystemEdit, RangeInfo, SourceChange,\n-    SourceFileEdit, TextRange,\n+    FileId, FilePosition, FileSystemEdit, RangeInfo, SourceChange, SourceFileEdit, TextRange,\n };\n \n use super::find_all_refs;\n@@ -17,11 +19,9 @@ pub(crate) fn rename(\n     position: FilePosition,\n     new_name: &str,\n ) -> Option<RangeInfo<SourceChange>> {\n-    let tokens = tokenize(new_name);\n-    if tokens.len() != 1\n-        || (tokens[0].kind != SyntaxKind::IDENT && tokens[0].kind != SyntaxKind::UNDERSCORE)\n-    {\n-        return None;\n+    match lex_single_valid_syntax_kind(new_name)? {\n+        SyntaxKind::IDENT | SyntaxKind::UNDERSCORE => (),\n+        _ => return None,\n     }\n \n     let parse = db.parse(position.file_id);"}, {"sha": "279f57be06a1c6f884032f80b60465eba16ec7c1", "filename": "crates/ra_ide/src/references/search_scope.rs", "status": "modified", "additions": 51, "deletions": 53, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -10,7 +10,7 @@ use ra_prof::profile;\n use ra_syntax::{AstNode, TextRange};\n use rustc_hash::FxHashMap;\n \n-use crate::db::RootDatabase;\n+use ra_ide_db::RootDatabase;\n \n use super::{NameDefinition, NameKind};\n \n@@ -19,59 +19,13 @@ pub struct SearchScope {\n }\n \n impl SearchScope {\n-    fn new(entries: FxHashMap<FileId, Option<TextRange>>) -> SearchScope {\n-        SearchScope { entries }\n-    }\n-    pub fn single_file(file: FileId) -> SearchScope {\n-        SearchScope::new(std::iter::once((file, None)).collect())\n-    }\n-    pub(crate) fn intersection(&self, other: &SearchScope) -> SearchScope {\n-        let (mut small, mut large) = (&self.entries, &other.entries);\n-        if small.len() > large.len() {\n-            mem::swap(&mut small, &mut large)\n-        }\n-\n-        let res = small\n-            .iter()\n-            .filter_map(|(file_id, r1)| {\n-                let r2 = large.get(file_id)?;\n-                let r = intersect_ranges(*r1, *r2)?;\n-                Some((*file_id, r))\n-            })\n-            .collect();\n-        return SearchScope::new(res);\n-\n-        fn intersect_ranges(\n-            r1: Option<TextRange>,\n-            r2: Option<TextRange>,\n-        ) -> Option<Option<TextRange>> {\n-            match (r1, r2) {\n-                (None, r) | (r, None) => Some(r),\n-                (Some(r1), Some(r2)) => {\n-                    let r = r1.intersection(&r2)?;\n-                    Some(Some(r))\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl IntoIterator for SearchScope {\n-    type Item = (FileId, Option<TextRange>);\n-    type IntoIter = std::collections::hash_map::IntoIter<FileId, Option<TextRange>>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.entries.into_iter()\n-    }\n-}\n-\n-impl NameDefinition {\n-    pub(crate) fn search_scope(&self, db: &RootDatabase) -> SearchScope {\n+    pub(crate) fn for_def(def: &NameDefinition, db: &RootDatabase) -> SearchScope {\n         let _p = profile(\"search_scope\");\n \n-        let module_src = self.container.definition_source(db);\n+        let module_src = def.container.definition_source(db);\n         let file_id = module_src.file_id.original_file(db);\n \n-        if let NameKind::Local(var) = self.kind {\n+        if let NameKind::Local(var) = def.kind {\n             let range = match var.parent(db) {\n                 DefWithBody::Function(f) => f.source(db).value.syntax().text_range(),\n                 DefWithBody::Const(c) => c.source(db).value.syntax().text_range(),\n@@ -82,10 +36,10 @@ impl NameDefinition {\n             return SearchScope::new(res);\n         }\n \n-        let vis = self.visibility.as_ref().map(|v| v.syntax().to_string()).unwrap_or_default();\n+        let vis = def.visibility.as_ref().map(|v| v.syntax().to_string()).unwrap_or_default();\n \n         if vis.as_str() == \"pub(super)\" {\n-            if let Some(parent_module) = self.container.parent(db) {\n+            if let Some(parent_module) = def.container.parent(db) {\n                 let mut res = FxHashMap::default();\n                 let parent_src = parent_module.definition_source(db);\n                 let file_id = parent_src.file_id.original_file(db);\n@@ -118,7 +72,7 @@ impl NameDefinition {\n                 return SearchScope::new(res);\n             }\n             if vis.as_str() == \"pub\" {\n-                let krate = self.container.krate();\n+                let krate = def.container.krate();\n                 for rev_dep in krate.reverse_dependencies(db) {\n                     let root_file = rev_dep.root_file(db);\n                     let source_root_id = db.file_source_root(root_file);\n@@ -137,4 +91,48 @@ impl NameDefinition {\n         res.insert(file_id, range);\n         SearchScope::new(res)\n     }\n+\n+    fn new(entries: FxHashMap<FileId, Option<TextRange>>) -> SearchScope {\n+        SearchScope { entries }\n+    }\n+    pub fn single_file(file: FileId) -> SearchScope {\n+        SearchScope::new(std::iter::once((file, None)).collect())\n+    }\n+    pub(crate) fn intersection(&self, other: &SearchScope) -> SearchScope {\n+        let (mut small, mut large) = (&self.entries, &other.entries);\n+        if small.len() > large.len() {\n+            mem::swap(&mut small, &mut large)\n+        }\n+\n+        let res = small\n+            .iter()\n+            .filter_map(|(file_id, r1)| {\n+                let r2 = large.get(file_id)?;\n+                let r = intersect_ranges(*r1, *r2)?;\n+                Some((*file_id, r))\n+            })\n+            .collect();\n+        return SearchScope::new(res);\n+\n+        fn intersect_ranges(\n+            r1: Option<TextRange>,\n+            r2: Option<TextRange>,\n+        ) -> Option<Option<TextRange>> {\n+            match (r1, r2) {\n+                (None, r) | (r, None) => Some(r),\n+                (Some(r1), Some(r2)) => {\n+                    let r = r1.intersection(&r2)?;\n+                    Some(Some(r))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl IntoIterator for SearchScope {\n+    type Item = (FileId, Option<TextRange>);\n+    type IntoIter = std::collections::hash_map::IntoIter<FileId, Option<TextRange>>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.entries.into_iter()\n+    }\n }"}, {"sha": "b6b0c70f9dbf4dc184f6429e1cfcc9d427015543", "filename": "crates/ra_ide/src/runnables.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Frunnables.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -3,12 +3,13 @@\n use hir::InFile;\n use itertools::Itertools;\n use ra_db::SourceDatabase;\n+use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     ast::{self, AstNode, AttrsOwner, ModuleItemOwner, NameOwner},\n     match_ast, SyntaxNode, TextRange,\n };\n \n-use crate::{db::RootDatabase, FileId};\n+use crate::FileId;\n \n #[derive(Debug)]\n pub struct Runnable {\n@@ -43,7 +44,7 @@ fn runnable_fn(fn_def: ast::FnDef) -> Option<Runnable> {\n     let name = fn_def.name()?.text().clone();\n     let kind = if name == \"main\" {\n         RunnableKind::Bin\n-    } else if fn_def.has_atom_attr(\"test\") {\n+    } else if has_test_related_attribute(&fn_def) {\n         RunnableKind::Test { name: name.to_string() }\n     } else if fn_def.has_atom_attr(\"bench\") {\n         RunnableKind::Bench { name: name.to_string() }\n@@ -53,6 +54,20 @@ fn runnable_fn(fn_def: ast::FnDef) -> Option<Runnable> {\n     Some(Runnable { range: fn_def.syntax().text_range(), kind })\n }\n \n+/// This is a method with a heuristics to support test methods annotated with custom test annotations, such as\n+/// `#[test_case(...)]`, `#[tokio::test]` and similar.\n+/// Also a regular `#[test]` annotation is supported.\n+///\n+/// It may produce false positives, for example, `#[wasm_bindgen_test]` requires a different command to run the test,\n+/// but it's better than not to have the runnables for the tests at all.\n+fn has_test_related_attribute(fn_def: &ast::FnDef) -> bool {\n+    fn_def\n+        .attrs()\n+        .filter_map(|attr| attr.path())\n+        .map(|path| path.syntax().to_string().to_lowercase())\n+        .any(|attribute_text| attribute_text.contains(\"test\"))\n+}\n+\n fn runnable_mod(db: &RootDatabase, file_id: FileId, module: ast::Module) -> Option<Runnable> {\n     let has_test_function = module\n         .item_list()?"}, {"sha": "1cc55e78b51eadb02b057bb3b10b4484860b2e86", "filename": "crates/ra_ide/src/snapshots/highlighting.html", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -34,6 +34,16 @@\n     <span class=\"function\">foo</span>::&lt;<span class=\"type.builtin\">i32</span>&gt;();\n }\n \n+<span class=\"macro\">macro_rules</span><span class=\"macro\">!</span> def_fn {\n+    ($($tt:tt)*) =&gt; {$($tt)*}\n+}\n+\n+<span class=\"macro\">def_fn</span><span class=\"macro\">!</span>{\n+    <span class=\"keyword\">fn</span> <span class=\"function\">bar</span>() -&gt; <span class=\"type.builtin\">u32</span> {\n+        <span class=\"literal.numeric\">100</span>\n+    }\n+}\n+\n <span class=\"comment\">// comment</span>\n <span class=\"keyword\">fn</span> <span class=\"function\">main</span>() {\n     <span class=\"macro\">println</span><span class=\"macro\">!</span>(<span class=\"string\">\"Hello, {}!\"</span>, <span class=\"literal.numeric\">92</span>);"}, {"sha": "918fd4b97879bcbb035c4c180b03cf90b97ed2df", "filename": "crates/ra_ide/src/snapshots/rainbow_highlighting.html", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -24,14 +24,14 @@\n .keyword\\.control  { color: #F0DFAF; font-weight: bold; }\n </style>\n <pre><code><span class=\"keyword\">fn</span> <span class=\"function\">main</span>() {\n-    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"8723171760279909834\" style=\"color: hsl(307,91%,75%);\">hello</span> = <span class=\"string\">\"hello\"</span>;\n-    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"14702933417323009544\" style=\"color: hsl(108,90%,49%);\">x</span> = <span class=\"variable\" data-binding-hash=\"8723171760279909834\" style=\"color: hsl(307,91%,75%);\">hello</span>.to_string();\n-    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"5443150872754369068\" style=\"color: hsl(215,43%,43%);\">y</span> = <span class=\"variable\" data-binding-hash=\"8723171760279909834\" style=\"color: hsl(307,91%,75%);\">hello</span>.to_string();\n+    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"2217585909179791122\" style=\"color: hsl(280,74%,48%);\">hello</span> = <span class=\"string\">\"hello\"</span>;\n+    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"4303609361109701698\" style=\"color: hsl(242,75%,88%);\">x</span> = <span class=\"variable\" data-binding-hash=\"2217585909179791122\" style=\"color: hsl(280,74%,48%);\">hello</span>.to_string();\n+    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"13865792086344377029\" style=\"color: hsl(340,64%,86%);\">y</span> = <span class=\"variable\" data-binding-hash=\"2217585909179791122\" style=\"color: hsl(280,74%,48%);\">hello</span>.to_string();\n \n-    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"17358108296605513516\" style=\"color: hsl(331,46%,60%);\">x</span> = <span class=\"string\">\"other color please!\"</span>;\n-    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"2073121142529774969\" style=\"color: hsl(320,43%,74%);\">y</span> = <span class=\"variable\" data-binding-hash=\"17358108296605513516\" style=\"color: hsl(331,46%,60%);\">x</span>.to_string();\n+    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"7011301204224269512\" style=\"color: hsl(198,45%,40%);\">x</span> = <span class=\"string\">\"other color please!\"</span>;\n+    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"12461245066629867975\" style=\"color: hsl(132,91%,68%);\">y</span> = <span class=\"variable\" data-binding-hash=\"7011301204224269512\" style=\"color: hsl(198,45%,40%);\">x</span>.to_string();\n }\n \n <span class=\"keyword\">fn</span> <span class=\"function\">bar</span>() {\n-    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable.mut\" data-binding-hash=\"8723171760279909834\" style=\"color: hsl(307,91%,75%);\">hello</span> = <span class=\"string\">\"hello\"</span>;\n+    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable.mut\" data-binding-hash=\"2217585909179791122\" style=\"color: hsl(280,74%,48%);\">hello</span> = <span class=\"string\">\"hello\"</span>;\n }</code></pre>\n\\ No newline at end of file"}, {"sha": "30eb5c995e6376dd4878403518e052c29656b854", "filename": "crates/ra_ide/src/status.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fstatus.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -10,14 +10,14 @@ use ra_db::{\n     },\n     FileTextQuery, SourceRootId,\n };\n+use ra_ide_db::{\n+    symbol_index::{LibrarySymbolsQuery, SymbolIndex},\n+    RootDatabase,\n+};\n use ra_prof::{memory_usage, Bytes};\n use ra_syntax::{ast, Parse, SyntaxNode};\n \n-use crate::{\n-    db::RootDatabase,\n-    symbol_index::{LibrarySymbolsQuery, SymbolIndex},\n-    FileId,\n-};\n+use crate::FileId;\n \n fn syntax_tree_stats(db: &RootDatabase) -> SyntaxTreeStats {\n     db.query(ra_db::ParseQuery).entries::<SyntaxTreeStats>()"}, {"sha": "174e135951a34f438880a2f623ff120d24550643", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 195, "deletions": 119, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,14 +1,18 @@\n //! FIXME: write short doc here\n \n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashMap;\n \n-use hir::{InFile, Name, SourceBinder};\n+use hir::{HirFileId, InFile, Name, SourceAnalyzer, SourceBinder};\n use ra_db::SourceDatabase;\n+use ra_ide_db::RootDatabase;\n use ra_prof::profile;\n-use ra_syntax::{ast, AstNode, Direction, SyntaxElement, SyntaxKind, SyntaxKind::*, TextRange, T};\n+use ra_syntax::{\n+    ast, AstNode, Direction, SyntaxElement, SyntaxKind, SyntaxKind::*, SyntaxToken, TextRange,\n+    WalkEvent, T,\n+};\n \n use crate::{\n-    db::RootDatabase,\n+    expand::descend_into_macros_with_analyzer,\n     references::{\n         classify_name, classify_name_ref,\n         NameKind::{self, *},\n@@ -72,121 +76,186 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n     let parse = db.parse(file_id);\n     let root = parse.tree().syntax().clone();\n \n-    fn calc_binding_hash(file_id: FileId, name: &Name, shadow_count: u32) -> u64 {\n-        fn hash<T: std::hash::Hash + std::fmt::Debug>(x: T) -> u64 {\n-            use std::{collections::hash_map::DefaultHasher, hash::Hasher};\n+    let mut sb = SourceBinder::new(db);\n+    let mut bindings_shadow_count: FxHashMap<Name, u32> = FxHashMap::default();\n+    let mut res = Vec::new();\n+    let analyzer = sb.analyze(InFile::new(file_id.into(), &root), None);\n \n-            let mut hasher = DefaultHasher::new();\n-            x.hash(&mut hasher);\n-            hasher.finish()\n+    let mut in_macro_call = None;\n+\n+    for event in root.preorder_with_tokens() {\n+        match event {\n+            WalkEvent::Enter(node) => match node.kind() {\n+                MACRO_CALL => {\n+                    in_macro_call = Some(node.clone());\n+                    if let Some(range) = highlight_macro(InFile::new(file_id.into(), node)) {\n+                        res.push(HighlightedRange { range, tag: tags::MACRO, binding_hash: None });\n+                    }\n+                }\n+                _ if in_macro_call.is_some() => {\n+                    if let Some(token) = node.as_token() {\n+                        if let Some((tag, binding_hash)) = highlight_token_tree(\n+                            db,\n+                            &mut sb,\n+                            &analyzer,\n+                            &mut bindings_shadow_count,\n+                            InFile::new(file_id.into(), token.clone()),\n+                        ) {\n+                            res.push(HighlightedRange {\n+                                range: node.text_range(),\n+                                tag,\n+                                binding_hash,\n+                            });\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    if let Some((tag, binding_hash)) = highlight_node(\n+                        db,\n+                        &mut sb,\n+                        &mut bindings_shadow_count,\n+                        InFile::new(file_id.into(), node.clone()),\n+                    ) {\n+                        res.push(HighlightedRange { range: node.text_range(), tag, binding_hash });\n+                    }\n+                }\n+            },\n+            WalkEvent::Leave(node) => {\n+                if let Some(m) = in_macro_call.as_ref() {\n+                    if *m == node {\n+                        in_macro_call = None;\n+                    }\n+                }\n+            }\n         }\n+    }\n \n-        hash((file_id, name, shadow_count))\n+    res\n+}\n+\n+fn highlight_macro(node: InFile<SyntaxElement>) -> Option<TextRange> {\n+    let macro_call = ast::MacroCall::cast(node.value.as_node()?.clone())?;\n+    let path = macro_call.path()?;\n+    let name_ref = path.segment()?.name_ref()?;\n+\n+    let range_start = name_ref.syntax().text_range().start();\n+    let mut range_end = name_ref.syntax().text_range().end();\n+    for sibling in path.syntax().siblings_with_tokens(Direction::Next) {\n+        match sibling.kind() {\n+            T![!] | IDENT => range_end = sibling.text_range().end(),\n+            _ => (),\n+        }\n     }\n \n-    let mut sb = SourceBinder::new(db);\n+    Some(TextRange::from_to(range_start, range_end))\n+}\n \n-    // Visited nodes to handle highlighting priorities\n-    // FIXME: retain only ranges here\n-    let mut highlighted: FxHashSet<SyntaxElement> = FxHashSet::default();\n-    let mut bindings_shadow_count: FxHashMap<Name, u32> = FxHashMap::default();\n+fn highlight_token_tree(\n+    db: &RootDatabase,\n+    sb: &mut SourceBinder<RootDatabase>,\n+    analyzer: &SourceAnalyzer,\n+    bindings_shadow_count: &mut FxHashMap<Name, u32>,\n+    token: InFile<SyntaxToken>,\n+) -> Option<(&'static str, Option<u64>)> {\n+    if token.value.parent().kind() != TOKEN_TREE {\n+        return None;\n+    }\n+    let token = descend_into_macros_with_analyzer(db, analyzer, token);\n+    let expanded = {\n+        let parent = token.value.parent();\n+        // We only care Name and Name_ref\n+        match (token.value.kind(), parent.kind()) {\n+            (IDENT, NAME) | (IDENT, NAME_REF) => token.with_value(parent.into()),\n+            _ => token.map(|it| it.into()),\n+        }\n+    };\n \n-    let mut res = Vec::new();\n-    for node in root.descendants_with_tokens() {\n-        if highlighted.contains(&node) {\n-            continue;\n+    highlight_node(db, sb, bindings_shadow_count, expanded)\n+}\n+\n+fn highlight_node(\n+    db: &RootDatabase,\n+    sb: &mut SourceBinder<RootDatabase>,\n+    bindings_shadow_count: &mut FxHashMap<Name, u32>,\n+    node: InFile<SyntaxElement>,\n+) -> Option<(&'static str, Option<u64>)> {\n+    let mut binding_hash = None;\n+    let tag = match node.value.kind() {\n+        FN_DEF => {\n+            bindings_shadow_count.clear();\n+            return None;\n         }\n-        let mut binding_hash = None;\n-        let tag = match node.kind() {\n-            FN_DEF => {\n-                bindings_shadow_count.clear();\n-                continue;\n-            }\n-            COMMENT => tags::LITERAL_COMMENT,\n-            STRING | RAW_STRING | RAW_BYTE_STRING | BYTE_STRING => tags::LITERAL_STRING,\n-            ATTR => tags::LITERAL_ATTRIBUTE,\n-            // Special-case field init shorthand\n-            NAME_REF if node.parent().and_then(ast::RecordField::cast).is_some() => tags::FIELD,\n-            NAME_REF if node.ancestors().any(|it| it.kind() == ATTR) => continue,\n-            NAME_REF => {\n-                let name_ref = node.as_node().cloned().and_then(ast::NameRef::cast).unwrap();\n-                let name_kind = classify_name_ref(&mut sb, InFile::new(file_id.into(), &name_ref))\n-                    .map(|d| d.kind);\n-                match name_kind {\n-                    Some(name_kind) => {\n-                        if let Local(local) = &name_kind {\n-                            if let Some(name) = local.name(db) {\n-                                let shadow_count =\n-                                    bindings_shadow_count.entry(name.clone()).or_default();\n-                                binding_hash =\n-                                    Some(calc_binding_hash(file_id, &name, *shadow_count))\n-                            }\n-                        };\n-\n-                        highlight_name(db, name_kind)\n-                    }\n-                    _ => continue,\n-                }\n-            }\n-            NAME => {\n-                let name = node.as_node().cloned().and_then(ast::Name::cast).unwrap();\n-                let name_kind =\n-                    classify_name(&mut sb, InFile::new(file_id.into(), &name)).map(|d| d.kind);\n-\n-                if let Some(Local(local)) = &name_kind {\n-                    if let Some(name) = local.name(db) {\n-                        let shadow_count = bindings_shadow_count.entry(name.clone()).or_default();\n-                        *shadow_count += 1;\n-                        binding_hash = Some(calc_binding_hash(file_id, &name, *shadow_count))\n-                    }\n-                };\n-\n-                match name_kind {\n-                    Some(name_kind) => highlight_name(db, name_kind),\n-                    None => name.syntax().parent().map_or(tags::FUNCTION, |x| match x.kind() {\n-                        STRUCT_DEF | ENUM_DEF | TRAIT_DEF | TYPE_ALIAS_DEF => tags::TYPE,\n-                        TYPE_PARAM => tags::TYPE_PARAM,\n-                        RECORD_FIELD_DEF => tags::FIELD,\n-                        _ => tags::FUNCTION,\n-                    }),\n+        COMMENT => tags::LITERAL_COMMENT,\n+        STRING | RAW_STRING | RAW_BYTE_STRING | BYTE_STRING => tags::LITERAL_STRING,\n+        ATTR => tags::LITERAL_ATTRIBUTE,\n+        // Special-case field init shorthand\n+        NAME_REF if node.value.parent().and_then(ast::RecordField::cast).is_some() => tags::FIELD,\n+        NAME_REF if node.value.ancestors().any(|it| it.kind() == ATTR) => return None,\n+        NAME_REF => {\n+            let name_ref = node.value.as_node().cloned().and_then(ast::NameRef::cast).unwrap();\n+            let name_kind = classify_name_ref(sb, node.with_value(&name_ref)).map(|d| d.kind);\n+            match name_kind {\n+                Some(name_kind) => {\n+                    if let Local(local) = &name_kind {\n+                        if let Some(name) = local.name(db) {\n+                            let shadow_count =\n+                                bindings_shadow_count.entry(name.clone()).or_default();\n+                            binding_hash =\n+                                Some(calc_binding_hash(node.file_id, &name, *shadow_count))\n+                        }\n+                    };\n+\n+                    highlight_name(db, name_kind)\n                 }\n+                _ => return None,\n             }\n-            INT_NUMBER | FLOAT_NUMBER => tags::LITERAL_NUMERIC,\n-            BYTE => tags::LITERAL_BYTE,\n-            CHAR => tags::LITERAL_CHAR,\n-            LIFETIME => tags::TYPE_LIFETIME,\n-            T![unsafe] => tags::KEYWORD_UNSAFE,\n-            k if is_control_keyword(k) => tags::KEYWORD_CONTROL,\n-            k if k.is_keyword() => tags::KEYWORD,\n-            _ => {\n-                if let Some(macro_call) = node.as_node().cloned().and_then(ast::MacroCall::cast) {\n-                    if let Some(path) = macro_call.path() {\n-                        if let Some(segment) = path.segment() {\n-                            if let Some(name_ref) = segment.name_ref() {\n-                                highlighted.insert(name_ref.syntax().clone().into());\n-                                let range_start = name_ref.syntax().text_range().start();\n-                                let mut range_end = name_ref.syntax().text_range().end();\n-                                for sibling in path.syntax().siblings_with_tokens(Direction::Next) {\n-                                    match sibling.kind() {\n-                                        T![!] | IDENT => range_end = sibling.text_range().end(),\n-                                        _ => (),\n-                                    }\n-                                }\n-                                res.push(HighlightedRange {\n-                                    range: TextRange::from_to(range_start, range_end),\n-                                    tag: tags::MACRO,\n-                                    binding_hash: None,\n-                                })\n-                            }\n-                        }\n-                    }\n+        }\n+        NAME => {\n+            let name = node.value.as_node().cloned().and_then(ast::Name::cast).unwrap();\n+            let name_kind = classify_name(sb, node.with_value(&name)).map(|d| d.kind);\n+\n+            if let Some(Local(local)) = &name_kind {\n+                if let Some(name) = local.name(db) {\n+                    let shadow_count = bindings_shadow_count.entry(name.clone()).or_default();\n+                    *shadow_count += 1;\n+                    binding_hash = Some(calc_binding_hash(node.file_id, &name, *shadow_count))\n                 }\n-                continue;\n+            };\n+\n+            match name_kind {\n+                Some(name_kind) => highlight_name(db, name_kind),\n+                None => name.syntax().parent().map_or(tags::FUNCTION, |x| match x.kind() {\n+                    STRUCT_DEF | ENUM_DEF | TRAIT_DEF | TYPE_ALIAS_DEF => tags::TYPE,\n+                    TYPE_PARAM => tags::TYPE_PARAM,\n+                    RECORD_FIELD_DEF => tags::FIELD,\n+                    _ => tags::FUNCTION,\n+                }),\n             }\n-        };\n-        res.push(HighlightedRange { range: node.text_range(), tag, binding_hash })\n+        }\n+        INT_NUMBER | FLOAT_NUMBER => tags::LITERAL_NUMERIC,\n+        BYTE => tags::LITERAL_BYTE,\n+        CHAR => tags::LITERAL_CHAR,\n+        LIFETIME => tags::TYPE_LIFETIME,\n+        T![unsafe] => tags::KEYWORD_UNSAFE,\n+        k if is_control_keyword(k) => tags::KEYWORD_CONTROL,\n+        k if k.is_keyword() => tags::KEYWORD,\n+\n+        _ => return None,\n+    };\n+\n+    return Some((tag, binding_hash));\n+\n+    fn calc_binding_hash(file_id: HirFileId, name: &Name, shadow_count: u32) -> u64 {\n+        fn hash<T: std::hash::Hash + std::fmt::Debug>(x: T) -> u64 {\n+            use std::{collections::hash_map::DefaultHasher, hash::Hasher};\n+\n+            let mut hasher = DefaultHasher::new();\n+            x.hash(&mut hasher);\n+            hasher.finish()\n+        }\n+\n+        hash((file_id, name, shadow_count))\n     }\n-    res\n }\n \n pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: bool) -> String {\n@@ -251,19 +320,16 @@ pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: boo\n fn highlight_name(db: &RootDatabase, name_kind: NameKind) -> &'static str {\n     match name_kind {\n         Macro(_) => tags::MACRO,\n-        Field(_) => tags::FIELD,\n-        AssocItem(hir::AssocItem::Function(_)) => tags::FUNCTION,\n-        AssocItem(hir::AssocItem::Const(_)) => tags::CONSTANT,\n-        AssocItem(hir::AssocItem::TypeAlias(_)) => tags::TYPE,\n-        Def(hir::ModuleDef::Module(_)) => tags::MODULE,\n-        Def(hir::ModuleDef::Function(_)) => tags::FUNCTION,\n-        Def(hir::ModuleDef::Adt(_)) => tags::TYPE,\n-        Def(hir::ModuleDef::EnumVariant(_)) => tags::CONSTANT,\n-        Def(hir::ModuleDef::Const(_)) => tags::CONSTANT,\n-        Def(hir::ModuleDef::Static(_)) => tags::CONSTANT,\n-        Def(hir::ModuleDef::Trait(_)) => tags::TYPE,\n-        Def(hir::ModuleDef::TypeAlias(_)) => tags::TYPE,\n-        Def(hir::ModuleDef::BuiltinType(_)) => tags::TYPE_BUILTIN,\n+        StructField(_) => tags::FIELD,\n+        ModuleDef(hir::ModuleDef::Module(_)) => tags::MODULE,\n+        ModuleDef(hir::ModuleDef::Function(_)) => tags::FUNCTION,\n+        ModuleDef(hir::ModuleDef::Adt(_)) => tags::TYPE,\n+        ModuleDef(hir::ModuleDef::EnumVariant(_)) => tags::CONSTANT,\n+        ModuleDef(hir::ModuleDef::Const(_)) => tags::CONSTANT,\n+        ModuleDef(hir::ModuleDef::Static(_)) => tags::CONSTANT,\n+        ModuleDef(hir::ModuleDef::Trait(_)) => tags::TYPE,\n+        ModuleDef(hir::ModuleDef::TypeAlias(_)) => tags::TYPE,\n+        ModuleDef(hir::ModuleDef::BuiltinType(_)) => tags::TYPE_BUILTIN,\n         SelfType(_) => tags::TYPE_SELF,\n         TypeParam(_) => tags::TYPE_PARAM,\n         Local(local) => {\n@@ -331,6 +397,16 @@ fn foo<T>() -> T {\n     foo::<i32>();\n }\n \n+macro_rules! def_fn {\n+    ($($tt:tt)*) => {$($tt)*}\n+}\n+\n+def_fn!{\n+    fn bar() -> u32 {\n+        100\n+    }\n+}\n+\n // comment\n fn main() {\n     println!(\"Hello, {}!\", 92);"}, {"sha": "55966daf3bdc0387771d8aebee75f9592a8748ed", "filename": "crates/ra_ide/src/syntax_tree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,7 +1,7 @@\n //! FIXME: write short doc here\n \n-use crate::db::RootDatabase;\n use ra_db::SourceDatabase;\n+use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo, AstNode, NodeOrToken, SourceFile,\n     SyntaxKind::{RAW_STRING, STRING},"}, {"sha": "e5d1779fdc140742207bf3af7b4cf51696516b44", "filename": "crates/ra_ide/src/typing.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ftyping.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -15,6 +15,7 @@\n \n use ra_db::{FilePosition, SourceDatabase};\n use ra_fmt::leading_indent;\n+use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo::find_node_at_offset,\n     ast::{self, AstToken},\n@@ -24,7 +25,7 @@ use ra_syntax::{\n };\n use ra_text_edit::TextEdit;\n \n-use crate::{db::RootDatabase, source_change::SingleFileChange, SourceChange, SourceFileEdit};\n+use crate::{source_change::SingleFileChange, SourceChange, SourceFileEdit};\n \n pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<SourceChange> {\n     let parse = db.parse(position.file_id);"}, {"sha": "716e88bc1bf0ea34a35117e383ee0714afb925ea", "filename": "crates/ra_ide_db/Cargo.toml", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2FCargo.toml?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,47 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_ide_db\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+\n+[lib]\n+doctest = false\n+\n+[features]\n+wasm = []\n+\n+[dependencies]\n+either = \"1.5\"\n+format-buf = \"1.0.0\"\n+indexmap = \"1.3.0\"\n+itertools = \"0.8.0\"\n+join_to_string = \"0.1.3\"\n+log = \"0.4.5\"\n+rayon = \"1.0.2\"\n+fst = { version = \"0.3.1\", default-features = false }\n+rustc-hash = \"1.0\"\n+unicase = \"2.2.0\"\n+superslice = \"1.0.0\"\n+rand = { version = \"0.7.0\", features = [\"small_rng\"] }\n+once_cell = \"1.2.0\"\n+\n+ra_syntax = { path = \"../ra_syntax\" }\n+ra_text_edit = { path = \"../ra_text_edit\" }\n+ra_db = { path = \"../ra_db\" }\n+ra_cfg = { path = \"../ra_cfg\" }\n+ra_fmt = { path = \"../ra_fmt\" }\n+ra_prof = { path = \"../ra_prof\" }\n+test_utils = { path = \"../test_utils\" }\n+\n+# ra_ide should depend only on the top-level `hir` package. if you need\n+# something from some `hir_xxx` subpackage, reexport the API via `hir`.\n+hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n+\n+[dev-dependencies]\n+insta = \"0.13.0\"\n+\n+[dev-dependencies.proptest]\n+version = \"0.9.0\"\n+# Disable `fork` feature to allow compiling on webassembly\n+default-features = false\n+features = [\"std\", \"bit-set\", \"break-dead-code\"]"}, {"sha": "4668784d3f13e46db5a1cf7974ed106a2947b04a", "filename": "crates/ra_ide_db/src/change.rs", "status": "renamed", "additions": 55, "deletions": 21, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fchange.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,4 +1,5 @@\n-//! FIXME: write short doc here\n+//! Defines a unit of change that can applied to a state of IDE to get the next\n+//! state. Changes are transactional.\n \n use std::{fmt, sync::Arc, time};\n \n@@ -14,8 +15,8 @@ use rayon::prelude::*;\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    db::{DebugData, RootDatabase},\n     symbol_index::{SymbolIndex, SymbolsDatabase},\n+    DebugData, RootDatabase,\n };\n \n #[derive(Default)]\n@@ -145,6 +146,8 @@ impl LibraryData {\n         root_id: SourceRootId,\n         files: Vec<(FileId, RelativePathBuf, Arc<String>)>,\n     ) -> LibraryData {\n+        let _p = profile(\"LibraryData::prepare\");\n+\n         #[cfg(not(feature = \"wasm\"))]\n         let iter = files.par_iter();\n         #[cfg(feature = \"wasm\")]\n@@ -166,13 +169,15 @@ impl LibraryData {\n const GC_COOLDOWN: time::Duration = time::Duration::from_millis(100);\n \n impl RootDatabase {\n-    pub(crate) fn apply_change(&mut self, change: AnalysisChange) {\n+    pub fn request_cancellation(&mut self) {\n+        let _p = profile(\"RootDatabase::request_cancellation\");\n+        self.salsa_runtime_mut().synthetic_write(Durability::LOW);\n+    }\n+\n+    pub fn apply_change(&mut self, change: AnalysisChange) {\n         let _p = profile(\"RootDatabase::apply_change\");\n+        self.request_cancellation();\n         log::info!(\"apply_change {:?}\", change);\n-        {\n-            let _p = profile(\"RootDatabase::apply_change/cancellation\");\n-            self.salsa_runtime_mut().synthetic_write(Durability::LOW);\n-        }\n         if !change.new_roots.is_empty() {\n             let mut local_roots = Vec::clone(&self.local_roots());\n             for (root_id, is_local) in change.new_roots {\n@@ -241,7 +246,7 @@ impl RootDatabase {\n         self.set_source_root_with_durability(root_id, Arc::new(source_root), durability);\n     }\n \n-    pub(crate) fn maybe_collect_garbage(&mut self) {\n+    pub fn maybe_collect_garbage(&mut self) {\n         if cfg!(feature = \"wasm\") {\n             return;\n         }\n@@ -251,7 +256,7 @@ impl RootDatabase {\n         }\n     }\n \n-    pub(crate) fn collect_garbage(&mut self) {\n+    pub fn collect_garbage(&mut self) {\n         if cfg!(feature = \"wasm\") {\n             return;\n         }\n@@ -278,7 +283,7 @@ impl RootDatabase {\n         self.query(hir::db::BodyQuery).sweep(sweep);\n     }\n \n-    pub(crate) fn per_query_memory_usage(&mut self) -> Vec<(String, Bytes)> {\n+    pub fn per_query_memory_usage(&mut self) -> Vec<(String, Bytes)> {\n         let mut acc: Vec<(String, Bytes)> = vec![];\n         let sweep = SweepStrategy::default().discard_values().sweep_all_revisions();\n         macro_rules! sweep_each_query {\n@@ -299,45 +304,74 @@ impl RootDatabase {\n             )*}\n         }\n         sweep_each_query![\n+            // SourceDatabase\n             ra_db::ParseQuery\n             ra_db::SourceRootCratesQuery\n+\n+            // AstDatabase\n             hir::db::AstIdMapQuery\n-            hir::db::ParseMacroQuery\n-            hir::db::MacroDefQuery\n+            hir::db::InternMacroQuery\n             hir::db::MacroArgQuery\n+            hir::db::MacroDefQuery\n+            hir::db::ParseMacroQuery\n             hir::db::MacroExpandQuery\n+\n+            // DefDatabase\n+            hir::db::RawItemsQuery\n+            hir::db::ComputeCrateDefMapQuery\n             hir::db::StructDataQuery\n+            hir::db::UnionDataQuery\n             hir::db::EnumDataQuery\n+            hir::db::ImplDataQuery\n             hir::db::TraitDataQuery\n-            hir::db::RawItemsQuery\n-            hir::db::ComputeCrateDefMapQuery\n-            hir::db::GenericParamsQuery\n-            hir::db::FunctionDataQuery\n             hir::db::TypeAliasDataQuery\n+            hir::db::FunctionDataQuery\n             hir::db::ConstDataQuery\n             hir::db::StaticDataQuery\n+            hir::db::BodyWithSourceMapQuery\n+            hir::db::BodyQuery\n+            hir::db::ExprScopesQuery\n+            hir::db::GenericParamsQuery\n+            hir::db::AttrsQuery\n             hir::db::ModuleLangItemsQuery\n             hir::db::CrateLangItemsQuery\n             hir::db::LangItemQuery\n             hir::db::DocumentationQuery\n-            hir::db::ExprScopesQuery\n+\n+            // InternDatabase\n+            hir::db::InternFunctionQuery\n+            hir::db::InternStructQuery\n+            hir::db::InternUnionQuery\n+            hir::db::InternEnumQuery\n+            hir::db::InternConstQuery\n+            hir::db::InternStaticQuery\n+            hir::db::InternTraitQuery\n+            hir::db::InternTypeAliasQuery\n+            hir::db::InternImplQuery\n+\n+            // HirDatabase\n             hir::db::DoInferQuery\n             hir::db::TyQuery\n             hir::db::ValueTyQuery\n+            hir::db::ImplSelfTyQuery\n+            hir::db::ImplTraitQuery\n             hir::db::FieldTypesQuery\n             hir::db::CallableItemSignatureQuery\n+            hir::db::GenericPredicatesForParamQuery\n             hir::db::GenericPredicatesQuery\n             hir::db::GenericDefaultsQuery\n-            hir::db::BodyWithSourceMapQuery\n-            hir::db::BodyQuery\n             hir::db::ImplsInCrateQuery\n             hir::db::ImplsForTraitQuery\n+            hir::db::TraitSolverQuery\n+            hir::db::InternTypeCtorQuery\n+            hir::db::InternChalkImplQuery\n+            hir::db::InternAssocTyValueQuery\n             hir::db::AssociatedTyDataQuery\n+            hir::db::AssociatedTyValueQuery\n+            hir::db::TraitSolveQuery\n             hir::db::TraitDatumQuery\n             hir::db::StructDatumQuery\n             hir::db::ImplDatumQuery\n-            hir::db::ImplDataQuery\n-            hir::db::TraitSolveQuery\n         ];\n         acc.sort_by_key(|it| std::cmp::Reverse(it.1));\n         acc", "previous_filename": "crates/ra_ide/src/change.rs"}, {"sha": "030f44f8649ddc1b0f0e4eb5ce3bcec8ee0bfd80", "filename": "crates/ra_ide_db/src/defs.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,172 @@\n+//! `NameDefinition` keeps information about the element we want to search references for.\n+//! The element is represented by `NameKind`. It's located inside some `container` and\n+//! has a `visibility`, which defines a search scope.\n+//! Note that the reference search is possible for not all of the classified items.\n+\n+// FIXME: this badly needs rename/rewrite (matklad, 2020-02-06).\n+\n+use hir::{\n+    Adt, HasSource, ImplBlock, InFile, Local, MacroDef, Module, ModuleDef, SourceBinder,\n+    StructField, TypeParam, VariantDef,\n+};\n+use ra_prof::profile;\n+use ra_syntax::{\n+    ast::{self, AstNode, VisibilityOwner},\n+    match_ast,\n+};\n+\n+use crate::RootDatabase;\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum NameKind {\n+    Macro(MacroDef),\n+    StructField(StructField),\n+    ModuleDef(ModuleDef),\n+    SelfType(ImplBlock),\n+    Local(Local),\n+    TypeParam(TypeParam),\n+}\n+\n+#[derive(PartialEq, Eq)]\n+pub struct NameDefinition {\n+    pub visibility: Option<ast::Visibility>,\n+    /// FIXME: this doesn't really make sense. For example, builtin types don't\n+    /// really have a module.\n+    pub container: Module,\n+    pub kind: NameKind,\n+}\n+\n+pub fn classify_name(\n+    sb: &mut SourceBinder<RootDatabase>,\n+    name: InFile<&ast::Name>,\n+) -> Option<NameDefinition> {\n+    let _p = profile(\"classify_name\");\n+    let parent = name.value.syntax().parent()?;\n+\n+    match_ast! {\n+        match parent {\n+            ast::BindPat(it) => {\n+                let src = name.with_value(it);\n+                let local = sb.to_def(src)?;\n+                Some(NameDefinition {\n+                    visibility: None,\n+                    container: local.module(sb.db),\n+                    kind: NameKind::Local(local),\n+                })\n+            },\n+            ast::RecordFieldDef(it) => {\n+                let src = name.with_value(it);\n+                let field: hir::StructField = sb.to_def(src)?;\n+                Some(from_struct_field(sb.db, field))\n+            },\n+            ast::Module(it) => {\n+                let def = sb.to_def(name.with_value(it))?;\n+                Some(from_module_def(sb.db, def.into(), None))\n+            },\n+            ast::StructDef(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::Struct = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n+            },\n+            ast::EnumDef(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::Enum = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n+            },\n+            ast::TraitDef(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::Trait = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n+            },\n+            ast::StaticDef(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::Static = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n+            },\n+            ast::EnumVariant(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::EnumVariant = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n+            },\n+            ast::FnDef(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::Function = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n+            },\n+            ast::ConstDef(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::Const = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n+            },\n+            ast::TypeAliasDef(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::TypeAlias = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n+            },\n+            ast::MacroCall(it) => {\n+                let src = name.with_value(it);\n+                let def = sb.to_def(src.clone())?;\n+\n+                let module = sb.to_module_def(src.file_id.original_file(sb.db))?;\n+\n+                Some(NameDefinition {\n+                    visibility: None,\n+                    container: module,\n+                    kind: NameKind::Macro(def),\n+                })\n+            },\n+            ast::TypeParam(it) => {\n+                let src = name.with_value(it);\n+                let def = sb.to_def(src)?;\n+                Some(NameDefinition {\n+                    visibility: None,\n+                    container: def.module(sb.db),\n+                    kind: NameKind::TypeParam(def),\n+                })\n+            },\n+            _ => None,\n+        }\n+    }\n+}\n+\n+pub fn from_struct_field(db: &RootDatabase, field: StructField) -> NameDefinition {\n+    let kind = NameKind::StructField(field);\n+    let parent = field.parent_def(db);\n+    let container = parent.module(db);\n+    let visibility = match parent {\n+        VariantDef::Struct(s) => s.source(db).value.visibility(),\n+        VariantDef::Union(e) => e.source(db).value.visibility(),\n+        VariantDef::EnumVariant(e) => e.source(db).value.parent_enum().visibility(),\n+    };\n+    NameDefinition { kind, container, visibility }\n+}\n+\n+pub fn from_module_def(\n+    db: &RootDatabase,\n+    def: ModuleDef,\n+    module: Option<Module>,\n+) -> NameDefinition {\n+    let kind = NameKind::ModuleDef(def);\n+    let (container, visibility) = match def {\n+        ModuleDef::Module(it) => {\n+            let container = it.parent(db).or_else(|| Some(it)).unwrap();\n+            let visibility = it.declaration_source(db).and_then(|s| s.value.visibility());\n+            (container, visibility)\n+        }\n+        ModuleDef::EnumVariant(it) => {\n+            let container = it.module(db);\n+            let visibility = it.source(db).value.parent_enum().visibility();\n+            (container, visibility)\n+        }\n+        ModuleDef::Function(it) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Const(it) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Static(it) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Trait(it) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::TypeAlias(it) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Adt(Adt::Struct(it)) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Adt(Adt::Union(it)) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Adt(Adt::Enum(it)) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::BuiltinType(..) => (module.unwrap(), None),\n+    };\n+    NameDefinition { kind, container, visibility }\n+}"}, {"sha": "1b3cabf4d95f570e0b461d0575b5c98c99db3e06", "filename": "crates/ra_ide_db/src/feature_flags.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide_db%2Fsrc%2Ffeature_flags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide_db%2Fsrc%2Ffeature_flags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Ffeature_flags.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,4 +1,4 @@\n-//! FIXME: write short doc here\n+//! See docs for `FeatureFlags`.\n \n use rustc_hash::FxHashMap;\n ", "previous_filename": "crates/ra_ide/src/feature_flags.rs"}, {"sha": "86383bcd03c9e6ca63bb189454561ae9396b2516", "filename": "crates/ra_ide_db/src/imports_locator.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide_db%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide_db%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fimports_locator.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,72 @@\n+//! This module contains an import search funcionality that is provided to the ra_assists module.\n+//! Later, this should be moved away to a separate crate that is accessible from the ra_assists module.\n+\n+use hir::{db::HirDatabase, ModuleDef, SourceBinder};\n+use ra_prof::profile;\n+use ra_syntax::{ast, AstNode, SyntaxKind::NAME};\n+\n+use crate::{\n+    defs::classify_name,\n+    defs::NameKind,\n+    symbol_index::{self, FileSymbol, Query},\n+    RootDatabase,\n+};\n+\n+pub struct ImportsLocator<'a> {\n+    source_binder: SourceBinder<'a, RootDatabase>,\n+}\n+\n+impl<'a> ImportsLocator<'a> {\n+    pub fn new(db: &'a RootDatabase) -> Self {\n+        Self { source_binder: SourceBinder::new(db) }\n+    }\n+\n+    pub fn find_imports(&mut self, name_to_import: &str) -> Vec<ModuleDef> {\n+        let _p = profile(\"search_for_imports\");\n+        let db = self.source_binder.db;\n+\n+        let project_results = {\n+            let mut query = Query::new(name_to_import.to_string());\n+            query.exact();\n+            query.limit(40);\n+            symbol_index::world_symbols(db, query)\n+        };\n+        let lib_results = {\n+            let mut query = Query::new(name_to_import.to_string());\n+            query.libs();\n+            query.exact();\n+            query.limit(40);\n+            symbol_index::world_symbols(db, query)\n+        };\n+\n+        project_results\n+            .into_iter()\n+            .chain(lib_results.into_iter())\n+            .filter_map(|import_candidate| self.get_name_definition(db, &import_candidate))\n+            .filter_map(|name_definition_to_import| match name_definition_to_import {\n+                NameKind::ModuleDef(module_def) => Some(module_def),\n+                _ => None,\n+            })\n+            .collect()\n+    }\n+\n+    fn get_name_definition(\n+        &mut self,\n+        db: &impl HirDatabase,\n+        import_candidate: &FileSymbol,\n+    ) -> Option<NameKind> {\n+        let _p = profile(\"get_name_definition\");\n+        let file_id = import_candidate.file_id.into();\n+        let candidate_node = import_candidate.ptr.to_node(&db.parse_or_expand(file_id)?);\n+        let candidate_name_node = if candidate_node.kind() != NAME {\n+            candidate_node.children().find(|it| it.kind() == NAME)?\n+        } else {\n+            candidate_node\n+        };\n+        classify_name(\n+            &mut self.source_binder,\n+            hir::InFile { file_id, value: &ast::Name::cast(candidate_name_node)? },\n+        )\n+        .map(|it| it.kind)\n+    }\n+}"}, {"sha": "877ac3c38e3cf24402f4189918d6d7dea8aac867", "filename": "crates/ra_ide_db/src/lib.rs", "status": "renamed", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Flib.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,4 +1,15 @@\n-//! FIXME: write short doc here\n+//! This crate defines the core datastructure representing IDE state -- `RootDatabase`.\n+//!\n+//! It is mainly a `HirDatabase` for semantic analysis, plus a `SymbolsDatabase`, for fuzzy search.\n+\n+pub mod line_index;\n+pub mod line_index_utils;\n+pub mod feature_flags;\n+pub mod symbol_index;\n+pub mod change;\n+pub mod defs;\n+pub mod imports_locator;\n+mod wasm_shims;\n \n use std::sync::Arc;\n \n@@ -9,10 +20,7 @@ use ra_db::{\n };\n use rustc_hash::FxHashMap;\n \n-use crate::{\n-    symbol_index::{self, SymbolsDatabase},\n-    FeatureFlags, LineIndex,\n-};\n+use crate::{feature_flags::FeatureFlags, line_index::LineIndex, symbol_index::SymbolsDatabase};\n \n #[salsa::database(\n     ra_db::SourceDatabaseStorage,\n@@ -25,12 +33,12 @@ use crate::{\n     hir::db::HirDatabaseStorage\n )]\n #[derive(Debug)]\n-pub(crate) struct RootDatabase {\n+pub struct RootDatabase {\n     runtime: salsa::Runtime<RootDatabase>,\n-    pub(crate) feature_flags: Arc<FeatureFlags>,\n+    pub feature_flags: Arc<FeatureFlags>,\n     pub(crate) debug_data: Arc<DebugData>,\n-    pub(crate) last_gc: crate::wasm_shims::Instant,\n-    pub(crate) last_gc_check: crate::wasm_shims::Instant,\n+    pub last_gc: crate::wasm_shims::Instant,\n+    pub last_gc_check: crate::wasm_shims::Instant,\n }\n \n impl FileLoader for RootDatabase {\n@@ -109,7 +117,7 @@ impl salsa::ParallelDatabase for RootDatabase {\n }\n \n #[salsa::query_group(LineIndexDatabaseStorage)]\n-pub(crate) trait LineIndexDatabase: ra_db::SourceDatabase + CheckCanceled {\n+pub trait LineIndexDatabase: ra_db::SourceDatabase + CheckCanceled {\n     fn line_index(&self, file_id: FileId) -> Arc<LineIndex>;\n }\n ", "previous_filename": "crates/ra_ide/src/db.rs"}, {"sha": "452c87ac513523931a42b0ebb06e25d04f0a0426", "filename": "crates/ra_ide_db/src/line_index.rs", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide_db%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide_db%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fline_index.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,6 +1,7 @@\n-//! FIXME: write short doc here\n+//! `LineIndex` maps flat `TextUnit` offsets into `(Line, Column)`\n+//! representation.\n \n-use crate::TextUnit;\n+use ra_syntax::TextUnit;\n use rustc_hash::FxHashMap;\n use superslice::Ext;\n ", "previous_filename": "crates/ra_ide/src/line_index.rs"}, {"sha": "435b06511663ff8653ba90fdfc36f2daff80c49d", "filename": "crates/ra_ide_db/src/line_index_utils.rs", "status": "renamed", "additions": 87, "deletions": 77, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide_db%2Fsrc%2Fline_index_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide_db%2Fsrc%2Fline_index_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fline_index_utils.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,9 +1,87 @@\n-//! FIXME: write short doc here\n+//! Code actions can specify desirable final position of the cursor.\n+//!\n+//! The position is specified as a `TextUnit` in the final file. We need to send\n+//! it in `(Line, Column)` coordinate though. However, we only have a LineIndex\n+//! for a file pre-edit!\n+//!\n+//! Code in this module applies this \"to (Line, Column) after edit\"\n+//! transformation.\n \n-use crate::{line_index::Utf16Char, LineCol, LineIndex};\n use ra_syntax::{TextRange, TextUnit};\n use ra_text_edit::{AtomTextEdit, TextEdit};\n \n+use crate::line_index::{LineCol, LineIndex, Utf16Char};\n+\n+pub fn translate_offset_with_edit(\n+    line_index: &LineIndex,\n+    offset: TextUnit,\n+    text_edit: &TextEdit,\n+) -> LineCol {\n+    let mut state = Edits::from_text_edit(&text_edit);\n+\n+    let mut res = RunningLineCol::new();\n+\n+    macro_rules! test_step {\n+        ($x:ident) => {\n+            match &$x {\n+                Step::Newline(n) => {\n+                    if offset < *n {\n+                        return res.to_line_col(offset);\n+                    } else {\n+                        res.add_line(*n);\n+                    }\n+                }\n+                Step::Utf16Char(x) => {\n+                    if offset < x.end() {\n+                        // if the offset is inside a multibyte char it's invalid\n+                        // clamp it to the start of the char\n+                        let clamp = offset.min(x.start());\n+                        return res.to_line_col(clamp);\n+                    } else {\n+                        res.adjust_col(*x);\n+                    }\n+                }\n+            }\n+        };\n+    }\n+\n+    for orig_step in LineIndexStepIter::from(line_index) {\n+        loop {\n+            let translated_step = state.translate_step(&orig_step);\n+            match state.next_steps(&translated_step) {\n+                NextSteps::Use => {\n+                    test_step!(translated_step);\n+                    break;\n+                }\n+                NextSteps::ReplaceMany(ns) => {\n+                    for n in ns {\n+                        test_step!(n);\n+                    }\n+                    break;\n+                }\n+                NextSteps::AddMany(ns) => {\n+                    for n in ns {\n+                        test_step!(n);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    loop {\n+        match state.next_inserted_steps() {\n+            None => break,\n+            Some(ns) => {\n+                for n in ns {\n+                    test_step!(n);\n+                }\n+            }\n+        }\n+    }\n+\n+    res.to_line_col(offset)\n+}\n+\n #[derive(Debug, Clone)]\n enum Step {\n     Newline(TextUnit),\n@@ -17,7 +95,7 @@ struct LineIndexStepIter<'a> {\n     utf16_chars: Option<(TextUnit, std::slice::Iter<'a, Utf16Char>)>,\n }\n \n-impl<'a> LineIndexStepIter<'a> {\n+impl LineIndexStepIter<'_> {\n     fn from(line_index: &LineIndex) -> LineIndexStepIter {\n         let mut x = LineIndexStepIter { line_index, next_newline_idx: 0, utf16_chars: None };\n         // skip first newline since it's not real\n@@ -26,7 +104,7 @@ impl<'a> LineIndexStepIter<'a> {\n     }\n }\n \n-impl<'a> Iterator for LineIndexStepIter<'a> {\n+impl Iterator for LineIndexStepIter<'_> {\n     type Item = Step;\n     fn next(&mut self) -> Option<Step> {\n         self.utf16_chars\n@@ -54,7 +132,7 @@ struct OffsetStepIter<'a> {\n     offset: TextUnit,\n }\n \n-impl<'a> Iterator for OffsetStepIter<'a> {\n+impl Iterator for OffsetStepIter<'_> {\n     type Item = Step;\n     fn next(&mut self) -> Option<Step> {\n         let (next, next_offset) = self\n@@ -220,84 +298,16 @@ impl RunningLineCol {\n     }\n }\n \n-pub fn translate_offset_with_edit(\n-    line_index: &LineIndex,\n-    offset: TextUnit,\n-    text_edit: &TextEdit,\n-) -> LineCol {\n-    let mut state = Edits::from_text_edit(&text_edit);\n-\n-    let mut res = RunningLineCol::new();\n-\n-    macro_rules! test_step {\n-        ($x:ident) => {\n-            match &$x {\n-                Step::Newline(n) => {\n-                    if offset < *n {\n-                        return res.to_line_col(offset);\n-                    } else {\n-                        res.add_line(*n);\n-                    }\n-                }\n-                Step::Utf16Char(x) => {\n-                    if offset < x.end() {\n-                        // if the offset is inside a multibyte char it's invalid\n-                        // clamp it to the start of the char\n-                        let clamp = offset.min(x.start());\n-                        return res.to_line_col(clamp);\n-                    } else {\n-                        res.adjust_col(*x);\n-                    }\n-                }\n-            }\n-        };\n-    }\n-\n-    for orig_step in LineIndexStepIter::from(line_index) {\n-        loop {\n-            let translated_step = state.translate_step(&orig_step);\n-            match state.next_steps(&translated_step) {\n-                NextSteps::Use => {\n-                    test_step!(translated_step);\n-                    break;\n-                }\n-                NextSteps::ReplaceMany(ns) => {\n-                    for n in ns {\n-                        test_step!(n);\n-                    }\n-                    break;\n-                }\n-                NextSteps::AddMany(ns) => {\n-                    for n in ns {\n-                        test_step!(n);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    loop {\n-        match state.next_inserted_steps() {\n-            None => break,\n-            Some(ns) => {\n-                for n in ns {\n-                    test_step!(n);\n-                }\n-            }\n-        }\n-    }\n-\n-    res.to_line_col(offset)\n-}\n-\n #[cfg(test)]\n mod test {\n-    use super::*;\n-    use crate::line_index;\n     use proptest::{prelude::*, proptest};\n     use ra_text_edit::test_utils::{arb_offset, arb_text_with_edit};\n     use ra_text_edit::TextEdit;\n \n+    use crate::line_index;\n+\n+    use super::*;\n+\n     #[derive(Debug)]\n     struct ArbTextWithEditAndOffset {\n         text: String,", "previous_filename": "crates/ra_ide/src/line_index_utils.rs"}, {"sha": "64ddf2f95e2aca72e694265efeb07a9881ee58e6", "filename": "crates/ra_ide_db/src/symbol_index.rs", "status": "renamed", "additions": 56, "deletions": 89, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -19,6 +19,7 @@\n //! for each library (which is assumed to never change) and an FST for each Rust\n //! file in the current workspace, and run a query against the union of all\n //! those FSTs.\n+\n use std::{\n     fmt,\n     hash::{Hash, Hasher},\n@@ -29,7 +30,7 @@ use std::{\n use fst::{self, Streamer};\n use ra_db::{\n     salsa::{self, ParallelDatabase},\n-    SourceDatabaseExt, SourceRootId,\n+    FileId, SourceDatabaseExt, SourceRootId,\n };\n use ra_syntax::{\n     ast::{self, NameOwner},\n@@ -40,10 +41,50 @@ use ra_syntax::{\n #[cfg(not(feature = \"wasm\"))]\n use rayon::prelude::*;\n \n-use crate::{db::RootDatabase, FileId, Query};\n+use crate::RootDatabase;\n+\n+#[derive(Debug)]\n+pub struct Query {\n+    query: String,\n+    lowercased: String,\n+    only_types: bool,\n+    libs: bool,\n+    exact: bool,\n+    limit: usize,\n+}\n+\n+impl Query {\n+    pub fn new(query: String) -> Query {\n+        let lowercased = query.to_lowercase();\n+        Query {\n+            query,\n+            lowercased,\n+            only_types: false,\n+            libs: false,\n+            exact: false,\n+            limit: usize::max_value(),\n+        }\n+    }\n+\n+    pub fn only_types(&mut self) {\n+        self.only_types = true;\n+    }\n+\n+    pub fn libs(&mut self) {\n+        self.libs = true;\n+    }\n+\n+    pub fn exact(&mut self) {\n+        self.exact = true;\n+    }\n+\n+    pub fn limit(&mut self, limit: usize) {\n+        self.limit = limit\n+    }\n+}\n \n #[salsa::query_group(SymbolsDatabaseStorage)]\n-pub(crate) trait SymbolsDatabase: hir::db::HirDatabase {\n+pub trait SymbolsDatabase: hir::db::HirDatabase {\n     fn file_symbols(&self, file_id: FileId) -> Arc<SymbolIndex>;\n     #[salsa::input]\n     fn library_symbols(&self, id: SourceRootId) -> Arc<SymbolIndex>;\n@@ -68,7 +109,7 @@ fn file_symbols(db: &impl SymbolsDatabase, file_id: FileId) -> Arc<SymbolIndex>\n     Arc::new(SymbolIndex::new(symbols))\n }\n \n-pub(crate) fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol> {\n+pub fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol> {\n     /// Need to wrap Snapshot to provide `Clone` impl for `map_with`\n     struct Snap(salsa::Snapshot<RootDatabase>);\n     impl Clone for Snap {\n@@ -110,16 +151,16 @@ pub(crate) fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol>\n     query.search(&buf)\n }\n \n-pub(crate) fn index_resolve(db: &RootDatabase, name_ref: &ast::NameRef) -> Vec<FileSymbol> {\n+pub fn index_resolve(db: &RootDatabase, name_ref: &ast::NameRef) -> Vec<FileSymbol> {\n     let name = name_ref.text();\n     let mut query = Query::new(name.to_string());\n     query.exact();\n     query.limit(4);\n-    crate::symbol_index::world_symbols(db, query)\n+    world_symbols(db, query)\n }\n \n #[derive(Default)]\n-pub(crate) struct SymbolIndex {\n+pub struct SymbolIndex {\n     symbols: Vec<FileSymbol>,\n     map: fst::Map,\n }\n@@ -178,11 +219,11 @@ impl SymbolIndex {\n         SymbolIndex { symbols, map }\n     }\n \n-    pub(crate) fn len(&self) -> usize {\n+    pub fn len(&self) -> usize {\n         self.symbols.len()\n     }\n \n-    pub(crate) fn memory_size(&self) -> usize {\n+    pub fn memory_size(&self) -> usize {\n         self.map.as_fst().size() + self.symbols.len() * mem::size_of::<FileSymbol>()\n     }\n \n@@ -262,12 +303,12 @@ fn is_type(kind: SyntaxKind) -> bool {\n /// The actual data that is stored in the index. It should be as compact as\n /// possible.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub(crate) struct FileSymbol {\n-    pub(crate) file_id: FileId,\n-    pub(crate) name: SmolStr,\n-    pub(crate) ptr: SyntaxNodePtr,\n-    pub(crate) name_range: Option<TextRange>,\n-    pub(crate) container_name: Option<SmolStr>,\n+pub struct FileSymbol {\n+    pub file_id: FileId,\n+    pub name: SmolStr,\n+    pub ptr: SyntaxNodePtr,\n+    pub name_range: Option<TextRange>,\n+    pub container_name: Option<SmolStr>,\n }\n \n fn source_file_to_file_symbols(source_file: &SourceFile, file_id: FileId) -> Vec<FileSymbol> {\n@@ -329,77 +370,3 @@ fn to_file_symbol(node: &SyntaxNode, file_id: FileId) -> Option<FileSymbol> {\n         container_name: None,\n     })\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::{display::NavigationTarget, mock_analysis::single_file, Query};\n-    use ra_syntax::{\n-        SmolStr,\n-        SyntaxKind::{FN_DEF, STRUCT_DEF},\n-    };\n-\n-    #[test]\n-    fn test_world_symbols_with_no_container() {\n-        let code = r#\"\n-    enum FooInner { }\n-    \"#;\n-\n-        let mut symbols = get_symbols_matching(code, \"FooInner\");\n-\n-        let s = symbols.pop().unwrap();\n-\n-        assert_eq!(s.name(), \"FooInner\");\n-        assert!(s.container_name().is_none());\n-    }\n-\n-    #[test]\n-    fn test_world_symbols_include_container_name() {\n-        let code = r#\"\n-fn foo() {\n-    enum FooInner { }\n-}\n-    \"#;\n-\n-        let mut symbols = get_symbols_matching(code, \"FooInner\");\n-\n-        let s = symbols.pop().unwrap();\n-\n-        assert_eq!(s.name(), \"FooInner\");\n-        assert_eq!(s.container_name(), Some(&SmolStr::new(\"foo\")));\n-\n-        let code = r#\"\n-mod foo {\n-    struct FooInner;\n-}\n-    \"#;\n-\n-        let mut symbols = get_symbols_matching(code, \"FooInner\");\n-\n-        let s = symbols.pop().unwrap();\n-\n-        assert_eq!(s.name(), \"FooInner\");\n-        assert_eq!(s.container_name(), Some(&SmolStr::new(\"foo\")));\n-    }\n-\n-    #[test]\n-    fn test_world_symbols_are_case_sensitive() {\n-        let code = r#\"\n-fn foo() {}\n-\n-struct Foo;\n-        \"#;\n-\n-        let symbols = get_symbols_matching(code, \"Foo\");\n-\n-        let fn_match = symbols.iter().find(|s| s.name() == \"foo\").map(|s| s.kind());\n-        let struct_match = symbols.iter().find(|s| s.name() == \"Foo\").map(|s| s.kind());\n-\n-        assert_eq!(fn_match, Some(FN_DEF));\n-        assert_eq!(struct_match, Some(STRUCT_DEF));\n-    }\n-\n-    fn get_symbols_matching(text: &str, query: &str) -> Vec<NavigationTarget> {\n-        let (analysis, _) = single_file(text);\n-        analysis.symbol_search(Query::new(query.into())).unwrap()\n-    }\n-}", "previous_filename": "crates/ra_ide/src/symbol_index.rs"}, {"sha": "7af9f9d9bb7bdafcd852e474572a1aca06dcadd0", "filename": "crates/ra_ide_db/src/wasm_shims.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide_db%2Fsrc%2Fwasm_shims.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_ide_db%2Fsrc%2Fwasm_shims.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fwasm_shims.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,4 +1,4 @@\n-//! FIXME: write short doc here\n+//! A version of `std::time::Instant` that doesn't panic in WASM.\n \n #[cfg(not(feature = \"wasm\"))]\n pub use std::time::Instant;", "previous_filename": "crates/ra_ide/src/wasm_shims.rs"}, {"sha": "fdf81ed87c9fe72feb95ecd6c88d2dadeba57559", "filename": "crates/ra_lsp_server/Cargo.toml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_lsp_server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_lsp_server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2FCargo.toml?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -26,10 +26,13 @@ lsp-server = \"0.3.0\"\n ra_project_model = { path = \"../ra_project_model\" }\n ra_prof = { path = \"../ra_prof\" }\n ra_vfs_glob = { path = \"../ra_vfs_glob\" }\n-env_logger = { version = \"0.7.1\", default-features = false, features = [\"humantime\"] }\n+env_logger = { version = \"0.7.1\", default-features = false }\n ra_cargo_watch = { path = \"../ra_cargo_watch\" }\n either = \"1.5\"\n \n+[target.'cfg(windows)'.dependencies]\n+winapi = \"0.3\"\n+\n [dev-dependencies]\n tempfile = \"3\"\n test_utils = { path = \"../test_utils\" }"}, {"sha": "ea08bce24bc387057e177323c9a0f619bce83b29", "filename": "crates/ra_lsp_server/src/diagnostics.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_lsp_server%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_lsp_server%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fdiagnostics.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,85 @@\n+//! Book keeping for keeping diagnostics easily in sync with the client.\n+use lsp_types::{CodeActionOrCommand, Diagnostic, Range};\n+use ra_ide::FileId;\n+use std::{collections::HashMap, sync::Arc};\n+\n+pub type CheckFixes = Arc<HashMap<FileId, Vec<Fix>>>;\n+\n+#[derive(Debug, Default, Clone)]\n+pub struct DiagnosticCollection {\n+    pub native: HashMap<FileId, Vec<Diagnostic>>,\n+    pub check: HashMap<FileId, Vec<Diagnostic>>,\n+    pub check_fixes: CheckFixes,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct Fix {\n+    pub range: Range,\n+    pub action: CodeActionOrCommand,\n+}\n+\n+#[derive(Debug)]\n+pub enum DiagnosticTask {\n+    ClearCheck,\n+    AddCheck(FileId, Diagnostic, Vec<CodeActionOrCommand>),\n+    SetNative(FileId, Vec<Diagnostic>),\n+}\n+\n+impl DiagnosticCollection {\n+    pub fn clear_check(&mut self) -> Vec<FileId> {\n+        Arc::make_mut(&mut self.check_fixes).clear();\n+        self.check.drain().map(|(key, _value)| key).collect()\n+    }\n+\n+    pub fn add_check_diagnostic(\n+        &mut self,\n+        file_id: FileId,\n+        diagnostic: Diagnostic,\n+        fixes: Vec<CodeActionOrCommand>,\n+    ) {\n+        let diagnostics = self.check.entry(file_id).or_default();\n+        for existing_diagnostic in diagnostics.iter() {\n+            if are_diagnostics_equal(&existing_diagnostic, &diagnostic) {\n+                return;\n+            }\n+        }\n+\n+        let check_fixes = Arc::make_mut(&mut self.check_fixes);\n+        check_fixes\n+            .entry(file_id)\n+            .or_default()\n+            .extend(fixes.into_iter().map(|action| Fix { range: diagnostic.range, action }));\n+        diagnostics.push(diagnostic);\n+    }\n+\n+    pub fn set_native_diagnostics(&mut self, file_id: FileId, diagnostics: Vec<Diagnostic>) {\n+        self.native.insert(file_id, diagnostics);\n+    }\n+\n+    pub fn diagnostics_for(&self, file_id: FileId) -> impl Iterator<Item = &Diagnostic> {\n+        let native = self.native.get(&file_id).into_iter().flatten();\n+        let check = self.check.get(&file_id).into_iter().flatten();\n+        native.chain(check)\n+    }\n+\n+    pub fn handle_task(&mut self, task: DiagnosticTask) -> Vec<FileId> {\n+        match task {\n+            DiagnosticTask::ClearCheck => self.clear_check(),\n+            DiagnosticTask::AddCheck(file_id, diagnostic, fixes) => {\n+                self.add_check_diagnostic(file_id, diagnostic, fixes);\n+                vec![file_id]\n+            }\n+            DiagnosticTask::SetNative(file_id, diagnostics) => {\n+                self.set_native_diagnostics(file_id, diagnostics);\n+                vec![file_id]\n+            }\n+        }\n+    }\n+}\n+\n+fn are_diagnostics_equal(left: &Diagnostic, right: &Diagnostic) -> bool {\n+    left.source == right.source\n+        && left.severity == right.severity\n+        && left.range == right.range\n+        && left.message == right.message\n+}"}, {"sha": "1208c13435bae253fb8ebd2d943827a93129c5dd", "filename": "crates/ra_lsp_server/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_lsp_server%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_lsp_server%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Flib.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -29,6 +29,7 @@ mod markdown;\n pub mod req;\n mod config;\n mod world;\n+mod diagnostics;\n \n pub type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send + Sync>>;\n pub use crate::{"}, {"sha": "ceff82fda9e3408349dc52dcc4b2583c8bad2fbc", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 90, "deletions": 49, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -5,21 +5,29 @@ mod handlers;\n mod subscriptions;\n pub(crate) mod pending_requests;\n \n-use std::{error::Error, fmt, panic, path::PathBuf, sync::Arc, time::Instant};\n+use std::{\n+    env,\n+    error::Error,\n+    fmt, panic,\n+    path::PathBuf,\n+    sync::Arc,\n+    time::{Duration, Instant},\n+};\n \n use crossbeam_channel::{select, unbounded, RecvError, Sender};\n use lsp_server::{Connection, ErrorCode, Message, Notification, Request, RequestId, Response};\n-use lsp_types::{ClientCapabilities, NumberOrString, Url};\n-use ra_cargo_watch::{CheckOptions, CheckTask};\n+use lsp_types::{ClientCapabilities, NumberOrString};\n+use ra_cargo_watch::{url_from_path_with_drive_lowercasing, CheckOptions, CheckTask};\n use ra_ide::{Canceled, FeatureFlags, FileId, LibraryData, SourceRootId};\n use ra_prof::profile;\n-use ra_vfs::{VfsTask, Watch};\n+use ra_vfs::{VfsFile, VfsTask, Watch};\n use relative_path::RelativePathBuf;\n use rustc_hash::FxHashSet;\n use serde::{de::DeserializeOwned, Serialize};\n use threadpool::ThreadPool;\n \n use crate::{\n+    diagnostics::DiagnosticTask,\n     main_loop::{\n         pending_requests::{PendingRequest, PendingRequests},\n         subscriptions::Subscriptions,\n@@ -29,9 +37,6 @@ use crate::{\n     Result, ServerConfig,\n };\n \n-const THREADPOOL_SIZE: usize = 8;\n-const MAX_IN_FLIGHT_LIBS: usize = THREADPOOL_SIZE - 3;\n-\n #[derive(Debug)]\n pub struct LspError {\n     pub code: i32,\n@@ -60,6 +65,25 @@ pub fn main_loop(\n ) -> Result<()> {\n     log::info!(\"server_config: {:#?}\", config);\n \n+    // Windows scheduler implements priority boosts: if thread waits for an\n+    // event (like a condvar), and event fires, priority of the thread is\n+    // temporary bumped. This optimization backfires in our case: each time the\n+    // `main_loop` schedules a task to run on a threadpool, the worker threads\n+    // gets a higher priority, and (on a machine with fewer cores) displaces the\n+    // main loop! We work-around this by marking the main loop as a\n+    // higher-priority thread.\n+    //\n+    // https://docs.microsoft.com/en-us/windows/win32/procthread/scheduling-priorities\n+    // https://docs.microsoft.com/en-us/windows/win32/procthread/priority-boosts\n+    // https://github.com/rust-analyzer/rust-analyzer/issues/2835\n+    #[cfg(windows)]\n+    unsafe {\n+        use winapi::um::processthreadsapi::*;\n+        let thread = GetCurrentThread();\n+        let thread_priority_above_normal = 1;\n+        SetThreadPriority(thread, thread_priority_above_normal);\n+    }\n+\n     let mut loop_state = LoopState::default();\n     let mut world_state = {\n         let feature_flags = {\n@@ -168,7 +192,7 @@ pub fn main_loop(\n         )\n     };\n \n-    let pool = ThreadPool::new(THREADPOOL_SIZE);\n+    let pool = ThreadPool::default();\n     let (task_sender, task_receiver) = unbounded::<Task>();\n     let (libdata_sender, libdata_receiver) = unbounded::<LibraryData>();\n \n@@ -210,7 +234,7 @@ pub fn main_loop(\n             )?;\n         }\n     }\n-\n+    world_state.analysis_host.request_cancellation();\n     log::info!(\"waiting for tasks to finish...\");\n     task_receiver.into_iter().for_each(|task| {\n         on_task(task, &connection.sender, &mut loop_state.pending_requests, &mut world_state)\n@@ -231,6 +255,7 @@ pub fn main_loop(\n enum Task {\n     Respond(Response),\n     Notify(Notification),\n+    Diagnostic(DiagnosticTask),\n }\n \n enum Event {\n@@ -371,15 +396,15 @@ fn loop_turn(\n         loop_state.pending_libraries.extend(changes);\n     }\n \n-    while loop_state.in_flight_libraries < MAX_IN_FLIGHT_LIBS\n+    let max_in_flight_libs = pool.max_count().saturating_sub(2).max(1);\n+    while loop_state.in_flight_libraries < max_in_flight_libs\n         && !loop_state.pending_libraries.is_empty()\n     {\n         let (root, files) = loop_state.pending_libraries.pop().unwrap();\n         loop_state.in_flight_libraries += 1;\n         let sender = libdata_sender.clone();\n         pool.execute(move || {\n             log::info!(\"indexing {:?} ... \", root);\n-            let _p = profile(&format!(\"indexed {:?}\", root));\n             let data = LibraryData::prepare(root, files);\n             sender.send(data).unwrap();\n         });\n@@ -408,6 +433,19 @@ fn loop_turn(\n             loop_state.subscriptions.subscriptions(),\n         )\n     }\n+\n+    let loop_duration = loop_start.elapsed();\n+    if loop_duration > Duration::from_millis(100) {\n+        log::error!(\"overly long loop turn: {:?}\", loop_duration);\n+        if env::var(\"RA_PROFILE\").is_ok() {\n+            show_message(\n+                req::MessageType::Error,\n+                format!(\"overly long loop turn: {:?}\", loop_duration),\n+                &connection.sender,\n+            );\n+        }\n+    }\n+\n     Ok(())\n }\n \n@@ -428,14 +466,15 @@ fn on_task(\n         Task::Notify(n) => {\n             msg_sender.send(n.into()).unwrap();\n         }\n+        Task::Diagnostic(task) => on_diagnostic_task(task, msg_sender, state),\n     }\n }\n \n fn on_request(\n     world: &mut WorldState,\n     pending_requests: &mut PendingRequests,\n     pool: &ThreadPool,\n-    sender: &Sender<Task>,\n+    task_sender: &Sender<Task>,\n     msg_sender: &Sender<Message>,\n     request_received: Instant,\n     req: Request,\n@@ -444,7 +483,7 @@ fn on_request(\n         req: Some(req),\n         pool,\n         world,\n-        sender,\n+        task_sender,\n         msg_sender,\n         pending_requests,\n         request_received,\n@@ -586,30 +625,26 @@ fn on_notification(\n \n fn on_check_task(\n     task: CheckTask,\n-    world_state: &WorldState,\n+    world_state: &mut WorldState,\n     task_sender: &Sender<Task>,\n ) -> Result<()> {\n     match task {\n         CheckTask::ClearDiagnostics => {\n-            let cleared_files = world_state.check_watcher.state.write().clear();\n-\n-            // Send updated diagnostics for each cleared file\n-            for url in cleared_files {\n-                publish_diagnostics_for_url(&url, world_state, task_sender)?;\n-            }\n+            task_sender.send(Task::Diagnostic(DiagnosticTask::ClearCheck))?;\n         }\n \n-        CheckTask::AddDiagnostic(url, diagnostic) => {\n-            world_state\n-                .check_watcher\n-                .state\n-                .write()\n-                .add_diagnostic_with_fixes(url.clone(), diagnostic);\n-\n-            // We manually send a diagnostic update when the watcher asks\n-            // us to, to avoid the issue of having to change the file to\n-            // receive updated diagnostics.\n-            publish_diagnostics_for_url(&url, world_state, task_sender)?;\n+        CheckTask::AddDiagnostic { url, diagnostic, fixes } => {\n+            let path = url.to_file_path().map_err(|()| format!(\"invalid uri: {}\", url))?;\n+            let file_id = match world_state.vfs.read().path2file(&path) {\n+                Some(file) => FileId(file.0),\n+                None => {\n+                    log::error!(\"File with cargo diagnostic not found in VFS: {}\", path.display());\n+                    return Ok(());\n+                }\n+            };\n+\n+            task_sender\n+                .send(Task::Diagnostic(DiagnosticTask::AddCheck(file_id, diagnostic, fixes)))?;\n         }\n \n         CheckTask::Status(progress) => {\n@@ -620,22 +655,29 @@ fn on_check_task(\n             let not = notification_new::<req::Progress>(params);\n             task_sender.send(Task::Notify(not)).unwrap();\n         }\n-    }\n+    };\n+\n     Ok(())\n }\n \n-fn publish_diagnostics_for_url(\n-    url: &Url,\n-    world_state: &WorldState,\n-    task_sender: &Sender<Task>,\n-) -> Result<()> {\n-    let path = url.to_file_path().map_err(|()| format!(\"invalid uri: {}\", url))?;\n-    if let Some(file_id) = world_state.vfs.read().path2file(&path) {\n-        let params = handlers::publish_diagnostics(&world_state.snapshot(), FileId(file_id.0))?;\n+fn on_diagnostic_task(task: DiagnosticTask, msg_sender: &Sender<Message>, state: &mut WorldState) {\n+    let subscriptions = state.diagnostics.handle_task(task);\n+\n+    for file_id in subscriptions {\n+        let path = state.vfs.read().file2path(VfsFile(file_id.0));\n+        let uri = match url_from_path_with_drive_lowercasing(&path) {\n+            Ok(uri) => uri,\n+            Err(err) => {\n+                log::error!(\"Couldn't convert path to url ({}): {:?}\", err, path.to_string_lossy());\n+                continue;\n+            }\n+        };\n+\n+        let diagnostics = state.diagnostics.diagnostics_for(file_id).cloned().collect();\n+        let params = req::PublishDiagnosticsParams { uri, diagnostics, version: None };\n         let not = notification_new::<req::PublishDiagnostics>(params);\n-        task_sender.send(Task::Notify(not)).unwrap();\n+        msg_sender.send(not.into()).unwrap();\n     }\n-    Ok(())\n }\n \n struct PoolDispatcher<'a> {\n@@ -644,7 +686,7 @@ struct PoolDispatcher<'a> {\n     world: &'a mut WorldState,\n     pending_requests: &'a mut PendingRequests,\n     msg_sender: &'a Sender<Message>,\n-    sender: &'a Sender<Task>,\n+    task_sender: &'a Sender<Task>,\n     request_received: Instant,\n }\n \n@@ -691,7 +733,7 @@ impl<'a> PoolDispatcher<'a> {\n \n         self.pool.execute({\n             let world = self.world.snapshot();\n-            let sender = self.sender.clone();\n+            let sender = self.task_sender.clone();\n             move || {\n                 let result = f(world, params);\n                 let task = result_to_task::<R>(id, result);\n@@ -769,7 +811,7 @@ fn update_file_notifications_on_threadpool(\n     pool: &ThreadPool,\n     world: WorldSnapshot,\n     publish_decorations: bool,\n-    sender: Sender<Task>,\n+    task_sender: Sender<Task>,\n     subscriptions: Vec<FileId>,\n ) {\n     log::trace!(\"updating notifications for {:?}\", subscriptions);\n@@ -783,9 +825,8 @@ fn update_file_notifications_on_threadpool(\n                             log::error!(\"failed to compute diagnostics: {:?}\", e);\n                         }\n                     }\n-                    Ok(params) => {\n-                        let not = notification_new::<req::PublishDiagnostics>(params);\n-                        sender.send(Task::Notify(not)).unwrap();\n+                    Ok(task) => {\n+                        task_sender.send(Task::Diagnostic(task)).unwrap();\n                     }\n                 }\n             }\n@@ -798,7 +839,7 @@ fn update_file_notifications_on_threadpool(\n                     }\n                     Ok(params) => {\n                         let not = notification_new::<req::PublishDecorations>(params);\n-                        sender.send(Task::Notify(not)).unwrap();\n+                        task_sender.send(Task::Notify(not)).unwrap();\n                     }\n                 }\n             }"}, {"sha": "65e8bc856dfd35a6196ca9ceccb5f32cf429bda8", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 60, "deletions": 61, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,17 +1,22 @@\n //! This module is responsible for implementing handlers for Lanuage Server Protocol.\n //! The majority of requests are fulfilled by calling into the `ra_ide` crate.\n \n-use std::{fmt::Write as _, io::Write as _};\n+use std::{\n+    collections::hash_map::Entry,\n+    fmt::Write as _,\n+    io::Write as _,\n+    process::{self, Stdio},\n+};\n \n-use either::Either;\n use lsp_server::ErrorCode;\n use lsp_types::{\n     CallHierarchyIncomingCall, CallHierarchyIncomingCallsParams, CallHierarchyItem,\n     CallHierarchyOutgoingCall, CallHierarchyOutgoingCallsParams, CallHierarchyPrepareParams,\n-    CodeAction, CodeActionResponse, CodeLens, Command, CompletionItem, Diagnostic,\n-    DocumentFormattingParams, DocumentHighlight, DocumentSymbol, FoldingRange, FoldingRangeParams,\n-    Hover, HoverContents, Location, MarkupContent, MarkupKind, Position, PrepareRenameResponse,\n-    Range, RenameParams, SymbolInformation, TextDocumentIdentifier, TextEdit, WorkspaceEdit,\n+    CodeAction, CodeActionOrCommand, CodeActionResponse, CodeLens, Command, CompletionItem,\n+    Diagnostic, DocumentFormattingParams, DocumentHighlight, DocumentSymbol, FoldingRange,\n+    FoldingRangeParams, Hover, HoverContents, Location, MarkupContent, MarkupKind, Position,\n+    PrepareRenameResponse, Range, RenameParams, SymbolInformation, TextDocumentIdentifier,\n+    TextEdit, WorkspaceEdit,\n };\n use ra_ide::{\n     AssistId, FileId, FilePosition, FileRange, Query, RangeInfo, Runnable, RunnableKind,\n@@ -29,6 +34,7 @@ use crate::{\n         to_call_hierarchy_item, to_location, Conv, ConvWith, FoldConvCtx, MapConvWith, TryConvWith,\n         TryConvWithToVec,\n     },\n+    diagnostics::DiagnosticTask,\n     req::{self, Decoration, InlayHint, InlayHintsParams, InlayKind},\n     world::WorldSnapshot,\n     LspError, Result,\n@@ -582,21 +588,19 @@ pub fn handle_formatting(\n     let file_line_index = world.analysis().file_line_index(file_id)?;\n     let end_position = TextUnit::of_str(&file).conv_with(&file_line_index);\n \n-    use std::process;\n     let mut rustfmt = process::Command::new(\"rustfmt\");\n     if let Some(&crate_id) = crate_ids.first() {\n         // Assume all crates are in the same edition\n         let edition = world.analysis().crate_edition(crate_id)?;\n         rustfmt.args(&[\"--edition\", &edition.to_string()]);\n     }\n-    rustfmt.stdin(process::Stdio::piped()).stdout(process::Stdio::piped());\n \n     if let Ok(path) = params.text_document.uri.to_file_path() {\n         if let Some(parent) = path.parent() {\n             rustfmt.current_dir(parent);\n         }\n     }\n-    let mut rustfmt = rustfmt.spawn()?;\n+    let mut rustfmt = rustfmt.stdin(Stdio::piped()).stdout(Stdio::piped()).spawn()?;\n \n     rustfmt.stdin.as_mut().unwrap().write_all(file.as_bytes())?;\n \n@@ -674,59 +678,61 @@ pub fn handle_code_action(\n         res.push(action.into());\n     }\n \n-    for fix in world.check_watcher.read().fixes_for(&params.text_document.uri).into_iter().flatten()\n-    {\n-        let fix_range = fix.location.range.conv_with(&line_index);\n+    for fix in world.check_fixes.get(&file_id).into_iter().flatten() {\n+        let fix_range = fix.range.conv_with(&line_index);\n         if fix_range.intersection(&range).is_none() {\n             continue;\n         }\n+        res.push(fix.action.clone());\n+    }\n \n-        let edit = {\n-            let edits = vec![TextEdit::new(fix.location.range, fix.replacement.clone())];\n-            let mut edit_map = std::collections::HashMap::new();\n-            edit_map.insert(fix.location.uri.clone(), edits);\n-            WorkspaceEdit::new(edit_map)\n+    let mut groups = FxHashMap::default();\n+    for assist in world.analysis().assists(FileRange { file_id, range })?.into_iter() {\n+        let arg = to_value(assist.source_change.try_conv_with(&world)?)?;\n+\n+        let (command, title, arg) = match assist.group_label {\n+            None => (\"rust-analyzer.applySourceChange\", assist.label.clone(), arg),\n+\n+            // Group all assists with the same `group_label` into a single CodeAction.\n+            Some(group_label) => {\n+                match groups.entry(group_label.clone()) {\n+                    Entry::Occupied(entry) => {\n+                        let idx: usize = *entry.get();\n+                        match &mut res[idx] {\n+                            CodeActionOrCommand::CodeAction(CodeAction {\n+                                command: Some(Command { arguments: Some(arguments), .. }),\n+                                ..\n+                            }) => match arguments.as_mut_slice() {\n+                                [serde_json::Value::Array(arguments)] => arguments.push(arg),\n+                                _ => panic!(\"invalid group\"),\n+                            },\n+                            _ => panic!(\"invalid group\"),\n+                        }\n+                        continue;\n+                    }\n+                    Entry::Vacant(entry) => {\n+                        entry.insert(res.len());\n+                    }\n+                }\n+                (\"rust-analyzer.selectAndApplySourceChange\", group_label, to_value(vec![arg])?)\n+            }\n         };\n \n-        let action = CodeAction {\n-            title: fix.title.clone(),\n-            kind: Some(\"quickfix\".to_string()),\n-            diagnostics: Some(fix.diagnostics.clone()),\n-            edit: Some(edit),\n-            command: None,\n-            is_preferred: None,\n+        let command = Command {\n+            title: assist.label.clone(),\n+            command: command.to_string(),\n+            arguments: Some(vec![arg]),\n         };\n-        res.push(action.into());\n-    }\n \n-    for assist in world.analysis().assists(FileRange { file_id, range })?.into_iter() {\n-        let title = assist.label.clone();\n-\n-        let command = match assist.change_data {\n-            Either::Left(change) => Command {\n-                title,\n-                command: \"rust-analyzer.applySourceChange\".to_string(),\n-                arguments: Some(vec![to_value(change.try_conv_with(&world)?)?]),\n-            },\n-            Either::Right(changes) => Command {\n-                title,\n-                command: \"rust-analyzer.selectAndApplySourceChange\".to_string(),\n-                arguments: Some(vec![to_value(\n-                    changes\n-                        .into_iter()\n-                        .map(|change| change.try_conv_with(&world))\n-                        .collect::<Result<Vec<_>>>()?,\n-                )?]),\n-            },\n+        let kind = match assist.id {\n+            AssistId(\"introduce_variable\") => Some(\"refactor.extract.variable\".to_string()),\n+            AssistId(\"add_custom_impl\") => Some(\"refactor.rewrite.add_custom_impl\".to_string()),\n+            _ => None,\n         };\n \n         let action = CodeAction {\n-            title: command.title.clone(),\n-            kind: match assist.id {\n-                AssistId(\"introduce_variable\") => Some(\"refactor.extract.variable\".to_string()),\n-                AssistId(\"add_custom_impl\") => Some(\"refactor.rewrite.add_custom_impl\".to_string()),\n-                _ => None,\n-            },\n+            title,\n+            kind,\n             diagnostics: None,\n             edit: None,\n             command: Some(command),\n@@ -874,14 +880,10 @@ pub fn handle_document_highlight(\n     ))\n }\n \n-pub fn publish_diagnostics(\n-    world: &WorldSnapshot,\n-    file_id: FileId,\n-) -> Result<req::PublishDiagnosticsParams> {\n+pub fn publish_diagnostics(world: &WorldSnapshot, file_id: FileId) -> Result<DiagnosticTask> {\n     let _p = profile(\"publish_diagnostics\");\n-    let uri = world.file_id_to_uri(file_id)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n-    let mut diagnostics: Vec<Diagnostic> = world\n+    let diagnostics: Vec<Diagnostic> = world\n         .analysis()\n         .diagnostics(file_id)?\n         .into_iter()\n@@ -895,10 +897,7 @@ pub fn publish_diagnostics(\n             tags: None,\n         })\n         .collect();\n-    if let Some(check_diags) = world.check_watcher.read().diagnostics_for(&uri) {\n-        diagnostics.extend(check_diags.iter().cloned());\n-    }\n-    Ok(req::PublishDiagnosticsParams { uri, diagnostics, version: None })\n+    Ok(DiagnosticTask::SetNative(file_id, diagnostics))\n }\n \n pub fn publish_decorations("}, {"sha": "1ee02b47c93cabd337217a35d069b604a349ef2f", "filename": "crates/ra_lsp_server/src/world.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -12,9 +12,7 @@ use crossbeam_channel::{unbounded, Receiver};\n use lsp_server::ErrorCode;\n use lsp_types::Url;\n use parking_lot::RwLock;\n-use ra_cargo_watch::{\n-    url_from_path_with_drive_lowercasing, CheckOptions, CheckState, CheckWatcher,\n-};\n+use ra_cargo_watch::{url_from_path_with_drive_lowercasing, CheckOptions, CheckWatcher};\n use ra_ide::{\n     Analysis, AnalysisChange, AnalysisHost, CrateGraph, FeatureFlags, FileId, LibraryData,\n     SourceRootId,\n@@ -25,6 +23,7 @@ use ra_vfs_glob::{Glob, RustPackageFilterBuilder};\n use relative_path::RelativePathBuf;\n \n use crate::{\n+    diagnostics::{CheckFixes, DiagnosticCollection},\n     main_loop::pending_requests::{CompletedRequest, LatestRequests},\n     LspError, Result,\n };\n@@ -55,6 +54,7 @@ pub struct WorldState {\n     pub task_receiver: Receiver<VfsTask>,\n     pub latest_requests: Arc<RwLock<LatestRequests>>,\n     pub check_watcher: CheckWatcher,\n+    pub diagnostics: DiagnosticCollection,\n }\n \n /// An immutable snapshot of the world's state at a point in time.\n@@ -63,7 +63,7 @@ pub struct WorldSnapshot {\n     pub workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub analysis: Analysis,\n     pub latest_requests: Arc<RwLock<LatestRequests>>,\n-    pub check_watcher: Arc<RwLock<CheckState>>,\n+    pub check_fixes: CheckFixes,\n     vfs: Arc<RwLock<Vfs>>,\n }\n \n@@ -159,6 +159,7 @@ impl WorldState {\n             task_receiver,\n             latest_requests: Default::default(),\n             check_watcher,\n+            diagnostics: Default::default(),\n         }\n     }\n \n@@ -220,7 +221,7 @@ impl WorldState {\n             analysis: self.analysis_host.analysis(),\n             vfs: Arc::clone(&self.vfs),\n             latest_requests: Arc::clone(&self.latest_requests),\n-            check_watcher: self.check_watcher.state.clone(),\n+            check_fixes: Arc::clone(&self.diagnostics.check_fixes),\n         }\n     }\n "}, {"sha": "c9f42b3ddef91400b569207f394e56c1e34e6e2b", "filename": "crates/ra_mbe/src/subtree_source.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,7 +1,7 @@\n //! FIXME: write short doc here\n \n use ra_parser::{Token, TokenSource};\n-use ra_syntax::{classify_literal, SmolStr, SyntaxKind, SyntaxKind::*, T};\n+use ra_syntax::{lex_single_valid_syntax_kind, SmolStr, SyntaxKind, SyntaxKind::*, T};\n use std::cell::{Cell, Ref, RefCell};\n use tt::buffer::{Cursor, TokenBuffer};\n \n@@ -129,8 +129,9 @@ fn convert_delim(d: Option<tt::DelimiterKind>, closing: bool) -> TtToken {\n }\n \n fn convert_literal(l: &tt::Literal) -> TtToken {\n-    let kind =\n-        classify_literal(&l.text).map(|tkn| tkn.kind).unwrap_or_else(|| match l.text.as_ref() {\n+    let kind = lex_single_valid_syntax_kind(&l.text)\n+        .filter(|kind| kind.is_literal())\n+        .unwrap_or_else(|| match l.text.as_ref() {\n             \"true\" => T![true],\n             \"false\" => T![false],\n             _ => panic!(\"Fail to convert given literal {:#?}\", &l),"}, {"sha": "f154077a86c88ce2c67382824d5ae9784115f68c", "filename": "crates/ra_parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -229,7 +229,7 @@ fn lambda_expr(p: &mut Parser) -> CompletedMarker {\n     let m = p.start();\n     p.eat(T![async]);\n     p.eat(T![move]);\n-    params::param_list_opt_types(p);\n+    params::param_list_closure(p);\n     if opt_fn_ret_type(p) {\n         if !p.at(T!['{']) {\n             p.error(\"expected `{`\");"}, {"sha": "54284c933eb5c19d18b507647d704ba952932efa", "filename": "crates/ra_parser/src/grammar/items.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -91,20 +91,20 @@ pub(super) fn maybe_item(p: &mut Parser, m: Marker, flavor: ItemFlavor) -> Resul\n     // modifiers\n     has_mods |= p.eat(T![const]);\n \n-    // test_err unsafe_block_in_mod\n-    // fn foo(){} unsafe { } fn bar(){}\n-    if p.at(T![unsafe]) && p.nth(1) != T!['{'] {\n-        p.eat(T![unsafe]);\n-        has_mods = true;\n-    }\n-\n     // test_err async_without_semicolon\n     // fn foo() { let _ = async {} }\n     if p.at(T![async]) && p.nth(1) != T!['{'] && p.nth(1) != T![move] && p.nth(1) != T![|] {\n         p.eat(T![async]);\n         has_mods = true;\n     }\n \n+    // test_err unsafe_block_in_mod\n+    // fn foo(){} unsafe { } fn bar(){}\n+    if p.at(T![unsafe]) && p.nth(1) != T!['{'] {\n+        p.eat(T![unsafe]);\n+        has_mods = true;\n+    }\n+\n     if p.at(T![extern]) {\n         has_mods = true;\n         abi(p);\n@@ -157,14 +157,14 @@ pub(super) fn maybe_item(p: &mut Parser, m: Marker, flavor: ItemFlavor) -> Resul\n         // unsafe fn foo() {}\n \n         // test combined_fns\n-        // unsafe async fn foo() {}\n+        // async unsafe fn foo() {}\n         // const unsafe fn bar() {}\n \n         // test_err wrong_order_fns\n-        // async unsafe fn foo() {}\n+        // unsafe async fn foo() {}\n         // unsafe const fn bar() {}\n         T![fn] => {\n-            fn_def(p, flavor);\n+            fn_def(p);\n             m.complete(p, FN_DEF);\n         }\n \n@@ -301,7 +301,7 @@ pub(crate) fn extern_item_list(p: &mut Parser) {\n     m.complete(p, EXTERN_ITEM_LIST);\n }\n \n-fn fn_def(p: &mut Parser, flavor: ItemFlavor) {\n+fn fn_def(p: &mut Parser) {\n     assert!(p.at(T![fn]));\n     p.bump(T![fn]);\n \n@@ -311,10 +311,7 @@ fn fn_def(p: &mut Parser, flavor: ItemFlavor) {\n     type_params::opt_type_param_list(p);\n \n     if p.at(T!['(']) {\n-        match flavor {\n-            ItemFlavor::Mod => params::param_list(p),\n-            ItemFlavor::Trait => params::param_list_opt_patterns(p),\n-        }\n+        params::param_list_fn_def(p);\n     } else {\n         p.error(\"expected function arguments\");\n     }"}, {"sha": "94edc7f35da43e6284ee9b0ec132562d8e47c8d7", "filename": "crates/ra_parser/src/grammar/params.rs", "status": "modified", "additions": 71, "deletions": 49, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fparams.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fparams.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fparams.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -7,54 +7,60 @@ use super::*;\n // fn b(x: i32) {}\n // fn c(x: i32, ) {}\n // fn d(x: i32, y: ()) {}\n-pub(super) fn param_list(p: &mut Parser) {\n-    list_(p, Flavor::Normal)\n+pub(super) fn param_list_fn_def(p: &mut Parser) {\n+    list_(p, Flavor::FnDef)\n }\n \n // test param_list_opt_patterns\n // fn foo<F: FnMut(&mut Foo<'a>)>(){}\n-pub(super) fn param_list_opt_patterns(p: &mut Parser) {\n-    list_(p, Flavor::OptionalPattern)\n+pub(super) fn param_list_fn_trait(p: &mut Parser) {\n+    list_(p, Flavor::FnTrait)\n }\n \n-pub(super) fn param_list_opt_types(p: &mut Parser) {\n-    list_(p, Flavor::OptionalType)\n+pub(super) fn param_list_fn_ptr(p: &mut Parser) {\n+    list_(p, Flavor::FnPointer)\n }\n \n-#[derive(Clone, Copy, Eq, PartialEq)]\n-enum Flavor {\n-    OptionalType,\n-    OptionalPattern,\n-    Normal,\n+pub(super) fn param_list_closure(p: &mut Parser) {\n+    list_(p, Flavor::Closure)\n }\n \n-impl Flavor {\n-    fn type_required(self) -> bool {\n-        match self {\n-            Flavor::OptionalType => false,\n-            _ => true,\n-        }\n-    }\n+#[derive(Debug, Clone, Copy)]\n+enum Flavor {\n+    FnDef,   // Includes trait fn params; omitted param idents are not supported\n+    FnTrait, // Params for `Fn(...)`/`FnMut(...)`/`FnOnce(...)` annotations\n+    FnPointer,\n+    Closure,\n }\n \n fn list_(p: &mut Parser, flavor: Flavor) {\n-    let (bra, ket) = if flavor.type_required() { (T!['('], T![')']) } else { (T![|], T![|]) };\n-    assert!(p.at(bra));\n+    use Flavor::*;\n+\n+    let (bra, ket) = match flavor {\n+        Closure => (T![|], T![|]),\n+        FnDef | FnTrait | FnPointer => (T!['('], T![')']),\n+    };\n+\n     let m = p.start();\n     p.bump(bra);\n-    if flavor.type_required() {\n+\n+    if let FnDef = flavor {\n         // test self_param_outer_attr\n         // fn f(#[must_use] self) {}\n         attributes::outer_attributes(p);\n         opt_self_param(p);\n     }\n+\n     while !p.at(EOF) && !p.at(ket) {\n         // test param_outer_arg\n         // fn f(#[attr1] pat: Type) {}\n         attributes::outer_attributes(p);\n \n-        if flavor.type_required() && p.at(T![...]) {\n-            break;\n+        // test param_list_vararg\n+        // extern \"C\" { fn printf(format: *const i8, ...) -> i32; }\n+        match flavor {\n+            FnDef | FnPointer if p.eat(T![...]) => break,\n+            _ => (),\n         }\n \n         if !p.at_ts(VALUE_PARAMETER_FIRST) {\n@@ -66,11 +72,7 @@ fn list_(p: &mut Parser, flavor: Flavor) {\n             p.expect(T![,]);\n         }\n     }\n-    // test param_list_vararg\n-    // extern \"C\" { fn printf(format: *const i8, ...) -> i32; }\n-    if flavor.type_required() {\n-        p.eat(T![...]);\n-    }\n+\n     p.expect(ket);\n     m.complete(p, PARAM_LIST);\n }\n@@ -80,36 +82,56 @@ const VALUE_PARAMETER_FIRST: TokenSet = patterns::PATTERN_FIRST.union(types::TYP\n fn value_parameter(p: &mut Parser, flavor: Flavor) {\n     let m = p.start();\n     match flavor {\n-        Flavor::OptionalType | Flavor::Normal => {\n+        // test trait_fn_placeholder_parameter\n+        // trait Foo {\n+        //     fn bar(_: u64, mut x: i32);\n+        // }\n+\n+        // test trait_fn_patterns\n+        // trait T {\n+        //     fn f1((a, b): (usize, usize)) {}\n+        //     fn f2(S { a, b }: S) {}\n+        //     fn f3(NewType(a): NewType) {}\n+        //     fn f4(&&a: &&usize) {}\n+        // }\n+\n+        // test fn_patterns\n+        // impl U {\n+        //     fn f1((a, b): (usize, usize)) {}\n+        //     fn f2(S { a, b }: S) {}\n+        //     fn f3(NewType(a): NewType) {}\n+        //     fn f4(&&a: &&usize) {}\n+        // }\n+        Flavor::FnDef => {\n             patterns::pattern(p);\n-            if p.at(T![:]) && !p.at(T![::]) || flavor.type_required() {\n-                types::ascription(p)\n-            }\n+            types::ascription(p);\n         }\n         // test value_parameters_no_patterns\n-        // type F = Box<Fn(a: i32, &b: &i32, &mut c: &i32, ())>;\n-        Flavor::OptionalPattern => {\n-            let la0 = p.current();\n-            let la1 = p.nth(1);\n-            let la2 = p.nth(2);\n-            let la3 = p.nth(3);\n-\n-            // test trait_fn_placeholder_parameter\n-            // trait Foo {\n-            //     fn bar(_: u64, mut x: i32);\n-            // }\n-            if (la0 == IDENT || la0 == T![_]) && la1 == T![:] && !p.nth_at(1, T![::])\n-                || la0 == T![mut] && la1 == IDENT && la2 == T![:]\n-                || la0 == T![&]\n-                    && (la1 == IDENT && la2 == T![:] && !p.nth_at(2, T![::])\n-                        || la1 == T![mut] && la2 == IDENT && la3 == T![:] && !p.nth_at(3, T![::]))\n-            {\n+        // type F = Box<Fn(i32, &i32, &i32, ())>;\n+        Flavor::FnTrait => {\n+            types::type_(p);\n+        }\n+        // test fn_pointer_param_ident_path\n+        // type Foo = fn(Bar::Baz);\n+        // type Qux = fn(baz: Bar::Baz);\n+        Flavor::FnPointer => {\n+            if p.at(IDENT) && p.nth(1) == T![:] && !p.nth_at(1, T![::]) {\n                 patterns::pattern(p);\n                 types::ascription(p);\n             } else {\n                 types::type_(p);\n             }\n         }\n+        // test closure_params\n+        // fn main() {\n+        //    let foo = |bar, baz: Baz, qux: Qux::Quux| ();\n+        // }\n+        Flavor::Closure => {\n+            patterns::pattern(p);\n+            if p.at(T![:]) && !p.at(T![::]) {\n+                types::ascription(p);\n+            }\n+        }\n     }\n     m.complete(p, PARAM);\n }"}, {"sha": "f5bf3d7ced5280e93c0658ebd4b62aa4bd682e08", "filename": "crates/ra_parser/src/grammar/paths.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -97,9 +97,9 @@ fn opt_path_type_args(p: &mut Parser, mode: Mode) {\n         Mode::Use => return,\n         Mode::Type => {\n             // test path_fn_trait_args\n-            // type F = Box<Fn(x: i32) -> ()>;\n+            // type F = Box<Fn(i32) -> ()>;\n             if p.at(T!['(']) {\n-                params::param_list_opt_patterns(p);\n+                params::param_list_fn_trait(p);\n                 opt_fn_ret_type(p);\n             } else {\n                 type_args::opt_type_arg_list(p, false)"}, {"sha": "2c00bce80306ebfa5891880642ecda1498c2ffca", "filename": "crates/ra_parser/src/grammar/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -183,7 +183,7 @@ fn fn_pointer_type(p: &mut Parser) {\n         return;\n     }\n     if p.at(T!['(']) {\n-        params::param_list_opt_patterns(p);\n+        params::param_list_fn_ptr(p);\n     } else {\n         p.error(\"expected parameters\")\n     }"}, {"sha": "e27b27ffabc2753932ce784ac79b5f32dd275d88", "filename": "crates/ra_parser/src/syntax_kind/generated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,4 +1,4 @@\n-//! Generated file, do not edit by hand, see `crate/ra_tools/src/codegen`\n+//! Generated file, do not edit by hand, see `xtask/src/codegen`\n \n #![allow(bad_style, missing_docs, unreachable_pub)]\n #[doc = r\" The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT_DEF`.\"]"}, {"sha": "d38ff397e33294a5cd1a1b7d45d114e59dc0f9c1", "filename": "crates/ra_prof/src/lib.rs", "status": "modified", "additions": 110, "deletions": 70, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_prof%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_prof%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Flib.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -6,18 +6,16 @@ mod google_cpu_profiler;\n \n use std::{\n     cell::RefCell,\n+    collections::BTreeMap,\n     collections::HashSet,\n     io::{stderr, Write},\n-    iter::repeat,\n-    mem,\n     sync::{\n         atomic::{AtomicBool, Ordering},\n         RwLock,\n     },\n     time::{Duration, Instant},\n };\n \n-use itertools::Itertools;\n use once_cell::sync::Lazy;\n \n pub use crate::memory_usage::{Bytes, MemoryUsage};\n@@ -51,6 +49,8 @@ pub fn set_filter(f: Filter) {\n     *old = filter_data;\n }\n \n+pub type Label = &'static str;\n+\n /// This function starts a profiling scope in the current execution stack with a given description.\n /// It returns a Profile structure and measure elapsed time between this method invocation and Profile structure drop.\n /// It supports nested profiling scopes in case when this function invoked multiple times at the execution stack. In this case the profiling information will be nested at the output.\n@@ -78,10 +78,10 @@ pub fn set_filter(f: Filter) {\n ///  0ms - profile\n ///      0ms - profile2\n /// ```\n-pub fn profile(desc: &str) -> Profiler {\n-    assert!(!desc.is_empty());\n+pub fn profile(label: Label) -> Profiler {\n+    assert!(!label.is_empty());\n     if !PROFILING_ENABLED.load(Ordering::Relaxed) {\n-        return Profiler { desc: None };\n+        return Profiler { label: None };\n     }\n \n     PROFILE_STACK.with(|stack| {\n@@ -94,20 +94,35 @@ pub fn profile(desc: &str) -> Profiler {\n             };\n         }\n         if stack.starts.len() > stack.filter_data.depth {\n-            return Profiler { desc: None };\n+            return Profiler { label: None };\n         }\n         let allowed = &stack.filter_data.allowed;\n-        if stack.starts.is_empty() && !allowed.is_empty() && !allowed.contains(desc) {\n-            return Profiler { desc: None };\n+        if stack.starts.is_empty() && !allowed.is_empty() && !allowed.contains(label) {\n+            return Profiler { label: None };\n         }\n \n         stack.starts.push(Instant::now());\n-        Profiler { desc: Some(desc.to_string()) }\n+        Profiler { label: Some(label) }\n     })\n }\n \n+pub fn print_time(label: Label) -> impl Drop {\n+    struct Guard {\n+        label: Label,\n+        start: Instant,\n+    }\n+\n+    impl Drop for Guard {\n+        fn drop(&mut self) {\n+            eprintln!(\"{}: {:?}\", self.label, self.start.elapsed())\n+        }\n+    }\n+\n+    Guard { label, start: Instant::now() }\n+}\n+\n pub struct Profiler {\n-    desc: Option<String>,\n+    label: Option<Label>,\n }\n \n pub struct Filter {\n@@ -160,7 +175,7 @@ struct ProfileStack {\n struct Message {\n     level: usize,\n     duration: Duration,\n-    message: String,\n+    label: Label,\n }\n \n impl ProfileStack {\n@@ -186,85 +201,110 @@ thread_local!(static PROFILE_STACK: RefCell<ProfileStack> = RefCell::new(Profile\n impl Drop for Profiler {\n     fn drop(&mut self) {\n         match self {\n-            Profiler { desc: Some(desc) } => {\n+            Profiler { label: Some(label) } => {\n                 PROFILE_STACK.with(|stack| {\n                     let mut stack = stack.borrow_mut();\n                     let start = stack.starts.pop().unwrap();\n                     let duration = start.elapsed();\n                     let level = stack.starts.len();\n-                    let message = mem::replace(desc, String::new());\n-                    stack.messages.push(Message { level, duration, message });\n+                    stack.messages.push(Message { level, duration, label: label });\n                     if level == 0 {\n                         let stdout = stderr();\n                         let longer_than = stack.filter_data.longer_than;\n                         // Convert to millis for comparison to avoid problems with rounding\n                         // (otherwise we could print `0ms` despite user's `>0` filter when\n                         // `duration` is just a few nanos).\n                         if duration.as_millis() > longer_than.as_millis() {\n-                            print(0, &stack.messages, &mut stdout.lock(), longer_than, None);\n+                            print(&stack.messages, longer_than, &mut stdout.lock());\n                         }\n                         stack.messages.clear();\n                     }\n                 });\n             }\n-            Profiler { desc: None } => (),\n+            Profiler { label: None } => (),\n         }\n     }\n }\n \n-fn print(\n-    lvl: usize,\n-    msgs: &[Message],\n-    out: &mut impl Write,\n-    longer_than: Duration,\n-    total: Option<Duration>,\n-) {\n+fn print(msgs: &[Message], longer_than: Duration, out: &mut impl Write) {\n     if msgs.is_empty() {\n         return;\n     }\n-    // The index of the first element that will be included in the slice when we recurse.\n-    let mut next_start = 0;\n-    let indent = repeat(\"    \").take(lvl).collect::<String>();\n-    // We output hierarchy for long calls, but sum up all short calls\n-    let mut short = Vec::new();\n+    let children_map = idx_to_children(msgs);\n+    let root_idx = msgs.len() - 1;\n+    print_for_idx(root_idx, &children_map, msgs, longer_than, out);\n+}\n+\n+fn print_for_idx(\n+    current_idx: usize,\n+    children_map: &[Vec<usize>],\n+    msgs: &[Message],\n+    longer_than: Duration,\n+    out: &mut impl Write,\n+) {\n+    let current = &msgs[current_idx];\n+    let current_indent = \"    \".repeat(current.level);\n+    writeln!(out, \"{}{:5}ms - {}\", current_indent, current.duration.as_millis(), current.label)\n+        .expect(\"printing profiling info\");\n+\n+    let longer_than_millis = longer_than.as_millis();\n+    let children_indices = &children_map[current_idx];\n     let mut accounted_for = Duration::default();\n-    for (i, &Message { level, duration, message: ref msg }) in msgs.iter().enumerate() {\n-        if level != lvl {\n-            continue;\n-        }\n-        accounted_for += duration;\n-        if duration.as_millis() > longer_than.as_millis() {\n-            writeln!(out, \"{}{:5}ms - {}\", indent, duration.as_millis(), msg)\n-                .expect(\"printing profiling info to stdout\");\n+    let mut short_children = BTreeMap::new(); // Use `BTreeMap` to get deterministic output.\n \n-            print(lvl + 1, &msgs[next_start..i], out, longer_than, Some(duration));\n+    for child_idx in children_indices.iter() {\n+        let child = &msgs[*child_idx];\n+        if child.duration.as_millis() > longer_than_millis {\n+            print_for_idx(*child_idx, children_map, msgs, longer_than, out);\n         } else {\n-            short.push((msg, duration))\n+            let pair = short_children.entry(child.label).or_insert((Duration::default(), 0));\n+            pair.0 += child.duration;\n+            pair.1 += 1;\n         }\n+        accounted_for += child.duration;\n+    }\n \n-        next_start = i + 1;\n+    for (child_msg, (duration, count)) in short_children.iter() {\n+        let millis = duration.as_millis();\n+        writeln!(out, \"    {}{:5}ms - {} ({} calls)\", current_indent, millis, child_msg, count)\n+            .expect(\"printing profiling info\");\n     }\n-    short.sort_by_key(|(msg, _time)| *msg);\n-    for (msg, entires) in short.iter().group_by(|(msg, _time)| msg).into_iter() {\n-        let mut count = 0;\n-        let mut total_duration = Duration::default();\n-        entires.for_each(|(_msg, time)| {\n-            count += 1;\n-            total_duration += *time;\n-        });\n-        writeln!(out, \"{}{:5}ms - {} ({} calls)\", indent, total_duration.as_millis(), msg, count)\n-            .expect(\"printing profiling info to stdout\");\n+\n+    let unaccounted_millis = (current.duration - accounted_for).as_millis();\n+    if !children_indices.is_empty()\n+        && unaccounted_millis > 0\n+        && unaccounted_millis > longer_than_millis\n+    {\n+        writeln!(out, \"    {}{:5}ms - ???\", current_indent, unaccounted_millis)\n+            .expect(\"printing profiling info\");\n     }\n+}\n \n-    if let Some(total) = total {\n-        if let Some(unaccounted) = total.checked_sub(accounted_for) {\n-            let unaccounted_millis = unaccounted.as_millis();\n-            if unaccounted_millis > longer_than.as_millis() && unaccounted_millis > 0 {\n-                writeln!(out, \"{}{:5}ms - ???\", indent, unaccounted_millis)\n-                    .expect(\"printing profiling info to stdout\");\n-            }\n+/// Returns a mapping from an index in the `msgs` to the vector with the indices of its children.\n+///\n+/// This assumes that the entries in `msgs` are in the order of when the calls to `profile` finish.\n+/// In other words, a postorder of the call graph. In particular, the root is the last element of\n+/// `msgs`.\n+fn idx_to_children(msgs: &[Message]) -> Vec<Vec<usize>> {\n+    // Initialize with the index of the root; `msgs` and `ancestors` should be never empty.\n+    assert!(!msgs.is_empty());\n+    let mut ancestors = vec![msgs.len() - 1];\n+    let mut result: Vec<Vec<usize>> = vec![vec![]; msgs.len()];\n+    for (idx, msg) in msgs[..msgs.len() - 1].iter().enumerate().rev() {\n+        // We need to find the parent of the current message, i.e., the last ancestor that has a\n+        // level lower than the current message.\n+        while msgs[*ancestors.last().unwrap()].level >= msg.level {\n+            ancestors.pop();\n         }\n+        result[*ancestors.last().unwrap()].push(idx);\n+        ancestors.push(idx);\n+    }\n+    // Note that above we visited all children from the last to the first one. Let's reverse vectors\n+    // to get the more natural order where the first element is the first child.\n+    for vec in result.iter_mut() {\n+        vec.reverse();\n     }\n+    result\n }\n \n /// Prints backtrace to stderr, useful for debugging.\n@@ -369,11 +409,11 @@ mod tests {\n     fn test_longer_than() {\n         let mut result = vec![];\n         let msgs = vec![\n-            Message { level: 1, duration: Duration::from_nanos(3), message: \"bar\".to_owned() },\n-            Message { level: 1, duration: Duration::from_nanos(2), message: \"bar\".to_owned() },\n-            Message { level: 0, duration: Duration::from_millis(1), message: \"foo\".to_owned() },\n+            Message { level: 1, duration: Duration::from_nanos(3), label: \"bar\" },\n+            Message { level: 1, duration: Duration::from_nanos(2), label: \"bar\" },\n+            Message { level: 0, duration: Duration::from_millis(1), label: \"foo\" },\n         ];\n-        print(0, &msgs, &mut result, Duration::from_millis(0), Some(Duration::from_millis(1)));\n+        print(&msgs, Duration::from_millis(0), &mut result);\n         // The calls to `bar` are so short that they'll be rounded to 0ms and should get collapsed\n         // when printing.\n         assert_eq!(\n@@ -386,10 +426,10 @@ mod tests {\n     fn test_unaccounted_for_topmost() {\n         let mut result = vec![];\n         let msgs = vec![\n-            Message { level: 1, duration: Duration::from_millis(2), message: \"bar\".to_owned() },\n-            Message { level: 0, duration: Duration::from_millis(5), message: \"foo\".to_owned() },\n+            Message { level: 1, duration: Duration::from_millis(2), label: \"bar\" },\n+            Message { level: 0, duration: Duration::from_millis(5), label: \"foo\" },\n         ];\n-        print(0, &msgs, &mut result, Duration::from_millis(0), Some(Duration::from_millis(1)));\n+        print(&msgs, Duration::from_millis(0), &mut result);\n         assert_eq!(\n             std::str::from_utf8(&result).unwrap().lines().collect::<Vec<_>>(),\n             vec![\n@@ -405,13 +445,13 @@ mod tests {\n     fn test_unaccounted_for_multiple_levels() {\n         let mut result = vec![];\n         let msgs = vec![\n-            Message { level: 2, duration: Duration::from_millis(3), message: \"baz\".to_owned() },\n-            Message { level: 1, duration: Duration::from_millis(5), message: \"bar\".to_owned() },\n-            Message { level: 2, duration: Duration::from_millis(2), message: \"baz\".to_owned() },\n-            Message { level: 1, duration: Duration::from_millis(4), message: \"bar\".to_owned() },\n-            Message { level: 0, duration: Duration::from_millis(9), message: \"foo\".to_owned() },\n+            Message { level: 2, duration: Duration::from_millis(3), label: \"baz\" },\n+            Message { level: 1, duration: Duration::from_millis(5), label: \"bar\" },\n+            Message { level: 2, duration: Duration::from_millis(2), label: \"baz\" },\n+            Message { level: 1, duration: Duration::from_millis(4), label: \"bar\" },\n+            Message { level: 0, duration: Duration::from_millis(9), label: \"foo\" },\n         ];\n-        print(0, &msgs, &mut result, Duration::from_millis(0), None);\n+        print(&msgs, Duration::from_millis(0), &mut result);\n         assert_eq!(\n             std::str::from_utf8(&result).unwrap().lines().collect::<Vec<_>>(),\n             vec!["}, {"sha": "60cb8c1eb20b65c4be927699fe1fa22d7324cb43", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -207,9 +207,28 @@ impl CargoWorkspace {\n         }\n         let resolve = meta.resolve.expect(\"metadata executed with deps\");\n         for node in resolve.nodes {\n-            let source = pkg_by_id[&node.id];\n+            let source = match pkg_by_id.get(&node.id) {\n+                Some(&src) => src,\n+                // FIXME: replace this and a similar branch below with `.unwrap`, once\n+                // https://github.com/rust-lang/cargo/issues/7841\n+                // is fixed and hits stable (around 1.43-is probably?).\n+                None => {\n+                    log::error!(\"Node id do not match in cargo metadata, ignoring {}\", node.id);\n+                    continue;\n+                }\n+            };\n             for dep_node in node.deps {\n-                let dep = PackageDependency { name: dep_node.name, pkg: pkg_by_id[&dep_node.pkg] };\n+                let pkg = match pkg_by_id.get(&dep_node.pkg) {\n+                    Some(&pkg) => pkg,\n+                    None => {\n+                        log::error!(\n+                            \"Dep node id do not match in cargo metadata, ignoring {}\",\n+                            dep_node.pkg\n+                        );\n+                        continue;\n+                    }\n+                };\n+                let dep = PackageDependency { name: dep_node.name, pkg };\n                 packages[source].dependencies.push(dep);\n             }\n             packages[source].features.extend(node.features);"}, {"sha": "bc1d15406b2fde4f677aedecd61e3817b55b997b", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -13,7 +13,7 @@ use std::{\n };\n \n use ra_cfg::CfgOptions;\n-use ra_db::{CrateGraph, CrateId, Edition, Env, FileId};\n+use ra_db::{CrateGraph, CrateId, CrateName, Edition, Env, FileId};\n use rustc_hash::FxHashMap;\n use serde_json::from_reader;\n \n@@ -177,7 +177,9 @@ impl ProjectWorkspace {\n                         if let (Some(&from), Some(&to)) =\n                             (crates.get(&from_crate_id), crates.get(&to_crate_id))\n                         {\n-                            if let Err(_) = crate_graph.add_dep(from, dep.name.clone().into(), to) {\n+                            if let Err(_) =\n+                                crate_graph.add_dep(from, CrateName::new(&dep.name).unwrap(), to)\n+                            {\n                                 log::error!(\n                                     \"cyclic dependency {:?} -> {:?}\",\n                                     from_crate_id,\n@@ -215,7 +217,9 @@ impl ProjectWorkspace {\n                         if let (Some(&from), Some(&to)) =\n                             (sysroot_crates.get(&from), sysroot_crates.get(&to))\n                         {\n-                            if let Err(_) = crate_graph.add_dep(from, name.into(), to) {\n+                            if let Err(_) =\n+                                crate_graph.add_dep(from, CrateName::new(name).unwrap(), to)\n+                            {\n                                 log::error!(\"cyclic dependency between sysroot crates\")\n                             }\n                         }\n@@ -257,7 +261,7 @@ impl ProjectWorkspace {\n                                 if let Some(proc_macro) = libproc_macro {\n                                     if let Err(_) = crate_graph.add_dep(\n                                         crate_id,\n-                                        \"proc_macro\".into(),\n+                                        CrateName::new(\"proc_macro\").unwrap(),\n                                         proc_macro,\n                                     ) {\n                                         log::error!(\n@@ -276,9 +280,14 @@ impl ProjectWorkspace {\n                     for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n                         if let Some(to) = lib_tgt {\n                             if to != from {\n-                                if let Err(_) =\n-                                    crate_graph.add_dep(from, pkg.name(&cargo).into(), to)\n-                                {\n+                                if let Err(_) = crate_graph.add_dep(\n+                                    from,\n+                                    // For root projects with dashes in their name,\n+                                    // cargo metadata does not do any normalization,\n+                                    // so we do it ourselves currently\n+                                    CrateName::normalize_dashes(pkg.name(&cargo)),\n+                                    to,\n+                                ) {\n                                     log::error!(\n                                         \"cyclic dependency between targets of {}\",\n                                         pkg.name(&cargo)\n@@ -289,17 +298,23 @@ impl ProjectWorkspace {\n                         // core is added as a dependency before std in order to\n                         // mimic rustcs dependency order\n                         if let Some(core) = libcore {\n-                            if let Err(_) = crate_graph.add_dep(from, \"core\".into(), core) {\n+                            if let Err(_) =\n+                                crate_graph.add_dep(from, CrateName::new(\"core\").unwrap(), core)\n+                            {\n                                 log::error!(\"cyclic dependency on core for {}\", pkg.name(&cargo))\n                             }\n                         }\n                         if let Some(alloc) = liballoc {\n-                            if let Err(_) = crate_graph.add_dep(from, \"alloc\".into(), alloc) {\n+                            if let Err(_) =\n+                                crate_graph.add_dep(from, CrateName::new(\"alloc\").unwrap(), alloc)\n+                            {\n                                 log::error!(\"cyclic dependency on alloc for {}\", pkg.name(&cargo))\n                             }\n                         }\n                         if let Some(std) = libstd {\n-                            if let Err(_) = crate_graph.add_dep(from, \"std\".into(), std) {\n+                            if let Err(_) =\n+                                crate_graph.add_dep(from, CrateName::new(\"std\").unwrap(), std)\n+                            {\n                                 log::error!(\"cyclic dependency on std for {}\", pkg.name(&cargo))\n                             }\n                         }\n@@ -312,9 +327,11 @@ impl ProjectWorkspace {\n                     for dep in pkg.dependencies(&cargo) {\n                         if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n                             for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n-                                if let Err(_) =\n-                                    crate_graph.add_dep(from, dep.name.clone().into(), to)\n-                                {\n+                                if let Err(_) = crate_graph.add_dep(\n+                                    from,\n+                                    CrateName::new(&dep.name).unwrap(),\n+                                    to,\n+                                ) {\n                                     log::error!(\n                                         \"cyclic dependency {} -> {}\",\n                                         pkg.name(&cargo),"}, {"sha": "83db943fec7f14c0d297db465176a492b9f29093", "filename": "crates/ra_syntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2FCargo.toml?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -4,7 +4,7 @@ name = \"ra_syntax\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n license = \"MIT OR Apache-2.0\"\n-description = \"Comment and whitespace preserving parser for the Rust langauge\"\n+description = \"Comment and whitespace preserving parser for the Rust language\"\n repository = \"https://github.com/rust-analyzer/rust-analyzer\"\n \n [lib]"}, {"sha": "acf677e7d78edec061df51cf72441c9dd6196932", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -81,7 +81,7 @@ impl TreeDiff {\n /// Specifically, returns a map whose keys are descendants of `from` and values\n /// are descendants of `to`, such that  `replace_descendants(from, map) == to`.\n ///\n-/// A trivial solution is a singletom map `{ from: to }`, but this function\n+/// A trivial solution is a singleton map `{ from: to }`, but this function\n /// tries to find a more fine-grained diff.\n pub fn diff(from: &SyntaxNode, to: &SyntaxNode) -> TreeDiff {\n     let mut buf = FxHashMap::default();"}, {"sha": "2e50a095c3e6c68aba7d24c5df464a3790417a48", "filename": "crates/ra_syntax/src/ast/expr_extensions.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -7,6 +7,21 @@ use crate::{\n     SyntaxToken, T,\n };\n \n+impl ast::Expr {\n+    pub fn is_block_like(&self) -> bool {\n+        match self {\n+            ast::Expr::IfExpr(_)\n+            | ast::Expr::LoopExpr(_)\n+            | ast::Expr::ForExpr(_)\n+            | ast::Expr::WhileExpr(_)\n+            | ast::Expr::BlockExpr(_)\n+            | ast::Expr::MatchExpr(_)\n+            | ast::Expr::TryBlockExpr(_) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum ElseBranch {\n     Block(ast::BlockExpr),"}, {"sha": "435135f92d5a596ca9a189c9f65488f7c8c89a4f", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,4 +1,4 @@\n-//! Generated file, do not edit by hand, see `crate/ra_tools/src/codegen`\n+//! Generated file, do not edit by hand, see `xtask/src/codegen`\n \n use crate::{\n     ast::{self, AstChildren, AstNode},"}, {"sha": "862eb11728cd491527f71e2220b8e56e8ec6ac52", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 47, "deletions": 14, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -2,7 +2,7 @@\n //! of smaller pieces.\n use itertools::Itertools;\n \n-use crate::{ast, AstNode, SourceFile, SyntaxKind, SyntaxToken};\n+use crate::{ast, AstNode, SourceFile, SyntaxKind, SyntaxNode, SyntaxToken};\n \n pub fn name(text: &str) -> ast::Name {\n     ast_from_text(&format!(\"mod {};\", text))\n@@ -33,6 +33,21 @@ pub fn record_field(name: ast::NameRef, expr: Option<ast::Expr>) -> ast::RecordF\n     }\n }\n \n+pub fn block_expr(\n+    stmts: impl IntoIterator<Item = ast::Stmt>,\n+    tail_expr: Option<ast::Expr>,\n+) -> ast::BlockExpr {\n+    let mut text = \"{\\n\".to_string();\n+    for stmt in stmts.into_iter() {\n+        text += &format!(\"    {}\\n\", stmt.syntax());\n+    }\n+    if let Some(tail_expr) = tail_expr {\n+        text += &format!(\"    {}\\n\", tail_expr.syntax())\n+    }\n+    text += \"}\";\n+    ast_from_text(&format!(\"fn f() {}\", text))\n+}\n+\n pub fn block_from_expr(e: ast::Expr) -> ast::Block {\n     return from_text(&format!(\"{{ {} }}\", e.syntax()));\n \n@@ -62,6 +77,13 @@ pub fn expr_return() -> ast::Expr {\n pub fn expr_match(expr: ast::Expr, match_arm_list: ast::MatchArmList) -> ast::Expr {\n     expr_from_text(&format!(\"match {} {}\", expr.syntax(), match_arm_list.syntax()))\n }\n+pub fn expr_if(condition: ast::Expr, then_branch: ast::BlockExpr) -> ast::Expr {\n+    expr_from_text(&format!(\"if {} {}\", condition.syntax(), then_branch.syntax()))\n+}\n+pub fn expr_prefix(op: SyntaxKind, expr: ast::Expr) -> ast::Expr {\n+    let token = token(op);\n+    expr_from_text(&format!(\"{}{}\", token, expr.syntax()))\n+}\n fn expr_from_text(text: &str) -> ast::Expr {\n     ast_from_text(&format!(\"const C: () = {};\", text))\n }\n@@ -122,11 +144,18 @@ pub fn match_arm(pats: impl IntoIterator<Item = ast::Pat>, expr: ast::Expr) -> a\n }\n \n pub fn match_arm_list(arms: impl IntoIterator<Item = ast::MatchArm>) -> ast::MatchArmList {\n-    let arms_str = arms.into_iter().map(|arm| format!(\"\\n    {}\", arm.syntax())).join(\",\");\n-    return from_text(&format!(\"{},\\n\", arms_str));\n+    let arms_str = arms\n+        .into_iter()\n+        .map(|arm| {\n+            let needs_comma = arm.expr().map_or(true, |it| !it.is_block_like());\n+            let comma = if needs_comma { \",\" } else { \"\" };\n+            format!(\"    {}{}\\n\", arm.syntax(), comma)\n+        })\n+        .collect::<String>();\n+    return from_text(&format!(\"{}\", arms_str));\n \n     fn from_text(text: &str) -> ast::MatchArmList {\n-        ast_from_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n+        ast_from_text(&format!(\"fn f() {{ match () {{\\n{}}} }}\", text))\n     }\n }\n \n@@ -151,21 +180,16 @@ pub fn where_clause(preds: impl IntoIterator<Item = ast::WherePred>) -> ast::Whe\n     }\n }\n \n-pub fn if_expression(condition: &ast::Expr, statement: &str) -> ast::IfExpr {\n-    ast_from_text(&format!(\n-        \"fn f() {{ if !{} {{\\n    {}\\n}}\\n}}\",\n-        condition.syntax().text(),\n-        statement\n-    ))\n-}\n-\n pub fn let_stmt(pattern: ast::Pat, initializer: Option<ast::Expr>) -> ast::LetStmt {\n     let text = match initializer {\n         Some(it) => format!(\"let {} = {};\", pattern.syntax(), it.syntax()),\n         None => format!(\"let {};\", pattern.syntax()),\n     };\n     ast_from_text(&format!(\"fn f() {{ {} }}\", text))\n }\n+pub fn expr_stmt(expr: ast::Expr) -> ast::ExprStmt {\n+    ast_from_text(&format!(\"fn f() {{ {}; }}\", expr.syntax()))\n+}\n \n pub fn token(kind: SyntaxKind) -> SyntaxToken {\n     tokens::SOURCE_FILE\n@@ -179,15 +203,24 @@ pub fn token(kind: SyntaxKind) -> SyntaxToken {\n \n fn ast_from_text<N: AstNode>(text: &str) -> N {\n     let parse = SourceFile::parse(text);\n-    parse.tree().syntax().descendants().find_map(N::cast).unwrap()\n+    let node = parse.tree().syntax().descendants().find_map(N::cast).unwrap();\n+    let node = node.syntax().clone();\n+    let node = unroot(node);\n+    let node = N::cast(node).unwrap();\n+    assert_eq!(node.syntax().text_range().start(), 0.into());\n+    node\n+}\n+\n+fn unroot(n: SyntaxNode) -> SyntaxNode {\n+    SyntaxNode::new_root(n.green().clone())\n }\n \n pub mod tokens {\n     use crate::{AstNode, Parse, SourceFile, SyntaxKind::*, SyntaxToken, T};\n     use once_cell::sync::Lazy;\n \n     pub(super) static SOURCE_FILE: Lazy<Parse<SourceFile>> =\n-        Lazy::new(|| SourceFile::parse(\"const C: <()>::Item = (1 != 1, 2 == 2)\\n;\"));\n+        Lazy::new(|| SourceFile::parse(\"const C: <()>::Item = (1 != 1, 2 == 2, !true)\\n;\"));\n \n     pub fn comma() -> SyntaxToken {\n         SOURCE_FILE"}, {"sha": "f8f4b64c1e459e97dcacbc0fcd5861527b6f2048", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -41,7 +41,9 @@ use crate::syntax_node::GreenNode;\n pub use crate::{\n     algo::InsertPosition,\n     ast::{AstNode, AstToken},\n-    parsing::{classify_literal, tokenize, Token},\n+    parsing::{\n+        lex_single_syntax_kind, lex_single_valid_syntax_kind, tokenize, Token, TokenizeError,\n+    },\n     ptr::{AstPtr, SyntaxNodePtr},\n     syntax_error::{Location, SyntaxError, SyntaxErrorKind},\n     syntax_node::{"}, {"sha": "e5eb808500de812a871b430db24d9295d50323b9", "filename": "crates/ra_syntax/src/parsing.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -7,15 +7,23 @@ mod text_tree_sink;\n mod reparsing;\n \n use crate::{syntax_node::GreenNode, SyntaxError};\n+use text_token_source::TextTokenSource;\n+use text_tree_sink::TextTreeSink;\n \n-pub use self::lexer::{classify_literal, tokenize, Token};\n+pub use lexer::*;\n \n pub(crate) use self::reparsing::incremental_reparse;\n \n pub(crate) fn parse_text(text: &str) -> (GreenNode, Vec<SyntaxError>) {\n-    let tokens = tokenize(&text);\n-    let mut token_source = text_token_source::TextTokenSource::new(text, &tokens);\n-    let mut tree_sink = text_tree_sink::TextTreeSink::new(text, &tokens);\n+    let (tokens, lexer_errors) = tokenize(&text);\n+\n+    let mut token_source = TextTokenSource::new(text, &tokens);\n+    let mut tree_sink = TextTreeSink::new(text, &tokens);\n+\n     ra_parser::parse(&mut token_source, &mut tree_sink);\n-    tree_sink.finish()\n+\n+    let (tree, mut parser_errors) = tree_sink.finish();\n+    parser_errors.extend(lexer_errors);\n+\n+    (tree, parser_errors)\n }"}, {"sha": "f889e6a1d63aca64e003c98dc73621643a46a562", "filename": "crates/ra_syntax/src/parsing/lexer.rs", "status": "modified", "additions": 248, "deletions": 76, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,8 +1,10 @@\n-//! FIXME: write short doc here\n+//! Lexer analyzes raw input string and produces lexemes (tokens).\n+//! It is just a bridge to `rustc_lexer`.\n \n use crate::{\n+    SyntaxError, SyntaxErrorKind,\n     SyntaxKind::{self, *},\n-    TextUnit,\n+    TextRange, TextUnit,\n };\n \n /// A token of Rust source.\n@@ -14,91 +16,261 @@ pub struct Token {\n     pub len: TextUnit,\n }\n \n-fn match_literal_kind(kind: rustc_lexer::LiteralKind) -> SyntaxKind {\n-    match kind {\n-        rustc_lexer::LiteralKind::Int { .. } => INT_NUMBER,\n-        rustc_lexer::LiteralKind::Float { .. } => FLOAT_NUMBER,\n-        rustc_lexer::LiteralKind::Char { .. } => CHAR,\n-        rustc_lexer::LiteralKind::Byte { .. } => BYTE,\n-        rustc_lexer::LiteralKind::Str { .. } => STRING,\n-        rustc_lexer::LiteralKind::ByteStr { .. } => BYTE_STRING,\n-        rustc_lexer::LiteralKind::RawStr { .. } => RAW_STRING,\n-        rustc_lexer::LiteralKind::RawByteStr { .. } => RAW_BYTE_STRING,\n+/// Break a string up into its component tokens.\n+/// Beware that it checks for shebang first and its length contributes to resulting\n+/// tokens offsets.\n+pub fn tokenize(text: &str) -> (Vec<Token>, Vec<SyntaxError>) {\n+    // non-empty string is a precondtion of `rustc_lexer::strip_shebang()`.\n+    if text.is_empty() {\n+        return Default::default();\n+    }\n+\n+    let mut tokens = Vec::new();\n+    let mut errors = Vec::new();\n+\n+    let mut offset: usize = rustc_lexer::strip_shebang(text)\n+        .map(|shebang_len| {\n+            tokens.push(Token { kind: SHEBANG, len: TextUnit::from_usize(shebang_len) });\n+            shebang_len\n+        })\n+        .unwrap_or(0);\n+\n+    let text_without_shebang = &text[offset..];\n+\n+    for rustc_token in rustc_lexer::tokenize(text_without_shebang) {\n+        let token_len = TextUnit::from_usize(rustc_token.len);\n+        let token_range = TextRange::offset_len(TextUnit::from_usize(offset), token_len);\n+\n+        let (syntax_kind, error) =\n+            rustc_token_kind_to_syntax_kind(&rustc_token.kind, &text[token_range]);\n+\n+        tokens.push(Token { kind: syntax_kind, len: token_len });\n+\n+        if let Some(error) = error {\n+            errors.push(SyntaxError::new(SyntaxErrorKind::TokenizeError(error), token_range));\n+        }\n+\n+        offset += rustc_token.len;\n     }\n+\n+    (tokens, errors)\n+}\n+\n+/// Returns `SyntaxKind` and `Option<SyntaxError>` of the first token\n+/// encountered at the beginning of the string.\n+///\n+/// Returns `None` if the string contains zero *or two or more* tokens.\n+/// The token is malformed if the returned error is not `None`.\n+///\n+/// Beware that unescape errors are not checked at tokenization time.\n+pub fn lex_single_syntax_kind(text: &str) -> Option<(SyntaxKind, Option<SyntaxError>)> {\n+    lex_first_token(text)\n+        .filter(|(token, _)| token.len.to_usize() == text.len())\n+        .map(|(token, error)| (token.kind, error))\n+}\n+\n+/// The same as `lex_single_syntax_kind()` but returns only `SyntaxKind` and\n+/// returns `None` if any tokenization error occured.\n+///\n+/// Beware that unescape errors are not checked at tokenization time.\n+pub fn lex_single_valid_syntax_kind(text: &str) -> Option<SyntaxKind> {\n+    lex_first_token(text)\n+        .filter(|(token, error)| !error.is_some() && token.len.to_usize() == text.len())\n+        .map(|(token, _error)| token.kind)\n }\n \n-/// Break a string up into its component tokens\n-pub fn tokenize(text: &str) -> Vec<Token> {\n+/// Returns `SyntaxKind` and `Option<SyntaxError>` of the first token\n+/// encountered at the beginning of the string.\n+///\n+/// Returns `None` if the string contains zero tokens or if the token was parsed\n+/// with an error.\n+/// The token is malformed if the returned error is not `None`.\n+///\n+/// Beware that unescape errors are not checked at tokenization time.\n+fn lex_first_token(text: &str) -> Option<(Token, Option<SyntaxError>)> {\n+    // non-empty string is a precondtion of `rustc_lexer::first_token()`.\n     if text.is_empty() {\n-        return vec![];\n-    }\n-    let mut text = text;\n-    let mut acc = Vec::new();\n-    if let Some(len) = rustc_lexer::strip_shebang(text) {\n-        acc.push(Token { kind: SHEBANG, len: TextUnit::from_usize(len) });\n-        text = &text[len..];\n+        return None;\n     }\n-    while !text.is_empty() {\n-        let rustc_token = rustc_lexer::first_token(text);\n-        let kind = match rustc_token.kind {\n-            rustc_lexer::TokenKind::LineComment => COMMENT,\n-            rustc_lexer::TokenKind::BlockComment { .. } => COMMENT,\n-            rustc_lexer::TokenKind::Whitespace => WHITESPACE,\n-            rustc_lexer::TokenKind::Ident => {\n-                let token_text = &text[..rustc_token.len];\n+\n+    let rustc_token = rustc_lexer::first_token(text);\n+    let (syntax_kind, error) = rustc_token_kind_to_syntax_kind(&rustc_token.kind, text);\n+\n+    let token = Token { kind: syntax_kind, len: TextUnit::from_usize(rustc_token.len) };\n+    let error = error.map(|error| {\n+        SyntaxError::new(\n+            SyntaxErrorKind::TokenizeError(error),\n+            TextRange::from_to(TextUnit::from(0), TextUnit::of_str(text)),\n+        )\n+    });\n+\n+    Some((token, error))\n+}\n+\n+// FIXME: simplify TokenizeError to `SyntaxError(String, TextRange)` as per @matklad advice:\n+// https://github.com/rust-analyzer/rust-analyzer/pull/2911/files#r371175067\n+\n+/// Describes the values of `SyntaxErrorKind::TokenizeError` enum variant.\n+/// It describes all the types of errors that may happen during the tokenization\n+/// of Rust source.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum TokenizeError {\n+    /// Base prefix was provided, but there were no digits\n+    /// after it, e.g. `0x`, `0b`.\n+    EmptyInt,\n+    /// Float exponent lacks digits e.g. `12.34e+`, `12.3E+`, `12e-`, `1_E-`,\n+    EmptyExponent,\n+\n+    /// Block comment lacks trailing delimiter `*/`\n+    UnterminatedBlockComment,\n+    /// Character literal lacks trailing delimiter `'`\n+    UnterminatedChar,\n+    /// Characterish byte literal lacks trailing delimiter `'`\n+    UnterminatedByte,\n+    /// String literal lacks trailing delimiter `\"`\n+    UnterminatedString,\n+    /// Byte string literal lacks trailing delimiter `\"`\n+    UnterminatedByteString,\n+    /// Raw literal lacks trailing delimiter e.g. `\"##`\n+    UnterminatedRawString,\n+    /// Raw byte string literal lacks trailing delimiter e.g. `\"##`\n+    UnterminatedRawByteString,\n+\n+    /// Raw string lacks a quote after the pound characters e.g. `r###`\n+    UnstartedRawString,\n+    /// Raw byte string lacks a quote after the pound characters e.g. `br###`\n+    UnstartedRawByteString,\n+\n+    /// Lifetime starts with a number e.g. `'4ever`\n+    LifetimeStartsWithNumber,\n+}\n+\n+fn rustc_token_kind_to_syntax_kind(\n+    rustc_token_kind: &rustc_lexer::TokenKind,\n+    token_text: &str,\n+) -> (SyntaxKind, Option<TokenizeError>) {\n+    // A note on an intended tradeoff:\n+    // We drop some useful infromation here (see patterns with double dots `..`)\n+    // Storing that info in `SyntaxKind` is not possible due to its layout requirements of\n+    // being `u16` that come from `rowan::SyntaxKind`.\n+\n+    let syntax_kind = {\n+        use rustc_lexer::TokenKind as TK;\n+        use TokenizeError as TE;\n+\n+        match rustc_token_kind {\n+            TK::LineComment => COMMENT,\n+\n+            TK::BlockComment { terminated: true } => COMMENT,\n+            TK::BlockComment { terminated: false } => {\n+                return (COMMENT, Some(TE::UnterminatedBlockComment));\n+            }\n+\n+            TK::Whitespace => WHITESPACE,\n+\n+            TK::Ident => {\n                 if token_text == \"_\" {\n                     UNDERSCORE\n                 } else {\n-                    SyntaxKind::from_keyword(&text[..rustc_token.len]).unwrap_or(IDENT)\n+                    SyntaxKind::from_keyword(token_text).unwrap_or(IDENT)\n                 }\n             }\n-            rustc_lexer::TokenKind::RawIdent => IDENT,\n-            rustc_lexer::TokenKind::Literal { kind, .. } => match_literal_kind(kind),\n-            rustc_lexer::TokenKind::Lifetime { .. } => LIFETIME,\n-            rustc_lexer::TokenKind::Semi => SEMI,\n-            rustc_lexer::TokenKind::Comma => COMMA,\n-            rustc_lexer::TokenKind::Dot => DOT,\n-            rustc_lexer::TokenKind::OpenParen => L_PAREN,\n-            rustc_lexer::TokenKind::CloseParen => R_PAREN,\n-            rustc_lexer::TokenKind::OpenBrace => L_CURLY,\n-            rustc_lexer::TokenKind::CloseBrace => R_CURLY,\n-            rustc_lexer::TokenKind::OpenBracket => L_BRACK,\n-            rustc_lexer::TokenKind::CloseBracket => R_BRACK,\n-            rustc_lexer::TokenKind::At => AT,\n-            rustc_lexer::TokenKind::Pound => POUND,\n-            rustc_lexer::TokenKind::Tilde => TILDE,\n-            rustc_lexer::TokenKind::Question => QUESTION,\n-            rustc_lexer::TokenKind::Colon => COLON,\n-            rustc_lexer::TokenKind::Dollar => DOLLAR,\n-            rustc_lexer::TokenKind::Eq => EQ,\n-            rustc_lexer::TokenKind::Not => EXCL,\n-            rustc_lexer::TokenKind::Lt => L_ANGLE,\n-            rustc_lexer::TokenKind::Gt => R_ANGLE,\n-            rustc_lexer::TokenKind::Minus => MINUS,\n-            rustc_lexer::TokenKind::And => AMP,\n-            rustc_lexer::TokenKind::Or => PIPE,\n-            rustc_lexer::TokenKind::Plus => PLUS,\n-            rustc_lexer::TokenKind::Star => STAR,\n-            rustc_lexer::TokenKind::Slash => SLASH,\n-            rustc_lexer::TokenKind::Caret => CARET,\n-            rustc_lexer::TokenKind::Percent => PERCENT,\n-            rustc_lexer::TokenKind::Unknown => ERROR,\n+\n+            TK::RawIdent => IDENT,\n+            TK::Literal { kind, .. } => return match_literal_kind(&kind),\n+\n+            TK::Lifetime { starts_with_number: false } => LIFETIME,\n+            TK::Lifetime { starts_with_number: true } => {\n+                return (LIFETIME, Some(TE::LifetimeStartsWithNumber))\n+            }\n+\n+            TK::Semi => SEMI,\n+            TK::Comma => COMMA,\n+            TK::Dot => DOT,\n+            TK::OpenParen => L_PAREN,\n+            TK::CloseParen => R_PAREN,\n+            TK::OpenBrace => L_CURLY,\n+            TK::CloseBrace => R_CURLY,\n+            TK::OpenBracket => L_BRACK,\n+            TK::CloseBracket => R_BRACK,\n+            TK::At => AT,\n+            TK::Pound => POUND,\n+            TK::Tilde => TILDE,\n+            TK::Question => QUESTION,\n+            TK::Colon => COLON,\n+            TK::Dollar => DOLLAR,\n+            TK::Eq => EQ,\n+            TK::Not => EXCL,\n+            TK::Lt => L_ANGLE,\n+            TK::Gt => R_ANGLE,\n+            TK::Minus => MINUS,\n+            TK::And => AMP,\n+            TK::Or => PIPE,\n+            TK::Plus => PLUS,\n+            TK::Star => STAR,\n+            TK::Slash => SLASH,\n+            TK::Caret => CARET,\n+            TK::Percent => PERCENT,\n+            TK::Unknown => ERROR,\n+        }\n+    };\n+\n+    return (syntax_kind, None);\n+\n+    fn match_literal_kind(kind: &rustc_lexer::LiteralKind) -> (SyntaxKind, Option<TokenizeError>) {\n+        use rustc_lexer::LiteralKind as LK;\n+        use TokenizeError as TE;\n+\n+        #[rustfmt::skip]\n+        let syntax_kind = match *kind {\n+            LK::Int { empty_int: false, .. } => INT_NUMBER,\n+            LK::Int { empty_int: true, .. } => {\n+                return (INT_NUMBER, Some(TE::EmptyInt))\n+            }\n+\n+            LK::Float { empty_exponent: false, .. } => FLOAT_NUMBER,\n+            LK::Float { empty_exponent: true, .. } => {\n+                return (FLOAT_NUMBER, Some(TE::EmptyExponent))\n+            }\n+\n+            LK::Char { terminated: true } => CHAR,\n+            LK::Char { terminated: false } => {\n+                return (CHAR, Some(TE::UnterminatedChar))\n+            }\n+\n+            LK::Byte { terminated: true } => BYTE,\n+            LK::Byte { terminated: false } => {\n+                return (BYTE, Some(TE::UnterminatedByte))\n+            }\n+\n+            LK::Str { terminated: true } => STRING,\n+            LK::Str { terminated: false } => {\n+                return (STRING, Some(TE::UnterminatedString))\n+            }\n+\n+\n+            LK::ByteStr { terminated: true } => BYTE_STRING,\n+            LK::ByteStr { terminated: false } => {\n+                return (BYTE_STRING, Some(TE::UnterminatedByteString))\n+            }\n+\n+            LK::RawStr { started: true, terminated: true, .. } => RAW_STRING,\n+            LK::RawStr { started: true, terminated: false, .. } => {\n+                return (RAW_STRING, Some(TE::UnterminatedRawString))\n+            }\n+            LK::RawStr { started: false, .. } => {\n+                return (RAW_STRING, Some(TE::UnstartedRawString))\n+            }\n+\n+            LK::RawByteStr { started: true, terminated: true, .. } => RAW_BYTE_STRING,\n+            LK::RawByteStr { started: true, terminated: false, .. } => {\n+                return (RAW_BYTE_STRING, Some(TE::UnterminatedRawByteString))\n+            }\n+            LK::RawByteStr { started: false, .. } => {\n+                return (RAW_BYTE_STRING, Some(TE::UnstartedRawByteString))\n+            }\n         };\n-        let token = Token { kind, len: TextUnit::from_usize(rustc_token.len) };\n-        acc.push(token);\n-        text = &text[rustc_token.len..];\n-    }\n-    acc\n-}\n \n-pub fn classify_literal(text: &str) -> Option<Token> {\n-    let t = rustc_lexer::first_token(text);\n-    if t.len != text.len() {\n-        return None;\n+        (syntax_kind, None)\n     }\n-    let kind = match t.kind {\n-        rustc_lexer::TokenKind::Literal { kind, .. } => match_literal_kind(kind),\n-        _ => return None,\n-    };\n-    Some(Token { kind, len: TextUnit::from_usize(t.len) })\n }"}, {"sha": "a86da067545867b05f491e2d72b8225d79459a91", "filename": "crates/ra_syntax/src/parsing/reparsing.rs", "status": "modified", "additions": 33, "deletions": 22, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -12,7 +12,7 @@ use ra_text_edit::AtomTextEdit;\n use crate::{\n     algo,\n     parsing::{\n-        lexer::{tokenize, Token},\n+        lexer::{lex_single_syntax_kind, tokenize, Token},\n         text_token_source::TextTokenSource,\n         text_tree_sink::TextTreeSink,\n     },\n@@ -41,37 +41,42 @@ fn reparse_token<'node>(\n     root: &'node SyntaxNode,\n     edit: &AtomTextEdit,\n ) -> Option<(GreenNode, TextRange)> {\n-    let token = algo::find_covering_element(root, edit.delete).as_token()?.clone();\n-    match token.kind() {\n+    let prev_token = algo::find_covering_element(root, edit.delete).as_token()?.clone();\n+    let prev_token_kind = prev_token.kind();\n+    match prev_token_kind {\n         WHITESPACE | COMMENT | IDENT | STRING | RAW_STRING => {\n-            if token.kind() == WHITESPACE || token.kind() == COMMENT {\n+            if prev_token_kind == WHITESPACE || prev_token_kind == COMMENT {\n                 // removing a new line may extends previous token\n-                if token.text().to_string()[edit.delete - token.text_range().start()].contains('\\n')\n-                {\n+                let deleted_range = edit.delete - prev_token.text_range().start();\n+                if prev_token.text()[deleted_range].contains('\\n') {\n                     return None;\n                 }\n             }\n \n-            let text = get_text_after_edit(token.clone().into(), &edit);\n-            let lex_tokens = tokenize(&text);\n-            let lex_token = match lex_tokens[..] {\n-                [lex_token] if lex_token.kind == token.kind() => lex_token,\n-                _ => return None,\n-            };\n+            let mut new_text = get_text_after_edit(prev_token.clone().into(), &edit);\n+            let (new_token_kind, _error) = lex_single_syntax_kind(&new_text)?;\n \n-            if lex_token.kind == IDENT && is_contextual_kw(&text) {\n+            if new_token_kind != prev_token_kind\n+                || (new_token_kind == IDENT && is_contextual_kw(&new_text))\n+            {\n                 return None;\n             }\n \n-            if let Some(next_char) = root.text().char_at(token.text_range().end()) {\n-                let tokens_with_next_char = tokenize(&format!(\"{}{}\", text, next_char));\n-                if tokens_with_next_char.len() == 1 {\n+            // Check that edited token is not a part of the bigger token.\n+            // E.g. if for source code `bruh\"str\"` the user removed `ruh`, then\n+            // `b` no longer remains an identifier, but becomes a part of byte string literal\n+            if let Some(next_char) = root.text().char_at(prev_token.text_range().end()) {\n+                new_text.push(next_char);\n+                let token_with_next_char = lex_single_syntax_kind(&new_text);\n+                if let Some((_kind, _error)) = token_with_next_char {\n                     return None;\n                 }\n+                new_text.pop();\n             }\n \n-            let new_token = GreenToken::new(rowan::SyntaxKind(token.kind().into()), text.into());\n-            Some((token.replace_with(new_token), token.text_range()))\n+            let new_token =\n+                GreenToken::new(rowan::SyntaxKind(prev_token_kind.into()), new_text.into());\n+            Some((prev_token.replace_with(new_token), prev_token.text_range()))\n         }\n         _ => None,\n     }\n@@ -83,20 +88,26 @@ fn reparse_block<'node>(\n ) -> Option<(GreenNode, Vec<SyntaxError>, TextRange)> {\n     let (node, reparser) = find_reparsable_node(root, edit.delete)?;\n     let text = get_text_after_edit(node.clone().into(), &edit);\n-    let tokens = tokenize(&text);\n+\n+    let (tokens, new_lexer_errors) = tokenize(&text);\n     if !is_balanced(&tokens) {\n         return None;\n     }\n+\n     let mut token_source = TextTokenSource::new(&text, &tokens);\n     let mut tree_sink = TextTreeSink::new(&text, &tokens);\n     reparser.parse(&mut token_source, &mut tree_sink);\n-    let (green, new_errors) = tree_sink.finish();\n-    Some((node.replace_with(green), new_errors, node.text_range()))\n+\n+    let (green, mut new_parser_errors) = tree_sink.finish();\n+    new_parser_errors.extend(new_lexer_errors);\n+\n+    Some((node.replace_with(green), new_parser_errors, node.text_range()))\n }\n \n fn get_text_after_edit(element: SyntaxElement, edit: &AtomTextEdit) -> String {\n     let edit =\n         AtomTextEdit::replace(edit.delete - element.text_range().start(), edit.insert.clone());\n+\n     let text = match element {\n         NodeOrToken::Token(token) => token.text().to_string(),\n         NodeOrToken::Node(node) => node.text().to_string(),\n@@ -113,6 +124,7 @@ fn is_contextual_kw(text: &str) -> bool {\n \n fn find_reparsable_node(node: &SyntaxNode, range: TextRange) -> Option<(SyntaxNode, Reparser)> {\n     let node = algo::find_covering_element(node, range);\n+\n     let mut ancestors = match node {\n         NodeOrToken::Token(it) => it.parent().ancestors(),\n         NodeOrToken::Node(it) => it.ancestors(),\n@@ -182,7 +194,6 @@ mod tests {\n         let fully_reparsed = SourceFile::parse(&after);\n         let incrementally_reparsed: Parse<SourceFile> = {\n             let f = SourceFile::parse(&before);\n-            let edit = AtomTextEdit { delete: range, insert: replace_with.to_string() };\n             let (green, new_errors, range) =\n                 incremental_reparse(f.tree().syntax(), &edit, f.errors.to_vec()).unwrap();\n             assert_eq!(range.len(), reparsed_len.into(), \"reparsed fragment has wrong length\");"}, {"sha": "dd202601d9ed631c0a55cf924165c05a0d677081", "filename": "crates/ra_syntax/src/parsing/text_tree_sink.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -92,8 +92,8 @@ impl<'a> TreeSink for TextTreeSink<'a> {\n }\n \n impl<'a> TextTreeSink<'a> {\n-    pub(super) fn new(text: &'a str, tokens: &'a [Token]) -> TextTreeSink<'a> {\n-        TextTreeSink {\n+    pub(super) fn new(text: &'a str, tokens: &'a [Token]) -> Self {\n+        Self {\n             text,\n             tokens,\n             text_pos: 0.into(),"}, {"sha": "7f9d366184b044430de3c872213035a0939758da", "filename": "crates/ra_syntax/src/syntax_error.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Fsyntax_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Fsyntax_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_error.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -4,14 +4,18 @@ use std::fmt;\n \n use ra_parser::ParseError;\n \n-use crate::{validation::EscapeError, TextRange, TextUnit};\n+use crate::{validation::EscapeError, TextRange, TextUnit, TokenizeError};\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SyntaxError {\n     kind: SyntaxErrorKind,\n     location: Location,\n }\n \n+// FIXME: Location should be just `Location(TextRange)`\n+// TextUnit enum member just unnecessarily compicates things,\n+// we should'n treat it specially, it just as a `TextRange { start: x, end: x + 1 }`\n+// see `location_to_range()` in ra_ide/src/diagnostics\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub enum Location {\n     Offset(TextUnit),\n@@ -67,6 +71,10 @@ impl SyntaxError {\n \n         self\n     }\n+\n+    pub fn debug_dump(&self, acc: &mut impl fmt::Write) {\n+        writeln!(acc, \"error {:?}: {}\", self.location(), self.kind()).unwrap();\n+    }\n }\n \n impl fmt::Display for SyntaxError {\n@@ -79,6 +87,10 @@ impl fmt::Display for SyntaxError {\n pub enum SyntaxErrorKind {\n     ParseError(ParseError),\n     EscapeError(EscapeError),\n+    TokenizeError(TokenizeError),\n+    // FIXME: the obvious pattern of this enum dictates that the following enum variants\n+    // should be wrapped into something like `SemmanticError(SemmanticError)`\n+    // or `ValidateError(ValidateError)` or `SemmanticValidateError(...)`\n     InvalidBlockAttr,\n     InvalidMatchInnerAttr,\n     InvalidTupleIndexFormat,\n@@ -101,6 +113,7 @@ impl fmt::Display for SyntaxErrorKind {\n             }\n             ParseError(msg) => write!(f, \"{}\", msg.0),\n             EscapeError(err) => write!(f, \"{}\", err),\n+            TokenizeError(err) => write!(f, \"{}\", err),\n             VisibilityNotAllowed => {\n                 write!(f, \"unnecessary visibility qualifier\")\n             }\n@@ -111,6 +124,51 @@ impl fmt::Display for SyntaxErrorKind {\n     }\n }\n \n+impl fmt::Display for TokenizeError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        #[rustfmt::skip]\n+        let msg = match self {\n+            TokenizeError::EmptyInt => {\n+                \"Missing digits after the integer base prefix\"\n+            }\n+            TokenizeError::EmptyExponent => {\n+                \"Missing digits after the exponent symbol\"\n+            }\n+            TokenizeError::UnterminatedBlockComment => {\n+                \"Missing trailing `*/` symbols to terminate the block comment\"\n+            }\n+            TokenizeError::UnterminatedChar => {\n+                \"Missing trailing `'` symbol to terminate the character literal\"\n+            }\n+            TokenizeError::UnterminatedByte => {\n+                \"Missing trailing `'` symbol to terminate the byte literal\"\n+            }\n+            TokenizeError::UnterminatedString => {\n+                \"Missing trailing `\\\"` symbol to terminate the string literal\"\n+            }\n+            TokenizeError::UnterminatedByteString => {\n+                \"Missing trailing `\\\"` symbol to terminate the byte string literal\"\n+            }\n+            TokenizeError::UnterminatedRawString => {\n+                \"Missing trailing `\\\"` with `#` symbols to terminate the raw string literal\"\n+            }\n+            TokenizeError::UnterminatedRawByteString => {\n+                \"Missing trailing `\\\"` with `#` symbols to terminate the raw byte string literal\"\n+            }\n+            TokenizeError::UnstartedRawString => {\n+                \"Missing `\\\"` symbol after `#` symbols to begin the raw string literal\"\n+            }\n+            TokenizeError::UnstartedRawByteString => {\n+                \"Missing `\\\"` symbol after `#` symbols to begin the raw byte string literal\"\n+            }\n+            TokenizeError::LifetimeStartsWithNumber => {\n+                \"Lifetime name cannot start with a number\"\n+            }\n+        };\n+        write!(f, \"{}\", msg)\n+    }\n+}\n+\n impl fmt::Display for EscapeError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let msg = match self {"}, {"sha": "7c2b18af34e56e46122331340085171f21f8aea2", "filename": "crates/ra_syntax/src/syntax_node.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -4,7 +4,7 @@\n //! `SyntaxNode`, and a basic traversal API (parent, children, siblings).\n //!\n //! The *real* implementation is in the (language-agnostic) `rowan` crate, this\n-//! modules just wraps its API.\n+//! module just wraps its API.\n \n use ra_parser::ParseError;\n use rowan::{GreenNodeBuilder, Language};\n@@ -38,17 +38,12 @@ pub type SyntaxElementChildren = rowan::SyntaxElementChildren<RustLanguage>;\n \n pub use rowan::{Direction, NodeOrToken};\n \n+#[derive(Default)]\n pub struct SyntaxTreeBuilder {\n     errors: Vec<SyntaxError>,\n     inner: GreenNodeBuilder<'static>,\n }\n \n-impl Default for SyntaxTreeBuilder {\n-    fn default() -> SyntaxTreeBuilder {\n-        SyntaxTreeBuilder { errors: Vec::new(), inner: GreenNodeBuilder::new() }\n-    }\n-}\n-\n impl SyntaxTreeBuilder {\n     pub(crate) fn finish_raw(self) -> (GreenNode, Vec<SyntaxError>) {\n         let green = self.inner.finish();"}, {"sha": "fb22b9e54c4739ea7c9f67ee867f3c79def6fc09", "filename": "crates/ra_syntax/src/tests.rs", "status": "modified", "additions": 58, "deletions": 21, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Ftests.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,18 +1,28 @@\n use std::{\n     fmt::Write,\n-    path::{Component, PathBuf},\n+    path::{Component, Path, PathBuf},\n };\n \n use test_utils::{collect_tests, dir_tests, project_dir, read_text};\n \n-use crate::{fuzz, SourceFile};\n+use crate::{fuzz, tokenize, Location, SourceFile, SyntaxError, TextRange, Token};\n \n #[test]\n fn lexer_tests() {\n-    dir_tests(&test_data_dir(), &[\"lexer\"], |text, _| {\n-        let tokens = crate::tokenize(text);\n-        dump_tokens(&tokens, text)\n-    })\n+    // FIXME:\n+    // * Add tests for unicode escapes in byte-character and [raw]-byte-string literals\n+    // * Add tests for unescape errors\n+\n+    dir_tests(&test_data_dir(), &[\"lexer/ok\"], |text, path| {\n+        let (tokens, errors) = tokenize(text);\n+        assert_errors_are_absent(&errors, path);\n+        dump_tokens_and_errors(&tokens, &errors, text)\n+    });\n+    dir_tests(&test_data_dir(), &[\"lexer/err\"], |text, path| {\n+        let (tokens, errors) = tokenize(text);\n+        assert_errors_are_present(&errors, path);\n+        dump_tokens_and_errors(&tokens, &errors, text)\n+    });\n }\n \n #[test]\n@@ -32,18 +42,13 @@ fn parser_tests() {\n     dir_tests(&test_data_dir(), &[\"parser/inline/ok\", \"parser/ok\"], |text, path| {\n         let parse = SourceFile::parse(text);\n         let errors = parse.errors();\n-        assert_eq!(\n-            errors,\n-            &[] as &[crate::SyntaxError],\n-            \"There should be no errors in the file {:?}\",\n-            path.display(),\n-        );\n+        assert_errors_are_absent(&errors, path);\n         parse.debug_dump()\n     });\n     dir_tests(&test_data_dir(), &[\"parser/err\", \"parser/inline/err\"], |text, path| {\n         let parse = SourceFile::parse(text);\n         let errors = parse.errors();\n-        assert!(!errors.is_empty(), \"There should be errors in the file {:?}\", path.display());\n+        assert_errors_are_present(&errors, path);\n         parse.debug_dump()\n     });\n }\n@@ -75,7 +80,7 @@ fn self_hosting_parsing() {\n         .into_iter()\n         .filter_entry(|entry| {\n             !entry.path().components().any(|component| {\n-                // Get all files which are not in the crates/ra_syntax/tests/data folder\n+                // Get all files which are not in the crates/ra_syntax/test_data folder\n                 component == Component::Normal(OsStr::new(\"test_data\"))\n             })\n         })\n@@ -101,15 +106,47 @@ fn test_data_dir() -> PathBuf {\n     project_dir().join(\"crates/ra_syntax/test_data\")\n }\n \n-fn dump_tokens(tokens: &[crate::Token], text: &str) -> String {\n+fn assert_errors_are_present(errors: &[SyntaxError], path: &Path) {\n+    assert!(!errors.is_empty(), \"There should be errors in the file {:?}\", path.display());\n+}\n+fn assert_errors_are_absent(errors: &[SyntaxError], path: &Path) {\n+    assert_eq!(\n+        errors,\n+        &[] as &[SyntaxError],\n+        \"There should be no errors in the file {:?}\",\n+        path.display(),\n+    );\n+}\n+\n+fn dump_tokens_and_errors(tokens: &[Token], errors: &[SyntaxError], text: &str) -> String {\n     let mut acc = String::new();\n     let mut offset = 0;\n     for token in tokens {\n-        let len: u32 = token.len.into();\n-        let len = len as usize;\n-        let token_text = &text[offset..offset + len];\n-        offset += len;\n-        write!(acc, \"{:?} {} {:?}\\n\", token.kind, token.len, token_text).unwrap()\n+        let token_len = token.len.to_usize();\n+        let token_text = &text[offset..offset + token_len];\n+        offset += token_len;\n+        writeln!(acc, \"{:?} {} {:?}\", token.kind, token_len, token_text).unwrap();\n+    }\n+    for err in errors {\n+        let err_range = location_to_range(err.location());\n+        writeln!(\n+            acc,\n+            \"> error{:?} token({:?}) msg({})\",\n+            err.location(),\n+            &text[err_range],\n+            err.kind()\n+        )\n+        .unwrap();\n+    }\n+    return acc;\n+\n+    // FIXME: copy-pasted this from `ra_ide/src/diagnostics.rs`\n+    // `Location` will be refactored soon in new PR, see todos here:\n+    // https://github.com/rust-analyzer/rust-analyzer/issues/223\n+    fn location_to_range(location: Location) -> TextRange {\n+        match location {\n+            Location::Offset(offset) => TextRange::offset_len(offset, 1.into()),\n+            Location::Range(range) => range,\n+        }\n     }\n-    acc\n }"}, {"sha": "8a5f0e4b75510f8b29ed5b0c9cf4320cef5a8781", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -94,6 +94,12 @@ impl From<rustc_lexer::unescape::EscapeError> for SyntaxErrorKind {\n }\n \n pub(crate) fn validate(root: &SyntaxNode) -> Vec<SyntaxError> {\n+    // FIXME:\n+    // * Add validation of character literal containing only a single char\n+    // * Add validation of `crate` keyword not appearing in the middle of the symbol path\n+    // * Add validation of doc comments are being attached to nodes\n+    // * Remove validation of unterminated literals (it is already implemented in `tokenize()`)\n+\n     let mut errors = Vec::new();\n     for node in root.descendants() {\n         match_ast! {"}, {"sha": "71bdd1f9c329f17512756af5d49e3958e8c0d44f", "filename": "crates/ra_syntax/test_data/lexer/0010_comments.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22caf982b99c54058e2e9200aeea0e61cada284a/crates%2Fra_syntax%2Ftest_data%2Flexer%2F0010_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22caf982b99c54058e2e9200aeea0e61cada284a/crates%2Fra_syntax%2Ftest_data%2Flexer%2F0010_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2F0010_comments.rs?ref=22caf982b99c54058e2e9200aeea0e61cada284a", "patch": "@@ -1,3 +0,0 @@\n-#!/usr/bin/env bash\n-// hello\n-//! World"}, {"sha": "3c997de3f1d7fd37c432f308b76348b22e5b2dcc", "filename": "crates/ra_syntax/test_data/lexer/0010_comments.txt", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/22caf982b99c54058e2e9200aeea0e61cada284a/crates%2Fra_syntax%2Ftest_data%2Flexer%2F0010_comments.txt", "raw_url": "https://github.com/rust-lang/rust/raw/22caf982b99c54058e2e9200aeea0e61cada284a/crates%2Fra_syntax%2Ftest_data%2Flexer%2F0010_comments.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2F0010_comments.txt?ref=22caf982b99c54058e2e9200aeea0e61cada284a", "patch": "@@ -1,6 +0,0 @@\n-SHEBANG 19 \"#!/usr/bin/env bash\"\n-WHITESPACE 1 \"\\n\"\n-COMMENT 8 \"// hello\"\n-WHITESPACE 1 \"\\n\"\n-COMMENT 9 \"//! World\"\n-WHITESPACE 1 \"\\n\""}, {"sha": "9c000707726fce782f96c9c7f5e1de51605a0e16", "filename": "crates/ra_syntax/test_data/lexer/0014_unclosed_char.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22caf982b99c54058e2e9200aeea0e61cada284a/crates%2Fra_syntax%2Ftest_data%2Flexer%2F0014_unclosed_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22caf982b99c54058e2e9200aeea0e61cada284a/crates%2Fra_syntax%2Ftest_data%2Flexer%2F0014_unclosed_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2F0014_unclosed_char.rs?ref=22caf982b99c54058e2e9200aeea0e61cada284a", "patch": "@@ -1 +0,0 @@\n-'1\n\\ No newline at end of file"}, {"sha": "737a300ee788e05525b67a01cfc1b3e885df54c4", "filename": "crates/ra_syntax/test_data/lexer/0014_unclosed_char.txt", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22caf982b99c54058e2e9200aeea0e61cada284a/crates%2Fra_syntax%2Ftest_data%2Flexer%2F0014_unclosed_char.txt", "raw_url": "https://github.com/rust-lang/rust/raw/22caf982b99c54058e2e9200aeea0e61cada284a/crates%2Fra_syntax%2Ftest_data%2Flexer%2F0014_unclosed_char.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2F0014_unclosed_char.txt?ref=22caf982b99c54058e2e9200aeea0e61cada284a", "patch": "@@ -1 +0,0 @@\n-LIFETIME 2 \"\\'1\""}, {"sha": "d771a26d49994fadee2004ba0e456fa5ab8dc1f0", "filename": "crates/ra_syntax/test_data/lexer/0015_unclosed_string.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22caf982b99c54058e2e9200aeea0e61cada284a/crates%2Fra_syntax%2Ftest_data%2Flexer%2F0015_unclosed_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22caf982b99c54058e2e9200aeea0e61cada284a/crates%2Fra_syntax%2Ftest_data%2Flexer%2F0015_unclosed_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2F0015_unclosed_string.rs?ref=22caf982b99c54058e2e9200aeea0e61cada284a", "patch": "@@ -1 +0,0 @@\n-\"hello"}, {"sha": "728c40b6624daa23237e2d7814e0cd438e4fbcc0", "filename": "crates/ra_syntax/test_data/lexer/0015_unclosed_string.txt", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22caf982b99c54058e2e9200aeea0e61cada284a/crates%2Fra_syntax%2Ftest_data%2Flexer%2F0015_unclosed_string.txt", "raw_url": "https://github.com/rust-lang/rust/raw/22caf982b99c54058e2e9200aeea0e61cada284a/crates%2Fra_syntax%2Ftest_data%2Flexer%2F0015_unclosed_string.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2F0015_unclosed_string.txt?ref=22caf982b99c54058e2e9200aeea0e61cada284a", "patch": "@@ -1 +0,0 @@\n-STRING 7 \"\\\"hello\\n\""}, {"sha": "ad2823b48f78a0667817300ddcac54c2f6c385e9", "filename": "crates/ra_syntax/test_data/lexer/err/0001_unclosed_char_at_eof.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0001_unclosed_char_at_eof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0001_unclosed_char_at_eof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0001_unclosed_char_at_eof.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+'\n\\ No newline at end of file"}, {"sha": "f24e1fd32a5f37f9f078f6268e23078618a61b6a", "filename": "crates/ra_syntax/test_data/lexer/err/0001_unclosed_char_at_eof.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0001_unclosed_char_at_eof.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0001_unclosed_char_at_eof.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0001_unclosed_char_at_eof.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+CHAR 1 \"\\'\"\n+> error[0; 1) token(\"\\'\") msg(Missing trailing `'` symbol to terminate the character literal)"}, {"sha": "e264a4152801b9c0475cc725983039da19f15b2a", "filename": "crates/ra_syntax/test_data/lexer/err/0002_unclosed_char_with_ferris.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0002_unclosed_char_with_ferris.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0002_unclosed_char_with_ferris.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0002_unclosed_char_with_ferris.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+'\ud83e\udd80\n\\ No newline at end of file"}, {"sha": "bd08cfc448981edd652db79e3c2c13beb7a31566", "filename": "crates/ra_syntax/test_data/lexer/err/0002_unclosed_char_with_ferris.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0002_unclosed_char_with_ferris.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0002_unclosed_char_with_ferris.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0002_unclosed_char_with_ferris.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+CHAR 5 \"\\'\ud83e\udd80\"\n+> error[0; 5) token(\"\\'\ud83e\udd80\") msg(Missing trailing `'` symbol to terminate the character literal)"}, {"sha": "cf74b4dad3b89ec75d72ff183be8e1ed7bc2bee6", "filename": "crates/ra_syntax/test_data/lexer/err/0003_unclosed_char_with_ascii_escape.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0003_unclosed_char_with_ascii_escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0003_unclosed_char_with_ascii_escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0003_unclosed_char_with_ascii_escape.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+'\\x7f\n\\ No newline at end of file"}, {"sha": "0ee22912d14845c616fb9096436da3c91201fe73", "filename": "crates/ra_syntax/test_data/lexer/err/0003_unclosed_char_with_ascii_escape.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0003_unclosed_char_with_ascii_escape.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0003_unclosed_char_with_ascii_escape.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0003_unclosed_char_with_ascii_escape.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+CHAR 5 \"\\'\\\\x7f\"\n+> error[0; 5) token(\"\\'\\\\x7f\") msg(Missing trailing `'` symbol to terminate the character literal)"}, {"sha": "50be91f68524873a1aafa2cdf67cbc7a62cc31a6", "filename": "crates/ra_syntax/test_data/lexer/err/0004_unclosed_char_with_unicode_escape.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0004_unclosed_char_with_unicode_escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0004_unclosed_char_with_unicode_escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0004_unclosed_char_with_unicode_escape.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+'\\u{20AA}\n\\ No newline at end of file"}, {"sha": "96fac42ce79a29783b4e599f419a43a3d8417afb", "filename": "crates/ra_syntax/test_data/lexer/err/0004_unclosed_char_with_unicode_escape.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0004_unclosed_char_with_unicode_escape.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0004_unclosed_char_with_unicode_escape.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0004_unclosed_char_with_unicode_escape.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+CHAR 9 \"\\'\\\\u{20AA}\"\n+> error[0; 9) token(\"\\'\\\\u{20AA}\") msg(Missing trailing `'` symbol to terminate the character literal)"}, {"sha": "309ecfe4786464210a9aaaf78df6d9d10ae72537", "filename": "crates/ra_syntax/test_data/lexer/err/0005_unclosed_char_with_space.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0005_unclosed_char_with_space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0005_unclosed_char_with_space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0005_unclosed_char_with_space.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+' \n\\ No newline at end of file"}, {"sha": "2059f3f81fc7f197b8968294fc1b1cf5bf64004c", "filename": "crates/ra_syntax/test_data/lexer/err/0005_unclosed_char_with_space.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0005_unclosed_char_with_space.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0005_unclosed_char_with_space.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0005_unclosed_char_with_space.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+CHAR 2 \"\\' \"\n+> error[0; 2) token(\"\\' \") msg(Missing trailing `'` symbol to terminate the character literal)"}, {"sha": "6ba258b10932b6a2147c88b623cffa331623b96b", "filename": "crates/ra_syntax/test_data/lexer/err/0006_unclosed_char_with_slash.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0006_unclosed_char_with_slash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0006_unclosed_char_with_slash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0006_unclosed_char_with_slash.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+'\\\n\\ No newline at end of file"}, {"sha": "7dd376e5971f2a64409325ae8679c045dca9c7df", "filename": "crates/ra_syntax/test_data/lexer/err/0006_unclosed_char_with_slash.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0006_unclosed_char_with_slash.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0006_unclosed_char_with_slash.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0006_unclosed_char_with_slash.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+CHAR 2 \"\\'\\\\\"\n+> error[0; 2) token(\"\\'\\\\\") msg(Missing trailing `'` symbol to terminate the character literal)"}, {"sha": "78bef7e3eb291e0f0826ee0455cbce8dada6990c", "filename": "crates/ra_syntax/test_data/lexer/err/0007_unclosed_char_with_slash_n.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0007_unclosed_char_with_slash_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0007_unclosed_char_with_slash_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0007_unclosed_char_with_slash_n.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+'\\n\n\\ No newline at end of file"}, {"sha": "ef7a0a147d014dcababb91749382132367efff3f", "filename": "crates/ra_syntax/test_data/lexer/err/0007_unclosed_char_with_slash_n.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0007_unclosed_char_with_slash_n.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0007_unclosed_char_with_slash_n.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0007_unclosed_char_with_slash_n.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+CHAR 3 \"\\'\\\\n\"\n+> error[0; 3) token(\"\\'\\\\n\") msg(Missing trailing `'` symbol to terminate the character literal)"}, {"sha": "a0e722065bd7004922c59f030e495dbd27baafd4", "filename": "crates/ra_syntax/test_data/lexer/err/0008_unclosed_char_with_slash_single_quote.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0008_unclosed_char_with_slash_single_quote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0008_unclosed_char_with_slash_single_quote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0008_unclosed_char_with_slash_single_quote.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+'\\'\n\\ No newline at end of file"}, {"sha": "13fc5ea9ac46a4219ec78a8de186fe5827fc25c6", "filename": "crates/ra_syntax/test_data/lexer/err/0008_unclosed_char_with_slash_single_quote.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0008_unclosed_char_with_slash_single_quote.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0008_unclosed_char_with_slash_single_quote.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0008_unclosed_char_with_slash_single_quote.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+CHAR 3 \"\\'\\\\\\'\"\n+> error[0; 3) token(\"\\'\\\\\\'\") msg(Missing trailing `'` symbol to terminate the character literal)"}, {"sha": "795dc7e25c587d7bc068e2f8b311505b75da2b68", "filename": "crates/ra_syntax/test_data/lexer/err/0009_unclosed_byte_at_eof.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0009_unclosed_byte_at_eof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0009_unclosed_byte_at_eof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0009_unclosed_byte_at_eof.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+b'\n\\ No newline at end of file"}, {"sha": "269d68c74ac93cb5c68adc44cbc2da8401b555ff", "filename": "crates/ra_syntax/test_data/lexer/err/0009_unclosed_byte_at_eof.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0009_unclosed_byte_at_eof.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0009_unclosed_byte_at_eof.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0009_unclosed_byte_at_eof.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+BYTE 2 \"b\\'\"\n+> error[0; 2) token(\"b\\'\") msg(Missing trailing `'` symbol to terminate the byte literal)"}, {"sha": "c9230dc24ea4421b5c88fa4bbb6eb402f7daffa6", "filename": "crates/ra_syntax/test_data/lexer/err/0010_unclosed_byte_with_ferris.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0010_unclosed_byte_with_ferris.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0010_unclosed_byte_with_ferris.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0010_unclosed_byte_with_ferris.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+b'\ud83e\udd80\n\\ No newline at end of file"}, {"sha": "91a76e479abb3c81ab6cd1cbac36ecc70d774a44", "filename": "crates/ra_syntax/test_data/lexer/err/0010_unclosed_byte_with_ferris.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0010_unclosed_byte_with_ferris.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0010_unclosed_byte_with_ferris.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0010_unclosed_byte_with_ferris.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+BYTE 6 \"b\\'\ud83e\udd80\"\n+> error[0; 6) token(\"b\\'\ud83e\udd80\") msg(Missing trailing `'` symbol to terminate the byte literal)"}, {"sha": "d146a8090d185b63ae752335134f55851dd0b539", "filename": "crates/ra_syntax/test_data/lexer/err/0011_unclosed_byte_with_ascii_escape.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0011_unclosed_byte_with_ascii_escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0011_unclosed_byte_with_ascii_escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0011_unclosed_byte_with_ascii_escape.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+b'\\x7f\n\\ No newline at end of file"}, {"sha": "b8c804a18942987f23b739ad44513b4ee7608310", "filename": "crates/ra_syntax/test_data/lexer/err/0011_unclosed_byte_with_ascii_escape.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0011_unclosed_byte_with_ascii_escape.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0011_unclosed_byte_with_ascii_escape.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0011_unclosed_byte_with_ascii_escape.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+BYTE 6 \"b\\'\\\\x7f\"\n+> error[0; 6) token(\"b\\'\\\\x7f\") msg(Missing trailing `'` symbol to terminate the byte literal)"}, {"sha": "a3dec7c255d0e17d6c55516c6e514bc574e1b083", "filename": "crates/ra_syntax/test_data/lexer/err/0012_unclosed_byte_with_unicode_escape.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0012_unclosed_byte_with_unicode_escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0012_unclosed_byte_with_unicode_escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0012_unclosed_byte_with_unicode_escape.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+b'\\u{20AA}\n\\ No newline at end of file"}, {"sha": "dfca22a59823960216e46bee624715b5850f43aa", "filename": "crates/ra_syntax/test_data/lexer/err/0012_unclosed_byte_with_unicode_escape.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0012_unclosed_byte_with_unicode_escape.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0012_unclosed_byte_with_unicode_escape.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0012_unclosed_byte_with_unicode_escape.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+BYTE 10 \"b\\'\\\\u{20AA}\"\n+> error[0; 10) token(\"b\\'\\\\u{20AA}\") msg(Missing trailing `'` symbol to terminate the byte literal)"}, {"sha": "93b7f9c87c9144783b4a4cf7ba0a093a68e6691d", "filename": "crates/ra_syntax/test_data/lexer/err/0013_unclosed_byte_with_space.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0013_unclosed_byte_with_space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0013_unclosed_byte_with_space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0013_unclosed_byte_with_space.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+b' \n\\ No newline at end of file"}, {"sha": "51a1cceabdfbc2557c3efd4c614e2a3e939fda7d", "filename": "crates/ra_syntax/test_data/lexer/err/0013_unclosed_byte_with_space.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0013_unclosed_byte_with_space.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0013_unclosed_byte_with_space.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0013_unclosed_byte_with_space.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+BYTE 3 \"b\\' \"\n+> error[0; 3) token(\"b\\' \") msg(Missing trailing `'` symbol to terminate the byte literal)"}, {"sha": "abffa5037c0daa68a067eb6bc9f1c9a1b6d0f795", "filename": "crates/ra_syntax/test_data/lexer/err/0014_unclosed_byte_with_slash.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0014_unclosed_byte_with_slash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0014_unclosed_byte_with_slash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0014_unclosed_byte_with_slash.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+b'\\\n\\ No newline at end of file"}, {"sha": "24e835c2795b8f9f8d5583676ffacb520a687e96", "filename": "crates/ra_syntax/test_data/lexer/err/0014_unclosed_byte_with_slash.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0014_unclosed_byte_with_slash.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0014_unclosed_byte_with_slash.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0014_unclosed_byte_with_slash.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+BYTE 3 \"b\\'\\\\\"\n+> error[0; 3) token(\"b\\'\\\\\") msg(Missing trailing `'` symbol to terminate the byte literal)"}, {"sha": "4f46836a935e31ab6b65ad8b185d51b34840b500", "filename": "crates/ra_syntax/test_data/lexer/err/0015_unclosed_byte_with_slash_n.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0015_unclosed_byte_with_slash_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0015_unclosed_byte_with_slash_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0015_unclosed_byte_with_slash_n.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+b'\\n\n\\ No newline at end of file"}, {"sha": "f1e39a41ba0b688b7cc84e70582a12ab3a9c9672", "filename": "crates/ra_syntax/test_data/lexer/err/0015_unclosed_byte_with_slash_n.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0015_unclosed_byte_with_slash_n.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0015_unclosed_byte_with_slash_n.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0015_unclosed_byte_with_slash_n.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+BYTE 4 \"b\\'\\\\n\"\n+> error[0; 4) token(\"b\\'\\\\n\") msg(Missing trailing `'` symbol to terminate the byte literal)"}, {"sha": "645b641eedb669cc85718c4a33665ac042278bc8", "filename": "crates/ra_syntax/test_data/lexer/err/0016_unclosed_byte_with_slash_single_quote.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0016_unclosed_byte_with_slash_single_quote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0016_unclosed_byte_with_slash_single_quote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0016_unclosed_byte_with_slash_single_quote.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+b'\\'\n\\ No newline at end of file"}, {"sha": "f8ffe815d429671a6f1adcc4dcaaeb14519139c2", "filename": "crates/ra_syntax/test_data/lexer/err/0016_unclosed_byte_with_slash_single_quote.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0016_unclosed_byte_with_slash_single_quote.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0016_unclosed_byte_with_slash_single_quote.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0016_unclosed_byte_with_slash_single_quote.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+BYTE 4 \"b\\'\\\\\\'\"\n+> error[0; 4) token(\"b\\'\\\\\\'\") msg(Missing trailing `'` symbol to terminate the byte literal)"}, {"sha": "9d68933c44f13985b9eb19159da6eb3ff0e574bf", "filename": "crates/ra_syntax/test_data/lexer/err/0017_unclosed_string_at_eof.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0017_unclosed_string_at_eof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0017_unclosed_string_at_eof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0017_unclosed_string_at_eof.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+\"\n\\ No newline at end of file"}, {"sha": "823daaf6f7a6856dd3eb18b0f399795eec13d799", "filename": "crates/ra_syntax/test_data/lexer/err/0017_unclosed_string_at_eof.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0017_unclosed_string_at_eof.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0017_unclosed_string_at_eof.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0017_unclosed_string_at_eof.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+STRING 1 \"\\\"\"\n+> error[0; 1) token(\"\\\"\") msg(Missing trailing `\"` symbol to terminate the string literal)"}, {"sha": "d439b8d2a1d6c12e517bb66ffb3ce05f1e09031b", "filename": "crates/ra_syntax/test_data/lexer/err/0018_unclosed_string_with_ferris.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0018_unclosed_string_with_ferris.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0018_unclosed_string_with_ferris.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0018_unclosed_string_with_ferris.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+\"\ud83e\udd80\n\\ No newline at end of file"}, {"sha": "164580eb35db05b2c43e55f7c6bc88f9f8e4d101", "filename": "crates/ra_syntax/test_data/lexer/err/0018_unclosed_string_with_ferris.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0018_unclosed_string_with_ferris.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0018_unclosed_string_with_ferris.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0018_unclosed_string_with_ferris.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+STRING 5 \"\\\"\ud83e\udd80\"\n+> error[0; 5) token(\"\\\"\ud83e\udd80\") msg(Missing trailing `\"` symbol to terminate the string literal)"}, {"sha": "56186a34444f4986761a67a953d4c35cb1bac065", "filename": "crates/ra_syntax/test_data/lexer/err/0019_unclosed_string_with_ascii_escape.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0019_unclosed_string_with_ascii_escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0019_unclosed_string_with_ascii_escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0019_unclosed_string_with_ascii_escape.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+\"\\x7f\n\\ No newline at end of file"}, {"sha": "4453827c303ec5dc63ef3c8562f8cbc461745601", "filename": "crates/ra_syntax/test_data/lexer/err/0019_unclosed_string_with_ascii_escape.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0019_unclosed_string_with_ascii_escape.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0019_unclosed_string_with_ascii_escape.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0019_unclosed_string_with_ascii_escape.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+STRING 5 \"\\\"\\\\x7f\"\n+> error[0; 5) token(\"\\\"\\\\x7f\") msg(Missing trailing `\"` symbol to terminate the string literal)"}, {"sha": "ed24095c3d4fc8904d1726f52167550ad75cadff", "filename": "crates/ra_syntax/test_data/lexer/err/0020_unclosed_string_with_unicode_escape.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0020_unclosed_string_with_unicode_escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0020_unclosed_string_with_unicode_escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0020_unclosed_string_with_unicode_escape.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+\"\\u{20AA}\n\\ No newline at end of file"}, {"sha": "aa614f3046130683f7dd05e6beafc3ff7f4d7781", "filename": "crates/ra_syntax/test_data/lexer/err/0020_unclosed_string_with_unicode_escape.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0020_unclosed_string_with_unicode_escape.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0020_unclosed_string_with_unicode_escape.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0020_unclosed_string_with_unicode_escape.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+STRING 9 \"\\\"\\\\u{20AA}\"\n+> error[0; 9) token(\"\\\"\\\\u{20AA}\") msg(Missing trailing `\"` symbol to terminate the string literal)"}, {"sha": "72cdc841fbd787e46735053268635236840e9c64", "filename": "crates/ra_syntax/test_data/lexer/err/0021_unclosed_string_with_space.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0021_unclosed_string_with_space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0021_unclosed_string_with_space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0021_unclosed_string_with_space.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+\" \n\\ No newline at end of file"}, {"sha": "b7db1236ffa8f26749e0e45cf69045d1e05a48fc", "filename": "crates/ra_syntax/test_data/lexer/err/0021_unclosed_string_with_space.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0021_unclosed_string_with_space.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0021_unclosed_string_with_space.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0021_unclosed_string_with_space.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+STRING 2 \"\\\" \"\n+> error[0; 2) token(\"\\\" \") msg(Missing trailing `\"` symbol to terminate the string literal)"}, {"sha": "00a25840087190c844abad32d4ae185260446822", "filename": "crates/ra_syntax/test_data/lexer/err/0022_unclosed_string_with_slash.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0022_unclosed_string_with_slash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0022_unclosed_string_with_slash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0022_unclosed_string_with_slash.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+\"\\\n\\ No newline at end of file"}, {"sha": "9d3df37991a996bb95e4df93b9fc2affee22127d", "filename": "crates/ra_syntax/test_data/lexer/err/0022_unclosed_string_with_slash.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0022_unclosed_string_with_slash.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0022_unclosed_string_with_slash.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0022_unclosed_string_with_slash.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+STRING 2 \"\\\"\\\\\"\n+> error[0; 2) token(\"\\\"\\\\\") msg(Missing trailing `\"` symbol to terminate the string literal)"}, {"sha": "a0c29b8cff7fc6f2b421683f51266c38e2d0cc2f", "filename": "crates/ra_syntax/test_data/lexer/err/0023_unclosed_string_with_slash_n.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0023_unclosed_string_with_slash_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0023_unclosed_string_with_slash_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0023_unclosed_string_with_slash_n.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+\"\\n\n\\ No newline at end of file"}, {"sha": "e3eb672b69152b57a9aa521d016b0e7cdc37935d", "filename": "crates/ra_syntax/test_data/lexer/err/0023_unclosed_string_with_slash_n.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0023_unclosed_string_with_slash_n.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0023_unclosed_string_with_slash_n.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0023_unclosed_string_with_slash_n.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+STRING 3 \"\\\"\\\\n\"\n+> error[0; 3) token(\"\\\"\\\\n\") msg(Missing trailing `\"` symbol to terminate the string literal)"}, {"sha": "403c2d6ddc698b0dd413fe92223411cbd8222e98", "filename": "crates/ra_syntax/test_data/lexer/err/0024_unclosed_string_with_slash_double_quote.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0024_unclosed_string_with_slash_double_quote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0024_unclosed_string_with_slash_double_quote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0024_unclosed_string_with_slash_double_quote.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+\"\\\"\n\\ No newline at end of file"}, {"sha": "041d7fb6efcdacb20609ffedd65c4d5a0f0ae21f", "filename": "crates/ra_syntax/test_data/lexer/err/0024_unclosed_string_with_slash_double_quote.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0024_unclosed_string_with_slash_double_quote.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0024_unclosed_string_with_slash_double_quote.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0024_unclosed_string_with_slash_double_quote.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+STRING 3 \"\\\"\\\\\\\"\"\n+> error[0; 3) token(\"\\\"\\\\\\\"\") msg(Missing trailing `\"` symbol to terminate the string literal)"}, {"sha": "36f4f432187d6542e917e3ca4f1614907cd6b25b", "filename": "crates/ra_syntax/test_data/lexer/err/0025_unclosed_byte_string_at_eof.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0025_unclosed_byte_string_at_eof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0025_unclosed_byte_string_at_eof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0025_unclosed_byte_string_at_eof.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+b\"\n\\ No newline at end of file"}, {"sha": "be7970a835bfce07e92a15e58658df4ff6b107ba", "filename": "crates/ra_syntax/test_data/lexer/err/0025_unclosed_byte_string_at_eof.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0025_unclosed_byte_string_at_eof.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0025_unclosed_byte_string_at_eof.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0025_unclosed_byte_string_at_eof.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+BYTE_STRING 2 \"b\\\"\"\n+> error[0; 2) token(\"b\\\"\") msg(Missing trailing `\"` symbol to terminate the byte string literal)"}, {"sha": "3c23a03722873d7d2d0c91271a629bce34550ec2", "filename": "crates/ra_syntax/test_data/lexer/err/0026_unclosed_byte_string_with_ferris.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0026_unclosed_byte_string_with_ferris.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0026_unclosed_byte_string_with_ferris.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0026_unclosed_byte_string_with_ferris.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+b\"\ud83e\udd80\n\\ No newline at end of file"}, {"sha": "bf9aab132cb272b0bba6dc3e91c9db9b256fe393", "filename": "crates/ra_syntax/test_data/lexer/err/0026_unclosed_byte_string_with_ferris.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0026_unclosed_byte_string_with_ferris.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0026_unclosed_byte_string_with_ferris.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0026_unclosed_byte_string_with_ferris.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+BYTE_STRING 6 \"b\\\"\ud83e\udd80\"\n+> error[0; 6) token(\"b\\\"\ud83e\udd80\") msg(Missing trailing `\"` symbol to terminate the byte string literal)"}, {"sha": "836c112c1572fe38f697b997b159df136cee0503", "filename": "crates/ra_syntax/test_data/lexer/err/0027_unclosed_byte_string_with_ascii_escape.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0027_unclosed_byte_string_with_ascii_escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0027_unclosed_byte_string_with_ascii_escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0027_unclosed_byte_string_with_ascii_escape.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+b\"\\x7f\n\\ No newline at end of file"}, {"sha": "76e16d7d3489d5363ac30bf92f15ba4e80989fc2", "filename": "crates/ra_syntax/test_data/lexer/err/0027_unclosed_byte_string_with_ascii_escape.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0027_unclosed_byte_string_with_ascii_escape.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0027_unclosed_byte_string_with_ascii_escape.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0027_unclosed_byte_string_with_ascii_escape.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+BYTE_STRING 6 \"b\\\"\\\\x7f\"\n+> error[0; 6) token(\"b\\\"\\\\x7f\") msg(Missing trailing `\"` symbol to terminate the byte string literal)"}, {"sha": "1c6df1d00e4e65390deb4dc086bd7dc516272241", "filename": "crates/ra_syntax/test_data/lexer/err/0028_unclosed_byte_string_with_unicode_escape.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0028_unclosed_byte_string_with_unicode_escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0028_unclosed_byte_string_with_unicode_escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0028_unclosed_byte_string_with_unicode_escape.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+b\"\\u{20AA}\n\\ No newline at end of file"}, {"sha": "09adffa160122d6d9ee2eb666543845bc6878e2f", "filename": "crates/ra_syntax/test_data/lexer/err/0028_unclosed_byte_string_with_unicode_escape.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0028_unclosed_byte_string_with_unicode_escape.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0028_unclosed_byte_string_with_unicode_escape.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0028_unclosed_byte_string_with_unicode_escape.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+BYTE_STRING 10 \"b\\\"\\\\u{20AA}\"\n+> error[0; 10) token(\"b\\\"\\\\u{20AA}\") msg(Missing trailing `\"` symbol to terminate the byte string literal)"}, {"sha": "d6898541e623c39b25417cceaba0f0324ea5da3e", "filename": "crates/ra_syntax/test_data/lexer/err/0029_unclosed_byte_string_with_space.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0029_unclosed_byte_string_with_space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0029_unclosed_byte_string_with_space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0029_unclosed_byte_string_with_space.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+b\" \n\\ No newline at end of file"}, {"sha": "fcb7253c82b0017193ec338e49e2c2edf9074064", "filename": "crates/ra_syntax/test_data/lexer/err/0029_unclosed_byte_string_with_space.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0029_unclosed_byte_string_with_space.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0029_unclosed_byte_string_with_space.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0029_unclosed_byte_string_with_space.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+BYTE_STRING 3 \"b\\\" \"\n+> error[0; 3) token(\"b\\\" \") msg(Missing trailing `\"` symbol to terminate the byte string literal)"}, {"sha": "cce6615381d5e9e22bbfc2f4f04181d2f865dfa5", "filename": "crates/ra_syntax/test_data/lexer/err/0030_unclosed_byte_string_with_slash.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0030_unclosed_byte_string_with_slash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0030_unclosed_byte_string_with_slash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0030_unclosed_byte_string_with_slash.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+b\"\\\n\\ No newline at end of file"}, {"sha": "0a1b3e26993a39b3da8c3bfb1565da5d7a25fa70", "filename": "crates/ra_syntax/test_data/lexer/err/0030_unclosed_byte_string_with_slash.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0030_unclosed_byte_string_with_slash.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0030_unclosed_byte_string_with_slash.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0030_unclosed_byte_string_with_slash.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+BYTE_STRING 3 \"b\\\"\\\\\"\n+> error[0; 3) token(\"b\\\"\\\\\") msg(Missing trailing `\"` symbol to terminate the byte string literal)"}, {"sha": "5e680aabb7b1c9c085bb39516429236ae2e685cc", "filename": "crates/ra_syntax/test_data/lexer/err/0031_unclosed_byte_string_with_slash_n.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0031_unclosed_byte_string_with_slash_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0031_unclosed_byte_string_with_slash_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0031_unclosed_byte_string_with_slash_n.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+b\"\\n\n\\ No newline at end of file"}, {"sha": "1fb89d2b6d04f7133a8b21845b6ad296d28032af", "filename": "crates/ra_syntax/test_data/lexer/err/0031_unclosed_byte_string_with_slash_n.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0031_unclosed_byte_string_with_slash_n.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0031_unclosed_byte_string_with_slash_n.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0031_unclosed_byte_string_with_slash_n.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+BYTE_STRING 4 \"b\\\"\\\\n\"\n+> error[0; 4) token(\"b\\\"\\\\n\") msg(Missing trailing `\"` symbol to terminate the byte string literal)"}, {"sha": "f2ff58ba9a883643b6b8e5d69f75344cbee6e9ad", "filename": "crates/ra_syntax/test_data/lexer/err/0032_unclosed_byte_string_with_slash_double_quote.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0032_unclosed_byte_string_with_slash_double_quote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0032_unclosed_byte_string_with_slash_double_quote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0032_unclosed_byte_string_with_slash_double_quote.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+b\"\\\"\n\\ No newline at end of file"}, {"sha": "718d36992998a167dc94499e9fef49661a903c8b", "filename": "crates/ra_syntax/test_data/lexer/err/0032_unclosed_byte_string_with_slash_double_quote.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0032_unclosed_byte_string_with_slash_double_quote.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0032_unclosed_byte_string_with_slash_double_quote.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0032_unclosed_byte_string_with_slash_double_quote.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+BYTE_STRING 4 \"b\\\"\\\\\\\"\"\n+> error[0; 4) token(\"b\\\"\\\\\\\"\") msg(Missing trailing `\"` symbol to terminate the byte string literal)"}, {"sha": "557c59b625190937a1e56e4d04cd37454fa38b5c", "filename": "crates/ra_syntax/test_data/lexer/err/0033_unclosed_raw_string_at_eof.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0033_unclosed_raw_string_at_eof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0033_unclosed_raw_string_at_eof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0033_unclosed_raw_string_at_eof.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+r##\"\n\\ No newline at end of file"}, {"sha": "93348f548fd89b3ea9a38da40d4258208d1d3448", "filename": "crates/ra_syntax/test_data/lexer/err/0033_unclosed_raw_string_at_eof.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0033_unclosed_raw_string_at_eof.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0033_unclosed_raw_string_at_eof.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0033_unclosed_raw_string_at_eof.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+RAW_STRING 4 \"r##\\\"\"\n+> error[0; 4) token(\"r##\\\"\") msg(Missing trailing `\"` with `#` symbols to terminate the raw string literal)"}, {"sha": "bd046e4bb9148e109cbe00519a49c22f16014928", "filename": "crates/ra_syntax/test_data/lexer/err/0034_unclosed_raw_string_with_ferris.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0034_unclosed_raw_string_with_ferris.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0034_unclosed_raw_string_with_ferris.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0034_unclosed_raw_string_with_ferris.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+r##\"\ud83e\udd80\n\\ No newline at end of file"}, {"sha": "42c70dfe836f0f536150cfc79a32463ffbe6db23", "filename": "crates/ra_syntax/test_data/lexer/err/0034_unclosed_raw_string_with_ferris.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0034_unclosed_raw_string_with_ferris.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0034_unclosed_raw_string_with_ferris.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0034_unclosed_raw_string_with_ferris.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+RAW_STRING 8 \"r##\\\"\ud83e\udd80\"\n+> error[0; 8) token(\"r##\\\"\ud83e\udd80\") msg(Missing trailing `\"` with `#` symbols to terminate the raw string literal)"}, {"sha": "5bec883dc7ae19bff364f58ed3b3df038fecd4aa", "filename": "crates/ra_syntax/test_data/lexer/err/0035_unclosed_raw_string_with_ascii_escape.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0035_unclosed_raw_string_with_ascii_escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0035_unclosed_raw_string_with_ascii_escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0035_unclosed_raw_string_with_ascii_escape.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+r##\"\\x7f\n\\ No newline at end of file"}, {"sha": "2bdeea0ff53abb88966ef7a79cea95c13c7661c4", "filename": "crates/ra_syntax/test_data/lexer/err/0035_unclosed_raw_string_with_ascii_escape.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0035_unclosed_raw_string_with_ascii_escape.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0035_unclosed_raw_string_with_ascii_escape.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0035_unclosed_raw_string_with_ascii_escape.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+RAW_STRING 8 \"r##\\\"\\\\x7f\"\n+> error[0; 8) token(\"r##\\\"\\\\x7f\") msg(Missing trailing `\"` with `#` symbols to terminate the raw string literal)"}, {"sha": "bf05c39134bd08d95d5094ccfe660bf4a0974de2", "filename": "crates/ra_syntax/test_data/lexer/err/0036_unclosed_raw_string_with_unicode_escape.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0036_unclosed_raw_string_with_unicode_escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0036_unclosed_raw_string_with_unicode_escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0036_unclosed_raw_string_with_unicode_escape.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+r##\"\\u{20AA}\n\\ No newline at end of file"}, {"sha": "667d4d79f9fee28bed86c1211ff800e675d6474d", "filename": "crates/ra_syntax/test_data/lexer/err/0036_unclosed_raw_string_with_unicode_escape.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0036_unclosed_raw_string_with_unicode_escape.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0036_unclosed_raw_string_with_unicode_escape.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0036_unclosed_raw_string_with_unicode_escape.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+RAW_STRING 12 \"r##\\\"\\\\u{20AA}\"\n+> error[0; 12) token(\"r##\\\"\\\\u{20AA}\") msg(Missing trailing `\"` with `#` symbols to terminate the raw string literal)"}, {"sha": "f104bae4f2cdfdeb47dec924c57bd0215b99dfdd", "filename": "crates/ra_syntax/test_data/lexer/err/0037_unclosed_raw_string_with_space.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0037_unclosed_raw_string_with_space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0037_unclosed_raw_string_with_space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0037_unclosed_raw_string_with_space.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+r##\" \n\\ No newline at end of file"}, {"sha": "dd9597a1a9e0422e489f1cd377c801aef436399e", "filename": "crates/ra_syntax/test_data/lexer/err/0037_unclosed_raw_string_with_space.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0037_unclosed_raw_string_with_space.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0037_unclosed_raw_string_with_space.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0037_unclosed_raw_string_with_space.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+RAW_STRING 5 \"r##\\\" \"\n+> error[0; 5) token(\"r##\\\" \") msg(Missing trailing `\"` with `#` symbols to terminate the raw string literal)"}, {"sha": "9242077b8b7c58f62aa24fd4efcaf8f5b1fe2789", "filename": "crates/ra_syntax/test_data/lexer/err/0038_unclosed_raw_string_with_slash.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0038_unclosed_raw_string_with_slash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0038_unclosed_raw_string_with_slash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0038_unclosed_raw_string_with_slash.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+r##\"\\\n\\ No newline at end of file"}, {"sha": "6ac6e3d623d22619b98b3faa4e784089d43292f1", "filename": "crates/ra_syntax/test_data/lexer/err/0038_unclosed_raw_string_with_slash.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0038_unclosed_raw_string_with_slash.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0038_unclosed_raw_string_with_slash.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0038_unclosed_raw_string_with_slash.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+RAW_STRING 5 \"r##\\\"\\\\\"\n+> error[0; 5) token(\"r##\\\"\\\\\") msg(Missing trailing `\"` with `#` symbols to terminate the raw string literal)"}, {"sha": "db1c16f2ba5ac812292e310602083f67cf77ab56", "filename": "crates/ra_syntax/test_data/lexer/err/0039_unclosed_raw_string_with_slash_n.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0039_unclosed_raw_string_with_slash_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0039_unclosed_raw_string_with_slash_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0039_unclosed_raw_string_with_slash_n.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+r##\"\\n\n\\ No newline at end of file"}, {"sha": "9d35443f5101680215a8b0e9b36ab6c792c11cec", "filename": "crates/ra_syntax/test_data/lexer/err/0039_unclosed_raw_string_with_slash_n.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0039_unclosed_raw_string_with_slash_n.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0039_unclosed_raw_string_with_slash_n.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0039_unclosed_raw_string_with_slash_n.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+RAW_STRING 6 \"r##\\\"\\\\n\"\n+> error[0; 6) token(\"r##\\\"\\\\n\") msg(Missing trailing `\"` with `#` symbols to terminate the raw string literal)"}, {"sha": "ae5bae62230856c72a718c0388a90fb420ef2f55", "filename": "crates/ra_syntax/test_data/lexer/err/0040_unclosed_raw_byte_string_at_eof.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0040_unclosed_raw_byte_string_at_eof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0040_unclosed_raw_byte_string_at_eof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0040_unclosed_raw_byte_string_at_eof.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+br##\"\n\\ No newline at end of file"}, {"sha": "81fa39ea515f8ff96a67c58eca78f3e898252928", "filename": "crates/ra_syntax/test_data/lexer/err/0040_unclosed_raw_byte_string_at_eof.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0040_unclosed_raw_byte_string_at_eof.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0040_unclosed_raw_byte_string_at_eof.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0040_unclosed_raw_byte_string_at_eof.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+RAW_BYTE_STRING 5 \"br##\\\"\"\n+> error[0; 5) token(\"br##\\\"\") msg(Missing trailing `\"` with `#` symbols to terminate the raw byte string literal)"}, {"sha": "9ef01207a173f33d66653c7c452095a885d7d525", "filename": "crates/ra_syntax/test_data/lexer/err/0041_unclosed_raw_byte_string_with_ferris.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0041_unclosed_raw_byte_string_with_ferris.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0041_unclosed_raw_byte_string_with_ferris.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0041_unclosed_raw_byte_string_with_ferris.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+br##\"\ud83e\udd80\n\\ No newline at end of file"}, {"sha": "c2503a4d05049147b9c73c6d979635f0e8b7b4f0", "filename": "crates/ra_syntax/test_data/lexer/err/0041_unclosed_raw_byte_string_with_ferris.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0041_unclosed_raw_byte_string_with_ferris.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0041_unclosed_raw_byte_string_with_ferris.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0041_unclosed_raw_byte_string_with_ferris.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+RAW_BYTE_STRING 9 \"br##\\\"\ud83e\udd80\"\n+> error[0; 9) token(\"br##\\\"\ud83e\udd80\") msg(Missing trailing `\"` with `#` symbols to terminate the raw byte string literal)"}, {"sha": "d50270afe1e1cd85d31c59dd38e72d0b70be8db2", "filename": "crates/ra_syntax/test_data/lexer/err/0042_unclosed_raw_byte_string_with_ascii_escape.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0042_unclosed_raw_byte_string_with_ascii_escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0042_unclosed_raw_byte_string_with_ascii_escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0042_unclosed_raw_byte_string_with_ascii_escape.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+br##\"\\x7f\n\\ No newline at end of file"}, {"sha": "3bd3d815296cf89e181463df5d27455f5a016ae2", "filename": "crates/ra_syntax/test_data/lexer/err/0042_unclosed_raw_byte_string_with_ascii_escape.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0042_unclosed_raw_byte_string_with_ascii_escape.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0042_unclosed_raw_byte_string_with_ascii_escape.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0042_unclosed_raw_byte_string_with_ascii_escape.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+RAW_BYTE_STRING 9 \"br##\\\"\\\\x7f\"\n+> error[0; 9) token(\"br##\\\"\\\\x7f\") msg(Missing trailing `\"` with `#` symbols to terminate the raw byte string literal)"}, {"sha": "90e299a1a977cab7edf3c3f4ccd891f258e38ef3", "filename": "crates/ra_syntax/test_data/lexer/err/0043_unclosed_raw_byte_string_with_unicode_escape.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0043_unclosed_raw_byte_string_with_unicode_escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0043_unclosed_raw_byte_string_with_unicode_escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0043_unclosed_raw_byte_string_with_unicode_escape.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+br##\"\\u{20AA}\n\\ No newline at end of file"}, {"sha": "a512f0428f5e5189900dab225d361a09ce834b7a", "filename": "crates/ra_syntax/test_data/lexer/err/0043_unclosed_raw_byte_string_with_unicode_escape.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0043_unclosed_raw_byte_string_with_unicode_escape.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0043_unclosed_raw_byte_string_with_unicode_escape.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0043_unclosed_raw_byte_string_with_unicode_escape.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+RAW_BYTE_STRING 13 \"br##\\\"\\\\u{20AA}\"\n+> error[0; 13) token(\"br##\\\"\\\\u{20AA}\") msg(Missing trailing `\"` with `#` symbols to terminate the raw byte string literal)"}, {"sha": "14c602fd2b35a949b27bd9c6484e08114d90b92f", "filename": "crates/ra_syntax/test_data/lexer/err/0044_unclosed_raw_byte_string_with_space.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0044_unclosed_raw_byte_string_with_space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0044_unclosed_raw_byte_string_with_space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0044_unclosed_raw_byte_string_with_space.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+br##\" \n\\ No newline at end of file"}, {"sha": "dc616a623b2b56e3bdbc9f34881a2fecd5538df5", "filename": "crates/ra_syntax/test_data/lexer/err/0044_unclosed_raw_byte_string_with_space.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0044_unclosed_raw_byte_string_with_space.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0044_unclosed_raw_byte_string_with_space.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0044_unclosed_raw_byte_string_with_space.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+RAW_BYTE_STRING 6 \"br##\\\" \"\n+> error[0; 6) token(\"br##\\\" \") msg(Missing trailing `\"` with `#` symbols to terminate the raw byte string literal)"}, {"sha": "0b3c015d74d48df9df99ea1d9398e47913f2641d", "filename": "crates/ra_syntax/test_data/lexer/err/0045_unclosed_raw_byte_string_with_slash.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0045_unclosed_raw_byte_string_with_slash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0045_unclosed_raw_byte_string_with_slash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0045_unclosed_raw_byte_string_with_slash.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+br##\"\\\n\\ No newline at end of file"}, {"sha": "debafe380e449eafd8c2eeb1a0d607a7d5c40230", "filename": "crates/ra_syntax/test_data/lexer/err/0045_unclosed_raw_byte_string_with_slash.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0045_unclosed_raw_byte_string_with_slash.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0045_unclosed_raw_byte_string_with_slash.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0045_unclosed_raw_byte_string_with_slash.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+RAW_BYTE_STRING 6 \"br##\\\"\\\\\"\n+> error[0; 6) token(\"br##\\\"\\\\\") msg(Missing trailing `\"` with `#` symbols to terminate the raw byte string literal)"}, {"sha": "0d8b0e7ab04f79b56c0ed51114ee02318de89347", "filename": "crates/ra_syntax/test_data/lexer/err/0046_unclosed_raw_byte_string_with_slash_n.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0046_unclosed_raw_byte_string_with_slash_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0046_unclosed_raw_byte_string_with_slash_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0046_unclosed_raw_byte_string_with_slash_n.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+br##\"\\n\n\\ No newline at end of file"}, {"sha": "524e617b77a7e3d626929c2bc0f9c2d16785ef9a", "filename": "crates/ra_syntax/test_data/lexer/err/0046_unclosed_raw_byte_string_with_slash_n.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0046_unclosed_raw_byte_string_with_slash_n.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0046_unclosed_raw_byte_string_with_slash_n.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0046_unclosed_raw_byte_string_with_slash_n.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+RAW_BYTE_STRING 7 \"br##\\\"\\\\n\"\n+> error[0; 7) token(\"br##\\\"\\\\n\") msg(Missing trailing `\"` with `#` symbols to terminate the raw byte string literal)"}, {"sha": "eddf8d0809445b52a740f0329a46753d5c0ab6c9", "filename": "crates/ra_syntax/test_data/lexer/err/0047_unstarted_raw_string_at_eof.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0047_unstarted_raw_string_at_eof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0047_unstarted_raw_string_at_eof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0047_unstarted_raw_string_at_eof.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+r##\n\\ No newline at end of file"}, {"sha": "00b0468405f42f3ac49553616cfb1f538272584e", "filename": "crates/ra_syntax/test_data/lexer/err/0047_unstarted_raw_string_at_eof.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0047_unstarted_raw_string_at_eof.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0047_unstarted_raw_string_at_eof.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0047_unstarted_raw_string_at_eof.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+RAW_STRING 3 \"r##\"\n+> error[0; 3) token(\"r##\") msg(Missing `\"` symbol after `#` symbols to begin the raw string literal)"}, {"sha": "7e8cadf4f4928e457deffc4c63fdd53b9e8f8cb2", "filename": "crates/ra_syntax/test_data/lexer/err/0048_unstarted_raw_byte_string_at_eof.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0048_unstarted_raw_byte_string_at_eof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0048_unstarted_raw_byte_string_at_eof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0048_unstarted_raw_byte_string_at_eof.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+br##\n\\ No newline at end of file"}, {"sha": "33b25e60f8bb8eeb042fa9a0a31ef807d761b664", "filename": "crates/ra_syntax/test_data/lexer/err/0048_unstarted_raw_byte_string_at_eof.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0048_unstarted_raw_byte_string_at_eof.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0048_unstarted_raw_byte_string_at_eof.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0048_unstarted_raw_byte_string_at_eof.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+RAW_BYTE_STRING 4 \"br##\"\n+> error[0; 4) token(\"br##\") msg(Missing `\"` symbol after `#` symbols to begin the raw byte string literal)"}, {"sha": "534668a9b6622683d1476bb839974af766ab3197", "filename": "crates/ra_syntax/test_data/lexer/err/0049_unstarted_raw_string_with_ascii.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0049_unstarted_raw_string_with_ascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0049_unstarted_raw_string_with_ascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0049_unstarted_raw_string_with_ascii.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+r## I lack a quote!\n\\ No newline at end of file"}, {"sha": "782dfd974f65661e7cc329613a27adf2b54bb7c0", "filename": "crates/ra_syntax/test_data/lexer/err/0049_unstarted_raw_string_with_ascii.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0049_unstarted_raw_string_with_ascii.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0049_unstarted_raw_string_with_ascii.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0049_unstarted_raw_string_with_ascii.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,10 @@\n+RAW_STRING 4 \"r## \"\n+IDENT 1 \"I\"\n+WHITESPACE 1 \" \"\n+IDENT 4 \"lack\"\n+WHITESPACE 1 \" \"\n+IDENT 1 \"a\"\n+WHITESPACE 1 \" \"\n+IDENT 5 \"quote\"\n+EXCL 1 \"!\"\n+> error[0; 4) token(\"r## \") msg(Missing `\"` symbol after `#` symbols to begin the raw string literal)"}, {"sha": "d9b55455ac40cde3f42a9962f3d5cb35fd6aa903", "filename": "crates/ra_syntax/test_data/lexer/err/0050_unstarted_raw_byte_string_with_ascii.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0050_unstarted_raw_byte_string_with_ascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0050_unstarted_raw_byte_string_with_ascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0050_unstarted_raw_byte_string_with_ascii.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+br## I lack a quote!\n\\ No newline at end of file"}, {"sha": "59c40cd65ac6c3da87fb0a99d05ac986ed47c798", "filename": "crates/ra_syntax/test_data/lexer/err/0050_unstarted_raw_byte_string_with_ascii.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0050_unstarted_raw_byte_string_with_ascii.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0050_unstarted_raw_byte_string_with_ascii.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0050_unstarted_raw_byte_string_with_ascii.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,10 @@\n+RAW_BYTE_STRING 5 \"br## \"\n+IDENT 1 \"I\"\n+WHITESPACE 1 \" \"\n+IDENT 4 \"lack\"\n+WHITESPACE 1 \" \"\n+IDENT 1 \"a\"\n+WHITESPACE 1 \" \"\n+IDENT 5 \"quote\"\n+EXCL 1 \"!\"\n+> error[0; 5) token(\"br## \") msg(Missing `\"` symbol after `#` symbols to begin the raw byte string literal)"}, {"sha": "22e83649f7d5219bb31ce45bd7e986e57ea4e72e", "filename": "crates/ra_syntax/test_data/lexer/err/0051_unclosed_block_comment_at_eof.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0051_unclosed_block_comment_at_eof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0051_unclosed_block_comment_at_eof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0051_unclosed_block_comment_at_eof.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+/*\n\\ No newline at end of file"}, {"sha": "5d04cdaa4b9ddc8eb5c9106f41851e8d939b3bbd", "filename": "crates/ra_syntax/test_data/lexer/err/0051_unclosed_block_comment_at_eof.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0051_unclosed_block_comment_at_eof.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0051_unclosed_block_comment_at_eof.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0051_unclosed_block_comment_at_eof.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+COMMENT 2 \"/*\"\n+> error[0; 2) token(\"/*\") msg(Missing trailing `*/` symbols to terminate the block comment)"}, {"sha": "c45c2844dbcc1ec5c032faa0b6f252c9a53c1a91", "filename": "crates/ra_syntax/test_data/lexer/err/0052_unclosed_block_comment_with_content.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0052_unclosed_block_comment_with_content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0052_unclosed_block_comment_with_content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0052_unclosed_block_comment_with_content.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+/* comment"}, {"sha": "8c6b678e32194c778d03d730407e2d0a94d7f690", "filename": "crates/ra_syntax/test_data/lexer/err/0052_unclosed_block_comment_with_content.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0052_unclosed_block_comment_with_content.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0052_unclosed_block_comment_with_content.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0052_unclosed_block_comment_with_content.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+COMMENT 11 \"/* comment\\n\"\n+> error[0; 11) token(\"/* comment\\n\") msg(Missing trailing `*/` symbols to terminate the block comment)"}, {"sha": "3fcfc96600a7f61bef4f93cea453de5f298dfcd7", "filename": "crates/ra_syntax/test_data/lexer/err/0053_unclosed_nested_block_comment_entirely.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0053_unclosed_nested_block_comment_entirely.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0053_unclosed_nested_block_comment_entirely.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0053_unclosed_nested_block_comment_entirely.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+/* /* /*"}, {"sha": "250de34d9f08c72e18e787e27554379b4a25d1a0", "filename": "crates/ra_syntax/test_data/lexer/err/0053_unclosed_nested_block_comment_entirely.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0053_unclosed_nested_block_comment_entirely.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0053_unclosed_nested_block_comment_entirely.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0053_unclosed_nested_block_comment_entirely.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+COMMENT 9 \"/* /* /*\\n\"\n+> error[0; 9) token(\"/* /* /*\\n\") msg(Missing trailing `*/` symbols to terminate the block comment)"}, {"sha": "26c898f019d6805a2445db2c3aa75b26d88fb736", "filename": "crates/ra_syntax/test_data/lexer/err/0054_unclosed_nested_block_comment_partially.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0054_unclosed_nested_block_comment_partially.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0054_unclosed_nested_block_comment_partially.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0054_unclosed_nested_block_comment_partially.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1 @@\n+/** /*! /* comment */ */"}, {"sha": "f97f2a8c76be7304e501217727e28e7859d52138", "filename": "crates/ra_syntax/test_data/lexer/err/0054_unclosed_nested_block_comment_partially.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0054_unclosed_nested_block_comment_partially.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0054_unclosed_nested_block_comment_partially.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0054_unclosed_nested_block_comment_partially.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+COMMENT 25 \"/** /*! /* comment */ */\\n\"\n+> error[0; 25) token(\"/** /*! /* comment */ */\\n\") msg(Missing trailing `*/` symbols to terminate the block comment)"}, {"sha": "aa2a9fdca17e0f9e15e89939d77e2e319db2e4e5", "filename": "crates/ra_syntax/test_data/lexer/err/0055_empty_int.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0055_empty_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0055_empty_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0055_empty_int.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,17 @@\n+0b\n+0o\n+0x\n+\n+0b_\n+0o_\n+0x_\n+\n+0bnoDigit\n+0onoDigit\n+0xnoDigit\n+\n+0xG\n+0xg\n+\n+0x_g\n+0x_G"}, {"sha": "2fe5bd950a562cbf03f260a8aa07189c0193bb47", "filename": "crates/ra_syntax/test_data/lexer/err/0055_empty_int.txt", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0055_empty_int.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0055_empty_int.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0055_empty_int.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,39 @@\n+INT_NUMBER 2 \"0b\"\n+WHITESPACE 1 \"\\n\"\n+INT_NUMBER 2 \"0o\"\n+WHITESPACE 1 \"\\n\"\n+INT_NUMBER 2 \"0x\"\n+WHITESPACE 2 \"\\n\\n\"\n+INT_NUMBER 3 \"0b_\"\n+WHITESPACE 1 \"\\n\"\n+INT_NUMBER 3 \"0o_\"\n+WHITESPACE 1 \"\\n\"\n+INT_NUMBER 3 \"0x_\"\n+WHITESPACE 2 \"\\n\\n\"\n+INT_NUMBER 9 \"0bnoDigit\"\n+WHITESPACE 1 \"\\n\"\n+INT_NUMBER 9 \"0onoDigit\"\n+WHITESPACE 1 \"\\n\"\n+INT_NUMBER 9 \"0xnoDigit\"\n+WHITESPACE 2 \"\\n\\n\"\n+INT_NUMBER 3 \"0xG\"\n+WHITESPACE 1 \"\\n\"\n+INT_NUMBER 3 \"0xg\"\n+WHITESPACE 2 \"\\n\\n\"\n+INT_NUMBER 4 \"0x_g\"\n+WHITESPACE 1 \"\\n\"\n+INT_NUMBER 4 \"0x_G\"\n+WHITESPACE 1 \"\\n\"\n+> error[0; 2) token(\"0b\") msg(Missing digits after the integer base prefix)\n+> error[3; 5) token(\"0o\") msg(Missing digits after the integer base prefix)\n+> error[6; 8) token(\"0x\") msg(Missing digits after the integer base prefix)\n+> error[10; 13) token(\"0b_\") msg(Missing digits after the integer base prefix)\n+> error[14; 17) token(\"0o_\") msg(Missing digits after the integer base prefix)\n+> error[18; 21) token(\"0x_\") msg(Missing digits after the integer base prefix)\n+> error[23; 32) token(\"0bnoDigit\") msg(Missing digits after the integer base prefix)\n+> error[33; 42) token(\"0onoDigit\") msg(Missing digits after the integer base prefix)\n+> error[43; 52) token(\"0xnoDigit\") msg(Missing digits after the integer base prefix)\n+> error[54; 57) token(\"0xG\") msg(Missing digits after the integer base prefix)\n+> error[58; 61) token(\"0xg\") msg(Missing digits after the integer base prefix)\n+> error[63; 67) token(\"0x_g\") msg(Missing digits after the integer base prefix)\n+> error[68; 72) token(\"0x_G\") msg(Missing digits after the integer base prefix)"}, {"sha": "286584c887f114c2fa3a18cad945b501e5fab846", "filename": "crates/ra_syntax/test_data/lexer/err/0056_empty_exponent.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0056_empty_exponent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0056_empty_exponent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0056_empty_exponent.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,22 @@\n+0e\n+0E\n+\n+42e+\n+42e-\n+42E+\n+42E-\n+\n+42.e+\n+42.e-\n+42.E+\n+42.E-\n+\n+42.2e+\n+42.2e-\n+42.2E+\n+42.2E-\n+\n+42.2e+f32\n+42.2e-f32\n+42.2E+f32\n+42.2E-f32"}, {"sha": "ab35e20a5cecda76637deaba0775c678fb0b3e93", "filename": "crates/ra_syntax/test_data/lexer/err/0056_empty_exponent.txt", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0056_empty_exponent.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0056_empty_exponent.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0056_empty_exponent.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,62 @@\n+FLOAT_NUMBER 2 \"0e\"\n+WHITESPACE 1 \"\\n\"\n+FLOAT_NUMBER 2 \"0E\"\n+WHITESPACE 2 \"\\n\\n\"\n+FLOAT_NUMBER 4 \"42e+\"\n+WHITESPACE 1 \"\\n\"\n+FLOAT_NUMBER 4 \"42e-\"\n+WHITESPACE 1 \"\\n\"\n+FLOAT_NUMBER 4 \"42E+\"\n+WHITESPACE 1 \"\\n\"\n+FLOAT_NUMBER 4 \"42E-\"\n+WHITESPACE 2 \"\\n\\n\"\n+INT_NUMBER 2 \"42\"\n+DOT 1 \".\"\n+IDENT 1 \"e\"\n+PLUS 1 \"+\"\n+WHITESPACE 1 \"\\n\"\n+INT_NUMBER 2 \"42\"\n+DOT 1 \".\"\n+IDENT 1 \"e\"\n+MINUS 1 \"-\"\n+WHITESPACE 1 \"\\n\"\n+INT_NUMBER 2 \"42\"\n+DOT 1 \".\"\n+IDENT 1 \"E\"\n+PLUS 1 \"+\"\n+WHITESPACE 1 \"\\n\"\n+INT_NUMBER 2 \"42\"\n+DOT 1 \".\"\n+IDENT 1 \"E\"\n+MINUS 1 \"-\"\n+WHITESPACE 2 \"\\n\\n\"\n+FLOAT_NUMBER 6 \"42.2e+\"\n+WHITESPACE 1 \"\\n\"\n+FLOAT_NUMBER 6 \"42.2e-\"\n+WHITESPACE 1 \"\\n\"\n+FLOAT_NUMBER 6 \"42.2E+\"\n+WHITESPACE 1 \"\\n\"\n+FLOAT_NUMBER 6 \"42.2E-\"\n+WHITESPACE 2 \"\\n\\n\"\n+FLOAT_NUMBER 9 \"42.2e+f32\"\n+WHITESPACE 1 \"\\n\"\n+FLOAT_NUMBER 9 \"42.2e-f32\"\n+WHITESPACE 1 \"\\n\"\n+FLOAT_NUMBER 9 \"42.2E+f32\"\n+WHITESPACE 1 \"\\n\"\n+FLOAT_NUMBER 9 \"42.2E-f32\"\n+WHITESPACE 1 \"\\n\"\n+> error[0; 2) token(\"0e\") msg(Missing digits after the exponent symbol)\n+> error[3; 5) token(\"0E\") msg(Missing digits after the exponent symbol)\n+> error[7; 11) token(\"42e+\") msg(Missing digits after the exponent symbol)\n+> error[12; 16) token(\"42e-\") msg(Missing digits after the exponent symbol)\n+> error[17; 21) token(\"42E+\") msg(Missing digits after the exponent symbol)\n+> error[22; 26) token(\"42E-\") msg(Missing digits after the exponent symbol)\n+> error[53; 59) token(\"42.2e+\") msg(Missing digits after the exponent symbol)\n+> error[60; 66) token(\"42.2e-\") msg(Missing digits after the exponent symbol)\n+> error[67; 73) token(\"42.2E+\") msg(Missing digits after the exponent symbol)\n+> error[74; 80) token(\"42.2E-\") msg(Missing digits after the exponent symbol)\n+> error[82; 91) token(\"42.2e+f32\") msg(Missing digits after the exponent symbol)\n+> error[92; 101) token(\"42.2e-f32\") msg(Missing digits after the exponent symbol)\n+> error[102; 111) token(\"42.2E+f32\") msg(Missing digits after the exponent symbol)\n+> error[112; 121) token(\"42.2E-f32\") msg(Missing digits after the exponent symbol)"}, {"sha": "a7698a404a87dc1ef9a86344e1dc2ea58ba0e30b", "filename": "crates/ra_syntax/test_data/lexer/err/0057_lifetime_strarts_with_a_number.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0057_lifetime_strarts_with_a_number.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0057_lifetime_strarts_with_a_number.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0057_lifetime_strarts_with_a_number.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,2 @@\n+'1\n+'1lifetime"}, {"sha": "89b38bfacfa5b8c36ccf8c9376c340f8cc7b6bd1", "filename": "crates/ra_syntax/test_data/lexer/err/0057_lifetime_strarts_with_a_number.txt", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0057_lifetime_strarts_with_a_number.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0057_lifetime_strarts_with_a_number.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Ferr%2F0057_lifetime_strarts_with_a_number.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -0,0 +1,6 @@\n+LIFETIME 2 \"\\'1\"\n+WHITESPACE 1 \"\\n\"\n+LIFETIME 10 \"\\'1lifetime\"\n+WHITESPACE 1 \"\\n\"\n+> error[0; 2) token(\"\\'1\") msg(Lifetime name cannot start with a number)\n+> error[3; 13) token(\"\\'1lifetime\") msg(Lifetime name cannot start with a number)"}, {"sha": "95d09f2b10159347eece71399a7e2e907ea3df4f", "filename": "crates/ra_syntax/test_data/lexer/ok/0001_hello.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0001_hello.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0001_hello.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0001_hello.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "previous_filename": "crates/ra_syntax/test_data/lexer/0001_hello.rs"}, {"sha": "27a5940a9c1ca360e1e87ce4fb3c507cba120f70", "filename": "crates/ra_syntax/test_data/lexer/ok/0001_hello.txt", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0001_hello.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0001_hello.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0001_hello.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "previous_filename": "crates/ra_syntax/test_data/lexer/0001_hello.txt"}, {"sha": "08fce1418a73608e5513f8173cc4a30749e8c1ea", "filename": "crates/ra_syntax/test_data/lexer/ok/0002_whitespace.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0002_whitespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0002_whitespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0002_whitespace.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "previous_filename": "crates/ra_syntax/test_data/lexer/0002_whitespace.rs"}, {"sha": "01d260918ee57db94ad80f55696e70f6765e32fd", "filename": "crates/ra_syntax/test_data/lexer/ok/0002_whitespace.txt", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0002_whitespace.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0002_whitespace.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0002_whitespace.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "previous_filename": "crates/ra_syntax/test_data/lexer/0002_whitespace.txt"}, {"sha": "c05c9c009d7e69382aae1bb987561c35f759686e", "filename": "crates/ra_syntax/test_data/lexer/ok/0003_ident.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0003_ident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0003_ident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0003_ident.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "previous_filename": "crates/ra_syntax/test_data/lexer/0003_ident.rs"}, {"sha": "4a0d5c0531205ef09d698894d4874629bc5b750f", "filename": "crates/ra_syntax/test_data/lexer/ok/0003_ident.txt", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0003_ident.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0003_ident.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0003_ident.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "previous_filename": "crates/ra_syntax/test_data/lexer/0003_ident.txt"}, {"sha": "bc761c235d8977fe87cfc258d6ed29ec592ed85d", "filename": "crates/ra_syntax/test_data/lexer/ok/0004_numbers.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0004_numbers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0004_numbers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0004_numbers.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,9 +1,9 @@\n-0 0b 0o 0x 00 0_ 0. 0e 0E 0z\n+0 00 0_ 0. 0z\n 01790 0b1790 0o1790 0x1790aAbBcCdDeEfF 001279 0_1279 0.1279 0e1279 0E1279\n 0..2\n 0.foo()\n 0e+1\n 0.e+1\n 0.0E-2\n 0___0.10000____0000e+111__\n-1i64 92.0f32 11__s\n\\ No newline at end of file\n+1i64 92.0f32 11__s", "previous_filename": "crates/ra_syntax/test_data/lexer/0004_numbers.rs"}, {"sha": "e19fc5789e355026cbf945ea0c88abc89fc4fb24", "filename": "crates/ra_syntax/test_data/lexer/ok/0004_numbers.txt", "status": "renamed", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0004_numbers.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0004_numbers.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0004_numbers.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "patch": "@@ -1,21 +1,11 @@\n INT_NUMBER 1 \"0\"\n WHITESPACE 1 \" \"\n-INT_NUMBER 2 \"0b\"\n-WHITESPACE 1 \" \"\n-INT_NUMBER 2 \"0o\"\n-WHITESPACE 1 \" \"\n-INT_NUMBER 2 \"0x\"\n-WHITESPACE 1 \" \"\n INT_NUMBER 2 \"00\"\n WHITESPACE 1 \" \"\n INT_NUMBER 2 \"0_\"\n WHITESPACE 1 \" \"\n FLOAT_NUMBER 2 \"0.\"\n WHITESPACE 1 \" \"\n-FLOAT_NUMBER 2 \"0e\"\n-WHITESPACE 1 \" \"\n-FLOAT_NUMBER 2 \"0E\"\n-WHITESPACE 1 \" \"\n INT_NUMBER 2 \"0z\"\n WHITESPACE 1 \"\\n\"\n INT_NUMBER 5 \"01790\"\n@@ -64,3 +54,4 @@ WHITESPACE 1 \" \"\n FLOAT_NUMBER 7 \"92.0f32\"\n WHITESPACE 1 \" \"\n INT_NUMBER 5 \"11__s\"\n+WHITESPACE 1 \"\\n\"", "previous_filename": "crates/ra_syntax/test_data/lexer/0004_numbers.txt"}, {"sha": "487569b5ae3c4d579595ac97668b788cb5bee418", "filename": "crates/ra_syntax/test_data/lexer/ok/0005_symbols.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0005_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0005_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0005_symbols.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "previous_filename": "crates/ra_syntax/test_data/lexer/0005_symbols.rs"}, {"sha": "469a90e4222eb527275a06fd527b35207a1b02a6", "filename": "crates/ra_syntax/test_data/lexer/ok/0005_symbols.txt", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0005_symbols.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0005_symbols.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0005_symbols.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "previous_filename": "crates/ra_syntax/test_data/lexer/0005_symbols.txt"}, {"sha": "454ee0a5f61721c71b9d60f8ce931571446cf978", "filename": "crates/ra_syntax/test_data/lexer/ok/0006_chars.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0006_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0006_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0006_chars.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "previous_filename": "crates/ra_syntax/test_data/lexer/0006_chars.rs"}, {"sha": "950954fbc88bdfa3c39ebc9bceaf7617f5e2c219", "filename": "crates/ra_syntax/test_data/lexer/ok/0006_chars.txt", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0006_chars.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0006_chars.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0006_chars.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "previous_filename": "crates/ra_syntax/test_data/lexer/0006_chars.txt"}, {"sha": "b764f1dce3c050a936622b9dfd401c9679cf79fb", "filename": "crates/ra_syntax/test_data/lexer/ok/0007_lifetimes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0007_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0007_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0007_lifetimes.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "previous_filename": "crates/ra_syntax/test_data/lexer/0007_lifetimes.rs"}, {"sha": "005c29100a060adb07be82b3f1ec7e4ec3a1a734", "filename": "crates/ra_syntax/test_data/lexer/ok/0007_lifetimes.txt", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0007_lifetimes.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0007_lifetimes.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0007_lifetimes.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "previous_filename": "crates/ra_syntax/test_data/lexer/0007_lifetimes.txt"}, {"sha": "b54930f5e699c24bbf5bc2e3a85c478ca8eea605", "filename": "crates/ra_syntax/test_data/lexer/ok/0008_byte_strings.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0008_byte_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0008_byte_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0008_byte_strings.rs?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "previous_filename": "crates/ra_syntax/test_data/lexer/0008_byte_strings.rs"}, {"sha": "bc03b51a8ab8e5df68ff2a0d8c5f8d10ab47acd5", "filename": "crates/ra_syntax/test_data/lexer/ok/0008_byte_strings.txt", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0008_byte_strings.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a957c473fdb79880c39b73dc9e0c923093cf16ac/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0008_byte_strings.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Flexer%2Fok%2F0008_byte_strings.txt?ref=a957c473fdb79880c39b73dc9e0c923093cf16ac", "previous_filename": "crates/ra_syntax/test_data/lexer/0008_byte_strings.txt"}]}