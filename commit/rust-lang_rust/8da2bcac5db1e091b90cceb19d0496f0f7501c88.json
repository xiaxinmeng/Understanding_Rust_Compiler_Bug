{"sha": "8da2bcac5db1e091b90cceb19d0496f0f7501c88", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkYTJiY2FjNWRiMWUwOTFiOTBjY2ViMTlkMDQ5NmYwZjc1MDFjODg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-28T21:37:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-28T21:37:30Z"}, "message": "Auto merge of #33171 - michaelwoerister:collector-drop-glue, r=nikomatsakis\n\nSome preliminary work towards making trans \"collector driven\".\n\nThe `trans::collector` already collects all translation items and `trans::partitioning` distributes these translation items into codegen units. The changes in this PR provide the following extensions to this functionality:\n\n1. Drop-glue is handled more accurately now, knowing about the difference between `DropGlueKind::Ty` and `DropGlueKind::TyContents`.\n2. The partitioning module now supports the `FixedUnitCount` strategy which more or less corresponds to the partitioning one gets via supplying `-Ccodegen-units` today.\n3. The partitioning scheme also takes care of assigned LLVM declarations to codegen units, not just definitions (declarations for external items not yet implemented).\n\nIt's debatable whether declarations should be handled by the partitioning scheme or whether they should just be emitted on demand.", "tree": {"sha": "3e7117b1cd94427c3f766a59f3885970b6fd32e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e7117b1cd94427c3f766a59f3885970b6fd32e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8da2bcac5db1e091b90cceb19d0496f0f7501c88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8da2bcac5db1e091b90cceb19d0496f0f7501c88", "html_url": "https://github.com/rust-lang/rust/commit/8da2bcac5db1e091b90cceb19d0496f0f7501c88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8da2bcac5db1e091b90cceb19d0496f0f7501c88/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "115c6c810caf8cedf04297804b1316e7b4e092d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/115c6c810caf8cedf04297804b1316e7b4e092d7", "html_url": "https://github.com/rust-lang/rust/commit/115c6c810caf8cedf04297804b1316e7b4e092d7"}, {"sha": "0fc9f9a20080753426772eac77d4d135ccd01ab7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fc9f9a20080753426772eac77d4d135ccd01ab7", "html_url": "https://github.com/rust-lang/rust/commit/0fc9f9a20080753426772eac77d4d135ccd01ab7"}], "stats": {"total": 469, "additions": 325, "deletions": 144}, "files": [{"sha": "cb648038c343643737ed3b7d327837edf4cb4dfe", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=8da2bcac5db1e091b90cceb19d0496f0f7501c88", "patch": "@@ -52,9 +52,8 @@ impl BitVector {\n \n     pub fn grow(&mut self, num_bits: usize) {\n         let num_words = u64s(num_bits);\n-        let extra_words = self.data.len() - num_words;\n-        if extra_words > 0 {\n-            self.data.extend((0..extra_words).map(|_| 0));\n+        if self.data.len() < num_words {\n+            self.data.resize(num_words, 0)\n         }\n     }\n \n@@ -284,15 +283,27 @@ fn union_two_vecs() {\n #[test]\n fn grow() {\n     let mut vec1 = BitVector::new(65);\n-    assert!(vec1.insert(3));\n-    assert!(!vec1.insert(3));\n-    assert!(vec1.insert(5));\n-    assert!(vec1.insert(64));\n+    for index in 0 .. 65 {\n+        assert!(vec1.insert(index));\n+        assert!(!vec1.insert(index));\n+    }\n     vec1.grow(128);\n-    assert!(vec1.contains(3));\n-    assert!(vec1.contains(5));\n-    assert!(vec1.contains(64));\n-    assert!(!vec1.contains(126));\n+\n+    // Check if the bits set before growing are still set\n+    for index in 0 .. 65 {\n+        assert!(vec1.contains(index));\n+    }\n+\n+    // Check if the new bits are all un-set\n+    for index in 65 .. 128 {\n+        assert!(!vec1.contains(index));\n+    }\n+\n+    // Check that we can set all new bits without running out of bounds\n+    for index in 65 .. 128 {\n+        assert!(vec1.insert(index));\n+        assert!(!vec1.insert(index));\n+    }\n }\n \n #[test]"}, {"sha": "526b6bf68be249e36b8e37dad1061ac4e38e54ed", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=8da2bcac5db1e091b90cceb19d0496f0f7501c88", "patch": "@@ -97,7 +97,7 @@ pub enum Visibility {\n // DLLExportLinkage, GhostLinkage and LinkOnceODRAutoHideLinkage.\n // LinkerPrivateLinkage and LinkerPrivateWeakLinkage are not included either;\n // they've been removed in upstream LLVM commit r203866.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Linkage {\n     ExternalLinkage = 0,\n     AvailableExternallyLinkage = 1,"}, {"sha": "b100282781ece2d3700b19c6c820673e0821f09b", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=8da2bcac5db1e091b90cceb19d0496f0f7501c88", "patch": "@@ -58,7 +58,6 @@ use attributes;\n use build::*;\n use builder::{Builder, noname};\n use callee::{Callee, CallArgs, ArgExprs, ArgVals};\n-use partitioning;\n use cleanup::{self, CleanupMethods, DropHint};\n use closure;\n use common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_uint, C_integral};\n@@ -83,6 +82,7 @@ use machine::{llalign_of_min, llsize_of, llsize_of_real};\n use meth;\n use mir;\n use monomorphize::{self, Instance};\n+use partitioning::{self, PartitioningStrategy, InstantiationMode};\n use symbol_names_test;\n use tvec;\n use type_::Type;\n@@ -2934,12 +2934,21 @@ fn collect_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n         None => TransItemCollectionMode::Lazy\n     };\n \n-    let (items, inlining_map) = time(time_passes, \"translation item collection\", || {\n+    let (items, reference_map) = time(time_passes, \"translation item collection\", || {\n         collector::collect_crate_translation_items(&ccx, collection_mode)\n     });\n \n+    let strategy = if ccx.sess().opts.debugging_opts.incremental.is_some() {\n+        PartitioningStrategy::PerModule\n+    } else {\n+        PartitioningStrategy::FixedUnitCount(ccx.sess().opts.cg.codegen_units)\n+    };\n+\n     let codegen_units = time(time_passes, \"codegen unit partitioning\", || {\n-        partitioning::partition(ccx.tcx(), items.iter().cloned(), &inlining_map)\n+        partitioning::partition(ccx.tcx(),\n+                                items.iter().cloned(),\n+                                strategy,\n+                                &reference_map)\n     });\n \n     if ccx.sess().opts.debugging_opts.print_trans_items.is_some() {\n@@ -2967,17 +2976,18 @@ fn collect_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n                     output.push_str(&cgu_name[..]);\n \n                     let linkage_abbrev = match linkage {\n-                        llvm::ExternalLinkage => \"External\",\n-                        llvm::AvailableExternallyLinkage => \"Available\",\n-                        llvm::LinkOnceAnyLinkage => \"OnceAny\",\n-                        llvm::LinkOnceODRLinkage => \"OnceODR\",\n-                        llvm::WeakAnyLinkage => \"WeakAny\",\n-                        llvm::WeakODRLinkage => \"WeakODR\",\n-                        llvm::AppendingLinkage => \"Appending\",\n-                        llvm::InternalLinkage => \"Internal\",\n-                        llvm::PrivateLinkage => \"Private\",\n-                        llvm::ExternalWeakLinkage => \"ExternalWeak\",\n-                        llvm::CommonLinkage => \"Common\",\n+                        InstantiationMode::Def(llvm::ExternalLinkage) => \"External\",\n+                        InstantiationMode::Def(llvm::AvailableExternallyLinkage) => \"Available\",\n+                        InstantiationMode::Def(llvm::LinkOnceAnyLinkage) => \"OnceAny\",\n+                        InstantiationMode::Def(llvm::LinkOnceODRLinkage) => \"OnceODR\",\n+                        InstantiationMode::Def(llvm::WeakAnyLinkage) => \"WeakAny\",\n+                        InstantiationMode::Def(llvm::WeakODRLinkage) => \"WeakODR\",\n+                        InstantiationMode::Def(llvm::AppendingLinkage) => \"Appending\",\n+                        InstantiationMode::Def(llvm::InternalLinkage) => \"Internal\",\n+                        InstantiationMode::Def(llvm::PrivateLinkage) => \"Private\",\n+                        InstantiationMode::Def(llvm::ExternalWeakLinkage) => \"ExternalWeak\",\n+                        InstantiationMode::Def(llvm::CommonLinkage) => \"Common\",\n+                        InstantiationMode::Decl => \"Declaration\",\n                     };\n \n                     output.push_str(\"[\");"}, {"sha": "e8181579911d2c085e6b28d28e63a4912229d2dd", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 118, "deletions": 35, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=8da2bcac5db1e091b90cceb19d0496f0f7501c88", "patch": "@@ -188,6 +188,8 @@\n //! this is not implemented however: a translation item will be produced\n //! regardless of whether it is actually needed or not.\n \n+use rustc_data_structures::bitvec::BitVector;\n+\n use rustc::hir;\n use rustc::hir::intravisit as hir_visit;\n \n@@ -211,7 +213,7 @@ use base::{custom_coerce_unsize_info, llvm_linkage_by_name};\n use context::CrateContext;\n use common::{fulfill_obligation, normalize_and_test_predicates,\n                     type_is_sized};\n-use glue;\n+use glue::{self, DropGlueKind};\n use llvm;\n use meth;\n use monomorphize::{self, Instance};\n@@ -227,7 +229,7 @@ pub enum TransItemCollectionMode {\n \n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n pub enum TransItem<'tcx> {\n-    DropGlue(Ty<'tcx>),\n+    DropGlue(DropGlueKind<'tcx>),\n     Fn(Instance<'tcx>),\n     Static(NodeId)\n }\n@@ -252,12 +254,76 @@ impl<'tcx> Hash for TransItem<'tcx> {\n     }\n }\n \n-pub type InliningMap<'tcx> = FnvHashMap<TransItem<'tcx>, FnvHashSet<TransItem<'tcx>>>;\n+/// Maps every translation item to all translation items it references in its\n+/// body.\n+pub struct ReferenceMap<'tcx> {\n+    // Maps a source translation item to a range of target translation items.\n+    // The two numbers in the tuple are the start (inclusive) and\n+    // end index (exclusive) within the `targets` and the `inlined` vecs.\n+    index: FnvHashMap<TransItem<'tcx>, (usize, usize)>,\n+    targets: Vec<TransItem<'tcx>>,\n+    inlined: BitVector\n+}\n+\n+impl<'tcx> ReferenceMap<'tcx> {\n+\n+    fn new() -> ReferenceMap<'tcx> {\n+        ReferenceMap {\n+            index: FnvHashMap(),\n+            targets: Vec::new(),\n+            inlined: BitVector::new(64 * 256),\n+        }\n+    }\n+\n+    fn record_references<I>(&mut self, source: TransItem<'tcx>, targets: I)\n+        where I: Iterator<Item=(TransItem<'tcx>, bool)>\n+    {\n+        assert!(!self.index.contains_key(&source));\n+\n+        let start_index = self.targets.len();\n+\n+        for (target, inlined) in targets {\n+            let index = self.targets.len();\n+            self.targets.push(target);\n+            self.inlined.grow(index + 1);\n+\n+            if inlined {\n+                self.inlined.insert(index);\n+            }\n+        }\n+\n+        let end_index = self.targets.len();\n+        self.index.insert(source, (start_index, end_index));\n+    }\n+\n+    // Internally iterate over all items referenced by `source` which will be\n+    // made available for inlining.\n+    pub fn with_inlining_candidates<F>(&self, source: TransItem<'tcx>, mut f: F)\n+        where F: FnMut(TransItem<'tcx>) {\n+        if let Some(&(start_index, end_index)) = self.index.get(&source)\n+        {\n+            for index in start_index .. end_index {\n+                if self.inlined.contains(index) {\n+                    f(self.targets[index])\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn get_direct_references_from(&self, source: TransItem<'tcx>) -> &[TransItem<'tcx>]\n+    {\n+        if let Some(&(start_index, end_index)) = self.index.get(&source) {\n+            &self.targets[start_index .. end_index]\n+        } else {\n+            &self.targets[0 .. 0]\n+        }\n+    }\n+}\n \n pub fn collect_crate_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                  mode: TransItemCollectionMode)\n                                                  -> (FnvHashSet<TransItem<'tcx>>,\n-                                                     InliningMap<'tcx>) {\n+                                                     ReferenceMap<'tcx>) {\n     // We are not tracking dependencies of this pass as it has to be re-executed\n     // every time no matter what.\n     ccx.tcx().dep_graph.with_ignore(|| {\n@@ -266,17 +332,17 @@ pub fn collect_crate_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         debug!(\"Building translation item graph, beginning at roots\");\n         let mut visited = FnvHashSet();\n         let mut recursion_depths = DefIdMap();\n-        let mut inlining_map = FnvHashMap();\n+        let mut reference_map = ReferenceMap::new();\n \n         for root in roots {\n             collect_items_rec(ccx,\n                               root,\n                               &mut visited,\n                               &mut recursion_depths,\n-                              &mut inlining_map);\n+                              &mut reference_map);\n         }\n \n-        (visited, inlining_map)\n+        (visited, reference_map)\n     })\n }\n \n@@ -307,7 +373,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n                                    starting_point: TransItem<'tcx>,\n                                    visited: &mut FnvHashSet<TransItem<'tcx>>,\n                                    recursion_depths: &mut DefIdMap<usize>,\n-                                   inlining_map: &mut InliningMap<'tcx>) {\n+                                   reference_map: &mut ReferenceMap<'tcx>) {\n     if !visited.insert(starting_point.clone()) {\n         // We've been here already, no need to search again.\n         return;\n@@ -326,7 +392,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n             let def_id = ccx.tcx().map.local_def_id(node_id);\n             let ty = ccx.tcx().lookup_item_type(def_id).ty;\n             let ty = glue::get_drop_glue_type(ccx, ty);\n-            neighbors.push(TransItem::DropGlue(ty));\n+            neighbors.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n             recursion_depth_reset = None;\n         }\n         TransItem::Fn(instance) => {\n@@ -351,9 +417,10 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n+    record_references(ccx, starting_point, &neighbors[..], reference_map);\n+\n     for neighbour in neighbors {\n-        record_inlined_use(ccx, starting_point, neighbour, inlining_map);\n-        collect_items_rec(ccx, neighbour, visited, recursion_depths, inlining_map);\n+        collect_items_rec(ccx, neighbour, visited, recursion_depths, reference_map);\n     }\n \n     if let Some((def_id, depth)) = recursion_depth_reset {\n@@ -363,16 +430,17 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"END collect_items_rec({})\", starting_point.to_string(ccx));\n }\n \n-fn record_inlined_use<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                caller: TransItem<'tcx>,\n-                                callee: TransItem<'tcx>,\n-                                inlining_map: &mut InliningMap<'tcx>) {\n-    if callee.is_from_extern_crate() ||\n-       callee.requests_inline(ccx.tcx()) {\n-        inlining_map.entry(caller)\n-                    .or_insert_with(|| FnvHashSet())\n-                    .insert(callee);\n-    }\n+fn record_references<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                               caller: TransItem<'tcx>,\n+                               callees: &[TransItem<'tcx>],\n+                               reference_map: &mut ReferenceMap<'tcx>) {\n+    let iter = callees.into_iter()\n+                      .map(|callee| {\n+                        let is_inlining_candidate = callee.is_from_extern_crate() ||\n+                                                    callee.requests_inline(ccx.tcx());\n+                        (*callee, is_inlining_candidate)\n+                      });\n+    reference_map.record_references(caller, iter);\n }\n \n fn check_recursion_limit<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n@@ -485,7 +553,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                                                       &ty);\n             let ty = self.ccx.tcx().erase_regions(&ty);\n             let ty = glue::get_drop_glue_type(self.ccx, ty);\n-            self.output.push(TransItem::DropGlue(ty));\n+            self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n         }\n \n         self.super_lvalue(lvalue, context);\n@@ -575,9 +643,17 @@ fn can_have_local_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                      ty: ty::Ty<'tcx>,\n-                                      output: &mut Vec<TransItem<'tcx>>)\n-{\n+                                      dg: DropGlueKind<'tcx>,\n+                                      output: &mut Vec<TransItem<'tcx>>) {\n+    let ty = match dg {\n+        DropGlueKind::Ty(ty) => ty,\n+        DropGlueKind::TyContents(_) => {\n+            // We already collected the neighbors of this item via the\n+            // DropGlueKind::Ty variant.\n+            return\n+        }\n+    };\n+\n     debug!(\"find_drop_glue_neighbors: {}\", type_to_string(ccx, ty));\n \n     // Make sure the exchange_free_fn() lang-item gets translated if\n@@ -634,6 +710,10 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                   &Substs::empty());\n             output.push(trans_item);\n         }\n+\n+        // This type has a Drop implementation, we'll need the contents-only\n+        // version of the glue too.\n+        output.push(TransItem::DropGlue(DropGlueKind::TyContents(ty)));\n     }\n \n     // Finally add the types of nested values\n@@ -661,30 +741,30 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 let field_type = glue::get_drop_glue_type(ccx, field_type);\n \n                 if glue::type_needs_drop(ccx.tcx(), field_type) {\n-                    output.push(TransItem::DropGlue(field_type));\n+                    output.push(TransItem::DropGlue(DropGlueKind::Ty(field_type)));\n                 }\n             }\n         }\n         ty::TyClosure(_, ref substs) => {\n             for upvar_ty in &substs.upvar_tys {\n                 let upvar_ty = glue::get_drop_glue_type(ccx, upvar_ty);\n                 if glue::type_needs_drop(ccx.tcx(), upvar_ty) {\n-                    output.push(TransItem::DropGlue(upvar_ty));\n+                    output.push(TransItem::DropGlue(DropGlueKind::Ty(upvar_ty)));\n                 }\n             }\n         }\n         ty::TyBox(inner_type)      |\n         ty::TyArray(inner_type, _) => {\n             let inner_type = glue::get_drop_glue_type(ccx, inner_type);\n             if glue::type_needs_drop(ccx.tcx(), inner_type) {\n-                output.push(TransItem::DropGlue(inner_type));\n+                output.push(TransItem::DropGlue(DropGlueKind::Ty(inner_type)));\n             }\n         }\n         ty::TyTuple(ref args) => {\n             for arg in args {\n                 let arg = glue::get_drop_glue_type(ccx, arg);\n                 if glue::type_needs_drop(ccx.tcx(), arg) {\n-                    output.push(TransItem::DropGlue(arg));\n+                    output.push(TransItem::DropGlue(DropGlueKind::Ty(arg)));\n                 }\n             }\n         }\n@@ -1000,7 +1080,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                                                 self.ccx.tcx().map.local_def_id(item.id)));\n \n                         let ty = glue::get_drop_glue_type(self.ccx, ty);\n-                        self.output.push(TransItem::DropGlue(ty));\n+                        self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n                     }\n                 }\n             }\n@@ -1413,10 +1493,13 @@ impl<'tcx> TransItem<'tcx> {\n         let hir_map = &ccx.tcx().map;\n \n         return match *self {\n-            TransItem::DropGlue(t) => {\n+            TransItem::DropGlue(dg) => {\n                 let mut s = String::with_capacity(32);\n-                s.push_str(\"drop-glue \");\n-                push_unique_type_name(ccx, t, &mut s);\n+                match dg {\n+                    DropGlueKind::Ty(_) => s.push_str(\"drop-glue \"),\n+                    DropGlueKind::TyContents(_) => s.push_str(\"drop-glue-contents \"),\n+                };\n+                push_unique_type_name(ccx, dg.ty(), &mut s);\n                 s\n             }\n             TransItem::Fn(instance) => {\n@@ -1442,8 +1525,8 @@ impl<'tcx> TransItem<'tcx> {\n \n     fn to_raw_string(&self) -> String {\n         match *self {\n-            TransItem::DropGlue(t) => {\n-                format!(\"DropGlue({})\", t as *const _ as usize)\n+            TransItem::DropGlue(dg) => {\n+                format!(\"DropGlue({})\", dg.ty() as *const _ as usize)\n             }\n             TransItem::Fn(instance) => {\n                 format!(\"Fn({:?}, {})\","}, {"sha": "06761a7016add15a5dbd03da7d12a13c456a8e53", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=8da2bcac5db1e091b90cceb19d0496f0f7501c88", "patch": "@@ -98,7 +98,7 @@ pub fn get_drop_glue_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Even if there is no dtor for t, there might be one deeper down and we\n     // might need to pass in the vtable ptr.\n     if !type_is_sized(tcx, t) {\n-        return t\n+        return ccx.tcx().erase_regions(&t);\n     }\n \n     // FIXME (#22815): note that type_needs_drop conservatively\n@@ -121,10 +121,10 @@ pub fn get_drop_glue_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             if llsize_of_alloc(ccx, llty) == 0 {\n                 tcx.types.i8\n             } else {\n-                t\n+                ccx.tcx().erase_regions(&t)\n             }\n         }\n-        _ => t\n+        _ => ccx.tcx().erase_regions(&t)\n     }\n }\n \n@@ -215,11 +215,11 @@ pub enum DropGlueKind<'tcx> {\n }\n \n impl<'tcx> DropGlueKind<'tcx> {\n-    fn ty(&self) -> Ty<'tcx> {\n+    pub fn ty(&self) -> Ty<'tcx> {\n         match *self { DropGlueKind::Ty(t) | DropGlueKind::TyContents(t) => t }\n     }\n \n-    fn map_ty<F>(&self, mut f: F) -> DropGlueKind<'tcx> where F: FnMut(Ty<'tcx>) -> Ty<'tcx>\n+    pub fn map_ty<F>(&self, mut f: F) -> DropGlueKind<'tcx> where F: FnMut(Ty<'tcx>) -> Ty<'tcx>\n     {\n         match *self {\n             DropGlueKind::Ty(t) => DropGlueKind::Ty(f(t)),\n@@ -487,14 +487,13 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n \n fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueKind<'tcx>)\n                               -> Block<'blk, 'tcx> {\n-    let t = g.ty();\n-\n     if collector::collecting_debug_information(bcx.ccx()) {\n         bcx.ccx()\n-           .record_translation_item_as_generated(TransItem::DropGlue(bcx.tcx()\n-                                                                        .erase_regions(&t)));\n+           .record_translation_item_as_generated(TransItem::DropGlue(g));\n     }\n \n+    let t = g.ty();\n+\n     let skip_dtor = match g { DropGlueKind::Ty(_) => false, DropGlueKind::TyContents(_) => true };\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");"}, {"sha": "250292ee684de52e465acd61782a2f35da2f2c9f", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 117, "deletions": 48, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=8da2bcac5db1e091b90cceb19d0496f0f7501c88", "patch": "@@ -116,8 +116,7 @@\n //! source-level module, functions from the same module will be available for\n //! inlining, even when they are not marked #[inline].\n \n-use collector::{InliningMap, TransItem};\n-use context::CrateContext;\n+use collector::{TransItem, ReferenceMap};\n use monomorphize;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n@@ -127,40 +126,76 @@ use llvm;\n use syntax::parse::token::{self, InternedString};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n+#[derive(Clone, Copy, Eq, PartialEq, Debug)]\n+pub enum InstantiationMode {\n+    /// This variant indicates that a translation item should be placed in some\n+    /// codegen unit as a definition and with the given linkage.\n+    Def(llvm::Linkage),\n+\n+    /// This variant indicates that only a declaration of some translation item\n+    /// should be placed in a given codegen unit.\n+    Decl\n+}\n+\n pub struct CodegenUnit<'tcx> {\n     pub name: InternedString,\n-    pub items: FnvHashMap<TransItem<'tcx>, llvm::Linkage>,\n+    pub items: FnvHashMap<TransItem<'tcx>, InstantiationMode>,\n+}\n+\n+pub enum PartitioningStrategy {\n+    /// Generate one codegen unit per source-level module.\n+    PerModule,\n+\n+    /// Partition the whole crate into a fixed number of codegen units.\n+    FixedUnitCount(usize)\n }\n \n // Anything we can't find a proper codegen unit for goes into this.\n const FALLBACK_CODEGEN_UNIT: &'static str = \"__rustc_fallback_codegen_unit\";\n \n pub fn partition<'tcx, I>(tcx: &TyCtxt<'tcx>,\n                           trans_items: I,\n-                          inlining_map: &InliningMap<'tcx>)\n+                          strategy: PartitioningStrategy,\n+                          reference_map: &ReferenceMap<'tcx>)\n                           -> Vec<CodegenUnit<'tcx>>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n     // In the first step, we place all regular translation items into their\n     // respective 'home' codegen unit. Regular translation items are all\n     // functions and statics defined in the local crate.\n-    let initial_partitioning = place_root_translation_items(tcx, trans_items);\n+    let mut initial_partitioning = place_root_translation_items(tcx, trans_items);\n+\n+    // If the partitioning should produce a fixed count of codegen units, merge\n+    // until that count is reached.\n+    if let PartitioningStrategy::FixedUnitCount(count) = strategy {\n+        merge_codegen_units(&mut initial_partitioning, count, &tcx.crate_name[..]);\n+    }\n \n     // In the next step, we use the inlining map to determine which addtional\n     // translation items have to go into each codegen unit. These additional\n     // translation items can be drop-glue, functions from external crates, and\n     // local functions the definition of which is marked with #[inline].\n-    place_inlined_translation_items(initial_partitioning, inlining_map)\n+    let post_inlining = place_inlined_translation_items(initial_partitioning,\n+                                                        reference_map);\n+\n+    // Now we know all *definitions* within all codegen units, thus we can\n+    // easily determine which declarations need to be placed within each one.\n+    let post_declarations = place_declarations(post_inlining, reference_map);\n+\n+    post_declarations.0\n }\n \n-struct InitialPartitioning<'tcx> {\n+struct PreInliningPartitioning<'tcx> {\n     codegen_units: Vec<CodegenUnit<'tcx>>,\n     roots: FnvHashSet<TransItem<'tcx>>,\n }\n \n+struct PostInliningPartitioning<'tcx>(Vec<CodegenUnit<'tcx>>);\n+struct PostDeclarationsPartitioning<'tcx>(Vec<CodegenUnit<'tcx>>);\n+\n fn place_root_translation_items<'tcx, I>(tcx: &TyCtxt<'tcx>,\n                                          trans_items: I)\n-                                         -> InitialPartitioning<'tcx>\n+                                         -> PreInliningPartitioning<'tcx>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n     let mut roots = FnvHashSet();\n@@ -204,74 +239,129 @@ fn place_root_translation_items<'tcx, I>(tcx: &TyCtxt<'tcx>,\n                 }\n             };\n \n-            codegen_unit.items.insert(trans_item, linkage);\n+            codegen_unit.items.insert(trans_item,\n+                                      InstantiationMode::Def(linkage));\n             roots.insert(trans_item);\n         }\n     }\n \n-    InitialPartitioning {\n+    PreInliningPartitioning {\n         codegen_units: codegen_units.into_iter()\n                                     .map(|(_, codegen_unit)| codegen_unit)\n                                     .collect(),\n         roots: roots,\n     }\n }\n \n-fn place_inlined_translation_items<'tcx>(initial_partitioning: InitialPartitioning<'tcx>,\n-                                         inlining_map: &InliningMap<'tcx>)\n-                                         -> Vec<CodegenUnit<'tcx>> {\n-    let mut final_partitioning = Vec::new();\n+fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n+                             target_cgu_count: usize,\n+                             crate_name: &str) {\n+    if target_cgu_count >= initial_partitioning.codegen_units.len() {\n+        return;\n+    }\n+\n+    assert!(target_cgu_count >= 1);\n+    let codegen_units = &mut initial_partitioning.codegen_units;\n+\n+    // Merge the two smallest codegen units until the target size is reached.\n+    // Note that \"size\" is estimated here rather inaccurately as the number of\n+    // translation items in a given unit. This could be improved on.\n+    while codegen_units.len() > target_cgu_count {\n+        // Sort small cgus to the back\n+        codegen_units.as_mut_slice().sort_by_key(|cgu| -(cgu.items.len() as i64));\n+        let smallest = codegen_units.pop().unwrap();\n+        let second_smallest = codegen_units.last_mut().unwrap();\n+\n+        for (k, v) in smallest.items.into_iter() {\n+            second_smallest.items.insert(k, v);\n+        }\n+    }\n+\n+    for (index, cgu) in codegen_units.iter_mut().enumerate() {\n+        cgu.name = token::intern_and_get_ident(&format!(\"{}.{}\", crate_name, index)[..]);\n+    }\n+}\n+\n+fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartitioning<'tcx>,\n+                                         reference_map: &ReferenceMap<'tcx>)\n+                                         -> PostInliningPartitioning<'tcx> {\n+    let mut new_partitioning = Vec::new();\n \n     for codegen_unit in &initial_partitioning.codegen_units[..] {\n         // Collect all items that need to be available in this codegen unit\n         let mut reachable = FnvHashSet();\n         for root in codegen_unit.items.keys() {\n-            follow_inlining(*root, inlining_map, &mut reachable);\n+            follow_inlining(*root, reference_map, &mut reachable);\n         }\n \n-        let mut final_codegen_unit = CodegenUnit {\n+        let mut new_codegen_unit = CodegenUnit {\n             name: codegen_unit.name.clone(),\n             items: FnvHashMap(),\n         };\n \n         // Add all translation items that are not already there\n         for trans_item in reachable {\n-            if let Some(linkage) = codegen_unit.items.get(&trans_item) {\n+            if let Some(instantiation_mode) = codegen_unit.items.get(&trans_item) {\n                 // This is a root, just copy it over\n-                final_codegen_unit.items.insert(trans_item, *linkage);\n+                new_codegen_unit.items.insert(trans_item, *instantiation_mode);\n             } else {\n                 if initial_partitioning.roots.contains(&trans_item) {\n                     // This item will be instantiated in some other codegen unit,\n                     // so we just add it here with AvailableExternallyLinkage\n-                    final_codegen_unit.items.insert(trans_item, llvm::AvailableExternallyLinkage);\n+                    new_codegen_unit.items.insert(trans_item,\n+                        InstantiationMode::Def(llvm::AvailableExternallyLinkage));\n                 } else {\n                     // We can't be sure if this will also be instantiated\n                     // somewhere else, so we add an instance here with\n                     // LinkOnceODRLinkage. That way the item can be discarded if\n                     // it's not needed (inlined) after all.\n-                    final_codegen_unit.items.insert(trans_item, llvm::LinkOnceODRLinkage);\n+                    new_codegen_unit.items.insert(trans_item,\n+                        InstantiationMode::Def(llvm::LinkOnceODRLinkage));\n                 }\n             }\n         }\n \n-        final_partitioning.push(final_codegen_unit);\n+        new_partitioning.push(new_codegen_unit);\n     }\n \n-    return final_partitioning;\n+    return PostInliningPartitioning(new_partitioning);\n \n     fn follow_inlining<'tcx>(trans_item: TransItem<'tcx>,\n-                             inlining_map: &InliningMap<'tcx>,\n+                             reference_map: &ReferenceMap<'tcx>,\n                              visited: &mut FnvHashSet<TransItem<'tcx>>) {\n         if !visited.insert(trans_item) {\n             return;\n         }\n \n-        if let Some(inlined_items) = inlining_map.get(&trans_item) {\n-            for &inlined_item in inlined_items {\n-                follow_inlining(inlined_item, inlining_map, visited);\n+        reference_map.with_inlining_candidates(trans_item, |target| {\n+            follow_inlining(target, reference_map, visited);\n+        });\n+    }\n+}\n+\n+fn place_declarations<'tcx>(codegen_units: PostInliningPartitioning<'tcx>,\n+                            reference_map: &ReferenceMap<'tcx>)\n+                            -> PostDeclarationsPartitioning<'tcx> {\n+    let PostInliningPartitioning(mut codegen_units) = codegen_units;\n+\n+    for codegen_unit in codegen_units.iter_mut() {\n+        let mut declarations = FnvHashSet();\n+\n+        for (trans_item, _) in &codegen_unit.items {\n+            for referenced_item in reference_map.get_direct_references_from(*trans_item) {\n+                if !codegen_unit.items.contains_key(referenced_item) {\n+                    declarations.insert(*referenced_item);\n+                }\n             }\n         }\n+\n+        codegen_unit.items\n+                    .extend(declarations.iter()\n+                                        .map(|trans_item| (*trans_item,\n+                                                           InstantiationMode::Decl)));\n     }\n+\n+    PostDeclarationsPartitioning(codegen_units)\n }\n \n fn characteristic_def_id_of_trans_item<'tcx>(tcx: &TyCtxt<'tcx>,\n@@ -304,7 +394,7 @@ fn characteristic_def_id_of_trans_item<'tcx>(tcx: &TyCtxt<'tcx>,\n \n             Some(instance.def)\n         }\n-        TransItem::DropGlue(t) => characteristic_def_id_of_type(t),\n+        TransItem::DropGlue(dg) => characteristic_def_id_of_type(dg.ty()),\n         TransItem::Static(node_id) => Some(tcx.map.local_def_id(node_id)),\n     }\n }\n@@ -340,24 +430,3 @@ fn compute_codegen_unit_name<'tcx>(tcx: &TyCtxt<'tcx>,\n \n     return token::intern_and_get_ident(&mod_path[..]);\n }\n-\n-impl<'tcx> CodegenUnit<'tcx> {\n-    pub fn _dump<'a>(&self, ccx: &CrateContext<'a, 'tcx>) {\n-        println!(\"CodegenUnit {} (\", self.name);\n-\n-        let mut items: Vec<_> = self.items\n-                                    .iter()\n-                                    .map(|(trans_item, inst)| {\n-                                        format!(\"{} -- ({:?})\", trans_item.to_string(ccx), inst)\n-                                    })\n-                                    .collect();\n-\n-        items.as_mut_slice().sort();\n-\n-        for s in items {\n-            println!(\"  {}\", s);\n-        }\n-\n-        println!(\")\");\n-    }\n-}"}, {"sha": "6da8154540574f9cc73616d7fa7520bc26a5f2f6", "filename": "src/test/codegen-units/item-collection/generic-drop-glue.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-drop-glue.rs?ref=8da2bcac5db1e091b90cceb19d0496f0f7501c88", "patch": "@@ -46,19 +46,22 @@ struct NonGenericNoDrop(i32);\n \n struct NonGenericWithDrop(i32);\n //~ TRANS_ITEM drop-glue generic_drop_glue::NonGenericWithDrop[0]\n+//~ TRANS_ITEM drop-glue-contents generic_drop_glue::NonGenericWithDrop[0]\n \n impl Drop for NonGenericWithDrop {\n+    //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[2]::drop[0]\n     fn drop(&mut self) {}\n-//~ TRANS_ITEM fn generic_drop_glue::{{impl}}[2]::drop[0]\n }\n \n //~ TRANS_ITEM fn generic_drop_glue::main[0]\n fn main() {\n     //~ TRANS_ITEM drop-glue generic_drop_glue::StructWithDrop[0]<i8, char>\n+    //~ TRANS_ITEM drop-glue-contents generic_drop_glue::StructWithDrop[0]<i8, char>\n     //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[0]::drop[0]<i8, char>\n     let _ = StructWithDrop { x: 0i8, y: 'a' }.x;\n \n     //~ TRANS_ITEM drop-glue generic_drop_glue::StructWithDrop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>\n+    //~ TRANS_ITEM drop-glue-contents generic_drop_glue::StructWithDrop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>\n     //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[0]::drop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>\n     let _ = StructWithDrop { x: \"&str\", y: NonGenericNoDrop(0) }.y;\n \n@@ -71,13 +74,15 @@ fn main() {\n     let _ = StructNoDrop { x: NonGenericWithDrop(0), y: 0f64 }.y;\n \n     //~ TRANS_ITEM drop-glue generic_drop_glue::EnumWithDrop[0]<i32, i64>\n+    //~ TRANS_ITEM drop-glue-contents generic_drop_glue::EnumWithDrop[0]<i32, i64>\n     //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[1]::drop[0]<i32, i64>\n     let _ = match EnumWithDrop::A::<i32, i64>(0) {\n         EnumWithDrop::A(x) => x,\n         EnumWithDrop::B(x) => x as i32\n     };\n \n     //~ TRANS_ITEM drop-glue generic_drop_glue::EnumWithDrop[0]<f64, f32>\n+    //~ TRANS_ITEM drop-glue-contents generic_drop_glue::EnumWithDrop[0]<f64, f32>\n     //~ TRANS_ITEM fn generic_drop_glue::{{impl}}[1]::drop[0]<f64, f32>\n     let _ = match EnumWithDrop::B::<f64, f32>(1.0) {\n         EnumWithDrop::A(x) => x,"}, {"sha": "91be81a0b8996ab81dd806deef1a102cec6e8d5b", "filename": "src/test/codegen-units/item-collection/non-generic-drop-glue.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-drop-glue.rs?ref=8da2bcac5db1e091b90cceb19d0496f0f7501c88", "patch": "@@ -14,6 +14,7 @@\n #![deny(dead_code)]\n \n //~ TRANS_ITEM drop-glue non_generic_drop_glue::StructWithDrop[0]\n+//~ TRANS_ITEM drop-glue-contents non_generic_drop_glue::StructWithDrop[0]\n struct StructWithDrop {\n     x: i32\n }\n@@ -28,6 +29,7 @@ struct StructNoDrop {\n }\n \n //~ TRANS_ITEM drop-glue non_generic_drop_glue::EnumWithDrop[0]\n+//~ TRANS_ITEM drop-glue-contents non_generic_drop_glue::EnumWithDrop[0]\n enum EnumWithDrop {\n     A(i32)\n }"}, {"sha": "81a7059fe209f4c7099fd167c600b97bc91270b0", "filename": "src/test/codegen-units/item-collection/transitive-drop-glue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftransitive-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftransitive-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftransitive-drop-glue.rs?ref=8da2bcac5db1e091b90cceb19d0496f0f7501c88", "patch": "@@ -18,18 +18,16 @@ struct Root(Intermediate);\n //~ TRANS_ITEM drop-glue transitive_drop_glue::Intermediate[0]\n struct Intermediate(Leaf);\n //~ TRANS_ITEM drop-glue transitive_drop_glue::Leaf[0]\n+//~ TRANS_ITEM drop-glue-contents transitive_drop_glue::Leaf[0]\n struct Leaf;\n \n impl Drop for Leaf {\n     //~ TRANS_ITEM fn transitive_drop_glue::{{impl}}[0]::drop[0]\n     fn drop(&mut self) {}\n }\n \n-//~ TRANS_ITEM drop-glue transitive_drop_glue::Root[0]\n struct RootGen<T>(IntermediateGen<T>);\n-//~ TRANS_ITEM drop-glue transitive_drop_glue::Root[0]\n struct IntermediateGen<T>(LeafGen<T>);\n-//~ TRANS_ITEM drop-glue transitive_drop_glue::Root[0]\n struct LeafGen<T>(T);\n \n impl<T> Drop for LeafGen<T> {\n@@ -44,12 +42,14 @@ fn main() {\n     //~ TRANS_ITEM drop-glue transitive_drop_glue::RootGen[0]<u32>\n     //~ TRANS_ITEM drop-glue transitive_drop_glue::IntermediateGen[0]<u32>\n     //~ TRANS_ITEM drop-glue transitive_drop_glue::LeafGen[0]<u32>\n+    //~ TRANS_ITEM drop-glue-contents transitive_drop_glue::LeafGen[0]<u32>\n     //~ TRANS_ITEM fn transitive_drop_glue::{{impl}}[1]::drop[0]<u32>\n     let _ = RootGen(IntermediateGen(LeafGen(0u32)));\n \n     //~ TRANS_ITEM drop-glue transitive_drop_glue::RootGen[0]<i16>\n     //~ TRANS_ITEM drop-glue transitive_drop_glue::IntermediateGen[0]<i16>\n     //~ TRANS_ITEM drop-glue transitive_drop_glue::LeafGen[0]<i16>\n+    //~ TRANS_ITEM drop-glue-contents transitive_drop_glue::LeafGen[0]<i16>\n     //~ TRANS_ITEM fn transitive_drop_glue::{{impl}}[1]::drop[0]<i16>\n     let _ = RootGen(IntermediateGen(LeafGen(0i16)));\n }"}, {"sha": "ef4bc1dca594cc6174d0aa355841df65cbb2e987", "filename": "src/test/codegen-units/item-collection/tuple-drop-glue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftuple-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftuple-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftuple-drop-glue.rs?ref=8da2bcac5db1e091b90cceb19d0496f0f7501c88", "patch": "@@ -14,6 +14,7 @@\n #![deny(dead_code)]\n \n //~ TRANS_ITEM drop-glue tuple_drop_glue::Dropped[0]\n+//~ TRANS_ITEM drop-glue-contents tuple_drop_glue::Dropped[0]\n struct Dropped;\n \n impl Drop for Dropped {"}, {"sha": "be41232ffbab00cd78579f0bc150bb8aad7a9960", "filename": "src/test/codegen-units/partitioning/extern-drop-glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs?ref=8da2bcac5db1e091b90cceb19d0496f0f7501c88", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=lazy\n+// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]\n@@ -18,6 +18,7 @@\n extern crate cgu_extern_drop_glue;\n \n //~ TRANS_ITEM drop-glue cgu_extern_drop_glue::Struct[0] @@ extern_drop_glue[OnceODR] extern_drop_glue-mod1[OnceODR]\n+//~ TRANS_ITEM drop-glue-contents cgu_extern_drop_glue::Struct[0] @@ extern_drop_glue[OnceODR] extern_drop_glue-mod1[OnceODR]\n \n struct LocalStruct(cgu_extern_drop_glue::Struct);\n \n@@ -40,4 +41,3 @@ mod mod1 {\n         let _ = LocalStruct(cgu_extern_drop_glue::Struct(0));\n     }\n }\n-"}, {"sha": "cd6f4619f9c8038c130212aac80b6b66c0b31c0d", "filename": "src/test/codegen-units/partitioning/extern-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs?ref=8da2bcac5db1e091b90cceb19d0496f0f7501c88", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-trans-items=eager -Zincremental=tmp\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]"}, {"sha": "7b92cf3f7cd52407b6677dbc52b9be1001b8fcfd", "filename": "src/test/codegen-units/partitioning/inlining-from-extern-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs?ref=8da2bcac5db1e091b90cceb19d0496f0f7501c88", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=lazy\n+// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp\n \n #![crate_type=\"lib\"]\n "}, {"sha": "f3a973fc47851800a15c09df29f82b654d4448e0", "filename": "src/test/codegen-units/partitioning/local-drop-glue.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs?ref=8da2bcac5db1e091b90cceb19d0496f0f7501c88", "patch": "@@ -9,18 +9,19 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=lazy\n+// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]\n \n //~ TRANS_ITEM drop-glue local_drop_glue::Struct[0] @@ local_drop_glue[OnceODR] local_drop_glue-mod1[OnceODR]\n+//~ TRANS_ITEM drop-glue-contents local_drop_glue::Struct[0] @@ local_drop_glue[OnceODR] local_drop_glue-mod1[OnceODR]\n struct Struct {\n     _a: u32\n }\n \n impl Drop for Struct {\n-    //~ TRANS_ITEM fn local_drop_glue::{{impl}}[0]::drop[0] @@ local_drop_glue[WeakODR]\n+    //~ TRANS_ITEM fn local_drop_glue::{{impl}}[0]::drop[0] @@ local_drop_glue[WeakODR] local_drop_glue-mod1[Declaration]\n     fn drop(&mut self) {}\n }\n "}, {"sha": "dd18874baa32b05fa5905d176b7036ee4d287a14", "filename": "src/test/codegen-units/partitioning/local-generic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs?ref=8da2bcac5db1e091b90cceb19d0496f0f7501c88", "patch": "@@ -9,18 +9,18 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-trans-items=eager -Zincremental=tmp\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]\n \n // Used in different modules/codegen units but always instantiated in the same\n // codegen unit.\n \n-//~ TRANS_ITEM fn local_generic::generic[0]<u32> @@ local_generic.volatile[WeakODR]\n-//~ TRANS_ITEM fn local_generic::generic[0]<u64> @@ local_generic.volatile[WeakODR]\n-//~ TRANS_ITEM fn local_generic::generic[0]<char> @@ local_generic.volatile[WeakODR]\n-//~ TRANS_ITEM fn local_generic::generic[0]<&str> @@ local_generic.volatile[WeakODR]\n+//~ TRANS_ITEM fn local_generic::generic[0]<u32> @@ local_generic.volatile[WeakODR] local_generic[Declaration]\n+//~ TRANS_ITEM fn local_generic::generic[0]<u64> @@ local_generic.volatile[WeakODR] local_generic-mod1[Declaration]\n+//~ TRANS_ITEM fn local_generic::generic[0]<char> @@ local_generic.volatile[WeakODR] local_generic-mod1-mod1[Declaration]\n+//~ TRANS_ITEM fn local_generic::generic[0]<&str> @@ local_generic.volatile[WeakODR] local_generic-mod2[Declaration]\n pub fn generic<T>(x: T) -> T { x }\n \n //~ TRANS_ITEM fn local_generic::user[0] @@ local_generic[WeakODR]"}, {"sha": "f493c8ed63f743b8088df4efcf6c572da4be3b90", "filename": "src/test/codegen-units/partitioning/local-inlining.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs?ref=8da2bcac5db1e091b90cceb19d0496f0f7501c88", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=lazy\n+// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]"}, {"sha": "31d99e08b653081925dda511e6255179d69f468b", "filename": "src/test/codegen-units/partitioning/local-transitive-inlining.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs?ref=8da2bcac5db1e091b90cceb19d0496f0f7501c88", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=lazy\n+// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]"}, {"sha": "6d04545f93d6e9d2c5ea36264a67d4c882114452", "filename": "src/test/codegen-units/partitioning/methods-are-with-self-type.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs?ref=8da2bcac5db1e091b90cceb19d0496f0f7501c88", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=lazy\n+// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp\n \n #![allow(dead_code)]\n \n@@ -59,19 +59,19 @@ mod type2 {\n //~ TRANS_ITEM fn methods_are_with_self_type::main[0]\n fn main()\n {\n-    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::method[0]<u32, u64> @@ methods_are_with_self_type.volatile[WeakODR]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::method[0]<u32, u64> @@ methods_are_with_self_type.volatile[WeakODR] methods_are_with_self_type[Declaration]\n     SomeGenericType(0u32, 0u64).method();\n-    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::associated_fn[0]<char, &str> @@ methods_are_with_self_type.volatile[WeakODR]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::associated_fn[0]<char, &str> @@ methods_are_with_self_type.volatile[WeakODR] methods_are_with_self_type[Declaration]\n     SomeGenericType::associated_fn('c', \"&str\");\n \n-    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR] methods_are_with_self_type[Declaration]\n     type1::Struct.foo();\n-    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR] methods_are_with_self_type[Declaration]\n     type2::Struct.foo();\n \n-    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR] methods_are_with_self_type[Declaration]\n     type1::Struct.default();\n-    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR] methods_are_with_self_type[Declaration]\n     type2::Struct.default();\n }\n "}, {"sha": "69c9bd0a12ae4e495413160dd8dbb2f3f269730c", "filename": "src/test/codegen-units/partitioning/regular-modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs?ref=8da2bcac5db1e091b90cceb19d0496f0f7501c88", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zprint-trans-items=eager -Z incremental=tmp\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]"}, {"sha": "e853ccaff0dd5ceb0e58da892c66b358cb7c73e7", "filename": "src/test/codegen-units/partitioning/statics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da2bcac5db1e091b90cceb19d0496f0f7501c88/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs?ref=8da2bcac5db1e091b90cceb19d0496f0f7501c88", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=lazy\n+// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp\n \n #![crate_type=\"lib\"]\n "}]}