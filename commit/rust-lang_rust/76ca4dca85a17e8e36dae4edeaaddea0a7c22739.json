{"sha": "76ca4dca85a17e8e36dae4edeaaddea0a7c22739", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2Y2E0ZGNhODVhMTdlOGUzNmRhZTRlZGVhYWRkZWEwYTdjMjI3Mzk=", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2017-08-02T22:41:46Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2017-08-04T05:48:43Z"}, "message": "unify checks into single visitor, fix block walk", "tree": {"sha": "02e6acbabba1021f9b0864ae55d939902a21fe96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02e6acbabba1021f9b0864ae55d939902a21fe96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76ca4dca85a17e8e36dae4edeaaddea0a7c22739", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76ca4dca85a17e8e36dae4edeaaddea0a7c22739", "html_url": "https://github.com/rust-lang/rust/commit/76ca4dca85a17e8e36dae4edeaaddea0a7c22739", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76ca4dca85a17e8e36dae4edeaaddea0a7c22739/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b7f3dc8e7124869c9d2399c37f5d59ddfe4e0ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b7f3dc8e7124869c9d2399c37f5d59ddfe4e0ef", "html_url": "https://github.com/rust-lang/rust/commit/3b7f3dc8e7124869c9d2399c37f5d59ddfe4e0ef"}], "stats": {"total": 158, "additions": 83, "deletions": 75}, "files": [{"sha": "fc28918ff169d9161cf465d5da83e8aa2f6ff536", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 80, "deletions": 72, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/76ca4dca85a17e8e36dae4edeaaddea0a7c22739/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76ca4dca85a17e8e36dae4edeaaddea0a7c22739/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=76ca4dca85a17e8e36dae4edeaaddea0a7c22739", "patch": "@@ -2,8 +2,8 @@ use reexport::*;\n use rustc::hir::*;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit::{Visitor, walk_expr, walk_block, walk_decl, NestedVisitorMap};\n-use rustc::hir::map::Node::NodeBlock;\n+use rustc::hir::intravisit::{Visitor, walk_expr, walk_block, walk_decl, walk_pat, walk_stmt, NestedVisitorMap};\n+use rustc::hir::map::Node::{NodeBlock, NodeExpr, NodeStmt};\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::region::CodeExtent;\n@@ -1327,105 +1327,113 @@ fn is_nested(cx: &LateContext, match_expr: &Expr, iter_expr: &Expr) -> bool {\n     if_let_chain! {[\n         let Some(loop_block) = get_enclosing_block(cx, match_expr.id),\n         let Some(map::Node::NodeExpr(loop_expr)) = cx.tcx.hir.find(cx.tcx.hir.get_parent_node(loop_block.id)),\n-        let Some(scope) = get_enclosing_block(cx, loop_expr.id)\n     ], {\n-        return is_loop_nested(cx, scope, loop_expr.id, iter_expr)\n+        return is_loop_nested(cx, loop_expr, iter_expr)\n     }}\n     false\n }\n \n-fn is_loop_nested(cx: &LateContext, scope: &Block, expr_id: NodeId, iter_expr: &Expr) -> bool {\n-    let mut b = scope;\n-    let mut e = expr_id;\n-    if let Some(name) = path_name(iter_expr) {\n-        loop {\n-            if b.stmts.iter().take_while(|stmt| !is_expr_stmt(stmt, e)).any(|stmt|\n-                    is_binding_or_assignment(stmt, name)) {\n-                return false;\n-            }\n-            if let Some(map::Node::NodeExpr(outer)) = cx.tcx.hir.find(cx.tcx.hir.get_parent_node(scope.id)) {\n-                if let ExprLoop(..) = outer.node {\n-                    return true;\n+fn is_loop_nested(cx: &LateContext, loop_expr: &Expr, iter_expr: &Expr) -> bool {\n+    let mut id = loop_expr.id;\n+    let iter_name = if let Some(name) = path_name(iter_expr) {\n+        name\n+    } else {\n+        return true;\n+    };\n+    loop {\n+        let parent = cx.tcx.hir.get_parent_node(id);\n+        if parent == id {\n+            return false;\n+        }\n+        match cx.tcx.hir.find(parent) {\n+            Some(NodeExpr(expr)) => {\n+                match expr.node {\n+                    ExprLoop(..) |\n+                    ExprWhile(..) => { return true; },\n+                    _ => ()\n                 }\n-                e = outer.id;\n-                if let Some(eb) = get_enclosing_block(cx, e) {\n-                    b = eb;\n-                } else {\n+            },\n+            Some(NodeBlock(block)) => {\n+                let mut block_visitor = LoopNestVisitor {\n+                                            id: id,\n+                                            iterator: iter_name,\n+                                            nesting: Unknown\n+                                        };\n+                walk_block(&mut block_visitor, block);\n+                if block_visitor.nesting == RuledOut {\n                     return false;\n                 }\n-            } else {\n+            },\n+            Some(NodeStmt(_)) => (),\n+            _ => {\n                 return false;\n             }\n         }\n+        id = parent;\n     }\n-    true\n }\n \n-fn path_name(e: &Expr) -> Option<Name> {\n-    if let ExprPath(QPath::Resolved(_, ref path)) = e.node {\n-        let segments = &path.segments;\n-        if segments.len() == 1 {\n-            return Some(segments[0].name);\n-        }\n-    };\n-    None\n+#[derive(PartialEq, Eq)]\n+enum Nesting {\n+    Unknown, // no nesting detected yet\n+    RuledOut, // the iterator is initialized or assigned within scope\n+    LookFurther // no nesting detected, no further walk required\n }\n \n-fn is_binding_or_assignment(stmt: &Stmt, name: Name) -> bool {\n-    match stmt.node {\n-        StmtExpr(ref e, _) | StmtSemi(ref e, _) => contains_assignment(e, name),\n-        StmtDecl(ref decl, _) => is_binding(decl, name)\n-    }\n-}\n+use self::Nesting::{Unknown, RuledOut, LookFurther};\n \n-struct AssignmentVisitor {\n-    var: ast::Name, // var to look for\n-    assigned: bool, // has the var been assigned?\n+struct LoopNestVisitor {\n+    id: NodeId,\n+    iterator: Name,\n+    nesting: Nesting\n }\n \n-impl<'tcx> Visitor<'tcx> for AssignmentVisitor {\n+impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n+    fn visit_stmt(&mut self, stmt: &'tcx Stmt) {\n+        if stmt.node.id() == self.id {\n+            self.nesting = LookFurther;\n+        } else if self.nesting == Unknown {\n+            walk_stmt(self, stmt);\n+        }\n+    }\n+\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if self.nesting != Unknown { return; }\n+        if expr.id == self.id {\n+            self.nesting = LookFurther;\n+            return;\n+        }\n         match expr.node {\n             ExprAssign(ref path, _) |\n-            ExprAssignOp(_, ref path, _) => if match_var(path, self.var) {\n-                self.assigned = true;\n-            }\n-            ExprLoop(..) |\n-            ExprIf(..) |\n-            ExprWhile(..) => (),\n+            ExprAssignOp(_, ref path, _) => if match_var(path, self.iterator) {\n+                self.nesting = RuledOut;\n+            },\n             _ => walk_expr(self, expr)\n         }\n     }\n \n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n+    fn visit_pat(&mut self, pat: &'tcx Pat) {\n+        if self.nesting != Unknown { return; }\n+        if let PatKind::Binding(_, _, span_name, _) = pat.node {\n+            if self.iterator == span_name.node {\n+                self.nesting = RuledOut;\n+                return;\n+            }\n+        }\n+        walk_pat(self, pat)\n     }\n-}\n-\n-fn contains_assignment(e: &Expr, name: Name) -> bool {\n-    let mut av = AssignmentVisitor { var: name, assigned: false };\n-    walk_expr(&mut av, e);\n-    av.assigned\n-}\n \n-fn is_binding(decl: &Decl, name: Name) -> bool {\n-    match decl.node {\n-        DeclLocal(ref local) => {\n-            !local.pat.walk(&mut |p: &Pat| {\n-                if let PatKind::Binding(_, _, span_name, _) = p.node {\n-                    name == span_name.node\n-                } else {\n-                    false\n-                }\n-            })\n-        },\n-        _ => false\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n     }\n }\n \n-fn is_expr_stmt(stmt: &Stmt, expr_id: NodeId) -> bool {\n-    match stmt.node {\n-        StmtExpr(ref e, _) | StmtSemi(ref e, _) => e.id == expr_id,\n-        _ => false\n-    }\n+fn path_name(e: &Expr) -> Option<Name> {\n+    if let ExprPath(QPath::Resolved(_, ref path)) = e.node {\n+        let segments = &path.segments;\n+        if segments.len() == 1 {\n+            return Some(segments[0].name);\n+        }\n+    };\n+    None\n }"}, {"sha": "689c92d6fb694bd06dcfaa55f0d4045d222c7a32", "filename": "tests/ui/while_loop.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76ca4dca85a17e8e36dae4edeaaddea0a7c22739/tests%2Fui%2Fwhile_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/76ca4dca85a17e8e36dae4edeaaddea0a7c22739/tests%2Fui%2Fwhile_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_loop.stderr?ref=76ca4dca85a17e8e36dae4edeaaddea0a7c22739", "patch": "@@ -104,10 +104,10 @@ error: empty `loop {}` detected. You may want to either use `panic!()` or add `s\n     = note: `-D empty-loop` implied by `-D warnings`\n \n error: this loop could be written as a `for` loop\n-   --> while_loop.rs:177:9\n+   --> $DIR/while_loop.rs:183:9\n     |\n-177 | /         while let Some(v) = y.next() {\n-178 | |         }\n+183 | /         while let Some(v) = y.next() { // use a for loop here\n+184 | |         }\n     | |_________^ help: try: `for v in y { .. }`\n \n error: aborting due to 11 previous errors"}]}