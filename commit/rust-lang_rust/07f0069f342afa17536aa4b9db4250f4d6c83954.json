{"sha": "07f0069f342afa17536aa4b9db4250f4d6c83954", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3ZjAwNjlmMzQyYWZhMTc1MzZhYTRiOWRiNDI1MGY0ZDZjODM5NTQ=", "commit": {"author": {"name": "Ville Penttinen", "email": "villem.penttinen@gmail.com", "date": "2019-04-09T11:43:11Z"}, "committer": {"name": "Ville Penttinen", "email": "villem.penttinen@gmail.com", "date": "2019-04-09T11:45:05Z"}, "message": "Move display related things from hover to display", "tree": {"sha": "2b322f27825803372b7e770856b8b890e105e152", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b322f27825803372b7e770856b8b890e105e152"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07f0069f342afa17536aa4b9db4250f4d6c83954", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07f0069f342afa17536aa4b9db4250f4d6c83954", "html_url": "https://github.com/rust-lang/rust/commit/07f0069f342afa17536aa4b9db4250f4d6c83954", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07f0069f342afa17536aa4b9db4250f4d6c83954/comments", "author": {"login": "vipentti", "id": 4726680, "node_id": "MDQ6VXNlcjQ3MjY2ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/4726680?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vipentti", "html_url": "https://github.com/vipentti", "followers_url": "https://api.github.com/users/vipentti/followers", "following_url": "https://api.github.com/users/vipentti/following{/other_user}", "gists_url": "https://api.github.com/users/vipentti/gists{/gist_id}", "starred_url": "https://api.github.com/users/vipentti/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vipentti/subscriptions", "organizations_url": "https://api.github.com/users/vipentti/orgs", "repos_url": "https://api.github.com/users/vipentti/repos", "events_url": "https://api.github.com/users/vipentti/events{/privacy}", "received_events_url": "https://api.github.com/users/vipentti/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vipentti", "id": 4726680, "node_id": "MDQ6VXNlcjQ3MjY2ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/4726680?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vipentti", "html_url": "https://github.com/vipentti", "followers_url": "https://api.github.com/users/vipentti/followers", "following_url": "https://api.github.com/users/vipentti/following{/other_user}", "gists_url": "https://api.github.com/users/vipentti/gists{/gist_id}", "starred_url": "https://api.github.com/users/vipentti/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vipentti/subscriptions", "organizations_url": "https://api.github.com/users/vipentti/orgs", "repos_url": "https://api.github.com/users/vipentti/repos", "events_url": "https://api.github.com/users/vipentti/events{/privacy}", "received_events_url": "https://api.github.com/users/vipentti/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fead60aa27e54d3ce48819c30d1db59c52d856c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/fead60aa27e54d3ce48819c30d1db59c52d856c9", "html_url": "https://github.com/rust-lang/rust/commit/fead60aa27e54d3ce48819c30d1db59c52d856c9"}], "stats": {"total": 219, "additions": 110, "deletions": 109}, "files": [{"sha": "b68b3a719428ea630fc172597ee8603ae1b6e6a7", "filename": "crates/ra_ide_api/src/display.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/07f0069f342afa17536aa4b9db4250f4d6c83954/crates%2Fra_ide_api%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f0069f342afa17536aa4b9db4250f4d6c83954/crates%2Fra_ide_api%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay.rs?ref=07f0069f342afa17536aa4b9db4250f4d6c83954", "patch": "@@ -5,6 +5,7 @@ mod function_signature;\n mod navigation_target;\n mod structure;\n \n+use crate::db::RootDatabase;\n use ra_syntax::{ast::{self, AstNode, TypeParamsOwner}, SyntaxKind::{ATTR, COMMENT}};\n \n pub use navigation_target::NavigationTarget;\n@@ -53,3 +54,29 @@ pub(crate) fn where_predicates<N: TypeParamsOwner>(node: &N) -> Vec<String> {\n     }\n     res\n }\n+\n+pub(crate) fn rust_code_markup<CODE: AsRef<str>>(val: CODE) -> String {\n+    rust_code_markup_with_doc::<_, &str>(val, None)\n+}\n+\n+pub(crate) fn rust_code_markup_with_doc<CODE, DOC>(val: CODE, doc: Option<DOC>) -> String\n+where\n+    CODE: AsRef<str>,\n+    DOC: AsRef<str>,\n+{\n+    if let Some(doc) = doc {\n+        format!(\"```rust\\n{}\\n```\\n\\n{}\", val.as_ref(), doc.as_ref())\n+    } else {\n+        format!(\"```rust\\n{}\\n```\", val.as_ref())\n+    }\n+}\n+\n+// FIXME: this should not really use navigation target. Rather, approximately\n+// resolved symbol should return a `DefId`.\n+pub(crate) fn doc_text_for(db: &RootDatabase, nav: NavigationTarget) -> Option<String> {\n+    match (nav.description(db), nav.docs(db)) {\n+        (Some(desc), docs) => Some(rust_code_markup_with_doc(desc, docs)),\n+        (None, Some(docs)) => Some(docs),\n+        _ => None,\n+    }\n+}"}, {"sha": "3c518faf50f09fdad47af42b9be8899ec185b2a8", "filename": "crates/ra_ide_api/src/display/navigation_target.rs", "status": "modified", "additions": 80, "deletions": 2, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/07f0069f342afa17536aa4b9db4250f4d6c83954/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f0069f342afa17536aa4b9db4250f4d6c83954/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=07f0069f342afa17536aa4b9db4250f4d6c83954", "patch": "@@ -1,7 +1,9 @@\n-use ra_db::FileId;\n+use ra_db::{FileId, SourceDatabase};\n use ra_syntax::{\n-    SyntaxNode, SyntaxNodePtr, AstNode, SmolStr, TextRange, ast,\n+    SyntaxNode, SyntaxNodePtr, AstNode, SmolStr, TextRange, TreeArc,\n     SyntaxKind::{self, NAME},\n+    ast::{self, NameOwner, VisibilityOwner, TypeAscriptionOwner},\n+    algo::visit::{visitor, Visitor},\n };\n use hir::{ModuleSource, FieldSource, Name, ImplItem};\n \n@@ -248,4 +250,80 @@ impl NavigationTarget {\n             container_name: None,\n         }\n     }\n+\n+    pub(crate) fn node(&self, db: &RootDatabase) -> Option<TreeArc<SyntaxNode>> {\n+        let source_file = db.parse(self.file_id());\n+        let source_file = source_file.syntax();\n+        let node = source_file\n+            .descendants()\n+            .find(|node| node.kind() == self.kind() && node.range() == self.full_range())?\n+            .to_owned();\n+        Some(node)\n+    }\n+\n+    pub(crate) fn docs(&self, db: &RootDatabase) -> Option<String> {\n+        let node = self.node(db)?;\n+        fn doc_comments<N: ast::DocCommentsOwner>(node: &N) -> Option<String> {\n+            node.doc_comment_text()\n+        }\n+\n+        visitor()\n+            .visit(doc_comments::<ast::FnDef>)\n+            .visit(doc_comments::<ast::StructDef>)\n+            .visit(doc_comments::<ast::EnumDef>)\n+            .visit(doc_comments::<ast::TraitDef>)\n+            .visit(doc_comments::<ast::Module>)\n+            .visit(doc_comments::<ast::TypeAliasDef>)\n+            .visit(doc_comments::<ast::ConstDef>)\n+            .visit(doc_comments::<ast::StaticDef>)\n+            .visit(doc_comments::<ast::NamedFieldDef>)\n+            .visit(doc_comments::<ast::EnumVariant>)\n+            .accept(&node)?\n+    }\n+\n+    /// Get a description of this node.\n+    ///\n+    /// e.g. `struct Name`, `enum Name`, `fn Name`\n+    pub(crate) fn description(&self, db: &RootDatabase) -> Option<String> {\n+        // FIXME: After type inference is done, add type information to improve the output\n+        let node = self.node(db)?;\n+\n+        fn visit_ascribed_node<T>(node: &T, prefix: &str) -> Option<String>\n+        where\n+            T: NameOwner + VisibilityOwner + TypeAscriptionOwner,\n+        {\n+            let mut string = visit_node(node, prefix)?;\n+\n+            if let Some(type_ref) = node.ascribed_type() {\n+                string.push_str(\": \");\n+                type_ref.syntax().text().push_to(&mut string);\n+            }\n+\n+            Some(string)\n+        }\n+\n+        fn visit_node<T>(node: &T, label: &str) -> Option<String>\n+        where\n+            T: NameOwner + VisibilityOwner,\n+        {\n+            let mut string =\n+                node.visibility().map(|v| format!(\"{} \", v.syntax().text())).unwrap_or_default();\n+            string.push_str(label);\n+            string.push_str(node.name()?.text().as_str());\n+            Some(string)\n+        }\n+\n+        visitor()\n+            .visit(|node: &ast::FnDef| Some(crate::display::function_label(node)))\n+            .visit(|node: &ast::StructDef| visit_node(node, \"struct \"))\n+            .visit(|node: &ast::EnumDef| visit_node(node, \"enum \"))\n+            .visit(|node: &ast::TraitDef| visit_node(node, \"trait \"))\n+            .visit(|node: &ast::Module| visit_node(node, \"mod \"))\n+            .visit(|node: &ast::TypeAliasDef| visit_node(node, \"type \"))\n+            .visit(|node: &ast::ConstDef| visit_ascribed_node(node, \"const \"))\n+            .visit(|node: &ast::StaticDef| visit_ascribed_node(node, \"static \"))\n+            .visit(|node: &ast::NamedFieldDef| visit_ascribed_node(node, \"\"))\n+            .visit(|node: &ast::EnumVariant| Some(node.name()?.text().to_string()))\n+            .accept(&node)?\n+    }\n }"}, {"sha": "3a8c93b99fc4fb0d37b03767df5809252d531591", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 3, "deletions": 107, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/07f0069f342afa17536aa4b9db4250f4d6c83954/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f0069f342afa17536aa4b9db4250f4d6c83954/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=07f0069f342afa17536aa4b9db4250f4d6c83954", "patch": "@@ -1,11 +1,11 @@\n use ra_db::SourceDatabase;\n use ra_syntax::{\n-    AstNode, SyntaxNode, TreeArc, ast::{self, NameOwner, VisibilityOwner, TypeAscriptionOwner},\n-    algo::{find_covering_element, find_node_at_offset, find_token_at_offset, visit::{visitor, Visitor}},\n+    AstNode, ast,\n+    algo::{find_covering_element, find_node_at_offset, find_token_at_offset},\n };\n use hir::HirDisplay;\n \n-use crate::{db::RootDatabase, RangeInfo, FilePosition, FileRange, NavigationTarget};\n+use crate::{db::RootDatabase, RangeInfo, FilePosition, FileRange, display::{rust_code_markup, doc_text_for}};\n \n /// Contains the results when hovering over an item\n #[derive(Debug, Clone)]\n@@ -145,110 +145,6 @@ pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Option<String> {\n     }\n }\n \n-fn rust_code_markup<CODE: AsRef<str>>(val: CODE) -> String {\n-    rust_code_markup_with_doc::<_, &str>(val, None)\n-}\n-\n-fn rust_code_markup_with_doc<CODE, DOC>(val: CODE, doc: Option<DOC>) -> String\n-where\n-    CODE: AsRef<str>,\n-    DOC: AsRef<str>,\n-{\n-    if let Some(doc) = doc {\n-        format!(\"```rust\\n{}\\n```\\n\\n{}\", val.as_ref(), doc.as_ref())\n-    } else {\n-        format!(\"```rust\\n{}\\n```\", val.as_ref())\n-    }\n-}\n-\n-// FIXME: this should not really use navigation target. Rather, approximately\n-// resolved symbol should return a `DefId`.\n-fn doc_text_for(db: &RootDatabase, nav: NavigationTarget) -> Option<String> {\n-    match (nav.description(db), nav.docs(db)) {\n-        (Some(desc), docs) => Some(rust_code_markup_with_doc(desc, docs)),\n-        (None, Some(docs)) => Some(docs),\n-        _ => None,\n-    }\n-}\n-\n-impl NavigationTarget {\n-    fn node(&self, db: &RootDatabase) -> Option<TreeArc<SyntaxNode>> {\n-        let source_file = db.parse(self.file_id());\n-        let source_file = source_file.syntax();\n-        let node = source_file\n-            .descendants()\n-            .find(|node| node.kind() == self.kind() && node.range() == self.full_range())?\n-            .to_owned();\n-        Some(node)\n-    }\n-\n-    fn docs(&self, db: &RootDatabase) -> Option<String> {\n-        let node = self.node(db)?;\n-        fn doc_comments<N: ast::DocCommentsOwner>(node: &N) -> Option<String> {\n-            node.doc_comment_text()\n-        }\n-\n-        visitor()\n-            .visit(doc_comments::<ast::FnDef>)\n-            .visit(doc_comments::<ast::StructDef>)\n-            .visit(doc_comments::<ast::EnumDef>)\n-            .visit(doc_comments::<ast::TraitDef>)\n-            .visit(doc_comments::<ast::Module>)\n-            .visit(doc_comments::<ast::TypeAliasDef>)\n-            .visit(doc_comments::<ast::ConstDef>)\n-            .visit(doc_comments::<ast::StaticDef>)\n-            .visit(doc_comments::<ast::NamedFieldDef>)\n-            .visit(doc_comments::<ast::EnumVariant>)\n-            .accept(&node)?\n-    }\n-\n-    /// Get a description of this node.\n-    ///\n-    /// e.g. `struct Name`, `enum Name`, `fn Name`\n-    fn description(&self, db: &RootDatabase) -> Option<String> {\n-        // FIXME: After type inference is done, add type information to improve the output\n-        let node = self.node(db)?;\n-\n-        fn visit_ascribed_node<T>(node: &T, prefix: &str) -> Option<String>\n-        where\n-            T: NameOwner + VisibilityOwner + TypeAscriptionOwner,\n-        {\n-            let mut string = visit_node(node, prefix)?;\n-\n-            if let Some(type_ref) = node.ascribed_type() {\n-                string.push_str(\": \");\n-                type_ref.syntax().text().push_to(&mut string);\n-            }\n-\n-            Some(string)\n-        }\n-\n-        fn visit_node<T>(node: &T, label: &str) -> Option<String>\n-        where\n-            T: NameOwner + VisibilityOwner,\n-        {\n-            let mut string =\n-                node.visibility().map(|v| format!(\"{} \", v.syntax().text())).unwrap_or_default();\n-            string.push_str(label);\n-            string.push_str(node.name()?.text().as_str());\n-            Some(string)\n-        }\n-\n-        visitor()\n-            .visit(|node: &ast::FnDef| Some(crate::display::function_label(node)))\n-            .visit(|node: &ast::StructDef| visit_node(node, \"struct \"))\n-            .visit(|node: &ast::EnumDef| visit_node(node, \"enum \"))\n-            .visit(|node: &ast::TraitDef| visit_node(node, \"trait \"))\n-            .visit(|node: &ast::Module| visit_node(node, \"mod \"))\n-            .visit(|node: &ast::TypeAliasDef| visit_node(node, \"type \"))\n-            .visit(|node: &ast::ConstDef| visit_ascribed_node(node, \"const \"))\n-            .visit(|node: &ast::StaticDef| visit_ascribed_node(node, \"static \"))\n-            .visit(|node: &ast::NamedFieldDef| visit_ascribed_node(node, \"\"))\n-            .visit(|node: &ast::EnumVariant| Some(node.name()?.text().to_string()))\n-            .accept(&node)?\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use ra_syntax::TextRange;"}]}