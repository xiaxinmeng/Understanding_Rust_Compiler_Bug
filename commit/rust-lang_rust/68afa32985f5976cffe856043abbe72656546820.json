{"sha": "68afa32985f5976cffe856043abbe72656546820", "node_id": "C_kwDOAAsO6NoAKDY4YWZhMzI5ODVmNTk3NmNmZmU4NTYwNDNhYmJlNzI2NTY1NDY4MjA", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-11-01T16:31:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-01T16:31:36Z"}, "message": "Rollup merge of #103760 - petrochenkov:macimp, r=cjgillot\n\nresolve: Turn the binding from `#[macro_export]` into a proper `Import`\n\nContinuation of https://github.com/rust-lang/rust/pull/91795.\n\n```rust\n#[macro_export]\nmacro_rules! m { /*...*/ }\n```\nis desugared to something like\n```rust\nmacro_rules! m { /*...*/ } // Non-modularized macro_rules item\n\npub use m; // It's modularized reexport\n```\n\nThis PR adjusts the internal representation to better match this model.", "tree": {"sha": "5a8f5d85a9bf94ba739b76d58b72cfb7ac64782f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a8f5d85a9bf94ba739b76d58b72cfb7ac64782f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68afa32985f5976cffe856043abbe72656546820", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjYUnoCRBK7hj4Ov3rIwAAJG8IAB2UoMN5usYFf6KBa/wG9cAi\nWpetzfK4RWA8joM7W+7CDZWWVZU0iyEIXXiUwZEZCx3VSmqoinZ1VpckUXosj+yP\n+tH9awK2pfPpVvupa8PGrMNXyGwL021twaX3onHNOAr9C8YrjA5sI+UW1dOw5vwl\nQHy3B0sXxbLGO7JLnKoi/ECYFLO6INgDTPJ3VacfGxMWPnNCjuN1AXg1M4pX7Asx\nS4MqFYog3q70aPOzHIbdkb//rPKTgJhRNWVrgTmcPDtfbCrVW82MZWDEcRGqq2Pm\n/tYXCqCzORlW7MEvHBnB+pvYp7CQo3PZmCvOgD6kMdcwAm5eANXnglgGrTm1iWQ=\n=n6wj\n-----END PGP SIGNATURE-----\n", "payload": "tree 5a8f5d85a9bf94ba739b76d58b72cfb7ac64782f\nparent 9f603feaeeb8f48c80fedc0128a55d0fff23a718\nparent 84317518ffaf8e56524510a2ca634ebb64022249\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1667320296 +0530\ncommitter GitHub <noreply@github.com> 1667320296 +0530\n\nRollup merge of #103760 - petrochenkov:macimp, r=cjgillot\n\nresolve: Turn the binding from `#[macro_export]` into a proper `Import`\n\nContinuation of https://github.com/rust-lang/rust/pull/91795.\n\n```rust\n#[macro_export]\nmacro_rules! m { /*...*/ }\n```\nis desugared to something like\n```rust\nmacro_rules! m { /*...*/ } // Non-modularized macro_rules item\n\npub use m; // It's modularized reexport\n```\n\nThis PR adjusts the internal representation to better match this model.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68afa32985f5976cffe856043abbe72656546820", "html_url": "https://github.com/rust-lang/rust/commit/68afa32985f5976cffe856043abbe72656546820", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68afa32985f5976cffe856043abbe72656546820/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f603feaeeb8f48c80fedc0128a55d0fff23a718", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f603feaeeb8f48c80fedc0128a55d0fff23a718", "html_url": "https://github.com/rust-lang/rust/commit/9f603feaeeb8f48c80fedc0128a55d0fff23a718"}, {"sha": "84317518ffaf8e56524510a2ca634ebb64022249", "url": "https://api.github.com/repos/rust-lang/rust/commits/84317518ffaf8e56524510a2ca634ebb64022249", "html_url": "https://github.com/rust-lang/rust/commit/84317518ffaf8e56524510a2ca634ebb64022249"}], "stats": {"total": 401, "additions": 237, "deletions": 164}, "files": [{"sha": "423c57275333a2c355020942ecfb383816b8f24b", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 22, "deletions": 33, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/68afa32985f5976cffe856043abbe72656546820/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68afa32985f5976cffe856043abbe72656546820/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=68afa32985f5976cffe856043abbe72656546820", "patch": "@@ -56,21 +56,7 @@ impl<'a, Id: Into<DefId>> ToNameBinding<'a>\n impl<'a, Id: Into<DefId>> ToNameBinding<'a> for (Res, ty::Visibility<Id>, Span, LocalExpnId) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Res(self.0, false),\n-            ambiguity: None,\n-            vis: self.1.to_def_id(),\n-            span: self.2,\n-            expansion: self.3,\n-        })\n-    }\n-}\n-\n-struct IsMacroExport;\n-\n-impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, LocalExpnId, IsMacroExport) {\n-    fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n-        arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Res(self.0, true),\n+            kind: NameBindingKind::Res(self.0),\n             ambiguity: None,\n             vis: self.1.to_def_id(),\n             span: self.2,\n@@ -364,7 +350,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         module_path: Vec<Segment>,\n         kind: ImportKind<'a>,\n         span: Span,\n-        id: NodeId,\n         item: &ast::Item,\n         root_span: Span,\n         root_id: NodeId,\n@@ -377,7 +362,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             module_path,\n             imported_module: Cell::new(None),\n             span,\n-            id,\n             use_span: item.span,\n             use_span_with_attributes: item.span_with_attributes(),\n             has_attributes: !item.attrs.is_empty(),\n@@ -574,27 +558,20 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     },\n                     type_ns_only,\n                     nested,\n+                    id,\n                     additional_ids: (id1, id2),\n                 };\n \n-                self.add_import(\n-                    module_path,\n-                    kind,\n-                    use_tree.span,\n-                    id,\n-                    item,\n-                    root_span,\n-                    item.id,\n-                    vis,\n-                );\n+                self.add_import(module_path, kind, use_tree.span, item, root_span, item.id, vis);\n             }\n             ast::UseTreeKind::Glob => {\n                 let kind = ImportKind::Glob {\n                     is_prelude: self.r.session.contains_name(&item.attrs, sym::prelude_import),\n                     max_vis: Cell::new(None),\n+                    id,\n                 };\n                 self.r.visibilities.insert(self.r.local_def_id(id), vis);\n-                self.add_import(prefix, kind, use_tree.span, id, item, root_span, item.id, vis);\n+                self.add_import(prefix, kind, use_tree.span, item, root_span, item.id, vis);\n             }\n             ast::UseTreeKind::Nested(ref items) => {\n                 // Ensure there is at most one `self` in the list\n@@ -881,9 +858,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         })\n         .unwrap_or((true, None, self.r.dummy_binding));\n         let import = self.r.arenas.alloc_import(Import {\n-            kind: ImportKind::ExternCrate { source: orig_name, target: ident },\n+            kind: ImportKind::ExternCrate { source: orig_name, target: ident, id: item.id },\n             root_id: item.id,\n-            id: item.id,\n             parent_scope: self.parent_scope,\n             imported_module: Cell::new(module),\n             has_attributes: !item.attrs.is_empty(),\n@@ -1118,7 +1094,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             this.r.arenas.alloc_import(Import {\n                 kind: ImportKind::MacroUse,\n                 root_id: item.id,\n-                id: item.id,\n                 parent_scope: this.parent_scope,\n                 imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n                 use_span_with_attributes: item.span_with_attributes(),\n@@ -1278,8 +1253,22 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             let binding = (res, vis, span, expansion).to_name_binding(self.r.arenas);\n             self.r.set_binding_parent_module(binding, parent_scope.module);\n             if is_macro_export {\n-                let module = self.r.graph_root;\n-                self.r.define(module, ident, MacroNS, (res, vis, span, expansion, IsMacroExport));\n+                let import = self.r.arenas.alloc_import(Import {\n+                    kind: ImportKind::MacroExport,\n+                    root_id: item.id,\n+                    parent_scope: self.parent_scope,\n+                    imported_module: Cell::new(None),\n+                    has_attributes: false,\n+                    use_span_with_attributes: span,\n+                    use_span: span,\n+                    root_span: span,\n+                    span: span,\n+                    module_path: Vec::new(),\n+                    vis: Cell::new(Some(vis)),\n+                    used: Cell::new(true),\n+                });\n+                let import_binding = self.r.import(binding, import);\n+                self.r.define(self.r.graph_root, ident, MacroNS, import_binding);\n             } else {\n                 self.r.check_reserved_macro_name(ident, res);\n                 self.insert_unused_macro(ident, def_id, item.id, &rule_spans);"}, {"sha": "32fb5e18276ab86fe721f533c56d88871cb2e44c", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68afa32985f5976cffe856043abbe72656546820/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68afa32985f5976cffe856043abbe72656546820/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=68afa32985f5976cffe856043abbe72656546820", "patch": "@@ -234,7 +234,7 @@ impl Resolver<'_> {\n                         if !import.span.is_dummy() {\n                             self.lint_buffer.buffer_lint(\n                                 MACRO_USE_EXTERN_CRATE,\n-                                import.id,\n+                                import.root_id,\n                                 import.span,\n                                 \"deprecated `#[macro_use]` attribute used to \\\n                                 import macros should be replaced at use sites \\\n@@ -244,13 +244,13 @@ impl Resolver<'_> {\n                         }\n                     }\n                 }\n-                ImportKind::ExternCrate { .. } => {\n-                    let def_id = self.local_def_id(import.id);\n+                ImportKind::ExternCrate { id, .. } => {\n+                    let def_id = self.local_def_id(id);\n                     self.maybe_unused_extern_crates.push((def_id, import.span));\n                 }\n                 ImportKind::MacroUse => {\n                     let msg = \"unused `#[macro_use]` import\";\n-                    self.lint_buffer.buffer_lint(UNUSED_IMPORTS, import.id, import.span, msg);\n+                    self.lint_buffer.buffer_lint(UNUSED_IMPORTS, import.root_id, import.span, msg);\n                 }\n                 _ => {}\n             }"}, {"sha": "7961e3f1194e1ab7743fc31d70ddec84dc2f36e3", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/68afa32985f5976cffe856043abbe72656546820/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68afa32985f5976cffe856043abbe72656546820/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=68afa32985f5976cffe856043abbe72656546820", "patch": "@@ -190,12 +190,12 @@ impl<'a> Resolver<'a> {\n             ModuleKind::Block => \"block\",\n         };\n \n-        let old_noun = match old_binding.is_import() {\n+        let old_noun = match old_binding.is_import_user_facing() {\n             true => \"import\",\n             false => \"definition\",\n         };\n \n-        let new_participle = match new_binding.is_import() {\n+        let new_participle = match new_binding.is_import_user_facing() {\n             true => \"imported\",\n             false => \"defined\",\n         };\n@@ -226,7 +226,7 @@ impl<'a> Resolver<'a> {\n                 true => struct_span_err!(self.session, span, E0254, \"{}\", msg),\n                 false => struct_span_err!(self.session, span, E0260, \"{}\", msg),\n             },\n-            _ => match (old_binding.is_import(), new_binding.is_import()) {\n+            _ => match (old_binding.is_import_user_facing(), new_binding.is_import_user_facing()) {\n                 (false, false) => struct_span_err!(self.session, span, E0428, \"{}\", msg),\n                 (true, true) => struct_span_err!(self.session, span, E0252, \"{}\", msg),\n                 _ => struct_span_err!(self.session, span, E0255, \"{}\", msg),\n@@ -248,14 +248,18 @@ impl<'a> Resolver<'a> {\n \n         // See https://github.com/rust-lang/rust/issues/32354\n         use NameBindingKind::Import;\n+        let can_suggest = |binding: &NameBinding<'_>, import: &self::Import<'_>| {\n+            !binding.span.is_dummy()\n+                && !matches!(import.kind, ImportKind::MacroUse | ImportKind::MacroExport)\n+        };\n         let import = match (&new_binding.kind, &old_binding.kind) {\n             // If there are two imports where one or both have attributes then prefer removing the\n             // import without attributes.\n             (Import { import: new, .. }, Import { import: old, .. })\n                 if {\n-                    !new_binding.span.is_dummy()\n-                        && !old_binding.span.is_dummy()\n-                        && (new.has_attributes || old.has_attributes)\n+                    (new.has_attributes || old.has_attributes)\n+                        && can_suggest(old_binding, old)\n+                        && can_suggest(new_binding, new)\n                 } =>\n             {\n                 if old.has_attributes {\n@@ -265,10 +269,10 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             // Otherwise prioritize the new binding.\n-            (Import { import, .. }, other) if !new_binding.span.is_dummy() => {\n+            (Import { import, .. }, other) if can_suggest(new_binding, import) => {\n                 Some((import, new_binding.span, other.is_import()))\n             }\n-            (other, Import { import, .. }) if !old_binding.span.is_dummy() => {\n+            (other, Import { import, .. }) if can_suggest(old_binding, import) => {\n                 Some((import, old_binding.span, other.is_import()))\n             }\n             _ => None,\n@@ -353,7 +357,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n             }\n-            ImportKind::ExternCrate { source, target } => {\n+            ImportKind::ExternCrate { source, target, .. } => {\n                 suggestion = Some(format!(\n                     \"extern crate {} as {};\",\n                     source.unwrap_or(target.name),\n@@ -1683,7 +1687,7 @@ impl<'a> Resolver<'a> {\n             let a = if built_in.is_empty() { res.article() } else { \"a\" };\n             format!(\"{a}{built_in} {thing}{from}\", thing = res.descr())\n         } else {\n-            let introduced = if b.is_import() { \"imported\" } else { \"defined\" };\n+            let introduced = if b.is_import_user_facing() { \"imported\" } else { \"defined\" };\n             format!(\"the {thing} {introduced} here\", thing = res.descr())\n         }\n     }\n@@ -1742,10 +1746,10 @@ impl<'a> Resolver<'a> {\n     /// If the binding refers to a tuple struct constructor with fields,\n     /// returns the span of its fields.\n     fn ctor_fields_span(&self, binding: &NameBinding<'_>) -> Option<Span> {\n-        if let NameBindingKind::Res(\n-            Res::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fn), ctor_def_id),\n-            _,\n-        ) = binding.kind\n+        if let NameBindingKind::Res(Res::Def(\n+            DefKind::Ctor(CtorOf::Struct, CtorKind::Fn),\n+            ctor_def_id,\n+        )) = binding.kind\n         {\n             let def_id = self.parent(ctor_def_id);\n             let fields = self.field_names.get(&def_id)?;\n@@ -1789,7 +1793,9 @@ impl<'a> Resolver<'a> {\n                         next_ident = source;\n                         Some(binding)\n                     }\n-                    ImportKind::Glob { .. } | ImportKind::MacroUse => Some(binding),\n+                    ImportKind::Glob { .. } | ImportKind::MacroUse | ImportKind::MacroExport => {\n+                        Some(binding)\n+                    }\n                     ImportKind::ExternCrate { .. } => None,\n                 },\n                 _ => None,"}, {"sha": "17ce854cb4388fa88a41aa87a9b8027730a98eee", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/68afa32985f5976cffe856043abbe72656546820/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68afa32985f5976cffe856043abbe72656546820/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=68afa32985f5976cffe856043abbe72656546820", "patch": "@@ -57,26 +57,45 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n                     while let NameBindingKind::Import { binding: nested_binding, import, .. } =\n                         binding.kind\n                     {\n-                        let mut update = |node_id| self.update(\n-                            self.r.local_def_id(node_id),\n-                            binding.vis.expect_local(),\n-                            prev_parent_id,\n-                            level,\n-                        );\n-                        // In theory all the import IDs have individual visibilities and effective\n-                        // visibilities, but in practice these IDs go straigth to HIR where all\n-                        // their few uses assume that their (effective) visibility applies to the\n-                        // whole syntactic `use` item. So we update them all to the maximum value\n-                        // among the potential individual effective visibilities. Maybe HIR for\n-                        // imports shouldn't use three IDs at all.\n-                        update(import.id);\n-                        if let ImportKind::Single { additional_ids, .. } = import.kind {\n-                            update(additional_ids.0);\n-                            update(additional_ids.1);\n+                        let mut update = |node_id| {\n+                            self.update(\n+                                self.r.local_def_id(node_id),\n+                                binding.vis.expect_local(),\n+                                prev_parent_id,\n+                                level,\n+                            )\n+                        };\n+                        match import.kind {\n+                            ImportKind::Single { id, additional_ids, .. } => {\n+                                // In theory all the import IDs have individual visibilities and\n+                                // effective visibilities, but in practice these IDs go straigth to\n+                                // HIR where all their few uses assume that their (effective)\n+                                // visibility applies to the whole syntactic `use` item. So we\n+                                // update them all to the maximum value among the potential\n+                                // individual effective visibilities. Maybe HIR for imports\n+                                // shouldn't use three IDs at all.\n+                                update(id);\n+                                update(additional_ids.0);\n+                                update(additional_ids.1);\n+                                prev_parent_id = self.r.local_def_id(id);\n+                            }\n+                            ImportKind::Glob { id, .. } | ImportKind::ExternCrate { id, .. } => {\n+                                update(id);\n+                                prev_parent_id = self.r.local_def_id(id);\n+                            }\n+                            ImportKind::MacroUse => {\n+                                // In theory we should reset the parent id to something private\n+                                // here, but `macro_use` imports always refer to external items,\n+                                // so it doesn't matter and we can just do nothing.\n+                            }\n+                            ImportKind::MacroExport => {\n+                                // In theory we should reset the parent id to something public\n+                                // here, but it has the same effect as leaving the previous parent,\n+                                // so we can just do nothing.\n+                            }\n                         }\n \n                         level = Level::Reexported;\n-                        prev_parent_id = self.r.local_def_id(import.id);\n                         binding = nested_binding;\n                     }\n                 }\n@@ -138,13 +157,6 @@ impl<'r, 'ast> Visitor<'ast> for EffectiveVisibilitiesVisitor<'ast, 'r> {\n                 self.update(def_id, Visibility::Public, parent_id, Level::Direct);\n             }\n \n-            // Only exported `macro_rules!` items are public, but they always are\n-            ast::ItemKind::MacroDef(ref macro_def) if macro_def.macro_rules => {\n-                let parent_id = self.r.local_parent(def_id);\n-                let vis = self.r.visibilities[&def_id];\n-                self.update(def_id, vis, parent_id, Level::Direct);\n-            }\n-\n             ast::ItemKind::Mod(..) => {\n                 self.set_bindings_effective_visibilities(def_id);\n                 visit::walk_item(self, item);"}, {"sha": "0c4b35b88335ad5e429b68d74e14db5555fb3451", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68afa32985f5976cffe856043abbe72656546820/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68afa32985f5976cffe856043abbe72656546820/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=68afa32985f5976cffe856043abbe72656546820", "patch": "@@ -17,7 +17,7 @@ use crate::late::{\n };\n use crate::macros::{sub_namespace_match, MacroRulesScope};\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, Determinacy, Finalize};\n-use crate::{ImportKind, LexicalScopeBinding, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{Import, ImportKind, LexicalScopeBinding, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{NameBinding, NameBindingKind, ParentScope, PathResult, PrivacyError, Res};\n use crate::{ResolutionError, Resolver, Scope, ScopeSet, Segment, ToNameBinding, Weak};\n \n@@ -860,7 +860,11 @@ impl<'a> Resolver<'a> {\n             }\n \n             if !restricted_shadowing && binding.expansion != LocalExpnId::ROOT {\n-                if let NameBindingKind::Res(_, true) = binding.kind {\n+                if let NameBindingKind::Import {\n+                    import: Import { kind: ImportKind::MacroExport, .. },\n+                    ..\n+                } = binding.kind\n+                {\n                     self.macro_expanded_macro_export_errors.insert((path_span, binding.span));\n                 }\n             }"}, {"sha": "bdb852548b84e43e652ba5764297173c20d181e8", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 96, "deletions": 62, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/68afa32985f5976cffe856043abbe72656546820/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68afa32985f5976cffe856043abbe72656546820/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=68afa32985f5976cffe856043abbe72656546820", "patch": "@@ -44,20 +44,36 @@ pub enum ImportKind<'a> {\n         type_ns_only: bool,\n         /// Did this import result from a nested import? ie. `use foo::{bar, baz};`\n         nested: bool,\n+        /// The ID of the `UseTree` that imported this `Import`.\n+        ///\n+        /// In the case where the `Import` was expanded from a \"nested\" use tree,\n+        /// this id is the ID of the leaf tree. For example:\n+        ///\n+        /// ```ignore (pacify the merciless tidy)\n+        /// use foo::bar::{a, b}\n+        /// ```\n+        ///\n+        /// If this is the import for `foo::bar::a`, we would have the ID of the `UseTree`\n+        /// for `a` in this field.\n+        id: NodeId,\n         /// Additional `NodeId`s allocated to a `ast::UseTree` for automatically generated `use` statement\n         /// (eg. implicit struct constructors)\n         additional_ids: (NodeId, NodeId),\n     },\n     Glob {\n         is_prelude: bool,\n-        max_vis: Cell<Option<ty::Visibility>>, // The visibility of the greatest re-export.\n-                                               // n.b. `max_vis` is only used in `finalize_import` to check for re-export errors.\n+        // The visibility of the greatest re-export.\n+        // n.b. `max_vis` is only used in `finalize_import` to check for re-export errors.\n+        max_vis: Cell<Option<ty::Visibility>>,\n+        id: NodeId,\n     },\n     ExternCrate {\n         source: Option<Symbol>,\n         target: Ident,\n+        id: NodeId,\n     },\n     MacroUse,\n+    MacroExport,\n }\n \n /// Manually implement `Debug` for `ImportKind` because the `source/target_bindings`\n@@ -71,6 +87,7 @@ impl<'a> std::fmt::Debug for ImportKind<'a> {\n                 ref target,\n                 ref type_ns_only,\n                 ref nested,\n+                ref id,\n                 ref additional_ids,\n                 // Ignore the following to avoid an infinite loop while printing.\n                 source_bindings: _,\n@@ -81,19 +98,23 @@ impl<'a> std::fmt::Debug for ImportKind<'a> {\n                 .field(\"target\", target)\n                 .field(\"type_ns_only\", type_ns_only)\n                 .field(\"nested\", nested)\n+                .field(\"id\", id)\n                 .field(\"additional_ids\", additional_ids)\n                 .finish_non_exhaustive(),\n-            Glob { ref is_prelude, ref max_vis } => f\n+            Glob { ref is_prelude, ref max_vis, ref id } => f\n                 .debug_struct(\"Glob\")\n                 .field(\"is_prelude\", is_prelude)\n                 .field(\"max_vis\", max_vis)\n+                .field(\"id\", id)\n                 .finish(),\n-            ExternCrate { ref source, ref target } => f\n+            ExternCrate { ref source, ref target, ref id } => f\n                 .debug_struct(\"ExternCrate\")\n                 .field(\"source\", source)\n                 .field(\"target\", target)\n+                .field(\"id\", id)\n                 .finish(),\n             MacroUse => f.debug_struct(\"MacroUse\").finish(),\n+            MacroExport => f.debug_struct(\"MacroExport\").finish(),\n         }\n     }\n }\n@@ -103,24 +124,15 @@ impl<'a> std::fmt::Debug for ImportKind<'a> {\n pub(crate) struct Import<'a> {\n     pub kind: ImportKind<'a>,\n \n-    /// The ID of the `extern crate`, `UseTree` etc that imported this `Import`.\n-    ///\n-    /// In the case where the `Import` was expanded from a \"nested\" use tree,\n-    /// this id is the ID of the leaf tree. For example:\n-    ///\n-    /// ```ignore (pacify the merciless tidy)\n+    /// Node ID of the \"root\" use item -- this is always the same as `ImportKind`'s `id`\n+    /// (if it exists) except in the case of \"nested\" use trees, in which case\n+    /// it will be the ID of the root use tree. e.g., in the example\n+    /// ```ignore (incomplete code)\n     /// use foo::bar::{a, b}\n     /// ```\n-    ///\n-    /// If this is the import for `foo::bar::a`, we would have the ID of the `UseTree`\n-    /// for `a` in this field.\n-    pub id: NodeId,\n-\n-    /// The `id` of the \"root\" use-kind -- this is always the same as\n-    /// `id` except in the case of \"nested\" use trees, in which case\n-    /// it will be the `id` of the root use tree. e.g., in the example\n-    /// from `id`, this would be the ID of the `use foo::bar`\n-    /// `UseTree` node.\n+    /// this would be the ID of the `use foo::bar` `UseTree` node.\n+    /// In case of imports without their own node ID it's the closest node that can be used,\n+    /// for example, for reporting lints.\n     pub root_id: NodeId,\n \n     /// Span of the entire use statement.\n@@ -161,6 +173,15 @@ impl<'a> Import<'a> {\n     pub(crate) fn expect_vis(&self) -> ty::Visibility {\n         self.vis.get().expect(\"encountered cleared import visibility\")\n     }\n+\n+    pub(crate) fn id(&self) -> Option<NodeId> {\n+        match self.kind {\n+            ImportKind::Single { id, .. }\n+            | ImportKind::Glob { id, .. }\n+            | ImportKind::ExternCrate { id, .. } => Some(id),\n+            ImportKind::MacroUse | ImportKind::MacroExport => None,\n+        }\n+    }\n }\n \n /// Records information about the resolution of a name in a namespace of a module.\n@@ -368,7 +389,9 @@ impl<'a> Resolver<'a> {\n             self.record_use(target, dummy_binding, false);\n         } else if import.imported_module.get().is_none() {\n             import.used.set(true);\n-            self.used_imports.insert(import.id);\n+            if let Some(id) = import.id() {\n+                self.used_imports.insert(id);\n+            }\n         }\n     }\n }\n@@ -718,47 +741,51 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             PathResult::Indeterminate => unreachable!(),\n         };\n \n-        let (ident, target, source_bindings, target_bindings, type_ns_only) = match import.kind {\n-            ImportKind::Single {\n-                source,\n-                target,\n-                ref source_bindings,\n-                ref target_bindings,\n-                type_ns_only,\n-                ..\n-            } => (source, target, source_bindings, target_bindings, type_ns_only),\n-            ImportKind::Glob { is_prelude, ref max_vis } => {\n-                if import.module_path.len() <= 1 {\n-                    // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n-                    // 2 segments, so the `resolve_path` above won't trigger it.\n-                    let mut full_path = import.module_path.clone();\n-                    full_path.push(Segment::from_ident(Ident::empty()));\n-                    self.r.lint_if_path_starts_with_module(Some(finalize), &full_path, None);\n-                }\n+        let (ident, target, source_bindings, target_bindings, type_ns_only, import_id) =\n+            match import.kind {\n+                ImportKind::Single {\n+                    source,\n+                    target,\n+                    ref source_bindings,\n+                    ref target_bindings,\n+                    type_ns_only,\n+                    id,\n+                    ..\n+                } => (source, target, source_bindings, target_bindings, type_ns_only, id),\n+                ImportKind::Glob { is_prelude, ref max_vis, id } => {\n+                    if import.module_path.len() <= 1 {\n+                        // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n+                        // 2 segments, so the `resolve_path` above won't trigger it.\n+                        let mut full_path = import.module_path.clone();\n+                        full_path.push(Segment::from_ident(Ident::empty()));\n+                        self.r.lint_if_path_starts_with_module(Some(finalize), &full_path, None);\n+                    }\n \n-                if let ModuleOrUniformRoot::Module(module) = module {\n-                    if ptr::eq(module, import.parent_scope.module) {\n-                        // Importing a module into itself is not allowed.\n-                        return Some(UnresolvedImportError {\n-                            span: import.span,\n-                            label: Some(String::from(\"cannot glob-import a module into itself\")),\n-                            note: None,\n-                            suggestion: None,\n-                            candidate: None,\n-                        });\n+                    if let ModuleOrUniformRoot::Module(module) = module {\n+                        if ptr::eq(module, import.parent_scope.module) {\n+                            // Importing a module into itself is not allowed.\n+                            return Some(UnresolvedImportError {\n+                                span: import.span,\n+                                label: Some(String::from(\n+                                    \"cannot glob-import a module into itself\",\n+                                )),\n+                                note: None,\n+                                suggestion: None,\n+                                candidate: None,\n+                            });\n+                        }\n                     }\n-                }\n-                if !is_prelude\n+                    if !is_prelude\n                     && let Some(max_vis) = max_vis.get()\n                     && !max_vis.is_at_least(import.expect_vis(), &*self.r)\n                 {\n                     let msg = \"glob import doesn't reexport anything because no candidate is public enough\";\n-                    self.r.lint_buffer.buffer_lint(UNUSED_IMPORTS, import.id, import.span, msg);\n+                    self.r.lint_buffer.buffer_lint(UNUSED_IMPORTS, id, import.span, msg);\n                 }\n-                return None;\n-            }\n-            _ => unreachable!(),\n-        };\n+                    return None;\n+                }\n+                _ => unreachable!(),\n+            };\n \n         let mut all_ns_err = true;\n         self.r.per_ns(|this, ns| {\n@@ -858,7 +885,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                         match binding.kind {\n                                             // Never suggest the name that has binding error\n                                             // i.e., the name that cannot be previously resolved\n-                                            NameBindingKind::Res(Res::Err, _) => None,\n+                                            NameBindingKind::Res(Res::Err) => None,\n                                             _ => Some(i.name),\n                                         }\n                                     }\n@@ -960,7 +987,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 );\n                 self.r.lint_buffer.buffer_lint(\n                     PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n-                    import.id,\n+                    import_id,\n                     import.span,\n                     &msg,\n                 );\n@@ -989,7 +1016,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     let mut err =\n                         struct_span_err!(self.r.session, import.span, E0364, \"{error_msg}\");\n                     match binding.kind {\n-                        NameBindingKind::Res(Res::Def(DefKind::Macro(_), def_id), _)\n+                        NameBindingKind::Res(Res::Def(DefKind::Macro(_), def_id))\n                             // exclude decl_macro\n                             if self.r.get_macro_by_def_id(def_id).macro_rules =>\n                         {\n@@ -1029,7 +1056,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         // purposes it's good enough to just favor one over the other.\n         self.r.per_ns(|this, ns| {\n             if let Ok(binding) = source_bindings[ns].get() {\n-                this.import_res_map.entry(import.id).or_default()[ns] = Some(binding.res());\n+                this.import_res_map.entry(import_id).or_default()[ns] = Some(binding.res());\n             }\n         });\n \n@@ -1047,6 +1074,9 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         target_bindings: &PerNS<Cell<Option<&'b NameBinding<'b>>>>,\n         target: Ident,\n     ) {\n+        // This function is only called for single imports.\n+        let ImportKind::Single { id, .. } = import.kind else { unreachable!() };\n+\n         // Skip if the import was produced by a macro.\n         if import.parent_scope.expansion != LocalExpnId::ROOT {\n             return;\n@@ -1094,7 +1124,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             redundant_spans.dedup();\n             self.r.lint_buffer.buffer_lint_with_diagnostic(\n                 UNUSED_IMPORTS,\n-                import.id,\n+                id,\n                 import.span,\n                 &format!(\"the item `{}` is imported redundantly\", ident),\n                 BuiltinLintDiagnostics::RedundantImport(redundant_spans, ident),\n@@ -1103,6 +1133,9 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     }\n \n     fn resolve_glob_import(&mut self, import: &'b Import<'b>) {\n+        // This function is only called for glob imports.\n+        let ImportKind::Glob { id, is_prelude, .. } = import.kind else { unreachable!() };\n+\n         let ModuleOrUniformRoot::Module(module) = import.imported_module.get().unwrap() else {\n             self.r.session.span_err(import.span, \"cannot glob-import all possible crates\");\n             return;\n@@ -1113,7 +1146,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             return;\n         } else if ptr::eq(module, import.parent_scope.module) {\n             return;\n-        } else if let ImportKind::Glob { is_prelude: true, .. } = import.kind {\n+        } else if is_prelude {\n             self.r.prelude = Some(module);\n             return;\n         }\n@@ -1145,7 +1178,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         }\n \n         // Record the destination of this import\n-        self.r.record_partial_res(import.id, PartialRes::new(module.res().unwrap()));\n+        self.r.record_partial_res(id, PartialRes::new(module.res().unwrap()));\n     }\n \n     // Miscellaneous post-processing, including recording re-exports,\n@@ -1204,5 +1237,6 @@ fn import_kind_to_string(import_kind: &ImportKind<'_>) -> String {\n         ImportKind::Glob { .. } => \"*\".to_string(),\n         ImportKind::ExternCrate { .. } => \"<extern crate>\".to_string(),\n         ImportKind::MacroUse => \"#[macro_use]\".to_string(),\n+        ImportKind::MacroExport => \"#[macro_export]\".to_string(),\n     }\n }"}, {"sha": "ee1c97d5ad2b7925875e30bf0f3a74fb16094417", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/68afa32985f5976cffe856043abbe72656546820/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68afa32985f5976cffe856043abbe72656546820/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=68afa32985f5976cffe856043abbe72656546820", "patch": "@@ -644,7 +644,7 @@ impl<'a> ToNameBinding<'a> for &'a NameBinding<'a> {\n \n #[derive(Clone, Debug)]\n enum NameBindingKind<'a> {\n-    Res(Res, /* is_macro_export */ bool),\n+    Res(Res),\n     Module(Module<'a>),\n     Import { binding: &'a NameBinding<'a>, import: &'a Import<'a>, used: Cell<bool> },\n }\n@@ -743,7 +743,7 @@ impl<'a> NameBinding<'a> {\n \n     fn res(&self) -> Res {\n         match self.kind {\n-            NameBindingKind::Res(res, _) => res,\n+            NameBindingKind::Res(res) => res,\n             NameBindingKind::Module(module) => module.res().unwrap(),\n             NameBindingKind::Import { binding, .. } => binding.res(),\n         }\n@@ -760,10 +760,10 @@ impl<'a> NameBinding<'a> {\n     fn is_possibly_imported_variant(&self) -> bool {\n         match self.kind {\n             NameBindingKind::Import { binding, .. } => binding.is_possibly_imported_variant(),\n-            NameBindingKind::Res(\n-                Res::Def(DefKind::Variant | DefKind::Ctor(CtorOf::Variant, ..), _),\n+            NameBindingKind::Res(Res::Def(\n+                DefKind::Variant | DefKind::Ctor(CtorOf::Variant, ..),\n                 _,\n-            ) => true,\n+            )) => true,\n             NameBindingKind::Res(..) | NameBindingKind::Module(..) => false,\n         }\n     }\n@@ -786,6 +786,13 @@ impl<'a> NameBinding<'a> {\n         matches!(self.kind, NameBindingKind::Import { .. })\n     }\n \n+    /// The binding introduced by `#[macro_export] macro_rules` is a public import, but it might\n+    /// not be perceived as such by users, so treat it as a non-import in some diagnostics.\n+    fn is_import_user_facing(&self) -> bool {\n+        matches!(self.kind, NameBindingKind::Import { import, .. }\n+            if !matches!(import.kind, ImportKind::MacroExport))\n+    }\n+\n     fn is_glob_import(&self) -> bool {\n         match self.kind {\n             NameBindingKind::Import { import, .. } => import.is_glob(),\n@@ -1281,7 +1288,7 @@ impl<'a> Resolver<'a> {\n \n             arenas,\n             dummy_binding: arenas.alloc_name_binding(NameBinding {\n-                kind: NameBindingKind::Res(Res::Err, false),\n+                kind: NameBindingKind::Res(Res::Err),\n                 ambiguity: None,\n                 expansion: LocalExpnId::ROOT,\n                 span: DUMMY_SP,\n@@ -1611,10 +1618,12 @@ impl<'a> Resolver<'a> {\n     ) -> SmallVec<[LocalDefId; 1]> {\n         let mut import_ids = smallvec![];\n         while let NameBindingKind::Import { import, binding, .. } = kind {\n-            let id = self.local_def_id(import.id);\n-            self.maybe_unused_trait_imports.insert(id);\n+            if let Some(node_id) = import.id() {\n+                let def_id = self.local_def_id(node_id);\n+                self.maybe_unused_trait_imports.insert(def_id);\n+                import_ids.push(def_id);\n+            }\n             self.add_to_glob_map(&import, trait_name);\n-            import_ids.push(id);\n             kind = &binding.kind;\n         }\n         import_ids\n@@ -1681,16 +1690,18 @@ impl<'a> Resolver<'a> {\n             }\n             used.set(true);\n             import.used.set(true);\n-            self.used_imports.insert(import.id);\n+            if let Some(id) = import.id() {\n+                self.used_imports.insert(id);\n+            }\n             self.add_to_glob_map(&import, ident);\n             self.record_use(ident, binding, false);\n         }\n     }\n \n     #[inline]\n     fn add_to_glob_map(&mut self, import: &Import<'_>, ident: Ident) {\n-        if import.is_glob() {\n-            let def_id = self.local_def_id(import.id);\n+        if let ImportKind::Glob { id, .. } = import.kind {\n+            let def_id = self.local_def_id(id);\n             self.glob_map.entry(def_id).or_default().insert(ident.name);\n         }\n     }\n@@ -1992,11 +2003,7 @@ impl<'a> Resolver<'a> {\n \n     // Items that go to reexport table encoded to metadata and visible through it to other crates.\n     fn is_reexport(&self, binding: &NameBinding<'a>) -> Option<def::Res<!>> {\n-        // FIXME: Consider changing the binding inserted by `#[macro_export] macro_rules`\n-        // into the crate root to actual `NameBindingKind::Import`.\n-        if binding.is_import()\n-            || matches!(binding.kind, NameBindingKind::Res(_, _is_macro_export @ true))\n-        {\n+        if binding.is_import() {\n             let res = binding.res().expect_non_local();\n             // Ambiguous imports are treated as errors at this point and are\n             // not exposed to other crates (see #36837 for more details)."}, {"sha": "85ed97663e8a0db7ff00411033bf8a9faff680d2", "filename": "src/test/ui/macros/issue-38715.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/68afa32985f5976cffe856043abbe72656546820/src%2Ftest%2Fui%2Fmacros%2Fissue-38715.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68afa32985f5976cffe856043abbe72656546820/src%2Ftest%2Fui%2Fmacros%2Fissue-38715.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-38715.rs?ref=68afa32985f5976cffe856043abbe72656546820", "patch": "@@ -1,7 +1,17 @@\n #[macro_export]\n-macro_rules! foo { ($i:ident) => {} }\n+macro_rules! foo { () => {} }\n \n #[macro_export]\n macro_rules! foo { () => {} } //~ ERROR the name `foo` is defined multiple times\n \n+mod inner1 {\n+    #[macro_export]\n+    macro_rules! bar { () => {} }\n+}\n+\n+mod inner2 {\n+    #[macro_export]\n+    macro_rules! bar { () => {} } //~ ERROR the name `bar` is defined multiple times\n+}\n+\n fn main() {}"}, {"sha": "828a7f459301fce6e8f21b190107e42fc931a6b9", "filename": "src/test/ui/macros/issue-38715.stderr", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/68afa32985f5976cffe856043abbe72656546820/src%2Ftest%2Fui%2Fmacros%2Fissue-38715.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/68afa32985f5976cffe856043abbe72656546820/src%2Ftest%2Fui%2Fmacros%2Fissue-38715.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-38715.stderr?ref=68afa32985f5976cffe856043abbe72656546820", "patch": "@@ -1,14 +1,25 @@\n error[E0428]: the name `foo` is defined multiple times\n   --> $DIR/issue-38715.rs:5:1\n    |\n-LL | macro_rules! foo { ($i:ident) => {} }\n+LL | macro_rules! foo { () => {} }\n    | ---------------- previous definition of the macro `foo` here\n ...\n LL | macro_rules! foo { () => {} }\n    | ^^^^^^^^^^^^^^^^ `foo` redefined here\n    |\n    = note: `foo` must be defined only once in the macro namespace of this module\n \n-error: aborting due to previous error\n+error[E0428]: the name `bar` is defined multiple times\n+  --> $DIR/issue-38715.rs:14:5\n+   |\n+LL |     macro_rules! bar { () => {} }\n+   |     ---------------- previous definition of the macro `bar` here\n+...\n+LL |     macro_rules! bar { () => {} }\n+   |     ^^^^^^^^^^^^^^^^ `bar` redefined here\n+   |\n+   = note: `bar` must be defined only once in the macro namespace of this module\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0428`."}, {"sha": "c1f9ee8dfdf73e1081e3841e9a8e8d26b4c41676", "filename": "src/test/ui/privacy/effective_visibilities.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68afa32985f5976cffe856043abbe72656546820/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68afa32985f5976cffe856043abbe72656546820/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.rs?ref=68afa32985f5976cffe856043abbe72656546820", "patch": "@@ -38,13 +38,13 @@ mod outer { //~ ERROR Direct: pub(crate), Reexported: pub(crate), Reachable: pub\n     }\n \n     #[rustc_effective_visibility]\n-    macro_rules! none_macro { //~ Direct: pub(crate), Reexported: pub(crate), Reachable: pub(crate), ReachableThroughImplTrait: pub(crate)\n+    macro_rules! none_macro { //~ ERROR not in the table\n         () => {};\n     }\n \n     #[macro_export]\n     #[rustc_effective_visibility]\n-    macro_rules! public_macro { //~ Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+    macro_rules! public_macro { //~ ERROR Direct: pub(self), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n         () => {};\n     }\n "}, {"sha": "5a8f7db38fc8a4db83fd53df3a1bf958b507ae7a", "filename": "src/test/ui/privacy/effective_visibilities.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68afa32985f5976cffe856043abbe72656546820/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/68afa32985f5976cffe856043abbe72656546820/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.stderr?ref=68afa32985f5976cffe856043abbe72656546820", "patch": "@@ -64,13 +64,13 @@ error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImpl\n LL |                 PubUnion,\n    |                 ^^^^^^^^\n \n-error: Direct: pub(crate), Reexported: pub(crate), Reachable: pub(crate), ReachableThroughImplTrait: pub(crate)\n+error: not in the table\n   --> $DIR/effective_visibilities.rs:41:5\n    |\n LL |     macro_rules! none_macro {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+error: Direct: pub(self), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n   --> $DIR/effective_visibilities.rs:47:5\n    |\n LL |     macro_rules! public_macro {"}]}