{"sha": "550939f654f08bfb25723f0fb4cbee0871dfb063", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1MDkzOWY2NTRmMDhiZmIyNTcyM2YwZmI0Y2JlZTA4NzFkZmIwNjM=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-04T13:37:15Z"}, "committer": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-19T14:54:20Z"}, "message": "Move error structs to new mod", "tree": {"sha": "a6de3533bc364c391e26ce29614d6cc12bb66b2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6de3533bc364c391e26ce29614d6cc12bb66b2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/550939f654f08bfb25723f0fb4cbee0871dfb063", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/550939f654f08bfb25723f0fb4cbee0871dfb063", "html_url": "https://github.com/rust-lang/rust/commit/550939f654f08bfb25723f0fb4cbee0871dfb063", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/550939f654f08bfb25723f0fb4cbee0871dfb063/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7125a481ce16fba90f833d4f2d9650d032229a83", "url": "https://api.github.com/repos/rust-lang/rust/commits/7125a481ce16fba90f833d4f2d9650d032229a83", "html_url": "https://github.com/rust-lang/rust/commit/7125a481ce16fba90f833d4f2d9650d032229a83"}], "stats": {"total": 336, "additions": 174, "deletions": 162}, "files": [{"sha": "aab171551861178ca6f0e65bf569d583156bc13d", "filename": "library/core/src/num/error.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/550939f654f08bfb25723f0fb4cbee0871dfb063/library%2Fcore%2Fsrc%2Fnum%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/550939f654f08bfb25723f0fb4cbee0871dfb063/library%2Fcore%2Fsrc%2Fnum%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ferror.rs?ref=550939f654f08bfb25723f0fb4cbee0871dfb063", "patch": "@@ -0,0 +1,151 @@\n+//! Error types for conversion to integral types.\n+\n+use crate::convert::Infallible;\n+use crate::fmt;\n+\n+/// The error type returned when a checked integral type conversion fails.\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub struct TryFromIntError(pub(crate) ());\n+\n+impl TryFromIntError {\n+    #[unstable(\n+        feature = \"int_error_internals\",\n+        reason = \"available through Error trait and this method should \\\n+                  not be exposed publicly\",\n+        issue = \"none\"\n+    )]\n+    #[doc(hidden)]\n+    pub fn __description(&self) -> &str {\n+        \"out of range integral type conversion attempted\"\n+    }\n+}\n+\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n+impl fmt::Display for TryFromIntError {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.__description().fmt(fmt)\n+    }\n+}\n+\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n+impl From<Infallible> for TryFromIntError {\n+    fn from(x: Infallible) -> TryFromIntError {\n+        match x {}\n+    }\n+}\n+\n+#[unstable(feature = \"never_type\", issue = \"35121\")]\n+impl From<!> for TryFromIntError {\n+    fn from(never: !) -> TryFromIntError {\n+        // Match rather than coerce to make sure that code like\n+        // `From<Infallible> for TryFromIntError` above will keep working\n+        // when `Infallible` becomes an alias to `!`.\n+        match never {}\n+    }\n+}\n+\n+/// An error which can be returned when parsing an integer.\n+///\n+/// This error is used as the error type for the `from_str_radix()` functions\n+/// on the primitive integer types, such as [`i8::from_str_radix`].\n+///\n+/// # Potential causes\n+///\n+/// Among other causes, `ParseIntError` can be thrown because of leading or trailing whitespace\n+/// in the string e.g., when it is obtained from the standard input.\n+/// Using the [`str.trim()`] method ensures that no whitespace remains before parsing.\n+///\n+/// [`str.trim()`]: ../../std/primitive.str.html#method.trim\n+/// [`i8::from_str_radix`]: ../../std/primitive.i8.html#method.from_str_radix\n+///\n+/// # Example\n+///\n+/// ```\n+/// if let Err(e) = i32::from_str_radix(\"a12\", 10) {\n+///     println!(\"Failed conversion to i32: {}\", e);\n+/// }\n+/// ```\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct ParseIntError {\n+    pub(super) kind: IntErrorKind,\n+}\n+\n+/// Enum to store the various types of errors that can cause parsing an integer to fail.\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(int_error_matching)]\n+///\n+/// # fn main() {\n+/// if let Err(e) = i32::from_str_radix(\"a12\", 10) {\n+///     println!(\"Failed conversion to i32: {:?}\", e.kind());\n+/// }\n+/// # }\n+/// ```\n+#[unstable(\n+    feature = \"int_error_matching\",\n+    reason = \"it can be useful to match errors when making error messages \\\n+              for integer parsing\",\n+    issue = \"22639\"\n+)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+#[non_exhaustive]\n+pub enum IntErrorKind {\n+    /// Value being parsed is empty.\n+    ///\n+    /// Among other causes, this variant will be constructed when parsing an empty string.\n+    Empty,\n+    /// Contains an invalid digit.\n+    ///\n+    /// Among other causes, this variant will be constructed when parsing a string that\n+    /// contains a letter.\n+    InvalidDigit,\n+    /// Integer is too large to store in target integer type.\n+    Overflow,\n+    /// Integer is too small to store in target integer type.\n+    Underflow,\n+    /// Value was Zero\n+    ///\n+    /// This variant will be emitted when the parsing string has a value of zero, which\n+    /// would be illegal for non-zero types.\n+    Zero,\n+}\n+\n+impl ParseIntError {\n+    /// Outputs the detailed cause of parsing an integer failing.\n+    #[unstable(\n+        feature = \"int_error_matching\",\n+        reason = \"it can be useful to match errors when making error messages \\\n+                  for integer parsing\",\n+        issue = \"22639\"\n+    )]\n+    pub fn kind(&self) -> &IntErrorKind {\n+        &self.kind\n+    }\n+    #[unstable(\n+        feature = \"int_error_internals\",\n+        reason = \"available through Error trait and this method should \\\n+                  not be exposed publicly\",\n+        issue = \"none\"\n+    )]\n+    #[doc(hidden)]\n+    pub fn __description(&self) -> &str {\n+        match self.kind {\n+            IntErrorKind::Empty => \"cannot parse integer from empty string\",\n+            IntErrorKind::InvalidDigit => \"invalid digit found in string\",\n+            IntErrorKind::Overflow => \"number too large to fit in target type\",\n+            IntErrorKind::Underflow => \"number too small to fit in target type\",\n+            IntErrorKind::Zero => \"number would be zero for non-zero type\",\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for ParseIntError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.__description().fmt(f)\n+    }\n+}"}, {"sha": "adcdee4219fe1741bdebe237598b002eb6f491c9", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 23, "deletions": 162, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/550939f654f08bfb25723f0fb4cbee0871dfb063/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/550939f654f08bfb25723f0fb4cbee0871dfb063/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=550939f654f08bfb25723f0fb4cbee0871dfb063", "patch": "@@ -4,8 +4,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::convert::Infallible;\n-use crate::fmt;\n use crate::intrinsics;\n use crate::mem;\n use crate::str::FromStr;\n@@ -40,18 +38,31 @@ pub mod dec2flt;\n pub mod diy_float;\n pub mod flt2dec;\n \n+mod error;\n mod nonzero;\n mod wrapping;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use wrapping::Wrapping;\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use dec2flt::ParseFloatError;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use error::ParseIntError;\n+\n #[stable(feature = \"nonzero\", since = \"1.28.0\")]\n pub use nonzero::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize};\n \n #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")]\n pub use nonzero::{NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize};\n \n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n+pub use error::TryFromIntError;\n+\n+#[unstable(feature = \"int_error_matching\", issue = \"22639\")]\n+pub use error::IntErrorKind;\n+\n macro_rules! usize_isize_to_xe_bytes_doc {\n     () => {\n         \"\n@@ -4904,6 +4915,16 @@ pub enum FpCategory {\n     Normal,\n }\n \n+#[doc(hidden)]\n+trait FromStrRadixHelper: PartialOrd + Copy {\n+    fn min_value() -> Self;\n+    fn max_value() -> Self;\n+    fn from_u32(u: u32) -> Self;\n+    fn checked_mul(&self, other: u32) -> Option<Self>;\n+    fn checked_sub(&self, other: u32) -> Option<Self>;\n+    fn checked_add(&self, other: u32) -> Option<Self>;\n+}\n+\n macro_rules! from_str_radix_int_impl {\n     ($($t:ty)*) => {$(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -4917,58 +4938,6 @@ macro_rules! from_str_radix_int_impl {\n }\n from_str_radix_int_impl! { isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128 }\n \n-/// The error type returned when a checked integral type conversion fails.\n-#[stable(feature = \"try_from\", since = \"1.34.0\")]\n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub struct TryFromIntError(pub(crate) ());\n-\n-impl TryFromIntError {\n-    #[unstable(\n-        feature = \"int_error_internals\",\n-        reason = \"available through Error trait and this method should \\\n-                  not be exposed publicly\",\n-        issue = \"none\"\n-    )]\n-    #[doc(hidden)]\n-    pub fn __description(&self) -> &str {\n-        \"out of range integral type conversion attempted\"\n-    }\n-}\n-\n-#[stable(feature = \"try_from\", since = \"1.34.0\")]\n-impl fmt::Display for TryFromIntError {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.__description().fmt(fmt)\n-    }\n-}\n-\n-#[stable(feature = \"try_from\", since = \"1.34.0\")]\n-impl From<Infallible> for TryFromIntError {\n-    fn from(x: Infallible) -> TryFromIntError {\n-        match x {}\n-    }\n-}\n-\n-#[unstable(feature = \"never_type\", issue = \"35121\")]\n-impl From<!> for TryFromIntError {\n-    fn from(never: !) -> TryFromIntError {\n-        // Match rather than coerce to make sure that code like\n-        // `From<Infallible> for TryFromIntError` above will keep working\n-        // when `Infallible` becomes an alias to `!`.\n-        match never {}\n-    }\n-}\n-\n-#[doc(hidden)]\n-trait FromStrRadixHelper: PartialOrd + Copy {\n-    fn min_value() -> Self;\n-    fn max_value() -> Self;\n-    fn from_u32(u: u32) -> Self;\n-    fn checked_mul(&self, other: u32) -> Option<Self>;\n-    fn checked_sub(&self, other: u32) -> Option<Self>;\n-    fn checked_add(&self, other: u32) -> Option<Self>;\n-}\n-\n macro_rules! doit {\n     ($($t:ty)*) => ($(impl FromStrRadixHelper for $t {\n         #[inline]\n@@ -5061,111 +5030,3 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, Par\n     }\n     Ok(result)\n }\n-\n-/// An error which can be returned when parsing an integer.\n-///\n-/// This error is used as the error type for the `from_str_radix()` functions\n-/// on the primitive integer types, such as [`i8::from_str_radix`].\n-///\n-/// # Potential causes\n-///\n-/// Among other causes, `ParseIntError` can be thrown because of leading or trailing whitespace\n-/// in the string e.g., when it is obtained from the standard input.\n-/// Using the [`str.trim()`] method ensures that no whitespace remains before parsing.\n-///\n-/// [`str.trim()`]: ../../std/primitive.str.html#method.trim\n-/// [`i8::from_str_radix`]: ../../std/primitive.i8.html#method.from_str_radix\n-///\n-/// # Example\n-///\n-/// ```\n-/// if let Err(e) = i32::from_str_radix(\"a12\", 10) {\n-///     println!(\"Failed conversion to i32: {}\", e);\n-/// }\n-/// ```\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct ParseIntError {\n-    kind: IntErrorKind,\n-}\n-\n-/// Enum to store the various types of errors that can cause parsing an integer to fail.\n-///\n-/// # Example\n-///\n-/// ```\n-/// #![feature(int_error_matching)]\n-///\n-/// # fn main() {\n-/// if let Err(e) = i32::from_str_radix(\"a12\", 10) {\n-///     println!(\"Failed conversion to i32: {:?}\", e.kind());\n-/// }\n-/// # }\n-/// ```\n-#[unstable(\n-    feature = \"int_error_matching\",\n-    reason = \"it can be useful to match errors when making error messages \\\n-              for integer parsing\",\n-    issue = \"22639\"\n-)]\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-#[non_exhaustive]\n-pub enum IntErrorKind {\n-    /// Value being parsed is empty.\n-    ///\n-    /// Among other causes, this variant will be constructed when parsing an empty string.\n-    Empty,\n-    /// Contains an invalid digit.\n-    ///\n-    /// Among other causes, this variant will be constructed when parsing a string that\n-    /// contains a letter.\n-    InvalidDigit,\n-    /// Integer is too large to store in target integer type.\n-    Overflow,\n-    /// Integer is too small to store in target integer type.\n-    Underflow,\n-    /// Value was Zero\n-    ///\n-    /// This variant will be emitted when the parsing string has a value of zero, which\n-    /// would be illegal for non-zero types.\n-    Zero,\n-}\n-\n-impl ParseIntError {\n-    /// Outputs the detailed cause of parsing an integer failing.\n-    #[unstable(\n-        feature = \"int_error_matching\",\n-        reason = \"it can be useful to match errors when making error messages \\\n-                  for integer parsing\",\n-        issue = \"22639\"\n-    )]\n-    pub fn kind(&self) -> &IntErrorKind {\n-        &self.kind\n-    }\n-    #[unstable(\n-        feature = \"int_error_internals\",\n-        reason = \"available through Error trait and this method should \\\n-                  not be exposed publicly\",\n-        issue = \"none\"\n-    )]\n-    #[doc(hidden)]\n-    pub fn __description(&self) -> &str {\n-        match self.kind {\n-            IntErrorKind::Empty => \"cannot parse integer from empty string\",\n-            IntErrorKind::InvalidDigit => \"invalid digit found in string\",\n-            IntErrorKind::Overflow => \"number too large to fit in target type\",\n-            IntErrorKind::Underflow => \"number too small to fit in target type\",\n-            IntErrorKind::Zero => \"number would be zero for non-zero type\",\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for ParseIntError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.__description().fmt(f)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use crate::num::dec2flt::ParseFloatError;"}]}