{"sha": "e1cb9ba221e5cb0070ac82c6a234af11e4240680", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxY2I5YmEyMjFlNWNiMDA3MGFjODJjNmEyMzRhZjExZTQyNDA2ODA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-28T07:59:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-28T07:59:25Z"}, "message": "Auto merge of #40008 - eddyb:lazy-12, r=nikomatsakis\n\n[12/12] On-demand type-checking, const-evaluation, MIR building & const-qualification.\n\n_This is the last of a series ([prev](https://github.com/rust-lang/rust/pull/38813)) of patches designed to rework rustc into an out-of-order on-demand pipeline model for both better feature support (e.g. [MIR-based](https://github.com/solson/miri) early constant evaluation) and incremental execution of compiler passes (e.g. type-checking), with beneficial consequences to IDE support as well.\nIf any motivation is unclear, please ask for additional PR description clarifications or code comments._\n\n<hr>\n\nAs this contains all of the changes that didn't fit neatly into other PRs, I'll be elaborating a bit:\n\n### User-facing changes\n* when determining whether an `impl Trait` type implements an auto-trait (e.g. `Send` or `Sync`), the function the `impl Trait` came from has to be inferred and type-checking, disallowing cycles\n  * this results from not having an obvious place to put the \"deferred obligation\" in on-demand atm\n  * while we could model side-effects like that and \"post-processing passes\" better, it's still more limiting than being able to know the result in the original function (e.g. specialization) *and* there are serious problems around region-checking (if a `Send` impl required `'static`, it wasn't enforced)\n* early const-eval requires type-checking and const-qualification to be performed first, which means:\n  * you get the intended errors before (if any) constant evaluation error that is simply fallout\n  * associated consts should always work now, and `const fn` type parameters are properly tracked\n    * don't get too excited, array lengths still can't depend on type parameters\n* #38864 works as intended now, with `Self` being allowed in `impl` bounds\n* #32205 is largely improved, with associated types being limited to \"exact match\" `impl`s (as opposed to traversing the specialization graph to resolve unspecified type parameters to their defaults in another `impl` or in the `trait`) *while* checking for overlaps building the specialization graph for that trait - once all the trait impls' have been checked for coherence (including ahead-of-time/on-demand), it's uniform\n* [crater report](https://gist.github.com/eddyb/bbb869072468c7e08d6d808e75938051) looks clean (aside from `clippy` which broke due to `rustc` internal changes)\n\n### Compiler-internal changes\n* `ty::Generics`\n  * no longer contains the actual type parameter defaults, instead they're associated with the type parameter's `DefId`, like associated types in a trait definition\n    * this allows computing `ty::Generics` as a leaf (reading only its own HIR)\n  * holds a mapping from `DefIndex` of type parameters to their indices\n* `ty::AdtDef`\n  * only tracks `#[repr(simd)]` in its `ReprOptions` `repr` field\n  * doesn't contain `enum` discriminant values, but instead each variant either refers to either an explicit value for its discriminant, or the distance from the last explicit discriminant, if any\n    * the `.discriminants(tcx)` method produces an iterator of `ConstInt` values, looking up explicit discriminants in a separate map, if necessary\n    * this allows computing `ty::AdtDef` as a leaf (reading only its own HIR)\n* Small note: the two above (`Generics`, `AdtDef`), `TraitDef` and `AssociatedItem` should probably end up as part of the HIR, eventually, as they're trivially constructed from it\n* `ty::FnSig`\n  * now also holds ABI and unsafety, alongside argument types, return type and C variadicity\n  * `&ty::BareFnTy` and `ty::ClosureTy` have been replaced with `PolyFnSig = Binder<FnSig>`\n    * `BareFnTy` was interned and `ClosureTy` was treated as non-trivial to `Clone` because they had a `PolyFnSig` and so used to contain a `Vec<Ty>` (now `&[Ty]`)\n* `ty::maps`\n  * all the `DepTrackingMap`s have been grouped in a structure available at `tcx.maps`\n  * when creating the `tcx`, a set of `Providers` (one `fn` pointer per map) is required for the local crate, and one for all other crates (i.e. metadata loading), `librustc_driver` plugging the various crates (e.g. `librustc_metadata`, `librustc_typeck`, `librustc_mir`) into it\n  * when a map is queried and the value is missing, the appropriate `fn` pointer from the `Providers` of that crate is called with the `TyCtxt` and the key being queried, to produce the value on-demand\n* `rustc_const_eval`\n  * demands both `typeck_tables` and `mir_const_qualif` (in preparation for miri)\n  * tracks `Substs` in `ConstVal::Function` for `const fn` calls\n  * returns `TypeckError` if type-checking has failed (or cases that can only be reached if it had)\n    * this error kind is never reported, resulting in less noisy/redundant diagnostics\n  * fixes #39548 (testcase by @larsluthman, taken from #39812, which this supersedes)\n* on-demand has so far been hooked up to:\n  * `rustc_metadata::cstore_impl`: `ty`, `generics`, `predicates`, `super_predicates`, `trait_def`, `adt_def`, `variances`, `associated_item_def_ids`, `associated_item`, `impl_trait_ref`, `custom_coerce_unsized_kind`, `mir`, `mir_const_qualif`, `typeck_tables`, `closure_kind`, `closure_type`\n  * `rustc_typeck::collect`: `ty`, `generics`, `predicates`, `super_predicates`, `type_param_predicates`, `trait_def`, `adt_def`, `impl_trait_ref`\n  * `rustc_typeck::coherence`: `coherent_trait`, `coherent_inherent_impls`\n  * `rustc_typeck::check`: `typeck_tables`, `closure_type`, `closure_kind`\n  * `rustc_mir::mir_map`: `mir`\n  * `rustc_mir::transform::qualify_consts`: `mir_const_qualif`", "tree": {"sha": "534e3817216f3118e5f07a18acfcd0a9e937f829", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/534e3817216f3118e5f07a18acfcd0a9e937f829"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1cb9ba221e5cb0070ac82c6a234af11e4240680", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1cb9ba221e5cb0070ac82c6a234af11e4240680", "html_url": "https://github.com/rust-lang/rust/commit/e1cb9ba221e5cb0070ac82c6a234af11e4240680", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1cb9ba221e5cb0070ac82c6a234af11e4240680/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b4d54ab88fd522b2f02d7079c601ddec047eba8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b4d54ab88fd522b2f02d7079c601ddec047eba8", "html_url": "https://github.com/rust-lang/rust/commit/3b4d54ab88fd522b2f02d7079c601ddec047eba8"}, {"sha": "f702b20dfd22990a326af9221cb3ed9b389c8307", "url": "https://api.github.com/repos/rust-lang/rust/commits/f702b20dfd22990a326af9221cb3ed9b389c8307", "html_url": "https://github.com/rust-lang/rust/commit/f702b20dfd22990a326af9221cb3ed9b389c8307"}], "stats": {"total": 10888, "additions": 4934, "deletions": 5954}, "files": [{"sha": "e0233d6f8b98cd1bf818a8766f58da2781a6919c", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -70,6 +70,7 @@ pub enum DepNode<D: Clone + Debug> {\n     Resolve,\n     EntryPoint,\n     CheckEntryFn,\n+    CoherenceCheckTrait(D),\n     CoherenceCheckImpl(D),\n     CoherenceOverlapCheck(D),\n     CoherenceOverlapCheckSpecial(D),\n@@ -109,11 +110,13 @@ pub enum DepNode<D: Clone + Debug> {\n     // predicates for an item wind up in `ItemSignature`).\n     AssociatedItems(D),\n     ItemSignature(D),\n+    TypeParamPredicates((D, D)),\n     SizedConstraint(D),\n     AssociatedItemDefIds(D),\n     InherentImpls(D),\n     TypeckTables(D),\n     UsedTraitImports(D),\n+    MonomorphicConstEval(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -239,6 +242,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             MetaData(ref d) => op(d).map(MetaData),\n             CollectItem(ref d) => op(d).map(CollectItem),\n             CollectItemSig(ref d) => op(d).map(CollectItemSig),\n+            CoherenceCheckTrait(ref d) => op(d).map(CoherenceCheckTrait),\n             CoherenceCheckImpl(ref d) => op(d).map(CoherenceCheckImpl),\n             CoherenceOverlapCheck(ref d) => op(d).map(CoherenceOverlapCheck),\n             CoherenceOverlapCheckSpecial(ref d) => op(d).map(CoherenceOverlapCheckSpecial),\n@@ -258,11 +262,15 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransInlinedItem(ref d) => op(d).map(TransInlinedItem),\n             AssociatedItems(ref d) => op(d).map(AssociatedItems),\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n+            TypeParamPredicates((ref item, ref param)) => {\n+                Some(TypeParamPredicates((try_opt!(op(item)), try_opt!(op(param)))))\n+            }\n             SizedConstraint(ref d) => op(d).map(SizedConstraint),\n             AssociatedItemDefIds(ref d) => op(d).map(AssociatedItemDefIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),\n             TypeckTables(ref d) => op(d).map(TypeckTables),\n             UsedTraitImports(ref d) => op(d).map(UsedTraitImports),\n+            MonomorphicConstEval(ref d) => op(d).map(MonomorphicConstEval),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),"}, {"sha": "9f45e66f0d937116c255fc65484d64086a67c82b", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -11,6 +11,7 @@\n use hir::def_id::DefId;\n use rustc_data_structures::fx::FxHashMap;\n use std::cell::RefCell;\n+use std::collections::hash_map::Entry;\n use std::ops::Index;\n use std::hash::Hash;\n use std::marker::PhantomData;\n@@ -67,6 +68,11 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n         assert!(old_value.is_none());\n     }\n \n+    pub fn entry(&mut self, k: M::Key) -> Entry<M::Key, M::Value> {\n+        self.write(&k);\n+        self.map.entry(k)\n+    }\n+\n     pub fn contains_key(&self, k: &M::Key) -> bool {\n         self.read(k);\n         self.map.contains_key(k)"}, {"sha": "b1b1b849437d1464339bce0655d6d716bf447173", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 17, "deletions": 73, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -390,44 +390,6 @@ RFC. It is, however, [currently unimplemented][iss15872].\n [iss15872]: https://github.com/rust-lang/rust/issues/15872\n \"##,\n \n-E0109: r##\"\n-You tried to give a type parameter to a type which doesn't need it. Erroneous\n-code example:\n-\n-```compile_fail,E0109\n-type X = u32<i32>; // error: type parameters are not allowed on this type\n-```\n-\n-Please check that you used the correct type and recheck its definition. Perhaps\n-it doesn't need the type parameter.\n-\n-Example:\n-\n-```\n-type X = u32; // this compiles\n-```\n-\n-Note that type parameters for enum-variant constructors go after the variant,\n-not after the enum (Option::None::<u32>, not Option::<u32>::None).\n-\"##,\n-\n-E0110: r##\"\n-You tried to give a lifetime parameter to a type which doesn't need it.\n-Erroneous code example:\n-\n-```compile_fail,E0110\n-type X = u32<'static>; // error: lifetime parameters are not allowed on\n-                       //        this type\n-```\n-\n-Please check that the correct type was used and recheck its definition; perhaps\n-it doesn't need the lifetime parameter. Example:\n-\n-```\n-type X = u32; // ok!\n-```\n-\"##,\n-\n E0133: r##\"\n Unsafe code was used outside of an unsafe function or block.\n \n@@ -627,41 +589,6 @@ attributes:\n See also https://doc.rust-lang.org/book/no-stdlib.html\n \"##,\n \n-E0229: r##\"\n-An associated type binding was done outside of the type parameter declaration\n-and `where` clause. Erroneous code example:\n-\n-```compile_fail,E0229\n-pub trait Foo {\n-    type A;\n-    fn boo(&self) -> <Self as Foo>::A;\n-}\n-\n-struct Bar;\n-\n-impl Foo for isize {\n-    type A = usize;\n-    fn boo(&self) -> usize { 42 }\n-}\n-\n-fn baz<I>(x: &<I as Foo<A=Bar>>::A) {}\n-// error: associated type bindings are not allowed here\n-```\n-\n-To solve this error, please move the type bindings in the type parameter\n-declaration:\n-\n-```ignore\n-fn baz<I: Foo<A=Bar>>(x: &<I as Foo>::A) {} // ok!\n-```\n-\n-Or in the `where` clause:\n-\n-```ignore\n-fn baz<I>(x: &<I as Foo>::A) where I: Foo<A=Bar> {}\n-```\n-\"##,\n-\n E0261: r##\"\n When using a lifetime like `'a` in a type, it must be declared before being\n used.\n@@ -1390,6 +1317,23 @@ error. To resolve it, add an `else` block having the same type as the `if`\n block.\n \"##,\n \n+E0391: r##\"\n+This error indicates that some types or traits depend on each other\n+and therefore cannot be constructed.\n+\n+The following example contains a circular dependency between two traits:\n+\n+```compile_fail,E0391\n+trait FirstTrait : SecondTrait {\n+\n+}\n+\n+trait SecondTrait : FirstTrait {\n+\n+}\n+```\n+\"##,\n+\n E0398: r##\"\n In Rust 1.3, the default object lifetime bounds are expected to change, as\n described in RFC #1156 [1]. You are getting a warning because the compiler"}, {"sha": "468421a68b54cb5f88168056a7d67ddf07f77761", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -80,6 +80,9 @@ pub struct LoweringContext<'a> {\n     impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n     bodies: FxHashMap<hir::BodyId, hir::Body>,\n \n+    trait_impls: BTreeMap<DefId, Vec<NodeId>>,\n+    trait_default_impl: BTreeMap<DefId, NodeId>,\n+\n     loop_scopes: Vec<NodeId>,\n     is_in_loop_condition: bool,\n \n@@ -116,6 +119,8 @@ pub fn lower_crate(sess: &Session,\n         trait_items: BTreeMap::new(),\n         impl_items: BTreeMap::new(),\n         bodies: FxHashMap(),\n+        trait_impls: BTreeMap::new(),\n+        trait_default_impl: BTreeMap::new(),\n         loop_scopes: Vec::new(),\n         is_in_loop_condition: false,\n         type_def_lifetime_params: DefIdMap(),\n@@ -201,6 +206,8 @@ impl<'a> LoweringContext<'a> {\n             trait_items: self.trait_items,\n             impl_items: self.impl_items,\n             bodies: self.bodies,\n+            trait_impls: self.trait_impls,\n+            trait_default_impl: self.trait_default_impl,\n         }\n     }\n \n@@ -525,7 +532,7 @@ impl<'a> LoweringContext<'a> {\n                         return n;\n                     }\n                     assert!(!def_id.is_local());\n-                    let (n, _) = self.sess.cstore.item_generics_own_param_counts(def_id);\n+                    let n = self.sess.cstore.item_generics_cloned(def_id).regions.len();\n                     self.type_def_lifetime_params.insert(def_id, n);\n                     n\n                 });\n@@ -1089,14 +1096,27 @@ impl<'a> LoweringContext<'a> {\n                 hir::ItemUnion(vdata, self.lower_generics(generics))\n             }\n             ItemKind::DefaultImpl(unsafety, ref trait_ref) => {\n+                let trait_ref = self.lower_trait_ref(trait_ref);\n+\n+                if let Def::Trait(def_id) = trait_ref.path.def {\n+                    self.trait_default_impl.insert(def_id, id);\n+                }\n+\n                 hir::ItemDefaultImpl(self.lower_unsafety(unsafety),\n-                                     self.lower_trait_ref(trait_ref))\n+                                     trait_ref)\n             }\n             ItemKind::Impl(unsafety, polarity, ref generics, ref ifce, ref ty, ref impl_items) => {\n                 let new_impl_items = impl_items.iter()\n                                                .map(|item| self.lower_impl_item_ref(item))\n                                                .collect();\n                 let ifce = ifce.as_ref().map(|trait_ref| self.lower_trait_ref(trait_ref));\n+\n+                if let Some(ref trait_ref) = ifce {\n+                    if let Def::Trait(def_id) = trait_ref.path.def {\n+                        self.trait_impls.entry(def_id).or_insert(vec![]).push(id);\n+                    }\n+                }\n+\n                 hir::ItemImpl(self.lower_unsafety(unsafety),\n                               self.lower_impl_polarity(polarity),\n                               self.lower_generics(generics),"}, {"sha": "20b4d8d8a8f031b71be26fe141630fef933d1fdd", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -437,6 +437,50 @@ impl<'hir> Map<'hir> {\n         self.local_def_id(self.body_owner(id))\n     }\n \n+    pub fn ty_param_owner(&self, id: NodeId) -> NodeId {\n+        match self.get(id) {\n+            NodeItem(&Item { node: ItemTrait(..), .. }) => id,\n+            NodeTyParam(_) => self.get_parent_node(id),\n+            _ => {\n+                bug!(\"ty_param_owner: {} not a type parameter\",\n+                    self.node_to_string(id))\n+            }\n+        }\n+    }\n+\n+    pub fn ty_param_name(&self, id: NodeId) -> Name {\n+        match self.get(id) {\n+            NodeItem(&Item { node: ItemTrait(..), .. }) => {\n+                keywords::SelfType.name()\n+            }\n+            NodeTyParam(tp) => tp.name,\n+            _ => {\n+                bug!(\"ty_param_name: {} not a type parameter\",\n+                    self.node_to_string(id))\n+            }\n+        }\n+    }\n+\n+    pub fn trait_impls(&self, trait_did: DefId) -> &'hir [NodeId] {\n+        self.dep_graph.read(DepNode::TraitImpls(trait_did));\n+\n+        // NB: intentionally bypass `self.forest.krate()` so that we\n+        // do not trigger a read of the whole krate here\n+        self.forest.krate.trait_impls.get(&trait_did).map_or(&[], |xs| &xs[..])\n+    }\n+\n+    pub fn trait_default_impl(&self, trait_did: DefId) -> Option<NodeId> {\n+        self.dep_graph.read(DepNode::TraitImpls(trait_did));\n+\n+        // NB: intentionally bypass `self.forest.krate()` so that we\n+        // do not trigger a read of the whole krate here\n+        self.forest.krate.trait_default_impl.get(&trait_did).cloned()\n+    }\n+\n+    pub fn trait_is_auto(&self, trait_did: DefId) -> bool {\n+        self.trait_default_impl(trait_did).is_some()\n+    }\n+\n     /// Get the attributes on the krate. This is preferable to\n     /// invoking `krate.attrs` because it registers a tighter\n     /// dep-graph access."}, {"sha": "8b6c75886baa8121ff62903a2c773202766531f3", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -410,6 +410,9 @@ pub struct Crate {\n     pub trait_items: BTreeMap<TraitItemId, TraitItem>,\n     pub impl_items: BTreeMap<ImplItemId, ImplItem>,\n     pub bodies: FxHashMap<BodyId, Body>,\n+\n+    pub trait_impls: BTreeMap<DefId, Vec<NodeId>>,\n+    pub trait_default_impl: BTreeMap<DefId, NodeId>,\n }\n \n impl Crate {"}, {"sha": "a929060cf98904e53d626677c179b43d20fce79a", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -505,7 +505,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             evaluation_cache: traits::EvaluationCache::new(),\n             projection_cache: RefCell::new(traits::ProjectionCache::new()),\n             reported_trait_errors: RefCell::new(FxHashSet()),\n-            projection_mode: Reveal::NotSpecializable,\n+            projection_mode: Reveal::UserFacing,\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: self.sess.err_count(),\n             obligations_in_snapshot: Cell::new(false),\n@@ -600,7 +600,7 @@ impl_trans_normalize!('gcx,\n     Ty<'gcx>,\n     &'gcx Substs<'gcx>,\n     ty::FnSig<'gcx>,\n-    &'gcx ty::BareFnTy<'gcx>,\n+    ty::PolyFnSig<'gcx>,\n     ty::ClosureSubsts<'gcx>,\n     ty::PolyTraitRef<'gcx>,\n     ty::ExistentialTraitRef<'gcx>\n@@ -1197,16 +1197,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// as the substitutions for the default, `(T, U)`.\n     pub fn type_var_for_def(&self,\n                             span: Span,\n-                            def: &ty::TypeParameterDef<'tcx>,\n+                            def: &ty::TypeParameterDef,\n                             substs: &[Kind<'tcx>])\n                             -> Ty<'tcx> {\n-        let default = def.default.map(|default| {\n-            type_variable::Default {\n+        let default = if def.has_default {\n+            let default = self.tcx.item_type(def.def_id);\n+            Some(type_variable::Default {\n                 ty: default.subst_spanned(self.tcx, substs, Some(span)),\n                 origin_span: span,\n-                def_id: def.default_def_id\n-            }\n-        });\n+                def_id: def.def_id\n+            })\n+        } else {\n+            None\n+        };\n \n \n         let ty_var_id = self.type_variables\n@@ -1646,20 +1649,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         Some(self.tcx.closure_kind(def_id))\n     }\n \n-    pub fn closure_type(&self,\n-                        def_id: DefId,\n-                        substs: ty::ClosureSubsts<'tcx>)\n-                        -> ty::ClosureTy<'tcx>\n-    {\n+    pub fn closure_type(&self, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n         if let InferTables::InProgress(tables) = self.tables {\n             if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                if let Some(ty) = tables.borrow().closure_tys.get(&id) {\n-                    return ty.subst(self.tcx, substs.substs);\n+                if let Some(&ty) = tables.borrow().closure_tys.get(&id) {\n+                    return ty;\n                 }\n             }\n         }\n \n-        self.tcx.closure_type(def_id, substs)\n+        self.tcx.closure_type(def_id)\n     }\n }\n "}, {"sha": "c4fccdcb9eb6220ce01c6727797aa487ca098e88", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -39,6 +39,7 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n+#![feature(specialization)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n \n@@ -75,7 +76,6 @@ pub mod infer;\n pub mod lint;\n \n pub mod middle {\n-    pub mod astconv_util;\n     pub mod expr_use_visitor;\n     pub mod const_val;\n     pub mod cstore;"}, {"sha": "3418034b069d606c7b4f084b0fa6ce5035d6bb17", "filename": "src/librustc/middle/astconv_util.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d54ab88fd522b2f02d7079c601ddec047eba8/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d54ab88fd522b2f02d7079c601ddec047eba8/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=3b4d54ab88fd522b2f02d7079c601ddec047eba8", "patch": "@@ -1,83 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * This module contains a simple utility routine\n- * used by both `typeck` and `const_eval`.\n- * Almost certainly this could (and should) be refactored out of existence.\n- */\n-\n-use hir;\n-use hir::def::Def;\n-use ty::{Ty, TyCtxt};\n-\n-use syntax_pos::Span;\n-\n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn prohibit_type_params(self, segments: &[hir::PathSegment]) {\n-        for segment in segments {\n-            for typ in segment.parameters.types() {\n-                struct_span_err!(self.sess, typ.span, E0109,\n-                                 \"type parameters are not allowed on this type\")\n-                    .span_label(typ.span, &format!(\"type parameter not allowed\"))\n-                    .emit();\n-                break;\n-            }\n-            for lifetime in segment.parameters.lifetimes() {\n-                struct_span_err!(self.sess, lifetime.span, E0110,\n-                                 \"lifetime parameters are not allowed on this type\")\n-                    .span_label(lifetime.span,\n-                                &format!(\"lifetime parameter not allowed on this type\"))\n-                    .emit();\n-                break;\n-            }\n-            for binding in segment.parameters.bindings() {\n-                self.prohibit_projection(binding.span);\n-                break;\n-            }\n-        }\n-    }\n-\n-    pub fn prohibit_projection(self, span: Span)\n-    {\n-        let mut err = struct_span_err!(self.sess, span, E0229,\n-                                       \"associated type bindings are not allowed here\");\n-        err.span_label(span, &format!(\"associate type not allowed here\")).emit();\n-    }\n-\n-    pub fn prim_ty_to_ty(self,\n-                         segments: &[hir::PathSegment],\n-                         nty: hir::PrimTy)\n-                         -> Ty<'tcx> {\n-        self.prohibit_type_params(segments);\n-        match nty {\n-            hir::TyBool => self.types.bool,\n-            hir::TyChar => self.types.char,\n-            hir::TyInt(it) => self.mk_mach_int(it),\n-            hir::TyUint(uit) => self.mk_mach_uint(uit),\n-            hir::TyFloat(ft) => self.mk_mach_float(ft),\n-            hir::TyStr => self.mk_str()\n-        }\n-    }\n-\n-    /// If a type in the AST is a primitive type, return the ty::Ty corresponding\n-    /// to it.\n-    pub fn ast_ty_to_prim_ty(self, ast_ty: &hir::Ty) -> Option<Ty<'tcx>> {\n-        if let hir::TyPath(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n-            if let Def::PrimTy(nty) = path.def {\n-                Some(self.prim_ty_to_ty(&path.segments, nty))\n-            } else {\n-                None\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-}"}, {"sha": "d81f89827d93814de111839dc33661c97fc282cf", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -12,28 +12,30 @@ use syntax::symbol::InternedString;\n use syntax::ast;\n use std::rc::Rc;\n use hir::def_id::DefId;\n+use ty::subst::Substs;\n use rustc_const_math::*;\n+\n use self::ConstVal::*;\n pub use rustc_const_math::ConstInt;\n \n use std::collections::BTreeMap;\n \n #[derive(Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n-pub enum ConstVal {\n+pub enum ConstVal<'tcx> {\n     Float(ConstFloat),\n     Integral(ConstInt),\n     Str(InternedString),\n     ByteStr(Rc<Vec<u8>>),\n     Bool(bool),\n-    Function(DefId),\n-    Struct(BTreeMap<ast::Name, ConstVal>),\n-    Tuple(Vec<ConstVal>),\n-    Array(Vec<ConstVal>),\n-    Repeat(Box<ConstVal>, u64),\n+    Function(DefId, &'tcx Substs<'tcx>),\n+    Struct(BTreeMap<ast::Name, ConstVal<'tcx>>),\n+    Tuple(Vec<ConstVal<'tcx>>),\n+    Array(Vec<ConstVal<'tcx>>),\n+    Repeat(Box<ConstVal<'tcx>>, u64),\n     Char(char),\n }\n \n-impl ConstVal {\n+impl<'tcx> ConstVal<'tcx> {\n     pub fn description(&self) -> &'static str {\n         match *self {\n             Float(f) => f.description(),\n@@ -43,7 +45,7 @@ impl ConstVal {\n             Bool(_) => \"boolean\",\n             Struct(_) => \"struct\",\n             Tuple(_) => \"tuple\",\n-            Function(_) => \"function definition\",\n+            Function(..) => \"function definition\",\n             Array(..) => \"array\",\n             Repeat(..) => \"repeat\",\n             Char(..) => \"char\",\n@@ -53,8 +55,7 @@ impl ConstVal {\n     pub fn to_const_int(&self) -> Option<ConstInt> {\n         match *self {\n             ConstVal::Integral(i) => Some(i),\n-            ConstVal::Bool(true) => Some(ConstInt::Infer(1)),\n-            ConstVal::Bool(false) => Some(ConstInt::Infer(0)),\n+            ConstVal::Bool(b) => Some(ConstInt::U8(b as u8)),\n             ConstVal::Char(ch) => Some(ConstInt::U32(ch as u32)),\n             _ => None\n         }"}, {"sha": "4a7027b8997a5854befdef64121af1d4b96a373e", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 24, "deletions": 71, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -28,13 +28,12 @@ use hir::map as hir_map;\n use hir::map::definitions::{Definitions, DefKey, DisambiguatedDefPathData};\n use hir::svh::Svh;\n use middle::lang_items;\n-use middle::resolve_lifetime::ObjectLifetimeDefault;\n-use ty::{self, Ty, TyCtxt};\n-use mir::Mir;\n+use ty::{self, TyCtxt};\n use session::Session;\n use session::search_paths::PathKind;\n use util::nodemap::{NodeSet, DefIdMap};\n \n+use std::any::Any;\n use std::collections::BTreeMap;\n use std::path::PathBuf;\n use std::rc::Rc;\n@@ -164,54 +163,34 @@ pub struct ExternCrate {\n \n /// A store of Rust crates, through with their metadata\n /// can be accessed.\n-pub trait CrateStore<'tcx> {\n+pub trait CrateStore {\n+    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Rc<Any>;\n+\n     // item info\n     fn describe_def(&self, def: DefId) -> Option<Def>;\n     fn def_span(&self, sess: &Session, def: DefId) -> Span;\n     fn stability(&self, def: DefId) -> Option<attr::Stability>;\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>;\n     fn visibility(&self, def: DefId) -> ty::Visibility;\n-    fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind;\n-    fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                      -> ty::ClosureTy<'tcx>;\n-    fn item_variances(&self, def: DefId) -> Vec<ty::Variance>;\n-    fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                     -> Ty<'tcx>;\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>>;\n-    fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                           -> ty::GenericPredicates<'tcx>;\n-    fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                 -> ty::GenericPredicates<'tcx>;\n-    fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                         -> ty::Generics<'tcx>;\n-    fn item_generics_own_param_counts(&self, def: DefId) -> (usize, usize);\n-    fn item_generics_object_lifetime_defaults(&self, def: DefId)\n-                                              -> Vec<ObjectLifetimeDefault>;\n+    fn item_generics_cloned(&self, def: DefId) -> ty::Generics;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n-    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef;\n-    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> &'tcx ty::AdtDef;\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>;\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n \n     // trait info\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>;\n \n     // impl info\n-    fn associated_item_def_ids(&self, def_id: DefId) -> Vec<DefId>;\n-    fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                          -> Option<ty::TraitRef<'tcx>>;\n     fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity;\n-    fn custom_coerce_unsized_kind(&self, def: DefId)\n-                                  -> Option<ty::adjustment::CustomCoerceUnsized>;\n     fn impl_parent(&self, impl_def_id: DefId) -> Option<DefId>;\n \n     // trait/impl-item info\n     fn trait_of_item(&self, def_id: DefId) -> Option<DefId>;\n-    fn associated_item(&self, def: DefId) -> Option<ty::AssociatedItem>;\n+    fn associated_item_cloned(&self, def: DefId) -> ty::AssociatedItem;\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool;\n-    fn is_defaulted_trait(&self, did: DefId) -> bool;\n     fn is_default_impl(&self, impl_did: DefId) -> bool;\n     fn is_foreign_item(&self, did: DefId) -> bool;\n     fn is_dllimport_foreign_item(&self, def: DefId) -> bool;\n@@ -257,12 +236,11 @@ pub trait CrateStore<'tcx> {\n     fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro;\n \n     // misc. metadata\n-    fn maybe_get_item_body<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                               -> Option<&'tcx hir::Body>;\n+    fn maybe_get_item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                                     -> Option<&'tcx hir::Body>;\n     fn item_body_nested_bodies(&self, def: DefId) -> BTreeMap<hir::BodyId, hir::Body>;\n     fn const_is_rvalue_promotable_to_static(&self, def: DefId) -> bool;\n \n-    fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> Mir<'tcx>;\n     fn is_item_mir_available(&self, def: DefId) -> bool;\n \n     // This is basically a 1-based range of ints, which is a little\n@@ -277,10 +255,10 @@ pub trait CrateStore<'tcx> {\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>;\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource;\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n-    fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           reexports: &def::ExportMap,\n-                           link_meta: &LinkMeta,\n-                           reachable: &NodeSet) -> Vec<u8>;\n+    fn encode_metadata<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 reexports: &def::ExportMap,\n+                                 link_meta: &LinkMeta,\n+                                 reachable: &NodeSet) -> Vec<u8>;\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n \n@@ -314,63 +292,40 @@ pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n /// A dummy crate store that does not support any non-local crates,\n /// for test purposes.\n pub struct DummyCrateStore;\n+\n #[allow(unused_variables)]\n-impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n+impl CrateStore for DummyCrateStore {\n+    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Rc<Any>\n+        { bug!(\"crate_data_as_rc_any\") }\n     // item info\n     fn describe_def(&self, def: DefId) -> Option<Def> { bug!(\"describe_def\") }\n     fn def_span(&self, sess: &Session, def: DefId) -> Span { bug!(\"def_span\") }\n     fn stability(&self, def: DefId) -> Option<attr::Stability> { bug!(\"stability\") }\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> { bug!(\"deprecation\") }\n     fn visibility(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n-    fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind { bug!(\"closure_kind\") }\n-    fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                      -> ty::ClosureTy<'tcx>  { bug!(\"closure_ty\") }\n-    fn item_variances(&self, def: DefId) -> Vec<ty::Variance> { bug!(\"item_variances\") }\n-    fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                     -> Ty<'tcx> { bug!(\"item_type\") }\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>> {\n         bug!(\"visible_parent_map\")\n     }\n-    fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                           -> ty::GenericPredicates<'tcx> { bug!(\"item_predicates\") }\n-    fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                 -> ty::GenericPredicates<'tcx> { bug!(\"item_super_predicates\") }\n-    fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                         -> ty::Generics<'tcx> { bug!(\"item_generics\") }\n-    fn item_generics_own_param_counts(&self, def: DefId) -> (usize, usize)\n-        { bug!(\"item_generics_own_param_counts\") }\n-    fn item_generics_object_lifetime_defaults(&self, def: DefId)\n-                                              -> Vec<ObjectLifetimeDefault>\n-        { bug!(\"item_generics_object_lifetime_defaults\") }\n+    fn item_generics_cloned(&self, def: DefId) -> ty::Generics\n+        { bug!(\"item_generics_cloned\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n-    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef\n-        { bug!(\"trait_def\") }\n-    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> &'tcx ty::AdtDef\n-        { bug!(\"adt_def\") }\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name> { bug!(\"fn_arg_names\") }\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n \n     // trait info\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId> { vec![] }\n \n     // impl info\n-    fn associated_item_def_ids(&self, def_id: DefId) -> Vec<DefId>\n-        { bug!(\"associated_items\") }\n-    fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                          -> Option<ty::TraitRef<'tcx>> { bug!(\"impl_trait_ref\") }\n     fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity { bug!(\"impl_polarity\") }\n-    fn custom_coerce_unsized_kind(&self, def: DefId)\n-                                  -> Option<ty::adjustment::CustomCoerceUnsized>\n-        { bug!(\"custom_coerce_unsized_kind\") }\n     fn impl_parent(&self, def: DefId) -> Option<DefId> { bug!(\"impl_parent\") }\n \n     // trait/impl-item info\n     fn trait_of_item(&self, def_id: DefId) -> Option<DefId> { bug!(\"trait_of_item\") }\n-    fn associated_item(&self, def: DefId) -> Option<ty::AssociatedItem> { bug!(\"associated_item\") }\n+    fn associated_item_cloned(&self, def: DefId) -> ty::AssociatedItem\n+        { bug!(\"associated_item_cloned\") }\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool { bug!(\"is_const_fn\") }\n-    fn is_defaulted_trait(&self, did: DefId) -> bool { bug!(\"is_defaulted_trait\") }\n     fn is_default_impl(&self, impl_did: DefId) -> bool { bug!(\"is_default_impl\") }\n     fn is_foreign_item(&self, did: DefId) -> bool { bug!(\"is_foreign_item\") }\n     fn is_dllimport_foreign_item(&self, id: DefId) -> bool { false }\n@@ -429,8 +384,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro { bug!(\"load_macro\") }\n \n     // misc. metadata\n-    fn maybe_get_item_body<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                               -> Option<&'tcx hir::Body> {\n+    fn maybe_get_item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                                     -> Option<&'tcx hir::Body> {\n         bug!(\"maybe_get_item_body\")\n     }\n     fn item_body_nested_bodies(&self, def: DefId) -> BTreeMap<hir::BodyId, hir::Body> {\n@@ -440,8 +395,6 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n         bug!(\"const_is_rvalue_promotable_to_static\")\n     }\n \n-    fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                        -> Mir<'tcx> { bug!(\"get_item_mir\") }\n     fn is_item_mir_available(&self, def: DefId) -> bool {\n         bug!(\"is_item_mir_available\")\n     }\n@@ -459,7 +412,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n         { vec![] }\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> { None }\n-    fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn encode_metadata<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n                            link_meta: &LinkMeta,\n                            reachable: &NodeSet) -> Vec<u8> { vec![] }"}, {"sha": "cc6d6e88dee4ee068424be59d0d10ee853903fe1", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -159,10 +159,9 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             hir_map::NodeItem(item) => {\n                 match item.node {\n                     hir::ItemStruct(..) | hir::ItemUnion(..) => {\n-                        self.struct_has_extern_repr = item.attrs.iter().any(|attr| {\n-                            attr::find_repr_attrs(self.tcx.sess.diagnostic(), attr)\n-                                .contains(&attr::ReprExtern)\n-                        });\n+                        let def_id = self.tcx.hir.local_def_id(item.id);\n+                        let def = self.tcx.lookup_adt_def(def_id);\n+                        self.struct_has_extern_repr = def.repr.c;\n \n                         intravisit::walk_item(self, &item);\n                     }\n@@ -478,7 +477,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // method of a private type is used, but the type itself is never\n         // called directly.\n         if let Some(impl_list) =\n-                self.tcx.inherent_impls.borrow().get(&self.tcx.hir.local_def_id(id)) {\n+                self.tcx.maps.inherent_impls.borrow().get(&self.tcx.hir.local_def_id(id)) {\n             for &impl_did in impl_list.iter() {\n                 for &item_did in &self.tcx.associated_item_def_ids(impl_did)[..] {\n                     if let Some(item_node_id) = self.tcx.hir.as_local_node_id(item_did) {"}, {"sha": "5af8e7e52d888407f57518c0bfd4addaedda1f6e", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -44,8 +44,8 @@ enum RootUnsafeContext {\n \n fn type_is_unsafe_function(ty: Ty) -> bool {\n     match ty.sty {\n-        ty::TyFnDef(.., ref f) |\n-        ty::TyFnPtr(ref f) => f.unsafety == hir::Unsafety::Unsafe,\n+        ty::TyFnDef(.., f) |\n+        ty::TyFnPtr(f) => f.unsafety() == hir::Unsafety::Unsafe,\n         _ => false,\n     }\n }"}, {"sha": "cdbf92e93a4cb983bcd70c53dc849e7e9e15117d", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -40,7 +40,7 @@ struct ExprVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n         let intrinsic = match self.infcx.tcx.item_type(def_id).sty {\n-            ty::TyFnDef(.., ref bfty) => bfty.abi == RustIntrinsic,\n+            ty::TyFnDef(.., bfty) => bfty.abi() == RustIntrinsic,\n             _ => return false\n         };\n         intrinsic && self.infcx.tcx.item_name(def_id) == \"transmute\"\n@@ -137,9 +137,9 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for ExprVisitor<'a, 'gcx, 'tcx> {\n                 let typ = self.infcx.tables.borrow().node_id_to_type(expr.id);\n                 let typ = self.infcx.tcx.lift_to_global(&typ).unwrap();\n                 match typ.sty {\n-                    ty::TyFnDef(.., ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n-                        let from = bare_fn_ty.sig.skip_binder().inputs()[0];\n-                        let to = bare_fn_ty.sig.skip_binder().output();\n+                    ty::TyFnDef(.., sig) if sig.abi() == RustIntrinsic => {\n+                        let from = sig.inputs().skip_binder()[0];\n+                        let to = *sig.output().skip_binder();\n                         self.check_transmute(expr.span, from, to, expr.id);\n                     }\n                     _ => {"}, {"sha": "a8c1559ae2373b309ca0072d0c0ec90790d1f917", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -1432,12 +1432,16 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                  body: &hir::Body)\n     {\n         let fn_ty = self.ir.tcx.item_type(self.ir.tcx.hir.local_def_id(id));\n-        let fn_ret = match fn_ty.sty {\n-            ty::TyClosure(closure_def_id, substs) =>\n-                self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n-            _ => fn_ty.fn_ret()\n+        let fn_sig = match fn_ty.sty {\n+            ty::TyClosure(closure_def_id, substs) => {\n+                self.ir.tcx.closure_type(closure_def_id)\n+                    .subst(self.ir.tcx, substs.substs)\n+            }\n+            _ => fn_ty.fn_sig()\n         };\n \n+        let fn_ret = fn_sig.output();\n+\n         // within the fn body, late-bound regions are liberated\n         // and must outlive the *call-site* of the function.\n         let fn_ret ="}, {"sha": "37749816eb153c725300a0eddba7f66cdc21b917", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -995,7 +995,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } else {\n                 let cstore = &self.sess.cstore;\n                 self.xcrate_object_lifetime_defaults.entry(def_id).or_insert_with(|| {\n-                    cstore.item_generics_object_lifetime_defaults(def_id)\n+                    cstore.item_generics_cloned(def_id).types.into_iter().map(|def| {\n+                        def.object_lifetime_default\n+                    }).collect()\n                 })\n             };\n             unsubst.iter().map(|set| {"}, {"sha": "baa22d706143519e6b20605b77d4bfebe2f399a7", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -433,23 +433,27 @@ struct Checker<'a, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // (See issue #38412)\n-    fn skip_stability_check_due_to_privacy(self, def_id: DefId) -> bool {\n-        let visibility = {\n-            // Check if `def_id` is a trait method.\n-            match self.sess.cstore.associated_item(def_id) {\n-                Some(ty::AssociatedItem { container: ty::TraitContainer(trait_def_id), .. }) => {\n-                    // Trait methods do not declare visibility (even\n-                    // for visibility info in cstore). Use containing\n-                    // trait instead, so methods of pub traits are\n-                    // themselves considered pub.\n-                    self.sess.cstore.visibility(trait_def_id)\n-                }\n-                _ => {\n-                    // Otherwise, cstore info works directly.\n-                    self.sess.cstore.visibility(def_id)\n+    fn skip_stability_check_due_to_privacy(self, mut def_id: DefId) -> bool {\n+        // Check if `def_id` is a trait method.\n+        match self.sess.cstore.describe_def(def_id) {\n+            Some(Def::Method(_)) |\n+            Some(Def::AssociatedTy(_)) |\n+            Some(Def::AssociatedConst(_)) => {\n+                match self.associated_item(def_id).container {\n+                    ty::TraitContainer(trait_def_id) => {\n+                        // Trait methods do not declare visibility (even\n+                        // for visibility info in cstore). Use containing\n+                        // trait instead, so methods of pub traits are\n+                        // themselves considered pub.\n+                        def_id = trait_def_id;\n+                    }\n+                    _ => {}\n                 }\n             }\n-        };\n+            _ => {}\n+        }\n+\n+        let visibility = self.sess.cstore.visibility(def_id);\n \n         match visibility {\n             // must check stability for pub items."}, {"sha": "40ebc97a78a6ce2f743a20f4c9e70061f79db5c4", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -542,7 +542,7 @@ impl<'tcx> Terminator<'tcx> {\n impl<'tcx> TerminatorKind<'tcx> {\n     pub fn if_<'a, 'gcx>(tcx: ty::TyCtxt<'a, 'gcx, 'tcx>, cond: Operand<'tcx>,\n                          t: BasicBlock, f: BasicBlock) -> TerminatorKind<'tcx> {\n-        static BOOL_SWITCH_FALSE: &'static [ConstInt] = &[ConstInt::Infer(0)];\n+        static BOOL_SWITCH_FALSE: &'static [ConstInt] = &[ConstInt::U8(0)];\n         TerminatorKind::SwitchInt {\n             discr: cond,\n             switch_ty: tcx.types.bool,\n@@ -1224,7 +1224,7 @@ pub enum Literal<'tcx> {\n         substs: &'tcx Substs<'tcx>,\n     },\n     Value {\n-        value: ConstVal,\n+        value: ConstVal<'tcx>,\n     },\n     Promoted {\n         // Index into the `promoted` vector of `Mir`.\n@@ -1271,7 +1271,7 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n             write!(fmt, \"b\\\"{}\\\"\", escaped)\n         }\n         Bool(b) => write!(fmt, \"{:?}\", b),\n-        Function(def_id) => write!(fmt, \"{}\", item_path_str(def_id)),\n+        Function(def_id, _) => write!(fmt, \"{}\", item_path_str(def_id)),\n         Struct(_) | Tuple(_) | Array(_) | Repeat(..) =>\n             bug!(\"ConstVal `{:?}` should not be in MIR\", const_val),\n         Char(c) => write!(fmt, \"{:?}\", c),"}, {"sha": "50a80305bee273e4163e67059bf2955b5ae21370", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -173,7 +173,7 @@ impl<'tcx> Rvalue<'tcx> {\n             Rvalue::Discriminant(ref lval) => {\n                 let ty = lval.ty(mir, tcx).to_ty(tcx);\n                 if let ty::TyAdt(adt_def, _) = ty.sty {\n-                    Some(adt_def.discr_ty.to_ty(tcx))\n+                    Some(adt_def.repr.discr_type().to_ty(tcx))\n                 } else {\n                     // Undefined behaviour, bug for now; may want to return something for\n                     // the `discriminant` intrinsic later."}, {"sha": "4cbbb67c7e43d8a1cd1caa7648b2064a2c215407", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -114,14 +114,14 @@ impl<'tcx, T: MirPass<'tcx>> MirMapPass<'tcx> for T {\n                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     hooks: &mut [Box<for<'s> MirPassHook<'s>>])\n     {\n-        let def_ids = tcx.mir_map.borrow().keys();\n+        let def_ids = tcx.maps.mir.borrow().keys();\n         for def_id in def_ids {\n             if !def_id.is_local() {\n                 continue;\n             }\n \n             let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n-            let mir = &mut tcx.mir_map.borrow()[&def_id].borrow_mut();\n+            let mir = &mut tcx.maps.mir.borrow()[&def_id].borrow_mut();\n             tcx.dep_graph.write(DepNode::Mir(def_id));\n \n             let id = tcx.hir.as_local_node_id(def_id).unwrap();"}, {"sha": "3ba82f34c3266a804fece8554e94707fb562c796", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -64,7 +64,7 @@ pub struct Session {\n     pub target: config::Config,\n     pub host: Target,\n     pub opts: config::Options,\n-    pub cstore: Rc<for<'a> CrateStore<'a>>,\n+    pub cstore: Rc<CrateStore>,\n     pub parse_sess: ParseSess,\n     // For a library crate, this is always none\n     pub entry_fn: RefCell<Option<(NodeId, Span)>>,\n@@ -510,7 +510,7 @@ pub fn build_session(sopts: config::Options,\n                      dep_graph: &DepGraph,\n                      local_crate_source_file: Option<PathBuf>,\n                      registry: errors::registry::Registry,\n-                     cstore: Rc<for<'a> CrateStore<'a>>)\n+                     cstore: Rc<CrateStore>)\n                      -> Session {\n     build_session_with_codemap(sopts,\n                                dep_graph,\n@@ -525,7 +525,7 @@ pub fn build_session_with_codemap(sopts: config::Options,\n                                   dep_graph: &DepGraph,\n                                   local_crate_source_file: Option<PathBuf>,\n                                   registry: errors::registry::Registry,\n-                                  cstore: Rc<for<'a> CrateStore<'a>>,\n+                                  cstore: Rc<CrateStore>,\n                                   codemap: Rc<codemap::CodeMap>,\n                                   emitter_dest: Option<Box<Write + Send>>)\n                                   -> Session {\n@@ -575,7 +575,7 @@ pub fn build_session_(sopts: config::Options,\n                       local_crate_source_file: Option<PathBuf>,\n                       span_diagnostic: errors::Handler,\n                       codemap: Rc<codemap::CodeMap>,\n-                      cstore: Rc<for<'a> CrateStore<'a>>)\n+                      cstore: Rc<CrateStore>)\n                       -> Session {\n     let host = match Target::search(config::host_triple()) {\n         Ok(t) => t,"}, {"sha": "b87d18464377f6b3f4481210de7eb09651fff63b", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 5, "deletions": 134, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -11,21 +11,18 @@\n use dep_graph::DepGraph;\n use infer::{InferCtxt, InferOk};\n use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, TyCtxt, ToPredicate};\n-use ty::subst::Subst;\n use rustc_data_structures::obligation_forest::{ObligationForest, Error};\n use rustc_data_structures::obligation_forest::{ForestObligation, ObligationProcessor};\n use std::marker::PhantomData;\n-use std::mem;\n use syntax::ast;\n use util::nodemap::{FxHashSet, NodeMap};\n use hir::def_id::DefId;\n \n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n use super::CodeSelectionError;\n-use super::{FulfillmentError, FulfillmentErrorCode, SelectionError};\n-use super::{ObligationCause, BuiltinDerivedObligation};\n-use super::{PredicateObligation, TraitObligation, Obligation};\n+use super::{FulfillmentError, FulfillmentErrorCode};\n+use super::{ObligationCause, PredicateObligation, Obligation};\n use super::project;\n use super::select::SelectionContext;\n use super::Unimplemented;\n@@ -82,10 +79,6 @@ pub struct FulfillmentContext<'tcx> {\n     // obligations (otherwise, it's easy to fail to walk to a\n     // particular node-id).\n     region_obligations: NodeMap<Vec<RegionObligation<'tcx>>>,\n-\n-    // A list of obligations that need to be deferred to\n-    // a later time for them to be properly fulfilled.\n-    deferred_obligations: Vec<DeferredObligation<'tcx>>,\n }\n \n #[derive(Clone)]\n@@ -101,100 +94,12 @@ pub struct PendingPredicateObligation<'tcx> {\n     pub stalled_on: Vec<Ty<'tcx>>,\n }\n \n-/// An obligation which cannot be fulfilled in the context\n-/// it was registered in, such as auto trait obligations on\n-/// `impl Trait`, which require the concrete type to be\n-/// available, only guaranteed after finishing type-checking.\n-#[derive(Clone, Debug)]\n-pub struct DeferredObligation<'tcx> {\n-    pub predicate: ty::PolyTraitPredicate<'tcx>,\n-    pub cause: ObligationCause<'tcx>\n-}\n-\n-impl<'a, 'gcx, 'tcx> DeferredObligation<'tcx> {\n-    /// If possible, create a `DeferredObligation` from\n-    /// a trait predicate which had failed selection,\n-    /// but could succeed later.\n-    pub fn from_select_error(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                             obligation: &TraitObligation<'tcx>,\n-                             selection_err: &SelectionError<'tcx>)\n-                             -> Option<DeferredObligation<'tcx>> {\n-        if let Unimplemented = *selection_err {\n-            if DeferredObligation::must_defer(tcx, &obligation.predicate) {\n-                return Some(DeferredObligation {\n-                    predicate: obligation.predicate.clone(),\n-                    cause: obligation.cause.clone()\n-                });\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    /// Returns true if the given trait predicate can be\n-    /// fulfilled at a later time.\n-    pub fn must_defer(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                      predicate: &ty::PolyTraitPredicate<'tcx>)\n-                      -> bool {\n-        // Auto trait obligations on `impl Trait`.\n-        if tcx.trait_has_default_impl(predicate.def_id()) {\n-            let substs = predicate.skip_binder().trait_ref.substs;\n-            if substs.types().count() == 1 && substs.regions().next().is_none() {\n-                if let ty::TyAnon(..) = predicate.skip_binder().self_ty().sty {\n-                    return true;\n-                }\n-            }\n-        }\n-\n-        false\n-    }\n-\n-    /// If possible, return the nested obligations required\n-    /// to fulfill this obligation.\n-    pub fn try_select(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n-                      -> Option<Vec<PredicateObligation<'tcx>>> {\n-        if let ty::TyAnon(def_id, substs) = self.predicate.skip_binder().self_ty().sty {\n-            let ty = if def_id.is_local() {\n-                tcx.item_types.borrow().get(&def_id).cloned()\n-            } else {\n-                Some(tcx.item_type(def_id))\n-            };\n-            // We can resolve the `impl Trait` to its concrete type.\n-            if let Some(concrete_ty) = ty.subst(tcx, substs) {\n-                let predicate = ty::TraitRef {\n-                    def_id: self.predicate.def_id(),\n-                    substs: tcx.mk_substs_trait(concrete_ty, &[])\n-                }.to_predicate();\n-\n-                let original_obligation = Obligation::new(self.cause.clone(),\n-                                                          self.predicate.clone());\n-                let cause = original_obligation.derived_cause(BuiltinDerivedObligation);\n-                return Some(vec![Obligation::new(cause, predicate)]);\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    /// Return the `PredicateObligation` this was created from.\n-    pub fn to_obligation(&self) -> PredicateObligation<'tcx> {\n-        let predicate = ty::Predicate::Trait(self.predicate.clone());\n-        Obligation::new(self.cause.clone(), predicate)\n-    }\n-\n-    /// Return an error as if this obligation had failed.\n-    pub fn to_error(&self) -> FulfillmentError<'tcx> {\n-        FulfillmentError::new(self.to_obligation(), CodeSelectionError(Unimplemented))\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n             region_obligations: NodeMap(),\n-            deferred_obligations: vec![],\n         }\n     }\n \n@@ -294,16 +199,10 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     {\n         self.select_where_possible(infcx)?;\n \n-        // Fail all of the deferred obligations that haven't\n-        // been otherwise removed from the context.\n-        let deferred_errors = self.deferred_obligations.iter()\n-                                  .map(|d| d.to_error());\n-\n         let errors: Vec<_> =\n             self.predicates.to_errors(CodeAmbiguity)\n                            .into_iter()\n                            .map(|e| to_fulfillment_error(e))\n-                           .chain(deferred_errors)\n                            .collect();\n         if errors.is_empty() {\n             Ok(())\n@@ -324,10 +223,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         self.predicates.pending_obligations()\n     }\n \n-    pub fn take_deferred_obligations(&mut self) -> Vec<DeferredObligation<'tcx>> {\n-        mem::replace(&mut self.deferred_obligations, vec![])\n-    }\n-\n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n     /// only attempts to select obligations that haven't been seen before.\n     fn select(&mut self, selcx: &mut SelectionContext<'a, 'gcx, 'tcx>)\n@@ -343,7 +238,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n             let outcome = self.predicates.process_obligations(&mut FulfillProcessor {\n                 selcx: selcx,\n                 region_obligations: &mut self.region_obligations,\n-                deferred_obligations: &mut self.deferred_obligations\n             });\n             debug!(\"select: outcome={:?}\", outcome);\n \n@@ -378,7 +272,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n struct FulfillProcessor<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {\n     selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n     region_obligations: &'a mut NodeMap<Vec<RegionObligation<'tcx>>>,\n-    deferred_obligations: &'a mut Vec<DeferredObligation<'tcx>>\n }\n \n impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx, 'tcx> {\n@@ -391,8 +284,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n     {\n         process_predicate(self.selcx,\n                           obligation,\n-                          self.region_obligations,\n-                          self.deferred_obligations)\n+                          self.region_obligations)\n             .map(|os| os.map(|os| os.into_iter().map(|o| PendingPredicateObligation {\n                 obligation: o,\n                 stalled_on: vec![]\n@@ -432,8 +324,7 @@ fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 't\n fn process_predicate<'a, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n     pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-    region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>,\n-    deferred_obligations: &mut Vec<DeferredObligation<'tcx>>)\n+    region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n               FulfillmentErrorCode<'tcx>>\n {\n@@ -502,21 +393,7 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n                     info!(\"selecting trait `{:?}` at depth {} yielded Err\",\n                           data, obligation.recursion_depth);\n \n-                    let defer = DeferredObligation::from_select_error(selcx.tcx(),\n-                                                                      &trait_obligation,\n-                                                                      &selection_err);\n-                    if let Some(deferred_obligation) = defer {\n-                        if let Some(nested) = deferred_obligation.try_select(selcx.tcx()) {\n-                            Ok(Some(nested))\n-                        } else {\n-                            // Pretend that the obligation succeeded,\n-                            // but record it for later.\n-                            deferred_obligations.push(deferred_obligation);\n-                            Ok(Some(vec![]))\n-                        }\n-                    } else {\n-                        Err(CodeSelectionError(selection_err))\n-                    }\n+                    Err(CodeSelectionError(selection_err))\n                 }\n             }\n         }\n@@ -714,12 +591,6 @@ impl<'a, 'gcx, 'tcx> GlobalFulfilledPredicates<'gcx> {\n             // already has the required read edges, so we don't need\n             // to add any more edges here.\n             if data.is_global() {\n-                // Don't cache predicates which were fulfilled\n-                // by deferring them for later fulfillment.\n-                if DeferredObligation::must_defer(tcx, data) {\n-                    return;\n-                }\n-\n                 if let Some(data) = tcx.lift_to_global(data) {\n                     if self.set.insert(data.clone()) {\n                         debug!(\"add_if_global: global predicate `{:?}` added\", data);"}, {"sha": "7e7d06e4b814e681e025a1b33e5966582c7043c0", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -31,7 +31,6 @@ pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n pub use self::fulfill::{FulfillmentContext, GlobalFulfilledPredicates, RegionObligation};\n-pub use self::fulfill::DeferredObligation;\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{normalize, normalize_projection_type, Normalized};\n pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, Reveal};\n@@ -474,7 +473,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n \n-    tcx.infer_ctxt(elaborated_env, Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt(elaborated_env, Reveal::UserFacing).enter(|infcx| {\n         let predicates = match fully_normalize(&infcx, cause,\n                                                &infcx.parameter_environment.caller_bounds) {\n             Ok(predicates) => predicates,"}, {"sha": "3d8f9e41c675b877e8fba6edf51f4155ceba7aed", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 8, "deletions": 36, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -38,36 +38,6 @@ use util::common::FN_OUTPUT_NAME;\n /// more or less conservative.\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub enum Reveal {\n-    /// FIXME (#32205)\n-    /// At coherence-checking time, we're still constructing the\n-    /// specialization graph, and thus we only project\n-    /// non-`default` associated types that are defined directly in\n-    /// the applicable impl. (This behavior should be improved over\n-    /// time, to allow for successful projections modulo cycles\n-    /// between different impls).\n-    ///\n-    /// Here's an example that will fail due to the restriction:\n-    ///\n-    /// ```\n-    /// trait Assoc {\n-    ///     type Output;\n-    /// }\n-    ///\n-    /// impl<T> Assoc for T {\n-    ///     type Output = bool;\n-    /// }\n-    ///\n-    /// impl Assoc for u8 {} // <- inherits the non-default type from above\n-    ///\n-    /// trait Foo {}\n-    /// impl Foo for u32 {}\n-    /// impl Foo for <u8 as Assoc>::Output {}  // <- this projection will fail\n-    /// ```\n-    ///\n-    /// The projection would succeed if `Output` had been defined\n-    /// directly in the impl for `u8`.\n-    ExactMatch,\n-\n     /// At type-checking time, we refuse to project any associated\n     /// type that is marked `default`. Non-`default` (\"final\") types\n     /// are always projected. This is necessary in general for\n@@ -90,7 +60,7 @@ pub enum Reveal {\n     /// fn main() {\n     ///     let <() as Assoc>::Output = true;\n     /// }\n-    NotSpecializable,\n+    UserFacing,\n \n     /// At trans time, all monomorphic projections will succeed.\n     /// Also, `impl Trait` is normalized to the concrete type,\n@@ -1208,7 +1178,8 @@ fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n     -> Progress<'tcx>\n {\n     let closure_typer = selcx.closure_typer();\n-    let closure_type = closure_typer.closure_type(vtable.closure_def_id, vtable.substs);\n+    let closure_type = closure_typer.closure_type(vtable.closure_def_id)\n+        .subst(selcx.tcx(), vtable.substs.substs);\n     let Normalized {\n         value: closure_type,\n         obligations\n@@ -1224,7 +1195,7 @@ fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n \n     confirm_callable_candidate(selcx,\n                                obligation,\n-                               &closure_type.sig,\n+                               closure_type,\n                                util::TupleArgumentsFlag::No)\n         .with_addl_obligations(vtable.nested)\n         .with_addl_obligations(obligations)\n@@ -1233,7 +1204,7 @@ fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n fn confirm_callable_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    fn_sig: &ty::PolyFnSig<'tcx>,\n+    fn_sig: ty::PolyFnSig<'tcx>,\n     flag: util::TupleArgumentsFlag)\n     -> Progress<'tcx>\n {\n@@ -1346,8 +1317,9 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n     -> Option<specialization_graph::NodeItem<ty::AssociatedItem>>\n {\n     let trait_def_id = selcx.tcx().impl_trait_ref(impl_def_id).unwrap().def_id;\n+    let trait_def = selcx.tcx().lookup_trait_def(trait_def_id);\n \n-    if selcx.projection_mode() == Reveal::ExactMatch {\n+    if !trait_def.is_complete(selcx.tcx()) {\n         let impl_node = specialization_graph::Node::Impl(impl_def_id);\n         for item in impl_node.items(selcx.tcx()) {\n             if item.kind == ty::AssociatedKind::Type && item.name == assoc_ty_name {\n@@ -1359,7 +1331,7 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n         }\n         None\n     } else {\n-        selcx.tcx().lookup_trait_def(trait_def_id)\n+        trait_def\n             .ancestors(impl_def_id)\n             .defs(selcx.tcx(), assoc_ty_name, ty::AssociatedKind::Type)\n             .next()"}, {"sha": "4c4ace0d8baf9629d64a1cb7a0c805405e27d731", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -1405,16 +1405,18 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             // provide an impl, but only for suitable `fn` pointers\n-            ty::TyFnDef(.., &ty::BareFnTy {\n+            ty::TyFnDef(.., ty::Binder(ty::FnSig {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: Abi::Rust,\n-                ref sig,\n-            }) |\n-            ty::TyFnPtr(&ty::BareFnTy {\n+                variadic: false,\n+                ..\n+            })) |\n+            ty::TyFnPtr(ty::Binder(ty::FnSig {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: Abi::Rust,\n-                ref sig\n-            }) if !sig.variadic() => {\n+                variadic: false,\n+                ..\n+            })) => {\n                 candidates.vec.push(FnPointerCandidate);\n             }\n \n@@ -1476,8 +1478,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     // `assemble_candidates_from_object_ty`.\n                 }\n                 ty::TyParam(..) |\n-                ty::TyProjection(..) |\n-                ty::TyAnon(..) => {\n+                ty::TyProjection(..) => {\n                     // In these cases, we don't know what the actual\n                     // type is.  Therefore, we cannot break it down\n                     // into its constituent types. So we don't\n@@ -1900,7 +1901,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyDynamic(..) |\n             ty::TyParam(..) |\n             ty::TyProjection(..) |\n-            ty::TyAnon(..) |\n             ty::TyInfer(ty::TyVar(_)) |\n             ty::TyInfer(ty::FreshTy(_)) |\n             ty::TyInfer(ty::FreshIntTy(_)) |\n@@ -1945,6 +1945,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     .map(|f| f.ty(self.tcx(), substs))\n                     .collect()\n             }\n+\n+            ty::TyAnon(def_id, substs) => {\n+                // We can resolve the `impl Trait` to its concrete type,\n+                // which enforces a DAG between the functions requiring\n+                // the auto trait bounds in question.\n+                vec![self.tcx().item_type(def_id).subst(self.tcx(), substs)]\n+            }\n         }\n     }\n \n@@ -2777,11 +2784,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                       substs: ty::ClosureSubsts<'tcx>)\n                                       -> ty::PolyTraitRef<'tcx>\n     {\n-        let closure_type = self.infcx.closure_type(closure_def_id, substs);\n+        let closure_type = self.infcx.closure_type(closure_def_id)\n+            .subst(self.tcx(), substs.substs);\n         let ty::Binder((trait_ref, _)) =\n             self.tcx().closure_trait_ref_and_return_type(obligation.predicate.def_id(),\n                                                          obligation.predicate.0.self_ty(), // (1)\n-                                                         &closure_type.sig,\n+                                                         closure_type,\n                                                          util::TupleArgumentsFlag::No);\n         // (1) Feels icky to skip the binder here, but OTOH we know\n         // that the self-type is an unboxed closure type and hence is"}, {"sha": "79df7de04f540a9c955a0a942660c5336d3d41da", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -189,7 +189,7 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              .subst(tcx, &penv.free_substs);\n \n     // Create a infcx, taking the predicates of impl1 as assumptions:\n-    let result = tcx.infer_ctxt(penv, Reveal::ExactMatch).enter(|infcx| {\n+    let result = tcx.infer_ctxt(penv, Reveal::UserFacing).enter(|infcx| {\n         // Normalize the trait reference. The WF rules ought to ensure\n         // that this always succeeds.\n         let impl1_trait_ref ="}, {"sha": "40eb69395678f2bd63d39a03d35b980e9d0524e9", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'gcx, 'tcx> Children {\n             let possible_sibling = *slot;\n \n             let tcx = tcx.global_tcx();\n-            let (le, ge) = tcx.infer_ctxt((), Reveal::ExactMatch).enter(|infcx| {\n+            let (le, ge) = tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n                 let overlap = traits::overlapping_impls(&infcx,\n                                                         possible_sibling,\n                                                         impl_def_id);"}, {"sha": "717c171db2ac7106a78ac11ff92dab42fbea2df1", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -269,20 +269,6 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for traits::DeferredObligation<'a> {\n-    type Lifted = traits::DeferredObligation<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.predicate).and_then(|predicate| {\n-            tcx.lift(&self.cause).map(|cause| {\n-                traits::DeferredObligation {\n-                    predicate: predicate,\n-                    cause: cause\n-                }\n-            })\n-        })\n-    }\n-}\n-\n // For trans only.\n impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n     type Lifted = traits::Vtable<'tcx, ()>;\n@@ -589,16 +575,3 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCause<'tcx> {\n         self.code.visit_with(visitor)\n     }\n }\n-\n-impl<'tcx> TypeFoldable<'tcx> for traits::DeferredObligation<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::DeferredObligation {\n-            predicate: self.predicate.fold_with(folder),\n-            cause: self.cause.fold_with(folder)\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.predicate.visit_with(visitor) || self.cause.visit_with(visitor)\n-    }\n-}"}, {"sha": "602f27a64d4d8d195b14c2903e4cfe6b2ac06f78", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -482,7 +482,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn closure_trait_ref_and_return_type(self,\n         fn_trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n-        sig: &ty::PolyFnSig<'tcx>,\n+        sig: ty::PolyFnSig<'tcx>,\n         tuple_arguments: TupleArgumentsFlag)\n         -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>)>\n     {"}, {"sha": "e14295982916f44ad0578777db464581b6a4554d", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -219,7 +219,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                         res = res - TC::OwnsDtor;\n                     }\n \n-                    if def.has_dtor() {\n+                    if def.has_dtor(tcx) {\n                         res = res | TC::OwnsDtor;\n                     }\n "}, {"sha": "6961e0da362a5f7835ca0decce0e93c9c603fe9e", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 53, "deletions": 158, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -10,7 +10,7 @@\n \n //! type context book-keeping\n \n-use dep_graph::{DepGraph, DepTrackingMap};\n+use dep_graph::DepGraph;\n use session::Session;\n use lint;\n use middle;\n@@ -32,26 +32,26 @@ use ty::{self, TraitRef, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants, Slice};\n use ty::{AdtKind, AdtDef, ClosureSubsts, Region};\n use hir::FreevarMap;\n-use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n+use ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n use ty::layout::{Layout, TargetDataLayout};\n use ty::inhabitedness::DefIdForest;\n use ty::maps;\n-use util::common::MemoizationMap;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n use arena::{TypedArena, DroplessArena};\n+use rustc_data_structures::indexed_vec::IndexVec;\n use std::borrow::Borrow;\n use std::cell::{Cell, RefCell};\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::ops::Deref;\n-use std::rc::Rc;\n use std::iter;\n use std::cmp::Ordering;\n+use syntax::abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n use syntax::symbol::{Symbol, keywords};\n@@ -64,7 +64,7 @@ pub struct GlobalArenas<'tcx> {\n     layout: TypedArena<Layout>,\n \n     // references\n-    generics: TypedArena<ty::Generics<'tcx>>,\n+    generics: TypedArena<ty::Generics>,\n     trait_def: TypedArena<ty::TraitDef>,\n     adt_def: TypedArena<ty::AdtDef>,\n     mir: TypedArena<RefCell<Mir<'tcx>>>,\n@@ -93,7 +93,6 @@ pub struct CtxtInterners<'tcx> {\n     type_: RefCell<FxHashSet<Interned<'tcx, TyS<'tcx>>>>,\n     type_list: RefCell<FxHashSet<Interned<'tcx, Slice<Ty<'tcx>>>>>,\n     substs: RefCell<FxHashSet<Interned<'tcx, Substs<'tcx>>>>,\n-    bare_fn: RefCell<FxHashSet<Interned<'tcx, BareFnTy<'tcx>>>>,\n     region: RefCell<FxHashSet<Interned<'tcx, Region>>>,\n     existential_predicates: RefCell<FxHashSet<Interned<'tcx, Slice<ExistentialPredicate<'tcx>>>>>,\n }\n@@ -105,7 +104,6 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n             type_: RefCell::new(FxHashSet()),\n             type_list: RefCell::new(FxHashSet()),\n             substs: RefCell::new(FxHashSet()),\n-            bare_fn: RefCell::new(FxHashSet()),\n             region: RefCell::new(FxHashSet()),\n             existential_predicates: RefCell::new(FxHashSet()),\n         }\n@@ -218,9 +216,9 @@ pub struct TypeckTables<'tcx> {\n     pub upvar_capture_map: ty::UpvarCaptureMap<'tcx>,\n \n     /// Records the type of each closure.\n-    pub closure_tys: NodeMap<ty::ClosureTy<'tcx>>,\n+    pub closure_tys: NodeMap<ty::PolyFnSig<'tcx>>,\n \n-    /// Records the type of each closure.\n+    /// Records the kind of each closure.\n     pub closure_kinds: NodeMap<ty::ClosureKind>,\n \n     /// For each fn, records the \"liberated\" types of its arguments\n@@ -242,6 +240,14 @@ pub struct TypeckTables<'tcx> {\n \n     /// Lints for the body of this fn generated by typeck.\n     pub lints: lint::LintTable,\n+\n+    /// Set of trait imports actually used in the method resolution.\n+    /// This is used for warning unused imports.\n+    pub used_trait_imports: DefIdSet,\n+\n+    /// If any errors occurred while type-checking this body,\n+    /// this field will be set to `true`.\n+    pub tainted_by_errors: bool,\n }\n \n impl<'tcx> TypeckTables<'tcx> {\n@@ -259,6 +265,8 @@ impl<'tcx> TypeckTables<'tcx> {\n             fru_field_types: NodeMap(),\n             cast_kinds: NodeMap(),\n             lints: lint::LintTable::new(),\n+            used_trait_imports: DefIdSet(),\n+            tainted_by_errors: false,\n         }\n     }\n \n@@ -389,15 +397,15 @@ pub struct GlobalCtxt<'tcx> {\n     global_arenas: &'tcx GlobalArenas<'tcx>,\n     global_interners: CtxtInterners<'tcx>,\n \n+    pub sess: &'tcx Session,\n+\n     pub specializes_cache: RefCell<traits::SpecializesCache>,\n \n     pub dep_graph: DepGraph,\n \n     /// Common types, pre-interned for your convenience.\n     pub types: CommonTypes<'tcx>,\n \n-    pub sess: &'tcx Session,\n-\n     /// Map indicating what traits are in scope for places where this\n     /// is relevant; generated by resolve.\n     pub trait_map: TraitMap,\n@@ -412,44 +420,9 @@ pub struct GlobalCtxt<'tcx> {\n     // borrowck. (They are not used during trans, and hence are not\n     // serialized or needed for cross-crate fns.)\n     free_region_maps: RefCell<NodeMap<FreeRegionMap>>,\n-    // FIXME: jroesch make this a refcell\n-\n-    pub tables: RefCell<DepTrackingMap<maps::TypeckTables<'tcx>>>,\n-\n-    /// Maps from a trait item to the trait item \"descriptor\"\n-    pub associated_items: RefCell<DepTrackingMap<maps::AssociatedItems<'tcx>>>,\n-\n-    /// Maps from an impl/trait def-id to a list of the def-ids of its items\n-    pub associated_item_def_ids: RefCell<DepTrackingMap<maps::AssociatedItemDefIds<'tcx>>>,\n-\n-    pub impl_trait_refs: RefCell<DepTrackingMap<maps::ImplTraitRefs<'tcx>>>,\n-    pub trait_defs: RefCell<DepTrackingMap<maps::TraitDefs<'tcx>>>,\n-    pub adt_defs: RefCell<DepTrackingMap<maps::AdtDefs<'tcx>>>,\n-    pub adt_sized_constraint: RefCell<DepTrackingMap<maps::AdtSizedConstraint<'tcx>>>,\n-\n-    /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n-    /// associated generics and predicates.\n-    pub generics: RefCell<DepTrackingMap<maps::Generics<'tcx>>>,\n-    pub predicates: RefCell<DepTrackingMap<maps::Predicates<'tcx>>>,\n-\n-    /// Maps from the def-id of a trait to the list of\n-    /// super-predicates. This is a subset of the full list of\n-    /// predicates. We store these in a separate map because we must\n-    /// evaluate them even during type conversion, often before the\n-    /// full predicates are available (note that supertraits have\n-    /// additional acyclicity requirements).\n-    pub super_predicates: RefCell<DepTrackingMap<maps::Predicates<'tcx>>>,\n \n     pub hir: hir_map::Map<'tcx>,\n-\n-    /// Maps from the def-id of a function/method or const/static\n-    /// to its MIR. Mutation is done at an item granularity to\n-    /// allow MIR optimization passes to function and still\n-    /// access cross-crate MIR (e.g. inlining or const eval).\n-    ///\n-    /// Note that cross-crate MIR appears to be always borrowed\n-    /// (in the `RefCell` sense) to prevent accidental mutation.\n-    pub mir_map: RefCell<DepTrackingMap<maps::Mir<'tcx>>>,\n+    pub maps: maps::Maps<'tcx>,\n \n     // Records the free variables refrenced by every closure\n     // expression. Do not track deps for this, just recompute it from\n@@ -458,37 +431,22 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub maybe_unused_trait_imports: NodeSet,\n \n-    // Records the type of every item.\n-    pub item_types: RefCell<DepTrackingMap<maps::Types<'tcx>>>,\n-\n     // Internal cache for metadata decoding. No need to track deps on this.\n     pub rcache: RefCell<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n \n     // Cache for the type-contents routine. FIXME -- track deps?\n     pub tc_cache: RefCell<FxHashMap<Ty<'tcx>, ty::contents::TypeContents>>,\n \n-    // FIXME no dep tracking, but we should be able to remove this\n-    pub ty_param_defs: RefCell<NodeMap<ty::TypeParameterDef<'tcx>>>,\n-\n     // FIXME dep tracking -- should be harmless enough\n     pub normalized_cache: RefCell<FxHashMap<Ty<'tcx>, Ty<'tcx>>>,\n \n     pub inhabitedness_cache: RefCell<FxHashMap<Ty<'tcx>, DefIdForest>>,\n \n     pub lang_items: middle::lang_items::LanguageItems,\n \n-    /// Maps from def-id of a type or region parameter to its\n-    /// (inferred) variance.\n-    pub item_variance_map: RefCell<DepTrackingMap<maps::ItemVariances<'tcx>>>,\n-\n     /// True if the variance has been computed yet; false otherwise.\n     pub variance_computed: Cell<bool>,\n \n-    /// Maps a DefId of a type to a list of its inherent impls.\n-    /// Contains implementations of methods that are inherent to a type.\n-    /// Methods in these implementations don't need to be exported.\n-    pub inherent_impls: RefCell<DepTrackingMap<maps::InherentImpls<'tcx>>>,\n-\n     /// Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     /// present in this set can be warned about.\n     pub used_unsafe: RefCell<NodeSet>,\n@@ -498,10 +456,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// about.\n     pub used_mut_nodes: RefCell<NodeSet>,\n \n-    /// Set of trait imports actually used in the method resolution.\n-    /// This is used for warning unused imports.\n-    pub used_trait_imports: RefCell<DepTrackingMap<maps::UsedTraitImports<'tcx>>>,\n-\n     /// The set of external nominal types whose implementations have been read.\n     /// This is used for lazy resolution of methods.\n     pub populated_external_types: RefCell<DefIdSet>,\n@@ -528,23 +482,9 @@ pub struct GlobalCtxt<'tcx> {\n     /// (i.e., no type or lifetime parameters).\n     pub fulfilled_predicates: RefCell<traits::GlobalFulfilledPredicates<'tcx>>,\n \n-    /// Caches the representation hints for struct definitions.\n-    repr_hint_cache: RefCell<DepTrackingMap<maps::ReprHints<'tcx>>>,\n-\n     /// Maps Expr NodeId's to `true` iff `&expr` can have 'static lifetime.\n     pub rvalue_promotable_to_static: RefCell<NodeMap<bool>>,\n \n-    /// Caches CoerceUnsized kinds for impls on custom types.\n-    pub custom_coerce_unsized_kinds: RefCell<DefIdMap<ty::adjustment::CustomCoerceUnsized>>,\n-\n-    /// Records the type of each closure. The def ID is the ID of the\n-    /// expression defining the closure.\n-    pub closure_tys: RefCell<DepTrackingMap<maps::ClosureTypes<'tcx>>>,\n-\n-    /// Records the type of each closure. The def ID is the ID of the\n-    /// expression defining the closure.\n-    pub closure_kinds: RefCell<DepTrackingMap<maps::ClosureKinds<'tcx>>>,\n-\n     /// Maps Fn items to a collection of fragment infos.\n     ///\n     /// The main goal is to identify data (each of which may be moved\n@@ -592,6 +532,15 @@ pub struct GlobalCtxt<'tcx> {\n     stability_interner: RefCell<FxHashSet<&'tcx attr::Stability>>,\n \n     layout_interner: RefCell<FxHashSet<&'tcx Layout>>,\n+\n+    /// A vector of every trait accessible in the whole crate\n+    /// (i.e. including those from subcrates). This is used only for\n+    /// error reporting, and so is lazily initialised and generally\n+    /// shouldn't taint the common path (hence the RefCell).\n+    pub all_traits: RefCell<Option<Vec<DefId>>>,\n+\n+    /// HIR Ty -> Ty lowering cache.\n+    pub ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n }\n \n impl<'tcx> GlobalCtxt<'tcx> {\n@@ -646,15 +595,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn type_parameter_def(self,\n-                              node_id: NodeId)\n-                              -> ty::TypeParameterDef<'tcx>\n-    {\n-        self.ty_param_defs.borrow().get(&node_id).unwrap().clone()\n-    }\n-\n-    pub fn alloc_generics(self, generics: ty::Generics<'gcx>)\n-                          -> &'gcx ty::Generics<'gcx> {\n+    pub fn alloc_generics(self, generics: ty::Generics) -> &'gcx ty::Generics {\n         self.global_arenas.generics.alloc(generics)\n     }\n \n@@ -673,12 +614,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn alloc_adt_def(self,\n                          did: DefId,\n                          kind: AdtKind,\n-                         discr_ty: Option<attr::IntType>,\n                          variants: Vec<ty::VariantDef>,\n                          repr: ReprOptions)\n                          -> &'gcx ty::AdtDef {\n-        let discr_ty = discr_ty.unwrap_or(attr::UnsignedInt(ast::UintTy::U8));\n-        let def = ty::AdtDef::new(self, did, kind, discr_ty, variants, repr);\n+        let def = ty::AdtDef::new(self, did, kind, variants, repr);\n         self.global_arenas.adt_def.alloc(def)\n     }\n \n@@ -737,6 +676,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n     /// reference to the context, to allow formatting values that need it.\n     pub fn create_and_enter<F, R>(s: &'tcx Session,\n+                                  local_providers: ty::maps::Providers<'tcx>,\n+                                  extern_providers: ty::maps::Providers<'tcx>,\n                                   arenas: &'tcx GlobalArenas<'tcx>,\n                                   arena: &'tcx DroplessArena,\n                                   resolutions: ty::Resolutions,\n@@ -754,7 +695,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let common_types = CommonTypes::new(&interners);\n         let dep_graph = hir.dep_graph.clone();\n         let fulfilled_predicates = traits::GlobalFulfilledPredicates::new(dep_graph.clone());\n+        let max_cnum = s.cstore.crates().iter().map(|c| c.as_usize()).max().unwrap_or(0);\n+        let mut providers = IndexVec::from_elem_n(extern_providers, max_cnum + 1);\n+        providers[LOCAL_CRATE] = local_providers;\n         tls::enter_global(GlobalCtxt {\n+            sess: s,\n             specializes_cache: RefCell::new(traits::SpecializesCache::new()),\n             global_arenas: arenas,\n             global_interners: interners,\n@@ -763,46 +708,26 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             named_region_map: named_region_map,\n             region_maps: region_maps,\n             free_region_maps: RefCell::new(FxHashMap()),\n-            item_variance_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             variance_computed: Cell::new(false),\n-            sess: s,\n             trait_map: resolutions.trait_map,\n-            tables: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            impl_trait_refs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            trait_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            adt_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            adt_sized_constraint: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            generics: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            super_predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             fulfilled_predicates: RefCell::new(fulfilled_predicates),\n             hir: hir,\n-            mir_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            maps: maps::Maps::new(dep_graph, providers),\n             freevars: RefCell::new(resolutions.freevars),\n             maybe_unused_trait_imports: resolutions.maybe_unused_trait_imports,\n-            item_types: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             rcache: RefCell::new(FxHashMap()),\n             tc_cache: RefCell::new(FxHashMap()),\n-            associated_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            associated_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            ty_param_defs: RefCell::new(NodeMap()),\n             normalized_cache: RefCell::new(FxHashMap()),\n             inhabitedness_cache: RefCell::new(FxHashMap()),\n             lang_items: lang_items,\n-            inherent_impls: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             used_unsafe: RefCell::new(NodeSet()),\n             used_mut_nodes: RefCell::new(NodeSet()),\n-            used_trait_imports: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             populated_external_types: RefCell::new(DefIdSet()),\n             populated_external_primitive_impls: RefCell::new(DefIdSet()),\n             stability: RefCell::new(stability),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n-            repr_hint_cache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             rvalue_promotable_to_static: RefCell::new(NodeMap()),\n-            custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n-            closure_tys: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            closure_kinds: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             fragment_infos: RefCell::new(DefIdMap()),\n             crate_name: Symbol::intern(crate_name),\n             data_layout: data_layout,\n@@ -811,6 +736,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             layout_depth: Cell::new(0),\n             derive_macros: RefCell::new(NodeMap()),\n             stability_interner: RefCell::new(FxHashSet()),\n+            all_traits: RefCell::new(None),\n+            ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n        }, f)\n     }\n }\n@@ -933,23 +860,6 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Slice<ExistentialPredicate<'a>> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a BareFnTy<'a> {\n-    type Lifted = &'tcx BareFnTy<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n-                             -> Option<&'tcx BareFnTy<'tcx>> {\n-        if tcx.interners.arena.in_arena(*self as *const _) {\n-            return Some(unsafe { mem::transmute(*self) });\n-        }\n-        // Also try in the global tcx if we're not that.\n-        if !tcx.is_global() {\n-            self.lift_to_tcx(tcx.global_tcx())\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-\n pub mod tls {\n     use super::{CtxtInterners, GlobalCtxt, TyCtxt};\n \n@@ -1102,7 +1012,6 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             TyDynamic, TyClosure, TyTuple, TyParam, TyInfer, TyProjection, TyAnon);\n \n         println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n-        println!(\"BareFnTy interner: #{}\", self.interners.bare_fn.borrow().len());\n         println!(\"Region interner: #{}\", self.interners.region.borrow().len());\n         println!(\"Stability interner: #{}\", self.stability_interner.borrow().len());\n         println!(\"Layout interner: #{}\", self.layout_interner.borrow().len());\n@@ -1161,12 +1070,6 @@ impl<'tcx: 'lcx, 'lcx> Borrow<[Kind<'lcx>]> for Interned<'tcx, Substs<'tcx>> {\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<BareFnTy<'lcx>> for Interned<'tcx, BareFnTy<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a BareFnTy<'lcx> {\n-        self.0\n-    }\n-}\n-\n impl<'tcx> Borrow<Region> for Interned<'tcx, Region> {\n     fn borrow<'a>(&'a self) -> &'a Region {\n         self.0\n@@ -1255,9 +1158,6 @@ fn keep_local<'tcx, T: ty::TypeFoldable<'tcx>>(x: &T) -> bool {\n }\n \n direct_interners!('tcx,\n-    bare_fn: mk_bare_fn(|fty: &BareFnTy| {\n-        keep_local(&fty.sig)\n-    }) -> BareFnTy<'tcx>,\n     region: mk_region(|r| {\n         match r {\n             &ty::ReVar(_) | &ty::ReSkolemized(..) => true,\n@@ -1283,12 +1183,11 @@ slice_interners!(\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Create an unsafe fn ty based on a safe fn ty.\n-    pub fn safe_to_unsafe_fn_ty(self, bare_fn: &BareFnTy<'tcx>) -> Ty<'tcx> {\n-        assert_eq!(bare_fn.unsafety, hir::Unsafety::Normal);\n-        self.mk_fn_ptr(self.mk_bare_fn(ty::BareFnTy {\n+    pub fn safe_to_unsafe_fn_ty(self, sig: PolyFnSig<'tcx>) -> Ty<'tcx> {\n+        assert_eq!(sig.unsafety(), hir::Unsafety::Normal);\n+        self.mk_fn_ptr(sig.map_bound(|sig| ty::FnSig {\n             unsafety: hir::Unsafety::Unsafe,\n-            abi: bare_fn.abi,\n-            sig: bare_fn.sig.clone()\n+            ..sig\n         }))\n     }\n \n@@ -1415,11 +1314,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn mk_fn_def(self, def_id: DefId,\n                      substs: &'tcx Substs<'tcx>,\n-                     fty: &'tcx BareFnTy<'tcx>) -> Ty<'tcx> {\n+                     fty: PolyFnSig<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(TyFnDef(def_id, substs, fty))\n     }\n \n-    pub fn mk_fn_ptr(self, fty: &'tcx BareFnTy<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_fn_ptr(self, fty: PolyFnSig<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(TyFnPtr(fty))\n     }\n \n@@ -1513,14 +1412,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn mk_fn_sig<I>(self, inputs: I, output: I::Item, variadic: bool)\n+    pub fn mk_fn_sig<I>(self,\n+                        inputs: I,\n+                        output: I::Item,\n+                        variadic: bool,\n+                        unsafety: hir::Unsafety,\n+                        abi: abi::Abi)\n         -> <I::Item as InternIteratorElement<Ty<'tcx>, ty::FnSig<'tcx>>>::Output\n         where I: Iterator,\n               I::Item: InternIteratorElement<Ty<'tcx>, ty::FnSig<'tcx>>\n     {\n         inputs.chain(iter::once(output)).intern_with(|xs| ty::FnSig {\n             inputs_and_output: self.intern_type_list(xs),\n-            variadic: variadic\n+            variadic, unsafety, abi\n         })\n     }\n \n@@ -1547,15 +1451,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     {\n         self.mk_substs(iter::once(s).chain(t.into_iter().cloned()).map(Kind::from))\n     }\n-\n-    /// Obtain the representation annotation for a struct definition.\n-    pub fn lookup_repr_hints(self, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n-        self.repr_hint_cache.memoize(did, || {\n-            Rc::new(self.get_attrs(did).iter().flat_map(|meta| {\n-                attr::find_repr_attrs(self.sess.diagnostic(), meta).into_iter()\n-            }).collect())\n-        })\n-    }\n }\n \n pub trait InternAs<T: ?Sized, R> {"}, {"sha": "44a3aabc0560abe2f6efccc747c3cff9c6a3fd35", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -10,7 +10,7 @@\n \n use hir::def_id::DefId;\n use infer::type_variable;\n-use ty::{self, BoundRegion, Region, Ty, TyCtxt};\n+use ty::{self, BoundRegion, DefIdTree, Region, Ty, TyCtxt};\n \n use std::fmt;\n use syntax::abi;\n@@ -287,8 +287,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         db.span_note(span, \"a default was defined here...\");\n                     }\n                     None => {\n+                        let item_def_id = self.parent(expected.def_id).unwrap();\n                         db.note(&format!(\"a default is defined on `{}`\",\n-                                         self.item_path_str(expected.def_id)));\n+                                         self.item_path_str(item_def_id)));\n                     }\n                 }\n \n@@ -301,8 +302,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         db.span_note(span, \"a second default was defined here...\");\n                     }\n                     None => {\n+                        let item_def_id = self.parent(found.def_id).unwrap();\n                         db.note(&format!(\"a second default is defined on `{}`\",\n-                                         self.item_path_str(found.def_id)));\n+                                         self.item_path_str(item_def_id)));\n                     }\n                 }\n "}, {"sha": "3d2cc4c598a22ea66677cc53010e271920c0c3e2", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -76,7 +76,7 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             Some(TupleSimplifiedType(tys.len()))\n         }\n         ty::TyFnDef(.., ref f) | ty::TyFnPtr(ref f) => {\n-            Some(FunctionSimplifiedType(f.sig.skip_binder().inputs().len()))\n+            Some(FunctionSimplifiedType(f.skip_binder().inputs().len()))\n         }\n         ty::TyProjection(_) | ty::TyParam(_) => {\n             if can_simplify_params {"}, {"sha": "384f99ceb4e83dff078b5201e7326417a86e4878", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -155,13 +155,13 @@ impl FlagComputation {\n                 self.add_tys(&ts[..]);\n             }\n \n-            &ty::TyFnDef(_, substs, ref f) => {\n+            &ty::TyFnDef(_, substs, f) => {\n                 self.add_substs(substs);\n-                self.add_fn_sig(&f.sig);\n+                self.add_fn_sig(f);\n             }\n \n-            &ty::TyFnPtr(ref f) => {\n-                self.add_fn_sig(&f.sig);\n+            &ty::TyFnPtr(f) => {\n+                self.add_fn_sig(f);\n             }\n         }\n     }\n@@ -177,7 +177,7 @@ impl FlagComputation {\n         }\n     }\n \n-    fn add_fn_sig(&mut self, fn_sig: &ty::PolyFnSig) {\n+    fn add_fn_sig(&mut self, fn_sig: ty::PolyFnSig) {\n         let mut computation = FlagComputation::new();\n \n         computation.add_tys(fn_sig.skip_binder().inputs());"}, {"sha": "e29653c9e88a03a7b81042850a40e41dd7886c45", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -159,19 +159,6 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n         sig.super_fold_with(self)\n     }\n \n-    fn fold_bare_fn_ty(&mut self,\n-                       fty: &'tcx ty::BareFnTy<'tcx>)\n-                       -> &'tcx ty::BareFnTy<'tcx>\n-    {\n-        fty.super_fold_with(self)\n-    }\n-\n-    fn fold_closure_ty(&mut self,\n-                       fty: &ty::ClosureTy<'tcx>)\n-                       -> ty::ClosureTy<'tcx> {\n-        fty.super_fold_with(self)\n-    }\n-\n     fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n         r.super_fold_with(self)\n     }"}, {"sha": "7bf1ba155b53511964c7e95edfc2e755e190a1e3", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -201,7 +201,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         } else {\n             // for local crates, check whether type info is\n             // available; typeck might not have completed yet\n-            self.impl_trait_refs.borrow().contains_key(&impl_def_id)\n+            self.maps.impl_trait_ref.borrow().contains_key(&impl_def_id)\n         };\n \n         if !use_types {"}, {"sha": "e7895ca799012530852c0c49be85c9a95466f3bd", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -1146,7 +1146,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n             }\n \n             // SIMD vector types.\n-            ty::TyAdt(def, ..) if def.is_simd() => {\n+            ty::TyAdt(def, ..) if def.repr.simd => {\n                 let element = ty.simd_type(tcx);\n                 match *element.layout(infcx)? {\n                     Scalar { value, .. } => {\n@@ -1181,8 +1181,8 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     let (mut min, mut max, mut non_zero) = (i64::max_value(),\n                                                             i64::min_value(),\n                                                             true);\n-                    for v in &def.variants {\n-                        let x = v.disr_val as i128 as i64;\n+                    for discr in def.discriminants(tcx) {\n+                        let x = discr.to_u128_unchecked() as i64;\n                         if x == 0 { non_zero = false; }\n                         if x < min { min = x; }\n                         if x > max { max = x; }\n@@ -1222,9 +1222,8 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     let fields = def.variants[0].fields.iter().map(|field| {\n                         field.ty(tcx, substs).layout(infcx)\n                     }).collect::<Result<Vec<_>, _>>()?;\n-                    let packed = tcx.lookup_packed(def.did);\n                     let layout = if def.is_union() {\n-                        let mut un = Union::new(dl, packed);\n+                        let mut un = Union::new(dl, def.repr.packed);\n                         un.extend(dl, fields.iter().map(|&f| Ok(f)), ty)?;\n                         UntaggedUnion { variants: un }\n                     } else {\n@@ -1240,7 +1239,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 // non-empty body, explicit discriminants should have\n                 // been rejected by a checker before this point.\n                 for (i, v) in def.variants.iter().enumerate() {\n-                    if i as u128 != v.disr_val {\n+                    if v.discr != ty::VariantDiscr::Relative(i) {\n                         bug!(\"non-C-like enum {} with specified discriminants\",\n                             tcx.item_path_str(def.did));\n                     }\n@@ -1348,7 +1347,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     return Err(LayoutError::SizeOverflow(ty));\n                 }\n \n-                let typeck_ity = Integer::from_attr(dl, def.discr_ty);\n+                let typeck_ity = Integer::from_attr(dl, def.repr.discr_type());\n                 if typeck_ity < min_ity {\n                     // It is a bug if Layout decided on a greater discriminant size than typeck for\n                     // some reason at this point (based on values discriminant can take on). Mostly"}, {"sha": "fd1403b15bc892fb4414aec38e9891dae1080d5c", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 385, "deletions": 40, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -8,46 +8,391 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use dep_graph::{DepNode, DepTrackingMapConfig};\n-use hir::def_id::DefId;\n+use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig};\n+use hir::def_id::{CrateNum, DefId};\n+use middle::const_val::ConstVal;\n use mir;\n-use ty::{self, Ty};\n-use util::nodemap::DefIdSet;\n+use ty::{self, Ty, TyCtxt};\n \n-use std::cell::RefCell;\n-use std::marker::PhantomData;\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use std::cell::{RefCell, RefMut};\n use std::rc::Rc;\n-use syntax::attr;\n-\n-macro_rules! dep_map_ty {\n-    ($ty_name:ident : $node_name:ident ($key:ty) -> $value:ty) => {\n-        pub struct $ty_name<'tcx> {\n-            data: PhantomData<&'tcx ()>\n-        }\n-\n-        impl<'tcx> DepTrackingMapConfig for $ty_name<'tcx> {\n-            type Key = $key;\n-            type Value = $value;\n-            fn to_dep_node(key: &$key) -> DepNode<DefId> { DepNode::$node_name(*key) }\n-        }\n-    }\n-}\n-\n-dep_map_ty! { AssociatedItems: AssociatedItems(DefId) -> ty::AssociatedItem }\n-dep_map_ty! { Types: ItemSignature(DefId) -> Ty<'tcx> }\n-dep_map_ty! { Generics: ItemSignature(DefId) -> &'tcx ty::Generics<'tcx> }\n-dep_map_ty! { Predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n-dep_map_ty! { SuperPredicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n-dep_map_ty! { AssociatedItemDefIds: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>> }\n-dep_map_ty! { ImplTraitRefs: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>> }\n-dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef }\n-dep_map_ty! { AdtDefs: ItemSignature(DefId) -> &'tcx ty::AdtDef }\n-dep_map_ty! { AdtSizedConstraint: SizedConstraint(DefId) -> Ty<'tcx> }\n-dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>> }\n-dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Vec<DefId> }\n-dep_map_ty! { ReprHints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>> }\n-dep_map_ty! { Mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>> }\n-dep_map_ty! { ClosureKinds: ItemSignature(DefId) -> ty::ClosureKind }\n-dep_map_ty! { ClosureTypes: ItemSignature(DefId) -> ty::ClosureTy<'tcx> }\n-dep_map_ty! { TypeckTables: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx> }\n-dep_map_ty! { UsedTraitImports: UsedTraitImports(DefId) -> DefIdSet }\n+use syntax_pos::{Span, DUMMY_SP};\n+\n+trait Key {\n+    fn map_crate(&self) -> CrateNum;\n+    fn default_span(&self, tcx: TyCtxt) -> Span;\n+}\n+\n+impl Key for CrateNum {\n+    fn map_crate(&self) -> CrateNum {\n+        *self\n+    }\n+    fn default_span(&self, _: TyCtxt) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n+impl Key for DefId {\n+    fn map_crate(&self) -> CrateNum {\n+        self.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        tcx.def_span(*self)\n+    }\n+}\n+\n+impl Key for (DefId, DefId) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.1.default_span(tcx)\n+    }\n+}\n+\n+impl Key for (CrateNum, DefId) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.0\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.1.default_span(tcx)\n+    }\n+}\n+\n+trait Value<'tcx>: Sized {\n+    fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self;\n+}\n+\n+impl<'tcx, T> Value<'tcx> for T {\n+    default fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> T {\n+        tcx.sess.abort_if_errors();\n+        bug!(\"Value::from_cycle_error called without errors\");\n+    }\n+}\n+\n+impl<'tcx, T: Default> Value<'tcx> for T {\n+    default fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> T {\n+        T::default()\n+    }\n+}\n+\n+impl<'tcx> Value<'tcx> for Ty<'tcx> {\n+    fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+        tcx.types.err\n+    }\n+}\n+\n+pub struct CycleError<'a> {\n+    span: Span,\n+    cycle: RefMut<'a, [(Span, Query)]>\n+}\n+\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub fn report_cycle(self, CycleError { span, cycle }: CycleError) {\n+        assert!(!cycle.is_empty());\n+\n+        let mut err = struct_span_err!(self.sess, span, E0391,\n+            \"unsupported cyclic reference between types/traits detected\");\n+        err.span_label(span, &format!(\"cyclic reference\"));\n+\n+        err.span_note(cycle[0].0, &format!(\"the cycle begins when {}...\",\n+                                           cycle[0].1.describe(self)));\n+\n+        for &(span, ref query) in &cycle[1..] {\n+            err.span_note(span, &format!(\"...which then requires {}...\",\n+                                         query.describe(self)));\n+        }\n+\n+        err.note(&format!(\"...which then again requires {}, completing the cycle.\",\n+                          cycle[0].1.describe(self)));\n+\n+        err.emit();\n+    }\n+\n+    fn cycle_check<F, R>(self, span: Span, query: Query, compute: F)\n+                         -> Result<R, CycleError<'a>>\n+        where F: FnOnce() -> R\n+    {\n+        {\n+            let mut stack = self.maps.query_stack.borrow_mut();\n+            if let Some((i, _)) = stack.iter().enumerate().rev()\n+                                       .find(|&(_, &(_, ref q))| *q == query) {\n+                return Err(CycleError {\n+                    span: span,\n+                    cycle: RefMut::map(stack, |stack| &mut stack[i..])\n+                });\n+            }\n+            stack.push((span, query));\n+        }\n+\n+        let result = compute();\n+\n+        self.maps.query_stack.borrow_mut().pop();\n+\n+        Ok(result)\n+    }\n+}\n+\n+trait QueryDescription: DepTrackingMapConfig {\n+    fn describe(tcx: TyCtxt, key: Self::Key) -> String;\n+}\n+\n+impl<M: DepTrackingMapConfig<Key=DefId>> QueryDescription for M {\n+    default fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"processing `{}`\", tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::super_predicates<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"computing the supertraits of `{}`\",\n+                tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::type_param_predicates<'tcx> {\n+    fn describe(tcx: TyCtxt, (_, def_id): (DefId, DefId)) -> String {\n+        let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+        format!(\"computing the bounds for type parameter `{}`\",\n+                tcx.hir.ty_param_name(id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::coherent_trait<'tcx> {\n+    fn describe(tcx: TyCtxt, (_, def_id): (CrateNum, DefId)) -> String {\n+        format!(\"coherence checking all impls of trait `{}`\",\n+                tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::coherent_inherent_impls<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        format!(\"coherence checking all inherent impls\")\n+    }\n+}\n+\n+macro_rules! define_maps {\n+    (<$tcx:tt>\n+     $($(#[$attr:meta])*\n+       pub $name:ident: $node:ident($K:ty) -> $V:ty),*) => {\n+        pub struct Maps<$tcx> {\n+            providers: IndexVec<CrateNum, Providers<$tcx>>,\n+            query_stack: RefCell<Vec<(Span, Query)>>,\n+            $($(#[$attr])* pub $name: RefCell<DepTrackingMap<queries::$name<$tcx>>>),*\n+        }\n+\n+        impl<$tcx> Maps<$tcx> {\n+            pub fn new(dep_graph: DepGraph,\n+                       providers: IndexVec<CrateNum, Providers<$tcx>>)\n+                       -> Self {\n+                Maps {\n+                    providers,\n+                    query_stack: RefCell::new(vec![]),\n+                    $($name: RefCell::new(DepTrackingMap::new(dep_graph.clone()))),*\n+                }\n+            }\n+        }\n+\n+        #[allow(bad_style)]\n+        #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+        pub enum Query {\n+            $($(#[$attr])* $name($K)),*\n+        }\n+\n+        impl Query {\n+            pub fn describe(&self, tcx: TyCtxt) -> String {\n+                match *self {\n+                    $(Query::$name(key) => queries::$name::describe(tcx, key)),*\n+                }\n+            }\n+        }\n+\n+        pub mod queries {\n+            use std::marker::PhantomData;\n+\n+            $(#[allow(bad_style)]\n+            pub struct $name<$tcx> {\n+                data: PhantomData<&$tcx ()>\n+            })*\n+        }\n+\n+        $(impl<$tcx> DepTrackingMapConfig for queries::$name<$tcx> {\n+            type Key = $K;\n+            type Value = $V;\n+\n+            #[allow(unused)]\n+            fn to_dep_node(key: &$K) -> DepNode<DefId> {\n+                use dep_graph::DepNode::*;\n+\n+                $node(*key)\n+            }\n+        }\n+        impl<'a, $tcx, 'lcx> queries::$name<$tcx> {\n+            fn try_get_with<F, R>(tcx: TyCtxt<'a, $tcx, 'lcx>,\n+                                  mut span: Span,\n+                                  key: $K,\n+                                  f: F)\n+                                  -> Result<R, CycleError<'a>>\n+                where F: FnOnce(&$V) -> R\n+            {\n+                if let Some(result) = tcx.maps.$name.borrow().get(&key) {\n+                    return Ok(f(result));\n+                }\n+\n+                // FIXME(eddyb) Get more valid Span's on queries.\n+                if span == DUMMY_SP {\n+                    span = key.default_span(tcx);\n+                }\n+\n+                let _task = tcx.dep_graph.in_task(Self::to_dep_node(&key));\n+\n+                let result = tcx.cycle_check(span, Query::$name(key), || {\n+                    let provider = tcx.maps.providers[key.map_crate()].$name;\n+                    provider(tcx.global_tcx(), key)\n+                })?;\n+\n+                Ok(f(&tcx.maps.$name.borrow_mut().entry(key).or_insert(result)))\n+            }\n+\n+            pub fn try_get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K)\n+                           -> Result<$V, CycleError<'a>> {\n+                Self::try_get_with(tcx, span, key, Clone::clone)\n+            }\n+\n+            $(#[$attr])*\n+            pub fn get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K) -> $V {\n+                Self::try_get(tcx, span, key).unwrap_or_else(|e| {\n+                    tcx.report_cycle(e);\n+                    Value::from_cycle_error(tcx.global_tcx())\n+                })\n+            }\n+\n+            pub fn force(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K) {\n+                // FIXME(eddyb) Move away from using `DepTrackingMap`\n+                // so we don't have to explicitly ignore a false edge:\n+                // we can't observe a value dependency, only side-effects,\n+                // through `force`, and once everything has been updated,\n+                // perhaps only diagnostics, if those, will remain.\n+                let _ignore = tcx.dep_graph.in_ignore();\n+                match Self::try_get_with(tcx, span, key, |_| ()) {\n+                    Ok(()) => {}\n+                    Err(e) => tcx.report_cycle(e)\n+                }\n+            }\n+        })*\n+\n+        pub struct Providers<$tcx> {\n+            $(pub $name: for<'a> fn(TyCtxt<'a, $tcx, $tcx>, $K) -> $V),*\n+        }\n+\n+        impl<$tcx> Copy for Providers<$tcx> {}\n+        impl<$tcx> Clone for Providers<$tcx> {\n+            fn clone(&self) -> Self { *self }\n+        }\n+\n+        impl<$tcx> Default for Providers<$tcx> {\n+            fn default() -> Self {\n+                $(fn $name<'a, $tcx>(_: TyCtxt<'a, $tcx, $tcx>, key: $K) -> $V {\n+                    bug!(\"tcx.maps.{}({:?}) unsupported by its crate\",\n+                         stringify!($name), key);\n+                })*\n+                Providers { $($name),* }\n+            }\n+        }\n+    }\n+}\n+\n+// Each of these maps also corresponds to a method on a\n+// `Provider` trait for requesting a value of that type,\n+// and a method on `Maps` itself for doing that in a\n+// a way that memoizes and does dep-graph tracking,\n+// wrapping around the actual chain of providers that\n+// the driver creates (using several `rustc_*` crates).\n+define_maps! { <'tcx>\n+    /// Records the type of every item.\n+    pub ty: ItemSignature(DefId) -> Ty<'tcx>,\n+\n+    /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n+    /// associated generics and predicates.\n+    pub generics: ItemSignature(DefId) -> &'tcx ty::Generics,\n+    pub predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx>,\n+\n+    /// Maps from the def-id of a trait to the list of\n+    /// super-predicates. This is a subset of the full list of\n+    /// predicates. We store these in a separate map because we must\n+    /// evaluate them even during type conversion, often before the\n+    /// full predicates are available (note that supertraits have\n+    /// additional acyclicity requirements).\n+    pub super_predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx>,\n+\n+    /// To avoid cycles within the predicates of a single item we compute\n+    /// per-type-parameter predicates for resolving `T::AssocTy`.\n+    pub type_param_predicates: TypeParamPredicates((DefId, DefId))\n+        -> ty::GenericPredicates<'tcx>,\n+\n+    pub trait_def: ItemSignature(DefId) -> &'tcx ty::TraitDef,\n+    pub adt_def: ItemSignature(DefId) -> &'tcx ty::AdtDef,\n+    pub adt_sized_constraint: SizedConstraint(DefId) -> Ty<'tcx>,\n+\n+    /// Maps from def-id of a type or region parameter to its\n+    /// (inferred) variance.\n+    pub variances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>>,\n+\n+    /// Maps from an impl/trait def-id to a list of the def-ids of its items\n+    pub associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n+\n+    /// Maps from a trait item to the trait item \"descriptor\"\n+    pub associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n+\n+    pub impl_trait_ref: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>>,\n+\n+    /// Maps a DefId of a type to a list of its inherent impls.\n+    /// Contains implementations of methods that are inherent to a type.\n+    /// Methods in these implementations don't need to be exported.\n+    pub inherent_impls: InherentImpls(DefId) -> Vec<DefId>,\n+\n+    /// Maps from the def-id of a function/method or const/static\n+    /// to its MIR. Mutation is done at an item granularity to\n+    /// allow MIR optimization passes to function and still\n+    /// access cross-crate MIR (e.g. inlining or const eval).\n+    ///\n+    /// Note that cross-crate MIR appears to be always borrowed\n+    /// (in the `RefCell` sense) to prevent accidental mutation.\n+    pub mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>>,\n+\n+    /// Maps DefId's that have an associated Mir to the result\n+    /// of the MIR qualify_consts pass. The actual meaning of\n+    /// the value isn't known except to the pass itself.\n+    pub mir_const_qualif: Mir(DefId) -> u8,\n+\n+    /// Records the type of each closure. The def ID is the ID of the\n+    /// expression defining the closure.\n+    pub closure_kind: ItemSignature(DefId) -> ty::ClosureKind,\n+\n+    /// Records the type of each closure. The def ID is the ID of the\n+    /// expression defining the closure.\n+    pub closure_type: ItemSignature(DefId) -> ty::PolyFnSig<'tcx>,\n+\n+    /// Caches CoerceUnsized kinds for impls on custom types.\n+    pub custom_coerce_unsized_kind: ItemSignature(DefId)\n+        -> ty::adjustment::CustomCoerceUnsized,\n+\n+    pub typeck_tables: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n+\n+    pub coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n+\n+    pub coherent_inherent_impls: coherent_inherent_impls_dep_node(CrateNum) -> (),\n+\n+    /// Results of evaluating monomorphic constants embedded in\n+    /// other items, such as enum variant explicit discriminants.\n+    pub monomorphic_const_eval: MonomorphicConstEval(DefId) -> Result<ConstVal<'tcx>, ()>\n+}\n+\n+fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n+    DepNode::CoherenceCheckTrait(def_id)\n+}\n+\n+fn coherent_inherent_impls_dep_node(_: CrateNum) -> DepNode<DefId> {\n+    DepNode::Coherence\n+}"}, {"sha": "55b6f61148d7715b947e7665d25942536f4b82f0", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 168, "deletions": 223, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -19,20 +19,24 @@ use dep_graph::{self, DepNode};\n use hir::{map as hir_map, FreevarMap, TraitMap};\n use middle;\n use hir::def::{Def, CtorKind, ExportMap};\n-use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::region::{CodeExtent, ROOT_CODE_EXTENT};\n+use middle::resolve_lifetime::ObjectLifetimeDefault;\n use mir::Mir;\n use traits;\n use ty;\n use ty::subst::{Subst, Substs};\n+use ty::util::IntTypeExt;\n use ty::walk::TypeWalker;\n use util::common::MemoizationMap;\n-use util::nodemap::{NodeSet, NodeMap, FxHashMap};\n+use util::nodemap::{NodeSet, FxHashMap};\n \n use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n use std::cell::{Cell, RefCell, Ref};\n+use std::collections::BTreeMap;\n use std::hash::{Hash, Hasher};\n use std::ops::Deref;\n use std::rc::Rc;\n@@ -43,15 +47,16 @@ use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n+use rustc_const_math::ConstInt;\n \n use rustc_data_structures::accumulate_vec::IntoIter as AccIntoIter;\n \n use hir;\n use hir::itemlikevisit::ItemLikeVisitor;\n \n pub use self::sty::{Binder, DebruijnIndex};\n-pub use self::sty::{BareFnTy, FnSig, PolyFnSig};\n-pub use self::sty::{ClosureTy, InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n+pub use self::sty::{FnSig, PolyFnSig};\n+pub use self::sty::{InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n pub use self::sty::{ClosureSubsts, TypeAndMut};\n pub use self::sty::{TraitRef, TypeVariants, PolyTraitRef};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n@@ -70,6 +75,8 @@ pub use self::context::{Lift, TypeckTables};\n \n pub use self::trait_def::{TraitDef, TraitFlags};\n \n+pub use self::maps::queries;\n+\n pub mod adjustment;\n pub mod cast;\n pub mod error;\n@@ -94,20 +101,17 @@ mod flags;\n mod structural_impls;\n mod sty;\n \n-pub type Disr = u128;\n-\n // Data types\n \n /// The complete set of all analyses described in this module. This is\n /// produced by the driver and fed to trans and later passes.\n #[derive(Clone)]\n-pub struct CrateAnalysis<'tcx> {\n+pub struct CrateAnalysis {\n     pub export_map: ExportMap,\n     pub access_levels: middle::privacy::AccessLevels,\n     pub reachable: NodeSet,\n     pub name: String,\n     pub glob_map: Option<hir::GlobMap>,\n-    pub hir_ty_to_ty: NodeMap<Ty<'tcx>>,\n }\n \n #[derive(Clone)]\n@@ -585,13 +589,13 @@ pub enum IntVarValue {\n     UintType(ast::UintTy),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n-pub struct TypeParameterDef<'tcx> {\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n+pub struct TypeParameterDef {\n     pub name: Name,\n     pub def_id: DefId,\n     pub index: u32,\n-    pub default_def_id: DefId, // for use in error reporing about defaults\n-    pub default: Option<Ty<'tcx>>,\n+    pub has_default: bool,\n+    pub object_lifetime_default: ObjectLifetimeDefault,\n \n     /// `pure_wrt_drop`, set by the (unsafe) `#[may_dangle]` attribute\n     /// on generic parameter `T`, asserts data behind the parameter\n@@ -628,16 +632,21 @@ impl RegionParameterDef {\n /// Information about the formal type/lifetime parameters associated\n /// with an item or method. Analogous to hir::Generics.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub struct Generics<'tcx> {\n+pub struct Generics {\n     pub parent: Option<DefId>,\n     pub parent_regions: u32,\n     pub parent_types: u32,\n     pub regions: Vec<RegionParameterDef>,\n-    pub types: Vec<TypeParameterDef<'tcx>>,\n+    pub types: Vec<TypeParameterDef>,\n+\n+    /// Reverse map to each `TypeParameterDef`'s `index` field, from\n+    /// `def_id.index` (`def_id.krate` is the same as the item's).\n+    pub type_param_to_index: BTreeMap<DefIndex, u32>,\n+\n     pub has_self: bool,\n }\n \n-impl<'tcx> Generics<'tcx> {\n+impl Generics {\n     pub fn parent_count(&self) -> usize {\n         self.parent_regions as usize + self.parent_types as usize\n     }\n@@ -651,16 +660,18 @@ impl<'tcx> Generics<'tcx> {\n     }\n \n     pub fn region_param(&self, param: &EarlyBoundRegion) -> &RegionParameterDef {\n+        assert_eq!(self.parent_count(), 0);\n         &self.regions[param.index as usize - self.has_self as usize]\n     }\n \n-    pub fn type_param(&self, param: &ParamTy) -> &TypeParameterDef<'tcx> {\n+    pub fn type_param(&self, param: &ParamTy) -> &TypeParameterDef {\n+        assert_eq!(self.parent_count(), 0);\n         &self.types[param.idx as usize - self.has_self as usize - self.regions.len()]\n     }\n }\n \n /// Bounds on generics.\n-#[derive(Clone)]\n+#[derive(Clone, Default)]\n pub struct GenericPredicates<'tcx> {\n     pub parent: Option<DefId>,\n     pub predicates: Vec<Predicate<'tcx>>,\n@@ -1287,10 +1298,10 @@ bitflags! {\n         const IS_DTORCK           = 1 << 1, // is this a dtorck type?\n         const IS_DTORCK_VALID     = 1 << 2,\n         const IS_PHANTOM_DATA     = 1 << 3,\n-        const IS_SIMD             = 1 << 4,\n-        const IS_FUNDAMENTAL      = 1 << 5,\n-        const IS_UNION            = 1 << 6,\n-        const IS_BOX              = 1 << 7,\n+        const IS_FUNDAMENTAL      = 1 << 4,\n+        const IS_UNION            = 1 << 5,\n+        const IS_BOX              = 1 << 6,\n+        const IS_DTOR_VALID       = 1 << 7,\n     }\n }\n \n@@ -1300,11 +1311,24 @@ pub struct VariantDef {\n     /// this is the DefId of the struct's ctor.\n     pub did: DefId,\n     pub name: Name, // struct's name if this is a struct\n-    pub disr_val: Disr,\n+    pub discr: VariantDiscr,\n     pub fields: Vec<FieldDef>,\n     pub ctor_kind: CtorKind,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+pub enum VariantDiscr {\n+    /// Explicit value for this variant, i.e. `X = 123`.\n+    /// The `DefId` corresponds to the embedded constant.\n+    Explicit(DefId),\n+\n+    /// The previous variant's discriminant plus one.\n+    /// For efficiency reasons, the distance from the\n+    /// last `Explicit` discriminant is being stored,\n+    /// or `0` for the first variant, if it has none.\n+    Relative(usize),\n+}\n+\n #[derive(Debug)]\n pub struct FieldDef {\n     pub did: DefId,\n@@ -1318,12 +1342,6 @@ pub struct FieldDef {\n /// table.\n pub struct AdtDef {\n     pub did: DefId,\n-    /// Type of the discriminant\n-    ///\n-    /// Note, that this is the type specified in `repr()` or a default type of some sort, and might\n-    /// not match the actual type that layout algorithm decides to use when translating this type\n-    /// into LLVM. That being said, layout algorithm may not use a type larger than specified here.\n-    pub discr_ty: attr::IntType,\n     pub variants: Vec<VariantDef>,\n     destructor: Cell<Option<DefId>>,\n     flags: Cell<AdtFlags>,\n@@ -1366,37 +1384,44 @@ pub struct ReprOptions {\n }\n \n impl ReprOptions {\n-    pub fn new<'a, 'gcx, 'tcx>(tcx: &TyCtxt<'a, 'gcx, 'tcx>, did: DefId) -> ReprOptions {\n+    pub fn new(tcx: TyCtxt, did: DefId) -> ReprOptions {\n         let mut ret = ReprOptions::default();\n-        let attrs = tcx.lookup_repr_hints(did);\n-        for r in attrs.iter() {\n-            match *r {\n-                attr::ReprExtern => ret.c = true,\n-                attr::ReprPacked => ret.packed = true,\n-                attr::ReprSimd => ret.simd = true,\n-                attr::ReprInt(i) => ret.int = Some(i),\n-                attr::ReprAny => (),\n+\n+        for attr in tcx.get_attrs(did).iter() {\n+            for r in attr::find_repr_attrs(tcx.sess.diagnostic(), attr) {\n+                match r {\n+                    attr::ReprExtern => ret.c = true,\n+                    attr::ReprPacked => ret.packed = true,\n+                    attr::ReprSimd => ret.simd = true,\n+                    attr::ReprInt(i) => ret.int = Some(i),\n+                }\n             }\n         }\n+\n+        // FIXME(eddyb) This is deprecated and should be removed.\n+        if tcx.has_attr(did, \"simd\") {\n+            ret.simd = true;\n+        }\n+\n         ret\n     }\n+\n+    pub fn discr_type(&self) -> attr::IntType {\n+        self.int.unwrap_or(attr::SignedInt(ast::IntTy::Is))\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> AdtDef {\n-    fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    fn new(tcx: TyCtxt,\n            did: DefId,\n            kind: AdtKind,\n-           discr_ty: attr::IntType,\n            variants: Vec<VariantDef>,\n            repr: ReprOptions) -> Self {\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n         let attrs = tcx.get_attrs(did);\n         if attr::contains_name(&attrs, \"fundamental\") {\n             flags = flags | AdtFlags::IS_FUNDAMENTAL;\n         }\n-        if tcx.lookup_simd(did) {\n-            flags = flags | AdtFlags::IS_SIMD;\n-        }\n         if Some(did) == tcx.lang_items.phantom_data() {\n             flags = flags | AdtFlags::IS_PHANTOM_DATA;\n         }\n@@ -1410,7 +1435,6 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n         AdtDef {\n             did: did,\n-            discr_ty: discr_ty,\n             variants: variants,\n             flags: Cell::new(flags),\n             destructor: Cell::new(None),\n@@ -1486,11 +1510,6 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.flags.get().intersects(AdtFlags::IS_FUNDAMENTAL)\n     }\n \n-    #[inline]\n-    pub fn is_simd(&self) -> bool {\n-        self.flags.get().intersects(AdtFlags::IS_SIMD)\n-    }\n-\n     /// Returns true if this is PhantomData<T>.\n     #[inline]\n     pub fn is_phantom_data(&self) -> bool {\n@@ -1504,8 +1523,8 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n \n     /// Returns whether this type has a destructor.\n-    pub fn has_dtor(&self) -> bool {\n-        self.destructor.get().is_some()\n+    pub fn has_dtor(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+        self.destructor(tcx).is_some()\n     }\n \n     /// Asserts this is a struct and returns the struct's unique\n@@ -1560,12 +1579,57 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n     }\n \n-    pub fn destructor(&self) -> Option<DefId> {\n-        self.destructor.get()\n+    pub fn destructor(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<DefId> {\n+        if self.flags.get().intersects(AdtFlags::IS_DTOR_VALID) {\n+            return self.destructor.get();\n+        }\n+\n+        let dtor = self.destructor_uncached(tcx);\n+        self.destructor.set(dtor);\n+        self.flags.set(self.flags.get() | AdtFlags::IS_DTOR_VALID);\n+\n+        dtor\n     }\n \n-    pub fn set_destructor(&self, dtor: DefId) {\n-        self.destructor.set(Some(dtor));\n+    fn destructor_uncached(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<DefId> {\n+        let drop_trait = if let Some(def_id) = tcx.lang_items.drop_trait() {\n+            def_id\n+        } else {\n+            return None;\n+        };\n+\n+        queries::coherent_trait::get(tcx, DUMMY_SP, (LOCAL_CRATE, drop_trait));\n+\n+        let mut dtor = None;\n+        let ty = tcx.item_type(self.did);\n+        tcx.lookup_trait_def(drop_trait).for_each_relevant_impl(tcx, ty, |def_id| {\n+            if let Some(item) = tcx.associated_items(def_id).next() {\n+                dtor = Some(item.def_id);\n+            }\n+        });\n+\n+        dtor\n+    }\n+\n+    pub fn discriminants(&'a self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n+                         -> impl Iterator<Item=ConstInt> + 'a {\n+        let repr_type = self.repr.discr_type();\n+        let initial = repr_type.initial_discriminant(tcx.global_tcx());\n+        let mut prev_discr = None::<ConstInt>;\n+        self.variants.iter().map(move |v| {\n+            let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr());\n+            if let VariantDiscr::Explicit(expr_did) = v.discr {\n+                match tcx.maps.monomorphic_const_eval.borrow()[&expr_did] {\n+                    Ok(ConstVal::Integral(v)) => {\n+                        discr = v;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            prev_discr = Some(discr);\n+\n+            discr\n+        })\n     }\n \n     /// Returns a simpler type such that `Self: Sized` if and only\n@@ -1609,7 +1673,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                                         stack: &mut Vec<DefId>)\n                                         -> Ty<'tcx>\n     {\n-        if let Some(ty) = tcx.adt_sized_constraint.borrow().get(&self.did) {\n+        if let Some(ty) = tcx.maps.adt_sized_constraint.borrow().get(&self.did) {\n             return ty;\n         }\n \n@@ -1623,7 +1687,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             //\n             // Consider the type as Sized in the meanwhile to avoid\n             // further errors.\n-            tcx.adt_sized_constraint.borrow_mut().insert(self.did, tcx.types.err);\n+            tcx.maps.adt_sized_constraint.borrow_mut().insert(self.did, tcx.types.err);\n             return tcx.types.err;\n         }\n \n@@ -1647,7 +1711,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             _ => tcx.intern_tup(&tys[..], false)\n         };\n \n-        let old = tcx.adt_sized_constraint.borrow().get(&self.did).cloned();\n+        let old = tcx.maps.adt_sized_constraint.borrow().get(&self.did).cloned();\n         match old {\n             Some(old_ty) => {\n                 debug!(\"calculate_sized_constraint: {:?} recurred\", self);\n@@ -1656,7 +1720,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             }\n             None => {\n                 debug!(\"calculate_sized_constraint: {:?} => {:?}\", self, ty);\n-                tcx.adt_sized_constraint.borrow_mut().insert(self.did, ty);\n+                tcx.maps.adt_sized_constraint.borrow_mut().insert(self.did, ty);\n                 ty\n             }\n         }\n@@ -1871,28 +1935,6 @@ impl LvaluePreference {\n     }\n }\n \n-/// Helper for looking things up in the various maps that are populated during\n-/// typeck::collect (e.g., `tcx.associated_items`, `tcx.types`, etc).  All of\n-/// these share the pattern that if the id is local, it should have been loaded\n-/// into the map by the `typeck::collect` phase.  If the def-id is external,\n-/// then we have to go consult the crate loading code (and cache the result for\n-/// the future).\n-fn lookup_locally_or_in_crate_store<M, F>(descr: &str,\n-                                          def_id: DefId,\n-                                          map: &M,\n-                                          load_external: F)\n-                                          -> M::Value where\n-    M: MemoizationMap<Key=DefId>,\n-    F: FnOnce() -> M::Value,\n-{\n-    map.memoize(def_id, || {\n-        if def_id.is_local() {\n-            bug!(\"No def'n found for {:?} in tcx.{}\", def_id, descr);\n-        }\n-        load_external()\n-    })\n-}\n-\n impl BorrowKind {\n     pub fn from_mutbl(m: hir::Mutability) -> BorrowKind {\n         match m {\n@@ -1932,25 +1974,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn item_tables(self, def_id: DefId) -> &'gcx TypeckTables<'gcx> {\n-        self.tables.memoize(def_id, || {\n-            if def_id.is_local() {\n-                // Closures' tables come from their outermost function,\n-                // as they are part of the same \"inference environment\".\n-                let outer_def_id = self.closure_base_def_id(def_id);\n-                if outer_def_id != def_id {\n-                    return self.item_tables(outer_def_id);\n-                }\n-\n-                bug!(\"No def'n found for {:?} in tcx.tables\", def_id);\n-            }\n-\n-            // Cross-crate side-tables only exist alongside serialized HIR.\n-            self.sess.cstore.maybe_get_item_body(self.global_tcx(), def_id).map(|_| {\n-                self.tables.borrow()[&def_id]\n-            }).unwrap_or_else(|| {\n-                bug!(\"tcx.item_tables({:?}): missing from metadata\", def_id)\n-            })\n-        })\n+        queries::typeck_tables::get(self, DUMMY_SP, def_id)\n     }\n \n     pub fn expr_span(self, id: NodeId) -> Span {\n@@ -2058,31 +2082,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn custom_coerce_unsized_kind(self, did: DefId) -> adjustment::CustomCoerceUnsized {\n-        self.custom_coerce_unsized_kinds.memoize(did, || {\n-            let (kind, src) = if did.krate != LOCAL_CRATE {\n-                (self.sess.cstore.custom_coerce_unsized_kind(did), \"external\")\n-            } else {\n-                (None, \"local\")\n-            };\n-\n-            match kind {\n-                Some(kind) => kind,\n-                None => {\n-                    bug!(\"custom_coerce_unsized_kind: \\\n-                          {} impl `{}` is missing its kind\",\n-                          src, self.item_path_str(did));\n-                }\n-            }\n-        })\n+        queries::custom_coerce_unsized_kind::get(self, DUMMY_SP, did)\n     }\n \n     pub fn associated_item(self, def_id: DefId) -> AssociatedItem {\n-        self.associated_items.memoize(def_id, || {\n-            if !def_id.is_local() {\n-                return self.sess.cstore.associated_item(def_id)\n-                           .expect(\"missing AssociatedItem in metadata\");\n-            }\n+        if !def_id.is_local() {\n+            return queries::associated_item::get(self, DUMMY_SP, def_id);\n+        }\n \n+        self.maps.associated_item.memoize(def_id, || {\n             // When the user asks for a given associated item, we\n             // always go ahead and convert all the associated items in\n             // the container. Note that we are also careful only to\n@@ -2104,15 +2112,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                             self.associated_item_from_impl_item_ref(parent_def_id,\n                                                                     impl_trait_ref.is_some(),\n                                                                     impl_item_ref);\n-                        self.associated_items.borrow_mut().insert(assoc_item.def_id, assoc_item);\n+                        self.maps.associated_item.borrow_mut()\n+                            .insert(assoc_item.def_id, assoc_item);\n                     }\n                 }\n \n                 hir::ItemTrait(.., ref trait_item_refs) => {\n                     for trait_item_ref in trait_item_refs {\n                         let assoc_item =\n                             self.associated_item_from_trait_item_ref(parent_def_id, trait_item_ref);\n-                        self.associated_items.borrow_mut().insert(assoc_item.def_id, assoc_item);\n+                        self.maps.associated_item.borrow_mut()\n+                            .insert(assoc_item.def_id, assoc_item);\n                     }\n                 }\n \n@@ -2123,7 +2133,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             // memoize wants us to return something, so return\n             // the one we generated for this def-id\n-            *self.associated_items.borrow().get(&def_id).unwrap()\n+            *self.maps.associated_item.borrow().get(&def_id).unwrap()\n         })\n     }\n \n@@ -2181,11 +2191,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn associated_item_def_ids(self, def_id: DefId) -> Rc<Vec<DefId>> {\n-        self.associated_item_def_ids.memoize(def_id, || {\n-            if !def_id.is_local() {\n-                return Rc::new(self.sess.cstore.associated_item_def_ids(def_id));\n-            }\n+        if !def_id.is_local() {\n+            return queries::associated_item_def_ids::get(self, DUMMY_SP, def_id);\n+        }\n \n+        self.maps.associated_item_def_ids.memoize(def_id, || {\n             let id = self.hir.as_local_node_id(def_id).unwrap();\n             let item = self.hir.expect_item(id);\n             let vec: Vec<_> = match item.node {\n@@ -2217,9 +2227,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns the trait-ref corresponding to a given impl, or None if it is\n     /// an inherent impl.\n     pub fn impl_trait_ref(self, id: DefId) -> Option<TraitRef<'gcx>> {\n-        lookup_locally_or_in_crate_store(\n-            \"impl_trait_refs\", id, &self.impl_trait_refs,\n-            || self.sess.cstore.impl_trait_ref(self.global_tcx(), id))\n+        queries::impl_trait_ref::get(self, DUMMY_SP, id)\n     }\n \n     // Returns `ty::VariantDef` if `def` refers to a struct,\n@@ -2298,58 +2306,37 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // If the given item is in an external crate, looks up its type and adds it to\n     // the type cache. Returns the type parameters and type.\n     pub fn item_type(self, did: DefId) -> Ty<'gcx> {\n-        lookup_locally_or_in_crate_store(\n-            \"item_types\", did, &self.item_types,\n-            || self.sess.cstore.item_type(self.global_tcx(), did))\n+        queries::ty::get(self, DUMMY_SP, did)\n     }\n \n     /// Given the did of a trait, returns its canonical trait ref.\n     pub fn lookup_trait_def(self, did: DefId) -> &'gcx TraitDef {\n-        lookup_locally_or_in_crate_store(\n-            \"trait_defs\", did, &self.trait_defs,\n-            || self.alloc_trait_def(self.sess.cstore.trait_def(self.global_tcx(), did))\n-        )\n+        queries::trait_def::get(self, DUMMY_SP, did)\n     }\n \n     /// Given the did of an ADT, return a reference to its definition.\n     pub fn lookup_adt_def(self, did: DefId) -> &'gcx AdtDef {\n-        lookup_locally_or_in_crate_store(\n-            \"adt_defs\", did, &self.adt_defs,\n-            || self.sess.cstore.adt_def(self.global_tcx(), did))\n+        queries::adt_def::get(self, DUMMY_SP, did)\n     }\n \n     /// Given the did of an item, returns its generics.\n-    pub fn item_generics(self, did: DefId) -> &'gcx Generics<'gcx> {\n-        lookup_locally_or_in_crate_store(\n-            \"generics\", did, &self.generics,\n-            || self.alloc_generics(self.sess.cstore.item_generics(self.global_tcx(), did)))\n+    pub fn item_generics(self, did: DefId) -> &'gcx Generics {\n+        queries::generics::get(self, DUMMY_SP, did)\n     }\n \n     /// Given the did of an item, returns its full set of predicates.\n     pub fn item_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n-        lookup_locally_or_in_crate_store(\n-            \"predicates\", did, &self.predicates,\n-            || self.sess.cstore.item_predicates(self.global_tcx(), did))\n+        queries::predicates::get(self, DUMMY_SP, did)\n     }\n \n     /// Given the did of a trait, returns its superpredicates.\n     pub fn item_super_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n-        lookup_locally_or_in_crate_store(\n-            \"super_predicates\", did, &self.super_predicates,\n-            || self.sess.cstore.item_super_predicates(self.global_tcx(), did))\n+        queries::super_predicates::get(self, DUMMY_SP, did)\n     }\n \n     /// Given the did of an item, returns its MIR, borrowed immutably.\n     pub fn item_mir(self, did: DefId) -> Ref<'gcx, Mir<'gcx>> {\n-        lookup_locally_or_in_crate_store(\"mir_map\", did, &self.mir_map, || {\n-            let mir = self.sess.cstore.get_item_mir(self.global_tcx(), did);\n-            let mir = self.alloc_mir(mir);\n-\n-            // Perma-borrow MIR from extern crates to prevent mutation.\n-            mem::forget(mir.borrow());\n-\n-            mir\n-        }).borrow()\n+        queries::mir::get(self, DUMMY_SP, did).borrow()\n     }\n \n     /// If `type_needs_drop` returns true, then `ty` is definitely\n@@ -2400,41 +2387,23 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.get_attrs(did).iter().any(|item| item.check_name(attr))\n     }\n \n-    /// Determine whether an item is annotated with `#[repr(packed)]`\n-    pub fn lookup_packed(self, did: DefId) -> bool {\n-        self.lookup_repr_hints(did).contains(&attr::ReprPacked)\n-    }\n-\n-    /// Determine whether an item is annotated with `#[simd]`\n-    pub fn lookup_simd(self, did: DefId) -> bool {\n-        self.has_attr(did, \"simd\")\n-            || self.lookup_repr_hints(did).contains(&attr::ReprSimd)\n-    }\n-\n     pub fn item_variances(self, item_id: DefId) -> Rc<Vec<ty::Variance>> {\n-        lookup_locally_or_in_crate_store(\n-            \"item_variance_map\", item_id, &self.item_variance_map,\n-            || Rc::new(self.sess.cstore.item_variances(item_id)))\n+        queries::variances::get(self, DUMMY_SP, item_id)\n     }\n \n     pub fn trait_has_default_impl(self, trait_def_id: DefId) -> bool {\n-        self.populate_implementations_for_trait_if_necessary(trait_def_id);\n-\n         let def = self.lookup_trait_def(trait_def_id);\n         def.flags.get().intersects(TraitFlags::HAS_DEFAULT_IMPL)\n     }\n \n-    /// Records a trait-to-implementation mapping.\n-    pub fn record_trait_has_default_impl(self, trait_def_id: DefId) {\n-        let def = self.lookup_trait_def(trait_def_id);\n-        def.flags.set(def.flags.get() | TraitFlags::HAS_DEFAULT_IMPL)\n-    }\n-\n     /// Populates the type context with all the inherent implementations for\n     /// the given type if necessary.\n     pub fn populate_inherent_implementations_for_type_if_necessary(self,\n+                                                                   span: Span,\n                                                                    type_id: DefId) {\n         if type_id.is_local() {\n+            // Make sure coherence of inherent impls ran already.\n+            ty::queries::coherent_inherent_impls::force(self, span, LOCAL_CRATE);\n             return\n         }\n \n@@ -2451,7 +2420,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         let inherent_impls = self.sess.cstore.inherent_implementations_for_type(type_id);\n \n-        self.inherent_impls.borrow_mut().insert(type_id, inherent_impls);\n+        self.maps.inherent_impls.borrow_mut().insert(type_id, inherent_impls);\n         self.populated_external_types.borrow_mut().insert(type_id);\n     }\n \n@@ -2467,16 +2436,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let _ignore = self.dep_graph.in_ignore();\n \n         let def = self.lookup_trait_def(trait_id);\n-        if def.flags.get().intersects(TraitFlags::IMPLS_VALID) {\n+        if def.flags.get().intersects(TraitFlags::HAS_REMOTE_IMPLS) {\n             return;\n         }\n \n         debug!(\"populate_implementations_for_trait_if_necessary: searching for {:?}\", def);\n \n-        if self.sess.cstore.is_defaulted_trait(trait_id) {\n-            self.record_trait_has_default_impl(trait_id);\n-        }\n-\n         for impl_def_id in self.sess.cstore.implementations_of_trait(Some(trait_id)) {\n             let trait_ref = self.impl_trait_ref(impl_def_id).unwrap();\n \n@@ -2485,37 +2450,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             def.record_remote_impl(self, impl_def_id, trait_ref, parent);\n         }\n \n-        def.flags.set(def.flags.get() | TraitFlags::IMPLS_VALID);\n+        def.flags.set(def.flags.get() | TraitFlags::HAS_REMOTE_IMPLS);\n     }\n \n     pub fn closure_kind(self, def_id: DefId) -> ty::ClosureKind {\n-        // If this is a local def-id, it should be inserted into the\n-        // tables by typeck; else, it will be retreived from\n-        // the external crate metadata.\n-        if let Some(&kind) = self.closure_kinds.borrow().get(&def_id) {\n-            return kind;\n-        }\n-\n-        let kind = self.sess.cstore.closure_kind(def_id);\n-        self.closure_kinds.borrow_mut().insert(def_id, kind);\n-        kind\n+        queries::closure_kind::get(self, DUMMY_SP, def_id)\n     }\n \n-    pub fn closure_type(self,\n-                        def_id: DefId,\n-                        substs: ClosureSubsts<'tcx>)\n-                        -> ty::ClosureTy<'tcx>\n-    {\n-        // If this is a local def-id, it should be inserted into the\n-        // tables by typeck; else, it will be retreived from\n-        // the external crate metadata.\n-        if let Some(ty) = self.closure_tys.borrow().get(&def_id) {\n-            return ty.subst(self, substs.substs);\n-        }\n-\n-        let ty = self.sess.cstore.closure_ty(self.global_tcx(), def_id);\n-        self.closure_tys.borrow_mut().insert(def_id, ty.clone());\n-        ty.subst(self, substs.substs)\n+    pub fn closure_type(self, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n+        queries::closure_type::get(self, DUMMY_SP, def_id)\n     }\n \n     /// Given the def_id of an impl, return the def_id of the trait it implements.\n@@ -2527,15 +2470,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// If the given def ID describes a method belonging to an impl, return the\n     /// ID of the impl that the method belongs to. Otherwise, return `None`.\n     pub fn impl_of_method(self, def_id: DefId) -> Option<DefId> {\n-        if def_id.krate != LOCAL_CRATE {\n-            return self.sess.cstore.associated_item(def_id).and_then(|item| {\n-                match item.container {\n-                    TraitContainer(_) => None,\n-                    ImplContainer(def_id) => Some(def_id),\n-                }\n-            });\n-        }\n-        match self.associated_items.borrow().get(&def_id).cloned() {\n+        let item = if def_id.krate != LOCAL_CRATE {\n+            if let Some(Def::Method(_)) = self.sess.cstore.describe_def(def_id) {\n+                Some(self.associated_item(def_id))\n+            } else {\n+                None\n+            }\n+        } else {\n+            self.maps.associated_item.borrow().get(&def_id).cloned()\n+        };\n+\n+        match item {\n             Some(trait_item) => {\n                 match trait_item.container {\n                     TraitContainer(_) => None,\n@@ -2553,7 +2498,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if def_id.krate != LOCAL_CRATE {\n             return self.sess.cstore.trait_of_item(def_id);\n         }\n-        match self.associated_items.borrow().get(&def_id) {\n+        match self.maps.associated_item.borrow().get(&def_id) {\n             Some(associated_item) => {\n                 match associated_item.container {\n                     TraitContainer(def_id) => Some(def_id),"}, {"sha": "cef24d44d6875300ded45c8bb997678f1e7eb521", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -157,24 +157,6 @@ pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n     Ok(tcx.mk_substs(params)?)\n }\n \n-impl<'tcx> Relate<'tcx> for &'tcx ty::BareFnTy<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &&'tcx ty::BareFnTy<'tcx>,\n-                           b: &&'tcx ty::BareFnTy<'tcx>)\n-                           -> RelateResult<'tcx, &'tcx ty::BareFnTy<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n-    {\n-        let unsafety = relation.relate(&a.unsafety, &b.unsafety)?;\n-        let abi = relation.relate(&a.abi, &b.abi)?;\n-        let sig = relation.relate(&a.sig, &b.sig)?;\n-        Ok(relation.tcx().mk_bare_fn(ty::BareFnTy {\n-            unsafety: unsafety,\n-            abi: abi,\n-            sig: sig\n-        }))\n-    }\n-}\n-\n impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n                            a: &ty::FnSig<'tcx>,\n@@ -186,6 +168,8 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n             return Err(TypeError::VariadicMismatch(\n                 expected_found(relation, &a.variadic, &b.variadic)));\n         }\n+        let unsafety = relation.relate(&a.unsafety, &b.unsafety)?;\n+        let abi = relation.relate(&a.abi, &b.abi)?;\n \n         if a.inputs().len() != b.inputs().len() {\n             return Err(TypeError::ArgCount);\n@@ -204,7 +188,9 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n             }).collect::<Result<AccumulateVec<[_; 8]>, _>>()?;\n         Ok(ty::FnSig {\n             inputs_and_output: relation.tcx().intern_type_list(&inputs_and_output),\n-            variadic: a.variadic\n+            variadic: a.variadic,\n+            unsafety: unsafety,\n+            abi: abi\n         })\n     }\n }"}, {"sha": "48f6fcd11b8acf18b1e221e751e68f90d5113fa7", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 5, "deletions": 85, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -235,20 +235,9 @@ impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n         tcx.lift(&self.inputs_and_output).map(|x| {\n             ty::FnSig {\n                 inputs_and_output: x,\n-                variadic: self.variadic\n-            }\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::ClosureTy<'a> {\n-    type Lifted = ty::ClosureTy<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.sig).map(|sig| {\n-            ty::ClosureTy {\n-                sig: sig,\n+                variadic: self.variadic,\n                 unsafety: self.unsafety,\n-                abi: self.abi\n+                abi: self.abi,\n             }\n         })\n     }\n@@ -353,7 +342,7 @@ macro_rules! CopyImpls {\n     }\n }\n \n-CopyImpls! { (), hir::Unsafety, abi::Abi, ty::RegionParameterDef }\n+CopyImpls! { (), hir::Unsafety, abi::Abi }\n \n impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> (T, U) {\n@@ -531,43 +520,6 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::BareFnTy<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let fty = ty::BareFnTy {\n-            sig: self.sig.fold_with(folder),\n-            abi: self.abi,\n-            unsafety: self.unsafety\n-        };\n-        folder.tcx().mk_bare_fn(fty)\n-    }\n-\n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.fold_bare_fn_ty(self)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.sig.visit_with(visitor)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::ClosureTy<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-       ty::ClosureTy {\n-            sig: self.sig.fold_with(folder),\n-            unsafety: self.unsafety,\n-            abi: self.abi,\n-        }\n-    }\n-\n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.fold_closure_ty(self)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.sig.visit_with(visitor)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::TypeAndMut { ty: self.ty.fold_with(folder), mutbl: self.mutbl }\n@@ -588,6 +540,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n         ty::FnSig {\n             inputs_and_output: folder.tcx().intern_type_list(&inputs_and_output),\n             variadic: self.variadic,\n+            unsafety: self.unsafety,\n+            abi: self.abi,\n         }\n     }\n \n@@ -716,40 +670,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoBorrow<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::TypeParameterDef {\n-            name: self.name,\n-            def_id: self.def_id,\n-            index: self.index,\n-            default: self.default.fold_with(folder),\n-            default_def_id: self.default_def_id,\n-            pure_wrt_drop: self.pure_wrt_drop,\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.default.visit_with(visitor)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::Generics {\n-            parent: self.parent,\n-            parent_regions: self.parent_regions,\n-            parent_types: self.parent_types,\n-            regions: self.regions.fold_with(folder),\n-            types: self.types.fold_with(folder),\n-            has_self: self.has_self,\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.regions.visit_with(visitor) || self.types.visit_with(visitor)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::GenericPredicates {"}, {"sha": "aa2990679b6acc27efbdae1f2a3718f8994cb7ed", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 18, "deletions": 36, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -128,12 +128,12 @@ pub enum TypeVariants<'tcx> {\n \n     /// The anonymous type of a function declaration/definition. Each\n     /// function has a unique type.\n-    TyFnDef(DefId, &'tcx Substs<'tcx>, &'tcx BareFnTy<'tcx>),\n+    TyFnDef(DefId, &'tcx Substs<'tcx>, PolyFnSig<'tcx>),\n \n     /// A pointer to a function.  Written as `fn() -> i32`.\n     /// FIXME: This is currently also used to represent the callee of a method;\n     /// see ty::MethodCallee etc.\n-    TyFnPtr(&'tcx BareFnTy<'tcx>),\n+    TyFnPtr(PolyFnSig<'tcx>),\n \n     /// A trait, defined with `trait`.\n     TyDynamic(Binder<&'tcx Slice<ExistentialPredicate<'tcx>>>, &'tcx ty::Region),\n@@ -531,38 +531,22 @@ pub struct ProjectionTy<'tcx> {\n     /// The name `N` of the associated type.\n     pub item_name: Name,\n }\n-\n-#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct BareFnTy<'tcx> {\n-    pub unsafety: hir::Unsafety,\n-    pub abi: abi::Abi,\n-    /// Signature (inputs and output) of this function type.\n-    pub sig: PolyFnSig<'tcx>,\n-}\n-\n-impl<'tcx> serialize::UseSpecializedDecodable for &'tcx BareFnTy<'tcx> {}\n-\n-#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-pub struct ClosureTy<'tcx> {\n-    pub unsafety: hir::Unsafety,\n-    pub abi: abi::Abi,\n-    pub sig: PolyFnSig<'tcx>,\n-}\n-\n /// Signature of a function type, which I have arbitrarily\n /// decided to use to refer to the input/output types.\n ///\n /// - `inputs` is the list of arguments and their modes.\n /// - `output` is the return type.\n /// - `variadic` indicates whether this is a variadic function. (only true for foreign fns)\n-#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct FnSig<'tcx> {\n     pub inputs_and_output: &'tcx Slice<Ty<'tcx>>,\n-    pub variadic: bool\n+    pub variadic: bool,\n+    pub unsafety: hir::Unsafety,\n+    pub abi: abi::Abi,\n }\n \n impl<'tcx> FnSig<'tcx> {\n-    pub fn inputs(&self) -> &[Ty<'tcx>] {\n+    pub fn inputs(&self) -> &'tcx [Ty<'tcx>] {\n         &self.inputs_and_output[..self.inputs_and_output.len() - 1]\n     }\n \n@@ -574,7 +558,7 @@ impl<'tcx> FnSig<'tcx> {\n pub type PolyFnSig<'tcx> = Binder<FnSig<'tcx>>;\n \n impl<'tcx> PolyFnSig<'tcx> {\n-    pub fn inputs(&self) -> Binder<&[Ty<'tcx>]> {\n+    pub fn inputs(&self) -> Binder<&'tcx [Ty<'tcx>]> {\n         Binder(self.skip_binder().inputs())\n     }\n     pub fn input(&self, index: usize) -> ty::Binder<Ty<'tcx>> {\n@@ -586,6 +570,12 @@ impl<'tcx> PolyFnSig<'tcx> {\n     pub fn variadic(&self) -> bool {\n         self.skip_binder().variadic\n     }\n+    pub fn unsafety(&self) -> hir::Unsafety {\n+        self.skip_binder().unsafety\n+    }\n+    pub fn abi(&self) -> abi::Abi {\n+        self.skip_binder().abi\n+    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n@@ -1087,7 +1077,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     #[inline]\n     pub fn is_simd(&self) -> bool {\n         match self.sty {\n-            TyAdt(def, _) => def.is_simd(),\n+            TyAdt(def, _) => def.repr.simd,\n             _ => false\n         }\n     }\n@@ -1280,23 +1270,15 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn fn_sig(&self) -> &'tcx PolyFnSig<'tcx> {\n+    pub fn fn_sig(&self) -> PolyFnSig<'tcx> {\n         match self.sty {\n-            TyFnDef(.., ref f) | TyFnPtr(ref f) => &f.sig,\n+            TyFnDef(.., f) | TyFnPtr(f) => f,\n             _ => bug!(\"Ty::fn_sig() called on non-fn type: {:?}\", self)\n         }\n     }\n \n-    /// Returns the ABI of the given function.\n-    pub fn fn_abi(&self) -> abi::Abi {\n-        match self.sty {\n-            TyFnDef(.., ref f) | TyFnPtr(ref f) => f.abi,\n-            _ => bug!(\"Ty::fn_abi() called on non-fn type\"),\n-        }\n-    }\n-\n     // Type accessors for substructures of types\n-    pub fn fn_args(&self) -> ty::Binder<&[Ty<'tcx>]> {\n+    pub fn fn_args(&self) -> ty::Binder<&'tcx [Ty<'tcx>]> {\n         self.fn_sig().inputs()\n     }\n "}, {"sha": "0a2cc1c30f40fc61452b3aa8bd3fedd3386269c9", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -184,7 +184,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                             mut mk_type: FT)\n                             -> &'tcx Substs<'tcx>\n     where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n-          FT: FnMut(&ty::TypeParameterDef<'tcx>, &[Kind<'tcx>]) -> Ty<'tcx> {\n+          FT: FnMut(&ty::TypeParameterDef, &[Kind<'tcx>]) -> Ty<'tcx> {\n         let defs = tcx.item_generics(def_id);\n         let mut substs = Vec::with_capacity(defs.count());\n         Substs::fill_item(&mut substs, tcx, defs, &mut mk_region, &mut mk_type);\n@@ -198,7 +198,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                              mut mk_type: FT)\n                              -> &'tcx Substs<'tcx>\n     where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n-          FT: FnMut(&ty::TypeParameterDef<'tcx>, &[Kind<'tcx>]) -> Ty<'tcx>\n+          FT: FnMut(&ty::TypeParameterDef, &[Kind<'tcx>]) -> Ty<'tcx>\n     {\n         let defs = tcx.item_generics(def_id);\n         let mut result = Vec::with_capacity(defs.count());\n@@ -209,11 +209,11 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n \n     fn fill_item<FR, FT>(substs: &mut Vec<Kind<'tcx>>,\n                          tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                         defs: &ty::Generics<'tcx>,\n+                         defs: &ty::Generics,\n                          mk_region: &mut FR,\n                          mk_type: &mut FT)\n     where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n-          FT: FnMut(&ty::TypeParameterDef<'tcx>, &[Kind<'tcx>]) -> Ty<'tcx> {\n+          FT: FnMut(&ty::TypeParameterDef, &[Kind<'tcx>]) -> Ty<'tcx> {\n \n         if let Some(def_id) = defs.parent {\n             let parent_defs = tcx.item_generics(def_id);\n@@ -223,11 +223,11 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     fn fill_single<FR, FT>(substs: &mut Vec<Kind<'tcx>>,\n-                           defs: &ty::Generics<'tcx>,\n+                           defs: &ty::Generics,\n                            mk_region: &mut FR,\n                            mk_type: &mut FT)\n     where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n-          FT: FnMut(&ty::TypeParameterDef<'tcx>, &[Kind<'tcx>]) -> Ty<'tcx> {\n+          FT: FnMut(&ty::TypeParameterDef, &[Kind<'tcx>]) -> Ty<'tcx> {\n         // Handle Self first, before all regions.\n         let mut types = defs.types.iter();\n         if defs.parent.is_none() && defs.has_self {\n@@ -301,7 +301,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         tcx.mk_substs(target_substs.iter().chain(&self[defs.own_count()..]).cloned())\n     }\n \n-    pub fn truncate_to(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, generics: &ty::Generics<'tcx>)\n+    pub fn truncate_to(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, generics: &ty::Generics)\n                        -> &'tcx Substs<'tcx> {\n         tcx.mk_substs(self.iter().take(generics.count()).cloned())\n     }"}, {"sha": "097b596c5ebb6b6c9e08219168643855605b265a", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 72, "deletions": 3, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use dep_graph::DepNode;\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, LOCAL_CRATE};\n use traits::{self, specialization_graph};\n use ty;\n use ty::fast_reject;\n@@ -18,6 +18,9 @@ use std::cell::{Cell, RefCell};\n use hir;\n use util::nodemap::FxHashMap;\n \n+use syntax::ast;\n+use syntax_pos::DUMMY_SP;\n+\n /// A trait's definition with type information.\n pub struct TraitDef {\n     pub def_id: DefId,\n@@ -60,6 +63,11 @@ pub struct TraitDef {\n     /// Various flags\n     pub flags: Cell<TraitFlags>,\n \n+    /// The number of impls we've added from the local crate.\n+    /// When this number matches up the list in the HIR map,\n+    /// we're done, and the specialization graph is correct.\n+    local_impl_count: Cell<usize>,\n+\n     /// The ICH of this trait's DefPath, cached here so it doesn't have to be\n     /// recomputed all the time.\n     pub def_path_hash: u64,\n@@ -78,6 +86,7 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n             nonblanket_impls: RefCell::new(FxHashMap()),\n             blanket_impls: RefCell::new(vec![]),\n             flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS),\n+            local_impl_count: Cell::new(0),\n             specialization_graph: RefCell::new(traits::specialization_graph::Graph::new()),\n             def_path_hash: def_path_hash,\n         }\n@@ -155,6 +164,13 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n         assert!(impl_def_id.is_local());\n         let was_new = self.record_impl(tcx, impl_def_id, impl_trait_ref);\n         assert!(was_new);\n+\n+        self.local_impl_count.set(self.local_impl_count.get() + 1);\n+    }\n+\n+    /// Records a trait-to-implementation mapping.\n+    pub fn record_has_default_impl(&self) {\n+        self.flags.set(self.flags.get() | TraitFlags::HAS_DEFAULT_IMPL);\n     }\n \n     /// Records a trait-to-implementation mapping for a non-local impl.\n@@ -194,10 +210,51 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n         specialization_graph::ancestors(self, of_impl)\n     }\n \n+    /// Whether the impl set and specialization graphs are complete.\n+    pub fn is_complete(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+        tcx.populate_implementations_for_trait_if_necessary(self.def_id);\n+        ty::queries::coherent_trait::try_get(tcx, DUMMY_SP, (LOCAL_CRATE, self.def_id)).is_ok()\n+    }\n+\n+    /// If any local impls haven't been added yet, returns\n+    /// Some(list of local impls for this trait).\n+    fn missing_local_impls(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n+                           -> Option<&'gcx [ast::NodeId]> {\n+        if self.flags.get().intersects(TraitFlags::HAS_LOCAL_IMPLS) {\n+            return None;\n+        }\n+\n+        if self.is_complete(tcx) {\n+            self.flags.set(self.flags.get() | TraitFlags::HAS_LOCAL_IMPLS);\n+            return None;\n+        }\n+\n+        let impls = tcx.hir.trait_impls(self.def_id);\n+        assert!(self.local_impl_count.get() <= impls.len());\n+        if self.local_impl_count.get() == impls.len() {\n+            self.flags.set(self.flags.get() | TraitFlags::HAS_LOCAL_IMPLS);\n+            return None;\n+        }\n+\n+        Some(impls)\n+    }\n+\n     pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, mut f: F) {\n         self.read_trait_impls(tcx);\n         tcx.populate_implementations_for_trait_if_necessary(self.def_id);\n \n+        let local_impls = self.missing_local_impls(tcx);\n+        if let Some(impls) = local_impls {\n+            for &id in impls {\n+                f(tcx.hir.local_def_id(id));\n+            }\n+        }\n+        let mut f = |def_id: DefId| {\n+            if !(local_impls.is_some() && def_id.is_local()) {\n+                f(def_id);\n+            }\n+        };\n+\n         for &impl_def_id in self.blanket_impls.borrow().iter() {\n             f(impl_def_id);\n         }\n@@ -217,9 +274,20 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n                                                    mut f: F)\n     {\n         self.read_trait_impls(tcx);\n-\n         tcx.populate_implementations_for_trait_if_necessary(self.def_id);\n \n+        let local_impls = self.missing_local_impls(tcx);\n+        if let Some(impls) = local_impls {\n+            for &id in impls {\n+                f(tcx.hir.local_def_id(id));\n+            }\n+        }\n+        let mut f = |def_id: DefId| {\n+            if !(local_impls.is_some() && def_id.is_local()) {\n+                f(def_id);\n+            }\n+        };\n+\n         for &impl_def_id in self.blanket_impls.borrow().iter() {\n             f(impl_def_id);\n         }\n@@ -258,6 +326,7 @@ bitflags! {\n         const HAS_DEFAULT_IMPL      = 1 << 0,\n         const IS_OBJECT_SAFE        = 1 << 1,\n         const OBJECT_SAFETY_VALID   = 1 << 2,\n-        const IMPLS_VALID           = 1 << 3,\n+        const HAS_REMOTE_IMPLS      = 1 << 3,\n+        const HAS_LOCAL_IMPLS       = 1 << 4,\n     }\n }"}, {"sha": "49c25d25c604fb8c893dbecc6d1b5e50e4fe92b0", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 92, "deletions": 33, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -16,13 +16,14 @@ use infer::InferCtxt;\n use hir::map as hir_map;\n use traits::{self, Reveal};\n use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n-use ty::{Disr, ParameterEnvironment};\n+use ty::{ParameterEnvironment};\n use ty::fold::TypeVisitor;\n use ty::layout::{Layout, LayoutError};\n use ty::TypeVariants::*;\n use util::nodemap::FxHashMap;\n use middle::lang_items;\n \n+use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult};\n \n use std::cell::RefCell;\n@@ -35,21 +36,94 @@ use syntax_pos::Span;\n \n use hir;\n \n-pub trait IntTypeExt {\n-    fn to_ty<'a, 'gcx: 'a+'tcx, 'tcx: 'a>(self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>;\n-    fn initial_discriminant<'a, 'tcx>(&self, _: TyCtxt<'a, 'tcx, 'tcx>) -> Disr;\n+type Disr = ConstInt;\n+\n+ pub trait IntTypeExt {\n+    fn to_ty<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>;\n+    fn disr_incr<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, val: Option<Disr>)\n+                           -> Option<Disr>;\n+    fn assert_ty_matches(&self, val: Disr);\n+    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Disr;\n+ }\n+\n+\n+macro_rules! typed_literal {\n+    ($tcx:expr, $ty:expr, $lit:expr) => {\n+        match $ty {\n+            SignedInt(ast::IntTy::I8)    => ConstInt::I8($lit),\n+            SignedInt(ast::IntTy::I16)   => ConstInt::I16($lit),\n+            SignedInt(ast::IntTy::I32)   => ConstInt::I32($lit),\n+            SignedInt(ast::IntTy::I64)   => ConstInt::I64($lit),\n+            SignedInt(ast::IntTy::I128)   => ConstInt::I128($lit),\n+            SignedInt(ast::IntTy::Is) => match $tcx.sess.target.int_type {\n+                ast::IntTy::I16 => ConstInt::Isize(ConstIsize::Is16($lit)),\n+                ast::IntTy::I32 => ConstInt::Isize(ConstIsize::Is32($lit)),\n+                ast::IntTy::I64 => ConstInt::Isize(ConstIsize::Is64($lit)),\n+                _ => bug!(),\n+            },\n+            UnsignedInt(ast::UintTy::U8)  => ConstInt::U8($lit),\n+            UnsignedInt(ast::UintTy::U16) => ConstInt::U16($lit),\n+            UnsignedInt(ast::UintTy::U32) => ConstInt::U32($lit),\n+            UnsignedInt(ast::UintTy::U64) => ConstInt::U64($lit),\n+            UnsignedInt(ast::UintTy::U128) => ConstInt::U128($lit),\n+            UnsignedInt(ast::UintTy::Us) => match $tcx.sess.target.uint_type {\n+                ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16($lit)),\n+                ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32($lit)),\n+                ast::UintTy::U64 => ConstInt::Usize(ConstUsize::Us64($lit)),\n+                _ => bug!(),\n+            },\n+        }\n+    }\n }\n \n impl IntTypeExt for attr::IntType {\n-    fn to_ty<'a, 'gcx: 'a+'tcx, 'tcx: 'a>(self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n-        match self {\n-            SignedInt(i) => tcx.mk_mach_int(i),\n-            UnsignedInt(i) => tcx.mk_mach_uint(i),\n+    fn to_ty<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+        match *self {\n+            SignedInt(ast::IntTy::I8)      => tcx.types.i8,\n+            SignedInt(ast::IntTy::I16)     => tcx.types.i16,\n+            SignedInt(ast::IntTy::I32)     => tcx.types.i32,\n+            SignedInt(ast::IntTy::I64)     => tcx.types.i64,\n+            SignedInt(ast::IntTy::I128)     => tcx.types.i128,\n+            SignedInt(ast::IntTy::Is)   => tcx.types.isize,\n+            UnsignedInt(ast::UintTy::U8)    => tcx.types.u8,\n+            UnsignedInt(ast::UintTy::U16)   => tcx.types.u16,\n+            UnsignedInt(ast::UintTy::U32)   => tcx.types.u32,\n+            UnsignedInt(ast::UintTy::U64)   => tcx.types.u64,\n+            UnsignedInt(ast::UintTy::U128)   => tcx.types.u128,\n+            UnsignedInt(ast::UintTy::Us) => tcx.types.usize,\n         }\n     }\n \n-    fn initial_discriminant<'a, 'tcx>(&self, _: TyCtxt<'a, 'tcx, 'tcx>) -> Disr {\n-        0\n+    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Disr {\n+        typed_literal!(tcx, *self, 0)\n+    }\n+\n+    fn assert_ty_matches(&self, val: Disr) {\n+        match (*self, val) {\n+            (SignedInt(ast::IntTy::I8), ConstInt::I8(_)) => {},\n+            (SignedInt(ast::IntTy::I16), ConstInt::I16(_)) => {},\n+            (SignedInt(ast::IntTy::I32), ConstInt::I32(_)) => {},\n+            (SignedInt(ast::IntTy::I64), ConstInt::I64(_)) => {},\n+            (SignedInt(ast::IntTy::I128), ConstInt::I128(_)) => {},\n+            (SignedInt(ast::IntTy::Is), ConstInt::Isize(_)) => {},\n+            (UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) => {},\n+            (UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) => {},\n+            (UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) => {},\n+            (UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) => {},\n+            (UnsignedInt(ast::UintTy::U128), ConstInt::U128(_)) => {},\n+            (UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) => {},\n+            _ => bug!(\"disr type mismatch: {:?} vs {:?}\", self, val),\n+        }\n+    }\n+\n+    fn disr_incr<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, val: Option<Disr>)\n+                           -> Option<Disr> {\n+        if let Some(val) = val {\n+            self.assert_ty_matches(val);\n+            (val + typed_literal!(tcx, *self, 1)).ok()\n+        } else {\n+            Some(self.initial_discriminant(tcx))\n+        }\n     }\n }\n \n@@ -81,7 +155,7 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n                                        self_type: Ty<'tcx>, span: Span)\n                                        -> Result<(), CopyImplementationError> {\n         // FIXME: (@jroesch) float this code up\n-        tcx.infer_ctxt(self.clone(), Reveal::NotSpecializable).enter(|infcx| {\n+        tcx.infer_ctxt(self.clone(), Reveal::UserFacing).enter(|infcx| {\n             let (adt, substs) = match self_type.sty {\n                 ty::TyAdt(adt, substs) => (adt, substs),\n                 _ => return Err(CopyImplementationError::NotAnAdt)\n@@ -103,7 +177,7 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n                 }\n             }\n \n-            if adt.has_dtor() {\n+            if adt.has_dtor(tcx) {\n                 return Err(CopyImplementationError::HasDestructor);\n             }\n \n@@ -164,21 +238,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Returns the IntType representation.\n-    /// This used to ensure `int_ty` doesn't contain `usize` and `isize`\n-    /// by converting them to their actual types. That doesn't happen anymore.\n-    pub fn enum_repr_type(self, opt_hint: Option<&attr::ReprAttr>) -> attr::IntType {\n-        match opt_hint {\n-            // Feed in the given type\n-            Some(&attr::ReprInt(int_t)) => int_t,\n-            // ... but provide sensible default if none provided\n-            //\n-            // NB. Historically `fn enum_variants` generate i64 here, while\n-            // rustc_typeck::check would generate isize.\n-            _ => SignedInt(ast::IntTy::Is),\n-        }\n-    }\n-\n     /// Returns the deeply last field of nested structures, or the same type,\n     /// if not a structure at all. Corresponds to the only possible unsized\n     /// field, and its type can be used to determine unsizing strategy.\n@@ -300,7 +359,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// (This allows programs to make cyclic structures without\n     /// resorting to unasfe means; see RFCs 769 and 1238).\n     pub fn is_adt_dtorck(self, adt: &ty::AdtDef) -> bool {\n-        let dtor_method = match adt.destructor() {\n+        let dtor_method = match adt.destructor(self) {\n             Some(dtor) => dtor,\n             None => return false\n         };\n@@ -388,10 +447,10 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n             TyFnDef(def_id, ..) => self.def_id(def_id),\n             TyAdt(d, _) => self.def_id(d.did),\n             TyFnPtr(f) => {\n-                self.hash(f.unsafety);\n-                self.hash(f.abi);\n-                self.hash(f.sig.variadic());\n-                self.hash(f.sig.skip_binder().inputs().len());\n+                self.hash(f.unsafety());\n+                self.hash(f.abi());\n+                self.hash(f.variadic());\n+                self.hash(f.inputs().skip_binder().len());\n             }\n             TyDynamic(ref data, ..) => {\n                 if let Some(p) = data.principal() {\n@@ -471,7 +530,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             }\n         }\n         let result =\n-            tcx.infer_ctxt(param_env.clone(), Reveal::ExactMatch)\n+            tcx.infer_ctxt(param_env.clone(), Reveal::UserFacing)\n             .enter(|infcx| {\n                 traits::type_known_to_meet_bound(&infcx, self, def_id, span)\n             });"}, {"sha": "d7954953aba856902fb1829b0d8d30db6f60d71e", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -115,17 +115,17 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::TyTuple(ts, _) => {\n             stack.extend(ts.iter().cloned().rev());\n         }\n-        ty::TyFnDef(_, substs, ref ft) => {\n+        ty::TyFnDef(_, substs, ft) => {\n             stack.extend(substs.types().rev());\n-            push_sig_subtypes(stack, &ft.sig);\n+            push_sig_subtypes(stack, ft);\n         }\n-        ty::TyFnPtr(ref ft) => {\n-            push_sig_subtypes(stack, &ft.sig);\n+        ty::TyFnPtr(ft) => {\n+            push_sig_subtypes(stack, ft);\n         }\n     }\n }\n \n-fn push_sig_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, sig: &ty::PolyFnSig<'tcx>) {\n+fn push_sig_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, sig: ty::PolyFnSig<'tcx>) {\n     stack.push(sig.skip_binder().output());\n     stack.extend(sig.skip_binder().inputs().iter().cloned().rev());\n }"}, {"sha": "6323f1dc0d4c4a8da2f00a60797851a88b2edbe8", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 17, "deletions": 40, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -137,11 +137,14 @@ pub fn parameterized(f: &mut fmt::Formatter,\n         }\n \n         if !verbose {\n-            if generics.types.last().map_or(false, |def| def.default.is_some()) {\n+            if generics.types.last().map_or(false, |def| def.has_default) {\n                 if let Some(substs) = tcx.lift(&substs) {\n                     let tps = substs.types().rev().skip(child_types);\n                     for (def, actual) in generics.types.iter().rev().zip(tps) {\n-                        if def.default.subst(tcx, substs) != Some(actual) {\n+                        if !def.has_default {\n+                            break;\n+                        }\n+                        if tcx.item_type(def.def_id).subst(tcx, substs) != actual {\n                             break;\n                         }\n                         num_supplied_defaults += 1;\n@@ -326,7 +329,7 @@ impl<'tcx> fmt::Display for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::TypeParameterDef<'tcx> {\n+impl fmt::Debug for ty::TypeParameterDef {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"TypeParameterDef({}, {:?}, {})\",\n                self.name,\n@@ -492,15 +495,6 @@ impl fmt::Debug for ty::Region {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::ClosureTy<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ClosureTy({},{:?},{})\",\n-               self.unsafety,\n-               self.sig,\n-               self.abi)\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"ClosureUpvar({:?},{:?})\",\n@@ -582,6 +576,14 @@ impl<'tcx> fmt::Debug for ty::InstantiatedPredicates<'tcx> {\n \n impl<'tcx> fmt::Display for ty::FnSig<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if self.unsafety == hir::Unsafety::Unsafe {\n+            write!(f, \"unsafe \")?;\n+        }\n+\n+        if self.abi != Abi::Rust {\n+            write!(f, \"extern {} \", self.abi)?;\n+        }\n+\n         write!(f, \"fn\")?;\n         fn_sig(f, self.inputs(), self.variadic, self.output())\n     }\n@@ -738,42 +740,17 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 write!(f, \")\")\n             }\n             TyFnDef(def_id, substs, ref bare_fn) => {\n-                if bare_fn.unsafety == hir::Unsafety::Unsafe {\n-                    write!(f, \"unsafe \")?;\n-                }\n-\n-                if bare_fn.abi != Abi::Rust {\n-                    write!(f, \"extern {} \", bare_fn.abi)?;\n-                }\n-\n-                write!(f, \"{} {{\", bare_fn.sig.0)?;\n+                write!(f, \"{} {{\", bare_fn.0)?;\n                 parameterized(f, substs, def_id, &[])?;\n                 write!(f, \"}}\")\n             }\n             TyFnPtr(ref bare_fn) => {\n-                if bare_fn.unsafety == hir::Unsafety::Unsafe {\n-                    write!(f, \"unsafe \")?;\n-                }\n-\n-                if bare_fn.abi != Abi::Rust {\n-                    write!(f, \"extern {} \", bare_fn.abi)?;\n-                }\n-\n-                write!(f, \"{}\", bare_fn.sig.0)\n+                write!(f, \"{}\", bare_fn.0)\n             }\n             TyInfer(infer_ty) => write!(f, \"{}\", infer_ty),\n             TyError => write!(f, \"[type error]\"),\n             TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n-            TyAdt(def, substs) => {\n-                ty::tls::with(|tcx| {\n-                    if def.did.is_local() &&\n-                          !tcx.item_types.borrow().contains_key(&def.did) {\n-                        write!(f, \"{}<..>\", tcx.item_path_str(def.did))\n-                    } else {\n-                        parameterized(f, substs, def.did, &[])\n-                    }\n-                })\n-            }\n+            TyAdt(def, substs) => parameterized(f, substs, def.did, &[]),\n             TyDynamic(data, r) => {\n                 write!(f, \"{}\", data)?;\n                 let r = r.to_string();"}, {"sha": "3ce31882b86c4583ec1c4f5a7d5a5f05dad26aa8", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -783,7 +783,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             }\n             LpExtend(ref lp_base, _, LpInterior(_, InteriorField(_))) => {\n                 match lp_base.to_type().sty {\n-                    ty::TyAdt(def, _) if def.has_dtor() => {\n+                    ty::TyAdt(def, _) if def.has_dtor(self.tcx()) => {\n                         // In the case where the owner implements drop, then\n                         // the path must be initialized to prevent a case of\n                         // partial reinitialization"}, {"sha": "0577ba7f45a938883d3767c8b697acd94913dca3", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -177,7 +177,7 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         Categorization::Interior(ref b, mc::InteriorElement(Kind::Pattern, _)) => {\n             match b.ty.sty {\n                 ty::TyAdt(def, _) => {\n-                    if def.has_dtor() {\n+                    if def.has_dtor(bccx.tcx) {\n                         Some(cmt.clone())\n                     } else {\n                         check_and_get_illegal_move_origin(bccx, b)"}, {"sha": "3678c2e55c1fdb17d0d175796e282f167f98f861", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -150,7 +150,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         Categorization::Downcast(ref b, _) |\n         Categorization::Interior(ref b, mc::InteriorField(_)) => {\n             match b.ty.sty {\n-                ty::TyAdt(def, _) if def.has_dtor() => {\n+                ty::TyAdt(def, _) if def.has_dtor(bccx.tcx) => {\n                     let mut err = struct_span_err!(bccx, move_from.span, E0509,\n                                                    \"cannot move out of type `{}`, \\\n                                                    which implements the `Drop` trait\","}, {"sha": "44e3b38ea3857dd04d18599e15734ade67c7822e", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -164,8 +164,9 @@ fn is_rustc_peek<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         {\n             if let mir::Operand::Constant(ref func) = *oper\n             {\n-                if let ty::TyFnDef(def_id, _, &ty::BareFnTy { abi, .. }) = func.ty.sty\n+                if let ty::TyFnDef(def_id, _, sig) = func.ty.sty\n                 {\n+                    let abi = sig.abi();\n                     let name = tcx.item_name(def_id);\n                     if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n                         if name == \"rustc_peek\" {"}, {"sha": "13f898219bc12dfba9c9d456cb34c7d15a5b51e5", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -20,7 +20,7 @@ use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::ty::util::IntTypeExt;\n use rustc::mir::*;\n use rustc::mir::transform::{Pass, MirPass, MirSource};\n-use rustc::middle::const_val::{ConstVal, ConstInt};\n+use rustc::middle::const_val::ConstVal;\n use rustc::middle::lang_items;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n@@ -639,10 +639,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 let mut values = Vec::with_capacity(adt.variants.len());\n                 let mut blocks = Vec::with_capacity(adt.variants.len());\n                 let mut otherwise = None;\n-                for (variant_index, variant) in adt.variants.iter().enumerate() {\n-                    let discr = ConstInt::new_inttype(variant.disr_val, adt.discr_ty,\n-                                                      self.tcx.sess.target.uint_type,\n-                                                      self.tcx.sess.target.int_type).unwrap();\n+                for (variant_index, discr) in adt.discriminants(self.tcx).enumerate() {\n                     let subpath = super::move_path_children_matching(\n                         self.move_data(), c.path, |proj| match proj {\n                             &Projection {\n@@ -680,7 +677,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 // Additionally, we do not want to switch on the\n                 // discriminant after it is free-ed, because that\n                 // way lies only trouble.\n-                let discr_ty = adt.discr_ty.to_ty(self.tcx);\n+                let discr_ty = adt.repr.discr_type().to_ty(self.tcx);\n                 let discr = Lvalue::Local(self.patch.new_temp(discr_ty));\n                 let switch_block = self.patch.new_block(BasicBlockData {\n                     statements: vec![\n@@ -901,7 +898,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n         match ty.sty {\n             ty::TyAdt(def, _) => {\n-                if def.has_dtor() && !def.is_box() {\n+                if def.has_dtor(self.tcx) && !def.is_box() {\n                     self.tcx.sess.span_warn(\n                         c.source_info.span,\n                         &format!(\"dataflow bug??? moving out of type with dtor {:?}\","}, {"sha": "8d866676dbd1875dc3838da2e0491e4db397ae00", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -289,7 +289,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             // error: can't move out of borrowed content\n             ty::TyRef(..) | ty::TyRawPtr(..) => return Err(MovePathError::IllegalMove),\n             // error: can't move out of struct with destructor\n-            ty::TyAdt(adt, _) if adt.has_dtor() && !adt.is_box() =>\n+            ty::TyAdt(adt, _) if adt.has_dtor(self.tcx) && !adt.is_box() =>\n                 return Err(MovePathError::IllegalMove),\n             // move out of union - always move the entire union\n             ty::TyAdt(adt, _) if adt.is_union() =>"}, {"sha": "1c9ee335699ae13439d689cbb1af77e826b72b69", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -248,7 +248,7 @@ fn lvalue_contents_drop_state_cannot_differ<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n                    lv, ty);\n             true\n         }\n-        ty::TyAdt(def, _) if (def.has_dtor() && !def.is_box()) || def.is_union() => {\n+        ty::TyAdt(def, _) if (def.has_dtor(tcx) && !def.is_box()) || def.is_union() => {\n             debug!(\"lvalue_contents_drop_state_cannot_differ lv: {:?} ty: {:?} Drop => true\",\n                    lv, ty);\n             true"}, {"sha": "53a7e87292818d773a7af3dfcd859d0b8467adcd", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -221,21 +221,21 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n }\n \n #[derive(Clone, Debug, PartialEq)]\n-pub enum Constructor {\n+pub enum Constructor<'tcx> {\n     /// The constructor of all patterns that don't vary by constructor,\n     /// e.g. struct patterns and fixed-length arrays.\n     Single,\n     /// Enum variants.\n     Variant(DefId),\n     /// Literal values.\n-    ConstantValue(ConstVal),\n+    ConstantValue(ConstVal<'tcx>),\n     /// Ranges of literal values (`2...5` and `2..5`).\n-    ConstantRange(ConstVal, ConstVal, RangeEnd),\n+    ConstantRange(ConstVal<'tcx>, ConstVal<'tcx>, RangeEnd),\n     /// Array patterns of length n.\n     Slice(usize),\n }\n \n-impl<'tcx> Constructor {\n+impl<'tcx> Constructor<'tcx> {\n     fn variant_index_for_adt(&self, adt: &'tcx ty::AdtDef) -> usize {\n         match self {\n             &Variant(vid) => adt.variant_index_with_id(vid),\n@@ -289,7 +289,7 @@ impl<'tcx> Witness<'tcx> {\n     fn push_wild_constructor<'a>(\n         mut self,\n         cx: &MatchCheckCtxt<'a, 'tcx>,\n-        ctor: &Constructor,\n+        ctor: &Constructor<'tcx>,\n         ty: Ty<'tcx>)\n         -> Self\n     {\n@@ -321,7 +321,7 @@ impl<'tcx> Witness<'tcx> {\n     fn apply_constructor<'a>(\n         mut self,\n         cx: &MatchCheckCtxt<'a,'tcx>,\n-        ctor: &Constructor,\n+        ctor: &Constructor<'tcx>,\n         ty: Ty<'tcx>)\n         -> Self\n     {\n@@ -399,7 +399,8 @@ impl<'tcx> Witness<'tcx> {\n /// We make sure to omit constructors that are statically impossible. eg for\n /// Option<!> we do not include Some(_) in the returned list of constructors.\n fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-                                  pcx: PatternContext<'tcx>) -> Vec<Constructor>\n+                                  pcx: PatternContext<'tcx>)\n+                                  -> Vec<Constructor<'tcx>>\n {\n     debug!(\"all_constructors({:?})\", pcx.ty);\n     match pcx.ty.sty {\n@@ -664,7 +665,7 @@ fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     &Matrix(ref m): &Matrix<'p, 'tcx>,\n     v: &[&'p Pattern<'tcx>],\n-    ctor: Constructor,\n+    ctor: Constructor<'tcx>,\n     lty: Ty<'tcx>,\n     witness: WitnessPreference) -> Usefulness<'tcx>\n {\n@@ -702,10 +703,10 @@ fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n /// `[a, b, ..tail]` can match a slice of length 2, 3, 4 and so on.\n ///\n /// Returns None in case of a catch-all, which can't be specialized.\n-fn pat_constructors(_cx: &mut MatchCheckCtxt,\n-                    pat: &Pattern,\n-                    pcx: PatternContext)\n-                    -> Option<Vec<Constructor>>\n+fn pat_constructors<'tcx>(_cx: &mut MatchCheckCtxt,\n+                          pat: &Pattern<'tcx>,\n+                          pcx: PatternContext)\n+                          -> Option<Vec<Constructor<'tcx>>>\n {\n     match *pat.kind {\n         PatternKind::Binding { .. } | PatternKind::Wild =>"}, {"sha": "e2b9f174ff0c200a6e174347d0e85cf5c7239fff", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -124,7 +124,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                               \"statics cannot be referenced in patterns\");\n                 }\n                 PatternError::ConstEval(err) => {\n-                    report_const_eval_err(self.tcx, &err, pat_span, \"pattern\").emit();\n+                    report_const_eval_err(self.tcx, &err, pat_span, \"pattern\");\n                 }\n             }\n         }\n@@ -516,7 +516,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n ///\n /// FIXME: this should be done by borrowck.\n fn check_for_mutation_in_guard(cx: &MatchVisitor, guard: &hir::Expr) {\n-    cx.tcx.infer_ctxt((cx.tables, cx.param_env.clone()), Reveal::NotSpecializable).enter(|infcx| {\n+    cx.tcx.infer_ctxt((cx.tables, cx.param_env.clone()), Reveal::UserFacing).enter(|infcx| {\n         let mut checker = MutationChecker {\n             cx: cx,\n         };"}, {"sha": "9937cbbf8e10c3929293c99e1cf1bdb7d3d3d4b9", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -576,22 +576,6 @@ integer type:\n https://doc.rust-lang.org/reference.html#ffi-attributes\n \"##,\n \n-\n-E0306: r##\"\n-In an array type `[T; N]`, `N` is the number of elements in the array. This\n-must be an unsigned integer. Erroneous code example:\n-\n-```compile_fail,E0306\n-const X: [i32; true] = [0]; // error: expected `usize` for array length,\n-                            //        found boolean\n-```\n-\n-Working example:\n-\n-```\n-const X: [i32; 1] = [0];\n-```\n-\"##,\n }\n \n "}, {"sha": "c5d577ce571d40aceb664dd8d190a19f4efb709d", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 227, "deletions": 473, "changes": 700, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -11,7 +11,6 @@\n use rustc::middle::const_val::ConstVal::*;\n use rustc::middle::const_val::ConstVal;\n use self::ErrKind::*;\n-use self::EvalHint::*;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::map::blocks::FnLikeNode;\n@@ -20,35 +19,40 @@ use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::util::IntTypeExt;\n-use rustc::ty::subst::Substs;\n+use rustc::ty::subst::{Substs, Subst};\n use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::DefIdMap;\n \n use graphviz::IntoCow;\n use syntax::ast;\n use rustc::hir::{self, Expr};\n-use syntax::attr::IntType;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n use std::borrow::Cow;\n use std::cmp::Ordering;\n \n use rustc_const_math::*;\n use rustc_errors::DiagnosticBuilder;\n \n+macro_rules! signal {\n+    ($e:expr, $exn:expr) => {\n+        return Err(ConstEvalErr { span: $e.span, kind: $exn })\n+    }\n+}\n+\n macro_rules! math {\n     ($e:expr, $op:expr) => {\n         match $op {\n             Ok(val) => val,\n-            Err(e) => signal!($e, Math(e)),\n+            Err(e) => signal!($e, ErrKind::from(e)),\n         }\n     }\n }\n \n fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   variant_def: DefId)\n-                                  -> Option<(&'tcx Expr, Option<&'a ty::TypeckTables<'tcx>>)> {\n+                                  -> Option<(&'tcx Expr, &'a ty::TypeckTables<'tcx>)> {\n     if let Some(variant_node_id) = tcx.hir.as_local_node_id(variant_def) {\n         let enum_node_id = tcx.hir.get_parent(variant_node_id);\n         if let Some(hir_map::NodeItem(it)) = tcx.hir.find(enum_node_id) {\n@@ -58,7 +62,7 @@ fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         return variant.node.disr_expr.map(|e| {\n                             let def_id = tcx.hir.body_owner_def_id(e);\n                             (&tcx.hir.body(e).value,\n-                             tcx.tables.borrow().get(&def_id).cloned())\n+                             tcx.item_tables(def_id))\n                         });\n                     }\n                 }\n@@ -75,55 +79,41 @@ fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// This generally happens in late/trans const evaluation.\n pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         def_id: DefId,\n-                                        substs: Option<&'tcx Substs<'tcx>>)\n+                                        substs: &'tcx Substs<'tcx>)\n                                         -> Option<(&'tcx Expr,\n-                                                   Option<&'a ty::TypeckTables<'tcx>>,\n-                                                   Option<ty::Ty<'tcx>>)> {\n+                                                   &'a ty::TypeckTables<'tcx>)> {\n     if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n         match tcx.hir.find(node_id) {\n             None => None,\n             Some(hir_map::NodeItem(&hir::Item {\n-                node: hir::ItemConst(ref ty, body), ..\n+                node: hir::ItemConst(_, body), ..\n             })) |\n             Some(hir_map::NodeImplItem(&hir::ImplItem {\n-                node: hir::ImplItemKind::Const(ref ty, body), ..\n+                node: hir::ImplItemKind::Const(_, body), ..\n             })) => {\n                 Some((&tcx.hir.body(body).value,\n-                      tcx.tables.borrow().get(&def_id).cloned(),\n-                      tcx.ast_ty_to_prim_ty(ty)))\n+                      tcx.item_tables(def_id)))\n             }\n             Some(hir_map::NodeTraitItem(ti)) => match ti.node {\n-                hir::TraitItemKind::Const(ref ty, default) => {\n-                    if let Some(substs) = substs {\n-                        // If we have a trait item and the substitutions for it,\n-                        // `resolve_trait_associated_const` will select an impl\n-                        // or the default.\n-                        let trait_id = tcx.hir.get_parent(node_id);\n-                        let trait_id = tcx.hir.local_def_id(trait_id);\n-                        let default_value = default.map(|body| {\n-                            (&tcx.hir.body(body).value,\n-                             tcx.tables.borrow().get(&def_id).cloned(),\n-                             tcx.ast_ty_to_prim_ty(ty))\n-                        });\n-                        resolve_trait_associated_const(tcx, def_id, default_value, trait_id, substs)\n-                    } else {\n-                        // Technically, without knowing anything about the\n-                        // expression that generates the obligation, we could\n-                        // still return the default if there is one. However,\n-                        // it's safer to return `None` than to return some value\n-                        // that may differ from what you would get from\n-                        // correctly selecting an impl.\n-                        None\n-                    }\n+                hir::TraitItemKind::Const(_, default) => {\n+                    // If we have a trait item and the substitutions for it,\n+                    // `resolve_trait_associated_const` will select an impl\n+                    // or the default.\n+                    let trait_id = tcx.hir.get_parent(node_id);\n+                    let trait_id = tcx.hir.local_def_id(trait_id);\n+                    let default_value = default.map(|body| {\n+                        (&tcx.hir.body(body).value,\n+                            tcx.item_tables(def_id))\n+                    });\n+                    resolve_trait_associated_const(tcx, def_id, default_value, trait_id, substs)\n                 }\n                 _ => None\n             },\n             Some(_) => None\n         }\n     } else {\n-        let expr_tables_ty = tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n-            (&body.value, Some(tcx.item_tables(def_id)),\n-             Some(tcx.sess.cstore.item_type(tcx, def_id)))\n+        let expr_and_tables = tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n+            (&body.value, tcx.item_tables(def_id))\n         });\n         match tcx.sess.cstore.describe_def(def_id) {\n             Some(Def::AssociatedConst(_)) => {\n@@ -133,46 +123,42 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 // trait-associated const if the caller gives us the\n                 // substitutions for the reference to it.\n                 if let Some(trait_id) = trait_id {\n-                    if let Some(substs) = substs {\n-                        resolve_trait_associated_const(tcx, def_id, expr_tables_ty,\n-                                                       trait_id, substs)\n-                    } else {\n-                        None\n-                    }\n+                    resolve_trait_associated_const(tcx, def_id, expr_and_tables,\n+                                                   trait_id, substs)\n                 } else {\n-                    expr_tables_ty\n+                    expr_and_tables\n                 }\n             },\n-            Some(Def::Const(..)) => expr_tables_ty,\n+            Some(Def::Const(..)) => expr_and_tables,\n             _ => None\n         }\n     }\n }\n \n fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                                   -> Option<(&'tcx hir::Body, Option<&'a ty::TypeckTables<'tcx>>)>\n+                                   -> Option<(&'tcx hir::Body, &'a ty::TypeckTables<'tcx>)>\n {\n     if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n         FnLikeNode::from_node(tcx.hir.get(node_id)).and_then(|fn_like| {\n             if fn_like.constness() == hir::Constness::Const {\n                 Some((tcx.hir.body(fn_like.body()),\n-                      tcx.tables.borrow().get(&def_id).cloned()))\n+                      tcx.item_tables(def_id)))\n             } else {\n                 None\n             }\n         })\n     } else {\n         if tcx.sess.cstore.is_const_fn(def_id) {\n             tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n-                (body, Some(tcx.item_tables(def_id)))\n+                (body, tcx.item_tables(def_id))\n             })\n         } else {\n             None\n         }\n     }\n }\n \n-pub fn report_const_eval_err<'a, 'tcx>(\n+fn build_const_eval_err<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     err: &ConstEvalErr,\n     primary_span: Span,\n@@ -189,14 +175,26 @@ pub fn report_const_eval_err<'a, 'tcx>(\n     diag\n }\n \n+pub fn report_const_eval_err<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    err: &ConstEvalErr,\n+    primary_span: Span,\n+    primary_kind: &str)\n+{\n+    if let TypeckError = err.kind {\n+        return;\n+    }\n+    build_const_eval_err(tcx, err, primary_span, primary_kind).emit();\n+}\n+\n pub fn fatal_const_eval_err<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     err: &ConstEvalErr,\n     primary_span: Span,\n     primary_kind: &str)\n     -> !\n {\n-    report_const_eval_err(tcx, err, primary_span, primary_kind).emit();\n+    report_const_eval_err(tcx, err, primary_span, primary_kind);\n     tcx.sess.abort_if_errors();\n     unreachable!()\n }\n@@ -222,88 +220,76 @@ pub fn note_const_eval_err<'a, 'tcx>(\n \n pub struct ConstContext<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    tables: Option<&'a ty::TypeckTables<'tcx>>,\n-    fn_args: Option<DefIdMap<ConstVal>>\n+    tables: &'a ty::TypeckTables<'tcx>,\n+    substs: &'tcx Substs<'tcx>,\n+    fn_args: Option<DefIdMap<ConstVal<'tcx>>>\n }\n \n impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, body: hir::BodyId) -> Self {\n         let def_id = tcx.hir.body_owner_def_id(body);\n-        ConstContext {\n-            tcx: tcx,\n-            tables: tcx.tables.borrow().get(&def_id).cloned(),\n-            fn_args: None\n-        }\n+        ty::queries::mir_const_qualif::get(tcx, DUMMY_SP, def_id);\n+        ConstContext::with_tables(tcx, tcx.item_tables(def_id))\n     }\n \n     pub fn with_tables(tcx: TyCtxt<'a, 'tcx, 'tcx>, tables: &'a ty::TypeckTables<'tcx>) -> Self {\n         ConstContext {\n             tcx: tcx,\n-            tables: Some(tables),\n+            tables: tables,\n+            substs: tcx.intern_substs(&[]),\n             fn_args: None\n         }\n     }\n \n     /// Evaluate a constant expression in a context where the expression isn't\n-    /// guaranteed to be evaluatable. `ty_hint` is usually ExprTypeChecked,\n-    /// but a few places need to evaluate constants during type-checking, like\n-    /// computing the length of an array. (See also the FIXME above EvalHint.)\n-    pub fn eval(&self, e: &Expr, ty_hint: EvalHint<'tcx>) -> EvalResult {\n-        eval_const_expr_partial(self, e, ty_hint)\n+    /// guaranteed to be evaluatable.\n+    pub fn eval(&self, e: &Expr) -> EvalResult<'tcx> {\n+        if self.tables.tainted_by_errors {\n+            signal!(e, TypeckError);\n+        }\n+        eval_const_expr_partial(self, e)\n     }\n }\n \n #[derive(Clone, Debug)]\n-pub struct ConstEvalErr {\n+pub struct ConstEvalErr<'tcx> {\n     pub span: Span,\n-    pub kind: ErrKind,\n+    pub kind: ErrKind<'tcx>,\n }\n \n #[derive(Clone, Debug)]\n-pub enum ErrKind {\n+pub enum ErrKind<'tcx> {\n     CannotCast,\n-    CannotCastTo(&'static str),\n-    InvalidOpForInts(hir::BinOp_),\n-    InvalidOpForBools(hir::BinOp_),\n-    InvalidOpForFloats(hir::BinOp_),\n-    InvalidOpForIntUint(hir::BinOp_),\n-    InvalidOpForUintInt(hir::BinOp_),\n-    NegateOn(ConstVal),\n-    NotOn(ConstVal),\n-    CallOn(ConstVal),\n-\n     MissingStructField,\n+    NegateOn(ConstVal<'tcx>),\n+    NotOn(ConstVal<'tcx>),\n+    CallOn(ConstVal<'tcx>),\n+\n     NonConstPath,\n     UnimplementedConstVal(&'static str),\n-    UnresolvedPath,\n     ExpectedConstTuple,\n     ExpectedConstStruct,\n-    TupleIndexOutOfBounds,\n     IndexedNonVec,\n-    IndexNegative,\n-    IndexNotInt,\n+    IndexNotUsize,\n     IndexOutOfBounds { len: u64, index: u64 },\n-    RepeatCountNotNatural,\n-    RepeatCountNotInt,\n \n     MiscBinaryOp,\n     MiscCatchAll,\n \n     IndexOpFeatureGated,\n     Math(ConstMathErr),\n \n-    IntermediateUnsignedNegative,\n-    /// Expected, Got\n-    TypeMismatch(String, ConstInt),\n+    ErroneousReferencedConstant(Box<ConstEvalErr<'tcx>>),\n \n-    BadType(ConstVal),\n-    ErroneousReferencedConstant(Box<ConstEvalErr>),\n-    CharCast(ConstInt),\n+    TypeckError\n }\n \n-impl From<ConstMathErr> for ErrKind {\n-    fn from(err: ConstMathErr) -> ErrKind {\n-        Math(err)\n+impl<'tcx> From<ConstMathErr> for ErrKind<'tcx> {\n+    fn from(err: ConstMathErr) -> ErrKind<'tcx> {\n+        match err {\n+            ConstMathErr::UnsignedNegation => TypeckError,\n+            _ => Math(err)\n+        }\n     }\n }\n \n@@ -321,7 +307,7 @@ impl<'a> ConstEvalErrDescription<'a> {\n     }\n }\n \n-impl ConstEvalErr {\n+impl<'tcx> ConstEvalErr<'tcx> {\n     pub fn description(&self) -> ConstEvalErrDescription {\n         use self::ErrKind::*;\n         use self::ConstEvalErrDescription::*;\n@@ -335,12 +321,6 @@ impl ConstEvalErr {\n \n         match self.kind {\n             CannotCast => simple!(\"can't cast this type\"),\n-            CannotCastTo(s) => simple!(\"can't cast this type to {}\", s),\n-            InvalidOpForInts(_) =>  simple!(\"can't do this op on integrals\"),\n-            InvalidOpForBools(_) =>  simple!(\"can't do this op on bools\"),\n-            InvalidOpForFloats(_) => simple!(\"can't do this op on floats\"),\n-            InvalidOpForIntUint(..) => simple!(\"can't do this op on an isize and usize\"),\n-            InvalidOpForUintInt(..) => simple!(\"can't do this op on a usize and isize\"),\n             NegateOn(ref const_val) => simple!(\"negate on {}\", const_val.description()),\n             NotOn(ref const_val) => simple!(\"not on {}\", const_val.description()),\n             CallOn(ref const_val) => simple!(\"call on {}\", const_val.description()),\n@@ -349,111 +329,42 @@ impl ConstEvalErr {\n             NonConstPath        => simple!(\"non-constant path in constant expression\"),\n             UnimplementedConstVal(what) =>\n                 simple!(\"unimplemented constant expression: {}\", what),\n-            UnresolvedPath => simple!(\"unresolved path in constant expression\"),\n             ExpectedConstTuple => simple!(\"expected constant tuple\"),\n             ExpectedConstStruct => simple!(\"expected constant struct\"),\n-            TupleIndexOutOfBounds => simple!(\"tuple index out of bounds\"),\n             IndexedNonVec => simple!(\"indexing is only supported for arrays\"),\n-            IndexNegative => simple!(\"indices must be non-negative integers\"),\n-            IndexNotInt => simple!(\"indices must be integers\"),\n+            IndexNotUsize => simple!(\"indices must be of type `usize`\"),\n             IndexOutOfBounds { len, index } => {\n                 simple!(\"index out of bounds: the len is {} but the index is {}\",\n                         len, index)\n             }\n-            RepeatCountNotNatural => simple!(\"repeat count must be a natural number\"),\n-            RepeatCountNotInt => simple!(\"repeat count must be integers\"),\n \n             MiscBinaryOp => simple!(\"bad operands for binary\"),\n             MiscCatchAll => simple!(\"unsupported constant expr\"),\n             IndexOpFeatureGated => simple!(\"the index operation on const values is unstable\"),\n             Math(ref err) => Simple(err.description().into_cow()),\n \n-            IntermediateUnsignedNegative => simple!(\n-                \"during the computation of an unsigned a negative \\\n-                 number was encountered. This is most likely a bug in\\\n-                 the constant evaluator\"),\n-\n-            TypeMismatch(ref expected, ref got) => {\n-                simple!(\"expected {}, found {}\", expected, got.description())\n-            },\n-            BadType(ref i) => simple!(\"value of wrong type: {:?}\", i),\n             ErroneousReferencedConstant(_) => simple!(\"could not evaluate referenced constant\"),\n-            CharCast(ref got) => {\n-                simple!(\"only `u8` can be cast as `char`, not `{}`\", got.description())\n-            },\n-        }\n-    }\n-}\n-\n-pub type EvalResult = Result<ConstVal, ConstEvalErr>;\n-pub type CastResult = Result<ConstVal, ErrKind>;\n-\n-// FIXME: Long-term, this enum should go away: trying to evaluate\n-// an expression which hasn't been type-checked is a recipe for\n-// disaster.  That said, it's not clear how to fix ast_ty_to_ty\n-// to avoid the ordering issue.\n-\n-/// Hint to determine how to evaluate constant expressions which\n-/// might not be type-checked.\n-#[derive(Copy, Clone, Debug)]\n-pub enum EvalHint<'tcx> {\n-    /// We have a type-checked expression.\n-    ExprTypeChecked,\n-    /// We have an expression which hasn't been type-checked, but we have\n-    /// an idea of what the type will be because of the context. For example,\n-    /// the length of an array is always `usize`. (This is referred to as\n-    /// a hint because it isn't guaranteed to be consistent with what\n-    /// type-checking would compute.)\n-    UncheckedExprHint(Ty<'tcx>),\n-    /// We have an expression which has not yet been type-checked, and\n-    /// and we have no clue what the type will be.\n-    UncheckedExprNoHint,\n-}\n \n-impl<'tcx> EvalHint<'tcx> {\n-    fn erase_hint(&self) -> EvalHint<'tcx> {\n-        match *self {\n-            ExprTypeChecked => ExprTypeChecked,\n-            UncheckedExprHint(_) | UncheckedExprNoHint => UncheckedExprNoHint,\n-        }\n-    }\n-    fn checked_or(&self, ty: Ty<'tcx>) -> EvalHint<'tcx> {\n-        match *self {\n-            ExprTypeChecked => ExprTypeChecked,\n-            _ => UncheckedExprHint(ty),\n+            TypeckError => simple!(\"type-checking failed\"),\n         }\n     }\n }\n \n-macro_rules! signal {\n-    ($e:expr, $exn:expr) => {\n-        return Err(ConstEvalErr { span: $e.span, kind: $exn })\n-    }\n-}\n+pub type EvalResult<'tcx> = Result<ConstVal<'tcx>, ConstEvalErr<'tcx>>;\n+pub type CastResult<'tcx> = Result<ConstVal<'tcx>, ErrKind<'tcx>>;\n \n fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n-                                     e: &Expr,\n-                                     ty_hint: EvalHint<'tcx>) -> EvalResult {\n+                                     e: &Expr) -> EvalResult<'tcx> {\n     let tcx = cx.tcx;\n-    // Try to compute the type of the expression based on the EvalHint.\n-    // (See also the definition of EvalHint, and the FIXME above EvalHint.)\n-    let ety = match ty_hint {\n-        ExprTypeChecked => {\n-            // After type-checking, expr_ty is guaranteed to succeed.\n-            cx.tables.map(|tables| tables.expr_ty(e))\n-        }\n-        UncheckedExprHint(ty) => {\n-            // Use the type hint; it's not guaranteed to be right, but it's\n-            // usually good enough.\n-            Some(ty)\n-        }\n-        UncheckedExprNoHint => {\n-            // This expression might not be type-checked, and we have no hint.\n-            // Try to query the context for a type anyway; we might get lucky\n-            // (for example, if the expression was imported from another crate).\n-            cx.tables.and_then(|tables| tables.expr_ty_opt(e))\n-        }\n+    let ety = cx.tables.expr_ty(e);\n+\n+    // Avoid applying substitutions if they're empty, that'd ICE.\n+    let ety = if cx.substs.is_empty() {\n+        ety\n+    } else {\n+        ety.subst(tcx, cx.substs)\n     };\n+\n     let result = match e.node {\n       hir::ExprUnary(hir::UnNeg, ref inner) => {\n         // unary neg literals already got their sign during creation\n@@ -465,28 +376,28 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n             const I32_OVERFLOW: u128 = i32::min_value() as u32 as u128;\n             const I64_OVERFLOW: u128 = i64::min_value() as u64 as u128;\n             const I128_OVERFLOW: u128 = i128::min_value() as u128;\n-            match (&lit.node, ety.map(|t| &t.sty)) {\n-                (&LitKind::Int(I8_OVERFLOW, _), Some(&ty::TyInt(IntTy::I8))) |\n+            match (&lit.node, &ety.sty) {\n+                (&LitKind::Int(I8_OVERFLOW, _), &ty::TyInt(IntTy::I8)) |\n                 (&LitKind::Int(I8_OVERFLOW, Signed(IntTy::I8)), _) => {\n                     return Ok(Integral(I8(i8::min_value())))\n                 },\n-                (&LitKind::Int(I16_OVERFLOW, _), Some(&ty::TyInt(IntTy::I16))) |\n+                (&LitKind::Int(I16_OVERFLOW, _), &ty::TyInt(IntTy::I16)) |\n                 (&LitKind::Int(I16_OVERFLOW, Signed(IntTy::I16)), _) => {\n                     return Ok(Integral(I16(i16::min_value())))\n                 },\n-                (&LitKind::Int(I32_OVERFLOW, _), Some(&ty::TyInt(IntTy::I32))) |\n+                (&LitKind::Int(I32_OVERFLOW, _), &ty::TyInt(IntTy::I32)) |\n                 (&LitKind::Int(I32_OVERFLOW, Signed(IntTy::I32)), _) => {\n                     return Ok(Integral(I32(i32::min_value())))\n                 },\n-                (&LitKind::Int(I64_OVERFLOW, _), Some(&ty::TyInt(IntTy::I64))) |\n+                (&LitKind::Int(I64_OVERFLOW, _), &ty::TyInt(IntTy::I64)) |\n                 (&LitKind::Int(I64_OVERFLOW, Signed(IntTy::I64)), _) => {\n                     return Ok(Integral(I64(i64::min_value())))\n                 },\n-                (&LitKind::Int(I128_OVERFLOW, _), Some(&ty::TyInt(IntTy::I128))) |\n+                (&LitKind::Int(I128_OVERFLOW, _), &ty::TyInt(IntTy::I128)) |\n                 (&LitKind::Int(I128_OVERFLOW, Signed(IntTy::I128)), _) => {\n                     return Ok(Integral(I128(i128::min_value())))\n                 },\n-                (&LitKind::Int(n, _), Some(&ty::TyInt(IntTy::Is))) |\n+                (&LitKind::Int(n, _), &ty::TyInt(IntTy::Is)) |\n                 (&LitKind::Int(n, Signed(IntTy::Is)), _) => {\n                     match tcx.sess.target.int_type {\n                         IntTy::I16 => if n == I16_OVERFLOW {\n@@ -498,37 +409,32 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n                         IntTy::I64 => if n == I64_OVERFLOW {\n                             return Ok(Integral(Isize(Is64(i64::min_value()))));\n                         },\n-                        _ => bug!(),\n+                        _ => span_bug!(e.span, \"typeck error\")\n                     }\n                 },\n                 _ => {},\n             }\n         }\n-        match cx.eval(inner, ty_hint)? {\n+        match cx.eval(inner)? {\n           Float(f) => Float(-f),\n           Integral(i) => Integral(math!(e, -i)),\n           const_val => signal!(e, NegateOn(const_val)),\n         }\n       }\n       hir::ExprUnary(hir::UnNot, ref inner) => {\n-        match cx.eval(inner, ty_hint)? {\n+        match cx.eval(inner)? {\n           Integral(i) => Integral(math!(e, !i)),\n           Bool(b) => Bool(!b),\n           const_val => signal!(e, NotOn(const_val)),\n         }\n       }\n       hir::ExprUnary(hir::UnDeref, _) => signal!(e, UnimplementedConstVal(\"deref operation\")),\n       hir::ExprBinary(op, ref a, ref b) => {\n-        let b_ty = match op.node {\n-            hir::BiShl | hir::BiShr => ty_hint.erase_hint(),\n-            _ => ty_hint\n-        };\n         // technically, if we don't have type hints, but integral eval\n         // gives us a type through a type-suffix, cast or const def type\n         // we need to re-eval the other value of the BinOp if it was\n         // not inferred\n-        match (cx.eval(a, ty_hint)?,\n-               cx.eval(b, b_ty)?) {\n+        match (cx.eval(a)?, cx.eval(b)?) {\n           (Float(a), Float(b)) => {\n             use std::cmp::Ordering::*;\n             match op.node {\n@@ -543,7 +449,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n               hir::BiNe => Bool(math!(e, a.try_cmp(b)) != Equal),\n               hir::BiGe => Bool(math!(e, a.try_cmp(b)) != Less),\n               hir::BiGt => Bool(math!(e, a.try_cmp(b)) == Greater),\n-              _ => signal!(e, InvalidOpForFloats(op.node)),\n+              _ => span_bug!(e.span, \"typeck error\"),\n             }\n           }\n           (Integral(a), Integral(b)) => {\n@@ -565,7 +471,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n               hir::BiNe => Bool(math!(e, a.try_cmp(b)) != Equal),\n               hir::BiGe => Bool(math!(e, a.try_cmp(b)) != Less),\n               hir::BiGt => Bool(math!(e, a.try_cmp(b)) == Greater),\n-              _ => signal!(e, InvalidOpForInts(op.node)),\n+              _ => span_bug!(e.span, \"typeck error\"),\n             }\n           }\n           (Bool(a), Bool(b)) => {\n@@ -581,90 +487,57 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n               hir::BiLe => a <= b,\n               hir::BiGe => a >= b,\n               hir::BiGt => a > b,\n-              _ => signal!(e, InvalidOpForBools(op.node)),\n+              _ => span_bug!(e.span, \"typeck error\"),\n              })\n           }\n \n           _ => signal!(e, MiscBinaryOp),\n         }\n       }\n-      hir::ExprCast(ref base, ref target_ty) => {\n-        let ety = tcx.ast_ty_to_prim_ty(&target_ty).or(ety)\n-                .unwrap_or_else(|| {\n-                    tcx.sess.span_fatal(target_ty.span,\n-                                        \"target type not found for const cast\")\n-                });\n-\n-        let base_hint = if let ExprTypeChecked = ty_hint {\n-            ExprTypeChecked\n-        } else {\n-            match cx.tables.and_then(|tables| tables.expr_ty_opt(&base)) {\n-                Some(t) => UncheckedExprHint(t),\n-                None => ty_hint\n-            }\n-        };\n-\n-        let val = match cx.eval(base, base_hint) {\n-            Ok(val) => val,\n-            Err(ConstEvalErr { kind: ErroneousReferencedConstant(\n-                box ConstEvalErr { kind: TypeMismatch(_, val), .. }), .. }) |\n-            Err(ConstEvalErr { kind: TypeMismatch(_, val), .. }) => {\n-                // Something like `5i8 as usize` doesn't need a type hint for the base\n-                // instead take the type hint from the inner value\n-                let hint = match val.int_type() {\n-                    Some(IntType::UnsignedInt(ty)) => ty_hint.checked_or(tcx.mk_mach_uint(ty)),\n-                    Some(IntType::SignedInt(ty)) => ty_hint.checked_or(tcx.mk_mach_int(ty)),\n-                    // we had a type hint, so we can't have an unknown type\n-                    None => bug!(),\n-                };\n-                cx.eval(base, hint)?\n-            },\n-            Err(e) => return Err(e),\n-        };\n-        match cast_const(tcx, val, ety) {\n+      hir::ExprCast(ref base, _) => {\n+        match cast_const(tcx, cx.eval(base)?, ety) {\n             Ok(val) => val,\n             Err(kind) => return Err(ConstEvalErr { span: e.span, kind: kind }),\n         }\n       }\n       hir::ExprPath(ref qpath) => {\n-          let def = cx.tables.map(|tables| tables.qpath_def(qpath, e.id)).unwrap_or_else(|| {\n-            // There are no tables so we can only handle already-resolved HIR.\n-            match *qpath {\n-                hir::QPath::Resolved(_, ref path) => path.def,\n-                hir::QPath::TypeRelative(..) => Def::Err\n-            }\n-          });\n-          match def {\n+        let substs = cx.tables.node_id_item_substs(e.id)\n+            .unwrap_or_else(|| tcx.intern_substs(&[]));\n+\n+        // Avoid applying substitutions if they're empty, that'd ICE.\n+        let substs = if cx.substs.is_empty() {\n+            substs\n+        } else {\n+            substs.subst(tcx, cx.substs)\n+        };\n+\n+          match cx.tables.qpath_def(qpath, e.id) {\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n-                  let substs = if let ExprTypeChecked = ty_hint {\n-                      Some(cx.tables.and_then(|tables| tables.node_id_item_substs(e.id))\n-                        .unwrap_or_else(|| tcx.intern_substs(&[])))\n-                  } else {\n-                      None\n-                  };\n-                  if let Some((expr, tables, ty)) = lookup_const_by_id(tcx, def_id, substs) {\n-                      let item_hint = match ty {\n-                          Some(ty) => ty_hint.checked_or(ty),\n-                          None => ty_hint,\n-                      };\n-                      let cx = ConstContext { tcx: tcx, tables: tables, fn_args: None };\n-                      match cx.eval(expr, item_hint) {\n+                  if let Some((expr, tables)) = lookup_const_by_id(tcx, def_id, substs) {\n+                      let cx = ConstContext::with_tables(tcx, tables);\n+                      match cx.eval(expr) {\n                           Ok(val) => val,\n+                          Err(ConstEvalErr { kind: TypeckError, .. }) => {\n+                              signal!(e, TypeckError);\n+                          }\n                           Err(err) => {\n                               debug!(\"bad reference: {:?}, {:?}\", err.description(), err.span);\n                               signal!(e, ErroneousReferencedConstant(box err))\n                           },\n                       }\n                   } else {\n-                      signal!(e, NonConstPath);\n+                      signal!(e, TypeckError);\n                   }\n               },\n               Def::VariantCtor(variant_def, ..) => {\n                   if let Some((expr, tables)) = lookup_variant_by_id(tcx, variant_def) {\n-                      let cx = ConstContext { tcx: tcx, tables: tables, fn_args: None };\n-                      match cx.eval(expr, ty_hint) {\n+                      let cx = ConstContext::with_tables(tcx, tables);\n+                      match cx.eval(expr) {\n                           Ok(val) => val,\n+                          Err(ConstEvalErr { kind: TypeckError, .. }) => {\n+                              signal!(e, TypeckError);\n+                          }\n                           Err(err) => {\n                               debug!(\"bad reference: {:?}, {:?}\", err.description(), err.span);\n                               signal!(e, ErroneousReferencedConstant(box err))\n@@ -685,16 +558,14 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n                       signal!(e, NonConstPath);\n                   }\n               },\n-              Def::Method(id) | Def::Fn(id) => Function(id),\n-              Def::Err => signal!(e, UnresolvedPath),\n+              Def::Method(id) | Def::Fn(id) => Function(id, substs),\n+              Def::Err => span_bug!(e.span, \"typeck error\"),\n               _ => signal!(e, NonConstPath),\n           }\n       }\n       hir::ExprCall(ref callee, ref args) => {\n-          let sub_ty_hint = ty_hint.erase_hint();\n-          let callee_val = cx.eval(callee, sub_ty_hint)?;\n-          let did = match callee_val {\n-              Function(did) => did,\n+          let (did, substs) = match cx.eval(callee)? {\n+              Function(did, substs) => (did, substs),\n               Struct(_) => signal!(e, UnimplementedConstVal(\"tuple struct constructors\")),\n               callee => signal!(e, CallOn(callee)),\n           };\n@@ -711,8 +582,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n \n           let mut call_args = DefIdMap();\n           for (arg, arg_expr) in arg_defs.into_iter().zip(args.iter()) {\n-              let arg_hint = ty_hint.erase_hint();\n-              let arg_val = cx.eval(arg_expr, arg_hint)?;\n+              let arg_val = cx.eval(arg_expr)?;\n               debug!(\"const call arg: {:?}\", arg);\n               if let Some(def_id) = arg {\n                 assert!(call_args.insert(def_id, arg_val).is_none());\n@@ -722,42 +592,38 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           let callee_cx = ConstContext {\n             tcx: tcx,\n             tables: tables,\n+            substs: substs,\n             fn_args: Some(call_args)\n           };\n-          callee_cx.eval(&body.value, ty_hint)?\n+          callee_cx.eval(&body.value)?\n       },\n       hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ety) {\n           Ok(val) => val,\n           Err(err) => signal!(e, err),\n       },\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n-            Some(ref expr) => cx.eval(expr, ty_hint)?,\n-            None => signal!(e, UnimplementedConstVal(\"empty block\")),\n+            Some(ref expr) => cx.eval(expr)?,\n+            None => Tuple(vec![]),\n         }\n       }\n-      hir::ExprType(ref e, _) => cx.eval(e, ty_hint)?,\n+      hir::ExprType(ref e, _) => cx.eval(e)?,\n       hir::ExprTup(ref fields) => {\n-        let field_hint = ty_hint.erase_hint();\n-        Tuple(fields.iter().map(|e| cx.eval(e, field_hint)).collect::<Result<_, _>>()?)\n+        Tuple(fields.iter().map(|e| cx.eval(e)).collect::<Result<_, _>>()?)\n       }\n       hir::ExprStruct(_, ref fields, _) => {\n-        let field_hint = ty_hint.erase_hint();\n         Struct(fields.iter().map(|f| {\n-            cx.eval(&f.expr, field_hint).map(|v| (f.name.node, v))\n+            cx.eval(&f.expr).map(|v| (f.name.node, v))\n         }).collect::<Result<_, _>>()?)\n       }\n       hir::ExprIndex(ref arr, ref idx) => {\n         if !tcx.sess.features.borrow().const_indexing {\n             signal!(e, IndexOpFeatureGated);\n         }\n-        let arr_hint = ty_hint.erase_hint();\n-        let arr = cx.eval(arr, arr_hint)?;\n-        let idx_hint = ty_hint.checked_or(tcx.types.usize);\n-        let idx = match cx.eval(idx, idx_hint)? {\n+        let arr = cx.eval(arr)?;\n+        let idx = match cx.eval(idx)? {\n             Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n-            Integral(_) => bug!(),\n-            _ => signal!(idx, IndexNotInt),\n+            _ => signal!(idx, IndexNotUsize),\n         };\n         assert_eq!(idx as usize as u64, idx);\n         match arr {\n@@ -787,45 +653,25 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n         }\n       }\n       hir::ExprArray(ref v) => {\n-        let elem_hint = ty_hint.erase_hint();\n-        Array(v.iter().map(|e| cx.eval(e, elem_hint)).collect::<Result<_, _>>()?)\n+        Array(v.iter().map(|e| cx.eval(e)).collect::<Result<_, _>>()?)\n       }\n-      hir::ExprRepeat(ref elem, count) => {\n-          let elem_hint = ty_hint.erase_hint();\n-          let len_hint = ty_hint.checked_or(tcx.types.usize);\n-          let n = if let Some(ty) = ety {\n-            // For cross-crate constants, we have the type already,\n-            // but not the body for `count`, so use the type.\n-            match ty.sty {\n-                ty::TyArray(_, n) => n as u64,\n-                _ => bug!()\n-            }\n-          } else {\n-            let n = &tcx.hir.body(count).value;\n-            match ConstContext::new(tcx, count).eval(n, len_hint)? {\n-                Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n-                Integral(_) => signal!(e, RepeatCountNotNatural),\n-                _ => signal!(e, RepeatCountNotInt),\n-            }\n+      hir::ExprRepeat(ref elem, _) => {\n+          let n = match ety.sty {\n+            ty::TyArray(_, n) => n as u64,\n+            _ => span_bug!(e.span, \"typeck error\")\n           };\n-          Repeat(Box::new(cx.eval(elem, elem_hint)?), n)\n+          Repeat(Box::new(cx.eval(elem)?), n)\n       },\n       hir::ExprTupField(ref base, index) => {\n-        let base_hint = ty_hint.erase_hint();\n-        let c = cx.eval(base, base_hint)?;\n+        let c = cx.eval(base)?;\n         if let Tuple(ref fields) = c {\n-            if let Some(elem) = fields.get(index.node) {\n-                elem.clone()\n-            } else {\n-                signal!(e, TupleIndexOutOfBounds);\n-            }\n+            fields[index.node].clone()\n         } else {\n             signal!(base, ExpectedConstTuple);\n         }\n       }\n       hir::ExprField(ref base, field_name) => {\n-        let base_hint = ty_hint.erase_hint();\n-        let c = cx.eval(base, base_hint)?;\n+        let c = cx.eval(base)?;\n         if let Struct(ref fields) = c {\n             if let Some(f) = fields.get(&field_name.node) {\n                 f.clone()\n@@ -840,90 +686,23 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n       _ => signal!(e, MiscCatchAll)\n     };\n \n-    match (ety.map(|t| &t.sty), result) {\n-        (Some(ref ty_hint), Integral(i)) => match infer(i, tcx, ty_hint) {\n-            Ok(inferred) => Ok(Integral(inferred)),\n-            Err(err) => signal!(e, err),\n-        },\n-        (_, result) => Ok(result),\n-    }\n-}\n-\n-fn infer<'a, 'tcx>(i: ConstInt,\n-                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                   ty_hint: &ty::TypeVariants<'tcx>)\n-                   -> Result<ConstInt, ErrKind> {\n-    use syntax::ast::*;\n-\n-    match (ty_hint, i) {\n-        (&ty::TyInt(IntTy::I8), result @ I8(_)) => Ok(result),\n-        (&ty::TyInt(IntTy::I16), result @ I16(_)) => Ok(result),\n-        (&ty::TyInt(IntTy::I32), result @ I32(_)) => Ok(result),\n-        (&ty::TyInt(IntTy::I64), result @ I64(_)) => Ok(result),\n-        (&ty::TyInt(IntTy::I128), result @ I128(_)) => Ok(result),\n-        (&ty::TyInt(IntTy::Is), result @ Isize(_)) => Ok(result),\n-\n-        (&ty::TyUint(UintTy::U8), result @ U8(_)) => Ok(result),\n-        (&ty::TyUint(UintTy::U16), result @ U16(_)) => Ok(result),\n-        (&ty::TyUint(UintTy::U32), result @ U32(_)) => Ok(result),\n-        (&ty::TyUint(UintTy::U64), result @ U64(_)) => Ok(result),\n-        (&ty::TyUint(UintTy::U128), result @ U128(_)) => Ok(result),\n-        (&ty::TyUint(UintTy::Us), result @ Usize(_)) => Ok(result),\n-\n-        (&ty::TyInt(IntTy::I8), Infer(i)) => Ok(I8(i as i128 as i8)),\n-        (&ty::TyInt(IntTy::I16), Infer(i)) => Ok(I16(i as i128 as i16)),\n-        (&ty::TyInt(IntTy::I32), Infer(i)) => Ok(I32(i as i128 as i32)),\n-        (&ty::TyInt(IntTy::I64), Infer(i)) => Ok(I64(i as i128 as i64)),\n-        (&ty::TyInt(IntTy::I128), Infer(i)) => Ok(I128(i as i128)),\n-        (&ty::TyInt(IntTy::Is), Infer(i)) => {\n-            Ok(Isize(ConstIsize::new_truncating(i as i128, tcx.sess.target.int_type)))\n-        },\n-\n-        (&ty::TyInt(IntTy::I8), InferSigned(i)) => Ok(I8(i as i8)),\n-        (&ty::TyInt(IntTy::I16), InferSigned(i)) => Ok(I16(i as i16)),\n-        (&ty::TyInt(IntTy::I32), InferSigned(i)) => Ok(I32(i as i32)),\n-        (&ty::TyInt(IntTy::I64), InferSigned(i)) => Ok(I64(i as i64)),\n-        (&ty::TyInt(IntTy::I128), InferSigned(i)) => Ok(I128(i)),\n-        (&ty::TyInt(IntTy::Is), InferSigned(i)) => {\n-            Ok(Isize(ConstIsize::new_truncating(i, tcx.sess.target.int_type)))\n-        },\n-\n-        (&ty::TyUint(UintTy::U8), Infer(i)) => Ok(U8(i as u8)),\n-        (&ty::TyUint(UintTy::U16), Infer(i)) => Ok(U16(i as u16)),\n-        (&ty::TyUint(UintTy::U32), Infer(i)) => Ok(U32(i as u32)),\n-        (&ty::TyUint(UintTy::U64), Infer(i)) => Ok(U64(i as u64)),\n-        (&ty::TyUint(UintTy::U128), Infer(i)) => Ok(U128(i)),\n-        (&ty::TyUint(UintTy::Us), Infer(i)) => {\n-            Ok(Usize(ConstUsize::new_truncating(i, tcx.sess.target.uint_type)))\n-        },\n-        (&ty::TyUint(_), InferSigned(_)) => Err(IntermediateUnsignedNegative),\n-\n-        (&ty::TyInt(ity), i) => Err(TypeMismatch(ity.to_string(), i)),\n-        (&ty::TyUint(ity), i) => Err(TypeMismatch(ity.to_string(), i)),\n-\n-        (&ty::TyAdt(adt, _), i) if adt.is_enum() => {\n-            let hints = tcx.lookup_repr_hints(adt.did);\n-            let int_ty = tcx.enum_repr_type(hints.iter().next());\n-            infer(i, tcx, &int_ty.to_ty(tcx).sty)\n-        },\n-        (_, i) => Err(BadType(ConstVal::Integral(i))),\n-    }\n+    Ok(result)\n }\n \n fn resolve_trait_associated_const<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     trait_item_id: DefId,\n-    default_value: Option<(&'tcx Expr, Option<&'a ty::TypeckTables<'tcx>>, Option<ty::Ty<'tcx>>)>,\n+    default_value: Option<(&'tcx Expr, &'a ty::TypeckTables<'tcx>)>,\n     trait_id: DefId,\n     rcvr_substs: &'tcx Substs<'tcx>\n-) -> Option<(&'tcx Expr, Option<&'a ty::TypeckTables<'tcx>>, Option<ty::Ty<'tcx>>)>\n+) -> Option<(&'tcx Expr, &'a ty::TypeckTables<'tcx>)>\n {\n     let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, rcvr_substs));\n     debug!(\"resolve_trait_associated_const: trait_ref={:?}\",\n            trait_ref);\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_id);\n-    tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n         let mut selcx = traits::SelectionContext::new(&infcx);\n         let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n                                                  trait_ref.to_poly_trait_predicate());\n@@ -951,7 +730,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(\n                 let ac = tcx.associated_items(impl_data.impl_def_id)\n                     .find(|item| item.kind == ty::AssociatedKind::Const && item.name == name);\n                 match ac {\n-                    Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n+                    Some(ic) => lookup_const_by_id(tcx, ic.def_id, Substs::empty()),\n                     None => default_value,\n                 }\n             }\n@@ -962,7 +741,10 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(\n     })\n }\n \n-fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstInt, ty: ty::Ty) -> CastResult {\n+fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            val: ConstInt,\n+                            ty: Ty<'tcx>)\n+                            -> CastResult<'tcx> {\n     let v = val.to_u128_unchecked();\n     match ty.sty {\n         ty::TyBool if v == 0 => Ok(Bool(false)),\n@@ -983,66 +765,58 @@ fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstInt, ty: ty::\n         ty::TyUint(ast::UintTy::Us) => {\n             Ok(Integral(Usize(ConstUsize::new_truncating(v, tcx.sess.target.uint_type))))\n         },\n-        ty::TyFloat(ast::FloatTy::F64) => match val.erase_type() {\n-            Infer(u) => Ok(Float(F64(u as f64))),\n-            InferSigned(i) => Ok(Float(F64(i as f64))),\n-            _ => bug!(\"ConstInt::erase_type returned something other than Infer/InferSigned\"),\n-        },\n-        ty::TyFloat(ast::FloatTy::F32) => match val.erase_type() {\n-            Infer(u) => Ok(Float(F32(u as f32))),\n-            InferSigned(i) => Ok(Float(F32(i as f32))),\n-            _ => bug!(\"ConstInt::erase_type returned something other than Infer/InferSigned\"),\n-        },\n+        ty::TyFloat(ast::FloatTy::F64) => Ok(Float(F64(val.to_f64()))),\n+        ty::TyFloat(ast::FloatTy::F32) => Ok(Float(F32(val.to_f32()))),\n         ty::TyRawPtr(_) => Err(ErrKind::UnimplementedConstVal(\"casting an address to a raw ptr\")),\n-        ty::TyChar => match infer(val, tcx, &ty::TyUint(ast::UintTy::U8)) {\n-            Ok(U8(u)) => Ok(Char(u as char)),\n-            // can only occur before typeck, typeck blocks `T as char` for `T` != `u8`\n-            _ => Err(CharCast(val)),\n+        ty::TyChar => match val {\n+            U8(u) => Ok(Char(u as char)),\n+            _ => bug!(),\n         },\n-        _ => Err(CannotCast),\n+        _ => bug!(),\n     }\n }\n \n fn cast_const_float<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               val: ConstFloat,\n-                              ty: ty::Ty) -> CastResult {\n+                              ty: Ty<'tcx>) -> CastResult<'tcx> {\n     match ty.sty {\n         ty::TyInt(_) | ty::TyUint(_) => {\n             let i = match val {\n-                F32(f) if f >= 0.0 => Infer(f as u128),\n-                FInfer { f64: f, .. } |\n-                F64(f) if f >= 0.0 => Infer(f as u128),\n+                F32(f) if f >= 0.0 => U128(f as u128),\n+                F64(f) if f >= 0.0 => U128(f as u128),\n \n-                F32(f) => InferSigned(f as i128),\n-                FInfer { f64: f, .. } |\n-                F64(f) => InferSigned(f as i128)\n+                F32(f) => I128(f as i128),\n+                F64(f) => I128(f as i128)\n             };\n \n-            if let (InferSigned(_), &ty::TyUint(_)) = (i, &ty.sty) {\n+            if let (I128(_), &ty::TyUint(_)) = (i, &ty.sty) {\n                 return Err(CannotCast);\n             }\n \n             cast_const_int(tcx, i, ty)\n         }\n         ty::TyFloat(ast::FloatTy::F64) => Ok(Float(F64(match val {\n             F32(f) => f as f64,\n-            FInfer { f64: f, .. } | F64(f) => f\n+            F64(f) => f\n         }))),\n         ty::TyFloat(ast::FloatTy::F32) => Ok(Float(F32(match val {\n             F64(f) => f as f32,\n-            FInfer { f32: f, .. } | F32(f) => f\n+            F32(f) => f\n         }))),\n         _ => Err(CannotCast),\n     }\n }\n \n-fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstVal, ty: ty::Ty) -> CastResult {\n+fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        val: ConstVal<'tcx>,\n+                        ty: Ty<'tcx>)\n+                        -> CastResult<'tcx> {\n     match val {\n         Integral(i) => cast_const_int(tcx, i, ty),\n-        Bool(b) => cast_const_int(tcx, Infer(b as u128), ty),\n+        Bool(b) => cast_const_int(tcx, U8(b as u8), ty),\n         Float(f) => cast_const_float(tcx, f, ty),\n-        Char(c) => cast_const_int(tcx, Infer(c as u128), ty),\n-        Function(_) => Err(UnimplementedConstVal(\"casting fn pointers\")),\n+        Char(c) => cast_const_int(tcx, U32(c as u32), ty),\n+        Function(..) => Err(UnimplementedConstVal(\"casting fn pointers\")),\n         ByteStr(b) => match ty.sty {\n             ty::TyRawPtr(_) => {\n                 Err(ErrKind::UnimplementedConstVal(\"casting a bytestr to a raw ptr\"))\n@@ -1070,67 +844,56 @@ fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstVal, ty: ty::Ty)\n \n fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          ty_hint: Option<Ty<'tcx>>)\n-                          -> Result<ConstVal, ErrKind> {\n+                          mut ty: Ty<'tcx>)\n+                          -> Result<ConstVal<'tcx>, ErrKind<'tcx>> {\n     use syntax::ast::*;\n     use syntax::ast::LitIntType::*;\n+\n+    if let ty::TyAdt(adt, _) = ty.sty {\n+        if adt.is_enum() {\n+            ty = adt.repr.discr_type().to_ty(tcx)\n+        }\n+    }\n+\n     match *lit {\n         LitKind::Str(ref s, _) => Ok(Str(s.as_str())),\n         LitKind::ByteStr(ref data) => Ok(ByteStr(data.clone())),\n         LitKind::Byte(n) => Ok(Integral(U8(n))),\n-        LitKind::Int(n, Signed(ity)) => {\n-            infer(InferSigned(n as i128), tcx, &ty::TyInt(ity)).map(Integral)\n-        },\n-\n-        // FIXME: this should become u128.\n-        LitKind::Int(n, Unsuffixed) => {\n-            match ty_hint.map(|t| &t.sty) {\n-                Some(&ty::TyInt(ity)) => {\n-                    infer(InferSigned(n as i128), tcx, &ty::TyInt(ity)).map(Integral)\n-                },\n-                Some(&ty::TyUint(uty)) => {\n-                    infer(Infer(n as u128), tcx, &ty::TyUint(uty)).map(Integral)\n-                },\n-                None => Ok(Integral(Infer(n as u128))),\n-                Some(&ty::TyAdt(adt, _)) => {\n-                    let hints = tcx.lookup_repr_hints(adt.did);\n-                    let int_ty = tcx.enum_repr_type(hints.iter().next());\n-                    infer(Infer(n as u128), tcx, &int_ty.to_ty(tcx).sty).map(Integral)\n-                },\n-                Some(ty_hint) => bug!(\"bad ty_hint: {:?}, {:?}\", ty_hint, lit),\n+        LitKind::Int(n, hint) => {\n+            match (&ty.sty, hint) {\n+                (&ty::TyInt(ity), _) |\n+                (_, Signed(ity)) => {\n+                    Ok(Integral(ConstInt::new_signed_truncating(n as i128,\n+                        ity, tcx.sess.target.int_type)))\n+                }\n+                (&ty::TyUint(uty), _) |\n+                (_, Unsigned(uty)) => {\n+                    Ok(Integral(ConstInt::new_unsigned_truncating(n as u128,\n+                        uty, tcx.sess.target.uint_type)))\n+                }\n+                _ => bug!()\n             }\n-        },\n-        LitKind::Int(n, Unsigned(ity)) => {\n-            infer(Infer(n as u128), tcx, &ty::TyUint(ity)).map(Integral)\n-        },\n-\n+        }\n         LitKind::Float(n, fty) => {\n-            parse_float(&n.as_str(), Some(fty)).map(Float)\n+            parse_float(&n.as_str(), fty).map(Float)\n         }\n         LitKind::FloatUnsuffixed(n) => {\n-            let fty_hint = match ty_hint.map(|t| &t.sty) {\n-                Some(&ty::TyFloat(fty)) => Some(fty),\n-                _ => None\n+            let fty = match ty.sty {\n+                ty::TyFloat(fty) => fty,\n+                _ => bug!()\n             };\n-            parse_float(&n.as_str(), fty_hint).map(Float)\n+            parse_float(&n.as_str(), fty).map(Float)\n         }\n         LitKind::Bool(b) => Ok(Bool(b)),\n         LitKind::Char(c) => Ok(Char(c)),\n     }\n }\n \n-fn parse_float(num: &str, fty_hint: Option<ast::FloatTy>)\n-               -> Result<ConstFloat, ErrKind> {\n-    let val = match fty_hint {\n-        Some(ast::FloatTy::F32) => num.parse::<f32>().map(F32),\n-        Some(ast::FloatTy::F64) => num.parse::<f64>().map(F64),\n-        None => {\n-            num.parse::<f32>().and_then(|f32| {\n-                num.parse::<f64>().map(|f64| {\n-                    FInfer { f32: f32, f64: f64 }\n-                })\n-            })\n-        }\n+fn parse_float<'tcx>(num: &str, fty: ast::FloatTy)\n+                     -> Result<ConstFloat, ErrKind<'tcx>> {\n+    let val = match fty {\n+        ast::FloatTy::F32 => num.parse::<f32>().map(F32),\n+        ast::FloatTy::F64 => num.parse::<f64>().map(F64)\n     };\n     val.map_err(|_| {\n         // FIXME(#31407) this is only necessary because float parsing is buggy\n@@ -1170,17 +933,17 @@ impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n                              a: &Expr,\n                              b: &Expr) -> Result<Ordering, ErrorReported> {\n         let tcx = self.tcx;\n-        let a = match self.eval(a, ExprTypeChecked) {\n+        let a = match self.eval(a) {\n             Ok(a) => a,\n             Err(e) => {\n-                report_const_eval_err(tcx, &e, a.span, \"expression\").emit();\n+                report_const_eval_err(tcx, &e, a.span, \"expression\");\n                 return Err(ErrorReported);\n             }\n         };\n-        let b = match self.eval(b, ExprTypeChecked) {\n+        let b = match self.eval(b) {\n             Ok(b) => b,\n             Err(e) => {\n-                report_const_eval_err(tcx, &e, b.span, \"expression\").emit();\n+                report_const_eval_err(tcx, &e, b.span, \"expression\");\n                 return Err(ErrorReported);\n             }\n         };\n@@ -1195,26 +958,17 @@ pub fn eval_length<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              reason: &str)\n                              -> Result<usize, ErrorReported>\n {\n-    let hint = UncheckedExprHint(tcx.types.usize);\n     let count_expr = &tcx.hir.body(count).value;\n-    match ConstContext::new(tcx, count).eval(count_expr, hint) {\n+    match ConstContext::new(tcx, count).eval(count_expr) {\n         Ok(Integral(Usize(count))) => {\n             let val = count.as_u64(tcx.sess.target.uint_type);\n             assert_eq!(val as usize as u64, val);\n             Ok(val as usize)\n         },\n-        Ok(const_val) => {\n-            struct_span_err!(tcx.sess, count_expr.span, E0306,\n-                             \"expected `usize` for {}, found {}\",\n-                             reason,\n-                             const_val.description())\n-                .span_label(count_expr.span, &format!(\"expected `usize`\"))\n-                .emit();\n-\n-            Err(ErrorReported)\n-        }\n+        Ok(_) |\n+        Err(ConstEvalErr { kind: TypeckError, .. }) => Err(ErrorReported),\n         Err(err) => {\n-            let mut diag = report_const_eval_err(\n+            let mut diag = build_const_eval_err(\n                 tcx, &err, count_expr.span, reason);\n \n             if let hir::ExprPath(hir::QPath::Resolved(None, ref path)) = count_expr.node {"}, {"sha": "4434a901f9412512f29ed52bcf674f7a15d0b106", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -21,6 +21,7 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![deny(warnings)]\n \n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "72a47c0028162a39d6e9d894cdbdf1380c52bf4f", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -27,9 +27,9 @@ use syntax::ptr::P;\n use syntax_pos::Span;\n \n #[derive(Clone, Debug)]\n-pub enum PatternError {\n+pub enum PatternError<'tcx> {\n     StaticInPattern(Span),\n-    ConstEval(eval::ConstEvalErr),\n+    ConstEval(eval::ConstEvalErr<'tcx>),\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -84,12 +84,12 @@ pub enum PatternKind<'tcx> {\n     },\n \n     Constant {\n-        value: ConstVal,\n+        value: ConstVal<'tcx>,\n     },\n \n     Range {\n-        lo: ConstVal,\n-        hi: ConstVal,\n+        lo: ConstVal<'tcx>,\n+        hi: ConstVal<'tcx>,\n         end: RangeEnd,\n     },\n \n@@ -118,7 +118,7 @@ fn print_const_val(value: &ConstVal, f: &mut fmt::Formatter) -> fmt::Result {\n         ConstVal::Char(c) => write!(f, \"{:?}\", c),\n         ConstVal::Struct(_) |\n         ConstVal::Tuple(_) |\n-        ConstVal::Function(_) |\n+        ConstVal::Function(..) |\n         ConstVal::Array(..) |\n         ConstVal::Repeat(..) => bug!(\"{:?} not printable in a pattern\", value)\n     }\n@@ -265,7 +265,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n pub struct PatternContext<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     pub tables: &'a ty::TypeckTables<'gcx>,\n-    pub errors: Vec<PatternError>,\n+    pub errors: Vec<PatternError<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> Pattern<'tcx> {\n@@ -582,11 +582,11 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 let tcx = self.tcx.global_tcx();\n                 let substs = self.tables.node_id_item_substs(id)\n                     .unwrap_or_else(|| tcx.intern_substs(&[]));\n-                match eval::lookup_const_by_id(tcx, def_id, Some(substs)) {\n-                    Some((const_expr, const_tables, _const_ty)) => {\n+                match eval::lookup_const_by_id(tcx, def_id, substs) {\n+                    Some((const_expr, const_tables)) => {\n                         // Enter the inlined constant's tables temporarily.\n                         let old_tables = self.tables;\n-                        self.tables = const_tables.expect(\"missing tables after typeck\");\n+                        self.tables = const_tables;\n                         let pat = self.lower_const_expr(const_expr, pat_id, span);\n                         self.tables = old_tables;\n                         return pat;\n@@ -609,7 +609,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n \n     fn lower_lit(&mut self, expr: &hir::Expr) -> PatternKind<'tcx> {\n         let const_cx = eval::ConstContext::with_tables(self.tcx.global_tcx(), self.tables);\n-        match const_cx.eval(expr, eval::EvalHint::ExprTypeChecked) {\n+        match const_cx.eval(expr) {\n             Ok(value) => {\n                 PatternKind::Constant { value: value }\n             }\n@@ -796,7 +796,7 @@ macro_rules! CloneImpls {\n }\n \n CloneImpls!{ <'tcx>\n-    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal, Region,\n+    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal<'tcx>, Region,\n     Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef,\n     &'tcx Substs<'tcx>, &'tcx Kind<'tcx>\n }"}, {"sha": "f557edffbda462053b3a8bfcfb737d407a291bd7", "filename": "src/librustc_const_math/float.rs", "status": "modified", "additions": 7, "deletions": 40, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_const_math%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_const_math%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ffloat.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -17,21 +17,14 @@ use super::err::*;\n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum ConstFloat {\n     F32(f32),\n-    F64(f64),\n-\n-    // When the type isn't known, we have to operate on both possibilities.\n-    FInfer {\n-        f32: f32,\n-        f64: f64\n-    }\n+    F64(f64)\n }\n pub use self::ConstFloat::*;\n \n impl ConstFloat {\n     /// Description of the type, not the value\n     pub fn description(&self) -> &'static str {\n         match *self {\n-            FInfer {..} => \"float\",\n             F32(_) => \"f32\",\n             F64(_) => \"f64\",\n         }\n@@ -41,17 +34,13 @@ impl ConstFloat {\n         match *self {\n             F32(f) => f.is_nan(),\n             F64(f) => f.is_nan(),\n-            FInfer { f32, f64 } => f32.is_nan() || f64.is_nan()\n         }\n     }\n \n     /// Compares the values if they are of the same type\n     pub fn try_cmp(self, rhs: Self) -> Result<Ordering, ConstMathErr> {\n         match (self, rhs) {\n-            (F64(a), F64(b)) |\n-            (F64(a), FInfer { f64: b, .. }) |\n-            (FInfer { f64: a, .. }, F64(b)) |\n-            (FInfer { f64: a, .. }, FInfer { f64: b, .. })  => {\n+            (F64(a), F64(b))  => {\n                 // This is pretty bad but it is the existing behavior.\n                 Ok(if a == b {\n                     Ordering::Equal\n@@ -62,9 +51,7 @@ impl ConstFloat {\n                 })\n             }\n \n-            (F32(a), F32(b)) |\n-            (F32(a), FInfer { f32: b, .. }) |\n-            (FInfer { f32: a, .. }, F32(b)) => {\n+            (F32(a), F32(b)) => {\n                 Ok(if a == b {\n                     Ordering::Equal\n                 } else if a < b {\n@@ -86,10 +73,7 @@ impl ConstFloat {\n impl PartialEq for ConstFloat {\n     fn eq(&self, other: &Self) -> bool {\n         match (*self, *other) {\n-            (F64(a), F64(b)) |\n-            (F64(a), FInfer { f64: b, .. }) |\n-            (FInfer { f64: a, .. }, F64(b)) |\n-            (FInfer { f64: a, .. }, FInfer { f64: b, .. }) => {\n+            (F64(a), F64(b)) => {\n                 unsafe{transmute::<_,u64>(a) == transmute::<_,u64>(b)}\n             }\n             (F32(a), F32(b)) => {\n@@ -105,7 +89,7 @@ impl Eq for ConstFloat {}\n impl hash::Hash for ConstFloat {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n         match *self {\n-            F64(a) | FInfer { f64: a, .. } => {\n+            F64(a) => {\n                 unsafe { transmute::<_,u64>(a) }.hash(state)\n             }\n             F32(a) => {\n@@ -118,7 +102,6 @@ impl hash::Hash for ConstFloat {\n impl ::std::fmt::Display for ConstFloat {\n     fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n         match *self {\n-            FInfer { f64, .. } => write!(fmt, \"{}\", f64),\n             F32(f) => write!(fmt, \"{}f32\", f),\n             F64(f) => write!(fmt, \"{}f64\", f),\n         }\n@@ -131,20 +114,8 @@ macro_rules! derive_binop {\n             type Output = Result<Self, ConstMathErr>;\n             fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n                 match (self, rhs) {\n-                    (F32(a), F32(b)) |\n-                    (F32(a), FInfer { f32: b, .. }) |\n-                    (FInfer { f32: a, .. }, F32(b)) => Ok(F32(a.$func(b))),\n-\n-                    (F64(a), F64(b)) |\n-                    (FInfer { f64: a, .. }, F64(b)) |\n-                    (F64(a), FInfer { f64: b, .. }) => Ok(F64(a.$func(b))),\n-\n-                    (FInfer { f32: a32, f64: a64 },\n-                     FInfer { f32: b32, f64: b64 }) => Ok(FInfer {\n-                        f32: a32.$func(b32),\n-                        f64: a64.$func(b64)\n-                    }),\n-\n+                    (F32(a), F32(b)) => Ok(F32(a.$func(b))),\n+                    (F64(a), F64(b)) => Ok(F64(a.$func(b))),\n                     _ => Err(UnequalTypes(Op::$op)),\n                 }\n             }\n@@ -164,10 +135,6 @@ impl ::std::ops::Neg for ConstFloat {\n         match self {\n             F32(f) => F32(-f),\n             F64(f) => F64(-f),\n-            FInfer { f32, f64 } => FInfer {\n-                f32: -f32,\n-                f64: -f64\n-            }\n         }\n     }\n }"}, {"sha": "d97276da9bf34b9315d7a410f403fe34a558a076", "filename": "src/librustc_const_math/int.rs", "status": "modified", "additions": 97, "deletions": 151, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_const_math%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_const_math%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fint.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -30,8 +30,6 @@ pub enum ConstInt {\n     U64(u64),\n     U128(u128),\n     Usize(ConstUsize),\n-    Infer(u128),\n-    InferSigned(i128),\n }\n pub use self::ConstInt::*;\n \n@@ -77,14 +75,6 @@ mod ibounds {\n }\n \n impl ConstInt {\n-    pub fn new_inttype(val: u128, ty: IntType, usize_ty: UintTy, isize_ty: IntTy)\n-    -> Option<ConstInt> {\n-        match ty {\n-            IntType::SignedInt(i) => ConstInt::new_signed(val as i128, i, isize_ty),\n-            IntType::UnsignedInt(i) => ConstInt::new_unsigned(val, i, usize_ty),\n-        }\n-    }\n-\n     /// Creates a new unsigned ConstInt with matching type while also checking that overflow does\n     /// not happen.\n     pub fn new_unsigned(val: u128, ty: UintTy, usize_ty: UintTy) -> Option<ConstInt> {\n@@ -100,7 +90,7 @@ impl ConstInt {\n         }\n     }\n \n-    /// Creates a new unsigned ConstInt with matching type while also checking that overflow does\n+    /// Creates a new signed ConstInt with matching type while also checking that overflow does\n     /// not happen.\n     pub fn new_signed(val: i128, ty: IntTy, isize_ty: IntTy) -> Option<ConstInt> {\n         match ty {\n@@ -115,103 +105,33 @@ impl ConstInt {\n         }\n     }\n \n-    /// If either value is `Infer` or `InferSigned`, try to turn the value into the type of\n-    /// the other value. If both values have no type, don't do anything\n-    pub fn infer(self, other: Self) -> Result<(Self, Self), ConstMathErr> {\n-        let inferred = match (self, other) {\n-            (InferSigned(_), InferSigned(_))\n-            | (Infer(_), Infer(_)) => self, // no inference possible\n-            // kindof wrong, you could have had values > I64MAX during computation of a\n-            (Infer(a @ 0...ubounds::I64MAX), InferSigned(_)) => InferSigned(a as i128),\n-            (Infer(_), InferSigned(_)) => return Err(ConstMathErr::NotInRange),\n-            (_, InferSigned(_))\n-            | (_, Infer(_)) => return other.infer(self).map(|(b, a)| (a, b)),\n-\n-            (Infer(a @ 0...ubounds::I8MAX), I8(_)) => I8(a as i64 as i8),\n-            (Infer(a @ 0...ubounds::I16MAX), I16(_)) => I16(a as i64 as i16),\n-            (Infer(a @ 0...ubounds::I32MAX), I32(_)) => I32(a as i64 as i32),\n-            (Infer(a @ 0...ubounds::I64MAX), I64(_)) => I64(a as i64),\n-            (Infer(a @ 0...ubounds::I128MAX), I128(_)) => I128(a as i128),\n-            (Infer(a @ 0...ubounds::I16MAX), Isize(Is16(_))) => Isize(Is16(a as i64 as i16)),\n-            (Infer(a @ 0...ubounds::I32MAX), Isize(Is32(_))) => Isize(Is32(a as i64 as i32)),\n-            (Infer(a @ 0...ubounds::I64MAX), Isize(Is64(_))) => Isize(Is64(a as i64)),\n-            (Infer(a @ 0...ubounds::U8MAX), U8(_)) => U8(a as u8),\n-            (Infer(a @ 0...ubounds::U16MAX), U16(_)) => U16(a as u16),\n-            (Infer(a @ 0...ubounds::U32MAX), U32(_)) => U32(a as u32),\n-            (Infer(a @ 0...ubounds::U64MAX), U64(_)) => U64(a as u64),\n-            (Infer(a @ 0...ubounds::U128MAX), U128(_)) => U128(a as u128),\n-            (Infer(a @ 0...ubounds::U16MAX), Usize(Us16(_))) => Usize(Us16(a as u16)),\n-            (Infer(a @ 0...ubounds::U32MAX), Usize(Us32(_))) => Usize(Us32(a as u32)),\n-            (Infer(a @ 0...ubounds::U64MAX), Usize(Us64(_))) => Usize(Us64(a as u64)),\n-\n-            (Infer(_), _) => return Err(ConstMathErr::NotInRange),\n-\n-            (InferSigned(a @ ibounds::I8MIN...ibounds::I8MAX), I8(_)) => I8(a as i8),\n-            (InferSigned(a @ ibounds::I16MIN...ibounds::I16MAX), I16(_)) => I16(a as i16),\n-            (InferSigned(a @ ibounds::I32MIN...ibounds::I32MAX), I32(_)) => I32(a as i32),\n-            (InferSigned(a @ ibounds::I64MIN...ibounds::I64MAX), I64(_)) => I64(a as i64),\n-            (InferSigned(a @ ibounds::I128MIN...ibounds::I128MAX), I128(_)) => I128(a as i128),\n-            (InferSigned(a @ ibounds::I16MIN...ibounds::I16MAX), Isize(Is16(_))) => {\n-                Isize(Is16(a as i16))\n-            },\n-            (InferSigned(a @ ibounds::I32MIN...ibounds::I32MAX), Isize(Is32(_))) => {\n-                Isize(Is32(a as i32))\n-            },\n-            (InferSigned(a @ ibounds::I64MIN...ibounds::I64MAX), Isize(Is64(_))) => {\n-                Isize(Is64(a as i64))\n-            },\n-            (InferSigned(a @ 0...ibounds::U8MAX), U8(_)) => U8(a as u8),\n-            (InferSigned(a @ 0...ibounds::U16MAX), U16(_)) => U16(a as u16),\n-            (InferSigned(a @ 0...ibounds::U32MAX), U32(_)) => U32(a as u32),\n-            (InferSigned(a @ 0...ibounds::U64MAX), U64(_)) => U64(a as u64),\n-            (InferSigned(a @ 0...ibounds::I128MAX), U128(_)) => U128(a as u128),\n-            (InferSigned(a @ 0...ibounds::U16MAX), Usize(Us16(_))) => Usize(Us16(a as u16)),\n-            (InferSigned(a @ 0...ibounds::U32MAX), Usize(Us32(_))) => Usize(Us32(a as u32)),\n-            (InferSigned(a @ 0...ibounds::U64MAX), Usize(Us64(_))) => Usize(Us64(a as u64)),\n-            (InferSigned(_), _) => return Err(ConstMathErr::NotInRange),\n-            _ => self, // already known types\n-        };\n-        Ok((inferred, other))\n+    /// Creates a new unsigned ConstInt with matching type.\n+    pub fn new_unsigned_truncating(val: u128, ty: UintTy, usize_ty: UintTy) -> ConstInt {\n+        match ty {\n+            UintTy::U8 => U8(val as u8),\n+            UintTy::U16 => U16(val as u16),\n+            UintTy::U32 => U32(val as u32),\n+            UintTy::U64 => U64(val as u64),\n+            UintTy::Us => Usize(ConstUsize::new_truncating(val, usize_ty)),\n+            UintTy::U128 => U128(val)\n+        }\n     }\n \n-    /// Turn this value into an `Infer` or an `InferSigned`\n-    pub fn erase_type(self) -> Self {\n-        match self {\n-            Infer(i) => Infer(i),\n-            InferSigned(i) if i < 0 => InferSigned(i),\n-            I8(i) if i < 0 => InferSigned(i as i128),\n-            I16(i) if i < 0 => InferSigned(i as i128),\n-            I32(i) if i < 0 => InferSigned(i as i128),\n-            I64(i) if i < 0 => InferSigned(i as i128),\n-            I128(i) if i < 0 => InferSigned(i as i128),\n-            Isize(Is16(i)) if i < 0 => InferSigned(i as i128),\n-            Isize(Is32(i)) if i < 0 => InferSigned(i as i128),\n-            Isize(Is64(i)) if i < 0 => InferSigned(i as i128),\n-            InferSigned(i) => Infer(i as u128),\n-            I8(i) => Infer(i as u128),\n-            I16(i) => Infer(i as u128),\n-            I32(i) => Infer(i as u128),\n-            I64(i) => Infer(i as u128),\n-            I128(i) => Infer(i as u128),\n-            Isize(Is16(i)) => Infer(i as u128),\n-            Isize(Is32(i)) => Infer(i as u128),\n-            Isize(Is64(i)) => Infer(i as u128),\n-            U8(i) => Infer(i as u128),\n-            U16(i) => Infer(i as u128),\n-            U32(i) => Infer(i as u128),\n-            U64(i) => Infer(i as u128),\n-            U128(i) => Infer(i as u128),\n-            Usize(Us16(i)) => Infer(i as u128),\n-            Usize(Us32(i)) => Infer(i as u128),\n-            Usize(Us64(i)) => Infer(i as u128),\n+    /// Creates a new signed ConstInt with matching type.\n+    pub fn new_signed_truncating(val: i128, ty: IntTy, isize_ty: IntTy) -> ConstInt {\n+        match ty {\n+            IntTy::I8 => I8(val as i8),\n+            IntTy::I16 => I16(val as i16),\n+            IntTy::I32 => I32(val as i32),\n+            IntTy::I64 => I64(val as i64),\n+            IntTy::Is => Isize(ConstIsize::new_truncating(val, isize_ty)),\n+            IntTy::I128 => I128(val)\n         }\n     }\n \n     /// Description of the type, not the value\n     pub fn description(&self) -> &'static str {\n         match *self {\n-            Infer(_) => \"not yet inferred integral\",\n-            InferSigned(_) => \"not yet inferred signed integral\",\n             I8(_) => \"i8\",\n             I16(_) => \"i16\",\n             I32(_) => \"i32\",\n@@ -230,10 +150,23 @@ impl ConstInt {\n     /// Erases the type and returns a u128.\n     /// This is not the same as `-5i8 as u128` but as `-5i8 as i128 as u128`\n     pub fn to_u128_unchecked(self) -> u128 {\n-        match self.erase_type() {\n-            ConstInt::Infer(i) => i,\n-            ConstInt::InferSigned(i) => i as u128,\n-            _ => unreachable!(),\n+        match self {\n+            I8(i) => i as i128 as u128,\n+            I16(i) => i as i128 as u128,\n+            I32(i) => i as i128 as u128,\n+            I64(i) => i as i128 as u128,\n+            I128(i) => i as i128 as u128,\n+            Isize(Is16(i)) => i as i128 as u128,\n+            Isize(Is32(i)) => i as i128 as u128,\n+            Isize(Is64(i)) => i as i128 as u128,\n+            U8(i) => i as u128,\n+            U16(i) => i as u128,\n+            U32(i) => i as u128,\n+            U64(i) => i as u128,\n+            U128(i) => i as u128,\n+            Usize(Us16(i)) => i as u128,\n+            Usize(Us32(i)) => i as u128,\n+            Usize(Us64(i)) => i as u128,\n         }\n     }\n \n@@ -258,8 +191,6 @@ impl ConstInt {\n     /// Converts the value to a `u128` if it's in the range 0...std::u128::MAX\n     pub fn to_u128(&self) -> Option<u128> {\n         match *self {\n-            Infer(v) => Some(v),\n-            InferSigned(v) if v >= 0 => Some(v as u128),\n             I8(v) if v >= 0 => Some(v as u128),\n             I16(v) if v >= 0 => Some(v as u128),\n             I32(v) if v >= 0 => Some(v as u128),\n@@ -280,6 +211,48 @@ impl ConstInt {\n         }\n     }\n \n+    pub fn to_f32(self) -> f32 {\n+        match self {\n+            I8(i) => i as f32,\n+            I16(i) => i as f32,\n+            I32(i) => i as f32,\n+            I64(i) => i as f32,\n+            I128(i) => i as f32,\n+            Isize(Is16(i)) => i as f32,\n+            Isize(Is32(i)) => i as f32,\n+            Isize(Is64(i)) => i as f32,\n+            U8(i) => i as f32,\n+            U16(i) => i as f32,\n+            U32(i) => i as f32,\n+            U64(i) => i as f32,\n+            U128(i) => i as f32,\n+            Usize(Us16(i)) => i as f32,\n+            Usize(Us32(i)) => i as f32,\n+            Usize(Us64(i)) => i as f32,\n+        }\n+    }\n+\n+    pub fn to_f64(self) -> f64 {\n+        match self {\n+            I8(i) => i as f64,\n+            I16(i) => i as f64,\n+            I32(i) => i as f64,\n+            I64(i) => i as f64,\n+            I128(i) => i as f64,\n+            Isize(Is16(i)) => i as f64,\n+            Isize(Is32(i)) => i as f64,\n+            Isize(Is64(i)) => i as f64,\n+            U8(i) => i as f64,\n+            U16(i) => i as f64,\n+            U32(i) => i as f64,\n+            U64(i) => i as f64,\n+            U128(i) => i as f64,\n+            Usize(Us16(i)) => i as f64,\n+            Usize(Us32(i)) => i as f64,\n+            Usize(Us64(i)) => i as f64,\n+        }\n+    }\n+\n     pub fn is_negative(&self) -> bool {\n         match *self {\n             I8(v) => v < 0,\n@@ -290,14 +263,13 @@ impl ConstInt {\n             Isize(Is16(v)) => v < 0,\n             Isize(Is32(v)) => v < 0,\n             Isize(Is64(v)) => v < 0,\n-            InferSigned(v) => v < 0,\n             _ => false,\n         }\n     }\n \n     /// Compares the values if they are of the same type\n     pub fn try_cmp(self, rhs: Self) -> Result<::std::cmp::Ordering, ConstMathErr> {\n-        match self.infer(rhs)? {\n+        match (self, rhs) {\n             (I8(a), I8(b)) => Ok(a.cmp(&b)),\n             (I16(a), I16(b)) => Ok(a.cmp(&b)),\n             (I32(a), I32(b)) => Ok(a.cmp(&b)),\n@@ -314,8 +286,6 @@ impl ConstInt {\n             (Usize(Us16(a)), Usize(Us16(b))) => Ok(a.cmp(&b)),\n             (Usize(Us32(a)), Usize(Us32(b))) => Ok(a.cmp(&b)),\n             (Usize(Us64(a)), Usize(Us64(b))) => Ok(a.cmp(&b)),\n-            (Infer(a), Infer(b)) => Ok(a.cmp(&b)),\n-            (InferSigned(a), InferSigned(b)) => Ok(a.cmp(&b)),\n             _ => Err(CmpBetweenUnequalTypes),\n         }\n     }\n@@ -342,25 +312,23 @@ impl ConstInt {\n             ConstInt::Usize(ConstUsize::Us16(i)) => ConstInt::Usize(ConstUsize::Us16(add1!(i))),\n             ConstInt::Usize(ConstUsize::Us32(i)) => ConstInt::Usize(ConstUsize::Us32(add1!(i))),\n             ConstInt::Usize(ConstUsize::Us64(i)) => ConstInt::Usize(ConstUsize::Us64(add1!(i))),\n-            ConstInt::Infer(_) | ConstInt::InferSigned(_) => panic!(\"no type info for const int\"),\n         }\n     }\n \n-    pub fn int_type(self) -> Option<IntType> {\n+    pub fn int_type(self) -> IntType {\n         match self {\n-            ConstInt::I8(_) => Some(IntType::SignedInt(IntTy::I8)),\n-            ConstInt::I16(_) => Some(IntType::SignedInt(IntTy::I16)),\n-            ConstInt::I32(_) => Some(IntType::SignedInt(IntTy::I32)),\n-            ConstInt::I64(_) => Some(IntType::SignedInt(IntTy::I64)),\n-            ConstInt::I128(_) => Some(IntType::SignedInt(IntTy::I128)),\n-            ConstInt::Isize(_) => Some(IntType::SignedInt(IntTy::Is)),\n-            ConstInt::U8(_) => Some(IntType::UnsignedInt(UintTy::U8)),\n-            ConstInt::U16(_) => Some(IntType::UnsignedInt(UintTy::U16)),\n-            ConstInt::U32(_) => Some(IntType::UnsignedInt(UintTy::U32)),\n-            ConstInt::U64(_) => Some(IntType::UnsignedInt(UintTy::U64)),\n-            ConstInt::U128(_) => Some(IntType::UnsignedInt(UintTy::U128)),\n-            ConstInt::Usize(_) => Some(IntType::UnsignedInt(UintTy::Us)),\n-            _ => None,\n+            ConstInt::I8(_) => IntType::SignedInt(IntTy::I8),\n+            ConstInt::I16(_) => IntType::SignedInt(IntTy::I16),\n+            ConstInt::I32(_) => IntType::SignedInt(IntTy::I32),\n+            ConstInt::I64(_) => IntType::SignedInt(IntTy::I64),\n+            ConstInt::I128(_) => IntType::SignedInt(IntTy::I128),\n+            ConstInt::Isize(_) => IntType::SignedInt(IntTy::Is),\n+            ConstInt::U8(_) => IntType::UnsignedInt(UintTy::U8),\n+            ConstInt::U16(_) => IntType::UnsignedInt(UintTy::U16),\n+            ConstInt::U32(_) => IntType::UnsignedInt(UintTy::U32),\n+            ConstInt::U64(_) => IntType::UnsignedInt(UintTy::U64),\n+            ConstInt::U128(_) => IntType::UnsignedInt(UintTy::U128),\n+            ConstInt::Usize(_) => IntType::UnsignedInt(UintTy::Us),\n         }\n     }\n }\n@@ -380,8 +348,6 @@ impl ::std::cmp::Ord for ConstInt {\n impl ::std::fmt::Display for ConstInt {\n     fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n         match *self {\n-            Infer(i) => write!(fmt, \"{}\", i),\n-            InferSigned(i) => write!(fmt, \"{}\", i),\n             I8(i) => write!(fmt, \"{}i8\", i),\n             I16(i) => write!(fmt, \"{}i16\", i),\n             I32(i) => write!(fmt, \"{}i32\", i),\n@@ -417,7 +383,7 @@ macro_rules! impl_binop {\n         impl ::std::ops::$op for ConstInt {\n             type Output = Result<Self, ConstMathErr>;\n             fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-                match self.infer(rhs)? {\n+                match (self, rhs) {\n                     (I8(a), I8(b)) => a.$checked_func(b).map(I8),\n                     (I16(a), I16(b)) => a.$checked_func(b).map(I16),\n                     (I32(a), I32(b)) => a.$checked_func(b).map(I32),\n@@ -434,8 +400,6 @@ macro_rules! impl_binop {\n                     (Usize(Us16(a)), Usize(Us16(b))) => a.$checked_func(b).map(Us16).map(Usize),\n                     (Usize(Us32(a)), Usize(Us32(b))) => a.$checked_func(b).map(Us32).map(Usize),\n                     (Usize(Us64(a)), Usize(Us64(b))) => a.$checked_func(b).map(Us64).map(Usize),\n-                    (Infer(a), Infer(b)) => a.$checked_func(b).map(Infer),\n-                    (InferSigned(a), InferSigned(b)) => a.$checked_func(b).map(InferSigned),\n                     _ => return Err(UnequalTypes(Op::$op)),\n                 }.ok_or(Overflow(Op::$op))\n             }\n@@ -448,7 +412,7 @@ macro_rules! derive_binop {\n         impl ::std::ops::$op for ConstInt {\n             type Output = Result<Self, ConstMathErr>;\n             fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-                match self.infer(rhs)? {\n+                match (self, rhs) {\n                     (I8(a), I8(b)) => Ok(I8(a.$func(b))),\n                     (I16(a), I16(b)) => Ok(I16(a.$func(b))),\n                     (I32(a), I32(b)) => Ok(I32(a.$func(b))),\n@@ -465,8 +429,6 @@ macro_rules! derive_binop {\n                     (Usize(Us16(a)), Usize(Us16(b))) => Ok(Usize(Us16(a.$func(b)))),\n                     (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a.$func(b)))),\n                     (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a.$func(b)))),\n-                    (Infer(a), Infer(b)) => Ok(Infer(a.$func(b))),\n-                    (InferSigned(a), InferSigned(b)) => Ok(InferSigned(a.$func(b))),\n                     _ => Err(UnequalTypes(Op::$op)),\n                 }\n             }\n@@ -498,7 +460,6 @@ fn check_division(\n         (Isize(_), Isize(Is16(0))) => Err(zerr),\n         (Isize(_), Isize(Is32(0))) => Err(zerr),\n         (Isize(_), Isize(Is64(0))) => Err(zerr),\n-        (InferSigned(_), InferSigned(0)) => Err(zerr),\n \n         (U8(_), U8(0)) => Err(zerr),\n         (U16(_), U16(0)) => Err(zerr),\n@@ -508,7 +469,6 @@ fn check_division(\n         (Usize(_), Usize(Us16(0))) => Err(zerr),\n         (Usize(_), Usize(Us32(0))) => Err(zerr),\n         (Usize(_), Usize(Us64(0))) => Err(zerr),\n-        (Infer(_), Infer(0)) => Err(zerr),\n \n         (I8(::std::i8::MIN), I8(-1)) => Err(Overflow(op)),\n         (I16(::std::i16::MIN), I16(-1)) => Err(Overflow(op)),\n@@ -518,7 +478,6 @@ fn check_division(\n         (Isize(Is16(::std::i16::MIN)), Isize(Is16(-1))) => Err(Overflow(op)),\n         (Isize(Is32(::std::i32::MIN)), Isize(Is32(-1))) => Err(Overflow(op)),\n         (Isize(Is64(::std::i64::MIN)), Isize(Is64(-1))) => Err(Overflow(op)),\n-        (InferSigned(I128_MIN), InferSigned(-1)) => Err(Overflow(op)),\n \n         _ => Ok(()),\n     }\n@@ -527,7 +486,7 @@ fn check_division(\n impl ::std::ops::Div for ConstInt {\n     type Output = Result<Self, ConstMathErr>;\n     fn div(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-        let (lhs, rhs) = self.infer(rhs)?;\n+        let (lhs, rhs) = (self, rhs);\n         check_division(lhs, rhs, Op::Div, DivisionByZero)?;\n         match (lhs, rhs) {\n             (I8(a), I8(b)) => Ok(I8(a/b)),\n@@ -538,7 +497,6 @@ impl ::std::ops::Div for ConstInt {\n             (Isize(Is16(a)), Isize(Is16(b))) => Ok(Isize(Is16(a/b))),\n             (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a/b))),\n             (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a/b))),\n-            (InferSigned(a), InferSigned(b)) => Ok(InferSigned(a/b)),\n \n             (U8(a), U8(b)) => Ok(U8(a/b)),\n             (U16(a), U16(b)) => Ok(U16(a/b)),\n@@ -548,7 +506,6 @@ impl ::std::ops::Div for ConstInt {\n             (Usize(Us16(a)), Usize(Us16(b))) => Ok(Usize(Us16(a/b))),\n             (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a/b))),\n             (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a/b))),\n-            (Infer(a), Infer(b)) => Ok(Infer(a/b)),\n \n             _ => Err(UnequalTypes(Op::Div)),\n         }\n@@ -558,7 +515,7 @@ impl ::std::ops::Div for ConstInt {\n impl ::std::ops::Rem for ConstInt {\n     type Output = Result<Self, ConstMathErr>;\n     fn rem(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-        let (lhs, rhs) = self.infer(rhs)?;\n+        let (lhs, rhs) = (self, rhs);\n         // should INT_MIN%-1 be zero or an error?\n         check_division(lhs, rhs, Op::Rem, RemainderByZero)?;\n         match (lhs, rhs) {\n@@ -570,7 +527,6 @@ impl ::std::ops::Rem for ConstInt {\n             (Isize(Is16(a)), Isize(Is16(b))) => Ok(Isize(Is16(a%b))),\n             (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a%b))),\n             (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a%b))),\n-            (InferSigned(a), InferSigned(b)) => Ok(InferSigned(a%b)),\n \n             (U8(a), U8(b)) => Ok(U8(a%b)),\n             (U16(a), U16(b)) => Ok(U16(a%b)),\n@@ -580,7 +536,6 @@ impl ::std::ops::Rem for ConstInt {\n             (Usize(Us16(a)), Usize(Us16(b))) => Ok(Usize(Us16(a%b))),\n             (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a%b))),\n             (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a%b))),\n-            (Infer(a), Infer(b)) => Ok(Infer(a%b)),\n \n             _ => Err(UnequalTypes(Op::Rem)),\n         }\n@@ -608,8 +563,6 @@ impl ::std::ops::Shl<ConstInt> for ConstInt {\n             Usize(Us16(a)) => Ok(Usize(Us16(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n             Usize(Us32(a)) => Ok(Usize(Us32(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n             Usize(Us64(a)) => Ok(Usize(Us64(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n-            Infer(a) => Ok(Infer(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            InferSigned(a) => Ok(InferSigned(overflowing!(a.overflowing_shl(b), Op::Shl))),\n         }\n     }\n }\n@@ -635,8 +588,6 @@ impl ::std::ops::Shr<ConstInt> for ConstInt {\n             Usize(Us16(a)) => Ok(Usize(Us16(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n             Usize(Us32(a)) => Ok(Usize(Us32(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n             Usize(Us64(a)) => Ok(Usize(Us64(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n-            Infer(a) => Ok(Infer(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            InferSigned(a) => Ok(InferSigned(overflowing!(a.overflowing_shr(b), Op::Shr))),\n         }\n     }\n }\n@@ -656,9 +607,6 @@ impl ::std::ops::Neg for ConstInt {\n             a@U8(0) | a@U16(0) | a@U32(0) | a@U64(0) | a@U128(0) |\n             a@Usize(Us16(0)) | a@Usize(Us32(0)) | a@Usize(Us64(0)) => Ok(a),\n             U8(_) | U16(_) | U32(_) | U64(_) | U128(_) | Usize(_) => Err(UnsignedNegation),\n-            Infer(a @ 0...ubounds::I128MAX) => Ok(InferSigned(-(a as i128))),\n-            Infer(_) => Err(Overflow(Op::Neg)),\n-            InferSigned(a) => Ok(InferSigned(overflowing!(a.overflowing_neg(), Op::Neg))),\n         }\n     }\n }\n@@ -683,8 +631,6 @@ impl ::std::ops::Not for ConstInt {\n             Usize(Us16(a)) => Ok(Usize(Us16(!a))),\n             Usize(Us32(a)) => Ok(Usize(Us32(!a))),\n             Usize(Us64(a)) => Ok(Usize(Us64(!a))),\n-            Infer(a) => Ok(Infer(!a)),\n-            InferSigned(a) => Ok(InferSigned(!a)),\n         }\n     }\n }"}, {"sha": "b7833a5440321221eb934a00ef08fd675550cfcc", "filename": "src/librustc_const_math/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_const_math%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_const_math%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Flib.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -21,7 +21,7 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-\n+#![deny(warnings)]\n \n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "ddf09f5cfe0e08dd5cb61d10e2af4bcf7d6391d7", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -21,14 +21,14 @@ use rustc::middle::{self, dependency_format, stability, reachable};\n use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt, Resolutions, GlobalArenas};\n use rustc::util::common::time;\n-use rustc::util::nodemap::{NodeSet, NodeMap};\n+use rustc::util::nodemap::NodeSet;\n use rustc::util::fs::rename_or_copy_remove;\n use rustc_borrowck as borrowck;\n use rustc_incremental::{self, IncrementalHashesMap};\n use rustc_incremental::ich::Fingerprint;\n use rustc_resolve::{MakeGlobMap, Resolver};\n use rustc_metadata::creader::CrateLoader;\n-use rustc_metadata::cstore::CStore;\n+use rustc_metadata::cstore::{self, CStore};\n use rustc_trans::back::{link, write};\n use rustc_trans as trans;\n use rustc_typeck as typeck;\n@@ -343,7 +343,7 @@ pub struct CompileState<'a, 'tcx: 'a> {\n     pub hir_crate: Option<&'a hir::Crate>,\n     pub hir_map: Option<&'a hir_map::Map<'tcx>>,\n     pub resolutions: Option<&'a Resolutions>,\n-    pub analysis: Option<&'a ty::CrateAnalysis<'tcx>>,\n+    pub analysis: Option<&'a ty::CrateAnalysis>,\n     pub tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n     pub trans: Option<&'a trans::CrateTranslation>,\n }\n@@ -417,7 +417,7 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n                                 arenas: &'tcx GlobalArenas<'tcx>,\n                                 cstore: &'a CStore,\n                                 hir_map: &'a hir_map::Map<'tcx>,\n-                                analysis: &'a ty::CrateAnalysis<'static>,\n+                                analysis: &'a ty::CrateAnalysis,\n                                 resolutions: &'a Resolutions,\n                                 krate: &'a ast::Crate,\n                                 hir_crate: &'a hir::Crate,\n@@ -444,7 +444,7 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n                             out_file: &'a Option<PathBuf>,\n                             krate: Option<&'a ast::Crate>,\n                             hir_crate: &'a hir::Crate,\n-                            analysis: &'a ty::CrateAnalysis<'tcx>,\n+                            analysis: &'a ty::CrateAnalysis,\n                             tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             crate_name: &'a str)\n                             -> Self {\n@@ -534,7 +534,7 @@ fn count_nodes(krate: &ast::Crate) -> usize {\n pub struct ExpansionResult {\n     pub expanded_crate: ast::Crate,\n     pub defs: hir_map::Definitions,\n-    pub analysis: ty::CrateAnalysis<'static>,\n+    pub analysis: ty::CrateAnalysis,\n     pub resolutions: Resolutions,\n     pub hir_forest: hir_map::Forest,\n }\n@@ -797,7 +797,6 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n             reachable: NodeSet(),\n             name: crate_name.to_string(),\n             glob_map: if resolver.make_glob_map { Some(resolver.glob_map) } else { None },\n-            hir_ty_to_ty: NodeMap(),\n         },\n         resolutions: Resolutions {\n             freevars: resolver.freevars,\n@@ -813,15 +812,15 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                hir_map: hir_map::Map<'tcx>,\n-                                               mut analysis: ty::CrateAnalysis<'tcx>,\n+                                               mut analysis: ty::CrateAnalysis,\n                                                resolutions: Resolutions,\n                                                arena: &'tcx DroplessArena,\n                                                arenas: &'tcx GlobalArenas<'tcx>,\n                                                name: &str,\n                                                f: F)\n                                                -> Result<R, usize>\n     where F: for<'a> FnOnce(TyCtxt<'a, 'tcx, 'tcx>,\n-                            ty::CrateAnalysis<'tcx>,\n+                            ty::CrateAnalysis,\n                             IncrementalHashesMap,\n                             CompileResult) -> R\n {\n@@ -872,7 +871,16 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let index = stability::Index::new(&hir_map);\n \n+    let mut local_providers = ty::maps::Providers::default();\n+    mir::provide(&mut local_providers);\n+    typeck::provide(&mut local_providers);\n+\n+    let mut extern_providers = ty::maps::Providers::default();\n+    cstore::provide(&mut extern_providers);\n+\n     TyCtxt::create_and_enter(sess,\n+                             local_providers,\n+                             extern_providers,\n                              arenas,\n                              arena,\n                              resolutions,\n@@ -900,8 +908,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              || stability::check_unstable_api_usage(tcx));\n \n         // passes are timed inside typeck\n-        analysis.hir_ty_to_ty =\n-            try_with_f!(typeck::check_crate(tcx), (tcx, analysis, incremental_hashes_map));\n+        try_with_f!(typeck::check_crate(tcx), (tcx, analysis, incremental_hashes_map));\n \n         time(time_passes,\n              \"const checking\",\n@@ -951,8 +958,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n             // in stage 4 below.\n             passes.push_hook(box mir::transform::dump_mir::DumpMir);\n             passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"initial\"));\n-            passes.push_pass(\n-                box mir::transform::qualify_consts::QualifyAndPromoteConstants::default());\n+            passes.push_pass(box mir::transform::qualify_consts::QualifyAndPromoteConstants);\n             passes.push_pass(box mir::transform::type_check::TypeckMir);\n             passes.push_pass(\n                 box mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));"}, {"sha": "064c4982ef00eb87adcbd828b18ac8701898e3e0", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -201,7 +201,7 @@ impl PpSourceMode {\n     fn call_with_pp_support_hir<'tcx, A, B, F>(&self,\n                                                sess: &'tcx Session,\n                                                hir_map: &hir_map::Map<'tcx>,\n-                                               analysis: &ty::CrateAnalysis<'tcx>,\n+                                               analysis: &ty::CrateAnalysis,\n                                                resolutions: &Resolutions,\n                                                arena: &'tcx DroplessArena,\n                                                arenas: &'tcx GlobalArenas<'tcx>,\n@@ -838,7 +838,7 @@ pub fn print_after_parsing(sess: &Session,\n \n pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                 hir_map: &hir_map::Map<'tcx>,\n-                                                analysis: &ty::CrateAnalysis<'tcx>,\n+                                                analysis: &ty::CrateAnalysis,\n                                                 resolutions: &Resolutions,\n                                                 input: &Input,\n                                                 krate: &ast::Crate,\n@@ -958,7 +958,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n // Instead, we call that function ourselves.\n fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                        hir_map: &hir_map::Map<'tcx>,\n-                                       analysis: &ty::CrateAnalysis<'tcx>,\n+                                       analysis: &ty::CrateAnalysis,\n                                        resolutions: &Resolutions,\n                                        crate_name: &str,\n                                        arena: &'tcx DroplessArena,\n@@ -996,11 +996,13 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                 } else {\n                     match ppm {\n                         PpmMir => {\n-                            write_mir_pretty(tcx, tcx.mir_map.borrow().keys().into_iter(), &mut out)\n+                            write_mir_pretty(tcx,\n+                                             tcx.maps.mir.borrow().keys().into_iter(),\n+                                             &mut out)\n                         }\n                         PpmMirCFG => {\n                             write_mir_graphviz(tcx,\n-                                               tcx.mir_map.borrow().keys().into_iter(),\n+                                               tcx.maps.mir.borrow().keys().into_iter(),\n                                                &mut out)\n                         }\n                         _ => unreachable!(),"}, {"sha": "9568cc3d6de0e35c8cc00fce917dc91b73e344c0", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -139,6 +139,8 @@ fn test_env<F>(source_string: &str,\n     let region_map = region::resolve_crate(&sess, &hir_map);\n     let index = stability::Index::new(&hir_map);\n     TyCtxt::create_and_enter(&sess,\n+                             ty::maps::Providers::default(),\n+                             ty::maps::Providers::default(),\n                              &arenas,\n                              &arena,\n                              resolutions,\n@@ -149,7 +151,7 @@ fn test_env<F>(source_string: &str,\n                              index,\n                              \"test_crate\",\n                              |tcx| {\n-        tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n+        tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n \n             body(Env { infcx: &infcx });\n             let free_regions = FreeRegionMap::new();\n@@ -268,11 +270,13 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn t_fn(&self, input_tys: &[Ty<'tcx>], output_ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.infcx.tcx.mk_fn_ptr(self.infcx.tcx.mk_bare_fn(ty::BareFnTy {\n-            unsafety: hir::Unsafety::Normal,\n-            abi: Abi::Rust,\n-            sig: ty::Binder(self.infcx.tcx.mk_fn_sig(input_tys.iter().cloned(), output_ty, false)),\n-        }))\n+        self.infcx.tcx.mk_fn_ptr(ty::Binder(self.infcx.tcx.mk_fn_sig(\n+            input_tys.iter().cloned(),\n+            output_ty,\n+            false,\n+            hir::Unsafety::Normal,\n+            Abi::Rust\n+        )))\n     }\n \n     pub fn t_nil(&self) -> Ty<'tcx> {"}, {"sha": "150a2c39db7a827e9796d5dca3edb992b88e39d5", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -1167,6 +1167,9 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n             trait_items: _,\n             impl_items: _,\n             bodies: _,\n+\n+            trait_impls: _,\n+            trait_default_impl: _,\n         } = *krate;\n \n         visit::Visitor::visit_mod(self, module, span, ast::CRATE_NODE_ID);"}, {"sha": "156f8b9e7c489a27750f346b7266b86898bc31e4", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -257,6 +257,12 @@ pub struct DirtyCleanMetadataVisitor<'a, 'tcx:'a, 'm> {\n impl<'a, 'tcx, 'm> ItemLikeVisitor<'tcx> for DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         self.check_item(item.id, item.span);\n+\n+        if let hir::ItemEnum(ref def, _) = item.node {\n+            for v in &def.variants {\n+                self.check_item(v.node.data.id(), v.span);\n+            }\n+        }\n     }\n \n     fn visit_trait_item(&mut self, item: &hir::TraitItem) {"}, {"sha": "353b86820c405e3811d9f438cc5a55cd797fdeea", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -29,7 +29,7 @@ pub enum MethodLateContext {\n \n pub fn method_context(cx: &LateContext, id: ast::NodeId, span: Span) -> MethodLateContext {\n     let def_id = cx.tcx.hir.local_def_id(id);\n-    match cx.tcx.associated_items.borrow().get(&def_id) {\n+    match cx.tcx.maps.associated_item.borrow().get(&def_id) {\n         None => span_bug!(span, \"missing method descriptor?!\"),\n         Some(item) => {\n             match item.container {"}, {"sha": "b3f09c28277ada98725c0c6729d148ee23499fdf", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -523,7 +523,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n             }\n             _ => return,\n         };\n-        if def.has_dtor() {\n+        if def.has_dtor(cx.tcx) {\n             return;\n         }\n         let parameter_environment = cx.tcx.empty_parameter_environment();\n@@ -882,7 +882,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                     let node_id = tcx.hir.as_local_node_id(method.def_id).unwrap();\n \n                     let param_env = ty::ParameterEnvironment::for_item(tcx, node_id);\n-                    tcx.infer_ctxt(param_env, Reveal::NotSpecializable).enter(|infcx| {\n+                    tcx.infer_ctxt(param_env, Reveal::UserFacing).enter(|infcx| {\n                         let mut selcx = traits::SelectionContext::new(&infcx);\n                         match selcx.select(&obligation) {\n                             // The method comes from a `T: Trait` bound.\n@@ -1082,9 +1082,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n                 }\n                 let typ = cx.tables.node_id_to_type(expr.id);\n                 match typ.sty {\n-                    ty::TyFnDef(.., ref bare_fn) if bare_fn.abi == RustIntrinsic => {\n-                        let from = bare_fn.sig.skip_binder().inputs()[0];\n-                        let to = bare_fn.sig.skip_binder().output();\n+                    ty::TyFnDef(.., bare_fn) if bare_fn.abi() == RustIntrinsic => {\n+                        let from = bare_fn.inputs().skip_binder()[0];\n+                        let to = *bare_fn.output().skip_binder();\n                         return Some((&from.sty, &to.sty));\n                     }\n                     _ => (),\n@@ -1095,7 +1095,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n \n         fn def_id_is_transmute(cx: &LateContext, def_id: DefId) -> bool {\n             match cx.tcx.item_type(def_id).sty {\n-                ty::TyFnDef(.., ref bfty) if bfty.abi == RustIntrinsic => (),\n+                ty::TyFnDef(.., bfty) if bfty.abi() == RustIntrinsic => (),\n                 _ => return false,\n             }\n             cx.tcx.item_name(def_id) == \"transmute\""}, {"sha": "529afe0215e53672eebee1ea1538e3c9c87719ae", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -17,7 +17,6 @@ use rustc::ty::layout::{Layout, Primitive};\n use rustc::traits::Reveal;\n use middle::const_val::ConstVal;\n use rustc_const_eval::ConstContext;\n-use rustc_const_eval::EvalHint::ExprTypeChecked;\n use util::nodemap::FxHashSet;\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass};\n@@ -109,7 +108,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                             }\n                         } else {\n                             let const_cx = ConstContext::with_tables(cx.tcx, cx.tables);\n-                            match const_cx.eval(&r, ExprTypeChecked) {\n+                            match const_cx.eval(&r) {\n                                 Ok(ConstVal::Integral(i)) => {\n                                     i.is_negative() ||\n                                     i.to_u64()\n@@ -381,6 +380,17 @@ fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     false\n }\n \n+fn is_ffi_safe(ty: attr::IntType) -> bool {\n+    match ty {\n+        attr::SignedInt(ast::IntTy::I8) | attr::UnsignedInt(ast::UintTy::U8) |\n+        attr::SignedInt(ast::IntTy::I16) | attr::UnsignedInt(ast::UintTy::U16) |\n+        attr::SignedInt(ast::IntTy::I32) | attr::UnsignedInt(ast::UintTy::U32) |\n+        attr::SignedInt(ast::IntTy::I64) | attr::UnsignedInt(ast::UintTy::U64) |\n+        attr::SignedInt(ast::IntTy::I128) | attr::UnsignedInt(ast::UintTy::U128) => true,\n+        attr::SignedInt(ast::IntTy::Is) | attr::UnsignedInt(ast::UintTy::Us) => false\n+    }\n+}\n+\n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     /// Check if the given type is \"ffi-safe\" (has a stable, well-defined\n     /// representation which can be exported to C code).\n@@ -406,7 +416,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 }\n                 match def.adt_kind() {\n                     AdtKind::Struct => {\n-                        if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n+                        if !def.repr.c {\n                             return FfiUnsafe(\"found struct without foreign-function-safe \\\n                                               representation annotation in foreign module, \\\n                                               consider adding a #[repr(C)] attribute to the type\");\n@@ -440,7 +450,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         if all_phantom { FfiPhantom } else { FfiSafe }\n                     }\n                     AdtKind::Union => {\n-                        if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n+                        if !def.repr.c {\n                             return FfiUnsafe(\"found union without foreign-function-safe \\\n                                               representation annotation in foreign module, \\\n                                               consider adding a #[repr(C)] attribute to the type\");\n@@ -479,35 +489,28 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n                         // Check for a repr() attribute to specify the size of the\n                         // discriminant.\n-                        let repr_hints = cx.lookup_repr_hints(def.did);\n-                        match &repr_hints[..] {\n-                            &[] => {\n-                                // Special-case types like `Option<extern fn()>`.\n-                                if !is_repr_nullable_ptr(cx, def, substs) {\n-                                    return FfiUnsafe(\"found enum without foreign-function-safe \\\n-                                                      representation annotation in foreign \\\n-                                                      module, consider adding a #[repr(...)] \\\n-                                                      attribute to the type\");\n-                                }\n+                        if !def.repr.c && def.repr.int.is_none() {\n+                            // Special-case types like `Option<extern fn()>`.\n+                            if !is_repr_nullable_ptr(cx, def, substs) {\n+                                return FfiUnsafe(\"found enum without foreign-function-safe \\\n+                                                  representation annotation in foreign \\\n+                                                  module, consider adding a #[repr(...)] \\\n+                                                  attribute to the type\");\n                             }\n-                            &[ref hint] => {\n-                                if !hint.is_ffi_safe() {\n-                                    // FIXME: This shouldn't be reachable: we should check\n-                                    // this earlier.\n-                                    return FfiUnsafe(\"enum has unexpected #[repr(...)] attribute\");\n-                                }\n-\n-                                // Enum with an explicitly sized discriminant; either\n-                                // a C-style enum or a discriminated union.\n+                        }\n \n-                                // The layout of enum variants is implicitly repr(C).\n-                                // FIXME: Is that correct?\n-                            }\n-                            _ => {\n+                        if let Some(int_ty) = def.repr.int {\n+                            if !is_ffi_safe(int_ty) {\n                                 // FIXME: This shouldn't be reachable: we should check\n                                 // this earlier.\n-                                return FfiUnsafe(\"enum has too many #[repr(...)] attributes\");\n+                                return FfiUnsafe(\"enum has unexpected #[repr(...)] attribute\");\n                             }\n+\n+                            // Enum with an explicitly sized discriminant; either\n+                            // a C-style enum or a discriminated union.\n+\n+                            // The layout of enum variants is implicitly repr(C).\n+                            // FIXME: Is that correct?\n                         }\n \n                         // Check the contained variants.\n@@ -568,8 +571,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             ty::TyArray(ty, _) => self.check_type_for_ffi(cache, ty),\n \n-            ty::TyFnPtr(bare_fn) => {\n-                match bare_fn.abi {\n+            ty::TyFnPtr(sig) => {\n+                match sig.abi() {\n                     Abi::Rust | Abi::RustIntrinsic | Abi::PlatformIntrinsic | Abi::RustCall => {\n                         return FfiUnsafe(\"found function pointer with Rust calling convention in \\\n                                           foreign module; consider using an `extern` function \\\n@@ -578,7 +581,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     _ => {}\n                 }\n \n-                let sig = cx.erase_late_bound_regions(&bare_fn.sig);\n+                let sig = cx.erase_late_bound_regions(&sig);\n                 if !sig.output().is_nil() {\n                     let r = self.check_type_for_ffi(cache, sig.output());\n                     match r {"}, {"sha": "bb30245df5f56315a1069c07c9da2d607626795c", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -35,6 +35,8 @@ pub use rustc::middle::cstore::{NativeLibrary, NativeLibraryKind, LinkagePrefere\n pub use rustc::middle::cstore::NativeLibraryKind::*;\n pub use rustc::middle::cstore::{CrateSource, LinkMeta, LibSource};\n \n+pub use cstore_impl::provide;\n+\n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external\n // crate may refer to types in other external crates, and each has their"}, {"sha": "7b02280ef904bda504369b93dd1bb07a42428fa4", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 87, "deletions": 114, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -13,21 +13,25 @@ use encoder;\n use locator;\n use schema;\n \n+use rustc::dep_graph::DepTrackingMapConfig;\n use rustc::middle::cstore::{CrateStore, CrateSource, LibSource, DepKind, ExternCrate};\n use rustc::middle::cstore::{NativeLibrary, LinkMeta, LinkagePreference, LoadedMacro};\n use rustc::hir::def::{self, Def};\n use rustc::middle::lang_items;\n-use rustc::middle::resolve_lifetime::ObjectLifetimeDefault;\n use rustc::session::Session;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, TyCtxt};\n+use rustc::ty::maps::Providers;\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n \n use rustc::dep_graph::DepNode;\n use rustc::hir::map::{DefKey, DefPath, DisambiguatedDefPathData};\n-use rustc::mir::Mir;\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n use rustc_back::PanicStrategy;\n \n+use std::any::Any;\n+use std::mem;\n+use std::rc::Rc;\n+\n use syntax::ast;\n use syntax::attr;\n use syntax::parse::filemap_to_tts;\n@@ -39,87 +43,103 @@ use rustc::hir;\n \n use std::collections::BTreeMap;\n \n-impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n-    fn describe_def(&self, def: DefId) -> Option<Def> {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_def(def.index)\n-    }\n-\n-    fn def_span(&self, sess: &Session, def: DefId) -> Span {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_span(def.index, sess)\n-    }\n-\n-    fn stability(&self, def: DefId) -> Option<attr::Stability> {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_stability(def.index)\n+macro_rules! provide {\n+    (<$lt:tt> $tcx:ident, $def_id:ident, $cdata:ident $($name:ident => $compute:block)*) => {\n+        pub fn provide<$lt>(providers: &mut Providers<$lt>) {\n+            $(fn $name<'a, $lt:$lt>($tcx: TyCtxt<'a, $lt, $lt>, $def_id: DefId)\n+                                    -> <ty::queries::$name<$lt> as\n+                                        DepTrackingMapConfig>::Value {\n+                assert!(!$def_id.is_local());\n+\n+                $tcx.dep_graph.read(DepNode::MetaData($def_id));\n+\n+                let $cdata = $tcx.sess.cstore.crate_data_as_rc_any($def_id.krate);\n+                let $cdata = $cdata.downcast_ref::<cstore::CrateMetadata>()\n+                    .expect(\"CrateStore crated ata is not a CrateMetadata\");\n+                $compute\n+            })*\n+\n+            *providers = Providers {\n+                $($name,)*\n+                ..*providers\n+            };\n+        }\n     }\n+}\n \n-    fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_deprecation(def.index)\n+provide! { <'tcx> tcx, def_id, cdata\n+    ty => { cdata.get_type(def_id.index, tcx) }\n+    generics => { tcx.alloc_generics(cdata.get_generics(def_id.index)) }\n+    predicates => { cdata.get_predicates(def_id.index, tcx) }\n+    super_predicates => { cdata.get_super_predicates(def_id.index, tcx) }\n+    trait_def => {\n+        tcx.alloc_trait_def(cdata.get_trait_def(def_id.index, tcx))\n+    }\n+    adt_def => { cdata.get_adt_def(def_id.index, tcx) }\n+    variances => { Rc::new(cdata.get_item_variances(def_id.index)) }\n+    associated_item_def_ids => {\n+        let mut result = vec![];\n+        cdata.each_child_of_item(def_id.index, |child| result.push(child.def.def_id()));\n+        Rc::new(result)\n+    }\n+    associated_item => { cdata.get_associated_item(def_id.index) }\n+    impl_trait_ref => { cdata.get_impl_trait(def_id.index, tcx) }\n+    custom_coerce_unsized_kind => {\n+        cdata.get_custom_coerce_unsized_kind(def_id.index).unwrap_or_else(|| {\n+            bug!(\"custom_coerce_unsized_kind: `{:?}` is missing its kind\", def_id);\n+        })\n     }\n+    mir => {\n+        let mir = cdata.maybe_get_item_mir(tcx, def_id.index).unwrap_or_else(|| {\n+            bug!(\"get_item_mir: missing MIR for `{:?}`\", def_id)\n+        });\n \n-    fn visibility(&self, def: DefId) -> ty::Visibility {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_visibility(def.index)\n-    }\n+        let mir = tcx.alloc_mir(mir);\n \n-    fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind\n-    {\n-        assert!(!def_id.is_local());\n-        self.dep_graph.read(DepNode::MetaData(def_id));\n-        self.get_crate_data(def_id.krate).closure_kind(def_id.index)\n-    }\n+        // Perma-borrow MIR from extern crates to prevent mutation.\n+        mem::forget(mir.borrow());\n \n-    fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::ClosureTy<'tcx> {\n-        assert!(!def_id.is_local());\n-        self.dep_graph.read(DepNode::MetaData(def_id));\n-        self.get_crate_data(def_id.krate).closure_ty(def_id.index, tcx)\n+        mir\n     }\n+    mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n+    typeck_tables => { cdata.item_body_tables(def_id.index, tcx) }\n+    closure_kind => { cdata.closure_kind(def_id.index) }\n+    closure_type => { cdata.closure_ty(def_id.index, tcx) }\n+}\n \n-    fn item_variances(&self, def: DefId) -> Vec<ty::Variance> {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_item_variances(def.index)\n+impl CrateStore for cstore::CStore {\n+    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Rc<Any> {\n+        self.get_crate_data(krate)\n     }\n \n-    fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                     -> Ty<'tcx>\n-    {\n+    fn describe_def(&self, def: DefId) -> Option<Def> {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_type(def.index, tcx)\n+        self.get_crate_data(def.krate).get_def(def.index)\n     }\n \n-    fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                           -> ty::GenericPredicates<'tcx>\n-    {\n+    fn def_span(&self, sess: &Session, def: DefId) -> Span {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_predicates(def.index, tcx)\n+        self.get_crate_data(def.krate).get_span(def.index, sess)\n     }\n \n-    fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                 -> ty::GenericPredicates<'tcx>\n-    {\n+    fn stability(&self, def: DefId) -> Option<attr::Stability> {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_super_predicates(def.index, tcx)\n+        self.get_crate_data(def.krate).get_stability(def.index)\n     }\n \n-    fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                         -> ty::Generics<'tcx>\n-    {\n+    fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_generics(def.index, tcx)\n+        self.get_crate_data(def.krate).get_deprecation(def.index)\n     }\n \n-    fn item_generics_own_param_counts(&self, def: DefId) -> (usize, usize) {\n+    fn visibility(&self, def: DefId) -> ty::Visibility {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).generics_own_param_counts(def.index)\n+        self.get_crate_data(def.krate).get_visibility(def.index)\n     }\n \n-    fn item_generics_object_lifetime_defaults(&self, def: DefId)\n-                                              -> Vec<ObjectLifetimeDefault> {\n+    fn item_generics_cloned(&self, def: DefId) -> ty::Generics {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).generics_object_lifetime_defaults(def.index)\n+        self.get_crate_data(def.krate).get_generics(def.index)\n     }\n \n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>\n@@ -128,18 +148,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def_id.krate).get_item_attrs(def_id.index)\n     }\n \n-    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::TraitDef\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_trait_def(def.index, tcx)\n-    }\n-\n-    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> &'tcx ty::AdtDef\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_adt_def(def.index, tcx)\n-    }\n-\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>\n     {\n         // FIXME(#38501) We've skipped a `read` on the `HirBody` of\n@@ -168,34 +176,12 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n-    fn associated_item_def_ids(&self, def_id: DefId) -> Vec<DefId> {\n-        self.dep_graph.read(DepNode::MetaData(def_id));\n-        let mut result = vec![];\n-        self.get_crate_data(def_id.krate)\n-            .each_child_of_item(def_id.index, |child| result.push(child.def.def_id()));\n-        result\n-    }\n-\n     fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).get_impl_polarity(def.index)\n     }\n \n-    fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                          -> Option<ty::TraitRef<'tcx>>\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_impl_trait(def.index, tcx)\n-    }\n-\n-    fn custom_coerce_unsized_kind(&self, def: DefId)\n-                                  -> Option<ty::adjustment::CustomCoerceUnsized>\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_custom_coerce_unsized_kind(def.index)\n-    }\n-\n     fn impl_parent(&self, impl_def: DefId) -> Option<DefId> {\n         self.dep_graph.read(DepNode::MetaData(impl_def));\n         self.get_crate_data(impl_def.krate).get_parent_impl(impl_def.index)\n@@ -206,7 +192,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def_id.krate).get_trait_of_item(def_id.index)\n     }\n \n-    fn associated_item(&self, def: DefId) -> Option<ty::AssociatedItem>\n+    fn associated_item_cloned(&self, def: DefId) -> ty::AssociatedItem\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).get_associated_item(def.index)\n@@ -218,12 +204,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(did.krate).is_const_fn(did.index)\n     }\n \n-    fn is_defaulted_trait(&self, trait_def_id: DefId) -> bool\n-    {\n-        self.dep_graph.read(DepNode::MetaData(trait_def_id));\n-        self.get_crate_data(trait_def_id.krate).is_defaulted_trait(trait_def_id.index)\n-    }\n-\n     fn is_default_impl(&self, impl_did: DefId) -> bool {\n         self.dep_graph.read(DepNode::MetaData(impl_did));\n         self.get_crate_data(impl_did.krate).is_default_impl(impl_did.index)\n@@ -439,10 +419,10 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         })\n     }\n \n-    fn maybe_get_item_body<'a>(&'tcx self,\n-                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               def_id: DefId)\n-                               -> Option<&'tcx hir::Body>\n+    fn maybe_get_item_body<'a, 'tcx>(&self,\n+                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     def_id: DefId)\n+                                     -> Option<&'tcx hir::Body>\n     {\n         if let Some(cached) = tcx.hir.get_inlined_body(def_id) {\n             return Some(cached);\n@@ -464,13 +444,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def.krate).const_is_rvalue_promotable_to_static(def.index)\n     }\n \n-    fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> Mir<'tcx> {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).maybe_get_item_mir(tcx, def.index).unwrap_or_else(|| {\n-            bug!(\"get_item_mir: missing MIR for {}\", tcx.item_path_str(def))\n-        })\n-    }\n-\n     fn is_item_mir_available(&self, def: DefId) -> bool {\n         self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).is_item_mir_available(def.index)\n@@ -518,10 +491,10 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.do_extern_mod_stmt_cnum(emod_id)\n     }\n \n-    fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           reexports: &def::ExportMap,\n-                           link_meta: &LinkMeta,\n-                           reachable: &NodeSet) -> Vec<u8>\n+    fn encode_metadata<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 reexports: &def::ExportMap,\n+                                 link_meta: &LinkMeta,\n+                                 reachable: &NodeSet) -> Vec<u8>\n     {\n         encoder::encode_metadata(tcx, self, reexports, link_meta, reachable)\n     }"}, {"sha": "b4b9966cbe47b98138d8ad1afe0e3b047d5537a6", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 73, "deletions": 101, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -20,7 +20,6 @@ use rustc::middle::cstore::LinkagePreference;\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::middle::lang_items;\n-use rustc::middle::resolve_lifetime::ObjectLifetimeDefault;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n@@ -364,12 +363,6 @@ impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Slice<Ty<'tcx>>> for DecodeContext<'\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::BareFnTy<'tcx>> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<&'tcx ty::BareFnTy<'tcx>, Self::Error> {\n-        Ok(self.tcx().mk_bare_fn(Decodable::decode(self)?))\n-    }\n-}\n-\n impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::AdtDef> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<&'tcx ty::AdtDef, Self::Error> {\n         let def_id = DefId::decode(self)?;\n@@ -418,8 +411,8 @@ impl<'a, 'tcx> MetadataBlob {\n impl<'tcx> EntryKind<'tcx> {\n     fn to_def(&self, did: DefId) -> Option<Def> {\n         Some(match *self {\n-            EntryKind::Const => Def::Const(did),\n-            EntryKind::AssociatedConst(_) => Def::AssociatedConst(did),\n+            EntryKind::Const(_) => Def::Const(did),\n+            EntryKind::AssociatedConst(..) => Def::AssociatedConst(did),\n             EntryKind::ImmStatic |\n             EntryKind::ForeignImmStatic => Def::Static(did, false),\n             EntryKind::MutStatic |\n@@ -508,15 +501,22 @@ impl<'a, 'tcx> CrateMetadata {\n             _ => bug!(),\n         };\n \n-        ty::TraitDef::new(self.local_def_id(item_id),\n-                          data.unsafety,\n-                          data.paren_sugar,\n-                          self.def_path(item_id).deterministic_hash(tcx))\n+        let def = ty::TraitDef::new(self.local_def_id(item_id),\n+                                    data.unsafety,\n+                                    data.paren_sugar,\n+                                    self.def_path(item_id).deterministic_hash(tcx));\n+\n+        if data.has_default_impl {\n+            def.record_has_default_impl();\n+        }\n+\n+        def\n     }\n \n     fn get_variant(&self,\n                    item: &Entry<'tcx>,\n-                   index: DefIndex)\n+                   index: DefIndex,\n+                   tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                    -> (ty::VariantDef, Option<DefIndex>) {\n         let data = match item.kind {\n             EntryKind::Variant(data) |\n@@ -525,6 +525,11 @@ impl<'a, 'tcx> CrateMetadata {\n             _ => bug!(),\n         };\n \n+        if let ty::VariantDiscr::Explicit(def_id) = data.discr {\n+            let result = data.evaluated_discr.map_or(Err(()), Ok);\n+            tcx.maps.monomorphic_const_eval.borrow_mut().insert(def_id, result);\n+        }\n+\n         (ty::VariantDef {\n             did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n             name: self.item_name(index),\n@@ -536,7 +541,7 @@ impl<'a, 'tcx> CrateMetadata {\n                     vis: f.visibility.decode(self)\n                 }\n             }).collect(),\n-            disr_val: data.disr,\n+            discr: data.discr,\n             ctor_kind: data.ctor_kind,\n         }, data.struct_ctor)\n     }\n@@ -547,38 +552,39 @@ impl<'a, 'tcx> CrateMetadata {\n                        -> &'tcx ty::AdtDef {\n         let item = self.entry(item_id);\n         let did = self.local_def_id(item_id);\n-        let (kind, ty) = match item.kind {\n-            EntryKind::Enum(dt, _) => (ty::AdtKind::Enum, Some(dt.decode(self))),\n-            EntryKind::Struct(_, _) => (ty::AdtKind::Struct, None),\n-            EntryKind::Union(_, _) => (ty::AdtKind::Union, None),\n+        let kind = match item.kind {\n+            EntryKind::Enum(_) => ty::AdtKind::Enum,\n+            EntryKind::Struct(_, _) => ty::AdtKind::Struct,\n+            EntryKind::Union(_, _) => ty::AdtKind::Union,\n             _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n         };\n         let mut ctor_index = None;\n         let variants = if let ty::AdtKind::Enum = kind {\n             item.children\n                 .decode(self)\n                 .map(|index| {\n-                    let (variant, struct_ctor) = self.get_variant(&self.entry(index), index);\n+                    let (variant, struct_ctor) =\n+                        self.get_variant(&self.entry(index), index, tcx);\n                     assert_eq!(struct_ctor, None);\n                     variant\n                 })\n                 .collect()\n         } else {\n-            let (variant, struct_ctor) = self.get_variant(&item, item_id);\n+            let (variant, struct_ctor) = self.get_variant(&item, item_id, tcx);\n             ctor_index = struct_ctor;\n             vec![variant]\n         };\n         let (kind, repr) = match item.kind {\n-            EntryKind::Enum(_, repr) => (ty::AdtKind::Enum, repr),\n+            EntryKind::Enum(repr) => (ty::AdtKind::Enum, repr),\n             EntryKind::Struct(_, repr) => (ty::AdtKind::Struct, repr),\n             EntryKind::Union(_, repr) => (ty::AdtKind::Union, repr),\n             _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n         };\n \n-        let adt = tcx.alloc_adt_def(did, kind, ty, variants, repr);\n+        let adt = tcx.alloc_adt_def(did, kind, variants, repr);\n         if let Some(ctor_index) = ctor_index {\n             // Make adt definition available through constructor id as well.\n-            tcx.adt_defs.borrow_mut().insert(self.local_def_id(ctor_index), adt);\n+            tcx.maps.adt_def.borrow_mut().insert(self.local_def_id(ctor_index), adt);\n         }\n \n         adt\n@@ -601,30 +607,8 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_generics(&self,\n-                        item_id: DefIndex,\n-                        tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                        -> ty::Generics<'tcx> {\n-        let g = self.entry(item_id).generics.unwrap().decode(self);\n-        ty::Generics {\n-            parent: g.parent,\n-            parent_regions: g.parent_regions,\n-            parent_types: g.parent_types,\n-            regions: g.regions.decode((self, tcx)).collect(),\n-            types: g.types.decode((self, tcx)).collect(),\n-            has_self: g.has_self,\n-        }\n-    }\n-\n-    pub fn generics_own_param_counts(&self, item_id: DefIndex) -> (usize, usize) {\n-        let g = self.entry(item_id).generics.unwrap().decode(self);\n-        (g.regions.len, g.types.len)\n-    }\n-\n-    pub fn generics_object_lifetime_defaults(&self, item_id: DefIndex)\n-                                             -> Vec<ObjectLifetimeDefault> {\n+    pub fn get_generics(&self, item_id: DefIndex) -> ty::Generics {\n         self.entry(item_id).generics.unwrap().decode(self)\n-                           .object_lifetime_defaults.decode(self).collect()\n     }\n \n     pub fn get_type(&self, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n@@ -802,16 +786,19 @@ impl<'a, 'tcx> CrateMetadata {\n         if self.is_proc_macro(id) { return None; }\n         self.entry(id).ast.map(|ast| {\n             let def_id = self.local_def_id(id);\n-            let ast = ast.decode(self);\n-\n-            let tables = ast.tables.decode((self, tcx));\n-            tcx.tables.borrow_mut().insert(def_id, tcx.alloc_tables(tables));\n-\n-            let body = ast.body.decode((self, tcx));\n+            let body = ast.decode(self).body.decode(self);\n             tcx.hir.intern_inlined_body(def_id, body)\n         })\n     }\n \n+    pub fn item_body_tables(&self,\n+                            id: DefIndex,\n+                            tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                            -> &'tcx ty::TypeckTables<'tcx> {\n+        let ast = self.entry(id).ast.unwrap().decode(self);\n+        tcx.alloc_tables(ast.tables.decode((self, tcx)))\n+    }\n+\n     pub fn item_body_nested_bodies(&self, id: DefIndex) -> BTreeMap<hir::BodyId, hir::Body> {\n         self.entry(id).ast.into_iter().flat_map(|ast| {\n             ast.decode(self).nested_bodies.decode(self).map(|body| (body.id(), body))\n@@ -838,54 +825,46 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_associated_item(&self, id: DefIndex) -> Option<ty::AssociatedItem> {\n+    pub fn mir_const_qualif(&self, id: DefIndex) -> u8 {\n+        match self.entry(id).kind {\n+            EntryKind::Const(qualif) |\n+            EntryKind::AssociatedConst(AssociatedContainer::ImplDefault, qualif) |\n+            EntryKind::AssociatedConst(AssociatedContainer::ImplFinal, qualif) => {\n+                qualif\n+            }\n+            _ => bug!(),\n+        }\n+    }\n+\n+    pub fn get_associated_item(&self, id: DefIndex) -> ty::AssociatedItem {\n         let item = self.entry(id);\n-        let parent_and_name = || {\n-            let def_key = self.def_key(id);\n-            (self.local_def_id(def_key.parent.unwrap()),\n-             def_key.disambiguated_data.data.get_opt_name().unwrap())\n-        };\n+        let def_key = self.def_key(id);\n+        let parent = self.local_def_id(def_key.parent.unwrap());\n+        let name = def_key.disambiguated_data.data.get_opt_name().unwrap();\n \n-        Some(match item.kind {\n-            EntryKind::AssociatedConst(container) => {\n-                let (parent, name) = parent_and_name();\n-                ty::AssociatedItem {\n-                    name: name,\n-                    kind: ty::AssociatedKind::Const,\n-                    vis: item.visibility.decode(self),\n-                    defaultness: container.defaultness(),\n-                    def_id: self.local_def_id(id),\n-                    container: container.with_def_id(parent),\n-                    method_has_self_argument: false\n-                }\n+        let (kind, container, has_self) = match item.kind {\n+            EntryKind::AssociatedConst(container, _) => {\n+                (ty::AssociatedKind::Const, container, false)\n             }\n             EntryKind::Method(data) => {\n-                let (parent, name) = parent_and_name();\n                 let data = data.decode(self);\n-                ty::AssociatedItem {\n-                    name: name,\n-                    kind: ty::AssociatedKind::Method,\n-                    vis: item.visibility.decode(self),\n-                    defaultness: data.container.defaultness(),\n-                    def_id: self.local_def_id(id),\n-                    container: data.container.with_def_id(parent),\n-                    method_has_self_argument: data.has_self\n-                }\n+                (ty::AssociatedKind::Method, data.container, data.has_self)\n             }\n             EntryKind::AssociatedType(container) => {\n-                let (parent, name) = parent_and_name();\n-                ty::AssociatedItem {\n-                    name: name,\n-                    kind: ty::AssociatedKind::Type,\n-                    vis: item.visibility.decode(self),\n-                    defaultness: container.defaultness(),\n-                    def_id: self.local_def_id(id),\n-                    container: container.with_def_id(parent),\n-                    method_has_self_argument: false\n-                }\n+                (ty::AssociatedKind::Type, container, false)\n             }\n-            _ => return None,\n-        })\n+            _ => bug!()\n+        };\n+\n+        ty::AssociatedItem {\n+            name: name,\n+            kind: kind,\n+            vis: item.visibility.decode(self),\n+            defaultness: container.defaultness(),\n+            def_id: self.local_def_id(id),\n+            container: container.with_def_id(parent),\n+            method_has_self_argument: has_self\n+        }\n     }\n \n     pub fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {\n@@ -1065,13 +1044,6 @@ impl<'a, 'tcx> CrateMetadata {\n         self.dllimport_foreign_items.contains(&id)\n     }\n \n-    pub fn is_defaulted_trait(&self, trait_id: DefIndex) -> bool {\n-        match self.entry(trait_id).kind {\n-            EntryKind::Trait(data) => data.decode(self).has_default_impl,\n-            _ => bug!(),\n-        }\n-    }\n-\n     pub fn is_default_impl(&self, impl_id: DefIndex) -> bool {\n         match self.entry(impl_id).kind {\n             EntryKind::DefaultImpl(_) => true,\n@@ -1089,7 +1061,7 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn closure_ty(&self,\n                       closure_id: DefIndex,\n                       tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                      -> ty::ClosureTy<'tcx> {\n+                      -> ty::PolyFnSig<'tcx> {\n         match self.entry(closure_id).kind {\n             EntryKind::Closure(data) => data.decode(self).ty.decode((self, tcx)),\n             _ => bug!(),"}, {"sha": "af0edab7a83bd9eee79893a85d7b8c3d40b9189b", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 71, "deletions": 33, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -36,7 +36,7 @@ use syntax::ast::{self, CRATE_NODE_ID};\n use syntax::codemap::Spanned;\n use syntax::attr;\n use syntax::symbol::Symbol;\n-use syntax_pos;\n+use syntax_pos::{self, DUMMY_SP};\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -261,7 +261,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n-            disr: variant.disr_val,\n+            discr: variant.discr,\n+            evaluated_discr: match variant.discr {\n+                ty::VariantDiscr::Explicit(def_id) => {\n+                    ty::queries::monomorphic_const_eval::get(tcx, DUMMY_SP, def_id).ok()\n+                }\n+                ty::VariantDiscr::Relative(_) => None\n+            },\n             struct_ctor: None,\n         };\n \n@@ -388,7 +394,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n-            disr: variant.disr_val,\n+            discr: variant.discr,\n+            evaluated_discr: None,\n             struct_ctor: Some(def_id.index),\n         };\n \n@@ -423,26 +430,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_generics(&mut self, def_id: DefId) -> Lazy<Generics<'tcx>> {\n+    fn encode_generics(&mut self, def_id: DefId) -> Lazy<ty::Generics> {\n         let tcx = self.tcx;\n-        let g = tcx.item_generics(def_id);\n-        let regions = self.lazy_seq_ref(&g.regions);\n-        let types = self.lazy_seq_ref(&g.types);\n-        let mut object_lifetime_defaults = LazySeq::empty();\n-        if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n-            if let Some(o) = tcx.named_region_map.object_lifetime_defaults.get(&id) {\n-                object_lifetime_defaults = self.lazy_seq_ref(o);\n-            }\n-        }\n-        self.lazy(&Generics {\n-            parent: g.parent,\n-            parent_regions: g.parent_regions,\n-            parent_types: g.parent_types,\n-            regions: regions,\n-            types: types,\n-            has_self: g.has_self,\n-            object_lifetime_defaults: object_lifetime_defaults,\n-        })\n+        self.lazy(tcx.item_generics(def_id))\n     }\n \n     fn encode_predicates(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n@@ -467,7 +457,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         };\n \n         let kind = match trait_item.kind {\n-            ty::AssociatedKind::Const => EntryKind::AssociatedConst(container),\n+            ty::AssociatedKind::Const => {\n+                EntryKind::AssociatedConst(container, 0)\n+            }\n             ty::AssociatedKind::Method => {\n                 let fn_data = if let hir::TraitItemKind::Method(_, ref m) = ast_item.node {\n                     let arg_names = match *m {\n@@ -543,7 +535,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         };\n \n         let kind = match impl_item.kind {\n-            ty::AssociatedKind::Const => EntryKind::AssociatedConst(container),\n+            ty::AssociatedKind::Const => {\n+                EntryKind::AssociatedConst(container,\n+                    ty::queries::mir_const_qualif::get(self.tcx, ast_item.span, def_id))\n+            }\n             ty::AssociatedKind::Method => {\n                 let fn_data = if let hir::ImplItemKind::Method(ref sig, body) = ast_item.node {\n                     FnData {\n@@ -614,12 +609,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::Mir<'tcx>>> {\n-        self.tcx.mir_map.borrow().get(&def_id).map(|mir| self.lazy(&*mir.borrow()))\n+        self.tcx.maps.mir.borrow().get(&def_id).map(|mir| self.lazy(&*mir.borrow()))\n     }\n \n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n     fn encode_inherent_implementations(&mut self, def_id: DefId) -> LazySeq<DefIndex> {\n-        match self.tcx.inherent_impls.borrow().get(&def_id) {\n+        match self.tcx.maps.inherent_impls.borrow().get(&def_id) {\n             None => LazySeq::empty(),\n             Some(implementations) => {\n                 self.lazy_seq(implementations.iter().map(|&def_id| {\n@@ -647,7 +642,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let kind = match item.node {\n             hir::ItemStatic(_, hir::MutMutable, _) => EntryKind::MutStatic,\n             hir::ItemStatic(_, hir::MutImmutable, _) => EntryKind::ImmStatic,\n-            hir::ItemConst(..) => EntryKind::Const,\n+            hir::ItemConst(..) => {\n+                EntryKind::Const(ty::queries::mir_const_qualif::get(tcx, item.span, def_id))\n+            }\n             hir::ItemFn(_, _, constness, .., body) => {\n                 let data = FnData {\n                     constness: constness,\n@@ -661,8 +658,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             hir::ItemForeignMod(_) => EntryKind::ForeignMod,\n             hir::ItemTy(..) => EntryKind::Type,\n-            hir::ItemEnum(..) => EntryKind::Enum(self.lazy(&tcx.lookup_adt_def(def_id).discr_ty),\n-                                                 get_repr_options(&tcx, def_id)),\n+            hir::ItemEnum(..) => EntryKind::Enum(get_repr_options(&tcx, def_id)),\n             hir::ItemStruct(ref struct_def, _) => {\n                 let variant = tcx.lookup_adt_def(def_id).struct_variant();\n \n@@ -679,7 +675,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n                 EntryKind::Struct(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n-                    disr: variant.disr_val,\n+                    discr: variant.discr,\n+                    evaluated_discr: None,\n                     struct_ctor: struct_ctor,\n                 }), repr_options)\n             }\n@@ -689,7 +686,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n                 EntryKind::Union(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n-                    disr: variant.disr_val,\n+                    discr: variant.discr,\n+                    evaluated_discr: None,\n                     struct_ctor: None,\n                 }), repr_options)\n             }\n@@ -720,7 +718,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let data = ImplData {\n                     polarity: polarity,\n                     parent_impl: parent,\n-                    coerce_unsized_kind: tcx.custom_coerce_unsized_kinds\n+                    coerce_unsized_kind: tcx.maps.custom_coerce_unsized_kind\n                         .borrow()\n                         .get(&def_id)\n                         .cloned(),\n@@ -1008,6 +1006,10 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n                           EncodeContext::encode_info_for_foreign_item,\n                           (def_id, ni));\n     }\n+    fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n+        intravisit::walk_generics(self, generics);\n+        self.index.encode_info_for_generics(generics);\n+    }\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         intravisit::walk_ty(self, ty);\n         self.index.encode_info_for_ty(ty);\n@@ -1019,6 +1021,14 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n }\n \n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n+    fn encode_info_for_generics(&mut self, generics: &hir::Generics) {\n+        for ty_param in &generics.ty_params {\n+            let def_id = self.tcx.hir.local_def_id(ty_param.id);\n+            let has_default = Untracked(ty_param.default.is_some());\n+            self.record(def_id, EncodeContext::encode_info_for_ty_param, (def_id, has_default));\n+        }\n+    }\n+\n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n         if let hir::TyImplTrait(_) = ty.node {\n             let def_id = self.tcx.hir.local_def_id(ty.id);\n@@ -1038,6 +1048,34 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n+    fn encode_info_for_ty_param(&mut self,\n+                                (def_id, Untracked(has_default)): (DefId, Untracked<bool>))\n+                                -> Entry<'tcx> {\n+        let tcx = self.tcx;\n+        Entry {\n+            kind: EntryKind::Type,\n+            visibility: self.lazy(&ty::Visibility::Public),\n+            span: self.lazy(&tcx.def_span(def_id)),\n+            attributes: LazySeq::empty(),\n+            children: LazySeq::empty(),\n+            stability: None,\n+            deprecation: None,\n+\n+            ty: if has_default {\n+                Some(self.encode_item_type(def_id))\n+            } else {\n+                None\n+            },\n+            inherent_impls: LazySeq::empty(),\n+            variances: LazySeq::empty(),\n+            generics: None,\n+            predicates: None,\n+\n+            ast: None,\n+            mir: None,\n+        }\n+    }\n+\n     fn encode_info_for_anon_ty(&mut self, def_id: DefId) -> Entry<'tcx> {\n         let tcx = self.tcx;\n         Entry {\n@@ -1065,7 +1103,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = ClosureData {\n             kind: tcx.closure_kind(def_id),\n-            ty: self.lazy(&tcx.closure_tys.borrow()[&def_id]),\n+            ty: self.lazy(&tcx.closure_type(def_id)),\n         };\n \n         Entry {"}, {"sha": "0ce886ce9e9dfc92a8ad9c35a4a5c76b22478eb3", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -20,6 +20,7 @@\n #![feature(box_patterns)]\n #![feature(conservative_impl_trait)]\n #![feature(core_intrinsics)]\n+#![cfg_attr(stage0, feature(field_init_shorthand))]\n #![feature(i128_type)]\n #![feature(proc_macro_internals)]\n #![feature(quote)]"}, {"sha": "4a20913d0b3fd19e16cef779f1817c42880f1a81", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -14,9 +14,9 @@ use index;\n use rustc::hir;\n use rustc::hir::def::{self, CtorKind};\n use rustc::hir::def_id::{DefIndex, DefId};\n+use rustc::middle::const_val::ConstVal;\n use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary};\n use rustc::middle::lang_items;\n-use rustc::middle::resolve_lifetime::ObjectLifetimeDefault;\n use rustc::mir;\n use rustc::ty::{self, Ty, ReprOptions};\n use rustc_back::PanicStrategy;\n@@ -212,7 +212,7 @@ pub struct Entry<'tcx> {\n     pub ty: Option<Lazy<Ty<'tcx>>>,\n     pub inherent_impls: LazySeq<DefIndex>,\n     pub variances: LazySeq<ty::Variance>,\n-    pub generics: Option<Lazy<Generics<'tcx>>>,\n+    pub generics: Option<Lazy<ty::Generics>>,\n     pub predicates: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n \n     pub ast: Option<Lazy<astencode::Ast<'tcx>>>,\n@@ -221,18 +221,18 @@ pub struct Entry<'tcx> {\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub enum EntryKind<'tcx> {\n-    Const,\n+    Const(u8),\n     ImmStatic,\n     MutStatic,\n     ForeignImmStatic,\n     ForeignMutStatic,\n     ForeignMod,\n     Type,\n-    Enum(Lazy<attr::IntType>, ReprOptions),\n+    Enum(ReprOptions),\n     Field,\n-    Variant(Lazy<VariantData>),\n-    Struct(Lazy<VariantData>, ReprOptions),\n-    Union(Lazy<VariantData>, ReprOptions),\n+    Variant(Lazy<VariantData<'tcx>>),\n+    Struct(Lazy<VariantData<'tcx>>, ReprOptions),\n+    Union(Lazy<VariantData<'tcx>>, ReprOptions),\n     Fn(Lazy<FnData>),\n     ForeignFn(Lazy<FnData>),\n     Mod(Lazy<ModData>),\n@@ -243,21 +243,7 @@ pub enum EntryKind<'tcx> {\n     DefaultImpl(Lazy<ImplData<'tcx>>),\n     Method(Lazy<MethodData>),\n     AssociatedType(AssociatedContainer),\n-    AssociatedConst(AssociatedContainer),\n-}\n-\n-/// A copy of `ty::Generics` which allows lazy decoding of\n-/// `regions` and `types` (e.g. knowing the number of type\n-/// and lifetime parameters before `TyCtxt` is created).\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct Generics<'tcx> {\n-    pub parent: Option<DefId>,\n-    pub parent_regions: u32,\n-    pub parent_types: u32,\n-    pub regions: LazySeq<ty::RegionParameterDef>,\n-    pub types: LazySeq<ty::TypeParameterDef<'tcx>>,\n-    pub has_self: bool,\n-    pub object_lifetime_defaults: LazySeq<ObjectLifetimeDefault>,\n+    AssociatedConst(AssociatedContainer, u8),\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -277,9 +263,10 @@ pub struct FnData {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct VariantData {\n+pub struct VariantData<'tcx> {\n     pub ctor_kind: CtorKind,\n-    pub disr: u128,\n+    pub discr: ty::VariantDiscr,\n+    pub evaluated_discr: Option<ConstVal<'tcx>>,\n \n     /// If this is a struct's only variant, this\n     /// is the index of the \"struct ctor\" item.\n@@ -350,5 +337,5 @@ pub struct MethodData {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ClosureData<'tcx> {\n     pub kind: ty::ClosureKind,\n-    pub ty: Lazy<ty::ClosureTy<'tcx>>,\n+    pub ty: Lazy<ty::PolyFnSig<'tcx>>,\n }"}, {"sha": "ae51951b519bd3420bb9281561c681a6adf75a7e", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -202,7 +202,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let diverges = match ty.sty {\n                     ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => {\n                         // FIXME(canndrew): This is_never should probably be an is_uninhabited\n-                        f.sig.skip_binder().output().is_never()\n+                        f.output().skip_binder().is_never()\n                     }\n                     _ => false\n                 };"}, {"sha": "6b6acb054b1b0200cb16f887a267815b28d1dff6", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -309,13 +309,13 @@ enum TestKind<'tcx> {\n     // test the branches of enum\n     SwitchInt {\n         switch_ty: Ty<'tcx>,\n-        options: Vec<ConstVal>,\n-        indices: FxHashMap<ConstVal, usize>,\n+        options: Vec<ConstVal<'tcx>>,\n+        indices: FxHashMap<ConstVal<'tcx>, usize>,\n     },\n \n     // test for equality\n     Eq {\n-        value: ConstVal,\n+        value: ConstVal<'tcx>,\n         ty: Ty<'tcx>,\n     },\n "}, {"sha": "f4fdf8ade900a0ba7951491a80889477d00ca4f5", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -20,7 +20,7 @@ use build::matches::{Candidate, MatchPair, Test, TestKind};\n use hair::*;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::bitvec::BitVector;\n-use rustc::middle::const_val::{ConstVal, ConstInt};\n+use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n use rustc::ty::util::IntTypeExt;\n use rustc::mir::*;\n@@ -112,8 +112,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                      test_lvalue: &Lvalue<'tcx>,\n                                      candidate: &Candidate<'pat, 'tcx>,\n                                      switch_ty: Ty<'tcx>,\n-                                     options: &mut Vec<ConstVal>,\n-                                     indices: &mut FxHashMap<ConstVal, usize>)\n+                                     options: &mut Vec<ConstVal<'tcx>>,\n+                                     indices: &mut FxHashMap<ConstVal<'tcx>, usize>)\n                                      -> bool\n     {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.lvalue == *test_lvalue) {\n@@ -191,11 +191,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let mut targets = Vec::with_capacity(used_variants + 1);\n                 let mut values = Vec::with_capacity(used_variants);\n                 let tcx = self.hir.tcx();\n-                for (idx, variant) in adt_def.variants.iter().enumerate() {\n+                for (idx, discr) in adt_def.discriminants(tcx).enumerate() {\n                     target_blocks.place_back() <- if variants.contains(idx) {\n-                        let discr = ConstInt::new_inttype(variant.disr_val, adt_def.discr_ty,\n-                                                          tcx.sess.target.uint_type,\n-                                                          tcx.sess.target.int_type).unwrap();\n                         values.push(discr);\n                         *(targets.place_back() <- self.cfg.start_new_block())\n                     } else {\n@@ -212,7 +209,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n                 debug!(\"num_enum_variants: {}, tested variants: {:?}, variants: {:?}\",\n                        num_enum_variants, values, variants);\n-                let discr_ty = adt_def.discr_ty.to_ty(tcx);\n+                let discr_ty = adt_def.repr.discr_type().to_ty(tcx);\n                 let discr = self.temp(discr_ty);\n                 self.cfg.push_assign(block, source_info, &discr,\n                                      Rvalue::Discriminant(lvalue.clone()));"}, {"sha": "41374a0012327a4e78cb7d49e1b9682b682c2890", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -223,6 +223,17 @@ pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     builder.finish(vec![], ty)\n }\n \n+pub fn construct_error<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n+                                       body_id: hir::BodyId)\n+                                       -> Mir<'tcx> {\n+    let span = hir.tcx().hir.span(hir.tcx().hir.body_owner(body_id));\n+    let ty = hir.tcx().types.err;\n+    let mut builder = Builder::new(hir, span, 0, ty);\n+    let source_info = builder.source_info(span);\n+    builder.cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n+    builder.finish(vec![], ty)\n+}\n+\n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn new(hir: Cx<'a, 'gcx, 'tcx>,\n            span: Span,"}, {"sha": "f2b89309e4ab15a709f8ba49f5f20280c9b61149", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -17,7 +17,7 @@ use hair::cx::to_ref::ToRef;\n use rustc::hir::map;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::middle::const_val::ConstVal;\n-use rustc_const_eval::{ConstContext, EvalHint, fatal_const_eval_err};\n+use rustc_const_eval::{ConstContext, fatal_const_eval_err};\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::hir;\n@@ -267,13 +267,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n                 let method = method_callee(cx, expr, ty::MethodCall::expr(expr.id));\n \n-                let sig = match method.ty.sty {\n-                    ty::TyFnDef(.., fn_ty) => &fn_ty.sig,\n-                    _ => span_bug!(expr.span, \"type of method is not an fn\"),\n-                };\n+                let sig = method.ty.fn_sig();\n \n                 let sig = cx.tcx\n-                    .no_late_bound_regions(sig)\n+                    .no_late_bound_regions(&sig)\n                     .unwrap_or_else(|| span_bug!(expr.span, \"method call has late-bound regions\"));\n \n                 assert_eq!(sig.inputs().len(), 2);\n@@ -597,7 +594,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprRepeat(ref v, count) => {\n             let tcx = cx.tcx.global_tcx();\n             let c = &cx.tcx.hir.body(count).value;\n-            let count = match ConstContext::new(tcx, count).eval(c, EvalHint::ExprTypeChecked) {\n+            let count = match ConstContext::new(tcx, count).eval(c) {\n                 Ok(ConstVal::Integral(ConstInt::Usize(u))) => u,\n                 Ok(other) => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n                 Err(s) => fatal_const_eval_err(tcx, &s, c.span, \"expression\")"}, {"sha": "c555ce1ab9c425de7e8c749a8c1a67826f6af472", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -18,7 +18,7 @@ use hair::*;\n use rustc::mir::transform::MirSource;\n \n use rustc::middle::const_val::ConstVal;\n-use rustc_const_eval::{ConstContext, EvalHint, fatal_const_eval_err};\n+use rustc_const_eval::{ConstContext, fatal_const_eval_err};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::blocks::FnLikeNode;\n@@ -113,7 +113,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n \n     pub fn const_eval_literal(&mut self, e: &hir::Expr) -> Literal<'tcx> {\n         let tcx = self.tcx.global_tcx();\n-        match ConstContext::with_tables(tcx, self.tables()).eval(e, EvalHint::ExprTypeChecked) {\n+        match ConstContext::with_tables(tcx, self.tables()).eval(e) {\n             Ok(value) => Literal::Value { value: value },\n             Err(s) => fatal_const_eval_err(tcx, &s, e.span, \"expression\")\n         }"}, {"sha": "a97495a0ebcc43d09599dc6606455b2bc28477d4", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -53,3 +53,9 @@ pub mod mir_map;\n pub mod pretty;\n pub mod transform;\n \n+use rustc::ty::maps::Providers;\n+\n+pub fn provide(providers: &mut Providers) {\n+    mir_map::provide(providers);\n+    transform::qualify_consts::provide(providers);\n+}"}, {"sha": "e0eb09fbf5d6f06e399b50d34216198f85bf16a8", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 107, "deletions": 57, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -17,23 +17,25 @@\n //! - `#[rustc_mir(pretty=\"file.mir\")]`\n \n use build;\n+use rustc::hir::def_id::DefId;\n use rustc::dep_graph::DepNode;\n use rustc::mir::Mir;\n use rustc::mir::transform::MirSource;\n use rustc::mir::visit::MutVisitor;\n use pretty;\n use hair::cx::Cx;\n \n-use rustc::infer::InferCtxt;\n use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::maps::Providers;\n use rustc::ty::subst::Substs;\n use rustc::hir;\n use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax_pos::Span;\n \n+use std::cell::RefCell;\n use std::mem;\n \n pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n@@ -42,6 +44,109 @@ pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }.as_deep_visitor());\n }\n \n+pub fn provide(providers: &mut Providers) {\n+    providers.mir = build_mir;\n+}\n+\n+fn build_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+                       -> &'tcx RefCell<Mir<'tcx>> {\n+    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let unsupported = || {\n+        span_bug!(tcx.hir.span(id), \"can't build MIR for {:?}\", def_id);\n+    };\n+\n+    // Figure out what primary body this item has.\n+    let body_id = match tcx.hir.get(id) {\n+        hir::map::NodeItem(item) => {\n+            match item.node {\n+                hir::ItemConst(_, body) |\n+                hir::ItemStatic(_, _, body) |\n+                hir::ItemFn(.., body) => body,\n+                _ => unsupported()\n+            }\n+        }\n+        hir::map::NodeTraitItem(item) => {\n+            match item.node {\n+                hir::TraitItemKind::Const(_, Some(body)) |\n+                hir::TraitItemKind::Method(_,\n+                    hir::TraitMethod::Provided(body)) => body,\n+                _ => unsupported()\n+            }\n+        }\n+        hir::map::NodeImplItem(item) => {\n+            match item.node {\n+                hir::ImplItemKind::Const(_, body) |\n+                hir::ImplItemKind::Method(_, body) => body,\n+                _ => unsupported()\n+            }\n+        }\n+        hir::map::NodeExpr(expr) => {\n+            // FIXME(eddyb) Closures should have separate\n+            // function definition IDs and expression IDs.\n+            // Type-checking should not let closures get\n+            // this far in a constant position.\n+            // Assume that everything other than closures\n+            // is a constant \"initializer\" expression.\n+            match expr.node {\n+                hir::ExprClosure(_, _, body, _) => body,\n+                _ => hir::BodyId { node_id: expr.id }\n+            }\n+        }\n+        _ => unsupported()\n+    };\n+\n+    let src = MirSource::from_node(tcx, id);\n+    tcx.infer_ctxt(body_id, Reveal::UserFacing).enter(|infcx| {\n+        let cx = Cx::new(&infcx, src);\n+        let mut mir = if cx.tables().tainted_by_errors {\n+            build::construct_error(cx, body_id)\n+        } else if let MirSource::Fn(id) = src {\n+            // fetch the fully liberated fn signature (that is, all bound\n+            // types/lifetimes replaced)\n+            let fn_sig = cx.tables().liberated_fn_sigs[&id].clone();\n+\n+            let ty = tcx.item_type(tcx.hir.local_def_id(id));\n+            let mut abi = fn_sig.abi;\n+            let implicit_argument = if let ty::TyClosure(..) = ty.sty {\n+                // HACK(eddyb) Avoid having RustCall on closures,\n+                // as it adds unnecessary (and wrong) auto-tupling.\n+                abi = Abi::Rust;\n+                Some((closure_self_ty(tcx, id, body_id), None))\n+            } else {\n+                None\n+            };\n+\n+            let body = tcx.hir.body(body_id);\n+            let explicit_arguments =\n+                body.arguments\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(index, arg)| {\n+                        (fn_sig.inputs()[index], Some(&*arg.pat))\n+                    });\n+\n+            let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n+            build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body)\n+        } else {\n+            build::construct_const(cx, body_id)\n+        };\n+\n+        // Convert the Mir to global types.\n+        let mut globalizer = GlobalizeMir {\n+            tcx: tcx,\n+            span: mir.span\n+        };\n+        globalizer.visit_mir(&mut mir);\n+        let mir = unsafe {\n+            mem::transmute::<Mir, Mir<'tcx>>(mir)\n+        };\n+\n+        pretty::dump_mir(tcx, \"mir_map\", &0, src, &mir);\n+\n+        tcx.alloc_mir(mir)\n+    })\n+}\n+\n /// A pass to lift all the types and substitutions in a Mir\n /// to the global tcx. Sadly, we don't have a \"folder\" that\n /// can change 'tcx so we have to transmute afterwards.\n@@ -79,68 +184,13 @@ struct BuildMir<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>\n }\n \n-fn build<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                         body_id: hir::BodyId)\n-                         -> (Mir<'tcx>, MirSource) {\n-    let tcx = infcx.tcx.global_tcx();\n-\n-    let item_id = tcx.hir.body_owner(body_id);\n-    let src = MirSource::from_node(tcx, item_id);\n-    let cx = Cx::new(infcx, src);\n-    if let MirSource::Fn(id) = src {\n-        // fetch the fully liberated fn signature (that is, all bound\n-        // types/lifetimes replaced)\n-        let fn_sig = cx.tables().liberated_fn_sigs[&id].clone();\n-\n-        let ty = tcx.item_type(tcx.hir.local_def_id(id));\n-        let (abi, implicit_argument) = if let ty::TyClosure(..) = ty.sty {\n-            (Abi::Rust, Some((closure_self_ty(tcx, id, body_id), None)))\n-        } else {\n-            (ty.fn_abi(), None)\n-        };\n-\n-        let body = tcx.hir.body(body_id);\n-        let explicit_arguments =\n-            body.arguments\n-                .iter()\n-                .enumerate()\n-                .map(|(index, arg)| {\n-                    (fn_sig.inputs()[index], Some(&*arg.pat))\n-                });\n-\n-        let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n-        (build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body), src)\n-    } else {\n-        (build::construct_const(cx, body_id), src)\n-    }\n-}\n-\n impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n     fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n-        self.tcx.infer_ctxt(body_id, Reveal::NotSpecializable).enter(|infcx| {\n-            let (mut mir, src) = build(&infcx, body_id);\n-\n-            // Convert the Mir to global types.\n-            let tcx = infcx.tcx.global_tcx();\n-            let mut globalizer = GlobalizeMir {\n-                tcx: tcx,\n-                span: mir.span\n-            };\n-            globalizer.visit_mir(&mut mir);\n-            let mir = unsafe {\n-                mem::transmute::<Mir, Mir<'tcx>>(mir)\n-            };\n-\n-            pretty::dump_mir(tcx, \"mir_map\", &0, src, &mir);\n-\n-            let mir = tcx.alloc_mir(mir);\n-            let def_id = tcx.hir.local_def_id(src.item_id());\n-            tcx.mir_map.borrow_mut().insert(def_id, mir);\n-        });\n+        self.tcx.item_mir(self.tcx.hir.body_owner_def_id(body_id));\n \n         let body = self.tcx.hir.body(body_id);\n         self.visit_body(body);"}, {"sha": "441a9add883ddfe9ca668f2704e99116aa335e24", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 74, "deletions": 79, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -16,61 +16,57 @@\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::traits::{self, Reveal};\n-use rustc::ty::{self, TyCtxt, Ty};\n+use rustc::ty::{self, TyCtxt, Ty, TypeFoldable};\n use rustc::ty::cast::CastTy;\n+use rustc::ty::maps::Providers;\n use rustc::mir::*;\n use rustc::mir::traversal::ReversePostorder;\n-use rustc::mir::transform::{Pass, MirPass, MirSource};\n+use rustc::mir::transform::{Pass, MirMapPass, MirPassHook, MirSource};\n use rustc::mir::visit::{LvalueContext, Visitor};\n-use rustc::util::nodemap::DefIdMap;\n use rustc::middle::lang_items;\n use syntax::abi::Abi;\n use syntax::feature_gate::UnstableFeatures;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n-use std::collections::hash_map::Entry;\n use std::fmt;\n use std::usize;\n \n use super::promote_consts::{self, Candidate, TempState};\n \n bitflags! {\n     flags Qualif: u8 {\n-        // Const item's qualification while recursing.\n-        // Recursive consts are an error.\n-        const RECURSIVE         = 1 << 0,\n-\n         // Constant containing interior mutability (UnsafeCell).\n-        const MUTABLE_INTERIOR  = 1 << 1,\n+        const MUTABLE_INTERIOR  = 1 << 0,\n \n         // Constant containing an ADT that implements Drop.\n-        const NEEDS_DROP        = 1 << 2,\n+        const NEEDS_DROP        = 1 << 1,\n \n         // Function argument.\n-        const FN_ARGUMENT       = 1 << 3,\n+        const FN_ARGUMENT       = 1 << 2,\n \n         // Static lvalue or move from a static.\n-        const STATIC            = 1 << 4,\n+        const STATIC            = 1 << 3,\n \n         // Reference to a static.\n-        const STATIC_REF        = 1 << 5,\n+        const STATIC_REF        = 1 << 4,\n \n         // Not constant at all - non-`const fn` calls, asm!,\n         // pointer comparisons, ptr-to-int casts, etc.\n-        const NOT_CONST         = 1 << 6,\n+        const NOT_CONST         = 1 << 5,\n \n         // Refers to temporaries which cannot be promoted as\n         // promote_consts decided they weren't simple enough.\n-        const NOT_PROMOTABLE    = 1 << 7,\n+        const NOT_PROMOTABLE    = 1 << 6,\n \n         // Borrows of temporaries can be promoted only\n         // if they have none of the above qualifications.\n-        const NEVER_PROMOTE     = !0,\n+        const NEVER_PROMOTE     = 0b111_1111,\n \n         // Const items can only have MUTABLE_INTERIOR\n         // and NOT_PROMOTABLE without producing an error.\n@@ -134,7 +130,6 @@ struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     rpo: ReversePostorder<'a, 'tcx>,\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParameterEnvironment<'tcx>,\n-    qualif_map: &'a mut DefIdMap<Qualif>,\n     temp_qualif: IndexVec<Local, Option<Qualif>>,\n     return_qualif: Option<Qualif>,\n     qualif: Qualif,\n@@ -146,7 +141,6 @@ struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            param_env: ty::ParameterEnvironment<'tcx>,\n-           qualif_map: &'a mut DefIdMap<Qualif>,\n            def_id: DefId,\n            mir: &'a Mir<'tcx>,\n            mode: Mode)\n@@ -162,7 +156,6 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             rpo: rpo,\n             tcx: tcx,\n             param_env: param_env,\n-            qualif_map: qualif_map,\n             temp_qualif: IndexVec::from_elem(None, &mir.local_decls),\n             return_qualif: None,\n             qualif: Qualif::empty(),\n@@ -585,17 +578,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     if substs.types().next().is_some() {\n                         self.add_type(constant.ty);\n                     } else {\n-                        let qualif = qualify_const_item_cached(self.tcx,\n-                                                               self.qualif_map,\n-                                                               def_id);\n-                        self.add(qualif);\n-                    }\n+                        let bits = ty::queries::mir_const_qualif::get(self.tcx,\n+                                                                      constant.span,\n+                                                                      def_id);\n \n-                    // FIXME(eddyb) check recursive constants here,\n-                    // instead of rustc_passes::static_recursion.\n-                    if self.qualif.intersects(Qualif::RECURSIVE) {\n-                        span_bug!(constant.span,\n-                                  \"recursive constant wasn't caught earlier\");\n+                        let qualif = Qualif::from_bits(bits).expect(\"invalid mir_const_qualif\");\n+                        self.add(qualif);\n                     }\n \n                     // Let `const fn` transitively have destructors,\n@@ -758,7 +746,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n             Rvalue::Aggregate(ref kind, _) => {\n                 if let AggregateKind::Adt(def, ..) = *kind {\n-                    if def.has_dtor() {\n+                    if def.has_dtor(self.tcx) {\n                         self.add(Qualif::NEEDS_DROP);\n                         self.deny_drop();\n                     }\n@@ -788,7 +776,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             let fn_ty = func.ty(self.mir, self.tcx);\n             let (is_shuffle, is_const_fn) = match fn_ty.sty {\n                 ty::TyFnDef(def_id, _, f) => {\n-                    (f.abi == Abi::PlatformIntrinsic &&\n+                    (f.abi() == Abi::PlatformIntrinsic &&\n                      self.tcx.item_name(def_id).as_str().starts_with(\"simd_shuffle\"),\n                      is_const_fn(self.tcx, def_id))\n                 }\n@@ -944,41 +932,64 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n     }\n }\n \n-fn qualify_const_item_cached<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       qualif_map: &mut DefIdMap<Qualif>,\n-                                       def_id: DefId)\n-                                       -> Qualif {\n-    match qualif_map.entry(def_id) {\n-        Entry::Occupied(entry) => return *entry.get(),\n-        Entry::Vacant(entry) => {\n-            // Guard against `const` recursion.\n-            entry.insert(Qualif::RECURSIVE);\n-        }\n+pub fn provide(providers: &mut Providers) {\n+    providers.mir_const_qualif = qualify_const_item;\n+}\n+\n+fn qualify_const_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                def_id: DefId)\n+                                -> u8 {\n+    let mir = &tcx.item_mir(def_id);\n+    if mir.return_ty.references_error() {\n+        return Qualif::NOT_CONST.bits();\n     }\n \n-    let param_env = if def_id.is_local() {\n-        let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-        ty::ParameterEnvironment::for_item(tcx, node_id)\n-    } else {\n-        // These should only be monomorphic constants.\n-        tcx.empty_parameter_environment()\n-    };\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let param_env = ty::ParameterEnvironment::for_item(tcx, node_id);\n \n-    let mir = &tcx.item_mir(def_id);\n-    let mut qualifier = Qualifier::new(tcx, param_env, qualif_map, def_id, mir, Mode::Const);\n-    let qualif = qualifier.qualify_const();\n-    qualifier.qualif_map.insert(def_id, qualif);\n-    qualif\n+    let mut qualifier = Qualifier::new(tcx, param_env, def_id, mir, Mode::Const);\n+    qualifier.qualify_const().bits()\n }\n \n-#[derive(Default)]\n-pub struct QualifyAndPromoteConstants {\n-    qualif_map: DefIdMap<Qualif>\n-}\n+pub struct QualifyAndPromoteConstants;\n \n impl Pass for QualifyAndPromoteConstants {}\n \n-impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants {\n+impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n+    fn run_pass<'a>(&mut self,\n+                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    hooks: &mut [Box<for<'s> MirPassHook<'s>>])\n+    {\n+        let def_ids = tcx.maps.mir.borrow().keys();\n+        for def_id in def_ids {\n+            if !def_id.is_local() {\n+                continue;\n+            }\n+\n+            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n+            let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+            let src = MirSource::from_node(tcx, id);\n+\n+            if let MirSource::Const(_) = src {\n+                ty::queries::mir_const_qualif::get(tcx, DUMMY_SP, def_id);\n+                continue;\n+            }\n+\n+            let mir = &mut tcx.maps.mir.borrow()[&def_id].borrow_mut();\n+            tcx.dep_graph.write(DepNode::Mir(def_id));\n+\n+            for hook in &mut *hooks {\n+                hook.on_mir_pass(tcx, src, mir, self, false);\n+            }\n+            self.run_pass(tcx, src, mir);\n+            for hook in &mut *hooks {\n+                hook.on_mir_pass(tcx, src, mir, self, true);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> QualifyAndPromoteConstants {\n     fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     src: MirSource, mir: &mut Mir<'tcx>) {\n         let id = src.item_id();\n@@ -991,18 +1002,9 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants {\n                     Mode::Fn\n                 }\n             }\n-            MirSource::Const(_) => {\n-                match self.qualif_map.entry(def_id) {\n-                    Entry::Occupied(_) => return,\n-                    Entry::Vacant(entry) => {\n-                        // Guard against `const` recursion.\n-                        entry.insert(Qualif::RECURSIVE);\n-                        Mode::Const\n-                    }\n-                }\n-            }\n             MirSource::Static(_, hir::MutImmutable) => Mode::Static,\n             MirSource::Static(_, hir::MutMutable) => Mode::StaticMut,\n+            MirSource::Const(_) |\n             MirSource::Promoted(..) => return\n         };\n         let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n@@ -1012,7 +1014,6 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants {\n             // which can't be mutated until its scope ends.\n             let (temps, candidates) = {\n                 let mut qualifier = Qualifier::new(tcx, param_env,\n-                                                   &mut self.qualif_map,\n                                                    def_id, mir, mode);\n                 if mode == Mode::ConstFn {\n                     // Enforce a constant-like CFG for `const fn`.\n@@ -1029,20 +1030,14 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants {\n             // Do the actual promotion, now that we know what's viable.\n             promote_consts::promote_candidates(mir, tcx, temps, candidates);\n         } else {\n-            let mut qualifier = Qualifier::new(tcx, param_env,\n-                                               &mut self.qualif_map,\n-                                               def_id, mir, mode);\n-            let qualif = qualifier.qualify_const();\n-\n-            if mode == Mode::Const {\n-                qualifier.qualif_map.insert(def_id, qualif);\n-            }\n+            let mut qualifier = Qualifier::new(tcx, param_env, def_id, mir, mode);\n+            qualifier.qualify_const();\n         }\n \n         // Statics must be Sync.\n         if mode == Mode::Static {\n             let ty = mir.return_ty;\n-            tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n+            tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n                 let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n                 let mut fulfillment_cx = traits::FulfillmentContext::new();\n                 fulfillment_cx.register_bound(&infcx, ty,"}, {"sha": "af4a4a53905eb05ffb265d9ee4fc1e8676b90098", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -440,14 +440,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             TerminatorKind::Call { ref func, ref args, ref destination, .. } => {\n                 let func_ty = func.ty(mir, tcx);\n                 debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n-                let func_ty = match func_ty.sty {\n-                    ty::TyFnDef(.., func_ty) | ty::TyFnPtr(func_ty) => func_ty,\n+                let sig = match func_ty.sty {\n+                    ty::TyFnDef(.., sig) | ty::TyFnPtr(sig) => sig,\n                     _ => {\n                         span_mirbug!(self, term, \"call to non-function {:?}\", func_ty);\n                         return;\n                     }\n                 };\n-                let sig = tcx.erase_late_bound_regions(&func_ty.sig);\n+                let sig = tcx.erase_late_bound_regions(&sig);\n                 let sig = self.normalize(&sig);\n                 self.check_call_dest(mir, term, &sig, destination);\n \n@@ -699,7 +699,7 @@ impl<'tcx> MirPass<'tcx> for TypeckMir {\n             return;\n         }\n         let param_env = ty::ParameterEnvironment::for_item(tcx, src.item_id());\n-        tcx.infer_ctxt(param_env, Reveal::NotSpecializable).enter(|infcx| {\n+        tcx.infer_ctxt(param_env, Reveal::UserFacing).enter(|infcx| {\n             let mut checker = TypeChecker::new(&infcx, src.item_id());\n             {\n                 let mut verifier = TypeVerifier::new(&mut checker, mir);"}, {"sha": "930a13e36bdcaebf3ba853882381c975c3e91ff4", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -28,9 +28,8 @@ use rustc::dep_graph::DepNode;\n use rustc::ty::cast::CastKind;\n use rustc_const_eval::{ConstEvalErr, ConstContext};\n use rustc_const_eval::ErrKind::{IndexOpFeatureGated, UnimplementedConstVal, MiscCatchAll, Math};\n-use rustc_const_eval::ErrKind::{ErroneousReferencedConstant, MiscBinaryOp, NonConstPath, BadType};\n-use rustc_const_eval::ErrKind::UnresolvedPath;\n-use rustc_const_eval::EvalHint::ExprTypeChecked;\n+use rustc_const_eval::ErrKind::{ErroneousReferencedConstant, MiscBinaryOp, NonConstPath};\n+use rustc_const_eval::ErrKind::{TypeckError};\n use rustc_const_math::{ConstMathErr, Op};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n@@ -66,12 +65,12 @@ struct CheckCrateVisitor<'a, 'tcx: 'a> {\n impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     fn check_const_eval(&self, expr: &'gcx hir::Expr) {\n         let const_cx = ConstContext::with_tables(self.tcx, self.tables);\n-        if let Err(err) = const_cx.eval(expr, ExprTypeChecked) {\n+        if let Err(err) = const_cx.eval(expr) {\n             match err.kind {\n                 UnimplementedConstVal(_) => {}\n                 IndexOpFeatureGated => {}\n                 ErroneousReferencedConstant(_) => {}\n-                BadType(_) => {}\n+                TypeckError => {}\n                 _ => {\n                     self.tcx.sess.add_lint(CONST_ERR,\n                                            expr.id,\n@@ -138,7 +137,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n             self.check_const_eval(&body.value);\n         }\n \n-        let outer_penv = self.tcx.infer_ctxt(body_id, Reveal::NotSpecializable).enter(|infcx| {\n+        let outer_penv = self.tcx.infer_ctxt(body_id, Reveal::UserFacing).enter(|infcx| {\n             let param_env = infcx.parameter_environment.clone();\n             let outer_penv = mem::replace(&mut self.param_env, param_env);\n             euv::ExprUseVisitor::new(self, &infcx).consume_body(body);\n@@ -240,18 +239,17 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n \n         if self.in_fn && self.promotable {\n             let const_cx = ConstContext::with_tables(self.tcx, self.tables);\n-            match const_cx.eval(ex, ExprTypeChecked) {\n+            match const_cx.eval(ex) {\n                 Ok(_) => {}\n                 Err(ConstEvalErr { kind: UnimplementedConstVal(_), .. }) |\n                 Err(ConstEvalErr { kind: MiscCatchAll, .. }) |\n                 Err(ConstEvalErr { kind: MiscBinaryOp, .. }) |\n                 Err(ConstEvalErr { kind: NonConstPath, .. }) |\n-                Err(ConstEvalErr { kind: UnresolvedPath, .. }) |\n                 Err(ConstEvalErr { kind: ErroneousReferencedConstant(_), .. }) |\n                 Err(ConstEvalErr { kind: Math(ConstMathErr::Overflow(Op::Shr)), .. }) |\n                 Err(ConstEvalErr { kind: Math(ConstMathErr::Overflow(Op::Shl)), .. }) |\n                 Err(ConstEvalErr { kind: IndexOpFeatureGated, .. }) => {}\n-                Err(ConstEvalErr { kind: BadType(_), .. }) => {}\n+                Err(ConstEvalErr { kind: TypeckError, .. }) => {}\n                 Err(msg) => {\n                     self.tcx.sess.add_lint(CONST_ERR,\n                                            ex.id,\n@@ -274,7 +272,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n /// instead of producing errors.\n fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node_ty: Ty<'tcx>) {\n     match node_ty.sty {\n-        ty::TyAdt(def, _) if def.has_dtor() => {\n+        ty::TyAdt(def, _) if def.has_dtor(v.tcx) => {\n             v.promotable = false;\n         }\n         _ => {}"}, {"sha": "ad20c535decbbd63946aaa12abdd53da75dc8ad0", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -44,7 +44,7 @@ pub fn print_mir_stats<'tcx, 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, title: &str) {\n     // For debugging instrumentation like this, we don't need to worry\n     // about maintaining the dep graph.\n     let _ignore = tcx.dep_graph.in_ignore();\n-    let mir_map = tcx.mir_map.borrow();\n+    let mir_map = tcx.maps.mir.borrow();\n     for def_id in mir_map.keys() {\n         let mir = mir_map.get(&def_id).unwrap();\n         collector.visit_mir(&mir.borrow());"}, {"sha": "c367e71fcd24619417dd41e20e2077739503b535", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -38,7 +38,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RvalueContext<'a, 'tcx> {\n \n     fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n         let body = self.tcx.hir.body(body_id);\n-        self.tcx.infer_ctxt(body_id, Reveal::NotSpecializable).enter(|infcx| {\n+        self.tcx.infer_ctxt(body_id, Reveal::UserFacing).enter(|infcx| {\n             let mut delegate = RvalueContextDelegate {\n                 tcx: infcx.tcx,\n                 param_env: &infcx.parameter_environment"}, {"sha": "72347f1616eb69e045f145d87b8d1eac4b8af40f", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -334,7 +334,11 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n \n impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     fn generics(&mut self) -> &mut Self {\n-        self.ev.tcx.item_generics(self.item_def_id).visit_with(self);\n+        for def in &self.ev.tcx.item_generics(self.item_def_id).types {\n+            if def.has_default {\n+                self.ev.tcx.item_type(def.def_id).visit_with(self);\n+            }\n+        }\n         self\n     }\n \n@@ -892,7 +896,11 @@ struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     fn generics(&mut self) -> &mut Self {\n-        self.tcx.item_generics(self.item_def_id).visit_with(self);\n+        for def in &self.tcx.item_generics(self.item_def_id).types {\n+            if def.has_default {\n+                self.tcx.item_type(def.def_id).visit_with(self);\n+            }\n+        }\n         self\n     }\n "}, {"sha": "89cff39c59e31317f3af47fe0fa81921c7962925", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -462,8 +462,8 @@ impl<'a> Resolver<'a> {\n                     self.define(module, ident, ns, (child.def, ty::Visibility::Public,\n                                                     DUMMY_SP, Mark::root()));\n \n-                    let has_self = self.session.cstore.associated_item(child.def.def_id())\n-                                       .map_or(false, |item| item.method_has_self_argument);\n+                    let has_self = self.session.cstore.associated_item_cloned(child.def.def_id())\n+                                       .method_has_self_argument;\n                     self.trait_item_map.insert((def_id, child.name, ns), (child.def, has_self));\n                 }\n                 module.populated.set(true);"}, {"sha": "8f6b1b8971e5b9ffb1967dbb72629227735966fe", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -15,6 +15,33 @@\n // use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n register_long_diagnostics! {\n \n+E0128: r##\"\n+Type parameter defaults can only use parameters that occur before them.\n+Erroneous code example:\n+\n+```compile_fail,E0128\n+struct Foo<T=U, U=()> {\n+    field1: T,\n+    filed2: U,\n+}\n+// error: type parameters with a default cannot use forward declared\n+// identifiers\n+```\n+\n+Since type parameters are evaluated in-order, you may be able to fix this issue\n+by doing:\n+\n+```\n+struct Foo<U=(), T=U> {\n+    field1: T,\n+    filed2: U,\n+}\n+```\n+\n+Please also verify that this wasn't because of a name-clash and rename the type\n+parameter if so.\n+\"##,\n+\n E0154: r##\"\n ## Note: this error code is no longer emitted by the compiler.\n "}, {"sha": "0565db28ec5c98412e9a3709247edd24664b315b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 62, "deletions": 16, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -136,6 +136,8 @@ enum ResolutionError<'a> {\n     AttemptToUseNonConstantValueInConstant,\n     /// error E0530: X bindings cannot shadow Ys\n     BindingShadowsSomethingUnacceptable(&'a str, Name, &'a NameBinding<'a>),\n+    /// error E0128: type parameters with a default cannot use forward declared identifiers\n+    ForwardDeclaredTyParam,\n }\n \n fn resolve_error<'sess, 'a>(resolver: &'sess Resolver,\n@@ -322,6 +324,14 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n             err.span_label(binding.span, msg);\n             err\n         }\n+        ResolutionError::ForwardDeclaredTyParam => {\n+            let mut err = struct_span_err!(resolver.session, span, E0128,\n+                                           \"type parameters with a default cannot use \\\n+                                            forward declared identifiers\");\n+            err.span_label(span, &format!(\"defaulted type parameters \\\n+                                           cannot be forward declared\"));\n+            err\n+        }\n     }\n }\n \n@@ -674,6 +684,32 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         self.label_ribs.pop();\n         self.ribs[ValueNS].pop();\n     }\n+    fn visit_generics(&mut self, generics: &'tcx Generics) {\n+        // For type parameter defaults, we have to ban access\n+        // to following type parameters, as the Substs can only\n+        // provide previous type parameters as they're built.\n+        let mut default_ban_rib = Rib::new(ForwardTyParamBanRibKind);\n+        default_ban_rib.bindings.extend(generics.ty_params.iter()\n+            .skip_while(|p| p.default.is_none())\n+            .map(|p| (Ident::with_empty_ctxt(p.ident.name), Def::Err)));\n+\n+        for param in &generics.ty_params {\n+            for bound in &param.bounds {\n+                self.visit_ty_param_bound(bound);\n+            }\n+\n+            if let Some(ref ty) = param.default {\n+                self.ribs[TypeNS].push(default_ban_rib);\n+                self.visit_ty(ty);\n+                default_ban_rib = self.ribs[TypeNS].pop().unwrap();\n+            }\n+\n+            // Allow all following defaults to refer to this type parameter.\n+            default_ban_rib.bindings.remove(&Ident::with_empty_ctxt(param.ident.name));\n+        }\n+        for lt in &generics.lifetimes { self.visit_lifetime_def(lt); }\n+        for p in &generics.where_clause.predicates { self.visit_where_predicate(p); }\n+    }\n }\n \n pub type ErrorMessage = Option<(Span, String)>;\n@@ -718,6 +754,11 @@ enum RibKind<'a> {\n \n     // We passed through a `macro_rules!` statement with the given expansion\n     MacroDefinition(Mark),\n+\n+    // All bindings in this rib are type parameters that can't be used\n+    // from the default of a type parameter because they're not declared\n+    // before said type parameter. Also see the `visit_generics` override.\n+    ForwardTyParamBanRibKind,\n }\n \n /// One local scope.\n@@ -736,13 +777,6 @@ impl<'a> Rib<'a> {\n     }\n }\n \n-/// A definition along with the index of the rib it was found on\n-#[derive(Copy, Clone, Debug)]\n-struct LocalDef {\n-    ribs: Option<(Namespace, usize)>,\n-    def: Def,\n-}\n-\n enum LexicalScopeBinding<'a> {\n     Item(&'a NameBinding<'a>),\n     Def(Def),\n@@ -1428,7 +1462,7 @@ impl<'a> Resolver<'a> {\n             if let Some(def) = self.ribs[ns][i].bindings.get(&ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n                 return Some(LexicalScopeBinding::Def(\n-                    self.adjust_local_def(LocalDef { ribs: Some((ns, i)), def: def }, record_used)\n+                    self.adjust_local_def(ns, i, def, record_used)\n                 ));\n             }\n \n@@ -2527,20 +2561,32 @@ impl<'a> Resolver<'a> {\n     }\n \n     // Resolve a local definition, potentially adjusting for closures.\n-    fn adjust_local_def(&mut self, local_def: LocalDef, record_used: Option<Span>) -> Def {\n-        let ribs = match local_def.ribs {\n-            Some((ns, i)) => &self.ribs[ns][i + 1..],\n-            None => &[] as &[_],\n-        };\n-        let mut def = local_def.def;\n+    fn adjust_local_def(&mut self,\n+                        ns: Namespace,\n+                        rib_index: usize,\n+                        mut def: Def,\n+                        record_used: Option<Span>) -> Def {\n+        let ribs = &self.ribs[ns][rib_index + 1..];\n+\n+        // An invalid forward use of a type parameter from a previous default.\n+        if let ForwardTyParamBanRibKind = self.ribs[ns][rib_index].kind {\n+            if let Some(span) = record_used {\n+                resolve_error(self, span,\n+                        ResolutionError::ForwardDeclaredTyParam);\n+            }\n+            assert_eq!(def, Def::Err);\n+            return Def::Err;\n+        }\n+\n         match def {\n             Def::Upvar(..) => {\n                 span_bug!(record_used.unwrap_or(DUMMY_SP), \"unexpected {:?} in bindings\", def)\n             }\n             Def::Local(def_id) => {\n                 for rib in ribs {\n                     match rib.kind {\n-                        NormalRibKind | ModuleRibKind(..) | MacroDefinition(..) => {\n+                        NormalRibKind | ModuleRibKind(..) | MacroDefinition(..) |\n+                        ForwardTyParamBanRibKind => {\n                             // Nothing to do. Continue.\n                         }\n                         ClosureRibKind(function_id) => {\n@@ -2593,7 +2639,7 @@ impl<'a> Resolver<'a> {\n                 for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind | MethodRibKind(_) | ClosureRibKind(..) |\n-                        ModuleRibKind(..) | MacroDefinition(..) => {\n+                        ModuleRibKind(..) | MacroDefinition(..) | ForwardTyParamBanRibKind => {\n                             // Nothing to do. Continue.\n                         }\n                         ItemRibKind => {"}, {"sha": "3c275e0996dac0c3877c693f5bad6a7763cf0274", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -112,7 +112,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         where F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, D>)\n     {\n         let item_def_id = self.tcx.hir.local_def_id(item_id);\n-        match self.tcx.tables.borrow().get(&item_def_id) {\n+        match self.tcx.maps.typeck_tables.borrow().get(&item_def_id) {\n             Some(tables) => {\n                 let old_tables = self.save_ctxt.tables;\n                 self.save_ctxt.tables = tables;"}, {"sha": "b1e435dcc751c40b1bdff58ed027eb1f212f1a84", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -85,7 +85,7 @@ pub mod recorder {\n pub struct SaveContext<'l, 'tcx: 'l> {\n     tcx: TyCtxt<'l, 'tcx, 'tcx>,\n     tables: &'l ty::TypeckTables<'tcx>,\n-    analysis: &'l ty::CrateAnalysis<'tcx>,\n+    analysis: &'l ty::CrateAnalysis,\n     span_utils: SpanUtils<'tcx>,\n }\n \n@@ -550,7 +550,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 match *qpath {\n                     hir::QPath::Resolved(_, ref path) => path.def,\n                     hir::QPath::TypeRelative(..) => {\n-                        if let Some(ty) = self.analysis.hir_ty_to_ty.get(&id) {\n+                        if let Some(ty) = self.tcx.ast_ty_to_ty_cache.borrow().get(&id) {\n                             if let ty::TyProjection(proj) = ty.sty {\n                                 for item in self.tcx.associated_items(proj.trait_ref.def_id) {\n                                     if item.kind == ty::AssociatedKind::Type {\n@@ -854,7 +854,7 @@ impl Format {\n \n pub fn process_crate<'l, 'tcx>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n                                krate: &ast::Crate,\n-                               analysis: &'l ty::CrateAnalysis<'tcx>,\n+                               analysis: &'l ty::CrateAnalysis,\n                                cratename: &str,\n                                odir: Option<&Path>,\n                                format: Format) {"}, {"sha": "b5add6404fc9f0e37f953c77fba7583c7fa416d7", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 16, "deletions": 51, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -17,7 +17,6 @@ use std::env;\n use std::path::Path;\n \n use syntax::ast;\n-use syntax::parse::filemap_to_tts;\n use syntax::parse::lexer::{self, StringReader};\n use syntax::parse::token::{self, Token};\n use syntax::symbol::keywords;\n@@ -49,23 +48,6 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n-    // sub_span starts at span.lo, so we need to adjust the positions etc.\n-    // If sub_span is None, we don't need to adjust.\n-    pub fn make_sub_span(&self, span: Span, sub_span: Option<Span>) -> Option<Span> {\n-        match sub_span {\n-            None => None,\n-            Some(sub) => {\n-                let FileMapAndBytePos {fm, pos} = self.sess.codemap().lookup_byte_offset(span.lo);\n-                let base = pos + fm.start_pos;\n-                Some(Span {\n-                    lo: base + self.sess.codemap().lookup_byte_offset(sub.lo).pos,\n-                    hi: base + self.sess.codemap().lookup_byte_offset(sub.hi).pos,\n-                    expn_id: span.expn_id,\n-                })\n-            }\n-        }\n-    }\n-\n     pub fn snippet(&self, span: Span) -> String {\n         match self.sess.codemap().span_to_snippet(span) {\n             Ok(s) => s,\n@@ -74,24 +56,7 @@ impl<'a> SpanUtils<'a> {\n     }\n \n     pub fn retokenise_span(&self, span: Span) -> StringReader<'a> {\n-        // sadness - we don't have spans for sub-expressions nor access to the tokens\n-        // so in order to get extents for the function name itself (which dxr expects)\n-        // we need to re-tokenise the fn definition\n-\n-        // Note: this is a bit awful - it adds the contents of span to the end of\n-        // the codemap as a new filemap. This is mostly OK, but means we should\n-        // not iterate over the codemap. Also, any spans over the new filemap\n-        // are incompatible with spans over other filemaps.\n-        let filemap = self.sess\n-                          .codemap()\n-                          .new_filemap(String::from(\"<anon-dxr>\"), None, self.snippet(span));\n-        lexer::StringReader::new(&self.sess.parse_sess, filemap)\n-    }\n-\n-    fn span_to_tts(&self, span: Span) -> Vec<TokenTree> {\n-        let filename = String::from(\"<anon-dxr>\");\n-        let filemap = self.sess.codemap().new_filemap(filename, None, self.snippet(span));\n-        filemap_to_tts(&self.sess.parse_sess, filemap)\n+        lexer::StringReader::retokenize(&self.sess.parse_sess, span)\n     }\n \n     // Re-parses a path and returns the span for the last identifier in the path\n@@ -103,7 +68,7 @@ impl<'a> SpanUtils<'a> {\n         loop {\n             let ts = toks.real_token();\n             if ts.tok == token::Eof {\n-                return self.make_sub_span(span, result)\n+                return result\n             }\n             if bracket_count == 0 && (ts.tok.is_ident() || ts.tok.is_keyword(keywords::SelfValue)) {\n                 result = Some(ts.sp);\n@@ -128,7 +93,7 @@ impl<'a> SpanUtils<'a> {\n                 return None;\n             }\n             if bracket_count == 0 && (ts.tok.is_ident() || ts.tok.is_keyword(keywords::SelfValue)) {\n-                return self.make_sub_span(span, Some(ts.sp));\n+                return Some(ts.sp);\n             }\n \n             bracket_count += match ts.tok {\n@@ -178,10 +143,7 @@ impl<'a> SpanUtils<'a> {\n             }\n             prev = next;\n         }\n-        if result.is_none() && prev_span.is_some() {\n-            return self.make_sub_span(span, prev_span);\n-        }\n-        return self.make_sub_span(span, result);\n+        result.or(prev_span)\n     }\n \n     // Return the span for the last ident before a `<` and outside any\n@@ -241,9 +203,9 @@ impl<'a> SpanUtils<'a> {\n                       loc.line);\n         }\n         if result.is_none() && prev.tok.is_ident() && angle_count == 0 {\n-            return self.make_sub_span(span, Some(prev.sp));\n+            return Some(prev.sp);\n         }\n-        self.make_sub_span(span, result)\n+        result\n     }\n \n     // Reparse span and return an owned vector of sub spans of the first limit\n@@ -310,7 +272,7 @@ impl<'a> SpanUtils<'a> {\n                 angle_count += 1;\n             }\n             if ts.tok.is_ident() && angle_count == nesting {\n-                result.push(self.make_sub_span(span, Some(ts.sp)).unwrap());\n+                result.push(ts.sp);\n             }\n         }\n     }\n@@ -320,8 +282,11 @@ impl<'a> SpanUtils<'a> {\n     /// end of the 'signature' part, that is up to, but not including an opening\n     /// brace or semicolon.\n     pub fn signature_string_for_span(&self, span: Span) -> String {\n-        let mut toks = self.span_to_tts(span).into_iter();\n+        let mut toks = self.retokenise_span(span);\n+        toks.real_token();\n+        let mut toks = toks.parse_all_token_trees().unwrap().into_iter();\n         let mut prev = toks.next().unwrap();\n+\n         let first_span = prev.get_span();\n         let mut angle_count = 0;\n         for tok in toks {\n@@ -360,7 +325,7 @@ impl<'a> SpanUtils<'a> {\n             }\n             let next = toks.real_token();\n             if next.tok == tok {\n-                return self.make_sub_span(span, Some(prev.sp));\n+                return Some(prev.sp);\n             }\n             prev = next;\n         }\n@@ -374,7 +339,7 @@ impl<'a> SpanUtils<'a> {\n                 return None;\n             }\n             if next.tok == tok {\n-                return self.make_sub_span(span, Some(next.sp));\n+                return Some(next.sp);\n             }\n         }\n     }\n@@ -399,7 +364,7 @@ impl<'a> SpanUtils<'a> {\n                 if ts.tok == token::Eof {\n                     return None\n                 } else {\n-                    return self.make_sub_span(span, Some(ts.sp));\n+                    return Some(ts.sp);\n                 }\n             }\n         }\n@@ -444,7 +409,7 @@ impl<'a> SpanUtils<'a> {\n             if ts.tok == token::Not {\n                 let ts = toks.real_token();\n                 if ts.tok.is_ident() {\n-                    return self.make_sub_span(span, Some(ts.sp));\n+                    return Some(ts.sp);\n                 } else {\n                     return None;\n                 }\n@@ -463,7 +428,7 @@ impl<'a> SpanUtils<'a> {\n             let ts = toks.real_token();\n             if ts.tok == token::Not {\n                 if prev.tok.is_ident() {\n-                    return self.make_sub_span(span, Some(prev.sp));\n+                    return Some(prev.sp);\n                 } else {\n                     return None;\n                 }"}, {"sha": "b44cd20e4402e58bc7c8735ddf1587777103abfe", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -327,20 +327,18 @@ pub struct FnType {\n \n impl FnType {\n     pub fn new<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                         abi: Abi,\n-                         sig: &ty::FnSig<'tcx>,\n+                         sig: ty::FnSig<'tcx>,\n                          extra_args: &[Ty<'tcx>]) -> FnType {\n-        let mut fn_ty = FnType::unadjusted(ccx, abi, sig, extra_args);\n-        fn_ty.adjust_for_abi(ccx, abi, sig);\n+        let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n+        fn_ty.adjust_for_abi(ccx, sig);\n         fn_ty\n     }\n \n     pub fn unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                abi: Abi,\n-                                sig: &ty::FnSig<'tcx>,\n+                                sig: ty::FnSig<'tcx>,\n                                 extra_args: &[Ty<'tcx>]) -> FnType {\n         use self::Abi::*;\n-        let cconv = match ccx.sess().target.target.adjust_abi(abi) {\n+        let cconv = match ccx.sess().target.target.adjust_abi(sig.abi) {\n             RustIntrinsic | PlatformIntrinsic |\n             Rust | RustCall => llvm::CCallConv,\n \n@@ -363,7 +361,7 @@ impl FnType {\n         };\n \n         let mut inputs = sig.inputs();\n-        let extra_args = if abi == RustCall {\n+        let extra_args = if sig.abi == RustCall {\n             assert!(!sig.variadic && extra_args.is_empty());\n \n             match sig.inputs().last().unwrap().sty {\n@@ -388,7 +386,7 @@ impl FnType {\n         let linux_s390x = target.target_os == \"linux\"\n                        && target.arch == \"s390x\"\n                        && target.target_env == \"gnu\";\n-        let rust_abi = match abi {\n+        let rust_abi = match sig.abi {\n             RustIntrinsic | PlatformIntrinsic | Rust | RustCall => true,\n             _ => false\n         };\n@@ -535,8 +533,8 @@ impl FnType {\n \n     pub fn adjust_for_abi<'a, 'tcx>(&mut self,\n                                     ccx: &CrateContext<'a, 'tcx>,\n-                                    abi: Abi,\n-                                    sig: &ty::FnSig<'tcx>) {\n+                                    sig: ty::FnSig<'tcx>) {\n+        let abi = sig.abi;\n         if abi == Abi::Unadjusted { return }\n \n         if abi == Abi::Rust || abi == Abi::RustCall ||"}, {"sha": "8125f432ff5ae963feb0db9e3aefbb087064ecb2", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -47,7 +47,7 @@ use rustc::util::common::time;\n use session::config::{self, NoDebugInfo};\n use rustc_incremental::IncrementalHashesMap;\n use session::{self, DataTypeKind, Session};\n-use abi::{self, Abi, FnType};\n+use abi::{self, FnType};\n use mir::lvalue::LvalueRef;\n use adt;\n use attributes;\n@@ -600,8 +600,8 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     let fn_ty = ccx.tcx().erase_regions(&fn_ty);\n     let fn_ty = monomorphize::apply_param_substs(ccx.shared(), instance.substs, &fn_ty);\n \n-    let ty::BareFnTy { abi, ref sig, .. } = *common::ty_fn_ty(ccx, fn_ty);\n-    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(sig);\n+    let sig = common::ty_fn_sig(ccx, fn_ty);\n+    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n \n     let lldecl = match ccx.instances().borrow().get(&instance) {\n         Some(&val) => val,\n@@ -614,10 +614,8 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n         attributes::emit_uwtable(lldecl, true);\n     }\n \n-    let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n-\n     let mir = ccx.tcx().item_mir(instance.def);\n-    mir::trans_mir(ccx, lldecl, fn_ty, &mir, instance, &sig, abi);\n+    mir::trans_mir(ccx, lldecl, &mir, instance, sig);\n }\n \n pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -632,7 +630,7 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let ctor_ty = monomorphize::apply_param_substs(ccx.shared(), substs, &ctor_ty);\n \n     let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&ctor_ty.fn_sig());\n-    let fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n+    let fn_ty = FnType::new(ccx, sig, &[]);\n \n     let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n     if !fn_ty.ret.is_ignore() {"}, {"sha": "4925c9d547e9d19ac45108ae6479dcedc2b3b2b0", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 35, "deletions": 55, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -18,7 +18,7 @@ pub use self::CalleeData::*;\n \n use llvm::{self, ValueRef, get_params};\n use rustc::hir::def_id::DefId;\n-use rustc::ty::subst::Substs;\n+use rustc::ty::subst::{Substs, Subst};\n use rustc::traits;\n use abi::{Abi, FnType};\n use attributes;\n@@ -83,7 +83,7 @@ impl<'tcx> Callee<'tcx> {\n \n         let fn_ty = def_ty(ccx.shared(), def_id, substs);\n         if let ty::TyFnDef(.., f) = fn_ty.sty {\n-            if f.abi == Abi::RustIntrinsic || f.abi == Abi::PlatformIntrinsic {\n+            if f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic {\n                 return Callee {\n                     data: Intrinsic,\n                     ty: fn_ty\n@@ -93,9 +93,9 @@ impl<'tcx> Callee<'tcx> {\n \n         // FIXME(eddyb) Detect ADT constructors more efficiently.\n         if let Some(adt_def) = fn_ty.fn_ret().skip_binder().ty_adt_def() {\n-            if let Some(v) = adt_def.variants.iter().find(|v| def_id == v.did) {\n+            if let Some(i) = adt_def.variants.iter().position(|v| def_id == v.did) {\n                 return Callee {\n-                    data: NamedTupleConstructor(Disr::from(v.disr_val)),\n+                    data: NamedTupleConstructor(Disr::for_variant(tcx, adt_def, i)),\n                     ty: fn_ty\n                 };\n             }\n@@ -169,14 +169,13 @@ impl<'tcx> Callee<'tcx> {\n     /// The extra argument types are for variadic (extern \"C\") functions.\n     pub fn direct_fn_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n                               extra_args: &[Ty<'tcx>]) -> FnType {\n-        let abi = self.ty.fn_abi();\n-        let sig = ccx.tcx().erase_late_bound_regions_and_normalize(self.ty.fn_sig());\n-        let mut fn_ty = FnType::unadjusted(ccx, abi, &sig, extra_args);\n+        let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&self.ty.fn_sig());\n+        let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n         if let Virtual(_) = self.data {\n             // Don't pass the vtable, it's not an argument of the virtual fn.\n             fn_ty.args[1].ignore();\n         }\n-        fn_ty.adjust_for_abi(ccx, abi, &sig);\n+        fn_ty.adjust_for_abi(ccx, sig);\n         fn_ty\n     }\n \n@@ -307,38 +306,32 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let ref_closure_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReErased), closure_ty);\n \n     // Make a version with the type of by-ref closure.\n-    let ty::ClosureTy { unsafety, abi, mut sig } = tcx.closure_type(def_id, substs);\n-    sig.0 = tcx.mk_fn_sig(\n-        iter::once(ref_closure_ty).chain(sig.0.inputs().iter().cloned()),\n-        sig.0.output(),\n-        sig.0.variadic\n-    );\n-    let llref_fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-        unsafety: unsafety,\n-        abi: abi,\n-        sig: sig.clone()\n-    }));\n+    let sig = tcx.closure_type(def_id).subst(tcx, substs.substs);\n+    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n+    assert_eq!(sig.abi, Abi::RustCall);\n+    let llref_fn_ty = tcx.mk_fn_ptr(ty::Binder(tcx.mk_fn_sig(\n+        iter::once(ref_closure_ty).chain(sig.inputs().iter().cloned()),\n+        sig.output(),\n+        sig.variadic,\n+        sig.unsafety,\n+        Abi::RustCall\n+    )));\n     debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={:?}\",\n            llref_fn_ty);\n \n \n     // Make a version of the closure type with the same arguments, but\n     // with argument #0 being by value.\n-    assert_eq!(abi, Abi::RustCall);\n-    sig.0 = tcx.mk_fn_sig(\n-        iter::once(closure_ty).chain(sig.0.inputs().iter().skip(1).cloned()),\n-        sig.0.output(),\n-        sig.0.variadic\n+    let sig = tcx.mk_fn_sig(\n+        iter::once(closure_ty).chain(sig.inputs().iter().cloned()),\n+        sig.output(),\n+        sig.variadic,\n+        sig.unsafety,\n+        Abi::RustCall\n     );\n \n-    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n-    let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n-\n-    let llonce_fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-        unsafety: unsafety,\n-        abi: abi,\n-        sig: ty::Binder(sig)\n-    }));\n+    let fn_ty = FnType::new(ccx, sig, &[]);\n+    let llonce_fn_ty = tcx.mk_fn_ptr(ty::Binder(sig));\n \n     // Create the by-value helper.\n     let function_name = method_instance.symbol_name(ccx.shared());\n@@ -470,33 +463,20 @@ fn trans_fn_pointer_shim<'a, 'tcx>(\n \n     // Construct the \"tuply\" version of `bare_fn_ty`. It takes two arguments: `self`,\n     // which is the fn pointer, and `args`, which is the arguments tuple.\n-    let sig = match bare_fn_ty.sty {\n-        ty::TyFnDef(..,\n-                    &ty::BareFnTy { unsafety: hir::Unsafety::Normal,\n-                                    abi: Abi::Rust,\n-                                    ref sig }) |\n-        ty::TyFnPtr(&ty::BareFnTy { unsafety: hir::Unsafety::Normal,\n-                                    abi: Abi::Rust,\n-                                    ref sig }) => sig,\n-\n-        _ => {\n-            bug!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n-                 bare_fn_ty);\n-        }\n-    };\n-    let sig = tcx.erase_late_bound_regions_and_normalize(sig);\n+    let sig = bare_fn_ty.fn_sig();\n+    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n+    assert_eq!(sig.unsafety, hir::Unsafety::Normal);\n+    assert_eq!(sig.abi, Abi::Rust);\n     let tuple_input_ty = tcx.intern_tup(sig.inputs(), false);\n     let sig = tcx.mk_fn_sig(\n         [bare_fn_ty_maybe_ref, tuple_input_ty].iter().cloned(),\n         sig.output(),\n-        false\n+        false,\n+        hir::Unsafety::Normal,\n+        Abi::RustCall\n     );\n-    let fn_ty = FnType::new(ccx, Abi::RustCall, &sig, &[]);\n-    let tuple_fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-        unsafety: hir::Unsafety::Normal,\n-        abi: Abi::RustCall,\n-        sig: ty::Binder(sig)\n-    }));\n+    let fn_ty = FnType::new(ccx, sig, &[]);\n+    let tuple_fn_ty = tcx.mk_fn_ptr(ty::Binder(sig));\n     debug!(\"tuple_fn_ty: {:?}\", tuple_fn_ty);\n \n     //\n@@ -600,7 +580,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // other weird situations. Annoying.\n \n     // Create a fn pointer with the substituted signature.\n-    let fn_ptr_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(common::ty_fn_ty(ccx, fn_ty).into_owned()));\n+    let fn_ptr_ty = tcx.mk_fn_ptr(common::ty_fn_sig(ccx, fn_ty));\n     let llptrty = type_of::type_of(ccx, fn_ptr_ty);\n \n     let llfn = if let Some(llfn) = declare::get_declared_value(ccx, &sym) {"}, {"sha": "b12c1220b2b4de797a9c9f4be568a02839fd35eb", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -682,10 +682,10 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n \n         fn is_drop_in_place_intrinsic<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 def_id: DefId,\n-                                                bare_fn_ty: &ty::BareFnTy<'tcx>)\n+                                                bare_fn_ty: ty::PolyFnSig<'tcx>)\n                                                 -> bool {\n-            (bare_fn_ty.abi == Abi::RustIntrinsic ||\n-             bare_fn_ty.abi == Abi::PlatformIntrinsic) &&\n+            (bare_fn_ty.abi() == Abi::RustIntrinsic ||\n+             bare_fn_ty.abi() == Abi::PlatformIntrinsic) &&\n             tcx.item_name(def_id) == \"drop_in_place\"\n         }\n     }\n@@ -697,8 +697,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   def_id: DefId)\n                                   -> bool {\n-    if let ty::TyFnDef(_, _, f) = tcx.item_type(def_id).sty {\n-        if let Some(adt_def) = f.sig.output().skip_binder().ty_adt_def() {\n+    if let ty::TyFnDef(_, _, sig) = tcx.item_type(def_id).sty {\n+        if let Some(adt_def) = sig.output().skip_binder().ty_adt_def() {\n             if adt_def.variants.iter().any(|v| def_id == v.did) {\n                 // HACK: ADT constructors are translated in-place and\n                 // do not have a trans-item.\n@@ -754,7 +754,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     // If the type implements Drop, also add a translation item for the\n     // monomorphized Drop::drop() implementation.\n     let destructor_did = match ty.sty {\n-        ty::TyAdt(def, _) => def.destructor(),\n+        ty::TyAdt(def, _) => def.destructor(scx.tcx()),\n         _ => None\n     };\n "}, {"sha": "1032da7ef75bb4ff9f66d87f67388b01afc14eb9", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -29,11 +29,11 @@ use type_::Type;\n use value::Value;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::Layout;\n+use rustc::ty::subst::Subst;\n use rustc::traits::{self, SelectionContext, Reveal};\n use rustc::hir;\n \n use libc::{c_uint, c_char};\n-use std::borrow::Cow;\n use std::iter;\n \n use syntax::ast;\n@@ -570,17 +570,17 @@ pub fn shift_mask_val<'a, 'tcx>(\n     }\n }\n \n-pub fn ty_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                          ty: Ty<'tcx>)\n-                          -> Cow<'tcx, ty::BareFnTy<'tcx>>\n+pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                           ty: Ty<'tcx>)\n+                           -> ty::PolyFnSig<'tcx>\n {\n     match ty.sty {\n-        ty::TyFnDef(_, _, fty) => Cow::Borrowed(fty),\n+        ty::TyFnDef(_, _, sig) => sig,\n         // Shims currently have type TyFnPtr. Not sure this should remain.\n-        ty::TyFnPtr(fty) => Cow::Borrowed(fty),\n+        ty::TyFnPtr(sig) => sig,\n         ty::TyClosure(def_id, substs) => {\n             let tcx = ccx.tcx();\n-            let ty::ClosureTy { unsafety, abi, sig } = tcx.closure_type(def_id, substs);\n+            let sig = tcx.closure_type(def_id).subst(tcx, substs.substs);\n \n             let env_region = ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrEnv);\n             let env_ty = match tcx.closure_kind(def_id) {\n@@ -589,12 +589,13 @@ pub fn ty_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 ty::ClosureKind::FnOnce => ty,\n             };\n \n-            let sig = sig.map_bound(|sig| tcx.mk_fn_sig(\n+            sig.map_bound(|sig| tcx.mk_fn_sig(\n                 iter::once(env_ty).chain(sig.inputs().iter().cloned()),\n                 sig.output(),\n-                sig.variadic\n-            ));\n-            Cow::Owned(ty::BareFnTy { unsafety: unsafety, abi: abi, sig: sig })\n+                sig.variadic,\n+                sig.unsafety,\n+                sig.abi\n+            ))\n         }\n         _ => bug!(\"unexpected type {:?} to ty_fn_sig\", ty)\n     }"}, {"sha": "011f7748f2c98764ae4f86cba39d0afcb68001e3", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -213,11 +213,11 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n     g\n }\n \n-pub fn trans_static(ccx: &CrateContext,\n-                    m: hir::Mutability,\n-                    id: ast::NodeId,\n-                    attrs: &[ast::Attribute])\n-                    -> Result<ValueRef, ConstEvalErr> {\n+pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                              m: hir::Mutability,\n+                              id: ast::NodeId,\n+                              attrs: &[ast::Attribute])\n+                              -> Result<ValueRef, ConstEvalErr<'tcx>> {\n     unsafe {\n         let def_id = ccx.tcx().hir.local_def_id(id);\n         let g = get_static(ccx, def_id);"}, {"sha": "d5f7549ece07b21134587e71f1c9fd10a55084be", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -959,15 +959,13 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n             return llfn;\n         }\n \n-        let ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-            unsafety: hir::Unsafety::Unsafe,\n-            abi: Abi::C,\n-            sig: ty::Binder(tcx.mk_fn_sig(\n-                iter::once(tcx.mk_mut_ptr(tcx.types.u8)),\n-                tcx.types.never,\n-                false\n-            )),\n-        }));\n+        let ty = tcx.mk_fn_ptr(ty::Binder(tcx.mk_fn_sig(\n+            iter::once(tcx.mk_mut_ptr(tcx.types.u8)),\n+            tcx.types.never,\n+            false,\n+            hir::Unsafety::Unsafe,\n+            Abi::C\n+        )));\n \n         let llfn = declare::declare_fn(self, \"rust_eh_unwind_resume\", ty);\n         attributes::unwind(llfn, true);"}, {"sha": "f6cdd883850cc5dc04b6062c2afd0902bbbfed02", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -373,11 +373,11 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                       unique_type_id: UniqueTypeId,\n-                                      signature: &ty::PolyFnSig<'tcx>,\n+                                      signature: ty::PolyFnSig<'tcx>,\n                                       span: Span)\n                                       -> MetadataCreationResult\n {\n-    let signature = cx.tcx().erase_late_bound_regions(signature);\n+    let signature = cx.tcx().erase_late_bound_regions(&signature);\n \n     let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs().len() + 1);\n \n@@ -558,10 +558,10 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 Err(metadata) => return metadata,\n             }\n         }\n-        ty::TyFnDef(.., ref barefnty) | ty::TyFnPtr(ref barefnty) => {\n+        ty::TyFnDef(.., sig) | ty::TyFnPtr(sig) => {\n             let fn_metadata = subroutine_type_metadata(cx,\n                                                        unique_type_id,\n-                                                       &barefnty.sig,\n+                                                       sig,\n                                                        usage_site_span).metadata;\n             match debug_context(cx).type_map\n                                    .borrow()\n@@ -1465,18 +1465,18 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // <unknown>\n     let file_metadata = unknown_file_metadata(cx);\n \n-    let variants = &enum_type.ty_adt_def().unwrap().variants;\n-    let enumerators_metadata: Vec<DIDescriptor> = variants\n-        .iter()\n-        .map(|v| {\n+    let def = enum_type.ty_adt_def().unwrap();\n+    let enumerators_metadata: Vec<DIDescriptor> = def.discriminants(cx.tcx())\n+        .zip(&def.variants)\n+        .map(|(discr, v)| {\n             let token = v.name.as_str();\n             let name = CString::new(token.as_bytes()).unwrap();\n             unsafe {\n                 llvm::LLVMRustDIBuilderCreateEnumerator(\n                     DIB(cx),\n                     name.as_ptr(),\n                     // FIXME: what if enumeration has i128 discriminant?\n-                    v.disr_val as u64)\n+                    discr.to_u128_unchecked() as u64)\n             }\n         })\n         .collect();"}, {"sha": "d5f04542d0255d5b52bfb058e6f735d9e4b80db4", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -198,8 +198,7 @@ pub fn finalize(cx: &CrateContext) {\n /// for the function.\n pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                instance: Instance<'tcx>,\n-                                               sig: &ty::FnSig<'tcx>,\n-                                               abi: Abi,\n+                                               sig: ty::FnSig<'tcx>,\n                                                llfn: ValueRef,\n                                                mir: &mir::Mir) -> FunctionDebugContext {\n     if cx.sess().opts.debuginfo == NoDebugInfo {\n@@ -225,7 +224,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let file_metadata = file_metadata(cx, &loc.file.name, &loc.file.abs_path);\n \n     let function_type_metadata = unsafe {\n-        let fn_signature = get_function_signature(cx, sig, abi);\n+        let fn_signature = get_function_signature(cx, sig);\n         llvm::LLVMRustDIBuilderCreateSubroutineType(DIB(cx), file_metadata, fn_signature)\n     };\n \n@@ -295,8 +294,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     return FunctionDebugContext::RegularContext(fn_debug_context);\n \n     fn get_function_signature<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                        sig: &ty::FnSig<'tcx>,\n-                                        abi: Abi) -> DIArray {\n+                                        sig: ty::FnSig<'tcx>) -> DIArray {\n         if cx.sess().opts.debuginfo == LimitedDebugInfo {\n             return create_DIArray(DIB(cx), &[]);\n         }\n@@ -309,7 +307,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             _ => type_metadata(cx, sig.output(), syntax_pos::DUMMY_SP)\n         });\n \n-        let inputs = if abi == Abi::RustCall {\n+        let inputs = if sig.abi == Abi::RustCall {\n             &sig.inputs()[..sig.inputs().len() - 1]\n         } else {\n             sig.inputs()\n@@ -320,7 +318,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             signature.push(type_metadata(cx, argument_type, syntax_pos::DUMMY_SP));\n         }\n \n-        if abi == Abi::RustCall && !sig.inputs().is_empty() {\n+        if sig.abi == Abi::RustCall && !sig.inputs().is_empty() {\n             if let ty::TyTuple(args, _) = sig.inputs()[sig.inputs().len() - 1].sty {\n                 for &argument_type in args {\n                     signature.push(type_metadata(cx, argument_type, syntax_pos::DUMMY_SP));\n@@ -332,7 +330,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n \n     fn get_template_parameters<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                         generics: &ty::Generics<'tcx>,\n+                                         generics: &ty::Generics,\n                                          substs: &Substs<'tcx>,\n                                          file_metadata: DIFile,\n                                          name_to_append_suffix_to: &mut String)\n@@ -382,9 +380,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         return create_DIArray(DIB(cx), &template_params[..]);\n     }\n \n-    fn get_type_parameter_names<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                          generics: &ty::Generics<'tcx>)\n-                                          -> Vec<ast::Name> {\n+    fn get_type_parameter_names(cx: &CrateContext, generics: &ty::Generics) -> Vec<ast::Name> {\n         let mut names = generics.parent.map_or(vec![], |def_id| {\n             get_type_parameter_names(cx, cx.tcx().item_generics(def_id))\n         });"}, {"sha": "13ff6646e666256f40772cb96a7d8934e6cb52d7", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -96,12 +96,13 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 push_type_params(cx, principal.substs, output);\n             }\n         },\n-        ty::TyFnDef(.., &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n-        ty::TyFnPtr(&ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n-            if unsafety == hir::Unsafety::Unsafe {\n+        ty::TyFnDef(.., sig) |\n+        ty::TyFnPtr(sig) => {\n+            if sig.unsafety() == hir::Unsafety::Unsafe {\n                 output.push_str(\"unsafe \");\n             }\n \n+            let abi = sig.abi();\n             if abi != ::abi::Abi::Rust {\n                 output.push_str(\"extern \\\"\");\n                 output.push_str(abi.name());\n@@ -110,7 +111,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             output.push_str(\"fn(\");\n \n-            let sig = cx.tcx().erase_late_bound_regions_and_normalize(sig);\n+            let sig = cx.tcx().erase_late_bound_regions_and_normalize(&sig);\n             if !sig.inputs().is_empty() {\n                 for &parameter_type in sig.inputs() {\n                     push_debuginfo_type_name(cx, parameter_type, true, output);"}, {"sha": "ceff96a39b2c982a04bc8233028aa67357506961", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -14,6 +14,7 @@ use super::{CrateDebugContext};\n use super::namespace::item_namespace;\n \n use rustc::hir::def_id::DefId;\n+use rustc::ty::DefIdTree;\n \n use llvm;\n use llvm::debuginfo::{DIScope, DIBuilderRef, DIDescriptor, DIArray};\n@@ -74,11 +75,8 @@ pub fn DIB(cx: &CrateContext) -> DIBuilderRef {\n \n pub fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: DefId)\n                                    -> (DIScope, Span) {\n-    let containing_scope = item_namespace(cx, DefId {\n-        krate: def_id.krate,\n-        index: cx.tcx().def_key(def_id).parent\n-                 .expect(\"get_namespace_and_span_for_item: missing parent?\")\n-    });\n+    let containing_scope = item_namespace(cx, cx.tcx().parent(def_id)\n+        .expect(\"get_namespace_and_span_for_item: missing parent?\"));\n \n     // Try to get some span information, if we have an inlined item.\n     let definition_span = cx.tcx().def_span(def_id);"}, {"sha": "2787812f9622ccc48d1d8ce4df268dc24c454d8b", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -132,19 +132,19 @@ pub fn declare_cfn(ccx: &CrateContext, name: &str, fn_type: Type) -> ValueRef {\n pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n                             fn_type: ty::Ty<'tcx>) -> ValueRef {\n     debug!(\"declare_rust_fn(name={:?}, fn_type={:?})\", name, fn_type);\n-    let ty::BareFnTy { abi, ref sig, .. } = *common::ty_fn_ty(ccx, fn_type);\n-    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(sig);\n+    let sig = common::ty_fn_sig(ccx, fn_type);\n+    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n     debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n \n-    let fty = FnType::new(ccx, abi, &sig, &[]);\n+    let fty = FnType::new(ccx, sig, &[]);\n     let llfn = declare_raw_fn(ccx, name, fty.cconv, fty.llvm_type(ccx));\n \n     // FIXME(canndrew): This is_never should really be an is_uninhabited\n     if sig.output().is_never() {\n         llvm::Attribute::NoReturn.apply_llfn(Function, llfn);\n     }\n \n-    if abi != Abi::Rust && abi != Abi::RustCall {\n+    if sig.abi != Abi::Rust && sig.abi != Abi::RustCall {\n         attributes::unwind(llfn, false);\n     }\n "}, {"sha": "a940faac8387735a7288f915564ea3b1dc0f88a0", "filename": "src/librustc_trans/disr.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fdisr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fdisr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdisr.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -8,10 +8,42 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::middle::const_val::ConstVal;\n+use rustc::ty::{self, TyCtxt};\n+use rustc_const_math::ConstInt;\n+\n #[derive(Debug, Eq, PartialEq, Copy, Clone)]\n pub struct Disr(pub u64);\n \n impl Disr {\n+    pub fn for_variant(tcx: TyCtxt,\n+                       def: &ty::AdtDef,\n+                       variant_index: usize) -> Self {\n+        let mut explicit_index = variant_index;\n+        let mut explicit_value = Disr(0);\n+        loop {\n+            match def.variants[explicit_index].discr {\n+                ty::VariantDiscr::Relative(0) => break,\n+                ty::VariantDiscr::Relative(distance) => {\n+                    explicit_index -= distance;\n+                }\n+                ty::VariantDiscr::Explicit(expr_did) => {\n+                    match tcx.maps.monomorphic_const_eval.borrow()[&expr_did] {\n+                        Ok(ConstVal::Integral(v)) => {\n+                            explicit_value = Disr::from(v);\n+                            break;\n+                        }\n+                        _ => {\n+                            explicit_index -= 1;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        let distance = variant_index - explicit_index;\n+        explicit_value.wrapping_add(Disr::from(distance))\n+    }\n+\n     pub fn wrapping_add(self, other: Self) -> Self {\n         Disr(self.0.wrapping_add(other.0))\n     }\n@@ -24,10 +56,10 @@ impl ::std::ops::BitAnd for Disr {\n     }\n }\n \n-impl From<::rustc::ty::Disr> for Disr {\n-    fn from(i: ::rustc::ty::Disr) -> Disr {\n+impl From<ConstInt> for Disr {\n+    fn from(i: ConstInt) -> Disr {\n         // FIXME: what if discr has 128 bit discr?\n-        Disr(i as u64)\n+        Disr(i.to_u128_unchecked() as u64)\n     }\n }\n "}, {"sha": "32fc3d5af24451f21d97a2a39d6c176329f1dd26", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -237,7 +237,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n             bcx.call(dtor, &[ptr.llval], None);\n             bcx\n         }\n-        ty::TyAdt(def, ..) if def.has_dtor() && !skip_dtor => {\n+        ty::TyAdt(def, ..) if def.has_dtor(bcx.tcx()) && !skip_dtor => {\n             let shallow_drop = def.is_union();\n             let tcx = bcx.tcx();\n \n@@ -265,7 +265,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n                 traits::VtableImpl(data) => data,\n                 _ => bug!(\"dtor for {:?} is not an impl???\", t)\n             };\n-            let dtor_did = def.destructor().unwrap();\n+            let dtor_did = def.destructor(tcx).unwrap();\n             let callee = Callee::def(bcx.ccx, dtor_did, vtbl.substs);\n             let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n             let llret;\n@@ -521,11 +521,10 @@ fn drop_structural_ty<'a, 'tcx>(\n                         let llswitch = cx.switch(lldiscrim_a, ret_void_cx.llbb(), n_variants);\n                         let next_cx = cx.build_sibling_block(\"enum-iter-next\");\n \n-                        for (i, variant) in adt.variants.iter().enumerate() {\n-                            let variant_cx_name = format!(\"enum-iter-variant-{}\",\n-                                &variant.disr_val.to_string());\n+                        for (i, discr) in adt.discriminants(cx.tcx()).enumerate() {\n+                            let variant_cx_name = format!(\"enum-iter-variant-{}\", i);\n                             let variant_cx = cx.build_sibling_block(&variant_cx_name);\n-                            let case_val = adt::trans_case(&cx, t, Disr::from(variant.disr_val));\n+                            let case_val = adt::trans_case(&cx, t, Disr::from(discr));\n                             variant_cx.add_case(llswitch, case_val, variant_cx.llbb());\n                             ptr.ty = LvalueTy::Downcast {\n                                 adt_def: adt,"}, {"sha": "b7aedb742db02e676e7ccb9d1bbb4563fa8652e6", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -97,12 +97,12 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let ccx = bcx.ccx;\n     let tcx = ccx.tcx();\n \n-    let (def_id, substs, fty) = match callee_ty.sty {\n-        ty::TyFnDef(def_id, substs, ref fty) => (def_id, substs, fty),\n+    let (def_id, substs, sig) = match callee_ty.sty {\n+        ty::TyFnDef(def_id, substs, sig) => (def_id, substs, sig),\n         _ => bug!(\"expected fn item type, found {}\", callee_ty)\n     };\n \n-    let sig = tcx.erase_late_bound_regions_and_normalize(&fty.sig);\n+    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n     let arg_tys = sig.inputs();\n     let ret_ty = sig.output();\n     let name = &*tcx.item_name(def_id).as_str();\n@@ -878,13 +878,13 @@ fn gen_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     output: Ty<'tcx>,\n                     trans: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n                     -> ValueRef {\n-    let sig = ccx.tcx().mk_fn_sig(inputs.into_iter(), output, false);\n-\n-    let rust_fn_ty = ccx.tcx().mk_fn_ptr(ccx.tcx().mk_bare_fn(ty::BareFnTy {\n-        unsafety: hir::Unsafety::Unsafe,\n-        abi: Abi::Rust,\n-        sig: ty::Binder(sig)\n-    }));\n+    let rust_fn_ty = ccx.tcx().mk_fn_ptr(ty::Binder(ccx.tcx().mk_fn_sig(\n+        inputs.into_iter(),\n+        output,\n+        false,\n+        hir::Unsafety::Unsafe,\n+        Abi::Rust\n+    )));\n     let llfn = declare::define_internal_fn(ccx, name, rust_fn_ty);\n     let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n     trans(bcx);\n@@ -905,11 +905,13 @@ fn get_rust_try_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Define the type up front for the signature of the rust_try function.\n     let tcx = ccx.tcx();\n     let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n-    let fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-        unsafety: hir::Unsafety::Unsafe,\n-        abi: Abi::Rust,\n-        sig: ty::Binder(tcx.mk_fn_sig(iter::once(i8p), tcx.mk_nil(), false)),\n-    }));\n+    let fn_ty = tcx.mk_fn_ptr(ty::Binder(tcx.mk_fn_sig(\n+        iter::once(i8p),\n+        tcx.mk_nil(),\n+        false,\n+        hir::Unsafety::Unsafe,\n+        Abi::Rust\n+    )));\n     let output = tcx.types.i32;\n     let rust_try = gen_fn(ccx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, trans);\n     ccx.rust_try_fn().set(Some(rust_try));\n@@ -959,7 +961,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n \n \n     let tcx = bcx.tcx();\n-    let sig = tcx.erase_late_bound_regions_and_normalize(callee_ty.fn_sig());\n+    let sig = tcx.erase_late_bound_regions_and_normalize(&callee_ty.fn_sig());\n     let arg_tys = sig.inputs();\n \n     // every intrinsic takes a SIMD vector as its first argument"}, {"sha": "3cad2bc1d842369e9a9000412fbd272f5e581f69", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 if switch_ty == bcx.tcx().types.bool {\n                     let lltrue = llblock(self, targets[0]);\n                     let llfalse = llblock(self, targets[1]);\n-                    if let [ConstInt::Infer(0)] = values[..] {\n+                    if let [ConstInt::U8(0)] = values[..] {\n                         bcx.cond_br(discr.immediate(), llfalse, lltrue);\n                     } else {\n                         bcx.cond_br(discr.immediate(), lltrue, llfalse);\n@@ -365,20 +365,21 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n                 let callee = self.trans_operand(&bcx, func);\n \n-                let (mut callee, abi, sig) = match callee.ty.sty {\n-                    ty::TyFnDef(def_id, substs, f) => {\n-                        (Callee::def(bcx.ccx, def_id, substs), f.abi, &f.sig)\n+                let (mut callee, sig) = match callee.ty.sty {\n+                    ty::TyFnDef(def_id, substs, sig) => {\n+                        (Callee::def(bcx.ccx, def_id, substs), sig)\n                     }\n-                    ty::TyFnPtr(f) => {\n+                    ty::TyFnPtr(sig) => {\n                         (Callee {\n                             data: Fn(callee.immediate()),\n                             ty: callee.ty\n-                        }, f.abi, &f.sig)\n+                        }, sig)\n                     }\n                     _ => bug!(\"{} is not callable\", callee.ty)\n                 };\n \n-                let sig = bcx.tcx().erase_late_bound_regions_and_normalize(sig);\n+                let sig = bcx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+                let abi = sig.abi;\n \n                 // Handle intrinsics old trans wants Expr's for, ourselves.\n                 let intrinsic = match (&callee.ty.sty, &callee.data) {"}, {"sha": "771a5b7f366a118d7ebea8d150507f1086e2a92b", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -20,7 +20,7 @@ use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc::ty::{self, layout, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::cast::{CastTy, IntTy};\n-use rustc::ty::subst::{Kind, Substs};\n+use rustc::ty::subst::{Kind, Substs, Subst};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use {abi, adt, base, Disr, machine};\n use callee::Callee;\n@@ -83,7 +83,6 @@ impl<'tcx> Const<'tcx> {\n                 let u = v.as_u64(ccx.tcx().sess.target.uint_type);\n                 (C_integral(Type::int(ccx), u, false), tcx.types.usize)\n             },\n-            Infer(_) | InferSigned(_) => bug!(\"MIR must not use `{:?}`\", ci),\n         };\n         Const { llval: llval, ty: ty }\n     }\n@@ -97,14 +96,13 @@ impl<'tcx> Const<'tcx> {\n         let val = match cv {\n             ConstVal::Float(F32(v)) => C_floating_f64(v as f64, llty),\n             ConstVal::Float(F64(v)) => C_floating_f64(v, llty),\n-            ConstVal::Float(FInfer {..}) => bug!(\"MIR must not use `{:?}`\", cv),\n             ConstVal::Bool(v) => C_bool(ccx, v),\n             ConstVal::Integral(ref i) => return Const::from_constint(ccx, i),\n             ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n             ConstVal::ByteStr(ref v) => consts::addr_of(ccx, C_bytes(ccx, v), 1, \"byte_str\"),\n             ConstVal::Struct(_) | ConstVal::Tuple(_) |\n             ConstVal::Array(..) | ConstVal::Repeat(..) |\n-            ConstVal::Function(_) => {\n+            ConstVal::Function(..) => {\n                 bug!(\"MIR must not use `{:?}` (which refers to a local ID)\", cv)\n             }\n             ConstVal::Char(c) => C_integral(Type::char(ccx), c as u64, false),\n@@ -249,7 +247,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     fn trans_def(ccx: &'a CrateContext<'a, 'tcx>,\n                  instance: Instance<'tcx>,\n                  args: IndexVec<mir::Local, Const<'tcx>>)\n-                 -> Result<Const<'tcx>, ConstEvalErr> {\n+                 -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n         let instance = instance.resolve_const(ccx.shared());\n         let mir = ccx.tcx().item_mir(instance.def);\n         MirConstContext::new(ccx, &mir, instance.substs, args).trans()\n@@ -263,7 +261,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                          value)\n     }\n \n-    fn trans(&mut self) -> Result<Const<'tcx>, ConstEvalErr> {\n+    fn trans(&mut self) -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n         let tcx = self.ccx.tcx();\n         let mut bb = mir::START_BLOCK;\n \n@@ -325,7 +323,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         };\n \n                         let err = ConstEvalErr{ span: span, kind: err };\n-                        report_const_eval_err(tcx, &err, span, \"expression\").emit();\n+                        report_const_eval_err(tcx, &err, span, \"expression\");\n                         failure = Err(err);\n                     }\n                     target\n@@ -373,7 +371,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     }\n \n     fn const_lvalue(&self, lvalue: &mir::Lvalue<'tcx>, span: Span)\n-                    -> Result<ConstLvalue<'tcx>, ConstEvalErr> {\n+                    -> Result<ConstLvalue<'tcx>, ConstEvalErr<'tcx>> {\n         let tcx = self.ccx.tcx();\n \n         if let mir::Lvalue::Local(index) = *lvalue {\n@@ -468,7 +466,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     }\n \n     fn const_operand(&self, operand: &mir::Operand<'tcx>, span: Span)\n-                     -> Result<Const<'tcx>, ConstEvalErr> {\n+                     -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n         debug!(\"const_operand({:?} @ {:?})\", operand, span);\n         let result = match *operand {\n             mir::Operand::Consume(ref lvalue) => {\n@@ -523,7 +521,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n     fn const_rvalue(&self, rvalue: &mir::Rvalue<'tcx>,\n                     dest_ty: Ty<'tcx>, span: Span)\n-                    -> Result<Const<'tcx>, ConstEvalErr> {\n+                    -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n         let tcx = self.ccx.tcx();\n         debug!(\"const_rvalue({:?}: {:?} @ {:?})\", rvalue, dest_ty, span);\n         let val = match *rvalue {\n@@ -588,7 +586,8 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                     .find(|it| it.kind == ty::AssociatedKind::Method)\n                                     .unwrap().def_id;\n                                 // Now create its substs [Closure, Tuple]\n-                                let input = tcx.closure_type(def_id, substs).sig.input(0);\n+                                let input = tcx.closure_type(def_id)\n+                                    .subst(tcx, substs.substs).input(0);\n                                 let substs = tcx.mk_substs([operand.ty, input.skip_binder()]\n                                     .iter().cloned().map(Kind::from));\n                                 Callee::def(self.ccx, call_once, substs)\n@@ -960,8 +959,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n }\n \n \n-pub fn trans_static_initializer(ccx: &CrateContext, def_id: DefId)\n-                                -> Result<ValueRef, ConstEvalErr> {\n+pub fn trans_static_initializer<'a, 'tcx>(\n+    ccx: &CrateContext<'a, 'tcx>,\n+    def_id: DefId)\n+    -> Result<ValueRef, ConstEvalErr<'tcx>>\n+{\n     let instance = Instance::mono(ccx.shared(), def_id);\n     MirConstContext::trans_def(ccx, instance, IndexVec::new()).map(|c| c.llval)\n }\n@@ -1001,7 +1003,7 @@ fn trans_const<'a, 'tcx>(\n         layout::CEnum { discr: d, min, max, .. } => {\n             let discr = match *kind {\n                 mir::AggregateKind::Adt(adt_def, _, _, _) => {\n-                    Disr::from(adt_def.variants[variant_index].disr_val)\n+                    Disr::for_variant(ccx.tcx(), adt_def, variant_index)\n                 },\n                 _ => Disr(0),\n             };"}, {"sha": "6419f41f86b6d3d93174ee41f412c6c89ebca9ee", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -28,7 +28,6 @@ use type_of;\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos, Span};\n use syntax::symbol::keywords;\n-use syntax::abi::Abi;\n \n use std::iter;\n \n@@ -205,15 +204,14 @@ impl<'tcx> LocalRef<'tcx> {\n pub fn trans_mir<'a, 'tcx: 'a>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n     llfn: ValueRef,\n-    fn_ty: FnType,\n     mir: &'a Mir<'tcx>,\n     instance: Instance<'tcx>,\n-    sig: &ty::FnSig<'tcx>,\n-    abi: Abi,\n+    sig: ty::FnSig<'tcx>,\n ) {\n+    let fn_ty = FnType::new(ccx, sig, &[]);\n     debug!(\"fn_ty: {:?}\", fn_ty);\n     let debug_context =\n-        debuginfo::create_function_debug_context(ccx, instance, sig, abi, llfn, mir);\n+        debuginfo::create_function_debug_context(ccx, instance, sig, llfn, mir);\n     let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n \n     let cleanup_kinds = analyze::cleanup_kinds(&mir);"}, {"sha": "037c771c97b066d52987a7248dcec1042afc1712", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -12,7 +12,7 @@ use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::layout::Layout;\n-use rustc::ty::subst::Kind;\n+use rustc::ty::subst::{Kind, Subst};\n use rustc::mir::tcx::LvalueTy;\n use rustc::mir;\n use middle::lang_items::ExchangeMallocFnLangItem;\n@@ -106,9 +106,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n                 match *kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, substs, active_field_index) => {\n-                        let disr = Disr::from(adt_def.variants[variant_index].disr_val);\n+                        let disr = Disr::for_variant(bcx.tcx(), adt_def, variant_index);\n                         let dest_ty = dest.ty.to_ty(bcx.tcx());\n-                        adt::trans_set_discr(&bcx, dest_ty, dest.llval, Disr::from(disr));\n+                        adt::trans_set_discr(&bcx, dest_ty, dest.llval, disr);\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields.\n@@ -119,7 +119,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 val.ty = LvalueTy::Downcast {\n                                     adt_def: adt_def,\n                                     substs: self.monomorphize(&substs),\n-                                    variant_index: disr.0 as usize,\n+                                    variant_index: variant_index,\n                                 };\n                                 let (lldest_i, align) = val.trans_field_ptr(&bcx, field_index);\n                                 self.store_operand(&bcx, lldest_i, align.to_align(), op);\n@@ -201,7 +201,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                     .find(|it| it.kind == ty::AssociatedKind::Method)\n                                     .unwrap().def_id;\n                                 // Now create its substs [Closure, Tuple]\n-                                let input = bcx.tcx().closure_type(def_id, substs).sig.input(0);\n+                                let input = bcx.tcx().closure_type(def_id)\n+                                    .subst(bcx.tcx(), substs.substs).input(0);\n                                 let substs = bcx.tcx().mk_substs([operand.ty, input.skip_binder()]\n                                     .iter().cloned().map(Kind::from));\n                                 OperandValue::Immediate("}, {"sha": "d691fa6aadf2ed3d1579dededff68533508ab3e0", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -199,11 +199,17 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         assert_eq!(dg.ty(), glue::get_drop_glue_type(ccx.shared(), dg.ty()));\n         let t = dg.ty();\n \n-        let sig = tcx.mk_fn_sig(iter::once(tcx.mk_mut_ptr(t)), tcx.mk_nil(), false);\n+        let sig = tcx.mk_fn_sig(\n+            iter::once(tcx.mk_mut_ptr(t)),\n+            tcx.mk_nil(),\n+            false,\n+            hir::Unsafety::Normal,\n+            Abi::Rust\n+        );\n \n         debug!(\"predefine_drop_glue: sig={}\", sig);\n \n-        let fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n+        let fn_ty = FnType::new(ccx, sig, &[]);\n         let llfnty = fn_ty.llvm_type(ccx);\n \n         assert!(declare::get_defined_value(ccx, symbol_name).is_none());\n@@ -457,12 +463,13 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                         output);\n                 }\n             },\n-            ty::TyFnDef(.., &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n-            ty::TyFnPtr(&ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n-                if unsafety == hir::Unsafety::Unsafe {\n+            ty::TyFnDef(.., sig) |\n+            ty::TyFnPtr(sig) => {\n+                if sig.unsafety() == hir::Unsafety::Unsafe {\n                     output.push_str(\"unsafe \");\n                 }\n \n+                let abi = sig.abi();\n                 if abi != ::abi::Abi::Rust {\n                     output.push_str(\"extern \\\"\");\n                     output.push_str(abi.name());\n@@ -471,7 +478,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n \n                 output.push_str(\"fn(\");\n \n-                let sig = self.tcx.erase_late_bound_regions_and_normalize(sig);\n+                let sig = self.tcx.erase_late_bound_regions_and_normalize(&sig);\n \n                 if !sig.inputs().is_empty() {\n                     for &parameter_type in sig.inputs() {"}, {"sha": "a5722e6e520d0140df8f482b768f55517aa31fcb", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -272,9 +272,9 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       ty::TyStr | ty::TyDynamic(..) => Type::i8(cx),\n \n       ty::TyFnDef(..) => Type::nil(cx),\n-      ty::TyFnPtr(f) => {\n-        let sig = cx.tcx().erase_late_bound_regions_and_normalize(&f.sig);\n-        FnType::new(cx, f.abi, &sig, &[]).llvm_type(cx).ptr_to()\n+      ty::TyFnPtr(sig) => {\n+        let sig = cx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+        FnType::new(cx, sig, &[]).llvm_type(cx).ptr_to()\n       }\n       ty::TyTuple(ref tys, _) if tys.is_empty() => Type::nil(cx),\n       ty::TyTuple(..) => {"}, {"sha": "577fe31eab02abff192e3125157610e9a95d5352", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 109, "deletions": 206, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -11,17 +11,6 @@\n //! Conversion from AST representation of types to the ty.rs\n //! representation.  The main routine here is `ast_ty_to_ty()`: each use\n //! is parameterized by an instance of `AstConv`.\n-//!\n-//! The parameterization of `ast_ty_to_ty()` is because it behaves\n-//! somewhat differently during the collect and check phases,\n-//! particularly with respect to looking up the types of top-level\n-//! items.  In the collect phase, the crate context is used as the\n-//! `AstConv` instance; in this phase, the `get_item_type()`\n-//! function triggers a recursive call to `type_of_item()`\n-//! (note that `ast_ty_to_ty()` will detect recursive types and report\n-//! an error).  In the check phase, when the FnCtxt is used as the\n-//! `AstConv`, `get_item_type()` just looks up the item type in\n-//! `tcx.types` (using `TyCtxt::item_type`).\n \n use rustc_const_eval::eval_length;\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n@@ -42,7 +31,7 @@ use std::cell::RefCell;\n use std::iter;\n use syntax::{abi, ast};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax::symbol::{Symbol, keywords};\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub trait AstConv<'gcx, 'tcx> {\n@@ -51,28 +40,10 @@ pub trait AstConv<'gcx, 'tcx> {\n     /// A cache used for the result of `ast_ty_to_ty_cache`\n     fn ast_ty_to_ty_cache(&self) -> &RefCell<NodeMap<Ty<'tcx>>>;\n \n-    /// Returns the generic type and lifetime parameters for an item.\n-    fn get_generics(&self, span: Span, id: DefId)\n-                    -> Result<&'tcx ty::Generics<'tcx>, ErrorReported>;\n-\n-    /// Identify the type for an item, like a type alias, fn, or struct.\n-    fn get_item_type(&self, span: Span, id: DefId) -> Result<Ty<'tcx>, ErrorReported>;\n-\n-    /// Returns the `TraitDef` for a given trait. This allows you to\n-    /// figure out the set of type parameters defined on the trait.\n-    fn get_trait_def(&self, span: Span, id: DefId)\n-                     -> Result<&'tcx ty::TraitDef, ErrorReported>;\n-\n-    /// Ensure that the super-predicates for the trait with the given\n-    /// id are available and also for the transitive set of\n-    /// super-predicates.\n-    fn ensure_super_predicates(&self, span: Span, id: DefId)\n-                               -> Result<(), ErrorReported>;\n-\n     /// Returns the set of bounds in scope for the type parameter with\n     /// the given id.\n-    fn get_type_parameter_bounds(&self, span: Span, def_id: ast::NodeId)\n-                                 -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>;\n+    fn get_type_parameter_bounds(&self, span: Span, def_id: DefId)\n+                                 -> ty::GenericPredicates<'tcx>;\n \n     /// Return an (optional) substitution to convert bound type parameters that\n     /// are in scope into free ones. This function should only return Some\n@@ -89,7 +60,7 @@ pub trait AstConv<'gcx, 'tcx> {\n \n     /// Same as ty_infer, but with a known type parameter definition.\n     fn ty_infer_for_def(&self,\n-                        _def: &ty::TypeParameterDef<'tcx>,\n+                        _def: &ty::TypeParameterDef,\n                         _substs: &[Kind<'tcx>],\n                         span: Span) -> Ty<'tcx> {\n         self.ty_infer(span)\n@@ -218,7 +189,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                             &item_segment.parameters,\n                                             None);\n \n-        assoc_bindings.first().map(|b| self.tcx().prohibit_projection(b.span));\n+        assoc_bindings.first().map(|b| self.prohibit_projection(b.span));\n \n         substs\n     }\n@@ -251,14 +222,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n-        let decl_generics = match self.get_generics(span, def_id) {\n-            Ok(generics) => generics,\n-            Err(ErrorReported) => {\n-                // No convenient way to recover from a cycle here. Just bail. Sorry!\n-                self.tcx().sess.abort_if_errors();\n-                bug!(\"ErrorReported returned, but no errors reports?\")\n-            }\n-        };\n+        let decl_generics = tcx.item_generics(def_id);\n         let expected_num_region_params = decl_generics.regions.len();\n         let supplied_num_region_params = lifetimes.len();\n         if expected_num_region_params != supplied_num_region_params {\n@@ -277,9 +241,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n \n         let is_object = self_ty.map_or(false, |ty| ty.sty == TRAIT_OBJECT_DUMMY_SELF);\n-        let default_needs_object_self = |p: &ty::TypeParameterDef<'tcx>| {\n-            if let Some(ref default) = p.default {\n-                if is_object && default.has_self_ty() {\n+        let default_needs_object_self = |p: &ty::TypeParameterDef| {\n+            if is_object && p.has_default {\n+                if ty::queries::ty::get(tcx, span, p.def_id).has_self_ty() {\n                     // There is no suitable inference default for a type parameter\n                     // that references self, in an object type.\n                     return true;\n@@ -327,7 +291,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     self.ty_infer(span)\n                 };\n                 ty_var\n-            } else if let Some(default) = def.default {\n+            } else if def.has_default {\n                 // No type parameter provided, but a default exists.\n \n                 // If we are converting an object type, then the\n@@ -346,7 +310,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     tcx.types.err\n                 } else {\n                     // This is a default type parameter.\n-                    default.subst_spanned(tcx, substs, Some(span))\n+                    ty::queries::ty::get(tcx, span, def.def_id)\n+                        .subst_spanned(tcx, substs, Some(span))\n                 }\n             } else {\n                 // We've already errored above about the mismatch.\n@@ -481,7 +446,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                  trait_def_id,\n                                                  self_ty,\n                                                  trait_segment);\n-        assoc_bindings.first().map(|b| self.tcx().prohibit_projection(b.span));\n+        assoc_bindings.first().map(|b| self.prohibit_projection(b.span));\n         ty::TraitRef::new(trait_def_id, substs)\n     }\n \n@@ -495,14 +460,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\",\n                trait_segment);\n \n-        let trait_def = match self.get_trait_def(span, trait_def_id) {\n-            Ok(trait_def) => trait_def,\n-            Err(ErrorReported) => {\n-                // No convenient way to recover from a cycle here. Just bail. Sorry!\n-                self.tcx().sess.abort_if_errors();\n-                bug!(\"ErrorReported returned, but no errors reports?\")\n-            }\n-        };\n+        let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n \n         match trait_segment.parameters {\n             hir::AngleBracketedParameters(_) => {\n@@ -615,8 +573,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         // Otherwise, we have to walk through the supertraits to find\n         // those that do.\n-        self.ensure_super_predicates(binding.span, trait_ref.def_id())?;\n-\n         let candidates =\n             traits::supertraits(tcx, trait_ref.clone())\n             .filter(|r| self.trait_defines_associated_type_named(r.def_id(), binding.item_name));\n@@ -643,16 +599,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         item_segment: &hir::PathSegment)\n         -> Ty<'tcx>\n     {\n-        let tcx = self.tcx();\n-        let decl_ty = match self.get_item_type(span, did) {\n-            Ok(ty) => ty,\n-            Err(ErrorReported) => {\n-                return tcx.types.err;\n-            }\n-        };\n-\n         let substs = self.ast_path_substs_for_ty(span, did, item_segment);\n-        decl_ty.subst(self.tcx(), substs)\n+        ty::queries::ty::get(self.tcx(), span, did).subst(self.tcx(), substs)\n     }\n \n     /// Transform a PolyTraitRef into a PolyExistentialTraitRef by\n@@ -709,11 +657,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             })\n         });\n \n-        // ensure the super predicates and stop if we encountered an error\n-        if self.ensure_super_predicates(span, principal.def_id()).is_err() {\n-            return tcx.types.err;\n-        }\n-\n         // check that there are no gross object safety violations,\n         // most importantly, that the supertraits don't contain Self,\n         // to avoid ICE-s.\n@@ -798,39 +741,30 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n \n     // Search for a bound on a type parameter which includes the associated item\n-    // given by assoc_name. ty_param_node_id is the node id for the type parameter\n-    // (which might be `Self`, but only if it is the `Self` of a trait, not an\n-    // impl). This function will fail if there are no suitable bounds or there is\n+    // given by `assoc_name`. `ty_param_def_id` is the `DefId` for the type parameter\n+    // This function will fail if there are no suitable bounds or there is\n     // any ambiguity.\n     fn find_bound_for_assoc_item(&self,\n-                                 ty_param_node_id: ast::NodeId,\n-                                 ty_param_name: ast::Name,\n+                                 ty_param_def_id: DefId,\n                                  assoc_name: ast::Name,\n                                  span: Span)\n                                  -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n     {\n         let tcx = self.tcx();\n \n-        let bounds = match self.get_type_parameter_bounds(span, ty_param_node_id) {\n-            Ok(v) => v,\n-            Err(ErrorReported) => {\n-                return Err(ErrorReported);\n-            }\n-        };\n-\n-        // Ensure the super predicates and stop if we encountered an error.\n-        if bounds.iter().any(|b| self.ensure_super_predicates(span, b.def_id()).is_err()) {\n-            return Err(ErrorReported);\n-        }\n+        let bounds: Vec<_> = self.get_type_parameter_bounds(span, ty_param_def_id)\n+            .predicates.into_iter().filter_map(|p| p.to_opt_poly_trait_ref()).collect();\n \n         // Check that there is exactly one way to find an associated type with the\n         // correct name.\n         let suitable_bounds =\n             traits::transitive_bounds(tcx, &bounds)\n             .filter(|b| self.trait_defines_associated_type_named(b.def_id(), assoc_name));\n \n+        let param_node_id = tcx.hir.as_local_node_id(ty_param_def_id).unwrap();\n+        let param_name = tcx.hir.ty_param_name(param_node_id);\n         self.one_bound_for_assoc_type(suitable_bounds,\n-                                      &ty_param_name.as_str(),\n+                                      &param_name.as_str(),\n                                       &assoc_name.as_str(),\n                                       span)\n     }\n@@ -910,37 +844,28 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         debug!(\"associated_path_def_to_ty: {:?}::{}\", ty, assoc_name);\n \n-        tcx.prohibit_type_params(slice::ref_slice(item_segment));\n+        self.prohibit_type_params(slice::ref_slice(item_segment));\n \n         // Find the type of the associated item, and the trait where the associated\n         // item is declared.\n         let bound = match (&ty.sty, ty_path_def) {\n             (_, Def::SelfTy(Some(_), Some(impl_def_id))) => {\n                 // `Self` in an impl of a trait - we have a concrete self type and a\n                 // trait reference.\n-                // FIXME: Self type is not always computed when we are here because type parameter\n-                // bounds may affect Self type and have to be converted before it.\n-                let trait_ref = if impl_def_id.is_local() {\n-                    tcx.impl_trait_refs.borrow().get(&impl_def_id).cloned().and_then(|x| x)\n-                } else {\n-                    tcx.impl_trait_ref(impl_def_id)\n-                };\n-                let trait_ref = if let Some(trait_ref) = trait_ref {\n-                    trait_ref\n-                } else {\n-                    tcx.sess.span_err(span, \"`Self` type is used before it's determined\");\n-                    return (tcx.types.err, Def::Err);\n+                let trait_ref = match tcx.impl_trait_ref(impl_def_id) {\n+                    Some(trait_ref) => trait_ref,\n+                    None => {\n+                        // A cycle error occurred, most likely.\n+                        return (tcx.types.err, Def::Err);\n+                    }\n                 };\n+\n                 let trait_ref = if let Some(free_substs) = self.get_free_substs() {\n                     trait_ref.subst(tcx, free_substs)\n                 } else {\n                     trait_ref\n                 };\n \n-                if self.ensure_super_predicates(span, trait_ref.def_id).is_err() {\n-                    return (tcx.types.err, Def::Err);\n-                }\n-\n                 let candidates =\n                     traits::supertraits(tcx, ty::Binder(trait_ref))\n                     .filter(|r| self.trait_defines_associated_type_named(r.def_id(),\n@@ -954,23 +879,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     Err(ErrorReported) => return (tcx.types.err, Def::Err),\n                 }\n             }\n-            (&ty::TyParam(_), Def::SelfTy(Some(trait_did), None)) => {\n-                let trait_node_id = tcx.hir.as_local_node_id(trait_did).unwrap();\n-                match self.find_bound_for_assoc_item(trait_node_id,\n-                                                     keywords::SelfType.name(),\n-                                                     assoc_name,\n-                                                     span) {\n-                    Ok(bound) => bound,\n-                    Err(ErrorReported) => return (tcx.types.err, Def::Err),\n-                }\n-            }\n+            (&ty::TyParam(_), Def::SelfTy(Some(param_did), None)) |\n             (&ty::TyParam(_), Def::TyParam(param_did)) => {\n-                let param_node_id = tcx.hir.as_local_node_id(param_did).unwrap();\n-                let param_name = tcx.type_parameter_def(param_node_id).name;\n-                match self.find_bound_for_assoc_item(param_node_id,\n-                                                     param_name,\n-                                                     assoc_name,\n-                                                     span) {\n+                match self.find_bound_for_assoc_item(param_did, assoc_name, span) {\n                     Ok(bound) => bound,\n                     Err(ErrorReported) => return (tcx.types.err, Def::Err),\n                 }\n@@ -1006,7 +917,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     {\n         let tcx = self.tcx();\n \n-        tcx.prohibit_type_params(slice::ref_slice(item_segment));\n+        self.prohibit_type_params(slice::ref_slice(item_segment));\n \n         let self_ty = if let Some(ty) = opt_self_ty {\n             ty\n@@ -1031,6 +942,36 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         self.projected_ty(span, trait_ref, item_segment.name)\n     }\n \n+    pub fn prohibit_type_params(&self, segments: &[hir::PathSegment]) {\n+        for segment in segments {\n+            for typ in segment.parameters.types() {\n+                struct_span_err!(self.tcx().sess, typ.span, E0109,\n+                                 \"type parameters are not allowed on this type\")\n+                    .span_label(typ.span, &format!(\"type parameter not allowed\"))\n+                    .emit();\n+                break;\n+            }\n+            for lifetime in segment.parameters.lifetimes() {\n+                struct_span_err!(self.tcx().sess, lifetime.span, E0110,\n+                                 \"lifetime parameters are not allowed on this type\")\n+                    .span_label(lifetime.span,\n+                                &format!(\"lifetime parameter not allowed on this type\"))\n+                    .emit();\n+                break;\n+            }\n+            for binding in segment.parameters.bindings() {\n+                self.prohibit_projection(binding.span);\n+                break;\n+            }\n+        }\n+    }\n+\n+    pub fn prohibit_projection(&self, span: Span) {\n+        let mut err = struct_span_err!(self.tcx().sess, span, E0229,\n+                                       \"associated type bindings are not allowed here\");\n+        err.span_label(span, &format!(\"associate type not allowed here\")).emit();\n+    }\n+\n     // Check a type Path and convert it to a Ty.\n     pub fn def_to_ty(&self,\n                      opt_self_ty: Option<Ty<'tcx>>,\n@@ -1046,71 +987,50 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         match path.def {\n             Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) | Def::Union(did) => {\n                 assert_eq!(opt_self_ty, None);\n-                tcx.prohibit_type_params(path.segments.split_last().unwrap().1);\n+                self.prohibit_type_params(path.segments.split_last().unwrap().1);\n                 self.ast_path_to_ty(span, did, path.segments.last().unwrap())\n             }\n             Def::Variant(did) if permit_variants => {\n                 // Convert \"variant type\" as if it were a real type.\n                 // The resulting `Ty` is type of the variant's enum for now.\n                 assert_eq!(opt_self_ty, None);\n-                tcx.prohibit_type_params(path.segments.split_last().unwrap().1);\n+                self.prohibit_type_params(path.segments.split_last().unwrap().1);\n                 self.ast_path_to_ty(span,\n                                     tcx.parent_def_id(did).unwrap(),\n                                     path.segments.last().unwrap())\n             }\n             Def::TyParam(did) => {\n                 assert_eq!(opt_self_ty, None);\n-                tcx.prohibit_type_params(&path.segments);\n+                self.prohibit_type_params(&path.segments);\n \n                 let node_id = tcx.hir.as_local_node_id(did).unwrap();\n-                let param = tcx.ty_param_defs.borrow().get(&node_id)\n-                               .map(ty::ParamTy::for_def);\n-                if let Some(p) = param {\n-                    p.to_ty(tcx)\n-                } else {\n-                    // Only while computing defaults of earlier type\n-                    // parameters can a type parameter be missing its def.\n-                    struct_span_err!(tcx.sess, span, E0128,\n-                                     \"type parameters with a default cannot use \\\n-                                      forward declared identifiers\")\n-                        .span_label(span, &format!(\"defaulted type parameters \\\n-                                                    cannot be forward declared\"))\n-                        .emit();\n-                    tcx.types.err\n-                }\n+                let item_id = tcx.hir.get_parent_node(node_id);\n+                let item_def_id = tcx.hir.local_def_id(item_id);\n+                let generics = tcx.item_generics(item_def_id);\n+                let index = generics.type_param_to_index[&tcx.hir.local_def_id(node_id).index];\n+                tcx.mk_param(index, tcx.hir.name(node_id))\n             }\n             Def::SelfTy(_, Some(def_id)) => {\n                 // Self in impl (we know the concrete type).\n \n                 assert_eq!(opt_self_ty, None);\n-                tcx.prohibit_type_params(&path.segments);\n+                self.prohibit_type_params(&path.segments);\n \n-                // FIXME: Self type is not always computed when we are here because type parameter\n-                // bounds may affect Self type and have to be converted before it.\n-                let ty = if def_id.is_local() {\n-                    tcx.item_types.borrow().get(&def_id).cloned()\n+                let ty = ty::queries::ty::get(tcx, span, def_id);\n+                if let Some(free_substs) = self.get_free_substs() {\n+                    ty.subst(tcx, free_substs)\n                 } else {\n-                    Some(tcx.item_type(def_id))\n-                };\n-                if let Some(ty) = ty {\n-                    if let Some(free_substs) = self.get_free_substs() {\n-                        ty.subst(tcx, free_substs)\n-                    } else {\n-                        ty\n-                    }\n-                } else {\n-                    tcx.sess.span_err(span, \"`Self` type is used before it's determined\");\n-                    tcx.types.err\n+                    ty\n                 }\n             }\n             Def::SelfTy(Some(_), None) => {\n                 // Self in trait.\n                 assert_eq!(opt_self_ty, None);\n-                tcx.prohibit_type_params(&path.segments);\n+                self.prohibit_type_params(&path.segments);\n                 tcx.mk_self_type()\n             }\n             Def::AssociatedTy(def_id) => {\n-                tcx.prohibit_type_params(&path.segments[..path.segments.len()-2]);\n+                self.prohibit_type_params(&path.segments[..path.segments.len()-2]);\n                 let trait_did = tcx.parent_def_id(def_id).unwrap();\n                 self.qpath_to_ty(span,\n                                  opt_self_ty,\n@@ -1120,7 +1040,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             Def::PrimTy(prim_ty) => {\n                 assert_eq!(opt_self_ty, None);\n-                tcx.prim_ty_to_ty(&path.segments, prim_ty)\n+                self.prohibit_type_params(&path.segments);\n+                match prim_ty {\n+                    hir::TyBool => tcx.types.bool,\n+                    hir::TyChar => tcx.types.char,\n+                    hir::TyInt(it) => tcx.mk_mach_int(it),\n+                    hir::TyUint(uit) => tcx.mk_mach_uint(uit),\n+                    hir::TyFloat(ft) => tcx.mk_mach_float(ft),\n+                    hir::TyStr => tcx.mk_str()\n+                }\n             }\n             Def::Err => {\n                 self.set_tainted_by_errors();\n@@ -1183,10 +1111,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // warning then. (Once we fix #32330, the regions we are\n                 // checking for here would be considered early bound\n                 // anyway.)\n-                let inputs = bare_fn_ty.sig.inputs();\n+                let inputs = bare_fn_ty.inputs();\n                 let late_bound_in_args = tcx.collect_constrained_late_bound_regions(\n                     &inputs.map_bound(|i| i.to_owned()));\n-                let output = bare_fn_ty.sig.output();\n+                let output = bare_fn_ty.output();\n                 let late_bound_in_ret = tcx.collect_referenced_late_bound_regions(&output);\n                 for br in late_bound_in_ret.difference(&late_bound_in_args) {\n                     let br_name = match *br {\n@@ -1211,9 +1139,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyTraitObject(ref bounds, ref lifetime) => {\n                 self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime)\n             }\n-            hir::TyImplTrait(ref bounds) => {\n-                use collect::{compute_bounds, SizedByDefault};\n-\n+            hir::TyImplTrait(_) => {\n                 // Figure out if we can allow an `impl Trait` here, by walking up\n                 // to a `fn` or inherent `impl` method, going only through `Ty`\n                 // or `TraitRef` nodes (as nothing else should be in types) and\n@@ -1253,24 +1179,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // Create the anonymized type.\n                 if allow {\n                     let def_id = tcx.hir.local_def_id(ast_ty.id);\n-                    if let Err(ErrorReported) = self.get_generics(ast_ty.span, def_id) {\n-                        return tcx.types.err;\n-                    }\n-                    let substs = Substs::identity_for_item(tcx, def_id);\n-                    let ty = tcx.mk_anon(tcx.hir.local_def_id(ast_ty.id), substs);\n-\n-                    // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n-                    let bounds = compute_bounds(self, ty, bounds,\n-                                                SizedByDefault::Yes,\n-                                                ast_ty.span);\n-                    let predicates = bounds.predicates(tcx, ty);\n-                    let predicates = tcx.lift_to_global(&predicates).unwrap();\n-                    tcx.predicates.borrow_mut().insert(def_id, ty::GenericPredicates {\n-                        parent: None,\n-                        predicates: predicates\n-                    });\n-\n-                    ty\n+                    tcx.mk_anon(def_id, Substs::identity_for_item(tcx, def_id))\n                 } else {\n                     span_err!(tcx.sess, ast_ty.span, E0562,\n                               \"`impl Trait` not allowed outside of function \\\n@@ -1341,7 +1250,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     unsafety: hir::Unsafety,\n                     abi: abi::Abi,\n                     decl: &hir::FnDecl)\n-                    -> &'tcx ty::BareFnTy<'tcx> {\n+                    -> ty::PolyFnSig<'tcx> {\n         debug!(\"ty_of_fn\");\n \n         let input_tys: Vec<Ty> =\n@@ -1354,23 +1263,21 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         debug!(\"ty_of_fn: output_ty={:?}\", output_ty);\n \n-        self.tcx().mk_bare_fn(ty::BareFnTy {\n-            unsafety: unsafety,\n-            abi: abi,\n-            sig: ty::Binder(self.tcx().mk_fn_sig(\n-                input_tys.into_iter(),\n-                output_ty,\n-                decl.variadic\n-            )),\n-        })\n+        ty::Binder(self.tcx().mk_fn_sig(\n+            input_tys.into_iter(),\n+            output_ty,\n+            decl.variadic,\n+            unsafety,\n+            abi\n+        ))\n     }\n \n     pub fn ty_of_closure(&self,\n         unsafety: hir::Unsafety,\n         decl: &hir::FnDecl,\n         abi: abi::Abi,\n         expected_sig: Option<ty::FnSig<'tcx>>)\n-        -> ty::ClosureTy<'tcx>\n+        -> ty::PolyFnSig<'tcx>\n     {\n         debug!(\"ty_of_closure(expected_sig={:?})\",\n                expected_sig);\n@@ -1407,11 +1314,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         debug!(\"ty_of_closure: output_ty={:?}\", output_ty);\n \n-        ty::ClosureTy {\n-            unsafety: unsafety,\n-            abi: abi,\n-            sig: ty::Binder(self.tcx().mk_fn_sig(input_tys, output_ty, decl.variadic)),\n-        }\n+        ty::Binder(self.tcx().mk_fn_sig(\n+            input_tys,\n+            output_ty,\n+            decl.variadic,\n+            unsafety,\n+            abi\n+        ))\n     }\n \n     /// Given the bounds on an object, determines what single region bound (if any) we can\n@@ -1429,12 +1338,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         debug!(\"compute_opt_region_bound(existential_predicates={:?})\",\n                existential_predicates);\n \n-        if let Some(principal) = existential_predicates.principal() {\n-            if let Err(ErrorReported) = self.ensure_super_predicates(span, principal.def_id()) {\n-                return Some(tcx.mk_region(ty::ReStatic));\n-            }\n-        }\n-\n         // No explicit region bound specified. Therefore, examine trait\n         // bounds and see if we can derive region bounds from those.\n         let derived_region_bounds =\n@@ -1510,7 +1413,7 @@ fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n fn check_type_argument_count(tcx: TyCtxt, span: Span, supplied: usize,\n                              ty_param_defs: &[ty::TypeParameterDef]) {\n     let accepted = ty_param_defs.len();\n-    let required = ty_param_defs.iter().take_while(|x| x.default.is_none()) .count();\n+    let required = ty_param_defs.iter().take_while(|x| !x.has_default).count();\n     if supplied < required {\n         let expected = if required < accepted {\n             \"expected at least\""}, {"sha": "4b88f5acf42da2415ea3442fec3c06440ef307b2", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -10,11 +10,12 @@\n \n use super::{DeferredCallResolution, Expectation, FnCtxt, TupleArgumentsFlag};\n \n-use CrateCtxt;\n use hir::def::Def;\n use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::{infer, traits};\n-use rustc::ty::{self, LvaluePreference, Ty};\n+use rustc::ty::{self, TyCtxt, LvaluePreference, Ty};\n+use rustc::ty::subst::Subst;\n+use syntax::abi;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n@@ -23,12 +24,9 @@ use rustc::hir;\n /// Check that it is legal to call methods of the trait corresponding\n /// to `trait_id` (this only cares about the trait, not the specific\n /// method that is called)\n-pub fn check_legal_trait_for_method_call(ccx: &CrateCtxt, span: Span, trait_id: DefId) {\n-    if ccx.tcx.lang_items.drop_trait() == Some(trait_id) {\n-        struct_span_err!(ccx.tcx.sess,\n-                         span,\n-                         E0040,\n-                         \"explicit use of destructor method\")\n+pub fn check_legal_trait_for_method_call(tcx: TyCtxt, span: Span, trait_id: DefId) {\n+    if tcx.lang_items.drop_trait() == Some(trait_id) {\n+        struct_span_err!(tcx.sess, span, E0040, \"explicit use of destructor method\")\n             .span_label(span, &format!(\"explicit destructor calls not allowed\"))\n             .emit();\n     }\n@@ -113,10 +111,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // haven't yet decided on whether the closure is fn vs\n                 // fnmut vs fnonce. If so, we have to defer further processing.\n                 if self.closure_kind(def_id).is_none() {\n-                    let closure_ty = self.closure_type(def_id, substs);\n+                    let closure_ty = self.closure_type(def_id).subst(self.tcx, substs.substs);\n                     let fn_sig = self.replace_late_bound_regions_with_fresh_var(call_expr.span,\n                                                                    infer::FnCall,\n-                                                                   &closure_ty.sig)\n+                                                                   &closure_ty)\n                         .0;\n                     self.record_deferred_call_resolution(def_id,\n                                                          Box::new(CallResolution {\n@@ -190,13 +188,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             arg_exprs: &'gcx [hir::Expr],\n                             expected: Expectation<'tcx>)\n                             -> Ty<'tcx> {\n-        let error_fn_sig;\n-\n         let (fn_sig, def_span) = match callee_ty.sty {\n-            ty::TyFnDef(def_id, .., &ty::BareFnTy {ref sig, ..}) => {\n+            ty::TyFnDef(def_id, .., sig) => {\n                 (sig, self.tcx.hir.span_if_local(def_id))\n             }\n-            ty::TyFnPtr(&ty::BareFnTy {ref sig, ..}) => (sig, None),\n+            ty::TyFnPtr(sig) => (sig, None),\n             ref t => {\n                 let mut unit_variant = None;\n                 if let &ty::TyAdt(adt_def, ..) = t {\n@@ -236,13 +232,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // This is the \"default\" function signature, used in case of error.\n                 // In that case, we check each argument against \"error\" in order to\n                 // set up all the node type bindings.\n-                error_fn_sig = ty::Binder(self.tcx.mk_fn_sig(\n+                (ty::Binder(self.tcx.mk_fn_sig(\n                     self.err_args(arg_exprs.len()).into_iter(),\n                     self.tcx.types.err,\n                     false,\n-                ));\n-\n-                (&error_fn_sig, None)\n+                    hir::Unsafety::Normal,\n+                    abi::Abi::Rust\n+                )), None)\n             }\n         };\n \n@@ -252,7 +248,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // previously appeared within a `Binder<>` and hence would not\n         // have been normalized before.\n         let fn_sig =\n-            self.replace_late_bound_regions_with_fresh_var(call_expr.span, infer::FnCall, fn_sig)\n+            self.replace_late_bound_regions_with_fresh_var(call_expr.span, infer::FnCall, &fn_sig)\n                 .0;\n         let fn_sig = self.normalize_associated_types_in(call_expr.span, &fn_sig);\n \n@@ -359,7 +355,7 @@ impl<'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> for CallResolution<'gcx, 'tc\n                 // (This always bites me, should find a way to\n                 // refactor it.)\n                 let method_sig = fcx.tcx\n-                    .no_late_bound_regions(method_callee.ty.fn_sig())\n+                    .no_late_bound_regions(&method_callee.ty.fn_sig())\n                     .unwrap();\n \n                 debug!(\"attempt_resolution: method_callee={:?}\", method_callee);"}, {"sha": "51fbc5aab6cd1510a87654b0f349967df668e050", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -55,11 +55,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                expected_sig);\n \n         let expr_def_id = self.tcx.hir.local_def_id(expr.id);\n-        let mut fn_ty = AstConv::ty_of_closure(self,\n-                                               hir::Unsafety::Normal,\n-                                               decl,\n-                                               Abi::RustCall,\n-                                               expected_sig);\n+        let sig = AstConv::ty_of_closure(self,\n+                                         hir::Unsafety::Normal,\n+                                         decl,\n+                                         Abi::RustCall,\n+                                         expected_sig);\n \n         // Create type variables (for now) to represent the transformed\n         // types of upvars. These will be unified during the upvar\n@@ -74,32 +74,28 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"check_closure: expr.id={:?} closure_type={:?}\", expr.id, closure_type);\n \n         let extent = self.tcx.region_maps.call_site_extent(expr.id, body.value.id);\n-        let fn_sig = self.tcx.liberate_late_bound_regions(extent, &fn_ty.sig);\n+        let fn_sig = self.tcx.liberate_late_bound_regions(extent, &sig);\n         let fn_sig = self.inh.normalize_associated_types_in(body.value.span,\n                                                             body.value.id, &fn_sig);\n \n-        check_fn(self,\n-                 hir::Unsafety::Normal,\n-                 expr.id,\n-                 &fn_sig,\n-                 decl,\n-                 expr.id,\n-                 body);\n+        check_fn(self, fn_sig, decl, expr.id, body);\n \n         // Tuple up the arguments and insert the resulting function type into\n         // the `closures` table.\n-        fn_ty.sig.0 = self.tcx.mk_fn_sig(\n-            iter::once(self.tcx.intern_tup(fn_ty.sig.skip_binder().inputs(), false)),\n-            fn_ty.sig.skip_binder().output(),\n-            fn_ty.sig.variadic()\n-        );\n+        let sig = sig.map_bound(|sig| self.tcx.mk_fn_sig(\n+            iter::once(self.tcx.intern_tup(sig.inputs(), false)),\n+            sig.output(),\n+            sig.variadic,\n+            sig.unsafety,\n+            sig.abi\n+        ));\n \n         debug!(\"closure for {:?} --> sig={:?} opt_kind={:?}\",\n                expr_def_id,\n-               fn_ty.sig,\n+               sig,\n                opt_kind);\n \n-        self.tables.borrow_mut().closure_tys.insert(expr.id, fn_ty);\n+        self.tables.borrow_mut().closure_tys.insert(expr.id, sig);\n         match opt_kind {\n             Some(kind) => {\n                 self.tables.borrow_mut().closure_kinds.insert(expr.id, kind);\n@@ -228,7 +224,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let ret_param_ty = self.resolve_type_vars_if_possible(&ret_param_ty);\n         debug!(\"deduce_sig_from_projection: ret_param_ty {:?}\", ret_param_ty);\n \n-        let fn_sig = self.tcx.mk_fn_sig(input_tys.cloned(), ret_param_ty, false);\n+        let fn_sig = self.tcx.mk_fn_sig(\n+            input_tys.cloned(),\n+            ret_param_ty,\n+            false,\n+            hir::Unsafety::Normal,\n+            Abi::Rust\n+        );\n         debug!(\"deduce_sig_from_projection: fn_sig {:?}\", fn_sig);\n \n         Some(fn_sig)"}, {"sha": "53759cc115d1cb69039a9473cdb2fc04c5b1446b", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -72,6 +72,7 @@ use rustc::ty::{self, LvaluePreference, TypeAndMut,\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n use rustc::ty::relate::RelateResult;\n+use rustc::ty::subst::Subst;\n use syntax::abi;\n use syntax::feature_gate;\n use util::common::indent;\n@@ -507,11 +508,11 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n     fn coerce_from_safe_fn(&self,\n                            a: Ty<'tcx>,\n-                           fn_ty_a: &'tcx ty::BareFnTy<'tcx>,\n+                           fn_ty_a: ty::PolyFnSig<'tcx>,\n                            b: Ty<'tcx>)\n                            -> CoerceResult<'tcx> {\n         if let ty::TyFnPtr(fn_ty_b) = b.sty {\n-            match (fn_ty_a.unsafety, fn_ty_b.unsafety) {\n+            match (fn_ty_a.unsafety(), fn_ty_b.unsafety()) {\n                 (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n                     let unsafe_a = self.tcx.safe_to_unsafe_fn_ty(fn_ty_a);\n                     return self.unify_and_identity(unsafe_a, b)\n@@ -525,7 +526,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n     fn coerce_from_fn_pointer(&self,\n                               a: Ty<'tcx>,\n-                              fn_ty_a: &'tcx ty::BareFnTy<'tcx>,\n+                              fn_ty_a: ty::PolyFnSig<'tcx>,\n                               b: Ty<'tcx>)\n                               -> CoerceResult<'tcx> {\n         //! Attempts to coerce from the type of a Rust function item\n@@ -540,7 +541,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n     fn coerce_from_fn_item(&self,\n                            a: Ty<'tcx>,\n-                           fn_ty_a: &'tcx ty::BareFnTy<'tcx>,\n+                           fn_ty_a: ty::PolyFnSig<'tcx>,\n                            b: Ty<'tcx>)\n                            -> CoerceResult<'tcx> {\n         //! Attempts to coerce from the type of a Rust function item\n@@ -587,24 +588,23 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n                 // to\n                 //     `fn(arg0,arg1,...) -> _`\n-                let sig = self.closure_type(def_id_a, substs_a).sig;\n+                let sig = self.closure_type(def_id_a).subst(self.tcx, substs_a.substs);\n                 let converted_sig = sig.map_bound(|s| {\n                     let params_iter = match s.inputs()[0].sty {\n                         ty::TyTuple(params, _) => {\n                             params.into_iter().cloned()\n                         }\n                         _ => bug!(),\n                     };\n-                    self.tcx.mk_fn_sig(params_iter,\n-                                       s.output(),\n-                                       s.variadic)\n+                    self.tcx.mk_fn_sig(\n+                        params_iter,\n+                        s.output(),\n+                        s.variadic,\n+                        hir::Unsafety::Normal,\n+                        abi::Abi::Rust\n+                    )\n                 });\n-                let fn_ty = self.tcx.mk_bare_fn(ty::BareFnTy {\n-                    unsafety: hir::Unsafety::Normal,\n-                    abi: abi::Abi::Rust,\n-                    sig: converted_sig,\n-                });\n-                let pointer_ty = self.tcx.mk_fn_ptr(&fn_ty);\n+                let pointer_ty = self.tcx.mk_fn_ptr(converted_sig);\n                 debug!(\"coerce_closure_to_fn(a={:?}, b={:?}, pty={:?})\",\n                        a, b, pointer_ty);\n                 self.unify_and_identity(pointer_ty, b)"}, {"sha": "0e9abaf1cf955e86c272e91acc882fcccbfcedb6", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 26, "deletions": 43, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -11,7 +11,7 @@\n use rustc::hir::{self, ImplItemKind, TraitItemKind};\n use rustc::infer::{self, InferOk};\n use rustc::middle::free_region::FreeRegionMap;\n-use rustc::ty;\n+use rustc::ty::{self, TyCtxt};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::error::{ExpectedFound, TypeError};\n use rustc::ty::subst::{Subst, Substs};\n@@ -20,7 +20,6 @@ use rustc::util::common::ErrorReported;\n use syntax::ast;\n use syntax_pos::Span;\n \n-use CrateCtxt;\n use super::assoc;\n use super::{Inherited, FnCtxt};\n use astconv::ExplicitSelf;\n@@ -36,7 +35,7 @@ use astconv::ExplicitSelf;\n /// - trait_m: the method in the trait\n /// - impl_trait_ref: the TraitRef corresponding to the trait implementation\n \n-pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+pub fn compare_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      impl_m: &ty::AssociatedItem,\n                                      impl_m_span: Span,\n                                      impl_m_body_id: ast::NodeId,\n@@ -47,31 +46,31 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     debug!(\"compare_impl_method(impl_trait_ref={:?})\",\n            impl_trait_ref);\n \n-    if let Err(ErrorReported) = compare_self_type(ccx,\n+    if let Err(ErrorReported) = compare_self_type(tcx,\n                                                   impl_m,\n                                                   impl_m_span,\n                                                   trait_m,\n                                                   impl_trait_ref) {\n         return;\n     }\n \n-    if let Err(ErrorReported) = compare_number_of_generics(ccx,\n+    if let Err(ErrorReported) = compare_number_of_generics(tcx,\n                                                            impl_m,\n                                                            impl_m_span,\n                                                            trait_m,\n                                                            trait_item_span) {\n         return;\n     }\n \n-    if let Err(ErrorReported) = compare_number_of_method_arguments(ccx,\n+    if let Err(ErrorReported) = compare_number_of_method_arguments(tcx,\n                                                                    impl_m,\n                                                                    impl_m_span,\n                                                                    trait_m,\n                                                                    trait_item_span) {\n         return;\n     }\n \n-    if let Err(ErrorReported) = compare_predicate_entailment(ccx,\n+    if let Err(ErrorReported) = compare_predicate_entailment(tcx,\n                                                              impl_m,\n                                                              impl_m_span,\n                                                              impl_m_body_id,\n@@ -82,16 +81,14 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                           impl_m: &ty::AssociatedItem,\n                                           impl_m_span: Span,\n                                           impl_m_body_id: ast::NodeId,\n                                           trait_m: &ty::AssociatedItem,\n                                           impl_trait_ref: ty::TraitRef<'tcx>,\n                                           old_broken_mode: bool)\n                                           -> Result<(), ErrorReported> {\n-    let tcx = ccx.tcx;\n-\n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n     let cause = ObligationCause {\n@@ -190,7 +187,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let trait_m_predicates = tcx.item_predicates(trait_m.def_id);\n \n     // Check region bounds.\n-    check_region_bounds_on_impl_method(ccx,\n+    check_region_bounds_on_impl_method(tcx,\n                                        impl_m_span,\n                                        impl_m,\n                                        &trait_m_generics,\n@@ -227,8 +224,8 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                                trait_param_env,\n                                                                normalize_cause.clone());\n \n-    tcx.infer_ctxt(trait_param_env, Reveal::NotSpecializable).enter(|infcx| {\n-        let inh = Inherited::new(ccx, infcx);\n+    tcx.infer_ctxt(trait_param_env, Reveal::UserFacing).enter(|infcx| {\n+        let inh = Inherited::new(infcx);\n         let infcx = &inh.infcx;\n         let fulfillment_cx = &inh.fulfillment_cx;\n \n@@ -266,19 +263,17 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         // Compute skolemized form of impl and trait method tys.\n         let tcx = infcx.tcx;\n \n-        let m_fty = |method: &ty::AssociatedItem| {\n+        let m_sig = |method: &ty::AssociatedItem| {\n             match tcx.item_type(method.def_id).sty {\n                 ty::TyFnDef(_, _, f) => f,\n                 _ => bug!()\n             }\n         };\n-        let impl_m_fty = m_fty(impl_m);\n-        let trait_m_fty = m_fty(trait_m);\n \n         let (impl_sig, _) =\n             infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n                                                             infer::HigherRankedType,\n-                                                            &impl_m_fty.sig);\n+                                                            &m_sig(impl_m));\n         let impl_sig =\n             impl_sig.subst(tcx, impl_to_skol_substs);\n         let impl_sig =\n@@ -287,16 +282,12 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                  impl_m_span,\n                                                  impl_m_body_id,\n                                                  &impl_sig);\n-        let impl_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-            unsafety: impl_m_fty.unsafety,\n-            abi: impl_m_fty.abi,\n-            sig: ty::Binder(impl_sig.clone()),\n-        }));\n+        let impl_fty = tcx.mk_fn_ptr(ty::Binder(impl_sig));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n         let trait_sig = tcx.liberate_late_bound_regions(\n             infcx.parameter_environment.free_id_outlive,\n-            &trait_m_fty.sig);\n+            &m_sig(trait_m));\n         let trait_sig =\n             trait_sig.subst(tcx, trait_to_skol_substs);\n         let trait_sig =\n@@ -305,11 +296,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                  impl_m_span,\n                                                  impl_m_body_id,\n                                                  &trait_sig);\n-        let trait_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-            unsafety: trait_m_fty.unsafety,\n-            abi: trait_m_fty.abi,\n-            sig: ty::Binder(trait_sig.clone()),\n-        }));\n+        let trait_fty = tcx.mk_fn_ptr(ty::Binder(trait_sig));\n \n         debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n \n@@ -383,11 +370,11 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     })\n }\n \n-fn check_region_bounds_on_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 span: Span,\n                                                 impl_m: &ty::AssociatedItem,\n-                                                trait_generics: &ty::Generics<'tcx>,\n-                                                impl_generics: &ty::Generics<'tcx>,\n+                                                trait_generics: &ty::Generics,\n+                                                impl_generics: &ty::Generics,\n                                                 trait_to_skol_substs: &Substs<'tcx>,\n                                                 impl_to_skol_substs: &Substs<'tcx>)\n                                                 -> Result<(), ErrorReported> {\n@@ -414,7 +401,7 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // are zero. Since I don't quite know how to phrase things at\n     // the moment, give a kind of vague error message.\n     if trait_params.len() != impl_params.len() {\n-        struct_span_err!(ccx.tcx.sess,\n+        struct_span_err!(tcx.sess,\n                          span,\n                          E0195,\n                          \"lifetime parameters or bounds on method `{}` do not match the \\\n@@ -510,14 +497,13 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n     }\n }\n \n-fn compare_self_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                impl_m: &ty::AssociatedItem,\n                                impl_m_span: Span,\n                                trait_m: &ty::AssociatedItem,\n                                impl_trait_ref: ty::TraitRef<'tcx>)\n                                -> Result<(), ErrorReported>\n {\n-    let tcx = ccx.tcx;\n     // Try to give more informative error messages about self typing\n     // mismatches.  Note that any mismatch will also be detected\n     // below, where we construct a canonical function type that\n@@ -583,13 +569,12 @@ fn compare_self_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     Ok(())\n }\n \n-fn compare_number_of_generics<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn compare_number_of_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         impl_m: &ty::AssociatedItem,\n                                         impl_m_span: Span,\n                                         trait_m: &ty::AssociatedItem,\n                                         trait_item_span: Option<Span>)\n                                         -> Result<(), ErrorReported> {\n-    let tcx = ccx.tcx;\n     let impl_m_generics = tcx.item_generics(impl_m.def_id);\n     let trait_m_generics = tcx.item_generics(trait_m.def_id);\n     let num_impl_m_type_params = impl_m_generics.types.len();\n@@ -653,13 +638,12 @@ fn compare_number_of_generics<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     Ok(())\n }\n \n-fn compare_number_of_method_arguments<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 impl_m: &ty::AssociatedItem,\n                                                 impl_m_span: Span,\n                                                 trait_m: &ty::AssociatedItem,\n                                                 trait_item_span: Option<Span>)\n                                                 -> Result<(), ErrorReported> {\n-    let tcx = ccx.tcx;\n     let m_fty = |method: &ty::AssociatedItem| {\n         match tcx.item_type(method.def_id).sty {\n             ty::TyFnDef(_, _, f) => f,\n@@ -668,8 +652,8 @@ fn compare_number_of_method_arguments<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     };\n     let impl_m_fty = m_fty(impl_m);\n     let trait_m_fty = m_fty(trait_m);\n-    let trait_number_args = trait_m_fty.sig.inputs().skip_binder().len();\n-    let impl_number_args = impl_m_fty.sig.inputs().skip_binder().len();\n+    let trait_number_args = trait_m_fty.inputs().skip_binder().len();\n+    let impl_number_args = impl_m_fty.inputs().skip_binder().len();\n     if trait_number_args != impl_number_args {\n         let trait_m_node_id = tcx.hir.as_local_node_id(trait_m.def_id);\n         let trait_span = if let Some(trait_id) = trait_m_node_id {\n@@ -739,15 +723,14 @@ fn compare_number_of_method_arguments<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     Ok(())\n }\n \n-pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     impl_c: &ty::AssociatedItem,\n                                     impl_c_span: Span,\n                                     trait_c: &ty::AssociatedItem,\n                                     impl_trait_ref: ty::TraitRef<'tcx>) {\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n-    let tcx = ccx.tcx;\n-    tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n         // The below is for the most part highly similar to the procedure"}, {"sha": "232c4c4db7c97d41133e19b229797cd4a047afe4", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -123,8 +123,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match method.def() {\n             Def::Method(def_id) => {\n                 match self.tcx.item_type(def_id).sty {\n-                    ty::TypeVariants::TyFnDef(_, _, fty) => {\n-                        fty.sig.skip_binder().inputs().len() == 1\n+                    ty::TypeVariants::TyFnDef(_, _, sig) => {\n+                        sig.inputs().skip_binder().len() == 1\n                     }\n                     _ => false,\n                 }"}, {"sha": "07cc35ed67bbb76ab86bf82bd3e446544cd0f7e1", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use CrateCtxt;\n use check::regionck::RegionCtxt;\n \n use hir::def_id::DefId;\n@@ -40,17 +39,18 @@ use syntax_pos::Span;\n ///    struct/enum definition for the nominal type itself (i.e.\n ///    cannot do `struct S<T>; impl<T:Clone> Drop for S<T> { ... }`).\n ///\n-pub fn check_drop_impl(ccx: &CrateCtxt, drop_impl_did: DefId) -> Result<(), ()> {\n-    let dtor_self_type = ccx.tcx.item_type(drop_impl_did);\n-    let dtor_predicates = ccx.tcx.item_predicates(drop_impl_did);\n+pub fn check_drop_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 drop_impl_did: DefId) -> Result<(), ()> {\n+    let dtor_self_type = tcx.item_type(drop_impl_did);\n+    let dtor_predicates = tcx.item_predicates(drop_impl_did);\n     match dtor_self_type.sty {\n         ty::TyAdt(adt_def, self_to_impl_substs) => {\n-            ensure_drop_params_and_item_params_correspond(ccx,\n+            ensure_drop_params_and_item_params_correspond(tcx,\n                                                           drop_impl_did,\n                                                           dtor_self_type,\n                                                           adt_def.did)?;\n \n-            ensure_drop_predicates_are_implied_by_item_defn(ccx,\n+            ensure_drop_predicates_are_implied_by_item_defn(tcx,\n                                                             drop_impl_did,\n                                                             &dtor_predicates,\n                                                             adt_def.did,\n@@ -59,7 +59,7 @@ pub fn check_drop_impl(ccx: &CrateCtxt, drop_impl_did: DefId) -> Result<(), ()>\n         _ => {\n             // Destructors only work on nominal types.  This was\n             // already checked by coherence, so we can panic here.\n-            let span = ccx.tcx.def_span(drop_impl_did);\n+            let span = tcx.def_span(drop_impl_did);\n             span_bug!(span,\n                       \"should have been rejected by coherence check: {}\",\n                       dtor_self_type);\n@@ -68,20 +68,19 @@ pub fn check_drop_impl(ccx: &CrateCtxt, drop_impl_did: DefId) -> Result<(), ()>\n }\n \n fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n-    ccx: &CrateCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     drop_impl_did: DefId,\n     drop_impl_ty: Ty<'tcx>,\n     self_type_did: DefId)\n     -> Result<(), ()>\n {\n-    let tcx = ccx.tcx;\n     let drop_impl_node_id = tcx.hir.as_local_node_id(drop_impl_did).unwrap();\n     let self_type_node_id = tcx.hir.as_local_node_id(self_type_did).unwrap();\n \n     // check that the impl type can be made to match the trait type.\n \n     let impl_param_env = ty::ParameterEnvironment::for_item(tcx, self_type_node_id);\n-    tcx.infer_ctxt(impl_param_env, Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt(impl_param_env, Reveal::UserFacing).enter(|infcx| {\n         let tcx = infcx.tcx;\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n@@ -126,7 +125,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n /// Confirms that every predicate imposed by dtor_predicates is\n /// implied by assuming the predicates attached to self_type_did.\n fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n-    ccx: &CrateCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     drop_impl_did: DefId,\n     dtor_predicates: &ty::GenericPredicates<'tcx>,\n     self_type_did: DefId,\n@@ -169,8 +168,6 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n     // absent. So we report an error that the Drop impl injected a\n     // predicate that is not present on the struct definition.\n \n-    let tcx = ccx.tcx;\n-\n     let self_type_node_id = tcx.hir.as_local_node_id(self_type_did).unwrap();\n \n     let drop_impl_span = tcx.def_span(drop_impl_did);\n@@ -557,7 +554,7 @@ fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n             // Find the `impl<..> Drop for _` to inspect any\n             // attributes attached to the impl's generics.\n-            let dtor_method = adt_def.destructor()\n+            let dtor_method = adt_def.destructor(tcx)\n                 .expect(\"dtorck type without destructor impossible\");\n             let method = tcx.associated_item(dtor_method);\n             let impl_def_id = method.container.id();"}, {"sha": "28996b40cfdfec0f2fa7d76df348e78311f00525", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 77, "deletions": 79, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -14,9 +14,9 @@\n use intrinsics;\n use rustc::traits::{ObligationCause, ObligationCauseCode};\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, TyCtxt, Ty};\n use rustc::util::nodemap::FxHashMap;\n-use {CrateCtxt, require_same_types};\n+use require_same_types;\n \n use syntax::abi::Abi;\n use syntax::ast;\n@@ -27,24 +27,25 @@ use rustc::hir;\n \n use std::iter;\n \n-fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    it: &hir::ForeignItem,\n                                    n_tps: usize,\n                                    abi: Abi,\n                                    inputs: Vec<Ty<'tcx>>,\n                                    output: Ty<'tcx>) {\n-    let tcx = ccx.tcx;\n     let def_id = tcx.hir.local_def_id(it.id);\n \n     let substs = Substs::for_item(tcx, def_id,\n                                   |_, _| tcx.mk_region(ty::ReErased),\n                                   |def, _| tcx.mk_param_from_def(def));\n \n-    let fty = tcx.mk_fn_def(def_id, substs, tcx.mk_bare_fn(ty::BareFnTy {\n-        unsafety: hir::Unsafety::Unsafe,\n-        abi: abi,\n-        sig: ty::Binder(tcx.mk_fn_sig(inputs.into_iter(), output, false)),\n-    }));\n+    let fty = tcx.mk_fn_def(def_id, substs, ty::Binder(tcx.mk_fn_sig(\n+        inputs.into_iter(),\n+        output,\n+        false,\n+        hir::Unsafety::Unsafe,\n+        abi\n+    )));\n     let i_n_tps = tcx.item_generics(def_id).types.len();\n     if i_n_tps != n_tps {\n         let span = match it.node {\n@@ -59,7 +60,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             .span_label(span, &format!(\"expected {} type parameter\", n_tps))\n             .emit();\n     } else {\n-        require_same_types(ccx,\n+        require_same_types(tcx,\n                            &ObligationCause::new(it.span,\n                                                  it.id,\n                                                  ObligationCauseCode::IntrinsicType),\n@@ -70,33 +71,29 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n /// Remember to add all intrinsics here, in librustc_trans/trans/intrinsic.rs,\n /// and in libcore/intrinsics.rs\n-pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n-    fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: u32) -> Ty<'tcx> {\n-        let name = Symbol::intern(&format!(\"P{}\", n));\n-        ccx.tcx.mk_param(n, name)\n-    }\n-\n-    let tcx = ccx.tcx;\n+pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      it: &hir::ForeignItem) {\n+    let param = |n| tcx.mk_param(n, Symbol::intern(&format!(\"P{}\", n)));\n     let name = it.name.as_str();\n     let (n_tps, inputs, output) = if name.starts_with(\"atomic_\") {\n         let split : Vec<&str> = name.split('_').collect();\n         assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n \n         //We only care about the operation here\n         let (n_tps, inputs, output) = match split[1] {\n-            \"cxchg\" | \"cxchgweak\" => (1, vec![tcx.mk_mut_ptr(param(ccx, 0)),\n-                                              param(ccx, 0),\n-                                              param(ccx, 0)],\n-                                      tcx.intern_tup(&[param(ccx, 0), tcx.types.bool], false)),\n-            \"load\" => (1, vec![tcx.mk_imm_ptr(param(ccx, 0))],\n-                       param(ccx, 0)),\n-            \"store\" => (1, vec![tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)],\n+            \"cxchg\" | \"cxchgweak\" => (1, vec![tcx.mk_mut_ptr(param(0)),\n+                                              param(0),\n+                                              param(0)],\n+                                      tcx.intern_tup(&[param(0), tcx.types.bool], false)),\n+            \"load\" => (1, vec![tcx.mk_imm_ptr(param(0))],\n+                       param(0)),\n+            \"store\" => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)],\n                         tcx.mk_nil()),\n \n             \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\" | \"xor\" | \"max\" |\n             \"min\"  | \"umax\" | \"umin\" => {\n-                (1, vec![tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)],\n-                 param(ccx, 0))\n+                (1, vec![tcx.mk_mut_ptr(param(0)), param(0)],\n+                 param(0))\n             }\n             \"fence\" | \"singlethreadfence\" => {\n                 (0, Vec::new(), tcx.mk_nil())\n@@ -116,57 +113,57 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n         let (n_tps, inputs, output) = match &name[..] {\n             \"breakpoint\" => (0, Vec::new(), tcx.mk_nil()),\n             \"size_of\" |\n-            \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), ccx.tcx.types.usize),\n+            \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), tcx.types.usize),\n             \"size_of_val\" |  \"min_align_of_val\" => {\n                 (1, vec![\n                     tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n                                                                   ty::BrAnon(0))),\n-                                    param(ccx, 0))\n-                 ], ccx.tcx.types.usize)\n+                                    param(0))\n+                 ], tcx.types.usize)\n             }\n-            \"rustc_peek\" => (1, vec![param(ccx, 0)], param(ccx, 0)),\n-            \"init\" => (1, Vec::new(), param(ccx, 0)),\n-            \"uninit\" => (1, Vec::new(), param(ccx, 0)),\n-            \"forget\" => (1, vec![ param(ccx, 0) ], tcx.mk_nil()),\n-            \"transmute\" => (2, vec![ param(ccx, 0) ], param(ccx, 1)),\n+            \"rustc_peek\" => (1, vec![param(0)], param(0)),\n+            \"init\" => (1, Vec::new(), param(0)),\n+            \"uninit\" => (1, Vec::new(), param(0)),\n+            \"forget\" => (1, vec![ param(0) ], tcx.mk_nil()),\n+            \"transmute\" => (2, vec![ param(0) ], param(1)),\n             \"move_val_init\" => {\n                 (1,\n                  vec![\n-                    tcx.mk_mut_ptr(param(ccx, 0)),\n-                    param(ccx, 0)\n+                    tcx.mk_mut_ptr(param(0)),\n+                    param(0)\n                   ],\n                tcx.mk_nil())\n             }\n             \"drop_in_place\" => {\n-                (1, vec![tcx.mk_mut_ptr(param(ccx, 0))], tcx.mk_nil())\n+                (1, vec![tcx.mk_mut_ptr(param(0))], tcx.mk_nil())\n             }\n-            \"needs_drop\" => (1, Vec::new(), ccx.tcx.types.bool),\n+            \"needs_drop\" => (1, Vec::new(), tcx.types.bool),\n \n             \"type_name\" => (1, Vec::new(), tcx.mk_static_str()),\n-            \"type_id\" => (1, Vec::new(), ccx.tcx.types.u64),\n+            \"type_id\" => (1, Vec::new(), tcx.types.u64),\n             \"offset\" | \"arith_offset\" => {\n               (1,\n                vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n+                      ty: param(0),\n                       mutbl: hir::MutImmutable\n                   }),\n-                  ccx.tcx.types.isize\n+                  tcx.types.isize\n                ],\n                tcx.mk_ptr(ty::TypeAndMut {\n-                   ty: param(ccx, 0),\n+                   ty: param(0),\n                    mutbl: hir::MutImmutable\n                }))\n             }\n             \"copy\" | \"copy_nonoverlapping\" => {\n               (1,\n                vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n+                      ty: param(0),\n                       mutbl: hir::MutImmutable\n                   }),\n                   tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n+                      ty: param(0),\n                       mutbl: hir::MutMutable\n                   }),\n                   tcx.types.usize,\n@@ -177,11 +174,11 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n               (1,\n                vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n+                      ty: param(0),\n                       mutbl: hir::MutMutable\n                   }),\n                   tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n+                      ty: param(0),\n                       mutbl: hir::MutImmutable\n                   }),\n                   tcx.types.usize,\n@@ -192,7 +189,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n               (1,\n                vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n+                      ty: param(0),\n                       mutbl: hir::MutMutable\n                   }),\n                   tcx.types.u8,\n@@ -264,23 +261,23 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n             \"roundf64\"     => (0, vec![ tcx.types.f64 ], tcx.types.f64),\n \n             \"volatile_load\" =>\n-                (1, vec![ tcx.mk_imm_ptr(param(ccx, 0)) ], param(ccx, 0)),\n+                (1, vec![ tcx.mk_imm_ptr(param(0)) ], param(0)),\n             \"volatile_store\" =>\n-                (1, vec![ tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0) ], tcx.mk_nil()),\n+                (1, vec![ tcx.mk_mut_ptr(param(0)), param(0) ], tcx.mk_nil()),\n \n-            \"ctpop\" | \"ctlz\" | \"cttz\" | \"bswap\" => (1, vec![param(ccx, 0)], param(ccx, 0)),\n+            \"ctpop\" | \"ctlz\" | \"cttz\" | \"bswap\" => (1, vec![param(0)], param(0)),\n \n             \"add_with_overflow\" | \"sub_with_overflow\"  | \"mul_with_overflow\" =>\n-                (1, vec![param(ccx, 0), param(ccx, 0)],\n-                tcx.intern_tup(&[param(ccx, 0), tcx.types.bool], false)),\n+                (1, vec![param(0), param(0)],\n+                tcx.intern_tup(&[param(0), tcx.types.bool], false)),\n \n             \"unchecked_div\" | \"unchecked_rem\" =>\n-                (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n+                (1, vec![param(0), param(0)], param(0)),\n \n             \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" =>\n-                (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n+                (1, vec![param(0), param(0)], param(0)),\n             \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" =>\n-                (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n+                (1, vec![param(0), param(0)], param(0)),\n \n             \"assume\" => (0, vec![tcx.types.bool], tcx.mk_nil()),\n             \"likely\" => (0, vec![tcx.types.bool], tcx.types.bool),\n@@ -289,15 +286,17 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n             \"discriminant_value\" => (1, vec![\n                     tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n                                                                   ty::BrAnon(0))),\n-                                   param(ccx, 0))], tcx.types.u64),\n+                                   param(0))], tcx.types.u64),\n \n             \"try\" => {\n                 let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);\n-                let fn_ty = tcx.mk_bare_fn(ty::BareFnTy {\n-                    unsafety: hir::Unsafety::Normal,\n-                    abi: Abi::Rust,\n-                    sig: ty::Binder(tcx.mk_fn_sig(iter::once(mut_u8), tcx.mk_nil(), false)),\n-                });\n+                let fn_ty = ty::Binder(tcx.mk_fn_sig(\n+                    iter::once(mut_u8),\n+                    tcx.mk_nil(),\n+                    false,\n+                    hir::Unsafety::Normal,\n+                    Abi::Rust,\n+                ));\n                 (0, vec![tcx.mk_fn_ptr(fn_ty), mut_u8, mut_u8], tcx.types.i32)\n             }\n \n@@ -312,18 +311,17 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n         };\n         (n_tps, inputs, output)\n     };\n-    equate_intrinsic_type(ccx, it, n_tps, Abi::RustIntrinsic, inputs, output)\n+    equate_intrinsic_type(tcx, it, n_tps, Abi::RustIntrinsic, inputs, output)\n }\n \n /// Type-check `extern \"platform-intrinsic\" { ... }` functions.\n-pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n-                                     it: &hir::ForeignItem) {\n+pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                               it: &hir::ForeignItem) {\n     let param = |n| {\n         let name = Symbol::intern(&format!(\"P{}\", n));\n-        ccx.tcx.mk_param(n, name)\n+        tcx.mk_param(n, name)\n     };\n \n-    let tcx = ccx.tcx;\n     let def_id = tcx.hir.local_def_id(it.id);\n     let i_n_tps = tcx.item_generics(def_id).types.len();\n     let name = it.name.as_str();\n@@ -369,7 +367,7 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n                     let mut structural_to_nomimal = FxHashMap();\n \n                     let sig = tcx.item_type(def_id).fn_sig();\n-                    let sig = tcx.no_late_bound_regions(sig).unwrap();\n+                    let sig = tcx.no_late_bound_regions(&sig).unwrap();\n                     if intr.inputs.len() != sig.inputs().len() {\n                         span_err!(tcx.sess, it.span, E0444,\n                                   \"platform-specific intrinsic has invalid number of \\\n@@ -379,10 +377,10 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n                     }\n                     let input_pairs = intr.inputs.iter().zip(sig.inputs());\n                     for (i, (expected_arg, arg)) in input_pairs.enumerate() {\n-                        match_intrinsic_type_to_type(ccx, &format!(\"argument {}\", i + 1), it.span,\n+                        match_intrinsic_type_to_type(tcx, &format!(\"argument {}\", i + 1), it.span,\n                                                      &mut structural_to_nomimal, expected_arg, arg);\n                     }\n-                    match_intrinsic_type_to_type(ccx, \"return value\", it.span,\n+                    match_intrinsic_type_to_type(tcx, \"return value\", it.span,\n                                                  &mut structural_to_nomimal,\n                                                  &intr.output, sig.output());\n                     return\n@@ -396,15 +394,15 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n         }\n     };\n \n-    equate_intrinsic_type(ccx, it, n_tps, Abi::PlatformIntrinsic,\n+    equate_intrinsic_type(tcx, it, n_tps, Abi::PlatformIntrinsic,\n                           inputs, output)\n }\n \n // walk the expected type and the actual type in lock step, checking they're\n // the same, in a kinda-structural way, i.e. `Vector`s have to be simd structs with\n // exactly the right element type\n-fn match_intrinsic_type_to_type<'tcx, 'a>(\n-        ccx: &CrateCtxt<'a, 'tcx>,\n+fn match_intrinsic_type_to_type<'a, 'tcx>(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         position: &str,\n         span: Span,\n         structural_to_nominal: &mut FxHashMap<&'a intrinsics::Type, ty::Ty<'tcx>>,\n@@ -413,7 +411,7 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n     use intrinsics::Type::*;\n \n     let simple_error = |real: &str, expected: &str| {\n-        span_err!(ccx.tcx.sess, span, E0442,\n+        span_err!(tcx.sess, span, E0442,\n                   \"intrinsic {} has wrong type: found {}, expected {}\",\n                   position, real, expected)\n     };\n@@ -453,7 +451,7 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n                         simple_error(&format!(\"`{}`\", t),\n                                      if const_ {\"const pointer\"} else {\"mut pointer\"})\n                     }\n-                    match_intrinsic_type_to_type(ccx, position, span, structural_to_nominal,\n+                    match_intrinsic_type_to_type(tcx, position, span, structural_to_nominal,\n                                                  inner_expected, ty)\n                 }\n                 _ => simple_error(&format!(\"`{}`\", t), \"raw pointer\"),\n@@ -464,19 +462,19 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n                 simple_error(&format!(\"non-simd type `{}`\", t), \"simd type\");\n                 return;\n             }\n-            let t_len = t.simd_size(ccx.tcx);\n+            let t_len = t.simd_size(tcx);\n             if len as usize != t_len {\n                 simple_error(&format!(\"vector with length {}\", t_len),\n                              &format!(\"length {}\", len));\n                 return;\n             }\n-            let t_ty = t.simd_type(ccx.tcx);\n+            let t_ty = t.simd_type(tcx);\n             {\n                 // check that a given structural type always has the same an intrinsic definition\n                 let previous = structural_to_nominal.entry(expected).or_insert(t);\n                 if *previous != t {\n                     // this gets its own error code because it is non-trivial\n-                    span_err!(ccx.tcx.sess, span, E0443,\n+                    span_err!(tcx.sess, span, E0443,\n                               \"intrinsic {} has wrong type: found `{}`, expected `{}` which \\\n                                was used for this vector type previously in this signature\",\n                               position,\n@@ -485,7 +483,7 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n                     return;\n                 }\n             }\n-            match_intrinsic_type_to_type(ccx,\n+            match_intrinsic_type_to_type(tcx,\n                                          position,\n                                          span,\n                                          structural_to_nominal,\n@@ -501,7 +499,7 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n                         return\n                     }\n                     for (e, c) in expected_contents.iter().zip(contents) {\n-                        match_intrinsic_type_to_type(ccx, position, span, structural_to_nominal,\n+                        match_intrinsic_type_to_type(tcx, position, span, structural_to_nominal,\n                                                      e, c)\n                     }\n                 }"}, {"sha": "e6e4b577bd50d785825d3690041d740f3c9b4498", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -365,32 +365,23 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         debug!(\"method_predicates after subst = {:?}\", method_predicates);\n \n-        let fty = match self.tcx.item_type(def_id).sty {\n-            ty::TyFnDef(_, _, f) => f,\n-            _ => bug!()\n-        };\n+        let sig = self.tcx.item_type(def_id).fn_sig();\n \n         // Instantiate late-bound regions and substitute the trait\n         // parameters into the method type to get the actual method type.\n         //\n         // NB: Instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n-        let method_sig = self.replace_late_bound_regions_with_fresh_var(&fty.sig);\n+        let method_sig = self.replace_late_bound_regions_with_fresh_var(&sig);\n         debug!(\"late-bound lifetimes from method instantiated, method_sig={:?}\",\n                method_sig);\n \n         let method_sig = self.instantiate_type_scheme(self.span, all_substs, &method_sig);\n         debug!(\"type scheme substituted, method_sig={:?}\", method_sig);\n \n-        let method_ty = self.tcx.mk_fn_def(def_id, all_substs,\n-                                           self.tcx.mk_bare_fn(ty::BareFnTy {\n-            sig: ty::Binder(method_sig),\n-            unsafety: fty.unsafety,\n-            abi: fty.abi,\n-        }));\n-\n-        (method_ty, method_predicates)\n+        (self.tcx.mk_fn_def(def_id, all_substs, ty::Binder(method_sig)),\n+         method_predicates)\n     }\n \n     fn add_obligations(&mut self,\n@@ -566,7 +557,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // Disallow calls to the method `drop` defined in the `Drop` trait.\n         match pick.item.container {\n             ty::TraitContainer(trait_def_id) => {\n-                callee::check_legal_trait_for_method_call(self.ccx, self.span, trait_def_id)\n+                callee::check_legal_trait_for_method_call(self.tcx, self.span, trait_def_id)\n             }\n             ty::ImplContainer(..) => {}\n         }"}, {"sha": "4085a171bbef53801977e1efa5a026c107968e5f", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Some(import_id) = pick.import_id {\n             let import_def_id = self.tcx.hir.local_def_id(import_id);\n             debug!(\"used_trait_import: {:?}\", import_def_id);\n-            self.used_trait_imports.borrow_mut().insert(import_def_id);\n+            self.tables.borrow_mut().used_trait_imports.insert(import_def_id);\n         }\n \n         self.tcx.check_stability(pick.item.def_id, call_expr.id, span);\n@@ -244,21 +244,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n         let original_method_ty = tcx.item_type(def_id);\n-        let fty = match original_method_ty.sty {\n-            ty::TyFnDef(_, _, f) => f,\n-            _ => bug!()\n-        };\n+        let fn_sig = original_method_ty.fn_sig();\n         let fn_sig = self.replace_late_bound_regions_with_fresh_var(span,\n                                                                     infer::FnCall,\n-                                                                    &fty.sig).0;\n+                                                                    &fn_sig).0;\n         let fn_sig = self.instantiate_type_scheme(span, trait_ref.substs, &fn_sig);\n         let transformed_self_ty = fn_sig.inputs()[0];\n         let method_ty = tcx.mk_fn_def(def_id, trait_ref.substs,\n-                                      tcx.mk_bare_fn(ty::BareFnTy {\n-            sig: ty::Binder(fn_sig),\n-            unsafety: fty.unsafety,\n-            abi: fty.abi\n-        }));\n+                                     ty::Binder(fn_sig));\n \n         debug!(\"lookup_in_trait_adjusted: matched method method_ty={:?} obligation={:?}\",\n                method_ty,\n@@ -340,7 +333,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Some(import_id) = pick.import_id {\n             let import_def_id = self.tcx.hir.local_def_id(import_id);\n             debug!(\"used_trait_import: {:?}\", import_def_id);\n-            self.used_trait_imports.borrow_mut().insert(import_def_id);\n+            self.tables.borrow_mut().used_trait_imports.insert(import_def_id);\n         }\n \n         let def = pick.item.def();"}, {"sha": "dfa7ababca0bbd8b97f143cbc9efcdca24d44ec6", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -481,9 +481,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn assemble_inherent_impl_candidates_for_type(&mut self, def_id: DefId) {\n         // Read the inherent implementation candidates for this type from the\n         // metadata if necessary.\n-        self.tcx.populate_inherent_implementations_for_type_if_necessary(def_id);\n+        self.tcx.populate_inherent_implementations_for_type_if_necessary(self.span, def_id);\n \n-        if let Some(impl_infos) = self.tcx.inherent_impls.borrow().get(&def_id) {\n+        if let Some(impl_infos) = self.tcx.maps.inherent_impls.borrow().get(&def_id) {\n             for &impl_def_id in impl_infos.iter() {\n                 self.assemble_inherent_impl_probe(impl_def_id);\n             }\n@@ -653,7 +653,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn assemble_extension_candidates_for_all_traits(&mut self) -> Result<(), MethodError<'tcx>> {\n         let mut duplicates = FxHashSet();\n-        for trait_info in suggest::all_traits(self.ccx) {\n+        for trait_info in suggest::all_traits(self.tcx) {\n             if duplicates.insert(trait_info.def_id) {\n                 self.assemble_extension_candidates_for_trait(None, trait_info.def_id)?;\n             }"}, {"sha": "6ce50d91124d445002769b6dfb0ad775dbecd867", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -11,11 +11,9 @@\n //! Give useful errors and suggestions to users when an item can't be\n //! found or is otherwise invalid.\n \n-use CrateCtxt;\n-\n use check::FnCtxt;\n use rustc::hir::map as hir_map;\n-use rustc::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt, ToPolyTraitRef, ToPredicate, TypeFoldable};\n use hir::def::Def;\n use hir::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::lang_items::FnOnceTraitLangItem;\n@@ -343,7 +341,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // there's no implemented traits, so lets suggest some traits to\n         // implement, by finding ones that have the item name, and are\n         // legal to implement.\n-        let mut candidates = all_traits(self.ccx)\n+        let mut candidates = all_traits(self.tcx)\n             .filter(|info| {\n                 // we approximate the coherence rules to only suggest\n                 // traits that are legal to implement by requiring that\n@@ -423,7 +421,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub type AllTraitsVec = Vec<TraitInfo>;\n+pub type AllTraitsVec = Vec<DefId>;\n \n #[derive(Copy, Clone)]\n pub struct TraitInfo {\n@@ -458,8 +456,8 @@ impl Ord for TraitInfo {\n }\n \n /// Retrieve all traits in this crate and any dependent crates.\n-pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n-    if ccx.all_traits.borrow().is_none() {\n+pub fn all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> AllTraits<'a> {\n+    if tcx.all_traits.borrow().is_none() {\n         use rustc::hir::itemlikevisit;\n \n         let mut traits = vec![];\n@@ -476,7 +474,7 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n                 match i.node {\n                     hir::ItemTrait(..) => {\n                         let def_id = self.map.local_def_id(i.id);\n-                        self.traits.push(TraitInfo::new(def_id));\n+                        self.traits.push(def_id);\n                     }\n                     _ => {}\n                 }\n@@ -488,45 +486,45 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n             fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n             }\n         }\n-        ccx.tcx.hir.krate().visit_all_item_likes(&mut Visitor {\n-            map: &ccx.tcx.hir,\n+        tcx.hir.krate().visit_all_item_likes(&mut Visitor {\n+            map: &tcx.hir,\n             traits: &mut traits,\n         });\n \n         // Cross-crate:\n         let mut external_mods = FxHashSet();\n-        fn handle_external_def(ccx: &CrateCtxt,\n+        fn handle_external_def(tcx: TyCtxt,\n                                traits: &mut AllTraitsVec,\n                                external_mods: &mut FxHashSet<DefId>,\n                                def: Def) {\n             let def_id = def.def_id();\n             match def {\n                 Def::Trait(..) => {\n-                    traits.push(TraitInfo::new(def_id));\n+                    traits.push(def_id);\n                 }\n                 Def::Mod(..) => {\n                     if !external_mods.insert(def_id) {\n                         return;\n                     }\n-                    for child in ccx.tcx.sess.cstore.item_children(def_id) {\n-                        handle_external_def(ccx, traits, external_mods, child.def)\n+                    for child in tcx.sess.cstore.item_children(def_id) {\n+                        handle_external_def(tcx, traits, external_mods, child.def)\n                     }\n                 }\n                 _ => {}\n             }\n         }\n-        for cnum in ccx.tcx.sess.cstore.crates() {\n+        for cnum in tcx.sess.cstore.crates() {\n             let def_id = DefId {\n                 krate: cnum,\n                 index: CRATE_DEF_INDEX,\n             };\n-            handle_external_def(ccx, &mut traits, &mut external_mods, Def::Mod(def_id));\n+            handle_external_def(tcx, &mut traits, &mut external_mods, Def::Mod(def_id));\n         }\n \n-        *ccx.all_traits.borrow_mut() = Some(traits);\n+        *tcx.all_traits.borrow_mut() = Some(traits);\n     }\n \n-    let borrow = ccx.all_traits.borrow();\n+    let borrow = tcx.all_traits.borrow();\n     assert!(borrow.is_some());\n     AllTraits {\n         borrow: borrow,\n@@ -547,7 +545,7 @@ impl<'a> Iterator for AllTraits<'a> {\n         // ugh.\n         borrow.as_ref().unwrap().get(*idx).map(|info| {\n             *idx += 1;\n-            *info\n+            TraitInfo::new(*info)\n         })\n     }\n }"}, {"sha": "0337727dcba9ad372e2426e7843b4bd0c942dfe2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 300, "deletions": 315, "changes": 615, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -56,7 +56,7 @@ stored in `fcx.node_types` and `fcx.item_substs`.  These types\n may contain unresolved type variables.  After type checking is\n complete, the functions in the writeback module are used to take the\n types from this table, resolve them, and then write them into their\n-permanent home in the type context `ccx.tcx`.\n+permanent home in the type context `tcx`.\n \n This means that during inferencing you should use `fcx.write_ty()`\n and `fcx.expr_ty()` / `fcx.node_ty()` to write/obtain the types of\n@@ -91,26 +91,25 @@ use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n-use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, Visibility};\n+use rustc::ty::{self, Ty, TyCtxt, Visibility};\n use rustc::ty::{MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n+use rustc::ty::maps::Providers;\n use rustc::ty::util::{Representability, IntTypeExt};\n use require_c_abi_if_variadic;\n use session::{Session, CompileResult};\n-use CrateCtxt;\n use TypeAndSubsts;\n use lint;\n use util::common::{ErrorReported, indenter};\n-use util::nodemap::{DefIdMap, DefIdSet, FxHashMap, FxHashSet, NodeMap};\n+use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap};\n \n use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::mem::replace;\n use std::ops::{self, Deref};\n use syntax::abi::Abi;\n use syntax::ast;\n-use syntax::attr;\n use syntax::codemap::{self, original_sp, Spanned};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n@@ -124,6 +123,7 @@ use rustc::hir::{self, PatKind};\n use rustc::middle::lang_items;\n use rustc_back::slice;\n use rustc_const_eval::eval_length;\n+use rustc_const_math::ConstInt;\n \n mod assoc;\n mod autoderef;\n@@ -153,8 +153,8 @@ mod op;\n /// `bar()` will each have their own `FnCtxt`, but they will\n /// share the inherited fields.\n pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    ccx: &'a CrateCtxt<'a, 'gcx>,\n     infcx: InferCtxt<'a, 'gcx, 'tcx>,\n+\n     locals: RefCell<NodeMap<Ty<'tcx>>>,\n \n     fulfillment_cx: RefCell<traits::FulfillmentContext<'tcx>>,\n@@ -174,16 +174,7 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // associated fresh inference variable. Writeback resolves these\n     // variables to get the concrete type, which can be used to\n     // deanonymize TyAnon, after typeck is done with all functions.\n-    anon_types: RefCell<DefIdMap<Ty<'tcx>>>,\n-\n-    // Obligations which will have to be checked at the end of\n-    // type-checking, after all functions have been inferred.\n-    deferred_obligations: RefCell<Vec<traits::DeferredObligation<'tcx>>>,\n-\n-    // a set of trait import def-ids that we use during method\n-    // resolution; during writeback, this is written into\n-    // `tcx.used_trait_imports` for this item def-id\n-    used_trait_imports: RefCell<FxHashSet<DefId>>,\n+    anon_types: RefCell<NodeMap<Ty<'tcx>>>,\n }\n \n impl<'a, 'gcx, 'tcx> Deref for Inherited<'a, 'gcx, 'tcx> {\n@@ -441,10 +432,6 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     body_id: ast::NodeId,\n \n-    // This flag is set to true if, during the writeback phase, we encounter\n-    // a type error in this function.\n-    writeback_errors: Cell<bool>,\n-\n     // Number of errors that had been reported when we started\n     // checking this function. On exit, if we find that *more* errors\n     // have been reported, we will skip regionck and other work that\n@@ -473,22 +460,20 @@ impl<'a, 'gcx, 'tcx> Deref for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/// Helper type of a temporary returned by ccx.inherited(...).\n+/// Helper type of a temporary returned by Inherited::build(...).\n /// Necessary because we can't write the following bound:\n /// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(Inherited<'b, 'gcx, 'tcx>).\n pub struct InheritedBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    ccx: &'a CrateCtxt<'a, 'gcx>,\n     infcx: infer::InferCtxtBuilder<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'gcx, 'tcx> CrateCtxt<'a, 'gcx> {\n-    pub fn inherited(&'a self, id: ast::NodeId)\n-                     -> InheritedBuilder<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n+    pub fn build(tcx: TyCtxt<'a, 'gcx, 'gcx>, id: ast::NodeId)\n+                 -> InheritedBuilder<'a, 'gcx, 'tcx> {\n         let tables = ty::TypeckTables::empty();\n-        let param_env = ParameterEnvironment::for_item(self.tcx, id);\n+        let param_env = ParameterEnvironment::for_item(tcx, id);\n         InheritedBuilder {\n-            ccx: self,\n-            infcx: self.tcx.infer_ctxt((tables, param_env), Reveal::NotSpecializable)\n+            infcx: tcx.infer_ctxt((tables, param_env), Reveal::UserFacing)\n         }\n     }\n }\n@@ -497,25 +482,19 @@ impl<'a, 'gcx, 'tcx> InheritedBuilder<'a, 'gcx, 'tcx> {\n     fn enter<F, R>(&'tcx mut self, f: F) -> R\n         where F: for<'b> FnOnce(Inherited<'b, 'gcx, 'tcx>) -> R\n     {\n-        let ccx = self.ccx;\n-        self.infcx.enter(|infcx| f(Inherited::new(ccx, infcx)))\n+        self.infcx.enter(|infcx| f(Inherited::new(infcx)))\n     }\n }\n \n impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n-    pub fn new(ccx: &'a CrateCtxt<'a, 'gcx>,\n-               infcx: InferCtxt<'a, 'gcx, 'tcx>)\n-               -> Self {\n+    pub fn new(infcx: InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n         Inherited {\n-            ccx: ccx,\n             infcx: infcx,\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n             locals: RefCell::new(NodeMap()),\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n-            anon_types: RefCell::new(DefIdMap()),\n-            deferred_obligations: RefCell::new(Vec::new()),\n-            used_trait_imports: RefCell::new(DefIdSet()),\n+            anon_types: RefCell::new(NodeMap()),\n         }\n     }\n \n@@ -535,23 +514,23 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n \n }\n \n-struct CheckItemTypesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n-struct CheckItemBodiesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n+struct CheckItemTypesVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n+struct CheckItemBodiesVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n \n impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.ccx.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n     }\n \n     fn visit_item(&mut self, i: &'tcx hir::Item) {\n-        check_item_type(self.ccx, i);\n+        check_item_type(self.tcx, i);\n         intravisit::walk_item(self, i);\n     }\n \n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n         match t.node {\n             hir::TyArray(_, length) => {\n-                check_const_with_type(self.ccx, length, self.ccx.tcx.types.usize, length.node_id);\n+                self.tcx.item_tables(self.tcx.hir.local_def_id(length.node_id));\n             }\n             _ => {}\n         }\n@@ -562,7 +541,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n         match e.node {\n             hir::ExprRepeat(_, count) => {\n-                check_const_with_type(self.ccx, count, self.ccx.tcx.types.usize, count.node_id);\n+                self.tcx.item_tables(self.tcx.hir.local_def_id(count.node_id));\n             }\n             _ => {}\n         }\n@@ -574,20 +553,18 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n-            hir::ItemFn(ref decl, .., body_id) => {\n-                check_bare_fn(self.ccx, &decl, body_id, item.id, item.span);\n+            hir::ItemFn(..) => {\n+                self.tcx.item_tables(self.tcx.hir.local_def_id(item.id));\n             }\n             _ => { }\n         }\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         match trait_item.node {\n-            hir::TraitItemKind::Const(_, Some(expr)) => {\n-                check_const(self.ccx, expr, trait_item.id)\n-            }\n-            hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body_id)) => {\n-                check_bare_fn(self.ccx, &sig.decl, body_id, trait_item.id, trait_item.span);\n+            hir::TraitItemKind::Const(_, Some(_)) |\n+            hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(_)) => {\n+                self.tcx.item_tables(self.tcx.hir.local_def_id(trait_item.id));\n             }\n             hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) |\n             hir::TraitItemKind::Const(_, None) |\n@@ -599,11 +576,9 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         match impl_item.node {\n-            hir::ImplItemKind::Const(_, expr) => {\n-                check_const(self.ccx, expr, impl_item.id)\n-            }\n-            hir::ImplItemKind::Method(ref sig, body_id) => {\n-                check_bare_fn(self.ccx, &sig.decl, body_id, impl_item.id, impl_item.span);\n+            hir::ImplItemKind::Const(..) |\n+            hir::ImplItemKind::Method(..) => {\n+                self.tcx.item_tables(self.tcx.hir.local_def_id(impl_item.id));\n             }\n             hir::ImplItemKind::Type(_) => {\n                 // Nothing to do here.\n@@ -612,109 +587,192 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_wf_new(ccx: &CrateCtxt) -> CompileResult {\n-    ccx.tcx.sess.track_errors(|| {\n-        let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(ccx);\n-        ccx.tcx.visit_all_item_likes_in_krate(DepNode::WfCheck, &mut visit.as_deep_visitor());\n+pub fn check_wf_new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult {\n+    tcx.sess.track_errors(|| {\n+        let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(tcx);\n+        tcx.visit_all_item_likes_in_krate(DepNode::WfCheck, &mut visit.as_deep_visitor());\n     })\n }\n \n-pub fn check_item_types(ccx: &CrateCtxt) -> CompileResult {\n-    ccx.tcx.sess.track_errors(|| {\n-        let mut visit = CheckItemTypesVisitor { ccx: ccx };\n-        ccx.tcx.visit_all_item_likes_in_krate(DepNode::TypeckItemType,\n+pub fn check_item_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult {\n+    tcx.sess.track_errors(|| {\n+        let mut visit = CheckItemTypesVisitor { tcx: tcx };\n+        tcx.visit_all_item_likes_in_krate(DepNode::TypeckItemType,\n                                               &mut visit.as_deep_visitor());\n     })\n }\n \n-pub fn check_item_bodies(ccx: &CrateCtxt) -> CompileResult {\n-    ccx.tcx.sess.track_errors(|| {\n-        let mut visit = CheckItemBodiesVisitor { ccx: ccx };\n-        ccx.tcx.visit_all_item_likes_in_krate(DepNode::TypeckTables, &mut visit);\n-\n-        // Process deferred obligations, now that all functions\n-        // bodies have been fully inferred.\n-        for (&item_id, obligations) in ccx.deferred_obligations.borrow().iter() {\n-            // Use the same DepNode as for the body of the original function/item.\n-            let def_id = ccx.tcx.hir.local_def_id(item_id);\n-            let _task = ccx.tcx.dep_graph.in_task(DepNode::TypeckTables(def_id));\n-\n-            let param_env = ParameterEnvironment::for_item(ccx.tcx, item_id);\n-            ccx.tcx.infer_ctxt(param_env, Reveal::NotSpecializable).enter(|infcx| {\n-                let mut fulfillment_cx = traits::FulfillmentContext::new();\n-                for obligation in obligations.iter().map(|o| o.to_obligation()) {\n-                    fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n-                }\n-\n-                if let Err(errors) = fulfillment_cx.select_all_or_error(&infcx) {\n-                    infcx.report_fulfillment_errors(&errors);\n-                }\n-            });\n-        }\n+pub fn check_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult {\n+    tcx.sess.track_errors(|| {\n+        let mut visit = CheckItemBodiesVisitor { tcx: tcx };\n+        tcx.visit_all_item_likes_in_krate(DepNode::TypeckTables, &mut visit);\n     })\n }\n \n-pub fn check_drop_impls(ccx: &CrateCtxt) -> CompileResult {\n-    ccx.tcx.sess.track_errors(|| {\n-        let _task = ccx.tcx.dep_graph.in_task(DepNode::Dropck);\n-        let drop_trait = match ccx.tcx.lang_items.drop_trait() {\n-            Some(id) => ccx.tcx.lookup_trait_def(id), None => { return }\n+pub fn check_drop_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult {\n+    tcx.sess.track_errors(|| {\n+        let _task = tcx.dep_graph.in_task(DepNode::Dropck);\n+        let drop_trait = match tcx.lang_items.drop_trait() {\n+            Some(id) => tcx.lookup_trait_def(id), None => { return }\n         };\n-        drop_trait.for_each_impl(ccx.tcx, |drop_impl_did| {\n-            let _task = ccx.tcx.dep_graph.in_task(DepNode::DropckImpl(drop_impl_did));\n+        drop_trait.for_each_impl(tcx, |drop_impl_did| {\n+            let _task = tcx.dep_graph.in_task(DepNode::DropckImpl(drop_impl_did));\n             if drop_impl_did.is_local() {\n-                match dropck::check_drop_impl(ccx, drop_impl_did) {\n+                match dropck::check_drop_impl(tcx, drop_impl_did) {\n                     Ok(()) => {}\n                     Err(()) => {\n-                        assert!(ccx.tcx.sess.has_errors());\n+                        assert!(tcx.sess.has_errors());\n                     }\n                 }\n             }\n         });\n     })\n }\n \n-fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                           decl: &'tcx hir::FnDecl,\n-                           body_id: hir::BodyId,\n-                           fn_id: ast::NodeId,\n-                           span: Span) {\n-    let body = ccx.tcx.hir.body(body_id);\n-\n-    let raw_fty = ccx.tcx.item_type(ccx.tcx.hir.local_def_id(fn_id));\n-    let fn_ty = match raw_fty.sty {\n-        ty::TyFnDef(.., f) => f,\n-        _ => span_bug!(body.value.span, \"check_bare_fn: function type expected\")\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        typeck_tables,\n+        closure_type,\n+        closure_kind,\n+        ..*providers\n+    };\n+}\n+\n+fn closure_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          def_id: DefId)\n+                          -> ty::PolyFnSig<'tcx> {\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    tcx.item_tables(def_id).closure_tys[&node_id]\n+}\n+\n+fn closure_kind<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          def_id: DefId)\n+                          -> ty::ClosureKind {\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    tcx.item_tables(def_id).closure_kinds[&node_id]\n+}\n+\n+fn typeck_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           def_id: DefId)\n+                           -> &'tcx ty::TypeckTables<'tcx> {\n+    // Closures' tables come from their outermost function,\n+    // as they are part of the same \"inference environment\".\n+    let outer_def_id = tcx.closure_base_def_id(def_id);\n+    if outer_def_id != def_id {\n+        return tcx.item_tables(outer_def_id);\n+    }\n+\n+    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let span = tcx.hir.span(id);\n+    let unsupported = || {\n+        span_bug!(span, \"can't type-check body of {:?}\", def_id);\n     };\n \n-    check_abi(ccx, span, fn_ty.abi);\n+    // Figure out what primary body this item has.\n+    let mut fn_decl = None;\n+    let body_id = match tcx.hir.get(id) {\n+        hir::map::NodeItem(item) => {\n+            match item.node {\n+                hir::ItemConst(_, body) |\n+                hir::ItemStatic(_, _, body) => body,\n+                hir::ItemFn(ref decl, .., body) => {\n+                    fn_decl = Some(decl);\n+                    body\n+                }\n+                _ => unsupported()\n+            }\n+        }\n+        hir::map::NodeTraitItem(item) => {\n+            match item.node {\n+                hir::TraitItemKind::Const(_, Some(body)) => body,\n+                hir::TraitItemKind::Method(ref sig,\n+                    hir::TraitMethod::Provided(body)) => {\n+                        fn_decl = Some(&sig.decl);\n+                        body\n+                    }\n+                _ => unsupported()\n+            }\n+        }\n+        hir::map::NodeImplItem(item) => {\n+            match item.node {\n+                hir::ImplItemKind::Const(_, body) => body,\n+                hir::ImplItemKind::Method(ref sig, body) => {\n+                    fn_decl = Some(&sig.decl);\n+                    body\n+                }\n+                _ => unsupported()\n+            }\n+        }\n+        hir::map::NodeExpr(expr) => {\n+            // FIXME(eddyb) Closures should have separate\n+            // function definition IDs and expression IDs.\n+            // Type-checking should not let closures get\n+            // this far in a constant position.\n+            // Assume that everything other than closures\n+            // is a constant \"initializer\" expression.\n+            match expr.node {\n+                hir::ExprClosure(..) => {\n+                    // We should've bailed out above for closures.\n+                    span_bug!(expr.span, \"unexpected closure\")\n+                }\n+                _ => hir::BodyId { node_id: expr.id }\n+            }\n+        }\n+        _ => unsupported()\n+    };\n+    let body = tcx.hir.body(body_id);\n+\n+    Inherited::build(tcx, id).enter(|inh| {\n+        let fcx = if let Some(decl) = fn_decl {\n+            let fn_sig = tcx.item_type(def_id).fn_sig();\n+\n+            check_abi(tcx, span, fn_sig.abi());\n+\n+            // Compute the fty from point of view of inside fn.\n+            let fn_scope = inh.tcx.region_maps.call_site_extent(id, body_id.node_id);\n+            let fn_sig =\n+                fn_sig.subst(inh.tcx, &inh.parameter_environment.free_substs);\n+            let fn_sig =\n+                inh.tcx.liberate_late_bound_regions(fn_scope, &fn_sig);\n+            let fn_sig =\n+                inh.normalize_associated_types_in(body.value.span, body_id.node_id, &fn_sig);\n \n-    ccx.inherited(fn_id).enter(|inh| {\n-        // Compute the fty from point of view of inside fn.\n-        let fn_scope = inh.tcx.region_maps.call_site_extent(fn_id, body_id.node_id);\n-        let fn_sig =\n-            fn_ty.sig.subst(inh.tcx, &inh.parameter_environment.free_substs);\n-        let fn_sig =\n-            inh.tcx.liberate_late_bound_regions(fn_scope, &fn_sig);\n-        let fn_sig =\n-            inh.normalize_associated_types_in(body.value.span, body_id.node_id, &fn_sig);\n+            check_fn(&inh, fn_sig, decl, id, body)\n+        } else {\n+            let expected_type = tcx.item_type(def_id);\n+            let fcx = FnCtxt::new(&inh, None, body.value.id);\n+            fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n+\n+            // Gather locals in statics (because of block expressions).\n+            // This is technically unnecessary because locals in static items are forbidden,\n+            // but prevents type checking from blowing up before const checking can properly\n+            // emit an error.\n+            GatherLocalsVisitor { fcx: &fcx }.visit_body(body);\n \n-        let fcx = check_fn(&inh, fn_ty.unsafety, fn_id, &fn_sig, decl, fn_id, body);\n+            fcx.check_expr_coercable_to_type(&body.value, expected_type);\n+\n+            fcx\n+        };\n \n         fcx.select_all_obligations_and_apply_defaults();\n         fcx.closure_analyze(body);\n         fcx.select_obligations_where_possible();\n         fcx.check_casts();\n-        fcx.select_all_obligations_or_error(); // Casts can introduce new obligations.\n+        fcx.select_all_obligations_or_error();\n \n-        fcx.regionck_fn(fn_id, body);\n-        fcx.resolve_type_vars_in_body(body);\n-    });\n+        if fn_decl.is_some() {\n+            fcx.regionck_fn(id, body);\n+        } else {\n+            fcx.regionck_expr(body);\n+        }\n+\n+        fcx.resolve_type_vars_in_body(body)\n+    })\n }\n \n-fn check_abi<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, span: Span, abi: Abi) {\n-    if !ccx.tcx.sess.target.target.is_abi_supported(abi) {\n-        struct_span_err!(ccx.tcx.sess, span, E0570,\n+fn check_abi<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, abi: Abi) {\n+    if !tcx.sess.target.target.is_abi_supported(abi) {\n+        struct_span_err!(tcx.sess, span, E0570,\n             \"The ABI `{}` is not supported for the current target\", abi).emit()\n     }\n }\n@@ -782,16 +840,14 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n                 _: hir::BodyId, _: Span, _: ast::NodeId) { }\n }\n \n-/// Helper used by check_bare_fn and check_expr_fn. Does the grungy work of checking a function\n+/// Helper used for fns and closures. Does the grungy work of checking a function\n /// body and returns the function context used for that purpose, since in the case of a fn item\n /// there is still a bit more to do.\n ///\n /// * ...\n /// * inherited: other fields inherited from the enclosing fn (if any)\n fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n-                            unsafety: hir::Unsafety,\n-                            unsafety_id: ast::NodeId,\n-                            fn_sig: &ty::FnSig<'tcx>,\n+                            fn_sig: ty::FnSig<'tcx>,\n                             decl: &'gcx hir::FnDecl,\n                             fn_id: ast::NodeId,\n                             body: &'gcx hir::Body)\n@@ -805,12 +861,17 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     // in the case of function expressions, based on the outer context.\n     let mut fcx = FnCtxt::new(inherited, None, body.value.id);\n     let ret_ty = fn_sig.output();\n-    *fcx.ps.borrow_mut() = UnsafetyState::function(unsafety, unsafety_id);\n+    *fcx.ps.borrow_mut() = UnsafetyState::function(fn_sig.unsafety, fn_id);\n \n     fcx.require_type_is_sized(ret_ty, decl.output.span(), traits::ReturnType);\n     fcx.ret_ty = fcx.instantiate_anon_types(&Some(ret_ty));\n-    fn_sig = fcx.tcx.mk_fn_sig(fn_sig.inputs().iter().cloned(), &fcx.ret_ty.unwrap(),\n-                               fn_sig.variadic);\n+    fn_sig = fcx.tcx.mk_fn_sig(\n+        fn_sig.inputs().iter().cloned(),\n+        fcx.ret_ty.unwrap(),\n+        fn_sig.variadic,\n+        fn_sig.unsafety,\n+        fn_sig.abi\n+    );\n \n     GatherLocalsVisitor { fcx: &fcx, }.visit_body(body);\n \n@@ -836,79 +897,85 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     fcx\n }\n \n-fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n-    let def_id = ccx.tcx.hir.local_def_id(id);\n-    check_representable(ccx.tcx, span, def_id);\n+fn check_struct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          id: ast::NodeId,\n+                          span: Span) {\n+    let def_id = tcx.hir.local_def_id(id);\n+    check_representable(tcx, span, def_id);\n \n-    if ccx.tcx.lookup_simd(def_id) {\n-        check_simd(ccx.tcx, span, def_id);\n+    if tcx.lookup_adt_def(def_id).repr.simd {\n+        check_simd(tcx, span, def_id);\n     }\n }\n \n-fn check_union(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n-    check_representable(ccx.tcx, span, ccx.tcx.hir.local_def_id(id));\n+fn check_union<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         id: ast::NodeId,\n+                         span: Span) {\n+    check_representable(tcx, span, tcx.hir.local_def_id(id));\n }\n \n-pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n+pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item) {\n     debug!(\"check_item_type(it.id={}, it.name={})\",\n            it.id,\n-           ccx.tcx.item_path_str(ccx.tcx.hir.local_def_id(it.id)));\n+           tcx.item_path_str(tcx.hir.local_def_id(it.id)));\n     let _indenter = indenter();\n     match it.node {\n       // Consts can play a role in type-checking, so they are included here.\n-      hir::ItemStatic(.., e) |\n-      hir::ItemConst(_, e) => check_const(ccx, e, it.id),\n+      hir::ItemStatic(..) |\n+      hir::ItemConst(..) => {\n+        tcx.item_tables(tcx.hir.local_def_id(it.id));\n+      }\n       hir::ItemEnum(ref enum_definition, _) => {\n-        check_enum_variants(ccx,\n+        check_enum_variants(tcx,\n                             it.span,\n                             &enum_definition.variants,\n                             it.id);\n       }\n       hir::ItemFn(..) => {} // entirely within check_item_body\n       hir::ItemImpl(.., ref impl_item_refs) => {\n           debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n-          let impl_def_id = ccx.tcx.hir.local_def_id(it.id);\n-          if let Some(impl_trait_ref) = ccx.tcx.impl_trait_ref(impl_def_id) {\n-              check_impl_items_against_trait(ccx,\n+          let impl_def_id = tcx.hir.local_def_id(it.id);\n+          if let Some(impl_trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n+              check_impl_items_against_trait(tcx,\n                                              it.span,\n                                              impl_def_id,\n                                              impl_trait_ref,\n                                              impl_item_refs);\n               let trait_def_id = impl_trait_ref.def_id;\n-              check_on_unimplemented(ccx, trait_def_id, it);\n+              check_on_unimplemented(tcx, trait_def_id, it);\n           }\n       }\n       hir::ItemTrait(..) => {\n-        let def_id = ccx.tcx.hir.local_def_id(it.id);\n-        check_on_unimplemented(ccx, def_id, it);\n+        let def_id = tcx.hir.local_def_id(it.id);\n+        check_on_unimplemented(tcx, def_id, it);\n       }\n       hir::ItemStruct(..) => {\n-        check_struct(ccx, it.id, it.span);\n+        check_struct(tcx, it.id, it.span);\n       }\n       hir::ItemUnion(..) => {\n-        check_union(ccx, it.id, it.span);\n+        check_union(tcx, it.id, it.span);\n       }\n       hir::ItemTy(_, ref generics) => {\n-        let def_id = ccx.tcx.hir.local_def_id(it.id);\n-        let pty_ty = ccx.tcx.item_type(def_id);\n-        check_bounds_are_used(ccx, generics, pty_ty);\n+        let def_id = tcx.hir.local_def_id(it.id);\n+        let pty_ty = tcx.item_type(def_id);\n+        check_bounds_are_used(tcx, generics, pty_ty);\n       }\n       hir::ItemForeignMod(ref m) => {\n-        check_abi(ccx, it.span, m.abi);\n+        check_abi(tcx, it.span, m.abi);\n \n         if m.abi == Abi::RustIntrinsic {\n             for item in &m.items {\n-                intrinsic::check_intrinsic_type(ccx, item);\n+                intrinsic::check_intrinsic_type(tcx, item);\n             }\n         } else if m.abi == Abi::PlatformIntrinsic {\n             for item in &m.items {\n-                intrinsic::check_platform_intrinsic_type(ccx, item);\n+                intrinsic::check_platform_intrinsic_type(tcx, item);\n             }\n         } else {\n             for item in &m.items {\n-                let generics = ccx.tcx.item_generics(ccx.tcx.hir.local_def_id(item.id));\n+                let generics = tcx.item_generics(tcx.hir.local_def_id(item.id));\n                 if !generics.types.is_empty() {\n-                    let mut err = struct_span_err!(ccx.tcx.sess, item.span, E0044,\n+                    let mut err = struct_span_err!(tcx.sess, item.span, E0044,\n                         \"foreign items may not have type parameters\");\n                     span_help!(&mut err, item.span,\n                         \"consider using specialization instead of \\\n@@ -917,7 +984,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n                 }\n \n                 if let hir::ForeignItemFn(ref fn_decl, _, _) = item.node {\n-                    require_c_abi_if_variadic(ccx.tcx, fn_decl, m.abi, item.span);\n+                    require_c_abi_if_variadic(tcx, fn_decl, m.abi, item.span);\n                 }\n             }\n         }\n@@ -926,10 +993,10 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n     }\n }\n \n-fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn check_on_unimplemented<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     def_id: DefId,\n                                     item: &hir::Item) {\n-    let generics = ccx.tcx.item_generics(def_id);\n+    let generics = tcx.item_generics(def_id);\n     if let Some(ref attr) = item.attrs.iter().find(|a| {\n         a.check_name(\"rustc_on_unimplemented\")\n     }) {\n@@ -949,16 +1016,16 @@ fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         }) {\n                             Some(_) => (),\n                             None => {\n-                                let name = ccx.tcx.item_name(def_id);\n-                                span_err!(ccx.tcx.sess, attr.span, E0230,\n+                                let name = tcx.item_name(def_id);\n+                                span_err!(tcx.sess, attr.span, E0230,\n                                                  \"there is no type parameter \\\n                                                           {} on trait {}\",\n                                                            s, name);\n                             }\n                         },\n                         // `{:1}` and `{}` are not to be used\n                         Position::ArgumentIs(_) => {\n-                            span_err!(ccx.tcx.sess, attr.span, E0231,\n+                            span_err!(tcx.sess, attr.span, E0231,\n                                                   \"only named substitution \\\n                                                    parameters are allowed\");\n                         }\n@@ -967,7 +1034,7 @@ fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             }\n         } else {\n             struct_span_err!(\n-                ccx.tcx.sess, attr.span, E0232,\n+                tcx.sess, attr.span, E0232,\n                 \"this attribute must have a value\")\n                 .span_label(attr.span, &format!(\"attribute requires a value\"))\n                 .note(&format!(\"eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\"))\n@@ -1025,7 +1092,7 @@ fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n }\n \n-fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             impl_span: Span,\n                                             impl_id: DefId,\n                                             impl_trait_ref: ty::TraitRef<'tcx>,\n@@ -1036,11 +1103,10 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     if impl_trait_ref.references_error() { return; }\n \n     // Locate trait definition and items\n-    let tcx = ccx.tcx;\n     let trait_def = tcx.lookup_trait_def(impl_trait_ref.def_id);\n     let mut overridden_associated_type = None;\n \n-    let impl_items = || impl_item_refs.iter().map(|iiref| ccx.tcx.hir.impl_item(iiref.id));\n+    let impl_items = || impl_item_refs.iter().map(|iiref| tcx.hir.impl_item(iiref.id));\n \n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n@@ -1055,7 +1121,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 hir::ImplItemKind::Const(..) => {\n                     // Find associated const definition.\n                     if ty_trait_item.kind == ty::AssociatedKind::Const {\n-                        compare_const_impl(ccx,\n+                        compare_const_impl(tcx,\n                                            &ty_impl_item,\n                                            impl_item.span,\n                                            &ty_trait_item,\n@@ -1079,7 +1145,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     let trait_span = tcx.hir.span_if_local(ty_trait_item.def_id);\n                     if ty_trait_item.kind == ty::AssociatedKind::Method {\n                         let err_count = tcx.sess.err_count();\n-                        compare_impl_method(ccx,\n+                        compare_impl_method(tcx,\n                                             &ty_impl_item,\n                                             impl_item.span,\n                                             body_id.node_id,\n@@ -1089,7 +1155,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             true); // start with old-broken-mode\n                         if err_count == tcx.sess.err_count() {\n                             // old broken mode did not report an error. Try with the new mode.\n-                            compare_impl_method(ccx,\n+                            compare_impl_method(tcx,\n                                                 &ty_impl_item,\n                                                 impl_item.span,\n                                                 body_id.node_id,\n@@ -1201,42 +1267,6 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-/// Checks a constant with a given type.\n-fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n-                                   body: hir::BodyId,\n-                                   expected_type: Ty<'tcx>,\n-                                   id: ast::NodeId) {\n-    let body = ccx.tcx.hir.body(body);\n-    ccx.inherited(id).enter(|inh| {\n-        let fcx = FnCtxt::new(&inh, None, body.value.id);\n-        fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n-\n-        // Gather locals in statics (because of block expressions).\n-        // This is technically unnecessary because locals in static items are forbidden,\n-        // but prevents type checking from blowing up before const checking can properly\n-        // emit an error.\n-        GatherLocalsVisitor { fcx: &fcx }.visit_body(body);\n-\n-        fcx.check_expr_coercable_to_type(&body.value, expected_type);\n-\n-        fcx.select_all_obligations_and_apply_defaults();\n-        fcx.closure_analyze(body);\n-        fcx.select_obligations_where_possible();\n-        fcx.check_casts();\n-        fcx.select_all_obligations_or_error();\n-\n-        fcx.regionck_expr(body);\n-        fcx.resolve_type_vars_in_body(body);\n-    });\n-}\n-\n-fn check_const<'a, 'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                         body: hir::BodyId,\n-                         id: ast::NodeId) {\n-    let decl_ty = ccx.tcx.item_type(ccx.tcx.hir.local_def_id(id));\n-    check_const_with_type(ccx, body, decl_ty, id);\n-}\n-\n /// Checks whether a type can be represented in memory. In particular, it\n /// identifies types that contain themselves without indirection through a\n /// pointer, which would mean their size is unbounded.\n@@ -1292,64 +1322,59 @@ pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId\n }\n \n #[allow(trivial_numeric_casts)]\n-pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                    sp: Span,\n-                                    vs: &'tcx [hir::Variant],\n-                                    id: ast::NodeId) {\n-    let def_id = ccx.tcx.hir.local_def_id(id);\n-    let hint = *ccx.tcx.lookup_repr_hints(def_id).get(0).unwrap_or(&attr::ReprAny);\n-\n-    if hint != attr::ReprAny && vs.is_empty() {\n+pub fn check_enum_variants<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     sp: Span,\n+                                     vs: &'tcx [hir::Variant],\n+                                     id: ast::NodeId) {\n+    let def_id = tcx.hir.local_def_id(id);\n+    let def = tcx.lookup_adt_def(def_id);\n+\n+    if vs.is_empty() && tcx.has_attr(def_id, \"repr\") {\n         struct_span_err!(\n-            ccx.tcx.sess, sp, E0084,\n+            tcx.sess, sp, E0084,\n             \"unsupported representation for zero-variant enum\")\n             .span_label(sp, &format!(\"unsupported enum representation\"))\n             .emit();\n     }\n \n-    let repr_type_ty = ccx.tcx.enum_repr_type(Some(&hint)).to_ty(ccx.tcx);\n-    if repr_type_ty == ccx.tcx.types.i128 || repr_type_ty == ccx.tcx.types.u128 {\n-        if !ccx.tcx.sess.features.borrow().i128_type {\n-            emit_feature_err(&ccx.tcx.sess.parse_sess,\n+    let repr_type_ty = def.repr.discr_type().to_ty(tcx);\n+    if repr_type_ty == tcx.types.i128 || repr_type_ty == tcx.types.u128 {\n+        if !tcx.sess.features.borrow().i128_type {\n+            emit_feature_err(&tcx.sess.parse_sess,\n                              \"i128_type\", sp, GateIssue::Language, \"128-bit type is unstable\");\n         }\n     }\n \n     for v in vs {\n         if let Some(e) = v.node.disr_expr {\n-            check_const_with_type(ccx, e, repr_type_ty, e.node_id);\n+            tcx.item_tables(tcx.hir.local_def_id(e.node_id));\n         }\n     }\n \n-    let def_id = ccx.tcx.hir.local_def_id(id);\n-\n-    let variants = &ccx.tcx.lookup_adt_def(def_id).variants;\n-    let mut disr_vals: Vec<ty::Disr> = Vec::new();\n-    for (v, variant) in vs.iter().zip(variants.iter()) {\n-        let current_disr_val = variant.disr_val;\n-\n+    let mut disr_vals: Vec<ConstInt> = Vec::new();\n+    for (discr, v) in def.discriminants(tcx).zip(vs) {\n         // Check for duplicate discriminant values\n-        if let Some(i) = disr_vals.iter().position(|&x| x == current_disr_val) {\n-            let variant_i_node_id = ccx.tcx.hir.as_local_node_id(variants[i].did).unwrap();\n-            let variant_i = ccx.tcx.hir.expect_variant(variant_i_node_id);\n+        if let Some(i) = disr_vals.iter().position(|&x| x == discr) {\n+            let variant_i_node_id = tcx.hir.as_local_node_id(def.variants[i].did).unwrap();\n+            let variant_i = tcx.hir.expect_variant(variant_i_node_id);\n             let i_span = match variant_i.node.disr_expr {\n-                Some(expr) => ccx.tcx.hir.span(expr.node_id),\n-                None => ccx.tcx.hir.span(variant_i_node_id)\n+                Some(expr) => tcx.hir.span(expr.node_id),\n+                None => tcx.hir.span(variant_i_node_id)\n             };\n             let span = match v.node.disr_expr {\n-                Some(expr) => ccx.tcx.hir.span(expr.node_id),\n+                Some(expr) => tcx.hir.span(expr.node_id),\n                 None => v.span\n             };\n-            struct_span_err!(ccx.tcx.sess, span, E0081,\n+            struct_span_err!(tcx.sess, span, E0081,\n                              \"discriminant value `{}` already exists\", disr_vals[i])\n                 .span_label(i_span, &format!(\"first use of `{}`\", disr_vals[i]))\n                 .span_label(span , &format!(\"enum already has `{}`\", disr_vals[i]))\n                 .emit();\n         }\n-        disr_vals.push(current_disr_val);\n+        disr_vals.push(discr);\n     }\n \n-    check_representable(ccx.tcx, sp, def_id);\n+    check_representable(tcx, sp, def_id);\n }\n \n impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n@@ -1359,57 +1384,30 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         &self.ast_ty_to_ty_cache\n     }\n \n-    fn get_generics(&self, _: Span, id: DefId)\n-                    -> Result<&'tcx ty::Generics<'tcx>, ErrorReported>\n-    {\n-        Ok(self.tcx().item_generics(id))\n-    }\n-\n-    fn get_item_type(&self, _: Span, id: DefId) -> Result<Ty<'tcx>, ErrorReported>\n-    {\n-        Ok(self.tcx().item_type(id))\n-    }\n-\n-    fn get_trait_def(&self, _: Span, id: DefId)\n-                     -> Result<&'tcx ty::TraitDef, ErrorReported>\n-    {\n-        Ok(self.tcx().lookup_trait_def(id))\n-    }\n-\n-    fn ensure_super_predicates(&self, _: Span, _: DefId) -> Result<(), ErrorReported> {\n-        // all super predicates are ensured during collect pass\n-        Ok(())\n-    }\n-\n     fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n         Some(&self.parameter_environment.free_substs)\n     }\n \n-    fn get_type_parameter_bounds(&self,\n-                                 _: Span,\n-                                 node_id: ast::NodeId)\n-                                 -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>\n+    fn get_type_parameter_bounds(&self, _: Span, def_id: DefId)\n+                                 -> ty::GenericPredicates<'tcx>\n     {\n-        let def = self.tcx.type_parameter_def(node_id);\n-        let r = self.parameter_environment\n-                                  .caller_bounds\n-                                  .iter()\n-                                  .filter_map(|predicate| {\n-                                      match *predicate {\n-                                          ty::Predicate::Trait(ref data) => {\n-                                              if data.0.self_ty().is_param(def.index) {\n-                                                  Some(data.to_poly_trait_ref())\n-                                              } else {\n-                                                  None\n-                                              }\n-                                          }\n-                                          _ => {\n-                                              None\n-                                          }\n-                                      }\n-                                  })\n-                                  .collect();\n-        Ok(r)\n+        let tcx = self.tcx;\n+        let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+        let item_id = tcx.hir.ty_param_owner(node_id);\n+        let item_def_id = tcx.hir.local_def_id(item_id);\n+        let generics = tcx.item_generics(item_def_id);\n+        let index = generics.type_param_to_index[&def_id.index];\n+        ty::GenericPredicates {\n+            parent: None,\n+            predicates: self.parameter_environment.caller_bounds.iter().filter(|predicate| {\n+                match **predicate {\n+                    ty::Predicate::Trait(ref data) => {\n+                        data.0.self_ty().is_param(index)\n+                    }\n+                    _ => false\n+                }\n+            }).cloned().collect()\n+        }\n     }\n \n     fn re_infer(&self, span: Span, def: Option<&ty::RegionParameterDef>)\n@@ -1426,7 +1424,7 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn ty_infer_for_def(&self,\n-                        ty_param_def: &ty::TypeParameterDef<'tcx>,\n+                        ty_param_def: &ty::TypeParameterDef,\n                         substs: &[Kind<'tcx>],\n                         span: Span) -> Ty<'tcx> {\n         self.type_var_for_def(span, ty_param_def, substs)\n@@ -1491,7 +1489,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         FnCtxt {\n             ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n             body_id: body_id,\n-            writeback_errors: Cell::new(false),\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_ty: rty,\n             ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal,\n@@ -1506,10 +1503,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn param_env(&self) -> &ty::ParameterEnvironment<'gcx> {\n-        &self.parameter_environment\n-    }\n-\n     pub fn sess(&self) -> &Session {\n         &self.tcx.sess\n     }\n@@ -1611,6 +1604,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if ty.references_error() {\n             self.has_errors.set(true);\n+            self.set_tainted_by_errors();\n         }\n \n         // FIXME(canndrew): This is_never should probably be an is_uninhabited\n@@ -1698,12 +1692,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if let ty::TyAnon(def_id, substs) = ty.sty {\n                 // Use the same type variable if the exact same TyAnon appears more\n                 // than once in the return type (e.g. if it's pased to a type alias).\n-                if let Some(ty_var) = self.anon_types.borrow().get(&def_id) {\n+                let id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n+                if let Some(ty_var) = self.anon_types.borrow().get(&id) {\n                     return ty_var;\n                 }\n                 let span = self.tcx.def_span(def_id);\n                 let ty_var = self.next_ty_var(TypeVariableOrigin::TypeInference(span));\n-                self.anon_types.borrow_mut().insert(def_id, ty_var);\n+                self.anon_types.borrow_mut().insert(id, ty_var);\n \n                 let item_predicates = self.tcx.item_predicates(def_id);\n                 let bounds = item_predicates.instantiate(self.tcx, substs);\n@@ -1756,10 +1751,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.write_ty(node_id, self.tcx.mk_nil());\n     }\n \n-    pub fn write_never(&self, node_id: ast::NodeId) {\n-        self.write_ty(node_id, self.tcx.types.never);\n-    }\n-\n     pub fn write_error(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, self.tcx.types.err);\n     }\n@@ -2242,11 +2233,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n \n-        // Steal the deferred obligations before the fulfillment\n-        // context can turn all of them into errors.\n-        let obligations = fulfillment_cx.take_deferred_obligations();\n-        self.deferred_obligations.borrow_mut().extend(obligations);\n-\n         match fulfillment_cx.select_all_or_error(self) {\n             Ok(()) => { }\n             Err(errors) => { self.report_fulfillment_errors(&errors); }\n@@ -2420,13 +2406,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let expected_arg_tys = self.expected_types_for_fn_args(\n                         sp,\n                         expected,\n-                        fty.sig.0.output(),\n-                        &fty.sig.0.inputs()[1..]\n+                        fty.0.output(),\n+                        &fty.0.inputs()[1..]\n                     );\n-                    self.check_argument_types(sp, &fty.sig.0.inputs()[1..], &expected_arg_tys[..],\n-                                              args_no_rcvr, fty.sig.0.variadic, tuple_arguments,\n+                    self.check_argument_types(sp, &fty.0.inputs()[1..], &expected_arg_tys[..],\n+                                              args_no_rcvr, fty.0.variadic, tuple_arguments,\n                                               self.tcx.hir.span_if_local(def_id));\n-                    fty.sig.0.output()\n+                    fty.0.output()\n                 }\n                 _ => {\n                     span_bug!(callee_expr.span, \"method without bare fn type\");\n@@ -4305,7 +4291,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let container = self.tcx.associated_item(def_id).container;\n                 match container {\n                     ty::TraitContainer(trait_did) => {\n-                        callee::check_legal_trait_for_method_call(self.ccx, span, trait_did)\n+                        callee::check_legal_trait_for_method_call(self.tcx, span, trait_did)\n                     }\n                     ty::ImplContainer(_) => {}\n                 }\n@@ -4336,7 +4322,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // errors if type parameters are provided in an inappropriate place.\n         let poly_segments = type_segment.is_some() as usize +\n                             fn_segment.is_some() as usize;\n-        self.tcx.prohibit_type_params(&segments[..segments.len() - poly_segments]);\n+        AstConv::prohibit_type_params(self, &segments[..segments.len() - poly_segments]);\n \n         match def {\n             Def::Local(def_id) | Def::Upvar(def_id, ..) => {\n@@ -4423,8 +4409,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if let Some(ast_ty) = types.get(i) {\n                 // A provided type parameter.\n                 self.to_ty(ast_ty)\n-            } else if let (false, Some(default)) = (infer_types, def.default) {\n+            } else if !infer_types && def.has_default {\n                 // No type parameter provided, but a default exists.\n+                let default = self.tcx.item_type(def.def_id);\n                 default.subst_spanned(self.tcx, substs, Some(span))\n             } else {\n                 // No type parameters were provided, we can infer all.\n@@ -4537,9 +4524,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 &generics.types\n             }\n         });\n-        let required_len = type_defs.iter()\n-                                    .take_while(|d| d.default.is_none())\n-                                    .count();\n+        let required_len = type_defs.iter().take_while(|d| !d.has_default).count();\n         if types.len() > type_defs.len() {\n             let span = types[type_defs.len()].span;\n             let expected_text = count_type_params(type_defs.len());\n@@ -4627,7 +4612,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        generics: &hir::Generics,\n                                        ty: Ty<'tcx>) {\n     debug!(\"check_bounds_are_used(n_tps={}, ty={:?})\",\n@@ -4646,7 +4631,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     for (&used, param) in tps_used.iter().zip(&generics.ty_params) {\n         if !used {\n-            struct_span_err!(ccx.tcx.sess, param.span, E0091,\n+            struct_span_err!(tcx.sess, param.span, E0091,\n                 \"type parameter `{}` is unused\",\n                 param.name)\n                 .span_label(param.span, &format!(\"unused type parameter\"))"}, {"sha": "e1067d299fa01b8d3f387e367f65c7435e4c996c", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -102,8 +102,6 @@ use syntax_pos::Span;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, PatKind};\n \n-use self::SubjectNode::Subject;\n-\n // a variation on try that just returns unit\n macro_rules! ignore_err {\n     ($e:expr) => (match $e { Ok(e) => e, Err(_) => return () })\n@@ -183,7 +181,7 @@ pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     repeating_scope: ast::NodeId,\n \n     // id of AST node being analyzed (the subject of the analysis).\n-    subject: SubjectNode,\n+    subject: ast::NodeId,\n \n }\n \n@@ -195,14 +193,13 @@ impl<'a, 'gcx, 'tcx> Deref for RegionCtxt<'a, 'gcx, 'tcx> {\n }\n \n pub struct RepeatingScope(ast::NodeId);\n-pub enum SubjectNode { Subject(ast::NodeId), None }\n+pub struct Subject(ast::NodeId);\n \n impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     pub fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-               initial_repeating_scope: RepeatingScope,\n+               RepeatingScope(initial_repeating_scope): RepeatingScope,\n                initial_body_id: ast::NodeId,\n-               subject: SubjectNode) -> RegionCtxt<'a, 'gcx, 'tcx> {\n-        let RepeatingScope(initial_repeating_scope) = initial_repeating_scope;\n+               Subject(subject): Subject) -> RegionCtxt<'a, 'gcx, 'tcx> {\n         RegionCtxt {\n             fcx: fcx,\n             repeating_scope: initial_repeating_scope,\n@@ -416,13 +413,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn resolve_regions_and_report_errors(&self) {\n-        let subject_node_id = match self.subject {\n-            Subject(s) => s,\n-            SubjectNode::None => {\n-                bug!(\"cannot resolve_regions_and_report_errors \\\n-                      without subject node\");\n-            }\n-        };\n+        let subject_node_id = self.subject;\n \n         self.fcx.resolve_regions_and_report_errors(&self.free_region_map,\n                                                    subject_node_id);\n@@ -936,7 +927,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     // was applied on the base type, as that is always the case.\n                     let fn_sig = method.ty.fn_sig();\n                     let fn_sig = // late-bound regions should have been instantiated\n-                        self.tcx.no_late_bound_regions(fn_sig).unwrap();\n+                        self.tcx.no_late_bound_regions(&fn_sig).unwrap();\n                     let self_ty = fn_sig.inputs()[0];\n                     let (m, r) = match self_ty.sty {\n                         ty::TyRef(r, ref m) => (m.mutbl, r),"}, {"sha": "7b14684267173e6fc2492bf662aee95a5cfc6227", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -208,9 +208,9 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n \n         // If we are also inferred the closure kind here, update the\n         // main table and process any deferred resolutions.\n-        let closure_def_id = self.fcx.tcx.hir.local_def_id(id);\n         if let Some(&kind) = self.temp_closure_kinds.get(&id) {\n             self.fcx.tables.borrow_mut().closure_kinds.insert(id, kind);\n+            let closure_def_id = self.fcx.tcx.hir.local_def_id(id);\n             debug!(\"closure_kind({:?}) = {:?}\", closure_def_id, kind);\n \n             let mut deferred_call_resolutions ="}, {"sha": "a4cb4071b4d88c319a88c59eda07db3e9866b4b0", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 47, "deletions": 60, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -9,9 +9,8 @@\n // except according to those terms.\n \n use astconv::ExplicitSelf;\n-use check::FnCtxt;\n+use check::{Inherited, FnCtxt};\n use constrained_type_params::{identify_constrained_type_params, Parameter};\n-use CrateCtxt;\n \n use hir::def_id::DefId;\n use middle::region::{CodeExtent};\n@@ -27,8 +26,8 @@ use errors::DiagnosticBuilder;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir;\n \n-pub struct CheckTypeWellFormedVisitor<'ccx, 'tcx:'ccx> {\n-    ccx: &'ccx CrateCtxt<'ccx, 'tcx>,\n+pub struct CheckTypeWellFormedVisitor<'a, 'tcx:'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     code: ObligationCauseCode<'tcx>,\n }\n \n@@ -51,9 +50,9 @@ impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n         let id = self.id;\n         let span = self.span;\n         self.inherited.enter(|inh| {\n-            let fcx = FnCtxt::new(&inh, Some(inh.ccx.tcx.types.never), id);\n+            let fcx = FnCtxt::new(&inh, None, id);\n             let wf_tys = f(&fcx, &mut CheckTypeWellFormedVisitor {\n-                ccx: fcx.ccx,\n+                tcx: fcx.tcx.global_tcx(),\n                 code: code\n             });\n             fcx.select_all_obligations_or_error();\n@@ -62,19 +61,15 @@ impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n-    pub fn new(ccx: &'ccx CrateCtxt<'ccx, 'gcx>)\n-               -> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n+impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'gcx>)\n+               -> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         CheckTypeWellFormedVisitor {\n-            ccx: ccx,\n+            tcx: tcx,\n             code: ObligationCauseCode::MiscObligation\n         }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'ccx, 'gcx, 'gcx> {\n-        self.ccx.tcx\n-    }\n-\n     /// Checks that the field types (in a struct def'n) or argument types (in an enum def'n) are\n     /// well-formed, meaning that they do not require any constraints not declared in the struct\n     /// definition itself. For example, this definition would be illegal:\n@@ -87,10 +82,10 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n     /// not included it frequently leads to confusing errors in fn bodies. So it's better to check\n     /// the types first.\n     fn check_item_well_formed(&mut self, item: &hir::Item) {\n-        let ccx = self.ccx;\n+        let tcx = self.tcx;\n         debug!(\"check_item_well_formed(it.id={}, it.name={})\",\n                item.id,\n-               ccx.tcx.item_path_str(ccx.tcx.hir.local_def_id(item.id)));\n+               tcx.item_path_str(tcx.hir.local_def_id(item.id)));\n \n         match item.node {\n             /// Right now we check that every default trait implementation\n@@ -117,9 +112,9 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             hir::ItemImpl(_, hir::ImplPolarity::Negative, _, Some(_), ..) => {\n                 // FIXME(#27579) what amount of WF checking do we need for neg impls?\n \n-                let trait_ref = ccx.tcx.impl_trait_ref(ccx.tcx.hir.local_def_id(item.id)).unwrap();\n-                if !ccx.tcx.trait_has_default_impl(trait_ref.def_id) {\n-                    error_192(ccx, item.span);\n+                let trait_ref = tcx.impl_trait_ref(tcx.hir.local_def_id(item.id)).unwrap();\n+                if !tcx.trait_has_default_impl(trait_ref.def_id) {\n+                    error_192(tcx, item.span);\n                 }\n             }\n             hir::ItemFn(.., body_id) => {\n@@ -187,11 +182,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                     let method_ty = fcx.tcx.item_type(item.def_id);\n                     let method_ty = fcx.instantiate_type_scheme(span, free_substs, &method_ty);\n                     let predicates = fcx.instantiate_bounds(span, item.def_id, free_substs);\n-                    let fty = match method_ty.sty {\n-                        ty::TyFnDef(_, _, f) => f,\n-                        _ => bug!()\n-                    };\n-                    this.check_fn_or_method(fcx, span, fty, &predicates,\n+                    let sig = method_ty.fn_sig();\n+                    this.check_fn_or_method(fcx, span, sig, &predicates,\n                                             free_id_outlive, &mut implied_bounds);\n                     let sig_if_method = sig_if_method.expect(\"bad signature for method\");\n                     this.check_method_receiver(fcx, sig_if_method, &item,\n@@ -211,14 +203,14 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n     }\n \n     fn for_item<'tcx>(&self, item: &hir::Item)\n-                      -> CheckWfFcxBuilder<'ccx, 'gcx, 'tcx> {\n+                      -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n         self.for_id(item.id, item.span)\n     }\n \n     fn for_id<'tcx>(&self, id: ast::NodeId, span: Span)\n-                    -> CheckWfFcxBuilder<'ccx, 'gcx, 'tcx> {\n+                    -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n         CheckWfFcxBuilder {\n-            inherited: self.ccx.inherited(id),\n+            inherited: Inherited::build(self.tcx, id),\n             code: self.code.clone(),\n             id: id,\n             span: span\n@@ -270,7 +262,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         //\n         // 3) that the trait definition does not have any type parameters\n \n-        let predicates = self.tcx().item_predicates(trait_def_id);\n+        let predicates = self.tcx.item_predicates(trait_def_id);\n \n         // We must exclude the Self : Trait predicate contained by all\n         // traits.\n@@ -285,7 +277,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                 }\n             });\n \n-        let has_ty_params = self.tcx().item_generics(trait_def_id).types.len() > 1;\n+        let has_ty_params = self.tcx.item_generics(trait_def_id).types.len() > 1;\n \n         // We use an if-else here, since the generics will also trigger\n         // an extraneous error message when we find predicates like\n@@ -296,14 +288,14 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         // extraneous predicates created by things like\n         // an associated type inside the trait.\n         let mut err = None;\n-        if !self.tcx().associated_item_def_ids(trait_def_id).is_empty() {\n-            error_380(self.ccx, span);\n+        if !self.tcx.associated_item_def_ids(trait_def_id).is_empty() {\n+            error_380(self.tcx, span);\n         } else if has_ty_params {\n-            err = Some(struct_span_err!(self.tcx().sess, span, E0567,\n+            err = Some(struct_span_err!(self.tcx.sess, span, E0567,\n                 \"traits with auto impls (`e.g. impl \\\n                     Trait for ..`) can not have type parameters\"));\n         } else if has_predicates {\n-            err = Some(struct_span_err!(self.tcx().sess, span, E0568,\n+            err = Some(struct_span_err!(self.tcx.sess, span, E0568,\n                 \"traits with auto impls (`e.g. impl \\\n                     Trait for ..`) cannot have predicates\"));\n         }\n@@ -321,9 +313,9 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n     }\n \n     fn check_trait(&mut self, item: &hir::Item) {\n-        let trait_def_id = self.tcx().hir.local_def_id(item.id);\n+        let trait_def_id = self.tcx.hir.local_def_id(item.id);\n \n-        if self.tcx().trait_has_default_impl(trait_def_id) {\n+        if self.tcx.trait_has_default_impl(trait_def_id) {\n             self.check_auto_trait(trait_def_id, item.span);\n         }\n \n@@ -344,18 +336,13 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             let def_id = fcx.tcx.hir.local_def_id(item.id);\n             let ty = fcx.tcx.item_type(def_id);\n             let item_ty = fcx.instantiate_type_scheme(item.span, free_substs, &ty);\n-            let bare_fn_ty = match item_ty.sty {\n-                ty::TyFnDef(.., ref bare_fn_ty) => bare_fn_ty,\n-                _ => {\n-                    span_bug!(item.span, \"Fn item without fn type\");\n-                }\n-            };\n+            let sig = item_ty.fn_sig();\n \n             let predicates = fcx.instantiate_bounds(item.span, def_id, free_substs);\n \n             let mut implied_bounds = vec![];\n             let free_id_outlive = fcx.tcx.region_maps.call_site_extent(item.id, body_id.node_id);\n-            this.check_fn_or_method(fcx, item.span, bare_fn_ty, &predicates,\n+            this.check_fn_or_method(fcx, item.span, sig, &predicates,\n                                     free_id_outlive, &mut implied_bounds);\n             implied_bounds\n         })\n@@ -440,14 +427,14 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n     fn check_fn_or_method<'fcx, 'tcx>(&mut self,\n                                       fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                                       span: Span,\n-                                      fty: &'tcx ty::BareFnTy<'tcx>,\n+                                      sig: ty::PolyFnSig<'tcx>,\n                                       predicates: &ty::InstantiatedPredicates<'tcx>,\n                                       free_id_outlive: CodeExtent,\n                                       implied_bounds: &mut Vec<Ty<'tcx>>)\n     {\n         let free_substs = &fcx.parameter_environment.free_substs;\n-        let fty = fcx.instantiate_type_scheme(span, free_substs, &fty);\n-        let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &fty.sig);\n+        let sig = fcx.instantiate_type_scheme(span, free_substs, &sig);\n+        let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &sig);\n \n         for input_ty in sig.inputs() {\n             fcx.register_wf_obligation(&input_ty, span, self.code.clone());\n@@ -514,15 +501,15 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                                      item: &hir::Item,\n                                      ast_generics: &hir::Generics)\n     {\n-        let item_def_id = self.tcx().hir.local_def_id(item.id);\n-        let ty = self.tcx().item_type(item_def_id);\n-        if self.tcx().has_error_field(ty) {\n+        let item_def_id = self.tcx.hir.local_def_id(item.id);\n+        let ty = self.tcx.item_type(item_def_id);\n+        if self.tcx.has_error_field(ty) {\n             return;\n         }\n \n-        let ty_predicates = self.tcx().item_predicates(item_def_id);\n+        let ty_predicates = self.tcx.item_predicates(item_def_id);\n         assert_eq!(ty_predicates.parent, None);\n-        let variances = self.tcx().item_variances(item_def_id);\n+        let variances = self.tcx.item_variances(item_def_id);\n \n         let mut constrained_parameters: FxHashSet<_> =\n             variances.iter().enumerate()\n@@ -555,15 +542,15 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                          span: Span,\n                          param_name: ast::Name)\n     {\n-        let mut err = error_392(self.ccx, span, param_name);\n+        let mut err = error_392(self.tcx, span, param_name);\n \n-        let suggested_marker_id = self.tcx().lang_items.phantom_data();\n+        let suggested_marker_id = self.tcx.lang_items.phantom_data();\n         match suggested_marker_id {\n             Some(def_id) => {\n                 err.help(\n                     &format!(\"consider removing `{}` or using a marker such as `{}`\",\n                              param_name,\n-                             self.tcx().item_path_str(def_id)));\n+                             self.tcx.item_path_str(def_id)));\n             }\n             None => {\n                 // no lang items, no help!\n@@ -595,7 +582,7 @@ fn reject_shadowing_type_parameters(tcx: TyCtxt, def_id: DefId) {\n     }\n }\n \n-impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n         NestedVisitorMap::None\n     }\n@@ -681,21 +668,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn error_192(ccx: &CrateCtxt, span: Span) {\n-    span_err!(ccx.tcx.sess, span, E0192,\n+fn error_192(tcx: TyCtxt, span: Span) {\n+    span_err!(tcx.sess, span, E0192,\n               \"negative impls are only allowed for traits with \\\n                default impls (e.g., `Send` and `Sync`)\")\n }\n \n-fn error_380(ccx: &CrateCtxt, span: Span) {\n-    span_err!(ccx.tcx.sess, span, E0380,\n+fn error_380(tcx: TyCtxt, span: Span) {\n+    span_err!(tcx.sess, span, E0380,\n               \"traits with default impls (`e.g. impl \\\n                Trait for ..`) must have no methods or associated items\")\n }\n \n-fn error_392<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, span: Span, param_name: ast::Name)\n+fn error_392<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, param_name: ast::Name)\n                        -> DiagnosticBuilder<'tcx> {\n-    let mut err = struct_span_err!(ccx.tcx.sess, span, E0392,\n+    let mut err = struct_span_err!(tcx.sess, span, E0392,\n                   \"parameter `{}` is never used\", param_name);\n     err.span_label(span, &format!(\"unused type parameter\"));\n     err"}, {"sha": "1382ab34ca52048b7ba419a5800913f12649b214", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 20, "deletions": 88, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -14,14 +14,12 @@\n use self::ResolveReason::*;\n \n use check::FnCtxt;\n-use hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::fold::{TypeFolder,TypeFoldable};\n use rustc::infer::{InferCtxt, FixupError};\n use rustc::util::nodemap::{DefIdMap, DefIdSet};\n \n-use std::cell::Cell;\n use std::mem;\n \n use syntax::ast;\n@@ -34,9 +32,8 @@ use rustc::hir;\n // Entry point\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn resolve_type_vars_in_body(&self, body: &'gcx hir::Body) {\n-        assert_eq!(self.writeback_errors.get(), false);\n-\n+    pub fn resolve_type_vars_in_body(&self, body: &'gcx hir::Body)\n+                                     -> &'gcx ty::TypeckTables<'gcx> {\n         let item_id = self.tcx.hir.body_owner(body.id());\n         let item_def_id = self.tcx.hir.local_def_id(item_id);\n \n@@ -50,18 +47,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n         wbcx.visit_anon_types();\n-        wbcx.visit_deferred_obligations(item_id);\n         wbcx.visit_type_nodes();\n         wbcx.visit_cast_types();\n         wbcx.visit_lints();\n \n-        let tables = self.tcx.alloc_tables(wbcx.tables);\n-        self.tcx.tables.borrow_mut().insert(item_def_id, tables);\n-\n-        let used_trait_imports = mem::replace(&mut *self.used_trait_imports.borrow_mut(),\n+        let used_trait_imports = mem::replace(&mut self.tables.borrow_mut().used_trait_imports,\n                                               DefIdSet());\n         debug!(\"used_trait_imports({:?}) = {:?}\", item_def_id, used_trait_imports);\n-        self.tcx.used_trait_imports.borrow_mut().insert(item_def_id, used_trait_imports);\n+        wbcx.tables.used_trait_imports = used_trait_imports;\n+\n+        wbcx.tables.tainted_by_errors = self.is_tainted_by_errors();\n+\n+        self.tcx.alloc_tables(wbcx.tables)\n     }\n }\n \n@@ -197,19 +194,11 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_stmt(&mut self, s: &'gcx hir::Stmt) {\n-        if self.fcx.writeback_errors.get() {\n-            return;\n-        }\n-\n         self.visit_node_id(ResolvingExpr(s.span), s.node.id());\n         intravisit::walk_stmt(self, s);\n     }\n \n     fn visit_expr(&mut self, e: &'gcx hir::Expr) {\n-        if self.fcx.writeback_errors.get() {\n-            return;\n-        }\n-\n         self.fix_scalar_builtin_expr(e);\n \n         self.visit_node_id(ResolvingExpr(e.span), e.id);\n@@ -229,29 +218,16 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_block(&mut self, b: &'gcx hir::Block) {\n-        if self.fcx.writeback_errors.get() {\n-            return;\n-        }\n-\n         self.visit_node_id(ResolvingExpr(b.span), b.id);\n         intravisit::walk_block(self, b);\n     }\n \n     fn visit_pat(&mut self, p: &'gcx hir::Pat) {\n-        if self.fcx.writeback_errors.get() {\n-            return;\n-        }\n-\n         self.visit_node_id(ResolvingPattern(p.span), p.id);\n-\n         intravisit::walk_pat(self, p);\n     }\n \n     fn visit_local(&mut self, l: &'gcx hir::Local) {\n-        if self.fcx.writeback_errors.get() {\n-            return;\n-        }\n-\n         let var_ty = self.fcx.local_ty(l.span, l.id);\n         let var_ty = self.resolve(&var_ty, ResolvingLocal(l.span));\n         self.write_ty_to_tables(l.id, var_ty);\n@@ -261,10 +237,6 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     fn visit_upvar_borrow_map(&mut self) {\n-        if self.fcx.writeback_errors.get() {\n-            return;\n-        }\n-\n         for (upvar_id, upvar_capture) in self.fcx.tables.borrow().upvar_capture_map.iter() {\n             let new_upvar_capture = match *upvar_capture {\n                 ty::UpvarCapture::ByValue => ty::UpvarCapture::ByValue,\n@@ -282,48 +254,30 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_closures(&self) {\n-        if self.fcx.writeback_errors.get() {\n-            return\n-        }\n-\n+    fn visit_closures(&mut self) {\n         for (&id, closure_ty) in self.fcx.tables.borrow().closure_tys.iter() {\n             let closure_ty = self.resolve(closure_ty, ResolvingClosure(id));\n-            let def_id = self.tcx().hir.local_def_id(id);\n-            self.tcx().closure_tys.borrow_mut().insert(def_id, closure_ty);\n+            self.tables.closure_tys.insert(id, closure_ty);\n         }\n \n         for (&id, &closure_kind) in self.fcx.tables.borrow().closure_kinds.iter() {\n-            let def_id = self.tcx().hir.local_def_id(id);\n-            self.tcx().closure_kinds.borrow_mut().insert(def_id, closure_kind);\n+            self.tables.closure_kinds.insert(id, closure_kind);\n         }\n     }\n \n     fn visit_cast_types(&mut self) {\n-        if self.fcx.writeback_errors.get() {\n-            return\n-        }\n-\n         self.tables.cast_kinds.extend(\n             self.fcx.tables.borrow().cast_kinds.iter().map(|(&key, &value)| (key, value)));\n     }\n \n     fn visit_lints(&mut self) {\n-        if self.fcx.writeback_errors.get() {\n-            return\n-        }\n-\n         self.fcx.tables.borrow_mut().lints.transfer(&mut self.tables.lints);\n     }\n \n-    fn visit_anon_types(&self) {\n-        if self.fcx.writeback_errors.get() {\n-            return\n-        }\n-\n+    fn visit_anon_types(&mut self) {\n         let gcx = self.tcx().global_tcx();\n-        for (&def_id, &concrete_ty) in self.fcx.anon_types.borrow().iter() {\n-            let reason = ResolvingAnonTy(def_id);\n+        for (&node_id, &concrete_ty) in self.fcx.anon_types.borrow().iter() {\n+            let reason = ResolvingAnonTy(node_id);\n             let inside_ty = self.resolve(&concrete_ty, reason);\n \n             // Convert the type from the function into a type valid outside\n@@ -361,7 +315,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 }\n             });\n \n-            gcx.item_types.borrow_mut().insert(def_id, outside_ty);\n+            self.tables.node_types.insert(node_id, outside_ty);\n         }\n     }\n \n@@ -483,23 +437,10 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_deferred_obligations(&mut self, item_id: ast::NodeId) {\n-        let deferred_obligations = self.fcx.deferred_obligations.borrow();\n-        let obligations: Vec<_> = deferred_obligations.iter().map(|obligation| {\n-            let reason = ResolvingDeferredObligation(obligation.cause.span);\n-            self.resolve(obligation, reason)\n-        }).collect();\n-\n-        if !obligations.is_empty() {\n-            assert!(self.fcx.ccx.deferred_obligations.borrow_mut()\n-                                .insert(item_id, obligations).is_none());\n-        }\n-    }\n-\n     fn visit_type_nodes(&self) {\n         for (&id, ty) in self.fcx.ast_ty_to_ty_cache.borrow().iter() {\n             let ty = self.resolve(ty, ResolvingTyNode(id));\n-            self.fcx.ccx.ast_ty_to_ty_cache.borrow_mut().insert(id, ty);\n+            self.fcx.tcx.ast_ty_to_ty_cache.borrow_mut().insert(id, ty);\n         }\n     }\n \n@@ -528,8 +469,7 @@ enum ResolveReason {\n     ResolvingClosure(ast::NodeId),\n     ResolvingFnSig(ast::NodeId),\n     ResolvingFieldTypes(ast::NodeId),\n-    ResolvingAnonTy(DefId),\n-    ResolvingDeferredObligation(Span),\n+    ResolvingAnonTy(ast::NodeId),\n     ResolvingTyNode(ast::NodeId),\n }\n \n@@ -545,13 +485,10 @@ impl<'a, 'gcx, 'tcx> ResolveReason {\n             ResolvingClosure(id) |\n             ResolvingFnSig(id) |\n             ResolvingFieldTypes(id) |\n-            ResolvingTyNode(id) => {\n+            ResolvingTyNode(id) |\n+            ResolvingAnonTy(id) => {\n                 tcx.hir.span(id)\n             }\n-            ResolvingAnonTy(did) => {\n-                tcx.def_span(did)\n-            }\n-            ResolvingDeferredObligation(span) => span\n         }\n     }\n }\n@@ -563,7 +500,6 @@ impl<'a, 'gcx, 'tcx> ResolveReason {\n struct Resolver<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n-    writeback_errors: &'cx Cell<bool>,\n     reason: ResolveReason,\n }\n \n@@ -572,22 +508,19 @@ impl<'cx, 'gcx, 'tcx> Resolver<'cx, 'gcx, 'tcx> {\n            reason: ResolveReason)\n            -> Resolver<'cx, 'gcx, 'tcx>\n     {\n-        Resolver::from_infcx(fcx, &fcx.writeback_errors, reason)\n+        Resolver::from_infcx(fcx, reason)\n     }\n \n     fn from_infcx(infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n-                  writeback_errors: &'cx Cell<bool>,\n                   reason: ResolveReason)\n                   -> Resolver<'cx, 'gcx, 'tcx>\n     {\n         Resolver { infcx: infcx,\n                    tcx: infcx.tcx,\n-                   writeback_errors: writeback_errors,\n                    reason: reason }\n     }\n \n     fn report_error(&self, e: FixupError) {\n-        self.writeback_errors.set(true);\n         if !self.tcx.sess.has_errors() {\n             match self.reason {\n                 ResolvingExpr(span) => {\n@@ -626,7 +559,6 @@ impl<'cx, 'gcx, 'tcx> Resolver<'cx, 'gcx, 'tcx> {\n \n                 ResolvingFnSig(_) |\n                 ResolvingFieldTypes(_) |\n-                ResolvingDeferredObligation(_) |\n                 ResolvingTyNode(_) => {\n                     // any failures here should also fail when\n                     // resolving the patterns, closure types, or"}, {"sha": "3791079dc812cb0b6d69ffb017c38af77a64a59d", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -70,7 +70,8 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         let item_def_id = tcx.hir.local_def_id(item_id);\n \n         // this will have been written by the main typeck pass\n-        if let Some(imports) = tcx.used_trait_imports.borrow().get(&item_def_id) {\n+        if let Some(tables) = tcx.maps.typeck_tables.borrow().get(&item_def_id) {\n+            let imports = &tables.used_trait_imports;\n             debug!(\"GatherVisitor: item_def_id={:?} with imports {:#?}\", item_def_id, imports);\n             used_trait_imports.extend(imports);\n         } else {"}, {"sha": "3cdf9fc93ae600617a4c84aa935dfdb1adcaec07", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 25, "deletions": 34, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -26,47 +26,38 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n use rustc::hir::{self, ItemImpl};\n \n-pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    check_trait(tcx, tcx.lang_items.drop_trait(), visit_implementation_of_drop);\n-    check_trait(tcx, tcx.lang_items.copy_trait(), visit_implementation_of_copy);\n-    check_trait(\n-        tcx,\n-        tcx.lang_items.coerce_unsized_trait(),\n-        visit_implementation_of_coerce_unsized);\n+pub fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_def_id: DefId) {\n+    Checker { tcx, trait_def_id }\n+        .check(tcx.lang_items.drop_trait(), visit_implementation_of_drop)\n+        .check(tcx.lang_items.copy_trait(), visit_implementation_of_copy)\n+        .check(tcx.lang_items.coerce_unsized_trait(),\n+               visit_implementation_of_coerce_unsized);\n }\n \n-fn check_trait<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            trait_def_id: Option<DefId>,\n-                            mut f: F)\n-    where F: FnMut(TyCtxt<'a, 'tcx, 'tcx>, DefId, DefId)\n-{\n-    if let Some(trait_def_id) = trait_def_id {\n-        let mut impls = vec![];\n-        tcx.lookup_trait_def(trait_def_id).for_each_impl(tcx, |did| {\n-            impls.push(did);\n-        });\n-        impls.sort();\n-        for impl_def_id in impls {\n-            f(tcx, trait_def_id, impl_def_id);\n+struct Checker<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    trait_def_id: DefId\n+}\n+\n+impl<'a, 'tcx> Checker<'a, 'tcx> {\n+    fn check<F>(&self, trait_def_id: Option<DefId>, mut f: F) -> &Self\n+        where F: FnMut(TyCtxt<'a, 'tcx, 'tcx>, DefId, DefId)\n+    {\n+        if Some(self.trait_def_id) == trait_def_id {\n+            for &impl_id in self.tcx.hir.trait_impls(self.trait_def_id) {\n+                let impl_def_id = self.tcx.hir.local_def_id(impl_id);\n+                f(self.tcx, self.trait_def_id, impl_def_id);\n+            }\n         }\n+        self\n     }\n }\n \n fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                           _drop_did: DefId,\n                                           impl_did: DefId) {\n-    let items = tcx.associated_item_def_ids(impl_did);\n-    if items.is_empty() {\n-        // We'll error out later. For now, just don't ICE.\n-        return;\n-    }\n-    let method_def_id = items[0];\n-\n-    let self_type = tcx.item_type(impl_did);\n-    match self_type.sty {\n-        ty::TyAdt(type_def, _) => {\n-            type_def.set_destructor(method_def_id);\n-        }\n+    match tcx.item_type(impl_did).sty {\n+        ty::TyAdt(..) => {}\n         _ => {\n             // Destructors only work on nominal types.\n             if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_did) {\n@@ -205,7 +196,7 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            source,\n            target);\n \n-    tcx.infer_ctxt(param_env, Reveal::ExactMatch).enter(|infcx| {\n+    tcx.infer_ctxt(param_env, Reveal::UserFacing).enter(|infcx| {\n         let cause = ObligationCause::misc(span, impl_node_id);\n         let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n                            mt_b: ty::TypeAndMut<'tcx>,\n@@ -341,7 +332,7 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n \n         if let Some(kind) = kind {\n-            tcx.custom_coerce_unsized_kinds.borrow_mut().insert(impl_did, kind);\n+            tcx.maps.custom_coerce_unsized_kind.borrow_mut().insert(impl_did, kind);\n         }\n     });\n }"}, {"sha": "e3b4ba9eb1b9e3fc89da9b826cacc3d8579d2b90", "filename": "src/librustc_typeck/coherence/inherent.rs", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcoherence%2Finherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcoherence%2Finherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -0,0 +1,356 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::dep_graph::DepNode;\n+use rustc::hir::def_id::DefId;\n+use rustc::hir;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::lint;\n+use rustc::traits::{self, Reveal};\n+use rustc::ty::{self, TyCtxt};\n+\n+use syntax::ast;\n+use syntax_pos::Span;\n+\n+struct InherentCollect<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+}\n+\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &hir::Item) {\n+        let (unsafety, ty) = match item.node {\n+            hir::ItemImpl(unsafety, .., None, ref ty, _) => (unsafety, ty),\n+            _ => return\n+        };\n+\n+        match unsafety {\n+            hir::Unsafety::Normal => {\n+                // OK\n+            }\n+            hir::Unsafety::Unsafe => {\n+                span_err!(self.tcx.sess,\n+                          item.span,\n+                          E0197,\n+                          \"inherent impls cannot be declared as unsafe\");\n+            }\n+        }\n+\n+        let def_id = self.tcx.hir.local_def_id(item.id);\n+        let self_ty = self.tcx.item_type(def_id);\n+        match self_ty.sty {\n+            ty::TyAdt(def, _) => {\n+                self.check_def_id(item, def.did);\n+            }\n+            ty::TyDynamic(ref data, ..) if data.principal().is_some() => {\n+                self.check_def_id(item, data.principal().unwrap().def_id());\n+            }\n+            ty::TyChar => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.char_impl(),\n+                                          \"char\",\n+                                          \"char\",\n+                                          item.span);\n+            }\n+            ty::TyStr => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.str_impl(),\n+                                          \"str\",\n+                                          \"str\",\n+                                          item.span);\n+            }\n+            ty::TySlice(_) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.slice_impl(),\n+                                          \"slice\",\n+                                          \"[T]\",\n+                                          item.span);\n+            }\n+            ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.const_ptr_impl(),\n+                                          \"const_ptr\",\n+                                          \"*const T\",\n+                                          item.span);\n+            }\n+            ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.mut_ptr_impl(),\n+                                          \"mut_ptr\",\n+                                          \"*mut T\",\n+                                          item.span);\n+            }\n+            ty::TyInt(ast::IntTy::I8) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.i8_impl(),\n+                                          \"i8\",\n+                                          \"i8\",\n+                                          item.span);\n+            }\n+            ty::TyInt(ast::IntTy::I16) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.i16_impl(),\n+                                          \"i16\",\n+                                          \"i16\",\n+                                          item.span);\n+            }\n+            ty::TyInt(ast::IntTy::I32) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.i32_impl(),\n+                                          \"i32\",\n+                                          \"i32\",\n+                                          item.span);\n+            }\n+            ty::TyInt(ast::IntTy::I64) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.i64_impl(),\n+                                          \"i64\",\n+                                          \"i64\",\n+                                          item.span);\n+            }\n+            ty::TyInt(ast::IntTy::I128) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.i128_impl(),\n+                                          \"i128\",\n+                                          \"i128\",\n+                                          item.span);\n+            }\n+            ty::TyInt(ast::IntTy::Is) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.isize_impl(),\n+                                          \"isize\",\n+                                          \"isize\",\n+                                          item.span);\n+            }\n+            ty::TyUint(ast::UintTy::U8) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.u8_impl(),\n+                                          \"u8\",\n+                                          \"u8\",\n+                                          item.span);\n+            }\n+            ty::TyUint(ast::UintTy::U16) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.u16_impl(),\n+                                          \"u16\",\n+                                          \"u16\",\n+                                          item.span);\n+            }\n+            ty::TyUint(ast::UintTy::U32) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.u32_impl(),\n+                                          \"u32\",\n+                                          \"u32\",\n+                                          item.span);\n+            }\n+            ty::TyUint(ast::UintTy::U64) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.u64_impl(),\n+                                          \"u64\",\n+                                          \"u64\",\n+                                          item.span);\n+            }\n+            ty::TyUint(ast::UintTy::U128) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.u128_impl(),\n+                                          \"u128\",\n+                                          \"u128\",\n+                                          item.span);\n+            }\n+            ty::TyUint(ast::UintTy::Us) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.usize_impl(),\n+                                          \"usize\",\n+                                          \"usize\",\n+                                          item.span);\n+            }\n+            ty::TyFloat(ast::FloatTy::F32) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.f32_impl(),\n+                                          \"f32\",\n+                                          \"f32\",\n+                                          item.span);\n+            }\n+            ty::TyFloat(ast::FloatTy::F64) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.f64_impl(),\n+                                          \"f64\",\n+                                          \"f64\",\n+                                          item.span);\n+            }\n+            ty::TyError => {\n+                return;\n+            }\n+            _ => {\n+                struct_span_err!(self.tcx.sess,\n+                                 ty.span,\n+                                 E0118,\n+                                 \"no base type found for inherent implementation\")\n+                    .span_label(ty.span, &format!(\"impl requires a base type\"))\n+                    .note(&format!(\"either implement a trait on it or create a newtype \\\n+                                    to wrap it instead\"))\n+                    .emit();\n+                return;\n+            }\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n+}\n+\n+impl<'a, 'tcx> InherentCollect<'a, 'tcx> {\n+    fn check_def_id(&self, item: &hir::Item, def_id: DefId) {\n+        if def_id.is_local() {\n+            // Add the implementation to the mapping from implementation to base\n+            // type def ID, if there is a base type for this implementation and\n+            // the implementation does not have any associated traits.\n+            let impl_def_id = self.tcx.hir.local_def_id(item.id);\n+\n+            // Subtle: it'd be better to collect these into a local map\n+            // and then write the vector only once all items are known,\n+            // but that leads to degenerate dep-graphs. The problem is\n+            // that the write of that big vector winds up having reads\n+            // from *all* impls in the krate, since we've lost the\n+            // precision basically.  This would be ok in the firewall\n+            // model so once we've made progess towards that we can modify\n+            // the strategy here. In the meantime, using `push` is ok\n+            // because we are doing this as a pre-pass before anyone\n+            // actually reads from `inherent_impls` -- and we know this is\n+            // true beacuse we hold the refcell lock.\n+            self.tcx.maps.inherent_impls.borrow_mut().push(def_id, impl_def_id);\n+        } else {\n+            struct_span_err!(self.tcx.sess,\n+                             item.span,\n+                             E0116,\n+                             \"cannot define inherent `impl` for a type outside of the crate \\\n+                              where the type is defined\")\n+                .span_label(item.span,\n+                            &format!(\"impl for type defined outside of crate.\"))\n+                .note(\"define and implement a trait or new type instead\")\n+                .emit();\n+        }\n+    }\n+\n+    fn check_primitive_impl(&self,\n+                            impl_def_id: DefId,\n+                            lang_def_id: Option<DefId>,\n+                            lang: &str,\n+                            ty: &str,\n+                            span: Span) {\n+        match lang_def_id {\n+            Some(lang_def_id) if lang_def_id == impl_def_id => {\n+                // OK\n+            }\n+            _ => {\n+                struct_span_err!(self.tcx.sess,\n+                                 span,\n+                                 E0390,\n+                                 \"only a single inherent implementation marked with `#[lang = \\\n+                                  \\\"{}\\\"]` is allowed for the `{}` primitive\",\n+                                 lang,\n+                                 ty)\n+                    .span_help(span, \"consider using a trait to implement these methods\")\n+                    .emit();\n+            }\n+        }\n+    }\n+}\n+\n+struct InherentOverlapChecker<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+}\n+\n+impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n+    fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId) {\n+        #[derive(Copy, Clone, PartialEq)]\n+        enum Namespace {\n+            Type,\n+            Value,\n+        }\n+\n+        let name_and_namespace = |def_id| {\n+            let item = self.tcx.associated_item(def_id);\n+            (item.name, match item.kind {\n+                ty::AssociatedKind::Type => Namespace::Type,\n+                ty::AssociatedKind::Const |\n+                ty::AssociatedKind::Method => Namespace::Value,\n+            })\n+        };\n+\n+        let impl_items1 = self.tcx.associated_item_def_ids(impl1);\n+        let impl_items2 = self.tcx.associated_item_def_ids(impl2);\n+\n+        for &item1 in &impl_items1[..] {\n+            let (name, namespace) = name_and_namespace(item1);\n+\n+            for &item2 in &impl_items2[..] {\n+                if (name, namespace) == name_and_namespace(item2) {\n+                    let msg = format!(\"duplicate definitions with name `{}`\", name);\n+                    let node_id = self.tcx.hir.as_local_node_id(item1).unwrap();\n+                    self.tcx.sess.add_lint(lint::builtin::OVERLAPPING_INHERENT_IMPLS,\n+                                           node_id,\n+                                           self.tcx.span_of_impl(item1).unwrap(),\n+                                           msg);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_for_overlapping_inherent_impls(&self, ty_def_id: DefId) {\n+        let _task = self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapInherentCheck(ty_def_id));\n+\n+        let inherent_impls = self.tcx.maps.inherent_impls.borrow();\n+        let impls = match inherent_impls.get(&ty_def_id) {\n+            Some(impls) => impls,\n+            None => return,\n+        };\n+\n+        for (i, &impl1_def_id) in impls.iter().enumerate() {\n+            for &impl2_def_id in &impls[(i + 1)..] {\n+                self.tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n+                    if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n+                        self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n+                    }\n+                });\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentOverlapChecker<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &'v hir::Item) {\n+        match item.node {\n+            hir::ItemEnum(..) |\n+            hir::ItemStruct(..) |\n+            hir::ItemTrait(..) |\n+            hir::ItemUnion(..) => {\n+                let type_def_id = self.tcx.hir.local_def_id(item.id);\n+                self.check_for_overlapping_inherent_impls(type_def_id);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n+}\n+\n+pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    tcx.visit_all_item_likes_in_krate(DepNode::CoherenceCheckImpl,\n+                                      &mut InherentCollect { tcx });\n+    tcx.visit_all_item_likes_in_krate(DepNode::CoherenceOverlapCheckSpecial,\n+                                      &mut InherentOverlapChecker { tcx });\n+}"}, {"sha": "9ecf42daeaae52021fd7f60f0a4dfd91de90f3d7", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 82, "deletions": 128, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -15,147 +15,72 @@\n // done by the orphan and overlap modules. Then we build up various\n // mappings. That mapping code resides here.\n \n-use dep_graph::DepTrackingMap;\n-use hir::def_id::DefId;\n-use rustc::ty::{self, maps, TyCtxt, TypeFoldable};\n-use rustc::ty::{Ty, TyBool, TyChar, TyError};\n-use rustc::ty::{TyParam, TyRawPtr};\n-use rustc::ty::{TyRef, TyAdt, TyDynamic, TyNever, TyTuple};\n-use rustc::ty::{TyStr, TyArray, TySlice, TyFloat, TyInfer, TyInt};\n-use rustc::ty::{TyUint, TyClosure, TyFnDef, TyFnPtr};\n-use rustc::ty::{TyProjection, TyAnon};\n-use CrateCtxt;\n-use syntax_pos::Span;\n+use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc::ty::{self, TyCtxt, TypeFoldable};\n+use rustc::ty::maps::Providers;\n use rustc::dep_graph::DepNode;\n-use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::hir::{Item, ItemImpl};\n-use rustc::hir;\n-use std::cell::RefMut;\n+\n+use syntax::ast;\n+use syntax_pos::DUMMY_SP;\n \n mod builtin;\n+mod inherent;\n mod orphan;\n mod overlap;\n mod unsafety;\n \n-struct CoherenceCollect<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    inherent_impls: RefMut<'a, DepTrackingMap<maps::InherentImpls<'tcx>>>,\n-}\n-\n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceCollect<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &Item) {\n-        if let ItemImpl(..) = item.node {\n-            self.check_implementation(item)\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n-    }\n+fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n+    let impl_def_id = tcx.hir.local_def_id(node_id);\n \n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n-    }\n-}\n+    // If there are no traits, then this implementation must have a\n+    // base type.\n \n-impl<'a, 'tcx> CoherenceCollect<'a, 'tcx> {\n-    fn check(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-        let inherent_impls = tcx.inherent_impls.borrow_mut();\n-        let mut this = &mut CoherenceCollect { tcx, inherent_impls };\n+    if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n+        debug!(\"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n+                trait_ref,\n+                tcx.item_path_str(impl_def_id));\n \n-        // Check implementations and traits. This populates the tables\n-        // containing the inherent methods and extension methods. It also\n-        // builds up the trait inheritance table.\n-        tcx.visit_all_item_likes_in_krate(DepNode::CoherenceCheckImpl, this);\n-    }\n-\n-    // Returns the def ID of the base type, if there is one.\n-    fn get_base_type_def_id(&self, span: Span, ty: Ty<'tcx>) -> Option<DefId> {\n-        match ty.sty {\n-            TyAdt(def, _) => Some(def.did),\n-\n-            TyDynamic(ref t, ..) => t.principal().map(|p| p.def_id()),\n-\n-            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) | TyStr | TyArray(..) |\n-            TySlice(..) | TyFnDef(..) | TyFnPtr(_) | TyTuple(..) | TyParam(..) | TyError |\n-            TyNever | TyRawPtr(_) | TyRef(..) | TyProjection(..) => None,\n-\n-            TyInfer(..) | TyClosure(..) | TyAnon(..) => {\n-                // `ty` comes from a user declaration so we should only expect types\n-                // that the user can type\n-                span_bug!(span,\n-                          \"coherence encountered unexpected type searching for base type: {}\",\n-                          ty);\n-            }\n+        // Skip impls where one of the self type is an error type.\n+        // This occurs with e.g. resolve failures (#30589).\n+        if trait_ref.references_error() {\n+            return;\n         }\n-    }\n \n-    fn check_implementation(&mut self, item: &Item) {\n-        let tcx = self.tcx;\n-        let impl_did = tcx.hir.local_def_id(item.id);\n-        let self_type = tcx.item_type(impl_did);\n-\n-        // If there are no traits, then this implementation must have a\n-        // base type.\n-\n-        if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_did) {\n-            debug!(\"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n-                   trait_ref,\n-                   item.name);\n-\n-            // Skip impls where one of the self type is an error type.\n-            // This occurs with e.g. resolve failures (#30589).\n-            if trait_ref.references_error() {\n-                return;\n-            }\n-\n-            enforce_trait_manually_implementable(self.tcx, item.span, trait_ref.def_id);\n-            self.add_trait_impl(trait_ref, impl_did);\n-        } else {\n-            // Skip inherent impls where the self type is an error\n-            // type. This occurs with e.g. resolve failures (#30589).\n-            if self_type.references_error() {\n-                return;\n-            }\n-\n-            // Add the implementation to the mapping from implementation to base\n-            // type def ID, if there is a base type for this implementation and\n-            // the implementation does not have any associated traits.\n-            if let Some(base_def_id) = self.get_base_type_def_id(item.span, self_type) {\n-                self.add_inherent_impl(base_def_id, impl_did);\n-            }\n-        }\n+        enforce_trait_manually_implementable(tcx, impl_def_id, trait_ref.def_id);\n+        let trait_def = tcx.lookup_trait_def(trait_ref.def_id);\n+        trait_def.record_local_impl(tcx, impl_def_id, trait_ref);\n     }\n+}\n \n-    fn add_inherent_impl(&mut self, base_def_id: DefId, impl_def_id: DefId) {\n-        // Subtle: it'd be better to collect these into a local map\n-        // and then write the vector only once all items are known,\n-        // but that leads to degenerate dep-graphs. The problem is\n-        // that the write of that big vector winds up having reads\n-        // from *all* impls in the krate, since we've lost the\n-        // precision basically.  This would be ok in the firewall\n-        // model so once we've made progess towards that we can modify\n-        // the strategy here. In the meantime, using `push` is ok\n-        // because we are doing this as a pre-pass before anyone\n-        // actually reads from `inherent_impls` -- and we know this is\n-        // true beacuse we hold the refcell lock.\n-        self.inherent_impls.push(base_def_id, impl_def_id);\n+fn enforce_trait_manually_implementable(tcx: TyCtxt, impl_def_id: DefId, trait_def_id: DefId) {\n+    let did = Some(trait_def_id);\n+    let li = &tcx.lang_items;\n+\n+    // Disallow *all* explicit impls of `Sized` and `Unsize` for now.\n+    if did == li.sized_trait() {\n+        let span = tcx.span_of_impl(impl_def_id).unwrap();\n+        struct_span_err!(tcx.sess,\n+                         span,\n+                         E0322,\n+                         \"explicit impls for the `Sized` trait are not permitted\")\n+            .span_label(span, &format!(\"impl of 'Sized' not allowed\"))\n+            .emit();\n+        return;\n     }\n \n-    fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'tcx>, impl_def_id: DefId) {\n-        debug!(\"add_trait_impl: impl_trait_ref={:?} impl_def_id={:?}\",\n-               impl_trait_ref,\n-               impl_def_id);\n-        let trait_def = self.tcx.lookup_trait_def(impl_trait_ref.def_id);\n-        trait_def.record_local_impl(self.tcx, impl_def_id, impl_trait_ref);\n+    if did == li.unsize_trait() {\n+        let span = tcx.span_of_impl(impl_def_id).unwrap();\n+        span_err!(tcx.sess,\n+                  span,\n+                  E0328,\n+                  \"explicit impls for the `Unsize` trait are not permitted\");\n+        return;\n     }\n-}\n \n-fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: DefId) {\n     if tcx.sess.features.borrow().unboxed_closures {\n-        // the feature gate allows all of them\n+        // the feature gate allows all Fn traits\n         return;\n     }\n-    let did = Some(trait_def_id);\n-    let li = &tcx.lang_items;\n \n     let trait_name = if did == li.fn_trait() {\n         \"Fn\"\n@@ -167,7 +92,7 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: Def\n         return; // everything OK\n     };\n     let mut err = struct_span_err!(tcx.sess,\n-                                   sp,\n+                                   tcx.span_of_impl(impl_def_id).unwrap(),\n                                    E0183,\n                                    \"manual implementations of `{}` are experimental\",\n                                    trait_name);\n@@ -176,12 +101,41 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: Def\n     err.emit();\n }\n \n-pub fn check_coherence(ccx: &CrateCtxt) {\n-    CoherenceCollect::check(ccx.tcx);\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        coherent_trait,\n+        coherent_inherent_impls,\n+        ..*providers\n+    };\n+}\n+\n+fn coherent_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            (_, def_id): (CrateNum, DefId)) {\n+    tcx.populate_implementations_for_trait_if_necessary(def_id);\n+\n+    let impls = tcx.hir.trait_impls(def_id);\n+    for &impl_id in impls {\n+        check_impl(tcx, impl_id);\n+    }\n+    for &impl_id in impls {\n+        overlap::check_impl(tcx, impl_id);\n+    }\n+    builtin::check_trait(tcx, def_id);\n+}\n+\n+fn coherent_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, _: CrateNum) {\n+    inherent::check(tcx);\n+}\n+\n+pub fn check_coherence<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    let _task = tcx.dep_graph.in_task(DepNode::Coherence);\n+    for &trait_def_id in tcx.hir.krate().trait_impls.keys() {\n+        ty::queries::coherent_trait::get(tcx, DUMMY_SP, (LOCAL_CRATE, trait_def_id));\n+    }\n+\n+    unsafety::check(tcx);\n+    orphan::check(tcx);\n+    overlap::check_default_impls(tcx);\n \n-    let _task = ccx.tcx.dep_graph.in_task(DepNode::Coherence);\n-    unsafety::check(ccx.tcx);\n-    orphan::check(ccx.tcx);\n-    overlap::check(ccx.tcx);\n-    builtin::check(ccx.tcx);\n+    ty::queries::coherent_inherent_impls::get(tcx, DUMMY_SP, LOCAL_CRATE);\n }"}, {"sha": "ee361ab6073d4e5c4df5b2029cef9ad10a430da0", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 225, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -11,11 +11,8 @@\n //! Orphan checker: every impl either implements a trait defined in this\n //! crate or pertains to a type defined in this crate.\n \n-use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::traits;\n use rustc::ty::{self, TyCtxt};\n-use syntax::ast;\n-use syntax_pos::Span;\n use rustc::dep_graph::DepNode;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir;\n@@ -29,46 +26,6 @@ struct OrphanChecker<'cx, 'tcx: 'cx> {\n     tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n }\n \n-impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n-    fn check_def_id(&self, item: &hir::Item, def_id: DefId) {\n-        if def_id.krate != LOCAL_CRATE {\n-            struct_span_err!(self.tcx.sess,\n-                             item.span,\n-                             E0116,\n-                             \"cannot define inherent `impl` for a type outside of the crate \\\n-                              where the type is defined\")\n-                .span_label(item.span,\n-                            &format!(\"impl for type defined outside of crate.\"))\n-                .note(\"define and implement a trait or new type instead\")\n-                .emit();\n-        }\n-    }\n-\n-    fn check_primitive_impl(&self,\n-                            impl_def_id: DefId,\n-                            lang_def_id: Option<DefId>,\n-                            lang: &str,\n-                            ty: &str,\n-                            span: Span) {\n-        match lang_def_id {\n-            Some(lang_def_id) if lang_def_id == impl_def_id => {\n-                // OK\n-            }\n-            _ => {\n-                struct_span_err!(self.tcx.sess,\n-                                 span,\n-                                 E0390,\n-                                 \"only a single inherent implementation marked with `#[lang = \\\n-                                  \\\"{}\\\"]` is allowed for the `{}` primitive\",\n-                                 lang,\n-                                 ty)\n-                    .span_help(span, \"consider using a trait to implement these methods\")\n-                    .emit();\n-            }\n-        }\n-    }\n-}\n-\n impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n     /// Checks exactly one impl for orphan rules and other such\n     /// restrictions.  In this fn, it can happen that multiple errors\n@@ -78,168 +35,6 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let def_id = self.tcx.hir.local_def_id(item.id);\n         match item.node {\n-            hir::ItemImpl(.., None, ref ty, _) => {\n-                // For inherent impls, self type must be a nominal type\n-                // defined in this crate.\n-                debug!(\"coherence2::orphan check: inherent impl {}\",\n-                       self.tcx.hir.node_to_string(item.id));\n-                let self_ty = self.tcx.item_type(def_id);\n-                match self_ty.sty {\n-                    ty::TyAdt(def, _) => {\n-                        self.check_def_id(item, def.did);\n-                    }\n-                    ty::TyDynamic(ref data, ..) if data.principal().is_some() => {\n-                        self.check_def_id(item, data.principal().unwrap().def_id());\n-                    }\n-                    ty::TyChar => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.char_impl(),\n-                                                  \"char\",\n-                                                  \"char\",\n-                                                  item.span);\n-                    }\n-                    ty::TyStr => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.str_impl(),\n-                                                  \"str\",\n-                                                  \"str\",\n-                                                  item.span);\n-                    }\n-                    ty::TySlice(_) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.slice_impl(),\n-                                                  \"slice\",\n-                                                  \"[T]\",\n-                                                  item.span);\n-                    }\n-                    ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.const_ptr_impl(),\n-                                                  \"const_ptr\",\n-                                                  \"*const T\",\n-                                                  item.span);\n-                    }\n-                    ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.mut_ptr_impl(),\n-                                                  \"mut_ptr\",\n-                                                  \"*mut T\",\n-                                                  item.span);\n-                    }\n-                    ty::TyInt(ast::IntTy::I8) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.i8_impl(),\n-                                                  \"i8\",\n-                                                  \"i8\",\n-                                                  item.span);\n-                    }\n-                    ty::TyInt(ast::IntTy::I16) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.i16_impl(),\n-                                                  \"i16\",\n-                                                  \"i16\",\n-                                                  item.span);\n-                    }\n-                    ty::TyInt(ast::IntTy::I32) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.i32_impl(),\n-                                                  \"i32\",\n-                                                  \"i32\",\n-                                                  item.span);\n-                    }\n-                    ty::TyInt(ast::IntTy::I64) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.i64_impl(),\n-                                                  \"i64\",\n-                                                  \"i64\",\n-                                                  item.span);\n-                    }\n-                    ty::TyInt(ast::IntTy::I128) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.i128_impl(),\n-                                                  \"i128\",\n-                                                  \"i128\",\n-                                                  item.span);\n-                    }\n-                    ty::TyInt(ast::IntTy::Is) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.isize_impl(),\n-                                                  \"isize\",\n-                                                  \"isize\",\n-                                                  item.span);\n-                    }\n-                    ty::TyUint(ast::UintTy::U8) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.u8_impl(),\n-                                                  \"u8\",\n-                                                  \"u8\",\n-                                                  item.span);\n-                    }\n-                    ty::TyUint(ast::UintTy::U16) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.u16_impl(),\n-                                                  \"u16\",\n-                                                  \"u16\",\n-                                                  item.span);\n-                    }\n-                    ty::TyUint(ast::UintTy::U32) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.u32_impl(),\n-                                                  \"u32\",\n-                                                  \"u32\",\n-                                                  item.span);\n-                    }\n-                    ty::TyUint(ast::UintTy::U64) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.u64_impl(),\n-                                                  \"u64\",\n-                                                  \"u64\",\n-                                                  item.span);\n-                    }\n-                    ty::TyUint(ast::UintTy::U128) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.u128_impl(),\n-                                                  \"u128\",\n-                                                  \"u128\",\n-                                                  item.span);\n-                    }\n-                    ty::TyUint(ast::UintTy::Us) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.usize_impl(),\n-                                                  \"usize\",\n-                                                  \"usize\",\n-                                                  item.span);\n-                    }\n-                    ty::TyFloat(ast::FloatTy::F32) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.f32_impl(),\n-                                                  \"f32\",\n-                                                  \"f32\",\n-                                                  item.span);\n-                    }\n-                    ty::TyFloat(ast::FloatTy::F64) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.f64_impl(),\n-                                                  \"f64\",\n-                                                  \"f64\",\n-                                                  item.span);\n-                    }\n-                    ty::TyError => {\n-                        return;\n-                    }\n-                    _ => {\n-                        struct_span_err!(self.tcx.sess,\n-                                         ty.span,\n-                                         E0118,\n-                                         \"no base type found for inherent implementation\")\n-                            .span_label(ty.span, &format!(\"impl requires a base type\"))\n-                            .note(&format!(\"either implement a trait on it or create a newtype \\\n-                                            to wrap it instead\"))\n-                            .emit();\n-                        return;\n-                    }\n-                }\n-            }\n             hir::ItemImpl(.., Some(_), _, _) => {\n                 // \"Trait\" impl\n                 debug!(\"coherence2::orphan check: trait impl {}\",\n@@ -311,7 +106,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                        trait_def_id,\n                        self.tcx.trait_has_default_impl(trait_def_id));\n                 if self.tcx.trait_has_default_impl(trait_def_id) &&\n-                   trait_def_id.krate != LOCAL_CRATE {\n+                   !trait_def_id.is_local() {\n                     let self_ty = trait_ref.self_ty();\n                     let opt_self_def_id = match self_ty.sty {\n                         ty::TyAdt(self_def, _) => Some(self_def.did),\n@@ -346,31 +141,13 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                         return;\n                     }\n                 }\n-\n-                // Disallow *all* explicit impls of `Sized` and `Unsize` for now.\n-                if Some(trait_def_id) == self.tcx.lang_items.sized_trait() {\n-                    struct_span_err!(self.tcx.sess,\n-                                     item.span,\n-                                     E0322,\n-                                     \"explicit impls for the `Sized` trait are not permitted\")\n-                        .span_label(item.span, &format!(\"impl of 'Sized' not allowed\"))\n-                        .emit();\n-                    return;\n-                }\n-                if Some(trait_def_id) == self.tcx.lang_items.unsize_trait() {\n-                    span_err!(self.tcx.sess,\n-                              item.span,\n-                              E0328,\n-                              \"explicit impls for the `Unsize` trait are not permitted\");\n-                    return;\n-                }\n             }\n             hir::ItemDefaultImpl(_, ref item_trait_ref) => {\n                 // \"Trait\" impl\n                 debug!(\"coherence2::orphan check: default trait impl {}\",\n                        self.tcx.hir.node_to_string(item.id));\n                 let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n-                if trait_ref.def_id.krate != LOCAL_CRATE {\n+                if !trait_ref.def_id.is_local() {\n                     struct_span_err!(self.tcx.sess,\n                                      item_trait_ref.path.span,\n                                      E0318,"}, {"sha": "d334d0c4338f9bc843887410dd1945f061f7c1be", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 71, "deletions": 142, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -12,111 +12,110 @@\n //! same type. Likewise, no two inherent impls for a given type\n //! constructor provide a method with the same name.\n \n-use hir::def_id::DefId;\n-use rustc::traits::{self, Reveal};\n+use rustc::traits;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n use syntax::ast;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use util::nodemap::DefIdMap;\n-use lint;\n \n-pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let mut overlap = OverlapChecker {\n-        tcx: tcx,\n-        default_impls: DefIdMap(),\n-    };\n+pub fn check_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    let mut overlap = OverlapChecker { tcx };\n \n     // this secondary walk specifically checks for some other cases,\n     // like defaulted traits, for which additional overlap rules exist\n     tcx.visit_all_item_likes_in_krate(DepNode::CoherenceOverlapCheckSpecial, &mut overlap);\n }\n \n-struct OverlapChecker<'cx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n-\n-    // maps from a trait def-id to an impl id\n-    default_impls: DefIdMap<ast::NodeId>,\n-}\n+pub fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n+    let impl_def_id = tcx.hir.local_def_id(node_id);\n+    let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+    let trait_def_id = trait_ref.def_id;\n \n-impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n-    fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId) {\n-        #[derive(Copy, Clone, PartialEq)]\n-        enum Namespace {\n-            Type,\n-            Value,\n-        }\n+    if trait_ref.references_error() {\n+        debug!(\"coherence: skipping impl {:?} with error {:?}\",\n+               impl_def_id, trait_ref);\n+        return\n+    }\n \n-        let name_and_namespace = |def_id| {\n-            let item = self.tcx.associated_item(def_id);\n-            (item.name, match item.kind {\n-                ty::AssociatedKind::Type => Namespace::Type,\n-                ty::AssociatedKind::Const |\n-                ty::AssociatedKind::Method => Namespace::Value,\n-            })\n-        };\n-\n-        let impl_items1 = self.tcx.associated_item_def_ids(impl1);\n-        let impl_items2 = self.tcx.associated_item_def_ids(impl2);\n-\n-        for &item1 in &impl_items1[..] {\n-            let (name, namespace) = name_and_namespace(item1);\n-\n-            for &item2 in &impl_items2[..] {\n-                if (name, namespace) == name_and_namespace(item2) {\n-                    let msg = format!(\"duplicate definitions with name `{}`\", name);\n-                    let node_id = self.tcx.hir.as_local_node_id(item1).unwrap();\n-                    self.tcx.sess.add_lint(lint::builtin::OVERLAPPING_INHERENT_IMPLS,\n-                                           node_id,\n-                                           self.tcx.span_of_impl(item1).unwrap(),\n-                                           msg);\n-                }\n+    let _task =\n+        tcx.dep_graph.in_task(DepNode::CoherenceOverlapCheck(trait_def_id));\n+\n+    let def = tcx.lookup_trait_def(trait_def_id);\n+\n+    // attempt to insert into the specialization graph\n+    let insert_result = def.add_impl_for_specialization(tcx, impl_def_id);\n+\n+    // insertion failed due to overlap\n+    if let Err(overlap) = insert_result {\n+        let mut err = struct_span_err!(tcx.sess,\n+                                       tcx.span_of_impl(impl_def_id).unwrap(),\n+                                       E0119,\n+                                       \"conflicting implementations of trait `{}`{}:\",\n+                                       overlap.trait_desc,\n+                                       overlap.self_desc.clone().map_or(String::new(),\n+                                                                        |ty| {\n+            format!(\" for type `{}`\", ty)\n+        }));\n+\n+        match tcx.span_of_impl(overlap.with_impl) {\n+            Ok(span) => {\n+                err.span_label(span, &format!(\"first implementation here\"));\n+                err.span_label(tcx.span_of_impl(impl_def_id).unwrap(),\n+                               &format!(\"conflicting implementation{}\",\n+                                        overlap.self_desc\n+                                            .map_or(String::new(),\n+                                                    |ty| format!(\" for `{}`\", ty))));\n+            }\n+            Err(cname) => {\n+                err.note(&format!(\"conflicting implementation in crate `{}`\", cname));\n             }\n         }\n+\n+        err.emit();\n     }\n \n-    fn check_for_overlapping_inherent_impls(&self, ty_def_id: DefId) {\n-        let _task = self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapInherentCheck(ty_def_id));\n-\n-        let inherent_impls = self.tcx.inherent_impls.borrow();\n-        let impls = match inherent_impls.get(&ty_def_id) {\n-            Some(impls) => impls,\n-            None => return,\n-        };\n-\n-        for (i, &impl1_def_id) in impls.iter().enumerate() {\n-            for &impl2_def_id in &impls[(i + 1)..] {\n-                self.tcx.infer_ctxt((), Reveal::ExactMatch).enter(|infcx| {\n-                    if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n-                        self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n-                    }\n-                });\n+    // check for overlap with the automatic `impl Trait for Trait`\n+    if let ty::TyDynamic(ref data, ..) = trait_ref.self_ty().sty {\n+        // This is something like impl Trait1 for Trait2. Illegal\n+        // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n+\n+        if data.principal().map_or(true, |p| !tcx.is_object_safe(p.def_id())) {\n+            // This is an error, but it will be reported by wfcheck.  Ignore it here.\n+            // This is tested by `coherence-impl-trait-for-trait-object-safe.rs`.\n+        } else {\n+            let mut supertrait_def_ids =\n+                traits::supertrait_def_ids(tcx,\n+                                           data.principal().unwrap().def_id());\n+            if supertrait_def_ids.any(|d| d == trait_def_id) {\n+                span_err!(tcx.sess,\n+                          tcx.span_of_impl(impl_def_id).unwrap(),\n+                          E0371,\n+                          \"the object type `{}` automatically \\\n+                           implements the trait `{}`\",\n+                          trait_ref.self_ty(),\n+                          tcx.item_path_str(trait_def_id));\n             }\n         }\n     }\n }\n \n+struct OverlapChecker<'cx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n+}\n+\n impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OverlapChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n-            hir::ItemEnum(..) |\n-            hir::ItemStruct(..) |\n-            hir::ItemTrait(..) |\n-            hir::ItemUnion(..) => {\n-                let type_def_id = self.tcx.hir.local_def_id(item.id);\n-                self.check_for_overlapping_inherent_impls(type_def_id);\n-            }\n-\n             hir::ItemDefaultImpl(..) => {\n                 // look for another default impl; note that due to the\n                 // general orphan/coherence rules, it must always be\n                 // in this crate.\n                 let impl_def_id = self.tcx.hir.local_def_id(item.id);\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n \n-                let prev_default_impl = self.default_impls.insert(trait_ref.def_id, item.id);\n-                if let Some(prev_id) = prev_default_impl {\n+                let prev_id = self.tcx.hir.trait_default_impl(trait_ref.def_id).unwrap();\n+                if prev_id != item.id {\n                     let mut err = struct_span_err!(self.tcx.sess,\n                                                    self.tcx.span_of_impl(impl_def_id).unwrap(),\n                                                    E0521,\n@@ -131,76 +130,6 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 }\n             }\n             hir::ItemImpl(.., Some(_), _, _) => {\n-                let impl_def_id = self.tcx.hir.local_def_id(item.id);\n-                let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n-                let trait_def_id = trait_ref.def_id;\n-\n-                if trait_ref.references_error() {\n-                    debug!(\"coherence: skipping impl {:?} with error {:?}\",\n-                           impl_def_id, trait_ref);\n-                    return\n-                }\n-\n-                let _task =\n-                    self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapCheck(trait_def_id));\n-\n-                let def = self.tcx.lookup_trait_def(trait_def_id);\n-\n-                // attempt to insert into the specialization graph\n-                let insert_result = def.add_impl_for_specialization(self.tcx, impl_def_id);\n-\n-                // insertion failed due to overlap\n-                if let Err(overlap) = insert_result {\n-                    let mut err = struct_span_err!(self.tcx.sess,\n-                                                   self.tcx.span_of_impl(impl_def_id).unwrap(),\n-                                                   E0119,\n-                                                   \"conflicting implementations of trait `{}`{}:\",\n-                                                   overlap.trait_desc,\n-                                                   overlap.self_desc.clone().map_or(String::new(),\n-                                                                                    |ty| {\n-                        format!(\" for type `{}`\", ty)\n-                    }));\n-\n-                    match self.tcx.span_of_impl(overlap.with_impl) {\n-                        Ok(span) => {\n-                            err.span_label(span, &format!(\"first implementation here\"));\n-                            err.span_label(self.tcx.span_of_impl(impl_def_id).unwrap(),\n-                                           &format!(\"conflicting implementation{}\",\n-                                                    overlap.self_desc\n-                                                        .map_or(String::new(),\n-                                                                |ty| format!(\" for `{}`\", ty))));\n-                        }\n-                        Err(cname) => {\n-                            err.note(&format!(\"conflicting implementation in crate `{}`\", cname));\n-                        }\n-                    }\n-\n-                    err.emit();\n-                }\n-\n-                // check for overlap with the automatic `impl Trait for Trait`\n-                if let ty::TyDynamic(ref data, ..) = trait_ref.self_ty().sty {\n-                    // This is something like impl Trait1 for Trait2. Illegal\n-                    // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n-\n-                    if data.principal().map_or(true, |p| !self.tcx.is_object_safe(p.def_id())) {\n-                        // This is an error, but it will be reported by wfcheck.  Ignore it here.\n-                        // This is tested by `coherence-impl-trait-for-trait-object-safe.rs`.\n-                    } else {\n-                        let mut supertrait_def_ids =\n-                            traits::supertrait_def_ids(self.tcx,\n-                                                       data.principal().unwrap().def_id());\n-                        if supertrait_def_ids.any(|d| d == trait_def_id) {\n-                            span_err!(self.tcx.sess,\n-                                      item.span,\n-                                      E0371,\n-                                      \"the object type `{}` automatically \\\n-                                       implements the trait `{}`\",\n-                                      trait_ref.self_ty(),\n-                                      self.tcx.item_path_str(trait_def_id));\n-                        }\n-                    }\n-                }\n             }\n             _ => {}\n         }"}, {"sha": "22247d2531aec32e821417765016ae4de0e0017f", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -31,20 +31,7 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n                                 unsafety: hir::Unsafety,\n                                 polarity: hir::ImplPolarity) {\n         match self.tcx.impl_trait_ref(self.tcx.hir.local_def_id(item.id)) {\n-            None => {\n-                // Inherent impl.\n-                match unsafety {\n-                    hir::Unsafety::Normal => {\n-                        // OK\n-                    }\n-                    hir::Unsafety::Unsafe => {\n-                        span_err!(self.tcx.sess,\n-                                  item.span,\n-                                  E0197,\n-                                  \"inherent impls cannot be declared as unsafe\");\n-                    }\n-                }\n-            }\n+            None => {}\n \n             Some(trait_ref) => {\n                 let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id);\n@@ -100,7 +87,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n             hir::ItemDefaultImpl(unsafety, _) => {\n                 self.check_unsafety_coherence(item, None, unsafety, hir::ImplPolarity::Positive);\n             }\n-            hir::ItemImpl(unsafety, polarity, ref generics, ..) => {\n+            hir::ItemImpl(unsafety, polarity, ref generics, Some(_), _, _) => {\n                 self.check_unsafety_coherence(item, Some(generics), unsafety, polarity);\n             }\n             _ => {}"}, {"sha": "7f413a0dfc3aba59ce1a3e27f7ed6e75e0f23112", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 865, "deletions": 1262, "changes": 2127, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680"}, {"sha": "644e323a8dbf2ce1d6d86cacf4912693d697c228", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 73, "deletions": 83, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -1039,45 +1039,6 @@ struct Good(u32, u32, u32);\n ```\n \"##,\n \n-E0079: r##\"\n-Enum variants which contain no data can be given a custom integer\n-representation. This error indicates that the value provided is not an integer\n-literal and is therefore invalid.\n-\n-For example, in the following code:\n-\n-```compile_fail,E0079\n-enum Foo {\n-    Q = \"32\",\n-}\n-```\n-\n-We try to set the representation to a string.\n-\n-There's no general fix for this; if you can work with an integer then just set\n-it to one:\n-\n-```\n-enum Foo {\n-    Q = 32,\n-}\n-```\n-\n-However if you actually wanted a mapping between variants and non-integer\n-objects, it may be preferable to use a method with a match instead:\n-\n-```\n-enum Foo { Q }\n-impl Foo {\n-    fn get_str(&self) -> &'static str {\n-        match *self {\n-            Foo::Q => \"32\",\n-        }\n-    }\n-}\n-```\n-\"##,\n-\n E0081: r##\"\n Enum discriminants are used to differentiate enum variants stored in memory.\n This error indicates that the same value was used for two or more variants,\n@@ -1427,6 +1388,44 @@ struct Baz<'a> {\n ```\n \"##,\n \n+E0109: r##\"\n+You tried to give a type parameter to a type which doesn't need it. Erroneous\n+code example:\n+\n+```compile_fail,E0109\n+type X = u32<i32>; // error: type parameters are not allowed on this type\n+```\n+\n+Please check that you used the correct type and recheck its definition. Perhaps\n+it doesn't need the type parameter.\n+\n+Example:\n+\n+```\n+type X = u32; // this compiles\n+```\n+\n+Note that type parameters for enum-variant constructors go after the variant,\n+not after the enum (Option::None::<u32>, not Option::<u32>::None).\n+\"##,\n+\n+E0110: r##\"\n+You tried to give a lifetime parameter to a type which doesn't need it.\n+Erroneous code example:\n+\n+```compile_fail,E0110\n+type X = u32<'static>; // error: lifetime parameters are not allowed on\n+                       //        this type\n+```\n+\n+Please check that the correct type was used and recheck its definition; perhaps\n+it doesn't need the lifetime parameter. Example:\n+\n+```\n+type X = u32; // ok!\n+```\n+\"##,\n+\n E0116: r##\"\n You can only define an inherent implementation for a type in the same crate\n where the type was defined. For example, an `impl` block as below is not allowed\n@@ -1701,33 +1700,6 @@ struct Foo {\n ```\n \"##,\n \n-E0128: r##\"\n-Type parameter defaults can only use parameters that occur before them.\n-Erroneous code example:\n-\n-```compile_fail,E0128\n-struct Foo<T=U, U=()> {\n-    field1: T,\n-    filed2: U,\n-}\n-// error: type parameters with a default cannot use forward declared\n-// identifiers\n-```\n-\n-Since type parameters are evaluated in-order, you may be able to fix this issue\n-by doing:\n-\n-```\n-struct Foo<U=(), T=U> {\n-    field1: T,\n-    filed2: U,\n-}\n-```\n-\n-Please also verify that this wasn't because of a name-clash and rename the type\n-parameter if so.\n-\"##,\n-\n E0131: r##\"\n It is not possible to define `main` with type parameters, or even with function\n parameters. When `main` is present, it must take no arguments and return `()`.\n@@ -2676,6 +2648,41 @@ fn main() {\n ```\n \"##,\n \n+E0229: r##\"\n+An associated type binding was done outside of the type parameter declaration\n+and `where` clause. Erroneous code example:\n+\n+```compile_fail,E0229\n+pub trait Foo {\n+    type A;\n+    fn boo(&self) -> <Self as Foo>::A;\n+}\n+\n+struct Bar;\n+\n+impl Foo for isize {\n+    type A = usize;\n+    fn boo(&self) -> usize { 42 }\n+}\n+\n+fn baz<I>(x: &<I as Foo<A=Bar>>::A) {}\n+// error: associated type bindings are not allowed here\n+```\n+\n+To solve this error, please move the type bindings in the type parameter\n+declaration:\n+\n+```ignore\n+fn baz<I: Foo<A=Bar>>(x: &<I as Foo>::A) {} // ok!\n+```\n+\n+Or in the `where` clause:\n+\n+```ignore\n+fn baz<I>(x: &<I as Foo>::A) where I: Foo<A=Bar> {}\n+```\n+\"##,\n+\n E0230: r##\"\n The trait has more type parameters specified than appear in its definition.\n \n@@ -3444,23 +3451,6 @@ impl Bar for *mut Foo {\n ```\n \"##,\n \n-E0391: r##\"\n-This error indicates that some types or traits depend on each other\n-and therefore cannot be constructed.\n-\n-The following example contains a circular dependency between two traits:\n-\n-```compile_fail,E0391\n-trait FirstTrait : SecondTrait {\n-\n-}\n-\n-trait SecondTrait : FirstTrait {\n-\n-}\n-```\n-\"##,\n-\n E0392: r##\"\n This error indicates that a type or lifetime parameter has been declared\n but not actually used. Here is an example that demonstrates the error:"}, {"sha": "3df25825a71f66328f1a313d2969cd472cc3376b", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -23,14 +23,12 @@ use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::def_id::DefId;\n-use rustc::ty;\n+use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n \n use syntax_pos::Span;\n \n-use CrateCtxt;\n-\n /// Checks that all the type/lifetime parameters on an impl also\n /// appear in the trait ref or self-type (or are constrained by a\n /// where-clause). These rules are needed to ensure that, given a\n@@ -61,27 +59,27 @@ use CrateCtxt;\n /// impl<'a> Trait<Foo> for Bar { type X = &'a i32; }\n ///      ^ 'a is unused and appears in assoc type, error\n /// ```\n-pub fn impl_wf_check<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>) {\n+pub fn impl_wf_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // We will tag this as part of the WF check -- logically, it is,\n     // but it's one that we must perform earlier than the rest of\n     // WfCheck.\n-    ccx.tcx.visit_all_item_likes_in_krate(DepNode::WfCheck, &mut ImplWfCheck { ccx: ccx });\n+    tcx.visit_all_item_likes_in_krate(DepNode::WfCheck, &mut ImplWfCheck { tcx: tcx });\n }\n \n struct ImplWfCheck<'a, 'tcx: 'a> {\n-    ccx: &'a CrateCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for ImplWfCheck<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n             hir::ItemImpl(.., ref generics, _, _, ref impl_item_refs) => {\n-                let impl_def_id = self.ccx.tcx.hir.local_def_id(item.id);\n-                enforce_impl_params_are_constrained(self.ccx,\n+                let impl_def_id = self.tcx.hir.local_def_id(item.id);\n+                enforce_impl_params_are_constrained(self.tcx,\n                                                     generics,\n                                                     impl_def_id,\n                                                     impl_item_refs);\n-                enforce_impl_items_are_distinct(self.ccx, impl_item_refs);\n+                enforce_impl_items_are_distinct(self.tcx, impl_item_refs);\n             }\n             _ => { }\n         }\n@@ -92,16 +90,16 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for ImplWfCheck<'a, 'tcx> {\n     fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem) { }\n }\n \n-fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                  impl_hir_generics: &hir::Generics,\n                                                  impl_def_id: DefId,\n                                                  impl_item_refs: &[hir::ImplItemRef])\n {\n     // Every lifetime used in an associated type must be constrained.\n-    let impl_self_ty = ccx.tcx.item_type(impl_def_id);\n-    let impl_generics = ccx.tcx.item_generics(impl_def_id);\n-    let impl_predicates = ccx.tcx.item_predicates(impl_def_id);\n-    let impl_trait_ref = ccx.tcx.impl_trait_ref(impl_def_id);\n+    let impl_self_ty = tcx.item_type(impl_def_id);\n+    let impl_generics = tcx.item_generics(impl_def_id);\n+    let impl_predicates = tcx.item_predicates(impl_def_id);\n+    let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n \n     let mut input_parameters = ctp::parameters_for_impl(impl_self_ty, impl_trait_ref);\n     ctp::identify_constrained_type_params(\n@@ -111,19 +109,19 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     for (ty_param, param) in impl_generics.types.iter().zip(&impl_hir_generics.ty_params) {\n         let param_ty = ty::ParamTy::for_def(ty_param);\n         if !input_parameters.contains(&ctp::Parameter::from(param_ty)) {\n-            report_unused_parameter(ccx, param.span, \"type\", &param_ty.to_string());\n+            report_unused_parameter(tcx, param.span, \"type\", &param_ty.to_string());\n         }\n     }\n \n     // Disallow unconstrained lifetimes, but only if they appear in assoc types.\n     let lifetimes_in_associated_types: FxHashSet<_> = impl_item_refs.iter()\n-        .map(|item_ref|  ccx.tcx.hir.local_def_id(item_ref.id.node_id))\n+        .map(|item_ref|  tcx.hir.local_def_id(item_ref.id.node_id))\n         .filter(|&def_id| {\n-            let item = ccx.tcx.associated_item(def_id);\n+            let item = tcx.associated_item(def_id);\n             item.kind == ty::AssociatedKind::Type && item.defaultness.has_value()\n         })\n         .flat_map(|def_id| {\n-            ctp::parameters_for(&ccx.tcx.item_type(def_id), true)\n+            ctp::parameters_for(&tcx.item_type(def_id), true)\n         }).collect();\n     for (ty_lifetime, lifetime) in impl_generics.regions.iter()\n         .zip(&impl_hir_generics.lifetimes)\n@@ -134,7 +132,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             lifetimes_in_associated_types.contains(&param) && // (*)\n             !input_parameters.contains(&param)\n         {\n-            report_unused_parameter(ccx, lifetime.lifetime.span,\n+            report_unused_parameter(tcx, lifetime.lifetime.span,\n                                     \"lifetime\", &lifetime.lifetime.name.to_string());\n         }\n     }\n@@ -159,13 +157,13 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // used elsewhere are not projected back out.\n }\n \n-fn report_unused_parameter(ccx: &CrateCtxt,\n+fn report_unused_parameter(tcx: TyCtxt,\n                            span: Span,\n                            kind: &str,\n                            name: &str)\n {\n     struct_span_err!(\n-        ccx.tcx.sess, span, E0207,\n+        tcx.sess, span, E0207,\n         \"the {} parameter `{}` is not constrained by the \\\n         impl trait, self type, or predicates\",\n         kind, name)\n@@ -174,10 +172,9 @@ fn report_unused_parameter(ccx: &CrateCtxt,\n }\n \n /// Enforce that we do not have two items in an impl with the same name.\n-fn enforce_impl_items_are_distinct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn enforce_impl_items_are_distinct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              impl_item_refs: &[hir::ImplItemRef])\n {\n-    let tcx = ccx.tcx;\n     let mut seen_type_items = FxHashMap();\n     let mut seen_value_items = FxHashMap();\n     for impl_item_ref in impl_item_refs {"}, {"sha": "2c325d46c0bc060ff3e8b1aa4c6ca90a4bfad11e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 46, "deletions": 71, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -110,7 +110,8 @@ use hir::map as hir_map;\n use rustc::infer::InferOk;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n+use rustc::ty::maps::Providers;\n+use rustc::traits::{ObligationCause, ObligationCauseCode, Reveal};\n use session::config;\n use util::common::time;\n \n@@ -119,9 +120,6 @@ use syntax::abi::Abi;\n use syntax_pos::Span;\n \n use std::iter;\n-use std::cell::RefCell;\n-use util::nodemap::NodeMap;\n-\n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n pub mod diagnostics;\n@@ -140,27 +138,6 @@ pub struct TypeAndSubsts<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n-pub struct CrateCtxt<'a, 'tcx: 'a> {\n-    ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n-\n-    /// A vector of every trait accessible in the whole crate\n-    /// (i.e. including those from subcrates). This is used only for\n-    /// error reporting, and so is lazily initialised and generally\n-    /// shouldn't taint the common path (hence the RefCell).\n-    pub all_traits: RefCell<Option<check::method::AllTraitsVec>>,\n-\n-    /// This stack is used to identify cycles in the user's source.\n-    /// Note that these cycles can cross multiple items.\n-    pub stack: RefCell<Vec<collect::AstConvRequest>>,\n-\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-\n-    /// Obligations which will have to be checked at the end of\n-    /// type-checking, after all functions have been inferred.\n-    /// The key is the NodeId of the item the obligations were from.\n-    pub deferred_obligations: RefCell<NodeMap<Vec<traits::DeferredObligation<'tcx>>>>,\n-}\n-\n fn require_c_abi_if_variadic(tcx: TyCtxt,\n                              decl: &hir::FnDecl,\n                              abi: Abi,\n@@ -173,12 +150,12 @@ fn require_c_abi_if_variadic(tcx: TyCtxt,\n     }\n }\n \n-fn require_same_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 cause: &ObligationCause<'tcx>,\n                                 expected: Ty<'tcx>,\n                                 actual: Ty<'tcx>)\n                                 -> bool {\n-    ccx.tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n         match infcx.eq_types(false, &cause, expected, actual) {\n             Ok(InferOk { obligations, .. }) => {\n                 // FIXME(#32730) propagate obligations\n@@ -193,10 +170,9 @@ fn require_same_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     })\n }\n \n-fn check_main_fn_ty(ccx: &CrateCtxt,\n-                    main_id: ast::NodeId,\n-                    main_span: Span) {\n-    let tcx = ccx.tcx;\n+fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              main_id: ast::NodeId,\n+                              main_span: Span) {\n     let main_def_id = tcx.hir.local_def_id(main_id);\n     let main_t = tcx.item_type(main_def_id);\n     match main_t.sty {\n@@ -206,7 +182,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                     match it.node {\n                         hir::ItemFn(.., ref generics, _) => {\n                             if generics.is_parameterized() {\n-                                struct_span_err!(ccx.tcx.sess, generics.span, E0131,\n+                                struct_span_err!(tcx.sess, generics.span, E0131,\n                                          \"main function is not allowed to have type parameters\")\n                                     .span_label(generics.span,\n                                                 &format!(\"main cannot have type parameters\"))\n@@ -221,14 +197,17 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n             }\n             let substs = tcx.intern_substs(&[]);\n             let se_ty = tcx.mk_fn_def(main_def_id, substs,\n-                                      tcx.mk_bare_fn(ty::BareFnTy {\n-                unsafety: hir::Unsafety::Normal,\n-                abi: Abi::Rust,\n-                sig: ty::Binder(tcx.mk_fn_sig(iter::empty(), tcx.mk_nil(), false))\n-            }));\n+                ty::Binder(tcx.mk_fn_sig(\n+                    iter::empty(),\n+                    tcx.mk_nil(),\n+                    false,\n+                    hir::Unsafety::Normal,\n+                    Abi::Rust\n+                ))\n+            );\n \n             require_same_types(\n-                ccx,\n+                tcx,\n                 &ObligationCause::new(main_span, main_id, ObligationCauseCode::MainFunctionType),\n                 se_ty,\n                 main_t);\n@@ -241,11 +220,10 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n     }\n }\n \n-fn check_start_fn_ty(ccx: &CrateCtxt,\n-                     start_id: ast::NodeId,\n-                     start_span: Span) {\n-    let tcx = ccx.tcx;\n-    let start_def_id = ccx.tcx.hir.local_def_id(start_id);\n+fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                               start_id: ast::NodeId,\n+                               start_span: Span) {\n+    let start_def_id = tcx.hir.local_def_id(start_id);\n     let start_t = tcx.item_type(start_def_id);\n     match start_t.sty {\n         ty::TyFnDef(..) => {\n@@ -269,21 +247,20 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n \n             let substs = tcx.intern_substs(&[]);\n             let se_ty = tcx.mk_fn_def(start_def_id, substs,\n-                                      tcx.mk_bare_fn(ty::BareFnTy {\n-                unsafety: hir::Unsafety::Normal,\n-                abi: Abi::Rust,\n-                sig: ty::Binder(tcx.mk_fn_sig(\n+                ty::Binder(tcx.mk_fn_sig(\n                     [\n                         tcx.types.isize,\n                         tcx.mk_imm_ptr(tcx.mk_imm_ptr(tcx.types.u8))\n                     ].iter().cloned(),\n                     tcx.types.isize,\n                     false,\n-                )),\n-            }));\n+                    hir::Unsafety::Normal,\n+                    Abi::Rust\n+                ))\n+            );\n \n             require_same_types(\n-                ccx,\n+                tcx,\n                 &ObligationCause::new(start_span, start_id, ObligationCauseCode::StartFunctionType),\n                 se_ty,\n                 start_t);\n@@ -296,35 +273,33 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n     }\n }\n \n-fn check_for_entry_fn(ccx: &CrateCtxt) {\n-    let tcx = ccx.tcx;\n+fn check_for_entry_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _task = tcx.dep_graph.in_task(DepNode::CheckEntryFn);\n     if let Some((id, sp)) = *tcx.sess.entry_fn.borrow() {\n         match tcx.sess.entry_type.get() {\n-            Some(config::EntryMain) => check_main_fn_ty(ccx, id, sp),\n-            Some(config::EntryStart) => check_start_fn_ty(ccx, id, sp),\n+            Some(config::EntryMain) => check_main_fn_ty(tcx, id, sp),\n+            Some(config::EntryStart) => check_start_fn_ty(tcx, id, sp),\n             Some(config::EntryNone) => {}\n             None => bug!(\"entry function without a type\")\n         }\n     }\n }\n \n+pub fn provide(providers: &mut Providers) {\n+    collect::provide(providers);\n+    coherence::provide(providers);\n+    check::provide(providers);\n+}\n+\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                             -> Result<NodeMap<Ty<'tcx>>, usize> {\n+                             -> Result<(), usize> {\n     let time_passes = tcx.sess.time_passes();\n-    let ccx = CrateCtxt {\n-        ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n-        all_traits: RefCell::new(None),\n-        stack: RefCell::new(Vec::new()),\n-        tcx: tcx,\n-        deferred_obligations: RefCell::new(NodeMap()),\n-    };\n \n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n     tcx.sess.track_errors(|| {\n         time(time_passes, \"type collecting\", ||\n-             collect::collect_item_types(&ccx));\n+             collect::collect_item_types(tcx));\n \n     })?;\n \n@@ -333,28 +308,28 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n \n     tcx.sess.track_errors(|| {\n         time(time_passes, \"impl wf inference\", ||\n-             impl_wf_check::impl_wf_check(&ccx));\n+             impl_wf_check::impl_wf_check(tcx));\n     })?;\n \n     tcx.sess.track_errors(|| {\n       time(time_passes, \"coherence checking\", ||\n-          coherence::check_coherence(&ccx));\n+          coherence::check_coherence(tcx));\n     })?;\n \n-    time(time_passes, \"wf checking\", || check::check_wf_new(&ccx))?;\n+    time(time_passes, \"wf checking\", || check::check_wf_new(tcx))?;\n \n-    time(time_passes, \"item-types checking\", || check::check_item_types(&ccx))?;\n+    time(time_passes, \"item-types checking\", || check::check_item_types(tcx))?;\n \n-    time(time_passes, \"item-bodies checking\", || check::check_item_bodies(&ccx))?;\n+    time(time_passes, \"item-bodies checking\", || check::check_item_bodies(tcx))?;\n \n-    time(time_passes, \"drop-impl checking\", || check::check_drop_impls(&ccx))?;\n+    time(time_passes, \"drop-impl checking\", || check::check_drop_impls(tcx))?;\n \n     check_unused::check_crate(tcx);\n-    check_for_entry_fn(&ccx);\n+    check_for_entry_fn(tcx);\n \n     let err_count = tcx.sess.err_count();\n     if err_count == 0 {\n-        Ok(ccx.ast_ty_to_ty_cache.into_inner())\n+        Ok(())\n     } else {\n         Err(err_count)\n     }"}, {"sha": "f0f543fa6f23b7af8b774a5e5e8bbe72e0fd069d", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -13,12 +13,10 @@\n //! The second pass over the AST determines the set of constraints.\n //! We walk the set of items and, for each member, generate new constraints.\n \n-use dep_graph::DepTrackingMapConfig;\n use hir::def_id::DefId;\n use middle::resolve_lifetime as rl;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::maps::ItemVariances;\n use rustc::hir::map as hir_map;\n use syntax::ast;\n use rustc::hir;\n@@ -28,6 +26,8 @@ use super::terms::*;\n use super::terms::VarianceTerm::*;\n use super::xform::*;\n \n+use dep_graph::DepNode::ItemSignature as VarianceDepNode;\n+\n pub struct ConstraintContext<'a, 'tcx: 'a> {\n     pub terms_cx: TermsContext<'a, 'tcx>,\n \n@@ -65,8 +65,7 @@ pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n     };\n \n     // See README.md for a discussion on dep-graph management.\n-    tcx.visit_all_item_likes_in_krate(|def_id| ItemVariances::to_dep_node(&def_id),\n-                                      &mut constraint_cx);\n+    tcx.visit_all_item_likes_in_krate(VarianceDepNode, &mut constraint_cx);\n \n     constraint_cx\n }\n@@ -279,7 +278,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     }\n \n     fn add_constraints_from_trait_ref(&mut self,\n-                                      generics: &ty::Generics<'tcx>,\n+                                      generics: &ty::Generics,\n                                       trait_ref: ty::TraitRef<'tcx>,\n                                       variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_trait_ref: trait_ref={:?} variance={:?}\",\n@@ -291,7 +290,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         // This edge is actually implied by the call to\n         // `lookup_trait_def`, but I'm trying to be future-proof. See\n         // README.md for a discussion on dep-graph management.\n-        self.tcx().dep_graph.read(ItemVariances::to_dep_node(&trait_ref.def_id));\n+        self.tcx().dep_graph.read(VarianceDepNode(trait_ref.def_id));\n \n         self.add_constraints_from_substs(generics,\n                                          trait_ref.def_id,\n@@ -305,7 +304,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// in a context with the generics defined in `generics` and\n     /// ambient variance `variance`\n     fn add_constraints_from_ty(&mut self,\n-                               generics: &ty::Generics<'tcx>,\n+                               generics: &ty::Generics,\n                                ty: Ty<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_ty(ty={:?}, variance={:?})\",\n@@ -350,7 +349,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // This edge is actually implied by the call to\n                 // `lookup_trait_def`, but I'm trying to be future-proof. See\n                 // README.md for a discussion on dep-graph management.\n-                self.tcx().dep_graph.read(ItemVariances::to_dep_node(&def.did));\n+                self.tcx().dep_graph.read(VarianceDepNode(def.did));\n \n                 self.add_constraints_from_substs(generics,\n                                                  def.did,\n@@ -367,7 +366,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // This edge is actually implied by the call to\n                 // `lookup_trait_def`, but I'm trying to be future-proof. See\n                 // README.md for a discussion on dep-graph management.\n-                self.tcx().dep_graph.read(ItemVariances::to_dep_node(&trait_ref.def_id));\n+                self.tcx().dep_graph.read(VarianceDepNode(trait_ref.def_id));\n \n                 self.add_constraints_from_substs(generics,\n                                                  trait_ref.def_id,\n@@ -412,8 +411,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 }\n             }\n \n-            ty::TyFnDef(.., &ty::BareFnTy { ref sig, .. }) |\n-            ty::TyFnPtr(&ty::BareFnTy { ref sig, .. }) => {\n+            ty::TyFnDef(.., sig) |\n+            ty::TyFnPtr(sig) => {\n                 self.add_constraints_from_sig(generics, sig, variance);\n             }\n \n@@ -433,9 +432,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for a nominal type (enum, struct,\n     /// object, etc) appearing in a context with ambient variance `variance`\n     fn add_constraints_from_substs(&mut self,\n-                                   generics: &ty::Generics<'tcx>,\n+                                   generics: &ty::Generics,\n                                    def_id: DefId,\n-                                   type_param_defs: &[ty::TypeParameterDef<'tcx>],\n+                                   type_param_defs: &[ty::TypeParameterDef],\n                                    region_param_defs: &[ty::RegionParameterDef],\n                                    substs: &Substs<'tcx>,\n                                    variance: VarianceTermPtr<'a>) {\n@@ -465,8 +464,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for a function with signature\n     /// `sig` appearing in a context with ambient variance `variance`\n     fn add_constraints_from_sig(&mut self,\n-                                generics: &ty::Generics<'tcx>,\n-                                sig: &ty::PolyFnSig<'tcx>,\n+                                generics: &ty::Generics,\n+                                sig: ty::PolyFnSig<'tcx>,\n                                 variance: VarianceTermPtr<'a>) {\n         let contra = self.contravariant(variance);\n         for &input in sig.0.inputs() {\n@@ -478,7 +477,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for a region appearing in a\n     /// context with ambient variance `variance`\n     fn add_constraints_from_region(&mut self,\n-                                   generics: &ty::Generics<'tcx>,\n+                                   generics: &ty::Generics,\n                                    region: &'tcx ty::Region,\n                                    variance: VarianceTermPtr<'a>) {\n         match *region {\n@@ -518,7 +517,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for a mutability-type pair\n     /// appearing in a context with ambient variance `variance`\n     fn add_constraints_from_mt(&mut self,\n-                               generics: &ty::Generics<'tcx>,\n+                               generics: &ty::Generics,\n                                mt: &ty::TypeAndMut<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n         match mt.mutbl {"}, {"sha": "6628c7c521fd103dec06ea7f5489b3f94d5dbecc", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                           item_variances);\n             }\n \n-            tcx.item_variance_map\n+            tcx.maps.variances\n                .borrow_mut()\n                .insert(item_def_id, Rc::new(item_variances));\n         }"}, {"sha": "36352f50e4406237115aa36abf42d55a53438c38", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -20,9 +20,7 @@\n // a variable.\n \n use arena::TypedArena;\n-use dep_graph::DepTrackingMapConfig;\n use rustc::ty::{self, TyCtxt};\n-use rustc::ty::maps::ItemVariances;\n use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n@@ -34,6 +32,8 @@ use self::VarianceTerm::*;\n \n pub type VarianceTermPtr<'a> = &'a VarianceTerm<'a>;\n \n+use dep_graph::DepNode::ItemSignature as VarianceDepNode;\n+\n #[derive(Copy, Clone, Debug)]\n pub struct InferredIndex(pub usize);\n \n@@ -109,7 +109,7 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n     };\n \n     // See README.md for a discussion on dep-graph management.\n-    tcx.visit_all_item_likes_in_krate(|def_id| ItemVariances::to_dep_node(&def_id), &mut terms_cx);\n+    tcx.visit_all_item_likes_in_krate(|def_id| VarianceDepNode(def_id), &mut terms_cx);\n \n     terms_cx\n }\n@@ -178,8 +178,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         // parameters\".\n         if self.num_inferred() == inferreds_on_entry {\n             let item_def_id = self.tcx.hir.local_def_id(item_id);\n-            self.tcx\n-                .item_variance_map\n+            self.tcx.maps.variances\n                 .borrow_mut()\n                 .insert(item_def_id, self.empty_variances.clone());\n         }"}, {"sha": "c4476483186c7a35ed1de6bb20e9de0e52ff179f", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -15,6 +15,7 @@ use std::io;\n use std::iter::once;\n \n use syntax::ast;\n+use syntax_pos::DUMMY_SP;\n use rustc::hir;\n \n use rustc::hir::def::{Def, CtorKind};\n@@ -164,11 +165,7 @@ pub fn build_external_trait(cx: &DocContext, did: DefId) -> clean::Trait {\n }\n \n fn build_external_function(cx: &DocContext, did: DefId) -> clean::Function {\n-    let ty = cx.tcx.item_type(did);\n-    let (decl, style, abi) = match ty.sty {\n-        ty::TyFnDef(.., ref f) => ((did, &f.sig).clean(cx), f.unsafety, f.abi),\n-        _ => panic!(\"bad function\"),\n-    };\n+    let sig = cx.tcx.item_type(did).fn_sig();\n \n     let constness = if cx.tcx.sess.cstore.is_const_fn(did) {\n         hir::Constness::Const\n@@ -178,11 +175,11 @@ fn build_external_function(cx: &DocContext, did: DefId) -> clean::Function {\n \n     let predicates = cx.tcx.item_predicates(did);\n     clean::Function {\n-        decl: decl,\n+        decl: (did, sig).clean(cx),\n         generics: (cx.tcx.item_generics(did), &predicates).clean(cx),\n-        unsafety: style,\n+        unsafety: sig.unsafety(),\n         constness: constness,\n-        abi: abi,\n+        abi: sig.abi(),\n     }\n }\n \n@@ -235,10 +232,10 @@ fn build_type_alias(cx: &DocContext, did: DefId) -> clean::Typedef {\n \n pub fn build_impls(cx: &DocContext, did: DefId) -> Vec<clean::Item> {\n     let tcx = cx.tcx;\n-    tcx.populate_inherent_implementations_for_type_if_necessary(did);\n+    tcx.populate_inherent_implementations_for_type_if_necessary(DUMMY_SP, did);\n     let mut impls = Vec::new();\n \n-    if let Some(i) = tcx.inherent_impls.borrow().get(&did) {\n+    if let Some(i) = tcx.maps.inherent_impls.borrow().get(&did) {\n         for &did in i.iter() {\n             build_impl(cx, did, &mut impls);\n         }"}, {"sha": "73b82fbad5dfda02aa50b0fb975ddd442c6a7143", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -596,14 +596,18 @@ impl Clean<TyParam> for hir::TyParam {\n     }\n }\n \n-impl<'tcx> Clean<TyParam> for ty::TypeParameterDef<'tcx> {\n+impl<'tcx> Clean<TyParam> for ty::TypeParameterDef {\n     fn clean(&self, cx: &DocContext) -> TyParam {\n         cx.renderinfo.borrow_mut().external_typarams.insert(self.def_id, self.name.clean(cx));\n         TyParam {\n             name: self.name.clean(cx),\n             did: self.def_id,\n             bounds: vec![], // these are filled in from the where-clauses\n-            default: self.default.clean(cx),\n+            default: if self.has_default {\n+                Some(cx.tcx.item_type(self.def_id).clean(cx))\n+            } else {\n+                None\n+            }\n         }\n     }\n }\n@@ -965,7 +969,7 @@ impl Clean<Generics> for hir::Generics {\n     }\n }\n \n-impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n+impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n                                     &'a ty::GenericPredicates<'tcx>) {\n     fn clean(&self, cx: &DocContext) -> Generics {\n         use self::WherePredicate as WP;\n@@ -1159,7 +1163,7 @@ impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl, A)\n     }\n }\n \n-impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n+impl<'a, 'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n     fn clean(&self, cx: &DocContext) -> FnDecl {\n         let (did, sig) = *self;\n         let mut names = if cx.tcx.hir.as_local_node_id(did).is_some() {\n@@ -1348,11 +1352,8 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n             ty::AssociatedKind::Method => {\n                 let generics = (cx.tcx.item_generics(self.def_id),\n                                 &cx.tcx.item_predicates(self.def_id)).clean(cx);\n-                let fty = match cx.tcx.item_type(self.def_id).sty {\n-                    ty::TyFnDef(_, _, f) => f,\n-                    _ => unreachable!()\n-                };\n-                let mut decl = (self.def_id, &fty.sig).clean(cx);\n+                let sig = cx.tcx.item_type(self.def_id).fn_sig();\n+                let mut decl = (self.def_id, sig).clean(cx);\n \n                 if self.method_has_self_argument {\n                     let self_ty = match self.container {\n@@ -1361,7 +1362,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                         }\n                         ty::TraitContainer(_) => cx.tcx.mk_self_type()\n                     };\n-                    let self_arg_ty = *fty.sig.input(0).skip_binder();\n+                    let self_arg_ty = *sig.input(0).skip_binder();\n                     if self_arg_ty == self_ty {\n                         decl.inputs.values[0].type_ = Generic(String::from(\"Self\"));\n                     } else if let ty::TyRef(_, mt) = self_arg_ty.sty {\n@@ -1382,20 +1383,20 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                 };\n                 if provided {\n                     MethodItem(Method {\n-                        unsafety: fty.unsafety,\n+                        unsafety: sig.unsafety(),\n                         generics: generics,\n                         decl: decl,\n-                        abi: fty.abi,\n+                        abi: sig.abi(),\n \n                         // trait methods canot (currently, at least) be const\n                         constness: hir::Constness::NotConst,\n                     })\n                 } else {\n                     TyMethodItem(TyMethod {\n-                        unsafety: fty.unsafety,\n+                        unsafety: sig.unsafety(),\n                         generics: generics,\n                         decl: decl,\n-                        abi: fty.abi,\n+                        abi: sig.abi(),\n                     })\n                 }\n             }\n@@ -1768,7 +1769,7 @@ impl Clean<Type> for hir::Ty {\n             }\n             TyPath(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 let mut def = Def::Err;\n-                if let Some(ty) = cx.hir_ty_to_ty.get(&self.id) {\n+                if let Some(ty) = cx.tcx.ast_ty_to_ty_cache.borrow().get(&self.id) {\n                     if let ty::TyProjection(proj) = ty.sty {\n                         def = Def::Trait(proj.trait_ref.def_id);\n                     }\n@@ -1830,16 +1831,16 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 mutability: mt.mutbl.clean(cx),\n                 type_: box mt.ty.clean(cx),\n             },\n-            ty::TyFnDef(.., ref fty) |\n-            ty::TyFnPtr(ref fty) => BareFunction(box BareFunctionDecl {\n-                unsafety: fty.unsafety,\n+            ty::TyFnDef(.., sig) |\n+            ty::TyFnPtr(sig) => BareFunction(box BareFunctionDecl {\n+                unsafety: sig.unsafety(),\n                 generics: Generics {\n                     lifetimes: Vec::new(),\n                     type_params: Vec::new(),\n                     where_predicates: Vec::new()\n                 },\n-                decl: (cx.tcx.hir.local_def_id(ast::CRATE_NODE_ID), &fty.sig).clean(cx),\n-                abi: fty.abi,\n+                decl: (cx.tcx.hir.local_def_id(ast::CRATE_NODE_ID), sig).clean(cx),\n+                abi: sig.abi(),\n             }),\n             ty::TyAdt(def, substs) => {\n                 let did = def.did;"}, {"sha": "0a9db2c26464ce6370b4c4c573742e469bf55959", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -15,10 +15,10 @@ use rustc::session::{self, config};\n use rustc::hir::def_id::DefId;\n use rustc::hir::def::{Def, ExportMap};\n use rustc::middle::privacy::AccessLevels;\n-use rustc::ty::{self, TyCtxt, GlobalArenas, Ty};\n+use rustc::ty::{self, TyCtxt, GlobalArenas};\n use rustc::hir::map as hir_map;\n use rustc::lint;\n-use rustc::util::nodemap::{FxHashMap, NodeMap};\n+use rustc::util::nodemap::FxHashMap;\n use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n@@ -65,9 +65,6 @@ pub struct DocContext<'a, 'tcx: 'a> {\n     /// Table node id of lifetime parameter definition -> substituted lifetime\n     pub lt_substs: RefCell<FxHashMap<ast::NodeId, clean::Lifetime>>,\n     pub export_map: ExportMap,\n-\n-    /// Table from HIR Ty nodes to their resolved Ty.\n-    pub hir_ty_to_ty: NodeMap<Ty<'tcx>>,\n }\n \n impl<'a, 'tcx> DocContext<'a, 'tcx> {\n@@ -183,7 +180,7 @@ pub fn run_core(search_paths: SearchPaths,\n             sess.fatal(\"Compilation failed, aborting rustdoc\");\n         }\n \n-        let ty::CrateAnalysis { access_levels, export_map, hir_ty_to_ty, .. } = analysis;\n+        let ty::CrateAnalysis { access_levels, export_map, .. } = analysis;\n \n         // Convert from a NodeId set to a DefId set since we don't always have easy access\n         // to the map from defid -> nodeid\n@@ -202,7 +199,6 @@ pub fn run_core(search_paths: SearchPaths,\n             ty_substs: Default::default(),\n             lt_substs: Default::default(),\n             export_map: export_map,\n-            hir_ty_to_ty: hir_ty_to_ty,\n         };\n         debug!(\"crate: {:?}\", tcx.hir.krate());\n "}, {"sha": "852c98eb2fd52fcfb37e4cab0131f3aa415b6338", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -24,7 +24,7 @@ use clean::{AttributesExt, NestedAttributesExt};\n /// specific rustdoc annotations into account (i.e. `doc(hidden)`)\n pub struct LibEmbargoVisitor<'a, 'b: 'a, 'tcx: 'b> {\n     cx: &'a ::core::DocContext<'b, 'tcx>,\n-    cstore: &'a CrateStore<'tcx>,\n+    cstore: &'a CrateStore,\n     // Accessibility levels for reachable nodes\n     access_levels: RefMut<'a, AccessLevels<DefId>>,\n     // Previous accessibility level, None means unreachable"}, {"sha": "096657a6e7ac82e0e213c586e03f5a71a1b97815", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -909,25 +909,12 @@ fn int_type_of_word(s: &str) -> Option<IntType> {\n \n #[derive(PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n pub enum ReprAttr {\n-    ReprAny,\n     ReprInt(IntType),\n     ReprExtern,\n     ReprPacked,\n     ReprSimd,\n }\n \n-impl ReprAttr {\n-    pub fn is_ffi_safe(&self) -> bool {\n-        match *self {\n-            ReprAny => false,\n-            ReprInt(ity) => ity.is_ffi_safe(),\n-            ReprExtern => true,\n-            ReprPacked => false,\n-            ReprSimd => true,\n-        }\n-    }\n-}\n-\n #[derive(Eq, Hash, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n pub enum IntType {\n     SignedInt(ast::IntTy),\n@@ -942,16 +929,6 @@ impl IntType {\n             UnsignedInt(..) => false\n         }\n     }\n-    fn is_ffi_safe(self) -> bool {\n-        match self {\n-            SignedInt(ast::IntTy::I8) | UnsignedInt(ast::UintTy::U8) |\n-            SignedInt(ast::IntTy::I16) | UnsignedInt(ast::UintTy::U16) |\n-            SignedInt(ast::IntTy::I32) | UnsignedInt(ast::UintTy::U32) |\n-            SignedInt(ast::IntTy::I64) | UnsignedInt(ast::UintTy::U64) |\n-            SignedInt(ast::IntTy::I128) | UnsignedInt(ast::UintTy::U128) => true,\n-            SignedInt(ast::IntTy::Is) | UnsignedInt(ast::UintTy::Us) => false\n-        }\n-    }\n }\n \n pub trait HasAttrs: Sized {"}, {"sha": "b7f6e6a2384f71d56435e3f3b0b12711dfd25c15", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -51,10 +51,10 @@ pub struct StringReader<'a> {\n     pub filemap: Rc<syntax_pos::FileMap>,\n     /// If Some, stop reading the source at this position (inclusive).\n     pub terminator: Option<BytePos>,\n-    /// Whether to record new-lines in filemap. This is only necessary the first\n-    /// time a filemap is lexed. If part of a filemap is being re-lexed, this\n-    /// should be set to false.\n-    pub save_new_lines: bool,\n+    /// Whether to record new-lines and multibyte chars in filemap.\n+    /// This is only necessary the first time a filemap is lexed.\n+    /// If part of a filemap is being re-lexed, this should be set to false.\n+    pub save_new_lines_and_multibyte: bool,\n     // cached:\n     pub peek_tok: token::Token,\n     pub peek_span: Span,\n@@ -162,7 +162,7 @@ impl<'a> StringReader<'a> {\n             ch: Some('\\n'),\n             filemap: filemap,\n             terminator: None,\n-            save_new_lines: true,\n+            save_new_lines_and_multibyte: true,\n             // dummy values; not read\n             peek_tok: token::Eof,\n             peek_span: syntax_pos::DUMMY_SP,\n@@ -183,6 +183,31 @@ impl<'a> StringReader<'a> {\n         sr\n     }\n \n+    pub fn retokenize(sess: &'a ParseSess, mut span: Span) -> Self {\n+        let begin = sess.codemap().lookup_byte_offset(span.lo);\n+        let end = sess.codemap().lookup_byte_offset(span.hi);\n+\n+        // Make the range zero-length if the span is invalid.\n+        if span.lo > span.hi || begin.fm.start_pos != end.fm.start_pos {\n+            span.hi = span.lo;\n+        }\n+\n+        let mut sr = StringReader::new_raw_internal(sess, begin.fm);\n+\n+        // Seek the lexer to the right byte range.\n+        sr.save_new_lines_and_multibyte = false;\n+        sr.next_pos = span.lo;\n+        sr.terminator = Some(span.hi);\n+\n+        sr.bump();\n+\n+        if let Err(_) = sr.advance_token() {\n+            sr.emit_fatal_errors();\n+            panic!(FatalError);\n+        }\n+        sr\n+    }\n+\n     pub fn ch_is(&self, c: char) -> bool {\n         self.ch == Some(c)\n     }\n@@ -378,7 +403,10 @@ impl<'a> StringReader<'a> {\n     pub fn bump(&mut self) {\n         let new_pos = self.next_pos;\n         let new_byte_offset = self.byte_offset(new_pos).to_usize();\n-        if new_byte_offset < self.source_text.len() {\n+        let end = self.terminator.map_or(self.source_text.len(), |t| {\n+            self.byte_offset(t).to_usize()\n+        });\n+        if new_byte_offset < end {\n             let old_ch_is_newline = self.ch.unwrap() == '\\n';\n             let new_ch = char_at(&self.source_text, new_byte_offset);\n             let new_ch_len = new_ch.len_utf8();\n@@ -387,15 +415,17 @@ impl<'a> StringReader<'a> {\n             self.pos = new_pos;\n             self.next_pos = new_pos + Pos::from_usize(new_ch_len);\n             if old_ch_is_newline {\n-                if self.save_new_lines {\n+                if self.save_new_lines_and_multibyte {\n                     self.filemap.next_line(self.pos);\n                 }\n                 self.col = CharPos(0);\n             } else {\n                 self.col = self.col + CharPos(1);\n             }\n             if new_ch_len > 1 {\n-                self.filemap.record_multibyte_char(self.pos, new_ch_len);\n+                if self.save_new_lines_and_multibyte {\n+                    self.filemap.record_multibyte_char(self.pos, new_ch_len);\n+                }\n             }\n         } else {\n             self.ch = None;"}, {"sha": "013632141dee69b27baf174a1abfe5a62b9fb973", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -68,6 +68,9 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_expr_post(&mut self, _ex: &'ast Expr) { }\n     fn visit_ty(&mut self, t: &'ast Ty) { walk_ty(self, t) }\n     fn visit_generics(&mut self, g: &'ast Generics) { walk_generics(self, g) }\n+    fn visit_where_predicate(&mut self, p: &'ast WherePredicate) {\n+        walk_where_predicate(self, p)\n+    }\n     fn visit_fn(&mut self, fk: FnKind<'ast>, fd: &'ast FnDecl, s: Span, _: NodeId) {\n         walk_fn(self, fk, fd, s)\n     }\n@@ -488,28 +491,30 @@ pub fn walk_generics<'a, V: Visitor<'a>>(visitor: &mut V, generics: &'a Generics\n         walk_list!(visitor, visit_attribute, &*param.attrs);\n     }\n     walk_list!(visitor, visit_lifetime_def, &generics.lifetimes);\n-    for predicate in &generics.where_clause.predicates {\n-        match *predicate {\n-            WherePredicate::BoundPredicate(WhereBoundPredicate{ref bounded_ty,\n-                                                               ref bounds,\n-                                                               ref bound_lifetimes,\n-                                                               ..}) => {\n-                visitor.visit_ty(bounded_ty);\n-                walk_list!(visitor, visit_ty_param_bound, bounds);\n-                walk_list!(visitor, visit_lifetime_def, bound_lifetimes);\n-            }\n-            WherePredicate::RegionPredicate(WhereRegionPredicate{ref lifetime,\n-                                                                 ref bounds,\n-                                                                 ..}) => {\n-                visitor.visit_lifetime(lifetime);\n-                walk_list!(visitor, visit_lifetime, bounds);\n-            }\n-            WherePredicate::EqPredicate(WhereEqPredicate{ref lhs_ty,\n-                                                         ref rhs_ty,\n-                                                         ..}) => {\n-                visitor.visit_ty(lhs_ty);\n-                visitor.visit_ty(rhs_ty);\n-            }\n+    walk_list!(visitor, visit_where_predicate, &generics.where_clause.predicates);\n+}\n+\n+pub fn walk_where_predicate<'a, V: Visitor<'a>>(visitor: &mut V, predicate: &'a WherePredicate) {\n+    match *predicate {\n+        WherePredicate::BoundPredicate(WhereBoundPredicate{ref bounded_ty,\n+                                                           ref bounds,\n+                                                           ref bound_lifetimes,\n+                                                           ..}) => {\n+            visitor.visit_ty(bounded_ty);\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_lifetime_def, bound_lifetimes);\n+        }\n+        WherePredicate::RegionPredicate(WhereRegionPredicate{ref lifetime,\n+                                                             ref bounds,\n+                                                             ..}) => {\n+            visitor.visit_lifetime(lifetime);\n+            walk_list!(visitor, visit_lifetime, bounds);\n+        }\n+        WherePredicate::EqPredicate(WhereEqPredicate{ref lhs_ty,\n+                                                     ref rhs_ty,\n+                                                     ..}) => {\n+            visitor.visit_ty(lhs_ty);\n+            visitor.visit_ty(rhs_ty);\n         }\n     }\n }"}, {"sha": "fe492bd7fc849bbaa46cce06734570adefb8cfda", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -773,7 +773,7 @@ fn find_repr_type_name(diagnostic: &Handler, type_attrs: &[ast::Attribute]) -> &\n     for a in type_attrs {\n         for r in &attr::find_repr_attrs(diagnostic, a) {\n             repr_type_name = match *r {\n-                attr::ReprAny | attr::ReprPacked | attr::ReprSimd => continue,\n+                attr::ReprPacked | attr::ReprSimd => continue,\n                 attr::ReprExtern => \"i32\",\n \n                 attr::ReprInt(attr::SignedInt(ast::IntTy::Is)) => \"isize\","}, {"sha": "9911e093a898036d5fcae44fe656f6add46c2225", "filename": "src/test/compile-fail/E0081.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2FE0081.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2FE0081.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0081.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n enum Enum {\n-    P = 3, //~ NOTE first use of `3`\n+    P = 3, //~ NOTE first use of `3isize`\n     X = 3,\n-    //~^ ERROR discriminant value `3` already exists\n-    //~| NOTE enum already has `3`\n+    //~^ ERROR discriminant value `3isize` already exists\n+    //~| NOTE enum already has `3isize`\n     Y = 5\n }\n "}, {"sha": "3da00da205fec27e1d827b0a08d613a9ee59fbd4", "filename": "src/test/compile-fail/E0117.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2FE0117.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2FE0117.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0117.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -12,6 +12,8 @@ impl Drop for u32 {} //~ ERROR E0117\n //~^ NOTE impl doesn't use types inside crate\n //~| NOTE the impl does not reference any types defined in this crate\n //~| NOTE define and implement a trait or new type instead\n+//~| ERROR the Drop trait may only be implemented on structures\n+//~| implementing Drop requires a struct\n \n fn main() {\n }"}, {"sha": "9ffaef7472b7830d4c5b259589c4109cd66350ff", "filename": "src/test/compile-fail/E0306.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3b4d54ab88fd522b2f02d7079c601ddec047eba8/src%2Ftest%2Fcompile-fail%2FE0306.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4d54ab88fd522b2f02d7079c601ddec047eba8/src%2Ftest%2Fcompile-fail%2FE0306.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0306.rs?ref=3b4d54ab88fd522b2f02d7079c601ddec047eba8", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-const A: [u32; \"hello\"] = [];\n-//~^ ERROR expected `usize` for array length, found string literal [E0306]\n-//~| NOTE expected `usize`\n-\n-const B: [u32; true] = [];\n-//~^ ERROR expected `usize` for array length, found boolean [E0306]\n-//~| NOTE expected `usize`\n-\n-const C: [u32; 0.0] = [];\n-//~^ ERROR expected `usize` for array length, found float [E0306]\n-//~| NOTE expected `usize`\n-\n-fn main() {\n-}"}, {"sha": "7f77ae2ec1f10ec4b954b29e780527dead31b99b", "filename": "src/test/compile-fail/associated-const-array-len.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fassociated-const-array-len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fassociated-const-array-len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-array-len.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -14,7 +14,8 @@ trait Foo {\n     const ID: usize;\n }\n \n-const X: [i32; <i32 as Foo>::ID] = [0, 1, 2]; //~ ERROR E0080\n+const X: [i32; <i32 as Foo>::ID] = [0, 1, 2];\n+//~^ ERROR the trait bound `i32: Foo` is not satisfied\n \n fn main() {\n     assert_eq!(1, X);"}, {"sha": "7fd9605ef2cdc6323b7177cd822272e9e1e748a0", "filename": "src/test/compile-fail/associated-const-type-parameter-arrays-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays-2.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -27,8 +27,6 @@ impl Foo for Def {\n pub fn test<A: Foo, B: Foo>() {\n     let _array = [4; <A as Foo>::Y];\n     //~^ ERROR cannot use an outer type parameter in this context [E0402]\n-    //~| ERROR constant evaluation error [E0080]\n-    //~| non-constant path in constant\n }\n \n fn main() {"}, {"sha": "71c7a3965ec3c8c5af96d6211de60b14cf3ca692", "filename": "src/test/compile-fail/associated-const-type-parameter-arrays.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -27,8 +27,6 @@ impl Foo for Def {\n pub fn test<A: Foo, B: Foo>() {\n     let _array: [u32; <A as Foo>::Y];\n     //~^ ERROR cannot use an outer type parameter in this context [E0402]\n-    //~| ERROR constant evaluation error [E0080]\n-    //~| non-constant path in constant\n }\n \n fn main() {"}, {"sha": "aac870293fd5500ae27a04fbf764f2b016d1a026", "filename": "src/test/compile-fail/coherence-cross-crate-conflict.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fcoherence-cross-crate-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fcoherence-cross-crate-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-cross-crate-conflict.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -17,6 +17,7 @@ use trait_impl_conflict::Foo;\n \n impl<A> Foo for A {\n     //~^ ERROR type parameter `A` must be used as the type parameter for some local type\n+    //~| ERROR conflicting implementations of trait `trait_impl_conflict::Foo` for type `isize`\n }\n \n fn main() {"}, {"sha": "15a80c64f8b0621fcd07d054ba4580a01e914377", "filename": "src/test/compile-fail/coherence-default-trait-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -13,9 +13,9 @@\n trait MyTrait {}\n \n impl MyTrait for .. {}\n+//~^ ERROR redundant default implementations of trait `MyTrait`\n \n impl MyTrait for .. {}\n-//~^ ERROR redundant default implementations of trait `MyTrait`\n \n trait MySafeTrait {}\n "}, {"sha": "60b5d14d1587a9f9706defd1eb3a56c2b4c169d6", "filename": "src/test/compile-fail/coherence-impls-sized.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -27,14 +27,20 @@ impl Sized for TestE {} //~ ERROR E0322\n impl Sized for MyType {} //~ ERROR E0322\n //~^ impl of 'Sized' not allowed\n \n-impl Sized for (MyType, MyType) {} //~ ERROR E0117\n+impl Sized for (MyType, MyType) {} //~ ERROR E0322\n+//~^ impl of 'Sized' not allowed\n+//~| ERROR E0117\n \n impl Sized for &'static NotSync {} //~ ERROR E0322\n //~^ impl of 'Sized' not allowed\n \n-impl Sized for [MyType] {} //~ ERROR E0117\n+impl Sized for [MyType] {} //~ ERROR E0322\n+//~^ impl of 'Sized' not allowed\n+//~| ERROR E0117\n \n-impl Sized for &'static [NotSync] {} //~ ERROR E0117\n+impl Sized for &'static [NotSync] {} //~ ERROR E0322\n+//~^ impl of 'Sized' not allowed\n+//~| ERROR E0117\n \n fn main() {\n }"}, {"sha": "108b7948dfcc20c981cc9ba88abebca27c909d5b", "filename": "src/test/compile-fail/const-array-oob.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fconst-array-oob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fconst-array-oob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-array-oob.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -12,8 +12,8 @@\n \n #![feature(const_indexing)]\n \n-const FOO: [u32; 3] = [1, 2, 3];\n-const BAR: u32 = FOO[5]; // no error, because the error below occurs before regular const eval\n+const FOO: [usize; 3] = [1, 2, 3];\n+const BAR: usize = FOO[5]; // no error, because the error below occurs before regular const eval\n \n const BLUB: [u32; FOO[4]] = [5, 6];\n //~^ ERROR constant evaluation error [E0080]"}, {"sha": "83166c9bd4b5e312c9dfab308c2c55c887abde15", "filename": "src/test/compile-fail/const-block-non-item-statement-2.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement-2.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const A: usize = { 1; 2 };\n+//~^ ERROR: blocks in constants are limited to items and tail expressions\n+\n+const B: usize = { { } 2 };\n+//~^ ERROR: blocks in constants are limited to items and tail expressions\n+\n+macro_rules! foo {\n+    () => (()) //~ ERROR: blocks in constants are limited to items and tail expressions\n+}\n+const C: usize = { foo!(); 2 };\n+\n+const D: usize = { let x = 4; 2 };\n+//~^ ERROR: blocks in constants are limited to items and tail expressions\n+//~^^ ERROR: blocks in constants are limited to items and tail expressions\n+\n+pub fn main() {}"}, {"sha": "bdc69c937c63780031f431cef0289674891359c8", "filename": "src/test/compile-fail/const-block-non-item-statement.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -8,21 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const A: usize = { 1; 2 };\n-//~^ ERROR: blocks in constants are limited to items and tail expressions\n-\n-const B: usize = { { } 2 };\n-//~^ ERROR: blocks in constants are limited to items and tail expressions\n-\n-macro_rules! foo {\n-    () => (()) //~ ERROR: blocks in constants are limited to items and tail expressions\n-}\n-const C: usize = { foo!(); 2 };\n-\n-const D: usize = { let x = 4; 2 };\n-//~^ ERROR: blocks in constants are limited to items and tail expressions\n-//~^^ ERROR: blocks in constants are limited to items and tail expressions\n-\n enum Foo {\n     Bar = { let x = 1; 3 }\n     //~^ ERROR: blocks in constants are limited to items and tail expressions\n@@ -33,8 +18,4 @@ type Array = [u32; {  let x = 2; 5 }];\n //~^ ERROR: blocks in constants are limited to items and tail expressions\n //~^^ ERROR: blocks in constants are limited to items and tail expressions\n \n-pub fn main() {\n-    let _: Array = [0; { let x = 3; 5 }];\n-    //~^ ERROR: blocks in constants are limited to items and tail expressions\n-    //~^^ ERROR: blocks in constants are limited to items and tail expressions\n-}\n+pub fn main() {}"}, {"sha": "ff83dd004a257ccb2a9f9b76911bf796d89bd844", "filename": "src/test/compile-fail/const-call.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fconst-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fconst-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-call.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -15,6 +15,8 @@ fn f(x: usize) -> usize {\n }\n \n fn main() {\n-    let _ = [0; f(2)]; //~ ERROR constant evaluation error [E0080]\n-                       //~| non-constant path in constant expression\n+    let _ = [0; f(2)];\n+    //~^ ERROR calls in constants are limited to constant functions\n+    //~| ERROR constant evaluation error [E0080]\n+    //~| non-constant path in constant expression\n }"}, {"sha": "02072e9a1a1f6ab5e298a281e6aa16564dc84786", "filename": "src/test/compile-fail/const-eval-overflow-4b.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -20,8 +20,9 @@ use std::{u8, u16, u32, u64, usize};\n \n const A_I8_T\n     : [u32; (i8::MAX as i8 + 1u8) as usize]\n-    //~^ ERROR constant evaluation error [E0080]\n+    //~^ ERROR mismatched types\n     //~| expected i8, found u8\n+    //~| ERROR the trait bound `i8: std::ops::Add<u8>` is not satisfied\n     = [0; (i8::MAX as usize) + 1];\n \n \n@@ -32,8 +33,7 @@ const A_CHAR_USIZE\n \n const A_BAD_CHAR_USIZE\n     : [u32; 5i8 as char as usize]\n-    //~^ ERROR constant evaluation error\n-    //~| only `u8` can be cast as `char`, not `i8`\n+    //~^ ERROR only `u8` can be cast as `char`, not `i8`\n     = [0; 5];\n \n fn main() {}"}, {"sha": "16f89606b01e6da87a20f6781b2c5bfa6991c2d7", "filename": "src/test/compile-fail/const-eval-span.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fconst-eval-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fconst-eval-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-span.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -14,12 +14,13 @@\n struct S(i32);\n \n const CONSTANT: S = S(0);\n-//~^ ERROR E0080\n-//~| unimplemented constant expression: tuple struct constructors\n \n enum E {\n     V = CONSTANT,\n-    //~^ NOTE: for enum discriminant here\n+    //~^ ERROR mismatched types\n+    //~| expected isize, found struct `S`\n+    //~| NOTE expected type `isize`\n+    //~|         found type `S`\n }\n \n fn main() {}"}, {"sha": "29bc665a22e7bbe5ed3c4b071ae847d2a3719f5e", "filename": "src/test/compile-fail/const-integer-bool-ops.rs", "status": "modified", "additions": 49, "deletions": 30, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -8,52 +8,71 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const X: usize = 42 && 39; //~ ERROR E0080\n-                           //~| can't do this op on integrals\n-const ARR: [i32; X] = [99; 34]; //~ NOTE: for array length here\n+const X: usize = 42 && 39;\n+//~^ ERROR mismatched types\n+//~| expected bool, found integral variable\n+//~| ERROR mismatched types\n+//~| expected bool, found integral variable\n+//~| ERROR mismatched types\n+//~| expected usize, found bool\n+const ARR: [i32; X] = [99; 34];\n \n-const X1: usize = 42 || 39; //~ ERROR E0080\n-                            //~| can't do this op on integrals\n-const ARR1: [i32; X1] = [99; 47]; //~ NOTE: for array length here\n+const X1: usize = 42 || 39;\n+//~^ ERROR mismatched types\n+//~| expected bool, found integral variable\n+//~| ERROR mismatched types\n+//~| expected bool, found integral variable\n+//~| ERROR mismatched types\n+//~| expected usize, found bool\n+const ARR1: [i32; X1] = [99; 47];\n \n-const X2: usize = -42 || -39; //~ ERROR E0080\n-                              //~| unary negation of unsigned integer\n-const ARR2: [i32; X2] = [99; 18446744073709551607]; //~ NOTE: for array length here\n+const X2: usize = -42 || -39;\n+//~^ ERROR mismatched types\n+//~| expected bool, found integral variable\n+//~| ERROR mismatched types\n+//~| expected bool, found integral variable\n+//~| ERROR mismatched types\n+//~| expected usize, found bool\n+const ARR2: [i32; X2] = [99; 18446744073709551607];\n \n-const X3: usize = -42 && -39; //~ ERROR E0080\n-                              //~| unary negation of unsigned integer\n-const ARR3: [i32; X3] = [99; 6]; //~ NOTE: for array length here\n+const X3: usize = -42 && -39;\n+//~^ ERROR mismatched types\n+//~| expected bool, found integral variable\n+//~| ERROR mismatched types\n+//~| expected bool, found integral variable\n+//~| ERROR mismatched types\n+//~| expected usize, found bool\n+const ARR3: [i32; X3] = [99; 6];\n \n const Y: usize = 42.0 == 42.0;\n+//~^ ERROR mismatched types\n+//~| expected usize, found bool\n const ARRR: [i32; Y] = [99; 1];\n-//~^ ERROR: expected `usize` for array length, found boolean [E0306]\n-//~| NOTE expected `usize`\n \n const Y1: usize = 42.0 >= 42.0;\n-const ARRR1: [i32; Y] = [99; 1];\n-//~^ ERROR: expected `usize` for array length, found boolean [E0306]\n-//~| NOTE expected `usize`\n+//~^ ERROR mismatched types\n+//~| expected usize, found bool\n+const ARRR1: [i32; Y1] = [99; 1];\n \n const Y2: usize = 42.0 <= 42.0;\n-const ARRR2: [i32; Y] = [99; 1];\n-//~^ ERROR: expected `usize` for array length, found boolean [E0306]\n-//~| NOTE expected `usize`\n+//~^ ERROR mismatched types\n+//~| expected usize, found bool\n+const ARRR2: [i32; Y2] = [99; 1];\n \n const Y3: usize = 42.0 > 42.0;\n-const ARRR3: [i32; Y] = [99; 0];\n-//~^ ERROR: expected `usize` for array length, found boolean [E0306]\n-//~| NOTE expected `usize`\n+//~^ ERROR mismatched types\n+//~| expected usize, found bool\n+const ARRR3: [i32; Y3] = [99; 0];\n \n const Y4: usize = 42.0 < 42.0;\n-const ARRR4: [i32; Y] = [99; 0];\n-//~^ ERROR: expected `usize` for array length, found boolean [E0306]\n-//~| NOTE expected `usize`\n+//~^ ERROR mismatched types\n+//~| expected usize, found bool\n+const ARRR4: [i32; Y4] = [99; 0];\n \n const Y5: usize = 42.0 != 42.0;\n-const ARRR5: [i32; Y] = [99; 0];\n-//~^ ERROR: expected `usize` for array length, found boolean [E0306]\n-//~| NOTE expected `usize`\n-\n+//~^ ERROR mismatched types\n+//~| expected usize, found bool\n+const ARRR5: [i32; Y5] = [99; 0];\n \n fn main() {\n     let _ = ARR;"}, {"sha": "b42c440f87d74e3678dfc6bf79c8d32a5e5ee7d8", "filename": "src/test/compile-fail/const-tup-index-span.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -11,8 +11,8 @@\n // Test spans of errors\n \n const TUP: (usize,) = 5usize << 64;\n-//~^ ERROR E0080\n-//~| attempt to shift left with overflow\n+//~^ ERROR mismatched types\n+//~| expected tuple, found usize\n const ARR: [i32; TUP.0] = [];\n \n fn main() {"}, {"sha": "7af2f11bd281506d11174fb7a3e40e9469961882", "filename": "src/test/compile-fail/cycle-projection-based-on-where-clause.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fcycle-projection-based-on-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fcycle-projection-based-on-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-projection-based-on-where-clause.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -26,6 +26,7 @@ struct A<T>\n     where T : Trait,\n           T : Add<T::Item>\n     //~^ ERROR unsupported cyclic reference between types/traits detected\n+    //~| ERROR associated type `Item` not found for `T`\n {\n     data: T\n }"}, {"sha": "6825572b26c83cfa83eb9b154e4b2d2275fb1f41", "filename": "src/test/compile-fail/cycle-trait-default-type-trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fcycle-trait-default-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fcycle-trait-default-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-trait-default-type-trait.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -13,6 +13,7 @@\n \n trait Foo<X = Box<Foo>> {\n     //~^ ERROR unsupported cyclic reference\n+    //~| ERROR unsupported cyclic reference\n }\n \n fn main() { }"}, {"sha": "905d546e99a066984ee7c0f0c471bd78ada191d1", "filename": "src/test/compile-fail/cycle-trait-supertrait-indirect.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-indirect.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -12,14 +12,16 @@\n // a direct participant in the cycle.\n \n trait A: B {\n-    //~^ ERROR unsupported cyclic reference\n+    //~^ NOTE the cycle begins when computing the supertraits of `B`...\n }\n \n trait B: C {\n-    //~^ ERROR unsupported cyclic reference\n+    //~^ NOTE ...which then requires computing the supertraits of `C`...\n }\n \n trait C: B { }\n     //~^ ERROR unsupported cyclic reference\n+    //~| cyclic reference\n+    //~| NOTE ...which then again requires computing the supertraits of `B`, completing the cycle\n \n fn main() { }"}, {"sha": "62e54c3f23773ab1f42bec31aee796eb13aaf10a", "filename": "src/test/compile-fail/discrim-ill-typed.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fdiscrim-ill-typed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fdiscrim-ill-typed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdiscrim-ill-typed.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -25,7 +25,7 @@ fn f_i8() {\n         Ok = i8::MAX - 1,\n         Ok2,\n         OhNo = 0_u8,\n-        //~^ ERROR E0080\n+        //~^ ERROR mismatched types\n         //~| expected i8, found u8\n     }\n \n@@ -38,7 +38,7 @@ fn f_u8() {\n         Ok = u8::MAX - 1,\n         Ok2,\n         OhNo = 0_i8,\n-        //~^ ERROR E0080\n+        //~^ ERROR mismatched types\n         //~| expected u8, found i8\n     }\n \n@@ -51,7 +51,7 @@ fn f_i16() {\n         Ok = i16::MAX - 1,\n         Ok2,\n         OhNo = 0_u16,\n-        //~^ ERROR E0080\n+        //~^ ERROR mismatched types\n         //~| expected i16, found u16\n     }\n \n@@ -64,7 +64,7 @@ fn f_u16() {\n         Ok = u16::MAX - 1,\n         Ok2,\n         OhNo = 0_i16,\n-        //~^ ERROR E0080\n+        //~^ ERROR mismatched types\n         //~| expected u16, found i16\n     }\n \n@@ -77,7 +77,7 @@ fn f_i32() {\n         Ok = i32::MAX - 1,\n         Ok2,\n         OhNo = 0_u32,\n-        //~^ ERROR E0080\n+        //~^ ERROR mismatched types\n         //~| expected i32, found u32\n     }\n \n@@ -90,7 +90,7 @@ fn f_u32() {\n         Ok = u32::MAX - 1,\n         Ok2,\n         OhNo = 0_i32,\n-        //~^ ERROR E0080\n+        //~^ ERROR mismatched types\n         //~| expected u32, found i32\n     }\n \n@@ -103,7 +103,7 @@ fn f_i64() {\n         Ok = i64::MAX - 1,\n         Ok2,\n         OhNo = 0_u64,\n-        //~^ ERROR E0080\n+        //~^ ERROR mismatched types\n         //~| expected i64, found u64\n     }\n \n@@ -116,7 +116,7 @@ fn f_u64() {\n         Ok = u64::MAX - 1,\n         Ok2,\n         OhNo = 0_i64,\n-        //~^ ERROR E0080\n+        //~^ ERROR mismatched types\n         //~| expected u64, found i64\n     }\n "}, {"sha": "393a67be57fe6b73daec83ae71929d4d7c310b8a", "filename": "src/test/compile-fail/enum-discrim-too-small.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -13,32 +13,32 @@\n enum Eu8 {\n     Au8 = 23,\n     Bu8 = 223,\n-    Cu8 = -23, //~ ERROR E0080\n-               //~| unary negation of unsigned integer\n+    Cu8 = -23,\n+    //~^ ERROR cannot apply unary operator `-` to type `u8`\n }\n \n #[repr(u16)]\n enum Eu16 {\n     Au16 = 23,\n     Bu16 = 55555,\n-    Cu16 = -22333, //~ ERROR E0080\n-                   //~| unary negation of unsigned integer\n+    Cu16 = -22333,\n+    //~^ ERROR cannot apply unary operator `-` to type `u16`\n }\n \n #[repr(u32)]\n enum Eu32 {\n     Au32 = 23,\n     Bu32 = 3_000_000_000,\n-    Cu32 = -2_000_000_000, //~ ERROR E0080\n-                           //~| unary negation of unsigned integer\n+    Cu32 = -2_000_000_000,\n+    //~^ ERROR cannot apply unary operator `-` to type `u32`\n }\n \n #[repr(u64)]\n enum Eu64 {\n     Au32 = 23,\n     Bu32 = 3_000_000_000,\n-    Cu32 = -2_000_000_000, //~ ERROR E0080\n-                           //~| unary negation of unsigned integer\n+    Cu32 = -2_000_000_000,\n+    //~^ ERROR cannot apply unary operator `-` to type `u64`\n }\n \n // u64 currently allows negative numbers, and i64 allows numbers greater than `1<<63`.  This is a"}, {"sha": "13b7753082c61d3c8915b5c75acbe58fd64ca06a", "filename": "src/test/compile-fail/generic-non-trailing-defaults.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fgeneric-non-trailing-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fgeneric-non-trailing-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-non-trailing-defaults.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -10,10 +10,10 @@\n \n struct Heap;\n \n-struct Vec<A = Heap, T>;\n+struct Vec<A = Heap, T>(A, T);\n //~^ ERROR type parameters with a default must be trailing\n \n-struct Foo<A, B = Vec<C>, C>;\n+struct Foo<A, B = Vec<C>, C>(A, B, C);\n //~^ ERROR type parameters with a default must be trailing\n //~| ERROR type parameters with a default cannot use forward declared identifiers\n "}, {"sha": "bfa6af0da433bc2b2b2c9a638e7cf3debc0707bb", "filename": "src/test/compile-fail/generic-type-params-forward-mention.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fgeneric-type-params-forward-mention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fgeneric-type-params-forward-mention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-type-params-forward-mention.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // Ensure that we get an error and not an ICE for this problematic case.\n-struct Foo<T = Option<U>, U = bool>;\n+struct Foo<T = Option<U>, U = bool>(T, U);\n //~^ ERROR type parameters with a default cannot use forward declared identifiers\n fn main() {\n     let x: Foo;"}, {"sha": "13e53cab17226d385107b551928608cb95c56a1a", "filename": "src/test/compile-fail/impl-trait/auto-trait-leak.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fauto-trait-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fauto-trait-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fauto-trait-leak.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -52,23 +52,20 @@ fn after() -> impl Fn(i32) {\n // independently resolved and only require the concrete\n // return type, which can't depend on the obligation.\n fn cycle1() -> impl Clone {\n+    //~^ ERROR unsupported cyclic reference between types/traits detected\n+    //~| cyclic reference\n+    //~| NOTE the cycle begins when processing `cycle1`...\n+    //~| NOTE ...which then requires processing `cycle1::{{impl-Trait}}`...\n+    //~| NOTE ...which then again requires processing `cycle1`, completing the cycle.\n     send(cycle2().clone());\n-    //~^ ERROR the trait bound `std::rc::Rc<std::string::String>: std::marker::Send` is not satisfied\n-    //~| NOTE the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::string::String>`\n-    //~| NOTE `std::rc::Rc<std::string::String>` cannot be sent between threads safely\n-    //~| NOTE required because it appears within the type `impl std::clone::Clone`\n-    //~| NOTE required by `send`\n \n     Rc::new(Cell::new(5))\n }\n \n fn cycle2() -> impl Clone {\n+    //~^ NOTE ...which then requires processing `cycle2::{{impl-Trait}}`...\n+    //~| NOTE ...which then requires processing `cycle2`...\n     send(cycle1().clone());\n-    //~^ ERROR the trait bound `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` is not satisfied\n-    //~| NOTE the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::cell::Cell<i32>>`\n-    //~| NOTE `std::rc::Rc<std::cell::Cell<i32>>` cannot be sent between threads safely\n-    //~| NOTE required because it appears within the type `impl std::clone::Clone`\n-    //~| NOTE required by `send`\n \n     Rc::new(String::from(\"foo\"))\n }"}, {"sha": "36df4f0eb4d46f7cc25792807680fa6c622dd3cc", "filename": "src/test/compile-fail/impl-trait/equality.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fequality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fequality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fequality.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -49,17 +49,6 @@ impl Leak for i32 {\n     fn leak(self) -> i32 { self }\n }\n \n-trait CheckIfSend: Sized {\n-    type T: Default;\n-    fn check(self) -> Self::T { Default::default() }\n-}\n-impl<T> CheckIfSend for T {\n-    default type T = ();\n-}\n-impl<T: Send> CheckIfSend for T {\n-    type T = bool;\n-}\n-\n fn main() {\n     let _: u32 = hide(0_u32);\n     //~^ ERROR mismatched types\n@@ -73,12 +62,6 @@ fn main() {\n     //~| found type `<impl Foo as Leak>::T`\n     //~| expected i32, found associated type\n \n-    let _: bool = CheckIfSend::check(hide(0_i32));\n-    //~^ ERROR mismatched types\n-    //~| expected type `bool`\n-    //~| found type `<impl Foo as CheckIfSend>::T`\n-    //~| expected bool, found associated type\n-\n     let mut x = (hide(0_u32), hide(0_i32));\n     x = (x.1,\n     //~^ ERROR mismatched types"}, {"sha": "ab839e7630de907904093b4f3ac54e70285a7f0b", "filename": "src/test/compile-fail/invalid-path-in-const.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Finvalid-path-in-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Finvalid-path-in-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finvalid-path-in-const.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -10,6 +10,5 @@\n \n fn main() {\n     fn f(a: [u8; u32::DOESNOTEXIST]) {}\n-    //~^ ERROR constant evaluation error\n-    //~| unresolved path in constant expression\n+    //~^ ERROR no associated item named `DOESNOTEXIST` found for type `u32`\n }"}, {"sha": "0c3073a770141f866a0eef4e883900413993cceb", "filename": "src/test/compile-fail/issue-12511.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-12511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-12511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12511.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -9,11 +9,14 @@\n // except according to those terms.\n \n trait t1 : t2 {\n-//~^ ERROR: unsupported cyclic reference between types/traits detected\n+//~^ NOTE the cycle begins when computing the supertraits of `t1`...\n+//~| NOTE ...which then requires computing the supertraits of `t2`...\n }\n \n trait t2 : t1 {\n-//~^ ERROR: unsupported cyclic reference between types/traits detected\n+//~^ ERROR unsupported cyclic reference between types/traits detected\n+//~| cyclic reference\n+//~| NOTE ...which then again requires computing the supertraits of `t1`, completing the cycle\n }\n \n fn main() { }"}, {"sha": "658a0c1546b9f337b27704fa31d060075e91bdfc", "filename": "src/test/compile-fail/issue-15524.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -12,20 +12,20 @@ const N: isize = 1;\n \n enum Foo {\n     A = 1,\n-    //~^ NOTE first use of `1`\n-    //~| NOTE first use of `1`\n-    //~| NOTE first use of `1`\n+    //~^ NOTE first use of `1isize`\n+    //~| NOTE first use of `1isize`\n+    //~| NOTE first use of `1isize`\n     B = 1,\n-    //~^ ERROR discriminant value `1` already exists\n-    //~| NOTE enum already has `1`\n+    //~^ ERROR discriminant value `1isize` already exists\n+    //~| NOTE enum already has `1isize`\n     C = 0,\n     D,\n-    //~^ ERROR discriminant value `1` already exists\n-    //~| NOTE enum already has `1`\n+    //~^ ERROR discriminant value `1isize` already exists\n+    //~| NOTE enum already has `1isize`\n \n     E = N,\n-    //~^ ERROR discriminant value `1` already exists\n-    //~| NOTE enum already has `1`\n+    //~^ ERROR discriminant value `1isize` already exists\n+    //~| NOTE enum already has `1isize`\n \n }\n "}, {"sha": "feab04531b7e11bca3b4738a7de5a19c6e1d8b71", "filename": "src/test/compile-fail/issue-18183.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-18183.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-18183.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18183.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub struct Foo<Bar=Bar>; //~ ERROR E0128\n-                         //~| NOTE defaulted type parameters cannot be forward declared\n+pub struct Foo<Bar=Bar>(Bar); //~ ERROR E0128\n+                              //~| NOTE defaulted type parameters cannot be forward declared\n pub struct Baz(Foo);\n fn main() {}"}, {"sha": "7ae4250d4203bac9f6274cd297433762c90c2d0f", "filename": "src/test/compile-fail/issue-20772.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-20772.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-20772.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20772.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -10,6 +10,7 @@\n \n trait T : Iterator<Item=Self::Item>\n //~^ ERROR unsupported cyclic reference between types/traits detected\n+//~| ERROR associated type `Item` not found for `Self`\n {}\n \n fn main() {}"}, {"sha": "f49b71953835b28ac50d8b058f39901c2d601fb8", "filename": "src/test/compile-fail/issue-21177.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-21177.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-21177.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21177.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -14,6 +14,7 @@ trait Trait {\n }\n \n fn foo<T: Trait<A = T::B>>() { }\n-//~^ ERROR: unsupported cyclic reference between types/traits detected\n+//~^ ERROR unsupported cyclic reference between types/traits detected\n+//~| ERROR associated type `B` not found for `T`\n \n fn main() { }"}, {"sha": "c78e1f7f5309505689b74c03c6d0f70e9f1b800c", "filename": "src/test/compile-fail/issue-22933-2.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -12,12 +12,10 @@ enum Delicious {\n     Pie      = 0x1,\n     Apple    = 0x2,\n     ApplePie = Delicious::Apple as isize | Delicious::PIE as isize,\n-    //~^ ERROR constant evaluation error\n-    //~| unresolved path in constant expression\n+    //~^ ERROR no associated item named `PIE` found for type `Delicious`\n }\n \n const FOO: [u32; u8::MIN as usize] = [];\n-//~^ ERROR constant evaluation error\n-//~| unresolved path in constant expression\n+//~^ ERROR no associated item named `MIN` found for type `u8`\n \n fn main() {}"}, {"sha": "95f6526f11559e835f37a126c6a20e17d7a297d2", "filename": "src/test/compile-fail/issue-23217.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-23217.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-23217.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23217.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -10,8 +10,7 @@\n \n pub enum SomeEnum {\n     B = SomeEnum::A,\n-    //~^ ERROR constant evaluation error\n-    //~| unresolved path in constant expression\n+    //~^ ERROR no associated item named `A` found for type `SomeEnum`\n }\n \n fn main() {}"}, {"sha": "b8571d2e85e2c8bfae4f42a6238a5e7a37aa337c", "filename": "src/test/compile-fail/issue-28586.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-28586.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-28586.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28586.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -11,6 +11,7 @@\n // Regression test for issue #28586\n \n pub trait Foo {}\n-impl Foo for [u8; usize::BYTES] {} //~ ERROR E0080\n+impl Foo for [u8; usize::BYTES] {}\n+//~^ ERROR no associated item named `BYTES` found for type `usize`\n \n fn main() { }"}, {"sha": "aac8b89e882b3b7f6adcec6367a7f13e25190e90", "filename": "src/test/compile-fail/issue-31910.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-31910.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-31910.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-31910.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -11,7 +11,9 @@\n #![feature(associated_consts)]\n \n enum Enum<T: Trait> {\n-    X = Trait::Number, //~ ERROR constant evaluation error\n+    X = Trait::Number,\n+    //~^ ERROR mismatched types\n+    //~| expected isize, found i32\n }\n \n trait Trait {"}, {"sha": "78af11a0b5813ebc0a032382c6def694fd87b387", "filename": "src/test/compile-fail/issue-3521.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -15,9 +15,7 @@ fn main() {\n     enum Stuff {\n         Bar = foo\n         //~^ ERROR attempt to use a non-constant value in a constant\n-        //~^^ ERROR constant evaluation error\n-        //~| unresolved path in constant expression\n     }\n \n-    println!(\"{}\", Stuff::Bar);\n+    println!(\"{:?}\", Stuff::Bar);\n }"}, {"sha": "06e8406cbc0bd15c3b7d531cc82058a71ec82eef", "filename": "src/test/compile-fail/issue-39559.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -23,9 +23,15 @@ impl Dim for Dim3 {\n pub struct Vector<T, D: Dim> {\n     entries: [T; D::dim()]\n     //~^ ERROR cannot use an outer type parameter in this context\n-    //~| ERROR constant evaluation error\n }\n \n fn main() {\n-    let array: [usize; Dim3::dim()] = [0; Dim3::dim()];\n+    let array: [usize; Dim3::dim()]\n+    //~^ ERROR calls in constants are limited to constant functions\n+    //~| ERROR constant evaluation error\n+    //~| non-constant path in constant expression\n+        = [0; Dim3::dim()];\n+        //~^ ERROR calls in constants are limited to constant functions\n+        //~| ERROR constant evaluation error\n+        //~| non-constant path in constant expression\n }"}, {"sha": "f8424ea64ef9e29794a76aa621eb0e974e34b075", "filename": "src/test/compile-fail/issue-8761.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-8761.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fissue-8761.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8761.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -10,10 +10,10 @@\n \n enum Foo {\n     A = 1i64,\n-    //~^ ERROR constant evaluation error\n+    //~^ ERROR mismatched types\n     //~| expected isize, found i64\n     B = 2u8\n-    //~^ ERROR constant evaluation error\n+    //~^ ERROR mismatched types\n     //~| expected isize, found u8\n }\n "}, {"sha": "52cd4e8a3ed95122a8683b43c3944fde46f82e2b", "filename": "src/test/compile-fail/non-constant-expr-for-fixed-len-vec.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -14,6 +14,5 @@ fn main() {\n     fn bar(n: isize) {\n         let _x: [isize; n];\n         //~^ ERROR attempt to use a non-constant value in a constant [E0435]\n-        //~| ERROR constant evaluation error [E0080]\n     }\n }"}, {"sha": "1eda5087784029be6f3aa30a76c95c035b6fa942", "filename": "src/test/compile-fail/non-constant-expr-for-vec-repeat.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -15,7 +15,5 @@ fn main() {\n         let _x = [0; n];\n         //~^ ERROR attempt to use a non-constant value in a constant [E0435]\n         //~| NOTE non-constant used with constant\n-        //~| NOTE unresolved path in constant expression\n-        //~| ERROR constant evaluation error [E0080]\n     }\n }"}, {"sha": "710d8e11ff03420964d691d587428e81cc60a97f", "filename": "src/test/compile-fail/resolve-self-in-impl.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -8,22 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_type_defaults)]\n+\n struct S<T = u8>(T);\n-trait Tr<T = u8> {}\n+trait Tr<T = u8> {\n+    type A = ();\n+}\n \n impl Tr<Self> for S {} // OK\n+impl<T: Tr<Self>> Tr<T> for S {} // OK\n+impl<T = Self> Tr<T> for S {} // OK\n+impl Tr for S where Self: Copy {} // OK\n+impl Tr for S where S<Self>: Copy {} // OK\n+impl Tr for S where Self::A: Copy {} // OK\n \n-// FIXME: `Self` cannot be used in bounds because it depends on bounds itself.\n-impl<T: Tr<Self>> Tr<T> for S {} //~ ERROR `Self` type is used before it's determined\n-impl<T = Self> Tr<T> for S {} //~ ERROR `Self` type is used before it's determined\n-impl Tr for S where Self: Copy {} //~ ERROR `Self` type is used before it's determined\n-impl Tr for S where S<Self>: Copy {} //~ ERROR `Self` type is used before it's determined\n-impl Tr for S where Self::Assoc: Copy {} //~ ERROR `Self` type is used before it's determined\n-                                         //~^ ERROR `Self` type is used before it's determined\n-impl Tr for Self {} //~ ERROR `Self` type is used before it's determined\n-impl Tr for S<Self> {} //~ ERROR `Self` type is used before it's determined\n-impl Self {} //~ ERROR `Self` type is used before it's determined\n-impl S<Self> {} //~ ERROR `Self` type is used before it's determined\n-impl Tr<Self::Assoc> for S {} //~ ERROR `Self` type is used before it's determined\n+impl Tr for Self {} //~ ERROR unsupported cyclic reference between types/traits detected\n+impl Tr for S<Self> {} //~ ERROR unsupported cyclic reference between types/traits detected\n+impl Self {} //~ ERROR unsupported cyclic reference between types/traits detected\n+impl S<Self> {} //~ ERROR unsupported cyclic reference between types/traits detected\n+impl Tr<Self::A> for S {} //~ ERROR unsupported cyclic reference between types/traits detected\n \n fn main() {}"}, {"sha": "048ccb529a24fc9a516eaeea9667189c55c454fd", "filename": "src/test/incremental/hashes/enum_defs.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -112,10 +112,13 @@ enum EnumChangeValueCStyleVariant0 {\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumChangeValueCStyleVariant0 {\n     Variant1,\n+\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     Variant2 = 22,\n }\n "}, {"sha": "6e80a9174676a1247515fae79095f52fc17a9899", "filename": "src/test/mir-opt/simplify_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -17,7 +17,7 @@ fn main() {\n // END RUST SOURCE\n // START rustc.node4.SimplifyBranches.initial-before.mir\n // bb0: {\n-//     switchInt(const false) -> [0: bb2, otherwise: bb1];\n+//     switchInt(const false) -> [0u8: bb2, otherwise: bb1];\n // }\n // END rustc.node4.SimplifyBranches.initial-before.mir\n // START rustc.node4.SimplifyBranches.initial-after.mir"}, {"sha": "587fb3f80d6c8a810910d7a31aa2c0451202ef8e", "filename": "src/test/run-pass/associated-types-sugar-path.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Frun-pass%2Fassociated-types-sugar-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Frun-pass%2Fassociated-types-sugar-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-sugar-path.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -10,10 +10,13 @@\n \n // Test paths to associated types using the type-parameter-only sugar.\n \n+use std::ops::Deref;\n \n pub trait Foo {\n     type A;\n     fn boo(&self) -> Self::A;\n+\n+    fn baz(_: Self::Target) where Self: Deref {}\n }\n \n impl Foo for isize {"}, {"sha": "011d910c5a50f6c5721445c3ea92e3cb8a49e6be", "filename": "src/test/run-pass/impl-trait/auto-trait-leak.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauto-trait-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauto-trait-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauto-trait-leak.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -29,16 +29,3 @@ fn after() -> impl FnMut(i32) {\n     let mut p = Box::new(0);\n     move |x| *p = x\n }\n-\n-// Cycles should work as the deferred obligations are\n-// independently resolved and only require the concrete\n-// return type, which can't depend on the obligation.\n-fn cycle1() -> impl Clone {\n-    send(cycle2().clone());\n-    5\n-}\n-\n-fn cycle2() -> impl Clone {\n-    send(cycle1().clone());\n-    String::from(\"foo\")\n-}"}, {"sha": "ceed454e5ad7e79698ccc8a3b6cf9fdb7b3825e2", "filename": "src/test/run-pass/impl-trait/equality.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fequality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fequality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fequality.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -28,6 +28,17 @@ impl<T> Leak<T> for T {\n     fn leak(self) -> T { self }\n }\n \n+trait CheckIfSend: Sized {\n+    type T: Default;\n+    fn check(self) -> Self::T { Default::default() }\n+}\n+impl<T> CheckIfSend for T {\n+    default type T = ();\n+}\n+impl<T: Send> CheckIfSend for T {\n+    type T = bool;\n+}\n+\n fn lucky_seven() -> impl Fn(usize) -> u8 {\n     let a = [1, 2, 3, 4, 5, 6, 7];\n     move |i| a[i]\n@@ -40,4 +51,6 @@ fn main() {\n     assert_eq!(std::mem::size_of_val(&lucky_seven()), 7);\n \n     assert_eq!(Leak::<i32>::leak(hide(5_i32)), 5_i32);\n+\n+    assert_eq!(CheckIfSend::check(hide(0_i32)), false);\n }"}, {"sha": "6f02f2783818e281ddb446ac48e2e0cec6ab0345", "filename": "src/test/run-pass/issue-25145.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Frun-pass%2Fissue-25145.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Frun-pass%2Fissue-25145.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-25145.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -17,7 +17,7 @@ impl S {\n }\n \n static STUFF: [u8; S::N] = [0; S::N];\n-//~^ ERROR constant evaluation error\n-//~| unresolved path in constant expression\n \n-fn main() {}\n+fn main() {\n+    assert_eq!(STUFF, [0; 3]);\n+}", "previous_filename": "src/test/compile-fail/issue-25145.rs"}, {"sha": "7da50670d1dee225f9dfc76c2149c1657a903146", "filename": "src/test/run-pass/issue-39548.rs", "status": "renamed", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Frun-pass%2Fissue-39548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Frun-pass%2Fissue-39548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-39548.rs?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum Foo {\n-    Q = \"32\" //~ ERROR E0079\n-    //~^ expected 'isize' type\n-}\n+type Array = [(); ((1 < 2) == false) as usize];\n \n fn main() {\n+    let _: Array = [];\n }", "previous_filename": "src/test/compile-fail/E0079.rs"}, {"sha": "fda87de9b9c500bb2f3d151ec33aa14cc7d9ca59", "filename": "src/test/ui/resolve/issue-23305.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -1,8 +1,15 @@\n-error: `Self` type is used before it's determined\n+error[E0391]: unsupported cyclic reference between types/traits detected\n   --> $DIR/issue-23305.rs:15:12\n    |\n 15 | impl ToNbt<Self> {}\n-   |            ^^^^\n+   |            ^^^^ cyclic reference\n+   |\n+note: the cycle begins when processing `<impl at $DIR/issue-23305.rs:15:1: 15:20>`...\n+  --> $DIR/issue-23305.rs:15:1\n+   |\n+15 | impl ToNbt<Self> {}\n+   | ^^^^^^^^^^^^^^^^^^^\n+   = note: ...which then again requires processing `<impl at $DIR/issue-23305.rs:15:1: 15:20>`, completing the cycle.\n \n error: aborting due to previous error\n "}, {"sha": "c7c42bcf239405088ebea527aaae1baa55e460cb", "filename": "src/test/ui/resolve/levenshtein.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -46,11 +46,5 @@ error[E0425]: cannot find value `second` in module `m`\n 32 |     let b: m::first = m::second; // Misspelled item in module.\n    |                       ^^^^^^^^^ did you mean `m::Second`?\n \n-error[E0080]: constant evaluation error\n-  --> $DIR/levenshtein.rs:30:20\n-   |\n-30 |     let v = [0u32; MAXITEM]; // Misspelled constant name.\n-   |                    ^^^^^^^ unresolved path in constant expression\n-\n-error: aborting due to previous error\n+error: aborting due to 8 previous errors\n "}, {"sha": "4fe6afaca8ec658a4eae9fdba79b35dc37cacb29", "filename": "src/test/ui/span/E0204.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fui%2Fspan%2FE0204.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1cb9ba221e5cb0070ac82c6a234af11e4240680/src%2Ftest%2Fui%2Fspan%2FE0204.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0204.stderr?ref=e1cb9ba221e5cb0070ac82c6a234af11e4240680", "patch": "@@ -7,15 +7,6 @@ error[E0204]: the trait `Copy` may not be implemented for this type\n 15 | impl Copy for Foo { }\n    |      ^^^^\n \n-error[E0204]: the trait `Copy` may not be implemented for this type\n-  --> $DIR/E0204.rs:27:6\n-   |\n-23 |     Bar { x: Vec<u32> },\n-   |           ----------- this field does not implement `Copy`\n-...\n-27 | impl Copy for EFoo { }\n-   |      ^^^^\n-\n error[E0204]: the trait `Copy` may not be implemented for this type\n   --> $DIR/E0204.rs:17:10\n    |\n@@ -25,6 +16,15 @@ error[E0204]: the trait `Copy` may not be implemented for this type\n 19 |     ty: &'a mut bool,\n    |     ---------------- this field does not implement `Copy`\n \n+error[E0204]: the trait `Copy` may not be implemented for this type\n+  --> $DIR/E0204.rs:27:6\n+   |\n+23 |     Bar { x: Vec<u32> },\n+   |           ----------- this field does not implement `Copy`\n+...\n+27 | impl Copy for EFoo { }\n+   |      ^^^^\n+\n error[E0204]: the trait `Copy` may not be implemented for this type\n   --> $DIR/E0204.rs:29:10\n    |"}]}