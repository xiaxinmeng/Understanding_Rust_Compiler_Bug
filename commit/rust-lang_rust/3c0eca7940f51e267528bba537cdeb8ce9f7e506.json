{"sha": "3c0eca7940f51e267528bba537cdeb8ce9f7e506", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjMGVjYTc5NDBmNTFlMjY3NTI4YmJhNTM3Y2RlYjhjZTlmN2U1MDY=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-16T18:16:32Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-19T18:02:52Z"}, "message": "librustc: convert creader and cstore to use @~strs", "tree": {"sha": "31e7a491fe733e45fd39be82f6f60c76634d053b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31e7a491fe733e45fd39be82f6f60c76634d053b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c0eca7940f51e267528bba537cdeb8ce9f7e506", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c0eca7940f51e267528bba537cdeb8ce9f7e506", "html_url": "https://github.com/rust-lang/rust/commit/3c0eca7940f51e267528bba537cdeb8ce9f7e506", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c0eca7940f51e267528bba537cdeb8ce9f7e506/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a18e7d6656e02216067aa752ce69ee37b5103f08", "url": "https://api.github.com/repos/rust-lang/rust/commits/a18e7d6656e02216067aa752ce69ee37b5103f08", "html_url": "https://github.com/rust-lang/rust/commit/a18e7d6656e02216067aa752ce69ee37b5103f08"}], "stats": {"total": 135, "additions": 67, "deletions": 68}, "files": [{"sha": "8567e90103262b562a9e1395cfefb2f726355a1c", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3c0eca7940f51e267528bba537cdeb8ce9f7e506/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c0eca7940f51e267528bba537cdeb8ce9f7e506/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=3c0eca7940f51e267528bba537cdeb8ce9f7e506", "patch": "@@ -64,7 +64,7 @@ pub fn read_crates(diag: span_handler,\n type cache_entry = {\n     cnum: int,\n     span: span,\n-    hash: ~str,\n+    hash: @~str,\n     metas: @~[@ast::meta_item]\n };\n \n@@ -100,7 +100,7 @@ fn warn_if_multiple_versions(e: @mut Env,\n \n         if matches.len() != 1u {\n             diag.handler().warn(\n-                fmt!(\"using multiple versions of crate `%s`\", name));\n+                fmt!(\"using multiple versions of crate `%s`\", *name));\n             for matches.each |match_| {\n                 diag.span_note(match_.span, ~\"used here\");\n                 let attrs = ~[\n@@ -145,7 +145,7 @@ fn visit_view_item(e: @mut Env, i: @ast::view_item) {\n       ast::view_item_extern_mod(ident, meta_items, id) => {\n         debug!(\"resolving extern mod stmt. ident: %?, meta: %?\",\n                ident, meta_items);\n-        let cnum = resolve_crate(e, ident, meta_items, ~\"\", i.span);\n+        let cnum = resolve_crate(e, ident, meta_items, @~\"\", i.span);\n         cstore::add_extern_mod_stmt_cnum(e.cstore, id, cnum);\n       }\n       _ => ()\n@@ -172,21 +172,20 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n                 let foreign_name =\n                     match attr::first_attr_value_str_by_name(i.attrs,\n                                                             ~\"link_name\") {\n-                        Some(ref nn) => {\n-                            if **nn == ~\"\" {\n+                        Some(nn) => {\n+                            if *nn == ~\"\" {\n                                 e.diag.span_fatal(\n                                     i.span,\n                                     ~\"empty #[link_name] not allowed; use \" +\n                                     ~\"#[nolink].\");\n                             }\n-                            /*bad*/copy *nn\n+                            nn\n                         }\n-                        None => @/*bad*/copy *e.intr.get(i.ident)\n+                        None => e.intr.get(i.ident)\n                     };\n                 if attr::find_attrs_by_name(i.attrs, ~\"nolink\").is_empty() {\n                     already_added =\n-                        !cstore::add_used_library(cstore,\n-                                /*bad*/ copy *foreign_name);\n+                        !cstore::add_used_library(cstore, foreign_name);\n                 }\n                 if !link_args.is_empty() && already_added {\n                     e.diag.span_fatal(i.span, ~\"library '\" + *foreign_name +\n@@ -198,8 +197,8 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n \n         for link_args.each |a| {\n             match attr::get_meta_item_value_str(attr::attr_meta(*a)) {\n-                Some(ref linkarg) => {\n-                    cstore::add_used_link_args(cstore, /*bad*/copy **linkarg);\n+                Some(linkarg) => {\n+                    cstore::add_used_link_args(cstore, *linkarg);\n                 }\n                 None => { /* fallthrough */ }\n             }\n@@ -209,22 +208,22 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n     }\n }\n \n-fn metas_with(+ident: ~str, +key: ~str, +metas: ~[@ast::meta_item])\n+fn metas_with(ident: @~str, key: @~str, +metas: ~[@ast::meta_item])\n     -> ~[@ast::meta_item] {\n-    let name_items = attr::find_meta_items_by_name(metas, key);\n+    let name_items = attr::find_meta_items_by_name(metas, *key);\n     if name_items.is_empty() {\n-        vec::append_one(metas, attr::mk_name_value_item_str(@key, @ident))\n+        vec::append_one(metas, attr::mk_name_value_item_str(key, ident))\n     } else {\n         metas\n     }\n }\n \n-fn metas_with_ident(+ident: ~str, +metas: ~[@ast::meta_item])\n+fn metas_with_ident(ident: @~str, +metas: ~[@ast::meta_item])\n     -> ~[@ast::meta_item] {\n-    metas_with(ident, ~\"name\", metas)\n+    metas_with(ident, @~\"name\", metas)\n }\n \n-fn existing_match(e: @mut Env, metas: ~[@ast::meta_item], hash: ~str)\n+fn existing_match(e: @mut Env, metas: ~[@ast::meta_item], hash: @~str)\n                -> Option<int> {\n     for e.crate_cache.each |c| {\n         if loader::metadata_matches(*c.metas, metas)\n@@ -238,10 +237,10 @@ fn existing_match(e: @mut Env, metas: ~[@ast::meta_item], hash: ~str)\n fn resolve_crate(e: @mut Env,\n                  ident: ast::ident,\n                  +metas: ~[@ast::meta_item],\n-                 +hash: ~str,\n+                 hash: @~str,\n                  span: span)\n               -> ast::crate_num {\n-    let metas = metas_with_ident(/*bad*/copy *e.intr.get(ident), metas);\n+    let metas = metas_with_ident(@/*bad*/copy *e.intr.get(ident), metas);\n \n     match existing_match(e, metas, hash) {\n       None => {\n@@ -277,10 +276,10 @@ fn resolve_crate(e: @mut Env,\n         let cname =\n             match attr::last_meta_item_value_str_by_name(load_ctxt.metas,\n                                                          ~\"name\") {\n-                Some(ref v) => /*bad*/copy *v,\n-                None => @/*bad*/copy *e.intr.get(ident),\n+                Some(v) => v,\n+                None => e.intr.get(ident),\n             };\n-        let cmeta = @{name: /*bad*/copy *cname, data: cdata,\n+        let cmeta = @{name: cname, data: cdata,\n                       cnum_map: cnum_map, cnum: cnum};\n \n         let cstore = e.cstore;\n@@ -303,10 +302,10 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n     for decoder::get_crate_deps(e.intr, cdata).each |dep| {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.name;\n-        let cmetas = metas_with(/*bad*/copy dep.vers, ~\"vers\", ~[]);\n+        let cmetas = metas_with(dep.vers, @~\"vers\", ~[]);\n         debug!(\"resolving dep crate %s ver: %s hash: %s\",\n-               *e.intr.get(dep.name), dep.vers, dep.hash);\n-        match existing_match(e, metas_with_ident(copy *e.intr.get(cname),\n+               *e.intr.get(dep.name), *dep.vers, *dep.hash);\n+        match existing_match(e, metas_with_ident(e.intr.get(cname),\n                                                  copy cmetas),\n                              dep.hash) {\n           Some(local_cnum) => {\n@@ -320,8 +319,8 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n             // FIXME (#2404): Need better error reporting than just a bogus\n             // span.\n             let fake_span = dummy_sp();\n-            let local_cnum = resolve_crate(e, cname, cmetas,\n-                                           /*bad*/copy dep.hash, fake_span);\n+            let local_cnum = resolve_crate(e, cname, cmetas, dep.hash,\n+                                           fake_span);\n             cnum_map.insert(extrn_cnum, local_cnum);\n           }\n         }"}, {"sha": "6231a6394df035429bbc64a2ee5f8adadd196cc7", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c0eca7940f51e267528bba537cdeb8ce9f7e506/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c0eca7940f51e267528bba537cdeb8ce9f7e506/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=3c0eca7940f51e267528bba537cdeb8ce9f7e506", "patch": "@@ -80,7 +80,7 @@ pub fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n     vec::append(~[ast_map::path_mod(tcx.sess.ident_of(\n-        /*bad*/copy cdata.name))], path)\n+        /*bad*/copy *cdata.name))], path)\n }\n \n pub enum found_ast {"}, {"sha": "23d126cae34a54975a2957a203486bc4ba0cd862", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3c0eca7940f51e267528bba537cdeb8ce9f7e506/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c0eca7940f51e267528bba537cdeb8ce9f7e506/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=3c0eca7940f51e267528bba537cdeb8ce9f7e506", "patch": "@@ -33,7 +33,7 @@ use syntax::parse::token::ident_interner;\n // own crate numbers.\n pub type cnum_map = oldmap::HashMap<ast::crate_num, ast::crate_num>;\n \n-pub type crate_metadata = @{name: ~str,\n+pub type crate_metadata = @{name: @~str,\n                             data: @~[u8],\n                             cnum_map: cnum_map,\n                             cnum: ast::crate_num};\n@@ -68,12 +68,12 @@ pub fn get_crate_data(cstore: @mut CStore, cnum: ast::crate_num)\n     return cstore.metas.get(&cnum);\n }\n \n-pub fn get_crate_hash(cstore: @mut CStore, cnum: ast::crate_num) -> ~str {\n+pub fn get_crate_hash(cstore: @mut CStore, cnum: ast::crate_num) -> @~str {\n     let cdata = get_crate_data(cstore, cnum);\n     decoder::get_crate_hash(cdata.data)\n }\n \n-pub fn get_crate_vers(cstore: @mut CStore, cnum: ast::crate_num) -> ~str {\n+pub fn get_crate_vers(cstore: @mut CStore, cnum: ast::crate_num) -> @~str {\n     let cdata = get_crate_data(cstore, cnum);\n     decoder::get_crate_vers(cdata.data)\n }\n@@ -107,11 +107,11 @@ pub fn get_used_crate_files(cstore: @mut CStore) -> ~[Path] {\n     return /*bad*/copy cstore.used_crate_files;\n }\n \n-pub fn add_used_library(cstore: @mut CStore, +lib: ~str) -> bool {\n-    assert lib != ~\"\";\n+pub fn add_used_library(cstore: @mut CStore, lib: @~str) -> bool {\n+    assert *lib != ~\"\";\n \n-    if cstore.used_libraries.contains(&lib) { return false; }\n-    cstore.used_libraries.push(lib);\n+    if cstore.used_libraries.contains(&*lib) { return false; }\n+    cstore.used_libraries.push(/*bad*/ copy *lib);\n     true\n }\n \n@@ -151,18 +151,18 @@ pub fn get_dep_hashes(cstore: @mut CStore) -> ~[~str] {\n     for extern_mod_crate_map.each_value |&cnum| {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n-        debug!(\"Add hash[%s]: %s\", cdata.name, hash);\n+        debug!(\"Add hash[%s]: %s\", *cdata.name, *hash);\n         result.push({name: /*bad*/copy cdata.name, hash: hash});\n     }\n \n     let sorted = std::sort::merge_sort(result, |a, b| a.name <= b.name);\n \n     debug!(\"sorted:\");\n     for sorted.each |x| {\n-        debug!(\"  hash[%s]: %s\", x.name, x.hash);\n+        debug!(\"  hash[%s]: %s\", *x.name, *x.hash);\n     }\n \n-    sorted.map(|ch| /*bad*/copy ch.hash)\n+    sorted.map(|ch| /*bad*/copy *ch.hash)\n }\n \n // Local Variables:"}, {"sha": "980942f609b42cf8daf9478995ce2f4f218e2132", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3c0eca7940f51e267528bba537cdeb8ce9f7e506/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c0eca7940f51e267528bba537cdeb8ce9f7e506/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=3c0eca7940f51e267528bba537cdeb8ce9f7e506", "patch": "@@ -1015,7 +1015,7 @@ fn list_meta_items(intr: @ident_interner,\n     }\n }\n \n-fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: ~str,\n+fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n                          out: io::Writer) {\n     out.write_str(fmt!(\"=Crate Attributes (%s)=\\n\", hash));\n \n@@ -1031,7 +1031,7 @@ pub fn get_crate_attributes(data: @~[u8]) -> ~[ast::attribute] {\n }\n \n pub type crate_dep = {cnum: ast::crate_num, name: ast::ident,\n-                      vers: ~str, hash: ~str};\n+                      vers: @~str, hash: @~str};\n \n pub fn get_crate_deps(intr: @ident_interner, data: @~[u8]) -> ~[crate_dep] {\n     let mut deps: ~[crate_dep] = ~[];\n@@ -1044,8 +1044,8 @@ pub fn get_crate_deps(intr: @ident_interner, data: @~[u8]) -> ~[crate_dep] {\n     for reader::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n         deps.push({cnum: crate_num,\n                   name: intr.intern(@docstr(depdoc, tag_crate_dep_name)),\n-                  vers: docstr(depdoc, tag_crate_dep_vers),\n-                  hash: docstr(depdoc, tag_crate_dep_hash)});\n+                  vers: @docstr(depdoc, tag_crate_dep_vers),\n+                  hash: @docstr(depdoc, tag_crate_dep_hash)});\n         crate_num += 1;\n     };\n     return deps;\n@@ -1057,25 +1057,25 @@ fn list_crate_deps(intr: @ident_interner, data: @~[u8], out: io::Writer) {\n     for get_crate_deps(intr, data).each |dep| {\n         out.write_str(\n             fmt!(\"%d %s-%s-%s\\n\",\n-                 dep.cnum, *intr.get(dep.name), dep.hash, dep.vers));\n+                 dep.cnum, *intr.get(dep.name), *dep.hash, *dep.vers));\n     }\n \n     out.write_str(~\"\\n\");\n }\n \n-pub fn get_crate_hash(data: @~[u8]) -> ~str {\n+pub fn get_crate_hash(data: @~[u8]) -> @~str {\n     let cratedoc = reader::Doc(data);\n     let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n-    str::from_bytes(reader::doc_data(hashdoc))\n+    @str::from_bytes(reader::doc_data(hashdoc))\n }\n \n-pub fn get_crate_vers(data: @~[u8]) -> ~str {\n+pub fn get_crate_vers(data: @~[u8]) -> @~str {\n     let attrs = decoder::get_crate_attributes(data);\n     let linkage_attrs = attr::find_linkage_metas(attrs);\n \n     match attr::last_meta_item_value_str_by_name(linkage_attrs, ~\"vers\") {\n-        Some(ref ver) => /*bad*/copy **ver,\n-        None => ~\"0.0\"\n+        Some(ver) => ver,\n+        None => @~\"0.0\"\n     }\n }\n \n@@ -1097,7 +1097,7 @@ pub fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n                            out: io::Writer) {\n     let hash = get_crate_hash(bytes);\n     let md = reader::Doc(bytes);\n-    list_crate_attributes(intr, md, hash, out);\n+    list_crate_attributes(intr, md, *hash, out);\n     list_crate_deps(intr, bytes, out);\n }\n "}, {"sha": "582da12fe08ad564c0cd4e24c3e3aba5f6575e66", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c0eca7940f51e267528bba537cdeb8ce9f7e506/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c0eca7940f51e267528bba537cdeb8ce9f7e506/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=3c0eca7940f51e267528bba537cdeb8ce9f7e506", "patch": "@@ -1127,7 +1127,7 @@ fn encode_crate_deps(ecx: @encode_ctxt,\n         let mut deps = ~[];\n         do cstore::iter_crate_data(cstore) |key, val| {\n             let dep = {cnum: key,\n-                       name: ecx.tcx.sess.ident_of(/*bad*/ copy val.name),\n+                       name: ecx.tcx.sess.ident_of(/*bad*/ copy *val.name),\n                        vers: decoder::get_crate_vers(val.data),\n                        hash: decoder::get_crate_hash(val.data)};\n             deps.push(dep);\n@@ -1189,10 +1189,10 @@ fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n     ebml_w.writer.write(str::to_bytes(ecx.tcx.sess.str_of(dep.name)));\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_crate_dep_vers);\n-    ebml_w.writer.write(str::to_bytes(dep.vers));\n+    ebml_w.writer.write(str::to_bytes(*dep.vers));\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_crate_dep_hash);\n-    ebml_w.writer.write(str::to_bytes(dep.hash));\n+    ebml_w.writer.write(str::to_bytes(*dep.hash));\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }"}, {"sha": "32aa474d360c8b27b15abb716f63186d0ef4e544", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3c0eca7940f51e267528bba537cdeb8ce9f7e506/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c0eca7940f51e267528bba537cdeb8ce9f7e506/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=3c0eca7940f51e267528bba537cdeb8ce9f7e506", "patch": "@@ -49,7 +49,7 @@ pub type ctxt = {\n     span: span,\n     ident: ast::ident,\n     metas: ~[@ast::meta_item],\n-    hash: ~str,\n+    hash: @~str,\n     os: os,\n     static: bool,\n     intr: @ident_interner\n@@ -91,7 +91,7 @@ fn find_library_crate_aux(cx: ctxt,\n                           filesearch: filesearch::FileSearch) ->\n    Option<{ident: ~str, data: @~[u8]}> {\n     let crate_name = crate_name_from_metas(/*bad*/copy cx.metas);\n-    let prefix: ~str = nn.prefix + crate_name + ~\"-\";\n+    let prefix: ~str = nn.prefix + *crate_name + ~\"-\";\n     let suffix: ~str = /*bad*/copy nn.suffix;\n \n     let mut matches = ~[];\n@@ -130,7 +130,7 @@ fn find_library_crate_aux(cx: ctxt,\n         Some(/*bad*/copy matches[0])\n     } else {\n         cx.diag.span_err(\n-            cx.span, fmt!(\"multiple matching crates for `%s`\", crate_name));\n+            cx.span, fmt!(\"multiple matching crates for `%s`\", *crate_name));\n         cx.diag.handler().note(~\"candidates:\");\n         for matches.each |match_| {\n             cx.diag.handler().note(fmt!(\"path: %s\", match_.ident));\n@@ -142,12 +142,12 @@ fn find_library_crate_aux(cx: ctxt,\n     }\n }\n \n-pub fn crate_name_from_metas(+metas: ~[@ast::meta_item]) -> ~str {\n+pub fn crate_name_from_metas(+metas: &[@ast::meta_item]) -> @~str {\n     let name_items = attr::find_meta_items_by_name(metas, ~\"name\");\n     match vec::last_opt(name_items) {\n         Some(i) => {\n             match attr::get_meta_item_value_str(i) {\n-                Some(ref n) => /*bad*/copy **n,\n+                Some(n) => n,\n                 // FIXME (#2406): Probably want a warning here since the user\n                 // is using the wrong type of meta item.\n                 _ => fail!()\n@@ -167,7 +167,7 @@ pub fn note_linkage_attrs(intr: @ident_interner, diag: span_handler,\n \n fn crate_matches(crate_data: @~[u8],\n                  metas: &[@ast::meta_item],\n-                 hash: ~str) -> bool {\n+                 hash: @~str) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n     let linkage_metas = attr::find_linkage_metas(attrs);\n     if !hash.is_empty() {"}, {"sha": "078f2a92365d11bca35cd33d0ea22048a4c60ed4", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c0eca7940f51e267528bba537cdeb8ce9f7e506/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c0eca7940f51e267528bba537cdeb8ce9f7e506/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3c0eca7940f51e267528bba537cdeb8ce9f7e506", "patch": "@@ -2859,9 +2859,9 @@ pub fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n     let cstore = ccx.sess.cstore;\n     while cstore::have_crate_data(cstore, i) {\n         let cdata = cstore::get_crate_data(cstore, i);\n-        let nm = ~\"_rust_crate_map_\" + cdata.name +\n-            ~\"_\" + cstore::get_crate_vers(cstore, i) +\n-            ~\"_\" + cstore::get_crate_hash(cstore, i);\n+        let nm = ~\"_rust_crate_map_\" + *cdata.name +\n+            ~\"_\" + *cstore::get_crate_vers(cstore, i) +\n+            ~\"_\" + *cstore::get_crate_hash(cstore, i);\n         let cr = str::as_c_str(nm, |buf| {\n             unsafe {\n                 llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)"}, {"sha": "47566f81457b9e59b24a76b3fe73804195e86750", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3c0eca7940f51e267528bba537cdeb8ce9f7e506/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c0eca7940f51e267528bba537cdeb8ce9f7e506/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=3c0eca7940f51e267528bba537cdeb8ce9f7e506", "patch": "@@ -47,10 +47,10 @@ fn abi_info(arch: session::arch) -> cabi::ABIInfo {\n     }\n }\n \n-pub fn link_name(ccx: @crate_ctxt, i: @ast::foreign_item) -> ~str {\n+pub fn link_name(ccx: @crate_ctxt, i: @ast::foreign_item) -> @~str {\n     match attr::first_attr_value_str_by_name(i.attrs, ~\"link_name\") {\n-        None => ccx.sess.str_of(i.ident),\n-        Some(ref ln) => /*bad*/copy **ln,\n+        None => @ccx.sess.str_of(i.ident),\n+        Some(ln) => ln,\n     }\n }\n \n@@ -228,18 +228,18 @@ pub fn trans_foreign_mod(ccx: @crate_ctxt,\n         }\n \n         let lname = link_name(ccx, foreign_item);\n-        let llbasefn = base_fn(ccx, copy lname, tys, cc);\n+        let llbasefn = base_fn(ccx, *lname, tys, cc);\n         // Name the shim function\n         let shim_name = lname + ~\"__c_stack_shim\";\n         return build_shim_fn_(ccx, shim_name, llbasefn, tys, cc,\n                            build_args, build_ret);\n     }\n \n-    fn base_fn(ccx: @crate_ctxt, +lname: ~str, tys: @c_stack_tys,\n+    fn base_fn(ccx: @crate_ctxt, lname: &str, tys: @c_stack_tys,\n                cc: lib::llvm::CallConv) -> ValueRef {\n         // Declare the \"prototype\" for the base function F:\n         do tys.fn_ty.decl_fn |fnty| {\n-            decl_fn(ccx.llmod, /*bad*/copy lname, cc, fnty)\n+            decl_fn(ccx.llmod, lname, cc, fnty)\n         }\n     }\n \n@@ -250,7 +250,7 @@ pub fn trans_foreign_mod(ccx: @crate_ctxt,\n                        cc: lib::llvm::CallConv) {\n         let fcx = new_fn_ctxt(ccx, ~[], decl, None);\n         let bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n-        let llbasefn = base_fn(ccx, link_name(ccx, item), tys, cc);\n+        let llbasefn = base_fn(ccx, *link_name(ccx, item), tys, cc);\n         let ty = ty::lookup_item_type(ccx.tcx,\n                                       ast_util::local_def(item.id)).ty;\n         let args = vec::from_fn(ty::ty_fn_args(ty).len(), |i| {"}]}