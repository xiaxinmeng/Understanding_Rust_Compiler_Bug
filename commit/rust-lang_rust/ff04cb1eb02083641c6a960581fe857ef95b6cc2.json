{"sha": "ff04cb1eb02083641c6a960581fe857ef95b6cc2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMDRjYjFlYjAyMDgzNjQxYzZhOTYwNTgxZmU4NTdlZjk1YjZjYzI=", "commit": {"author": {"name": "Stefan Plantikow", "email": "stefan.plantikow@googlemail.com", "date": "2011-11-20T00:53:12Z"}, "committer": {"name": "Stefan Plantikow", "email": "stefan.plantikow@googlemail.com", "date": "2011-11-20T00:53:12Z"}, "message": "Added a little sudoku solver to test/bench for everone's puzzle solving needs", "tree": {"sha": "47a4f4395c9481acba64f4ab3e89f4c1b3016ee5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47a4f4395c9481acba64f4ab3e89f4c1b3016ee5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff04cb1eb02083641c6a960581fe857ef95b6cc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff04cb1eb02083641c6a960581fe857ef95b6cc2", "html_url": "https://github.com/rust-lang/rust/commit/ff04cb1eb02083641c6a960581fe857ef95b6cc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff04cb1eb02083641c6a960581fe857ef95b6cc2/comments", "author": {"login": "boggle", "id": 50886, "node_id": "MDQ6VXNlcjUwODg2", "avatar_url": "https://avatars.githubusercontent.com/u/50886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/boggle", "html_url": "https://github.com/boggle", "followers_url": "https://api.github.com/users/boggle/followers", "following_url": "https://api.github.com/users/boggle/following{/other_user}", "gists_url": "https://api.github.com/users/boggle/gists{/gist_id}", "starred_url": "https://api.github.com/users/boggle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/boggle/subscriptions", "organizations_url": "https://api.github.com/users/boggle/orgs", "repos_url": "https://api.github.com/users/boggle/repos", "events_url": "https://api.github.com/users/boggle/events{/privacy}", "received_events_url": "https://api.github.com/users/boggle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "boggle", "id": 50886, "node_id": "MDQ6VXNlcjUwODg2", "avatar_url": "https://avatars.githubusercontent.com/u/50886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/boggle", "html_url": "https://github.com/boggle", "followers_url": "https://api.github.com/users/boggle/followers", "following_url": "https://api.github.com/users/boggle/following{/other_user}", "gists_url": "https://api.github.com/users/boggle/gists{/gist_id}", "starred_url": "https://api.github.com/users/boggle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/boggle/subscriptions", "organizations_url": "https://api.github.com/users/boggle/orgs", "repos_url": "https://api.github.com/users/boggle/repos", "events_url": "https://api.github.com/users/boggle/events{/privacy}", "received_events_url": "https://api.github.com/users/boggle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "134f7b761143e57b81a861baaaffe60c2e7694ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/134f7b761143e57b81a861baaaffe60c2e7694ba", "html_url": "https://github.com/rust-lang/rust/commit/134f7b761143e57b81a861baaaffe60c2e7694ba"}], "stats": {"total": 170, "additions": 170, "deletions": 0}, "files": [{"sha": "51338605a820b11656b95847b4f327b58fa1bd8b", "filename": "src/test/bench/sudoku.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/ff04cb1eb02083641c6a960581fe857ef95b6cc2/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff04cb1eb02083641c6a960581fe857ef95b6cc2/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=ff04cb1eb02083641c6a960581fe857ef95b6cc2", "patch": "@@ -0,0 +1,170 @@\n+use std;\n+\n+import std::io;\n+import std::str;\n+import std::uint;\n+import std::u8;\n+import std::vec;\n+import std::bitv;\n+\n+// Computes a single solution to a given 9x9 sudoku\n+//\n+// Call with \"-\" to read input sudoku from stdin\n+//\n+// The expected line-based format is:\n+//\n+// 9,9\n+// <row>,<column>,<color>\n+// ...\n+//\n+// Row and column are 0-based (i.e. <= 8) and color is 1-based (>=1,<=9).\n+// A color of 0 indicates an empty field.\n+//\n+// If called without arguments, sudoku solves a built-in example sudoku\n+//\n+\n+export grid_t, read_grid, solve_grid, write_grid;\n+\n+// internal type of sudoku grids\n+type grid = [[mutable u8]];\n+\n+// exported type of sudoku grids\n+tag grid_t { grid_ctor(grid); }\n+\n+// read a sudoku problem from file f\n+fn read_grid(f: io::reader) -> grid_t {\n+    assert f.read_line() == \"9,9\"; /* assert first line is exactly \"9,9\" */\n+\n+    let g = vec::init_fn({|_i| vec::init_elt_mut(0 as u8, 10u) }, 10u);\n+    while !f.eof() {\n+        // FIXME: replace with unicode compliant call\n+        let comps = str::split(str::trim(f.read_line()), ',' as u8);\n+        if vec::len(comps) >= 3u {\n+            let row     = uint::from_str(comps[0]) as u8;\n+            let col     = uint::from_str(comps[1]) as u8;\n+            g[row][col] = uint::from_str(comps[2]) as u8;\n+        }\n+    }\n+    ret grid_ctor(g);\n+}\n+\n+// solve sudoku grid\n+fn solve_grid(g: grid_t) {\n+    fn next_color(g: grid, row: u8, col: u8, start_color: u8) -> bool {\n+        if start_color < 10u8 {\n+            // colors not yet used\n+            let avail = bitv::create(10u, false);\n+            u8::range(start_color, 10u8) { |color|\n+                bitv::set(avail, color as uint, true);\n+            }\n+\n+            // drop colors already in use in neighbourhood\n+            drop_colors(g, avail, row, col);\n+\n+            // find first remaining color that is available\n+            let i = 1 as uint;\n+            while i < (10 as uint) { /* FIXME llvm ctlhd */\n+                if bitv::get(avail, i) {\n+                    g[row][col] = i as u8;\n+                    ret true;\n+                }\n+                i += 1 as uint; /* else */\n+            }\n+        }\n+        g[row][col] = 0u8;\n+        ret false;\n+    }\n+\n+    // find colors available in neighbourhood of (row, col)\n+    fn drop_colors(g: grid, avail: bitv::t, row: u8, col: u8) {\n+        fn drop_color(g: grid, colors: bitv::t, row: u8, col: u8) {\n+            let color = g[row][col];\n+            if color != 0u8 { bitv::set(colors, color as uint, false); }\n+        }\n+\n+        let it = bind drop_color(g, avail, _, _);\n+\n+        u8::range(0u8, 9u8) { |idx|\n+            it(idx, col); /* check same column fields */\n+            it(row, idx); /* check same row fields */\n+        }\n+\n+        // check same block fields\n+        let row0 = (row / 3u8) * 3u8;\n+        let col0 = (col / 3u8) * 3u8;\n+        u8::range(row0, row0 + 3u8) { |alt_row|\n+            u8::range(col0, col0 + 3u8) { |alt_col| it(alt_row, alt_col); }\n+        }\n+    }\n+\n+    let work: [(u8, u8)] = []; /* queue of uncolored fields */\n+    u8::range(0u8, 9u8) { |row|\n+        u8::range(0u8, 9u8) { |col|\n+            let color = (*g)[row][col];\n+            if color == 0u8 { work += [(row, col)]; }\n+        }\n+    }\n+\n+    let ptr = 0u;\n+    let end = vec::len(work);\n+    while (ptr < end) {\n+        let (row, col) = work[ptr];\n+        // is there another color to try?\n+        if next_color(*g, row, col, (*g)[row][col] + (1 as u8)) {\n+            //  yes: advance work list\n+            ptr = ptr + 1u;\n+        } else {\n+            // no: redo this field aft recoloring pred; unless there is none\n+            if ptr == 0u { fail \"No solution found for this sudoku\"; }\n+            ptr = ptr - 1u;\n+        }\n+    }\n+}\n+\n+fn write_grid(f: io::writer, g: grid_t) {\n+    u8::range(0u8, 9u8) { |row|\n+        f.write_str(#fmt(\"%u\", (*g)[row][0] as uint));\n+        u8::range(1u8, 9u8) { |col|\n+            f.write_str(#fmt(\" %u\", (*g)[row][col] as uint));\n+        }\n+        f.write_char('\\n');\n+     }\n+}\n+\n+fn main(args: [str]) {\n+    let grid = if vec::len(args) == 1u {\n+        // FIXME create sudoku inline since nested vec consts dont work yet\n+        let g = vec::init_fn({|_i| vec::init_elt_mut(0 as u8, 10u) }, 10u);\n+        g[0][1] = 4u8;\n+        g[0][3] = 6u8;\n+        g[0][7] = 3u8;\n+        g[0][8] = 2u8;\n+        g[1][2] = 8u8;\n+        g[1][4] = 2u8;\n+        g[2][0] = 7u8;\n+        g[2][3] = 8u8;\n+        g[3][3] = 5u8;\n+        g[4][1] = 5u8;\n+        g[4][5] = 3u8;\n+        g[4][6] = 6u8;\n+        g[5][0] = 6u8;\n+        g[5][1] = 8u8;\n+        g[5][7] = 9u8;\n+        g[6][1] = 9u8;\n+        g[6][2] = 5u8;\n+        g[6][5] = 6u8;\n+        g[6][7] = 7u8;\n+        g[7][4] = 4u8;\n+        g[7][7] = 6u8;\n+        g[8][0] = 4u8;\n+        g[8][5] = 7u8;\n+        g[8][6] = 2u8;\n+        g[8][8] = 3u8;\n+        grid_ctor(g)\n+    } else {\n+        read_grid(io::stdin())\n+    };\n+    solve_grid(grid);\n+    write_grid(io::stdout(), grid);\n+}\n+"}]}