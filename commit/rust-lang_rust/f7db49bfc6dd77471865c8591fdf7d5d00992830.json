{"sha": "f7db49bfc6dd77471865c8591fdf7d5d00992830", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3ZGI0OWJmYzZkZDc3NDcxODY1Yzg1OTFmZGY3ZDVkMDA5OTI4MzA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-26T18:39:32Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-27T08:32:00Z"}, "message": "Better highlightign API", "tree": {"sha": "68600a30d47e3f4b632d9c42fb8b29297b3f4eef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68600a30d47e3f4b632d9c42fb8b29297b3f4eef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7db49bfc6dd77471865c8591fdf7d5d00992830", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7db49bfc6dd77471865c8591fdf7d5d00992830", "html_url": "https://github.com/rust-lang/rust/commit/f7db49bfc6dd77471865c8591fdf7d5d00992830", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7db49bfc6dd77471865c8591fdf7d5d00992830/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05388b4ea46c886fa4ec8a1d49b71eb816cf7c6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/05388b4ea46c886fa4ec8a1d49b71eb816cf7c6d", "html_url": "https://github.com/rust-lang/rust/commit/05388b4ea46c886fa4ec8a1d49b71eb816cf7c6d"}], "stats": {"total": 512, "additions": 332, "deletions": 180}, "files": [{"sha": "d509de14e553e5bf81e3e640702c091ab4efc2dd", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7db49bfc6dd77471865c8591fdf7d5d00992830/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7db49bfc6dd77471865c8591fdf7d5d00992830/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=f7db49bfc6dd77471865c8591fdf7d5d00992830", "patch": "@@ -74,7 +74,9 @@ pub use crate::{\n     runnables::{Runnable, RunnableKind, TestId},\n     source_change::{FileSystemEdit, SourceChange, SourceFileEdit},\n     ssr::SsrError,\n-    syntax_highlighting::{HighlightTag, HighlightedRange},\n+    syntax_highlighting::{\n+        Highlight, HighlightModifier, HighlightModifiers, HighlightTag, HighlightedRange,\n+    },\n };\n \n pub use hir::Documentation;"}, {"sha": "18980dc202e01e7b83cae33957f2fb6daac622eb", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 60, "deletions": 47, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/f7db49bfc6dd77471865c8591fdf7d5d00992830/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7db49bfc6dd77471865c8591fdf7d5d00992830/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=f7db49bfc6dd77471865c8591fdf7d5d00992830", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-mod highlight_tag;\n+mod highlight;\n \n use hir::{Name, Semantics};\n use ra_db::SourceDatabase;\n@@ -17,12 +17,12 @@ use rustc_hash::FxHashMap;\n \n use crate::{references::classify_name_ref, FileId};\n \n-pub use highlight_tag::HighlightTag;\n+pub use highlight::{Highlight, HighlightModifier, HighlightModifiers, HighlightTag};\n \n #[derive(Debug)]\n pub struct HighlightedRange {\n     pub range: TextRange,\n-    pub tag: HighlightTag,\n+    pub highlight: Highlight,\n     pub binding_hash: Option<u64>,\n }\n \n@@ -79,33 +79,33 @@ pub(crate) fn highlight(\n                         if let Some(range) = highlight_macro(node) {\n                             res.push(HighlightedRange {\n                                 range,\n-                                tag: HighlightTag::MACRO,\n+                                highlight: HighlightTag::Macro.into(),\n                                 binding_hash: None,\n                             });\n                         }\n                     }\n                     _ if in_macro_call.is_some() => {\n                         if let Some(token) = node.as_token() {\n-                            if let Some((tag, binding_hash)) = highlight_token_tree(\n+                            if let Some((highlight, binding_hash)) = highlight_token_tree(\n                                 &sema,\n                                 &mut bindings_shadow_count,\n                                 token.clone(),\n                             ) {\n                                 res.push(HighlightedRange {\n                                     range: node.text_range(),\n-                                    tag,\n+                                    highlight,\n                                     binding_hash,\n                                 });\n                             }\n                         }\n                     }\n                     _ => {\n-                        if let Some((tag, binding_hash)) =\n+                        if let Some((highlight, binding_hash)) =\n                             highlight_node(&sema, &mut bindings_shadow_count, node.clone())\n                         {\n                             res.push(HighlightedRange {\n                                 range: node.text_range(),\n-                                tag,\n+                                highlight,\n                                 binding_hash,\n                             });\n                         }\n@@ -150,7 +150,7 @@ fn highlight_token_tree(\n     sema: &Semantics<RootDatabase>,\n     bindings_shadow_count: &mut FxHashMap<Name, u32>,\n     token: SyntaxToken,\n-) -> Option<(HighlightTag, Option<u64>)> {\n+) -> Option<(Highlight, Option<u64>)> {\n     if token.parent().kind() != TOKEN_TREE {\n         return None;\n     }\n@@ -171,19 +171,21 @@ fn highlight_node(\n     sema: &Semantics<RootDatabase>,\n     bindings_shadow_count: &mut FxHashMap<Name, u32>,\n     node: SyntaxElement,\n-) -> Option<(HighlightTag, Option<u64>)> {\n+) -> Option<(Highlight, Option<u64>)> {\n     let db = sema.db;\n     let mut binding_hash = None;\n-    let tag = match node.kind() {\n+    let highlight: Highlight = match node.kind() {\n         FN_DEF => {\n             bindings_shadow_count.clear();\n             return None;\n         }\n-        COMMENT => HighlightTag::LITERAL_COMMENT,\n-        STRING | RAW_STRING | RAW_BYTE_STRING | BYTE_STRING => HighlightTag::LITERAL_STRING,\n-        ATTR => HighlightTag::LITERAL_ATTRIBUTE,\n+        COMMENT => HighlightTag::Comment.into(),\n+        STRING | RAW_STRING | RAW_BYTE_STRING | BYTE_STRING => HighlightTag::LiteralString.into(),\n+        ATTR => HighlightTag::Attribute.into(),\n         // Special-case field init shorthand\n-        NAME_REF if node.parent().and_then(ast::RecordField::cast).is_some() => HighlightTag::FIELD,\n+        NAME_REF if node.parent().and_then(ast::RecordField::cast).is_some() => {\n+            HighlightTag::Field.into()\n+        }\n         NAME_REF if node.ancestors().any(|it| it.kind() == ATTR) => return None,\n         NAME_REF => {\n             let name_ref = node.as_node().cloned().and_then(ast::NameRef::cast).unwrap();\n@@ -217,26 +219,30 @@ fn highlight_node(\n \n             match name_kind {\n                 Some(name_kind) => highlight_name(db, name_kind),\n-                None => name.syntax().parent().map_or(HighlightTag::FUNCTION, |x| match x.kind() {\n-                    STRUCT_DEF | ENUM_DEF | TRAIT_DEF | TYPE_ALIAS_DEF => HighlightTag::TYPE,\n-                    TYPE_PARAM => HighlightTag::TYPE_PARAM,\n-                    RECORD_FIELD_DEF => HighlightTag::FIELD,\n-                    _ => HighlightTag::FUNCTION,\n+                None => name.syntax().parent().map_or(HighlightTag::Function.into(), |x| {\n+                    match x.kind() {\n+                        STRUCT_DEF | ENUM_DEF | TRAIT_DEF | TYPE_ALIAS_DEF => {\n+                            HighlightTag::Type.into()\n+                        }\n+                        TYPE_PARAM => HighlightTag::TypeParam.into(),\n+                        RECORD_FIELD_DEF => HighlightTag::Field.into(),\n+                        _ => HighlightTag::Function.into(),\n+                    }\n                 }),\n             }\n         }\n-        INT_NUMBER | FLOAT_NUMBER => HighlightTag::LITERAL_NUMERIC,\n-        BYTE => HighlightTag::LITERAL_BYTE,\n-        CHAR => HighlightTag::LITERAL_CHAR,\n-        LIFETIME => HighlightTag::TYPE_LIFETIME,\n-        T![unsafe] => HighlightTag::KEYWORD_UNSAFE,\n-        k if is_control_keyword(k) => HighlightTag::KEYWORD_CONTROL,\n-        k if k.is_keyword() => HighlightTag::KEYWORD,\n+        INT_NUMBER | FLOAT_NUMBER => HighlightTag::LiteralNumeric.into(),\n+        BYTE => HighlightTag::LiteralByte.into(),\n+        CHAR => HighlightTag::LiteralChar.into(),\n+        LIFETIME => HighlightTag::TypeLifetime.into(),\n+        T![unsafe] => HighlightTag::Keyword | HighlightModifier::Unsafe,\n+        k if is_control_keyword(k) => HighlightTag::Keyword | HighlightModifier::Control,\n+        k if k.is_keyword() => HighlightTag::Keyword.into(),\n \n         _ => return None,\n     };\n \n-    return Some((tag, binding_hash));\n+    return Some((highlight, binding_hash));\n \n     fn calc_binding_hash(name: &Name, shadow_count: u32) -> u64 {\n         fn hash<T: std::hash::Hash + std::fmt::Debug>(x: T) -> u64 {\n@@ -293,7 +299,11 @@ pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: boo\n         if ranges.is_empty() {\n             buf.push_str(&text);\n         } else {\n-            let classes = ranges.iter().map(|x| x.tag.to_string()).collect::<Vec<_>>().join(\" \");\n+            let classes = ranges\n+                .iter()\n+                .map(|it| it.highlight.to_string().replace('.', \" \"))\n+                .collect::<Vec<_>>()\n+                .join(\" \");\n             let binding_hash = ranges.first().and_then(|x| x.binding_hash);\n             let color = match (rainbow, binding_hash) {\n                 (true, Some(hash)) => format!(\n@@ -310,29 +320,32 @@ pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: boo\n     buf\n }\n \n-fn highlight_name(db: &RootDatabase, def: NameDefinition) -> HighlightTag {\n+fn highlight_name(db: &RootDatabase, def: NameDefinition) -> Highlight {\n     match def {\n-        NameDefinition::Macro(_) => HighlightTag::MACRO,\n-        NameDefinition::StructField(_) => HighlightTag::FIELD,\n-        NameDefinition::ModuleDef(hir::ModuleDef::Module(_)) => HighlightTag::MODULE,\n-        NameDefinition::ModuleDef(hir::ModuleDef::Function(_)) => HighlightTag::FUNCTION,\n-        NameDefinition::ModuleDef(hir::ModuleDef::Adt(_)) => HighlightTag::TYPE,\n-        NameDefinition::ModuleDef(hir::ModuleDef::EnumVariant(_)) => HighlightTag::CONSTANT,\n-        NameDefinition::ModuleDef(hir::ModuleDef::Const(_)) => HighlightTag::CONSTANT,\n-        NameDefinition::ModuleDef(hir::ModuleDef::Static(_)) => HighlightTag::CONSTANT,\n-        NameDefinition::ModuleDef(hir::ModuleDef::Trait(_)) => HighlightTag::TYPE,\n-        NameDefinition::ModuleDef(hir::ModuleDef::TypeAlias(_)) => HighlightTag::TYPE,\n-        NameDefinition::ModuleDef(hir::ModuleDef::BuiltinType(_)) => HighlightTag::TYPE_BUILTIN,\n-        NameDefinition::SelfType(_) => HighlightTag::TYPE_SELF,\n-        NameDefinition::TypeParam(_) => HighlightTag::TYPE_PARAM,\n+        NameDefinition::Macro(_) => HighlightTag::Macro,\n+        NameDefinition::StructField(_) => HighlightTag::Field,\n+        NameDefinition::ModuleDef(hir::ModuleDef::Module(_)) => HighlightTag::Module,\n+        NameDefinition::ModuleDef(hir::ModuleDef::Function(_)) => HighlightTag::Function,\n+        NameDefinition::ModuleDef(hir::ModuleDef::Adt(_)) => HighlightTag::Type,\n+        NameDefinition::ModuleDef(hir::ModuleDef::EnumVariant(_)) => HighlightTag::Constant,\n+        NameDefinition::ModuleDef(hir::ModuleDef::Const(_)) => HighlightTag::Constant,\n+        NameDefinition::ModuleDef(hir::ModuleDef::Static(_)) => HighlightTag::Constant,\n+        NameDefinition::ModuleDef(hir::ModuleDef::Trait(_)) => HighlightTag::Type,\n+        NameDefinition::ModuleDef(hir::ModuleDef::TypeAlias(_)) => HighlightTag::Type,\n+        NameDefinition::ModuleDef(hir::ModuleDef::BuiltinType(_)) => {\n+            return HighlightTag::Type | HighlightModifier::Builtin\n+        }\n+        NameDefinition::SelfType(_) => HighlightTag::TypeSelf,\n+        NameDefinition::TypeParam(_) => HighlightTag::TypeParam,\n         NameDefinition::Local(local) => {\n+            let mut h = Highlight::new(HighlightTag::Variable);\n             if local.is_mut(db) || local.ty(db).is_mutable_reference() {\n-                HighlightTag::VARIABLE_MUT\n-            } else {\n-                HighlightTag::VARIABLE\n+                h |= HighlightModifier::Mutable;\n             }\n+            return h;\n         }\n     }\n+    .into()\n }\n \n //FIXME: like, real html escaping\n@@ -498,6 +511,6 @@ fn bar() {\n             })\n             .unwrap();\n \n-        assert_eq!(&highlights[0].tag.to_string(), \"field\");\n+        assert_eq!(&highlights[0].highlight.to_string(), \"field\");\n     }\n }"}, {"sha": "383c74c9860458b42b8d869c6442217cbbf28cb6", "filename": "crates/ra_ide/src/syntax_highlighting/highlight.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/f7db49bfc6dd77471865c8591fdf7d5d00992830/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7db49bfc6dd77471865c8591fdf7d5d00992830/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=f7db49bfc6dd77471865c8591fdf7d5d00992830", "patch": "@@ -0,0 +1,163 @@\n+//! Defines token tags we use for syntax highlighting.\n+//! A tag is not unlike a CSS class.\n+\n+use std::{fmt, ops};\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub struct Highlight {\n+    pub tag: HighlightTag,\n+    pub modifiers: HighlightModifiers,\n+}\n+\n+#[derive(Default, Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub struct HighlightModifiers(u32);\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub enum HighlightTag {\n+    Field,\n+    Function,\n+    Module,\n+    Constant,\n+    Macro,\n+    Variable,\n+\n+    Type,\n+    TypeSelf,\n+    TypeParam,\n+    TypeLifetime,\n+\n+    LiteralByte,\n+    LiteralNumeric,\n+    LiteralChar,\n+\n+    Comment,\n+    LiteralString,\n+    Attribute,\n+\n+    Keyword,\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+#[repr(u8)]\n+pub enum HighlightModifier {\n+    Mutable = 0,\n+    Unsafe,\n+    /// Used with keywords like `if` and `break`.\n+    Control,\n+    Builtin,\n+}\n+\n+impl HighlightTag {\n+    fn as_str(self) -> &'static str {\n+        match self {\n+            HighlightTag::Field => \"field\",\n+            HighlightTag::Function => \"function\",\n+            HighlightTag::Module => \"module\",\n+            HighlightTag::Constant => \"constant\",\n+            HighlightTag::Macro => \"macro\",\n+            HighlightTag::Variable => \"variable\",\n+            HighlightTag::Type => \"type\",\n+            HighlightTag::TypeSelf => \"type.self\",\n+            HighlightTag::TypeParam => \"type.param\",\n+            HighlightTag::TypeLifetime => \"type.lifetime\",\n+            HighlightTag::LiteralByte => \"literal.byte\",\n+            HighlightTag::LiteralNumeric => \"literal.numeric\",\n+            HighlightTag::LiteralChar => \"literal.char\",\n+            HighlightTag::Comment => \"comment\",\n+            HighlightTag::LiteralString => \"string\",\n+            HighlightTag::Attribute => \"attribute\",\n+            HighlightTag::Keyword => \"keyword\",\n+        }\n+    }\n+}\n+\n+impl fmt::Display for HighlightTag {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self.as_str(), f)\n+    }\n+}\n+\n+impl HighlightModifier {\n+    const ALL: &'static [HighlightModifier] = &[\n+        HighlightModifier::Mutable,\n+        HighlightModifier::Unsafe,\n+        HighlightModifier::Control,\n+        HighlightModifier::Builtin,\n+    ];\n+\n+    fn as_str(self) -> &'static str {\n+        match self {\n+            HighlightModifier::Mutable => \"mutable\",\n+            HighlightModifier::Unsafe => \"unsafe\",\n+            HighlightModifier::Control => \"control\",\n+            HighlightModifier::Builtin => \"builtin\",\n+        }\n+    }\n+\n+    fn mask(self) -> u32 {\n+        1 << (self as u32)\n+    }\n+}\n+\n+impl fmt::Display for HighlightModifier {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self.as_str(), f)\n+    }\n+}\n+\n+impl fmt::Display for Highlight {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.tag)?;\n+        for modifier in self.modifiers.iter() {\n+            write!(f, \".{}\", modifier)?\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl From<HighlightTag> for Highlight {\n+    fn from(tag: HighlightTag) -> Highlight {\n+        Highlight::new(tag)\n+    }\n+}\n+\n+impl Highlight {\n+    pub(crate) fn new(tag: HighlightTag) -> Highlight {\n+        Highlight { tag, modifiers: HighlightModifiers::default() }\n+    }\n+}\n+\n+impl ops::BitOr<HighlightModifier> for HighlightTag {\n+    type Output = Highlight;\n+\n+    fn bitor(self, rhs: HighlightModifier) -> Highlight {\n+        Highlight::new(self) | rhs\n+    }\n+}\n+\n+impl ops::BitOrAssign<HighlightModifier> for HighlightModifiers {\n+    fn bitor_assign(&mut self, rhs: HighlightModifier) {\n+        self.0 |= rhs.mask();\n+    }\n+}\n+\n+impl ops::BitOrAssign<HighlightModifier> for Highlight {\n+    fn bitor_assign(&mut self, rhs: HighlightModifier) {\n+        self.modifiers |= rhs;\n+    }\n+}\n+\n+impl ops::BitOr<HighlightModifier> for Highlight {\n+    type Output = Highlight;\n+\n+    fn bitor(mut self, rhs: HighlightModifier) -> Highlight {\n+        self |= rhs;\n+        self\n+    }\n+}\n+\n+impl HighlightModifiers {\n+    pub fn iter(self) -> impl Iterator<Item = HighlightModifier> {\n+        HighlightModifier::ALL.iter().copied().filter(move |it| self.0 & it.mask() == it.mask())\n+    }\n+}"}, {"sha": "af1ac07b3d8e1c4056f3d0ffbfd43a297f7f4afa", "filename": "crates/ra_ide/src/syntax_highlighting/highlight_tag.rs", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/05388b4ea46c886fa4ec8a1d49b71eb816cf7c6d/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhighlight_tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05388b4ea46c886fa4ec8a1d49b71eb816cf7c6d/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhighlight_tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhighlight_tag.rs?ref=05388b4ea46c886fa4ec8a1d49b71eb816cf7c6d", "patch": "@@ -1,43 +0,0 @@\n-//! Defines token tags we use for syntax highlighting.\n-//! A tag is not unlike a CSS class.\n-\n-use std::fmt;\n-\n-#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub struct HighlightTag(&'static str);\n-\n-impl fmt::Display for HighlightTag {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self.0, f)\n-    }\n-}\n-\n-#[rustfmt::skip]\n-impl HighlightTag {\n-    pub const FIELD: HighlightTag              = HighlightTag(\"field\");\n-    pub const FUNCTION: HighlightTag           = HighlightTag(\"function\");\n-    pub const MODULE: HighlightTag             = HighlightTag(\"module\");\n-    pub const CONSTANT: HighlightTag           = HighlightTag(\"constant\");\n-    pub const MACRO: HighlightTag              = HighlightTag(\"macro\");\n-\n-    pub const VARIABLE: HighlightTag           = HighlightTag(\"variable\");\n-    pub const VARIABLE_MUT: HighlightTag       = HighlightTag(\"variable.mut\");\n-\n-    pub const TYPE: HighlightTag               = HighlightTag(\"type\");\n-    pub const TYPE_BUILTIN: HighlightTag       = HighlightTag(\"type.builtin\");\n-    pub const TYPE_SELF: HighlightTag          = HighlightTag(\"type.self\");\n-    pub const TYPE_PARAM: HighlightTag         = HighlightTag(\"type.param\");\n-    pub const TYPE_LIFETIME: HighlightTag      = HighlightTag(\"type.lifetime\");\n-\n-    pub const LITERAL_BYTE: HighlightTag       = HighlightTag(\"literal.byte\");\n-    pub const LITERAL_NUMERIC: HighlightTag    = HighlightTag(\"literal.numeric\");\n-    pub const LITERAL_CHAR: HighlightTag       = HighlightTag(\"literal.char\");\n-\n-    pub const LITERAL_COMMENT: HighlightTag    = HighlightTag(\"comment\");\n-    pub const LITERAL_STRING: HighlightTag     = HighlightTag(\"string\");\n-    pub const LITERAL_ATTRIBUTE: HighlightTag  = HighlightTag(\"attribute\");\n-\n-    pub const KEYWORD: HighlightTag            = HighlightTag(\"keyword\");\n-    pub const KEYWORD_UNSAFE: HighlightTag     = HighlightTag(\"keyword.unsafe\");\n-    pub const KEYWORD_CONTROL: HighlightTag    = HighlightTag(\"keyword.control\");\n-}"}, {"sha": "759bceb32a1243e2b957b35e9a90eb79cc2036da", "filename": "crates/rust-analyzer/src/caps.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f7db49bfc6dd77471865c8591fdf7d5d00992830/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7db49bfc6dd77471865c8591fdf7d5d00992830/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs?ref=f7db49bfc6dd77471865c8591fdf7d5d00992830", "patch": "@@ -63,11 +63,8 @@ pub fn server_capabilities() -> ServerCapabilities {\n         semantic_tokens_provider: Some(\n             SemanticTokensOptions {\n                 legend: SemanticTokensLegend {\n-                    token_types: semantic_tokens::supported_token_types().iter().cloned().collect(),\n-                    token_modifiers: semantic_tokens::supported_token_modifiers()\n-                        .iter()\n-                        .cloned()\n-                        .collect(),\n+                    token_types: semantic_tokens::SUPPORTED_TYPES.iter().cloned().collect(),\n+                    token_modifiers: semantic_tokens::SUPPORTED_MODIFIERS.iter().cloned().collect(),\n                 },\n \n                 document_provider: Some(SemanticTokensDocumentProvider::Bool(true)),"}, {"sha": "86851c1f199433f7e56d85fcbc67eb19d159eb45", "filename": "crates/rust-analyzer/src/conv.rs", "status": "modified", "additions": 48, "deletions": 63, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/f7db49bfc6dd77471865c8591fdf7d5d00992830/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7db49bfc6dd77471865c8591fdf7d5d00992830/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconv.rs?ref=f7db49bfc6dd77471865c8591fdf7d5d00992830", "patch": "@@ -10,14 +10,21 @@ use lsp_types::{\n };\n use ra_ide::{\n     translate_offset_with_edit, CompletionItem, CompletionItemKind, FileId, FilePosition,\n-    FileRange, FileSystemEdit, Fold, FoldKind, HighlightTag, InsertTextFormat, LineCol, LineIndex,\n-    NavigationTarget, RangeInfo, ReferenceAccess, Severity, SourceChange, SourceFileEdit,\n+    FileRange, FileSystemEdit, Fold, FoldKind, Highlight, HighlightModifier, HighlightTag,\n+    InsertTextFormat, LineCol, LineIndex, NavigationTarget, RangeInfo, ReferenceAccess, Severity,\n+    SourceChange, SourceFileEdit,\n };\n use ra_syntax::{SyntaxKind, TextRange, TextUnit};\n use ra_text_edit::{AtomTextEdit, TextEdit};\n use ra_vfs::LineEndings;\n \n-use crate::{req, semantic_tokens, world::WorldSnapshot, Result};\n+use crate::{\n+    req,\n+    semantic_tokens::{self, ModifierSet, BUILTIN, CONTROL, MUTABLE, UNSAFE},\n+    world::WorldSnapshot,\n+    Result,\n+};\n+use semantic_tokens::ATTRIBUTE;\n \n pub trait Conv {\n     type Output;\n@@ -303,74 +310,52 @@ impl ConvWith<&FoldConvCtx<'_>> for Fold {\n     }\n }\n \n-impl Conv for HighlightTag {\n-    type Output = (SemanticTokenType, Vec<SemanticTokenModifier>);\n-\n-    fn conv(self) -> (SemanticTokenType, Vec<SemanticTokenModifier>) {\n-        let token_type: SemanticTokenType = match self {\n-            HighlightTag::FIELD => SemanticTokenType::MEMBER,\n-            HighlightTag::FUNCTION => SemanticTokenType::FUNCTION,\n-            HighlightTag::MODULE => SemanticTokenType::NAMESPACE,\n-            HighlightTag::CONSTANT => {\n-                return (\n-                    SemanticTokenType::VARIABLE,\n-                    vec![SemanticTokenModifier::STATIC, SemanticTokenModifier::READONLY],\n-                )\n-            }\n-            HighlightTag::MACRO => SemanticTokenType::MACRO,\n-\n-            HighlightTag::VARIABLE => {\n-                return (SemanticTokenType::VARIABLE, vec![SemanticTokenModifier::READONLY])\n-            }\n-            HighlightTag::VARIABLE_MUT => SemanticTokenType::VARIABLE,\n+impl Conv for Highlight {\n+    type Output = (u32, u32);\n \n-            HighlightTag::TYPE => SemanticTokenType::TYPE,\n-            HighlightTag::TYPE_BUILTIN => SemanticTokenType::TYPE,\n-            HighlightTag::TYPE_SELF => {\n-                return (SemanticTokenType::TYPE, vec![SemanticTokenModifier::REFERENCE])\n+    fn conv(self) -> Self::Output {\n+        let mut mods = ModifierSet::default();\n+        let type_ = match self.tag {\n+            HighlightTag::Field => SemanticTokenType::MEMBER,\n+            HighlightTag::Function => SemanticTokenType::FUNCTION,\n+            HighlightTag::Module => SemanticTokenType::NAMESPACE,\n+            HighlightTag::Constant => {\n+                mods |= SemanticTokenModifier::STATIC;\n+                mods |= SemanticTokenModifier::READONLY;\n+                SemanticTokenType::VARIABLE\n             }\n-            HighlightTag::TYPE_PARAM => SemanticTokenType::TYPE_PARAMETER,\n-            HighlightTag::TYPE_LIFETIME => {\n-                return (SemanticTokenType::LABEL, vec![SemanticTokenModifier::REFERENCE])\n+            HighlightTag::Macro => SemanticTokenType::MACRO,\n+            HighlightTag::Variable => SemanticTokenType::VARIABLE,\n+            HighlightTag::Type => SemanticTokenType::TYPE,\n+            HighlightTag::TypeSelf => {\n+                mods |= SemanticTokenModifier::REFERENCE;\n+                SemanticTokenType::TYPE\n             }\n-\n-            HighlightTag::LITERAL_BYTE => SemanticTokenType::NUMBER,\n-            HighlightTag::LITERAL_NUMERIC => SemanticTokenType::NUMBER,\n-            HighlightTag::LITERAL_CHAR => SemanticTokenType::NUMBER,\n-\n-            HighlightTag::LITERAL_COMMENT => {\n-                return (SemanticTokenType::COMMENT, vec![SemanticTokenModifier::DOCUMENTATION])\n+            HighlightTag::TypeParam => SemanticTokenType::TYPE_PARAMETER,\n+            HighlightTag::TypeLifetime => {\n+                mods |= SemanticTokenModifier::REFERENCE;\n+                SemanticTokenType::LABEL\n             }\n-\n-            HighlightTag::LITERAL_STRING => SemanticTokenType::STRING,\n-            HighlightTag::LITERAL_ATTRIBUTE => SemanticTokenType::KEYWORD,\n-\n-            HighlightTag::KEYWORD => SemanticTokenType::KEYWORD,\n-            HighlightTag::KEYWORD_UNSAFE => SemanticTokenType::KEYWORD,\n-            HighlightTag::KEYWORD_CONTROL => SemanticTokenType::KEYWORD,\n-            unknown => panic!(\"Unknown semantic token: {}\", unknown),\n+            HighlightTag::LiteralByte => SemanticTokenType::NUMBER,\n+            HighlightTag::LiteralNumeric => SemanticTokenType::NUMBER,\n+            HighlightTag::LiteralChar => SemanticTokenType::NUMBER,\n+            HighlightTag::Comment => SemanticTokenType::COMMENT,\n+            HighlightTag::LiteralString => SemanticTokenType::STRING,\n+            HighlightTag::Attribute => ATTRIBUTE,\n+            HighlightTag::Keyword => SemanticTokenType::KEYWORD,\n         };\n \n-        (token_type, vec![])\n-    }\n-}\n-\n-impl Conv for (SemanticTokenType, Vec<SemanticTokenModifier>) {\n-    type Output = (u32, u32);\n-\n-    fn conv(self) -> Self::Output {\n-        let token_index =\n-            semantic_tokens::supported_token_types().iter().position(|it| *it == self.0).unwrap();\n-        let mut token_modifier_bitset = 0;\n-        for modifier in self.1.iter() {\n-            let modifier_index = semantic_tokens::supported_token_modifiers()\n-                .iter()\n-                .position(|it| it == modifier)\n-                .unwrap();\n-            token_modifier_bitset |= 1 << modifier_index;\n+        for modifier in self.modifiers.iter() {\n+            let modifier = match modifier {\n+                HighlightModifier::Mutable => MUTABLE,\n+                HighlightModifier::Unsafe => UNSAFE,\n+                HighlightModifier::Control => CONTROL,\n+                HighlightModifier::Builtin => BUILTIN,\n+            };\n+            mods |= modifier;\n         }\n \n-        (token_index as u32, token_modifier_bitset as u32)\n+        (semantic_tokens::type_index(type_), mods.0)\n     }\n }\n "}, {"sha": "9ed53169c85511d2df7779c4170d81712d4b0670", "filename": "crates/rust-analyzer/src/main_loop/handlers.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f7db49bfc6dd77471865c8591fdf7d5d00992830/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7db49bfc6dd77471865c8591fdf7d5d00992830/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=f7db49bfc6dd77471865c8591fdf7d5d00992830", "patch": "@@ -16,9 +16,9 @@ use lsp_types::{\n     CodeAction, CodeActionOrCommand, CodeActionResponse, CodeLens, Command, CompletionItem,\n     Diagnostic, DocumentFormattingParams, DocumentHighlight, DocumentSymbol, FoldingRange,\n     FoldingRangeParams, Hover, HoverContents, Location, MarkupContent, MarkupKind, Position,\n-    PrepareRenameResponse, Range, RenameParams, SemanticTokenModifier, SemanticTokenType,\n-    SemanticTokens, SemanticTokensParams, SemanticTokensRangeParams, SemanticTokensRangeResult,\n-    SemanticTokensResult, SymbolInformation, TextDocumentIdentifier, TextEdit, WorkspaceEdit,\n+    PrepareRenameResponse, Range, RenameParams, SemanticTokens, SemanticTokensParams,\n+    SemanticTokensRangeParams, SemanticTokensRangeResult, SemanticTokensResult, SymbolInformation,\n+    TextDocumentIdentifier, TextEdit, WorkspaceEdit,\n };\n use ra_ide::{\n     AssistId, FileId, FilePosition, FileRange, Query, RangeInfo, Runnable, RunnableKind,\n@@ -954,7 +954,7 @@ fn highlight(world: &WorldSnapshot, file_id: FileId) -> Result<Vec<Decoration>>\n         .into_iter()\n         .map(|h| Decoration {\n             range: h.range.conv_with(&line_index),\n-            tag: h.tag.to_string(),\n+            tag: h.highlight.to_string(),\n             binding_hash: h.binding_hash.map(|x| x.to_string()),\n         })\n         .collect();\n@@ -1082,10 +1082,9 @@ pub fn handle_semantic_tokens(\n \n     let mut builder = SemanticTokensBuilder::default();\n \n-    for h in world.analysis().highlight(file_id)?.into_iter() {\n-        let type_and_modifiers: (SemanticTokenType, Vec<SemanticTokenModifier>) = h.tag.conv();\n-        let (token_type, token_modifiers) = type_and_modifiers.conv();\n-        builder.push(h.range.conv_with(&line_index), token_type, token_modifiers);\n+    for highlight_range in world.analysis().highlight(file_id)?.into_iter() {\n+        let (token_type, token_modifiers) = highlight_range.highlight.conv();\n+        builder.push(highlight_range.range.conv_with(&line_index), token_type, token_modifiers);\n     }\n \n     let tokens = SemanticTokens { data: builder.build(), ..Default::default() };\n@@ -1104,10 +1103,9 @@ pub fn handle_semantic_tokens_range(\n \n     let mut builder = SemanticTokensBuilder::default();\n \n-    for h in world.analysis().highlight_range(frange)?.into_iter() {\n-        let type_and_modifiers: (SemanticTokenType, Vec<SemanticTokenModifier>) = h.tag.conv();\n-        let (token_type, token_modifiers) = type_and_modifiers.conv();\n-        builder.push(h.range.conv_with(&line_index), token_type, token_modifiers);\n+    for highlight_range in world.analysis().highlight_range(frange)?.into_iter() {\n+        let (token_type, token_modifiers) = highlight_range.highlight.conv();\n+        builder.push(highlight_range.range.conv_with(&line_index), token_type, token_modifiers);\n     }\n \n     let tokens = SemanticTokens { data: builder.build(), ..Default::default() };"}, {"sha": "bf21dc68ecb91c2c149ff013acad1f2b988f0fcc", "filename": "crates/rust-analyzer/src/semantic_tokens.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f7db49bfc6dd77471865c8591fdf7d5d00992830/crates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7db49bfc6dd77471865c8591fdf7d5d00992830/crates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs?ref=f7db49bfc6dd77471865c8591fdf7d5d00992830", "patch": "@@ -1,8 +1,17 @@\n //! Semantic Tokens helpers\n \n+use std::ops;\n+\n use lsp_types::{Range, SemanticToken, SemanticTokenModifier, SemanticTokenType};\n \n-const SUPPORTED_TYPES: &[SemanticTokenType] = &[\n+pub(crate) const ATTRIBUTE: SemanticTokenType = SemanticTokenType::new(\"attribute\");\n+\n+pub(crate) const MUTABLE: SemanticTokenModifier = SemanticTokenModifier::new(\"mutable\");\n+pub(crate) const UNSAFE: SemanticTokenModifier = SemanticTokenModifier::new(\"unsafe\");\n+pub(crate) const CONTROL: SemanticTokenModifier = SemanticTokenModifier::new(\"control\");\n+pub(crate) const BUILTIN: SemanticTokenModifier = SemanticTokenModifier::new(\"builtin\");\n+\n+pub(crate) const SUPPORTED_TYPES: &[SemanticTokenType] = &[\n     SemanticTokenType::COMMENT,\n     SemanticTokenType::KEYWORD,\n     SemanticTokenType::STRING,\n@@ -23,9 +32,10 @@ const SUPPORTED_TYPES: &[SemanticTokenType] = &[\n     SemanticTokenType::VARIABLE,\n     SemanticTokenType::PARAMETER,\n     SemanticTokenType::LABEL,\n+    ATTRIBUTE,\n ];\n \n-const SUPPORTED_MODIFIERS: &[SemanticTokenModifier] = &[\n+pub(crate) const SUPPORTED_MODIFIERS: &[SemanticTokenModifier] = &[\n     SemanticTokenModifier::DOCUMENTATION,\n     SemanticTokenModifier::DECLARATION,\n     SemanticTokenModifier::DEFINITION,\n@@ -36,16 +46,20 @@ const SUPPORTED_MODIFIERS: &[SemanticTokenModifier] = &[\n     SemanticTokenModifier::ASYNC,\n     SemanticTokenModifier::VOLATILE,\n     SemanticTokenModifier::READONLY,\n+    MUTABLE,\n+    UNSAFE,\n+    CONTROL,\n+    BUILTIN,\n ];\n \n-/// Token types that the server supports\n-pub(crate) fn supported_token_types() -> &'static [SemanticTokenType] {\n-    SUPPORTED_TYPES\n-}\n+#[derive(Default)]\n+pub(crate) struct ModifierSet(pub(crate) u32);\n \n-/// Token modifiers that the server supports\n-pub(crate) fn supported_token_modifiers() -> &'static [SemanticTokenModifier] {\n-    SUPPORTED_MODIFIERS\n+impl ops::BitOrAssign<SemanticTokenModifier> for ModifierSet {\n+    fn bitor_assign(&mut self, rhs: SemanticTokenModifier) {\n+        let idx = SUPPORTED_MODIFIERS.iter().position(|it| it == &rhs).unwrap();\n+        self.0 |= 1 << idx;\n+    }\n }\n \n /// Tokens are encoded relative to each other.\n@@ -92,3 +106,7 @@ impl SemanticTokensBuilder {\n         self.data\n     }\n }\n+\n+pub fn type_index(type_: SemanticTokenType) -> u32 {\n+    SUPPORTED_TYPES.iter().position(|it| *it == type_).unwrap() as u32\n+}"}, {"sha": "3fbf3f0bbc10b268d07acc87a406b4771249b9b3", "filename": "editors/code/package.json", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f7db49bfc6dd77471865c8591fdf7d5d00992830/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/f7db49bfc6dd77471865c8591fdf7d5d00992830/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=f7db49bfc6dd77471865c8591fdf7d5d00992830", "patch": "@@ -380,6 +380,25 @@\n                 }\n             }\n         ],\n+        \"semanticTokenTypes\": [\n+            {\n+                \"id\": \"attribute\"\n+            }\n+        ],\n+        \"semanticTokenModifiers\": [\n+            {\n+                \"id\": \"mutable\"\n+            },\n+            {\n+                \"id\": \"unsafe\"\n+            },\n+            {\n+                \"id\": \"control\"\n+            },\n+            {\n+                \"id\": \"builtin\"\n+            }\n+        ],\n         \"semanticTokenStyleDefaults\": [\n             {\n                 \"selector\": \"*.mutable\","}]}