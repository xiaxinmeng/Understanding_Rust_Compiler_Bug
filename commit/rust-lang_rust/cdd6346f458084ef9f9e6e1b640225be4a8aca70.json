{"sha": "cdd6346f458084ef9f9e6e1b640225be4a8aca70", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkZDYzNDZmNDU4MDg0ZWY5ZjllNmUxYjY0MDIyNWJlNGE4YWNhNzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-12T11:06:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-12T11:06:39Z"}, "message": "auto merge of #15601 : jbclements/rust/disable-default-macro-behavior, r=alexcrichton\n\nOur AST definition can include macro invocations, which can expand into all kinds of things. Macro invocations are expanded away during expansion time, and the rest of the compiler doesn't have to deal with them. However, we have no way of enforcing this.\r\n\r\nThis patch adds two protective mechanisms.\r\n\r\nFirst, it adds a (quick) explicit check that ensures there are no macro invocations remaining in the AST after expansion. Second, it updates the visit and fold mechanisms so that by default, they will not traverse macro invocations. It's easy enough to add this, if desired (it's documented in the source, and examples appear, e.g. in the IdentFinder.\r\n\r\nAlong the way, I also consulted with @sfackler to refactor the macro export mechanism so that it stores macro text spans in a side table, rather than leaving them in the AST.", "tree": {"sha": "92473d4a48cf9609db4295a4ea546916c38dfe99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92473d4a48cf9609db4295a4ea546916c38dfe99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdd6346f458084ef9f9e6e1b640225be4a8aca70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdd6346f458084ef9f9e6e1b640225be4a8aca70", "html_url": "https://github.com/rust-lang/rust/commit/cdd6346f458084ef9f9e6e1b640225be4a8aca70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdd6346f458084ef9f9e6e1b640225be4a8aca70/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "767f4a7937c9f8a56cf4d1ac8fd111d481312f34", "url": "https://api.github.com/repos/rust-lang/rust/commits/767f4a7937c9f8a56cf4d1ac8fd111d481312f34", "html_url": "https://github.com/rust-lang/rust/commit/767f4a7937c9f8a56cf4d1ac8fd111d481312f34"}, {"sha": "c253b3675ab03b6c64021e8acee3988cea81f3f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c253b3675ab03b6c64021e8acee3988cea81f3f9", "html_url": "https://github.com/rust-lang/rust/commit/c253b3675ab03b6c64021e8acee3988cea81f3f9"}], "stats": {"total": 191, "additions": 136, "deletions": 55}, "files": [{"sha": "d03bf3593fa41bc19aa4ed3ef767b7de0e31e07c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=cdd6346f458084ef9f9e6e1b640225be4a8aca70", "patch": "@@ -270,6 +270,8 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         }\n     );\n \n+    // JBC: make CFG processing part of expansion to avoid this problem:\n+\n     // strip again, in case expansion added anything with a #[cfg].\n     krate = time(time_passes, \"configuration 2\", krate, |krate|\n                  front::config::strip_unconfigured_items(krate));\n@@ -290,6 +292,9 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         krate.encode(&mut json).unwrap();\n     }\n \n+    time(time_passes, \"checking that all macro invocations are gone\", &krate, |krate|\n+         syntax::ext::expand::check_for_macros(&sess.parse_sess, krate));\n+\n     Some((krate, map))\n }\n \n@@ -302,14 +307,14 @@ pub struct CrateAnalysis {\n     pub name: String,\n }\n \n+\n /// Run the resolution, typechecking, region checking and other\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes(sess: Session,\n                                    krate: &ast::Crate,\n                                    ast_map: syntax::ast_map::Map,\n                                    name: String) -> CrateAnalysis {\n-\n     let time_passes = sess.time_passes();\n \n     time(time_passes, \"external crate/lib resolution\", (), |_|"}, {"sha": "313b2bd6bf0d46e7c1db8e5ee77c81a50d870b36", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=cdd6346f458084ef9f9e6e1b640225be4a8aca70", "patch": "@@ -29,7 +29,8 @@ use syntax::{ast, codemap};\n use std::os;\n use std::cell::{Cell, RefCell};\n \n-\n+// Represents the data associated with a compilation\n+// session for a single crate.\n pub struct Session {\n     pub targ_cfg: config::Config,\n     pub opts: config::Options,"}, {"sha": "0c39cf350a613c02b06e57deacc1f6ede7cfb872", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=cdd6346f458084ef9f9e6e1b640225be4a8aca70", "patch": "@@ -14,6 +14,8 @@ use syntax::codemap;\n \n use std::gc::{Gc, GC};\n \n+/// A folder that strips out items that do not belong in the current\n+/// configuration.\n struct Context<'a> {\n     in_cfg: |attrs: &[ast::Attribute]|: 'a -> bool,\n }\n@@ -41,6 +43,9 @@ impl<'a> fold::Folder for Context<'a> {\n     fn fold_expr(&mut self, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         fold_expr(self, expr)\n     }\n+    fn fold_mac(&mut self, mac: &ast::Mac) -> ast::Mac {\n+        fold::fold_mac(mac, self)\n+    }\n }\n \n pub fn strip_items(krate: ast::Crate,"}, {"sha": "493fd575a8408e06fff2c6d8d3400c8361aa099b", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 16, "deletions": 28, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=cdd6346f458084ef9f9e6e1b640225be4a8aca70", "patch": "@@ -1588,37 +1588,25 @@ fn encode_plugin_registrar_fn(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n     }\n }\n \n-struct MacroDefVisitor<'a, 'b, 'c> {\n-    ecx: &'a EncodeContext<'b>,\n-    ebml_w: &'a mut Encoder<'c>\n-}\n-\n-impl<'a, 'b, 'c> Visitor<()> for MacroDefVisitor<'a, 'b, 'c> {\n-    fn visit_item(&mut self, item: &Item, _: ()) {\n-        match item.node {\n-            ItemMac(..) => {\n-                let def = self.ecx.tcx.sess.codemap().span_to_snippet(item.span)\n-                    .expect(\"Unable to find source for macro\");\n-                self.ebml_w.start_tag(tag_macro_def);\n-                self.ebml_w.wr_str(def.as_slice());\n-                self.ebml_w.end_tag();\n-            }\n-            _ => {}\n-        }\n-        visit::walk_item(self, item, ());\n-    }\n+/// Given a span, write the text of that span into the output stream\n+/// as an exported macro\n+fn encode_macro_def(ecx: &EncodeContext,\n+                    ebml_w: &mut Encoder,\n+                    span: &syntax::codemap::Span) {\n+    let def = ecx.tcx.sess.codemap().span_to_snippet(*span)\n+        .expect(\"Unable to find source for macro\");\n+    ebml_w.start_tag(tag_macro_def);\n+    ebml_w.wr_str(def.as_slice());\n+    ebml_w.end_tag();\n }\n \n-fn encode_macro_defs<'a>(ecx: &'a EncodeContext,\n-                         krate: &Crate,\n-                         ebml_w: &'a mut Encoder) {\n+/// Serialize the text of the exported macros\n+fn encode_macro_defs(ecx: &EncodeContext,\n+                     krate: &Crate,\n+                     ebml_w: &mut Encoder) {\n     ebml_w.start_tag(tag_exported_macros);\n-    {\n-        let mut visitor = MacroDefVisitor {\n-            ecx: ecx,\n-            ebml_w: ebml_w,\n-        };\n-        visit::walk_crate(&mut visitor, krate, ());\n+    for span in krate.exported_macros.iter() {\n+        encode_macro_def(ecx, ebml_w, span);\n     }\n     ebml_w.end_tag();\n }"}, {"sha": "499cffa42aac9f124913adb549a0c81175765ffc", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=cdd6346f458084ef9f9e6e1b640225be4a8aca70", "patch": "@@ -72,6 +72,7 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate) -> Plugins {\n     loader.plugins\n }\n \n+// note that macros aren't expanded yet, and therefore macros can't add plugins.\n impl<'a> Visitor<()> for PluginLoader<'a> {\n     fn visit_view_item(&mut self, vi: &ast::ViewItem, _: ()) {\n         match vi.node {\n@@ -109,6 +110,10 @@ impl<'a> Visitor<()> for PluginLoader<'a> {\n             _ => (),\n         }\n     }\n+    fn visit_mac(&mut self, _: &ast::Mac, _:()) {\n+        // bummer... can't see plugins inside macros.\n+        // do nothing.\n+    }\n }\n \n impl<'a> PluginLoader<'a> {"}, {"sha": "dd8304014433a5acdaf5a50c1e31f27869cbfb2c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=cdd6346f458084ef9f9e6e1b640225be4a8aca70", "patch": "@@ -249,6 +249,7 @@ pub struct Crate {\n     pub attrs: Vec<Attribute>,\n     pub config: CrateConfig,\n     pub span: Span,\n+    pub exported_macros: Vec<Span>\n }\n \n pub type MetaItem = Spanned<MetaItem_>;\n@@ -1245,6 +1246,7 @@ mod test {\n                 hi: BytePos(20),\n                 expn_info: None,\n             },\n+            exported_macros: Vec::new(),\n         };\n         // doesn't matter which encoder we use....\n         let _f = &e as &serialize::Encodable<json::Encoder, io::IoError>;"}, {"sha": "de2ecd9a2640488fcf3db7c4d6aa67423498448b", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=cdd6346f458084ef9f9e6e1b640225be4a8aca70", "patch": "@@ -112,6 +112,7 @@ pub enum Node {\n     NodeLifetime(Gc<Lifetime>),\n }\n \n+/// Represents an entry and its parent Node ID\n /// The odd layout is to bring down the total size.\n #[deriving(Clone)]\n enum MapEntry {\n@@ -184,6 +185,8 @@ impl MapEntry {\n     }\n }\n \n+/// Represents a mapping from Node IDs to AST elements and their parent\n+/// Node IDs\n pub struct Map {\n     /// NodeIds are sequential integers from 0, so we can be\n     /// super-compact by storing them in a vector. Not everything with\n@@ -430,6 +433,8 @@ pub trait FoldOps {\n     }\n }\n \n+/// A Folder that walks over an AST and constructs a Node ID Map. Its\n+/// fold_ops argument has the opportunity to replace Node IDs and spans.\n pub struct Ctx<'a, F> {\n     map: &'a Map,\n     /// The node in which we are currently mapping (an item or a method).\n@@ -584,6 +589,10 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n         self.insert(lifetime.id, EntryLifetime(self.parent, box(GC) lifetime));\n         lifetime\n     }\n+\n+    fn fold_mac(&mut self, mac: &Mac) -> Mac {\n+        fold::fold_mac(mac, self)\n+    }\n }\n \n pub fn map_crate<F: FoldOps>(krate: Crate, fold_ops: F) -> (Crate, Map) {"}, {"sha": "dcb69ae8f7e64df0c08bf8f5fa49293c6aa6240e", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=cdd6346f458084ef9f9e6e1b640225be4a8aca70", "patch": "@@ -48,7 +48,8 @@ pub struct BasicMacroExpander {\n     pub span: Option<Span>\n }\n \n-pub trait MacroExpander {\n+/// Represents a thing that maps token trees to Macro Results\n+pub trait TTMacroExpander {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               span: Span,\n@@ -60,7 +61,7 @@ pub type MacroExpanderFn =\n     fn(ecx: &mut ExtCtxt, span: codemap::Span, token_tree: &[ast::TokenTree])\n        -> Box<MacResult>;\n \n-impl MacroExpander for BasicMacroExpander {\n+impl TTMacroExpander for BasicMacroExpander {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               span: Span,\n@@ -259,7 +260,7 @@ pub enum SyntaxExtension {\n     /// A normal, function-like syntax extension.\n     ///\n     /// `bytes!` is a `NormalTT`.\n-    NormalTT(Box<MacroExpander + 'static>, Option<Span>),\n+    NormalTT(Box<TTMacroExpander + 'static>, Option<Span>),\n \n     /// A function-like syntax extension that has an extra ident before\n     /// the block.\n@@ -409,6 +410,7 @@ pub struct ExtCtxt<'a> {\n \n     pub mod_path: Vec<ast::Ident> ,\n     pub trace_mac: bool,\n+    pub exported_macros: Vec<codemap::Span>\n }\n \n impl<'a> ExtCtxt<'a> {\n@@ -420,7 +422,8 @@ impl<'a> ExtCtxt<'a> {\n             backtrace: None,\n             mod_path: Vec::new(),\n             ecfg: ecfg,\n-            trace_mac: false\n+            trace_mac: false,\n+            exported_macros: Vec::new(),\n         }\n     }\n \n@@ -538,6 +541,9 @@ impl<'a> ExtCtxt<'a> {\n     pub fn name_of(&self, st: &str) -> ast::Name {\n         token::intern(st)\n     }\n+    pub fn push_exported_macro(&mut self, span: codemap::Span) {\n+        self.exported_macros.push(span);\n+    }\n }\n \n /// Extract a string literal from the macro expanded version of `expr`,"}, {"sha": "6e44bfa6747eb405eef00f66feee6cda5769a073", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=cdd6346f458084ef9f9e6e1b640225be4a8aca70", "patch": "@@ -518,10 +518,9 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n             // create issue to recommend refactoring here?\n             fld.extsbox.insert(intern(name.as_slice()), ext);\n             if attr::contains_name(it.attrs.as_slice(), \"macro_export\") {\n-                SmallVector::one(it)\n-            } else {\n-                SmallVector::zero()\n+                fld.cx.push_exported_macro(it.span);\n             }\n+            SmallVector::zero()\n         }\n         None => {\n             match expanded.make_items() {\n@@ -754,7 +753,6 @@ impl Visitor<()> for PatIdentFinder {\n             _ => visit::walk_pat(self, pattern, ())\n         }\n     }\n-\n }\n \n /// find the PatIdent paths in a pattern\n@@ -903,6 +901,9 @@ impl<'a> Folder for IdentRenamer<'a> {\n             ctxt: mtwt::apply_renames(self.renames, id.ctxt),\n         }\n     }\n+    fn fold_mac(&mut self, macro: &ast::Mac) -> ast::Mac {\n+        fold::fold_mac(macro, self)\n+    }\n }\n \n /// A tree-folder that applies every rename in its list to\n@@ -932,6 +933,9 @@ impl<'a> Folder for PatIdentRenamer<'a> {\n             _ => noop_fold_pat(pat, self)\n         }\n     }\n+    fn fold_mac(&mut self, macro: &ast::Mac) -> ast::Mac {\n+        fold::fold_mac(macro, self)\n+    }\n }\n \n // expand a method\n@@ -1039,6 +1043,7 @@ pub struct ExportedMacros {\n \n pub fn expand_crate(parse_sess: &parse::ParseSess,\n                     cfg: ExpansionConfig,\n+                    // these are the macros being imported to this crate:\n                     macros: Vec<ExportedMacros>,\n                     user_exts: Vec<NamedSyntaxExtension>,\n                     c: Crate) -> Crate {\n@@ -1066,7 +1071,8 @@ pub fn expand_crate(parse_sess: &parse::ParseSess,\n         expander.extsbox.insert(name, extension);\n     }\n \n-    let ret = expander.fold_crate(c);\n+    let mut ret = expander.fold_crate(c);\n+    ret.exported_macros = expander.cx.exported_macros.clone();\n     parse_sess.span_diagnostic.handler().abort_if_errors();\n     return ret;\n }\n@@ -1145,6 +1151,25 @@ fn original_span(cx: &ExtCtxt) -> Gc<codemap::ExpnInfo> {\n     return einfo;\n }\n \n+/// Check that there are no macro invocations left in the AST:\n+pub fn check_for_macros(sess: &parse::ParseSess, krate: &ast::Crate) {\n+    visit::walk_crate(&mut MacroExterminator{sess:sess}, krate, ());\n+}\n+\n+/// A visitor that ensures that no macro invocations remain in an AST.\n+struct MacroExterminator<'a>{\n+    sess: &'a parse::ParseSess\n+}\n+\n+impl<'a> visit::Visitor<()> for MacroExterminator<'a> {\n+    fn visit_mac(&mut self, macro: &ast::Mac, _:()) {\n+        self.sess.span_diagnostic.span_bug(macro.span,\n+                                           \"macro exterminator: expected AST \\\n+                                           with no macro invocations\");\n+    }\n+}\n+\n+\n #[cfg(test)]\n mod test {\n     use super::{pattern_bindings, expand_crate, contains_macro_escape};"}, {"sha": "923b3e78731a09c635a65d448def5cd93c578ed3", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=cdd6346f458084ef9f9e6e1b640225be4a8aca70", "patch": "@@ -13,7 +13,7 @@ use ast::{TTDelim};\n use ast;\n use codemap::{Span, Spanned, DUMMY_SP};\n use ext::base::{ExtCtxt, MacResult, MacroDef};\n-use ext::base::{NormalTT, MacroExpander};\n+use ext::base::{NormalTT, TTMacroExpander};\n use ext::base;\n use ext::tt::macro_parser::{Success, Error, Failure};\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n@@ -95,7 +95,7 @@ struct MacroRulesMacroExpander {\n     rhses: Vec<Rc<NamedMatch>>,\n }\n \n-impl MacroExpander for MacroRulesMacroExpander {\n+impl TTMacroExpander for MacroRulesMacroExpander {\n     fn expand(&self,\n               cx: &mut ExtCtxt,\n               sp: Span,"}, {"sha": "3e3b57be6e40650ff77c14ed99fc93d30aa37317", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=cdd6346f458084ef9f9e6e1b640225be4a8aca70", "patch": "@@ -8,6 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! A Folder represents an AST->AST fold; it accepts an AST piece,\n+//! and returns a piece of the same type. So, for instance, macro\n+//! expansion is a Folder that walks over an AST and produces another\n+//! AST.\n+//!\n+//! Note: using a Folder (other than the MacroExpander Folder) on\n+//! an AST before macro expansion is probably a bad idea. For instance,\n+//! a folder renaming item names in a module will miss all of those\n+//! that are created by the expansion of a macro.\n+\n use ast::*;\n use ast;\n use ast_util;\n@@ -299,17 +309,13 @@ pub trait Folder {\n         }\n     }\n \n-    fn fold_mac(&mut self, macro: &Mac) -> Mac {\n-        Spanned {\n-            node: match macro.node {\n-                MacInvocTT(ref p, ref tts, ctxt) => {\n-                    MacInvocTT(self.fold_path(p),\n-                               fold_tts(tts.as_slice(), self),\n-                               ctxt)\n-                }\n-            },\n-            span: self.new_span(macro.span)\n-        }\n+    fn fold_mac(&mut self, _macro: &Mac) -> Mac {\n+        fail!(\"fold_mac disabled by default\");\n+        // NB: see note about macros above.\n+        // if you really want a folder that\n+        // works on macros, use this\n+        // definition in your trait impl:\n+        // fold::fold_mac(_macro, self)\n     }\n \n     fn map_exprs(&self, f: |Gc<Expr>| -> Gc<Expr>,\n@@ -361,6 +367,20 @@ pub trait Folder {\n \n }\n \n+\n+pub fn fold_mac<T: Folder>(macro: &Mac, fld: &mut T) -> Mac {\n+    Spanned {\n+        node: match macro.node {\n+            MacInvocTT(ref p, ref tts, ctxt) => {\n+                MacInvocTT(fld.fold_path(p),\n+                           fold_tts(tts.as_slice(), fld),\n+                           ctxt)\n+            }\n+        },\n+        span: fld.new_span(macro.span)\n+    }\n+}\n+\n /* some little folds that probably aren't useful to have in Folder itself*/\n \n //used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n@@ -713,6 +733,7 @@ pub fn noop_fold_crate<T: Folder>(c: Crate, folder: &mut T) -> Crate {\n         attrs: c.attrs.iter().map(|x| folder.fold_attribute(*x)).collect(),\n         config: c.config.iter().map(|x| fold_meta_item_(*x, folder)).collect(),\n         span: folder.new_span(c.span),\n+        exported_macros: c.exported_macros.iter().map(|sp| folder.new_span(*sp)).collect(),\n     }\n }\n \n@@ -985,6 +1006,7 @@ mod test {\n     use util::parser_testing::{string_to_crate, matches_codepattern};\n     use parse::token;\n     use print::pprust;\n+    use fold;\n     use super::*;\n \n     // this version doesn't care about getting comments or docstrings in.\n@@ -1000,6 +1022,9 @@ mod test {\n         fn fold_ident(&mut self, _: ast::Ident) -> ast::Ident {\n             token::str_to_ident(\"zz\")\n         }\n+        fn fold_mac(&mut self, macro: &ast::Mac) -> ast::Mac {\n+            fold::fold_mac(macro, self)\n+        }\n     }\n \n     // maybe add to expand.rs..."}, {"sha": "84db2bc5a2217cf6ba00c09ce2529ab355070d3b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=cdd6346f458084ef9f9e6e1b640225be4a8aca70", "patch": "@@ -5386,7 +5386,8 @@ impl<'a> Parser<'a> {\n             module: m,\n             attrs: inner,\n             config: self.cfg.clone(),\n-            span: mk_sp(lo, self.span.lo)\n+            span: mk_sp(lo, self.span.lo),\n+            exported_macros: Vec::new(),\n         }\n     }\n "}, {"sha": "7caaf2f6cc1faccee1c1b98ab774e3b08ef17e1f", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdd6346f458084ef9f9e6e1b640225be4a8aca70/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=cdd6346f458084ef9f9e6e1b640225be4a8aca70", "patch": "@@ -20,6 +20,10 @@\n //! execute before AST node B, then A is visited first.  The borrow checker in\n //! particular relies on this property.\n //!\n+//! Note: walking an AST before macro expansion is probably a bad idea. For\n+//! instance, a walker looking for item names in a module will miss all of\n+//! those that are created by the expansion of a macro.\n+\n use abi::Abi;\n use ast::*;\n use ast;\n@@ -124,8 +128,13 @@ pub trait Visitor<E: Clone> {\n     fn visit_explicit_self(&mut self, es: &ExplicitSelf, e: E) {\n         walk_explicit_self(self, es, e)\n     }\n-    fn visit_mac(&mut self, macro: &Mac, e: E) {\n-        walk_mac(self, macro, e)\n+    fn visit_mac(&mut self, _macro: &Mac, _e: E) {\n+        fail!(\"visit_mac disabled by default\");\n+        // NB: see note about macros above.\n+        // if you really want a visitor that\n+        // works on macros, use this\n+        // definition in your trait impl:\n+        // visit::walk_mac(self, _macro, _e)\n     }\n     fn visit_path(&mut self, path: &Path, _id: ast::NodeId, e: E) {\n         walk_path(self, path, e)"}]}