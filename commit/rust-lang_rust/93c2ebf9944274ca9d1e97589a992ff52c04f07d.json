{"sha": "93c2ebf9944274ca9d1e97589a992ff52c04f07d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzYzJlYmY5OTQ0Mjc0Y2E5ZDFlOTc1ODlhOTkyZmY1MmMwNGYwN2Q=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-12-27T19:36:00Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-01-09T16:55:36Z"}, "message": "syntax: convert ast::spanned into a struct", "tree": {"sha": "8ceaf6ee4de8aa8f65c70e5fa3deb5a7964b1018", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ceaf6ee4de8aa8f65c70e5fa3deb5a7964b1018"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93c2ebf9944274ca9d1e97589a992ff52c04f07d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93c2ebf9944274ca9d1e97589a992ff52c04f07d", "html_url": "https://github.com/rust-lang/rust/commit/93c2ebf9944274ca9d1e97589a992ff52c04f07d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93c2ebf9944274ca9d1e97589a992ff52c04f07d/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b75550af5ce401a27ab777b8bb6a7d4dfd5c4f17", "url": "https://api.github.com/repos/rust-lang/rust/commits/b75550af5ce401a27ab777b8bb6a7d4dfd5c4f17", "html_url": "https://github.com/rust-lang/rust/commit/b75550af5ce401a27ab777b8bb6a7d4dfd5c4f17"}], "stats": {"total": 455, "additions": 245, "deletions": 210}, "files": [{"sha": "f588f3643cee1ea4c1c60ecd5c4c137e8ada6c5a", "filename": "src/libcargo/cargo.rc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rc?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -294,7 +294,8 @@ fn load_link(mis: ~[@ast::meta_item]) -> (Option<~str>,\n     let mut uuid = None;\n     for mis.each |a| {\n         match a.node {\n-            ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) => {\n+            ast::meta_name_value(v, ast::spanned { node: ast::lit_str(s),\n+                                                   _ }) => {\n                 match v {\n                     ~\"name\" => name = Some(*s),\n                     ~\"vers\" => vers = Some(*s),\n@@ -321,7 +322,8 @@ fn load_crate(filename: &Path) -> Option<Crate> {\n \n     for c.node.attrs.each |a| {\n         match a.node.value.node {\n-            ast::meta_name_value(v, {node: ast::lit_str(_), span: _}) => {\n+            ast::meta_name_value(v, ast::spanned { node: ast::lit_str(_),\n+                                                   _ }) => {\n                 match v {\n                     ~\"desc\" => desc = Some(v),\n                     ~\"sigs\" => sigs = Some(v),"}, {"sha": "de8ce8fc3708de176f2def2c4dceb4dba2aefe6f", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -81,7 +81,7 @@ fn common_exprs() -> ~[ast::expr] {\n     }\n \n     fn dsl(l: ast::lit_) -> ast::lit {\n-        { node: l, span: ast_util::dummy_sp() }\n+        ast::spanned { node: l, span: ast_util::dummy_sp() }\n     }\n \n     ~[dse(ast::expr_break(option::None)),"}, {"sha": "772bd39e07b03c4f06fe57a1f69fdad66b0f2906", "filename": "src/librustc/front/core_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fcore_inject.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -39,7 +39,7 @@ fn use_core(crate: @ast::crate) -> bool {\n fn inject_libcore_ref(sess: Session,\n                       crate: @ast::crate) -> @ast::crate {\n     fn spanned<T: Copy>(x: T) -> ast::spanned<T> {\n-        return {node: x, span: dummy_sp()};\n+        ast::spanned { node: x, span: dummy_sp() }\n     }\n \n     let precursor = @{"}, {"sha": "14d31e2f841ca77e02c4165ceefa2d9df269f669", "filename": "src/librustc/front/intrinsic_inject.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -36,6 +36,9 @@ fn inject_intrinsic(sess: Session, crate: @ast::crate) -> @ast::crate {\n \n     let items = vec::append(~[item], crate.node.module.items);\n \n-    return @{node: {module: { items: items ,.. /*bad*/copy crate.node.module }\n-                 ,.. /*bad*/copy crate.node} ,.. /*bad*/copy *crate }\n+    @ast::spanned {\n+        node: { module: { items: items ,.. /*bad*/copy crate.node.module },\n+                .. /*bad*/copy crate.node},\n+        .. /*bad*/copy *crate\n+    }\n }"}, {"sha": "497a6878bc1e9226d35a1bd435134bdbe84214ed", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -242,7 +242,7 @@ fn mk_test_module(cx: test_ctxt) -> @ast::item {\n }\n \n fn nospan<T: Copy>(t: T) -> ast::spanned<T> {\n-    return {node: t, span: dummy_sp()};\n+    ast::spanned { node: t, span: dummy_sp() }\n }\n \n fn path_node(+ids: ~[ast::ident]) -> @ast::path {\n@@ -489,7 +489,7 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n     let body_: ast::blk_ =\n         default_block(~[], option::Some(test_main_call_expr),\n                       cx.sess.next_node_id());\n-    let body = {node: body_, span: dummy_sp()};\n+    let body = ast::spanned { node: body_, span: dummy_sp() };\n \n     let item_ = ast::item_fn(decl, ast::impure_fn, ~[], body);\n     let item: ast::item ="}, {"sha": "081a92f686b9a7a80df36bb6c4df067f6700af3f", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -1031,9 +1031,10 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n             assert (vec::len(meta_items) == 1u);\n             let meta_item = meta_items[0];\n             attrs.push(\n-                {node: {style: ast::attr_outer, value: /*bad*/copy *meta_item,\n-                        is_sugared_doc: false},\n-                 span: ast_util::dummy_sp()});\n+                ast::spanned { node: { style: ast::attr_outer,\n+                                       value: /*bad*/copy *meta_item,\n+                                       is_sugared_doc: false },\n+                               span: ast_util::dummy_sp()});\n         };\n       }\n       option::None => ()"}, {"sha": "45e4b9f328fc380ba1a65947c39446c01665342a", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -259,8 +259,10 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n         let stmts_sans_items = do vec::filter(blk.stmts) |stmt| {\n             match stmt.node {\n               ast::stmt_expr(_, _) | ast::stmt_semi(_, _) |\n-              ast::stmt_decl(@{node: ast::decl_local(_), span: _}, _) => true,\n-              ast::stmt_decl(@{node: ast::decl_item(_), span: _}, _) => false,\n+              ast::stmt_decl(@ast::spanned { node: ast::decl_local(_),\n+                                             span: _}, _) => true,\n+              ast::stmt_decl(@ast::spanned { node: ast::decl_item(_),\n+                                             span: _}, _) => false,\n               ast::stmt_mac(*) => fail ~\"unexpanded macro in astencode\"\n             }\n         };\n@@ -286,9 +288,10 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n       }\n       ast::ii_dtor(ref dtor, nm, ref tps, parent_id) => {\n         let dtor_body = fld.fold_block((*dtor).node.body);\n-        ast::ii_dtor({node: {body: dtor_body,\n-                              .. /*bad*/copy (*dtor).node},\n-            .. (/*bad*/copy *dtor)}, nm, /*bad*/copy *tps, parent_id)\n+        ast::ii_dtor(ast::spanned { node: { body: dtor_body,\n+                                            .. /*bad*/copy (*dtor).node },\n+                                    .. (/*bad*/copy *dtor) },\n+                     nm, /*bad*/copy *tps, parent_id)\n       }\n     }\n }\n@@ -324,9 +327,11 @@ fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n         let dtor_id = fld.new_id((*dtor).node.id);\n         let new_parent = xcx.tr_def_id(parent_id);\n         let new_self = fld.new_id((*dtor).node.self_id);\n-        ast::ii_dtor({node: {id: dtor_id, attrs: dtor_attrs,\n-                self_id: new_self, body: dtor_body},\n-                        .. (/*bad*/copy *dtor)},\n+        ast::ii_dtor(ast::spanned { node: { id: dtor_id,\n+                                            attrs: dtor_attrs,\n+                                            self_id: new_self,\n+                                            body: dtor_body },\n+                                    .. (/*bad*/copy *dtor)},\n           nm, new_params, new_parent)\n       }\n      }"}, {"sha": "0166c8da4100058028d04e324e6830977c551adc", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -57,7 +57,8 @@ fn check_item(sess: Session, ast_map: ast_map::map,\n fn check_pat(p: @pat, &&_is_const: bool, v: visit::vt<bool>) {\n     fn is_str(e: @expr) -> bool {\n         match e.node {\n-          expr_vstore(@{node: expr_lit(@{node: lit_str(_), _}), _},\n+          expr_vstore(@{node: expr_lit(@spanned { node: lit_str(_),\n+                                                  _}), _},\n                       expr_vstore_uniq) => true,\n           _ => false\n         }\n@@ -84,7 +85,7 @@ fn check_expr(sess: Session, def_map: resolve::DefMap,\n                           ~\"disallowed operator in constant expression\");\n             return;\n           }\n-          expr_lit(@{node: lit_str(_), _}) => { }\n+          expr_lit(@spanned {node: lit_str(_), _}) => { }\n           expr_binary(_, _, _) | expr_unary(_, _) => {\n             if method_map.contains_key(e.id) {\n                 sess.span_err(e.span, ~\"user-defined operators are not \\\n@@ -170,15 +171,15 @@ fn check_expr(sess: Session, def_map: resolve::DefMap,\n         }\n     }\n     match e.node {\n-      expr_lit(@{node: lit_int(v, t), _}) => {\n+      expr_lit(@spanned {node: lit_int(v, t), _}) => {\n         if t != ty_char {\n             if (v as u64) > ast_util::int_ty_max(\n                 if t == ty_i { sess.targ_cfg.int_type } else { t }) {\n                 sess.span_err(e.span, ~\"literal out of range for its type\");\n             }\n         }\n       }\n-      expr_lit(@{node: lit_uint(v, t), _}) => {\n+      expr_lit(@spanned {node: lit_uint(v, t), _}) => {\n         if v > ast_util::uint_ty_max(\n             if t == ty_u { sess.targ_cfg.uint_type } else { t }) {\n             sess.span_err(e.span, ~\"literal out of range for its type\");"}, {"sha": "441e800f36f1783f3d6ede33eb273b8209463c83", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -692,7 +692,10 @@ fn is_refutable(cx: @MatchCheckCtxt, pat: &pat) -> bool {\n         is_refutable(cx, sub)\n       }\n       pat_wild | pat_ident(_, _, None) => { false }\n-      pat_lit(@{node: expr_lit(@{node: lit_nil, _}), _}) => { false } // \"()\"\n+      pat_lit(@{node: expr_lit(@spanned { node: lit_nil, _}), _}) => {\n+        // \"()\"\n+        false\n+      }\n       pat_lit(_) | pat_range(_, _) => { true }\n       pat_rec(fields, _) => {\n         fields.any(|f| is_refutable(cx, f.pat))"}, {"sha": "5e7002af2a59476f4fb04ea31f5075653674fd4f", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -409,7 +409,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n \n fn check_stmt(stmt: @stmt, cx: ctx, v: visit::vt<ctx>) {\n     match stmt.node {\n-      stmt_decl(@{node: decl_local(ref locals), _}, _) => {\n+      stmt_decl(@spanned {node: decl_local(ref locals), _}, _) => {\n         for locals.each |local| {\n             match local.node.init {\n               Some(expr) =>"}, {"sha": "1db7e666ffbe333948bfaba5e88f696a873ad476", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -467,7 +467,8 @@ fn check_item_while_true(cx: ty::ctxt, it: @ast::item) {\n            match e.node {\n              ast::expr_while(cond, _) => {\n                 match cond.node {\n-                    ast::expr_lit(@{node: ast::lit_bool(true),_}) => {\n+                    ast::expr_lit(@ast::spanned { node: ast::lit_bool(true),\n+                                                  _}) => {\n                             cx.sess.span_lint(\n                                 while_true, e.id, it.id,\n                                 e.span,"}, {"sha": "668457a6a463de4fada52c0a2af67aca92fd0eed", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -1938,7 +1938,8 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         } else {\n             for vec::each((*body).node.stmts) |stmt| {\n                 match stmt.node {\n-                  ast::stmt_decl(@{node: ast::decl_item(i), _}, _) => {\n+                  ast::stmt_decl(@ast::spanned { node: ast::decl_item(i),\n+                                                 _ }, _) => {\n                     trans_item(ccx, *i);\n                   }\n                   _ => ()"}, {"sha": "50267a5965e94c56929689be1d6fed288e32247d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -545,7 +545,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         ast::expr_tup(args) => {\n             return trans_tup(bcx, args, dest);\n         }\n-        ast::expr_lit(@{node: ast::lit_str(s), _}) => {\n+        ast::expr_lit(@ast::spanned {node: ast::lit_str(s), _}) => {\n             return tvec::trans_lit_str(bcx, expr, s, dest);\n         }\n         ast::expr_vstore(contents, ast::expr_vstore_slice) |"}, {"sha": "11990b5a8b67f8dbba19d86a36fcdc93e75f17ac", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -197,7 +197,7 @@ fn trans_slice_vstore(bcx: block,\n \n     // Handle the &\"...\" case:\n     match content_expr.node {\n-        ast::expr_lit(@{node: ast::lit_str(s), span: _}) => {\n+        ast::expr_lit(@ast::spanned {node: ast::lit_str(s), span: _}) => {\n             return trans_lit_str(bcx, content_expr, s, dest);\n         }\n         _ => {}\n@@ -316,7 +316,7 @@ fn write_content(bcx: block,\n     let _indenter = indenter();\n \n     match /*bad*/copy content_expr.node {\n-        ast::expr_lit(@{node: ast::lit_str(s), span: _}) => {\n+        ast::expr_lit(@ast::spanned { node: ast::lit_str(s), _ }) => {\n             match dest {\n                 Ignore => {\n                     return bcx;\n@@ -422,7 +422,9 @@ fn elements_required(bcx: block, content_expr: @ast::expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n     match /*bad*/copy content_expr.node {\n-        ast::expr_lit(@{node: ast::lit_str(s), span: _}) => s.len() + 1,\n+        ast::expr_lit(@ast::spanned { node: ast::lit_str(s), _ }) => {\n+            s.len() + 1\n+        },\n         ast::expr_vec(es, _) => es.len(),\n         ast::expr_repeat(_, count_expr, _) => {\n             ty::eval_repeat_count(bcx.tcx(), count_expr, content_expr.span)"}, {"sha": "65533571f9a46d37b63d8377fd0ebaea7959ca3a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -3157,7 +3157,7 @@ fn expr_kind(tcx: ctxt,\n         ast::expr_copy(*) |\n         ast::expr_unary_move(*) |\n         ast::expr_repeat(*) |\n-        ast::expr_lit(@{node: lit_str(_), _}) |\n+        ast::expr_lit(@ast::spanned {node: lit_str(_), _}) |\n         ast::expr_vstore(_, ast::expr_vstore_slice) |\n         ast::expr_vstore(_, ast::expr_vstore_mut_slice) |\n         ast::expr_vstore(_, ast::expr_vstore_fixed(_)) |"}, {"sha": "69b2724c0540ee2a27561906abbf7e4a59d70e08", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -552,11 +552,12 @@ fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n     let self_ty = ty::node_id_to_type(tcx, id);\n \n     do struct_def.dtor.iter() |dtor| {\n-        let class_t = {self_ty: self_ty,\n-                       self_id: dtor.node.self_id,\n-                       def_id: local_def(id),\n-                       explicit_self: {node: ast::sty_by_ref,\n-                                       span: ast_util::dummy_sp()}};\n+        let class_t = { self_ty: self_ty,\n+                        self_id: dtor.node.self_id,\n+                        def_id: local_def(id),\n+                        explicit_self:\n+                            spanned { node: ast::sty_by_ref,\n+                                      span: ast_util::dummy_sp() } };\n         // typecheck the dtor\n         check_bare_fn(ccx, ast_util::dtor_dec(),\n                       dtor.node.body, dtor.node.id,\n@@ -1911,7 +1912,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     match /*bad*/copy expr.node {\n       ast::expr_vstore(ev, vst) => {\n         let typ = match /*bad*/copy ev.node {\n-          ast::expr_lit(@{node: ast::lit_str(s), span:_}) => {\n+          ast::expr_lit(@ast::spanned { node: ast::lit_str(s), _ }) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, str::len(*s), vst);\n             ty::mk_estr(tcx, tt)\n           }\n@@ -2600,7 +2601,8 @@ fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n         for blk.node.stmts.each |s| {\n             if bot && !warned &&\n                 match s.node {\n-                  ast::stmt_decl(@{node: ast::decl_local(_), _}, _) |\n+                  ast::stmt_decl(@ast::spanned { node: ast::decl_local(_),\n+                                                 _}, _) |\n                   ast::stmt_expr(_, _) | ast::stmt_semi(_, _) => {\n                     true\n                   }"}, {"sha": "1e4082fc9611b1e956e24e40f0b25f71c1b35c29", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -43,7 +43,8 @@ fn replace_bound_regions_in_fn_ty(\n     let mut all_tys = ty::tys_in_fn_ty(fn_ty);\n \n     match self_info {\n-      Some({explicit_self: {node: ast::sty_region(m), _}, _}) => {\n+      Some({explicit_self: ast::spanned { node: ast::sty_region(m),\n+                                          _}, _}) => {\n         let region = ty::re_bound(ty::br_self);\n         let ty = ty::mk_rptr(tcx, region,\n                              { ty: ty::mk_self(tcx), mutbl: m });"}, {"sha": "b71f62c6db2533949900da99a60668b9ab299b5b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -23,8 +23,7 @@ use std::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n #[auto_encode]\n #[auto_decode]\n-type spanned<T> = {node: T, span: span};\n-\n+struct spanned<T> { node: T, span: span }\n \n /* can't import macros yet, so this is copied from token.rs. See its comment\n  * there. */"}, {"sha": "81c7bb2abc99952988cf567b23d8cc8d30f8347f", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -176,12 +176,15 @@ fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n         cx.local_id += 1u;\n     }\n     match fk {\n-      visit::fk_dtor(tps, ref attrs, self_id, parent_id) => {\n-          let dt = @{node: {id: id, attrs: (*attrs), self_id: self_id,\n-                     body: /* FIXME (#2543) */ copy body}, span: sp};\n-          cx.map.insert(id, node_dtor(/* FIXME (#2543) */ copy tps, dt,\n-                                      parent_id,\n-                                      @/* FIXME (#2543) */ copy cx.path));\n+        visit::fk_dtor(tps, ref attrs, self_id, parent_id) => {\n+            let dt = @spanned {\n+                node: {id: id, attrs: (*attrs), self_id: self_id,\n+                     body: /* FIXME (#2543) */ copy body},\n+                span: sp,\n+            };\n+            cx.map.insert(id, node_dtor(/* FIXME (#2543) */ copy tps, dt,\n+                                        parent_id,\n+                                        @/* FIXME (#2543) */ copy cx.path));\n       }\n       _ => ()\n     }"}, {"sha": "91baaaaa1da4b5387354504f7fa096bae1d1d493", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -29,7 +29,7 @@ pure fn spanned<T>(+lo: BytePos, +hi: BytePos, +t: T) -> spanned<T> {\n }\n \n pure fn respan<T>(sp: span, +t: T) -> spanned<T> {\n-    {node: move t, span: sp}\n+    spanned {node: t, span: sp}\n }\n \n pure fn dummy_spanned<T>(+t: T) -> spanned<T> {\n@@ -284,7 +284,7 @@ impl def_id : to_bytes::IterBytes {\n \n fn block_from_expr(e: @expr) -> blk {\n     let blk_ = default_block(~[], option::Some::<@expr>(e), e.id);\n-    return {node: blk_, span: e.span};\n+    return spanned {node: blk_, span: e.span};\n }\n \n fn default_block(+stmts1: ~[@stmt], expr1: Option<@expr>, id1: node_id) ->"}, {"sha": "a3f208a3f076cf83d107bc90862761c1dae5c6ec", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -299,8 +299,8 @@ priv impl ext_ctxt {\n     }\n \n     fn stmt(expr: @ast::expr) -> @ast::stmt {\n-        @{node: ast::stmt_semi(expr, self.next_id()),\n-          span: expr.span}\n+        @ast::spanned { node: ast::stmt_semi(expr, self.next_id()),\n+                       span: expr.span }\n     }\n \n     fn lit_str(span: span, s: @~str) -> @ast::expr {\n@@ -310,17 +310,17 @@ priv impl ext_ctxt {\n                 self.expr(\n                     span,\n                     ast::expr_lit(\n-                        @{node: ast::lit_str(s),\n-                          span: span})),\n+                        @ast::spanned { node: ast::lit_str(s),\n+                                        span: span})),\n                 ast::expr_vstore_uniq))\n     }\n \n     fn lit_uint(span: span, i: uint) -> @ast::expr {\n         self.expr(\n             span,\n             ast::expr_lit(\n-                @{node: ast::lit_uint(i as u64, ast::ty_u),\n-                  span: span}))\n+                @ast::spanned { node: ast::lit_uint(i as u64, ast::ty_u),\n+                                span: span}))\n     }\n \n     fn lambda(blk: ast::blk) -> @ast::expr {\n@@ -330,21 +330,21 @@ priv impl ext_ctxt {\n     }\n \n     fn blk(span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n-        {node: {view_items: ~[],\n-                stmts: stmts,\n-                expr: None,\n-                id: self.next_id(),\n-                rules: ast::default_blk},\n-         span: span}\n+        ast::spanned { node: { view_items: ~[],\n+                               stmts: stmts,\n+                               expr: None,\n+                               id: self.next_id(),\n+                               rules: ast::default_blk},\n+                       span: span }\n     }\n \n     fn expr_blk(expr: @ast::expr) -> ast::blk {\n-        {node: {view_items: ~[],\n-                stmts: ~[],\n-                expr: Some(expr),\n-                id: self.next_id(),\n-                rules: ast::default_blk},\n-         span: expr.span}\n+        ast::spanned { node: { view_items: ~[],\n+                               stmts: ~[],\n+                               expr: Some(expr),\n+                               id: self.next_id(),\n+                               rules: ast::default_blk},\n+                       span: expr.span }\n     }\n \n     fn expr_path(span: span, strs: ~[ast::ident]) -> @ast::expr {\n@@ -570,7 +570,8 @@ fn mk_ser_method(\n         ident: cx.ident_of(~\"encode\"),\n         attrs: ~[],\n         tps: ~[],\n-        self_ty: { node: ast::sty_region(ast::m_imm), span: span },\n+        self_ty: ast::spanned { node: ast::sty_region(ast::m_imm),\n+                                span: span },\n         purity: ast::impure_fn,\n         decl: ser_decl,\n         body: ser_body,\n@@ -624,7 +625,8 @@ fn mk_deser_method(\n         ident: cx.ident_of(~\"decode\"),\n         attrs: ~[],\n         tps: ~[],\n-        self_ty: { node: ast::sty_static, span: span },\n+        self_ty: ast::spanned { node: ast::sty_static,\n+                                span: span },\n         purity: ast::impure_fn,\n         decl: deser_decl,\n         body: deser_body,\n@@ -862,7 +864,7 @@ fn mk_deser_fields(\n             ]\n         );\n \n-        {\n+        ast::spanned {\n             node: { mutbl: field.mutbl, ident: field.ident, expr: expr },\n             span: span,\n         }"}, {"sha": "288ef1b273eba32c60205ed167dc7e1b1576f19d", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -26,7 +26,7 @@ fn mk_expr(cx: ext_ctxt, sp: codemap::span, expr: ast::expr_) ->\n }\n \n fn mk_lit(cx: ext_ctxt, sp: span, lit: ast::lit_) -> @ast::expr {\n-    let sp_lit = @{node: lit, span: sp};\n+    let sp_lit = @ast::spanned { node: lit, span: sp };\n     mk_expr(cx, sp, ast::expr_lit(sp_lit))\n }\n fn mk_int(cx: ext_ctxt, sp: span, i: int) -> @ast::expr {\n@@ -136,7 +136,8 @@ fn mk_uniq_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n }\n fn mk_field(sp: span, f: &{ident: ast::ident, ex: @ast::expr})\n     -> ast::field {\n-    {node: {mutbl: ast::m_imm, ident: f.ident, expr: f.ex}, span: sp}\n+    ast::spanned { node: {mutbl: ast::m_imm, ident: f.ident, expr: f.ex},\n+                   span: sp }\n }\n fn mk_fields(sp: span, fields: ~[{ident: ast::ident, ex: @ast::expr}]) ->\n     ~[ast::field] {\n@@ -159,9 +160,10 @@ fn mk_struct_e(cx: ext_ctxt, sp: span,\n }\n fn mk_glob_use(cx: ext_ctxt, sp: span,\n                path: ~[ast::ident]) -> @ast::view_item {\n-    let glob = @{node: ast::view_path_glob(mk_raw_path(sp, path),\n-                                          cx.next_id()),\n-                span: sp};\n+    let glob = @ast::spanned {\n+        node: ast::view_path_glob(mk_raw_path(sp, path), cx.next_id()),\n+        span: sp,\n+    };\n     @{node: ast::view_item_import(~[glob]),\n       attrs: ~[],\n       vis: ast::private,\n@@ -176,29 +178,29 @@ fn mk_local(cx: ext_ctxt, sp: span, mutbl: bool,\n                                                  None),\n                            span: sp};\n     let ty : @ast::Ty = @{ id: cx.next_id(), node: ast::ty_infer, span: sp };\n-    let local : @ast::local = @{node: {is_mutbl: mutbl,\n-                                       ty: ty,\n-                                       pat: pat,\n-                                       init: Some(ex),\n-                                       id: cx.next_id()},\n-                                span: sp};\n-    let decl = {node: ast::decl_local(~[local]), span: sp};\n-    @{ node: ast::stmt_decl(@decl, cx.next_id()), span: sp }\n+    let local : @ast::local = @ast::spanned { node: { is_mutbl: mutbl,\n+                                                      ty: ty,\n+                                                      pat: pat,\n+                                                      init: Some(ex),\n+                                                      id: cx.next_id()},\n+                                              span: sp};\n+    let decl = ast::spanned {node: ast::decl_local(~[local]), span: sp};\n+    @ast::spanned { node: ast::stmt_decl(@decl, cx.next_id()), span: sp }\n }\n fn mk_block(cx: ext_ctxt, sp: span,\n             view_items: ~[@ast::view_item],\n             stmts: ~[@ast::stmt],\n             expr: Option<@ast::expr>) -> @ast::expr {\n-    let blk = {node: {view_items: view_items,\n-                      stmts: stmts,\n-                      expr: expr,\n-                      id: cx.next_id(),\n-                      rules: ast::default_blk },\n-               span: sp };\n+    let blk = ast::spanned { node: { view_items: view_items,\n+                                     stmts: stmts,\n+                                     expr: expr,\n+                                     id: cx.next_id(),\n+                                     rules: ast::default_blk },\n+                             span: sp };\n     mk_expr(cx, sp, ast::expr_block(blk))\n }\n fn mk_block_(cx: ext_ctxt, sp: span, +stmts: ~[@ast::stmt]) -> ast::blk {\n-    {\n+    ast::spanned {\n         node: {\n             view_items: ~[],\n             stmts: move stmts,\n@@ -217,7 +219,7 @@ fn mk_simple_block(cx: ext_ctxt, span: span, expr: @ast::expr) -> ast::blk {\n         id: cx.next_id(),\n         rules: ast::default_blk\n     };\n-    { node: move block, span: span }\n+    ast::spanned { node: block, span: span }\n }\n fn mk_copy(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_copy(e))\n@@ -250,12 +252,13 @@ fn mk_pat_struct(cx: ext_ctxt,\n     mk_pat(cx, span, move pat)\n }\n fn mk_bool(cx: ext_ctxt, span: span, value: bool) -> @ast::expr {\n-    let lit_expr = ast::expr_lit(@{ node: ast::lit_bool(value), span: span });\n+    let lit_expr = ast::expr_lit(@ast::spanned { node: ast::lit_bool(value),\n+                                                 span: span });\n     build::mk_expr(cx, span, move lit_expr)\n }\n fn mk_stmt(cx: ext_ctxt, span: span, expr: @ast::expr) -> @ast::stmt {\n     let stmt_ = ast::stmt_semi(expr, cx.next_id());\n-    @{ node: move stmt_, span: span }\n+    @ast::spanned { node: move stmt_, span: span }\n }\n fn mk_ty_path(cx: ext_ctxt,\n               span: span,"}, {"sha": "8e36dc01e2ad32004caf8b583dcacb2e66fcfdfe", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -16,10 +16,10 @@ use core::prelude::*;\n use ast::{Ty, and, bind_by_ref, binop, deref, enum_def, enum_variant_kind};\n use ast::{expr, expr_match, ident, item, item_, item_struct, item_enum};\n use ast::{item_impl, m_imm, meta_item, method, named_field, or, pat};\n-use ast::{pat_ident, pat_wild, public, pure_fn, re_anon, stmt, struct_def};\n-use ast::{struct_variant_kind, sty_by_ref, sty_region, tuple_variant_kind};\n-use ast::{ty_nil, ty_param, ty_param_bound, ty_path, ty_rptr, unnamed_field};\n-use ast::{variant};\n+use ast::{pat_ident, pat_wild, public, pure_fn, re_anon, spanned, stmt};\n+use ast::{struct_def, struct_variant_kind, sty_by_ref, sty_region};\n+use ast::{tuple_variant_kind, ty_nil, ty_param, ty_param_bound, ty_path};\n+use ast::{ty_rptr, unnamed_field, variant};\n use ext::base::ext_ctxt;\n use ext::build;\n use codemap::span;\n@@ -159,7 +159,7 @@ fn create_eq_method(cx: ext_ctxt,\n     let body_block = build::mk_simple_block(cx, span, body);\n \n     // Create the method.\n-    let self_ty = { node: sty_region(m_imm), span: span };\n+    let self_ty = spanned { node: sty_region(m_imm), span: span };\n     return @{\n         ident: method_ident,\n         attrs: ~[],\n@@ -309,7 +309,7 @@ fn create_iter_bytes_method(cx: ext_ctxt,\n     let body_block = build::mk_block_(cx, span, move statements);\n \n     // Create the method.\n-    let self_ty = { node: sty_region(m_imm), span: span };\n+    let self_ty = spanned { node: sty_region(m_imm), span: span };\n     let method_ident = cx.ident_of(~\"iter_bytes\");\n     return @{\n         ident: method_ident,"}, {"sha": "82dae3e26b35c0a1a7524d49ee719d1d0523b96f", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -156,7 +156,9 @@ fn expand_item_mac(exts: HashMap<~str, syntax_extension>,\n                    fld: ast_fold) -> Option<@ast::item> {\n \n     let (pth, tts) = match it.node {\n-        item_mac({node: mac_invoc_tt(pth, ref tts), _}) => (pth, (*tts)),\n+        item_mac(ast::spanned { node: mac_invoc_tt(pth, ref tts), _}) => {\n+            (pth, (*tts))\n+        }\n         _ => cx.span_bug(it.span, ~\"invalid item macro invocation\")\n     };\n \n@@ -234,7 +236,8 @@ fn expand_stmt(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n                 {call_site: sp, callie: {name: *extname, span: exp_sp}}));\n             let expanded = match exp(cx, mac.span, tts) {\n                 mr_expr(e) =>\n-                    @{node: stmt_expr(e, cx.next_id()), span: e.span},\n+                    @ast::spanned { node: stmt_expr(e, cx.next_id()),\n+                                    span: e.span},\n                 mr_any(_,_,stmt_mkr) => stmt_mkr(),\n                 _ => cx.span_fatal(\n                     pth.span,"}, {"sha": "3e265de04a394236766f98f78332c5a14ab8cda0", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -136,8 +136,8 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n     }\n \n     fn stmt_expr(e: @ast::expr) -> @ast::stmt {\n-        @{node: ast::stmt_expr(e, self.next_id()),\n-          span: dummy_sp()}\n+        @spanned { node: ast::stmt_expr(e, self.next_id()),\n+                   span: dummy_sp()}\n     }\n \n     fn stmt_let(ident: ident, e: @ast::expr) -> @ast::stmt {\n@@ -146,8 +146,8 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n     }\n \n     fn field_imm(name: ident, e: @ast::expr) -> ast::field {\n-        {node: {mutbl: ast::m_imm, ident: name, expr: e},\n-         span: dummy_sp()}\n+        spanned { node: { mutbl: ast::m_imm, ident: name, expr: e },\n+                  span: dummy_sp()}\n     }\n \n     fn rec(+fields: ~[ast::field]) -> @ast::expr {\n@@ -158,8 +158,8 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n     }\n \n     fn ty_field_imm(name: ident, ty: @ast::Ty) -> ast::ty_field {\n-        {node: {ident: name, mt: { ty: ty, mutbl: ast::m_imm } },\n-          span: dummy_sp()}\n+        spanned { node: { ident: name, mt: { ty: ty, mutbl: ast::m_imm } },\n+                  span: dummy_sp() }\n     }\n \n     fn ty_rec(+fields: ~[ast::ty_field]) -> @ast::Ty {\n@@ -199,8 +199,7 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n                    id: self.next_id(),\n                    rules: ast::default_blk};\n \n-        {node: blk,\n-         span: dummy_sp()}\n+        spanned { node: blk, span: dummy_sp() }\n     }\n \n     fn expr_block(e: @ast::expr) -> ast::blk {\n@@ -275,13 +274,13 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n                +tys: ~[@ast::Ty]) -> ast::variant {\n         let args = tys.map(|ty| {ty: *ty, id: self.next_id()});\n \n-        {node: {name: name,\n-                attrs: ~[],\n-                kind: ast::tuple_variant_kind(args),\n-                id: self.next_id(),\n-                disr_expr: None,\n-                vis: ast::public},\n-         span: span}\n+        spanned { node: { name: name,\n+                          attrs: ~[],\n+                          kind: ast::tuple_variant_kind(args),\n+                          id: self.next_id(),\n+                          disr_expr: None,\n+                          vis: ast::public},\n+                  span: span}\n     }\n \n     fn item_mod(name: ident,\n@@ -290,7 +289,7 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n         // XXX: Total hack: import `core::kinds::Owned` to work around a\n         // parser bug whereby `fn f<T: ::kinds::Owned>` doesn't parse.\n         let vi = ast::view_item_import(~[\n-            @{\n+            @ast::spanned {\n                 node: ast::view_path_simple(\n                     self.ident_of(~\"Owned\"),\n                     path("}, {"sha": "2449db17c0f47702d64038bdcac2017f0535cbe3", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -189,13 +189,13 @@ fn nameize(p_s: parse_sess, ms: ~[matcher], res: ~[@named_match])\n     fn n_rec(p_s: parse_sess, m: matcher, res: ~[@named_match],\n              ret_val: HashMap<ident, @named_match>) {\n         match m {\n-          {node: match_tok(_), span: _} => (),\n-          {node: match_seq(ref more_ms, _, _, _, _), span: _} => {\n+          spanned {node: match_tok(_), _} => (),\n+          spanned {node: match_seq(ref more_ms, _, _, _, _), _} => {\n             for (*more_ms).each() |next_m| {\n                 n_rec(p_s, *next_m, res, ret_val)\n             };\n           }\n-          {node: match_nonterminal(bind_name, _, idx), span: sp} => {\n+          spanned {node: match_nonterminal(bind_name, _, idx), span: sp} => {\n             if ret_val.contains_key(bind_name) {\n                 p_s.span_diagnostic.span_fatal(sp, ~\"Duplicated bind name: \"+\n                                                *p_s.interner.get(bind_name))"}, {"sha": "069eb1e0d82535f767f74a796bcdb7e8d9a0ba03", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -33,7 +33,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                      arg: ~[ast::token_tree]) -> base::mac_result {\n     // these spans won't matter, anyways\n     fn ms(m: matcher_) -> matcher {\n-        {node: m, span: dummy_sp()}\n+        ast::spanned { node: m, span: dummy_sp() }\n     }\n \n     let lhs_nm =  cx.parse_sess().interner.gensym(@~\"lhs\");"}, {"sha": "2c4efa8249930359dc8718953dd313b30ef408ee", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -93,27 +93,27 @@ type ast_fold_precursor = @{\n \n //used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n-    return @{node:\n-              match mi.node {\n+    @spanned {\n+        node:\n+            match mi.node {\n                 meta_word(ref id) => meta_word((*id)),\n                 meta_list(ref id, mis) => {\n-                  let fold_meta_item = |x|fold_meta_item_(x, fld);\n-                  meta_list(/* FIXME: (#2543) */ copy (*id),\n-                            vec::map(mis, |e| fold_meta_item(*e)))\n+                    let fold_meta_item = |x|fold_meta_item_(x, fld);\n+                    meta_list(/* FIXME: (#2543) */ copy (*id),\n+                        vec::map(mis, |e| fold_meta_item(*e)))\n                 }\n                 meta_name_value(ref id, s) => {\n-                  meta_name_value((*id), /* FIXME (#2543) */ copy s)\n+                    meta_name_value((*id), /* FIXME (#2543) */ copy s)\n                 }\n-              },\n-          span: fld.new_span(mi.span)};\n+            },\n+        span: fld.new_span(mi.span) }\n }\n //used in noop_fold_item and noop_fold_crate\n-fn fold_attribute_(at: attribute, fld: ast_fold) ->\n-   attribute {\n-    return {node: {style: at.node.style,\n-                value: *fold_meta_item_(@at.node.value, fld),\n-                is_sugared_doc: at.node.is_sugared_doc },\n-         span: fld.new_span(at.span)};\n+fn fold_attribute_(at: attribute, fld: ast_fold) -> attribute {\n+    spanned { node: { style: at.node.style,\n+                      value: *fold_meta_item_(@at.node.value, fld),\n+                      is_sugared_doc: at.node.is_sugared_doc },\n+              span: fld.new_span(at.span) }\n }\n //used in noop_fold_foreign_item and noop_fold_fn_decl\n fn fold_arg_(a: arg, fld: ast_fold) -> arg {\n@@ -124,11 +124,10 @@ fn fold_arg_(a: arg, fld: ast_fold) -> arg {\n }\n //used in noop_fold_expr, and possibly elsewhere in the future\n fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n-    return {node:\n-             match m.node {\n-               mac_invoc_tt(*) => m.node,\n-             },\n-         span: fld.new_span(m.span)};\n+    spanned { node: match m.node {\n+                        mac_invoc_tt(*) => m.node,\n+                    },\n+              span: fld.new_span(m.span) }\n }\n \n fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n@@ -206,10 +205,10 @@ fn noop_fold_item(&&i: @item, fld: ast_fold) -> Option<@item> {\n \n fn noop_fold_struct_field(&&sf: @struct_field, fld: ast_fold)\n                        -> @struct_field {\n-    @{node: {kind: copy sf.node.kind,\n-             id: sf.node.id,\n-             ty: fld.fold_ty(sf.node.ty)},\n-      span: sf.span}\n+    @spanned { node: { kind: copy sf.node.kind,\n+                       id: sf.node.id,\n+                       ty: fld.fold_ty(sf.node.ty) },\n+               span: sf.span }\n }\n \n fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n@@ -266,9 +265,10 @@ fn fold_struct_def(struct_def: @ast::struct_def, fld: ast_fold)\n     let dtor = do option::map(&struct_def.dtor) |dtor| {\n         let dtor_body = fld.fold_block(dtor.node.body);\n         let dtor_id   = fld.new_id(dtor.node.id);\n-        {node: {body: dtor_body,\n-                id: dtor_id,.. dtor.node},\n-            .. *dtor}};\n+        spanned { node: { body: dtor_body,\n+                          id: dtor_id, .. dtor.node},\n+                  span: dtor.span }\n+    };\n     return @{\n         fields: vec::map(struct_def.fields, |f| fold_struct_field(*f, fld)),\n         dtor: dtor,\n@@ -281,10 +281,10 @@ fn fold_trait_ref(&&p: @trait_ref, fld: ast_fold) -> @trait_ref {\n }\n \n fn fold_struct_field(&&f: @struct_field, fld: ast_fold) -> @struct_field {\n-    @{node: {kind: copy f.node.kind,\n-             id: fld.new_id(f.node.id),\n-             ty: fld.fold_ty(f.node.ty)},\n-      span: fld.new_span(f.span)}\n+    @spanned { node: { kind: copy f.node.kind,\n+                       id: fld.new_id(f.node.id),\n+                       ty: fld.fold_ty(f.node.ty) },\n+               span: fld.new_span(f.span) }\n }\n \n fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n@@ -390,11 +390,10 @@ fn wrap<T>(f: fn@(T, ast_fold) -> T)\n \n fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n     fn fold_field_(field: field, fld: ast_fold) -> field {\n-        return {node:\n-                 {mutbl: field.node.mutbl,\n-                  ident: fld.fold_ident(field.node.ident),\n-                  expr: fld.fold_expr(field.node.expr)},\n-             span: fld.new_span(field.span)};\n+        spanned { node: { mutbl: field.node.mutbl,\n+                          ident: fld.fold_ident(field.node.ident),\n+                          expr: fld.fold_expr(field.node.expr)},\n+                  span: fld.new_span(field.span) }\n     }\n     let fold_field = |x| fold_field_(x, fld);\n \n@@ -508,9 +507,9 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n         {ty: fld.fold_ty(mt.ty), mutbl: mt.mutbl}\n     }\n     fn fold_field(f: ty_field, fld: ast_fold) -> ty_field {\n-        {node: {ident: fld.fold_ident(f.node.ident),\n-                mt: fold_mt(f.node.mt, fld)},\n-         span: fld.new_span(f.span)}\n+        spanned { node: { ident: fld.fold_ident(f.node.ident),\n+                          mt: fold_mt(f.node.mt, fld) },\n+                  span: fld.new_span(f.span) }\n     }\n     match t {\n       ty_nil | ty_bot | ty_infer => copy t,\n@@ -566,9 +565,10 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n             let dtor = do option::map(&struct_def.dtor) |dtor| {\n                 let dtor_body = fld.fold_block(dtor.node.body);\n                 let dtor_id   = fld.new_id(dtor.node.id);\n-                {node: {body: dtor_body,\n-                        id: dtor_id,.. dtor.node},\n-                    .. *dtor}};\n+                spanned { node: { body: dtor_body,\n+                                  id: dtor_id, .. dtor.node},\n+                          .. *dtor }\n+            };\n             kind = struct_variant_kind(@{\n                 fields: vec::map(struct_def.fields,\n                                  |f| fld.fold_struct_field(*f)),\n@@ -661,7 +661,7 @@ impl ast_fold_precursor: ast_fold {\n     /* naturally, a macro to write these would be nice */\n     fn fold_crate(c: crate) -> crate {\n         let (n, s) = (self.fold_crate)(c.node, c.span, self as ast_fold);\n-        return {node: n, span: (self.new_span)(s)};\n+        spanned { node: n, span: (self.new_span)(s) }\n     }\n     fn fold_view_item(&&x: @view_item) ->\n        @view_item {\n@@ -679,10 +679,10 @@ impl ast_fold_precursor: ast_fold {\n         return (self.fold_item)(i, self as ast_fold);\n     }\n     fn fold_struct_field(&&sf: @struct_field) -> @struct_field {\n-        @{node: {kind: copy sf.node.kind,\n-                 id: sf.node.id,\n-                 ty: (self as ast_fold).fold_ty(sf.node.ty)},\n-          span: (self.new_span)(sf.span)}\n+        @spanned { node: { kind: copy sf.node.kind,\n+                           id: sf.node.id,\n+                           ty: (self as ast_fold).fold_ty(sf.node.ty) },\n+                   span: (self.new_span)(sf.span) }\n     }\n     fn fold_item_underscore(i: item_) ->\n        item_ {\n@@ -694,11 +694,11 @@ impl ast_fold_precursor: ast_fold {\n     }\n     fn fold_block(x: blk) -> blk {\n         let (n, s) = (self.fold_block)(x.node, x.span, self as ast_fold);\n-        return {node: n, span: (self.new_span)(s)};\n+        spanned { node: n, span: (self.new_span)(s) }\n     }\n     fn fold_stmt(&&x: @stmt) -> @stmt {\n         let (n, s) = (self.fold_stmt)(x.node, x.span, self as ast_fold);\n-        return @{node: n, span: (self.new_span)(s)};\n+        @spanned { node: n, span: (self.new_span)(s) }\n     }\n     fn fold_arm(x: arm) -> arm {\n         return (self.fold_arm)(x, self as ast_fold);\n@@ -711,7 +711,7 @@ impl ast_fold_precursor: ast_fold {\n     }\n     fn fold_decl(&&x: @decl) -> @decl {\n         let (n, s) = (self.fold_decl)(x.node, x.span, self as ast_fold);\n-        return @{node: n, span: (self.new_span)(s)};\n+        @spanned { node: n, span: (self.new_span)(s) }\n     }\n     fn fold_expr(&&x: @expr) -> @expr {\n         let (n, s) = (self.fold_expr)(x.node, x.span, self as ast_fold);\n@@ -734,7 +734,7 @@ impl ast_fold_precursor: ast_fold {\n     fn fold_variant(x: variant) ->\n        variant {\n         let (n, s) = (self.fold_variant)(x.node, x.span, self as ast_fold);\n-        return {node: n, span: (self.new_span)(s)};\n+        spanned { node: n, span: (self.new_span)(s) }\n     }\n     fn fold_ident(&&x: ident) -> ident {\n         return (self.fold_ident)(x, self as ast_fold);\n@@ -744,7 +744,7 @@ impl ast_fold_precursor: ast_fold {\n     }\n     fn fold_local(&&x: @local) -> @local {\n         let (n, s) = (self.fold_local)(x.node, x.span, self as ast_fold);\n-        return @{node: n, span: (self.new_span)(s)};\n+        @spanned { node: n, span: (self.new_span)(s) }\n     }\n     fn map_exprs(f: fn@(&&v: @expr) -> @expr, e: ~[@expr]) -> ~[@expr] {\n         (self.map_exprs)(f, e)"}, {"sha": "04316e05b64750653bb5030881f788fd2598492c", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -30,7 +30,8 @@ fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n \n fn expr_is_simple_block(e: @ast::expr) -> bool {\n     match e.node {\n-      ast::expr_block({node: {rules: ast::default_blk, _}, _}) => true,\n+      ast::expr_block(ast::spanned {node: {rules: ast::default_blk, _}, _}) =>\n+        true,\n       _ => false\n     }\n }"}, {"sha": "1a549fc93d517bbdbee43e4ba121e22eab173229", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -772,7 +772,7 @@ impl Parser {\n             self.bump();\n             self.lit_from_token(tok)\n         };\n-        return {node: lit, span: mk_sp(lo, self.last_span.hi)};\n+        spanned { node: lit, span: mk_sp(lo, self.last_span.hi) }\n     }\n \n     fn parse_path_without_tps() -> @path {\n@@ -844,7 +844,7 @@ impl Parser {\n                 self.parse_seq_lt_gt(Some(token::COMMA),\n                                      |p| p.parse_ty(false))\n             } else {\n-                {node: ~[], span: path.span}\n+                spanned {node: ~[], span: path.span}\n             }\n         };\n \n@@ -880,14 +880,14 @@ impl Parser {\n     fn mk_mac_expr(+lo: BytePos, +hi: BytePos, m: mac_) -> @expr {\n         return @{id: self.get_id(),\n               callee_id: self.get_id(),\n-              node: expr_mac({node: m, span: mk_sp(lo, hi)}),\n+              node: expr_mac(spanned {node: m, span: mk_sp(lo, hi)}),\n               span: mk_sp(lo, hi)};\n     }\n \n     fn mk_lit_u32(i: u32) -> @expr {\n         let span = self.span;\n-        let lv_lit = @{node: lit_uint(i as u64, ty_u32),\n-                       span: span};\n+        let lv_lit = @spanned { node: lit_uint(i as u64, ty_u32),\n+                                span: span };\n \n         return @{id: self.get_id(), callee_id: self.get_id(),\n               node: expr_lit(lv_lit), span: span};\n@@ -1363,7 +1363,7 @@ impl Parser {\n                 hi = e.span.hi;\n                 // HACK: turn &[...] into a &-evec\n                 ex = match e.node {\n-                  expr_vec(*) | expr_lit(@{node: lit_str(_), span: _})\n+                  expr_vec(*) | expr_lit(@spanned {node: lit_str(_), span: _})\n                   if m == m_imm => {\n                     expr_vstore(e, expr_vstore_slice)\n                   }\n@@ -1386,7 +1386,7 @@ impl Parser {\n               expr_vec(*) if m == m_mutbl =>\n                 expr_vstore(e, expr_vstore_mut_box),\n               expr_vec(*) if m == m_imm => expr_vstore(e, expr_vstore_box),\n-              expr_lit(@{node: lit_str(_), span: _}) if m == m_imm =>\n+              expr_lit(@spanned {node: lit_str(_), span: _}) if m == m_imm =>\n                 expr_vstore(e, expr_vstore_box),\n               _ => expr_unary(box(m), e)\n             };\n@@ -1398,7 +1398,7 @@ impl Parser {\n             hi = e.span.hi;\n             // HACK: turn ~[...] into a ~-evec\n             ex = match e.node {\n-              expr_vec(*) | expr_lit(@{node: lit_str(_), span: _})\n+              expr_vec(*) | expr_lit(@spanned {node: lit_str(_), span: _})\n               if m == m_imm => expr_vstore(e, expr_vstore_uniq),\n               _ => expr_unary(uniq(m), e)\n             };\n@@ -1748,12 +1748,12 @@ impl Parser {\n                 self.eat(token::COMMA);\n             }\n \n-            let blk = {node: {view_items: ~[],\n-                              stmts: ~[],\n-                              expr: Some(expr),\n-                              id: self.get_id(),\n-                              rules: default_blk},\n-                       span: expr.span};\n+            let blk = spanned { node: { view_items: ~[],\n+                                        stmts: ~[],\n+                                        expr: Some(expr),\n+                                        id: self.get_id(),\n+                                        rules: default_blk},\n+                                span: expr.span };\n \n             arms.push({pats: pats, guard: guard, body: blk});\n         }\n@@ -1893,7 +1893,7 @@ impl Parser {\n             // HACK: parse @\"...\" as a literal of a vstore @str\n             pat = match sub.node {\n               pat_lit(e@@{\n-                node: expr_lit(@{node: lit_str(_), span: _}), _\n+                node: expr_lit(@spanned {node: lit_str(_), span: _}), _\n               }) => {\n                 let vst = @{id: self.get_id(), callee_id: self.get_id(),\n                             node: expr_vstore(e, expr_vstore_box),\n@@ -1910,7 +1910,7 @@ impl Parser {\n             // HACK: parse ~\"...\" as a literal of a vstore ~str\n             pat = match sub.node {\n               pat_lit(e@@{\n-                node: expr_lit(@{node: lit_str(_), span: _}), _\n+                node: expr_lit(@spanned {node: lit_str(_), span: _}), _\n               }) => {\n                 let vst = @{id: self.get_id(), callee_id: self.get_id(),\n                             node: expr_vstore(e, expr_vstore_uniq),\n@@ -1929,7 +1929,7 @@ impl Parser {\n               // HACK: parse &\"...\" as a literal of a borrowed str\n               pat = match sub.node {\n                   pat_lit(e@@{\n-                      node: expr_lit(@{node: lit_str(_), span: _}), _\n+                      node: expr_lit(@spanned {node: lit_str(_), span: _}), _\n                   }) => {\n                       let vst = @{\n                           id: self.get_id(),\n@@ -1954,7 +1954,7 @@ impl Parser {\n             if self.token == token::RPAREN {\n                 hi = self.span.hi;\n                 self.bump();\n-                let lit = @{node: lit_nil, span: mk_sp(lo, hi)};\n+                let lit = @spanned {node: lit_nil, span: mk_sp(lo, hi)};\n                 let expr = self.mk_expr(lo, hi, expr_lit(lit));\n                 pat = pat_lit(expr);\n             } else {\n@@ -2319,8 +2319,9 @@ impl Parser {\n                             match self.token {\n                                 token::SEMI => {\n                                     self.bump();\n-                                    stmts.push(@{node: stmt_semi(e, stmt_id),\n-                                                 ..*stmt});\n+                                    stmts.push(@spanned {\n+                                        node: stmt_semi(e, stmt_id),\n+                                        .. *stmt});\n                                 }\n                                 token::RBRACE => {\n                                     expr = Some(e);\n@@ -2343,8 +2344,9 @@ impl Parser {\n                             match self.token {\n                                 token::SEMI => {\n                                     self.bump();\n-                                    stmts.push(@{node: stmt_mac((*m), true),\n-                                                 ..*stmt});\n+                                    stmts.push(@spanned {\n+                                        node: stmt_mac((*m), true),\n+                                        .. *stmt});\n                                 }\n                                 token::RBRACE => {\n                                     // if a block ends in `m!(arg)` without\n@@ -2811,11 +2813,11 @@ impl Parser {\n \n         let actual_dtor = do the_dtor.map |dtor| {\n             let (d_body, d_attrs, d_s) = *dtor;\n-            {node: {id: self.get_id(),\n-                    attrs: d_attrs,\n-                    self_id: self.get_id(),\n-                    body: d_body},\n-             span: d_s}};\n+            spanned { node: { id: self.get_id(),\n+                              attrs: d_attrs,\n+                              self_id: self.get_id(),\n+                              body: d_body},\n+                       span: d_s}};\n         let _ = self.get_id();  // XXX: Workaround for crazy bug.\n         let new_id = self.get_id();\n         (class_name,\n@@ -3308,11 +3310,11 @@ impl Parser {\n         self.bump();\n         let mut actual_dtor = do the_dtor.map |dtor| {\n             let (d_body, d_attrs, d_s) = *dtor;\n-            {node: {id: self.get_id(),\n-                    attrs: d_attrs,\n-                    self_id: self.get_id(),\n-                    body: d_body},\n-             span: d_s}\n+            spanned { node: { id: self.get_id(),\n+                              attrs: d_attrs,\n+                              self_id: self.get_id(),\n+                              body: d_body },\n+                      span: d_s }\n         };\n \n         return @{\n@@ -3592,9 +3594,9 @@ impl Parser {\n               _ => self.fatal(~\"expected open delimiter\")\n             };\n             let m = ast::mac_invoc_tt(pth, tts);\n-            let m: ast::mac = {node: m,\n-                               span: mk_sp(self.span.lo,\n-                                           self.span.hi)};\n+            let m: ast::mac = spanned { node: m,\n+                                        span: mk_sp(self.span.lo,\n+                                                    self.span.hi) };\n             let item_ = item_mac(m);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, id, item_,\n                                           visibility, attrs));"}, {"sha": "dda83aa2d0e074b0176ca4bb5cf0e318ed921930", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c2ebf9944274ca9d1e97589a992ff52c04f07d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=93c2ebf9944274ca9d1e97589a992ff52c04f07d", "patch": "@@ -599,7 +599,8 @@ fn print_item(s: ps, &&item: @ast::item) {\n         }\n         bclose(s, item.span);\n       }\n-      ast::item_mac({node: ast::mac_invoc_tt(pth, ref tts), _}) => {\n+      ast::item_mac(ast::spanned { node: ast::mac_invoc_tt(pth, ref tts),\n+                                   _}) => {\n         print_visibility(s, item.vis);\n         print_path(s, pth, false);\n         word(s.s, ~\"! \");"}]}