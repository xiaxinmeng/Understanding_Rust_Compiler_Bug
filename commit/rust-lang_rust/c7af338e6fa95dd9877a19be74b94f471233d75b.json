{"sha": "c7af338e6fa95dd9877a19be74b94f471233d75b", "node_id": "C_kwDOAAsO6NoAKGM3YWYzMzhlNmZhOTVkZDk4NzdhMTliZTc0Yjk0ZjQ3MTIzM2Q3NWI", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-10-01T06:39:15Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-10-01T06:39:15Z"}, "message": "Tell LLVM that `partition_point` returns a valid fencepost\n\nThis was already done for a successful `binary_search`, but this way `partition_point` can get similar optimizations.", "tree": {"sha": "0e72eda8e64f2aa620123085487a4223ce0203a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e72eda8e64f2aa620123085487a4223ce0203a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7af338e6fa95dd9877a19be74b94f471233d75b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7af338e6fa95dd9877a19be74b94f471233d75b", "html_url": "https://github.com/rust-lang/rust/commit/c7af338e6fa95dd9877a19be74b94f471233d75b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7af338e6fa95dd9877a19be74b94f471233d75b/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe217c28ffc6955f0927d8e8715d43d727debe5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe217c28ffc6955f0927d8e8715d43d727debe5a", "html_url": "https://github.com/rust-lang/rust/commit/fe217c28ffc6955f0927d8e8715d43d727debe5a"}], "stats": {"total": 35, "additions": 32, "deletions": 3}, "files": [{"sha": "b2289c6bed74affada2355bd75cb4ae4cd65209f", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c7af338e6fa95dd9877a19be74b94f471233d75b/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7af338e6fa95dd9877a19be74b94f471233d75b/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=c7af338e6fa95dd9877a19be74b94f471233d75b", "patch": "@@ -2426,15 +2426,20 @@ impl<T> [T] {\n     where\n         F: FnMut(&'a T) -> Ordering,\n     {\n+        // INVARIANTS:\n+        // - 0 <= left <= left + size = right <= self.len()\n+        // - f returns Less for everything in self[..left]\n+        // - f returns Greater for everything in self[right..]\n         let mut size = self.len();\n         let mut left = 0;\n         let mut right = size;\n         while left < right {\n             let mid = left + size / 2;\n \n-            // SAFETY: the call is made safe by the following invariants:\n-            // - `mid >= 0`\n-            // - `mid < size`: `mid` is limited by `[left; right)` bound.\n+            // SAFETY: the while condition means `size` is strictly positive, so\n+            // `size/2 < size`.  Thus `left + size/2 < left + size`, which\n+            // coupled with the `left + size <= self.len()` invariant means\n+            // we have `left + size/2 < self.len()`, and this is in-bounds.\n             let cmp = f(unsafe { self.get_unchecked(mid) });\n \n             // The reason why we use if/else control flow rather than match\n@@ -2452,6 +2457,10 @@ impl<T> [T] {\n \n             size = right - left;\n         }\n+\n+        // SAFETY: directly true from the overall invariant.\n+        // Note that this is `<=`, unlike the assume in the `Ok` path.\n+        unsafe { crate::intrinsics::assume(left <= self.len()) };\n         Err(left)\n     }\n "}, {"sha": "c1766a4a44ae122689302ab5f749789e2f8fd78b", "filename": "src/test/codegen/binary-search-index-no-bound-check.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c7af338e6fa95dd9877a19be74b94f471233d75b/src%2Ftest%2Fcodegen%2Fbinary-search-index-no-bound-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7af338e6fa95dd9877a19be74b94f471233d75b/src%2Ftest%2Fcodegen%2Fbinary-search-index-no-bound-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fbinary-search-index-no-bound-check.rs?ref=c7af338e6fa95dd9877a19be74b94f471233d75b", "patch": "@@ -16,3 +16,23 @@ pub fn binary_search_index_no_bounds_check(s: &[u8]) -> u8 {\n         42\n     }\n }\n+\n+// Similarly, check that `partition_point` is known to return a valid fencepost.\n+\n+// CHECK-LABEL: @unknown_split\n+#[no_mangle]\n+pub fn unknown_split(x: &[i32], i: usize) -> (&[i32], &[i32]) {\n+    // This just makes sure that the subsequent function is looking for the\n+    // absence of something that might actually be there.\n+\n+    // CHECK: call core::panicking::panic\n+    x.split_at(i)\n+}\n+\n+// CHECK-LABEL: @partition_point_split_no_bounds_check\n+#[no_mangle]\n+pub fn partition_point_split_no_bounds_check(x: &[i32], needle: i32) -> (&[i32], &[i32]) {\n+    // CHECK-NOT: call core::panicking::panic\n+    let i = x.partition_point(|p| p < &needle);\n+    x.split_at(i)\n+}"}]}