{"sha": "8e0cac18cd2951e2679ea55e15242d04e2d410c9", "node_id": "C_kwDOAAsO6NoAKDhlMGNhYzE4Y2QyOTUxZTI2NzllYTU1ZTE1MjQyZDA0ZTJkNDEwYzk", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-11-07T18:13:01Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-11-07T18:13:01Z"}, "message": "rustdoc: refactor `notable_traits_decl` to just act on the type directly", "tree": {"sha": "c9e2662883510d37f5f5cf211a1cf923b78f5e40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9e2662883510d37f5f5cf211a1cf923b78f5e40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e0cac18cd2951e2679ea55e15242d04e2d410c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e0cac18cd2951e2679ea55e15242d04e2d410c9", "html_url": "https://github.com/rust-lang/rust/commit/8e0cac18cd2951e2679ea55e15242d04e2d410c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e0cac18cd2951e2679ea55e15242d04e2d410c9/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "391ba78ab442610a63310b9a3d24646082628081", "url": "https://api.github.com/repos/rust-lang/rust/commits/391ba78ab442610a63310b9a3d24646082628081", "html_url": "https://github.com/rust-lang/rust/commit/391ba78ab442610a63310b9a3d24646082628081"}], "stats": {"total": 140, "additions": 72, "deletions": 68}, "files": [{"sha": "881f107925315eea9df956312f5a00ee5e1eec78", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 66, "deletions": 67, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/8e0cac18cd2951e2679ea55e15242d04e2d410c9/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e0cac18cd2951e2679ea55e15242d04e2d410c9/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=8e0cac18cd2951e2679ea55e15242d04e2d410c9", "patch": "@@ -861,7 +861,11 @@ fn assoc_method(\n         name = name,\n         generics = g.print(cx),\n         decl = d.full_print(header_len, indent, cx),\n-        notable_traits = notable_traits_decl(d, cx),\n+        notable_traits = d\n+            .output\n+            .as_return()\n+            .and_then(|output| notable_traits_decl(output, cx))\n+            .unwrap_or_default(),\n         where_clause = print_where_clause(g, cx, indent, end_newline),\n     )\n }\n@@ -1273,88 +1277,83 @@ fn should_render_item(item: &clean::Item, deref_mut_: bool, tcx: TyCtxt<'_>) ->\n     }\n }\n \n-fn notable_traits_decl(decl: &clean::FnDecl, cx: &Context<'_>) -> String {\n+fn notable_traits_decl(ty: &clean::Type, cx: &Context<'_>) -> Option<String> {\n     let mut out = Buffer::html();\n \n-    if let Some((did, ty)) = decl.output.as_return().and_then(|t| Some((t.def_id(cx.cache())?, t)))\n+    let did = ty.def_id(cx.cache())?;\n+\n+    // Box has pass-through impls for Read, Write, Iterator, and Future when the\n+    // boxed type implements one of those. We don't want to treat every Box return\n+    // as being notably an Iterator (etc), though, so we exempt it. Pin has the same\n+    // issue, with a pass-through impl for Future.\n+    if Some(did) == cx.tcx().lang_items().owned_box()\n+        || Some(did) == cx.tcx().lang_items().pin_type()\n     {\n-        // Box has pass-through impls for Read, Write, Iterator, and Future when the\n-        // boxed type implements one of those. We don't want to treat every Box return\n-        // as being notably an Iterator (etc), though, so we exempt it. Pin has the same\n-        // issue, with a pass-through impl for Future.\n-        if Some(did) == cx.tcx().lang_items().owned_box()\n-            || Some(did) == cx.tcx().lang_items().pin_type()\n-        {\n-            return \"\".to_string();\n-        }\n-        if let Some(impls) = cx.cache().impls.get(&did) {\n-            for i in impls {\n-                let impl_ = i.inner_impl();\n-                if !impl_.for_.without_borrowed_ref().is_same(ty.without_borrowed_ref(), cx.cache())\n-                {\n-                    // Two different types might have the same did,\n-                    // without actually being the same.\n-                    continue;\n-                }\n-                if let Some(trait_) = &impl_.trait_ {\n-                    let trait_did = trait_.def_id();\n-\n-                    if cx\n-                        .cache()\n-                        .traits\n-                        .get(&trait_did)\n-                        .map_or(false, |t| t.is_notable_trait(cx.tcx()))\n-                    {\n-                        if out.is_empty() {\n-                            write!(\n-                                &mut out,\n-                                \"<span class=\\\"notable\\\">Notable traits for {}</span>\\\n-                             <code class=\\\"content\\\">\",\n-                                impl_.for_.print(cx)\n-                            );\n-                        }\n+        return None;\n+    }\n+    if let Some(impls) = cx.cache().impls.get(&did) {\n+        for i in impls {\n+            let impl_ = i.inner_impl();\n+            if !impl_.for_.without_borrowed_ref().is_same(ty.without_borrowed_ref(), cx.cache()) {\n+                // Two different types might have the same did,\n+                // without actually being the same.\n+                continue;\n+            }\n+            if let Some(trait_) = &impl_.trait_ {\n+                let trait_did = trait_.def_id();\n \n-                        //use the \"where\" class here to make it small\n+                if cx.cache().traits.get(&trait_did).map_or(false, |t| t.is_notable_trait(cx.tcx()))\n+                {\n+                    if out.is_empty() {\n                         write!(\n                             &mut out,\n-                            \"<span class=\\\"where fmt-newline\\\">{}</span>\",\n-                            impl_.print(false, cx)\n+                            \"<span class=\\\"notable\\\">Notable traits for {}</span>\\\n+                         <code class=\\\"content\\\">\",\n+                            impl_.for_.print(cx)\n                         );\n-                        for it in &impl_.items {\n-                            if let clean::AssocTypeItem(ref tydef, ref _bounds) = *it.kind {\n-                                out.push_str(\"<span class=\\\"where fmt-newline\\\">    \");\n-                                let empty_set = FxHashSet::default();\n-                                let src_link =\n-                                    AssocItemLink::GotoSource(trait_did.into(), &empty_set);\n-                                assoc_type(\n-                                    &mut out,\n-                                    it,\n-                                    &tydef.generics,\n-                                    &[], // intentionally leaving out bounds\n-                                    Some(&tydef.type_),\n-                                    src_link,\n-                                    0,\n-                                    cx,\n-                                );\n-                                out.push_str(\";</span>\");\n-                            }\n+                    }\n+\n+                    //use the \"where\" class here to make it small\n+                    write!(\n+                        &mut out,\n+                        \"<span class=\\\"where fmt-newline\\\">{}</span>\",\n+                        impl_.print(false, cx)\n+                    );\n+                    for it in &impl_.items {\n+                        if let clean::AssocTypeItem(ref tydef, ref _bounds) = *it.kind {\n+                            out.push_str(\"<span class=\\\"where fmt-newline\\\">    \");\n+                            let empty_set = FxHashSet::default();\n+                            let src_link = AssocItemLink::GotoSource(trait_did.into(), &empty_set);\n+                            assoc_type(\n+                                &mut out,\n+                                it,\n+                                &tydef.generics,\n+                                &[], // intentionally leaving out bounds\n+                                Some(&tydef.type_),\n+                                src_link,\n+                                0,\n+                                cx,\n+                            );\n+                            out.push_str(\";</span>\");\n                         }\n                     }\n                 }\n             }\n         }\n     }\n \n-    if !out.is_empty() {\n-        out.insert_str(\n-            0,\n-            \"<span class=\\\"notable-traits\\\"><span class=\\\"notable-traits-tooltip\\\">\u24d8\\\n-            <span class=\\\"notable-traits-tooltiptext\\\"><span class=\\\"docblock\\\">\",\n-        );\n-        out.push_str(\"</code></span></span></span></span>\");\n+    if out.is_empty() {\n+        return None;\n     }\n \n-    out.into_inner()\n+    out.insert_str(\n+        0,\n+        \"<span class=\\\"notable-traits\\\"><span class=\\\"notable-traits-tooltip\\\">\u24d8\\\n+        <span class=\\\"notable-traits-tooltiptext\\\"><span class=\\\"docblock\\\">\",\n+    );\n+    out.push_str(\"</code></span></span></span></span>\");\n+\n+    Some(out.into_inner())\n }\n \n #[derive(Clone, Copy, Debug)]"}, {"sha": "e6abd23eb951b7e376616ef85733429d89319df7", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8e0cac18cd2951e2679ea55e15242d04e2d410c9/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e0cac18cd2951e2679ea55e15242d04e2d410c9/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=8e0cac18cd2951e2679ea55e15242d04e2d410c9", "patch": "@@ -533,7 +533,12 @@ fn item_function(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, f: &cle\n                 generics = f.generics.print(cx),\n                 where_clause = print_where_clause(&f.generics, cx, 0, Ending::Newline),\n                 decl = f.decl.full_print(header_len, 0, cx),\n-                notable_traits = notable_traits_decl(&f.decl, cx),\n+                notable_traits = f\n+                    .decl\n+                    .output\n+                    .as_return()\n+                    .and_then(|output| notable_traits_decl(output, cx))\n+                    .unwrap_or_default(),\n             );\n         });\n     });"}]}