{"sha": "75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "node_id": "C_kwDOAAsO6NoAKDc1ZjRlZThiNDQyNzI3OGQ3YTM1YjcwMjVlYTcyZTAyYzU1YWU4ZjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-22T05:30:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-22T05:30:00Z"}, "message": "Auto merge of #106025 - matthiaskrgr:rollup-vz5rqah, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #105837 (Don't ICE in `check_must_not_suspend_ty` for mismatched tuple arity)\n - #105932 (Correct branch-protection ModFlagBehavior for Aarch64 on LLVM-15)\n - #105960 (Various cleanups)\n - #105985 (Method chain nitpicks)\n - #105996 (Test that async blocks are `UnwindSafe`)\n - #106012 (Clarify that raw retags are not permitted in Mir)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "66c9d888a81928d77fb3578333f4a5654adf7845", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66c9d888a81928d77fb3578333f4a5654adf7845"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "html_url": "https://github.com/rust-lang/rust/commit/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "857488010837d296a4f3c0c5aadb3c0fa8494ff3", "url": "https://api.github.com/repos/rust-lang/rust/commits/857488010837d296a4f3c0c5aadb3c0fa8494ff3", "html_url": "https://github.com/rust-lang/rust/commit/857488010837d296a4f3c0c5aadb3c0fa8494ff3"}, {"sha": "d0d0ccdca2a32e850b8611f3738e00e11d13123e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0d0ccdca2a32e850b8611f3738e00e11d13123e", "html_url": "https://github.com/rust-lang/rust/commit/d0d0ccdca2a32e850b8611f3738e00e11d13123e"}], "stats": {"total": 280, "additions": 181, "deletions": 99}, "files": [{"sha": "d9ccba07a346a1066e93beea9981566f383b15e9", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -280,29 +280,35 @@ pub unsafe fn create_module<'ll>(\n     }\n \n     if let Some(BranchProtection { bti, pac_ret }) = sess.opts.unstable_opts.branch_protection {\n+        let behavior = if llvm_version >= (15, 0, 0) {\n+            llvm::LLVMModFlagBehavior::Min\n+        } else {\n+            llvm::LLVMModFlagBehavior::Error\n+        };\n+\n         if sess.target.arch == \"aarch64\" {\n             llvm::LLVMRustAddModuleFlag(\n                 llmod,\n-                llvm::LLVMModFlagBehavior::Error,\n+                behavior,\n                 \"branch-target-enforcement\\0\".as_ptr().cast(),\n                 bti.into(),\n             );\n             llvm::LLVMRustAddModuleFlag(\n                 llmod,\n-                llvm::LLVMModFlagBehavior::Error,\n+                behavior,\n                 \"sign-return-address\\0\".as_ptr().cast(),\n                 pac_ret.is_some().into(),\n             );\n             let pac_opts = pac_ret.unwrap_or(PacRet { leaf: false, key: PAuthKey::A });\n             llvm::LLVMRustAddModuleFlag(\n                 llmod,\n-                llvm::LLVMModFlagBehavior::Error,\n+                behavior,\n                 \"sign-return-address-all\\0\".as_ptr().cast(),\n                 pac_opts.leaf.into(),\n             );\n             llvm::LLVMRustAddModuleFlag(\n                 llmod,\n-                llvm::LLVMModFlagBehavior::Error,\n+                behavior,\n                 \"sign-return-address-with-bkey\\0\".as_ptr().cast(),\n                 u32::from(pac_opts.key == PAuthKey::B),\n             );"}, {"sha": "6c78966a98d81d9f6e73c55f5a0d223bb8c6d47b", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -79,6 +79,7 @@ pub enum LLVMModFlagBehavior {\n     Append = 5,\n     AppendUnique = 6,\n     Max = 7,\n+    Min = 8,\n }\n \n // Consts for the LLVM CallConv type, pre-cast to usize."}, {"sha": "94e1b95a0eb3c9501a33f4d3bafecd82c632bd9f", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -9,8 +9,8 @@ use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{\n     traversal, AggregateKind, BasicBlock, BinOp, Body, BorrowKind, CastKind, CopyNonOverlapping,\n     Local, Location, MirPass, MirPhase, NonDivergingIntrinsic, Operand, Place, PlaceElem, PlaceRef,\n-    ProjectionElem, RuntimePhase, Rvalue, SourceScope, Statement, StatementKind, Terminator,\n-    TerminatorKind, UnOp, START_BLOCK,\n+    ProjectionElem, RetagKind, RuntimePhase, Rvalue, SourceScope, Statement, StatementKind,\n+    Terminator, TerminatorKind, UnOp, START_BLOCK,\n };\n use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeVisitable};\n use rustc_mir_dataflow::impls::MaybeStorageLive;\n@@ -667,10 +667,13 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     self.fail(location, \"`Deinit`is not allowed until deaggregation\");\n                 }\n             }\n-            StatementKind::Retag(_, _) => {\n+            StatementKind::Retag(kind, _) => {\n                 // FIXME(JakobDegen) The validator should check that `self.mir_phase <\n                 // DropsLowered`. However, this causes ICEs with generation of drop shims, which\n                 // seem to fail to set their `MirPhase` correctly.\n+                if *kind == RetagKind::Raw || *kind == RetagKind::TwoPhase {\n+                    self.fail(location, format!(\"explicit `{:?}` is forbidden\", kind));\n+                }\n             }\n             StatementKind::StorageLive(..)\n             | StatementKind::StorageDead(..)"}, {"sha": "e4ac91befac610e8f71729bf7be89dacf1ababff", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -607,10 +607,7 @@ fn check_must_not_suspend_ty<'tcx>(\n         ty::Tuple(fields) => {\n             let mut has_emitted = false;\n             let comps = match data.expr.map(|e| &e.kind) {\n-                Some(hir::ExprKind::Tup(comps)) => {\n-                    debug_assert_eq!(comps.len(), fields.len());\n-                    Some(comps)\n-                }\n+                Some(hir::ExprKind::Tup(comps)) if comps.len() == fields.len() => Some(comps),\n                 _ => None,\n             };\n             for (i, ty) in fields.iter().enumerate() {"}, {"sha": "f5cb89fa62463db7acb9d4ea47f66f270c97af48", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -170,6 +170,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n+    #[track_caller]\n     pub fn local_def_id(self, hir_id: HirId) -> LocalDefId {\n         self.opt_local_def_id(hir_id).unwrap_or_else(|| {\n             bug!(\n@@ -310,6 +311,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    #[track_caller]\n     pub fn get_parent_node(self, hir_id: HirId) -> HirId {\n         self.find_parent_node(hir_id)\n             .unwrap_or_else(|| bug!(\"No parent for node {:?}\", self.node_to_string(hir_id)))\n@@ -334,12 +336,14 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n+    #[track_caller]\n     pub fn get(self, id: HirId) -> Node<'hir> {\n         self.find(id).unwrap_or_else(|| bug!(\"couldn't find hir id {} in the HIR map\", id))\n     }\n \n     /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n     #[inline]\n+    #[track_caller]\n     pub fn get_by_def_id(self, id: LocalDefId) -> Node<'hir> {\n         self.find_by_def_id(id).unwrap_or_else(|| bug!(\"couldn't find {:?} in the HIR map\", id))\n     }\n@@ -377,6 +381,7 @@ impl<'hir> Map<'hir> {\n         self.tcx.hir_owner_nodes(id.hir_id.owner).unwrap().bodies[&id.hir_id.local_id]\n     }\n \n+    #[track_caller]\n     pub fn fn_decl_by_hir_id(self, hir_id: HirId) -> Option<&'hir FnDecl<'hir>> {\n         if let Some(node) = self.find(hir_id) {\n             node.fn_decl()\n@@ -385,6 +390,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    #[track_caller]\n     pub fn fn_sig_by_hir_id(self, hir_id: HirId) -> Option<&'hir FnSig<'hir>> {\n         if let Some(node) = self.find(hir_id) {\n             node.fn_sig()\n@@ -393,6 +399,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    #[track_caller]\n     pub fn enclosing_body_owner(self, hir_id: HirId) -> LocalDefId {\n         for (_, node) in self.parent_iter(hir_id) {\n             if let Some(body) = associated_body(node) {\n@@ -408,7 +415,7 @@ impl<'hir> Map<'hir> {\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n     pub fn body_owner(self, BodyId { hir_id }: BodyId) -> HirId {\n         let parent = self.get_parent_node(hir_id);\n-        assert!(self.find(parent).map_or(false, |n| is_body_owner(n, hir_id)));\n+        assert!(self.find(parent).map_or(false, |n| is_body_owner(n, hir_id)), \"{hir_id:?}\");\n         parent\n     }\n \n@@ -419,10 +426,11 @@ impl<'hir> Map<'hir> {\n     /// Given a `LocalDefId`, returns the `BodyId` associated with it,\n     /// if the node is a body owner, otherwise returns `None`.\n     pub fn maybe_body_owned_by(self, id: LocalDefId) -> Option<BodyId> {\n-        self.get_if_local(id.to_def_id()).map(associated_body).flatten()\n+        self.find_by_def_id(id).and_then(associated_body)\n     }\n \n     /// Given a body owner's id, returns the `BodyId` associated with it.\n+    #[track_caller]\n     pub fn body_owned_by(self, id: LocalDefId) -> BodyId {\n         self.maybe_body_owned_by(id).unwrap_or_else(|| {\n             let hir_id = self.local_def_id_to_hir_id(id);"}, {"sha": "bb03359b138f31b0693c1e7a3144d4ee070878f8", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -320,8 +320,10 @@ pub enum StatementKind<'tcx> {\n     /// <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/> for\n     /// more details.\n     ///\n-    /// For code that is not specific to stacked borrows, you should consider retags to read\n-    /// and modify the place in an opaque way.\n+    /// For code that is not specific to stacked borrows, you should consider retags to read and\n+    /// modify the place in an opaque way.\n+    ///\n+    /// Only `RetagKind::Default` and `RetagKind::FnEntry` are permitted.\n     Retag(RetagKind, Box<Place<'tcx>>),\n \n     /// Encodes a user's type ascription. These need to be preserved"}, {"sha": "705adecd3b90f517b9d9c5ed814fdcbaecf4c111", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -70,14 +70,6 @@ impl GenericParamDef {\n         }\n     }\n \n-    pub fn has_default(&self) -> bool {\n-        match self.kind {\n-            GenericParamDefKind::Type { has_default, .. }\n-            | GenericParamDefKind::Const { has_default } => has_default,\n-            GenericParamDefKind::Lifetime => false,\n-        }\n-    }\n-\n     pub fn is_anonymous_lifetime(&self) -> bool {\n         match self.kind {\n             GenericParamDefKind::Lifetime => {"}, {"sha": "cbab4a16e94b6cdd8515943bf8745e264d2a8cbf", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -348,7 +348,7 @@ impl<'tcx> InternalSubsts<'tcx> {\n         substs.reserve(defs.params.len());\n         for param in &defs.params {\n             let kind = mk_kind(param, substs);\n-            assert_eq!(param.index as usize, substs.len());\n+            assert_eq!(param.index as usize, substs.len(), \"{substs:#?}, {defs:#?}\");\n             substs.push(kind);\n         }\n     }"}, {"sha": "d5553f84f7517d8531eb348324bef6c259f44b2c", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -88,9 +88,11 @@ pub trait TypeVisitable<'tcx>: fmt::Debug + Clone {\n         self.has_vars_bound_at_or_above(ty::INNERMOST)\n     }\n \n-    #[instrument(level = \"trace\", ret)]\n     fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.visit_with(&mut HasTypeFlagsVisitor { flags }).break_value() == Some(FoundFlags)\n+        let res =\n+            self.visit_with(&mut HasTypeFlagsVisitor { flags }).break_value() == Some(FoundFlags);\n+        trace!(?self, ?flags, ?res, \"has_type_flags\");\n+        res\n     }\n     fn has_projections(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_PROJECTION)\n@@ -560,10 +562,8 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     type BreakTy = FoundFlags;\n \n     #[inline]\n-    #[instrument(skip(self), level = \"trace\", ret)]\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let flags = t.flags();\n-        trace!(t.flags=?t.flags());\n         if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {\n@@ -572,10 +572,8 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     }\n \n     #[inline]\n-    #[instrument(skip(self), level = \"trace\", ret)]\n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let flags = r.type_flags();\n-        trace!(r.flags=?flags);\n         if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {\n@@ -584,7 +582,6 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     }\n \n     #[inline]\n-    #[instrument(level = \"trace\", ret)]\n     fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let flags = FlagComputation::for_const(c);\n         trace!(r.flags=?flags);\n@@ -596,14 +593,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     }\n \n     #[inline]\n-    #[instrument(level = \"trace\", ret)]\n     fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        debug!(\n-            \"HasTypeFlagsVisitor: predicate={:?} predicate.flags={:?} self.flags={:?}\",\n-            predicate,\n-            predicate.flags(),\n-            self.flags\n-        );\n         if predicate.flags().intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {"}, {"sha": "dca4906c07de54bd2042edccd8ab65a5702e44fb", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -15,9 +15,6 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n             @call(\"mir_retag\", args) => {\n                 Ok(StatementKind::Retag(RetagKind::Default, Box::new(self.parse_place(args[0])?)))\n             },\n-            @call(\"mir_retag_raw\", args) => {\n-                Ok(StatementKind::Retag(RetagKind::Raw, Box::new(self.parse_place(args[0])?)))\n-            },\n             @call(\"mir_set_discriminant\", args) => {\n                 let place = self.parse_place(args[0])?;\n                 let var = self.parse_integer_literal(args[1])? as u32;"}, {"sha": "27c207528c73537c9c8a5a01e7fa595549dc12b4", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/method_chain.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -14,21 +14,27 @@ impl<'a, 'tcx> TypeRelation<'tcx> for CollectAllMismatches<'a, 'tcx> {\n     fn tag(&self) -> &'static str {\n         \"CollectAllMismatches\"\n     }\n+\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n+\n     fn intercrate(&self) -> bool {\n         false\n     }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n+\n     fn a_is_expected(&self) -> bool {\n         true\n-    } // irrelevant\n+    }\n+\n     fn mark_ambiguous(&mut self) {\n         bug!()\n     }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,\n@@ -38,22 +44,28 @@ impl<'a, 'tcx> TypeRelation<'tcx> for CollectAllMismatches<'a, 'tcx> {\n     ) -> RelateResult<'tcx, T> {\n         self.relate(a, b)\n     }\n+\n     fn regions(\n         &mut self,\n         a: ty::Region<'tcx>,\n         _b: ty::Region<'tcx>,\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n         Ok(a)\n     }\n+\n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        if a == b || matches!(a.kind(), ty::Infer(_)) || matches!(b.kind(), ty::Infer(_)) {\n-            return Ok(a);\n-        }\n-        relate::super_relate_tys(self, a, b).or_else(|e| {\n-            self.errors.push(e);\n-            Ok(a)\n+        self.infcx.probe(|_| {\n+            if a.is_ty_infer() || b.is_ty_infer() {\n+                Ok(a)\n+            } else {\n+                self.infcx.super_combine_tys(self, a, b).or_else(|e| {\n+                    self.errors.push(e);\n+                    Ok(a)\n+                })\n+            }\n         })\n     }\n+\n     fn consts(\n         &mut self,\n         a: ty::Const<'tcx>,\n@@ -64,6 +76,7 @@ impl<'a, 'tcx> TypeRelation<'tcx> for CollectAllMismatches<'a, 'tcx> {\n         }\n         relate::super_relate_consts(self, a, b) // could do something similar here for constants!\n     }\n+\n     fn binders<T: Relate<'tcx>>(\n         &mut self,\n         a: ty::Binder<'tcx, T>,"}, {"sha": "eb5e1d5ad5c1da2ca800d3334ebbdebe215c44a8", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 20, "deletions": 31, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -335,7 +335,7 @@ pub trait TypeErrCtxtExt<'tcx> {\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n-    fn function_argument_obligation(\n+    fn note_function_argument_obligation(\n         &self,\n         arg_hir_id: HirId,\n         err: &mut Diagnostic,\n@@ -2909,7 +2909,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 ref parent_code,\n                 ..\n             } => {\n-                self.function_argument_obligation(\n+                self.note_function_argument_obligation(\n                     arg_hir_id,\n                     err,\n                     parent_code,\n@@ -3141,23 +3141,20 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             );\n         }\n     }\n-    fn function_argument_obligation(\n+    fn note_function_argument_obligation(\n         &self,\n         arg_hir_id: HirId,\n         err: &mut Diagnostic,\n         parent_code: &ObligationCauseCode<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        predicate: ty::Predicate<'tcx>,\n+        failed_pred: ty::Predicate<'tcx>,\n         call_hir_id: HirId,\n     ) {\n         let tcx = self.tcx;\n         let hir = tcx.hir();\n-        if let Some(Node::Expr(expr)) = hir.find(arg_hir_id) {\n-            let parent_id = hir.get_parent_item(arg_hir_id);\n-            let typeck_results: &TypeckResults<'tcx> = match &self.typeck_results {\n-                Some(t) if t.hir_owner == parent_id => t,\n-                _ => self.tcx.typeck(parent_id.def_id),\n-            };\n+        if let Some(Node::Expr(expr)) = hir.find(arg_hir_id)\n+            && let Some(typeck_results) = &self.typeck_results\n+        {\n             if let hir::Expr { kind: hir::ExprKind::Block(..), .. } = expr {\n                 let expr = expr.peel_blocks();\n                 let ty = typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error());\n@@ -3182,37 +3179,29 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             let mut type_diffs = vec![];\n \n             if let ObligationCauseCode::ExprBindingObligation(def_id, _, _, idx) = parent_code.deref()\n-                && let predicates = self.tcx.predicates_of(def_id).instantiate_identity(self.tcx)\n-                && let Some(pred) = predicates.predicates.get(*idx)\n+                && let Some(node_substs) = typeck_results.node_substs_opt(call_hir_id)\n+                && let where_clauses = self.tcx.predicates_of(def_id).instantiate(self.tcx, node_substs)\n+                && let Some(where_pred) = where_clauses.predicates.get(*idx)\n             {\n-                if let Ok(trait_pred) = pred.kind().try_map_bound(|pred| match pred {\n-                    ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => Ok(trait_pred),\n-                    _ => Err(()),\n-                })\n-                    && let Ok(trait_predicate) = predicate.kind().try_map_bound(|pred| match pred {\n-                        ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => Ok(trait_pred),\n-                        _ => Err(()),\n-                    })\n+                if let Some(where_pred) = where_pred.to_opt_poly_trait_pred()\n+                    && let Some(failed_pred) = failed_pred.to_opt_poly_trait_pred()\n                 {\n                     let mut c = CollectAllMismatches {\n                         infcx: self.infcx,\n                         param_env,\n                         errors: vec![],\n                     };\n-                    if let Ok(_) = c.relate(trait_pred, trait_predicate) {\n+                    if let Ok(_) = c.relate(where_pred, failed_pred) {\n                         type_diffs = c.errors;\n                     }\n-                } else if let ty::PredicateKind::Clause(\n-                    ty::Clause::Projection(proj)\n-                ) = pred.kind().skip_binder()\n-                    && let ty::PredicateKind::Clause(\n-                        ty::Clause::Projection(projection)\n-                    ) = predicate.kind().skip_binder()\n+                } else if let Some(where_pred) = where_pred.to_opt_poly_projection_pred()\n+                    && let Some(failed_pred) = failed_pred.to_opt_poly_projection_pred()\n+                    && let Some(found) = failed_pred.skip_binder().term.ty()\n                 {\n                     type_diffs = vec![\n                         Sorts(ty::error::ExpectedFound {\n-                            expected: self.tcx.mk_ty(ty::Alias(ty::Projection, proj.projection_ty)),\n-                            found: projection.term.ty().unwrap(),\n+                            expected: self.tcx.mk_ty(ty::Alias(ty::Projection, where_pred.skip_binder().projection_ty)),\n+                            found,\n                         }),\n                     ];\n                 }\n@@ -3227,9 +3216,9 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 // If the expression we're calling on is a binding, we want to point at the\n                 // `let` when talking about the type. Otherwise we'll point at every part\n                 // of the method chain with the type.\n-                self.point_at_chain(binding_expr, typeck_results, type_diffs, param_env, err);\n+                self.point_at_chain(binding_expr, &typeck_results, type_diffs, param_env, err);\n             } else {\n-                self.point_at_chain(expr, typeck_results, type_diffs, param_env, err);\n+                self.point_at_chain(expr, &typeck_results, type_diffs, param_env, err);\n             }\n         }\n         let call_node = hir.find(call_hir_id);"}, {"sha": "920c31233c18799a254a9f82282f8dbc30a56371", "filename": "library/core/src/const_closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/library%2Fcore%2Fsrc%2Fconst_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/library%2Fcore%2Fsrc%2Fconst_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconst_closure.rs?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -51,7 +51,7 @@ macro_rules! impl_fn_mut_tuple {\n         impl<'a, $($var,)* ClosureArguments, Function, ClosureReturnValue> const\n             FnOnce<ClosureArguments> for ConstFnMutClosure<($(&'a mut $var),*), Function>\n         where\n-            Function: ~const Fn(($(&mut $var),*), ClosureArguments) -> ClosureReturnValue+ ~const Destruct,\n+            Function: ~const Fn(($(&mut $var),*), ClosureArguments) -> ClosureReturnValue + ~const Destruct,\n         {\n             type Output = ClosureReturnValue;\n \n@@ -64,7 +64,7 @@ macro_rules! impl_fn_mut_tuple {\n         impl<'a, $($var,)* ClosureArguments, Function, ClosureReturnValue> const\n             FnMut<ClosureArguments> for ConstFnMutClosure<($(&'a mut $var),*), Function>\n         where\n-            Function: ~const Fn(($(&mut $var),*), ClosureArguments)-> ClosureReturnValue,\n+            Function: ~const Fn(($(&mut $var),*), ClosureArguments)-> ClosureReturnValue + ~const Destruct,\n         {\n             extern \"rust-call\" fn call_mut(&mut self, args: ClosureArguments) -> Self::Output {\n                 #[allow(non_snake_case)]"}, {"sha": "71a0d1825efec359cdf4b11fa9717ca2d082118f", "filename": "library/core/src/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -199,7 +199,7 @@ pub trait Hash {\n     /// println!(\"Hash is {:x}!\", hasher.finish());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn hash<H: Hasher>(&self, state: &mut H);\n+    fn hash<H: ~const Hasher>(&self, state: &mut H);\n \n     /// Feeds a slice of this type into the given [`Hasher`].\n     ///\n@@ -980,7 +980,7 @@ mod impls {\n     #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n     impl<T: ?Sized + ~const Hash> const Hash for &mut T {\n         #[inline]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n+        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n             (**self).hash(state);\n         }\n     }"}, {"sha": "9e7099ddfd1e1d98756d5b7624e0da4e20eca346", "filename": "library/core/src/intrinsics/mir.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -259,7 +259,6 @@ define!(\"mir_drop\", fn Drop<T>(place: T, goto: BasicBlock));\n define!(\"mir_drop_and_replace\", fn DropAndReplace<T>(place: T, value: T, goto: BasicBlock));\n define!(\"mir_call\", fn Call<T>(place: T, goto: BasicBlock, call: T));\n define!(\"mir_retag\", fn Retag<T>(place: T));\n-define!(\"mir_retag_raw\", fn RetagRaw<T>(place: T));\n define!(\"mir_move\", fn Move<T>(place: T) -> T);\n define!(\"mir_static\", fn Static<T>(s: T) -> &'static T);\n define!(\"mir_static_mut\", fn StaticMut<T>(s: T) -> *mut T);"}, {"sha": "228efb0bc0a5c41b95507952d0fdafaf7678a578", "filename": "library/core/src/ops/index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/library%2Fcore%2Fsrc%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/library%2Fcore%2Fsrc%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Findex.rs?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -165,7 +165,7 @@ see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#ind\n #[doc(alias = \"]\")]\n #[doc(alias = \"[]\")]\n #[const_trait]\n-pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n+pub trait IndexMut<Idx: ?Sized>: ~const Index<Idx> {\n     /// Performs the mutable indexing (`container[index]`) operation.\n     ///\n     /// # Panics"}, {"sha": "f5ee112623541519731735298cd5b3ef5aab3c02", "filename": "src/test/mir-opt/building/custom/references.immut_ref.built.after.mir", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.immut_ref.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.immut_ref.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.immut_ref.built.after.mir?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -6,9 +6,8 @@ fn immut_ref(_1: &i32) -> &i32 {\n \n     bb0: {\n         _2 = &raw const (*_1);           // scope 0 at $DIR/references.rs:+5:13: +5:29\n-        Retag([raw] _2);                 // scope 0 at $DIR/references.rs:+6:13: +6:24\n-        _0 = &(*_2);                     // scope 0 at $DIR/references.rs:+7:13: +7:23\n-        Retag(_0);                       // scope 0 at $DIR/references.rs:+8:13: +8:23\n-        return;                          // scope 0 at $DIR/references.rs:+9:13: +9:21\n+        _0 = &(*_2);                     // scope 0 at $DIR/references.rs:+6:13: +6:23\n+        Retag(_0);                       // scope 0 at $DIR/references.rs:+7:13: +7:23\n+        return;                          // scope 0 at $DIR/references.rs:+8:13: +8:21\n     }\n }"}, {"sha": "8e2ffc33b1a0afabb9e26ad87691060905864c31", "filename": "src/test/mir-opt/building/custom/references.mut_ref.built.after.mir", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.mut_ref.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.mut_ref.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.mut_ref.built.after.mir?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -6,9 +6,8 @@ fn mut_ref(_1: &mut i32) -> &mut i32 {\n \n     bb0: {\n         _2 = &raw mut (*_1);             // scope 0 at $DIR/references.rs:+5:13: +5:33\n-        Retag([raw] _2);                 // scope 0 at $DIR/references.rs:+6:13: +6:24\n-        _0 = &mut (*_2);                 // scope 0 at $DIR/references.rs:+7:13: +7:26\n-        Retag(_0);                       // scope 0 at $DIR/references.rs:+8:13: +8:23\n-        return;                          // scope 0 at $DIR/references.rs:+9:13: +9:21\n+        _0 = &mut (*_2);                 // scope 0 at $DIR/references.rs:+6:13: +6:26\n+        Retag(_0);                       // scope 0 at $DIR/references.rs:+7:13: +7:23\n+        return;                          // scope 0 at $DIR/references.rs:+8:13: +8:21\n     }\n }"}, {"sha": "a1c896de04cf0185e7b0a7a1fcaf32da06a8e82c", "filename": "src/test/mir-opt/building/custom/references.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.rs?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -12,7 +12,6 @@ pub fn mut_ref(x: &mut i32) -> &mut i32 {\n \n         {\n             t = addr_of_mut!(*x);\n-            RetagRaw(t);\n             RET = &mut *t;\n             Retag(RET);\n             Return()\n@@ -28,7 +27,6 @@ pub fn immut_ref(x: &i32) -> &i32 {\n \n         {\n             t = addr_of!(*x);\n-            RetagRaw(t);\n             RET = & *t;\n             Retag(RET);\n             Return()"}, {"sha": "56ed2847292d186fecd5d20487b076ae23be7e87", "filename": "src/test/ui/async-await/async-is-unwindsafe.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/src%2Ftest%2Fui%2Fasync-await%2Fasync-is-unwindsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/src%2Ftest%2Fui%2Fasync-await%2Fasync-is-unwindsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-is-unwindsafe.rs?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -0,0 +1,30 @@\n+// edition:2018\n+\n+fn is_unwindsafe(_: impl std::panic::UnwindSafe) {}\n+\n+fn main() {\n+    // A normal future created by an async block takes a `&mut Context<'_>` argument.\n+    // That should not leak through to the whole async block.\n+    is_unwindsafe(async {\n+        async {}.await; // this needs an inner await point\n+    });\n+\n+    is_unwindsafe(async {\n+        //~^ ERROR the type `&mut Context<'_>` may not be safely transferred across an unwind boundary\n+        use std::ptr::null;\n+        use std::task::{Context, RawWaker, RawWakerVTable, Waker};\n+        let waker = unsafe {\n+            Waker::from_raw(RawWaker::new(\n+                null(),\n+                &RawWakerVTable::new(|_| todo!(), |_| todo!(), |_| todo!(), |_| todo!()),\n+            ))\n+        };\n+        let mut cx = Context::from_waker(&waker);\n+        let cx_ref = &mut cx;\n+\n+        async {}.await; // this needs an inner await point\n+\n+        // in this case, `&mut Context<'_>` is *truly* alive across an await point\n+        drop(cx_ref);\n+    });\n+}"}, {"sha": "d6404b30e74f1bffc4b0ec450ee3271ee2f978e6", "filename": "src/test/ui/async-await/async-is-unwindsafe.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/src%2Ftest%2Fui%2Fasync-await%2Fasync-is-unwindsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/src%2Ftest%2Fui%2Fasync-await%2Fasync-is-unwindsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-is-unwindsafe.stderr?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -0,0 +1,38 @@\n+error[E0277]: the type `&mut Context<'_>` may not be safely transferred across an unwind boundary\n+  --> $DIR/async-is-unwindsafe.rs:12:19\n+   |\n+LL |       is_unwindsafe(async {\n+   |  ___________________^\n+LL | |\n+LL | |         use std::ptr::null;\n+LL | |         use std::task::{Context, RawWaker, RawWakerVTable, Waker};\n+...  |\n+LL | |         drop(cx_ref);\n+LL | |     });\n+   | |     ^\n+   | |     |\n+   | |_____`&mut Context<'_>` may not be safely transferred across an unwind boundary\n+   |       within this `[async block@$DIR/async-is-unwindsafe.rs:12:19: 29:6]`\n+   |\n+   = help: within `[async block@$DIR/async-is-unwindsafe.rs:12:19: 29:6]`, the trait `UnwindSafe` is not implemented for `&mut Context<'_>`\n+   = note: `UnwindSafe` is implemented for `&std::task::Context<'_>`, but not for `&mut std::task::Context<'_>`\n+note: future does not implement `UnwindSafe` as this value is used across an await\n+  --> $DIR/async-is-unwindsafe.rs:25:17\n+   |\n+LL |         let cx_ref = &mut cx;\n+   |             ------ has type `&mut Context<'_>` which does not implement `UnwindSafe`\n+LL |\n+LL |         async {}.await; // this needs an inner await point\n+   |                 ^^^^^^ await occurs here, with `cx_ref` maybe used later\n+...\n+LL |     });\n+   |     - `cx_ref` is later dropped here\n+note: required by a bound in `is_unwindsafe`\n+  --> $DIR/async-is-unwindsafe.rs:3:26\n+   |\n+LL | fn is_unwindsafe(_: impl std::panic::UnwindSafe) {}\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_unwindsafe`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "f3dceca7e4139365646a9b4d8f1ccefb9bedcb8f", "filename": "src/test/ui/iterators/invalid-iterator-chain.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -52,14 +52,14 @@ LL |             .sum::<i32>(),\n              <i32 as Sum<&'a i32>>\n              <i32 as Sum>\n note: the method call chain might not have had the expected associated types\n-  --> $DIR/invalid-iterator-chain.rs:20:14\n+  --> $DIR/invalid-iterator-chain.rs:25:14\n    |\n LL |         vec![0, 1]\n    |         ---------- this expression has type `Vec<{integer}>`\n LL |             .iter()\n    |              ------ `Iterator::Item` is `&{integer}` here\n LL |             .map(|x| x * 2)\n-   |              ^^^^^^^^^^^^^^ `Iterator::Item` changed to `{integer}` here\n+   |              -------------- `Iterator::Item` changed to `{integer}` here\n LL |             .map(|x| x as f64)\n    |              ----------------- `Iterator::Item` changed to `f64` here\n LL |             .map(|x| x as i64)\n@@ -84,14 +84,14 @@ LL |             .sum::<i32>(),\n              <i32 as Sum<&'a i32>>\n              <i32 as Sum>\n note: the method call chain might not have had the expected associated types\n-  --> $DIR/invalid-iterator-chain.rs:32:14\n+  --> $DIR/invalid-iterator-chain.rs:33:14\n    |\n LL |         vec![0, 1]\n    |         ---------- this expression has type `Vec<{integer}>`\n LL |             .iter()\n    |              ------ `Iterator::Item` is `&{integer}` here\n LL |             .map(|x| x * 2)\n-   |              ^^^^^^^^^^^^^^ `Iterator::Item` changed to `{integer}` here\n+   |              -------------- `Iterator::Item` changed to `{integer}` here\n LL |             .map(|x| x as f64)\n    |              ^^^^^^^^^^^^^^^^^ `Iterator::Item` changed to `f64` here\n LL |             .filter(|x| *x > 0.0)"}, {"sha": "c7e14e4256138d9dbe3d6443a60f571e14119f4a", "filename": "src/test/ui/lint/must_not_suspend/tuple-mismatch.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Ftuple-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Ftuple-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Ftuple-mismatch.rs?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -0,0 +1,9 @@\n+#![feature(generators)]\n+\n+fn main() {\n+    let _generator = || {\n+        yield ((), ((), ()));\n+        yield ((), ());\n+        //~^ ERROR mismatched types\n+    };\n+}"}, {"sha": "cca8cd9bd89f16ce5e9b3aecc24c6ed5f4cf58dc", "filename": "src/test/ui/lint/must_not_suspend/tuple-mismatch.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Ftuple-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75f4ee8b4427278d7a35b7025ea72e02c55ae8f1/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Ftuple-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fmust_not_suspend%2Ftuple-mismatch.stderr?ref=75f4ee8b4427278d7a35b7025ea72e02c55ae8f1", "patch": "@@ -0,0 +1,12 @@\n+error[E0308]: mismatched types\n+  --> $DIR/tuple-mismatch.rs:6:20\n+   |\n+LL |         yield ((), ());\n+   |                    ^^ expected tuple, found `()`\n+   |\n+   = note:  expected tuple `((), ())`\n+           found unit type `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}