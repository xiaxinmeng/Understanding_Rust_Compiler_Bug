{"sha": "026339e42ba11a559767029d933d1197aefb877a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyNjMzOWU0MmJhMTFhNTU5NzY3MDI5ZDkzM2QxMTk3YWVmYjg3N2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-25T02:07:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-25T02:07:14Z"}, "message": "Auto merge of #48520 - Manishearth:rollup, r=Manishearth\n\nRollup of 15 pull requests\n\n- Successful merges: #47689, #48110, #48197, #48296, #48386, #48392, #48404, #48415, #48441, #48448, #48452, #48481, #48490, #48499, #48503\n- Failed merges:", "tree": {"sha": "884a690f24c660b4ece0ea6818846920f82631f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/884a690f24c660b4ece0ea6818846920f82631f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/026339e42ba11a559767029d933d1197aefb877a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/026339e42ba11a559767029d933d1197aefb877a", "html_url": "https://github.com/rust-lang/rust/commit/026339e42ba11a559767029d933d1197aefb877a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/026339e42ba11a559767029d933d1197aefb877a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28a1e4ffefa2620ad9f4179ea339833448874fd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/28a1e4ffefa2620ad9f4179ea339833448874fd3", "html_url": "https://github.com/rust-lang/rust/commit/28a1e4ffefa2620ad9f4179ea339833448874fd3"}, {"sha": "52047f0ba0d1b1144073963b9b009399d32fb984", "url": "https://api.github.com/repos/rust-lang/rust/commits/52047f0ba0d1b1144073963b9b009399d32fb984", "html_url": "https://github.com/rust-lang/rust/commit/52047f0ba0d1b1144073963b9b009399d32fb984"}], "stats": {"total": 1487, "additions": 941, "deletions": 546}, "files": [{"sha": "7836ad214edc426a8ba2fcf80b937684d3b32a74", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -313,7 +313,7 @@ impl Step for TestHelpers {\n     type Output = ();\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/rt/rust_test_helpers.c\")\n+        run.path(\"src/test/auxiliary/rust_test_helpers.c\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -326,7 +326,7 @@ impl Step for TestHelpers {\n         let build = builder.build;\n         let target = self.target;\n         let dst = build.test_helpers_out(target);\n-        let src = build.src.join(\"src/rt/rust_test_helpers.c\");\n+        let src = build.src.join(\"src/test/auxiliary/rust_test_helpers.c\");\n         if up_to_date(&src, &dst.join(\"librust_test_helpers.a\")) {\n             return\n         }\n@@ -353,7 +353,7 @@ impl Step for TestHelpers {\n            .opt_level(0)\n            .warnings(false)\n            .debug(false)\n-           .file(build.src.join(\"src/rt/rust_test_helpers.c\"))\n+           .file(build.src.join(\"src/test/auxiliary/rust_test_helpers.c\"))\n            .compile(\"rust_test_helpers\");\n     }\n }"}, {"sha": "98921e9de849acdaeaed08cfad6758bb89769b7d", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -1 +1 @@\n-Subproject commit ec5660820dea91df470dab0b9eb26ef798f20889\n+Subproject commit 98921e9de849acdaeaed08cfad6758bb89769b7d"}, {"sha": "75a59de337cef3e01e49eb5a7cb92c0645fe136a", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -359,8 +359,6 @@ impl<T: ?Sized> Box<T> {\n     /// Simple usage:\n     ///\n     /// ```\n-    /// #![feature(box_leak)]\n-    ///\n     /// fn main() {\n     ///     let x = Box::new(41);\n     ///     let static_ref: &'static mut usize = Box::leak(x);\n@@ -372,17 +370,14 @@ impl<T: ?Sized> Box<T> {\n     /// Unsized data:\n     ///\n     /// ```\n-    /// #![feature(box_leak)]\n-    ///\n     /// fn main() {\n     ///     let x = vec![1, 2, 3].into_boxed_slice();\n     ///     let static_ref = Box::leak(x);\n     ///     static_ref[0] = 4;\n     ///     assert_eq!(*static_ref, [4, 2, 3]);\n     /// }\n     /// ```\n-    #[unstable(feature = \"box_leak\", reason = \"needs an FCP to stabilize\",\n-               issue = \"46179\")]\n+    #[stable(feature = \"box_leak\", since = \"1.26.0\")]\n     #[inline]\n     pub fn leak<'a>(b: Box<T>) -> &'a mut T\n     where"}, {"sha": "89ed47ea194fb7e51859e9748946561b024046d6", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -2956,7 +2956,7 @@ impl<'a> LoweringContext<'a> {\n \n             // Desugar ExprIfLet\n             // From: `if let <pat> = <sub_expr> <body> [<else_opt>]`\n-            ExprKind::IfLet(ref pat, ref sub_expr, ref body, ref else_opt) => {\n+            ExprKind::IfLet(ref pats, ref sub_expr, ref body, ref else_opt) => {\n                 // to:\n                 //\n                 //   match <sub_expr> {\n@@ -2970,8 +2970,8 @@ impl<'a> LoweringContext<'a> {\n                 {\n                     let body = self.lower_block(body, false);\n                     let body_expr = P(self.expr_block(body, ThinVec::new()));\n-                    let pat = self.lower_pat(pat);\n-                    arms.push(self.arm(hir_vec![pat], body_expr));\n+                    let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+                    arms.push(self.arm(pats, body_expr));\n                 }\n \n                 // _ => [<else_opt>|()]\n@@ -3000,7 +3000,7 @@ impl<'a> LoweringContext<'a> {\n \n             // Desugar ExprWhileLet\n             // From: `[opt_ident]: while let <pat> = <sub_expr> <body>`\n-            ExprKind::WhileLet(ref pat, ref sub_expr, ref body, opt_label) => {\n+            ExprKind::WhileLet(ref pats, ref sub_expr, ref body, opt_label) => {\n                 // to:\n                 //\n                 //   [opt_ident]: loop {\n@@ -3021,8 +3021,8 @@ impl<'a> LoweringContext<'a> {\n                 // `<pat> => <body>`\n                 let pat_arm = {\n                     let body_expr = P(self.expr_block(body, ThinVec::new()));\n-                    let pat = self.lower_pat(pat);\n-                    self.arm(hir_vec![pat], body_expr)\n+                    let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+                    self.arm(pats, body_expr)\n                 };\n \n                 // `_ => break`"}, {"sha": "71a57dbf32fb180b8bac1c01e9e2f1a9a4cf9594", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -56,8 +56,19 @@ for ty::subst::Kind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        self.as_type().hash_stable(hcx, hasher);\n-        self.as_region().hash_stable(hcx, hasher);\n+        self.unpack().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+for ty::subst::UnpackedKind<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        match self {\n+            ty::subst::UnpackedKind::Lifetime(lt) => lt.hash_stable(hcx, hasher),\n+            ty::subst::UnpackedKind::Type(ty) => ty.hash_stable(hcx, hasher),\n+        }\n     }\n }\n "}, {"sha": "a749d0dddd7eeea31863271ecbce1de5f6297008", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -17,7 +17,7 @@ use traits::{self, PredicateObligation};\n use ty::{self, Ty};\n use ty::fold::{BottomUpFolder, TypeFoldable};\n use ty::outlives::Component;\n-use ty::subst::{Kind, Substs};\n+use ty::subst::{Kind, UnpackedKind, Substs};\n use util::nodemap::DefIdMap;\n \n pub type AnonTypeMap<'tcx> = DefIdMap<AnonTypeDecl<'tcx>>;\n@@ -321,7 +321,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             let index = region_def.index as usize;\n \n             // Get the value supplied for this region from the substs.\n-            let subst_arg = anon_defn.substs[index].as_region().unwrap();\n+            let subst_arg = anon_defn.substs.region_at(index);\n \n             // Compute the least upper bound of it with the other regions.\n             debug!(\"constrain_anon_types: least_region={:?}\", least_region);\n@@ -466,7 +466,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // All other regions, we map them appropriately to their adjusted\n                 // indices, erroring if we find any lifetimes that were not mapped\n                 // into the new set.\n-                _ => if let Some(r1) = map.get(&Kind::from(r)).and_then(|k| k.as_region()) {\n+                _ => if let Some(UnpackedKind::Lifetime(r1)) = map.get(&r.into())\n+                                                                  .map(|k| k.unpack()) {\n                     r1\n                 } else {\n                     // No mapping was found. This means that"}, {"sha": "49f43b18e61987fd005f1aec103f9fe530cdbc65", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -73,7 +73,7 @@ pub enum IntercrateMode {\n /// either identifying an `impl` (e.g., `impl Eq for int`) that\n /// provides the required vtable, or else finding a bound that is in\n /// scope. The eventual result is usually a `Selection` (defined below).\n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, Hash)]\n pub struct Obligation<'tcx, T> {\n     pub cause: ObligationCause<'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n@@ -85,7 +85,7 @@ pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n \n /// Why did we incur this obligation? Used for error reporting.\n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct ObligationCause<'tcx> {\n     pub span: Span,\n \n@@ -113,7 +113,7 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from span.\n     MiscObligation,\n@@ -215,7 +215,7 @@ pub enum ObligationCauseCode<'tcx> {\n     BlockTailExpression(ast::NodeId),\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct DerivedObligationCause<'tcx> {\n     /// The trait reference of the parent obligation that led to the\n     /// current obligation. Note that only trait obligations lead to\n@@ -304,7 +304,7 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n /// ### The type parameter `N`\n ///\n /// See explanation on `VtableImplData`.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum Vtable<'tcx, N> {\n     /// Vtable identifying a particular impl.\n     VtableImpl(VtableImplData<'tcx, N>),\n@@ -374,13 +374,13 @@ pub struct VtableClosureData<'tcx, N> {\n     pub nested: Vec<N>\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub struct VtableAutoImplData<N> {\n     pub trait_def_id: DefId,\n     pub nested: Vec<N>\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub struct VtableBuiltinData<N> {\n     pub nested: Vec<N>\n }"}, {"sha": "1778a8d693a832fc6c1e9a2a010e12eacca3a8d6", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 112, "deletions": 109, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -16,6 +16,7 @@ use super::translate_substs;\n use super::Obligation;\n use super::ObligationCause;\n use super::PredicateObligation;\n+use super::Selection;\n use super::SelectionContext;\n use super::SelectionError;\n use super::VtableClosureData;\n@@ -101,7 +102,7 @@ pub struct MismatchedProjectionTypes<'tcx> {\n     pub err: ty::error::TypeError<'tcx>\n }\n \n-#[derive(PartialEq, Eq, PartialOrd, Ord, Debug)]\n+#[derive(PartialEq, Eq, Debug)]\n enum ProjectionTyCandidate<'tcx> {\n     // from a where-clause in the env or object type\n     ParamEnv(ty::PolyProjectionPredicate<'tcx>),\n@@ -110,12 +111,59 @@ enum ProjectionTyCandidate<'tcx> {\n     TraitDef(ty::PolyProjectionPredicate<'tcx>),\n \n     // from a \"impl\" (or a \"pseudo-impl\" returned by select)\n-    Select,\n+    Select(Selection<'tcx>),\n }\n \n-struct ProjectionTyCandidateSet<'tcx> {\n-    vec: Vec<ProjectionTyCandidate<'tcx>>,\n-    ambiguous: bool\n+enum ProjectionTyCandidateSet<'tcx> {\n+    None,\n+    Single(ProjectionTyCandidate<'tcx>),\n+    Ambiguous,\n+    Error(SelectionError<'tcx>),\n+}\n+\n+impl<'tcx> ProjectionTyCandidateSet<'tcx> {\n+    fn mark_ambiguous(&mut self) {\n+        *self = ProjectionTyCandidateSet::Ambiguous;\n+    }\n+\n+    fn mark_error(&mut self, err: SelectionError<'tcx>) {\n+        *self = ProjectionTyCandidateSet::Error(err);\n+    }\n+\n+    // Returns true if the push was successful, or false if the candidate\n+    // was discarded -- this could be because of ambiguity, or because\n+    // a higher-priority candidate is already there.\n+    fn push_candidate(&mut self, candidate: ProjectionTyCandidate<'tcx>) -> bool {\n+        use self::ProjectionTyCandidateSet::*;\n+        use self::ProjectionTyCandidate::*;\n+        match self {\n+            None => {\n+                *self = Single(candidate);\n+                true\n+            }\n+            Single(current) => {\n+                // No duplicates are expected.\n+                assert_ne!(current, &candidate);\n+                // Prefer where-clauses. As in select, if there are multiple\n+                // candidates, we prefer where-clause candidates over impls.  This\n+                // may seem a bit surprising, since impls are the source of\n+                // \"truth\" in some sense, but in fact some of the impls that SEEM\n+                // applicable are not, because of nested obligations. Where\n+                // clauses are the safer choice. See the comment on\n+                // `select::SelectionCandidate` and #21974 for more details.\n+                match (current, candidate) {\n+                    (ParamEnv(..), ParamEnv(..)) => { *self = Ambiguous; }\n+                    (ParamEnv(..), _) => {}\n+                    (_, ParamEnv(..)) => { unreachable!(); }\n+                    (_, _) => { *self = Ambiguous; }\n+                }\n+                false\n+            }\n+            Ambiguous | Error(..) => {\n+                false\n+            }\n+        }\n+    }\n }\n \n /// Evaluates constraints of the form:\n@@ -803,11 +851,11 @@ fn project_type<'cx, 'gcx, 'tcx>(\n         return Ok(ProjectedTy::Progress(Progress::error(selcx.tcx())));\n     }\n \n-    let mut candidates = ProjectionTyCandidateSet {\n-        vec: Vec::new(),\n-        ambiguous: false,\n-    };\n+    let mut candidates = ProjectionTyCandidateSet::None;\n \n+    // Make sure that the following procedures are kept in order. ParamEnv\n+    // needs to be first because it has highest priority, and Select checks\n+    // the return value of push_candidate which assumes it's ran at last.\n     assemble_candidates_from_param_env(selcx,\n                                        obligation,\n                                        &obligation_trait_ref,\n@@ -818,67 +866,27 @@ fn project_type<'cx, 'gcx, 'tcx>(\n                                        &obligation_trait_ref,\n                                        &mut candidates);\n \n-    if let Err(e) = assemble_candidates_from_impls(selcx,\n-                                                   obligation,\n-                                                   &obligation_trait_ref,\n-                                                   &mut candidates) {\n-        return Err(ProjectionTyError::TraitSelectionError(e));\n-    }\n-\n-    debug!(\"{} candidates, ambiguous={}\",\n-           candidates.vec.len(),\n-           candidates.ambiguous);\n-\n-    // Inherent ambiguity that prevents us from even enumerating the\n-    // candidates.\n-    if candidates.ambiguous {\n-        return Err(ProjectionTyError::TooManyCandidates);\n-    }\n-\n-    // Drop duplicates.\n-    //\n-    // Note: `candidates.vec` seems to be on the critical path of the\n-    // compiler. Replacing it with an HashSet was also tried, which would\n-    // render the following dedup unnecessary. The original comment indicated\n-    // that it was 9% slower, but that data is now obsolete and a new\n-    // benchmark should be performed.\n-    candidates.vec.sort_unstable();\n-    candidates.vec.dedup();\n-\n-    // Prefer where-clauses. As in select, if there are multiple\n-    // candidates, we prefer where-clause candidates over impls.  This\n-    // may seem a bit surprising, since impls are the source of\n-    // \"truth\" in some sense, but in fact some of the impls that SEEM\n-    // applicable are not, because of nested obligations. Where\n-    // clauses are the safer choice. See the comment on\n-    // `select::SelectionCandidate` and #21974 for more details.\n-    if candidates.vec.len() > 1 {\n-        debug!(\"retaining param-env candidates only from {:?}\", candidates.vec);\n-        candidates.vec.retain(|c| match *c {\n-            ProjectionTyCandidate::ParamEnv(..) => true,\n-            ProjectionTyCandidate::TraitDef(..) |\n-            ProjectionTyCandidate::Select => false,\n-        });\n-        debug!(\"resulting candidate set: {:?}\", candidates.vec);\n-        if candidates.vec.len() != 1 {\n-            return Err(ProjectionTyError::TooManyCandidates);\n-        }\n-    }\n-\n-    assert!(candidates.vec.len() <= 1);\n+    assemble_candidates_from_impls(selcx,\n+                                   obligation,\n+                                   &obligation_trait_ref,\n+                                   &mut candidates);\n+\n+    match candidates {\n+        ProjectionTyCandidateSet::Single(candidate) => Ok(ProjectedTy::Progress(\n+            confirm_candidate(selcx,\n+                              obligation,\n+                              &obligation_trait_ref,\n+                              candidate))),\n+        ProjectionTyCandidateSet::None => Ok(ProjectedTy::NoProgress(\n+            selcx.tcx().mk_projection(\n+                obligation.predicate.item_def_id,\n+                obligation.predicate.substs))),\n+        // Error occurred while trying to processing impls.\n+        ProjectionTyCandidateSet::Error(e) => Err(ProjectionTyError::TraitSelectionError(e)),\n+        // Inherent ambiguity that prevents us from even enumerating the\n+        // candidates.\n+        ProjectionTyCandidateSet::Ambiguous => Err(ProjectionTyError::TooManyCandidates),\n \n-    match candidates.vec.pop() {\n-        Some(candidate) => {\n-            Ok(ProjectedTy::Progress(\n-                confirm_candidate(selcx,\n-                                  obligation,\n-                                  &obligation_trait_ref,\n-                                  candidate)))\n-        }\n-        None => Ok(ProjectedTy::NoProgress(\n-                    selcx.tcx().mk_projection(\n-                        obligation.predicate.item_def_id,\n-                        obligation.predicate.substs)))\n     }\n }\n \n@@ -928,7 +936,7 @@ fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n         ty::TyInfer(ty::TyVar(_)) => {\n             // If the self-type is an inference variable, then it MAY wind up\n             // being a projected type, so induce an ambiguity.\n-            candidate_set.ambiguous = true;\n+            candidate_set.mark_ambiguous();\n             return;\n         }\n         _ => { return; }\n@@ -962,7 +970,7 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n         debug!(\"assemble_candidates_from_predicates: predicate={:?}\",\n                predicate);\n         match predicate {\n-            ty::Predicate::Projection(ref data) => {\n+            ty::Predicate::Projection(data) => {\n                 let same_def_id =\n                     data.0.projection_ty.item_def_id == obligation.predicate.item_def_id;\n \n@@ -985,10 +993,10 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n                        data, is_match, same_def_id);\n \n                 if is_match {\n-                    candidate_set.vec.push(ctor(data.clone()));\n+                    candidate_set.push_candidate(ctor(data));\n                 }\n             }\n-            _ => { }\n+            _ => {}\n         }\n     }\n }\n@@ -998,37 +1006,36 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n-    -> Result<(), SelectionError<'tcx>>\n {\n     // If we are resolving `<T as TraitRef<...>>::Item == Type`,\n     // start out by selecting the predicate `T as TraitRef<...>`:\n     let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n     let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n-    selcx.infcx().probe(|_| {\n+    let _ = selcx.infcx().commit_if_ok(|_| {\n         let vtable = match selcx.select(&trait_obligation) {\n             Ok(Some(vtable)) => vtable,\n             Ok(None) => {\n-                candidate_set.ambiguous = true;\n-                return Ok(());\n+                candidate_set.mark_ambiguous();\n+                return Err(());\n             }\n             Err(e) => {\n                 debug!(\"assemble_candidates_from_impls: selection error {:?}\",\n                        e);\n-                return Err(e);\n+                candidate_set.mark_error(e);\n+                return Err(());\n             }\n         };\n \n-        match vtable {\n+        let eligible = match &vtable {\n             super::VtableClosure(_) |\n             super::VtableGenerator(_) |\n             super::VtableFnPointer(_) |\n             super::VtableObject(_) => {\n                 debug!(\"assemble_candidates_from_impls: vtable={:?}\",\n                        vtable);\n-\n-                candidate_set.vec.push(ProjectionTyCandidate::Select);\n+                true\n             }\n-            super::VtableImpl(ref impl_data) => {\n+            super::VtableImpl(impl_data) => {\n                 // We have to be careful when projecting out of an\n                 // impl because of specialization. If we are not in\n                 // trans (i.e., projection mode is not \"any\"), and the\n@@ -1072,27 +1079,25 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                     node_item.item.defaultness.has_value()\n                 } else {\n                     node_item.item.defaultness.is_default() ||\n-                    selcx.tcx().impl_is_default(node_item.node.def_id())\n+                        selcx.tcx().impl_is_default(node_item.node.def_id())\n                 };\n \n                 // Only reveal a specializable default if we're past type-checking\n                 // and the obligations is monomorphic, otherwise passes such as\n                 // transmute checking and polymorphic MIR optimizations could\n                 // get a result which isn't correct for all monomorphizations.\n-                let new_candidate = if !is_default {\n-                    Some(ProjectionTyCandidate::Select)\n+                if !is_default {\n+                    true\n                 } else if obligation.param_env.reveal == Reveal::All {\n                     assert!(!poly_trait_ref.needs_infer());\n                     if !poly_trait_ref.needs_subst() {\n-                        Some(ProjectionTyCandidate::Select)\n+                        true\n                     } else {\n-                        None\n+                        false\n                     }\n                 } else {\n-                    None\n-                };\n-\n-                candidate_set.vec.extend(new_candidate);\n+                    false\n+                }\n             }\n             super::VtableParam(..) => {\n                 // This case tell us nothing about the value of an\n@@ -1120,6 +1125,7 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                 // in the compiler: a trait predicate (`T : SomeTrait`) and a\n                 // projection. And the projection where clause is handled\n                 // in `assemble_candidates_from_param_env`.\n+                false\n             }\n             super::VtableAutoImpl(..) |\n             super::VtableBuiltin(..) => {\n@@ -1129,10 +1135,18 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                     \"Cannot project an associated type from `{:?}`\",\n                     vtable);\n             }\n-        }\n+        };\n \n-        Ok(())\n-    })\n+        if eligible {\n+            if candidate_set.push_candidate(ProjectionTyCandidate::Select(vtable)) {\n+                Ok(())\n+            } else {\n+                Err(())\n+            }\n+        } else {\n+            Err(())\n+        }\n+    });\n }\n \n fn confirm_candidate<'cx, 'gcx, 'tcx>(\n@@ -1152,30 +1166,19 @@ fn confirm_candidate<'cx, 'gcx, 'tcx>(\n             confirm_param_env_candidate(selcx, obligation, poly_projection)\n         }\n \n-        ProjectionTyCandidate::Select => {\n-            confirm_select_candidate(selcx, obligation, obligation_trait_ref)\n+        ProjectionTyCandidate::Select(vtable) => {\n+            confirm_select_candidate(selcx, obligation, obligation_trait_ref, vtable)\n         }\n     }\n }\n \n fn confirm_select_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>)\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n+    vtable: Selection<'tcx>)\n     -> Progress<'tcx>\n {\n-    let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n-    let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n-    let vtable = match selcx.select(&trait_obligation) {\n-        Ok(Some(vtable)) => vtable,\n-        _ => {\n-            span_bug!(\n-                obligation.cause.span,\n-                \"Failed to select `{:?}`\",\n-                trait_obligation);\n-        }\n-    };\n-\n     match vtable {\n         super::VtableImpl(data) =>\n             confirm_impl_candidate(selcx, obligation, data),"}, {"sha": "9a3738c163d386b2da57f590252e7ae58ab9cb56", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -53,7 +53,7 @@ use std::rc::Rc;\n use syntax::abi::Abi;\n use hir;\n use lint;\n-use util::nodemap::FxHashMap;\n+use util::nodemap::{FxHashMap, FxHashSet};\n \n struct InferredObligationsSnapshotVecDelegate<'tcx> {\n     phantom: PhantomData<&'tcx i32>,\n@@ -584,7 +584,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     let trait_ref = &mut trait_pred.trait_ref;\n                     let unit_substs = trait_ref.substs;\n                     let mut never_substs = Vec::with_capacity(unit_substs.len());\n-                    never_substs.push(From::from(tcx.types.never));\n+                    never_substs.push(tcx.types.never.into());\n                     never_substs.extend(&unit_substs[1..]);\n                     trait_ref.substs = tcx.intern_substs(&never_substs);\n                 }\n@@ -2997,7 +2997,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // unsized parameters is equal to the target.\n                 let params = substs_a.iter().enumerate().map(|(i, &k)| {\n                     if ty_params.contains(i) {\n-                        Kind::from(substs_b.type_at(i))\n+                        substs_b.type_at(i).into()\n                     } else {\n                         k\n                     }\n@@ -3303,7 +3303,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // that order.\n         let predicates = tcx.predicates_of(def_id);\n         assert_eq!(predicates.parent, None);\n-        let predicates = predicates.predicates.iter().flat_map(|predicate| {\n+        let mut predicates: Vec<_> = predicates.predicates.iter().flat_map(|predicate| {\n             let predicate = normalize_with_depth(self, param_env, cause.clone(), recursion_depth,\n                                                  &predicate.subst(tcx, substs));\n             predicate.obligations.into_iter().chain(\n@@ -3314,6 +3314,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     predicate: predicate.value\n                 }))\n         }).collect();\n+        // We are performing deduplication here to avoid exponential blowups\n+        // (#38528) from happening, but the real cause of the duplication is\n+        // unknown. What we know is that the deduplication avoids exponential\n+        // amount of predicates being propogated when processing deeply nested\n+        // types.\n+        let mut seen = FxHashSet();\n+        predicates.retain(|i| seen.insert(i.clone()));\n         self.infcx().plug_leaks(skol_map, snapshot, predicates)\n     }\n }"}, {"sha": "f4b5ffbb7dc4044780382598c62258d2e636d425", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -355,10 +355,7 @@ fn fn_once_adapter_instance<'a, 'tcx>(\n     let sig = substs.closure_sig(closure_did, tcx);\n     let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n     assert_eq!(sig.inputs().len(), 1);\n-    let substs = tcx.mk_substs([\n-                               Kind::from(self_ty),\n-                               Kind::from(sig.inputs()[0]),\n-    ].iter().cloned());\n+    let substs = tcx.mk_substs([Kind::from(self_ty), sig.inputs()[0].into()].iter().cloned());\n \n     debug!(\"fn_once_adapter_shim: self_ty={:?} sig={:?}\", self_ty, sig);\n     Instance { def, substs }"}, {"sha": "3ab2cd274b90ea98ad80a8d4998a9a0f6e00a6ec", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -39,7 +39,6 @@ use util::nodemap::{NodeSet, DefIdMap, FxHashMap, FxHashSet};\n use serialize::{self, Encodable, Encoder};\n use std::cell::RefCell;\n use std::cmp;\n-use std::cmp::Ordering;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::iter::FromIterator;\n@@ -498,20 +497,6 @@ impl<'tcx> Hash for TyS<'tcx> {\n     }\n }\n \n-impl<'tcx> Ord for TyS<'tcx> {\n-    #[inline]\n-    fn cmp(&self, other: &TyS<'tcx>) -> Ordering {\n-        // (self as *const _).cmp(other as *const _)\n-        (self as *const TyS<'tcx>).cmp(&(other as *const TyS<'tcx>))\n-    }\n-}\n-impl<'tcx> PartialOrd for TyS<'tcx> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &TyS<'tcx>) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n impl<'tcx> TyS<'tcx> {\n     pub fn is_primitive_ty(&self) -> bool {\n         match self.sty {\n@@ -581,19 +566,6 @@ impl<T> PartialEq for Slice<T> {\n }\n impl<T> Eq for Slice<T> {}\n \n-impl<T> Ord for Slice<T> {\n-    #[inline]\n-    fn cmp(&self, other: &Slice<T>) -> Ordering {\n-        (&self.0 as *const [T]).cmp(&(&other.0 as *const [T]))\n-    }\n-}\n-impl<T> PartialOrd for Slice<T> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &Slice<T>) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n impl<T> Hash for Slice<T> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         (self.as_ptr(), self.len()).hash(s)\n@@ -1128,7 +1100,7 @@ pub type PolySubtypePredicate<'tcx> = ty::Binder<SubtypePredicate<'tcx>>;\n /// equality between arbitrary types. Processing an instance of\n /// Form #2 eventually yields one of these `ProjectionPredicate`\n /// instances to normalize the LHS.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct ProjectionPredicate<'tcx> {\n     pub projection_ty: ProjectionTy<'tcx>,\n     pub ty: Ty<'tcx>,\n@@ -1532,7 +1504,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for AdtDef {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n pub enum AdtKind { Struct, Union, Enum }\n \n bitflags! {"}, {"sha": "b9927c7eeb2fa491569db9a92557df892948e4fe", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -16,7 +16,7 @@\n use hir::def_id::DefId;\n use middle::const_val::ConstVal;\n use traits::Reveal;\n-use ty::subst::{Kind, Substs};\n+use ty::subst::{UnpackedKind, Substs};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::{TypeVisitor, TypeFolder};\n use ty::error::{ExpectedFound, TypeError};\n@@ -142,12 +142,14 @@ pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n \n     let params = a_subst.iter().zip(b_subst).enumerate().map(|(i, (a, b))| {\n         let variance = variances.map_or(ty::Invariant, |v| v[i]);\n-        if let (Some(a_ty), Some(b_ty)) = (a.as_type(), b.as_type()) {\n-            Ok(Kind::from(relation.relate_with_variance(variance, &a_ty, &b_ty)?))\n-        } else if let (Some(a_r), Some(b_r)) = (a.as_region(), b.as_region()) {\n-            Ok(Kind::from(relation.relate_with_variance(variance, &a_r, &b_r)?))\n-        } else {\n-            bug!()\n+        match (a.unpack(), b.unpack()) {\n+            (UnpackedKind::Lifetime(a_lt), UnpackedKind::Lifetime(b_lt)) => {\n+                Ok(relation.relate_with_variance(variance, &a_lt, &b_lt)?.into())\n+            }\n+            (UnpackedKind::Type(a_ty), UnpackedKind::Type(b_ty)) => {\n+                Ok(relation.relate_with_variance(variance, &a_ty, &b_ty)?.into())\n+            }\n+            (UnpackedKind::Lifetime(_), _) | (UnpackedKind::Type(_), _) => bug!()\n         }\n     });\n "}, {"sha": "a18e8f578364d21033bc85b458b3bcfadf434b02", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -15,10 +15,9 @@ use hir::def_id::DefId;\n use middle::const_val::ConstVal;\n use middle::region;\n use rustc_data_structures::indexed_vec::Idx;\n-use ty::subst::{Substs, Subst};\n+use ty::subst::{Substs, Subst, Kind, UnpackedKind};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use ty::{Slice, TyS};\n-use ty::subst::Kind;\n \n use std::iter;\n use std::cmp::Ordering;\n@@ -297,8 +296,8 @@ impl<'tcx> ClosureSubsts<'tcx> {\n         let generics = tcx.generics_of(def_id);\n         let parent_len = generics.parent_count();\n         SplitClosureSubsts {\n-            closure_kind_ty: self.substs[parent_len].as_type().expect(\"CK should be a type\"),\n-            closure_sig_ty: self.substs[parent_len + 1].as_type().expect(\"CS should be a type\"),\n+            closure_kind_ty: self.substs.type_at(parent_len),\n+            closure_sig_ty: self.substs.type_at(parent_len + 1),\n             upvar_kinds: &self.substs[parent_len + 2..],\n         }\n     }\n@@ -308,7 +307,13 @@ impl<'tcx> ClosureSubsts<'tcx> {\n         impl Iterator<Item=Ty<'tcx>> + 'tcx\n     {\n         let SplitClosureSubsts { upvar_kinds, .. } = self.split(def_id, tcx);\n-        upvar_kinds.iter().map(|t| t.as_type().expect(\"upvar should be type\"))\n+        upvar_kinds.iter().map(|t| {\n+            if let UnpackedKind::Type(ty) = t.unpack() {\n+                ty\n+            } else {\n+                bug!(\"upvar should be type\")\n+            }\n+        })\n     }\n \n     /// Returns the closure kind for this closure; may return a type\n@@ -620,7 +625,7 @@ impl<'a, 'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n         ty::TraitRef {\n             def_id: self.def_id,\n             substs: tcx.mk_substs(\n-                iter::once(Kind::from(self_ty)).chain(self.substs.iter().cloned()))\n+                iter::once(self_ty.into()).chain(self.substs.iter().cloned()))\n         }\n     }\n }\n@@ -645,7 +650,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n /// erase, or otherwise \"discharge\" these bound regions, we change the\n /// type from `Binder<T>` to just `T` (see\n /// e.g. `liberate_late_bound_regions`).\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Binder<T>(pub T);\n \n impl<T> Binder<T> {\n@@ -745,7 +750,7 @@ impl<T> Binder<T> {\n \n /// Represents the projection of an associated type. In explicit UFCS\n /// form this would be written `<T as Trait<..>>::N`.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ProjectionTy<'tcx> {\n     /// The parameters of the associated item.\n     pub substs: &'tcx Substs<'tcx>,\n@@ -1127,7 +1132,7 @@ impl<'a, 'tcx, 'gcx> ExistentialProjection<'tcx> {\n             projection_ty: ty::ProjectionTy {\n                 item_def_id: self.item_def_id,\n                 substs: tcx.mk_substs(\n-                iter::once(Kind::from(self_ty)).chain(self.substs.iter().cloned())),\n+                iter::once(self_ty.into()).chain(self.substs.iter().cloned())),\n             },\n             ty: self.ty,\n         }"}, {"sha": "5e3417e98c2e9551d42c7a19f58a8f462acfa70b", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 88, "deletions": 86, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -18,6 +18,7 @@ use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n use syntax_pos::{Span, DUMMY_SP};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n+use core::intrinsics;\n use core::nonzero::NonZero;\n use std::fmt;\n use std::iter;\n@@ -29,7 +30,7 @@ use std::mem;\n /// To reduce memory usage, a `Kind` is a interned pointer,\n /// with the lowest 2 bits being reserved for a tag to\n /// indicate the type (`Ty` or `Region`) it points to.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Kind<'tcx> {\n     ptr: NonZero<usize>,\n     marker: PhantomData<(Ty<'tcx>, ty::Region<'tcx>)>\n@@ -39,15 +40,29 @@ const TAG_MASK: usize = 0b11;\n const TYPE_TAG: usize = 0b00;\n const REGION_TAG: usize = 0b01;\n \n-impl<'tcx> From<Ty<'tcx>> for Kind<'tcx> {\n-    fn from(ty: Ty<'tcx>) -> Kind<'tcx> {\n-        // Ensure we can use the tag bits.\n-        assert_eq!(mem::align_of_val(ty) & TAG_MASK, 0);\n+pub enum UnpackedKind<'tcx> {\n+    Lifetime(ty::Region<'tcx>),\n+    Type(Ty<'tcx>),\n+}\n+\n+impl<'tcx> UnpackedKind<'tcx> {\n+    fn pack(self) -> Kind<'tcx> {\n+        let (tag, ptr) = match self {\n+            UnpackedKind::Lifetime(lt) => {\n+                // Ensure we can use the tag bits.\n+                assert_eq!(mem::align_of_val(lt) & TAG_MASK, 0);\n+                (REGION_TAG, lt as *const _ as usize)\n+            }\n+            UnpackedKind::Type(ty) => {\n+                // Ensure we can use the tag bits.\n+                assert_eq!(mem::align_of_val(ty) & TAG_MASK, 0);\n+                (TYPE_TAG, ty as *const _ as usize)\n+            }\n+        };\n \n-        let ptr = ty as *const _ as usize;\n         Kind {\n             ptr: unsafe {\n-                NonZero::new_unchecked(ptr | TYPE_TAG)\n+                NonZero::new_unchecked(ptr | tag)\n             },\n             marker: PhantomData\n         }\n@@ -56,105 +71,78 @@ impl<'tcx> From<Ty<'tcx>> for Kind<'tcx> {\n \n impl<'tcx> From<ty::Region<'tcx>> for Kind<'tcx> {\n     fn from(r: ty::Region<'tcx>) -> Kind<'tcx> {\n-        // Ensure we can use the tag bits.\n-        assert_eq!(mem::align_of_val(r) & TAG_MASK, 0);\n+        UnpackedKind::Lifetime(r).pack()\n+    }\n+}\n \n-        let ptr = r as *const _ as usize;\n-        Kind {\n-            ptr: unsafe {\n-                NonZero::new_unchecked(ptr | REGION_TAG)\n-            },\n-            marker: PhantomData\n-        }\n+impl<'tcx> From<Ty<'tcx>> for Kind<'tcx> {\n+    fn from(ty: Ty<'tcx>) -> Kind<'tcx> {\n+        UnpackedKind::Type(ty).pack()\n     }\n }\n \n impl<'tcx> Kind<'tcx> {\n     #[inline]\n-    unsafe fn downcast<T>(self, tag: usize) -> Option<&'tcx T> {\n+    pub fn unpack(self) -> UnpackedKind<'tcx> {\n         let ptr = self.ptr.get();\n-        if ptr & TAG_MASK == tag {\n-            Some(&*((ptr & !TAG_MASK) as *const _))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn as_type(self) -> Option<Ty<'tcx>> {\n-        unsafe {\n-            self.downcast(TYPE_TAG)\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn as_region(self) -> Option<ty::Region<'tcx>> {\n         unsafe {\n-            self.downcast(REGION_TAG)\n+            match ptr & TAG_MASK {\n+                REGION_TAG => UnpackedKind::Lifetime(&*((ptr & !TAG_MASK) as *const _)),\n+                TYPE_TAG => UnpackedKind::Type(&*((ptr & !TAG_MASK) as *const _)),\n+                _ => intrinsics::unreachable()\n+            }\n         }\n     }\n }\n \n impl<'tcx> fmt::Debug for Kind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if let Some(ty) = self.as_type() {\n-            write!(f, \"{:?}\", ty)\n-        } else if let Some(r) = self.as_region() {\n-            write!(f, \"{:?}\", r)\n-        } else {\n-            write!(f, \"<unknown @ {:p}>\", self.ptr.get() as *const ())\n+        match self.unpack() {\n+            UnpackedKind::Lifetime(lt) => write!(f, \"{:?}\", lt),\n+            UnpackedKind::Type(ty) => write!(f, \"{:?}\", ty),\n         }\n     }\n }\n \n impl<'tcx> fmt::Display for Kind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if let Some(ty) = self.as_type() {\n-            write!(f, \"{}\", ty)\n-        } else if let Some(r) = self.as_region() {\n-            write!(f, \"{}\", r)\n-        } else {\n-            // FIXME(RFC 2000): extend this if/else chain when we support const generic.\n-            unimplemented!();\n+        match self.unpack() {\n+            UnpackedKind::Lifetime(lt) => write!(f, \"{}\", lt),\n+            UnpackedKind::Type(ty) => write!(f, \"{}\", ty),\n         }\n     }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Kind<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        if let Some(ty) = self.as_type() {\n-            Kind::from(ty.fold_with(folder))\n-        } else if let Some(r) = self.as_region() {\n-            Kind::from(r.fold_with(folder))\n-        } else {\n-            bug!()\n+        match self.unpack() {\n+            UnpackedKind::Lifetime(lt) => lt.fold_with(folder).into(),\n+            UnpackedKind::Type(ty) => ty.fold_with(folder).into(),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        if let Some(ty) = self.as_type() {\n-            ty.visit_with(visitor)\n-        } else if let Some(r) = self.as_region() {\n-            r.visit_with(visitor)\n-        } else {\n-            bug!()\n+        match self.unpack() {\n+            UnpackedKind::Lifetime(lt) => lt.visit_with(visitor),\n+            UnpackedKind::Type(ty) => ty.visit_with(visitor),\n         }\n     }\n }\n \n impl<'tcx> Encodable for Kind<'tcx> {\n     fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n         e.emit_enum(\"Kind\", |e| {\n-            if let Some(ty) = self.as_type() {\n-                e.emit_enum_variant(\"Ty\", TYPE_TAG, 1, |e| {\n-                    e.emit_enum_variant_arg(0, |e| ty.encode(e))\n-                })\n-            } else if let Some(r) = self.as_region() {\n-                e.emit_enum_variant(\"Region\", REGION_TAG, 1, |e| {\n-                    e.emit_enum_variant_arg(0, |e| r.encode(e))\n-                })\n-            } else {\n-                bug!()\n+            match self.unpack() {\n+                UnpackedKind::Lifetime(lt) => {\n+                    e.emit_enum_variant(\"Region\", REGION_TAG, 1, |e| {\n+                        e.emit_enum_variant_arg(0, |e| lt.encode(e))\n+                    })\n+                }\n+                UnpackedKind::Type(ty) => {\n+                    e.emit_enum_variant(\"Ty\", TYPE_TAG, 1, |e| {\n+                        e.emit_enum_variant_arg(0, |e| ty.encode(e))\n+                    })\n+                }\n             }\n         })\n     }\n@@ -247,7 +235,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n             let def = types.next().unwrap();\n             let ty = mk_type(def, substs);\n             assert_eq!(def.index as usize, substs.len());\n-            substs.push(Kind::from(ty));\n+            substs.push(ty.into());\n         }\n \n         for def in &defs.regions {\n@@ -269,26 +257,42 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n \n     #[inline]\n     pub fn types(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n-        self.iter().filter_map(|k| k.as_type())\n+        self.iter().filter_map(|k| {\n+            if let UnpackedKind::Type(ty) = k.unpack() {\n+                Some(ty)\n+            } else {\n+                None\n+            }\n+        })\n     }\n \n     #[inline]\n     pub fn regions(&'a self) -> impl DoubleEndedIterator<Item=ty::Region<'tcx>> + 'a {\n-        self.iter().filter_map(|k| k.as_region())\n+        self.iter().filter_map(|k| {\n+            if let UnpackedKind::Lifetime(lt) = k.unpack() {\n+                Some(lt)\n+            } else {\n+                None\n+            }\n+        })\n     }\n \n     #[inline]\n     pub fn type_at(&self, i: usize) -> Ty<'tcx> {\n-        self[i].as_type().unwrap_or_else(|| {\n+        if let UnpackedKind::Type(ty) = self[i].unpack() {\n+            ty\n+        } else {\n             bug!(\"expected type for param #{} in {:?}\", i, self);\n-        })\n+        }\n     }\n \n     #[inline]\n     pub fn region_at(&self, i: usize) -> ty::Region<'tcx> {\n-        self[i].as_region().unwrap_or_else(|| {\n+        if let UnpackedKind::Lifetime(lt) = self[i].unpack() {\n+            lt\n+        } else {\n             bug!(\"expected region for param #{} in {:?}\", i, self);\n-        })\n+        }\n     }\n \n     #[inline]\n@@ -413,13 +417,12 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n         // the specialized routine `ty::replace_late_regions()`.\n         match *r {\n             ty::ReEarlyBound(data) => {\n-                let r = self.substs.get(data.index as usize)\n-                            .and_then(|k| k.as_region());\n+                let r = self.substs.get(data.index as usize).map(|k| k.unpack());\n                 match r {\n-                    Some(r) => {\n-                        self.shift_region_through_binders(r)\n+                    Some(UnpackedKind::Lifetime(lt)) => {\n+                        self.shift_region_through_binders(lt)\n                     }\n-                    None => {\n+                    _ => {\n                         let span = self.span.unwrap_or(DUMMY_SP);\n                         span_bug!(\n                             span,\n@@ -470,11 +473,10 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n     fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty<'tcx>) -> Ty<'tcx> {\n         // Look up the type in the substitutions. It really should be in there.\n-        let opt_ty = self.substs.get(p.idx as usize)\n-                         .and_then(|k| k.as_type());\n+        let opt_ty = self.substs.get(p.idx as usize).map(|k| k.unpack());\n         let ty = match opt_ty {\n-            Some(t) => t,\n-            None => {\n+            Some(UnpackedKind::Type(ty)) => ty,\n+            _ => {\n                 let span = self.span.unwrap_or(DUMMY_SP);\n                 span_bug!(\n                     span,\n@@ -600,7 +602,7 @@ impl<'a, 'gcx, 'tcx> ty::PolyExistentialTraitRef<'tcx> {\n             ty::TraitRef {\n                 def_id: trait_ref.def_id,\n                 substs: tcx.mk_substs(\n-                    iter::once(Kind::from(self_ty)).chain(trait_ref.substs.iter().cloned()))\n+                    iter::once(self_ty.into()).chain(trait_ref.substs.iter().cloned()))\n             }\n         })\n     }"}, {"sha": "110808919e905fc65f725e4a8724be03c558f23f", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -19,7 +19,7 @@ use middle::const_val::ConstVal;\n use traits::{self, Reveal};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::TypeVisitor;\n-use ty::subst::{Subst, Kind};\n+use ty::subst::{Subst, UnpackedKind};\n use ty::TypeVariants::*;\n use util::common::ErrorReported;\n use middle::lang_items;\n@@ -509,16 +509,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         let result = item_substs.iter().zip(impl_substs.iter())\n             .filter(|&(_, &k)| {\n-                if let Some(&ty::RegionKind::ReEarlyBound(ref ebr)) = k.as_region() {\n-                    !impl_generics.region_param(ebr, self).pure_wrt_drop\n-                } else if let Some(&ty::TyS {\n-                    sty: ty::TypeVariants::TyParam(ref pt), ..\n-                }) = k.as_type() {\n-                    !impl_generics.type_param(pt, self).pure_wrt_drop\n-                } else {\n-                    // not a type or region param - this should be reported\n-                    // as an error.\n-                    false\n+                match k.unpack() {\n+                    UnpackedKind::Lifetime(&ty::RegionKind::ReEarlyBound(ref ebr)) => {\n+                        !impl_generics.region_param(ebr, self).pure_wrt_drop\n+                    }\n+                    UnpackedKind::Type(&ty::TyS {\n+                        sty: ty::TypeVariants::TyParam(ref pt), ..\n+                    }) => {\n+                        !impl_generics.type_param(pt, self).pure_wrt_drop\n+                    }\n+                    UnpackedKind::Lifetime(_) | UnpackedKind::Type(_) => {\n+                        // not a type or region param - this should be reported\n+                        // as an error.\n+                        false\n+                    }\n                 }\n             }).map(|(&item_param, _)| item_param).collect();\n         debug!(\"destructor_constraint({:?}) = {:?}\", def.did, result);\n@@ -596,7 +600,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             // Objects must be alive in order for their destructor\n             // to be called.\n             ty::TyDynamic(..) => Ok(ty::DtorckConstraint {\n-                outlives: vec![Kind::from(ty)],\n+                outlives: vec![ty.into()],\n                 dtorck_types: vec![],\n             }),\n "}, {"sha": "54e3418d4f0178fb1ba1f93b860b8bb67c2fb4bd", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -878,7 +878,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n         ty::TyAdt(adt, substs) => {\n             if adt.is_box() {\n                 // Use T as the sub pattern type of Box<T>.\n-                vec![substs[0].as_type().unwrap()]\n+                vec![substs.type_at(0)]\n             } else {\n                 adt.variants[ctor.variant_index_for_adt(adt)].fields.iter().map(|field| {\n                     let is_visible = adt.is_enum()"}, {"sha": "35d2205cf33f3cea858e9e58c8dfd12ad4892be4", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -17,7 +17,7 @@ use driver;\n use rustc_lint;\n use rustc_resolve::MakeGlobMap;\n use rustc::middle::region;\n-use rustc::ty::subst::{Kind, Subst};\n+use rustc::ty::subst::Subst;\n use rustc::traits::{ObligationCause, Reveal};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::maps::OnDiskCache;\n@@ -468,7 +468,7 @@ fn subst_ty_renumber_bound() {\n             env.t_fn(&[t_param], env.t_nil())\n         };\n \n-        let substs = env.infcx.tcx.intern_substs(&[Kind::from(t_rptr_bound1)]);\n+        let substs = env.infcx.tcx.intern_substs(&[t_rptr_bound1.into()]);\n         let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n         // t_expected = fn(&'a isize)\n@@ -503,7 +503,7 @@ fn subst_ty_renumber_some_bounds() {\n             env.t_pair(t_param, env.t_fn(&[t_param], env.t_nil()))\n         };\n \n-        let substs = env.infcx.tcx.intern_substs(&[Kind::from(t_rptr_bound1)]);\n+        let substs = env.infcx.tcx.intern_substs(&[t_rptr_bound1.into()]);\n         let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n         // t_expected = (&'a isize, fn(&'a isize))\n@@ -565,7 +565,7 @@ fn subst_region_renumber_region() {\n             env.t_fn(&[env.t_rptr(re_early)], env.t_nil())\n         };\n \n-        let substs = env.infcx.tcx.intern_substs(&[Kind::from(re_bound1)]);\n+        let substs = env.infcx.tcx.intern_substs(&[re_bound1.into()]);\n         let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n         // t_expected = fn(&'a isize)"}, {"sha": "f3c6ff2f2b3a10ba8aeb720eb8adabb67e4bc157", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -152,6 +152,12 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                     NON_SNAKE_CASE,\n                     NON_UPPER_CASE_GLOBALS);\n \n+    add_lint_group!(sess,\n+                    \"nonstandard_style\",\n+                    NON_CAMEL_CASE_TYPES,\n+                    NON_SNAKE_CASE,\n+                    NON_UPPER_CASE_GLOBALS);\n+\n     add_lint_group!(sess,\n                     \"unused\",\n                     UNUSED_IMPORTS,"}, {"sha": "08c16fed5dd3fd074a0c75e42a2924128bb68681", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -7,7 +7,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::mir;\n use rustc::traits::Reveal;\n use rustc::ty::layout::{self, Size, Align, HasDataLayout, LayoutOf, TyLayout};\n-use rustc::ty::subst::{Subst, Substs, Kind};\n+use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n use syntax::codemap::{self, DUMMY_SP};\n@@ -1663,6 +1663,6 @@ pub fn resolve_drop_in_place<'a, 'tcx>(\n     ty: Ty<'tcx>,\n ) -> ty::Instance<'tcx> {\n     let def_id = tcx.require_lang_item(::rustc::middle::lang_items::DropInPlaceFnLangItem);\n-    let substs = tcx.intern_substs(&[Kind::from(ty)]);\n+    let substs = tcx.intern_substs(&[ty.into()]);\n     ty::Instance::resolve(tcx, ty::ParamEnv::empty(Reveal::All), def_id, substs).unwrap()\n }"}, {"sha": "2ca6c76a8009a058e18f8bdc1c2e33f958544f8e", "filename": "src/librustc_mir/monomorphize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -92,7 +92,7 @@ fn fn_once_adapter_instance<'a, 'tcx>(\n     assert_eq!(sig.inputs().len(), 1);\n     let substs = tcx.mk_substs([\n         Kind::from(self_ty),\n-        Kind::from(sig.inputs()[0]),\n+        sig.inputs()[0].into(),\n     ].iter().cloned());\n \n     debug!(\"fn_once_adapter_shim: self_ty={:?} sig={:?}\", self_ty, sig);\n@@ -153,7 +153,7 @@ pub fn resolve_drop_in_place<'a, 'tcx>(\n     -> ty::Instance<'tcx>\n {\n     let def_id = tcx.require_lang_item(DropInPlaceFnLangItem);\n-    let substs = tcx.intern_substs(&[Kind::from(ty)]);\n+    let substs = tcx.intern_substs(&[ty.into()]);\n     Instance::resolve(tcx, ty::ParamEnv::empty(traits::Reveal::All), def_id, substs).unwrap()\n }\n "}, {"sha": "04ebaa031fe5a305548574865e2c1724fe61dac1", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -65,7 +65,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, Visitor, MutVisitor};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, GeneratorInterior};\n-use rustc::ty::subst::{Kind, Substs};\n+use rustc::ty::subst::Substs;\n use util::dump_mir;\n use util::liveness::{self, LivenessMode};\n use rustc_const_math::ConstInt;\n@@ -858,8 +858,8 @@ impl MirPass for StateTransform {\n         // Compute GeneratorState<yield_ty, return_ty>\n         let state_did = tcx.lang_items().gen_state().unwrap();\n         let state_adt_ref = tcx.adt_def(state_did);\n-        let state_substs = tcx.mk_substs([Kind::from(yield_ty),\n-            Kind::from(mir.return_ty())].iter());\n+        let state_substs = tcx.mk_substs([yield_ty.into(),\n+            mir.return_ty().into()].iter());\n         let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n \n         // We rename RETURN_PLACE which has type mir.return_ty to new_ret_local"}, {"sha": "e4e9ee58330cc58b775692491e72a68164b0b412", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -59,6 +59,7 @@ use syntax::ast::{Label, Local, Mutability, Pat, PatKind, Path};\n use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n use syntax::feature_gate::{feature_err, emit_feature_err, GateIssue};\n use syntax::parse::token;\n+use syntax::ptr::P;\n \n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use errors::{DiagnosticBuilder, DiagnosticId};\n@@ -2329,17 +2330,17 @@ impl<'a> Resolver<'a> {\n \n     // check that all of the arms in an or-pattern have exactly the\n     // same set of bindings, with the same binding modes for each.\n-    fn check_consistent_bindings(&mut self, arm: &Arm) {\n-        if arm.pats.is_empty() {\n+    fn check_consistent_bindings(&mut self, pats: &[P<Pat>]) {\n+        if pats.is_empty() {\n             return;\n         }\n \n         let mut missing_vars = FxHashMap();\n         let mut inconsistent_vars = FxHashMap();\n-        for (i, p) in arm.pats.iter().enumerate() {\n+        for (i, p) in pats.iter().enumerate() {\n             let map_i = self.binding_mode_map(&p);\n \n-            for (j, q) in arm.pats.iter().enumerate() {\n+            for (j, q) in pats.iter().enumerate() {\n                 if i == j {\n                     continue;\n                 }\n@@ -2404,9 +2405,8 @@ impl<'a> Resolver<'a> {\n             self.resolve_pattern(&pattern, PatternSource::Match, &mut bindings_list);\n         }\n \n-        // This has to happen *after* we determine which\n-        // pat_idents are variants\n-        self.check_consistent_bindings(arm);\n+        // This has to happen *after* we determine which pat_idents are variants\n+        self.check_consistent_bindings(&arm.pats);\n \n         walk_list!(self, visit_expr, &arm.guard);\n         self.visit_expr(&arm.body);\n@@ -2490,7 +2490,9 @@ impl<'a> Resolver<'a> {\n                         &ident.node.name.as_str())\n                 );\n             }\n-            Some(..) if pat_src == PatternSource::Match => {\n+            Some(..) if pat_src == PatternSource::Match ||\n+                        pat_src == PatternSource::IfLet ||\n+                        pat_src == PatternSource::WhileLet => {\n                 // `Variant1(a) | Variant2(a)`, ok\n                 // Reuse definition from the first `a`.\n                 def = self.ribs[ValueNS].last_mut().unwrap().bindings[&ident.node];\n@@ -3480,11 +3482,16 @@ impl<'a> Resolver<'a> {\n                 visit::walk_expr(self, expr);\n             }\n \n-            ExprKind::IfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n+            ExprKind::IfLet(ref pats, ref subexpression, ref if_block, ref optional_else) => {\n                 self.visit_expr(subexpression);\n \n                 self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::IfLet, &mut FxHashMap());\n+                let mut bindings_list = FxHashMap();\n+                for pat in pats {\n+                    self.resolve_pattern(pat, PatternSource::IfLet, &mut bindings_list);\n+                }\n+                // This has to happen *after* we determine which pat_idents are variants\n+                self.check_consistent_bindings(pats);\n                 self.visit_block(if_block);\n                 self.ribs[ValueNS].pop();\n \n@@ -3500,11 +3507,16 @@ impl<'a> Resolver<'a> {\n                 });\n             }\n \n-            ExprKind::WhileLet(ref pattern, ref subexpression, ref block, label) => {\n+            ExprKind::WhileLet(ref pats, ref subexpression, ref block, label) => {\n                 self.with_resolved_label(label, expr.id, |this| {\n                     this.visit_expr(subexpression);\n                     this.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                    this.resolve_pattern(pattern, PatternSource::WhileLet, &mut FxHashMap());\n+                    let mut bindings_list = FxHashMap();\n+                    for pat in pats {\n+                        this.resolve_pattern(pat, PatternSource::WhileLet, &mut bindings_list);\n+                    }\n+                    // This has to happen *after* we determine which pat_idents are variants\n+                    this.check_consistent_bindings(pats);\n                     this.visit_block(block);\n                     this.ribs[ValueNS].pop();\n                 });"}, {"sha": "6e98604101345a6796fd526a08955020ee430ea8", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 85, "deletions": 78, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -1031,6 +1031,81 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         }\n     }\n \n+    fn process_var_decl_multi(&mut self, pats: &'l [P<ast::Pat>]) {\n+        let mut collector = PathCollector::new();\n+        for pattern in pats {\n+            // collect paths from the arm's patterns\n+            collector.visit_pat(&pattern);\n+            self.visit_pat(&pattern);\n+        }\n+\n+        // process collected paths\n+        for (id, i, sp, immut) in collector.collected_idents {\n+            match self.save_ctxt.get_path_def(id) {\n+                HirDef::Local(id) => {\n+                    let mut value = if immut == ast::Mutability::Immutable {\n+                        self.span.snippet(sp).to_string()\n+                    } else {\n+                        \"<mutable>\".to_string()\n+                    };\n+                    let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                    let typ = self.save_ctxt\n+                        .tables\n+                        .node_id_to_type_opt(hir_id)\n+                        .map(|t| t.to_string())\n+                        .unwrap_or(String::new());\n+                    value.push_str(\": \");\n+                    value.push_str(&typ);\n+\n+                    if !self.span.filter_generated(Some(sp), sp) {\n+                        let qualname = format!(\"{}${}\", i.to_string(), id);\n+                        let id = ::id_from_node_id(id, &self.save_ctxt);\n+                        let span = self.span_from_span(sp);\n+\n+                        self.dumper.dump_def(\n+                            &Access {\n+                                public: false,\n+                                reachable: false,\n+                            },\n+                            Def {\n+                                kind: DefKind::Local,\n+                                id,\n+                                span,\n+                                name: i.to_string(),\n+                                qualname,\n+                                value: typ,\n+                                parent: None,\n+                                children: vec![],\n+                                decl_id: None,\n+                                docs: String::new(),\n+                                sig: None,\n+                                attributes: vec![],\n+                            },\n+                        );\n+                    }\n+                }\n+                HirDef::StructCtor(..) |\n+                HirDef::VariantCtor(..) |\n+                HirDef::Const(..) |\n+                HirDef::AssociatedConst(..) |\n+                HirDef::Struct(..) |\n+                HirDef::Variant(..) |\n+                HirDef::TyAlias(..) |\n+                HirDef::AssociatedTy(..) |\n+                HirDef::SelfTy(..) => {\n+                    self.dump_path_ref(id, &ast::Path::from_ident(sp, i));\n+                }\n+                def => error!(\n+                    \"unexpected definition kind when processing collected idents: {:?}\",\n+                    def\n+                ),\n+            }\n+        }\n+\n+        for (id, ref path) in collector.collected_paths {\n+            self.process_path(id, path);\n+        }\n+    }\n \n     fn process_var_decl(&mut self, p: &'l ast::Pat, value: String) {\n         // The local could declare multiple new vars, we must walk the\n@@ -1622,17 +1697,21 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     v.nest_scope(ex.id, |v| v.visit_expr(body))\n                 });\n             }\n-            ast::ExprKind::ForLoop(ref pattern, ref subexpression, ref block, _) |\n-            ast::ExprKind::WhileLet(ref pattern, ref subexpression, ref block, _) => {\n+            ast::ExprKind::ForLoop(ref pattern, ref subexpression, ref block, _) => {\n                 let value = self.span.snippet(subexpression.span);\n                 self.process_var_decl(pattern, value);\n                 debug!(\"for loop, walk sub-expr: {:?}\", subexpression.node);\n                 self.visit_expr(subexpression);\n                 visit::walk_block(self, block);\n             }\n-            ast::ExprKind::IfLet(ref pattern, ref subexpression, ref block, ref opt_else) => {\n-                let value = self.span.snippet(subexpression.span);\n-                self.process_var_decl(pattern, value);\n+            ast::ExprKind::WhileLet(ref pats, ref subexpression, ref block, _) => {\n+                self.process_var_decl_multi(pats);\n+                debug!(\"for loop, walk sub-expr: {:?}\", subexpression.node);\n+                self.visit_expr(subexpression);\n+                visit::walk_block(self, block);\n+            }\n+            ast::ExprKind::IfLet(ref pats, ref subexpression, ref block, ref opt_else) => {\n+                self.process_var_decl_multi(pats);\n                 self.visit_expr(subexpression);\n                 visit::walk_block(self, block);\n                 opt_else.as_ref().map(|el| self.visit_expr(el));\n@@ -1661,79 +1740,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n     }\n \n     fn visit_arm(&mut self, arm: &'l ast::Arm) {\n-        let mut collector = PathCollector::new();\n-        for pattern in &arm.pats {\n-            // collect paths from the arm's patterns\n-            collector.visit_pat(&pattern);\n-            self.visit_pat(&pattern);\n-        }\n-\n-        // process collected paths\n-        for (id, i, sp, immut) in collector.collected_idents {\n-            match self.save_ctxt.get_path_def(id) {\n-                HirDef::Local(id) => {\n-                    let mut value = if immut == ast::Mutability::Immutable {\n-                        self.span.snippet(sp).to_string()\n-                    } else {\n-                        \"<mutable>\".to_string()\n-                    };\n-                    let hir_id = self.tcx.hir.node_to_hir_id(id);\n-                    let typ = self.save_ctxt\n-                        .tables\n-                        .node_id_to_type_opt(hir_id)\n-                        .map(|t| t.to_string())\n-                        .unwrap_or(String::new());\n-                    value.push_str(\": \");\n-                    value.push_str(&typ);\n-\n-                    if !self.span.filter_generated(Some(sp), sp) {\n-                        let qualname = format!(\"{}${}\", i.to_string(), id);\n-                        let id = ::id_from_node_id(id, &self.save_ctxt);\n-                        let span = self.span_from_span(sp);\n-\n-                        self.dumper.dump_def(\n-                            &Access {\n-                                public: false,\n-                                reachable: false,\n-                            },\n-                            Def {\n-                                kind: DefKind::Local,\n-                                id,\n-                                span,\n-                                name: i.to_string(),\n-                                qualname,\n-                                value: typ,\n-                                parent: None,\n-                                children: vec![],\n-                                decl_id: None,\n-                                docs: String::new(),\n-                                sig: None,\n-                                attributes: vec![],\n-                            },\n-                        );\n-                    }\n-                }\n-                HirDef::StructCtor(..) |\n-                HirDef::VariantCtor(..) |\n-                HirDef::Const(..) |\n-                HirDef::AssociatedConst(..) |\n-                HirDef::Struct(..) |\n-                HirDef::Variant(..) |\n-                HirDef::TyAlias(..) |\n-                HirDef::AssociatedTy(..) |\n-                HirDef::SelfTy(..) => {\n-                    self.dump_path_ref(id, &ast::Path::from_ident(sp, i));\n-                }\n-                def => error!(\n-                    \"unexpected definition kind when processing collected idents: {:?}\",\n-                    def\n-                ),\n-            }\n-        }\n-\n-        for (id, ref path) in collector.collected_paths {\n-            self.process_path(id, path);\n-        }\n+        self.process_var_decl_multi(&arm.pats);\n         walk_list!(self, visit_expr, &arm.guard);\n         self.visit_expr(&arm.body);\n     }"}, {"sha": "37bd225a7d9cbd304286290c80835eac3e3b9880", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -28,7 +28,6 @@ use value::Value;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n-use rustc::ty::subst::Kind;\n use rustc::hir;\n \n use libc::{c_uint, c_char};\n@@ -413,8 +412,8 @@ pub fn ty_fn_sig<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             sig.map_bound(|sig| {\n                 let state_did = tcx.lang_items().gen_state().unwrap();\n                 let state_adt_ref = tcx.adt_def(state_did);\n-                let state_substs = tcx.mk_substs([Kind::from(sig.yield_ty),\n-                    Kind::from(sig.return_ty)].iter());\n+                let state_substs = tcx.mk_substs([sig.yield_ty.into(),\n+                    sig.return_ty.into()].iter());\n                 let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n \n                 tcx.mk_fn_sig(iter::once(env_ty),"}, {"sha": "650e530519887a71de58fd81c538aa7cf303ae39", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -19,7 +19,7 @@ use hir::def::Def;\n use hir::def_id::DefId;\n use middle::resolve_lifetime as rl;\n use namespace::Namespace;\n-use rustc::ty::subst::{Kind, Subst, Substs};\n+use rustc::ty::subst::{Kind, UnpackedKind, Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, RegionKind, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::wf::object_region_bounds;\n@@ -1136,7 +1136,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n             // Replace all lifetimes with 'static\n             for subst in &mut substs {\n-                if let Some(_) = subst.as_region() {\n+                if let UnpackedKind::Lifetime(_) = subst.unpack() {\n                     *subst = Kind::from(&RegionKind::ReStatic);\n                 }\n             }\n@@ -1146,8 +1146,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         // Fill in our own generics with the resolved lifetimes\n         assert_eq!(lifetimes.len(), generics.own_count());\n-        substs.extend(lifetimes.iter().map(|lt|\n-            Kind::from(self.ast_region_to_region(lt, None))));\n+        substs.extend(lifetimes.iter().map(|lt| Kind::from(self.ast_region_to_region(lt, None))));\n \n         debug!(\"impl_trait_ty_to_ty: final substs = {:?}\", substs);\n "}, {"sha": "427641aaf0951a3eb1dd91831d132eed16cbf4ca", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -151,6 +151,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     err.emit();\n                 }\n             }\n+        } else if let PatKind::Ref(..) = pat.node {\n+            // When you encounter a `&pat` pattern, reset to \"by\n+            // value\". This is so that `x` and `y` here are by value,\n+            // as they appear to be:\n+            //\n+            // ```\n+            // match &(&22, &44) {\n+            //   (&x, &y) => ...\n+            // }\n+            // ```\n+            //\n+            // cc #46688\n+            def_bm = ty::BindByValue(hir::MutImmutable);\n         }\n \n         // Lose mutability now that we know binding mode and discriminant type."}, {"sha": "039669a62e104ab6491651ad645610fa68c75e8f", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -14,7 +14,7 @@ use hir::def_id::DefId;\n use rustc::infer::{self, InferOk};\n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::middle::region;\n-use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::traits::{self, Reveal, ObligationCause};\n use util::common::ErrorReported;\n@@ -331,10 +331,9 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n         }\n \n         for outlive in outlives {\n-            if let Some(r) = outlive.as_region() {\n-                rcx.sub_regions(origin(), parent_scope, r);\n-            } else if let Some(ty) = outlive.as_type() {\n-                rcx.type_must_outlive(origin(), ty, parent_scope);\n+            match outlive.unpack() {\n+                UnpackedKind::Lifetime(lt) => rcx.sub_regions(origin(), parent_scope, lt),\n+                UnpackedKind::Type(ty) => rcx.type_must_outlive(origin(), ty, parent_scope),\n             }\n         }\n     }"}, {"sha": "a28625be2c73963e3e09465dc4328150a0ddac0d", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 49, "deletions": 34, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -13,7 +13,7 @@\n use super::{FnCtxt, Needs};\n use super::method::MethodCallee;\n use rustc::ty::{self, Ty, TypeFoldable, TypeVariants};\n-use rustc::ty::TypeVariants::{TyStr, TyRef};\n+use rustc::ty::TypeVariants::{TyStr, TyRef, TyAdt};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use errors;\n@@ -201,10 +201,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let mutbl = match mt.mutbl {\n                             hir::MutImmutable => AutoBorrowMutability::Immutable,\n                             hir::MutMutable => AutoBorrowMutability::Mutable {\n-                                // For initial two-phase borrow\n-                                // deployment, conservatively omit\n-                                // overloaded binary ops.\n-                                allow_two_phase_borrow: false,\n+                                // Allow two-phase borrows for binops in initial deployment\n+                                // since they desugar to methods\n+                                allow_two_phase_borrow: true,\n                             }\n                         };\n                         let autoref = Adjustment {\n@@ -219,10 +218,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let mutbl = match mt.mutbl {\n                             hir::MutImmutable => AutoBorrowMutability::Immutable,\n                             hir::MutMutable => AutoBorrowMutability::Mutable {\n-                                // For initial two-phase borrow\n-                                // deployment, conservatively omit\n-                                // overloaded binary ops.\n-                                allow_two_phase_borrow: false,\n+                                // Allow two-phase borrows for binops in initial deployment\n+                                // since they desugar to methods\n+                                allow_two_phase_borrow: true,\n                             }\n                         };\n                         let autoref = Adjustment {\n@@ -301,7 +299,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                         if let Some(missing_trait) = missing_trait {\n                             if missing_trait == \"std::ops::Add\" &&\n-                                self.check_str_addition(expr, lhs_expr, lhs_ty,\n+                                self.check_str_addition(expr, lhs_expr, rhs_expr, lhs_ty,\n                                                         rhs_ty, &mut err) {\n                                 // This has nothing here because it means we did string\n                                 // concatenation (e.g. \"Hello \" + \"World!\"). This means\n@@ -330,37 +328,54 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_str_addition(&self,\n                           expr: &'gcx hir::Expr,\n                           lhs_expr: &'gcx hir::Expr,\n+                          rhs_expr: &'gcx hir::Expr,\n                           lhs_ty: Ty<'tcx>,\n                           rhs_ty: Ty<'tcx>,\n                           err: &mut errors::DiagnosticBuilder) -> bool {\n+        let codemap = self.tcx.sess.codemap();\n+        let msg = \"`to_owned()` can be used to create an owned `String` \\\n+                   from a string reference. String concatenation \\\n+                   appends the string on the right to the string \\\n+                   on the left and may require reallocation. This \\\n+                   requires ownership of the string on the left\";\n         // If this function returns true it means a note was printed, so we don't need\n         // to print the normal \"implementation of `std::ops::Add` might be missing\" note\n-        let mut is_string_addition = false;\n-        if let TyRef(_, l_ty) = lhs_ty.sty {\n-            if let TyRef(_, r_ty) = rhs_ty.sty {\n-                if l_ty.ty.sty == TyStr && r_ty.ty.sty == TyStr {\n-                    err.span_label(expr.span,\n-                        \"`+` can't be used to concatenate two `&str` strings\");\n-                    let codemap = self.tcx.sess.codemap();\n-                    let suggestion =\n-                        match codemap.span_to_snippet(lhs_expr.span) {\n-                            Ok(lstring) => format!(\"{}.to_owned()\", lstring),\n-                            _ => format!(\"<expression>\")\n-                        };\n-                    err.span_suggestion(lhs_expr.span,\n-                        &format!(\"`to_owned()` can be used to create an owned `String` \\\n-                                  from a string reference. String concatenation \\\n-                                  appends the string on the right to the string \\\n-                                  on the left and may require reallocation. This \\\n-                                  requires ownership of the string on the left\"), suggestion);\n-                    is_string_addition = true;\n-                }\n-\n+        match (&lhs_ty.sty, &rhs_ty.sty) {\n+            (&TyRef(_, ref l_ty), &TyRef(_, ref r_ty))\n+            if l_ty.ty.sty == TyStr && r_ty.ty.sty == TyStr => {\n+                err.span_label(expr.span,\n+                    \"`+` can't be used to concatenate two `&str` strings\");\n+                match codemap.span_to_snippet(lhs_expr.span) {\n+                    Ok(lstring) => err.span_suggestion(lhs_expr.span,\n+                                                       msg,\n+                                                       format!(\"{}.to_owned()\", lstring)),\n+                    _ => err.help(msg),\n+                };\n+                true\n             }\n-\n+            (&TyRef(_, ref l_ty), &TyAdt(..))\n+            if l_ty.ty.sty == TyStr && &format!(\"{:?}\", rhs_ty) == \"std::string::String\" => {\n+                err.span_label(expr.span,\n+                    \"`+` can't be used to concatenate a `&str` with a `String`\");\n+                match codemap.span_to_snippet(lhs_expr.span) {\n+                    Ok(lstring) => err.span_suggestion(lhs_expr.span,\n+                                                       msg,\n+                                                       format!(\"{}.to_owned()\", lstring)),\n+                    _ => err.help(msg),\n+                };\n+                match codemap.span_to_snippet(rhs_expr.span) {\n+                    Ok(rstring) => {\n+                        err.span_suggestion(rhs_expr.span,\n+                                            \"you also need to borrow the `String` on the right to \\\n+                                             get a `&str`\",\n+                                            format!(\"&{}\", rstring));\n+                    }\n+                    _ => {}\n+                };\n+                true\n+            }\n+            _ => false,\n         }\n-\n-        is_string_addition\n     }\n \n     pub fn check_user_unop(&self,"}, {"sha": "44ac7a10e8287634637b692237a1fcbcf01095c1", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -14,7 +14,7 @@\n //! We walk the set of items and, for each member, generate new constraints.\n \n use hir::def_id::DefId;\n-use rustc::ty::subst::Substs;\n+use rustc::ty::subst::{Substs, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n use syntax::ast;\n use rustc::hir;\n@@ -381,12 +381,13 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n                    variance_decl,\n                    variance_i);\n-            if let Some(ty) = k.as_type() {\n-                self.add_constraints_from_ty(current, ty, variance_i);\n-            } else if let Some(r) = k.as_region() {\n-                self.add_constraints_from_region(current, r, variance_i);\n-            } else {\n-                bug!();\n+            match k.unpack() {\n+                UnpackedKind::Lifetime(lt) => {\n+                    self.add_constraints_from_region(current, lt, variance_i)\n+                }\n+                UnpackedKind::Type(ty) => {\n+                    self.add_constraints_from_ty(current, ty, variance_i)\n+                }\n             }\n         }\n     }"}, {"sha": "b382ba7f22da713bfa20fb37c662fab4e6461282", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -512,7 +512,16 @@ fn separate_supertrait_bounds(mut g: clean::Generics)\n }\n \n pub fn record_extern_trait(cx: &DocContext, did: DefId) {\n-    cx.external_traits.borrow_mut().entry(did).or_insert_with(|| {\n-        build_external_trait(cx, did)\n-    });\n+    if cx.external_traits.borrow().contains_key(&did) ||\n+        cx.active_extern_traits.borrow().contains(&did)\n+    {\n+        return;\n+    }\n+\n+    cx.active_extern_traits.borrow_mut().push(did);\n+\n+    let trait_ = build_external_trait(cx, did);\n+\n+    cx.external_traits.borrow_mut().insert(did, trait_);\n+    cx.active_extern_traits.borrow_mut().remove_item(&did);\n }"}, {"sha": "9ee0937f425c90cbbb0a88125c16c2cae4ac47ec", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -61,6 +61,9 @@ pub struct DocContext<'a, 'tcx: 'a, 'rcx: 'a> {\n     pub renderinfo: RefCell<RenderInfo>,\n     /// Later on moved through `clean::Crate` into `html::render::CACHE_KEY`\n     pub external_traits: RefCell<FxHashMap<DefId, clean::Trait>>,\n+    /// Used while populating `external_traits` to ensure we don't process the same trait twice at\n+    /// the same time.\n+    pub active_extern_traits: RefCell<Vec<DefId>>,\n     // The current set of type and lifetime substitutions,\n     // for expanding type aliases at the HIR level:\n \n@@ -253,6 +256,7 @@ pub fn run_core(search_paths: SearchPaths,\n             populated_all_crate_impls: Cell::new(false),\n             access_levels: RefCell::new(access_levels),\n             external_traits: Default::default(),\n+            active_extern_traits: Default::default(),\n             renderinfo: Default::default(),\n             ty_substs: Default::default(),\n             lt_substs: Default::default(),"}, {"sha": "4bbad30a5a3152cac16732144274c154196b6bf1", "filename": "src/libstd/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -1825,7 +1825,7 @@ impl Path {\n     /// If the path is a normal file, this is the file name. If it's the path of a directory, this\n     /// is the directory name.\n     ///\n-    /// Returns [`None`] If the path terminates in `..`.\n+    /// Returns [`None`] if the path terminates in `..`.\n     ///\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///"}, {"sha": "6609b77b132c62f27dec7f5c3ea4c61c182a1bc9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -1085,7 +1085,7 @@ pub enum ExprKind {\n     /// `if let pat = expr { block } else { expr }`\n     ///\n     /// This is desugared to a `match` expression.\n-    IfLet(P<Pat>, P<Expr>, P<Block>, Option<P<Expr>>),\n+    IfLet(Vec<P<Pat>>, P<Expr>, P<Block>, Option<P<Expr>>),\n     /// A while loop, with an optional label\n     ///\n     /// `'label: while expr { block }`\n@@ -1095,7 +1095,7 @@ pub enum ExprKind {\n     /// `'label: while let pat = expr { block }`\n     ///\n     /// This is desugared to a combination of `loop` and `match` expressions.\n-    WhileLet(P<Pat>, P<Expr>, P<Block>, Option<Label>),\n+    WhileLet(Vec<P<Pat>>, P<Expr>, P<Block>, Option<Label>),\n     /// A for loop, with an optional label\n     ///\n     /// `'label: for pat in expr { block }`"}, {"sha": "1ebf52e9fe8c016a43512c48e545e10d563a9d48", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -446,6 +446,9 @@ declare_features! (\n \n     // Use `?` as the Kleene \"at most one\" operator\n     (active, macro_at_most_once_rep, \"1.25.0\", Some(48075)),\n+\n+    // Multiple patterns with `|` in `if let` and `while let`\n+    (active, if_while_or_patterns, \"1.26.0\", Some(48215)),\n );\n \n declare_features! (\n@@ -1618,6 +1621,12 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::ExprKind::Catch(_) => {\n                 gate_feature_post!(&self, catch_expr, e.span, \"`catch` expression is experimental\");\n             }\n+            ast::ExprKind::IfLet(ref pats, ..) | ast::ExprKind::WhileLet(ref pats, ..) => {\n+                if pats.len() > 1 {\n+                    gate_feature_post!(&self, if_while_or_patterns, e.span,\n+                                    \"multiple patterns in `if let` and `while let` are unstable\");\n+                }\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);"}, {"sha": "e8eb75f5e6018e6e97e1c39d6cdbd1caf8d79130", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -1210,8 +1210,8 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                        folder.fold_block(tr),\n                        fl.map(|x| folder.fold_expr(x)))\n             }\n-            ExprKind::IfLet(pat, expr, tr, fl) => {\n-                ExprKind::IfLet(folder.fold_pat(pat),\n+            ExprKind::IfLet(pats, expr, tr, fl) => {\n+                ExprKind::IfLet(pats.move_map(|pat| folder.fold_pat(pat)),\n                           folder.fold_expr(expr),\n                           folder.fold_block(tr),\n                           fl.map(|x| folder.fold_expr(x)))\n@@ -1221,8 +1221,8 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                           folder.fold_block(body),\n                           opt_label.map(|label| folder.fold_label(label)))\n             }\n-            ExprKind::WhileLet(pat, expr, body, opt_label) => {\n-                ExprKind::WhileLet(folder.fold_pat(pat),\n+            ExprKind::WhileLet(pats, expr, body, opt_label) => {\n+                ExprKind::WhileLet(pats.move_map(|pat| folder.fold_pat(pat)),\n                              folder.fold_expr(expr),\n                              folder.fold_block(body),\n                              opt_label.map(|label| folder.fold_label(label)))"}, {"sha": "4d457f4864af0050587f86a75a52a0e953441ab4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -405,11 +405,14 @@ impl TokenType {\n     }\n }\n \n-// Returns true if `IDENT t` can start a type - `IDENT::a::b`, `IDENT<u8, u8>`,\n-// `IDENT<<u8 as Trait>::AssocTy>`, `IDENT(u8, u8) -> u8`.\n-fn can_continue_type_after_ident(t: &token::Token) -> bool {\n+/// Returns true if `IDENT t` can start a type - `IDENT::a::b`, `IDENT<u8, u8>`,\n+/// `IDENT<<u8 as Trait>::AssocTy>`.\n+///\n+/// Types can also be of the form `IDENT(u8, u8) -> u8`, however this assumes\n+/// that IDENT is not the ident of a fn trait\n+fn can_continue_type_after_non_fn_ident(t: &token::Token) -> bool {\n     t == &token::ModSep || t == &token::Lt ||\n-    t == &token::BinOp(token::Shl) || t == &token::OpenDelim(token::Paren)\n+    t == &token::BinOp(token::Shl)\n }\n \n /// Information about the path to a module.\n@@ -1321,7 +1324,7 @@ impl<'a> Parser<'a> {\n     pub fn token_is_bare_fn_keyword(&mut self) -> bool {\n         self.check_keyword(keywords::Fn) ||\n             self.check_keyword(keywords::Unsafe) ||\n-            self.check_keyword(keywords::Extern)\n+            self.check_keyword(keywords::Extern) && self.is_extern_non_path()\n     }\n \n     fn eat_label(&mut self) -> Option<Label> {\n@@ -1619,7 +1622,8 @@ impl<'a> Parser<'a> {\n             impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n             TyKind::ImplTrait(bounds)\n         } else if self.check_keyword(keywords::Dyn) &&\n-                  self.look_ahead(1, |t| t.can_begin_bound() && !can_continue_type_after_ident(t)) {\n+                  self.look_ahead(1, |t| t.can_begin_bound() &&\n+                                         !can_continue_type_after_non_fn_ident(t)) {\n             self.bump(); // `dyn`\n             // Always parse bounds greedily for better error recovery.\n             let bounds = self.parse_ty_param_bounds()?;\n@@ -3224,7 +3228,7 @@ impl<'a> Parser<'a> {\n                              -> PResult<'a, P<Expr>> {\n         let lo = self.prev_span;\n         self.expect_keyword(keywords::Let)?;\n-        let pat = self.parse_pat()?;\n+        let pats = self.parse_pats()?;\n         self.expect(&token::Eq)?;\n         let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n         let thn = self.parse_block()?;\n@@ -3234,7 +3238,7 @@ impl<'a> Parser<'a> {\n         } else {\n             (thn.span, None)\n         };\n-        Ok(self.mk_expr(lo.to(hi), ExprKind::IfLet(pat, expr, thn, els), attrs))\n+        Ok(self.mk_expr(lo.to(hi), ExprKind::IfLet(pats, expr, thn, els), attrs))\n     }\n \n     // `move |args| expr`\n@@ -3325,13 +3329,13 @@ impl<'a> Parser<'a> {\n                                 span_lo: Span,\n                                 mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         self.expect_keyword(keywords::Let)?;\n-        let pat = self.parse_pat()?;\n+        let pats = self.parse_pats()?;\n         self.expect(&token::Eq)?;\n         let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         let span = span_lo.to(body.span);\n-        return Ok(self.mk_expr(span, ExprKind::WhileLet(pat, expr, body, opt_label), attrs));\n+        return Ok(self.mk_expr(span, ExprKind::WhileLet(pats, expr, body, opt_label), attrs));\n     }\n \n     // parse `loop {...}`, `loop` token already eaten"}, {"sha": "9cad9f46e98cfef05af3906fc9d24a2a763a16d5", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -1767,11 +1767,11 @@ impl<'a> State<'a> {\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"another else-if-let\"\n-                    ast::ExprKind::IfLet(ref pat, ref expr, ref then, ref e) => {\n+                    ast::ExprKind::IfLet(ref pats, ref expr, ref then, ref e) => {\n                         self.cbox(INDENT_UNIT - 1)?;\n                         self.ibox(0)?;\n                         self.s.word(\" else if let \")?;\n-                        self.print_pat(pat)?;\n+                        self.print_pats(pats)?;\n                         self.s.space()?;\n                         self.word_space(\"=\")?;\n                         self.print_expr_as_cond(expr)?;\n@@ -1805,10 +1805,10 @@ impl<'a> State<'a> {\n         self.print_else(elseopt)\n     }\n \n-    pub fn print_if_let(&mut self, pat: &ast::Pat, expr: &ast::Expr, blk: &ast::Block,\n+    pub fn print_if_let(&mut self, pats: &[P<ast::Pat>], expr: &ast::Expr, blk: &ast::Block,\n                         elseopt: Option<&ast::Expr>) -> io::Result<()> {\n         self.head(\"if let\")?;\n-        self.print_pat(pat)?;\n+        self.print_pats(pats)?;\n         self.s.space()?;\n         self.word_space(\"=\")?;\n         self.print_expr_as_cond(expr)?;\n@@ -2109,8 +2109,8 @@ impl<'a> State<'a> {\n             ast::ExprKind::If(ref test, ref blk, ref elseopt) => {\n                 self.print_if(test, blk, elseopt.as_ref().map(|e| &**e))?;\n             }\n-            ast::ExprKind::IfLet(ref pat, ref expr, ref blk, ref elseopt) => {\n-                self.print_if_let(pat, expr, blk, elseopt.as_ref().map(|e| &**e))?;\n+            ast::ExprKind::IfLet(ref pats, ref expr, ref blk, ref elseopt) => {\n+                self.print_if_let(pats, expr, blk, elseopt.as_ref().map(|e| &**e))?;\n             }\n             ast::ExprKind::While(ref test, ref blk, opt_label) => {\n                 if let Some(label) = opt_label {\n@@ -2122,13 +2122,13 @@ impl<'a> State<'a> {\n                 self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n-            ast::ExprKind::WhileLet(ref pat, ref expr, ref blk, opt_label) => {\n+            ast::ExprKind::WhileLet(ref pats, ref expr, ref blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while let\")?;\n-                self.print_pat(pat)?;\n+                self.print_pats(pats)?;\n                 self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_expr_as_cond(expr)?;\n@@ -2664,6 +2664,20 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodePat(pat))\n     }\n \n+    fn print_pats(&mut self, pats: &[P<ast::Pat>]) -> io::Result<()> {\n+        let mut first = true;\n+        for p in pats {\n+            if first {\n+                first = false;\n+            } else {\n+                self.s.space()?;\n+                self.word_space(\"|\")?;\n+            }\n+            self.print_pat(p)?;\n+        }\n+        Ok(())\n+    }\n+\n     fn print_arm(&mut self, arm: &ast::Arm) -> io::Result<()> {\n         // I have no idea why this check is necessary, but here it\n         // is :(\n@@ -2674,16 +2688,7 @@ impl<'a> State<'a> {\n         self.ibox(0)?;\n         self.maybe_print_comment(arm.pats[0].span.lo())?;\n         self.print_outer_attributes(&arm.attrs)?;\n-        let mut first = true;\n-        for p in &arm.pats {\n-            if first {\n-                first = false;\n-            } else {\n-                self.s.space()?;\n-                self.word_space(\"|\")?;\n-            }\n-            self.print_pat(p)?;\n-        }\n+        self.print_pats(&arm.pats)?;\n         self.s.space()?;\n         if let Some(ref e) = arm.guard {\n             self.word_space(\"if\")?;"}, {"sha": "640f90ecb4a4367e57d9b4b32b4f1bf1966f6279", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -705,15 +705,15 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n         }\n-        ExprKind::IfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n-            visitor.visit_pat(pattern);\n+        ExprKind::IfLet(ref pats, ref subexpression, ref if_block, ref optional_else) => {\n+            walk_list!(visitor, visit_pat, pats);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprKind::WhileLet(ref pattern, ref subexpression, ref block, ref opt_label) => {\n+        ExprKind::WhileLet(ref pats, ref subexpression, ref block, ref opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n-            visitor.visit_pat(pattern);\n+            walk_list!(visitor, visit_pat, pats);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n         }"}, {"sha": "2a14b3da7b7d01ecc43cb056f5bbca9fc7fe9ecf", "filename": "src/test/auxiliary/rust_test_helpers.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fauxiliary%2Frust_test_helpers.c", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fauxiliary%2Frust_test_helpers.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Frust_test_helpers.c?ref=026339e42ba11a559767029d933d1197aefb877a", "previous_filename": "src/rt/rust_test_helpers.c"}, {"sha": "f4c36157fe98a431ea7cd7d760555882e4617954", "filename": "src/test/compile-fail/borrowck/two-phase-nonrecv-autoref.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -30,8 +30,6 @@\n // #![feature(rustc_attrs)]\n \n use std::ops::{Index, IndexMut};\n-use std::ops::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign};\n-use std::ops::{BitAndAssign, BitOrAssign, BitXorAssign, ShlAssign, ShrAssign};\n \n // This is case outlined by Niko that we want to ensure we reject\n // (at least initially).\n@@ -182,56 +180,6 @@ fn coerce_index_op() {\n     //[nll]~^^ ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n }\n \n-struct A(i32);\n-\n-macro_rules! trivial_binop {\n-    ($Trait:ident, $m:ident) => {\n-        impl $Trait<i32> for A { fn $m(&mut self, rhs: i32) { self.0 = rhs; } }\n-    }\n-}\n-\n-trivial_binop!(AddAssign, add_assign);\n-trivial_binop!(SubAssign, sub_assign);\n-trivial_binop!(MulAssign, mul_assign);\n-trivial_binop!(DivAssign, div_assign);\n-trivial_binop!(RemAssign, rem_assign);\n-trivial_binop!(BitAndAssign, bitand_assign);\n-trivial_binop!(BitOrAssign, bitor_assign);\n-trivial_binop!(BitXorAssign, bitxor_assign);\n-trivial_binop!(ShlAssign, shl_assign);\n-trivial_binop!(ShrAssign, shr_assign);\n-\n-fn overloaded_binops() {\n-    let mut a = A(10);\n-    a += a.0;\n-    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n-    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n-    a -= a.0;\n-    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n-    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n-    a *= a.0;\n-    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n-    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n-    a /= a.0;\n-    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n-    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n-    a &= a.0;\n-    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n-    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n-    a |= a.0;\n-    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n-    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n-    a ^= a.0;\n-    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n-    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n-    a <<= a.0;\n-    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n-    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n-    a >>= a.0;\n-    //[lxl]~^   ERROR cannot use `a.0` because it was mutably borrowed\n-    //[nll]~^^  ERROR cannot use `a.0` because it was mutably borrowed\n-}\n-\n fn main() {\n \n     // As a reminder, this is the basic case we want to ensure we handle.\n@@ -252,5 +200,4 @@ fn main() {\n \n     coerce_unsized();\n     coerce_index_op();\n-    overloaded_binops();\n }"}, {"sha": "454b6d2f566eb3cad53e027ba0c43359c5b52766", "filename": "src/test/compile-fail/dyn-trait-compatibility.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fcompile-fail%2Fdyn-trait-compatibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fcompile-fail%2Fdyn-trait-compatibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdyn-trait-compatibility.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -20,10 +20,5 @@ type A3 = dyn<<dyn as dyn>::dyn>;\n //~^ ERROR cannot find type `dyn` in this scope\n //~| ERROR cannot find type `dyn` in this scope\n //~| ERROR Use of undeclared type or module `dyn`\n-type A4 = dyn(dyn, dyn) -> dyn;\n-//~^ ERROR cannot find type `dyn` in this scope\n-//~| ERROR cannot find type `dyn` in this scope\n-//~| ERROR cannot find type `dyn` in this scope\n-//~| ERROR cannot find type `dyn` in this scope\n \n fn main() {}"}, {"sha": "1b2529d7875ab436a998d5e1e5c75ac983248959", "filename": "src/test/run-pass/borrowck/two-phase-bin-ops.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Frun-pass%2Fborrowck%2Ftwo-phase-bin-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Frun-pass%2Fborrowck%2Ftwo-phase-bin-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck%2Ftwo-phase-bin-ops.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: lxl nll\n+\n+#![cfg_attr(nll, feature(nll))]\n+\n+use std::ops::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign};\n+use std::ops::{BitAndAssign, BitOrAssign, BitXorAssign, ShlAssign, ShrAssign};\n+\n+struct A(i32);\n+\n+macro_rules! trivial_binop {\n+    ($Trait:ident, $m:ident) => {\n+        impl $Trait<i32> for A { fn $m(&mut self, rhs: i32) { self.0 = rhs; } }\n+    }\n+}\n+\n+trivial_binop!(AddAssign, add_assign);\n+trivial_binop!(SubAssign, sub_assign);\n+trivial_binop!(MulAssign, mul_assign);\n+trivial_binop!(DivAssign, div_assign);\n+trivial_binop!(RemAssign, rem_assign);\n+trivial_binop!(BitAndAssign, bitand_assign);\n+trivial_binop!(BitOrAssign, bitor_assign);\n+trivial_binop!(BitXorAssign, bitxor_assign);\n+trivial_binop!(ShlAssign, shl_assign);\n+trivial_binop!(ShrAssign, shr_assign);\n+\n+fn main() {\n+    let mut a = A(10);\n+    a += a.0;\n+    a -= a.0;\n+    a *= a.0;\n+    a /= a.0;\n+    a &= a.0;\n+    a |= a.0;\n+    a ^= a.0;\n+    a <<= a.0;\n+    a >>= a.0;\n+}"}, {"sha": "fdec6a26ac945bace66b4fefb6303c506d9a6529", "filename": "src/test/run-pass/dyn-trait.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Frun-pass%2Fdyn-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Frun-pass%2Fdyn-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdyn-trait.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty `dyn ::foo` parses differently in the current epoch\n+\n #![feature(dyn_trait)]\n \n use std::fmt::Display;\n@@ -17,6 +19,8 @@ static BYTE: u8 = 33;\n fn main() {\n     let x: &(dyn 'static + Display) = &BYTE;\n     let y: Box<dyn Display + 'static> = Box::new(BYTE);\n+    let _: &dyn (Display) = &BYTE;\n+    let _: &dyn (::std::fmt::Display) = &BYTE;\n     let xstr = format!(\"{}\", x);\n     let ystr = format!(\"{}\", y);\n     assert_eq!(xstr, \"33\");"}, {"sha": "f980ef0ccdddaf9f4fd917f2385afeed50307ff3", "filename": "src/test/run-pass/rfc-2005-default-binding-mode/reset-mode.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Freset-mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Freset-mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2005-default-binding-mode%2Freset-mode.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(match_default_bindings)]\n+\n+// Test that we \"reset\" the mode as we pass through a `&` pattern.\n+//\n+// cc #46688\n+\n+fn surprise(x: i32) {\n+    assert_eq!(x, 2);\n+}\n+\n+fn main() {\n+    let x = &(1, &2);\n+    let (_, &b) = x;\n+    surprise(b);\n+}"}, {"sha": "a5214d796cd6253291f9b66867517bc029c6a518", "filename": "src/test/run-pass/rfc-2126-extern-absolute-paths/auxiliary/xcrate.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Frun-pass%2Frfc-2126-extern-absolute-paths%2Fauxiliary%2Fxcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Frun-pass%2Frfc-2126-extern-absolute-paths%2Fauxiliary%2Fxcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2126-extern-absolute-paths%2Fauxiliary%2Fxcrate.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[derive(Debug)]\n+#[derive(Debug, PartialEq)]\n pub struct S;\n \n #[derive(Debug)]\n pub struct Z;\n+\n+pub trait Tr<'a> {}"}, {"sha": "15b754e1fe6b2ae500fe83289ec2b299421c9c3e", "filename": "src/test/run-pass/rfc-2126-extern-absolute-paths/extern.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Frun-pass%2Frfc-2126-extern-absolute-paths%2Fextern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Frun-pass%2Frfc-2126-extern-absolute-paths%2Fextern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2126-extern-absolute-paths%2Fextern.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -14,6 +14,9 @@\n \n use extern::xcrate::Z;\n \n+type A = extern::xcrate::S;\n+type B = for<'a> extern::xcrate::Tr<'a>;\n+\n fn f() {\n     use extern::xcrate;\n     use extern::xcrate as ycrate;\n@@ -28,4 +31,5 @@ fn main() {\n     assert_eq!(format!(\"{:?}\", s), \"S\");\n     let z = Z;\n     assert_eq!(format!(\"{:?}\", z), \"Z\");\n+    assert_eq!(A {}, extern::xcrate::S {});\n }"}, {"sha": "a516a3e5dcd75967253c9c9a39e57d791341bde5", "filename": "src/test/run-pass/rfc-2175-or-if-while-let/basic.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Frun-pass%2Frfc-2175-or-if-while-let%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Frun-pass%2Frfc-2175-or-if-while-let%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2175-or-if-while-let%2Fbasic.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(if_while_or_patterns)]\n+\n+enum E {\n+    V(u8),\n+    U(u8),\n+    W,\n+}\n+use E::*;\n+\n+fn main() {\n+    let mut e = V(10);\n+\n+    if let V(x) | U(x) = e {\n+        assert_eq!(x, 10);\n+    }\n+    while let V(x) | U(x) = e {\n+        assert_eq!(x, 10);\n+        e = W;\n+    }\n+}"}, {"sha": "7e0edf76f6ac9d18c48e8d6f71a6d52562c947f2", "filename": "src/test/rustdoc/auxiliary/issue-48414.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Frustdoc%2Fauxiliary%2Fissue-48414.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Frustdoc%2Fauxiliary%2Fissue-48414.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fissue-48414.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// Woah, this trait links to [OtherTrait](OtherTrait)!\n+pub trait SomeTrait {}\n+\n+/// Woah, this trait links to [SomeTrait](SomeTrait)!\n+pub trait OtherTrait {}"}, {"sha": "0136f9c4759c7660edf77fd6c519382881d52077", "filename": "src/test/rustdoc/issue-48414.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Frustdoc%2Fissue-48414.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Frustdoc%2Fissue-48414.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-48414.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-48414.rs\n+\n+// ICE when resolving paths for a trait that linked to another trait, when both were in an external\n+// crate\n+\n+#![crate_name = \"base\"]\n+\n+extern crate issue_48414;\n+\n+#[doc(inline)]\n+pub use issue_48414::{SomeTrait, OtherTrait};"}, {"sha": "3df140c77fc811e3d4f1da9528eb340ea2168e4f", "filename": "src/test/ui/feature-gate-if_while_or_patterns.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fui%2Ffeature-gate-if_while_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fui%2Ffeature-gate-if_while_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-if_while_or_patterns.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    if let 0 | 1 = 0 { //~ ERROR multiple patterns in `if let` and `while let` are unstable\n+        ;\n+    }\n+    while let 0 | 1 = 1 { //~ ERROR multiple patterns in `if let` and `while let` are unstable\n+        break;\n+    }\n+}"}, {"sha": "c906fa5a2f45af5198b088a06428a2e1fcd0bec9", "filename": "src/test/ui/feature-gate-if_while_or_patterns.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fui%2Ffeature-gate-if_while_or_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fui%2Ffeature-gate-if_while_or_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-if_while_or_patterns.stderr?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -0,0 +1,22 @@\n+error[E0658]: multiple patterns in `if let` and `while let` are unstable (see issue #48215)\n+  --> $DIR/feature-gate-if_while_or_patterns.rs:12:5\n+   |\n+12 | /     if let 0 | 1 = 0 { //~ ERROR multiple patterns in `if let` and `while let` are unstable\n+13 | |         ;\n+14 | |     }\n+   | |_____^\n+   |\n+   = help: add #![feature(if_while_or_patterns)] to the crate attributes to enable\n+\n+error[E0658]: multiple patterns in `if let` and `while let` are unstable (see issue #48215)\n+  --> $DIR/feature-gate-if_while_or_patterns.rs:15:5\n+   |\n+15 | /     while let 0 | 1 = 1 { //~ ERROR multiple patterns in `if let` and `while let` are unstable\n+16 | |         break;\n+17 | |     }\n+   | |_____^\n+   |\n+   = help: add #![feature(if_while_or_patterns)] to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "cff338f76c507b675fcce9137f96eb5ed3bd86b2", "filename": "src/test/ui/issue-45157.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fui%2Fissue-45157.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fui%2Fissue-45157.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-45157.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused)]\n+#![feature(nll)]\n+\n+#[derive(Clone, Copy, Default)]\n+struct S {\n+    a: u8,\n+    b: u8,\n+}\n+#[derive(Clone, Copy, Default)]\n+struct Z {\n+    c: u8,\n+    d: u8,\n+}\n+\n+union U {\n+    s: S,\n+    z: Z,\n+}\n+\n+fn main() {\n+    unsafe {\n+        let mut u = U { s: Default::default() };\n+\n+        let mref = &mut u.s.a;\n+        *mref = 22;\n+\n+        let nref = &u.z.c;\n+        //~^ ERROR cannot borrow `u.z.c` as immutable because it is also borrowed as mutable [E0502]\n+        println!(\"{} {}\", mref, nref)\n+        //~^ ERROR cannot borrow `u.s.a` as mutable because it is also borrowed as immutable [E0502]\n+    }\n+}\n+"}, {"sha": "e133aab31bc0110ddfbaaa96a190ed024b946be3", "filename": "src/test/ui/issue-45157.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fui%2Fissue-45157.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fui%2Fissue-45157.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-45157.stderr?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -0,0 +1,20 @@\n+error[E0502]: cannot borrow `u.z.c` as immutable because it is also borrowed as mutable\n+  --> $DIR/issue-45157.rs:37:20\n+   |\n+34 |         let mref = &mut u.s.a;\n+   |                    ---------- mutable borrow occurs here\n+...\n+37 |         let nref = &u.z.c;\n+   |                    ^^^^^^ immutable borrow occurs here\n+\n+error[E0502]: cannot borrow `u.s.a` as mutable because it is also borrowed as immutable\n+  --> $DIR/issue-45157.rs:39:27\n+   |\n+37 |         let nref = &u.z.c;\n+   |                    ------ immutable borrow occurs here\n+38 |         //~^ ERROR cannot borrow `u.z.c` as immutable because it is also borrowed as mutable [E0502]\n+39 |         println!(\"{} {}\", mref, nref)\n+   |                           ^^^^ mutable borrow occurs here\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "55d6168e6e0085205d0044dca7e8f4ab517d8c7a", "filename": "src/test/ui/lint/lint-group-nonstandard-style.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fui%2Flint%2Flint-group-nonstandard-style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fui%2Flint%2Flint-group-nonstandard-style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-group-nonstandard-style.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014\u20132017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(nonstandard_style)]\n+#![allow(dead_code)]\n+\n+fn CamelCase() {} //~ ERROR should have a snake\n+\n+#[allow(nonstandard_style)]\n+mod test {\n+    fn CamelCase() {}\n+\n+    #[forbid(nonstandard_style)]\n+    mod bad {\n+        fn CamelCase() {} //~ ERROR should have a snake\n+\n+        static bad: isize = 1; //~ ERROR should have an upper\n+    }\n+\n+    mod warn {\n+        #![warn(nonstandard_style)]\n+\n+        fn CamelCase() {} //~ WARN should have a snake\n+\n+        struct snake_case; //~ WARN should have a camel\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "b0ce19e35eec7ce199cd3a9bcf2da2382aa240c9", "filename": "src/test/ui/lint/lint-group-nonstandard-style.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fui%2Flint%2Flint-group-nonstandard-style.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fui%2Flint%2Flint-group-nonstandard-style.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-group-nonstandard-style.stderr?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -0,0 +1,67 @@\n+error: function `CamelCase` should have a snake case name such as `camel_case`\n+  --> $DIR/lint-group-nonstandard-style.rs:14:1\n+   |\n+14 | fn CamelCase() {} //~ ERROR should have a snake\n+   | ^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/lint-group-nonstandard-style.rs:11:9\n+   |\n+11 | #![deny(nonstandard_style)]\n+   |         ^^^^^^^^^^^^^^^^^\n+   = note: #[deny(non_snake_case)] implied by #[deny(nonstandard_style)]\n+\n+error: function `CamelCase` should have a snake case name such as `camel_case`\n+  --> $DIR/lint-group-nonstandard-style.rs:22:9\n+   |\n+22 |         fn CamelCase() {} //~ ERROR should have a snake\n+   |         ^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/lint-group-nonstandard-style.rs:20:14\n+   |\n+20 |     #[forbid(nonstandard_style)]\n+   |              ^^^^^^^^^^^^^^^^^\n+   = note: #[forbid(non_snake_case)] implied by #[forbid(nonstandard_style)]\n+\n+error: static variable `bad` should have an upper case name such as `BAD`\n+  --> $DIR/lint-group-nonstandard-style.rs:24:9\n+   |\n+24 |         static bad: isize = 1; //~ ERROR should have an upper\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/lint-group-nonstandard-style.rs:20:14\n+   |\n+20 |     #[forbid(nonstandard_style)]\n+   |              ^^^^^^^^^^^^^^^^^\n+   = note: #[forbid(non_upper_case_globals)] implied by #[forbid(nonstandard_style)]\n+\n+warning: function `CamelCase` should have a snake case name such as `camel_case`\n+  --> $DIR/lint-group-nonstandard-style.rs:30:9\n+   |\n+30 |         fn CamelCase() {} //~ WARN should have a snake\n+   |         ^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/lint-group-nonstandard-style.rs:28:17\n+   |\n+28 |         #![warn(nonstandard_style)]\n+   |                 ^^^^^^^^^^^^^^^^^\n+   = note: #[warn(non_snake_case)] implied by #[warn(nonstandard_style)]\n+\n+warning: type `snake_case` should have a camel case name such as `SnakeCase`\n+  --> $DIR/lint-group-nonstandard-style.rs:32:9\n+   |\n+32 |         struct snake_case; //~ WARN should have a camel\n+   |         ^^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/lint-group-nonstandard-style.rs:28:17\n+   |\n+28 |         #![warn(nonstandard_style)]\n+   |                 ^^^^^^^^^^^^^^^^^\n+   = note: #[warn(non_camel_case_types)] implied by #[warn(nonstandard_style)]\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "7b3288fd29cc190d956279022591c27d755a8800", "filename": "src/test/ui/span/issue-39018.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fui%2Fspan%2Fissue-39018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fui%2Fspan%2Fissue-39018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-39018.rs?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -17,6 +17,9 @@ pub fn main() {\n     // that won't output for the above string concatenation\n     let y = World::Hello + World::Goodbye;\n     //~^ ERROR cannot be applied to type\n+\n+    let x = \"Hello \" + \"World!\".to_owned();\n+    //~^ ERROR cannot be applied to type\n }\n \n enum World {"}, {"sha": "70f8ecf42cb2d91f5afbab1ffc69179a2dba0d72", "filename": "src/test/ui/span/issue-39018.stderr", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fui%2Fspan%2Fissue-39018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/026339e42ba11a559767029d933d1197aefb877a/src%2Ftest%2Fui%2Fspan%2Fissue-39018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-39018.stderr?ref=026339e42ba11a559767029d933d1197aefb877a", "patch": "@@ -16,5 +16,19 @@ error[E0369]: binary operation `+` cannot be applied to type `World`\n    |\n    = note: an implementation of `std::ops::Add` might be missing for `World`\n \n-error: aborting due to 2 previous errors\n+error[E0369]: binary operation `+` cannot be applied to type `&str`\n+  --> $DIR/issue-39018.rs:21:13\n+   |\n+21 |     let x = \"Hello \" + \"World!\".to_owned();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `+` can't be used to concatenate a `&str` with a `String`\n+help: `to_owned()` can be used to create an owned `String` from a string reference. String concatenation appends the string on the right to the string on the left and may require reallocation. This requires ownership of the string on the left\n+   |\n+21 |     let x = \"Hello \".to_owned() + \"World!\".to_owned();\n+   |             ^^^^^^^^^^^^^^^^^^^\n+help: you also need to borrow the `String` on the right to get a `&str`\n+   |\n+21 |     let x = \"Hello \" + &\"World!\".to_owned();\n+   |                        ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n "}]}