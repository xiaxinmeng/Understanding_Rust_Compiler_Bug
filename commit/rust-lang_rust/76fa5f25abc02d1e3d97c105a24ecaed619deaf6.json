{"sha": "76fa5f25abc02d1e3d97c105a24ecaed619deaf6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2ZmE1ZjI1YWJjMDJkMWUzZDk3YzEwNWEyNGVjYWVkNjE5ZGVhZjY=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-11-12T18:46:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-12T18:46:14Z"}, "message": "Rollup merge of #78950 - khyperia:spirv-asm, r=Amanieu\n\nAdd asm register information for SPIR-V\n\nAs discussed in [zulip](https://rust-lang.zulipchat.com/#narrow/stream/182449-t-compiler.2Fhelp/topic/Defining.20asm!.20for.20new.20architecture), we at [rust-gpu](https://github.com/EmbarkStudios/rust-gpu) would like to support `asm!` for our SPIR-V backend. However, we cannot do so purely without frontend support: [this match](https://github.com/rust-lang/rust/blob/d4ea0b3e46a0303d5802b632e88ba1ba84d9d16f/compiler/rustc_target/src/asm/mod.rs#L185) fails and so `asm!` is not supported ([error reported here](https://github.com/rust-lang/rust/blob/d4ea0b3e46a0303d5802b632e88ba1ba84d9d16f/compiler/rustc_ast_lowering/src/expr.rs#L1095)). To resolve this, we need to stub out register information for SPIR-V to support getting the `asm!` content all the way to [`AsmBuilderMethods::codegen_inline_asm`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/traits/trait.AsmBuilderMethods.html#tymethod.codegen_inline_asm), at which point the rust-gpu backend can do all the parsing and codegen that is needed.\n\nThis is a pretty weird PR - adding support for a backend that isn't in-tree feels pretty gross to me, but I don't see an easy way around this. ``@Amanieu`` said I should submit it anyway, so, here we are! Let me know if this needs to go through a more formal process (MCP?) and what I should do to help this along.\n\nI based this off the [wasm asm PR](https://github.com/rust-lang/rust/pull/78684), which unfortunately this PR conflicts with that one quite a bit, sorry for any merge conflict pain :(\n\n---\n\nSome open questions:\n\n- What do we call the register class? Some context, SPIR-V is an SSA-based IR, there are \"instructions\" that create IDs (referred to as `<id>` in the spec), which can be referenced by other instructions. So, `reg` isn't exactly accurate, they're SSA IDs, not re-assignable registers.\n- What happens when a SPIR-V register gets to the LLVM backend? Right now it's a `bug!`, but should that be a `sess.fatal()`? I'm not sure if it's even possible to reach that point, maybe there's a check that prevents the `spirv` target from even reaching that codepath.", "tree": {"sha": "289e1537ea4a48877349ad1c01cc3ae92c56810e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/289e1537ea4a48877349ad1c01cc3ae92c56810e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76fa5f25abc02d1e3d97c105a24ecaed619deaf6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfrYL2CRBK7hj4Ov3rIwAAdHIIABbP3f0a9U5uA6TSPSLtyQlY\nNkYxJJOh2XoqlGJfNk/oKeMA0Kp3268lfW1/p0emB40RUU8ZuuqwbDhYQ6SJ5sSm\nKb2jqMrzmGaivEBiqfZ4RJwiQY7tlTm53IIwnmJJWii/zFXJpJ/3PlgWb5KNktUG\n1NpebGODOBFXYnVahVNAEdlKXl5ixPJpA+G19jUfQxOYytmKEll84x9kISL4u3on\nCInUevBKFF706mmtYCricxkpxw6UjHx+iOl6ey4J0kE092KD4exvwSVZ/LoZRAGH\nbyUuYDnlzsvPP8sWCDD9LFopeeIYzYrvKqGANDNDlOMUaMbniu8TlZLrVVgbQmE=\n=OLd0\n-----END PGP SIGNATURE-----\n", "payload": "tree 289e1537ea4a48877349ad1c01cc3ae92c56810e\nparent 40889819ee8bf53aa880bace5ae472bdb84c797d\nparent 0e34b73996e87bb3f761b52616b3ac0e081fa84d\nauthor Mara Bos <m-ou.se@m-ou.se> 1605206774 +0100\ncommitter GitHub <noreply@github.com> 1605206774 +0100\n\nRollup merge of #78950 - khyperia:spirv-asm, r=Amanieu\n\nAdd asm register information for SPIR-V\n\nAs discussed in [zulip](https://rust-lang.zulipchat.com/#narrow/stream/182449-t-compiler.2Fhelp/topic/Defining.20asm!.20for.20new.20architecture), we at [rust-gpu](https://github.com/EmbarkStudios/rust-gpu) would like to support `asm!` for our SPIR-V backend. However, we cannot do so purely without frontend support: [this match](https://github.com/rust-lang/rust/blob/d4ea0b3e46a0303d5802b632e88ba1ba84d9d16f/compiler/rustc_target/src/asm/mod.rs#L185) fails and so `asm!` is not supported ([error reported here](https://github.com/rust-lang/rust/blob/d4ea0b3e46a0303d5802b632e88ba1ba84d9d16f/compiler/rustc_ast_lowering/src/expr.rs#L1095)). To resolve this, we need to stub out register information for SPIR-V to support getting the `asm!` content all the way to [`AsmBuilderMethods::codegen_inline_asm`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/traits/trait.AsmBuilderMethods.html#tymethod.codegen_inline_asm), at which point the rust-gpu backend can do all the parsing and codegen that is needed.\n\nThis is a pretty weird PR - adding support for a backend that isn't in-tree feels pretty gross to me, but I don't see an easy way around this. ``@Amanieu`` said I should submit it anyway, so, here we are! Let me know if this needs to go through a more formal process (MCP?) and what I should do to help this along.\n\nI based this off the [wasm asm PR](https://github.com/rust-lang/rust/pull/78684), which unfortunately this PR conflicts with that one quite a bit, sorry for any merge conflict pain :(\n\n---\n\nSome open questions:\n\n- What do we call the register class? Some context, SPIR-V is an SSA-based IR, there are \"instructions\" that create IDs (referred to as `<id>` in the spec), which can be referenced by other instructions. So, `reg` isn't exactly accurate, they're SSA IDs, not re-assignable registers.\n- What happens when a SPIR-V register gets to the LLVM backend? Right now it's a `bug!`, but should that be a `sess.fatal()`? I'm not sure if it's even possible to reach that point, maybe there's a check that prevents the `spirv` target from even reaching that codepath.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76fa5f25abc02d1e3d97c105a24ecaed619deaf6", "html_url": "https://github.com/rust-lang/rust/commit/76fa5f25abc02d1e3d97c105a24ecaed619deaf6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76fa5f25abc02d1e3d97c105a24ecaed619deaf6/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40889819ee8bf53aa880bace5ae472bdb84c797d", "url": "https://api.github.com/repos/rust-lang/rust/commits/40889819ee8bf53aa880bace5ae472bdb84c797d", "html_url": "https://github.com/rust-lang/rust/commit/40889819ee8bf53aa880bace5ae472bdb84c797d"}, {"sha": "0e34b73996e87bb3f761b52616b3ac0e081fa84d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e34b73996e87bb3f761b52616b3ac0e081fa84d", "html_url": "https://github.com/rust-lang/rust/commit/0e34b73996e87bb3f761b52616b3ac0e081fa84d"}], "stats": {"total": 79, "additions": 78, "deletions": 1}, "files": [{"sha": "b5d279eeb6f2fd1bf6b7638c32936137e036e582", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/76fa5f25abc02d1e3d97c105a24ecaed619deaf6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76fa5f25abc02d1e3d97c105a24ecaed619deaf6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=76fa5f25abc02d1e3d97c105a24ecaed619deaf6", "patch": "@@ -12,8 +12,8 @@ use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n-use rustc_middle::span_bug;\n use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_middle::{bug, span_bug};\n use rustc_span::{Pos, Span};\n use rustc_target::abi::*;\n use rustc_target::asm::*;\n@@ -260,6 +260,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 InlineAsmArch::Nvptx64 => {}\n                 InlineAsmArch::Hexagon => {}\n                 InlineAsmArch::Mips | InlineAsmArch::Mips64 => {}\n+                InlineAsmArch::SpirV => {}\n             }\n         }\n         if !options.contains(InlineAsmOptions::NOMEM) {\n@@ -518,6 +519,9 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'tcx>>)\n             | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg) => \"x\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => \"v\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => \"^Yk\",\n+            InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n+                bug!(\"LLVM backend does not support SPIR-V\")\n+            }\n         }\n         .to_string(),\n     }\n@@ -580,6 +584,9 @@ fn modifier_to_llvm(\n             _ => unreachable!(),\n         },\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => None,\n+        InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n+            bug!(\"LLVM backend does not support SPIR-V\")\n+        }\n     }\n }\n \n@@ -619,6 +626,9 @@ fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll\n         | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg)\n         | InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => cx.type_f32(),\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => cx.type_i16(),\n+        InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n+            bug!(\"LLVM backend does not support SPIR-V\")\n+        }\n     }\n }\n "}, {"sha": "5ebd6c4a2349f5a689656f22b6ee9ce77462cca4", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/76fa5f25abc02d1e3d97c105a24ecaed619deaf6/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76fa5f25abc02d1e3d97c105a24ecaed619deaf6/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=76fa5f25abc02d1e3d97c105a24ecaed619deaf6", "patch": "@@ -155,6 +155,7 @@ mod hexagon;\n mod mips;\n mod nvptx;\n mod riscv;\n+mod spirv;\n mod x86;\n \n pub use aarch64::{AArch64InlineAsmReg, AArch64InlineAsmRegClass};\n@@ -163,6 +164,7 @@ pub use hexagon::{HexagonInlineAsmReg, HexagonInlineAsmRegClass};\n pub use mips::{MipsInlineAsmReg, MipsInlineAsmRegClass};\n pub use nvptx::{NvptxInlineAsmReg, NvptxInlineAsmRegClass};\n pub use riscv::{RiscVInlineAsmReg, RiscVInlineAsmRegClass};\n+pub use spirv::{SpirVInlineAsmReg, SpirVInlineAsmRegClass};\n pub use x86::{X86InlineAsmReg, X86InlineAsmRegClass};\n \n #[derive(Copy, Clone, Encodable, Decodable, Debug, Eq, PartialEq, Hash)]\n@@ -177,6 +179,7 @@ pub enum InlineAsmArch {\n     Hexagon,\n     Mips,\n     Mips64,\n+    SpirV,\n }\n \n impl FromStr for InlineAsmArch {\n@@ -194,6 +197,7 @@ impl FromStr for InlineAsmArch {\n             \"hexagon\" => Ok(Self::Hexagon),\n             \"mips\" => Ok(Self::Mips),\n             \"mips64\" => Ok(Self::Mips64),\n+            \"spirv\" => Ok(Self::SpirV),\n             _ => Err(()),\n         }\n     }\n@@ -208,6 +212,7 @@ pub enum InlineAsmReg {\n     Nvptx(NvptxInlineAsmReg),\n     Hexagon(HexagonInlineAsmReg),\n     Mips(MipsInlineAsmReg),\n+    SpirV(SpirVInlineAsmReg),\n }\n \n impl InlineAsmReg {\n@@ -264,6 +269,9 @@ impl InlineAsmReg {\n             InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n                 Self::Mips(MipsInlineAsmReg::parse(arch, has_feature, target, &name)?)\n             }\n+            InlineAsmArch::SpirV => {\n+                Self::SpirV(SpirVInlineAsmReg::parse(arch, has_feature, target, &name)?)\n+            }\n         })\n     }\n \n@@ -306,6 +314,7 @@ pub enum InlineAsmRegClass {\n     Nvptx(NvptxInlineAsmRegClass),\n     Hexagon(HexagonInlineAsmRegClass),\n     Mips(MipsInlineAsmRegClass),\n+    SpirV(SpirVInlineAsmRegClass),\n }\n \n impl InlineAsmRegClass {\n@@ -318,6 +327,7 @@ impl InlineAsmRegClass {\n             Self::Nvptx(r) => r.name(),\n             Self::Hexagon(r) => r.name(),\n             Self::Mips(r) => r.name(),\n+            Self::SpirV(r) => r.name(),\n         }\n     }\n \n@@ -333,6 +343,7 @@ impl InlineAsmRegClass {\n             Self::Nvptx(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Nvptx),\n             Self::Hexagon(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Hexagon),\n             Self::Mips(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Mips),\n+            Self::SpirV(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::SpirV),\n         }\n     }\n \n@@ -355,6 +366,7 @@ impl InlineAsmRegClass {\n             Self::Nvptx(r) => r.suggest_modifier(arch, ty),\n             Self::Hexagon(r) => r.suggest_modifier(arch, ty),\n             Self::Mips(r) => r.suggest_modifier(arch, ty),\n+            Self::SpirV(r) => r.suggest_modifier(arch, ty),\n         }\n     }\n \n@@ -373,6 +385,7 @@ impl InlineAsmRegClass {\n             Self::Nvptx(r) => r.default_modifier(arch),\n             Self::Hexagon(r) => r.default_modifier(arch),\n             Self::Mips(r) => r.default_modifier(arch),\n+            Self::SpirV(r) => r.default_modifier(arch),\n         }\n     }\n \n@@ -390,6 +403,7 @@ impl InlineAsmRegClass {\n             Self::Nvptx(r) => r.supported_types(arch),\n             Self::Hexagon(r) => r.supported_types(arch),\n             Self::Mips(r) => r.supported_types(arch),\n+            Self::SpirV(r) => r.supported_types(arch),\n         }\n     }\n \n@@ -414,6 +428,7 @@ impl InlineAsmRegClass {\n                 InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n                     Self::Mips(MipsInlineAsmRegClass::parse(arch, name)?)\n                 }\n+                InlineAsmArch::SpirV => Self::SpirV(SpirVInlineAsmRegClass::parse(arch, name)?),\n             })\n         })\n     }\n@@ -429,6 +444,7 @@ impl InlineAsmRegClass {\n             Self::Nvptx(r) => r.valid_modifiers(arch),\n             Self::Hexagon(r) => r.valid_modifiers(arch),\n             Self::Mips(r) => r.valid_modifiers(arch),\n+            Self::SpirV(r) => r.valid_modifiers(arch),\n         }\n     }\n }\n@@ -571,5 +587,10 @@ pub fn allocatable_registers(\n             mips::fill_reg_map(arch, has_feature, target, &mut map);\n             map\n         }\n+        InlineAsmArch::SpirV => {\n+            let mut map = spirv::regclass_map();\n+            spirv::fill_reg_map(arch, has_feature, target, &mut map);\n+            map\n+        }\n     }\n }"}, {"sha": "da82749e96a16704719374cbe2fdafc23045aa69", "filename": "compiler/rustc_target/src/asm/spirv.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/76fa5f25abc02d1e3d97c105a24ecaed619deaf6/compiler%2Frustc_target%2Fsrc%2Fasm%2Fspirv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76fa5f25abc02d1e3d97c105a24ecaed619deaf6/compiler%2Frustc_target%2Fsrc%2Fasm%2Fspirv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fspirv.rs?ref=76fa5f25abc02d1e3d97c105a24ecaed619deaf6", "patch": "@@ -0,0 +1,46 @@\n+use super::{InlineAsmArch, InlineAsmType};\n+use rustc_macros::HashStable_Generic;\n+\n+def_reg_class! {\n+    SpirV SpirVInlineAsmRegClass {\n+        reg,\n+    }\n+}\n+\n+impl SpirVInlineAsmRegClass {\n+    pub fn valid_modifiers(self, _arch: super::InlineAsmArch) -> &'static [char] {\n+        &[]\n+    }\n+\n+    pub fn suggest_class(self, _arch: InlineAsmArch, _ty: InlineAsmType) -> Option<Self> {\n+        None\n+    }\n+\n+    pub fn suggest_modifier(\n+        self,\n+        _arch: InlineAsmArch,\n+        _ty: InlineAsmType,\n+    ) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn default_modifier(self, _arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn supported_types(\n+        self,\n+        _arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+        match self {\n+            Self::reg => {\n+                types! { _: I8, I16, I32, I64, F32, F64; }\n+            }\n+        }\n+    }\n+}\n+\n+def_regs! {\n+    // SPIR-V is SSA-based, it does not have registers.\n+    SpirV SpirVInlineAsmReg SpirVInlineAsmRegClass {}\n+}"}]}