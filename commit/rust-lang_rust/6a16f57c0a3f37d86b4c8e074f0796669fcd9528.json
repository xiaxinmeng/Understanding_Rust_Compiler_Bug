{"sha": "6a16f57c0a3f37d86b4c8e074f0796669fcd9528", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhMTZmNTdjMGEzZjM3ZDg2YjRjOGUwNzRmMDc5NjY2OWZjZDk1Mjg=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-02T09:15:21Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-16T10:46:57Z"}, "message": "Get a very primitive form of typechecking/resolving to work for impls\n\nNo conflict resolution or polymorphism yet.\n\nIssue #1227", "tree": {"sha": "36c18a257c443174f94678c0597785b749c5dc59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36c18a257c443174f94678c0597785b749c5dc59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a16f57c0a3f37d86b4c8e074f0796669fcd9528", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a16f57c0a3f37d86b4c8e074f0796669fcd9528", "html_url": "https://github.com/rust-lang/rust/commit/6a16f57c0a3f37d86b4c8e074f0796669fcd9528", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a16f57c0a3f37d86b4c8e074f0796669fcd9528/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "888bc80025262286f2270442cea86e20e60d5430", "url": "https://api.github.com/repos/rust-lang/rust/commits/888bc80025262286f2270442cea86e20e60d5430", "html_url": "https://github.com/rust-lang/rust/commit/888bc80025262286f2270442cea86e20e60d5430"}], "stats": {"total": 155, "additions": 93, "deletions": 62}, "files": [{"sha": "22d5945a792ba466de5fee29ac8a6239d6525ccf", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6a16f57c0a3f37d86b4c8e074f0796669fcd9528/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16f57c0a3f37d86b4c8e074f0796669fcd9528/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=6a16f57c0a3f37d86b4c8e074f0796669fcd9528", "patch": "@@ -19,7 +19,7 @@ import option::{some, none, is_none, is_some};\n import syntax::print::pprust::*;\n \n export resolve_crate;\n-export def_map, ext_map, exp_map, impl_map;\n+export def_map, ext_map, exp_map, impl_map, iscopes;\n \n // Resolving happens in two passes. The first pass collects defids of all\n // (internal) imports and modules, so that they can be looked up when needed,\n@@ -48,7 +48,7 @@ tag import_state {\n     resolved(option::t<def>, /* value */\n              option::t<def>, /* type */\n              option::t<def>, /* module */\n-             @[def_id],\n+             @[@ast::item],\n              /* used for reporting unused import warning */\n              ast::ident, codemap::span);\n }\n@@ -487,7 +487,7 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n                   ids: [ast::ident], sp: codemap::span, sc: scopes) {\n     fn register(e: env, id: node_id, cx: ctxt, sp: codemap::span,\n                 name: ast::ident, lookup: block(namespace) -> option::t<def>,\n-                impls: [def_id]) {\n+                impls: [@ast::item]) {\n         let val = lookup(ns_value), typ = lookup(ns_type),\n             md = lookup(ns_module);\n         if is_none(val) && is_none(typ) && is_none(md) {\n@@ -1623,13 +1623,14 @@ fn check_exports(e: @env) {\n fn resolve_impls(e: @env, c: @ast::crate) {\n     visit::visit_crate(*c, nil, visit::mk_vt(@{\n         visit_block: bind visit_block_with_impl_scope(e, _, _, _),\n-        visit_item: bind visit_item_with_impl_scope(e, _, _, _),\n+        visit_mod: bind visit_mod_with_impl_scope(e, _, _, _, _),\n         visit_expr: bind resolve_impl_in_expr(e, _, _, _)\n         with *visit::default_visitor()\n     }));\n }\n \n-fn find_impls_in_view_item(e: env, vi: @ast::view_item, &impls: [def_id]) {\n+fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n+                           &impls: [@ast::item]) {\n     alt vi.node {\n       ast::view_item_import(ident, _, id) {\n         // FIXME if single name, simply look in our own iscope\n@@ -1658,20 +1659,20 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item, &impls: [def_id]) {\n     }\n }\n \n-fn find_impls_in_item(i: @ast::item, &impls: [def_id],\n+fn find_impls_in_item(i: @ast::item, &impls: [@ast::item],\n                       name: option::t<ident>, _dir: dir) {\n     // FIXME check exports\n     alt i.node {\n       ast::item_impl(_, _, _) {\n         if alt name { some(n) { n == i.ident } _ { true } } {\n-            impls += [local_def(i.id)];\n+            impls += [i];\n         }\n       }\n       _ {}\n     }\n }\n \n-fn find_impls_in_mod(e: env, m: def, &impls: [def_id],\n+fn find_impls_in_mod(e: env, m: def, &impls: [@ast::item],\n                      name: option::t<ident>) {\n     alt m {\n       ast::def_mod(defid) {\n@@ -1686,7 +1687,7 @@ fn find_impls_in_mod(e: env, m: def, &impls: [def_id],\n     }\n }\n \n-type iscopes = list<@[def_id]>;\n+type iscopes = list<@[@ast::item]>;\n \n fn visit_block_with_impl_scope(e: @env, b: ast::blk, sc: iscopes,\n                                v: vt<iscopes>) {\n@@ -1704,19 +1705,12 @@ fn visit_block_with_impl_scope(e: @env, b: ast::blk, sc: iscopes,\n     visit::visit_block(b, sc, v);\n }\n \n-fn visit_item_with_impl_scope(e: @env, i: @ast::item, sc: iscopes,\n-                              v: vt<iscopes>) {\n-    let sc = sc;\n-    alt i.node {\n-      ast::item_mod(m) {\n-        let impls = [];\n-        for vi in m.view_items { find_impls_in_view_item(*e, vi, impls); }\n-        for i in m.items { find_impls_in_item(i, impls, none, inside); }\n-        if vec::len(impls) > 0u { sc = cons(@impls, @sc); }\n-      }\n-      _ {}\n-    }\n-    visit::visit_item(i, sc, v);\n+fn visit_mod_with_impl_scope(e: @env, m: ast::_mod, s: span, sc: iscopes,\n+                             v: vt<iscopes>) {\n+    let impls = [];\n+    for vi in m.view_items { find_impls_in_view_item(*e, vi, impls); }\n+    for i in m.items { find_impls_in_item(i, impls, none, inside); }\n+    visit::visit_mod(m, s, vec::len(impls) > 0u ? cons(@impls, @sc) : sc, v);\n }\n \n fn resolve_impl_in_expr(e: @env, x: @ast::expr, sc: iscopes, v: vt<iscopes>) {"}, {"sha": "a0493b8cbc82a89bc6501aa2c08247829741055f", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6a16f57c0a3f37d86b4c8e074f0796669fcd9528/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16f57c0a3f37d86b4c8e074f0796669fcd9528/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=6a16f57c0a3f37d86b4c8e074f0796669fcd9528", "patch": "@@ -4949,7 +4949,10 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n                  with *extend_path(cx, item.ident)};\n         trans_obj(sub_cx, item.span, ob, ctor_id, tps);\n       }\n-      ast::item_impl(_, _, _) { fail \"FIXME[impl]\"; }\n+      ast::item_impl(_, _, _) {\n+        \n+        fail \"FIXME[impl]\";\n+      }\n       ast::item_res(dtor, dtor_id, tps, ctor_id) {\n         trans_res_ctor(cx, item.span, dtor, ctor_id, tps);\n "}, {"sha": "10814ed61aefc45dd13e559ef8c3ff1faaf142df", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 73, "deletions": 39, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/6a16f57c0a3f37d86b4c8e074f0796669fcd9528/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16f57c0a3f37d86b4c8e074f0796669fcd9528/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=6a16f57c0a3f37d86b4c8e074f0796669fcd9528", "patch": "@@ -457,7 +457,7 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n-      ast::item_mod(_) { fail; }\n+      ast::item_impl(_, _, _) | ast::item_mod(_) |\n       ast::item_native_mod(_) { fail; }\n     }\n }\n@@ -689,17 +689,20 @@ mod collect {\n     }\n     fn convert(cx: @ctxt, it: @ast::item) {\n         alt it.node {\n-          ast::item_mod(_) | ast::item_impl(_, _, _) {\n-            // ignore item_mod, it has no type.\n-          }\n-          ast::item_native_mod(native_mod) {\n-            // do nothing, as native modules have no types.\n-          }\n+          // These don't define types.\n+          ast::item_mod(_) | ast::item_native_mod(_) {}\n           ast::item_tag(variants, ty_params) {\n             let tpt = ty_of_item(cx.tcx, m_collect, it);\n             write::ty_only(cx.tcx, it.id, tpt.ty);\n             get_tag_variant_types(cx, local_def(it.id), variants, ty_params);\n           }\n+          ast::item_impl(_, _, ms) {\n+            for m in ms {\n+                write::ty_only(cx.tcx, m.node.id, \n+                               ty::method_ty_to_fn_ty(cx.tcx, ty_of_method(\n+                                   cx.tcx, m_collect, m)));\n+            }\n+          }\n           ast::item_obj(object, ty_params, ctor_id) {\n             // Now we need to call ty_of_obj_ctor(); this is the type that\n             // we write into the table for this item.\n@@ -714,8 +717,8 @@ mod collect {\n             // ty_of_obj().)\n             let method_types = ty_of_obj_methods(cx.tcx, m_collect, object);\n             let i = 0u;\n-            while i < vec::len::<@ast::method>(object.methods) {\n-                write::ty_only(cx.tcx, object.methods[i].node.id,\n+            for m in object.methods {\n+                write::ty_only(cx.tcx, m.node.id,\n                                ty::method_ty_to_fn_ty(cx.tcx,\n                                                       method_types[i]));\n                 i += 1u;\n@@ -919,8 +922,6 @@ fn variant_arg_types(ccx: @crate_ctxt, _sp: span, vid: ast::def_id,\n     let tpt = ty::lookup_item_type(ccx.tcx, vid);\n     alt ty::struct(ccx.tcx, tpt.ty) {\n       ty::ty_fn(_, ins, _, _, _) {\n-\n-\n         // N-ary variant.\n         for arg: ty::arg in ins {\n             let arg_ty =\n@@ -930,7 +931,6 @@ fn variant_arg_types(ccx: @crate_ctxt, _sp: span, vid: ast::def_id,\n       }\n       _ {\n         // Nullary variant. Do nothing, as there are no arguments.\n-\n       }\n     }\n     /* result is a vector of the *expected* types of all the fields */\n@@ -2144,35 +2144,70 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         }\n       }\n       ast::expr_field(base, field) {\n+        // FIXME proper type compare, notice conflicts\n+        fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n+                         name: ast::ident, ty: ty::t)\n+            -> option::t<@ast::method> {\n+            let result = none;\n+            std::list::iter(isc) {|impls|\n+                for im in *impls {\n+                    alt im.node {\n+                      ast::item_impl(_, slf, mthds) {\n+                        let self_ty = ast_ty_to_ty_crate(fcx.ccx, slf);\n+                        alt unify::unify(fcx, ty, self_ty) {\n+                          ures_ok(_) {}\n+                          _ { cont; }\n+                        }\n+                        for m in mthds {\n+                            if m.node.ident == name {\n+                                result = some(m);\n+                                ret;\n+                            }\n+                        }\n+                      }\n+                    }\n+                }\n+            }\n+            result\n+        }\n         bot |= check_expr(fcx, base);\n         let base_t = expr_ty(tcx, base);\n-        base_t = do_autoderef(fcx, expr.span, base_t);\n-        alt structure_of(fcx, expr.span, base_t) {\n-          ty::ty_rec(fields) {\n-            let ix: uint = ty::field_idx(tcx.sess, expr.span, field, fields);\n-            if ix >= vec::len::<ty::field>(fields) {\n-                tcx.sess.span_fatal(expr.span, \"bad index on record\");\n-            }\n-            write::ty_only_fixup(fcx, id, fields[ix].mt.ty);\n-          }\n-          ty::ty_obj(methods) {\n-            let ix: uint =\n-                ty::method_idx(tcx.sess, expr.span, field, methods);\n-            if ix >= vec::len::<ty::method>(methods) {\n-                tcx.sess.span_fatal(expr.span, \"bad index on obj\");\n-            }\n-            let meth = methods[ix];\n-            let t =\n-                ty::mk_fn(tcx, meth.proto, meth.inputs, meth.output, meth.cf,\n-                          meth.constrs);\n-            write::ty_only_fixup(fcx, id, t);\n+        let iscope = fcx.ccx.impl_map.get(expr.id);\n+        alt lookup_method(fcx, iscope, field, base_t) {\n+          some(method) {\n+            let mt = ty_of_method(fcx.ccx.tcx, m_check, method);\n+            let f_ty = ty::mk_fn(fcx.ccx.tcx, mt.proto, mt.inputs,\n+                                 mt.output, mt.cf, mt.constrs);\n+            write::ty_only_fixup(fcx, id, f_ty);\n           }\n           _ {\n-            let t_err = resolve_type_vars_if_possible(fcx, base_t);\n-            let msg =\n-                #fmt[\"attempted field access on type %s\",\n-                     ty_to_str(tcx, t_err)];\n-            tcx.sess.span_fatal(expr.span, msg);\n+            base_t = do_autoderef(fcx, expr.span, base_t);\n+            alt structure_of(fcx, expr.span, base_t) {\n+              ty::ty_rec(fields) {\n+                let ix = ty::field_idx(tcx.sess, expr.span, field, fields);\n+                if ix >= vec::len::<ty::field>(fields) {\n+                    tcx.sess.span_fatal(expr.span, \"bad index on record\");\n+                }\n+                write::ty_only_fixup(fcx, id, fields[ix].mt.ty);\n+              }\n+              ty::ty_obj(methods) {\n+                let ix = ty::method_idx(tcx.sess, expr.span, field, methods);\n+                if ix >= vec::len::<ty::method>(methods) {\n+                    tcx.sess.span_fatal(expr.span, \"bad index on obj\");\n+                }\n+                let meth = methods[ix];\n+                let t = ty::mk_fn(tcx, meth.proto, meth.inputs, meth.output,\n+                                  meth.cf, meth.constrs);\n+                write::ty_only_fixup(fcx, id, t);\n+              }\n+              _ {\n+                let t_err = resolve_type_vars_if_possible(fcx, base_t);\n+                let msg = #fmt[\"attempted field access on type %s, but no \\\n+                                method implementation was found\",\n+                               ty_to_str(tcx, t_err)];\n+                tcx.sess.span_fatal(expr.span, msg);\n+              }\n+            }\n           }\n         }\n       }\n@@ -2602,13 +2637,12 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n       ast::item_obj(ob, _, _) {\n         // We're entering an object, so gather up the info we need.\n         ccx.obj_infos += [regular_obj(ob.fields, it.id)];\n-\n         // Typecheck the methods.\n         for method: @ast::method in ob.methods { check_method(ccx, method); }\n-\n         // Now remove the info from the stack.\n         vec::pop::<obj_info>(ccx.obj_infos);\n       }\n+      ast::item_impl(_, _, ms) { for m in ms { check_method(ccx, m); } }\n       _ {/* nothing to do */ }\n     }\n }"}]}