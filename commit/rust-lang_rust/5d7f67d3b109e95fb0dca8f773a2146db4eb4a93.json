{"sha": "5d7f67d3b109e95fb0dca8f773a2146db4eb4a93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkN2Y2N2QzYjEwOWU5NWZiMGRjYThmNzczYTIxNDZkYjRlYjRhOTM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-07T13:34:29Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-09T09:42:41Z"}, "message": "rustc_parse: Remove `Parser::normalized(_prev)_token`", "tree": {"sha": "8babcc69a09b4ca3ebf03b4b359e340001a749a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8babcc69a09b4ca3ebf03b4b359e340001a749a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d7f67d3b109e95fb0dca8f773a2146db4eb4a93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d7f67d3b109e95fb0dca8f773a2146db4eb4a93", "html_url": "https://github.com/rust-lang/rust/commit/5d7f67d3b109e95fb0dca8f773a2146db4eb4a93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d7f67d3b109e95fb0dca8f773a2146db4eb4a93/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43b27df5b211bc0fae74f34834ae84d17215c5ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/43b27df5b211bc0fae74f34834ae84d17215c5ac", "html_url": "https://github.com/rust-lang/rust/commit/43b27df5b211bc0fae74f34834ae84d17215c5ac"}], "stats": {"total": 47, "additions": 7, "deletions": 40}, "files": [{"sha": "10d524776a11b58c5b5ca2751244f9a1a8805f96", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d7f67d3b109e95fb0dca8f773a2146db4eb4a93/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d7f67d3b109e95fb0dca8f773a2146db4eb4a93/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=5d7f67d3b109e95fb0dca8f773a2146db4eb4a93", "patch": "@@ -4,7 +4,7 @@\n #![feature(crate_visibility_modifier)]\n \n use rustc_ast::ast;\n-use rustc_ast::token::{self, Nonterminal, Token};\n+use rustc_ast::token::{self, Nonterminal};\n use rustc_ast::tokenstream::{self, TokenStream, TokenTree};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n@@ -171,8 +171,7 @@ fn maybe_source_file_to_parser(\n     let mut parser = stream_to_parser(sess, stream, None);\n     parser.unclosed_delims = unclosed_delims;\n     if parser.token == token::Eof {\n-        let span = Span::new(end_pos, end_pos, parser.token.span.ctxt());\n-        parser.set_token(Token::new(token::Eof, span));\n+        parser.token.span = Span::new(end_pos, end_pos, parser.token.span.ctxt());\n     }\n \n     Ok(parser)"}, {"sha": "9376c7c1c724d15fee382596ae6bb0b40eae5ffc", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 5, "deletions": 37, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5d7f67d3b109e95fb0dca8f773a2146db4eb4a93/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d7f67d3b109e95fb0dca8f773a2146db4eb4a93/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=5d7f67d3b109e95fb0dca8f773a2146db4eb4a93", "patch": "@@ -88,21 +88,10 @@ macro_rules! maybe_recover_from_interpolated_ty_qpath {\n #[derive(Clone)]\n pub struct Parser<'a> {\n     pub sess: &'a ParseSess,\n-    /// The current non-normalized token.\n+    /// The current token.\n     pub token: Token,\n-    /// The current normalized token.\n-    /// \"Normalized\" means that some interpolated tokens\n-    /// (`$i: ident` and `$l: lifetime` meta-variables) are replaced\n-    /// with non-interpolated identifier and lifetime tokens they refer to.\n-    /// Use this if you need to check for `token::Ident` or `token::Lifetime` specifically,\n-    /// this also includes edition checks for edition-specific keyword identifiers.\n-    pub normalized_token: Token,\n-    /// The previous non-normalized token.\n+    /// The previous token.\n     pub prev_token: Token,\n-    /// The previous normalized token.\n-    /// Use this if you need to check for `token::Ident` or `token::Lifetime` specifically,\n-    /// this also includes edition checks for edition-specific keyword identifiers.\n-    pub normalized_prev_token: Token,\n     restrictions: Restrictions,\n     /// Used to determine the path to externally loaded source files.\n     pub(super) directory: Directory,\n@@ -374,9 +363,7 @@ impl<'a> Parser<'a> {\n         let mut parser = Parser {\n             sess,\n             token: Token::dummy(),\n-            normalized_token: Token::dummy(),\n             prev_token: Token::dummy(),\n-            normalized_prev_token: Token::dummy(),\n             restrictions: Restrictions::empty(),\n             recurse_into_file_modules,\n             directory: Directory {\n@@ -609,7 +596,7 @@ impl<'a> Parser<'a> {\n             Some((first, second)) if first == expected => {\n                 let first_span = self.sess.source_map().start_point(self.token.span);\n                 let second_span = self.token.span.with_lo(first_span.hi());\n-                self.set_token(Token::new(first, first_span));\n+                self.token = Token::new(first, first_span);\n                 self.bump_with(Token::new(second, second_span));\n                 true\n             }\n@@ -817,23 +804,6 @@ impl<'a> Parser<'a> {\n         self.parse_delim_comma_seq(token::Paren, f)\n     }\n \n-    // Interpolated identifier (`$i: ident`) and lifetime (`$l: lifetime`)\n-    // tokens are replaced with usual identifier and lifetime tokens,\n-    // so the former are never encountered during normal parsing.\n-    crate fn set_token(&mut self, token: Token) {\n-        self.token = token;\n-        self.normalized_token = match &self.token.kind {\n-            token::Interpolated(nt) => match **nt {\n-                token::NtIdent(ident, is_raw) => {\n-                    Token::new(token::Ident(ident.name, is_raw), ident.span)\n-                }\n-                token::NtLifetime(ident) => Token::new(token::Lifetime(ident.name), ident.span),\n-                _ => self.token.clone(),\n-            },\n-            _ => self.token.clone(),\n-        }\n-    }\n-\n     /// Advance the parser by one token using provided token as the next one.\n     fn bump_with(&mut self, next_token: Token) {\n         // Bumping after EOF is a bad sign, usually an infinite loop.\n@@ -843,9 +813,7 @@ impl<'a> Parser<'a> {\n         }\n \n         // Update the current and previous tokens.\n-        self.prev_token = self.token.take();\n-        self.normalized_prev_token = self.normalized_token.take();\n-        self.set_token(next_token);\n+        self.prev_token = mem::replace(&mut self.token, next_token);\n \n         // Diagnostics.\n         self.expected_tokens.clear();\n@@ -1005,7 +973,7 @@ impl<'a> Parser<'a> {\n                     &mut self.token_cursor.frame,\n                     self.token_cursor.stack.pop().unwrap(),\n                 );\n-                self.set_token(Token::new(TokenKind::CloseDelim(frame.delim), frame.span.close));\n+                self.token = Token::new(TokenKind::CloseDelim(frame.delim), frame.span.close);\n                 self.bump();\n                 TokenTree::Delimited(frame.span, frame.delim, frame.tree_cursor.stream)\n             }"}]}