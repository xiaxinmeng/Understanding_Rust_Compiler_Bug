{"sha": "158b085f06a41004ebf36d87afa3548f8b60861a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1OGIwODVmMDZhNDEwMDRlYmYzNmQ4N2FmYTM1NDhmOGI2MDg2MWE=", "commit": {"author": {"name": "Matthew", "email": "mjjasper1@gmail.com", "date": "2017-04-24T09:20:05Z"}, "committer": {"name": "Matthew", "email": "mjjasper1@gmail.com", "date": "2017-04-24T09:20:05Z"}, "message": "Fix more merge conflicts", "tree": {"sha": "e035c4787385e562748f7a3d04bb4e5018f82767", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e035c4787385e562748f7a3d04bb4e5018f82767"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/158b085f06a41004ebf36d87afa3548f8b60861a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/158b085f06a41004ebf36d87afa3548f8b60861a", "html_url": "https://github.com/rust-lang/rust/commit/158b085f06a41004ebf36d87afa3548f8b60861a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/158b085f06a41004ebf36d87afa3548f8b60861a/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "html_url": "https://github.com/rust-lang/rust/commit/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3"}, {"sha": "15ce54096a589de277771ad1f55a334fe2661a64", "url": "https://api.github.com/repos/rust-lang/rust/commits/15ce54096a589de277771ad1f55a334fe2661a64", "html_url": "https://github.com/rust-lang/rust/commit/15ce54096a589de277771ad1f55a334fe2661a64"}], "stats": {"total": 4742, "additions": 2041, "deletions": 2701}, "files": [{"sha": "8326a3683a9045d825e4fdc4021af340ee3b3755", "filename": "cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -1 +1 @@\n-Subproject commit c416fb60b11ecfd2a1ba0fb8567c9a92590b5d28\n+Subproject commit 8326a3683a9045d825e4fdc4021af340ee3b3755"}, {"sha": "12daa24e857fcbfa62a4f292c1aab804936a57d9", "filename": "src/doc/grammar.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -781,10 +781,11 @@ never_type : \"!\" ;\n ### Type parameter bounds\n \n ```antlr\n+bound-list := bound | bound '+' bound-list '+' ?\n bound := ty_bound | lt_bound\n lt_bound := lifetime\n-ty_bound := [?] [ for<lt_param_defs> ] simple_path\n-bound-list := bound | bound '+' bound-list '+' ?\n+ty_bound := ty_bound_noparen | (ty_bound_noparen)\n+ty_bound_noparen := [?] [ for<lt_param_defs> ] simple_path\n ```\n \n ### Self types"}, {"sha": "ef67941975bf285ed8bee0444e2b4263ba40eb29", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -101,11 +101,8 @@\n     - [alloc_system](library-features/alloc-system.md)\n     - [alloc](library-features/alloc.md)\n     - [as_c_str](library-features/as-c-str.md)\n-    - [as_unsafe_cell](library-features/as-unsafe-cell.md)\n     - [ascii_ctype](library-features/ascii-ctype.md)\n-    - [binary_heap_extras](library-features/binary-heap-extras.md)\n     - [binary_heap_peek_mut_pop](library-features/binary-heap-peek-mut-pop.md)\n-    - [borrow_state](library-features/borrow-state.md)\n     - [box_heap](library-features/box-heap.md)\n     - [c_void_variant](library-features/c-void-variant.md)\n     - [char_escape_debug](library-features/char-escape-debug.md)\n@@ -130,14 +127,12 @@\n     - [derive_clone_copy](library-features/derive-clone-copy.md)\n     - [derive_eq](library-features/derive-eq.md)\n     - [discriminant_value](library-features/discriminant-value.md)\n-    - [enumset](library-features/enumset.md)\n     - [error_type_id](library-features/error-type-id.md)\n     - [exact_size_is_empty](library-features/exact-size-is-empty.md)\n     - [fd](library-features/fd.md)\n     - [fd_read](library-features/fd-read.md)\n     - [fixed_size_array](library-features/fixed-size-array.md)\n     - [float_bits_conv](library-features/float-bits-conv.md)\n-    - [float_extras](library-features/float-extras.md)\n     - [flt2dec](library-features/flt2dec.md)\n     - [fmt_flags_align](library-features/fmt-flags-align.md)\n     - [fmt_internals](library-features/fmt-internals.md)\n@@ -157,15 +152,13 @@\n     - [io_error_internals](library-features/io-error-internals.md)\n     - [io](library-features/io.md)\n     - [ip](library-features/ip.md)\n-    - [is_unique](library-features/is-unique.md)\n     - [iter_rfind](library-features/iter-rfind.md)\n     - [libstd_io_internals](library-features/libstd-io-internals.md)\n     - [libstd_sys_internals](library-features/libstd-sys-internals.md)\n     - [libstd_thread_internals](library-features/libstd-thread-internals.md)\n     - [linked_list_extras](library-features/linked-list-extras.md)\n     - [lookup_host](library-features/lookup-host.md)\n     - [manually_drop](library-features/manually-drop.md)\n-    - [map_entry_recover_keys](library-features/map-entry-recover-keys.md)\n     - [mpsc_select](library-features/mpsc-select.md)\n     - [n16](library-features/n16.md)\n     - [never_type_impls](library-features/never-type-impls.md)\n@@ -188,7 +181,6 @@\n     - [rand](library-features/rand.md)\n     - [range_contains](library-features/range-contains.md)\n     - [raw](library-features/raw.md)\n-    - [rc_would_unwrap](library-features/rc-would-unwrap.md)\n     - [retain_hash_collection](library-features/retain-hash-collection.md)\n     - [reverse_cmp_key](library-features/reverse-cmp-key.md)\n     - [rt](library-features/rt.md)\n@@ -224,4 +216,3 @@\n     - [windows_handle](library-features/windows-handle.md)\n     - [windows_net](library-features/windows-net.md)\n     - [windows_stdio](library-features/windows-stdio.md)\n-    - [zero_one](library-features/zero-one.md)"}, {"sha": "79d7a7cad0b6e232c869ec59bf1ccc6a2eb11f7a", "filename": "src/doc/unstable-book/src/library-features/as-unsafe-cell.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fas-unsafe-cell.md", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fas-unsafe-cell.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fas-unsafe-cell.md?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1,7 +0,0 @@\n-# `as_unsafe_cell`\n-\n-The tracking issue for this feature is: [#27708]\n-\n-[#27708]: https://github.com/rust-lang/rust/issues/27708\n-\n-------------------------"}, {"sha": "aa535f3b67840cd51a80aec11c38d9648be17cbd", "filename": "src/doc/unstable-book/src/library-features/binary-heap-extras.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fbinary-heap-extras.md", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fbinary-heap-extras.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fbinary-heap-extras.md?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1,7 +0,0 @@\n-# `binary_heap_extras`\n-\n-The tracking issue for this feature is: [#28147]\n-\n-[#28147]: https://github.com/rust-lang/rust/issues/28147\n-\n-------------------------"}, {"sha": "304b8dffe98679c9f6fea3e7d2558757c1797563", "filename": "src/doc/unstable-book/src/library-features/borrow-state.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fborrow-state.md", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fborrow-state.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fborrow-state.md?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1,7 +0,0 @@\n-# `borrow_state`\n-\n-The tracking issue for this feature is: [#27733]\n-\n-[#27733]: https://github.com/rust-lang/rust/issues/27733\n-\n-------------------------"}, {"sha": "24c8d8fa7dbb914ae7243fb81af9b67bb544791e", "filename": "src/doc/unstable-book/src/library-features/enumset.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fenumset.md", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fenumset.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fenumset.md?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1,7 +0,0 @@\n-# `enumset`\n-\n-The tracking issue for this feature is: [#37966]\n-\n-[#37966]: https://github.com/rust-lang/rust/issues/37966\n-\n-------------------------"}, {"sha": "ff2d20a545fe5d1dfc4f5daadf332e113411ce81", "filename": "src/doc/unstable-book/src/library-features/float-extras.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffloat-extras.md", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffloat-extras.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffloat-extras.md?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1,7 +0,0 @@\n-# `float_extras`\n-\n-The tracking issue for this feature is: [#27752]\n-\n-[#27752]: https://github.com/rust-lang/rust/issues/27752\n-\n-------------------------"}, {"sha": "6070006758b7ac86a29f3c01de14a22ad9d1080f", "filename": "src/doc/unstable-book/src/library-features/is-unique.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fis-unique.md", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fis-unique.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fis-unique.md?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1,7 +0,0 @@\n-# `is_unique`\n-\n-The tracking issue for this feature is: [#28356]\n-\n-[#28356]: https://github.com/rust-lang/rust/issues/28356\n-\n-------------------------"}, {"sha": "2d15aa0e90de8e18b4b6dfafe7ab1ae759e3ddf8", "filename": "src/doc/unstable-book/src/library-features/map-entry-recover-keys.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fmap-entry-recover-keys.md", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fmap-entry-recover-keys.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fmap-entry-recover-keys.md?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1,5 +0,0 @@\n-# `map_entry_recover_keys`\n-\n-The tracking issue for this feature is: [#34285]\n-\n-[#34285]: https://github.com/rust-lang/rust/issues/34285"}, {"sha": "462387dfdcc4024034cfaef26b369010969fc095", "filename": "src/doc/unstable-book/src/library-features/rc-would-unwrap.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frc-would-unwrap.md", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frc-would-unwrap.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frc-would-unwrap.md?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1,5 +0,0 @@\n-# `rc_would_unwrap`\n-\n-The tracking issue for this feature is: [#28356]\n-\n-[#28356]: https://github.com/rust-lang/rust/issues/28356"}, {"sha": "4d1cf38c3c2ea6205823e9c8c461f734afe51a2d", "filename": "src/doc/unstable-book/src/library-features/zero-one.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fzero-one.md", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fzero-one.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fzero-one.md?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1,7 +0,0 @@\n-# `zero_one`\n-\n-The tracking issue for this feature is: [#27739]\n-\n-[#27739]: https://github.com/rust-lang/rust/issues/27739\n-\n-------------------------"}, {"sha": "056af13016cf22797fb1624e2d0be77b8ffbd1d4", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -16,7 +16,6 @@\n             issue = \"27700\")]\n \n use core::{isize, usize};\n-#[cfg(not(test))]\n use core::intrinsics::{min_align_of_val, size_of_val};\n \n #[allow(improper_ctypes)]\n@@ -158,10 +157,9 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     }\n }\n \n-#[cfg(not(test))]\n-#[lang = \"box_free\"]\n+#[cfg_attr(not(test), lang = \"box_free\")]\n #[inline]\n-unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n+pub(crate) unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n     let size = size_of_val(&*ptr);\n     let align = min_align_of_val(&*ptr);\n     // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary."}, {"sha": "c70d82392f9148cd8357bed3695a0d04f2b68f86", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -87,6 +87,7 @@\n #![feature(needs_allocator)]\n #![feature(optin_builtin_traits)]\n #![feature(placement_in_syntax)]\n+#![cfg_attr(stage0, feature(pub_restricted))]\n #![feature(shared)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]"}, {"sha": "38dc914583517f9410e1f685fbe0b50e47286ec6", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -239,7 +239,7 @@ use core::ops::CoerceUnsized;\n use core::ptr::{self, Shared};\n use core::convert::From;\n \n-use heap::deallocate;\n+use heap::{allocate, deallocate, box_free};\n use raw_vec::RawVec;\n \n struct RcBox<T: ?Sized> {\n@@ -248,7 +248,6 @@ struct RcBox<T: ?Sized> {\n     value: T,\n }\n \n-\n /// A single-threaded reference-counting pointer.\n ///\n /// See the [module-level documentation](./index.html) for more details.\n@@ -341,19 +340,6 @@ impl<T> Rc<T> {\n         }\n     }\n \n-    /// Checks whether [`Rc::try_unwrap`][try_unwrap] would return\n-    /// [`Ok`].\n-    ///\n-    /// [try_unwrap]: struct.Rc.html#method.try_unwrap\n-    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n-    #[unstable(feature = \"rc_would_unwrap\",\n-               reason = \"just added for niche usecase\",\n-               issue = \"28356\")]\n-    #[rustc_deprecated(since = \"1.15.0\", reason = \"too niche; use `strong_count` instead\")]\n-    pub fn would_unwrap(this: &Self) -> bool {\n-        Rc::strong_count(&this) == 1\n-    }\n-\n     /// Consumes the `Rc`, returning the wrapped pointer.\n     ///\n     /// To avoid a memory leak the pointer must be converted back to an `Rc` using\n@@ -438,6 +424,38 @@ impl Rc<str> {\n     }\n }\n \n+impl<T> Rc<[T]> {\n+    /// Constructs a new `Rc<[T]>` from a `Box<[T]>`.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"rustc_private\",\n+               reason = \"for internal use in rustc\",\n+               issue = \"0\")]\n+    pub fn __from_array(value: Box<[T]>) -> Rc<[T]> {\n+        unsafe {\n+            let ptr: *mut RcBox<[T]> =\n+                mem::transmute([mem::align_of::<RcBox<[T; 1]>>(), value.len()]);\n+            // FIXME(custom-DST): creating this invalid &[T] is dubiously defined,\n+            // we should have a better way of getting the size/align\n+            // of a DST from its unsized part.\n+            let ptr = allocate(size_of_val(&*ptr), align_of_val(&*ptr));\n+            let ptr: *mut RcBox<[T]> = mem::transmute([ptr as usize, value.len()]);\n+\n+            // Initialize the new RcBox.\n+            ptr::write(&mut (*ptr).strong, Cell::new(1));\n+            ptr::write(&mut (*ptr).weak, Cell::new(1));\n+            ptr::copy_nonoverlapping(\n+                value.as_ptr(),\n+                &mut (*ptr).value as *mut [T] as *mut T,\n+                value.len());\n+\n+            // Free the original allocation without freeing its (moved) contents.\n+            box_free(Box::into_raw(value));\n+\n+            Rc { ptr: Shared::new(ptr as *const _) }\n+        }\n+    }\n+}\n+\n impl<T: ?Sized> Rc<T> {\n     /// Creates a new [`Weak`][weak] pointer to this value.\n     ///\n@@ -501,11 +519,7 @@ impl<T: ?Sized> Rc<T> {\n     ///\n     /// [weak]: struct.Weak.html\n     #[inline]\n-    #[unstable(feature = \"is_unique\", reason = \"uniqueness has unclear meaning\",\n-               issue = \"28356\")]\n-    #[rustc_deprecated(since = \"1.15.0\",\n-                       reason = \"too niche; use `strong_count` and `weak_count` instead\")]\n-    pub fn is_unique(this: &Self) -> bool {\n+    fn is_unique(this: &Self) -> bool {\n         Rc::weak_count(this) == 0 && Rc::strong_count(this) == 1\n     }\n "}, {"sha": "7d972403f65db47dd923dc257487de5a5b08ab9a", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 77, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -555,82 +555,6 @@ impl<T: Ord> BinaryHeap<T> {\n         self.sift_up(0, old_len);\n     }\n \n-    /// Pushes an item onto the binary heap, then pops the greatest item off the queue in\n-    /// an optimized fashion.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// #![feature(binary_heap_extras)]\n-    /// #![allow(deprecated)]\n-    ///\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap = BinaryHeap::new();\n-    /// heap.push(1);\n-    /// heap.push(5);\n-    ///\n-    /// assert_eq!(heap.push_pop(3), 5);\n-    /// assert_eq!(heap.push_pop(9), 9);\n-    /// assert_eq!(heap.len(), 2);\n-    /// assert_eq!(heap.peek(), Some(&3));\n-    /// ```\n-    #[unstable(feature = \"binary_heap_extras\",\n-               reason = \"needs to be audited\",\n-               issue = \"28147\")]\n-    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `peek_mut` instead\")]\n-    pub fn push_pop(&mut self, mut item: T) -> T {\n-        match self.data.get_mut(0) {\n-            None => return item,\n-            Some(top) => {\n-                if *top > item {\n-                    swap(&mut item, top);\n-                } else {\n-                    return item;\n-                }\n-            }\n-        }\n-\n-        self.sift_down(0);\n-        item\n-    }\n-\n-    /// Pops the greatest item off the binary heap, then pushes an item onto the queue in\n-    /// an optimized fashion. The push is done regardless of whether the binary heap\n-    /// was empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// #![feature(binary_heap_extras)]\n-    /// #![allow(deprecated)]\n-    ///\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap = BinaryHeap::new();\n-    ///\n-    /// assert_eq!(heap.replace(1), None);\n-    /// assert_eq!(heap.replace(3), Some(1));\n-    /// assert_eq!(heap.len(), 1);\n-    /// assert_eq!(heap.peek(), Some(&3));\n-    /// ```\n-    #[unstable(feature = \"binary_heap_extras\",\n-               reason = \"needs to be audited\",\n-               issue = \"28147\")]\n-    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `peek_mut` instead\")]\n-    pub fn replace(&mut self, mut item: T) -> Option<T> {\n-        if !self.is_empty() {\n-            swap(&mut item, &mut self.data[0]);\n-            self.sift_down(0);\n-            Some(item)\n-        } else {\n-            self.push(item);\n-            None\n-        }\n-    }\n-\n     /// Consumes the `BinaryHeap` and returns the underlying vector\n     /// in arbitrary order.\n     ///\n@@ -1042,7 +966,7 @@ impl<'a, T> FusedIterator for Iter<'a, T> {}\n \n /// An owning iterator over the elements of a `BinaryHeap`.\n ///\n-/// This `struct` is created by the [`into_iter`] method on [`BinaryHeap`]\n+/// This `struct` is created by the [`into_iter`] method on [`BinaryHeap`][`BinaryHeap`]\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n /// [`into_iter`]: struct.BinaryHeap.html#method.into_iter"}, {"sha": "d73c0254a74574221e1cd44d9ff12fe858cf588d", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -298,7 +298,7 @@ pub struct IterMut<'a, K: 'a, V: 'a> {\n \n /// An owning iterator over the entries of a `BTreeMap`.\n ///\n-/// This `struct` is created by the [`into_iter`] method on [`BTreeMap`]\n+/// This `struct` is created by the [`into_iter`] method on [`BTreeMap`][`BTreeMap`]\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n /// [`into_iter`]: struct.BTreeMap.html#method.into_iter\n@@ -2217,13 +2217,6 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n         self.handle.reborrow().into_kv().0\n     }\n \n-    /// Deprecated, renamed to `remove_entry`\n-    #[unstable(feature = \"map_entry_recover_keys\", issue = \"34285\")]\n-    #[rustc_deprecated(since = \"1.12.0\", reason = \"renamed to `remove_entry`\")]\n-    pub fn remove_pair(self) -> (K, V) {\n-        self.remove_entry()\n-    }\n-\n     /// Take ownership of the key and value from the map.\n     ///\n     /// # Examples"}, {"sha": "d32460da9392342e12834e28d1e5684956297b0a", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -97,7 +97,7 @@ impl<'a, T: 'a + fmt::Debug> fmt::Debug for Iter<'a, T> {\n \n /// An owning iterator over the items of a `BTreeSet`.\n ///\n-/// This `struct` is created by the [`into_iter`] method on [`BTreeSet`]\n+/// This `struct` is created by the [`into_iter`] method on [`BTreeSet`][`BTreeSet`]\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n /// [`BTreeSet`]: struct.BTreeSet.html"}, {"sha": "aaee567bf1dbfe475b13951d6e28fdddb7c75eab", "filename": "src/libcollections/enum_set.rs", "status": "removed", "additions": 0, "deletions": 313, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1,313 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A structure for holding a set of enum variants.\n-//!\n-//! This module defines a container which uses an efficient bit mask\n-//! representation to hold C-like enum variants.\n-\n-#![unstable(feature = \"enumset\",\n-            reason = \"matches collection reform specification, \\\n-                      waiting for dust to settle\",\n-            issue = \"37966\")]\n-#![rustc_deprecated(since = \"1.16.0\", reason = \"long since replaced\")]\n-#![allow(deprecated)]\n-\n-use core::marker;\n-use core::fmt;\n-use core::iter::{FromIterator, FusedIterator};\n-use core::ops::{Sub, BitOr, BitAnd, BitXor};\n-\n-// FIXME(contentions): implement union family of methods? (general design may be\n-// wrong here)\n-\n-/// A specialized set implementation to use enum types.\n-///\n-/// It is a logic error for an item to be modified in such a way that the\n-/// transformation of the item to or from a `usize`, as determined by the\n-/// `CLike` trait, changes while the item is in the set. This is normally only\n-/// possible through `Cell`, `RefCell`, global state, I/O, or unsafe code.\n-#[derive(PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct EnumSet<E> {\n-    // We must maintain the invariant that no bits are set\n-    // for which no variant exists\n-    bits: usize,\n-    marker: marker::PhantomData<E>,\n-}\n-\n-impl<E> Copy for EnumSet<E> {}\n-\n-impl<E> Clone for EnumSet<E> {\n-    fn clone(&self) -> EnumSet<E> {\n-        *self\n-    }\n-}\n-\n-impl<E: CLike + fmt::Debug> fmt::Debug for EnumSet<E> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fmt.debug_set().entries(self).finish()\n-    }\n-}\n-\n-/// An interface for casting C-like enum to usize and back.\n-/// A typically implementation is as below.\n-///\n-/// ```{rust,ignore}\n-/// #[repr(usize)]\n-/// enum Foo {\n-///     A, B, C\n-/// }\n-///\n-/// impl CLike for Foo {\n-///     fn to_usize(&self) -> usize {\n-///         *self as usize\n-///     }\n-///\n-///     fn from_usize(v: usize) -> Foo {\n-///         unsafe { mem::transmute(v) }\n-///     }\n-/// }\n-/// ```\n-pub trait CLike {\n-    /// Converts a C-like enum to a `usize`.\n-    fn to_usize(&self) -> usize;\n-    /// Converts a `usize` to a C-like enum.\n-    fn from_usize(usize) -> Self;\n-}\n-\n-fn bit<E: CLike>(e: &E) -> usize {\n-    use core::mem;\n-    let value = e.to_usize();\n-    let bits = mem::size_of::<usize>() * 8;\n-    assert!(value < bits,\n-            \"EnumSet only supports up to {} variants.\",\n-            bits - 1);\n-    1 << value\n-}\n-\n-impl<E: CLike> EnumSet<E> {\n-    /// Returns an empty `EnumSet`.\n-    pub fn new() -> EnumSet<E> {\n-        EnumSet {\n-            bits: 0,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-\n-    /// Returns the number of elements in the given `EnumSet`.\n-    pub fn len(&self) -> usize {\n-        self.bits.count_ones() as usize\n-    }\n-\n-    /// Returns `true` if the `EnumSet` is empty.\n-    pub fn is_empty(&self) -> bool {\n-        self.bits == 0\n-    }\n-\n-    pub fn clear(&mut self) {\n-        self.bits = 0;\n-    }\n-\n-    /// Returns `false` if the `EnumSet` contains any enum of the given `EnumSet`.\n-    pub fn is_disjoint(&self, other: &EnumSet<E>) -> bool {\n-        (self.bits & other.bits) == 0\n-    }\n-\n-    /// Returns `true` if a given `EnumSet` is included in this `EnumSet`.\n-    pub fn is_superset(&self, other: &EnumSet<E>) -> bool {\n-        (self.bits & other.bits) == other.bits\n-    }\n-\n-    /// Returns `true` if this `EnumSet` is included in the given `EnumSet`.\n-    pub fn is_subset(&self, other: &EnumSet<E>) -> bool {\n-        other.is_superset(self)\n-    }\n-\n-    /// Returns the union of both `EnumSets`.\n-    pub fn union(&self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {\n-            bits: self.bits | e.bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-\n-    /// Returns the intersection of both `EnumSets`.\n-    pub fn intersection(&self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {\n-            bits: self.bits & e.bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-\n-    /// Adds an enum to the `EnumSet`, and returns `true` if it wasn't there before\n-    pub fn insert(&mut self, e: E) -> bool {\n-        let result = !self.contains(&e);\n-        self.bits |= bit(&e);\n-        result\n-    }\n-\n-    /// Removes an enum from the EnumSet\n-    pub fn remove(&mut self, e: &E) -> bool {\n-        let result = self.contains(e);\n-        self.bits &= !bit(e);\n-        result\n-    }\n-\n-    /// Returns `true` if an `EnumSet` contains a given enum.\n-    pub fn contains(&self, e: &E) -> bool {\n-        (self.bits & bit(e)) != 0\n-    }\n-\n-    /// Returns an iterator over an `EnumSet`.\n-    pub fn iter(&self) -> Iter<E> {\n-        Iter::new(self.bits)\n-    }\n-}\n-\n-impl<E: CLike> Sub for EnumSet<E> {\n-    type Output = EnumSet<E>;\n-\n-    fn sub(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {\n-            bits: self.bits & !e.bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-}\n-\n-impl<E: CLike> BitOr for EnumSet<E> {\n-    type Output = EnumSet<E>;\n-\n-    fn bitor(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {\n-            bits: self.bits | e.bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-}\n-\n-impl<E: CLike> BitAnd for EnumSet<E> {\n-    type Output = EnumSet<E>;\n-\n-    fn bitand(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {\n-            bits: self.bits & e.bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-}\n-\n-impl<E: CLike> BitXor for EnumSet<E> {\n-    type Output = EnumSet<E>;\n-\n-    fn bitxor(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {\n-            bits: self.bits ^ e.bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-}\n-\n-/// An iterator over an `EnumSet`\n-pub struct Iter<E> {\n-    index: usize,\n-    bits: usize,\n-    marker: marker::PhantomData<E>,\n-}\n-\n-impl<E: fmt::Debug> fmt::Debug for Iter<E> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"Iter\")\n-         .field(&self.index)\n-         .field(&self.bits)\n-         .finish()\n-    }\n-}\n-\n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-impl<E> Clone for Iter<E> {\n-    fn clone(&self) -> Iter<E> {\n-        Iter {\n-            index: self.index,\n-            bits: self.bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-}\n-\n-impl<E: CLike> Iter<E> {\n-    fn new(bits: usize) -> Iter<E> {\n-        Iter {\n-            index: 0,\n-            bits: bits,\n-            marker: marker::PhantomData,\n-        }\n-    }\n-}\n-\n-impl<E: CLike> Iterator for Iter<E> {\n-    type Item = E;\n-\n-    fn next(&mut self) -> Option<E> {\n-        if self.bits == 0 {\n-            return None;\n-        }\n-\n-        while (self.bits & 1) == 0 {\n-            self.index += 1;\n-            self.bits >>= 1;\n-        }\n-        let elem = CLike::from_usize(self.index);\n-        self.index += 1;\n-        self.bits >>= 1;\n-        Some(elem)\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let exact = self.bits.count_ones() as usize;\n-        (exact, Some(exact))\n-    }\n-}\n-\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n-impl<E: CLike> FusedIterator for Iter<E> {}\n-\n-impl<E: CLike> FromIterator<E> for EnumSet<E> {\n-    fn from_iter<I: IntoIterator<Item = E>>(iter: I) -> EnumSet<E> {\n-        let mut ret = EnumSet::new();\n-        ret.extend(iter);\n-        ret\n-    }\n-}\n-\n-impl<'a, E> IntoIterator for &'a EnumSet<E>\n-    where E: CLike\n-{\n-    type Item = E;\n-    type IntoIter = Iter<E>;\n-\n-    fn into_iter(self) -> Iter<E> {\n-        self.iter()\n-    }\n-}\n-\n-impl<E: CLike> Extend<E> for EnumSet<E> {\n-    fn extend<I: IntoIterator<Item = E>>(&mut self, iter: I) {\n-        for element in iter {\n-            self.insert(element);\n-        }\n-    }\n-}\n-\n-impl<'a, E: 'a + CLike + Copy> Extend<&'a E> for EnumSet<E> {\n-    fn extend<I: IntoIterator<Item = &'a E>>(&mut self, iter: I) {\n-        self.extend(iter.into_iter().cloned());\n-    }\n-}"}, {"sha": "8d056afdb571a4881ed1e86399fc3cc3294bbb06", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -89,9 +89,6 @@ pub use btree_set::BTreeSet;\n #[doc(no_inline)]\n pub use linked_list::LinkedList;\n #[doc(no_inline)]\n-#[allow(deprecated)]\n-pub use enum_set::EnumSet;\n-#[doc(no_inline)]\n pub use vec_deque::VecDeque;\n #[doc(no_inline)]\n pub use string::String;\n@@ -107,7 +104,6 @@ mod macros;\n pub mod binary_heap;\n mod btree;\n pub mod borrow;\n-pub mod enum_set;\n pub mod fmt;\n pub mod linked_list;\n pub mod range;"}, {"sha": "adfd91bec4893a32824e17f606ff911676338057", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -115,7 +115,7 @@ impl<'a, T: 'a + fmt::Debug> fmt::Debug for IterMut<'a, T> {\n \n /// An owning iterator over the elements of a `LinkedList`.\n ///\n-/// This `struct` is created by the [`into_iter`] method on [`LinkedList`]\n+/// This `struct` is created by the [`into_iter`] method on [`LinkedList`][`LinkedList`]\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n /// [`into_iter`]: struct.LinkedList.html#method.into_iter"}, {"sha": "af18cddaddb013050ce91c6c98e32e06c6ba2ebe", "filename": "src/libcollections/tests/binary_heap.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcollections%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcollections%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fbinary_heap.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -152,36 +152,6 @@ fn test_push_unique() {\n     assert!(*heap.peek().unwrap() == box 103);\n }\n \n-#[test]\n-#[allow(deprecated)]\n-fn test_push_pop() {\n-    let mut heap = BinaryHeap::from(vec![5, 5, 2, 1, 3]);\n-    assert_eq!(heap.len(), 5);\n-    assert_eq!(heap.push_pop(6), 6);\n-    assert_eq!(heap.len(), 5);\n-    assert_eq!(heap.push_pop(0), 5);\n-    assert_eq!(heap.len(), 5);\n-    assert_eq!(heap.push_pop(4), 5);\n-    assert_eq!(heap.len(), 5);\n-    assert_eq!(heap.push_pop(1), 4);\n-    assert_eq!(heap.len(), 5);\n-}\n-\n-#[test]\n-#[allow(deprecated)]\n-fn test_replace() {\n-    let mut heap = BinaryHeap::from(vec![5, 5, 2, 1, 3]);\n-    assert_eq!(heap.len(), 5);\n-    assert_eq!(heap.replace(6).unwrap(), 5);\n-    assert_eq!(heap.len(), 5);\n-    assert_eq!(heap.replace(0).unwrap(), 6);\n-    assert_eq!(heap.len(), 5);\n-    assert_eq!(heap.replace(4).unwrap(), 5);\n-    assert_eq!(heap.len(), 5);\n-    assert_eq!(heap.replace(1).unwrap(), 4);\n-    assert_eq!(heap.len(), 5);\n-}\n-\n fn check_to_vec(mut data: Vec<i32>) {\n     let heap = BinaryHeap::from(data.clone());\n     let mut v = heap.clone().into_vec();\n@@ -227,13 +197,6 @@ fn test_empty_peek_mut() {\n     assert!(empty.peek_mut().is_none());\n }\n \n-#[test]\n-#[allow(deprecated)]\n-fn test_empty_replace() {\n-    let mut heap = BinaryHeap::new();\n-    assert!(heap.replace(5).is_none());\n-}\n-\n #[test]\n fn test_from_iter() {\n     let xs = vec![9, 8, 7, 6, 5, 4, 3, 2, 1];"}, {"sha": "9c6e31d70a541c12ac1d460ee28475aebdfab769", "filename": "src/libcollections/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcollections%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcollections%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Flib.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -10,7 +10,6 @@\n \n #![deny(warnings)]\n \n-#![feature(binary_heap_extras)]\n #![feature(binary_heap_peek_mut_pop)]\n #![feature(box_syntax)]\n #![feature(inclusive_range_syntax)]"}, {"sha": "079d3acf3764ac159c9014b043f7c14380da2781", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -2070,7 +2070,7 @@ impl<'a, T> FusedIterator for IterMut<'a, T> {}\n \n /// An owning iterator over the elements of a `VecDeque`.\n ///\n-/// This `struct` is created by the [`into_iter`] method on [`VecDeque`]\n+/// This `struct` is created by the [`into_iter`] method on [`VecDeque`][`VecDeque`]\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n /// [`into_iter`]: struct.VecDeque.html#method.into_iter"}, {"sha": "ba04cbb0543cd6de56de80d2412cda33e8525bfc", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -310,26 +310,6 @@ impl<T> Cell<T> {\n         }\n     }\n \n-    /// Returns a reference to the underlying `UnsafeCell`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(as_unsafe_cell)]\n-    ///\n-    /// use std::cell::Cell;\n-    ///\n-    /// let c = Cell::new(5);\n-    ///\n-    /// let uc = c.as_unsafe_cell();\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"as_unsafe_cell\", issue = \"27708\")]\n-    #[rustc_deprecated(since = \"1.12.0\", reason = \"renamed to as_ptr\")]\n-    pub fn as_unsafe_cell(&self) -> &UnsafeCell<T> {\n-        &self.value\n-    }\n-\n     /// Returns a raw pointer to the underlying data in this cell.\n     ///\n     /// # Examples\n@@ -480,20 +460,6 @@ pub struct RefCell<T: ?Sized> {\n     value: UnsafeCell<T>,\n }\n \n-/// An enumeration of values returned from the `state` method on a `RefCell<T>`.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-#[unstable(feature = \"borrow_state\", issue = \"27733\")]\n-#[rustc_deprecated(since = \"1.15.0\", reason = \"use `try_borrow` instead\")]\n-#[allow(deprecated)]\n-pub enum BorrowState {\n-    /// The cell is currently being read, there is at least one active `borrow`.\n-    Reading,\n-    /// The cell is currently being written to, there is an active `borrow_mut`.\n-    Writing,\n-    /// There are no outstanding borrows on this cell.\n-    Unused,\n-}\n-\n /// An error returned by [`RefCell::try_borrow`](struct.RefCell.html#method.try_borrow).\n #[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n pub struct BorrowError {\n@@ -582,38 +548,6 @@ impl<T> RefCell<T> {\n }\n \n impl<T: ?Sized> RefCell<T> {\n-    /// Query the current state of this `RefCell`\n-    ///\n-    /// The returned value can be dispatched on to determine if a call to\n-    /// `borrow` or `borrow_mut` would succeed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(borrow_state)]\n-    ///\n-    /// use std::cell::{BorrowState, RefCell};\n-    ///\n-    /// let c = RefCell::new(5);\n-    ///\n-    /// match c.borrow_state() {\n-    ///     BorrowState::Writing => println!(\"Cannot be borrowed\"),\n-    ///     BorrowState::Reading => println!(\"Cannot be borrowed mutably\"),\n-    ///     BorrowState::Unused => println!(\"Can be borrowed (mutably as well)\"),\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"borrow_state\", issue = \"27733\")]\n-    #[rustc_deprecated(since = \"1.15.0\", reason = \"use `try_borrow` instead\")]\n-    #[allow(deprecated)]\n-    #[inline]\n-    pub fn borrow_state(&self) -> BorrowState {\n-        match self.borrow.get() {\n-            WRITING => BorrowState::Writing,\n-            UNUSED => BorrowState::Unused,\n-            _ => BorrowState::Reading,\n-        }\n-    }\n-\n     /// Immutably borrows the wrapped value.\n     ///\n     /// The borrow lasts until the returned `Ref` exits scope. Multiple\n@@ -769,29 +703,6 @@ impl<T: ?Sized> RefCell<T> {\n         }\n     }\n \n-    /// Returns a reference to the underlying `UnsafeCell`.\n-    ///\n-    /// This can be used to circumvent `RefCell`'s safety checks.\n-    ///\n-    /// This function is `unsafe` because `UnsafeCell`'s field is public.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(as_unsafe_cell)]\n-    ///\n-    /// use std::cell::RefCell;\n-    ///\n-    /// let c = RefCell::new(5);\n-    /// let c = unsafe { c.as_unsafe_cell() };\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"as_unsafe_cell\", issue = \"27708\")]\n-    #[rustc_deprecated(since = \"1.12.0\", reason = \"renamed to as_ptr\")]\n-    pub unsafe fn as_unsafe_cell(&self) -> &UnsafeCell<T> {\n-        &self.value\n-    }\n-\n     /// Returns a raw pointer to the underlying data in this cell.\n     ///\n     /// # Examples"}, {"sha": "4ca303dee43f2ad600237d82680c0a6ddfa6d0f7", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -15,16 +15,16 @@\n // FIXME: #6220 Implement floating point formatting\n \n use fmt;\n-use num::Zero;\n use ops::{Div, Rem, Sub};\n use str;\n use slice;\n use ptr;\n use mem;\n \n #[doc(hidden)]\n-trait Int: Zero + PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +\n+trait Int: PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +\n            Sub<Output=Self> + Copy {\n+    fn zero() -> Self;\n     fn from_u8(u: u8) -> Self;\n     fn to_u8(&self) -> u8;\n     fn to_u16(&self) -> u16;\n@@ -35,6 +35,7 @@ trait Int: Zero + PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +\n \n macro_rules! doit {\n     ($($t:ident)*) => ($(impl Int for $t {\n+        fn zero() -> $t { 0 }\n         fn from_u8(u: u8) -> $t { u as $t }\n         fn to_u8(&self) -> u8 { *self as u8 }\n         fn to_u16(&self) -> u16 { *self as u16 }"}, {"sha": "2a60292d0232e1e525606edc20ecc0a9821abc68", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -63,11 +63,8 @@ pub trait RawFloat : Float + Copy + Debug + LowerExp\n     const NAN: Self;\n     const ZERO: Self;\n \n-    // suffix of \"2\" because Float::integer_decode is deprecated\n-    #[allow(deprecated)]\n-    fn integer_decode2(self) -> (u64, i16, i8) {\n-        Float::integer_decode(self)\n-    }\n+    /// Returns the mantissa, exponent and sign as integers.\n+    fn integer_decode(self) -> (u64, i16, i8);\n \n     /// Get the raw binary representation of the float.\n     fn transmute(self) -> u64;\n@@ -160,6 +157,21 @@ impl RawFloat for f32 {\n     const ZERO_CUTOFF: i64 = -48;\n     other_constants!(f32);\n \n+    /// Returns the mantissa, exponent and sign as integers.\n+    fn integer_decode(self) -> (u64, i16, i8) {\n+        let bits: u32 = unsafe { transmute(self) };\n+        let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n+        let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n+        let mantissa = if exponent == 0 {\n+            (bits & 0x7fffff) << 1\n+        } else {\n+            (bits & 0x7fffff) | 0x800000\n+        };\n+        // Exponent bias + mantissa shift\n+        exponent -= 127 + 23;\n+        (mantissa as u64, exponent, sign)\n+    }\n+\n     fn transmute(self) -> u64 {\n         let bits: u32 = unsafe { transmute(self) };\n         bits as u64\n@@ -171,7 +183,7 @@ impl RawFloat for f32 {\n     }\n \n     fn unpack(self) -> Unpacked {\n-        let (sig, exp, _sig) = self.integer_decode2();\n+        let (sig, exp, _sig) = self.integer_decode();\n         Unpacked::new(sig, exp)\n     }\n \n@@ -196,6 +208,21 @@ impl RawFloat for f64 {\n     const ZERO_CUTOFF: i64 = -326;\n     other_constants!(f64);\n \n+    /// Returns the mantissa, exponent and sign as integers.\n+    fn integer_decode(self) -> (u64, i16, i8) {\n+        let bits: u64 = unsafe { transmute(self) };\n+        let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n+        let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n+        let mantissa = if exponent == 0 {\n+            (bits & 0xfffffffffffff) << 1\n+        } else {\n+            (bits & 0xfffffffffffff) | 0x10000000000000\n+        };\n+        // Exponent bias + mantissa shift\n+        exponent -= 1023 + 52;\n+        (mantissa, exponent, sign)\n+    }\n+\n     fn transmute(self) -> u64 {\n         let bits: u64 = unsafe { transmute(self) };\n         bits\n@@ -206,7 +233,7 @@ impl RawFloat for f64 {\n     }\n \n     fn unpack(self) -> Unpacked {\n-        let (sig, exp, _sig) = self.integer_decode2();\n+        let (sig, exp, _sig) = self.integer_decode();\n         Unpacked::new(sig, exp)\n     }\n "}, {"sha": "91ca213e96e0d19b84c38b83668d193790804020", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -143,36 +143,6 @@ pub mod consts {\n            reason = \"stable interface is via `impl f{32,64}` in later crates\",\n            issue = \"32110\")]\n impl Float for f32 {\n-    #[inline]\n-    fn nan() -> f32 {\n-        NAN\n-    }\n-\n-    #[inline]\n-    fn infinity() -> f32 {\n-        INFINITY\n-    }\n-\n-    #[inline]\n-    fn neg_infinity() -> f32 {\n-        NEG_INFINITY\n-    }\n-\n-    #[inline]\n-    fn zero() -> f32 {\n-        0.0\n-    }\n-\n-    #[inline]\n-    fn neg_zero() -> f32 {\n-        -0.0\n-    }\n-\n-    #[inline]\n-    fn one() -> f32 {\n-        1.0\n-    }\n-\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool {\n@@ -214,21 +184,6 @@ impl Float for f32 {\n         }\n     }\n \n-    /// Returns the mantissa, exponent and sign as integers.\n-    fn integer_decode(self) -> (u64, i16, i8) {\n-        let bits: u32 = unsafe { mem::transmute(self) };\n-        let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n-        let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n-        let mantissa = if exponent == 0 {\n-            (bits & 0x7fffff) << 1\n-        } else {\n-            (bits & 0x7fffff) | 0x800000\n-        };\n-        // Exponent bias + mantissa shift\n-        exponent -= 127 + 23;\n-        (mantissa as u64, exponent, sign)\n-    }\n-\n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n     /// number is `Float::nan()`.\n     #[inline]"}, {"sha": "7d6d6cef049772f3f2d267a394cf44125015ad69", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -143,36 +143,6 @@ pub mod consts {\n            reason = \"stable interface is via `impl f{32,64}` in later crates\",\n            issue = \"32110\")]\n impl Float for f64 {\n-    #[inline]\n-    fn nan() -> f64 {\n-        NAN\n-    }\n-\n-    #[inline]\n-    fn infinity() -> f64 {\n-        INFINITY\n-    }\n-\n-    #[inline]\n-    fn neg_infinity() -> f64 {\n-        NEG_INFINITY\n-    }\n-\n-    #[inline]\n-    fn zero() -> f64 {\n-        0.0\n-    }\n-\n-    #[inline]\n-    fn neg_zero() -> f64 {\n-        -0.0\n-    }\n-\n-    #[inline]\n-    fn one() -> f64 {\n-        1.0\n-    }\n-\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool {\n@@ -214,21 +184,6 @@ impl Float for f64 {\n         }\n     }\n \n-    /// Returns the mantissa, exponent and sign as integers.\n-    fn integer_decode(self) -> (u64, i16, i8) {\n-        let bits: u64 = unsafe { mem::transmute(self) };\n-        let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n-        let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n-        let mantissa = if exponent == 0 {\n-            (bits & 0xfffffffffffff) << 1\n-        } else {\n-            (bits & 0xfffffffffffff) | 0x10000000000000\n-        };\n-        // Exponent bias + mantissa shift\n-        exponent -= 1023 + 52;\n-        (mantissa, exponent, sign)\n-    }\n-\n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n     /// number is `Float::nan()`.\n     #[inline]"}, {"sha": "b779eefce5752c1bf100488f35106454c83c7770", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -67,7 +67,7 @@ impl DecodableFloat for f64 {\n /// Returns a sign (true when negative) and `FullDecoded` value\n /// from given floating point number.\n pub fn decode<T: DecodableFloat>(v: T) -> (/*negative?*/ bool, FullDecoded) {\n-    let (mant, exp, sign) = v.integer_decode2();\n+    let (mant, exp, sign) = v.integer_decode();\n     let even = (mant & 1) == 0;\n     let decoded = match v.classify() {\n         FpCategory::Nan => FullDecoded::Nan,\n@@ -81,7 +81,7 @@ pub fn decode<T: DecodableFloat>(v: T) -> (/*negative?*/ bool, FullDecoded) {\n                                           exp: exp, inclusive: even })\n         }\n         FpCategory::Normal => {\n-            let minnorm = <T as DecodableFloat>::min_pos_norm_value().integer_decode2();\n+            let minnorm = <T as DecodableFloat>::min_pos_norm_value().integer_decode();\n             if mant == minnorm.0 {\n                 // neighbors: (maxmant, exp - 1) -- (minnormmant, exp) -- (minnormmant + 1, exp)\n                 // where maxmant = minnormmant * 2 - 1"}, {"sha": "5c4a43fbd110a4e4a86202146e8d0ddb05abdde2", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -96,78 +96,6 @@ pub mod dec2flt;\n pub mod bignum;\n pub mod diy_float;\n \n-/// Types that have a \"zero\" value.\n-///\n-/// This trait is intended for use in conjunction with `Add`, as an identity:\n-/// `x + T::zero() == x`.\n-#[unstable(feature = \"zero_one\",\n-           reason = \"unsure of placement, wants to use associated constants\",\n-           issue = \"27739\")]\n-#[rustc_deprecated(since = \"1.11.0\", reason = \"no longer used for \\\n-                                               Iterator::sum\")]\n-pub trait Zero: Sized {\n-    /// The \"zero\" (usually, additive identity) for this type.\n-    fn zero() -> Self;\n-}\n-\n-/// Types that have a \"one\" value.\n-///\n-/// This trait is intended for use in conjunction with `Mul`, as an identity:\n-/// `x * T::one() == x`.\n-#[unstable(feature = \"zero_one\",\n-           reason = \"unsure of placement, wants to use associated constants\",\n-           issue = \"27739\")]\n-#[rustc_deprecated(since = \"1.11.0\", reason = \"no longer used for \\\n-                                               Iterator::product\")]\n-pub trait One: Sized {\n-    /// The \"one\" (usually, multiplicative identity) for this type.\n-    fn one() -> Self;\n-}\n-\n-macro_rules! zero_one_impl {\n-    ($($t:ty)*) => ($(\n-        #[unstable(feature = \"zero_one\",\n-                   reason = \"unsure of placement, wants to use associated constants\",\n-                   issue = \"27739\")]\n-        #[allow(deprecated)]\n-        impl Zero for $t {\n-            #[inline]\n-            fn zero() -> Self { 0 }\n-        }\n-        #[unstable(feature = \"zero_one\",\n-                   reason = \"unsure of placement, wants to use associated constants\",\n-                   issue = \"27739\")]\n-        #[allow(deprecated)]\n-        impl One for $t {\n-            #[inline]\n-            fn one() -> Self { 1 }\n-        }\n-    )*)\n-}\n-zero_one_impl! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n-\n-macro_rules! zero_one_impl_float {\n-    ($($t:ty)*) => ($(\n-        #[unstable(feature = \"zero_one\",\n-                   reason = \"unsure of placement, wants to use associated constants\",\n-                   issue = \"27739\")]\n-        #[allow(deprecated)]\n-        impl Zero for $t {\n-            #[inline]\n-            fn zero() -> Self { 0.0 }\n-        }\n-        #[unstable(feature = \"zero_one\",\n-                   reason = \"unsure of placement, wants to use associated constants\",\n-                   issue = \"27739\")]\n-        #[allow(deprecated)]\n-        impl One for $t {\n-            #[inline]\n-            fn one() -> Self { 1.0 }\n-        }\n-    )*)\n-}\n-zero_one_impl_float! { f32 f64 }\n-\n macro_rules! checked_op {\n     ($U:ty, $op:path, $x:expr, $y:expr) => {{\n         let (result, overflowed) = unsafe { $op($x as $U, $y as $U) };\n@@ -2525,49 +2453,6 @@ pub enum FpCategory {\n            reason = \"stable interface is via `impl f{32,64}` in later crates\",\n            issue = \"32110\")]\n pub trait Float: Sized {\n-    /// Returns the NaN value.\n-    #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    fn nan() -> Self;\n-    /// Returns the infinite value.\n-    #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    fn infinity() -> Self;\n-    /// Returns the negative infinite value.\n-    #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    fn neg_infinity() -> Self;\n-    /// Returns -0.0.\n-    #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    fn neg_zero() -> Self;\n-    /// Returns 0.0.\n-    #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    fn zero() -> Self;\n-    /// Returns 1.0.\n-    #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    fn one() -> Self;\n-\n     /// Returns `true` if this value is NaN and false otherwise.\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn is_nan(self) -> bool;\n@@ -2585,14 +2470,6 @@ pub trait Float: Sized {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn classify(self) -> FpCategory;\n \n-    /// Returns the mantissa, exponent and sign as integers, respectively.\n-    #[unstable(feature = \"float_extras\", reason = \"signature is undecided\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    fn integer_decode(self) -> (u64, i16, i8);\n-\n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n     /// number is `Float::nan()`.\n     #[stable(feature = \"core\", since = \"1.6.0\")]"}, {"sha": "2b0afc402027f11f1c999846583241f231ed66d0", "filename": "src/libcore/tests/num/dec2flt/rawfp.rs", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -8,23 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::f32;\n use std::f64;\n-use std::mem;\n use core::num::diy_float::Fp;\n use core::num::dec2flt::rawfp::{fp_to_float, prev_float, next_float, round_normal};\n+use core::num::dec2flt::rawfp::RawFloat;\n \n fn integer_decode(f: f64) -> (u64, i16, i8) {\n-    let bits: u64 = unsafe { mem::transmute(f) };\n-    let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n-    let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n-    let mantissa = if exponent == 0 {\n-        (bits & 0xfffffffffffff) << 1\n-    } else {\n-        (bits & 0xfffffffffffff) | 0x10000000000000\n-    };\n-    // Exponent bias + mantissa shift\n-    exponent -= 1023 + 52;\n-    (mantissa, exponent, sign)\n+    RawFloat::integer_decode(f)\n }\n \n #[test]\n@@ -152,3 +143,35 @@ fn next_float_monotonic() {\n     }\n     assert!(x > 0.5);\n }\n+\n+#[test]\n+fn test_f32_integer_decode() {\n+    assert_eq!(3.14159265359f32.integer_decode(), (13176795, -22, 1));\n+    assert_eq!((-8573.5918555f32).integer_decode(), (8779358, -10, -1));\n+    assert_eq!(2f32.powf(100.0).integer_decode(), (8388608, 77, 1));\n+    assert_eq!(0f32.integer_decode(), (0, -150, 1));\n+    assert_eq!((-0f32).integer_decode(), (0, -150, -1));\n+    assert_eq!(f32::INFINITY.integer_decode(), (8388608, 105, 1));\n+    assert_eq!(f32::NEG_INFINITY.integer_decode(), (8388608, 105, -1));\n+\n+    // Ignore the \"sign\" (quiet / signalling flag) of NAN.\n+    // It can vary between runtime operations and LLVM folding.\n+    let (nan_m, nan_e, _nan_s) = f32::NAN.integer_decode();\n+    assert_eq!((nan_m, nan_e), (12582912, 105));\n+}\n+\n+#[test]\n+fn test_f64_integer_decode() {\n+    assert_eq!(3.14159265359f64.integer_decode(), (7074237752028906, -51, 1));\n+    assert_eq!((-8573.5918555f64).integer_decode(), (4713381968463931, -39, -1));\n+    assert_eq!(2f64.powf(100.0).integer_decode(), (4503599627370496, 48, 1));\n+    assert_eq!(0f64.integer_decode(), (0, -1075, 1));\n+    assert_eq!((-0f64).integer_decode(), (0, -1075, -1));\n+    assert_eq!(f64::INFINITY.integer_decode(), (4503599627370496, 972, 1));\n+    assert_eq!(f64::NEG_INFINITY.integer_decode(), (4503599627370496, 972, -1));\n+\n+    // Ignore the \"sign\" (quiet / signalling flag) of NAN.\n+    // It can vary between runtime operations and LLVM folding.\n+    let (nan_m, nan_e, _nan_s) = f64::NAN.integer_decode();\n+    assert_eq!((nan_m, nan_e), (6755399441055744, 972));\n+}"}, {"sha": "33133f6834b9ab70a32a3e45de54c27929363d35", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -88,15 +88,17 @@ pub enum DepNode<D: Clone + Debug> {\n     // predicates for an item wind up in `ItemSignature`).\n     AssociatedItems(D),\n     ItemSignature(D),\n+    IsForeignItem(D),\n     TypeParamPredicates((D, D)),\n     SizedConstraint(D),\n+    DtorckConstraint(D),\n     AdtDestructor(D),\n     AssociatedItemDefIds(D),\n     InherentImpls(D),\n     TypeckBodiesKrate,\n     TypeckTables(D),\n     UsedTraitImports(D),\n-    MonomorphicConstEval(D),\n+    ConstEval(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -171,6 +173,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransCrateItem,\n             AssociatedItems,\n             ItemSignature,\n+            IsForeignItem,\n             AssociatedItemDefIds,\n             InherentImpls,\n             TypeckTables,\n@@ -221,16 +224,18 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransInlinedItem(ref d) => op(d).map(TransInlinedItem),\n             AssociatedItems(ref d) => op(d).map(AssociatedItems),\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n+            IsForeignItem(ref d) => op(d).map(IsForeignItem),\n             TypeParamPredicates((ref item, ref param)) => {\n                 Some(TypeParamPredicates((try_opt!(op(item)), try_opt!(op(param)))))\n             }\n             SizedConstraint(ref d) => op(d).map(SizedConstraint),\n+            DtorckConstraint(ref d) => op(d).map(DtorckConstraint),\n             AdtDestructor(ref d) => op(d).map(AdtDestructor),\n             AssociatedItemDefIds(ref d) => op(d).map(AssociatedItemDefIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),\n             TypeckTables(ref d) => op(d).map(TypeckTables),\n             UsedTraitImports(ref d) => op(d).map(UsedTraitImports),\n-            MonomorphicConstEval(ref d) => op(d).map(MonomorphicConstEval),\n+            ConstEval(ref d) => op(d).map(ConstEval),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),"}, {"sha": "30e9f502abc8c83b91c3a91a02f4b5720ef6eb42", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -1829,6 +1829,7 @@ register_diagnostics! {\n     E0314, // closure outlives stack frame\n     E0315, // cannot invoke closure outside of its lifetime\n     E0316, // nested quantification of lifetimes\n+    E0320, // recursive overflow during dropck\n     E0473, // dereference of reference outside its lifetime\n     E0474, // captured variable `..` does not outlive the enclosing closure\n     E0475, // index of slice outside its lifetime"}, {"sha": "16af98c2035480ef382ab55f7dbed9a5b521fb9a", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -273,6 +273,12 @@ for ::middle::const_val::ConstVal<'tcx> {\n             ConstVal::Bool(value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n+            ConstVal::Char(value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            ConstVal::Variant(def_id) => {\n+                def_id.hash_stable(hcx, hasher);\n+            }\n             ConstVal::Function(def_id, substs) => {\n                 def_id.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n@@ -296,9 +302,6 @@ for ::middle::const_val::ConstVal<'tcx> {\n                 value.hash_stable(hcx, hasher);\n                 times.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Char(value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n         }\n     }\n }"}, {"sha": "922842136dc9f398464b422bd2437400e13de105", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::ReEmpty |\n             ty::ReErased => {\n                 // replace all free regions with 'erased\n-                self.tcx().mk_region(ty::ReErased)\n+                self.tcx().types.re_erased\n             }\n         }\n     }"}, {"sha": "fa6775737b57df93f167f176f2d8c8dd6bc0e4ac", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -948,7 +948,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 } else {\n                     // otherwise, we don't know what the free region is,\n                     // so we must conservatively say the LUB is static:\n-                    self.tcx.mk_region(ReStatic)\n+                    self.tcx.types.re_static\n                 }\n             }\n \n@@ -971,7 +971,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 if a == b {\n                     a\n                 } else {\n-                    self.tcx.mk_region(ReStatic)\n+                    self.tcx.types.re_static\n                 }\n             }\n         }\n@@ -1018,7 +1018,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     fn construct_var_data(&self) -> Vec<VarValue<'tcx>> {\n         (0..self.num_vars() as usize)\n-            .map(|_| Value(self.tcx.mk_region(ty::ReEmpty)))\n+            .map(|_| Value(self.tcx.types.re_empty))\n             .collect()\n     }\n \n@@ -1493,7 +1493,7 @@ fn lookup<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                           -> &'tcx ty::Region {\n     match values[rid.index as usize] {\n         Value(r) => r,\n-        ErrorValue => tcx.mk_region(ReStatic), // Previously reported error.\n+        ErrorValue => tcx.types.re_static, // Previously reported error.\n     }\n }\n "}, {"sha": "ec7b3c4dd8dffd4514205789364611c8a89a4a26", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -38,12 +38,13 @@ pub enum ConstVal<'tcx> {\n     Str(InternedString),\n     ByteStr(Rc<Vec<u8>>),\n     Bool(bool),\n+    Char(char),\n+    Variant(DefId),\n     Function(DefId, &'tcx Substs<'tcx>),\n     Struct(BTreeMap<ast::Name, ConstVal<'tcx>>),\n     Tuple(Vec<ConstVal<'tcx>>),\n     Array(Vec<ConstVal<'tcx>>),\n     Repeat(Box<ConstVal<'tcx>>, u64),\n-    Char(char),\n }\n \n impl<'tcx> ConstVal<'tcx> {\n@@ -54,12 +55,13 @@ impl<'tcx> ConstVal<'tcx> {\n             Str(_) => \"string literal\",\n             ByteStr(_) => \"byte string literal\",\n             Bool(_) => \"boolean\",\n+            Char(..) => \"char\",\n+            Variant(_) => \"enum variant\",\n             Struct(_) => \"struct\",\n             Tuple(_) => \"tuple\",\n             Function(..) => \"function definition\",\n             Array(..) => \"array\",\n             Repeat(..) => \"repeat\",\n-            Char(..) => \"char\",\n         }\n     }\n \n@@ -85,7 +87,6 @@ pub enum ErrKind<'tcx> {\n     MissingStructField,\n     NegateOn(ConstVal<'tcx>),\n     NotOn(ConstVal<'tcx>),\n-    CallOn(ConstVal<'tcx>),\n \n     NonConstPath,\n     UnimplementedConstVal(&'static str),\n@@ -145,7 +146,6 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n             CannotCast => simple!(\"can't cast this type\"),\n             NegateOn(ref const_val) => simple!(\"negate on {}\", const_val.description()),\n             NotOn(ref const_val) => simple!(\"not on {}\", const_val.description()),\n-            CallOn(ref const_val) => simple!(\"call on {}\", const_val.description()),\n \n             MissingStructField  => simple!(\"nonexistent struct field\"),\n             NonConstPath        => simple!(\"non-constant path in constant expression\"),\n@@ -227,7 +227,8 @@ pub fn eval_length(tcx: TyCtxt,\n {\n     let count_expr = &tcx.hir.body(count).value;\n     let count_def_id = tcx.hir.body_owner_def_id(count);\n-    match ty::queries::monomorphic_const_eval::get(tcx, count_expr.span, count_def_id) {\n+    let substs = Substs::empty();\n+    match ty::queries::const_eval::get(tcx, count_expr.span, (count_def_id, substs)) {\n         Ok(Integral(Usize(count))) => {\n             let val = count.as_u64(tcx.sess.target.uint_type);\n             assert_eq!(val as usize as u64, val);"}, {"sha": "3251addcb3283310ffaf7b32dcca5f5019c58d95", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -188,14 +188,13 @@ pub trait CrateStore {\n     fn visibility(&self, def: DefId) -> ty::Visibility;\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::Ref<'a, DefIdMap<DefId>>;\n     fn item_generics_cloned(&self, def: DefId) -> ty::Generics;\n-    fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n+    fn item_attrs(&self, def_id: DefId) -> Rc<[ast::Attribute]>;\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>;\n \n     // trait info\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>;\n \n     // impl info\n-    fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity;\n     fn impl_parent(&self, impl_def_id: DefId) -> Option<DefId>;\n \n     // trait/impl-item info\n@@ -250,8 +249,8 @@ pub trait CrateStore {\n     fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro;\n \n     // misc. metadata\n-    fn maybe_get_item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                     -> Option<&'tcx hir::Body>;\n+    fn item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                           -> &'tcx hir::Body;\n     fn item_body_nested_bodies(&self, def: DefId) -> BTreeMap<hir::BodyId, hir::Body>;\n     fn const_is_rvalue_promotable_to_static(&self, def: DefId) -> bool;\n \n@@ -323,14 +322,13 @@ impl CrateStore for DummyCrateStore {\n     }\n     fn item_generics_cloned(&self, def: DefId) -> ty::Generics\n         { bug!(\"item_generics_cloned\") }\n-    fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n+    fn item_attrs(&self, def_id: DefId) -> Rc<[ast::Attribute]> { bug!(\"item_attrs\") }\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name> { bug!(\"fn_arg_names\") }\n \n     // trait info\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId> { vec![] }\n \n     // impl info\n-    fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity { bug!(\"impl_polarity\") }\n     fn impl_parent(&self, def: DefId) -> Option<DefId> { bug!(\"impl_parent\") }\n \n     // trait/impl-item info\n@@ -401,9 +399,9 @@ impl CrateStore for DummyCrateStore {\n     fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro { bug!(\"load_macro\") }\n \n     // misc. metadata\n-    fn maybe_get_item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                     -> Option<&'tcx hir::Body> {\n-        bug!(\"maybe_get_item_body\")\n+    fn item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                           -> &'tcx hir::Body {\n+        bug!(\"item_body\")\n     }\n     fn item_body_nested_bodies(&self, def: DefId) -> BTreeMap<hir::BodyId, hir::Body> {\n         bug!(\"item_body_nested_bodies\")"}, {"sha": "8b26315915826ce41723cc3f27afd06c183aa900", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -426,7 +426,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n             hir::ExprMatch(ref discr, ref arms, _) => {\n                 let discr_cmt = return_if_err!(self.mc.cat_expr(&discr));\n-                let r = self.tcx().mk_region(ty::ReEmpty);\n+                let r = self.tcx().types.re_empty;\n                 self.borrow_expr(&discr, r, ty::ImmBorrow, MatchDiscriminant);\n \n                 // treatment of the discriminant is handled while walking the arms."}, {"sha": "3b506d748ef7a01ff17f88dcd524da8f22cc0100", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -223,9 +223,10 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n \n pub fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     for attribute in attrs {\n-        match attribute.value_str() {\n-            Some(value) if attribute.check_name(\"lang\") => return Some(value),\n-            _ => {}\n+        if attribute.check_name(\"lang\") {\n+            if let Some(value) = attribute.value_str() {\n+                return Some(value)\n+            }\n         }\n     }\n "}, {"sha": "188fcc9141492447de66d14cf6486ef4f5ea7136", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -871,8 +871,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // we can promote to a constant, otherwise equal to enclosing temp\n         // lifetime.\n         let (re, old_re) = if promotable {\n-            (self.tcx().mk_region(ty::ReStatic),\n-             self.tcx().mk_region(ty::ReStatic))\n+            (self.tcx().types.re_static,\n+             self.tcx().types.re_static)\n         } else {\n             self.temporary_scope(id)\n         };"}, {"sha": "be4ec16cd63aab3038176482046aa024893b9564", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -18,6 +18,7 @@\n use hir::map as hir_map;\n use hir::def::Def;\n use hir::def_id::{DefId, CrateNum};\n+use std::rc::Rc;\n use ty::{self, TyCtxt};\n use ty::maps::Providers;\n use middle::privacy;\n@@ -362,11 +363,11 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n     }\n }\n \n-pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> NodeSet {\n+pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Rc<NodeSet> {\n     ty::queries::reachable_set::get(tcx, DUMMY_SP, LOCAL_CRATE)\n }\n \n-fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> NodeSet {\n+fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> Rc<NodeSet> {\n     debug_assert!(crate_num == LOCAL_CRATE);\n \n     let access_levels = &ty::queries::privacy_access_levels::get(tcx, DUMMY_SP, LOCAL_CRATE);\n@@ -411,7 +412,7 @@ fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) ->\n     reachable_context.propagate();\n \n     // Return the set of reachable symbols.\n-    reachable_context.reachable_symbols\n+    Rc::new(reachable_context.reachable_symbols)\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "bfb72b5df7b2e7143d9dc058490c12f2444f375b", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -1307,10 +1307,11 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n             write!(fmt, \"b\\\"{}\\\"\", escaped)\n         }\n         Bool(b) => write!(fmt, \"{:?}\", b),\n+        Char(c) => write!(fmt, \"{:?}\", c),\n+        Variant(def_id) |\n         Function(def_id, _) => write!(fmt, \"{}\", item_path_str(def_id)),\n         Struct(_) | Tuple(_) | Array(_) | Repeat(..) =>\n             bug!(\"ConstVal `{:?}` should not be in MIR\", const_val),\n-        Char(c) => write!(fmt, \"{:?}\", c),\n     }\n }\n "}, {"sha": "908bb337fa18e1b3b9cd57bac62262e675204b7c", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -443,7 +443,7 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n                         // Otherwise, we have something of the form\n                         // `for<'a> T: 'a where 'a not in T`, which we can treat as `T: 'static`.\n                         Some(t_a) => {\n-                            let r_static = selcx.tcx().mk_region(ty::ReStatic);\n+                            let r_static = selcx.tcx().types.re_static;\n                             register_region_obligation(t_a, r_static,\n                                                        obligation.cause.clone(),\n                                                        region_obligations);"}, {"sha": "281c1e253798cd080383731626b90d98cfb0d6cc", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -55,6 +55,7 @@ mod object_safety;\n mod select;\n mod specialize;\n mod structural_impls;\n+pub mod trans;\n mod util;\n \n /// An `Obligation` represents some trait reference (e.g. `int:Eq`) for\n@@ -628,7 +629,7 @@ pub fn get_vtable_methods<'a, 'tcx>(\n             // the method may have some early-bound lifetimes, add\n             // regions for those\n             let substs = Substs::for_item(tcx, def_id,\n-                                          |_, _| tcx.mk_region(ty::ReErased),\n+                                          |_, _| tcx.types.re_erased,\n                                           |def, _| trait_ref.substs().type_for_def(def));\n \n             // the trait type may have higher-ranked lifetimes in it;"}, {"sha": "207016170faa20655d5b564fa0fbcdc66c03a4b9", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -943,17 +943,17 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     debug!(\"Retaining candidate #{}/{}: {:?}\",\n                            i, candidates.len(), candidates[i]);\n                     i += 1;\n+\n+                    // If there are *STILL* multiple candidates, give up\n+                    // and report ambiguity.\n+                    if i > 1 {\n+                        debug!(\"multiple matches, ambig\");\n+                        return Ok(None);\n+                    }\n                 }\n             }\n         }\n \n-        // If there are *STILL* multiple candidates, give up and\n-        // report ambiguity.\n-        if candidates.len() > 1 {\n-            debug!(\"multiple matches, ambig\");\n-            return Ok(None);\n-        }\n-\n         // If there are *NO* candidates, then there are no impls --\n         // that we know of, anyway. Note that in the case where there\n         // are unbound type variables within the obligation, it might\n@@ -1300,8 +1300,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                             .iter()\n                             .filter_map(|o| o.to_opt_poly_trait_ref());\n \n+        // micro-optimization: filter out predicates relating to different\n+        // traits.\n+        let matching_bounds =\n+            all_bounds.filter(|p| p.def_id() == stack.obligation.predicate.def_id());\n+\n         let matching_bounds =\n-            all_bounds.filter(\n+            matching_bounds.filter(\n                 |bound| self.evaluate_where_clause(stack, bound.clone()).may_apply());\n \n         let param_candidates =\n@@ -1790,11 +1795,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyAdt(def, substs) => {\n                 let sized_crit = def.sized_constraint(self.tcx());\n                 // (*) binder moved here\n-                Where(ty::Binder(match sized_crit.sty {\n-                    ty::TyTuple(tys, _) => tys.to_vec().subst(self.tcx(), substs),\n-                    ty::TyBool => vec![],\n-                    _ => vec![sized_crit.subst(self.tcx(), substs)]\n-                }))\n+                Where(ty::Binder(\n+                    sized_crit.iter().map(|ty| ty.subst(self.tcx(), substs)).collect()\n+                ))\n             }\n \n             ty::TyProjection(_) | ty::TyParam(_) | ty::TyAnon(..) => None,"}, {"sha": "e38306aed2a91b9e7a0ffeac8bbe57bf32547ef1", "filename": "src/librustc/traits/trans/mod.rs", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -0,0 +1,212 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file contains various trait resolution methods used by trans.\n+// They all assume regions can be erased and monomorphic types.  It\n+// seems likely that they should eventually be merged into more\n+// general routines.\n+\n+use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig};\n+use hir::def_id::DefId;\n+use infer::TransNormalize;\n+use std::cell::RefCell;\n+use std::marker::PhantomData;\n+use syntax::ast;\n+use syntax_pos::Span;\n+use traits::{FulfillmentContext, Obligation, ObligationCause, Reveal, SelectionContext, Vtable};\n+use ty::{self, Ty, TyCtxt};\n+use ty::subst::{Subst, Substs};\n+use ty::fold::{TypeFoldable, TypeFolder};\n+use util::common::MemoizationMap;\n+\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+    /// Attempts to resolve an obligation to a vtable.. The result is\n+    /// a shallow vtable resolution -- meaning that we do not\n+    /// (necessarily) resolve all nested obligations on the impl. Note\n+    /// that type check should guarantee to us that all nested\n+    /// obligations *could be* resolved if we wanted to.\n+    pub fn trans_fulfill_obligation(self,\n+                                    span: Span,\n+                                    trait_ref: ty::PolyTraitRef<'tcx>)\n+                                    -> Vtable<'tcx, ()>\n+    {\n+        // Remove any references to regions; this helps improve caching.\n+        let trait_ref = self.erase_regions(&trait_ref);\n+\n+        self.trans_trait_caches.trait_cache.memoize(trait_ref, || {\n+            debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n+                   trait_ref, trait_ref.def_id());\n+\n+            // Do the initial selection for the obligation. This yields the\n+            // shallow result we are looking for -- that is, what specific impl.\n+            self.infer_ctxt((), Reveal::All).enter(|infcx| {\n+                let mut selcx = SelectionContext::new(&infcx);\n+\n+                let obligation_cause = ObligationCause::misc(span,\n+                                                             ast::DUMMY_NODE_ID);\n+                let obligation = Obligation::new(obligation_cause,\n+                                                 trait_ref.to_poly_trait_predicate());\n+\n+                let selection = match selcx.select(&obligation) {\n+                    Ok(Some(selection)) => selection,\n+                    Ok(None) => {\n+                        // Ambiguity can happen when monomorphizing during trans\n+                        // expands to some humongo type that never occurred\n+                        // statically -- this humongo type can then overflow,\n+                        // leading to an ambiguous result. So report this as an\n+                        // overflow bug, since I believe this is the only case\n+                        // where ambiguity can result.\n+                        debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n+                                presuming due to overflow\",\n+                               trait_ref);\n+                        self.sess.span_fatal(span,\n+                                            \"reached the recursion limit during monomorphization \\\n+                                             (selection ambiguity)\");\n+                    }\n+                    Err(e) => {\n+                        span_bug!(span, \"Encountered error `{:?}` selecting `{:?}` during trans\",\n+                                  e, trait_ref)\n+                    }\n+                };\n+\n+                debug!(\"fulfill_obligation: selection={:?}\", selection);\n+\n+                // Currently, we use a fulfillment context to completely resolve\n+                // all nested obligations. This is because they can inform the\n+                // inference of the impl's type parameters.\n+                let mut fulfill_cx = FulfillmentContext::new();\n+                let vtable = selection.map(|predicate| {\n+                    debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n+                    fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+                });\n+                let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);\n+\n+                info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n+                vtable\n+            })\n+        })\n+    }\n+\n+    /// Monomorphizes a type from the AST by first applying the in-scope\n+    /// substitutions and then normalizing any associated types.\n+    pub fn trans_apply_param_substs<T>(self,\n+                                       param_substs: &Substs<'tcx>,\n+                                       value: &T)\n+                                       -> T\n+        where T: TransNormalize<'tcx>\n+    {\n+        debug!(\"apply_param_substs(param_substs={:?}, value={:?})\", param_substs, value);\n+        let substituted = value.subst(self, param_substs);\n+        let substituted = self.erase_regions(&substituted);\n+        AssociatedTypeNormalizer::new(self).fold(&substituted)\n+    }\n+}\n+\n+struct AssociatedTypeNormalizer<'a, 'gcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+}\n+\n+impl<'a, 'gcx> AssociatedTypeNormalizer<'a, 'gcx> {\n+    fn new(tcx: TyCtxt<'a, 'gcx, 'gcx>) -> Self {\n+        AssociatedTypeNormalizer { tcx }\n+    }\n+\n+    fn fold<T:TypeFoldable<'gcx>>(&mut self, value: &T) -> T {\n+        if !value.has_projection_types() {\n+            value.clone()\n+        } else {\n+            value.fold_with(self)\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx> TypeFolder<'gcx, 'gcx> for AssociatedTypeNormalizer<'a, 'gcx> {\n+    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'gcx, 'gcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'gcx>) -> Ty<'gcx> {\n+        if !ty.has_projection_types() {\n+            ty\n+        } else {\n+            self.tcx.trans_trait_caches.project_cache.memoize(ty, || {\n+                debug!(\"AssociatedTypeNormalizer: ty={:?}\", ty);\n+                self.tcx.normalize_associated_type(&ty)\n+            })\n+        }\n+    }\n+}\n+\n+/// Specializes caches used in trans -- in particular, they assume all\n+/// types are fully monomorphized and that free regions can be erased.\n+pub struct TransTraitCaches<'tcx> {\n+    trait_cache: RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>>,\n+    project_cache: RefCell<DepTrackingMap<ProjectionCache<'tcx>>>,\n+}\n+\n+impl<'tcx> TransTraitCaches<'tcx> {\n+    pub fn new(graph: DepGraph) -> Self {\n+        TransTraitCaches {\n+            trait_cache: RefCell::new(DepTrackingMap::new(graph.clone())),\n+            project_cache: RefCell::new(DepTrackingMap::new(graph)),\n+        }\n+    }\n+}\n+\n+// Implement DepTrackingMapConfig for `trait_cache`\n+pub struct TraitSelectionCache<'tcx> {\n+    data: PhantomData<&'tcx ()>\n+}\n+\n+impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n+    type Key = ty::PolyTraitRef<'tcx>;\n+    type Value = Vtable<'tcx, ()>;\n+    fn to_dep_node(key: &ty::PolyTraitRef<'tcx>) -> DepNode<DefId> {\n+        key.to_poly_trait_predicate().dep_node()\n+    }\n+}\n+\n+// # Global Cache\n+\n+pub struct ProjectionCache<'gcx> {\n+    data: PhantomData<&'gcx ()>\n+}\n+\n+impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n+    type Key = Ty<'gcx>;\n+    type Value = Ty<'gcx>;\n+    fn to_dep_node(key: &Self::Key) -> DepNode<DefId> {\n+        // Ideally, we'd just put `key` into the dep-node, but we\n+        // can't put full types in there. So just collect up all the\n+        // def-ids of structs/enums as well as any traits that we\n+        // project out of. It doesn't matter so much what we do here,\n+        // except that if we are too coarse, we'll create overly\n+        // coarse edges between impls and the trans. For example, if\n+        // we just used the def-id of things we are projecting out of,\n+        // then the key for `<Foo as SomeTrait>::T` and `<Bar as\n+        // SomeTrait>::T` would both share a dep-node\n+        // (`TraitSelect(SomeTrait)`), and hence the impls for both\n+        // `Foo` and `Bar` would be considered inputs. So a change to\n+        // `Bar` would affect things that just normalized `Foo`.\n+        // Anyway, this heuristic is not ideal, but better than\n+        // nothing.\n+        let def_ids: Vec<DefId> =\n+            key.walk()\n+               .filter_map(|t| match t.sty {\n+                   ty::TyAdt(adt_def, _) => Some(adt_def.did),\n+                   ty::TyProjection(ref proj) => Some(proj.trait_ref.def_id),\n+                   _ => None,\n+               })\n+               .collect();\n+\n+        DepNode::ProjectionCache { def_ids: def_ids }\n+    }\n+}\n+"}, {"sha": "b20ac8ddbfc8a925bd85ea1c0dcff79facae0486", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -190,6 +190,10 @@ pub struct CommonTypes<'tcx> {\n     pub f64: Ty<'tcx>,\n     pub never: Ty<'tcx>,\n     pub err: Ty<'tcx>,\n+\n+    pub re_empty: &'tcx Region,\n+    pub re_static: &'tcx Region,\n+    pub re_erased: &'tcx Region,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -360,6 +364,14 @@ impl<'tcx> TypeckTables<'tcx> {\n impl<'tcx> CommonTypes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonTypes<'tcx> {\n         let mk = |sty| interners.intern_ty(sty, None);\n+        let mk_region = |r| {\n+            if let Some(r) = interners.region.borrow().get(&r) {\n+                return r.0;\n+            }\n+            let r = interners.arena.alloc(r);\n+            interners.region.borrow_mut().insert(Interned(r));\n+            &*r\n+        };\n         CommonTypes {\n             bool: mk(TyBool),\n             char: mk(TyChar),\n@@ -379,6 +391,10 @@ impl<'tcx> CommonTypes<'tcx> {\n             u128: mk(TyUint(ast::UintTy::U128)),\n             f32: mk(TyFloat(ast::FloatTy::F32)),\n             f64: mk(TyFloat(ast::FloatTy::F64)),\n+\n+            re_empty: mk_region(Region::ReEmpty),\n+            re_static: mk_region(Region::ReStatic),\n+            re_erased: mk_region(Region::ReErased),\n         }\n     }\n }\n@@ -407,6 +423,8 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub specializes_cache: RefCell<traits::SpecializesCache>,\n \n+    pub trans_trait_caches: traits::trans::TransTraitCaches<'tcx>,\n+\n     pub dep_graph: DepGraph,\n \n     /// Common types, pre-interned for your convenience.\n@@ -689,6 +707,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         providers[LOCAL_CRATE] = local_providers;\n         tls::enter_global(GlobalCtxt {\n             sess: s,\n+            trans_trait_caches: traits::trans::TransTraitCaches::new(dep_graph.clone()),\n             specializes_cache: RefCell::new(traits::SpecializesCache::new()),\n             global_arenas: arenas,\n             global_interners: interners,\n@@ -1229,7 +1248,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_static_str(self) -> Ty<'tcx> {\n-        self.mk_imm_ref(self.mk_region(ty::ReStatic), self.mk_str())\n+        self.mk_imm_ref(self.types.re_static, self.mk_str())\n     }\n \n     pub fn mk_adt(self, def: &'tcx AdtDef, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {"}, {"sha": "969d040e7a6e8f94e92fdd724be49dbce6769907", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -410,7 +410,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn erase_late_bound_regions<T>(self, value: &Binder<T>) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        self.replace_late_bound_regions(value, |_| self.mk_region(ty::ReErased)).0\n+        self.replace_late_bound_regions(value, |_| self.types.re_erased).0\n     }\n \n     /// Rewrite any late-bound regions so that they are anonymous.  Region numbers are\n@@ -538,7 +538,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 // whenever a substitution occurs.\n                 match *r {\n                     ty::ReLateBound(..) => r,\n-                    _ => self.tcx().mk_region(ty::ReErased)\n+                    _ => self.tcx().types.re_erased\n                 }\n             }\n         }\n@@ -565,6 +565,22 @@ pub fn shift_region(region: ty::Region, amount: u32) -> ty::Region {\n     }\n }\n \n+pub fn shift_region_ref<'a, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    region: &'tcx ty::Region,\n+    amount: u32)\n+    -> &'tcx ty::Region\n+{\n+    match region {\n+        &ty::ReLateBound(debruijn, br) if amount > 0 => {\n+            tcx.mk_region(ty::ReLateBound(debruijn.shifted(amount), br))\n+        }\n+        _ => {\n+            region\n+        }\n+    }\n+}\n+\n pub fn shift_regions<'a, 'gcx, 'tcx, T>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                         amount: u32, value: &T) -> T\n     where T: TypeFoldable<'tcx>\n@@ -573,7 +589,7 @@ pub fn shift_regions<'a, 'gcx, 'tcx, T>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n            value, amount);\n \n     value.fold_with(&mut RegionFolder::new(tcx, &mut false, &mut |region, _current_depth| {\n-        tcx.mk_region(shift_region(*region, amount))\n+        shift_region_ref(tcx, region, amount)\n     }))\n }\n "}, {"sha": "cfff3d0e573603340808c3e73b98db8e8e30b3e4", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -13,10 +13,7 @@ use hir::def_id::DefId;\n use ty::{self, Ty, TypeFoldable, Substs};\n use util::ppaux;\n \n-use std::borrow::Cow;\n use std::fmt;\n-use syntax::ast;\n-\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct Instance<'tcx> {\n@@ -59,7 +56,7 @@ impl<'tcx> InstanceDef<'tcx> {\n     }\n \n     #[inline]\n-    pub fn attrs<'a>(&self, tcx: ty::TyCtxt<'a, 'tcx, 'tcx>) -> Cow<'tcx, [ast::Attribute]> {\n+    pub fn attrs<'a>(&self, tcx: ty::TyCtxt<'a, 'tcx, 'tcx>) -> ty::Attributes<'tcx> {\n         tcx.get_attrs(self.def_id())\n     }\n "}, {"sha": "49cc4e7c993a53de08f46a0c11feab317722c3ec", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -822,7 +822,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n             }\n \n             (_, &ty::TyProjection(_)) | (_, &ty::TyAnon(..)) => {\n-                let normalized = normalize_associated_type(infcx, ty);\n+                let normalized = infcx.normalize_projections(ty);\n                 if ty == normalized {\n                     return Ok(None);\n                 }\n@@ -1067,28 +1067,6 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n     }\n }\n \n-/// Helper function for normalizing associated types in an inference context.\n-fn normalize_associated_type<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                             ty: Ty<'gcx>)\n-                                             -> Ty<'gcx> {\n-    if !ty.has_projection_types() {\n-        return ty;\n-    }\n-\n-    let mut selcx = traits::SelectionContext::new(infcx);\n-    let cause = traits::ObligationCause::dummy();\n-    let traits::Normalized { value: result, obligations } =\n-        traits::normalize(&mut selcx, cause, &ty);\n-\n-    let mut fulfill_cx = traits::FulfillmentContext::new();\n-\n-    for obligation in obligations {\n-        fulfill_cx.register_predicate_obligation(infcx, obligation);\n-    }\n-\n-    infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &result)\n-}\n-\n impl<'a, 'gcx, 'tcx> Layout {\n     pub fn compute_uncached(ty: Ty<'gcx>,\n                             infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n@@ -1100,7 +1078,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n         let ptr_layout = |pointee: Ty<'gcx>| {\n             let non_zero = !ty.is_unsafe_ptr();\n-            let pointee = normalize_associated_type(infcx, pointee);\n+            let pointee = infcx.normalize_projections(pointee);\n             if pointee.is_sized(tcx, &infcx.parameter_environment, DUMMY_SP) {\n                 Ok(Scalar { value: Pointer, non_zero: non_zero })\n             } else {\n@@ -1494,7 +1472,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             // Types with no meaningful known layout.\n             ty::TyProjection(_) | ty::TyAnon(..) => {\n-                let normalized = normalize_associated_type(infcx, ty);\n+                let normalized = infcx.normalize_projections(ty);\n                 if ty == normalized {\n                     return Err(LayoutError::Unknown(ty));\n                 }\n@@ -1812,7 +1790,7 @@ impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n             }\n \n             ty::TyProjection(_) | ty::TyAnon(..) => {\n-                let normalized = normalize_associated_type(infcx, ty);\n+                let normalized = infcx.normalize_projections(ty);\n                 if ty == normalized {\n                     Err(err)\n                 } else {\n@@ -1882,20 +1860,40 @@ pub trait LayoutTyper<'tcx>: HasTyCtxt<'tcx> {\n     type TyLayout;\n \n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout;\n+    fn normalize_projections(self, ty: Ty<'tcx>) -> Ty<'tcx>;\n }\n \n impl<'a, 'gcx, 'tcx> LayoutTyper<'gcx> for &'a InferCtxt<'a, 'gcx, 'tcx> {\n     type TyLayout = Result<TyLayout<'gcx>, LayoutError<'gcx>>;\n \n     fn layout_of(self, ty: Ty<'gcx>) -> Self::TyLayout {\n-        let ty = normalize_associated_type(self, ty);\n+        let ty = self.normalize_projections(ty);\n \n         Ok(TyLayout {\n             ty: ty,\n             layout: ty.layout(self)?,\n             variant_index: None\n         })\n     }\n+\n+    fn normalize_projections(self, ty: Ty<'gcx>) -> Ty<'gcx> {\n+        if !ty.has_projection_types() {\n+            return ty;\n+        }\n+\n+        let mut selcx = traits::SelectionContext::new(self);\n+        let cause = traits::ObligationCause::dummy();\n+        let traits::Normalized { value: result, obligations } =\n+            traits::normalize(&mut selcx, cause, &ty);\n+\n+        let mut fulfill_cx = traits::FulfillmentContext::new();\n+\n+        for obligation in obligations {\n+            fulfill_cx.register_predicate_obligation(self, obligation);\n+        }\n+\n+        self.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &result)\n+    }\n }\n \n impl<'a, 'tcx> TyLayout<'tcx> {\n@@ -2019,6 +2017,6 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n     }\n \n     pub fn field<C: LayoutTyper<'tcx>>(&self, cx: C, i: usize) -> C::TyLayout {\n-        cx.layout_of(self.field_type(cx, i))\n+        cx.layout_of(cx.normalize_projections(self.field_type(cx, i)))\n     }\n }"}, {"sha": "4595a8c4f7784161715db667abad9c2bd50c3040", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 42, "deletions": 7, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -10,11 +10,13 @@\n \n use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use hir;\n use middle::const_val;\n use middle::privacy::AccessLevels;\n use mir;\n use session::CompileResult;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n+use ty::subst::Substs;\n use util::nodemap::NodeSet;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -73,6 +75,15 @@ impl Key for (CrateNum, DefId) {\n     }\n }\n \n+impl<'tcx> Key for (DefId, &'tcx Substs<'tcx>) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.0.default_span(tcx)\n+    }\n+}\n+\n trait Value<'tcx>: Sized {\n     fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self;\n }\n@@ -96,6 +107,13 @@ impl<'tcx> Value<'tcx> for Ty<'tcx> {\n     }\n }\n \n+\n+impl<'tcx> Value<'tcx> for ty::DtorckConstraint<'tcx> {\n+    fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+        Self::empty()\n+    }\n+}\n+\n pub struct CycleError<'a, 'tcx: 'a> {\n     span: Span,\n     cycle: RefMut<'a, [(Span, Query<'tcx>)]>,\n@@ -216,6 +234,13 @@ impl<'tcx> QueryDescription for queries::reachable_set<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::const_eval<'tcx> {\n+    fn describe(tcx: TyCtxt, (def_id, _): (DefId, &'tcx Substs<'tcx>)) -> String {\n+        format!(\"const-evaluating `{}`\",\n+                tcx.item_path_str(def_id))\n+    }\n+}\n+\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n@@ -378,7 +403,11 @@ define_maps! { <'tcx>\n     pub trait_def: ItemSignature(DefId) -> &'tcx ty::TraitDef,\n     pub adt_def: ItemSignature(DefId) -> &'tcx ty::AdtDef,\n     pub adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n-    pub adt_sized_constraint: SizedConstraint(DefId) -> Ty<'tcx>,\n+    pub adt_sized_constraint: SizedConstraint(DefId) -> &'tcx [Ty<'tcx>],\n+    pub adt_dtorck_constraint: DtorckConstraint(DefId) -> ty::DtorckConstraint<'tcx>,\n+\n+    /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n+    pub is_foreign_item: IsForeignItem(DefId) -> bool,\n \n     /// Maps from def-id of a type or region parameter to its\n     /// (inferred) variance.\n@@ -391,6 +420,7 @@ define_maps! { <'tcx>\n     pub associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n \n     pub impl_trait_ref: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>>,\n+    pub impl_polarity: ItemSignature(DefId) -> hir::ImplPolarity,\n \n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n@@ -441,16 +471,17 @@ define_maps! { <'tcx>\n     /// (Defined only for LOCAL_CRATE)\n     pub crate_inherent_impls_overlap_check: crate_inherent_impls_dep_node(CrateNum) -> (),\n \n-    /// Results of evaluating monomorphic constants embedded in\n-    /// other items, such as enum variant explicit discriminants.\n-    pub monomorphic_const_eval: MonomorphicConstEval(DefId) -> const_val::EvalResult<'tcx>,\n+    /// Results of evaluating const items or constants embedded in\n+    /// other items (such as enum variant explicit discriminants).\n+    pub const_eval: const_eval_dep_node((DefId, &'tcx Substs<'tcx>))\n+        -> const_val::EvalResult<'tcx>,\n \n     /// Performs the privacy check and computes \"access levels\".\n     pub privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,\n \n-    pub reachable_set: reachability_dep_node(CrateNum) -> NodeSet,\n+    pub reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n \n-    pub mir_shims: mir_shim(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>\n+    pub mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>\n }\n \n fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n@@ -465,10 +496,14 @@ fn reachability_dep_node(_: CrateNum) -> DepNode<DefId> {\n     DepNode::Reachability\n }\n \n-fn mir_shim(instance: ty::InstanceDef) -> DepNode<DefId> {\n+fn mir_shim_dep_node(instance: ty::InstanceDef) -> DepNode<DefId> {\n     instance.dep_node()\n }\n \n fn typeck_item_bodies_dep_node(_: CrateNum) -> DepNode<DefId> {\n     DepNode::TypeckBodiesKrate\n }\n+\n+fn const_eval_dep_node((def_id, _): (DefId, &Substs)) -> DepNode<DefId> {\n+    DepNode::ConstEval(def_id)\n+}"}, {"sha": "352b6ab1d356f456ef26f5e2ba4452f1d03efe6d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 143, "deletions": 86, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -31,14 +31,15 @@ use ty;\n use ty::subst::{Subst, Substs};\n use ty::util::IntTypeExt;\n use ty::walk::TypeWalker;\n-use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n+use util::common::ErrorReported;\n+use util::nodemap::{NodeSet, DefIdMap, FxHashMap, FxHashSet};\n \n use serialize::{self, Encodable, Encoder};\n-use std::borrow::Cow;\n use std::cell::{Cell, RefCell, Ref};\n use std::collections::BTreeMap;\n use std::cmp;\n use std::hash::{Hash, Hasher};\n+use std::iter::FromIterator;\n use std::ops::Deref;\n use std::rc::Rc;\n use std::slice;\n@@ -115,7 +116,7 @@ mod sty;\n #[derive(Clone)]\n pub struct CrateAnalysis {\n     pub access_levels: Rc<AccessLevels>,\n-    pub reachable: NodeSet,\n+    pub reachable: Rc<NodeSet>,\n     pub name: String,\n     pub glob_map: Option<hir::GlobMap>,\n }\n@@ -1333,17 +1334,6 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n pub struct Destructor {\n     /// The def-id of the destructor method\n     pub did: DefId,\n-    /// Invoking the destructor of a dtorck type during usual cleanup\n-    /// (e.g. the glue emitted for stack unwinding) requires all\n-    /// lifetimes in the type-structure of `adt` to strictly outlive\n-    /// the adt value itself.\n-    ///\n-    /// If `adt` is not dtorck, then the adt's destructor can be\n-    /// invoked even when there are lifetimes in the type-structure of\n-    /// `adt` that do not strictly outlive the adt value itself.\n-    /// (This allows programs to make cyclic structures without\n-    /// resorting to unsafe means; see RFCs 769 and 1238).\n-    pub is_dtorck: bool,\n }\n \n bitflags! {\n@@ -1610,14 +1600,6 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n     }\n \n-    /// Returns whether this is a dtorck type. If this returns\n-    /// true, this type being safe for destruction requires it to be\n-    /// alive; Otherwise, only the contents are required to be.\n-    #[inline]\n-    pub fn is_dtorck(&'gcx self, tcx: TyCtxt) -> bool {\n-        self.destructor(tcx).map_or(false, |d| d.is_dtorck)\n-    }\n-\n     /// Returns whether this type is #[fundamental] for the purposes\n     /// of coherence checking.\n     #[inline]\n@@ -1694,6 +1676,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n     }\n \n+    #[inline]\n     pub fn discriminants(&'a self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n                          -> impl Iterator<Item=ConstInt> + 'a {\n         let repr_type = self.repr.discr_type();\n@@ -1702,11 +1685,18 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.variants.iter().map(move |v| {\n             let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr());\n             if let VariantDiscr::Explicit(expr_did) = v.discr {\n-                match queries::monomorphic_const_eval::get(tcx, DUMMY_SP, expr_did) {\n+                let substs = Substs::empty();\n+                match queries::const_eval::get(tcx, DUMMY_SP, (expr_did, substs)) {\n                     Ok(ConstVal::Integral(v)) => {\n                         discr = v;\n                     }\n-                    _ => {}\n+                    err => {\n+                        if !expr_did.is_local() {\n+                            span_bug!(tcx.def_span(expr_did),\n+                                \"variant discriminant evaluation succeeded \\\n+                                 in its crate but failed locally: {:?}\", err);\n+                        }\n+                    }\n                 }\n             }\n             prev_discr = Some(discr);\n@@ -1734,12 +1724,21 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                     explicit_index -= distance;\n                 }\n                 ty::VariantDiscr::Explicit(expr_did) => {\n-                    match queries::monomorphic_const_eval::get(tcx, DUMMY_SP, expr_did) {\n+                    let substs = Substs::empty();\n+                    match queries::const_eval::get(tcx, DUMMY_SP, (expr_did, substs)) {\n                         Ok(ConstVal::Integral(v)) => {\n                             explicit_value = v;\n                             break;\n                         }\n-                        _ => {\n+                        err => {\n+                            if !expr_did.is_local() {\n+                                span_bug!(tcx.def_span(expr_did),\n+                                    \"variant discriminant evaluation succeeded \\\n+                                     in its crate but failed locally: {:?}\", err);\n+                            }\n+                            if explicit_index == 0 {\n+                                break;\n+                            }\n                             explicit_index -= 1;\n                         }\n                     }\n@@ -1764,33 +1763,26 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         queries::adt_destructor::get(tcx, DUMMY_SP, self.did)\n     }\n \n-    /// Returns a simpler type such that `Self: Sized` if and only\n+    /// Returns a list of types such that `Self: Sized` if and only\n     /// if that type is Sized, or `TyErr` if this type is recursive.\n     ///\n-    /// HACK: instead of returning a list of types, this function can\n-    /// return a tuple. In that case, the result is Sized only if\n-    /// all elements of the tuple are Sized.\n-    ///\n-    /// This is generally the `struct_tail` if this is a struct, or a\n-    /// tuple of them if this is an enum.\n-    ///\n     /// Oddly enough, checking that the sized-constraint is Sized is\n     /// actually more expressive than checking all members:\n     /// the Sized trait is inductive, so an associated type that references\n     /// Self would prevent its containing ADT from being Sized.\n     ///\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer, e.g. issue #31299.\n-    pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx [Ty<'tcx>] {\n         match queries::adt_sized_constraint::try_get(tcx, DUMMY_SP, self.did) {\n-            Ok(ty) => ty,\n+            Ok(tys) => tys,\n             Err(_) => {\n                 debug!(\"adt_sized_constraint: {:?} is recursive\", self);\n                 // This should be reported as an error by `check_representable`.\n                 //\n                 // Consider the type as Sized in the meanwhile to avoid\n                 // further errors.\n-                tcx.types.err\n+                tcx.intern_type_list(&[tcx.types.err])\n             }\n         }\n     }\n@@ -1820,18 +1812,13 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n \n             TyAdt(adt, substs) => {\n                 // recursive case\n-                let adt_ty =\n-                    adt.sized_constraint(tcx)\n-                       .subst(tcx, substs);\n+                let adt_tys = adt.sized_constraint(tcx);\n                 debug!(\"sized_constraint_for_ty({:?}) intermediate = {:?}\",\n-                       ty, adt_ty);\n-                if let ty::TyTuple(ref tys, _) = adt_ty.sty {\n-                    tys.iter().flat_map(|ty| {\n-                        self.sized_constraint_for_ty(tcx, ty)\n-                    }).collect()\n-                } else {\n-                    self.sized_constraint_for_ty(tcx, adt_ty)\n-                }\n+                       ty, adt_tys);\n+                adt_tys.iter()\n+                    .map(|ty| ty.subst(tcx, substs))\n+                    .flat_map(|ty| self.sized_constraint_for_ty(tcx, ty))\n+                    .collect()\n             }\n \n             TyProjection(..) | TyAnon(..) => {\n@@ -2036,6 +2023,23 @@ impl BorrowKind {\n     }\n }\n \n+#[derive(Debug, Clone)]\n+pub enum Attributes<'gcx> {\n+    Owned(Rc<[ast::Attribute]>),\n+    Borrowed(&'gcx [ast::Attribute])\n+}\n+\n+impl<'gcx> ::std::ops::Deref for Attributes<'gcx> {\n+    type Target = [ast::Attribute];\n+\n+    fn deref(&self) -> &[ast::Attribute] {\n+        match self {\n+            &Attributes::Owned(ref data) => &data,\n+            &Attributes::Borrowed(data) => data\n+        }\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn body_tables(self, body: hir::BodyId) -> &'gcx TypeckTables<'gcx> {\n         self.item_tables(self.hir.body_owner_def_id(body))\n@@ -2133,14 +2137,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn trait_impl_polarity(self, id: DefId) -> hir::ImplPolarity {\n-        if let Some(id) = self.hir.as_local_node_id(id) {\n-            match self.hir.expect_item(id).node {\n-                hir::ItemImpl(_, polarity, ..) => polarity,\n-                ref item => bug!(\"trait_impl_polarity: {:?} not an impl\", item)\n-            }\n-        } else {\n-            self.sess.cstore.impl_polarity(id)\n-        }\n+        queries::impl_polarity::get(self, DUMMY_SP, id)\n     }\n \n     pub fn trait_relevant_for_never(self, did: DefId) -> bool {\n@@ -2389,11 +2386,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Get the attributes of a definition.\n-    pub fn get_attrs(self, did: DefId) -> Cow<'gcx, [ast::Attribute]> {\n+    pub fn get_attrs(self, did: DefId) -> Attributes<'gcx> {\n         if let Some(id) = self.hir.as_local_node_id(did) {\n-            Cow::Borrowed(self.hir.attrs(id))\n+            Attributes::Borrowed(self.hir.attrs(id))\n         } else {\n-            Cow::Owned(self.sess.cstore.item_attrs(did))\n+            Attributes::Owned(self.sess.cstore.item_attrs(did))\n         }\n     }\n \n@@ -2499,15 +2496,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Construct a parameter environment suitable for static contexts or other contexts where there\n     /// are no free type/lifetime parameters in scope.\n     pub fn empty_parameter_environment(self) -> ParameterEnvironment<'tcx> {\n-\n-        // for an empty parameter environment, there ARE no free\n-        // regions, so it shouldn't matter what we use for the free id\n-        let free_id_outlive = self.region_maps.node_extent(ast::DUMMY_NODE_ID);\n         ty::ParameterEnvironment {\n             free_substs: self.intern_substs(&[]),\n             caller_bounds: Vec::new(),\n-            implicit_region_bound: self.mk_region(ty::ReEmpty),\n-            free_id_outlive: free_id_outlive,\n+            implicit_region_bound: self.types.re_empty,\n+            // for an empty parameter environment, there ARE no free\n+            // regions, so it shouldn't matter what we use for the free id\n+            free_id_outlive: ROOT_CODE_EXTENT,\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),\n             is_freeze_cache: RefCell::new(FxHashMap()),\n@@ -2673,13 +2668,7 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n \n /// Calculates the Sized-constraint.\n ///\n-/// As the Sized-constraint of enums can be a *set* of types,\n-/// the Sized-constraint may need to be a set also. Because introducing\n-/// a new type of IVar is currently a complex affair, the Sized-constraint\n-/// may be a tuple.\n-///\n-/// In fact, there are only a few options for the constraint:\n-///     - `bool`, if the type is always Sized\n+/// In fact, there are only a few options for the types in the constraint:\n ///     - an obviously-unsized type\n ///     - a type parameter or projection whose Sizedness can't be known\n ///     - a tuple of type parameters or projections, if there are multiple\n@@ -2688,26 +2677,50 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n ///       check should catch this case.\n fn adt_sized_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   def_id: DefId)\n-                                  -> Ty<'tcx> {\n+                                  -> &'tcx [Ty<'tcx>] {\n     let def = tcx.lookup_adt_def(def_id);\n \n-    let tys: Vec<_> = def.variants.iter().flat_map(|v| {\n+    let result = tcx.intern_type_list(&def.variants.iter().flat_map(|v| {\n         v.fields.last()\n     }).flat_map(|f| {\n-        let ty = tcx.item_type(f.did);\n-        def.sized_constraint_for_ty(tcx, ty)\n-    }).collect();\n-\n-    let ty = match tys.len() {\n-        _ if tys.references_error() => tcx.types.err,\n-        0 => tcx.types.bool,\n-        1 => tys[0],\n-        _ => tcx.intern_tup(&tys[..], false)\n-    };\n+        def.sized_constraint_for_ty(tcx, tcx.item_type(f.did))\n+    }).collect::<Vec<_>>());\n \n-    debug!(\"adt_sized_constraint: {:?} => {:?}\", def, ty);\n+    debug!(\"adt_sized_constraint: {:?} => {:?}\", def, result);\n \n-    ty\n+    result\n+}\n+\n+/// Calculates the dtorck constraint for a type.\n+fn adt_dtorck_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   def_id: DefId)\n+                                   -> DtorckConstraint<'tcx> {\n+    let def = tcx.lookup_adt_def(def_id);\n+    let span = tcx.def_span(def_id);\n+    debug!(\"dtorck_constraint: {:?}\", def);\n+\n+    if def.is_phantom_data() {\n+        let result = DtorckConstraint {\n+            outlives: vec![],\n+            dtorck_types: vec![\n+                tcx.mk_param_from_def(&tcx.item_generics(def_id).types[0])\n+           ]\n+        };\n+        debug!(\"dtorck_constraint: {:?} => {:?}\", def, result);\n+        return result;\n+    }\n+\n+    let mut result = def.all_fields()\n+        .map(|field| tcx.item_type(field.did))\n+        .map(|fty| tcx.dtorck_constraint_for_ty(span, fty, 0, fty))\n+        .collect::<Result<DtorckConstraint, ErrorReported>>()\n+        .unwrap_or(DtorckConstraint::empty());\n+    result.outlives.extend(tcx.destructor_constraints(def));\n+    result.dedup();\n+\n+    debug!(\"dtorck_constraint: {:?} => {:?}\", def, result);\n+\n+    result\n }\n \n fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -2738,13 +2751,15 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         associated_item,\n         associated_item_def_ids,\n         adt_sized_constraint,\n+        adt_dtorck_constraint,\n         ..*providers\n     };\n }\n \n pub fn provide_extern(providers: &mut ty::maps::Providers) {\n     *providers = ty::maps::Providers {\n         adt_sized_constraint,\n+        adt_dtorck_constraint,\n         ..*providers\n     };\n }\n@@ -2761,3 +2776,45 @@ pub struct CrateInherentImpls {\n     pub inherent_impls: DefIdMap<Rc<Vec<DefId>>>,\n }\n \n+/// A set of constraints that need to be satisfied in order for\n+/// a type to be valid for destruction.\n+#[derive(Clone, Debug)]\n+pub struct DtorckConstraint<'tcx> {\n+    /// Types that are required to be alive in order for this\n+    /// type to be valid for destruction.\n+    pub outlives: Vec<ty::subst::Kind<'tcx>>,\n+    /// Types that could not be resolved: projections and params.\n+    pub dtorck_types: Vec<Ty<'tcx>>,\n+}\n+\n+impl<'tcx> FromIterator<DtorckConstraint<'tcx>> for DtorckConstraint<'tcx>\n+{\n+    fn from_iter<I: IntoIterator<Item=DtorckConstraint<'tcx>>>(iter: I) -> Self {\n+        let mut result = Self::empty();\n+\n+        for constraint in iter {\n+            result.outlives.extend(constraint.outlives);\n+            result.dtorck_types.extend(constraint.dtorck_types);\n+        }\n+\n+        result\n+    }\n+}\n+\n+\n+impl<'tcx> DtorckConstraint<'tcx> {\n+    fn empty() -> DtorckConstraint<'tcx> {\n+        DtorckConstraint {\n+            outlives: vec![],\n+            dtorck_types: vec![]\n+        }\n+    }\n+\n+    fn dedup<'a>(&mut self) {\n+        let mut outlives = FxHashSet();\n+        let mut dtorck_types = FxHashSet();\n+\n+        self.outlives.retain(|&val| outlives.replace(val).is_none());\n+        self.dtorck_types.retain(|&val| dtorck_types.replace(val).is_none());\n+    }\n+}"}, {"sha": "14aebdf8418fe58c1565847c12d69a0e82d9c5fd", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -539,6 +539,9 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n     }\n \n     fn shift_region_through_binders(&self, region: &'tcx ty::Region) -> &'tcx ty::Region {\n+        if self.region_binders_passed == 0 || !region.has_escaping_regions() {\n+            return region;\n+        }\n         self.tcx().mk_region(ty::fold::shift_region(*region, self.region_binders_passed))\n     }\n }"}, {"sha": "f68cf6f97f857d77bf9bfcaf2e7c516d79035f6a", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 162, "deletions": 4, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -19,6 +19,7 @@ use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n use ty::ParameterEnvironment;\n use ty::fold::TypeVisitor;\n use ty::layout::{Layout, LayoutError};\n+use ty::subst::{Subst, Kind};\n use ty::TypeVariants::*;\n use util::common::ErrorReported;\n use util::nodemap::{FxHashMap, FxHashSet};\n@@ -385,6 +386,27 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             None => return None,\n         };\n \n+        Some(ty::Destructor { did: dtor_did })\n+    }\n+\n+    /// Return the set of types that are required to be alive in\n+    /// order to run the destructor of `def` (see RFCs 769 and\n+    /// 1238).\n+    ///\n+    /// Note that this returns only the constraints for the\n+    /// destructor of `def` itself. For the destructors of the\n+    /// contents, you need `adt_dtorck_constraint`.\n+    pub fn destructor_constraints(self, def: &'tcx ty::AdtDef)\n+                                  -> Vec<ty::subst::Kind<'tcx>>\n+    {\n+        let dtor = match def.destructor(self) {\n+            None => {\n+                debug!(\"destructor_constraints({:?}) - no dtor\", def.did);\n+                return vec![]\n+            }\n+            Some(dtor) => dtor.did\n+        };\n+\n         // RFC 1238: if the destructor method is tagged with the\n         // attribute `unsafe_destructor_blind_to_params`, then the\n         // compiler is being instructed to *assume* that the\n@@ -394,11 +416,147 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // Such access can be in plain sight (e.g. dereferencing\n         // `*foo.0` of `Foo<'a>(&'a u32)`) or indirectly hidden\n         // (e.g. calling `foo.0.clone()` of `Foo<T:Clone>`).\n-        let is_dtorck = !self.has_attr(dtor_did, \"unsafe_destructor_blind_to_params\");\n-        Some(ty::Destructor { did: dtor_did, is_dtorck: is_dtorck })\n+        if self.has_attr(dtor, \"unsafe_destructor_blind_to_params\") {\n+            debug!(\"destructor_constraint({:?}) - blind\", def.did);\n+            return vec![];\n+        }\n+\n+        let impl_def_id = self.associated_item(dtor).container.id();\n+        let impl_generics = self.item_generics(impl_def_id);\n+\n+        // We have a destructor - all the parameters that are not\n+        // pure_wrt_drop (i.e, don't have a #[may_dangle] attribute)\n+        // must be live.\n+\n+        // We need to return the list of parameters from the ADTs\n+        // generics/substs that correspond to impure parameters on the\n+        // impl's generics. This is a bit ugly, but conceptually simple:\n+        //\n+        // Suppose our ADT looks like the following\n+        //\n+        //     struct S<X, Y, Z>(X, Y, Z);\n+        //\n+        // and the impl is\n+        //\n+        //     impl<#[may_dangle] P0, P1, P2> Drop for S<P1, P2, P0>\n+        //\n+        // We want to return the parameters (X, Y). For that, we match\n+        // up the item-substs <X, Y, Z> with the substs on the impl ADT,\n+        // <P1, P2, P0>, and then look up which of the impl substs refer to\n+        // parameters marked as pure.\n+\n+        let impl_substs = match self.item_type(impl_def_id).sty {\n+            ty::TyAdt(def_, substs) if def_ == def => substs,\n+            _ => bug!()\n+        };\n+\n+        let item_substs = match self.item_type(def.did).sty {\n+            ty::TyAdt(def_, substs) if def_ == def => substs,\n+            _ => bug!()\n+        };\n+\n+        let result = item_substs.iter().zip(impl_substs.iter())\n+            .filter(|&(_, &k)| {\n+                if let Some(&ty::Region::ReEarlyBound(ref ebr)) = k.as_region() {\n+                    !impl_generics.region_param(ebr).pure_wrt_drop\n+                } else if let Some(&ty::TyS {\n+                    sty: ty::TypeVariants::TyParam(ref pt), ..\n+                }) = k.as_type() {\n+                    !impl_generics.type_param(pt).pure_wrt_drop\n+                } else {\n+                    // not a type or region param - this should be reported\n+                    // as an error.\n+                    false\n+                }\n+            }).map(|(&item_param, _)| item_param).collect();\n+        debug!(\"destructor_constraint({:?}) = {:?}\", def.did, result);\n+        result\n+    }\n+\n+    /// Return a set of constraints that needs to be satisfied in\n+    /// order for `ty` to be valid for destruction.\n+    pub fn dtorck_constraint_for_ty(self,\n+                                    span: Span,\n+                                    for_ty: Ty<'tcx>,\n+                                    depth: usize,\n+                                    ty: Ty<'tcx>)\n+                                    -> Result<ty::DtorckConstraint<'tcx>, ErrorReported>\n+    {\n+        debug!(\"dtorck_constraint_for_ty({:?}, {:?}, {:?}, {:?})\",\n+               span, for_ty, depth, ty);\n+\n+        if depth >= self.sess.recursion_limit.get() {\n+            let mut err = struct_span_err!(\n+                self.sess, span, E0320,\n+                \"overflow while adding drop-check rules for {}\", for_ty);\n+            err.note(&format!(\"overflowed on {}\", ty));\n+            err.emit();\n+            return Err(ErrorReported);\n+        }\n+\n+        let result = match ty.sty {\n+            ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) |\n+            ty::TyFloat(_) | ty::TyStr | ty::TyNever |\n+            ty::TyRawPtr(..) | ty::TyRef(..) | ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+                // these types never have a destructor\n+                Ok(ty::DtorckConstraint::empty())\n+            }\n+\n+            ty::TyArray(ety, _) | ty::TySlice(ety) => {\n+                // single-element containers, behave like their element\n+                self.dtorck_constraint_for_ty(span, for_ty, depth+1, ety)\n+            }\n+\n+            ty::TyTuple(tys, _) => {\n+                tys.iter().map(|ty| {\n+                    self.dtorck_constraint_for_ty(span, for_ty, depth+1, ty)\n+                }).collect()\n+            }\n+\n+            ty::TyClosure(def_id, substs) => {\n+                substs.upvar_tys(def_id, self).map(|ty| {\n+                    self.dtorck_constraint_for_ty(span, for_ty, depth+1, ty)\n+                }).collect()\n+            }\n+\n+            ty::TyAdt(def, substs) => {\n+                let ty::DtorckConstraint {\n+                    dtorck_types, outlives\n+                } = ty::queries::adt_dtorck_constraint::get(self, span, def.did);\n+                Ok(ty::DtorckConstraint {\n+                    // FIXME: we can try to recursively `dtorck_constraint_on_ty`\n+                    // there, but that needs some way to handle cycles.\n+                    dtorck_types: dtorck_types.subst(self, substs),\n+                    outlives: outlives.subst(self, substs)\n+                })\n+            }\n+\n+            // Objects must be alive in order for their destructor\n+            // to be called.\n+            ty::TyDynamic(..) => Ok(ty::DtorckConstraint {\n+                outlives: vec![Kind::from(ty)],\n+                dtorck_types: vec![],\n+            }),\n+\n+            // Types that can't be resolved. Pass them forward.\n+            ty::TyProjection(..) | ty::TyAnon(..) | ty::TyParam(..) => {\n+                Ok(ty::DtorckConstraint {\n+                    outlives: vec![],\n+                    dtorck_types: vec![ty],\n+                })\n+            }\n+\n+            ty::TyInfer(..) | ty::TyError => {\n+                self.sess.delay_span_bug(span, \"unresolved type in dtorck\");\n+                Err(ErrorReported)\n+            }\n+        };\n+\n+        debug!(\"dtorck_constraint_for_ty({:?}) = {:?}\", ty, result);\n+        result\n     }\n \n-    pub fn closure_base_def_id(&self, def_id: DefId) -> DefId {\n+    pub fn closure_base_def_id(self, def_id: DefId) -> DefId {\n         let mut def_id = def_id;\n         while self.def_key(def_id).disambiguated_data.data == DefPathData::ClosureExpr {\n             def_id = self.parent_def_id(def_id).unwrap_or_else(|| {\n@@ -412,7 +570,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// a suitable \"empty substs\" for it.\n     pub fn empty_substs_for_def_id(self, item_def_id: DefId) -> &'tcx ty::Substs<'tcx> {\n         ty::Substs::for_item(self, item_def_id,\n-                             |_, _| self.mk_region(ty::ReErased),\n+                             |_, _| self.types.re_erased,\n                              |_, _| {\n             bug!(\"empty_substs_for_def_id: {:?} has type parameters\", item_def_id)\n         })"}, {"sha": "b921678b495c2803c0e6063184bd02d0960e398f", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -120,7 +120,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             }\n             Categorization::StaticItem |\n             Categorization::Deref(.., mc::UnsafePtr(..)) => {\n-                self.bccx.tcx.mk_region(ty::ReStatic)\n+                self.bccx.tcx.types.re_static\n             }\n             Categorization::Deref(.., mc::BorrowedPtr(_, r)) |\n             Categorization::Deref(.., mc::Implicit(_, r)) => {"}, {"sha": "e9352f53c92d68c724d5934465cc9ebe202a2abc", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 115, "deletions": 149, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -15,7 +15,7 @@ use rustc::middle::const_val::{ConstVal, ConstEvalErr, EvalResult, ErrKind};\n use rustc::hir::map as hir_map;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::traits;\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n@@ -48,110 +48,39 @@ macro_rules! math {\n     }\n }\n \n-fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  variant_def: DefId)\n-                                  -> Option<(&'tcx Expr, &'a ty::TypeckTables<'tcx>)> {\n-    if let Some(variant_node_id) = tcx.hir.as_local_node_id(variant_def) {\n-        let enum_node_id = tcx.hir.get_parent(variant_node_id);\n-        if let Some(hir_map::NodeItem(it)) = tcx.hir.find(enum_node_id) {\n-            if let hir::ItemEnum(ref edef, _) = it.node {\n-                for variant in &edef.variants {\n-                    if variant.node.data.id() == variant_node_id {\n-                        return variant.node.disr_expr.map(|e| {\n-                            let def_id = tcx.hir.body_owner_def_id(e);\n-                            (&tcx.hir.body(e).value,\n-                             tcx.item_tables(def_id))\n-                        });\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    None\n-}\n-\n /// * `def_id` is the id of the constant.\n /// * `substs` is the monomorphized substitutions for the expression.\n ///\n /// `substs` is optional and is used for associated constants.\n /// This generally happens in late/trans const evaluation.\n-pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        def_id: DefId,\n-                                        substs: &'tcx Substs<'tcx>)\n-                                        -> Option<(&'tcx Expr,\n-                                                   &'a ty::TypeckTables<'tcx>)> {\n+pub fn lookup_const_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                    def_id: DefId,\n+                                    substs: &'tcx Substs<'tcx>)\n+                                    -> Option<(DefId, &'tcx Substs<'tcx>)> {\n     if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n         match tcx.hir.find(node_id) {\n-            None => None,\n-            Some(hir_map::NodeItem(&hir::Item {\n-                node: hir::ItemConst(_, body), ..\n-            })) |\n-            Some(hir_map::NodeImplItem(&hir::ImplItem {\n-                node: hir::ImplItemKind::Const(_, body), ..\n-            })) => {\n-                Some((&tcx.hir.body(body).value,\n-                      tcx.item_tables(def_id)))\n+            Some(hir_map::NodeTraitItem(_)) => {\n+                // If we have a trait item and the substitutions for it,\n+                // `resolve_trait_associated_const` will select an impl\n+                // or the default.\n+                resolve_trait_associated_const(tcx, def_id, substs)\n             }\n-            Some(hir_map::NodeTraitItem(ti)) => match ti.node {\n-                hir::TraitItemKind::Const(_, default) => {\n-                    // If we have a trait item and the substitutions for it,\n-                    // `resolve_trait_associated_const` will select an impl\n-                    // or the default.\n-                    let trait_id = tcx.hir.get_parent(node_id);\n-                    let trait_id = tcx.hir.local_def_id(trait_id);\n-                    let default_value = default.map(|body| {\n-                        (&tcx.hir.body(body).value,\n-                            tcx.item_tables(def_id))\n-                    });\n-                    resolve_trait_associated_const(tcx, def_id, default_value, trait_id, substs)\n-                }\n-                _ => None\n-            },\n-            Some(_) => None\n+            _ => Some((def_id, substs))\n         }\n     } else {\n-        let expr_and_tables = tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n-            (&body.value, tcx.item_tables(def_id))\n-        });\n         match tcx.sess.cstore.describe_def(def_id) {\n             Some(Def::AssociatedConst(_)) => {\n-                let trait_id = tcx.sess.cstore.trait_of_item(def_id);\n                 // As mentioned in the comments above for in-crate\n                 // constants, we only try to find the expression for a\n                 // trait-associated const if the caller gives us the\n                 // substitutions for the reference to it.\n-                if let Some(trait_id) = trait_id {\n-                    resolve_trait_associated_const(tcx, def_id, expr_and_tables,\n-                                                   trait_id, substs)\n+                if tcx.sess.cstore.trait_of_item(def_id).is_some() {\n+                    resolve_trait_associated_const(tcx, def_id, substs)\n                 } else {\n-                    expr_and_tables\n+                    Some((def_id, substs))\n                 }\n-            },\n-            Some(Def::Const(..)) => expr_and_tables,\n-            _ => None\n-        }\n-    }\n-}\n-\n-fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                                   -> Option<(&'tcx hir::Body, &'a ty::TypeckTables<'tcx>)>\n-{\n-    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-        FnLikeNode::from_node(tcx.hir.get(node_id)).and_then(|fn_like| {\n-            if fn_like.constness() == hir::Constness::Const {\n-                Some((tcx.hir.body(fn_like.body()),\n-                      tcx.item_tables(def_id)))\n-            } else {\n-                None\n             }\n-        })\n-    } else {\n-        if tcx.sess.cstore.is_const_fn(def_id) {\n-            tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n-                (body, tcx.item_tables(def_id))\n-            })\n-        } else {\n-            None\n+            _ => Some((def_id, substs))\n         }\n     }\n }\n@@ -338,9 +267,22 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n         }\n       }\n       hir::ExprCast(ref base, _) => {\n-        match cast_const(tcx, cx.eval(base)?, ety) {\n-            Ok(val) => val,\n-            Err(kind) => return Err(ConstEvalErr { span: e.span, kind: kind }),\n+        let base_val = cx.eval(base)?;\n+        let base_ty = cx.tables.expr_ty(base);\n+\n+        // Avoid applying substitutions if they're empty, that'd ICE.\n+        let base_ty = if cx.substs.is_empty() {\n+            base_ty\n+        } else {\n+            base_ty.subst(tcx, cx.substs)\n+        };\n+        if ety == base_ty {\n+            base_val\n+        } else {\n+            match cast_const(tcx, base_val, ety) {\n+                Ok(val) => val,\n+                Err(kind) => signal!(e, kind),\n+            }\n         }\n       }\n       hir::ExprPath(ref qpath) => {\n@@ -357,42 +299,29 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           match cx.tables.qpath_def(qpath, e.id) {\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n-                  if let Some((expr, tables)) = lookup_const_by_id(tcx, def_id, substs) {\n-                      let cx = ConstContext::with_tables(tcx, tables);\n-                      match cx.eval(expr) {\n-                          Ok(val) => val,\n-                          Err(ConstEvalErr { kind: TypeckError, .. }) => {\n-                              signal!(e, TypeckError);\n-                          }\n-                          Err(err) => {\n-                              debug!(\"bad reference: {:?}, {:?}\", err.description(), err.span);\n-                              signal!(e, ErroneousReferencedConstant(box err))\n-                          },\n-                      }\n-                  } else {\n-                      signal!(e, TypeckError);\n-                  }\n+                    match ty::queries::const_eval::get(tcx, e.span, (def_id, substs)) {\n+                        Ok(val) => val,\n+                        Err(ConstEvalErr { kind: TypeckError, .. }) => {\n+                            signal!(e, TypeckError);\n+                        }\n+                        Err(err) => {\n+                            debug!(\"bad reference: {:?}, {:?}\", err.description(), err.span);\n+                            signal!(e, ErroneousReferencedConstant(box err))\n+                        },\n+                    }\n               },\n-              Def::VariantCtor(variant_def, ..) => {\n-                  if let Some((expr, tables)) = lookup_variant_by_id(tcx, variant_def) {\n-                      let cx = ConstContext::with_tables(tcx, tables);\n-                      match cx.eval(expr) {\n-                          Ok(val) => val,\n-                          Err(ConstEvalErr { kind: TypeckError, .. }) => {\n-                              signal!(e, TypeckError);\n-                          }\n-                          Err(err) => {\n-                              debug!(\"bad reference: {:?}, {:?}\", err.description(), err.span);\n-                              signal!(e, ErroneousReferencedConstant(box err))\n-                          },\n-                      }\n-                  } else {\n-                      signal!(e, UnimplementedConstVal(\"enum variants\"));\n-                  }\n+              Def::VariantCtor(variant_def, CtorKind::Const) => {\n+                Variant(variant_def)\n+              }\n+              Def::VariantCtor(_, CtorKind::Fn) => {\n+                  signal!(e, UnimplementedConstVal(\"enum variants\"));\n               }\n-              Def::StructCtor(..) => {\n+              Def::StructCtor(_, CtorKind::Const) => {\n                   ConstVal::Struct(Default::default())\n               }\n+              Def::StructCtor(_, CtorKind::Fn) => {\n+                  signal!(e, UnimplementedConstVal(\"tuple struct constructors\"))\n+              }\n               Def::Local(def_id) => {\n                   debug!(\"Def::Local({:?}): {:?}\", def_id, cx.fn_args);\n                   if let Some(val) = cx.fn_args.as_ref().and_then(|args| args.get(&def_id)) {\n@@ -407,14 +336,27 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           }\n       }\n       hir::ExprCall(ref callee, ref args) => {\n-          let (did, substs) = match cx.eval(callee)? {\n-              Function(did, substs) => (did, substs),\n-              Struct(_) => signal!(e, UnimplementedConstVal(\"tuple struct constructors\")),\n-              callee => signal!(e, CallOn(callee)),\n+          let (def_id, substs) = match cx.eval(callee)? {\n+              Function(def_id, substs) => (def_id, substs),\n+              _ => signal!(e, TypeckError),\n           };\n-          let (body, tables) = match lookup_const_fn_by_id(tcx, did) {\n-              Some(x) => x,\n-              None => signal!(e, NonConstPath),\n+\n+          let body = if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n+            if let Some(fn_like) = FnLikeNode::from_node(tcx.hir.get(node_id)) {\n+                if fn_like.constness() == hir::Constness::Const {\n+                    tcx.hir.body(fn_like.body())\n+                } else {\n+                    signal!(e, TypeckError)\n+                }\n+            } else {\n+                signal!(e, TypeckError)\n+            }\n+          } else {\n+            if tcx.sess.cstore.is_const_fn(def_id) {\n+                tcx.sess.cstore.item_body(tcx, def_id)\n+            } else {\n+                signal!(e, TypeckError)\n+            }\n           };\n \n           let arg_defs = body.arguments.iter().map(|arg| match arg.pat.node {\n@@ -434,7 +376,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           debug!(\"const call({:?})\", call_args);\n           let callee_cx = ConstContext {\n             tcx: tcx,\n-            tables: tables,\n+            tables: tcx.item_tables(def_id),\n             substs: substs,\n             fn_args: Some(call_args)\n           };\n@@ -532,19 +474,16 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n     Ok(result)\n }\n \n-fn resolve_trait_associated_const<'a, 'tcx: 'a>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    trait_item_id: DefId,\n-    default_value: Option<(&'tcx Expr, &'a ty::TypeckTables<'tcx>)>,\n-    trait_id: DefId,\n-    rcvr_substs: &'tcx Substs<'tcx>\n-) -> Option<(&'tcx Expr, &'a ty::TypeckTables<'tcx>)>\n-{\n-    let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, rcvr_substs));\n+fn resolve_trait_associated_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                            def_id: DefId,\n+                                            substs: &'tcx Substs<'tcx>)\n+                                            -> Option<(DefId, &'tcx Substs<'tcx>)> {\n+    let trait_item = tcx.associated_item(def_id);\n+    let trait_id = trait_item.container.id();\n+    let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, substs));\n     debug!(\"resolve_trait_associated_const: trait_ref={:?}\",\n            trait_ref);\n \n-    tcx.populate_implementations_for_trait_if_necessary(trait_id);\n     tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n         let mut selcx = traits::SelectionContext::new(&infcx);\n         let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n@@ -569,12 +508,20 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(\n         // when constructing the inference context above.\n         match selection {\n             traits::VtableImpl(ref impl_data) => {\n-                let name = tcx.associated_item(trait_item_id).name;\n+                let name = trait_item.name;\n                 let ac = tcx.associated_items(impl_data.impl_def_id)\n                     .find(|item| item.kind == ty::AssociatedKind::Const && item.name == name);\n                 match ac {\n-                    Some(ic) => lookup_const_by_id(tcx, ic.def_id, Substs::empty()),\n-                    None => default_value,\n+                    // FIXME(eddyb) Use proper Instance resolution to\n+                    // get the correct Substs returned from here.\n+                    Some(ic) => Some((ic.def_id, Substs::empty())),\n+                    None => {\n+                        if trait_item.defaultness.has_value() {\n+                            Some((def_id, substs))\n+                        } else {\n+                            None\n+                        }\n+                    }\n                 }\n             }\n             _ => {\n@@ -615,7 +562,7 @@ fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             U8(u) => Ok(Char(u as char)),\n             _ => bug!(),\n         },\n-        _ => bug!(),\n+        _ => Err(CannotCast),\n     }\n }\n \n@@ -659,6 +606,11 @@ fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         Bool(b) => cast_const_int(tcx, U8(b as u8), ty),\n         Float(f) => cast_const_float(tcx, f, ty),\n         Char(c) => cast_const_int(tcx, U32(c as u32), ty),\n+        Variant(v) => {\n+            let adt = tcx.lookup_adt_def(tcx.parent_def_id(v).unwrap());\n+            let idx = adt.variant_index_with_id(v);\n+            cast_const_int(tcx, adt.discriminant_for_variant(tcx, idx), ty)\n+        }\n         Function(..) => Err(UnimplementedConstVal(\"casting fn pointers\")),\n         ByteStr(b) => match ty.sty {\n             ty::TyRawPtr(_) => {\n@@ -796,21 +748,35 @@ impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n-        monomorphic_const_eval,\n+        const_eval,\n         ..*providers\n     };\n }\n \n-fn monomorphic_const_eval<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    def_id: DefId)\n-                                    -> EvalResult<'tcx> {\n-    let cx = ConstContext::with_tables(tcx, tcx.item_tables(def_id));\n+fn const_eval<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        (def_id, substs): (DefId, &'tcx Substs<'tcx>))\n+                        -> EvalResult<'tcx> {\n+    let (def_id, substs) = if let Some(resolved) = lookup_const_by_id(tcx, def_id, substs) {\n+        resolved\n+    } else {\n+        return Err(ConstEvalErr {\n+            span: tcx.def_span(def_id),\n+            kind: TypeckError\n+        });\n+    };\n+\n+    let cx = ConstContext {\n+        tcx,\n+        tables: tcx.item_tables(def_id),\n+        substs: substs,\n+        fn_args: None\n+    };\n \n     let body = if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n         ty::queries::mir_const_qualif::get(tcx, DUMMY_SP, def_id);\n         tcx.hir.body(tcx.hir.body_owned_by(id))\n     } else {\n-        tcx.sess.cstore.maybe_get_item_body(tcx, def_id).unwrap()\n+        tcx.sess.cstore.item_body(tcx, def_id)\n     };\n     cx.eval(&body.value)\n }"}, {"sha": "0dfafeb6fb8362b95c7f8af1fc0953307e12e18e", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -116,6 +116,7 @@ fn print_const_val(value: &ConstVal, f: &mut fmt::Formatter) -> fmt::Result {\n         ConstVal::ByteStr(ref b) => write!(f, \"{:?}\", &b[..]),\n         ConstVal::Bool(b) => write!(f, \"{:?}\", b),\n         ConstVal::Char(c) => write!(f, \"{:?}\", c),\n+        ConstVal::Variant(_) |\n         ConstVal::Struct(_) |\n         ConstVal::Tuple(_) |\n         ConstVal::Function(..) |\n@@ -587,11 +588,16 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 let substs = self.tables.node_id_item_substs(id)\n                     .unwrap_or_else(|| tcx.intern_substs(&[]));\n                 match eval::lookup_const_by_id(tcx, def_id, substs) {\n-                    Some((const_expr, const_tables)) => {\n+                    Some((def_id, _substs)) => {\n                         // Enter the inlined constant's tables temporarily.\n                         let old_tables = self.tables;\n-                        self.tables = const_tables;\n-                        let pat = self.lower_const_expr(const_expr, pat_id, span);\n+                        self.tables = tcx.item_tables(def_id);\n+                        let body = if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n+                            tcx.hir.body(tcx.hir.body_owned_by(id))\n+                        } else {\n+                            tcx.sess.cstore.item_body(tcx, def_id)\n+                        };\n+                        let pat = self.lower_const_expr(&body.value, pat_id, span);\n                         self.tables = old_tables;\n                         return pat;\n                     }\n@@ -615,7 +621,12 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n         let const_cx = eval::ConstContext::with_tables(self.tcx.global_tcx(), self.tables);\n         match const_cx.eval(expr) {\n             Ok(value) => {\n-                PatternKind::Constant { value: value }\n+                if let ConstVal::Variant(def_id) = value {\n+                    let ty = self.tables.expr_ty(expr);\n+                    self.lower_variant_or_leaf(Def::Variant(def_id), ty, vec![])\n+                } else {\n+                    PatternKind::Constant { value: value }\n+                }\n             }\n             Err(e) => {\n                 self.errors.push(PatternError::ConstEval(e));"}, {"sha": "438f482fa55c7bfbd90be456920f77f3edfbbbfd", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -225,6 +225,8 @@ pub fn compile_input(sess: &Session,\n         sess.code_stats.borrow().print_type_sizes();\n     }\n \n+    if ::std::env::var(\"SKIP_LLVM\").is_ok() { ::std::process::exit(0); }\n+\n     let phase5_result = phase_5_run_llvm_passes(sess, &trans, &outputs);\n \n     controller_entry_point!(after_llvm,\n@@ -810,7 +812,7 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         defs: resolver.definitions,\n         analysis: ty::CrateAnalysis {\n             access_levels: Rc::new(AccessLevels::default()),\n-            reachable: NodeSet(),\n+            reachable: Rc::new(NodeSet()),\n             name: crate_name.to_string(),\n             glob_map: if resolver.make_glob_map { Some(resolver.glob_map) } else { None },\n         },\n@@ -889,9 +891,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     let index = stability::Index::new(&hir_map);\n \n     let mut local_providers = ty::maps::Providers::default();\n+    borrowck::provide(&mut local_providers);\n     mir::provide(&mut local_providers);\n+    reachable::provide(&mut local_providers);\n     rustc_privacy::provide(&mut local_providers);\n-    borrowck::provide(&mut local_providers);\n     typeck::provide(&mut local_providers);\n     ty::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);"}, {"sha": "147d6558e19cc31a12842f4af039d9d046e77c81", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -343,12 +343,12 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn t_rptr_static(&self) -> Ty<'tcx> {\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(ty::ReStatic),\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.types.re_static,\n                                   self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_empty(&self) -> Ty<'tcx> {\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(ty::ReEmpty),\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.types.re_empty,\n                                   self.tcx().types.isize)\n     }\n "}, {"sha": "7bc0e8a512be02eb589a1d3036c494dd72b31e3a", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -326,6 +326,7 @@ impl<'a> CrateLoader<'a> {\n             cnum_map: RefCell::new(cnum_map),\n             cnum: cnum,\n             codemap_import_info: RefCell::new(vec![]),\n+            attribute_cache: RefCell::new([Vec::new(), Vec::new()]),\n             dep_kind: Cell::new(dep_kind),\n             source: cstore::CrateSource {\n                 dylib: dylib,"}, {"sha": "72ad1d75a5615761543ffdd61fd26b35a4fd2d38", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -72,6 +72,7 @@ pub struct CrateMetadata {\n     pub cnum_map: RefCell<CrateNumMap>,\n     pub cnum: CrateNum,\n     pub codemap_import_info: RefCell<Vec<ImportedFileMap>>,\n+    pub attribute_cache: RefCell<[Vec<Option<Rc<[ast::Attribute]>>>; 2]>,\n \n     pub root: schema::CrateRoot,\n \n@@ -269,7 +270,7 @@ impl CrateMetadata {\n     }\n \n     pub fn is_staged_api(&self) -> bool {\n-        for attr in self.get_item_attrs(CRATE_DEF_INDEX) {\n+        for attr in self.get_item_attrs(CRATE_DEF_INDEX).iter() {\n             if attr.path == \"stable\" || attr.path == \"unstable\" {\n                 return true;\n             }"}, {"sha": "9e6a45e7f8b7c68ddfed3850f607392154f616e4", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -89,6 +89,7 @@ provide! { <'tcx> tcx, def_id, cdata\n     }\n     associated_item => { cdata.get_associated_item(def_id.index) }\n     impl_trait_ref => { cdata.get_impl_trait(def_id.index, tcx) }\n+    impl_polarity => { cdata.get_impl_polarity(def_id.index) }\n     coerce_unsized_info => {\n         cdata.get_coerce_unsized_info(def_id.index).unwrap_or_else(|| {\n             bug!(\"coerce_unsized_info: `{:?}` is missing its info\", def_id);\n@@ -111,6 +112,7 @@ provide! { <'tcx> tcx, def_id, cdata\n     closure_kind => { cdata.closure_kind(def_id.index) }\n     closure_type => { cdata.closure_ty(def_id.index, tcx) }\n     inherent_impls => { Rc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }\n+    is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n }\n \n impl CrateStore for cstore::CStore {\n@@ -148,7 +150,7 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(def.krate).get_generics(def.index)\n     }\n \n-    fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>\n+    fn item_attrs(&self, def_id: DefId) -> Rc<[ast::Attribute]>\n     {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n         self.get_crate_data(def_id.krate).get_item_attrs(def_id.index)\n@@ -176,12 +178,6 @@ impl CrateStore for cstore::CStore {\n         result\n     }\n \n-    fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_impl_polarity(def.index)\n-    }\n-\n     fn impl_parent(&self, impl_def: DefId) -> Option<DefId> {\n         self.dep_graph.read(DepNode::MetaData(impl_def));\n         self.get_crate_data(impl_def.krate).get_parent_impl(impl_def.index)\n@@ -405,7 +401,7 @@ impl CrateStore for cstore::CStore {\n \n         // Mark the attrs as used\n         let attrs = data.get_item_attrs(id.index);\n-        for attr in &attrs {\n+        for attr in attrs.iter() {\n             attr::mark_used(attr);\n         }\n \n@@ -418,25 +414,24 @@ impl CrateStore for cstore::CStore {\n             ident: ast::Ident::with_empty_ctxt(name),\n             id: ast::DUMMY_NODE_ID,\n             span: local_span,\n-            attrs: attrs,\n+            attrs: attrs.iter().cloned().collect(),\n             node: ast::ItemKind::MacroDef(body.into()),\n             vis: ast::Visibility::Inherited,\n         })\n     }\n \n-    fn maybe_get_item_body<'a, 'tcx>(&self,\n-                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     def_id: DefId)\n-                                     -> Option<&'tcx hir::Body>\n-    {\n+    fn item_body<'a, 'tcx>(&self,\n+                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           def_id: DefId)\n+                           -> &'tcx hir::Body {\n         if let Some(cached) = tcx.hir.get_inlined_body(def_id) {\n-            return Some(cached);\n+            return cached;\n         }\n \n         self.dep_graph.read(DepNode::MetaData(def_id));\n-        debug!(\"maybe_get_item_body({}): inlining item\", tcx.item_path_str(def_id));\n+        debug!(\"item_body({}): inlining item\", tcx.item_path_str(def_id));\n \n-        self.get_crate_data(def_id.krate).maybe_get_item_body(tcx, def_id.index)\n+        self.get_crate_data(def_id.krate).item_body(tcx, def_id.index)\n     }\n \n     fn item_body_nested_bodies(&self, def: DefId) -> BTreeMap<hir::BodyId, hir::Body> {"}, {"sha": "a9eae5281b241fa3ede78cdb699560f798ae501a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -31,6 +31,7 @@ use std::cell::Ref;\n use std::collections::BTreeMap;\n use std::io;\n use std::mem;\n+use std::rc::Rc;\n use std::str;\n use std::u32;\n \n@@ -749,16 +750,15 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn maybe_get_item_body(&self,\n-                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               id: DefIndex)\n-                               -> Option<&'tcx hir::Body> {\n-        if self.is_proc_macro(id) { return None; }\n-        self.entry(id).ast.map(|ast| {\n-            let def_id = self.local_def_id(id);\n-            let body = ast.decode(self).body.decode(self);\n-            tcx.hir.intern_inlined_body(def_id, body)\n-        })\n+    pub fn item_body(&self,\n+                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                     id: DefIndex)\n+                     -> &'tcx hir::Body {\n+        assert!(!self.is_proc_macro(id));\n+        let ast = self.entry(id).ast.unwrap();\n+        let def_id = self.local_def_id(id);\n+        let body = ast.decode(self).body.decode(self);\n+        tcx.hir.intern_inlined_body(def_id, body)\n     }\n \n     pub fn item_body_tables(&self,\n@@ -859,10 +859,18 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_item_attrs(&self, node_id: DefIndex) -> Vec<ast::Attribute> {\n+    pub fn get_item_attrs(&self, node_id: DefIndex) -> Rc<[ast::Attribute]> {\n+        let (node_as, node_index) =\n+            (node_id.address_space().index(), node_id.as_array_index());\n         if self.is_proc_macro(node_id) {\n-            return Vec::new();\n+            return Rc::new([]);\n+        }\n+\n+        if let Some(&Some(ref val)) =\n+            self.attribute_cache.borrow()[node_as].get(node_index) {\n+            return val.clone();\n         }\n+\n         // The attributes for a tuple struct are attached to the definition, not the ctor;\n         // we assume that someone passing in a tuple struct ctor is actually wanting to\n         // look at the definition\n@@ -871,7 +879,13 @@ impl<'a, 'tcx> CrateMetadata {\n         if def_key.disambiguated_data.data == DefPathData::StructCtor {\n             item = self.entry(def_key.parent.unwrap());\n         }\n-        self.get_attributes(&item)\n+        let result = Rc::__from_array(self.get_attributes(&item).into_boxed_slice());\n+        let vec_ = &mut self.attribute_cache.borrow_mut()[node_as];\n+        if vec_.len() < node_index + 1 {\n+            vec_.resize(node_index + 1, None);\n+        }\n+        vec_[node_index] = Some(result.clone());\n+        result\n     }\n \n     pub fn get_struct_field_names(&self, id: DefIndex) -> Vec<ast::Name> {"}, {"sha": "0833342927fec9dbbb31bab1164aa70a44080b58", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -280,7 +280,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     assert!(ty.is_slice());\n \n                     let array_ty = tcx.mk_array(tcx.types.u8, bytes.len());\n-                    let array_ref = tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic), array_ty);\n+                    let array_ref = tcx.mk_imm_ref(tcx.types.re_static, array_ty);\n                     let array = self.literal_operand(test.span, array_ref, Literal::Value {\n                         value: value.clone()\n                     });"}, {"sha": "736c076ea15446cb4b510cafb72e434290df6fef", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -593,7 +593,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprRepeat(ref v, count) => {\n             let c = &cx.tcx.hir.body(count).value;\n             let def_id = cx.tcx.hir.body_owner_def_id(count);\n-            let count = match ty::queries::monomorphic_const_eval::get(cx.tcx, c.span, def_id) {\n+            let substs = Substs::empty();\n+            let count = match ty::queries::const_eval::get(cx.tcx, c.span, (def_id, substs)) {\n                 Ok(ConstVal::Integral(ConstInt::Usize(u))) => u,\n                 Ok(other) => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n                 Err(s) => cx.fatal_const_eval_err(&s, c.span, \"expression\")"}, {"sha": "7f7377e5ffe3f78a2d9c4cf7f7f161dcef2bb6b8", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -308,10 +308,9 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n         Adjustment::Deref => Operand::Consume(rcvr_l.deref()),\n         Adjustment::RefMut => {\n             // let rcvr = &mut rcvr;\n-            let re_erased = tcx.mk_region(ty::ReErased);\n             let ref_rcvr = local_decls.push(temp_decl(\n                 Mutability::Not,\n-                tcx.mk_ref(re_erased, ty::TypeAndMut {\n+                tcx.mk_ref(tcx.types.re_erased, ty::TypeAndMut {\n                     ty: sig.inputs()[0],\n                     mutbl: hir::Mutability::MutMutable\n                 }),\n@@ -321,7 +320,7 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n                 source_info: source_info,\n                 kind: StatementKind::Assign(\n                     Lvalue::Local(ref_rcvr),\n-                    Rvalue::Ref(re_erased, BorrowKind::Mut, rcvr_l)\n+                    Rvalue::Ref(tcx.types.re_erased, BorrowKind::Mut, rcvr_l)\n                 )\n             });\n             Operand::Consume(Lvalue::Local(ref_rcvr))"}, {"sha": "5cc5cf297936d3606a90a5f62bd4e7155608c860", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -13,7 +13,7 @@\n //! care erasing regions all over the place.\n \n use rustc::ty::subst::Substs;\n-use rustc::ty::{Ty, TyCtxt, ReErased, ClosureSubsts};\n+use rustc::ty::{Ty, TyCtxt, ClosureSubsts};\n use rustc::mir::*;\n use rustc::mir::visit::MutVisitor;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n@@ -43,7 +43,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n         match *rvalue {\n             Rvalue::Ref(ref mut r, _, _) => {\n-                *r = self.tcx.mk_region(ReErased);\n+                *r = self.tcx.types.re_erased;\n             }\n             Rvalue::Use(..) |\n             Rvalue::Repeat(..) |"}, {"sha": "45bdff9195c4f10924987830f7f12e6810f778f6", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -497,7 +497,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 let dest = if dest_needs_borrow(&destination.0) {\n                     debug!(\"Creating temp for return destination\");\n                     let dest = Rvalue::Ref(\n-                        self.tcx.mk_region(ty::ReErased),\n+                        self.tcx.types.re_erased,\n                         BorrowKind::Mut,\n                         destination.0);\n \n@@ -582,7 +582,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n     fn cast_box_free_arg(&self, arg: Lvalue<'tcx>, ptr_ty: Ty<'tcx>,\n                          callsite: &CallSite<'tcx>, caller_mir: &mut Mir<'tcx>) -> Operand<'tcx> {\n         let arg = Rvalue::Ref(\n-            self.tcx.mk_region(ty::ReErased),\n+            self.tcx.types.re_erased,\n             BorrowKind::Mut,\n             arg.deref());\n "}, {"sha": "ef7990653ba982cc8de8319fad9e9401d1729535", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -124,6 +124,8 @@ impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n                     self.collapse_goto_chain(successor, &mut changed);\n                 }\n \n+                changed |= self.simplify_unwind(&mut terminator);\n+\n                 let mut new_stmts = vec![];\n                 let mut inner_changed = true;\n                 while inner_changed {\n@@ -238,6 +240,38 @@ impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n         true\n     }\n \n+    // turn an unwind branch to a resume block into a None\n+    fn simplify_unwind(&mut self, terminator: &mut Terminator<'tcx>) -> bool {\n+        let unwind = match terminator.kind {\n+            TerminatorKind::Drop { ref mut unwind, .. } |\n+            TerminatorKind::DropAndReplace { ref mut unwind, .. } |\n+            TerminatorKind::Call { cleanup: ref mut unwind, .. } |\n+            TerminatorKind::Assert { cleanup: ref mut unwind, .. } =>\n+                unwind,\n+            _ => return false\n+        };\n+\n+        if let &mut Some(unwind_block) = unwind {\n+            let is_resume_block = match self.basic_blocks[unwind_block] {\n+                BasicBlockData {\n+                    ref statements,\n+                    terminator: Some(Terminator {\n+                        kind: TerminatorKind::Resume, ..\n+                    }), ..\n+                } if statements.is_empty() => true,\n+                _ => false\n+            };\n+            if is_resume_block {\n+                debug!(\"simplifying unwind to {:?} from {:?}\",\n+                       unwind_block, terminator.source_info);\n+                *unwind = None;\n+            }\n+            return is_resume_block;\n+        }\n+\n+        false\n+    }\n+\n     fn strip_nops(&mut self) {\n         for blk in self.basic_blocks.iter_mut() {\n             blk.statements.retain(|stmt| if let StatementKind::Nop = stmt.kind {"}, {"sha": "9d7c7ec63cfc57afbc32eccfa5dfb5cee46185c2", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -506,8 +506,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let ty = self.lvalue_ty(self.lvalue);\n         let substs = tcx.mk_substs(iter::once(Kind::from(ty)));\n \n-        let re_erased = tcx.mk_region(ty::ReErased);\n-        let ref_ty = tcx.mk_ref(re_erased, ty::TypeAndMut {\n+        let ref_ty = tcx.mk_ref(tcx.types.re_erased, ty::TypeAndMut {\n             ty: ty,\n             mutbl: hir::Mutability::MutMutable\n         });\n@@ -519,7 +518,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 source_info: self.source_info,\n                 kind: StatementKind::Assign(\n                     Lvalue::Local(ref_lvalue),\n-                    Rvalue::Ref(re_erased, BorrowKind::Mut, self.lvalue.clone())\n+                    Rvalue::Ref(tcx.types.re_erased, BorrowKind::Mut, self.lvalue.clone())\n                 )\n             }],\n             terminator: Some(Terminator {"}, {"sha": "221c52141a8323de0193f3d2a926599df704a5b9", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -53,7 +53,7 @@ impl ExportedSymbols {\n                 scx.tcx().hir.local_def_id(node_id)\n             })\n             .map(|def_id| {\n-                let name = symbol_for_def_id(scx, def_id, symbol_map);\n+                let name = symbol_for_def_id(scx.tcx(), def_id, symbol_map);\n                 let export_level = export_level(scx, def_id);\n                 debug!(\"EXPORTED SYMBOL (local): {} ({:?})\", name, export_level);\n                 (name, export_level)\n@@ -108,7 +108,7 @@ impl ExportedSymbols {\n                 .exported_symbols(cnum)\n                 .iter()\n                 .map(|&def_id| {\n-                    let name = symbol_name(Instance::mono(scx.tcx(), def_id), scx);\n+                    let name = symbol_name(Instance::mono(scx.tcx(), def_id), scx.tcx());\n                     let export_level = if special_runtime_crate {\n                         // We can probably do better here by just ensuring that\n                         // it has hidden visibility rather than public\n@@ -214,21 +214,21 @@ pub fn is_below_threshold(level: SymbolExportLevel,\n     }\n }\n \n-fn symbol_for_def_id<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn symbol_for_def_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                def_id: DefId,\n                                symbol_map: &SymbolMap<'tcx>)\n                                -> String {\n     // Just try to look things up in the symbol map. If nothing's there, we\n     // recompute.\n-    if let Some(node_id) = scx.tcx().hir.as_local_node_id(def_id) {\n+    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n         if let Some(sym) = symbol_map.get(TransItem::Static(node_id)) {\n             return sym.to_owned();\n         }\n     }\n \n-    let instance = Instance::mono(scx.tcx(), def_id);\n+    let instance = Instance::mono(tcx, def_id);\n \n     symbol_map.get(TransItem::Fn(instance))\n               .map(str::to_owned)\n-              .unwrap_or_else(|| symbol_name(instance, scx))\n+              .unwrap_or_else(|| symbol_name(instance, tcx))\n }"}, {"sha": "f21864764ddf1f828b428414ab2449d0e028e7c3", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 77, "deletions": 80, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -97,23 +97,23 @@\n //! virtually impossible. Thus, symbol hash generation exclusively relies on\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n-use common::SharedCrateContext;\n use monomorphize::Instance;\n \n use rustc::middle::weak_lang_items;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n-use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::fold::TypeVisitor;\n use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n use rustc::ty::subst::Substs;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::util::common::record_time;\n \n use syntax::attr;\n-use syntax::symbol::{Symbol, InternedString};\n \n-fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+use std::fmt::Write;\n+\n+fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                              // the DefId of the item this name is for\n                              def_id: Option<DefId>,\n@@ -130,8 +130,6 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                              -> String {\n     debug!(\"get_symbol_hash(def_id={:?}, parameters={:?})\", def_id, substs);\n \n-    let tcx = scx.tcx();\n-\n     let mut hasher = ty::util::TypeIdHasher::<u64>::new(tcx);\n \n     record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n@@ -157,8 +155,8 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             // in case the same instances is emitted in two crates of the same\n             // project.\n             if substs.types().next().is_some() {\n-                hasher.hash(scx.tcx().crate_name.as_str());\n-                hasher.hash(scx.sess().local_crate_disambiguator().as_str());\n+                hasher.hash(tcx.crate_name.as_str());\n+                hasher.hash(tcx.sess.local_crate_disambiguator().as_str());\n             }\n         }\n     });\n@@ -168,37 +166,37 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n }\n \n pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n-                             scx: &SharedCrateContext<'a, 'tcx>) -> String {\n+                             tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n     debug!(\"symbol_name(def_id={:?}, substs={:?})\",\n            def_id, substs);\n \n-    let node_id = scx.tcx().hir.as_local_node_id(def_id);\n+    let node_id = tcx.hir.as_local_node_id(def_id);\n \n     if let Some(id) = node_id {\n-        if scx.sess().plugin_registrar_fn.get() == Some(id) {\n+        if tcx.sess.plugin_registrar_fn.get() == Some(id) {\n             let idx = def_id.index;\n-            let disambiguator = scx.sess().local_crate_disambiguator();\n-            return scx.sess().generate_plugin_registrar_symbol(disambiguator, idx);\n+            let disambiguator = tcx.sess.local_crate_disambiguator();\n+            return tcx.sess.generate_plugin_registrar_symbol(disambiguator, idx);\n         }\n-        if scx.sess().derive_registrar_fn.get() == Some(id) {\n+        if tcx.sess.derive_registrar_fn.get() == Some(id) {\n             let idx = def_id.index;\n-            let disambiguator = scx.sess().local_crate_disambiguator();\n-            return scx.sess().generate_derive_registrar_symbol(disambiguator, idx);\n+            let disambiguator = tcx.sess.local_crate_disambiguator();\n+            return tcx.sess.generate_derive_registrar_symbol(disambiguator, idx);\n         }\n     }\n \n     // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n-    let attrs = scx.tcx().get_attrs(def_id);\n+    let attrs = tcx.get_attrs(def_id);\n     let is_foreign = if let Some(id) = node_id {\n-        match scx.tcx().hir.get(id) {\n+        match tcx.hir.get(id) {\n             hir_map::NodeForeignItem(_) => true,\n             _ => false\n         }\n     } else {\n-        scx.sess().cstore.is_foreign_item(def_id)\n+        tcx.sess.cstore.is_foreign_item(def_id)\n     };\n \n     if let Some(name) = weak_lang_items::link_name(&attrs) {\n@@ -210,17 +208,17 @@ pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n             return name.to_string();\n         }\n         // Don't mangle foreign items.\n-        return scx.tcx().item_name(def_id).as_str().to_string();\n+        return tcx.item_name(def_id).as_str().to_string();\n     }\n \n-    if let Some(name) = attr::find_export_name_attr(scx.sess().diagnostic(), &attrs) {\n+    if let Some(name) = attr::find_export_name_attr(tcx.sess.diagnostic(), &attrs) {\n         // Use provided name\n         return name.to_string();\n     }\n \n     if attr::contains_name(&attrs, \"no_mangle\") {\n         // Don't mangle\n-        return scx.tcx().item_name(def_id).as_str().to_string();\n+        return tcx.item_name(def_id).as_str().to_string();\n     }\n \n     // We want to compute the \"type\" of this item. Unfortunately, some\n@@ -230,11 +228,11 @@ pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n     let mut ty_def_id = def_id;\n     let instance_ty;\n     loop {\n-        let key = scx.tcx().def_key(ty_def_id);\n+        let key = tcx.def_key(ty_def_id);\n         match key.disambiguated_data.data {\n             DefPathData::TypeNs(_) |\n             DefPathData::ValueNs(_) => {\n-                instance_ty = scx.tcx().item_type(ty_def_id);\n+                instance_ty = tcx.item_type(ty_def_id);\n                 break;\n             }\n             _ => {\n@@ -251,23 +249,51 @@ pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n \n     // Erase regions because they may not be deterministic when hashed\n     // and should not matter anyhow.\n-    let instance_ty = scx.tcx().erase_regions(&instance_ty);\n-\n-    let hash = get_symbol_hash(scx, Some(def_id), instance_ty, Some(substs));\n+    let instance_ty = tcx.erase_regions(&instance_ty);\n \n-    let mut buffer = SymbolPathBuffer {\n-        names: Vec::new()\n-    };\n+    let hash = get_symbol_hash(tcx, Some(def_id), instance_ty, Some(substs));\n \n+    let mut buffer = SymbolPathBuffer::new();\n     item_path::with_forced_absolute_paths(|| {\n-        scx.tcx().push_item_path(&mut buffer, def_id);\n+        tcx.push_item_path(&mut buffer, def_id);\n     });\n-\n-    mangle(buffer.names.into_iter(), &hash)\n+    buffer.finish(&hash)\n }\n \n+// Follow C++ namespace-mangling style, see\n+// http://en.wikipedia.org/wiki/Name_mangling for more info.\n+//\n+// It turns out that on macOS you can actually have arbitrary symbols in\n+// function names (at least when given to LLVM), but this is not possible\n+// when using unix's linker. Perhaps one day when we just use a linker from LLVM\n+// we won't need to do this name mangling. The problem with name mangling is\n+// that it seriously limits the available characters. For example we can't\n+// have things like &T in symbol names when one would theoretically\n+// want them for things like impls of traits on that type.\n+//\n+// To be able to work on all platforms and get *some* reasonable output, we\n+// use C++ name-mangling.\n struct SymbolPathBuffer {\n-    names: Vec<InternedString>,\n+    result: String,\n+    temp_buf: String\n+}\n+\n+impl SymbolPathBuffer {\n+    fn new() -> Self {\n+        let mut result = SymbolPathBuffer {\n+            result: String::with_capacity(64),\n+            temp_buf: String::with_capacity(16)\n+        };\n+        result.result.push_str(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n+        result\n+    }\n+\n+    fn finish(mut self, hash: &str) -> String {\n+        // end name-sequence\n+        self.push(hash);\n+        self.result.push('E');\n+        self.result\n+    }\n }\n \n impl ItemPathBuffer for SymbolPathBuffer {\n@@ -277,24 +303,32 @@ impl ItemPathBuffer for SymbolPathBuffer {\n     }\n \n     fn push(&mut self, text: &str) {\n-        self.names.push(Symbol::intern(text).as_str());\n+        self.temp_buf.clear();\n+        let need_underscore = sanitize(&mut self.temp_buf, text);\n+        let _ = write!(self.result, \"{}\", self.temp_buf.len() + (need_underscore as usize));\n+        if need_underscore {\n+            self.result.push('_');\n+        }\n+        self.result.push_str(&self.temp_buf);\n     }\n }\n \n-pub fn exported_name_from_type_and_prefix<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+pub fn exported_name_from_type_and_prefix<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                     t: Ty<'tcx>,\n                                                     prefix: &str)\n                                                     -> String {\n-    let hash = get_symbol_hash(scx, None, t, None);\n-    let path = [Symbol::intern(prefix).as_str()];\n-    mangle(path.iter().cloned(), &hash)\n+    let hash = get_symbol_hash(tcx, None, t, None);\n+    let mut buffer = SymbolPathBuffer::new();\n+    buffer.push(prefix);\n+    buffer.finish(&hash)\n }\n \n // Name sanitation. LLVM will happily accept identifiers with weird names, but\n // gas doesn't!\n // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n-pub fn sanitize(s: &str) -> String {\n-    let mut result = String::new();\n+//\n+// returns true if an underscore must be added at the start\n+pub fn sanitize(result: &mut String, s: &str) -> bool {\n     for c in s.chars() {\n         match c {\n             // Escape these with $ sequences\n@@ -331,44 +365,7 @@ pub fn sanitize(s: &str) -> String {\n     }\n \n     // Underscore-qualify anything that didn't start as an ident.\n-    if !result.is_empty() &&\n+    !result.is_empty() &&\n         result.as_bytes()[0] != '_' as u8 &&\n-        ! (result.as_bytes()[0] as char).is_xid_start() {\n-        return format!(\"_{}\", result);\n-    }\n-\n-    return result;\n-}\n-\n-fn mangle<PI: Iterator<Item=InternedString>>(path: PI, hash: &str) -> String {\n-    // Follow C++ namespace-mangling style, see\n-    // http://en.wikipedia.org/wiki/Name_mangling for more info.\n-    //\n-    // It turns out that on macOS you can actually have arbitrary symbols in\n-    // function names (at least when given to LLVM), but this is not possible\n-    // when using unix's linker. Perhaps one day when we just use a linker from LLVM\n-    // we won't need to do this name mangling. The problem with name mangling is\n-    // that it seriously limits the available characters. For example we can't\n-    // have things like &T in symbol names when one would theoretically\n-    // want them for things like impls of traits on that type.\n-    //\n-    // To be able to work on all platforms and get *some* reasonable output, we\n-    // use C++ name-mangling.\n-\n-    let mut n = String::from(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n-\n-    fn push(n: &mut String, s: &str) {\n-        let sani = sanitize(s);\n-        n.push_str(&format!(\"{}{}\", sani.len(), sani));\n-    }\n-\n-    // First, connect each component with <len, name> pairs.\n-    for data in path {\n-        push(&mut n, &data);\n-    }\n-\n-    push(&mut n, hash);\n-\n-    n.push('E'); // End name-sequence.\n-    n\n+        ! (result.as_bytes()[0] as char).is_xid_start()\n }"}, {"sha": "ba119bd9ef069b01be558592183d795bacca7e73", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -65,6 +65,7 @@ use meth;\n use mir;\n use monomorphize::{self, Instance};\n use partitioning::{self, PartitioningStrategy, CodegenUnit};\n+use symbol_cache::SymbolCache;\n use symbol_map::SymbolMap;\n use symbol_names_test;\n use trans_item::{TransItem, DefPathBasedNames};\n@@ -75,7 +76,6 @@ use util::nodemap::{NodeSet, FxHashMap, FxHashSet};\n \n use libc::c_uint;\n use std::ffi::{CStr, CString};\n-use std::rc::Rc;\n use std::str;\n use std::i32;\n use syntax_pos::Span;\n@@ -802,6 +802,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n /// in any other compilation unit.  Give these symbols internal linkage.\n fn internalize_symbols<'a, 'tcx>(sess: &Session,\n                                  scx: &SharedCrateContext<'a, 'tcx>,\n+                                 translation_items: &FxHashSet<TransItem<'tcx>>,\n                                  llvm_modules: &[ModuleLlvm],\n                                  symbol_map: &SymbolMap<'tcx>,\n                                  exported_symbols: &ExportedSymbols) {\n@@ -854,7 +855,7 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n             let mut locally_defined_symbols = FxHashSet();\n             let mut linkage_fixed_explicitly = FxHashSet();\n \n-            for trans_item in scx.translation_items().borrow().iter() {\n+            for trans_item in translation_items {\n                 let symbol_name = symbol_map.get_or_compute(scx, *trans_item);\n                 if trans_item.explicit_linkage(tcx).is_some() {\n                     linkage_fixed_explicitly.insert(symbol_name.clone());\n@@ -1011,8 +1012,8 @@ fn iter_functions(llmod: llvm::ModuleRef) -> ValueIter {\n ///\n /// This list is later used by linkers to determine the set of symbols needed to\n /// be exposed from a dynamic library and it's also encoded into the metadata.\n-pub fn find_exported_symbols(tcx: TyCtxt, reachable: NodeSet) -> NodeSet {\n-    reachable.into_iter().filter(|&id| {\n+pub fn find_exported_symbols(tcx: TyCtxt, reachable: &NodeSet) -> NodeSet {\n+    reachable.iter().cloned().filter(|&id| {\n         // Next, we want to ignore some FFI functions that are not exposed from\n         // this crate. Reachable FFI functions can be lumped into two\n         // categories:\n@@ -1064,7 +1065,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let krate = tcx.hir.krate();\n \n     let ty::CrateAnalysis { reachable, .. } = analysis;\n-    let exported_symbols = find_exported_symbols(tcx, reachable);\n+    let exported_symbols = find_exported_symbols(tcx, &reachable);\n \n     let check_overflow = tcx.sess.overflow_checks();\n \n@@ -1109,9 +1110,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Run the translation item collector and partition the collected items into\n     // codegen units.\n-    let (codegen_units, symbol_map) = collect_and_partition_translation_items(&shared_ccx);\n-\n-    let symbol_map = Rc::new(symbol_map);\n+    let (translation_items, codegen_units, symbol_map) =\n+        collect_and_partition_translation_items(&shared_ccx);\n \n     let mut all_stats = Stats::default();\n     let modules: Vec<ModuleTranslation> = codegen_units\n@@ -1121,7 +1121,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let (stats, module) =\n                 tcx.dep_graph.with_task(dep_node,\n                                         AssertDepGraphSafe(&shared_ccx),\n-                                        AssertDepGraphSafe((cgu, symbol_map.clone())),\n+                                        AssertDepGraphSafe(cgu),\n                                         module_translation);\n             all_stats.extend(stats);\n             module\n@@ -1130,16 +1130,17 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     fn module_translation<'a, 'tcx>(\n         scx: AssertDepGraphSafe<&SharedCrateContext<'a, 'tcx>>,\n-        args: AssertDepGraphSafe<(CodegenUnit<'tcx>, Rc<SymbolMap<'tcx>>)>)\n+        args: AssertDepGraphSafe<CodegenUnit<'tcx>>)\n         -> (Stats, ModuleTranslation)\n     {\n         // FIXME(#40304): We ought to be using the id as a key and some queries, I think.\n         let AssertDepGraphSafe(scx) = scx;\n-        let AssertDepGraphSafe((cgu, symbol_map)) = args;\n+        let AssertDepGraphSafe(cgu) = args;\n \n         let cgu_name = String::from(cgu.name());\n         let cgu_id = cgu.work_product_id();\n-        let symbol_name_hash = cgu.compute_symbol_name_hash(scx, &symbol_map);\n+        let symbol_cache = SymbolCache::new(scx.tcx());\n+        let symbol_name_hash = cgu.compute_symbol_name_hash(scx, &symbol_cache);\n \n         // Check whether there is a previous work-product we can\n         // re-use.  Not only must the file exist, and the inputs not\n@@ -1174,11 +1175,11 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         // Instantiate translation items without filling out definitions yet...\n-        let lcx = LocalCrateContext::new(scx, cgu, symbol_map.clone());\n+        let lcx = LocalCrateContext::new(scx, cgu, &symbol_cache);\n         let module = {\n             let ccx = CrateContext::new(scx, &lcx);\n             let trans_items = ccx.codegen_unit()\n-                                 .items_in_deterministic_order(ccx.tcx(), &symbol_map);\n+                                 .items_in_deterministic_order(ccx.tcx(), &symbol_cache);\n             for &(trans_item, linkage) in &trans_items {\n                 trans_item.predefine(&ccx, linkage);\n             }\n@@ -1238,7 +1239,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     assert_module_sources::assert_module_sources(tcx, &modules);\n \n-    symbol_names_test::report_symbol_names(&shared_ccx);\n+    symbol_names_test::report_symbol_names(tcx);\n \n     if shared_ccx.sess().trans_stats() {\n         println!(\"--- trans stats ---\");\n@@ -1289,6 +1290,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     time(shared_ccx.sess().time_passes(), \"internalize symbols\", || {\n         internalize_symbols(sess,\n                             &shared_ccx,\n+                            &translation_items,\n                             &llvm_modules,\n                             &symbol_map,\n                             &exported_symbols);\n@@ -1517,7 +1519,9 @@ fn gather_type_sizes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n }\n \n fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>)\n-                                                     -> (Vec<CodegenUnit<'tcx>>, SymbolMap<'tcx>) {\n+                                                     -> (FxHashSet<TransItem<'tcx>>,\n+                                                         Vec<CodegenUnit<'tcx>>,\n+                                                         SymbolMap<'tcx>) {\n     let time_passes = scx.sess().time_passes();\n \n     let collection_mode = match scx.sess().opts.debugging_opts.print_trans_items {\n@@ -1563,13 +1567,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n     assert!(scx.tcx().sess.opts.cg.codegen_units == codegen_units.len() ||\n             scx.tcx().sess.opts.debugging_opts.incremental.is_some());\n \n-    {\n-        let mut ccx_map = scx.translation_items().borrow_mut();\n-\n-        for trans_item in items.iter().cloned() {\n-            ccx_map.insert(trans_item);\n-        }\n-    }\n+    let translation_items: FxHashSet<TransItem<'tcx>> = items.iter().cloned().collect();\n \n     if scx.sess().opts.debugging_opts.print_trans_items.is_some() {\n         let mut item_to_cgus = FxHashMap();\n@@ -1624,5 +1622,5 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         }\n     }\n \n-    (codegen_units, symbol_map)\n+    (translation_items, codegen_units, symbol_map)\n }"}, {"sha": "264e26e4594ca04c88baf6a33cb2c8fd7a09a401", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -14,18 +14,18 @@\n //! and methods are represented as just a fn ptr and not a full\n //! closure.\n \n-use llvm::{self, ValueRef};\n-use rustc::hir::def_id::DefId;\n-use rustc::ty::subst::Substs;\n use attributes;\n use common::{self, CrateContext};\n-use monomorphize;\n use consts;\n use declare;\n-use monomorphize::Instance;\n+use llvm::{self, ValueRef};\n+use monomorphize::{self, Instance};\n+use rustc::hir::def_id::DefId;\n+use rustc::ty::{self, TypeFoldable};\n+use rustc::ty::subst::Substs;\n+use syntax_pos::DUMMY_SP;\n use trans_item::TransItem;\n use type_of;\n-use rustc::ty::TypeFoldable;\n \n /// Translates a reference to a fn/method item, monomorphizing and\n /// inlining as it goes.\n@@ -51,8 +51,7 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         return llfn;\n     }\n \n-    let sym = ccx.symbol_map().get_or_compute(ccx.shared(),\n-                                              TransItem::Fn(instance));\n+    let sym = ccx.symbol_cache().get(TransItem::Fn(instance));\n     debug!(\"get_fn({:?}: {:?}) => {}\", instance, fn_ty, sym);\n \n     // This is subtle and surprising, but sometimes we have to bitcast\n@@ -102,15 +101,17 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let attrs = instance.def.attrs(ccx.tcx());\n         attributes::from_fn_attrs(ccx, &attrs, llfn);\n \n-        let is_local_def = ccx.shared().translation_items().borrow()\n-                              .contains(&TransItem::Fn(instance));\n-        if is_local_def {\n-            // FIXME(eddyb) Doubt all extern fn should allow unwinding.\n+        // Perhaps questionable, but we assume that anything defined\n+        // *in Rust code* may unwind. Foreign items like `extern \"C\" {\n+        // fn foo(); }` are assumed not to unwind **unless** they have\n+        // a `#[unwind]` attribute.\n+        if !ty::queries::is_foreign_item::get(tcx, DUMMY_SP, instance.def_id()) {\n             attributes::unwind(llfn, true);\n             unsafe {\n                 llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::ExternalLinkage);\n             }\n         }\n+\n         if ccx.use_dll_storage_attrs() &&\n             ccx.sess().cstore.is_dllimport_foreign_item(instance.def_id())\n         {"}, {"sha": "13bb0d371250f98b5490b9c0696db0cc2548adff", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -467,13 +467,11 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             // have to instantiate all methods of the trait being cast to, so we\n             // can build the appropriate vtable.\n             mir::Rvalue::Cast(mir::CastKind::Unsize, ref operand, target_ty) => {\n-                let target_ty = monomorphize::apply_param_substs(self.scx,\n-                                                                 self.param_substs,\n-                                                                 &target_ty);\n+                let target_ty = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n+                                                                        &target_ty);\n                 let source_ty = operand.ty(self.mir, self.scx.tcx());\n-                let source_ty = monomorphize::apply_param_substs(self.scx,\n-                                                                 self.param_substs,\n-                                                                 &source_ty);\n+                let source_ty = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n+                                                                        &source_ty);\n                 let (source_ty, target_ty) = find_vtable_types_for_unsizing(self.scx,\n                                                                             source_ty,\n                                                                             target_ty);\n@@ -489,10 +487,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             }\n             mir::Rvalue::Cast(mir::CastKind::ReifyFnPointer, ref operand, _) => {\n                 let fn_ty = operand.ty(self.mir, self.scx.tcx());\n-                let fn_ty = monomorphize::apply_param_substs(\n-                    self.scx,\n-                    self.param_substs,\n-                    &fn_ty);\n+                let fn_ty = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n+                                                                    &fn_ty);\n                 visit_fn_use(self.scx, fn_ty, false, &mut self.output);\n             }\n             mir::Rvalue::Cast(mir::CastKind::ClosureFnPointer, ref operand, _) => {\n@@ -534,9 +530,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         }\n \n         if let mir::Literal::Item { def_id, substs } = constant.literal {\n-            let substs = monomorphize::apply_param_substs(self.scx,\n-                                                          self.param_substs,\n-                                                          &substs);\n+            let substs = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n+                                                                 &substs);\n             let instance = monomorphize::resolve(self.scx, def_id, substs);\n             collect_neighbours(self.scx, instance, self.output);\n         }\n@@ -552,17 +547,14 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         match *kind {\n             mir::TerminatorKind::Call { ref func, .. } => {\n                 let callee_ty = func.ty(self.mir, tcx);\n-                let callee_ty = monomorphize::apply_param_substs(\n-                    self.scx, self.param_substs, &callee_ty);\n+                let callee_ty = tcx.trans_apply_param_substs(self.param_substs, &callee_ty);\n                 visit_fn_use(self.scx, callee_ty, true, &mut self.output);\n             }\n             mir::TerminatorKind::Drop { ref location, .. } |\n             mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n                 let ty = location.ty(self.mir, self.scx.tcx())\n                     .to_ty(self.scx.tcx());\n-                let ty = monomorphize::apply_param_substs(self.scx,\n-                                                          self.param_substs,\n-                                                          &ty);\n+                let ty = tcx.trans_apply_param_substs(self.param_substs, &ty);\n                 visit_drop_use(self.scx, ty, true, self.output);\n             }\n             mir::TerminatorKind::Goto { .. } |"}, {"sha": "648ea92c8437601d22f7dd62d6c068dc1adea136", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -564,7 +564,7 @@ pub fn def_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n                         -> Ty<'tcx>\n {\n     let ty = shared.tcx().item_type(def_id);\n-    monomorphize::apply_param_substs(shared, substs, &ty)\n+    shared.tcx().trans_apply_param_substs(substs, &ty)\n }\n \n /// Return the substituted type of an instance.\n@@ -573,5 +573,5 @@ pub fn instance_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n                              -> Ty<'tcx>\n {\n     let ty = instance.def.def_ty(shared.tcx());\n-    monomorphize::apply_param_substs(shared, instance.substs, &ty)\n+    shared.tcx().trans_apply_param_substs(instance.substs, &ty)\n }"}, {"sha": "3d614cfbcbf3c5c5f961a0d8b5b361c2df6274e2", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -93,28 +93,27 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n             hir_map::NodeItem(&hir::Item {\n                 ref attrs, span, node: hir::ItemStatic(..), ..\n             }) => {\n-                let sym = ccx.symbol_map()\n-                             .get(TransItem::Static(id))\n-                             .expect(\"Local statics should always be in the SymbolMap\");\n+                let sym = ccx.symbol_cache()\n+                             .get(TransItem::Static(id));\n \n                 let defined_in_current_codegen_unit = ccx.codegen_unit()\n                                                          .items()\n                                                          .contains_key(&TransItem::Static(id));\n                 assert!(!defined_in_current_codegen_unit);\n \n-                if declare::get_declared_value(ccx, sym).is_some() {\n+                if declare::get_declared_value(ccx, &sym[..]).is_some() {\n                     span_bug!(span, \"trans: Conflicting symbol names for static?\");\n                 }\n \n-                let g = declare::define_global(ccx, sym, llty).unwrap();\n+                let g = declare::define_global(ccx, &sym[..], llty).unwrap();\n \n                 (g, attrs)\n             }\n \n             hir_map::NodeForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemStatic(..), ..\n             }) => {\n-                let sym = symbol_names::symbol_name(instance, ccx.shared());\n+                let sym = symbol_names::symbol_name(instance, ccx.tcx());\n                 let g = if let Some(name) =\n                         attr::first_attr_value_str_by_name(&attrs, \"linkage\") {\n                     // If this is a static with a linkage specified, then we need to handle\n@@ -174,7 +173,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n \n         g\n     } else {\n-        let sym = symbol_names::symbol_name(instance, ccx.shared());\n+        let sym = symbol_names::symbol_name(instance, ccx.tcx());\n \n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         // FIXME(nagisa): investigate whether it can be changed into define_global"}, {"sha": "bef22cf304dcb938f962c7e58c50429617807efb", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 32, "deletions": 96, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -10,7 +10,7 @@\n \n use llvm;\n use llvm::{ContextRef, ModuleRef, ValueRef};\n-use rustc::dep_graph::{DepGraph, DepGraphSafe, DepNode, DepTrackingMap, DepTrackingMapConfig};\n+use rustc::dep_graph::{DepGraph, DepGraphSafe};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::traits;\n@@ -21,7 +21,6 @@ use declare;\n use monomorphize::Instance;\n \n use partitioning::CodegenUnit;\n-use trans_item::TransItem;\n use type_::Type;\n use rustc_data_structures::base_n;\n use rustc::ty::subst::Substs;\n@@ -30,15 +29,13 @@ use rustc::ty::layout::{LayoutTyper, TyLayout};\n use session::config::NoDebugInfo;\n use session::Session;\n use session::config;\n-use symbol_map::SymbolMap;\n-use util::nodemap::{NodeSet, DefIdMap, FxHashMap, FxHashSet};\n+use symbol_cache::SymbolCache;\n+use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n-use std::marker::PhantomData;\n use std::ptr;\n use std::iter;\n-use std::rc::Rc;\n use std::str;\n use syntax::ast;\n use syntax::symbol::InternedString;\n@@ -86,17 +83,13 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     check_overflow: bool,\n \n     use_dll_storage_attrs: bool,\n-\n-    translation_items: RefCell<FxHashSet<TransItem<'tcx>>>,\n-    trait_cache: RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>>,\n-    project_cache: RefCell<DepTrackingMap<ProjectionCache<'tcx>>>,\n }\n \n /// The local portion of a `CrateContext`.  There is one `LocalCrateContext`\n /// per compilation unit.  Each one has its own LLVM `ContextRef` so that\n /// several compilation units may be optimized in parallel.  All other LLVM\n /// data structures in the `LocalCrateContext` are tied to that `ContextRef`.\n-pub struct LocalCrateContext<'tcx> {\n+pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     llmod: ModuleRef,\n     llcx: ContextRef,\n     stats: Stats,\n@@ -168,73 +161,23 @@ pub struct LocalCrateContext<'tcx> {\n     /// Depth of the current type-of computation - used to bail out\n     type_of_depth: Cell<usize>,\n \n-    symbol_map: Rc<SymbolMap<'tcx>>,\n-\n     /// A counter that is used for generating local symbol names\n     local_gen_sym_counter: Cell<usize>,\n-}\n \n-// Implement DepTrackingMapConfig for `trait_cache`\n-pub struct TraitSelectionCache<'tcx> {\n-    data: PhantomData<&'tcx ()>\n-}\n-\n-impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n-    type Key = ty::PolyTraitRef<'tcx>;\n-    type Value = traits::Vtable<'tcx, ()>;\n-    fn to_dep_node(key: &ty::PolyTraitRef<'tcx>) -> DepNode<DefId> {\n-        key.to_poly_trait_predicate().dep_node()\n-    }\n-}\n-\n-// # Global Cache\n-\n-pub struct ProjectionCache<'gcx> {\n-    data: PhantomData<&'gcx ()>\n-}\n-\n-impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n-    type Key = Ty<'gcx>;\n-    type Value = Ty<'gcx>;\n-    fn to_dep_node(key: &Self::Key) -> DepNode<DefId> {\n-        // Ideally, we'd just put `key` into the dep-node, but we\n-        // can't put full types in there. So just collect up all the\n-        // def-ids of structs/enums as well as any traits that we\n-        // project out of. It doesn't matter so much what we do here,\n-        // except that if we are too coarse, we'll create overly\n-        // coarse edges between impls and the trans. For example, if\n-        // we just used the def-id of things we are projecting out of,\n-        // then the key for `<Foo as SomeTrait>::T` and `<Bar as\n-        // SomeTrait>::T` would both share a dep-node\n-        // (`TraitSelect(SomeTrait)`), and hence the impls for both\n-        // `Foo` and `Bar` would be considered inputs. So a change to\n-        // `Bar` would affect things that just normalized `Foo`.\n-        // Anyway, this heuristic is not ideal, but better than\n-        // nothing.\n-        let def_ids: Vec<DefId> =\n-            key.walk()\n-               .filter_map(|t| match t.sty {\n-                   ty::TyAdt(adt_def, _) => Some(adt_def.did),\n-                   ty::TyProjection(ref proj) => Some(proj.trait_ref.def_id),\n-                   _ => None,\n-               })\n-               .collect();\n-\n-        DepNode::ProjectionCache { def_ids: def_ids }\n-    }\n+    symbol_cache: &'a SymbolCache<'a, 'tcx>,\n }\n \n /// A CrateContext value binds together one LocalCrateContext with the\n /// SharedCrateContext. It exists as a convenience wrapper, so we don't have to\n /// pass around (SharedCrateContext, LocalCrateContext) tuples all over trans.\n pub struct CrateContext<'a, 'tcx: 'a> {\n     shared: &'a SharedCrateContext<'a, 'tcx>,\n-    local_ccx: &'a LocalCrateContext<'tcx>,\n+    local_ccx: &'a LocalCrateContext<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n     pub fn new(shared: &'a SharedCrateContext<'a, 'tcx>,\n-               local_ccx: &'a LocalCrateContext<'tcx>)\n+               local_ccx: &'a LocalCrateContext<'a, 'tcx>)\n                -> Self {\n         CrateContext { shared, local_ccx }\n     }\n@@ -385,9 +328,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             tcx: tcx,\n             check_overflow: check_overflow,\n             use_dll_storage_attrs: use_dll_storage_attrs,\n-            translation_items: RefCell::new(FxHashSet()),\n-            trait_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n-            project_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n         }\n     }\n \n@@ -407,14 +347,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         &self.exported_symbols\n     }\n \n-    pub fn trait_cache(&self) -> &RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>> {\n-        &self.trait_cache\n-    }\n-\n-    pub fn project_cache(&self) -> &RefCell<DepTrackingMap<ProjectionCache<'tcx>>> {\n-        &self.project_cache\n-    }\n-\n     pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.tcx\n     }\n@@ -430,17 +362,13 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     pub fn use_dll_storage_attrs(&self) -> bool {\n         self.use_dll_storage_attrs\n     }\n-\n-    pub fn translation_items(&self) -> &RefCell<FxHashSet<TransItem<'tcx>>> {\n-        &self.translation_items\n-    }\n }\n \n-impl<'tcx> LocalCrateContext<'tcx> {\n-    pub fn new<'a>(shared: &SharedCrateContext<'a, 'tcx>,\n-                   codegen_unit: CodegenUnit<'tcx>,\n-                   symbol_map: Rc<SymbolMap<'tcx>>)\n-                   -> LocalCrateContext<'tcx> {\n+impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n+    pub fn new(shared: &SharedCrateContext<'a, 'tcx>,\n+               codegen_unit: CodegenUnit<'tcx>,\n+               symbol_cache: &'a SymbolCache<'a, 'tcx>)\n+               -> LocalCrateContext<'a, 'tcx> {\n         unsafe {\n             // Append \".rs\" to LLVM module identifier.\n             //\n@@ -494,8 +422,8 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 rust_try_fn: Cell::new(None),\n                 intrinsics: RefCell::new(FxHashMap()),\n                 type_of_depth: Cell::new(0),\n-                symbol_map: symbol_map,\n                 local_gen_sym_counter: Cell::new(0),\n+                symbol_cache: symbol_cache,\n             };\n \n             let (int_type, opaque_vec_type, str_slice_ty, mut local_ccx) = {\n@@ -529,9 +457,9 @@ impl<'tcx> LocalCrateContext<'tcx> {\n     /// This is used in the `LocalCrateContext` constructor to allow calling\n     /// functions that expect a complete `CrateContext`, even before the local\n     /// portion is fully initialized and attached to the `SharedCrateContext`.\n-    fn dummy_ccx<'a>(shared: &'a SharedCrateContext<'a, 'tcx>,\n-                     local_ccxs: &'a [LocalCrateContext<'tcx>])\n-                     -> CrateContext<'a, 'tcx> {\n+    fn dummy_ccx(shared: &'a SharedCrateContext<'a, 'tcx>,\n+                 local_ccxs: &'a [LocalCrateContext<'a, 'tcx>])\n+                 -> CrateContext<'a, 'tcx> {\n         assert!(local_ccxs.len() == 1);\n         CrateContext {\n             shared: shared,\n@@ -549,7 +477,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.shared\n     }\n \n-    fn local(&self) -> &'b LocalCrateContext<'tcx> {\n+    fn local(&self) -> &'b LocalCrateContext<'b, 'tcx> {\n         self.local_ccx\n     }\n \n@@ -716,12 +644,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.shared.use_dll_storage_attrs()\n     }\n \n-    pub fn symbol_map(&self) -> &SymbolMap<'tcx> {\n-        &*self.local().symbol_map\n-    }\n-\n-    pub fn translation_items(&self) -> &RefCell<FxHashSet<TransItem<'tcx>>> {\n-        &self.shared.translation_items\n+    pub fn symbol_cache(&self) -> &'b SymbolCache<'b, 'tcx> {\n+        self.local().symbol_cache\n     }\n \n     /// Given the def-id of some item that has no type parameters, make\n@@ -847,6 +771,10 @@ impl<'a, 'tcx> LayoutTyper<'tcx> for &'a SharedCrateContext<'a, 'tcx> {\n     type TyLayout = TyLayout<'tcx>;\n \n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n+        if let Some(&layout) = self.tcx().layout_cache.borrow().get(&ty) {\n+            return TyLayout { ty: ty, layout: layout, variant_index: None };\n+        }\n+\n         self.tcx().infer_ctxt((), traits::Reveal::All).enter(|infcx| {\n             infcx.layout_of(ty).unwrap_or_else(|e| {\n                 match e {\n@@ -857,6 +785,10 @@ impl<'a, 'tcx> LayoutTyper<'tcx> for &'a SharedCrateContext<'a, 'tcx> {\n             })\n         })\n     }\n+\n+    fn normalize_projections(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.tcx().normalize_associated_type(&ty)\n+    }\n }\n \n impl<'a, 'tcx> LayoutTyper<'tcx> for &'a CrateContext<'a, 'tcx> {\n@@ -865,9 +797,13 @@ impl<'a, 'tcx> LayoutTyper<'tcx> for &'a CrateContext<'a, 'tcx> {\n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n         self.shared.layout_of(ty)\n     }\n+\n+    fn normalize_projections(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.shared.normalize_projections(ty)\n+    }\n }\n \n-pub struct TypeOfDepthLock<'a, 'tcx: 'a>(&'a LocalCrateContext<'tcx>);\n+pub struct TypeOfDepthLock<'a, 'tcx: 'a>(&'a LocalCrateContext<'a, 'tcx>);\n \n impl<'a, 'tcx> Drop for TypeOfDepthLock<'a, 'tcx> {\n     fn drop(&mut self) {"}, {"sha": "117d8568500b8a61176374b31d56aa5cc49d64b5", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -124,6 +124,7 @@ mod meth;\n mod mir;\n mod monomorphize;\n mod partitioning;\n+mod symbol_cache;\n mod symbol_map;\n mod symbol_names_test;\n mod trans_item;"}, {"sha": "040194e63d07e0ec6f549244ec495d3f3951abae", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -100,15 +100,13 @@ impl<'tcx> Const<'tcx> {\n             ConstVal::Integral(ref i) => return Const::from_constint(ccx, i),\n             ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n             ConstVal::ByteStr(ref v) => consts::addr_of(ccx, C_bytes(ccx, v), 1, \"byte_str\"),\n+            ConstVal::Char(c) => C_integral(Type::char(ccx), c as u64, false),\n+            ConstVal::Function(..) => C_null(type_of::type_of(ccx, ty)),\n+            ConstVal::Variant(_) |\n             ConstVal::Struct(_) | ConstVal::Tuple(_) |\n             ConstVal::Array(..) | ConstVal::Repeat(..) => {\n                 bug!(\"MIR must not use `{:?}` (aggregates are expanded to MIR rvalues)\", cv)\n             }\n-            ConstVal::Function(..) => {\n-                let llty = type_of::type_of(ccx, ty);\n-                return Const::new(C_null(llty), ty);\n-            }\n-            ConstVal::Char(c) => C_integral(Type::char(ccx), c as u64, false),\n         };\n \n         assert!(!ty.has_erasable_regions());\n@@ -260,9 +258,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     fn monomorphize<T>(&self, value: &T) -> T\n         where T: TransNormalize<'tcx>\n     {\n-        monomorphize::apply_param_substs(self.ccx.shared(),\n-                                         self.substs,\n-                                         value)\n+        self.ccx.tcx().trans_apply_param_substs(self.substs, value)\n     }\n \n     fn trans(&mut self) -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n@@ -710,7 +706,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 let tr_lvalue = self.const_lvalue(lvalue, span)?;\n \n                 let ty = tr_lvalue.ty;\n-                let ref_ty = tcx.mk_ref(tcx.mk_region(ty::ReErased),\n+                let ref_ty = tcx.mk_ref(tcx.types.re_erased,\n                     ty::TypeAndMut { ty: ty, mutbl: bk.to_mutbl_lossy() });\n \n                 let base = match tr_lvalue.base {"}, {"sha": "af0e27c8ca391e69823b80d7f1e07432acb2b5ee", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -22,7 +22,7 @@ use base;\n use builder::Builder;\n use common::{self, CrateContext, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n-use monomorphize::{self, Instance};\n+use monomorphize::Instance;\n use abi::FnType;\n use type_of;\n \n@@ -102,8 +102,9 @@ pub struct MirContext<'a, 'tcx:'a> {\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T: TransNormalize<'tcx> {\n-        monomorphize::apply_param_substs(self.ccx.shared(), self.param_substs, value)\n+        where T: TransNormalize<'tcx>\n+    {\n+        self.ccx.tcx().trans_apply_param_substs(self.param_substs, value)\n     }\n \n     pub fn set_debug_loc(&mut self, bcx: &Builder, source_info: mir::SourceInfo) {"}, {"sha": "b8e9a490b0e7cffa36b0ce40812131c19ebd8382", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -329,7 +329,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n                 let ref_ty = bcx.tcx().mk_ref(\n-                    bcx.tcx().mk_region(ty::ReErased),\n+                    bcx.tcx().types.re_erased,\n                     ty::TypeAndMut { ty: ty, mutbl: bk.to_mutbl_lossy() }\n                 );\n "}, {"sha": "d27eeb2b64667b712d8f1939cae832eb3a828dab", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 126, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -13,17 +13,13 @@ use common::*;\n use glue;\n \n use rustc::hir::def_id::DefId;\n-use rustc::infer::TransNormalize;\n use rustc::middle::lang_items::DropInPlaceFnLangItem;\n-use rustc::traits::{self, SelectionContext, Reveal};\n+use rustc::traits;\n use rustc::ty::adjustment::CustomCoerceUnsized;\n-use rustc::ty::fold::{TypeFolder, TypeFoldable};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::util::common::MemoizationMap;\n \n-use syntax::ast;\n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::codemap::DUMMY_SP;\n \n pub use rustc::ty::Instance;\n \n@@ -104,73 +100,6 @@ pub fn resolve_closure<'a, 'tcx> (\n     }\n }\n \n-/// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n-/// do not (necessarily) resolve all nested obligations on the impl. Note that type check should\n-/// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n-fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                span: Span,\n-                                trait_ref: ty::PolyTraitRef<'tcx>)\n-                                -> traits::Vtable<'tcx, ()>\n-{\n-    let tcx = scx.tcx();\n-\n-    // Remove any references to regions; this helps improve caching.\n-    let trait_ref = tcx.erase_regions(&trait_ref);\n-\n-    scx.trait_cache().memoize(trait_ref, || {\n-        debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n-               trait_ref, trait_ref.def_id());\n-\n-        // Do the initial selection for the obligation. This yields the\n-        // shallow result we are looking for -- that is, what specific impl.\n-        tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n-            let mut selcx = SelectionContext::new(&infcx);\n-\n-            let obligation_cause = traits::ObligationCause::misc(span,\n-                                                             ast::DUMMY_NODE_ID);\n-            let obligation = traits::Obligation::new(obligation_cause,\n-                                                     trait_ref.to_poly_trait_predicate());\n-\n-            let selection = match selcx.select(&obligation) {\n-                Ok(Some(selection)) => selection,\n-                Ok(None) => {\n-                    // Ambiguity can happen when monomorphizing during trans\n-                    // expands to some humongo type that never occurred\n-                    // statically -- this humongo type can then overflow,\n-                    // leading to an ambiguous result. So report this as an\n-                    // overflow bug, since I believe this is the only case\n-                    // where ambiguity can result.\n-                    debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n-                            presuming due to overflow\",\n-                           trait_ref);\n-                    tcx.sess.span_fatal(span,\n-                        \"reached the recursion limit during monomorphization \\\n-                         (selection ambiguity)\");\n-                }\n-                Err(e) => {\n-                    span_bug!(span, \"Encountered error `{:?}` selecting `{:?}` during trans\",\n-                              e, trait_ref)\n-                }\n-            };\n-\n-            debug!(\"fulfill_obligation: selection={:?}\", selection);\n-\n-            // Currently, we use a fulfillment context to completely resolve\n-            // all nested obligations. This is because they can inform the\n-            // inference of the impl's type parameters.\n-            let mut fulfill_cx = traits::FulfillmentContext::new();\n-            let vtable = selection.map(|predicate| {\n-                debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n-                fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-            });\n-            let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);\n-\n-            info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n-            vtable\n-        })\n-    })\n-}\n-\n fn resolve_associated_item<'a, 'tcx>(\n     scx: &SharedCrateContext<'a, 'tcx>,\n     trait_item: &ty::AssociatedItem,\n@@ -185,7 +114,7 @@ fn resolve_associated_item<'a, 'tcx>(\n            def_id, trait_id, rcvr_substs);\n \n     let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n-    let vtbl = fulfill_obligation(scx, DUMMY_SP, ty::Binder(trait_ref));\n+    let vtbl = tcx.trans_fulfill_obligation(DUMMY_SP, ty::Binder(trait_ref));\n \n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:\n@@ -285,7 +214,7 @@ pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx\n         substs: scx.tcx().mk_substs_trait(source_ty, &[target_ty])\n     });\n \n-    match fulfill_obligation(scx, DUMMY_SP, trait_ref) {\n+    match scx.tcx().trans_fulfill_obligation(DUMMY_SP, trait_ref) {\n         traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n             scx.tcx().coerce_unsized_info(impl_def_id).custom_kind.unwrap()\n         }\n@@ -295,21 +224,6 @@ pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx\n     }\n }\n \n-/// Monomorphizes a type from the AST by first applying the in-scope\n-/// substitutions and then normalizing any associated types.\n-pub fn apply_param_substs<'a, 'tcx, T>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                       param_substs: &Substs<'tcx>,\n-                                       value: &T)\n-                                       -> T\n-    where T: TransNormalize<'tcx>\n-{\n-    let tcx = scx.tcx();\n-    debug!(\"apply_param_substs(param_substs={:?}, value={:?})\", param_substs, value);\n-    let substituted = value.subst(tcx, param_substs);\n-    let substituted = scx.tcx().erase_regions(&substituted);\n-    AssociatedTypeNormalizer::new(scx).fold(&substituted)\n-}\n-\n /// Returns the normalized type of a struct field\n pub fn field_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           param_substs: &Substs<'tcx>,\n@@ -319,39 +233,3 @@ pub fn field_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.normalize_associated_type(&f.ty(tcx, param_substs))\n }\n \n-struct AssociatedTypeNormalizer<'a, 'b: 'a, 'gcx: 'b> {\n-    shared: &'a SharedCrateContext<'b, 'gcx>,\n-}\n-\n-impl<'a, 'b, 'gcx> AssociatedTypeNormalizer<'a, 'b, 'gcx> {\n-    fn new(shared: &'a SharedCrateContext<'b, 'gcx>) -> Self {\n-        AssociatedTypeNormalizer {\n-            shared: shared,\n-        }\n-    }\n-\n-    fn fold<T:TypeFoldable<'gcx>>(&mut self, value: &T) -> T {\n-        if !value.has_projection_types() {\n-            value.clone()\n-        } else {\n-            value.fold_with(self)\n-        }\n-    }\n-}\n-\n-impl<'a, 'b, 'gcx> TypeFolder<'gcx, 'gcx> for AssociatedTypeNormalizer<'a, 'b, 'gcx> {\n-    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'gcx, 'gcx> {\n-        self.shared.tcx()\n-    }\n-\n-    fn fold_ty(&mut self, ty: Ty<'gcx>) -> Ty<'gcx> {\n-        if !ty.has_projection_types() {\n-            ty\n-        } else {\n-            self.shared.project_cache().memoize(ty, || {\n-                debug!(\"AssociatedTypeNormalizer: ty={:?}\", ty);\n-                self.shared.tcx().normalize_associated_type(&ty)\n-            })\n-        }\n-    }\n-}"}, {"sha": "6b89d11cfb68f161e9356ba6934a46e943f306bc", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -116,7 +116,7 @@ use rustc_incremental::IchHasher;\n use std::cmp::Ordering;\n use std::hash::Hash;\n use std::sync::Arc;\n-use symbol_map::SymbolMap;\n+use symbol_cache::SymbolCache;\n use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n use trans_item::{TransItem, InstantiationMode};\n@@ -174,14 +174,15 @@ impl<'tcx> CodegenUnit<'tcx> {\n         DepNode::WorkProduct(self.work_product_id())\n     }\n \n-    pub fn compute_symbol_name_hash(&self,\n-                                    scx: &SharedCrateContext,\n-                                    symbol_map: &SymbolMap) -> u64 {\n+    pub fn compute_symbol_name_hash<'a>(&self,\n+                                        scx: &SharedCrateContext<'a, 'tcx>,\n+                                        symbol_cache: &SymbolCache<'a, 'tcx>)\n+                                        -> u64 {\n         let mut state = IchHasher::new();\n         let exported_symbols = scx.exported_symbols();\n-        let all_items = self.items_in_deterministic_order(scx.tcx(), symbol_map);\n+        let all_items = self.items_in_deterministic_order(scx.tcx(), symbol_cache);\n         for (item, _) in all_items {\n-            let symbol_name = symbol_map.get(item).unwrap();\n+            let symbol_name = symbol_cache.get(item);\n             symbol_name.len().hash(&mut state);\n             symbol_name.hash(&mut state);\n             let exported = match item {\n@@ -201,10 +202,10 @@ impl<'tcx> CodegenUnit<'tcx> {\n         state.finish().to_smaller_hash()\n     }\n \n-    pub fn items_in_deterministic_order(&self,\n-                                        tcx: TyCtxt,\n-                                        symbol_map: &SymbolMap)\n-                                        -> Vec<(TransItem<'tcx>, llvm::Linkage)> {\n+    pub fn items_in_deterministic_order<'a>(&self,\n+                                            tcx: TyCtxt,\n+                                            symbol_cache: &SymbolCache<'a, 'tcx>)\n+                                            -> Vec<(TransItem<'tcx>, llvm::Linkage)> {\n         let mut items: Vec<(TransItem<'tcx>, llvm::Linkage)> =\n             self.items.iter().map(|(item, linkage)| (*item, *linkage)).collect();\n \n@@ -216,9 +217,9 @@ impl<'tcx> CodegenUnit<'tcx> {\n \n             match (node_id1, node_id2) {\n                 (None, None) => {\n-                    let symbol_name1 = symbol_map.get(trans_item1).unwrap();\n-                    let symbol_name2 = symbol_map.get(trans_item2).unwrap();\n-                    symbol_name1.cmp(symbol_name2)\n+                    let symbol_name1 = symbol_cache.get(trans_item1);\n+                    let symbol_name2 = symbol_cache.get(trans_item2);\n+                    symbol_name1.cmp(&symbol_name2)\n                 }\n                 // In the following two cases we can avoid looking up the symbol\n                 (None, Some(_)) => Ordering::Less,\n@@ -230,9 +231,9 @@ impl<'tcx> CodegenUnit<'tcx> {\n                         return ordering;\n                     }\n \n-                    let symbol_name1 = symbol_map.get(trans_item1).unwrap();\n-                    let symbol_name2 = symbol_map.get(trans_item2).unwrap();\n-                    symbol_name1.cmp(symbol_name2)\n+                    let symbol_name1 = symbol_cache.get(trans_item1);\n+                    let symbol_name2 = symbol_cache.get(trans_item2);\n+                    symbol_name1.cmp(&symbol_name2)\n                 }\n             }\n         });\n@@ -271,14 +272,14 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     let mut initial_partitioning = place_root_translation_items(scx,\n                                                                 trans_items);\n \n-    debug_dump(scx, \"INITIAL PARTITONING:\", initial_partitioning.codegen_units.iter());\n+    debug_dump(tcx, \"INITIAL PARTITONING:\", initial_partitioning.codegen_units.iter());\n \n     // If the partitioning should produce a fixed count of codegen units, merge\n     // until that count is reached.\n     if let PartitioningStrategy::FixedUnitCount(count) = strategy {\n         merge_codegen_units(&mut initial_partitioning, count, &tcx.crate_name.as_str());\n \n-        debug_dump(scx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n+        debug_dump(tcx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n     }\n \n     // In the next step, we use the inlining map to determine which addtional\n@@ -288,7 +289,7 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     let post_inlining = place_inlined_translation_items(initial_partitioning,\n                                                         inlining_map);\n \n-    debug_dump(scx, \"POST INLINING:\", post_inlining.0.iter());\n+    debug_dump(tcx, \"POST INLINING:\", post_inlining.0.iter());\n \n     // Finally, sort by codegen unit name, so that we get deterministic results\n     let mut result = post_inlining.0;\n@@ -528,28 +529,26 @@ fn numbered_codegen_unit_name(crate_name: &str, index: usize) -> InternedString\n     Symbol::intern(&format!(\"{}{}{}\", crate_name, NUMBERED_CODEGEN_UNIT_MARKER, index)).as_str()\n }\n \n-fn debug_dump<'a, 'b, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                label: &str,\n                                cgus: I)\n     where I: Iterator<Item=&'b CodegenUnit<'tcx>>,\n           'tcx: 'a + 'b\n {\n     if cfg!(debug_assertions) {\n         debug!(\"{}\", label);\n+        let symbol_cache = SymbolCache::new(tcx);\n         for cgu in cgus {\n-            let symbol_map = SymbolMap::build(scx, cgu.items\n-                                                      .iter()\n-                                                      .map(|(&trans_item, _)| trans_item));\n             debug!(\"CodegenUnit {}:\", cgu.name);\n \n             for (trans_item, linkage) in &cgu.items {\n-                let symbol_name = symbol_map.get_or_compute(scx, *trans_item);\n+                let symbol_name = symbol_cache.get(*trans_item);\n                 let symbol_hash_start = symbol_name.rfind('h');\n                 let symbol_hash = symbol_hash_start.map(|i| &symbol_name[i ..])\n                                                    .unwrap_or(\"<no hash>\");\n \n                 debug!(\" - {} [{:?}] [{}]\",\n-                       trans_item.to_string(scx.tcx()),\n+                       trans_item.to_string(tcx),\n                        linkage,\n                        symbol_hash);\n             }"}, {"sha": "ddc1ef537a55fcdd4fd575579758efee882301f9", "filename": "src/librustc_trans/symbol_cache.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fsymbol_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fsymbol_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_cache.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty::TyCtxt;\n+use std::cell::RefCell;\n+use syntax_pos::symbol::{InternedString, Symbol};\n+use trans_item::TransItem;\n+use util::nodemap::FxHashMap;\n+\n+// In the SymbolCache we collect the symbol names of translation items\n+// and cache them for later reference. This is just a performance\n+// optimization and the cache is populated lazilly; symbol names of\n+// translation items are deterministic and fully defined by the item.\n+// Thus they can always be recomputed if needed.\n+\n+pub struct SymbolCache<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    index: RefCell<FxHashMap<TransItem<'tcx>, Symbol>>,\n+}\n+\n+impl<'a, 'tcx> SymbolCache<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+        SymbolCache {\n+            tcx: tcx,\n+            index: RefCell::new(FxHashMap())\n+        }\n+    }\n+\n+    pub fn get(&self, trans_item: TransItem<'tcx>) -> InternedString {\n+        let mut index = self.index.borrow_mut();\n+        index.entry(trans_item)\n+             .or_insert_with(|| Symbol::intern(&trans_item.compute_symbol_name(self.tcx)))\n+             .as_str()\n+    }\n+}"}, {"sha": "9d3e62888a2df1fadb22b8088c4d2a2de74875a2", "filename": "src/librustc_trans/symbol_map.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fsymbol_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fsymbol_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_map.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -34,8 +34,9 @@ impl<'tcx> SymbolMap<'tcx> {\n         where I: Iterator<Item=TransItem<'tcx>>\n     {\n         // Check for duplicate symbol names\n+        let tcx = scx.tcx();\n         let mut symbols: Vec<_> = trans_items.map(|trans_item| {\n-            (trans_item, trans_item.compute_symbol_name(scx))\n+            (trans_item, trans_item.compute_symbol_name(tcx))\n         }).collect();\n \n         (&mut symbols[..]).sort_by(|&(_, ref sym1), &(_, ref sym2)|{\n@@ -124,7 +125,7 @@ impl<'tcx> SymbolMap<'tcx> {\n         if let Some(sym) = self.get(trans_item) {\n             Cow::from(sym)\n         } else {\n-            Cow::from(trans_item.compute_symbol_name(scx))\n+            Cow::from(trans_item.compute_symbol_name(scx.tcx()))\n         }\n     }\n }"}, {"sha": "fd817cb94c1c1db1251d73e7ea84c6832a300d47", "filename": "src/librustc_trans/symbol_names_test.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_names_test.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -17,43 +17,42 @@\n use back::symbol_names;\n use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use rustc::ty::TyCtxt;\n use syntax::ast;\n \n-use common::SharedCrateContext;\n use monomorphize::Instance;\n \n const SYMBOL_NAME: &'static str = \"rustc_symbol_name\";\n const ITEM_PATH: &'static str = \"rustc_item_path\";\n \n-pub fn report_symbol_names(scx: &SharedCrateContext) {\n+pub fn report_symbol_names<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // if the `rustc_attrs` feature is not enabled, then the\n     // attributes we are interested in cannot be present anyway, so\n     // skip the walk.\n-    let tcx = scx.tcx();\n     if !tcx.sess.features.borrow().rustc_attrs {\n         return;\n     }\n \n     let _ignore = tcx.dep_graph.in_ignore();\n-    let mut visitor = SymbolNamesTest { scx: scx };\n+    let mut visitor = SymbolNamesTest { tcx: tcx };\n     // FIXME(#37712) could use ItemLikeVisitor if trait items were item-like\n     tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n }\n \n struct SymbolNamesTest<'a, 'tcx:'a> {\n-    scx: &'a SharedCrateContext<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n     fn process_attrs(&mut self,\n                      node_id: ast::NodeId) {\n-        let tcx = self.scx.tcx();\n+        let tcx = self.tcx;\n         let def_id = tcx.hir.local_def_id(node_id);\n         for attr in tcx.get_attrs(def_id).iter() {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names\n                 let instance = Instance::mono(tcx, def_id);\n-                let name = symbol_names::symbol_name(instance, self.scx);\n+                let name = symbol_names::symbol_name(instance, self.tcx);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", name));\n             } else if attr.check_name(ITEM_PATH) {\n                 let path = tcx.item_path_str(def_id);"}, {"sha": "de35d1b7dd4c96330d46d06e479386e179c27a32", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -18,7 +18,7 @@ use asm;\n use attributes;\n use base;\n use consts;\n-use context::{CrateContext, SharedCrateContext};\n+use context::CrateContext;\n use common;\n use declare;\n use llvm;\n@@ -118,8 +118,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                self.to_raw_string(),\n                ccx.codegen_unit().name());\n \n-        let symbol_name = ccx.symbol_map()\n-                             .get_or_compute(ccx.shared(), *self);\n+        let symbol_name = ccx.symbol_cache().get(*self);\n \n         debug!(\"symbol {}\", &symbol_name);\n \n@@ -185,16 +184,15 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         ccx.instances().borrow_mut().insert(instance, lldecl);\n     }\n \n-    pub fn compute_symbol_name(&self,\n-                               scx: &SharedCrateContext<'a, 'tcx>) -> String {\n+    pub fn compute_symbol_name(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n         match *self {\n-            TransItem::Fn(instance) => symbol_names::symbol_name(instance, scx),\n+            TransItem::Fn(instance) => symbol_names::symbol_name(instance, tcx),\n             TransItem::Static(node_id) => {\n-                let def_id = scx.tcx().hir.local_def_id(node_id);\n-                symbol_names::symbol_name(Instance::mono(scx.tcx(), def_id), scx)\n+                let def_id = tcx.hir.local_def_id(node_id);\n+                symbol_names::symbol_name(Instance::mono(tcx, def_id), tcx)\n             }\n             TransItem::GlobalAsm(node_id) => {\n-                let def_id = scx.tcx().hir.local_def_id(node_id);\n+                let def_id = tcx.hir.local_def_id(node_id);\n                 format!(\"global_asm_{:?}\", def_id)\n             }\n         }"}, {"sha": "5137ae6ff42227f20cbb7dc21a14b7d925a54403", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -109,7 +109,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let tcx = self.tcx();\n         let r = match tcx.named_region_map.defs.get(&lifetime.id) {\n             Some(&rl::Region::Static) => {\n-                tcx.mk_region(ty::ReStatic)\n+                tcx.types.re_static\n             }\n \n             Some(&rl::Region::LateBound(debruijn, id)) => {\n@@ -171,7 +171,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     .emit();\n \n                 return Substs::for_item(tcx, def_id, |_, _| {\n-                    tcx.mk_region(ty::ReStatic)\n+                    tcx.types.re_static\n                 }, |_, _| {\n                     tcx.types.err\n                 });\n@@ -254,7 +254,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             if let Some(lifetime) = lifetimes.get(i) {\n                 self.ast_region_to_region(lifetime, Some(def))\n             } else {\n-                tcx.mk_region(ty::ReStatic)\n+                tcx.types.re_static\n             }\n         }, |def, substs| {\n             let i = def.index as usize;\n@@ -715,7 +715,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         span_err!(tcx.sess, span, E0228,\n                                   \"the lifetime bound for this object type cannot be deduced \\\n                                    from context; please supply an explicit bound\");\n-                        tcx.mk_region(ty::ReStatic)\n+                        tcx.types.re_static\n                     })\n                 }\n             })\n@@ -1357,7 +1357,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // If any of the derived region bounds are 'static, that is always\n         // the best choice.\n         if derived_region_bounds.iter().any(|&r| ty::ReStatic == *r) {\n-            return Some(tcx.mk_region(ty::ReStatic));\n+            return Some(tcx.types.re_static);\n         }\n \n         // Determine whether there is exactly one unique region in the set"}, {"sha": "1086773041c9351624a7fa86d249781634872bcc", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let expected_ty = self.structurally_resolved_type(pat.span, expected);\n                         if let ty::TyRef(_, mt) = expected_ty.sty {\n                             if let ty::TySlice(_) = mt.ty.sty {\n-                                pat_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic),\n+                                pat_ty = tcx.mk_imm_ref(tcx.types.re_static,\n                                                          tcx.mk_slice(tcx.types.u8))\n                             }\n                         }"}, {"sha": "c125d7c02556fb2e67c317dc0ef70871113669ee", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 43, "deletions": 369, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -15,12 +15,11 @@ use middle::free_region::FreeRegionMap;\n use rustc::infer::{self, InferOk};\n use middle::region;\n use rustc::ty::subst::{Subst, Substs};\n-use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::traits::{self, ObligationCause, Reveal};\n use util::common::ErrorReported;\n use util::nodemap::FxHashSet;\n \n-use syntax::ast;\n use syntax_pos::Span;\n \n /// check_drop_impl confirms that the Drop implementation identfied by\n@@ -270,389 +269,64 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n ///\n pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n     rcx: &mut RegionCtxt<'a, 'gcx, 'tcx>,\n-    typ: ty::Ty<'tcx>,\n+    ty: ty::Ty<'tcx>,\n     span: Span,\n     scope: region::CodeExtent)\n+    -> Result<(), ErrorReported>\n {\n     debug!(\"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\",\n-           typ, scope);\n+           ty, scope);\n \n \n     let parent_scope = match rcx.tcx.region_maps.opt_encl_scope(scope) {\n-      Some(parent_scope) => parent_scope,\n-      // If no enclosing scope, then it must be the root scope which cannot be outlived.\n-      None => return\n+        Some(parent_scope) => parent_scope,\n+        // If no enclosing scope, then it must be the root scope\n+        // which cannot be outlived.\n+        None => return Ok(())\n     };\n-\n-    let result = iterate_over_potentially_unsafe_regions_in_type(\n-        &mut DropckContext {\n-            rcx: rcx,\n-            span: span,\n-            parent_scope: parent_scope,\n-            breadcrumbs: FxHashSet()\n-        },\n-        TypeContext::Root,\n-        typ,\n-        0);\n-    match result {\n-        Ok(()) => {}\n-        Err(Error::Overflow(ref ctxt, ref detected_on_typ)) => {\n-            let tcx = rcx.tcx;\n-            let mut err = struct_span_err!(tcx.sess, span, E0320,\n-                                           \"overflow while adding drop-check rules for {}\", typ);\n-            match *ctxt {\n-                TypeContext::Root => {\n-                    // no need for an additional note if the overflow\n-                    // was somehow on the root.\n-                }\n-                TypeContext::ADT { def_id, variant, field } => {\n-                    let adt = tcx.lookup_adt_def(def_id);\n-                    let variant_name = match adt.adt_kind() {\n-                        AdtKind::Enum => format!(\"enum {} variant {}\",\n-                                                 tcx.item_path_str(def_id),\n-                                                 variant),\n-                        AdtKind::Struct => format!(\"struct {}\",\n-                                                   tcx.item_path_str(def_id)),\n-                        AdtKind::Union => format!(\"union {}\",\n-                                                  tcx.item_path_str(def_id)),\n-                    };\n-                    span_note!(\n-                        &mut err,\n-                        span,\n-                        \"overflowed on {} field {} type: {}\",\n-                        variant_name,\n-                        field,\n-                        detected_on_typ);\n+    let parent_scope = rcx.tcx.mk_region(ty::ReScope(parent_scope));\n+    let origin = || infer::SubregionOrigin::SafeDestructor(span);\n+\n+    let ty = rcx.fcx.resolve_type_vars_if_possible(&ty);\n+    let for_ty = ty;\n+    let mut types = vec![(ty, 0)];\n+    let mut known = FxHashSet();\n+    while let Some((ty, depth)) = types.pop() {\n+        let ty::DtorckConstraint {\n+            dtorck_types, outlives\n+        } = rcx.tcx.dtorck_constraint_for_ty(span, for_ty, depth, ty)?;\n+\n+        for ty in dtorck_types {\n+            let ty = rcx.fcx.normalize_associated_types_in(span, &ty);\n+            let ty = rcx.fcx.resolve_type_vars_with_obligations(ty);\n+            let ty = rcx.fcx.resolve_type_and_region_vars_if_possible(&ty);\n+            match ty.sty {\n+                // All parameters live for the duration of the\n+                // function.\n+                ty::TyParam(..) => {}\n+\n+                // A projection that we couldn't resolve - it\n+                // might have a destructor.\n+                ty::TyProjection(..) | ty::TyAnon(..) => {\n+                    rcx.type_must_outlive(origin(), ty, parent_scope);\n                 }\n-            }\n-            err.emit();\n-        }\n-    }\n-}\n-\n-enum Error<'tcx> {\n-    Overflow(TypeContext, ty::Ty<'tcx>),\n-}\n-\n-#[derive(Copy, Clone)]\n-enum TypeContext {\n-    Root,\n-    ADT {\n-        def_id: DefId,\n-        variant: ast::Name,\n-        field: ast::Name,\n-    }\n-}\n-\n-struct DropckContext<'a, 'b: 'a, 'gcx: 'b+'tcx, 'tcx: 'b> {\n-    rcx: &'a mut RegionCtxt<'b, 'gcx, 'tcx>,\n-    /// types that have already been traversed\n-    breadcrumbs: FxHashSet<Ty<'tcx>>,\n-    /// span for error reporting\n-    span: Span,\n-    /// the scope reachable dtorck types must outlive\n-    parent_scope: region::CodeExtent\n-}\n-\n-// `context` is used for reporting overflow errors\n-fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n-    cx: &mut DropckContext<'a, 'b, 'gcx, 'tcx>,\n-    context: TypeContext,\n-    ty: Ty<'tcx>,\n-    depth: usize)\n-    -> Result<(), Error<'tcx>>\n-{\n-    let tcx = cx.rcx.tcx;\n-    // Issue #22443: Watch out for overflow. While we are careful to\n-    // handle regular types properly, non-regular ones cause problems.\n-    let recursion_limit = tcx.sess.recursion_limit.get();\n-    if depth / 4 >= recursion_limit {\n-        // This can get into rather deep recursion, especially in the\n-        // presence of things like Vec<T> -> Unique<T> -> PhantomData<T> -> T.\n-        // use a higher recursion limit to avoid errors.\n-        return Err(Error::Overflow(context, ty))\n-    }\n \n-    // canoncialize the regions in `ty` before inserting - infinitely many\n-    // region variables can refer to the same region.\n-    let ty = cx.rcx.resolve_type_and_region_vars_if_possible(&ty);\n-\n-    if !cx.breadcrumbs.insert(ty) {\n-        debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n-               {}ty: {} scope: {:?} - cached\",\n-               (0..depth).map(|_| ' ').collect::<String>(),\n-               ty, cx.parent_scope);\n-        return Ok(()); // we already visited this type\n-    }\n-    debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n-           {}ty: {} scope: {:?}\",\n-           (0..depth).map(|_| ' ').collect::<String>(),\n-           ty, cx.parent_scope);\n-\n-    // If `typ` has a destructor, then we must ensure that all\n-    // borrowed data reachable via `typ` must outlive the parent\n-    // of `scope`. This is handled below.\n-    //\n-    // However, there is an important special case: for any Drop\n-    // impl that is tagged as \"blind\" to their parameters,\n-    // we assume that data borrowed via such type parameters\n-    // remains unreachable via that Drop impl.\n-    //\n-    // For example, consider:\n-    //\n-    // ```rust\n-    // #[unsafe_destructor_blind_to_params]\n-    // impl<T> Drop for Vec<T> { ... }\n-    // ```\n-    //\n-    // which does have to be able to drop instances of `T`, but\n-    // otherwise cannot read data from `T`.\n-    //\n-    // Of course, for the type expression passed in for any such\n-    // unbounded type parameter `T`, we must resume the recursive\n-    // analysis on `T` (since it would be ignored by\n-    // type_must_outlive).\n-    let dropck_kind = has_dtor_of_interest(tcx, ty);\n-    debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n-            ty: {:?} dropck_kind: {:?}\", ty, dropck_kind);\n-    match dropck_kind {\n-        DropckKind::NoBorrowedDataAccessedInMyDtor => {\n-            // The maximally blind attribute.\n-        }\n-        DropckKind::BorrowedDataMustStrictlyOutliveSelf => {\n-            cx.rcx.type_must_outlive(infer::SubregionOrigin::SafeDestructor(cx.span),\n-                                     ty, tcx.mk_region(ty::ReScope(cx.parent_scope)));\n-            return Ok(());\n-        }\n-        DropckKind::RevisedSelf(revised_ty) => {\n-            cx.rcx.type_must_outlive(infer::SubregionOrigin::SafeDestructor(cx.span),\n-                                     revised_ty, tcx.mk_region(ty::ReScope(cx.parent_scope)));\n-            // Do not return early from this case; we want\n-            // to recursively process the internal structure of Self\n-            // (because even though the Drop for Self has been asserted\n-            //  safe, the types instantiated for the generics of Self\n-            //  may themselves carry dropck constraints.)\n-        }\n-    }\n-\n-    debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n-           {}ty: {} scope: {:?} - checking interior\",\n-           (0..depth).map(|_| ' ').collect::<String>(),\n-           ty, cx.parent_scope);\n-\n-    // We still need to ensure all referenced data is safe.\n-    match ty.sty {\n-        ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) |\n-        ty::TyFloat(_) | ty::TyStr | ty::TyNever => {\n-            // primitive - definitely safe\n-            Ok(())\n-        }\n-\n-        ty::TyArray(ity, _) | ty::TySlice(ity) => {\n-            // single-element containers, behave like their element\n-            iterate_over_potentially_unsafe_regions_in_type(\n-                cx, context, ity, depth+1)\n-        }\n-\n-        ty::TyAdt(def, substs) if def.is_phantom_data() => {\n-            // PhantomData<T> - behaves identically to T\n-            let ity = substs.type_at(0);\n-            iterate_over_potentially_unsafe_regions_in_type(\n-                cx, context, ity, depth+1)\n-        }\n-\n-        ty::TyAdt(def, substs) => {\n-            let did = def.did;\n-            for variant in &def.variants {\n-                for field in variant.fields.iter() {\n-                    let fty = field.ty(tcx, substs);\n-                    let fty = cx.rcx.fcx.resolve_type_vars_with_obligations(\n-                        cx.rcx.fcx.normalize_associated_types_in(cx.span, &fty));\n-                    iterate_over_potentially_unsafe_regions_in_type(\n-                        cx,\n-                        TypeContext::ADT {\n-                            def_id: did,\n-                            field: field.name,\n-                            variant: variant.name,\n-                        },\n-                        fty,\n-                        depth+1)?\n+                _ => {\n+                    if let None = known.replace(ty) {\n+                        types.push((ty, depth+1));\n+                    }\n                 }\n             }\n-            Ok(())\n-        }\n-\n-        ty::TyClosure(def_id, substs) => {\n-            for ty in substs.upvar_tys(def_id, tcx) {\n-                iterate_over_potentially_unsafe_regions_in_type(cx, context, ty, depth+1)?\n-            }\n-            Ok(())\n-        }\n-\n-        ty::TyTuple(tys, _) => {\n-            for ty in tys {\n-                iterate_over_potentially_unsafe_regions_in_type(cx, context, ty, depth+1)?\n-            }\n-            Ok(())\n-        }\n-\n-        ty::TyRawPtr(..) | ty::TyRef(..) | ty::TyParam(..) => {\n-            // these always come with a witness of liveness (references\n-            // explicitly, pointers implicitly, parameters by the\n-            // caller).\n-            Ok(())\n         }\n \n-        ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n-            // FIXME(#26656): this type is always destruction-safe, but\n-            // it implicitly witnesses Self: Fn, which can be false.\n-            Ok(())\n-        }\n-\n-        ty::TyInfer(..) | ty::TyError => {\n-            tcx.sess.delay_span_bug(cx.span, \"unresolved type in regionck\");\n-            Ok(())\n-        }\n-\n-        // these are always dtorck\n-        ty::TyDynamic(..) | ty::TyProjection(_) | ty::TyAnon(..) => bug!(),\n-    }\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum DropckKind<'tcx> {\n-    /// The \"safe\" kind; i.e. conservatively assume any borrow\n-    /// accessed by dtor, and therefore such data must strictly\n-    /// outlive self.\n-    ///\n-    /// Equivalent to RevisedTy with no change to the self type.\n-    BorrowedDataMustStrictlyOutliveSelf,\n-\n-    /// The nearly completely-unsafe kind.\n-    ///\n-    /// Equivalent to RevisedSelf with *all* parameters remapped to ()\n-    /// (maybe...?)\n-    NoBorrowedDataAccessedInMyDtor,\n-\n-    /// Assume all borrowed data access by dtor occurs as if Self has the\n-    /// type carried by this variant. In practice this means that some\n-    /// of the type parameters are remapped to `()` (and some lifetime\n-    /// parameters remapped to `'static`), because the developer has asserted\n-    /// that the destructor will not access their contents.\n-    RevisedSelf(Ty<'tcx>),\n-}\n-\n-/// Returns the classification of what kind of check should be applied\n-/// to `ty`, which may include a revised type where some of the type\n-/// parameters are re-mapped to `()` to reflect the destructor's\n-/// \"purity\" with respect to their actual contents.\n-fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                        ty: Ty<'tcx>)\n-                                        -> DropckKind<'tcx> {\n-    match ty.sty {\n-        ty::TyAdt(adt_def, substs) => {\n-            if !adt_def.is_dtorck(tcx) {\n-                return DropckKind::NoBorrowedDataAccessedInMyDtor;\n+        for outlive in outlives {\n+            if let Some(r) = outlive.as_region() {\n+                rcx.sub_regions(origin(), parent_scope, r);\n+            } else if let Some(ty) = outlive.as_type() {\n+                rcx.type_must_outlive(origin(), ty, parent_scope);\n             }\n-\n-            // Find the `impl<..> Drop for _` to inspect any\n-            // attributes attached to the impl's generics.\n-            let dtor_method = adt_def.destructor(tcx)\n-                .expect(\"dtorck type without destructor impossible\");\n-            let method = tcx.associated_item(dtor_method.did);\n-            let impl_def_id = method.container.id();\n-            let revised_ty = revise_self_ty(tcx, adt_def, impl_def_id, substs);\n-            return DropckKind::RevisedSelf(revised_ty);\n-        }\n-        ty::TyDynamic(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n-            debug!(\"ty: {:?} isn't known, and therefore is a dropck type\", ty);\n-            return DropckKind::BorrowedDataMustStrictlyOutliveSelf;\n-        },\n-        _ => {\n-            return DropckKind::NoBorrowedDataAccessedInMyDtor;\n         }\n     }\n-}\n \n-// Constructs new Ty just like the type defined by `adt_def` coupled\n-// with `substs`, except each type and lifetime parameter marked as\n-// `#[may_dangle]` in the Drop impl (identified by `impl_def_id`) is\n-// respectively mapped to `()` or `'static`.\n-//\n-// For example: If the `adt_def` maps to:\n-//\n-//   enum Foo<'a, X, Y> { ... }\n-//\n-// and the `impl_def_id` maps to:\n-//\n-//   impl<#[may_dangle] 'a, X, #[may_dangle] Y> Drop for Foo<'a, X, Y> { ... }\n-//\n-// then revises input: `Foo<'r,i64,&'r i64>` to: `Foo<'static,i64,()>`\n-fn revise_self_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                  adt_def: &'tcx ty::AdtDef,\n-                                  impl_def_id: DefId,\n-                                  substs: &Substs<'tcx>)\n-                                  -> Ty<'tcx> {\n-    // Get generics for `impl Drop` to query for `#[may_dangle]` attr.\n-    let impl_bindings = tcx.item_generics(impl_def_id);\n-\n-    // Get Substs attached to Self on `impl Drop`; process in parallel\n-    // with `substs`, replacing dangling entries as appropriate.\n-    let self_substs = {\n-        let impl_self_ty: Ty<'tcx> = tcx.item_type(impl_def_id);\n-        if let ty::TyAdt(self_adt_def, self_substs) = impl_self_ty.sty {\n-            assert_eq!(adt_def, self_adt_def);\n-            self_substs\n-        } else {\n-            bug!(\"Self in `impl Drop for _` must be an Adt.\");\n-        }\n-    };\n-\n-    // Walk `substs` + `self_substs`, build new substs appropriate for\n-    // `adt_def`; each non-dangling param reuses entry from `substs`.\n-    //\n-    // Note: The manner we map from a right-hand side (i.e. Region or\n-    // Ty) for a given `def` to generic parameter associated with that\n-    // right-hand side is tightly coupled to `Drop` impl constraints.\n-    //\n-    // E.g. we know such a Ty must be `TyParam`, because a destructor\n-    // for `struct Foo<X>` is defined via `impl<Y> Drop for Foo<Y>`,\n-    // and never by (for example) `impl<Z> Drop for Foo<Vec<Z>>`.\n-    let substs = Substs::for_item(\n-        tcx,\n-        adt_def.did,\n-        |def, _| {\n-            let r_orig = substs.region_for_def(def);\n-            let impl_self_orig = self_substs.region_for_def(def);\n-            let r = if let ty::Region::ReEarlyBound(ref ebr) = *impl_self_orig {\n-                if impl_bindings.region_param(ebr).pure_wrt_drop {\n-                    tcx.mk_region(ty::ReStatic)\n-                } else {\n-                    r_orig\n-                }\n-            } else {\n-                bug!(\"substs for an impl must map regions to ReEarlyBound\");\n-            };\n-            debug!(\"has_dtor_of_interest mapping def {:?} orig {:?} to {:?}\",\n-                   def, r_orig, r);\n-            r\n-        },\n-        |def, _| {\n-            let t_orig = substs.type_for_def(def);\n-            let impl_self_orig = self_substs.type_for_def(def);\n-            let t = if let ty::TypeVariants::TyParam(ref pt) = impl_self_orig.sty {\n-                if impl_bindings.type_param(pt).pure_wrt_drop {\n-                    tcx.mk_nil()\n-                } else {\n-                    t_orig\n-                }\n-            } else {\n-                bug!(\"substs for an impl must map types to TyParam\");\n-            };\n-            debug!(\"has_dtor_of_interest mapping def {:?} orig {:?} {:?} to {:?} {:?}\",\n-                   def, t_orig, t_orig.sty, t, t.sty);\n-            t\n-        });\n-\n-    tcx.mk_adt(adt_def, &substs)\n+    Ok(())\n }"}, {"sha": "bf7649242fa71c918b35bd782469c3bb21984b48", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -36,7 +36,7 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let def_id = tcx.hir.local_def_id(it.id);\n \n     let substs = Substs::for_item(tcx, def_id,\n-                                  |_, _| tcx.mk_region(ty::ReErased),\n+                                  |_, _| tcx.types.re_erased,\n                                   |def, _| tcx.mk_param_from_def(def));\n \n     let fty = tcx.mk_fn_def(def_id, substs, ty::Binder(tcx.mk_fn_sig("}, {"sha": "80f9372eb54c40e76d12ba6741c23e209d52b363", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -1063,7 +1063,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         // In general, during probing we erase regions. See\n         // `impl_self_ty()` for an explanation.\n-        let region = tcx.mk_region(ty::ReErased);\n+        let region = tcx.types.re_erased;\n \n         // Search through mutabilities in order to find one where pick works:\n         [hir::MutImmutable, hir::MutMutable]\n@@ -1325,7 +1325,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 } else {\n                     // In general, during probe we erase regions. See\n                     // `impl_self_ty()` for an explanation.\n-                    self.tcx.mk_region(ty::ReErased)\n+                    self.tcx.types.re_erased\n                 }\n             }, |def, cur_substs| {\n                 let i = def.index as usize;\n@@ -1345,7 +1345,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         let substs = Substs::for_item(self.tcx,\n                                       impl_def_id,\n-                                      |_, _| self.tcx.mk_region(ty::ReErased),\n+                                      |_, _| self.tcx.types.re_erased,\n                                       |_, _| self.next_ty_var(\n                                         TypeVariableOrigin::SubstitutionPlaceholder(\n                                             self.tcx.def_span(impl_def_id))));"}, {"sha": "098e8c53a52c12c89582022d77d05da0afcaebd4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -1954,7 +1954,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //\n         // FIXME(#27579) all uses of this should be migrated to register_wf_obligation eventually\n         let cause = traits::ObligationCause::new(span, self.body_id, code);\n-        self.register_region_obligation(ty, self.tcx.mk_region(ty::ReEmpty), cause);\n+        self.register_region_obligation(ty, self.tcx.types.re_empty, cause);\n     }\n \n     /// Registers obligations that all types appearing in `substs` are well-formed.\n@@ -2513,7 +2513,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match lit.node {\n             ast::LitKind::Str(..) => tcx.mk_static_str(),\n             ast::LitKind::ByteStr(ref v) => {\n-                tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic),\n+                tcx.mk_imm_ref(tcx.types.re_static,\n                                 tcx.mk_array(tcx.types.u8, v.len()))\n             }\n             ast::LitKind::Byte(_) => tcx.types.u8,"}, {"sha": "dcef22da879646e6c4df0858d57d03f8ca948fae", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -457,7 +457,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             self.type_of_node_must_outlive(origin, id, var_region);\n \n             let typ = self.resolve_node_type(id);\n-            dropck::check_safety_of_destructor_if_necessary(self, typ, span, var_scope);\n+            let _ = dropck::check_safety_of_destructor_if_necessary(\n+                self, typ, span, var_scope);\n         })\n     }\n }\n@@ -995,10 +996,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 match *region {\n                     ty::ReScope(rvalue_scope) => {\n                         let typ = self.resolve_type(cmt.ty);\n-                        dropck::check_safety_of_destructor_if_necessary(self,\n-                                                                        typ,\n-                                                                        span,\n-                                                                        rvalue_scope);\n+                        let _ = dropck::check_safety_of_destructor_if_necessary(\n+                            self, typ, span, rvalue_scope);\n                     }\n                     ty::ReStatic => {}\n                     _ => {"}, {"sha": "35b2e8f8afcb8eabce30c843e995b83a8f7b449f", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -288,8 +288,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             let outside_ty = gcx.fold_regions(&inside_ty, &mut false, |r, _| {\n                 match *r {\n                     // 'static is valid everywhere.\n-                    ty::ReStatic |\n-                    ty::ReEmpty => gcx.mk_region(*r),\n+                    ty::ReStatic => gcx.types.re_static,\n+                    ty::ReEmpty => gcx.types.re_empty,\n \n                     // Free regions that come from early-bound regions are valid.\n                     ty::ReFree(ty::FreeRegion {\n@@ -307,7 +307,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                         span_err!(self.tcx().sess, span, E0564,\n                                   \"only named lifetimes are allowed in `impl Trait`, \\\n                                    but `{}` was found in the type `{}`\", r, inside_ty);\n-                        gcx.mk_region(ty::ReStatic)\n+                        gcx.types.re_static\n                     }\n \n                     ty::ReVar(_) |\n@@ -526,7 +526,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Resolver<'cx, 'gcx, 'tcx> {\n         match self.infcx.fully_resolve(&r) {\n             Ok(r) => r,\n             Err(_) => {\n-                self.tcx.mk_region(ty::ReStatic)\n+                self.tcx.types.re_static\n             }\n         }\n     }"}, {"sha": "660ce837043c1d02d6481d4396325e958730ed27", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -99,6 +99,8 @@ pub fn provide(providers: &mut Providers) {\n         trait_def,\n         adt_def,\n         impl_trait_ref,\n+        impl_polarity,\n+        is_foreign_item,\n         ..*providers\n     };\n }\n@@ -553,7 +555,8 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr());\n         prev_discr = Some(if let Some(e) = variant.node.disr_expr {\n             let expr_did = tcx.hir.local_def_id(e.node_id);\n-            let result = ty::queries::monomorphic_const_eval::get(tcx, variant.span, expr_did);\n+            let substs = Substs::empty();\n+            let result = ty::queries::const_eval::get(tcx, variant.span, (expr_did, substs));\n \n             // enum variant evaluation happens before the global constant check\n             // so we need to report the real error\n@@ -1132,6 +1135,16 @@ fn impl_trait_ref<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+fn impl_polarity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           def_id: DefId)\n+                           -> hir::ImplPolarity {\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    match tcx.hir.expect_item(node_id).node {\n+        hir::ItemImpl(_, polarity, ..) => polarity,\n+        ref item => bug!(\"trait_impl_polarity: {:?} not an impl\", item)\n+    }\n+}\n+\n // Is it marked with ?Sized\n fn is_unsized<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n                                 ast_bounds: &[hir::TyParamBound],\n@@ -1530,3 +1543,13 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n     let substs = Substs::identity_for_item(tcx, def_id);\n     tcx.mk_fn_def(def_id, substs, fty)\n }\n+\n+fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             def_id: DefId)\n+                             -> bool {\n+    match tcx.hir.get_if_local(def_id) {\n+        Some(hir_map::NodeForeignItem(..)) => true,\n+        Some(_) => false,\n+        _ => bug!(\"is_foreign_item applied to non-local def-id {:?}\", def_id)\n+    }\n+}"}, {"sha": "2bae6a0d9e11a7e1bfe1e7d42d4797bd6d637ebe", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -4154,7 +4154,6 @@ register_diagnostics! {\n //  E0248, // value used as a type, now reported earlier during resolution as E0412\n //  E0249,\n //  E0319, // trait impls for defaulted traits allowed just for structs/enums\n-    E0320, // recursive overflow during dropck\n //  E0372, // coherence not object safe\n     E0377, // the trait `CoerceUnsized` may only be implemented for a coercion\n            // between structures with the same definition"}, {"sha": "6016fd488f56c8938e025e8c1783e85bde6d59ea", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -487,7 +487,7 @@ impl hir::print::PpAnn for InlinedConst {\n }\n \n fn print_inlined_const(cx: &DocContext, did: DefId) -> String {\n-    let body = cx.tcx.sess.cstore.maybe_get_item_body(cx.tcx, did).unwrap();\n+    let body = cx.tcx.sess.cstore.item_body(cx.tcx, did);\n     let inlined = InlinedConst {\n         nested_bodies: cx.tcx.sess.cstore.item_body_nested_bodies(did)\n     };"}, {"sha": "85a28bbfbc6d0bb0e636356327fbde67030cb00c", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 296, "deletions": 46, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -32,6 +32,7 @@ use std::ascii::AsciiExt;\n use std::cell::RefCell;\n use std::collections::{HashMap, VecDeque};\n use std::default::Default;\n+use std::ffi::CString;\n use std::fmt::{self, Write};\n use std::str;\n use syntax::feature_gate::UnstableFeatures;\n@@ -40,21 +41,28 @@ use syntax::codemap::Span;\n use html::render::derive_id;\n use html::toc::TocBuilder;\n use html::highlight;\n+use html::escape::Escape;\n use test;\n \n use pulldown_cmark::{html, Event, Tag, Parser};\n use pulldown_cmark::{Options, OPTION_ENABLE_FOOTNOTES, OPTION_ENABLE_TABLES};\n \n+#[derive(PartialEq, Debug, Clone, Copy)]\n+pub enum RenderType {\n+    Hoedown,\n+    Pulldown,\n+}\n+\n /// A unit struct which has the `fmt::Display` trait implemented. When\n /// formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n // The second parameter is whether we need a shorter version or not.\n-pub struct Markdown<'a>(pub &'a str);\n+pub struct Markdown<'a>(pub &'a str, pub RenderType);\n /// A unit struct like `Markdown`, that renders the markdown with a\n /// table of contents.\n-pub struct MarkdownWithToc<'a>(pub &'a str);\n+pub struct MarkdownWithToc<'a>(pub &'a str, pub RenderType);\n /// A unit struct like `Markdown`, that renders the markdown escaping HTML tags.\n-pub struct MarkdownHtml<'a>(pub &'a str);\n+pub struct MarkdownHtml<'a>(pub &'a str, pub RenderType);\n /// A unit struct like `Markdown`, that renders only the first paragraph.\n pub struct MarkdownSummaryLine<'a>(pub &'a str);\n \n@@ -73,6 +81,14 @@ fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n     }\n }\n \n+/// Returns a new string with all consecutive whitespace collapsed into\n+/// single spaces.\n+///\n+/// Any leading or trailing whitespace will be trimmed.\n+fn collapse_whitespace(s: &str) -> String {\n+    s.split_whitespace().collect::<Vec<_>>().join(\" \")\n+}\n+\n /// Convert chars from a title for an id.\n ///\n /// \"Hello, world!\" -> \"hello-world\"\n@@ -368,6 +384,7 @@ const HOEDOWN_EXT_AUTOLINK: libc::c_uint = 1 << 3;\n const HOEDOWN_EXT_STRIKETHROUGH: libc::c_uint = 1 << 4;\n const HOEDOWN_EXT_SUPERSCRIPT: libc::c_uint = 1 << 8;\n const HOEDOWN_EXT_FOOTNOTES: libc::c_uint = 1 << 2;\n+const HOEDOWN_HTML_ESCAPE: libc::c_uint = 1 << 1;\n \n const HOEDOWN_EXTENSIONS: libc::c_uint =\n     HOEDOWN_EXT_NO_INTRA_EMPHASIS | HOEDOWN_EXT_TABLES |\n@@ -462,6 +479,13 @@ struct hoedown_buffer {\n     unit: libc::size_t,\n }\n \n+struct MyOpaque {\n+    dfltblk: extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n+                           *const hoedown_buffer, *const hoedown_renderer_data,\n+                           libc::size_t),\n+    toc_builder: Option<TocBuilder>,\n+}\n+\n extern {\n     fn hoedown_html_renderer_new(render_flags: libc::c_uint,\n                                  nesting_level: libc::c_int)\n@@ -478,6 +502,7 @@ extern {\n     fn hoedown_document_free(md: *mut hoedown_document);\n \n     fn hoedown_buffer_new(unit: libc::size_t) -> *mut hoedown_buffer;\n+    fn hoedown_buffer_puts(b: *mut hoedown_buffer, c: *const libc::c_char);\n     fn hoedown_buffer_free(b: *mut hoedown_buffer);\n }\n \n@@ -487,12 +512,214 @@ impl hoedown_buffer {\n     }\n }\n \n+pub fn render(w: &mut fmt::Formatter,\n+              s: &str,\n+              print_toc: bool,\n+              html_flags: libc::c_uint) -> fmt::Result {\n+    extern fn block(ob: *mut hoedown_buffer, orig_text: *const hoedown_buffer,\n+                    lang: *const hoedown_buffer, data: *const hoedown_renderer_data,\n+                    line: libc::size_t) {\n+        unsafe {\n+            if orig_text.is_null() { return }\n+\n+            let opaque = (*data).opaque as *mut hoedown_html_renderer_state;\n+            let my_opaque: &MyOpaque = &*((*opaque).opaque as *const MyOpaque);\n+            let text = (*orig_text).as_bytes();\n+            let origtext = str::from_utf8(text).unwrap();\n+            let origtext = origtext.trim_left();\n+            debug!(\"docblock: ==============\\n{:?}\\n=======\", text);\n+            let rendered = if lang.is_null() || origtext.is_empty() {\n+                false\n+            } else {\n+                let rlang = (*lang).as_bytes();\n+                let rlang = str::from_utf8(rlang).unwrap();\n+                if !LangString::parse(rlang).rust {\n+                    (my_opaque.dfltblk)(ob, orig_text, lang,\n+                                        opaque as *const hoedown_renderer_data,\n+                                        line);\n+                    true\n+                } else {\n+                    false\n+                }\n+            };\n+\n+            let lines = origtext.lines().filter(|l| {\n+                stripped_filtered_line(*l).is_none()\n+            });\n+            let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n+            if rendered { return }\n+            PLAYGROUND.with(|play| {\n+                // insert newline to clearly separate it from the\n+                // previous block so we can shorten the html output\n+                let mut s = String::from(\"\\n\");\n+                let playground_button = play.borrow().as_ref().and_then(|&(ref krate, ref url)| {\n+                    if url.is_empty() {\n+                        return None;\n+                    }\n+                    let test = origtext.lines().map(|l| {\n+                        stripped_filtered_line(l).unwrap_or(l)\n+                    }).collect::<Vec<&str>>().join(\"\\n\");\n+                    let krate = krate.as_ref().map(|s| &**s);\n+                    let test = test::maketest(&test, krate, false,\n+                                              &Default::default());\n+                    let channel = if test.contains(\"#![feature(\") {\n+                        \"&amp;version=nightly\"\n+                    } else {\n+                        \"\"\n+                    };\n+                    // These characters don't need to be escaped in a URI.\n+                    // FIXME: use a library function for percent encoding.\n+                    fn dont_escape(c: u8) -> bool {\n+                        (b'a' <= c && c <= b'z') ||\n+                        (b'A' <= c && c <= b'Z') ||\n+                        (b'0' <= c && c <= b'9') ||\n+                        c == b'-' || c == b'_' || c == b'.' ||\n+                        c == b'~' || c == b'!' || c == b'\\'' ||\n+                        c == b'(' || c == b')' || c == b'*'\n+                    }\n+                    let mut test_escaped = String::new();\n+                    for b in test.bytes() {\n+                        if dont_escape(b) {\n+                            test_escaped.push(char::from(b));\n+                        } else {\n+                            write!(test_escaped, \"%{:02X}\", b).unwrap();\n+                        }\n+                    }\n+                    Some(format!(\n+                        r#\"<a class=\"test-arrow\" target=\"_blank\" href=\"{}?code={}{}\">Run</a>\"#,\n+                        url, test_escaped, channel\n+                    ))\n+                });\n+                s.push_str(&highlight::render_with_highlighting(\n+                               &text,\n+                               Some(\"rust-example-rendered\"),\n+                               None,\n+                               playground_button.as_ref().map(String::as_str)));\n+                let output = CString::new(s).unwrap();\n+                hoedown_buffer_puts(ob, output.as_ptr());\n+            })\n+        }\n+    }\n+\n+    extern fn header(ob: *mut hoedown_buffer, text: *const hoedown_buffer,\n+                     level: libc::c_int, data: *const hoedown_renderer_data,\n+                     _: libc::size_t) {\n+        // hoedown does this, we may as well too\n+        unsafe { hoedown_buffer_puts(ob, \"\\n\\0\".as_ptr() as *const _); }\n+\n+        // Extract the text provided\n+        let s = if text.is_null() {\n+            \"\".to_owned()\n+        } else {\n+            let s = unsafe { (*text).as_bytes() };\n+            str::from_utf8(&s).unwrap().to_owned()\n+        };\n+\n+        // Discard '<em>', '<code>' tags and some escaped characters,\n+        // transform the contents of the header into a hyphenated string\n+        // without non-alphanumeric characters other than '-' and '_'.\n+        //\n+        // This is a terrible hack working around how hoedown gives us rendered\n+        // html for text rather than the raw text.\n+        let mut id = s.clone();\n+        let repl_sub = vec![\"<em>\", \"</em>\", \"<code>\", \"</code>\",\n+                            \"<strong>\", \"</strong>\",\n+                            \"&lt;\", \"&gt;\", \"&amp;\", \"&#39;\", \"&quot;\"];\n+        for sub in repl_sub {\n+            id = id.replace(sub, \"\");\n+        }\n+        let id = id.chars().filter_map(|c| {\n+            if c.is_alphanumeric() || c == '-' || c == '_' {\n+                if c.is_ascii() {\n+                    Some(c.to_ascii_lowercase())\n+                } else {\n+                    Some(c)\n+                }\n+            } else if c.is_whitespace() && c.is_ascii() {\n+                Some('-')\n+            } else {\n+                None\n+            }\n+        }).collect::<String>();\n+\n+        let opaque = unsafe { (*data).opaque as *mut hoedown_html_renderer_state };\n+        let opaque = unsafe { &mut *((*opaque).opaque as *mut MyOpaque) };\n+\n+        let id = derive_id(id);\n+\n+        let sec = opaque.toc_builder.as_mut().map_or(\"\".to_owned(), |builder| {\n+            format!(\"{} \", builder.push(level as u32, s.clone(), id.clone()))\n+        });\n+\n+        // Render the HTML\n+        let text = format!(\"<h{lvl} id='{id}' class='section-header'>\\\n+                           <a href='#{id}'>{sec}{}</a></h{lvl}>\",\n+                           s, lvl = level, id = id, sec = sec);\n+\n+        let text = CString::new(text).unwrap();\n+        unsafe { hoedown_buffer_puts(ob, text.as_ptr()) }\n+    }\n+\n+    extern fn codespan(\n+        ob: *mut hoedown_buffer,\n+        text: *const hoedown_buffer,\n+        _: *const hoedown_renderer_data,\n+        _: libc::size_t\n+    ) -> libc::c_int {\n+        let content = if text.is_null() {\n+            \"\".to_owned()\n+        } else {\n+            let bytes = unsafe { (*text).as_bytes() };\n+            let s = str::from_utf8(bytes).unwrap();\n+            collapse_whitespace(s)\n+        };\n+\n+        let content = format!(\"<code>{}</code>\", Escape(&content));\n+        let element = CString::new(content).unwrap();\n+        unsafe { hoedown_buffer_puts(ob, element.as_ptr()); }\n+        // Return anything except 0, which would mean \"also print the code span verbatim\".\n+        1\n+    }\n+\n+    unsafe {\n+        let ob = hoedown_buffer_new(DEF_OUNIT);\n+        let renderer = hoedown_html_renderer_new(html_flags, 0);\n+        let mut opaque = MyOpaque {\n+            dfltblk: (*renderer).blockcode.unwrap(),\n+            toc_builder: if print_toc {Some(TocBuilder::new())} else {None}\n+        };\n+        (*((*renderer).opaque as *mut hoedown_html_renderer_state)).opaque\n+                = &mut opaque as *mut _ as *mut libc::c_void;\n+        (*renderer).blockcode = Some(block);\n+        (*renderer).header = Some(header);\n+        (*renderer).codespan = Some(codespan);\n+\n+        let document = hoedown_document_new(renderer, HOEDOWN_EXTENSIONS, 16);\n+        hoedown_document_render(document, ob, s.as_ptr(),\n+                                s.len() as libc::size_t);\n+        hoedown_document_free(document);\n+\n+        hoedown_html_renderer_free(renderer);\n+\n+        let mut ret = opaque.toc_builder.map_or(Ok(()), |builder| {\n+            write!(w, \"<nav id=\\\"TOC\\\">{}</nav>\", builder.into_toc())\n+        });\n+\n+        if ret.is_ok() {\n+            let buf = (*ob).as_bytes();\n+            ret = w.write_str(str::from_utf8(buf).unwrap());\n+        }\n+        hoedown_buffer_free(ob);\n+        ret\n+    }\n+}\n+\n pub fn old_find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Span) {\n     extern fn block(_ob: *mut hoedown_buffer,\n                     text: *const hoedown_buffer,\n                     lang: *const hoedown_buffer,\n                     data: *const hoedown_renderer_data,\n-                    _line: libc::size_t) {\n+                    line: libc::size_t) {\n         unsafe {\n             if text.is_null() { return }\n             let block_info = if lang.is_null() {\n@@ -510,8 +737,19 @@ pub fn old_find_testable_code(doc: &str, tests: &mut ::test::Collector, position\n             let lines = text.lines().map(|l| {\n                 stripped_filtered_line(l).unwrap_or(l)\n             });\n+            let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n             let filename = tests.get_filename();\n-            tests.add_old_test(lines.collect::<Vec<&str>>().join(\"\\n\"), filename);\n+\n+            if tests.render_type == RenderType::Hoedown {\n+                let line = tests.get_line() + line;\n+                tests.add_test(text.to_owned(),\n+                               block_info.should_panic, block_info.no_run,\n+                               block_info.ignore, block_info.test_harness,\n+                               block_info.compile_fail, block_info.error_codes,\n+                               line, filename);\n+            } else {\n+                tests.add_old_test(text, filename);\n+            }\n         }\n     }\n \n@@ -533,7 +771,6 @@ pub fn old_find_testable_code(doc: &str, tests: &mut ::test::Collector, position\n     }\n \n     tests.set_position(position);\n-\n     unsafe {\n         let ob = hoedown_buffer_new(DEF_OUNIT);\n         let renderer = hoedown_html_renderer_new(0, 0);\n@@ -702,72 +939,84 @@ impl LangString {\n \n impl<'a> fmt::Display for Markdown<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let Markdown(md) = *self;\n+        let Markdown(md, render_type) = *self;\n+\n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n+        if render_type == RenderType::Hoedown {\n+            render(fmt, md, false, 0)\n+        } else {\n+            let mut opts = Options::empty();\n+            opts.insert(OPTION_ENABLE_TABLES);\n+            opts.insert(OPTION_ENABLE_FOOTNOTES);\n \n-        let mut opts = Options::empty();\n-        opts.insert(OPTION_ENABLE_TABLES);\n-        opts.insert(OPTION_ENABLE_FOOTNOTES);\n-\n-        let p = Parser::new_ext(md, opts);\n+            let p = Parser::new_ext(md, opts);\n \n-        let mut s = String::with_capacity(md.len() * 3 / 2);\n+            let mut s = String::with_capacity(md.len() * 3 / 2);\n \n-        html::push_html(&mut s,\n-                        Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, None))));\n+            html::push_html(&mut s,\n+                            Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, None))));\n \n-        fmt.write_str(&s)\n+            fmt.write_str(&s)\n+        }\n     }\n }\n \n impl<'a> fmt::Display for MarkdownWithToc<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let MarkdownWithToc(md) = *self;\n+        let MarkdownWithToc(md, render_type) = *self;\n \n-        let mut opts = Options::empty();\n-        opts.insert(OPTION_ENABLE_TABLES);\n-        opts.insert(OPTION_ENABLE_FOOTNOTES);\n+        if render_type == RenderType::Hoedown {\n+            render(fmt, md, true, 0)\n+        } else {\n+            let mut opts = Options::empty();\n+            opts.insert(OPTION_ENABLE_TABLES);\n+            opts.insert(OPTION_ENABLE_FOOTNOTES);\n \n-        let p = Parser::new_ext(md, opts);\n+            let p = Parser::new_ext(md, opts);\n \n-        let mut s = String::with_capacity(md.len() * 3 / 2);\n+            let mut s = String::with_capacity(md.len() * 3 / 2);\n \n-        let mut toc = TocBuilder::new();\n+            let mut toc = TocBuilder::new();\n \n-        html::push_html(&mut s,\n-                        Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, Some(&mut toc)))));\n+            html::push_html(&mut s,\n+                            Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, Some(&mut toc)))));\n \n-        write!(fmt, \"<nav id=\\\"TOC\\\">{}</nav>\", toc.into_toc())?;\n+            write!(fmt, \"<nav id=\\\"TOC\\\">{}</nav>\", toc.into_toc())?;\n \n-        fmt.write_str(&s)\n+            fmt.write_str(&s)\n+        }\n     }\n }\n \n impl<'a> fmt::Display for MarkdownHtml<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let MarkdownHtml(md) = *self;\n+        let MarkdownHtml(md, render_type) = *self;\n+\n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n+        if render_type == RenderType::Hoedown {\n+            render(fmt, md, false, HOEDOWN_HTML_ESCAPE)\n+        } else {\n+            let mut opts = Options::empty();\n+            opts.insert(OPTION_ENABLE_TABLES);\n+            opts.insert(OPTION_ENABLE_FOOTNOTES);\n \n-        let mut opts = Options::empty();\n-        opts.insert(OPTION_ENABLE_TABLES);\n-        opts.insert(OPTION_ENABLE_FOOTNOTES);\n-\n-        let p = Parser::new_ext(md, opts);\n+            let p = Parser::new_ext(md, opts);\n \n-        // Treat inline HTML as plain text.\n-        let p = p.map(|event| match event {\n-            Event::Html(text) | Event::InlineHtml(text) => Event::Text(text),\n-            _ => event\n-        });\n+            // Treat inline HTML as plain text.\n+            let p = p.map(|event| match event {\n+                Event::Html(text) | Event::InlineHtml(text) => Event::Text(text),\n+                _ => event\n+            });\n \n-        let mut s = String::with_capacity(md.len() * 3 / 2);\n+            let mut s = String::with_capacity(md.len() * 3 / 2);\n \n-        html::push_html(&mut s,\n-                        Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, None))));\n+            html::push_html(&mut s,\n+                            Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, None))));\n \n-        fmt.write_str(&s)\n+            fmt.write_str(&s)\n+        }\n     }\n }\n \n@@ -841,6 +1090,7 @@ pub fn plain_summary_line(md: &str) -> String {\n mod tests {\n     use super::{LangString, Markdown, MarkdownHtml};\n     use super::plain_summary_line;\n+    use super::RenderType;\n     use html::render::reset_ids;\n \n     #[test]\n@@ -881,14 +1131,14 @@ mod tests {\n     #[test]\n     fn issue_17736() {\n         let markdown = \"# title\";\n-        format!(\"{}\", Markdown(markdown));\n+        format!(\"{}\", Markdown(markdown, RenderType::Pulldown));\n         reset_ids(true);\n     }\n \n     #[test]\n     fn test_header() {\n         fn t(input: &str, expect: &str) {\n-            let output = format!(\"{}\", Markdown(input));\n+            let output = format!(\"{}\", Markdown(input, RenderType::Pulldown));\n             assert_eq!(output, expect, \"original: {}\", input);\n             reset_ids(true);\n         }\n@@ -910,7 +1160,7 @@ mod tests {\n     #[test]\n     fn test_header_ids_multiple_blocks() {\n         fn t(input: &str, expect: &str) {\n-            let output = format!(\"{}\", Markdown(input));\n+            let output = format!(\"{}\", Markdown(input, RenderType::Pulldown));\n             assert_eq!(output, expect, \"original: {}\", input);\n         }\n \n@@ -951,7 +1201,7 @@ mod tests {\n     #[test]\n     fn test_markdown_html_escape() {\n         fn t(input: &str, expect: &str) {\n-            let output = format!(\"{}\", MarkdownHtml(input));\n+            let output = format!(\"{}\", MarkdownHtml(input, RenderType::Pulldown));\n             assert_eq!(output, expect, \"original: {}\", input);\n         }\n "}, {"sha": "57d71e6c4e004e37b7542d6eb1eecf117c72f598", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -72,7 +72,7 @@ use html::format::{TyParamBounds, WhereClause, href, AbiSpace};\n use html::format::{VisSpace, Method, UnsafetySpace, MutableSpace};\n use html::format::fmt_impl_for_trait_page;\n use html::item_type::ItemType;\n-use html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine};\n+use html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine, RenderType};\n use html::{highlight, layout};\n \n /// A pair of name and its optional document.\n@@ -98,6 +98,7 @@ pub struct Context {\n     /// publicly reused items to redirect to the right location.\n     pub render_redirect_pages: bool,\n     pub shared: Arc<SharedContext>,\n+    pub render_type: RenderType,\n }\n \n pub struct SharedContext {\n@@ -433,7 +434,8 @@ pub fn run(mut krate: clean::Crate,\n            dst: PathBuf,\n            passes: FxHashSet<String>,\n            css_file_extension: Option<PathBuf>,\n-           renderinfo: RenderInfo) -> Result<(), Error> {\n+           renderinfo: RenderInfo,\n+           render_type: RenderType) -> Result<(), Error> {\n     let src_root = match krate.src.parent() {\n         Some(p) => p.to_path_buf(),\n         None => PathBuf::new(),\n@@ -495,6 +497,7 @@ pub fn run(mut krate: clean::Crate,\n         dst: dst,\n         render_redirect_pages: false,\n         shared: Arc::new(scx),\n+        render_type: render_type,\n     };\n \n     // Crawl the crate to build various caches used for the output\n@@ -1638,11 +1641,12 @@ fn plain_summary_line(s: Option<&str>) -> String {\n \n fn document(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item) -> fmt::Result {\n     document_stability(w, cx, item)?;\n-    document_full(w, item)?;\n+    document_full(w, item, cx.render_type)?;\n     Ok(())\n }\n \n-fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLink) -> fmt::Result {\n+fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLink,\n+                  render_type: RenderType) -> fmt::Result {\n     if let Some(s) = item.doc_value() {\n         let markdown = if s.contains('\\n') {\n             format!(\"{} [Read more]({})\",\n@@ -1651,7 +1655,7 @@ fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLin\n             format!(\"{}\", &plain_summary_line(Some(s)))\n         };\n         write!(w, \"<div class='docblock'>{}</div>\",\n-               Markdown(&markdown))?;\n+               Markdown(&markdown, render_type))?;\n     }\n     Ok(())\n }\n@@ -1681,10 +1685,11 @@ fn get_doc_value(item: &clean::Item) -> Option<&str> {\n     }\n }\n \n-fn document_full(w: &mut fmt::Formatter, item: &clean::Item) -> fmt::Result {\n+fn document_full(w: &mut fmt::Formatter, item: &clean::Item,\n+                 render_type: RenderType) -> fmt::Result {\n     if let Some(s) = get_doc_value(item) {\n         write!(w, \"<div class='docblock'>{}</div>\",\n-               Markdown(&format!(\"{}{}\", md_render_assoc_item(item), s)))?;\n+               Markdown(&format!(\"{}{}\", md_render_assoc_item(item), s), render_type))?;\n     }\n     Ok(())\n }\n@@ -1872,7 +1877,13 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                        </tr>\",\n                        name = *myitem.name.as_ref().unwrap(),\n                        stab_docs = stab_docs,\n-                       docs = MarkdownSummaryLine(doc_value),\n+                       docs = if cx.render_type == RenderType::Hoedown {\n+                           format!(\"{}\",\n+                                   shorter(Some(&Markdown(doc_value,\n+                                                          RenderType::Hoedown).to_string())))\n+                       } else {\n+                           format!(\"{}\", MarkdownSummaryLine(doc_value))\n+                       },\n                        class = myitem.type_(),\n                        stab = myitem.stability_class().unwrap_or(\"\".to_string()),\n                        unsafety_flag = unsafety_flag,\n@@ -1915,7 +1926,9 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n             } else {\n                 String::new()\n             };\n-            let text = format!(\"Deprecated{}{}\", since, MarkdownHtml(&deprecated_reason));\n+            let text = format!(\"Deprecated{}{}\",\n+                               since,\n+                               MarkdownHtml(&deprecated_reason, cx.render_type));\n             stability.push(format!(\"<div class='stab deprecated'>{}</div>\", text))\n         };\n \n@@ -1944,7 +1957,8 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n                     let text = format!(\"<summary><span class=microscope>\ud83d\udd2c</span> \\\n                                         This is a nightly-only experimental API. {}\\\n                                         </summary>{}\",\n-                                       unstable_extra, MarkdownHtml(&stab.unstable_reason));\n+                                       unstable_extra,\n+                                       MarkdownHtml(&stab.unstable_reason, cx.render_type));\n                     stability.push(format!(\"<div class='stab unstable'><details>{}</details></div>\",\n                                    text));\n                 }\n@@ -1964,7 +1978,7 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n             String::new()\n         };\n \n-        let text = format!(\"Deprecated{}{}\", since, MarkdownHtml(&note));\n+        let text = format!(\"Deprecated{}{}\", since, MarkdownHtml(&note, cx.render_type));\n         stability.push(format!(\"<div class='stab deprecated'>{}</div>\", text))\n     }\n \n@@ -2900,7 +2914,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         write!(w, \"</span>\")?;\n         write!(w, \"</h3>\\n\")?;\n         if let Some(ref dox) = i.impl_item.doc_value() {\n-            write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox))?;\n+            write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox, cx.render_type))?;\n         }\n     }\n \n@@ -2999,19 +3013,19 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                         // because impls can't have a stability.\n                         document_stability(w, cx, it)?;\n                         if get_doc_value(item).is_some() {\n-                            document_full(w, item)?;\n+                            document_full(w, item, cx.render_type)?;\n                         } else {\n                             // In case the item isn't documented,\n                             // provide short documentation from the trait.\n-                            document_short(w, it, link)?;\n+                            document_short(w, it, link, cx.render_type)?;\n                         }\n                     }\n                 } else {\n                     document(w, cx, item)?;\n                 }\n             } else {\n                 document_stability(w, cx, item)?;\n-                document_short(w, item, link)?;\n+                document_short(w, item, link, cx.render_type)?;\n             }\n         }\n         Ok(())"}, {"sha": "2a6134fde5c3d8f8e9aaba8b30ee207590052184", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -93,6 +93,8 @@ pub mod test;\n \n use clean::AttributesExt;\n \n+use html::markdown::RenderType;\n+\n struct Output {\n     krate: clean::Crate,\n     renderinfo: html::render::RenderInfo,\n@@ -169,6 +171,7 @@ pub fn opts() -> Vec<RustcOptGroup> {\n                         \"URL to send code snippets to, may be reset by --markdown-playground-url \\\n                          or `#![doc(html_playground_url=...)]`\",\n                         \"URL\")),\n+        unstable(optflag(\"\", \"enable-commonmark\", \"to enable commonmark doc rendering/testing\")),\n     ]\n }\n \n@@ -250,6 +253,12 @@ pub fn main_args(args: &[String]) -> isize {\n     let css_file_extension = matches.opt_str(\"e\").map(|s| PathBuf::from(&s));\n     let cfgs = matches.opt_strs(\"cfg\");\n \n+    let render_type = if matches.opt_present(\"enable-commonmark\") {\n+        RenderType::Pulldown\n+    } else {\n+        RenderType::Hoedown\n+    };\n+\n     if let Some(ref p) = css_file_extension {\n         if !p.is_file() {\n             writeln!(\n@@ -273,15 +282,17 @@ pub fn main_args(args: &[String]) -> isize {\n \n     match (should_test, markdown_input) {\n         (true, true) => {\n-            return markdown::test(input, cfgs, libs, externs, test_args, maybe_sysroot)\n+            return markdown::test(input, cfgs, libs, externs, test_args, maybe_sysroot, render_type)\n         }\n         (true, false) => {\n-            return test::run(input, cfgs, libs, externs, test_args, crate_name, maybe_sysroot)\n+            return test::run(input, cfgs, libs, externs, test_args, crate_name, maybe_sysroot,\n+                             render_type)\n         }\n         (false, true) => return markdown::render(input,\n                                                  output.unwrap_or(PathBuf::from(\"doc\")),\n                                                  &matches, &external_html,\n-                                                 !matches.opt_present(\"markdown-no-toc\")),\n+                                                 !matches.opt_present(\"markdown-no-toc\"),\n+                                                 render_type),\n         (false, false) => {}\n     }\n \n@@ -295,7 +306,8 @@ pub fn main_args(args: &[String]) -> isize {\n                                   output.unwrap_or(PathBuf::from(\"doc\")),\n                                   passes.into_iter().collect(),\n                                   css_file_extension,\n-                                  renderinfo)\n+                                  renderinfo,\n+                                  render_type)\n                     .expect(\"failed to generate documentation\");\n                 0\n             }"}, {"sha": "b9ed0eeaef736715d814e34a0d04e51c10399855", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -26,6 +26,7 @@ use html::render::reset_ids;\n use html::escape::Escape;\n use html::markdown;\n use html::markdown::{Markdown, MarkdownWithToc, find_testable_code, old_find_testable_code};\n+use html::markdown::RenderType;\n use test::{TestOptions, Collector};\n \n /// Separate any lines at the start of the file that begin with `# ` or `%`.\n@@ -50,7 +51,8 @@ fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n /// Render `input` (e.g. \"foo.md\") into an HTML file in `output`\n /// (e.g. output = \"bar\" => \"bar/foo.html\").\n pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n-              external_html: &ExternalHtml, include_toc: bool) -> isize {\n+              external_html: &ExternalHtml, include_toc: bool,\n+              render_type: RenderType) -> isize {\n     let input_p = Path::new(input);\n     output.push(input_p.file_stem().unwrap());\n     output.set_extension(\"html\");\n@@ -94,9 +96,9 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n     reset_ids(false);\n \n     let rendered = if include_toc {\n-        format!(\"{}\", MarkdownWithToc(text))\n+        format!(\"{}\", MarkdownWithToc(text, render_type))\n     } else {\n-        format!(\"{}\", Markdown(text))\n+        format!(\"{}\", Markdown(text, render_type))\n     };\n \n     let err = write!(\n@@ -147,7 +149,8 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n \n /// Run any tests/code examples in the markdown file `input`.\n pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n-            mut test_args: Vec<String>, maybe_sysroot: Option<PathBuf>) -> isize {\n+            mut test_args: Vec<String>, maybe_sysroot: Option<PathBuf>,\n+            render_type: RenderType) -> isize {\n     let input_str = match load_string(input) {\n         Ok(s) => s,\n         Err(LoadStringError::ReadFail) => return 1,\n@@ -158,7 +161,8 @@ pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n     opts.no_crate_inject = true;\n     let mut collector = Collector::new(input.to_string(), cfgs, libs, externs,\n                                        true, opts, maybe_sysroot, None,\n-                                       Some(input.to_owned()));\n+                                       Some(input.to_owned()),\n+                                       render_type);\n     old_find_testable_code(&input_str, &mut collector, DUMMY_SP);\n     find_testable_code(&input_str, &mut collector, DUMMY_SP);\n     test_args.insert(0, \"rustdoctest\".to_string());"}, {"sha": "5b9ab304db0a9667ff27843166d7baca1aabf8d0", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -43,7 +43,7 @@ use errors;\n use errors::emitter::ColorConfig;\n \n use clean::Attributes;\n-use html::markdown;\n+use html::markdown::{self, RenderType};\n \n #[derive(Clone, Default)]\n pub struct TestOptions {\n@@ -57,7 +57,8 @@ pub fn run(input: &str,\n            externs: Externs,\n            mut test_args: Vec<String>,\n            crate_name: Option<String>,\n-           maybe_sysroot: Option<PathBuf>)\n+           maybe_sysroot: Option<PathBuf>,\n+           render_type: RenderType)\n            -> isize {\n     let input_path = PathBuf::from(input);\n     let input = config::Input::File(input_path.clone());\n@@ -106,7 +107,8 @@ pub fn run(input: &str,\n                                        opts,\n                                        maybe_sysroot,\n                                        Some(codemap),\n-                                       None);\n+                                       None,\n+                                       render_type);\n \n     {\n         let dep_graph = DepGraph::new(false);\n@@ -396,12 +398,15 @@ pub struct Collector {\n     position: Span,\n     codemap: Option<Rc<CodeMap>>,\n     filename: Option<String>,\n+    // to be removed when hoedown will be removed as well\n+    pub render_type: RenderType,\n }\n \n impl Collector {\n     pub fn new(cratename: String, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n                use_headers: bool, opts: TestOptions, maybe_sysroot: Option<PathBuf>,\n-               codemap: Option<Rc<CodeMap>>, filename: Option<String>) -> Collector {\n+               codemap: Option<Rc<CodeMap>>, filename: Option<String>,\n+               render_type: RenderType) -> Collector {\n         Collector {\n             tests: Vec::new(),\n             old_tests: HashMap::new(),\n@@ -418,6 +423,7 @@ impl Collector {\n             position: DUMMY_SP,\n             codemap: codemap,\n             filename: filename,\n+            render_type: render_type,\n         }\n     }\n \n@@ -458,20 +464,22 @@ impl Collector {\n                     as_test_harness: bool, compile_fail: bool, error_codes: Vec<String>,\n                     line: usize, filename: String) {\n         let name = self.generate_name(line, &filename);\n-        let name_beg = self.generate_name_beginning(&filename);\n-        let mut found = false;\n         // to be removed when hoedown is removed\n-        let test = test.trim().to_owned();\n-        if let Some(entry) = self.old_tests.get_mut(&name_beg) {\n-            found = entry.remove_item(&test).is_some();\n-        }\n-        if !found {\n-            let _ = writeln!(&mut io::stderr(),\n-                             \"WARNING: {} Code block is not currently run as a test, but will in \\\n-                              future versions of rustdoc. Please ensure this code block is a \\\n-                              runnable test, or use the `ignore` directive.\",\n-                             name);\n-            return\n+        if self.render_type == RenderType::Pulldown {\n+            let name_beg = self.generate_name_beginning(&filename);\n+            let mut found = false;\n+            let test = test.trim().to_owned();\n+            if let Some(entry) = self.old_tests.get_mut(&name_beg) {\n+                found = entry.remove_item(&test).is_some();\n+            }\n+            if !found {\n+                let _ = writeln!(&mut io::stderr(),\n+                                 \"WARNING: {} Code block is not currently run as a test, but will \\\n+                                  in future versions of rustdoc. Please ensure this code block is \\\n+                                  a runnable test, or use the `ignore` directive.\",\n+                                 name);\n+                return\n+            }\n         }\n         let cfgs = self.cfgs.clone();\n         let libs = self.libs.clone();\n@@ -587,10 +595,15 @@ impl<'a, 'hir> HirCollector<'a, 'hir> {\n         attrs.unindent_doc_comments();\n         if let Some(doc) = attrs.doc_value() {\n             self.collector.cnt = 0;\n-            markdown::old_find_testable_code(doc, self.collector,\n+            if self.collector.render_type == RenderType::Pulldown {\n+                markdown::old_find_testable_code(doc, self.collector,\n+                                                 attrs.span.unwrap_or(DUMMY_SP));\n+                markdown::find_testable_code(doc, self.collector,\n                                              attrs.span.unwrap_or(DUMMY_SP));\n-            markdown::find_testable_code(doc, self.collector,\n-                                         attrs.span.unwrap_or(DUMMY_SP));\n+            } else {\n+                markdown::old_find_testable_code(doc, self.collector,\n+                                                 attrs.span.unwrap_or(DUMMY_SP));\n+            }\n         }\n \n         nested(self);"}, {"sha": "51d127f8ba79a246c33745356c94ab0888f4bf98", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -1377,7 +1377,7 @@ pub struct IterMut<'a, K: 'a, V: 'a> {\n \n /// An owning iterator over the entries of a `HashMap`.\n ///\n-/// This `struct` is created by the [`into_iter`] method on [`HashMap`]\n+/// This `struct` is created by the [`into_iter`] method on [`HashMap`][`HashMap`]\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n /// [`into_iter`]: struct.HashMap.html#method.into_iter\n@@ -2017,13 +2017,6 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n         self.elem.read().0\n     }\n \n-    /// Deprecated, renamed to `remove_entry`\n-    #[unstable(feature = \"map_entry_recover_keys\", issue = \"34285\")]\n-    #[rustc_deprecated(since = \"1.12.0\", reason = \"renamed to `remove_entry`\")]\n-    pub fn remove_pair(self) -> (K, V) {\n-        self.remove_entry()\n-    }\n-\n     /// Take the ownership of the key and value from the map.\n     ///\n     /// # Examples"}, {"sha": "7215e1bde8503e1988f14e3bcbcde373a58ab4a1", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -890,7 +890,7 @@ pub struct Iter<'a, K: 'a> {\n \n /// An owning iterator over the items of a `HashSet`.\n ///\n-/// This `struct` is created by the [`into_iter`] method on [`HashSet`]\n+/// This `struct` is created by the [`into_iter`] method on [`HashSet`][`HashSet`]\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n /// [`HashSet`]: struct.HashSet.html"}, {"sha": "4abad7e24f8107a6b2690399190104eec2bf07ba", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 1, "deletions": 205, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -22,8 +22,6 @@ use core::num;\n #[cfg(not(test))]\n use intrinsics;\n #[cfg(not(test))]\n-use libc::c_int;\n-#[cfg(not(test))]\n use num::FpCategory;\n \n \n@@ -73,8 +71,6 @@ mod cmath {\n         pub fn atan2f(a: c_float, b: c_float) -> c_float;\n         pub fn atanf(n: c_float) -> c_float;\n         pub fn coshf(n: c_float) -> c_float;\n-        pub fn frexpf(n: c_float, value: &mut c_int) -> c_float;\n-        pub fn ldexpf(x: c_float, n: c_int) -> c_float;\n         pub fn sinhf(n: c_float) -> c_float;\n         pub fn tanf(n: c_float) -> c_float;\n         pub fn tanhf(n: c_float) -> c_float;\n@@ -84,7 +80,7 @@ mod cmath {\n     pub use self::shims::*;\n     #[cfg(target_env = \"msvc\")]\n     mod shims {\n-        use libc::{c_float, c_int};\n+        use libc::c_float;\n \n         #[inline]\n         pub unsafe fn acosf(n: c_float) -> c_float {\n@@ -111,20 +107,6 @@ mod cmath {\n             f64::cosh(n as f64) as c_float\n         }\n \n-        #[inline]\n-        #[allow(deprecated)]\n-        pub unsafe fn frexpf(x: c_float, value: &mut c_int) -> c_float {\n-            let (a, b) = f64::frexp(x as f64);\n-            *value = b as c_int;\n-            a as c_float\n-        }\n-\n-        #[inline]\n-        #[allow(deprecated)]\n-        pub unsafe fn ldexpf(x: c_float, n: c_int) -> c_float {\n-            f64::ldexp(x as f64, n as isize) as c_float\n-        }\n-\n         #[inline]\n         pub unsafe fn sinhf(n: c_float) -> c_float {\n             f64::sinh(n as f64) as c_float\n@@ -244,40 +226,6 @@ impl f32 {\n     #[inline]\n     pub fn classify(self) -> FpCategory { num::Float::classify(self) }\n \n-    /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.\n-    /// The original number can be recovered by `sign * mantissa * 2 ^ exponent`.\n-    /// The floating point encoding is documented in the [Reference][floating-point].\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// use std::f32;\n-    ///\n-    /// let num = 2.0f32;\n-    ///\n-    /// // (8388608, -22, 1)\n-    /// let (mantissa, exponent, sign) = num.integer_decode();\n-    /// let sign_f = sign as f32;\n-    /// let mantissa_f = mantissa as f32;\n-    /// let exponent_f = num.powf(exponent as f32);\n-    ///\n-    /// // 1 * 8388608 * 2^(-22) == 2\n-    /// let abs_difference = (sign_f * mantissa_f * exponent_f - num).abs();\n-    ///\n-    /// assert!(abs_difference <= f32::EPSILON);\n-    /// ```\n-    /// [floating-point]: ../reference/types.html#machine-types\n-    #[unstable(feature = \"float_extras\", reason = \"signature is undecided\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    #[allow(deprecated)]\n-    pub fn integer_decode(self) -> (u64, i16, i8) {\n-        num::Float::integer_decode(self)\n-    }\n-\n     /// Returns the largest integer less than or equal to a number.\n     ///\n     /// ```\n@@ -712,89 +660,6 @@ impl f32 {\n     #[inline]\n     pub fn to_radians(self) -> f32 { num::Float::to_radians(self) }\n \n-    /// Constructs a floating point number of `x*2^exp`.\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// use std::f32;\n-    /// // 3*2^2 - 12 == 0\n-    /// let abs_difference = (f32::ldexp(3.0, 2) - 12.0).abs();\n-    ///\n-    /// assert!(abs_difference <= f32::EPSILON);\n-    /// ```\n-    #[unstable(feature = \"float_extras\",\n-               reason = \"pending integer conventions\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    pub fn ldexp(x: f32, exp: isize) -> f32 {\n-        unsafe { cmath::ldexpf(x, exp as c_int) }\n-    }\n-\n-    /// Breaks the number into a normalized fraction and a base-2 exponent,\n-    /// satisfying:\n-    ///\n-    ///  * `self = x * 2^exp`\n-    ///  * `0.5 <= abs(x) < 1.0`\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// use std::f32;\n-    ///\n-    /// let x = 4.0f32;\n-    ///\n-    /// // (1/2)*2^3 -> 1 * 8/2 -> 4.0\n-    /// let f = x.frexp();\n-    /// let abs_difference_0 = (f.0 - 0.5).abs();\n-    /// let abs_difference_1 = (f.1 as f32 - 3.0).abs();\n-    ///\n-    /// assert!(abs_difference_0 <= f32::EPSILON);\n-    /// assert!(abs_difference_1 <= f32::EPSILON);\n-    /// ```\n-    #[unstable(feature = \"float_extras\",\n-               reason = \"pending integer conventions\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    pub fn frexp(self) -> (f32, isize) {\n-        unsafe {\n-            let mut exp = 0;\n-            let x = cmath::frexpf(self, &mut exp);\n-            (x, exp as isize)\n-        }\n-    }\n-\n-    /// Returns the next representable floating-point value in the direction of\n-    /// `other`.\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// use std::f32;\n-    ///\n-    /// let x = 1.0f32;\n-    ///\n-    /// let abs_diff = (x.next_after(2.0) - 1.00000011920928955078125_f32).abs();\n-    ///\n-    /// assert!(abs_diff <= f32::EPSILON);\n-    /// ```\n-    #[unstable(feature = \"float_extras\",\n-               reason = \"unsure about its place in the world\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    pub fn next_after(self, other: f32) -> f32 {\n-        unsafe { cmath::nextafterf(self, other) }\n-    }\n-\n     /// Returns the maximum of the two numbers.\n     ///\n     /// ```\n@@ -1462,23 +1327,6 @@ mod tests {\n         assert_eq!(1e-38f32.classify(), Fp::Subnormal);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_integer_decode() {\n-        assert_eq!(3.14159265359f32.integer_decode(), (13176795, -22, 1));\n-        assert_eq!((-8573.5918555f32).integer_decode(), (8779358, -10, -1));\n-        assert_eq!(2f32.powf(100.0).integer_decode(), (8388608, 77, 1));\n-        assert_eq!(0f32.integer_decode(), (0, -150, 1));\n-        assert_eq!((-0f32).integer_decode(), (0, -150, -1));\n-        assert_eq!(INFINITY.integer_decode(), (8388608, 105, 1));\n-        assert_eq!(NEG_INFINITY.integer_decode(), (8388608, 105, -1));\n-\n-        // Ignore the \"sign\" (quiet / signalling flag) of NAN.\n-        // It can vary between runtime operations and LLVM folding.\n-        let (nan_m, nan_e, _nan_s) = NAN.integer_decode();\n-        assert_eq!((nan_m, nan_e), (12582912, 105));\n-    }\n-\n     #[test]\n     fn test_floor() {\n         assert_approx_eq!(1.0f32.floor(), 1.0f32);\n@@ -1790,58 +1638,6 @@ mod tests {\n         assert_eq!(neg_inf.to_radians(), neg_inf);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_ldexp() {\n-        let f1 = 2.0f32.powi(-123);\n-        let f2 = 2.0f32.powi(-111);\n-        let f3 = 1.75 * 2.0f32.powi(-12);\n-        assert_eq!(f32::ldexp(1f32, -123), f1);\n-        assert_eq!(f32::ldexp(1f32, -111), f2);\n-        assert_eq!(f32::ldexp(1.75f32, -12), f3);\n-\n-        assert_eq!(f32::ldexp(0f32, -123), 0f32);\n-        assert_eq!(f32::ldexp(-0f32, -123), -0f32);\n-\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        let nan: f32 = f32::NAN;\n-        assert_eq!(f32::ldexp(inf, -123), inf);\n-        assert_eq!(f32::ldexp(neg_inf, -123), neg_inf);\n-        assert!(f32::ldexp(nan, -123).is_nan());\n-    }\n-\n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_frexp() {\n-        let f1 = 2.0f32.powi(-123);\n-        let f2 = 2.0f32.powi(-111);\n-        let f3 = 1.75 * 2.0f32.powi(-123);\n-        let (x1, exp1) = f1.frexp();\n-        let (x2, exp2) = f2.frexp();\n-        let (x3, exp3) = f3.frexp();\n-        assert_eq!((x1, exp1), (0.5f32, -122));\n-        assert_eq!((x2, exp2), (0.5f32, -110));\n-        assert_eq!((x3, exp3), (0.875f32, -122));\n-        assert_eq!(f32::ldexp(x1, exp1), f1);\n-        assert_eq!(f32::ldexp(x2, exp2), f2);\n-        assert_eq!(f32::ldexp(x3, exp3), f3);\n-\n-        assert_eq!(0f32.frexp(), (0f32, 0));\n-        assert_eq!((-0f32).frexp(), (-0f32, 0));\n-    }\n-\n-    #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n-    #[allow(deprecated)]\n-    fn test_frexp_nowin() {\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        let nan: f32 = f32::NAN;\n-        assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n-        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n-        assert!(match nan.frexp() { (x, _) => x.is_nan() })\n-    }\n-\n     #[test]\n     fn test_asinh() {\n         assert_eq!(0.0f32.asinh(), 0.0f32);"}, {"sha": "82e3903eec7b13d8270b39115d3402fa7ee9a689", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -22,8 +22,6 @@ use core::num;\n #[cfg(not(test))]\n use intrinsics;\n #[cfg(not(test))]\n-use libc::c_int;\n-#[cfg(not(test))]\n use num::FpCategory;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -188,36 +186,6 @@ impl f64 {\n     #[inline]\n     pub fn classify(self) -> FpCategory { num::Float::classify(self) }\n \n-    /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.\n-    /// The original number can be recovered by `sign * mantissa * 2 ^ exponent`.\n-    /// The floating point encoding is documented in the [Reference][floating-point].\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// let num = 2.0f64;\n-    ///\n-    /// // (8388608, -22, 1)\n-    /// let (mantissa, exponent, sign) = num.integer_decode();\n-    /// let sign_f = sign as f64;\n-    /// let mantissa_f = mantissa as f64;\n-    /// let exponent_f = num.powf(exponent as f64);\n-    ///\n-    /// // 1 * 8388608 * 2^(-22) == 2\n-    /// let abs_difference = (sign_f * mantissa_f * exponent_f - num).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    /// [floating-point]: ../reference/types.html#machine-types\n-    #[unstable(feature = \"float_extras\", reason = \"signature is undecided\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    #[allow(deprecated)]\n-    pub fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }\n-\n     /// Returns the largest integer less than or equal to a number.\n     ///\n     /// ```\n@@ -606,84 +574,6 @@ impl f64 {\n     #[inline]\n     pub fn to_radians(self) -> f64 { num::Float::to_radians(self) }\n \n-    /// Constructs a floating point number of `x*2^exp`.\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// // 3*2^2 - 12 == 0\n-    /// let abs_difference = (f64::ldexp(3.0, 2) - 12.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"float_extras\",\n-               reason = \"pending integer conventions\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    pub fn ldexp(x: f64, exp: isize) -> f64 {\n-        unsafe { cmath::ldexp(x, exp as c_int) }\n-    }\n-\n-    /// Breaks the number into a normalized fraction and a base-2 exponent,\n-    /// satisfying:\n-    ///\n-    ///  * `self = x * 2^exp`\n-    ///  * `0.5 <= abs(x) < 1.0`\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// let x = 4.0_f64;\n-    ///\n-    /// // (1/2)*2^3 -> 1 * 8/2 -> 4.0\n-    /// let f = x.frexp();\n-    /// let abs_difference_0 = (f.0 - 0.5).abs();\n-    /// let abs_difference_1 = (f.1 as f64 - 3.0).abs();\n-    ///\n-    /// assert!(abs_difference_0 < 1e-10);\n-    /// assert!(abs_difference_1 < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"float_extras\",\n-               reason = \"pending integer conventions\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    pub fn frexp(self) -> (f64, isize) {\n-        unsafe {\n-            let mut exp = 0;\n-            let x = cmath::frexp(self, &mut exp);\n-            (x, exp as isize)\n-        }\n-    }\n-\n-    /// Returns the next representable floating-point value in the direction of\n-    /// `other`.\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// let x = 1.0f64;\n-    ///\n-    /// let abs_diff = (x.next_after(2.0) - 1.0000000000000002220446049250313_f64).abs();\n-    ///\n-    /// assert!(abs_diff < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"float_extras\",\n-               reason = \"unsure about its place in the world\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    pub fn next_after(self, other: f64) -> f64 {\n-        unsafe { cmath::nextafter(self, other) }\n-    }\n-\n     /// Returns the maximum of the two numbers.\n     ///\n     /// ```\n@@ -1353,23 +1243,6 @@ mod tests {\n         assert_eq!(1e-308f64.classify(), Fp::Subnormal);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_integer_decode() {\n-        assert_eq!(3.14159265359f64.integer_decode(), (7074237752028906, -51, 1));\n-        assert_eq!((-8573.5918555f64).integer_decode(), (4713381968463931, -39, -1));\n-        assert_eq!(2f64.powf(100.0).integer_decode(), (4503599627370496, 48, 1));\n-        assert_eq!(0f64.integer_decode(), (0, -1075, 1));\n-        assert_eq!((-0f64).integer_decode(), (0, -1075, -1));\n-        assert_eq!(INFINITY.integer_decode(), (4503599627370496, 972, 1));\n-        assert_eq!(NEG_INFINITY.integer_decode(), (4503599627370496, 972, -1));\n-\n-        // Ignore the \"sign\" (quiet / signalling flag) of NAN.\n-        // It can vary between runtime operations and LLVM folding.\n-        let (nan_m, nan_e, _nan_s) = NAN.integer_decode();\n-        assert_eq!((nan_m, nan_e), (6755399441055744, 972));\n-    }\n-\n     #[test]\n     fn test_floor() {\n         assert_approx_eq!(1.0f64.floor(), 1.0f64);\n@@ -1681,58 +1554,6 @@ mod tests {\n         assert_eq!(neg_inf.to_radians(), neg_inf);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_ldexp() {\n-        let f1 = 2.0f64.powi(-123);\n-        let f2 = 2.0f64.powi(-111);\n-        let f3 = 1.75 * 2.0f64.powi(-12);\n-        assert_eq!(f64::ldexp(1f64, -123), f1);\n-        assert_eq!(f64::ldexp(1f64, -111), f2);\n-        assert_eq!(f64::ldexp(1.75f64, -12), f3);\n-\n-        assert_eq!(f64::ldexp(0f64, -123), 0f64);\n-        assert_eq!(f64::ldexp(-0f64, -123), -0f64);\n-\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n-        let nan: f64 = NAN;\n-        assert_eq!(f64::ldexp(inf, -123), inf);\n-        assert_eq!(f64::ldexp(neg_inf, -123), neg_inf);\n-        assert!(f64::ldexp(nan, -123).is_nan());\n-    }\n-\n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_frexp() {\n-        let f1 = 2.0f64.powi(-123);\n-        let f2 = 2.0f64.powi(-111);\n-        let f3 = 1.75 * 2.0f64.powi(-123);\n-        let (x1, exp1) = f1.frexp();\n-        let (x2, exp2) = f2.frexp();\n-        let (x3, exp3) = f3.frexp();\n-        assert_eq!((x1, exp1), (0.5f64, -122));\n-        assert_eq!((x2, exp2), (0.5f64, -110));\n-        assert_eq!((x3, exp3), (0.875f64, -122));\n-        assert_eq!(f64::ldexp(x1, exp1), f1);\n-        assert_eq!(f64::ldexp(x2, exp2), f2);\n-        assert_eq!(f64::ldexp(x3, exp3), f3);\n-\n-        assert_eq!(0f64.frexp(), (0f64, 0));\n-        assert_eq!((-0f64).frexp(), (-0f64, 0));\n-    }\n-\n-    #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n-    #[allow(deprecated)]\n-    fn test_frexp_nowin() {\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n-        let nan: f64 = NAN;\n-        assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n-        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n-        assert!(match nan.frexp() { (x, _) => x.is_nan() })\n-    }\n-\n     #[test]\n     fn test_asinh() {\n         assert_eq!(0.0f64.asinh(), 0.0f64);"}, {"sha": "70225da5f3355c2150b722b4a3bdc20f15deaa7d", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -248,7 +248,6 @@\n #![feature(allow_internal_unstable)]\n #![feature(asm)]\n #![feature(associated_consts)]\n-#![feature(borrow_state)]\n #![feature(box_syntax)]\n #![feature(cfg_target_has_atomic)]\n #![feature(cfg_target_thread_local)]\n@@ -263,7 +262,6 @@\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n-#![feature(float_extras)]\n #![feature(float_from_str_radix)]\n #![feature(fn_traits)]\n #![feature(fnbox)]\n@@ -319,7 +317,6 @@\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]\n #![feature(vec_push_all)]\n-#![feature(zero_one)]\n #![cfg_attr(test, feature(update_panic_count))]\n #![cfg_attr(stage0, feature(pub_restricted))]\n #![cfg_attr(test, feature(float_bits_conv))]"}, {"sha": "ff89887ac92c3c59369a75ffcf5e9df20d3f224e", "filename": "src/libstd/num.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibstd%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibstd%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -16,9 +16,6 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-pub use core::num::{Zero, One};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::num::{FpCategory, ParseIntError, ParseFloatError, TryFromIntError};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "9d66430bc93032a59bf5953027646bd9730bc07a", "filename": "src/libstd/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -10,7 +10,7 @@\n \n //! Cross-platform path manipulation.\n //!\n-//! This module provides two types, [`PathBuf`] and [`Path`] (akin to [`String`]\n+//! This module provides two types, [`PathBuf`] and [`Path`][`Path`] (akin to [`String`]\n //! and [`str`]), for working with paths abstractly. These types are thin wrappers\n //! around [`OsString`] and [`OsStr`] respectively, meaning that they work directly\n //! on strings according to the local platform's path syntax."}, {"sha": "6c8839224f77dafb5f00f039ec22b18a09f50d5c", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -452,7 +452,7 @@ pub struct SendError<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n /// An error returned from the [`recv`] function on a [`Receiver`].\n ///\n /// The [`recv`] operation can only fail if the sending half of a\n-/// [`channel`] (or [`sync_channel`]) is disconnected, implying that no further\n+/// [`channel`][`channel`] (or [`sync_channel`]) is disconnected, implying that no further\n /// messages will ever be received.\n ///\n /// [`recv`]: struct.Receiver.html#method.recv"}, {"sha": "1baf0d1b54ce1f7530dd6ab9736134be4661c80d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 64, "deletions": 37, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -152,6 +152,7 @@ fn maybe_append(mut lhs: Vec<Attribute>, rhs: Option<Vec<Attribute>>)\n enum PrevTokenKind {\n     DocComment,\n     Comma,\n+    Plus,\n     Interpolated,\n     Eof,\n     Other,\n@@ -1061,6 +1062,7 @@ impl<'a> Parser<'a> {\n         self.prev_token_kind = match self.token {\n             token::DocComment(..) => PrevTokenKind::DocComment,\n             token::Comma => PrevTokenKind::Comma,\n+            token::BinOp(token::Plus) => PrevTokenKind::Plus,\n             token::Interpolated(..) => PrevTokenKind::Interpolated,\n             token::Eof => PrevTokenKind::Eof,\n             _ => PrevTokenKind::Other,\n@@ -1354,20 +1356,26 @@ impl<'a> Parser<'a> {\n                     break;\n                 }\n             }\n+            let trailing_plus = self.prev_token_kind == PrevTokenKind::Plus;\n             self.expect(&token::CloseDelim(token::Paren))?;\n \n             if ts.len() == 1 && !last_comma {\n                 let ty = ts.into_iter().nth(0).unwrap().unwrap();\n+                let maybe_bounds = allow_plus && self.token == token::BinOp(token::Plus);\n                 match ty.node {\n-                    // Accept `(Trait1) + Trait2 + 'a` for backward compatibility (#39318).\n-                    TyKind::Path(None, ref path)\n-                            if allow_plus && self.token == token::BinOp(token::Plus) => {\n-                        self.bump(); // `+`\n-                        let pt = PolyTraitRef::new(Vec::new(), path.clone(), lo.to(self.prev_span));\n-                        let mut bounds = vec![TraitTyParamBound(pt, TraitBoundModifier::None)];\n-                        bounds.append(&mut self.parse_ty_param_bounds()?);\n-                        TyKind::TraitObject(bounds)\n+                    // `(TY_BOUND_NOPAREN) + BOUND + ...`.\n+                    TyKind::Path(None, ref path) if maybe_bounds => {\n+                        self.parse_remaining_bounds(Vec::new(), path.clone(), lo, true)?\n                     }\n+                    TyKind::TraitObject(ref bounds)\n+                            if maybe_bounds && bounds.len() == 1 && !trailing_plus => {\n+                        let path = match bounds[0] {\n+                            TraitTyParamBound(ref pt, ..) => pt.trait_ref.path.clone(),\n+                            _ => self.bug(\"unexpected lifetime bound\"),\n+                        };\n+                        self.parse_remaining_bounds(Vec::new(), path, lo, true)?\n+                    }\n+                    // `(TYPE)`\n                     _ => TyKind::Paren(P(ty))\n                 }\n             } else {\n@@ -1418,11 +1426,8 @@ impl<'a> Parser<'a> {\n                 // Just a type path or bound list (trait object type) starting with a trait.\n                 //   `Type`\n                 //   `Trait1 + Trait2 + 'a`\n-                if allow_plus && self.eat(&token::BinOp(token::Plus)) {\n-                    let poly_trait = PolyTraitRef::new(Vec::new(), path, lo.to(self.prev_span));\n-                    let mut bounds = vec![TraitTyParamBound(poly_trait, TraitBoundModifier::None)];\n-                    bounds.append(&mut self.parse_ty_param_bounds()?);\n-                    TyKind::TraitObject(bounds)\n+                if allow_plus && self.check(&token::BinOp(token::Plus)) {\n+                    self.parse_remaining_bounds(Vec::new(), path, lo, true)?\n                 } else {\n                     TyKind::Path(None, path)\n                 }\n@@ -1440,12 +1445,8 @@ impl<'a> Parser<'a> {\n                 self.parse_ty_bare_fn(lifetime_defs)?\n             } else {\n                 let path = self.parse_path(PathStyle::Type)?;\n-                let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_span));\n-                let mut bounds = vec![TraitTyParamBound(poly_trait, TraitBoundModifier::None)];\n-                if allow_plus && self.eat(&token::BinOp(token::Plus)) {\n-                    bounds.append(&mut self.parse_ty_param_bounds()?)\n-                }\n-                TyKind::TraitObject(bounds)\n+                let parse_plus = allow_plus && self.check(&token::BinOp(token::Plus));\n+                self.parse_remaining_bounds(lifetime_defs, path, lo, parse_plus)?\n             }\n         } else if self.eat_keyword(keywords::Impl) {\n             // FIXME: figure out priority of `+` in `impl Trait1 + Trait2` (#34511).\n@@ -1468,6 +1469,17 @@ impl<'a> Parser<'a> {\n         Ok(P(ty))\n     }\n \n+    fn parse_remaining_bounds(&mut self, lifetime_defs: Vec<LifetimeDef>, path: ast::Path,\n+                              lo: Span, parse_plus: bool) -> PResult<'a, TyKind> {\n+        let poly_trait_ref = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_span));\n+        let mut bounds = vec![TraitTyParamBound(poly_trait_ref, TraitBoundModifier::None)];\n+        if parse_plus {\n+            self.bump(); // `+`\n+            bounds.append(&mut self.parse_ty_param_bounds()?);\n+        }\n+        Ok(TyKind::TraitObject(bounds))\n+    }\n+\n     fn maybe_recover_from_bad_type_plus(&mut self, allow_plus: bool, ty: &Ty) -> PResult<'a, ()> {\n         // Do not add `+` to expected tokens.\n         if !allow_plus || self.token != token::BinOp(token::Plus) {\n@@ -4070,28 +4082,43 @@ impl<'a> Parser<'a> {\n     // Parse bounds of a type parameter `BOUND + BOUND + BOUND`, possibly with trailing `+`.\n     // BOUND = TY_BOUND | LT_BOUND\n     // LT_BOUND = LIFETIME (e.g. `'a`)\n-    // TY_BOUND = [?] [for<LT_PARAM_DEFS>] SIMPLE_PATH (e.g. `?for<'a: 'b> m::Trait<'a>`)\n+    // TY_BOUND = TY_BOUND_NOPAREN | (TY_BOUND_NOPAREN)\n+    // TY_BOUND_NOPAREN = [?] [for<LT_PARAM_DEFS>] SIMPLE_PATH (e.g. `?for<'a: 'b> m::Trait<'a>`)\n     fn parse_ty_param_bounds_common(&mut self, allow_plus: bool) -> PResult<'a, TyParamBounds> {\n         let mut bounds = Vec::new();\n         loop {\n-            let question = if self.eat(&token::Question) { Some(self.prev_span) } else { None };\n-            if self.check_lifetime() {\n-                if let Some(question_span) = question {\n-                    self.span_err(question_span,\n-                                  \"`?` may only modify trait bounds, not lifetime bounds\");\n-                }\n-                bounds.push(RegionTyParamBound(self.expect_lifetime()));\n-            } else if self.check_keyword(keywords::For) || self.check_path() {\n-                let lo = self.span;\n-                let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n-                let path = self.parse_path(PathStyle::Type)?;\n-                let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_span));\n-                let modifier = if question.is_some() {\n-                    TraitBoundModifier::Maybe\n+            let is_bound_start = self.check_path() || self.check_lifetime() ||\n+                                 self.check(&token::Question) ||\n+                                 self.check_keyword(keywords::For) ||\n+                                 self.check(&token::OpenDelim(token::Paren));\n+            if is_bound_start {\n+                let has_parens = self.eat(&token::OpenDelim(token::Paren));\n+                let question = if self.eat(&token::Question) { Some(self.prev_span) } else { None };\n+                if self.token.is_lifetime() {\n+                    if let Some(question_span) = question {\n+                        self.span_err(question_span,\n+                                      \"`?` may only modify trait bounds, not lifetime bounds\");\n+                    }\n+                    bounds.push(RegionTyParamBound(self.expect_lifetime()));\n                 } else {\n-                    TraitBoundModifier::None\n-                };\n-                bounds.push(TraitTyParamBound(poly_trait, modifier));\n+                    let lo = self.span;\n+                    let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n+                    let path = self.parse_path(PathStyle::Type)?;\n+                    let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_span));\n+                    let modifier = if question.is_some() {\n+                        TraitBoundModifier::Maybe\n+                    } else {\n+                        TraitBoundModifier::None\n+                    };\n+                    bounds.push(TraitTyParamBound(poly_trait, modifier));\n+                }\n+                if has_parens {\n+                    self.expect(&token::CloseDelim(token::Paren))?;\n+                    if let Some(&RegionTyParamBound(..)) = bounds.last() {\n+                        self.span_err(self.prev_span,\n+                                      \"parenthesized lifetime bounds are not supported\");\n+                    }\n+                }\n             } else {\n                 break\n             }"}, {"sha": "d7e2cb6d9a50ba6c8e3fafe8034b62e7442d2569", "filename": "src/test/codegen/drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Fcodegen%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Fcodegen%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fdrop.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -36,7 +36,7 @@ pub fn droppy() {\n // CHECK-NOT: call{{.*}}drop{{.*}}SomeUniqueName\n // CHECK: invoke{{.*}}drop{{.*}}SomeUniqueName\n // CHECK: invoke{{.*}}drop{{.*}}SomeUniqueName\n-// CHECK: invoke{{.*}}drop{{.*}}SomeUniqueName\n+// CHECK: call{{.*}}drop{{.*}}SomeUniqueName\n // CHECK-NOT: {{(call|invoke).*}}drop{{.*}}SomeUniqueName\n // The next line checks for the } that ends the function definition\n // CHECK-LABEL: {{^[}]}}"}, {"sha": "9fd600b32e6c71c6473d4c9878c43615a8f2483e", "filename": "src/test/codegen/personality_lifetimes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Fcodegen%2Fpersonality_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Fcodegen%2Fpersonality_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpersonality_lifetimes.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -37,5 +37,6 @@ pub fn test() {\n     // CHECK: bitcast{{.*}}personalityslot\n     // CHECK-NEXT: call void @llvm.lifetime.start\n     might_unwind();\n+    let _t = S;\n     might_unwind();\n }"}, {"sha": "0745ac02d0723e620e82856f217cf666e1a21175", "filename": "src/test/compile-fail/const-call.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Fcompile-fail%2Fconst-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Fcompile-fail%2Fconst-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-call.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -17,6 +17,4 @@ fn f(x: usize) -> usize {\n fn main() {\n     let _ = [0; f(2)];\n     //~^ ERROR calls in constants are limited to constant functions\n-    //~| ERROR constant evaluation error [E0080]\n-    //~| non-constant path in constant expression\n }"}, {"sha": "71cac3edbc188beb9542952db26707d3d81c05d0", "filename": "src/test/compile-fail/const-pattern-not-const-evaluable.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -10,21 +10,22 @@\n \n #![feature(const_fn)]\n \n+#[derive(PartialEq, Eq)]\n enum Cake {\n     BlackForest,\n     Marmor,\n }\n use Cake::*;\n \n-const BOO: (Cake, Cake) = (Marmor, BlackForest);\n+struct Pair<A, B>(A, B);\n+\n+const BOO: Pair<Cake, Cake> = Pair(Marmor, BlackForest);\n //~^ ERROR: constant evaluation error [E0080]\n-//~| unimplemented constant expression: enum variants\n+//~| unimplemented constant expression: tuple struct constructors\n const FOO: Cake = BOO.1;\n \n const fn foo() -> Cake {\n     Marmor\n-        //~^ ERROR: constant evaluation error [E0080]\n-        //~| unimplemented constant expression: enum variants\n }\n \n const WORKS: Cake = Marmor;\n@@ -34,7 +35,7 @@ const GOO: Cake = foo();\n fn main() {\n     match BlackForest {\n         FOO => println!(\"hi\"), //~ NOTE: for pattern here\n-        GOO => println!(\"meh\"), //~ NOTE: for pattern here\n+        GOO => println!(\"meh\"),\n         WORKS => println!(\"m\u00f6p\"),\n         _ => println!(\"bye\"),\n     }"}, {"sha": "b7f767f109c0c7437ce421135f1c358bb7c16cfa", "filename": "src/test/compile-fail/issue-39559.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -28,10 +28,6 @@ pub struct Vector<T, D: Dim> {\n fn main() {\n     let array: [usize; Dim3::dim()]\n     //~^ ERROR calls in constants are limited to constant functions\n-    //~| ERROR constant evaluation error\n-    //~| non-constant path in constant expression\n         = [0; Dim3::dim()];\n         //~^ ERROR calls in constants are limited to constant functions\n-        //~| ERROR constant evaluation error\n-        //~| non-constant path in constant expression\n }"}, {"sha": "1fb3b7c4ee120011142d88e045e36e8611977e6f", "filename": "src/test/compile-fail/issue-41394.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Fcompile-fail%2Fissue-41394.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Fcompile-fail%2Fissue-41394.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-41394.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_name = \"foo\"]\n+enum Foo {\n+    A = \"\" + 1\n+    //~^ ERROR binary operation `+` cannot be applied to type `&'static str`\n+}\n \n-// ignore-tidy-end-whitespace\n+enum Bar {\n+    A = Foo::A as isize\n+}\n \n-// @has foo/fn.f.html\n-// @has - '<p>hard break:<br />'\n-// @has - 'after hard break</p>'\n-/// hard break:  \n-/// after hard break\n-pub fn f() {}\n+fn main() {}", "previous_filename": "src/test/rustdoc/check-hard-break.rs"}, {"sha": "9dde5268c0878b0f0caa475b9bdc2635cc38b097", "filename": "src/test/parse-fail/bound-single-question-mark.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Fparse-fail%2Fbound-single-question-mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Fparse-fail%2Fbound-single-question-mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fbound-single-question-mark.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+fn f<T: ?>() {} //~ ERROR expected identifier, found `>`"}, {"sha": "a44c0c3f32fef0b46b8d3f4e8b6f697cb9abd6ca", "filename": "src/test/parse-fail/trait-object-bad-parens.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Fparse-fail%2Ftrait-object-bad-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Fparse-fail%2Ftrait-object-bad-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-object-bad-parens.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n+\n+fn main() {\n+    let _: Box<((Copy)) + Copy>;\n+    //~^ ERROR expected a path on the left-hand side of `+`, not `((Copy))`\n+    let _: Box<(Copy + Copy) + Copy>;\n+    //~^ ERROR expected a path on the left-hand side of `+`, not `( Copy + Copy)`\n+    let _: Box<(Copy +) + Copy>;\n+    //~^ ERROR expected a path on the left-hand side of `+`, not `( Copy)`\n+}"}, {"sha": "6be62d966eb9490232aaeacb5c71713db222cdba", "filename": "src/test/parse-fail/trait-object-lifetime-parens.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Fparse-fail%2Ftrait-object-lifetime-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Fparse-fail%2Ftrait-object-lifetime-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-object-lifetime-parens.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n+\n+fn f<T: Copy + ('a)>() {} //~ ERROR parenthesized lifetime bounds are not supported\n+\n+fn main() {\n+    let _: Box<Copy + ('a)>; //~ ERROR parenthesized lifetime bounds are not supported\n+    let _: Box<('a) + Copy>; //~ ERROR expected type, found `'a`\n+}"}, {"sha": "dc44f4f3fb1353db6bd3acad024a71655ffc528c", "filename": "src/test/parse-fail/trait-object-trait-parens.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Fparse-fail%2Ftrait-object-trait-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Fparse-fail%2Ftrait-object-trait-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-object-trait-parens.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+fn f<T: (Copy) + (?Sized) + (for<'a> Trait<'a>)>() {}\n+\n+fn main() {\n+    let _: Box<(Copy) + (?Sized) + (for<'a> Trait<'a>)>;\n+    let _: Box<(?Sized) + (for<'a> Trait<'a>) + (Copy)>;\n+    let _: Box<(for<'a> Trait<'a>) + (Copy) + (?Sized)>;\n+}\n+\n+FAIL //~ ERROR"}, {"sha": "f06b81279ac4135658dc7f343dbb087279aec110", "filename": "src/test/run-pass/auxiliary/issue-41394.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-41394.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-41394.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-41394.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+#[repr(u32)]\n+pub enum Foo {\n+    Foo = Private::Variant as u32\n+}\n+\n+#[repr(u8)]\n+enum Private {\n+    Variant = 42\n+}\n+\n+#[inline(always)]\n+pub fn foo() -> Foo {\n+    Foo::Foo\n+}"}, {"sha": "104ab6e19db672db5e51b2bf8001b9a4b821cdf8", "filename": "src/test/run-pass/const-pattern-variant.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Frun-pass%2Fconst-pattern-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Frun-pass%2Fconst-pattern-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-pattern-variant.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_fn)]\n+\n+#[derive(PartialEq, Eq)]\n+enum Cake {\n+    BlackForest,\n+    Marmor,\n+}\n+use Cake::*;\n+\n+const BOO: (Cake, Cake) = (Marmor, BlackForest);\n+const FOO: Cake = BOO.1;\n+\n+const fn foo() -> Cake {\n+    Marmor\n+}\n+\n+const WORKS: Cake = Marmor;\n+\n+const GOO: Cake = foo();\n+\n+fn main() {\n+    match BlackForest {\n+        FOO => println!(\"hi\"),\n+        GOO => println!(\"meh\"),\n+        WORKS => println!(\"m\u00f6p\"),\n+        _ => println!(\"bye\"),\n+    }\n+}"}, {"sha": "3f5546ce83ddf49a79c3daf69dc7b9f7f31b352a", "filename": "src/test/run-pass/issue-23898.rs", "status": "renamed", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Frun-pass%2Fissue-23898.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Frun-pass%2Fissue-23898.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23898.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -8,13 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Note: This test is checking that we forbid a coding pattern that\n-// Issue #5873 explicitly wants to allow.\n+// Note: This test was used to demonstrate #5873 (now #23898).\n \n enum State { ST_NULL, ST_WHITESPACE }\n \n fn main() {\n     [State::ST_NULL; (State::ST_WHITESPACE as usize)];\n-    //~^ ERROR constant evaluation error\n-    //~| unimplemented constant expression: enum variants\n }", "previous_filename": "src/test/compile-fail/non-constant-enum-for-vec-repeat.rs"}, {"sha": "798905599a852f73b364863c22aec70e6d3701bd", "filename": "src/test/run-pass/issue-41394.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Frun-pass%2Fissue-41394.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Frun-pass%2Fissue-41394.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-41394.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-41394.rs\n+\n+extern crate issue_41394 as lib;\n+\n+fn main() {\n+    assert_eq!(lib::foo() as u32, 42);\n+}"}, {"sha": "17ea5b9a79489855c314adc38a5f985f53c5f5d5", "filename": "src/test/run-pass/issue-8460.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8460.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -9,11 +9,22 @@\n // except according to those terms.\n \n // ignore-emscripten no threads support\n-#![feature(rustc_attrs, zero_one)]\n+#![feature(rustc_attrs)]\n \n-use std::num::Zero;\n use std::thread;\n \n+trait Int {\n+    fn zero() -> Self;\n+    fn one() -> Self;\n+}\n+macro_rules! doit {\n+    ($($t:ident)*) => ($(impl Int for $t {\n+        fn zero() -> $t { 0 }\n+        fn one() -> $t { 1 }\n+    })*)\n+}\n+doit! { i8 i16 i32 i64 isize }\n+\n macro_rules! check {\n     ($($e:expr),*) => {\n         $(assert!(thread::spawn({\n@@ -24,21 +35,21 @@ macro_rules! check {\n \n fn main() {\n     check![\n-        isize::min_value() / -1,\n-        i8::min_value() / -1,\n-        i16::min_value() / -1,\n-        i32::min_value() / -1,\n-        i64::min_value() / -1,\n+        isize::min_value() / -isize::one(),\n+        i8::min_value() / -i8::one(),\n+        i16::min_value() / -i16::one(),\n+        i32::min_value() / -i32::one(),\n+        i64::min_value() / -i64::one(),\n         1isize / isize::zero(),\n         1i8 / i8::zero(),\n         1i16 / i16::zero(),\n         1i32 / i32::zero(),\n         1i64 / i64::zero(),\n-        isize::min_value() % -1,\n-        i8::min_value() % -1,\n-        i16::min_value() % -1,\n-        i32::min_value() % -1,\n-        i64::min_value() % -1,\n+        isize::min_value() % -isize::one(),\n+        i8::min_value() % -i8::one(),\n+        i16::min_value() % -i16::one(),\n+        i32::min_value() % -i32::one(),\n+        i64::min_value() % -i64::one(),\n         1isize % isize::zero(),\n         1i8 % i8::zero(),\n         1i16 % i16::zero(),"}, {"sha": "ea154590deef0af432ff2ce192a7cb76ee60be33", "filename": "src/test/run-pass/sync-send-iterators-in-libcollections.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -10,13 +10,12 @@\n \n #![allow(warnings)]\n #![feature(collections)]\n-#![feature(drain, enumset, collections_bound, btree_range, vecmap)]\n+#![feature(drain, collections_bound, btree_range, vecmap)]\n \n extern crate collections;\n \n use collections::BinaryHeap;\n use collections::{BTreeMap, BTreeSet};\n-use collections::EnumSet;\n use collections::LinkedList;\n use collections::String;\n use collections::Vec;\n@@ -25,7 +24,6 @@ use std::collections::HashMap;\n use std::collections::HashSet;\n \n use collections::Bound::Included;\n-use collections::enum_set::CLike;\n use std::mem;\n \n fn is_sync<T>(_: T) where T: Sync {}\n@@ -76,21 +74,6 @@ fn main() {\n \n     all_sync_send!(LinkedList::<usize>::new(), iter, iter_mut, into_iter);\n \n-    #[derive(Copy, Clone)]\n-    #[repr(usize)]\n-    #[allow(dead_code)]\n-    enum Foo { A, B, C }\n-    impl CLike for Foo {\n-        fn to_usize(&self) -> usize {\n-            *self as usize\n-        }\n-\n-        fn from_usize(v: usize) -> Foo {\n-            unsafe { mem::transmute(v) }\n-        }\n-    }\n-    all_sync_send!(EnumSet::<Foo>::new(), iter);\n-\n     all_sync_send!(VecDeque::<usize>::new(), iter, iter_mut, into_iter);\n     is_sync_send!(VecDeque::<usize>::new(), drain(..));\n "}, {"sha": "7a0b4c6aaca4922b62eddf73c0ab65a0096b2fca", "filename": "src/test/run-pass/union/union-transmute.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Frun-pass%2Funion%2Funion-transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Frun-pass%2Funion%2Funion-transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-transmute.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core_float)]\n-#![feature(float_extras)]\n #![feature(untagged_unions)]\n \n extern crate core;\n-use core::num::Float;\n+use core::f32;\n \n union U {\n     a: (u8, u8),\n@@ -33,8 +31,8 @@ fn main() {\n         assert_eq!(u.a, (2, 2));\n \n         let mut w = W { a: 0b0_11111111_00000000000000000000000 };\n-        assert_eq!(w.b, f32::infinity());\n-        w.b = f32::neg_infinity();\n+        assert_eq!(w.b, f32::INFINITY);\n+        w.b = f32::NEG_INFINITY;\n         assert_eq!(w.a, 0b1_11111111_00000000000000000000000);\n     }\n }"}, {"sha": "aed6986c5fe5d380b71a1fefc1fff776e0186ebe", "filename": "src/test/run-pass/while-let.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Frun-pass%2Fwhile-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftest%2Frun-pass%2Fwhile-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-let.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n \n-#![feature(binary_heap_extras)]\n-\n use std::collections::BinaryHeap;\n \n fn make_pq() -> BinaryHeap<isize> {"}, {"sha": "46542677857fc797cc0461d335502f13d25a45ad", "filename": "src/test/rustdoc/check-rule-image-footnote.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Frustdoc%2Fcheck-rule-image-footnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3ea01bcae85a3ed0c90ca5603cd88c469172c3/src%2Ftest%2Frustdoc%2Fcheck-rule-image-footnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcheck-rule-image-footnote.rs?ref=8a3ea01bcae85a3ed0c90ca5603cd88c469172c3", "patch": "@@ -1,44 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![crate_name = \"foo\"]\n-\n-// ignore-tidy-linelength\n-\n-// @has foo/fn.f.html\n-// @has - '<p>markdown test</p>'\n-// @has - '<p>this is a <a href=\"https://example.com\" title=\"this is a title\">link</a>.</p>'\n-// @has - '<hr />'\n-// @has - '<p>a footnote<sup id=\"supref1\"><a href=\"#ref1\">1</a></sup>.</p>'\n-// @has - '<p>another footnote<sup id=\"supref2\"><a href=\"#ref2\">2</a></sup>.</p>'\n-// @has - '<p><img src=\"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\" alt=\"Rust\" /></p>'\n-// @has - '<div class=\"footnotes\"><hr><ol><li id=\"ref1\">'\n-// @has - '<p>Thing&nbsp;<a href=\"#supref1\" rev=\"footnote\">\u21a9</a></p></li><li id=\"ref2\">'\n-// @has - '<p>Another Thing&nbsp;<a href=\"#supref2\" rev=\"footnote\">\u21a9</a></p></li></ol></div>'\n-/// markdown test\n-///\n-/// this is a [link].\n-///\n-/// [link]: https://example.com \"this is a title\"\n-///\n-/// -----------\n-///\n-/// a footnote[^footnote].\n-///\n-/// another footnote[^footnotebis].\n-///\n-/// [^footnote]: Thing\n-///\n-///\n-/// [^footnotebis]: Another Thing\n-///\n-///\n-/// ![Rust](https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png)\n-pub fn f() {}"}, {"sha": "ca383b5add011533e4bba7cd61057ac6c68946f1", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b085f06a41004ebf36d87afa3548f8b60861a/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=158b085f06a41004ebf36d87afa3548f8b60861a", "patch": "@@ -24,7 +24,7 @@ use std::path::PathBuf;\n \n use syntax::diagnostics::metadata::{get_metadata_dir, ErrorMetadataMap, ErrorMetadata};\n \n-use rustdoc::html::markdown::{Markdown, PLAYGROUND};\n+use rustdoc::html::markdown::{Markdown, PLAYGROUND, RenderType};\n use rustc_serialize::json;\n \n enum OutputFormat {\n@@ -100,7 +100,7 @@ impl Formatter for HTMLFormatter {\n \n         // Description rendered as markdown.\n         match info.description {\n-            Some(ref desc) => write!(output, \"{}\", Markdown(desc))?,\n+            Some(ref desc) => write!(output, \"{}\", Markdown(desc, RenderType::Hoedown))?,\n             None => write!(output, \"<p>No description.</p>\\n\")?,\n         }\n "}]}