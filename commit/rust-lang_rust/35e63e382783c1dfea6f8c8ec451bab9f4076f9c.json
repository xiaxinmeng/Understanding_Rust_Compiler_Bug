{"sha": "35e63e382783c1dfea6f8c8ec451bab9f4076f9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1ZTYzZTM4Mjc4M2MxZGZlYTZmOGM4ZWM0NTFiYWI5ZjQwNzZmOWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-29T18:01:38Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-29T22:41:30Z"}, "message": "std: Stabilization pass for mutex/rwlock/condvar\n\nThis commit performs a stabilization pass over the sync::{mutex, rwlock,\ncondvar} modules, marking the following items as stable:\n\n* Mutex\n* Mutex::new\n* Mutex::lock\n* Mutex::try_lock\n* MutexGuard\n* RWLock\n* RWLock::new\n* RWLock::read\n* RWLock::try_read\n* RWLock::write\n* RWLock::try_write\n* RWLockReadGuard\n* RWLockWriteGuard\n* Condvar\n* Condvar::new\n* Condvar::wait\n* Condvar::notify_one\n* Condvar::notify_all\n* PoisonError\n* TryLockError\n* TryLockError::Poisoned\n* TryLockError::WouldBlock\n* LockResult\n* TryLockResult\n\nThe following items remain unstable to explore future possibilities of unifying\nthe static/non-static variants of the types:\n\n* StaticMutex\n* StaticMutex::new\n* StaticMutex::lock\n* StaticMutex::try_lock\n* StaticMutex::desroy\n* StaticRWLock\n* StaticRWLock::new\n* StaticRWLock::read\n* StaticRWLock::try_read\n* StaticRWLock::write\n* StaticRWLock::try_write\n* StaticRWLock::destroy\n\nThe following items were removed in favor of `Guard<'static, ()>` instead.\n\n* StaticMutexGuard\n* StaticRWLockReadGuard\n* StaticRWLockWriteGuard", "tree": {"sha": "b3bb4f939a4b9f0d374954c0926fbf33077d3cc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3bb4f939a4b9f0d374954c0926fbf33077d3cc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35e63e382783c1dfea6f8c8ec451bab9f4076f9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35e63e382783c1dfea6f8c8ec451bab9f4076f9c", "html_url": "https://github.com/rust-lang/rust/commit/35e63e382783c1dfea6f8c8ec451bab9f4076f9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35e63e382783c1dfea6f8c8ec451bab9f4076f9c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76e5ed655c762b812c3da4749a55f1bb1b52c787", "url": "https://api.github.com/repos/rust-lang/rust/commits/76e5ed655c762b812c3da4749a55f1bb1b52c787", "html_url": "https://github.com/rust-lang/rust/commit/76e5ed655c762b812c3da4749a55f1bb1b52c787"}], "stats": {"total": 376, "additions": 149, "deletions": 227}, "files": [{"sha": "15faf5be258f594816a289fda4d0e9f9fe8104a1", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/35e63e382783c1dfea6f8c8ec451bab9f4076f9c/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e63e382783c1dfea6f8c8ec451bab9f4076f9c/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=35e63e382783c1dfea6f8c8ec451bab9f4076f9c", "patch": "@@ -12,10 +12,10 @@ use prelude::*;\n \n use sync::atomic::{mod, AtomicUint};\n use sync::poison::{mod, LockResult};\n-use sync::CondvarGuard;\n use sys_common::condvar as sys;\n use sys_common::mutex as sys_mutex;\n use time::Duration;\n+use sync::{mutex, MutexGuard};\n \n /// A Condition Variable\n ///\n@@ -57,6 +57,7 @@ use time::Duration;\n ///     started = cvar.wait(started).unwrap();\n /// }\n /// ```\n+#[stable]\n pub struct Condvar { inner: Box<StaticCondvar> }\n \n unsafe impl Send for Condvar {}\n@@ -74,6 +75,7 @@ unsafe impl Sync for Condvar {}\n ///\n /// static CVAR: StaticCondvar = CONDVAR_INIT;\n /// ```\n+#[unstable = \"may be merged with Condvar in the future\"]\n pub struct StaticCondvar {\n     inner: sys::Condvar,\n     mutex: AtomicUint,\n@@ -83,24 +85,16 @@ unsafe impl Send for StaticCondvar {}\n unsafe impl Sync for StaticCondvar {}\n \n /// Constant initializer for a statically allocated condition variable.\n+#[unstable = \"may be merged with Condvar in the future\"]\n pub const CONDVAR_INIT: StaticCondvar = StaticCondvar {\n     inner: sys::CONDVAR_INIT,\n     mutex: atomic::INIT_ATOMIC_UINT,\n };\n \n-/// A trait for vaules which can be passed to the waiting methods of condition\n-/// variables. This is implemented by the mutex guards in this module.\n-///\n-/// Note that this trait should likely not be implemented manually unless you\n-/// really know what you're doing.\n-pub trait AsGuard {\n-    #[allow(missing_docs)]\n-    fn as_guard(&self) -> CondvarGuard;\n-}\n-\n impl Condvar {\n     /// Creates a new condition variable which is ready to be waited on and\n     /// notified.\n+    #[stable]\n     pub fn new() -> Condvar {\n         Condvar {\n             inner: box StaticCondvar {\n@@ -136,11 +130,12 @@ impl Condvar {\n     /// over time. Each condition variable is dynamically bound to exactly one\n     /// mutex to ensure defined behavior across platforms. If this functionality\n     /// is not desired, then unsafe primitives in `sys` are provided.\n-    pub fn wait<T: AsGuard>(&self, mutex_guard: T)\n-                            -> LockResult<T> {\n+    #[stable]\n+    pub fn wait<'a, T>(&self, guard: MutexGuard<'a, T>)\n+                       -> LockResult<MutexGuard<'a, T>> {\n         unsafe {\n             let me: &'static Condvar = &*(self as *const _);\n-            me.inner.wait(mutex_guard)\n+            me.inner.wait(guard)\n         }\n     }\n \n@@ -164,11 +159,11 @@ impl Condvar {\n     // provide. There are also additional concerns about the unix-specific\n     // implementation which may need to be addressed.\n     #[allow(dead_code)]\n-    fn wait_timeout<T: AsGuard>(&self, mutex_guard: T, dur: Duration)\n-                                -> LockResult<(T, bool)> {\n+    fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>, dur: Duration)\n+                           -> LockResult<(MutexGuard<'a, T>, bool)> {\n         unsafe {\n             let me: &'static Condvar = &*(self as *const _);\n-            me.inner.wait_timeout(mutex_guard, dur)\n+            me.inner.wait_timeout(guard, dur)\n         }\n     }\n \n@@ -179,6 +174,7 @@ impl Condvar {\n     /// `notify_one` are not buffered in any way.\n     ///\n     /// To wake up all threads, see `notify_one()`.\n+    #[stable]\n     pub fn notify_one(&self) { unsafe { self.inner.inner.notify_one() } }\n \n     /// Wake up all blocked threads on this condvar.\n@@ -188,6 +184,7 @@ impl Condvar {\n     /// way.\n     ///\n     /// To wake up only one thread, see `notify_one()`.\n+    #[stable]\n     pub fn notify_all(&self) { unsafe { self.inner.inner.notify_all() } }\n }\n \n@@ -202,17 +199,19 @@ impl StaticCondvar {\n     /// notification.\n     ///\n     /// See `Condvar::wait`.\n-    pub fn wait<T: AsGuard>(&'static self, mutex_guard: T) -> LockResult<T> {\n+    #[unstable = \"may be merged with Condvar in the future\"]\n+    pub fn wait<'a, T>(&'static self, guard: MutexGuard<'a, T>)\n+                       -> LockResult<MutexGuard<'a, T>> {\n         let poisoned = unsafe {\n-            let cvar_guard = mutex_guard.as_guard();\n-            self.verify(cvar_guard.lock);\n-            self.inner.wait(cvar_guard.lock);\n-            cvar_guard.poisoned.get()\n+            let lock = mutex::guard_lock(&guard);\n+            self.verify(lock);\n+            self.inner.wait(lock);\n+            mutex::guard_poison(&guard).get()\n         };\n         if poisoned {\n-            Err(poison::new_poison_error(mutex_guard))\n+            Err(poison::new_poison_error(guard))\n         } else {\n-            Ok(mutex_guard)\n+            Ok(guard)\n         }\n     }\n \n@@ -221,29 +220,31 @@ impl StaticCondvar {\n     ///\n     /// See `Condvar::wait_timeout`.\n     #[allow(dead_code)] // may want to stabilize this later, see wait_timeout above\n-    fn wait_timeout<T: AsGuard>(&'static self, mutex_guard: T, dur: Duration)\n-                                -> LockResult<(T, bool)> {\n+    fn wait_timeout<'a, T>(&'static self, guard: MutexGuard<'a, T>, dur: Duration)\n+                           -> LockResult<(MutexGuard<'a, T>, bool)> {\n         let (poisoned, success) = unsafe {\n-            let cvar_guard = mutex_guard.as_guard();\n-            self.verify(cvar_guard.lock);\n-            let success = self.inner.wait_timeout(cvar_guard.lock, dur);\n-            (cvar_guard.poisoned.get(), success)\n+            let lock = mutex::guard_lock(&guard);\n+            self.verify(lock);\n+            let success = self.inner.wait_timeout(lock, dur);\n+            (mutex::guard_poison(&guard).get(), success)\n         };\n         if poisoned {\n-            Err(poison::new_poison_error((mutex_guard, success)))\n+            Err(poison::new_poison_error((guard, success)))\n         } else {\n-            Ok((mutex_guard, success))\n+            Ok((guard, success))\n         }\n     }\n \n     /// Wake up one blocked thread on this condvar.\n     ///\n     /// See `Condvar::notify_one`.\n+    #[unstable = \"may be merged with Condvar in the future\"]\n     pub fn notify_one(&'static self) { unsafe { self.inner.notify_one() } }\n \n     /// Wake up all blocked threads on this condvar.\n     ///\n     /// See `Condvar::notify_all`.\n+    #[unstable = \"may be merged with Condvar in the future\"]\n     pub fn notify_all(&'static self) { unsafe { self.inner.notify_all() } }\n \n     /// Deallocate all resources associated with this static condvar.\n@@ -252,6 +253,7 @@ impl StaticCondvar {\n     /// active users of the condvar, and this also doesn't prevent any future\n     /// users of the condvar. This method is required to be called to not leak\n     /// memory on all platforms.\n+    #[unstable = \"may be merged with Condvar in the future\"]\n     pub unsafe fn destroy(&'static self) {\n         self.inner.destroy()\n     }"}, {"sha": "092acc7ff25698fc1e33b0a0ed362add32665856", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/35e63e382783c1dfea6f8c8ec451bab9f4076f9c/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e63e382783c1dfea6f8c8ec451bab9f4076f9c/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=35e63e382783c1dfea6f8c8ec451bab9f4076f9c", "patch": "@@ -17,16 +17,13 @@\n \n #![experimental]\n \n-use sys_common::mutex as sys_mutex;\n-\n pub use alloc::arc::{Arc, Weak};\n \n-pub use self::mutex::{Mutex, MutexGuard, StaticMutex, StaticMutexGuard};\n+pub use self::mutex::{Mutex, MutexGuard, StaticMutex};\n pub use self::mutex::MUTEX_INIT;\n pub use self::rwlock::{RWLock, StaticRWLock, RWLOCK_INIT};\n pub use self::rwlock::{RWLockReadGuard, RWLockWriteGuard};\n-pub use self::rwlock::{StaticRWLockReadGuard, StaticRWLockWriteGuard};\n-pub use self::condvar::{Condvar, StaticCondvar, CONDVAR_INIT, AsGuard};\n+pub use self::condvar::{Condvar, StaticCondvar, CONDVAR_INIT};\n pub use self::once::{Once, ONCE_INIT};\n pub use self::semaphore::{Semaphore, SemaphoreGuard};\n pub use self::barrier::Barrier;\n@@ -45,10 +42,3 @@ mod poison;\n mod rwlock;\n mod semaphore;\n mod task_pool;\n-\n-/// Structure returned by `AsGuard` to wait on a condition variable.\n-// NB: defined here to all modules have access to these private fields.\n-pub struct CondvarGuard<'a> {\n-    lock: &'a sys_mutex::Mutex,\n-    poisoned: &'a poison::Flag,\n-}"}, {"sha": "32c2c67152fe4a68ba53ffe8dc7441c833575857", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 43, "deletions": 82, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/35e63e382783c1dfea6f8c8ec451bab9f4076f9c/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e63e382783c1dfea6f8c8ec451bab9f4076f9c/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=35e63e382783c1dfea6f8c8ec451bab9f4076f9c", "patch": "@@ -12,7 +12,6 @@ use prelude::*;\n \n use cell::UnsafeCell;\n use kinds::marker;\n-use sync::{AsGuard, CondvarGuard};\n use sync::poison::{mod, TryLockError, TryLockResult, LockResult};\n use sys_common::mutex as sys;\n \n@@ -107,6 +106,7 @@ use sys_common::mutex as sys;\n ///\n /// *guard += 1;\n /// ```\n+#[stable]\n pub struct Mutex<T> {\n     // Note that this static mutex is in a *box*, not inlined into the struct\n     // itself. Once a native mutex has been used once, its address can never\n@@ -142,6 +142,7 @@ unsafe impl<T:Send> Sync for Mutex<T> { }\n /// }\n /// // lock is unlocked here.\n /// ```\n+#[unstable = \"may be merged with Mutex in the future\"]\n pub struct StaticMutex {\n     lock: sys::Mutex,\n     poison: poison::Flag,\n@@ -155,34 +156,27 @@ unsafe impl Sync for StaticMutex {}\n /// The data protected by the mutex can be access through this guard via its\n /// Deref and DerefMut implementations\n #[must_use]\n+#[stable]\n pub struct MutexGuard<'a, T: 'a> {\n     // funny underscores due to how Deref/DerefMut currently work (they\n     // disregard field privacy).\n-    __inner: Guard<'a, Mutex<T>>,\n-}\n-\n-/// An RAII implementation of a \"scoped lock\" of a static mutex. When this\n-/// structure is dropped (falls out of scope), the lock will be unlocked.\n-#[must_use]\n-pub struct StaticMutexGuard {\n-    inner: Guard<'static, StaticMutex>,\n-}\n-\n-struct Guard<'a, T: 'a> {\n-    inner: &'a T,\n-    poison: poison::Guard,\n-    marker: marker::NoSend, // even if 'a is static, this cannot be sent\n+    __lock: &'a StaticMutex,\n+    __data: &'a UnsafeCell<T>,\n+    __poison: poison::Guard,\n+    __marker: marker::NoSend,\n }\n \n /// Static initialization of a mutex. This constant can be used to initialize\n /// other mutex constants.\n+#[unstable = \"may be merged with Mutex in the future\"]\n pub const MUTEX_INIT: StaticMutex = StaticMutex {\n     lock: sys::MUTEX_INIT,\n     poison: poison::FLAG_INIT,\n };\n \n impl<T: Send> Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n+    #[stable]\n     pub fn new(t: T) -> Mutex<T> {\n         Mutex {\n             inner: box MUTEX_INIT,\n@@ -201,9 +195,10 @@ impl<T: Send> Mutex<T> {\n     ///\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return an error once the mutex is acquired.\n+    #[stable]\n     pub fn lock(&self) -> LockResult<MutexGuard<T>> {\n         unsafe { self.inner.lock.lock() }\n-        MutexGuard::new(self)\n+        MutexGuard::new(&*self.inner, &self.data)\n     }\n \n     /// Attempts to acquire this lock.\n@@ -219,9 +214,10 @@ impl<T: Send> Mutex<T> {\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return failure if the mutex would otherwise be\n     /// acquired.\n+    #[stable]\n     pub fn try_lock(&self) -> TryLockResult<MutexGuard<T>> {\n         if unsafe { self.inner.lock.try_lock() } {\n-            Ok(try!(MutexGuard::new(self)))\n+            Ok(try!(MutexGuard::new(&*self.inner, &self.data)))\n         } else {\n             Err(TryLockError::WouldBlock)\n         }\n@@ -238,19 +234,23 @@ impl<T: Send> Drop for Mutex<T> {\n     }\n }\n \n+static DUMMY: UnsafeCell<()> = UnsafeCell { value: () };\n+\n impl StaticMutex {\n     /// Acquires this lock, see `Mutex::lock`\n     #[inline]\n-    pub fn lock(&'static self) -> LockResult<StaticMutexGuard> {\n+    #[unstable = \"may be merged with Mutex in the future\"]\n+    pub fn lock(&'static self) -> LockResult<MutexGuard<()>> {\n         unsafe { self.lock.lock() }\n-        StaticMutexGuard::new(self)\n+        MutexGuard::new(self, &DUMMY)\n     }\n \n     /// Attempts to grab this lock, see `Mutex::try_lock`\n     #[inline]\n-    pub fn try_lock(&'static self) -> TryLockResult<StaticMutexGuard> {\n+    #[unstable = \"may be merged with Mutex in the future\"]\n+    pub fn try_lock(&'static self) -> TryLockResult<MutexGuard<()>> {\n         if unsafe { self.lock.try_lock() } {\n-            Ok(try!(StaticMutexGuard::new(self)))\n+            Ok(try!(MutexGuard::new(self, &DUMMY)))\n         } else {\n             Err(TryLockError::WouldBlock)\n         }\n@@ -266,93 +266,54 @@ impl StaticMutex {\n     /// *all* platforms. It may be the case that some platforms do not leak\n     /// memory if this method is not called, but this is not guaranteed to be\n     /// true on all platforms.\n+    #[unstable = \"may be merged with Mutex in the future\"]\n     pub unsafe fn destroy(&'static self) {\n         self.lock.destroy()\n     }\n }\n \n impl<'mutex, T> MutexGuard<'mutex, T> {\n-    fn new(lock: &Mutex<T>) -> LockResult<MutexGuard<T>> {\n-        poison::map_result(Guard::new(lock), |guard| {\n-            MutexGuard { __inner: guard }\n+    fn new(lock: &'mutex StaticMutex, data: &'mutex UnsafeCell<T>)\n+           -> LockResult<MutexGuard<'mutex, T>> {\n+        poison::map_result(lock.poison.borrow(), |guard| {\n+            MutexGuard {\n+                __lock: lock,\n+                __data: data,\n+                __poison: guard,\n+                __marker: marker::NoSend,\n+            }\n         })\n     }\n }\n \n-impl<T> AsGuard for Mutex<T> {\n-    fn as_guard(&self) -> CondvarGuard { self.inner.as_guard() }\n-}\n-\n-impl<'mutex, T> AsGuard for MutexGuard<'mutex, T> {\n-    fn as_guard(&self) -> CondvarGuard {\n-        CondvarGuard {\n-            lock: &self.__inner.inner.inner.lock,\n-            poisoned: &self.__inner.inner.inner.poison,\n-        }\n-    }\n-}\n-\n impl<'mutex, T> Deref<T> for MutexGuard<'mutex, T> {\n     fn deref<'a>(&'a self) -> &'a T {\n-        unsafe { &*self.__inner.inner.data.get() }\n+        unsafe { &*self.__data.get() }\n     }\n }\n impl<'mutex, T> DerefMut<T> for MutexGuard<'mutex, T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n-        unsafe { &mut *self.__inner.inner.data.get() }\n-    }\n-}\n-\n-impl StaticMutexGuard {\n-    #[inline]\n-    fn new(lock: &'static StaticMutex) -> LockResult<StaticMutexGuard> {\n-        poison::map_result(Guard::new(lock), |guard| {\n-            StaticMutexGuard { inner: guard }\n-        })\n+        unsafe { &mut *self.__data.get() }\n     }\n }\n \n-impl AsGuard for StaticMutex {\n-    #[inline]\n-    fn as_guard(&self) -> CondvarGuard {\n-        CondvarGuard { lock: &self.lock, poisoned: &self.poison }\n-    }\n-}\n-\n-impl AsGuard for StaticMutexGuard {\n+#[unsafe_destructor]\n+impl<'a, T> Drop for MutexGuard<'a, T> {\n     #[inline]\n-    fn as_guard(&self) -> CondvarGuard {\n-        CondvarGuard {\n-            lock: &self.inner.inner.lock,\n-            poisoned: &self.inner.inner.poison,\n+    fn drop(&mut self) {\n+        unsafe {\n+            self.__lock.poison.done(&self.__poison);\n+            self.__lock.lock.unlock();\n         }\n     }\n }\n \n-impl<'a, T: AsGuard> Guard<'a, T> {\n-    #[inline]\n-    fn new(t: &T) -> LockResult<Guard<T>> {\n-        let data = t.as_guard();\n-        poison::map_result(data.poisoned.borrow(), |guard| {\n-            Guard {\n-                inner: t,\n-                poison: guard,\n-                marker: marker::NoSend,\n-            }\n-        })\n-    }\n+pub fn guard_lock<'a, T>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex {\n+    &guard.__lock.lock\n }\n \n-#[unsafe_destructor]\n-impl<'a, T: AsGuard> Drop for Guard<'a, T> {\n-    #[inline]\n-    fn drop(&mut self) {\n-        unsafe {\n-            let data = self.inner.as_guard();\n-            data.poisoned.done(&self.poison);\n-            data.lock.unlock();\n-        }\n-    }\n+pub fn guard_poison<'a, T>(guard: &MutexGuard<'a, T>) -> &'a poison::Flag {\n+    &guard.__lock.poison\n }\n \n #[cfg(test)]"}, {"sha": "edf16d99f4966d1e7e6a02462524fc5730f4aa4f", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35e63e382783c1dfea6f8c8ec451bab9f4076f9c/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e63e382783c1dfea6f8c8ec451bab9f4076f9c/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=35e63e382783c1dfea6f8c8ec451bab9f4076f9c", "patch": "@@ -53,18 +53,22 @@ pub struct Guard {\n /// is held. The precise semantics for when a lock is poisoned is documented on\n /// each lock, but once a lock is poisoned then all future acquisitions will\n /// return this error.\n+#[stable]\n pub struct PoisonError<T> {\n     guard: T,\n }\n \n /// An enumeration of possible errors which can occur while calling the\n /// `try_lock` method.\n+#[stable]\n pub enum TryLockError<T> {\n     /// The lock could not be acquired because another task failed while holding\n     /// the lock.\n+    #[stable]\n     Poisoned(PoisonError<T>),\n     /// The lock could not be acquired at this time because the operation would\n     /// otherwise block.\n+    #[stable]\n     WouldBlock,\n }\n \n@@ -75,13 +79,15 @@ pub enum TryLockError<T> {\n /// that the primitive was poisoned. Note that the `Err` variant *also* carries\n /// the associated guard, and it can be acquired through the `into_inner`\n /// method.\n+#[stable]\n pub type LockResult<Guard> = Result<Guard, PoisonError<Guard>>;\n \n /// A type alias for the result of a nonblocking locking method.\n ///\n /// For more information, see `LockResult`. A `TryLockResult` doesn't\n /// necessarily hold the associated guard in the `Err` type as the lock may not\n /// have been acquired for other reasons.\n+#[stable]\n pub type TryLockResult<Guard> = Result<Guard, TryLockError<Guard>>;\n \n impl<T> fmt::Show for PoisonError<T> {\n@@ -93,6 +99,7 @@ impl<T> fmt::Show for PoisonError<T> {\n impl<T> PoisonError<T> {\n     /// Consumes this error indicating that a lock is poisoned, returning the\n     /// underlying guard to allow access regardless.\n+    #[stable]\n     pub fn into_guard(self) -> T { self.guard }\n }\n "}, {"sha": "29cc1f8563f9a9d4671ee5e9e5e5ae14e563b9c8", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 63, "deletions": 101, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/35e63e382783c1dfea6f8c8ec451bab9f4076f9c/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e63e382783c1dfea6f8c8ec451bab9f4076f9c/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=35e63e382783c1dfea6f8c8ec451bab9f4076f9c", "patch": "@@ -57,6 +57,7 @@ use sys_common::rwlock as sys;\n ///     assert_eq!(*w, 6);\n /// } // write lock is dropped here\n /// ```\n+#[stable]\n pub struct RWLock<T> {\n     inner: Box<StaticRWLock>,\n     data: UnsafeCell<T>,\n@@ -88,6 +89,7 @@ unsafe impl<T> Sync for RWLock<T> {}\n /// }\n /// unsafe { LOCK.destroy() } // free all resources\n /// ```\n+#[unstable = \"may be merged with RWLock in the future\"]\n pub struct StaticRWLock {\n     lock: sys::RWLock,\n     poison: poison::Flag,\n@@ -97,6 +99,7 @@ unsafe impl Send for StaticRWLock {}\n unsafe impl Sync for StaticRWLock {}\n \n /// Constant initialization for a statically-initialized rwlock.\n+#[unstable = \"may be merged with RWLock in the future\"]\n pub const RWLOCK_INIT: StaticRWLock = StaticRWLock {\n     lock: sys::RWLOCK_INIT,\n     poison: poison::FLAG_INIT,\n@@ -105,49 +108,27 @@ pub const RWLOCK_INIT: StaticRWLock = StaticRWLock {\n /// RAII structure used to release the shared read access of a lock when\n /// dropped.\n #[must_use]\n+#[stable]\n pub struct RWLockReadGuard<'a, T: 'a> {\n-    __inner: ReadGuard<'a, RWLock<T>>,\n+    __lock: &'a StaticRWLock,\n+    __data: &'a UnsafeCell<T>,\n+    __marker: marker::NoSend,\n }\n \n /// RAII structure used to release the exclusive write access of a lock when\n /// dropped.\n #[must_use]\n+#[stable]\n pub struct RWLockWriteGuard<'a, T: 'a> {\n-    __inner: WriteGuard<'a, RWLock<T>>,\n-}\n-\n-/// RAII structure used to release the shared read access of a lock when\n-/// dropped.\n-#[must_use]\n-pub struct StaticRWLockReadGuard {\n-    _inner: ReadGuard<'static, StaticRWLock>,\n-}\n-\n-/// RAII structure used to release the exclusive write access of a lock when\n-/// dropped.\n-#[must_use]\n-pub struct StaticRWLockWriteGuard {\n-    _inner: WriteGuard<'static, StaticRWLock>,\n-}\n-\n-struct ReadGuard<'a, T: 'a> {\n-    inner: &'a T,\n-    marker: marker::NoSend, // even if 'a == static, cannot send\n-}\n-\n-struct WriteGuard<'a, T: 'a> {\n-    inner: &'a T,\n-    poison: poison::Guard,\n-    marker: marker::NoSend, // even if 'a == static, cannot send\n-}\n-\n-#[doc(hidden)]\n-trait AsStaticRWLock {\n-    fn as_static_rwlock(&self) -> &StaticRWLock;\n+    __lock: &'a StaticRWLock,\n+    __data: &'a UnsafeCell<T>,\n+    __poison: poison::Guard,\n+    __marker: marker::NoSend,\n }\n \n impl<T: Send + Sync> RWLock<T> {\n     /// Creates a new instance of an RWLock which is unlocked and read to go.\n+    #[stable]\n     pub fn new(t: T) -> RWLock<T> {\n         RWLock { inner: box RWLOCK_INIT, data: UnsafeCell::new(t) }\n     }\n@@ -170,9 +151,10 @@ impl<T: Send + Sync> RWLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock.\n     /// The failure will occur immediately after the lock has been acquired.\n     #[inline]\n+    #[stable]\n     pub fn read(&self) -> LockResult<RWLockReadGuard<T>> {\n         unsafe { self.inner.lock.read() }\n-        RWLockReadGuard::new(self)\n+        RWLockReadGuard::new(&*self.inner, &self.data)\n     }\n \n     /// Attempt to acquire this lock with shared read access.\n@@ -191,9 +173,10 @@ impl<T: Send + Sync> RWLock<T> {\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n     #[inline]\n+    #[stable]\n     pub fn try_read(&self) -> TryLockResult<RWLockReadGuard<T>> {\n         if unsafe { self.inner.lock.try_read() } {\n-            Ok(try!(RWLockReadGuard::new(self)))\n+            Ok(try!(RWLockReadGuard::new(&*self.inner, &self.data)))\n         } else {\n             Err(TryLockError::WouldBlock)\n         }\n@@ -214,9 +197,10 @@ impl<T: Send + Sync> RWLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock.\n     /// An error will be returned when the lock is acquired.\n     #[inline]\n+    #[stable]\n     pub fn write(&self) -> LockResult<RWLockWriteGuard<T>> {\n         unsafe { self.inner.lock.write() }\n-        RWLockWriteGuard::new(self)\n+        RWLockWriteGuard::new(&*self.inner, &self.data)\n     }\n \n     /// Attempt to lock this rwlock with exclusive write access.\n@@ -232,9 +216,10 @@ impl<T: Send + Sync> RWLock<T> {\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n     #[inline]\n+    #[stable]\n     pub fn try_write(&self) -> TryLockResult<RWLockWriteGuard<T>> {\n         if unsafe { self.inner.lock.try_read() } {\n-            Ok(try!(RWLockWriteGuard::new(self)))\n+            Ok(try!(RWLockWriteGuard::new(&*self.inner, &self.data)))\n         } else {\n             Err(TryLockError::WouldBlock)\n         }\n@@ -248,24 +233,29 @@ impl<T> Drop for RWLock<T> {\n     }\n }\n \n+static DUMMY: UnsafeCell<()> = UnsafeCell { value: () };\n+\n impl StaticRWLock {\n     /// Locks this rwlock with shared read access, blocking the current thread\n     /// until it can be acquired.\n     ///\n     /// See `RWLock::read`.\n     #[inline]\n-    pub fn read(&'static self) -> LockResult<StaticRWLockReadGuard> {\n+    #[unstable = \"may be merged with RWLock in the future\"]\n+    pub fn read(&'static self) -> LockResult<RWLockReadGuard<'static, ()>> {\n         unsafe { self.lock.read() }\n-        StaticRWLockReadGuard::new(self)\n+        RWLockReadGuard::new(self, &DUMMY)\n     }\n \n     /// Attempt to acquire this lock with shared read access.\n     ///\n     /// See `RWLock::try_read`.\n     #[inline]\n-    pub fn try_read(&'static self) -> TryLockResult<StaticRWLockReadGuard> {\n+    #[unstable = \"may be merged with RWLock in the future\"]\n+    pub fn try_read(&'static self)\n+                    -> TryLockResult<RWLockReadGuard<'static, ()>> {\n         if unsafe { self.lock.try_read() } {\n-            Ok(try!(StaticRWLockReadGuard::new(self)))\n+            Ok(try!(RWLockReadGuard::new(self, &DUMMY)))\n         } else {\n             Err(TryLockError::WouldBlock)\n         }\n@@ -276,18 +266,21 @@ impl StaticRWLock {\n     ///\n     /// See `RWLock::write`.\n     #[inline]\n-    pub fn write(&'static self) -> LockResult<StaticRWLockWriteGuard> {\n+    #[unstable = \"may be merged with RWLock in the future\"]\n+    pub fn write(&'static self) -> LockResult<RWLockWriteGuard<'static, ()>> {\n         unsafe { self.lock.write() }\n-        StaticRWLockWriteGuard::new(self)\n+        RWLockWriteGuard::new(self, &DUMMY)\n     }\n \n     /// Attempt to lock this rwlock with exclusive write access.\n     ///\n     /// See `RWLock::try_write`.\n     #[inline]\n-    pub fn try_write(&'static self) -> TryLockResult<StaticRWLockWriteGuard> {\n+    #[unstable = \"may be merged with RWLock in the future\"]\n+    pub fn try_write(&'static self)\n+                     -> TryLockResult<RWLockWriteGuard<'static, ()>> {\n         if unsafe { self.lock.try_write() } {\n-            Ok(try!(StaticRWLockWriteGuard::new(self)))\n+            Ok(try!(RWLockWriteGuard::new(self, &DUMMY)))\n         } else {\n             Err(TryLockError::WouldBlock)\n         }\n@@ -299,93 +292,62 @@ impl StaticRWLock {\n     /// active users of the lock, and this also doesn't prevent any future users\n     /// of this lock. This method is required to be called to not leak memory on\n     /// all platforms.\n+    #[unstable = \"may be merged with RWLock in the future\"]\n     pub unsafe fn destroy(&'static self) {\n         self.lock.destroy()\n     }\n }\n \n impl<'rwlock, T> RWLockReadGuard<'rwlock, T> {\n-    fn new(lock: &RWLock<T>) -> LockResult<RWLockReadGuard<T>> {\n-        poison::map_result(ReadGuard::new(lock), |guard| {\n-            RWLockReadGuard { __inner: guard }\n+    fn new(lock: &'rwlock StaticRWLock, data: &'rwlock UnsafeCell<T>)\n+           -> LockResult<RWLockReadGuard<'rwlock, T>> {\n+        poison::map_result(lock.poison.borrow(), |_| {\n+            RWLockReadGuard {\n+                __lock: lock,\n+                __data: data,\n+                __marker: marker::NoSend,\n+            }\n         })\n     }\n }\n impl<'rwlock, T> RWLockWriteGuard<'rwlock, T> {\n-    fn new(lock: &RWLock<T>) -> LockResult<RWLockWriteGuard<T>> {\n-        poison::map_result(WriteGuard::new(lock), |guard| {\n-            RWLockWriteGuard { __inner: guard }\n+    fn new(lock: &'rwlock StaticRWLock, data: &'rwlock UnsafeCell<T>)\n+           -> LockResult<RWLockWriteGuard<'rwlock, T>> {\n+        poison::map_result(lock.poison.borrow(), |guard| {\n+            RWLockWriteGuard {\n+                __lock: lock,\n+                __data: data,\n+                __poison: guard,\n+                __marker: marker::NoSend,\n+            }\n         })\n     }\n }\n \n impl<'rwlock, T> Deref<T> for RWLockReadGuard<'rwlock, T> {\n-    fn deref(&self) -> &T { unsafe { &*self.__inner.inner.data.get() } }\n+    fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n impl<'rwlock, T> Deref<T> for RWLockWriteGuard<'rwlock, T> {\n-    fn deref(&self) -> &T { unsafe { &*self.__inner.inner.data.get() } }\n+    fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n impl<'rwlock, T> DerefMut<T> for RWLockWriteGuard<'rwlock, T> {\n     fn deref_mut(&mut self) -> &mut T {\n-        unsafe { &mut *self.__inner.inner.data.get() }\n-    }\n-}\n-\n-impl StaticRWLockReadGuard {\n-    #[inline]\n-    fn new(lock: &'static StaticRWLock) -> LockResult<StaticRWLockReadGuard> {\n-        poison::map_result(ReadGuard::new(lock), |guard| {\n-            StaticRWLockReadGuard { _inner: guard }\n-        })\n-    }\n-}\n-impl StaticRWLockWriteGuard {\n-    #[inline]\n-    fn new(lock: &'static StaticRWLock) -> LockResult<StaticRWLockWriteGuard> {\n-        poison::map_result(WriteGuard::new(lock), |guard| {\n-            StaticRWLockWriteGuard { _inner: guard }\n-        })\n-    }\n-}\n-\n-impl<T> AsStaticRWLock for RWLock<T> {\n-    #[inline]\n-    fn as_static_rwlock(&self) -> &StaticRWLock { &*self.inner }\n-}\n-impl AsStaticRWLock for StaticRWLock {\n-    #[inline]\n-    fn as_static_rwlock(&self) -> &StaticRWLock { self }\n-}\n-\n-impl<'a, T: AsStaticRWLock> ReadGuard<'a, T> {\n-    fn new(t: &'a T) -> LockResult<ReadGuard<'a, T>> {\n-        poison::map_result(t.as_static_rwlock().poison.borrow(), |_| {\n-            ReadGuard { inner: t, marker: marker::NoSend }\n-        })\n-    }\n-}\n-\n-impl<'a, T: AsStaticRWLock> WriteGuard<'a, T> {\n-    fn new(t: &'a T) -> LockResult<WriteGuard<'a, T>> {\n-        poison::map_result(t.as_static_rwlock().poison.borrow(), |guard| {\n-            WriteGuard { inner: t, marker: marker::NoSend, poison: guard }\n-        })\n+        unsafe { &mut *self.__data.get() }\n     }\n }\n \n #[unsafe_destructor]\n-impl<'a, T: AsStaticRWLock> Drop for ReadGuard<'a, T> {\n+impl<'a, T> Drop for RWLockReadGuard<'a, T> {\n     fn drop(&mut self) {\n-        unsafe { self.inner.as_static_rwlock().lock.read_unlock(); }\n+        unsafe { self.__lock.lock.read_unlock(); }\n     }\n }\n \n #[unsafe_destructor]\n-impl<'a, T: AsStaticRWLock> Drop for WriteGuard<'a, T> {\n+impl<'a, T> Drop for RWLockWriteGuard<'a, T> {\n     fn drop(&mut self) {\n-        let inner = self.inner.as_static_rwlock();\n-        inner.poison.done(&self.poison);\n-        unsafe { inner.lock.write_unlock(); }\n+        self.__lock.poison.done(&self.__poison);\n+        unsafe { self.__lock.lock.write_unlock(); }\n     }\n }\n "}]}