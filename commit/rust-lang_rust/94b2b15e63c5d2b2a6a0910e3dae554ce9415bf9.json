{"sha": "94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "node_id": "C_kwDOAAsO6NoAKDk0YjJiMTVlNjNjNWQyYjJhNmEwOTEwZTNkYWU1NTRjZTk0MTViZjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-29T05:12:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-29T05:12:53Z"}, "message": "Auto merge of #101143 - matthiaskrgr:rollup-g8y5k0g, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #94890 (Support parsing IP addresses from a byte string)\n - #96334 (socket `set_mark` addition.)\n - #99027 (Replace `Body::basic_blocks()` with field access)\n - #100437 (Improve const mismatch `FulfillmentError`)\n - #100843 (Migrate part of rustc_infer to session diagnostic)\n - #100897 (extra sanity check against consts pointing to mutable memory)\n - #100959 (translations: rename warn_ to warning)\n - #101111 (Use the declaration's SourceInfo for FnEntry retags, not the outermost)\n - #101116 ([rustdoc] Remove Attrs type alias)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "52fe4cbdebc7c7b04dcd6a25793b8a8660969700", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52fe4cbdebc7c7b04dcd6a25793b8a8660969700"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "html_url": "https://github.com/rust-lang/rust/commit/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c142a61373eda083cec64de383cf79e9a173f16", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c142a61373eda083cec64de383cf79e9a173f16", "html_url": "https://github.com/rust-lang/rust/commit/7c142a61373eda083cec64de383cf79e9a173f16"}, {"sha": "fa177a9db2d7c96ced985d018a0108de033f5ded", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa177a9db2d7c96ced985d018a0108de033f5ded", "html_url": "https://github.com/rust-lang/rust/commit/fa177a9db2d7c96ced985d018a0108de033f5ded"}], "stats": {"total": 1813, "additions": 1289, "deletions": 524}, "files": [{"sha": "7c3879fdd98d41c25ab8be243218d8ea1980a5b9", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -3631,6 +3631,7 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_serialize\",\n+ \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec\","}, {"sha": "144fd15fc24075d4b4ba5d8e244feb9076ab035d", "filename": "compiler/rustc_borrowck/src/constraint_generation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -31,7 +31,7 @@ pub(super) fn generate_constraints<'cx, 'tcx>(\n         body,\n     };\n \n-    for (bb, data) in body.basic_blocks().iter_enumerated() {\n+    for (bb, data) in body.basic_blocks.iter_enumerated() {\n         cg.visit_basic_block_data(bb, data);\n     }\n }"}, {"sha": "816288eb50b293e35518b7af57063dc19bc688d9", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -143,7 +143,7 @@ struct OutOfScopePrecomputer<'a, 'tcx> {\n impl<'a, 'tcx> OutOfScopePrecomputer<'a, 'tcx> {\n     fn new(body: &'a Body<'tcx>, regioncx: &'a RegionInferenceContext<'tcx>) -> Self {\n         OutOfScopePrecomputer {\n-            visited: BitSet::new_empty(body.basic_blocks().len()),\n+            visited: BitSet::new_empty(body.basic_blocks.len()),\n             visit_stack: vec![],\n             body,\n             regioncx,"}, {"sha": "a6b8c6057e05ee0f9be50a4357652e4d599e2167", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -459,7 +459,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 return outmost_back_edge;\n             }\n \n-            let block = &self.body.basic_blocks()[location.block];\n+            let block = &self.body.basic_blocks[location.block];\n \n             if location.statement_index < block.statements.len() {\n                 let successor = location.successor_within_block();\n@@ -518,7 +518,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n \n         if loop_head.dominates(from, &self.dominators) {\n-            let block = &self.body.basic_blocks()[from.block];\n+            let block = &self.body.basic_blocks[from.block];\n \n             if from.statement_index < block.statements.len() {\n                 let successor = from.successor_within_block();\n@@ -568,7 +568,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             UseSpans::PatUse(span)\n             | UseSpans::OtherUse(span)\n             | UseSpans::FnSelfUse { var_span: span, .. } => {\n-                let block = &self.body.basic_blocks()[location.block];\n+                let block = &self.body.basic_blocks[location.block];\n \n                 let kind = if let Some(&Statement {\n                     kind: StatementKind::FakeRead(box (FakeReadCause::ForLet(_), _)),"}, {"sha": "16c2f9ccc6aa4b8d06a122bdb85748eef3e5c285", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -88,7 +88,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 if let Some(StatementKind::Assign(box (\n                     place,\n                     Rvalue::Use(Operand::Move(move_from)),\n-                ))) = self.body.basic_blocks()[location.block]\n+                ))) = self.body.basic_blocks[location.block]\n                     .statements\n                     .get(location.statement_index)\n                     .map(|stmt| &stmt.kind)"}, {"sha": "5ca3f2f4d033c1c8dc27815369c9db4338ff6790", "filename": "compiler/rustc_borrowck/src/location.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -33,7 +33,7 @@ impl LocationTable {\n     pub(crate) fn new(body: &Body<'_>) -> Self {\n         let mut num_points = 0;\n         let statements_before_block = body\n-            .basic_blocks()\n+            .basic_blocks\n             .iter()\n             .map(|block_data| {\n                 let v = num_points;"}, {"sha": "de20a4bb465c207c6e77a6b4c47280b8c822e3d1", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -25,7 +25,7 @@ impl RegionValueElements {\n     pub(crate) fn new(body: &Body<'_>) -> Self {\n         let mut num_points = 0;\n         let statements_before_block: IndexVec<BasicBlock, usize> = body\n-            .basic_blocks()\n+            .basic_blocks\n             .iter()\n             .map(|block_data| {\n                 let v = num_points;\n@@ -37,7 +37,7 @@ impl RegionValueElements {\n         debug!(\"RegionValueElements: num_points={:#?}\", num_points);\n \n         let mut basic_blocks = IndexVec::with_capacity(num_points);\n-        for (bb, bb_data) in body.basic_blocks().iter_enumerated() {\n+        for (bb, bb_data) in body.basic_blocks.iter_enumerated() {\n             basic_blocks.extend((0..=bb_data.statements.len()).map(|_| bb));\n         }\n "}, {"sha": "c1812aa4bbab65fda259c44278df2cba74debdba", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -2633,7 +2633,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             self.check_local(&body, local, local_decl);\n         }\n \n-        for (block, block_data) in body.basic_blocks().iter_enumerated() {\n+        for (block, block_data) in body.basic_blocks.iter_enumerated() {\n             let mut location = Location { block, statement_index: 0 };\n             for stmt in &block_data.statements {\n                 if !stmt.source_info.span.is_dummy() {"}, {"sha": "0cbb9f3ec2d80512d6277be4ab8463d07932e2bc", "filename": "compiler/rustc_codegen_cranelift/src/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -26,7 +26,7 @@ pub(crate) fn analyze(fx: &FunctionCx<'_, '_, '_>) -> IndexVec<Local, SsaKind> {\n         })\n         .collect::<IndexVec<Local, SsaKind>>();\n \n-    for bb in fx.mir.basic_blocks().iter() {\n+    for bb in fx.mir.basic_blocks.iter() {\n         for stmt in bb.statements.iter() {\n             match &stmt.kind {\n                 Assign(place_and_rval) => match &place_and_rval.1 {"}, {"sha": "3011813c7035b56ae39bbc80fd1852fbae466154", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -73,7 +73,7 @@ pub(crate) fn codegen_fn<'tcx>(\n     // Predefine blocks\n     let start_block = bcx.create_block();\n     let block_map: IndexVec<BasicBlock, Block> =\n-        (0..mir.basic_blocks().len()).map(|_| bcx.create_block()).collect();\n+        (0..mir.basic_blocks.len()).map(|_| bcx.create_block()).collect();\n \n     // Make FunctionCx\n     let target_config = module.target_config();\n@@ -271,7 +271,7 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n     }\n     fx.tcx.sess.time(\"codegen prelude\", || crate::abi::codegen_fn_prelude(fx, start_block));\n \n-    for (bb, bb_data) in fx.mir.basic_blocks().iter_enumerated() {\n+    for (bb, bb_data) in fx.mir.basic_blocks.iter_enumerated() {\n         let block = fx.get_block(bb);\n         fx.bcx.switch_to_block(block);\n "}, {"sha": "e2b68f24a21dc699becffd75ff9afec81c8fa8ef", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -505,7 +505,7 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n                 return None;\n             }\n             let mut computed_const_val = None;\n-            for bb_data in fx.mir.basic_blocks() {\n+            for bb_data in fx.mir.basic_blocks.iter() {\n                 for stmt in &bb_data.statements {\n                     match &stmt.kind {\n                         StatementKind::Assign(local_and_rvalue) if &local_and_rvalue.0 == place => {"}, {"sha": "c7617d2e464fab1e7b867c373e3b20e23185bd47", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -266,7 +266,7 @@ pub fn cleanup_kinds(mir: &mir::Body<'_>) -> IndexVec<mir::BasicBlock, CleanupKi\n         result: &mut IndexVec<mir::BasicBlock, CleanupKind>,\n         mir: &mir::Body<'tcx>,\n     ) {\n-        for (bb, data) in mir.basic_blocks().iter_enumerated() {\n+        for (bb, data) in mir.basic_blocks.iter_enumerated() {\n             match data.terminator().kind {\n                 TerminatorKind::Goto { .. }\n                 | TerminatorKind::Resume\n@@ -296,7 +296,7 @@ pub fn cleanup_kinds(mir: &mir::Body<'_>) -> IndexVec<mir::BasicBlock, CleanupKi\n     }\n \n     fn propagate<'tcx>(result: &mut IndexVec<mir::BasicBlock, CleanupKind>, mir: &mir::Body<'tcx>) {\n-        let mut funclet_succs = IndexVec::from_elem(None, mir.basic_blocks());\n+        let mut funclet_succs = IndexVec::from_elem(None, &mir.basic_blocks);\n \n         let mut set_successor = |funclet: mir::BasicBlock, succ| match funclet_succs[funclet] {\n             ref mut s @ None => {\n@@ -359,7 +359,7 @@ pub fn cleanup_kinds(mir: &mir::Body<'_>) -> IndexVec<mir::BasicBlock, CleanupKi\n         }\n     }\n \n-    let mut result = IndexVec::from_elem(CleanupKind::NotCleanup, mir.basic_blocks());\n+    let mut result = IndexVec::from_elem(CleanupKind::NotCleanup, &mir.basic_blocks);\n \n     discover_masters(&mut result, mir);\n     propagate(&mut result, mir);"}, {"sha": "d6bbcd99234553bf3173620c5fdc8d7c0a419674", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -150,13 +150,13 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     let start_llbb = Bx::append_block(cx, llfn, \"start\");\n     let mut bx = Bx::build(cx, start_llbb);\n \n-    if mir.basic_blocks().iter().any(|bb| bb.is_cleanup) {\n+    if mir.basic_blocks.iter().any(|bb| bb.is_cleanup) {\n         bx.set_personality_fn(cx.eh_personality());\n     }\n \n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n     let cached_llbbs: IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>> = mir\n-        .basic_blocks()\n+        .basic_blocks\n         .indices()\n         .map(|bb| if bb == mir::START_BLOCK { Some(start_llbb) } else { None })\n         .collect();\n@@ -172,8 +172,8 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         unreachable_block: None,\n         double_unwind_guard: None,\n         cleanup_kinds,\n-        landing_pads: IndexVec::from_elem(None, mir.basic_blocks()),\n-        funclets: IndexVec::from_fn_n(|_| None, mir.basic_blocks().len()),\n+        landing_pads: IndexVec::from_elem(None, &mir.basic_blocks),\n+        funclets: IndexVec::from_fn_n(|_| None, mir.basic_blocks.len()),\n         locals: IndexVec::new(),\n         debug_context,\n         per_local_var_debug_info: None,"}, {"sha": "2da9123b84610520d7ea7601ad1df1f98605041d", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -782,7 +782,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         assert_eq!(\n             unwinding,\n             match self.frame().loc {\n-                Ok(loc) => self.body().basic_blocks()[loc.block].is_cleanup,\n+                Ok(loc) => self.body().basic_blocks[loc.block].is_cleanup,\n                 Err(_) => true,\n             }\n         );"}, {"sha": "91f4f04251721209e177286b3363c4f215098f67", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -28,7 +28,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             let mut source_info = *frame.body.source_info(loc);\n \n             // If this is a `Call` terminator, use the `fn_span` instead.\n-            let block = &frame.body.basic_blocks()[loc.block];\n+            let block = &frame.body.basic_blocks[loc.block];\n             if loc.statement_index == block.statements.len() {\n                 debug!(\n                     \"find_closest_untracked_caller_location: got terminator {:?} ({:?})\","}, {"sha": "683e11ff7e0e50fc97448cff63ad10185b48e03c", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -53,7 +53,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.pop_stack_frame(/* unwinding */ true)?;\n             return Ok(true);\n         };\n-        let basic_block = &self.body().basic_blocks()[loc.block];\n+        let basic_block = &self.body().basic_blocks[loc.block];\n \n         if let Some(stmt) = basic_block.statements.get(loc.statement_index) {\n             let old_frames = self.frame_idx();"}, {"sha": "5f77c9b88927d37aab90bf84b267b314bb0a9804", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 45, "deletions": 27, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -8,6 +8,7 @@ use std::convert::TryFrom;\n use std::fmt::Write;\n use std::num::NonZeroUsize;\n \n+use rustc_ast::Mutability;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_middle::mir::interpret::InterpError;\n@@ -423,34 +424,51 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             // Proceed recursively even for ZST, no reason to skip them!\n             // `!` is a ZST and we want to validate it.\n             if let Ok((alloc_id, _offset, _prov)) = self.ecx.ptr_try_get_alloc_id(place.ptr) {\n-                // Special handling for pointers to statics (irrespective of their type).\n+                // Let's see what kind of memory this points to.\n                 let alloc_kind = self.ecx.tcx.try_get_global_alloc(alloc_id);\n-                if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n-                    assert!(!self.ecx.tcx.is_thread_local_static(did));\n-                    assert!(self.ecx.tcx.is_static(did));\n-                    if matches!(\n-                        self.ctfe_mode,\n-                        Some(CtfeValidationMode::Const { allow_static_ptrs: false, .. })\n-                    ) {\n-                        // See const_eval::machine::MemoryExtra::can_access_statics for why\n-                        // this check is so important.\n-                        // This check is reachable when the const just referenced the static,\n-                        // but never read it (so we never entered `before_access_global`).\n-                        throw_validation_failure!(self.path,\n-                            { \"a {} pointing to a static variable\", kind }\n-                        );\n+                match alloc_kind {\n+                    Some(GlobalAlloc::Static(did)) => {\n+                        // Special handling for pointers to statics (irrespective of their type).\n+                        assert!(!self.ecx.tcx.is_thread_local_static(did));\n+                        assert!(self.ecx.tcx.is_static(did));\n+                        if matches!(\n+                            self.ctfe_mode,\n+                            Some(CtfeValidationMode::Const { allow_static_ptrs: false, .. })\n+                        ) {\n+                            // See const_eval::machine::MemoryExtra::can_access_statics for why\n+                            // this check is so important.\n+                            // This check is reachable when the const just referenced the static,\n+                            // but never read it (so we never entered `before_access_global`).\n+                            throw_validation_failure!(self.path,\n+                                { \"a {} pointing to a static variable in a constant\", kind }\n+                            );\n+                        }\n+                        // We skip recursively checking other statics. These statics must be sound by\n+                        // themselves, and the only way to get broken statics here is by using\n+                        // unsafe code.\n+                        // The reasons we don't check other statics is twofold. For one, in all\n+                        // sound cases, the static was already validated on its own, and second, we\n+                        // trigger cycle errors if we try to compute the value of the other static\n+                        // and that static refers back to us.\n+                        // We might miss const-invalid data,\n+                        // but things are still sound otherwise (in particular re: consts\n+                        // referring to statics).\n+                        return Ok(());\n                     }\n-                    // We skip checking other statics. These statics must be sound by\n-                    // themselves, and the only way to get broken statics here is by using\n-                    // unsafe code.\n-                    // The reasons we don't check other statics is twofold. For one, in all\n-                    // sound cases, the static was already validated on its own, and second, we\n-                    // trigger cycle errors if we try to compute the value of the other static\n-                    // and that static refers back to us.\n-                    // We might miss const-invalid data,\n-                    // but things are still sound otherwise (in particular re: consts\n-                    // referring to statics).\n-                    return Ok(());\n+                    Some(GlobalAlloc::Memory(alloc)) => {\n+                        if alloc.inner().mutability == Mutability::Mut\n+                            && matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { .. }))\n+                        {\n+                            // This should be unreachable, but if someone manages to copy a pointer\n+                            // out of a `static`, then that pointer might point to mutable memory,\n+                            // and we would catch that here.\n+                            throw_validation_failure!(self.path,\n+                                { \"a {} pointing to mutable memory in a constant\", kind }\n+                            );\n+                        }\n+                    }\n+                    // Nothing to check for these.\n+                    None | Some(GlobalAlloc::Function(..) | GlobalAlloc::VTable(..)) => {}\n                 }\n             }\n             let path = &self.path;\n@@ -528,7 +546,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             }\n             ty::Ref(_, ty, mutbl) => {\n                 if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { .. }))\n-                    && *mutbl == hir::Mutability::Mut\n+                    && *mutbl == Mutability::Mut\n                 {\n                     // A mutable reference inside a const? That does not seem right (except if it is\n                     // a ZST)."}, {"sha": "cbfdb47dd1a4072eb30b9c919873f69e38b69b32", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -135,7 +135,7 @@ impl<'mir, 'tcx> Qualifs<'mir, 'tcx> {\n         // qualifs for the return type.\n         let return_block = ccx\n             .body\n-            .basic_blocks()\n+            .basic_blocks\n             .iter_enumerated()\n             .find(|(_, block)| matches!(block.terminator().kind, TerminatorKind::Return))\n             .map(|(bb, _)| bb);"}, {"sha": "6301388d1e84091fa97f262ea76babfb0cf7c9ad", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -710,7 +710,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     }\n \n     fn assign(&mut self, dest: Local, rvalue: Rvalue<'tcx>, span: Span) {\n-        let last = self.promoted.basic_blocks().last().unwrap();\n+        let last = self.promoted.basic_blocks.last().unwrap();\n         let data = &mut self.promoted[last];\n         data.statements.push(Statement {\n             source_info: SourceInfo::outermost(span),\n@@ -803,7 +803,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         self.visit_operand(arg, loc);\n                     }\n \n-                    let last = self.promoted.basic_blocks().last().unwrap();\n+                    let last = self.promoted.basic_blocks.last().unwrap();\n                     let new_target = self.new_block();\n \n                     *self.promoted[last].terminator_mut() = Terminator {\n@@ -1041,7 +1041,7 @@ pub fn is_const_fn_in_array_repeat_expression<'tcx>(\n         _ => {}\n     }\n \n-    for block in body.basic_blocks() {\n+    for block in body.basic_blocks.iter() {\n         if let Some(Terminator { kind: TerminatorKind::Call { func, destination, .. }, .. }) =\n             &block.terminator\n         {"}, {"sha": "45a94972c1134b8fd2cd4523713e724fe5ccf5fc", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -140,8 +140,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         if bb == START_BLOCK {\n             self.fail(location, \"start block must not have predecessors\")\n         }\n-        if let Some(bb) = self.body.basic_blocks().get(bb) {\n-            let src = self.body.basic_blocks().get(location.block).unwrap();\n+        if let Some(bb) = self.body.basic_blocks.get(bb) {\n+            let src = self.body.basic_blocks.get(location.block).unwrap();\n             match (src.is_cleanup, bb.is_cleanup, edge_kind) {\n                 // Non-cleanup blocks can jump to non-cleanup blocks along non-unwind edges\n                 (false, false, EdgeKind::Normal)\n@@ -881,13 +881,13 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             }\n             TerminatorKind::Resume | TerminatorKind::Abort => {\n                 let bb = location.block;\n-                if !self.body.basic_blocks()[bb].is_cleanup {\n+                if !self.body.basic_blocks[bb].is_cleanup {\n                     self.fail(location, \"Cannot `Resume` or `Abort` from non-cleanup basic block\")\n                 }\n             }\n             TerminatorKind::Return => {\n                 let bb = location.block;\n-                if self.body.basic_blocks()[bb].is_cleanup {\n+                if self.body.basic_blocks[bb].is_cleanup {\n                     self.fail(location, \"Cannot `Return` from cleanup basic block\")\n                 }\n             }"}, {"sha": "60086cd6e477f430bff9432081f32af0d7583b40", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -0,0 +1,112 @@\n+infer_opaque_hidden_type =\n+    opaque type's hidden type cannot be another opaque type from the same scope\n+    .label = one of the two opaque types used here has to be outside its defining scope\n+    .opaque_type = opaque type whose hidden type is being assigned\n+    .hidden_type = opaque type being used as hidden type\n+\n+infer_type_annotations_needed = {$source_kind ->\n+    [closure] type annotations needed for the closure `{$source_name}`\n+    [normal] type annotations needed for `{$source_name}`\n+    *[other] type annotations needed\n+}\n+    .label = type must be known at this point\n+\n+infer_label_bad = {$bad_kind ->\n+    *[other] cannot infer type\n+    [more_info] cannot infer {$prefix_kind ->\n+        *[type] type for {$prefix}\n+        [const_with_param] the value of const parameter\n+        [const] the value of the constant\n+    } `{$name}`{$has_parent ->\n+        [true] {\" \"}declared on the {$parent_prefix} `{$parent_name}`\n+        *[false] {\"\"}\n+    }\n+}\n+\n+infer_source_kind_subdiag_let = {$kind ->\n+    [with_pattern] consider giving `{$name}` an explicit type\n+    [closure] consider giving this closure parameter an explicit type\n+    *[other] consider giving this pattern a type\n+}{$x_kind ->\n+    [has_name] , where the {$prefix_kind ->\n+        *[type] type for {$prefix}\n+        [const_with_param] the value of const parameter\n+        [const] the value of the constant\n+    } `{$arg_name}` is specified\n+    [underscore] , where the placeholders `_` are specified\n+    *[empty] {\"\"}\n+}\n+\n+infer_source_kind_subdiag_generic_label =\n+    cannot infer {$is_type ->\n+    [true] type\n+    *[false] the value\n+    } of the {$is_type ->\n+    [true] type\n+    *[false] const\n+    } {$parent_exists ->\n+    [true] parameter `{$param_name}` declared on the {$parent_prefix} `{$parent_name}`\n+    *[false] parameter {$param_name}\n+    }\n+\n+infer_source_kind_subdiag_generic_suggestion =\n+    consider specifying the generic {$arg_count ->\n+    [one] argument\n+    *[other] arguments\n+    }\n+\n+infer_source_kind_fully_qualified =\n+    try using a fully qualified path to specify the expected types\n+\n+infer_source_kind_closure_return =\n+    try giving this closure an explicit return type\n+\n+# generator_kind  may need to be translated\n+infer_need_type_info_in_generator =\n+    type inside {$generator_kind ->\n+    [async_block] `async` block\n+    [async_closure] `async` closure\n+    [async_fn] `async fn` body\n+    *[generator] generator\n+    } must be known in this context\n+\n+\n+infer_subtype = ...so that the {$requirement ->\n+    [method_compat] method type is compatible with trait\n+    [type_compat] associated type is compatible with trait\n+    [const_compat] const is compatible with trait\n+    [expr_assignable] expression is assignable\n+    [if_else_different] `if` and `else` have incompatible types\n+    [no_else] `if` missing an `else` returns `()`\n+    [fn_main_correct_type] `main` function has the correct type\n+    [fn_start_correct_type] #[start]` function has the correct type\n+    [intristic_correct_type] intrinsic has the correct type\n+    [method_correct_type] method receiver has the correct type\n+    *[other] types are compatible\n+}\n+infer_subtype_2 = ...so that {$requirement ->\n+    [method_compat] method type is compatible with trait\n+    [type_compat] associated type is compatible with trait\n+    [const_compat] const is compatible with trait\n+    [expr_assignable] expression is assignable\n+    [if_else_different] `if` and `else` have incompatible types\n+    [no_else] `if` missing an `else` returns `()`\n+    [fn_main_correct_type] `main` function has the correct type\n+    [fn_start_correct_type] #[start]` function has the correct type\n+    [intristic_correct_type] intrinsic has the correct type\n+    [method_correct_type] method receiver has the correct type\n+    *[other] types are compatible\n+}\n+\n+infer_reborrow = ...so that reference does not outlive borrowed content\n+infer_reborrow_upvar = ...so that closure can access `{$name}`\n+infer_relate_object_bound = ...so that it can be closed over into an object\n+infer_data_borrowed = ...so that the type `{$name}` is not borrowed for too long\n+infer_reference_outlives_referent = ...so that the reference type `{$name}` does not outlive the data it points at\n+infer_relate_param_bound = ...so that the type `{$name}` will meet its required lifetime bounds{$continues ->\n+[true] ...\n+*[false] {\"\"}\n+}\n+infer_relate_param_bound_2 = ...that is required by this bound\n+infer_relate_region_param_bound = ...so that the declared lifetime parameter bounds are satisfied\n+infer_compare_impl_item_obligation = ...so that the definition in impl matches the definition from the trait"}, {"sha": "b17668dc0ae7718fd194f2931625483ced29ef5d", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -41,6 +41,7 @@ fluent_messages! {\n     driver => \"../locales/en-US/driver.ftl\",\n     expand => \"../locales/en-US/expand.ftl\",\n     interface => \"../locales/en-US/interface.ftl\",\n+    infer => \"../locales/en-US/infer.ftl\",\n     lint => \"../locales/en-US/lint.ftl\",\n     parser => \"../locales/en-US/parser.ftl\",\n     passes => \"../locales/en-US/passes.ftl\","}, {"sha": "aced787d6711600ee0337b7ee4dd16a3c736973b", "filename": "compiler/rustc_infer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_infer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_infer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2FCargo.toml?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -15,6 +15,7 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n+rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "938f8aa77a5b4589f6e5eb2f5ed5956fce22ee8b", "filename": "compiler/rustc_infer/src/errors.rs", "status": "added", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -0,0 +1,254 @@\n+use rustc_errors::{fluent, AddSubdiagnostic, DiagnosticMessage, DiagnosticStyledString};\n+use rustc_hir::FnRetTy;\n+use rustc_macros::SessionDiagnostic;\n+use rustc_span::{BytePos, Span};\n+\n+use crate::infer::error_reporting::{\n+    need_type_info::{GeneratorKindAsDiagArg, UnderspecifiedArgKind},\n+    ObligationCauseAsDiagArg,\n+};\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::opaque_hidden_type)]\n+pub struct OpaqueHiddenTypeDiag {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[note(infer::opaque_type)]\n+    pub opaque_type: Span,\n+    #[note(infer::hidden_type)]\n+    pub hidden_type: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::type_annotations_needed, code = \"E0282\")]\n+pub struct AnnotationRequired<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub source_kind: &'static str,\n+    pub source_name: &'a str,\n+    #[label]\n+    pub failure_span: Option<Span>,\n+    #[subdiagnostic]\n+    pub bad_label: Option<InferenceBadError<'a>>,\n+    #[subdiagnostic]\n+    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n+    #[subdiagnostic]\n+    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n+}\n+\n+// Copy of `AnnotationRequired` for E0283\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::type_annotations_needed, code = \"E0283\")]\n+pub struct AmbigousImpl<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub source_kind: &'static str,\n+    pub source_name: &'a str,\n+    #[label]\n+    pub failure_span: Option<Span>,\n+    #[subdiagnostic]\n+    pub bad_label: Option<InferenceBadError<'a>>,\n+    #[subdiagnostic]\n+    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n+    #[subdiagnostic]\n+    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n+}\n+\n+// Copy of `AnnotationRequired` for E0284\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::type_annotations_needed, code = \"E0284\")]\n+pub struct AmbigousReturn<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub source_kind: &'static str,\n+    pub source_name: &'a str,\n+    #[label]\n+    pub failure_span: Option<Span>,\n+    #[subdiagnostic]\n+    pub bad_label: Option<InferenceBadError<'a>>,\n+    #[subdiagnostic]\n+    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n+    #[subdiagnostic]\n+    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::need_type_info_in_generator, code = \"E0698\")]\n+pub struct NeedTypeInfoInGenerator<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub generator_kind: GeneratorKindAsDiagArg,\n+    #[subdiagnostic]\n+    pub bad_label: InferenceBadError<'a>,\n+}\n+\n+// Used when a better one isn't available\n+#[derive(SessionSubdiagnostic)]\n+#[label(infer::label_bad)]\n+pub struct InferenceBadError<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub bad_kind: &'static str,\n+    pub prefix_kind: UnderspecifiedArgKind,\n+    pub has_parent: bool,\n+    pub prefix: &'a str,\n+    pub parent_prefix: &'a str,\n+    pub parent_name: String,\n+    pub name: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum SourceKindSubdiag<'a> {\n+    #[suggestion_verbose(\n+        infer::source_kind_subdiag_let,\n+        code = \": {type_name}\",\n+        applicability = \"has-placeholders\"\n+    )]\n+    LetLike {\n+        #[primary_span]\n+        span: Span,\n+        name: String,\n+        type_name: String,\n+        kind: &'static str,\n+        x_kind: &'static str,\n+        prefix_kind: UnderspecifiedArgKind,\n+        prefix: &'a str,\n+        arg_name: String,\n+    },\n+    #[label(infer::source_kind_subdiag_generic_label)]\n+    GenericLabel {\n+        #[primary_span]\n+        span: Span,\n+        is_type: bool,\n+        param_name: String,\n+        parent_exists: bool,\n+        parent_prefix: String,\n+        parent_name: String,\n+    },\n+    #[suggestion_verbose(\n+        infer::source_kind_subdiag_generic_suggestion,\n+        code = \"::<{args}>\",\n+        applicability = \"has-placeholders\"\n+    )]\n+    GenericSuggestion {\n+        #[primary_span]\n+        span: Span,\n+        arg_count: usize,\n+        args: String,\n+    },\n+}\n+\n+// Has to be implemented manually because multipart suggestions are not supported by the derive macro.\n+// Would be a part of `SourceKindSubdiag` otherwise.\n+pub enum SourceKindMultiSuggestion<'a> {\n+    FullyQualified {\n+        span: Span,\n+        def_path: String,\n+        adjustment: &'a str,\n+        successor: (&'a str, BytePos),\n+    },\n+    ClosureReturn {\n+        ty_info: String,\n+        data: &'a FnRetTy<'a>,\n+        should_wrap_expr: Option<Span>,\n+    },\n+}\n+\n+impl AddSubdiagnostic for SourceKindMultiSuggestion<'_> {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        match self {\n+            Self::FullyQualified { span, def_path, adjustment, successor } => {\n+                let suggestion = vec![\n+                    (span.shrink_to_lo(), format!(\"{def_path}({adjustment}\")),\n+                    (span.shrink_to_hi().with_hi(successor.1), successor.0.to_string()),\n+                ];\n+                diag.multipart_suggestion_verbose(\n+                    fluent::infer::source_kind_fully_qualified,\n+                    suggestion,\n+                    rustc_errors::Applicability::HasPlaceholders,\n+                );\n+            }\n+            Self::ClosureReturn { ty_info, data, should_wrap_expr } => {\n+                let (arrow, post) = match data {\n+                    FnRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n+                    _ => (\"\", \"\"),\n+                };\n+                let suggestion = match should_wrap_expr {\n+                    Some(end_span) => vec![\n+                        (data.span(), format!(\"{}{}{}{{ \", arrow, ty_info, post)),\n+                        (end_span, \" }\".to_string()),\n+                    ],\n+                    None => vec![(data.span(), format!(\"{}{}{}\", arrow, ty_info, post))],\n+                };\n+                diag.multipart_suggestion_verbose(\n+                    fluent::infer::source_kind_closure_return,\n+                    suggestion,\n+                    rustc_errors::Applicability::HasPlaceholders,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+pub enum RegionOriginNote<'a> {\n+    Plain {\n+        span: Span,\n+        msg: DiagnosticMessage,\n+    },\n+    WithName {\n+        span: Span,\n+        msg: DiagnosticMessage,\n+        name: &'a str,\n+        continues: bool,\n+    },\n+    WithRequirement {\n+        span: Span,\n+        requirement: ObligationCauseAsDiagArg<'a>,\n+        expected_found: Option<(DiagnosticStyledString, DiagnosticStyledString)>,\n+    },\n+}\n+\n+impl AddSubdiagnostic for RegionOriginNote<'_> {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        let mut label_or_note = |span, msg: DiagnosticMessage| {\n+            let sub_count = diag.children.iter().filter(|d| d.span.is_dummy()).count();\n+            let expanded_sub_count = diag.children.iter().filter(|d| !d.span.is_dummy()).count();\n+            let span_is_primary = diag.span.primary_spans().iter().all(|&sp| sp == span);\n+            if span_is_primary && sub_count == 0 && expanded_sub_count == 0 {\n+                diag.span_label(span, msg);\n+            } else if span_is_primary && expanded_sub_count == 0 {\n+                diag.note(msg);\n+            } else {\n+                diag.span_note(span, msg);\n+            }\n+        };\n+        match self {\n+            RegionOriginNote::Plain { span, msg } => {\n+                label_or_note(span, msg);\n+            }\n+            RegionOriginNote::WithName { span, msg, name, continues } => {\n+                label_or_note(span, msg);\n+                diag.set_arg(\"name\", name);\n+                diag.set_arg(\"continues\", continues);\n+            }\n+            RegionOriginNote::WithRequirement {\n+                span,\n+                requirement,\n+                expected_found: Some((expected, found)),\n+            } => {\n+                label_or_note(span, fluent::infer::subtype);\n+                diag.set_arg(\"requirement\", requirement);\n+\n+                diag.note_expected_found(&\"\", expected, &\"\", found);\n+            }\n+            RegionOriginNote::WithRequirement { span, requirement, expected_found: None } => {\n+                // FIXME: this really should be handled at some earlier stage. Our\n+                // handling of region checking when type errors are present is\n+                // *terrible*.\n+                label_or_note(span, fluent::infer::subtype_2);\n+                diag.set_arg(\"requirement\", requirement);\n+            }\n+        };\n+    }\n+}"}, {"sha": "465508e12058f9ef9e5ab173b848a2ab6ab015d8", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -58,7 +58,7 @@ use crate::traits::{\n };\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorGuaranteed};\n+use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorGuaranteed, IntoDiagnosticArg};\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -78,7 +78,7 @@ use std::{cmp, fmt, iter};\n \n mod note;\n \n-mod need_type_info;\n+pub(crate) mod need_type_info;\n pub use need_type_info::TypeAnnotationNeeded;\n \n pub mod nice_region_error;\n@@ -1588,9 +1588,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             Mismatch::Variable(infer::ExpectedFound { expected, found }),\n                         )\n                     }\n+                    ValuePairs::Terms(infer::ExpectedFound {\n+                        expected: ty::Term::Const(_),\n+                        found: ty::Term::Const(_),\n+                    }) => (false, Mismatch::Fixed(\"constant\")),\n                     ValuePairs::TraitRefs(_) | ValuePairs::PolyTraitRefs(_) => {\n                         (false, Mismatch::Fixed(\"trait\"))\n                     }\n+                    ValuePairs::Regions(_) => (false, Mismatch::Fixed(\"lifetime\")),\n                     _ => (false, Mismatch::Fixed(\"type\")),\n                 };\n                 let vals = match self.values_str(values) {\n@@ -2881,6 +2886,30 @@ impl<'tcx> ObligationCauseExt<'tcx> for ObligationCause<'tcx> {\n     }\n }\n \n+/// Newtype to allow implementing IntoDiagnosticArg\n+pub struct ObligationCauseAsDiagArg<'tcx>(pub ObligationCause<'tcx>);\n+\n+impl IntoDiagnosticArg for ObligationCauseAsDiagArg<'_> {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        use crate::traits::ObligationCauseCode::*;\n+        let kind = match self.0.code() {\n+            CompareImplItemObligation { kind: ty::AssocKind::Fn, .. } => \"method_compat\",\n+            CompareImplItemObligation { kind: ty::AssocKind::Type, .. } => \"type_compat\",\n+            CompareImplItemObligation { kind: ty::AssocKind::Const, .. } => \"const_compat\",\n+            ExprAssignable => \"expr_assignable\",\n+            IfExpression { .. } => \"if_else_different\",\n+            IfExpressionWithNoElse => \"no_else\",\n+            MainFunctionType => \"fn_main_correct_type\",\n+            StartFunctionType => \"fn_start_correct_type\",\n+            IntrinsicType => \"intristic_correct_type\",\n+            MethodReceiver => \"method_correct_type\",\n+            _ => \"other\",\n+        }\n+        .into();\n+        rustc_errors::DiagnosticArgValue::Str(kind)\n+    }\n+}\n+\n /// This is a bare signal of what kind of type we're dealing with. `ty::TyKind` tracks\n /// extra information about each type, but we only care about the category.\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]"}, {"sha": "e990fe7ecb50427edb13538bd0a4a0b985cf7fa0", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 199, "deletions": 128, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -1,6 +1,10 @@\n+use crate::errors::{\n+    AmbigousImpl, AmbigousReturn, AnnotationRequired, InferenceBadError, NeedTypeInfoInGenerator,\n+    SourceKindMultiSuggestion, SourceKindSubdiag,\n+};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::InferCtxt;\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed, IntoDiagnosticArg};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def::{CtorOf, DefKind, Namespace};\n@@ -14,6 +18,7 @@ use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Print, Printer};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n use rustc_middle::ty::{self, DefIdTree, InferConst};\n use rustc_middle::ty::{IsSuggestable, Ty, TyCtxt, TypeckResults};\n+use rustc_session::SessionDiagnostic;\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::{BytePos, Span};\n use std::borrow::Cow;\n@@ -60,38 +65,49 @@ pub struct InferenceDiagnosticsParentData {\n     name: String,\n }\n \n+#[derive(Clone)]\n pub enum UnderspecifiedArgKind {\n     Type { prefix: Cow<'static, str> },\n     Const { is_parameter: bool },\n }\n \n impl InferenceDiagnosticsData {\n-    /// Generate a label for a generic argument which can't be inferred. When not\n-    /// much is known about the argument, `use_diag` may be used to describe the\n-    /// labeled value.\n-    fn cannot_infer_msg(&self) -> String {\n-        if self.name == \"_\" && matches!(self.kind, UnderspecifiedArgKind::Type { .. }) {\n-            return \"cannot infer type\".to_string();\n-        }\n-\n-        let suffix = match &self.parent {\n-            Some(parent) => parent.suffix_string(),\n-            None => String::new(),\n-        };\n-\n-        // For example: \"cannot infer type for type parameter `T`\"\n-        format!(\"cannot infer {} `{}`{}\", self.kind.prefix_string(), self.name, suffix)\n+    fn can_add_more_info(&self) -> bool {\n+        !(self.name == \"_\" && matches!(self.kind, UnderspecifiedArgKind::Type { .. }))\n     }\n \n-    fn where_x_is_specified(&self, in_type: Ty<'_>) -> String {\n+    fn where_x_is_kind(&self, in_type: Ty<'_>) -> &'static str {\n         if in_type.is_ty_infer() {\n-            String::new()\n+            \"empty\"\n         } else if self.name == \"_\" {\n             // FIXME: Consider specializing this message if there is a single `_`\n             // in the type.\n-            \", where the placeholders `_` are specified\".to_string()\n+            \"underscore\"\n         } else {\n-            format!(\", where the {} `{}` is specified\", self.kind.prefix_string(), self.name)\n+            \"has_name\"\n+        }\n+    }\n+\n+    /// Generate a label for a generic argument which can't be inferred. When not\n+    /// much is known about the argument, `use_diag` may be used to describe the\n+    /// labeled value.\n+    fn make_bad_error(&self, span: Span) -> InferenceBadError<'_> {\n+        let has_parent = self.parent.is_some();\n+        let bad_kind = if self.can_add_more_info() { \"more_info\" } else { \"other\" };\n+        let (parent_prefix, parent_name) = self\n+            .parent\n+            .as_ref()\n+            .map(|parent| (parent.prefix, parent.name.clone()))\n+            .unwrap_or_default();\n+        InferenceBadError {\n+            span,\n+            bad_kind,\n+            prefix_kind: self.kind.clone(),\n+            prefix: self.kind.try_get_prefix().unwrap_or_default(),\n+            name: self.name.clone(),\n+            has_parent,\n+            parent_prefix,\n+            parent_name,\n         }\n     }\n }\n@@ -113,18 +129,24 @@ impl InferenceDiagnosticsParentData {\n     fn for_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<InferenceDiagnosticsParentData> {\n         Self::for_parent_def_id(tcx, tcx.parent(def_id))\n     }\n+}\n \n-    fn suffix_string(&self) -> String {\n-        format!(\" declared on the {} `{}`\", self.prefix, self.name)\n+impl IntoDiagnosticArg for UnderspecifiedArgKind {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        let kind = match self {\n+            Self::Type { .. } => \"type\",\n+            Self::Const { is_parameter: true } => \"const_with_param\",\n+            Self::Const { is_parameter: false } => \"const\",\n+        };\n+        rustc_errors::DiagnosticArgValue::Str(kind.into())\n     }\n }\n \n impl UnderspecifiedArgKind {\n-    fn prefix_string(&self) -> Cow<'static, str> {\n+    fn try_get_prefix(&self) -> Option<&str> {\n         match self {\n-            Self::Type { prefix } => format!(\"type for {}\", prefix).into(),\n-            Self::Const { is_parameter: true } => \"the value of const parameter\".into(),\n-            Self::Const { is_parameter: false } => \"the value of the constant\".into(),\n+            Self::Type { prefix } => Some(prefix.as_ref()),\n+            Self::Const { .. } => None,\n         }\n     }\n }\n@@ -303,11 +325,44 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         arg_data: InferenceDiagnosticsData,\n         error_code: TypeAnnotationNeeded,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let error_code = error_code.into();\n-        let mut err =\n-            self.tcx.sess.struct_span_err_with_code(span, \"type annotations needed\", error_code);\n-        err.span_label(span, arg_data.cannot_infer_msg());\n-        err\n+        let source_kind = \"other\";\n+        let source_name = \"\";\n+        let failure_span = None;\n+        let infer_subdiags = Vec::new();\n+        let multi_suggestions = Vec::new();\n+        let bad_label = Some(arg_data.make_bad_error(span));\n+        match error_code {\n+            TypeAnnotationNeeded::E0282 => AnnotationRequired {\n+                span,\n+                source_kind,\n+                source_name,\n+                failure_span,\n+                infer_subdiags,\n+                multi_suggestions,\n+                bad_label,\n+            }\n+            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            TypeAnnotationNeeded::E0283 => AmbigousImpl {\n+                span,\n+                source_kind,\n+                source_name,\n+                failure_span,\n+                infer_subdiags,\n+                multi_suggestions,\n+                bad_label,\n+            }\n+            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            TypeAnnotationNeeded::E0284 => AmbigousReturn {\n+                span,\n+                source_kind,\n+                source_name,\n+                failure_span,\n+                infer_subdiags,\n+                multi_suggestions,\n+                bad_label,\n+            }\n+            .into_diagnostic(&self.tcx.sess.parse_sess),\n+        }\n     }\n \n     pub fn emit_inference_failure_err(\n@@ -340,48 +395,39 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             return self.bad_inference_failure_err(failure_span, arg_data, error_code)\n         };\n \n-        let error_code = error_code.into();\n-        let mut err = self.tcx.sess.struct_span_err_with_code(\n-            span,\n-            &format!(\"type annotations needed{}\", kind.ty_msg(self)),\n-            error_code,\n-        );\n-\n-        if should_label_span && !failure_span.overlaps(span) {\n-            err.span_label(failure_span, \"type must be known at this point\");\n-        }\n+        let (source_kind, name) = kind.ty_localized_msg(self);\n+        let failure_span = if should_label_span && !failure_span.overlaps(span) {\n+            Some(failure_span)\n+        } else {\n+            None\n+        };\n \n+        let mut infer_subdiags = Vec::new();\n+        let mut multi_suggestions = Vec::new();\n         match kind {\n             InferSourceKind::LetBinding { insert_span, pattern_name, ty } => {\n-                let suggestion_msg = if let Some(name) = pattern_name {\n-                    format!(\n-                        \"consider giving `{}` an explicit type{}\",\n-                        name,\n-                        arg_data.where_x_is_specified(ty)\n-                    )\n-                } else {\n-                    format!(\n-                        \"consider giving this pattern a type{}\",\n-                        arg_data.where_x_is_specified(ty)\n-                    )\n-                };\n-                err.span_suggestion_verbose(\n-                    insert_span,\n-                    &suggestion_msg,\n-                    format!(\": {}\", ty_to_string(self, ty)),\n-                    Applicability::HasPlaceholders,\n-                );\n+                infer_subdiags.push(SourceKindSubdiag::LetLike {\n+                    span: insert_span,\n+                    name: pattern_name.map(|name| name.to_string()).unwrap_or_else(String::new),\n+                    x_kind: arg_data.where_x_is_kind(ty),\n+                    prefix_kind: arg_data.kind.clone(),\n+                    prefix: arg_data.kind.try_get_prefix().unwrap_or_default(),\n+                    arg_name: arg_data.name,\n+                    kind: if pattern_name.is_some() { \"with_pattern\" } else { \"other\" },\n+                    type_name: ty_to_string(self, ty),\n+                });\n             }\n             InferSourceKind::ClosureArg { insert_span, ty } => {\n-                err.span_suggestion_verbose(\n-                    insert_span,\n-                    &format!(\n-                        \"consider giving this closure parameter an explicit type{}\",\n-                        arg_data.where_x_is_specified(ty)\n-                    ),\n-                    format!(\": {}\", ty_to_string(self, ty)),\n-                    Applicability::HasPlaceholders,\n-                );\n+                infer_subdiags.push(SourceKindSubdiag::LetLike {\n+                    span: insert_span,\n+                    name: String::new(),\n+                    x_kind: arg_data.where_x_is_kind(ty),\n+                    prefix_kind: arg_data.kind.clone(),\n+                    prefix: arg_data.kind.try_get_prefix().unwrap_or_default(),\n+                    arg_name: arg_data.name,\n+                    kind: \"closure\",\n+                    type_name: ty_to_string(self, ty),\n+                });\n             }\n             InferSourceKind::GenericArg {\n                 insert_span,\n@@ -393,19 +439,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 let generics = self.tcx.generics_of(generics_def_id);\n                 let is_type = matches!(arg.unpack(), GenericArgKind::Type(_));\n \n-                let cannot_infer_msg = format!(\n-                    \"cannot infer {} of the {} parameter `{}`{}\",\n-                    if is_type { \"type\" } else { \"the value\" },\n-                    if is_type { \"type\" } else { \"const\" },\n-                    generics.params[argument_index].name,\n-                    // We use the `generics_def_id` here, as even when suggesting `None::<T>`,\n-                    // the type parameter `T` was still declared on the enum, not on the\n-                    // variant.\n+                let (parent_exists, parent_prefix, parent_name) =\n                     InferenceDiagnosticsParentData::for_parent_def_id(self.tcx, generics_def_id)\n-                        .map_or(String::new(), |parent| parent.suffix_string()),\n-                );\n+                        .map_or((false, String::new(), String::new()), |parent| {\n+                            (true, parent.prefix.to_string(), parent.name)\n+                        });\n \n-                err.span_label(span, cannot_infer_msg);\n+                infer_subdiags.push(SourceKindSubdiag::GenericLabel {\n+                    span,\n+                    is_type,\n+                    param_name: generics.params[argument_index].name.to_string(),\n+                    parent_exists,\n+                    parent_prefix,\n+                    parent_name,\n+                });\n \n                 let args = fmt_printer(self, Namespace::TypeNS)\n                     .comma_sep(generic_args.iter().copied().map(|arg| {\n@@ -435,15 +482,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     .unwrap()\n                     .into_buffer();\n \n-                err.span_suggestion_verbose(\n-                    insert_span,\n-                    &format!(\n-                        \"consider specifying the generic argument{}\",\n-                        pluralize!(generic_args.len()),\n-                    ),\n-                    format!(\"::<{}>\", args),\n-                    Applicability::HasPlaceholders,\n-                );\n+                infer_subdiags.push(SourceKindSubdiag::GenericSuggestion {\n+                    span: insert_span,\n+                    arg_count: generic_args.len(),\n+                    args,\n+                });\n             }\n             InferSourceKind::FullyQualifiedMethodCall { receiver, successor, substs, def_id } => {\n                 let printer = fmt_printer(self, Namespace::ValueNS);\n@@ -468,37 +511,54 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     _ => \"\",\n                 };\n \n-                let suggestion = vec![\n-                    (receiver.span.shrink_to_lo(), format!(\"{def_path}({adjustment}\")),\n-                    (receiver.span.shrink_to_hi().with_hi(successor.1), successor.0.to_string()),\n-                ];\n-                err.multipart_suggestion_verbose(\n-                    \"try using a fully qualified path to specify the expected types\",\n-                    suggestion,\n-                    Applicability::HasPlaceholders,\n-                );\n+                multi_suggestions.push(SourceKindMultiSuggestion::FullyQualified {\n+                    span: receiver.span,\n+                    def_path,\n+                    adjustment,\n+                    successor,\n+                });\n             }\n             InferSourceKind::ClosureReturn { ty, data, should_wrap_expr } => {\n-                let ret = ty_to_string(self, ty);\n-                let (arrow, post) = match data {\n-                    FnRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n-                    _ => (\"\", \"\"),\n-                };\n-                let suggestion = match should_wrap_expr {\n-                    Some(end_span) => vec![\n-                        (data.span(), format!(\"{}{}{}{{ \", arrow, ret, post)),\n-                        (end_span, \" }\".to_string()),\n-                    ],\n-                    None => vec![(data.span(), format!(\"{}{}{}\", arrow, ret, post))],\n-                };\n-                err.multipart_suggestion_verbose(\n-                    \"try giving this closure an explicit return type\",\n-                    suggestion,\n-                    Applicability::HasPlaceholders,\n-                );\n+                let ty_info = ty_to_string(self, ty);\n+                multi_suggestions.push(SourceKindMultiSuggestion::ClosureReturn {\n+                    ty_info,\n+                    data,\n+                    should_wrap_expr,\n+                });\n+            }\n+        }\n+        match error_code {\n+            TypeAnnotationNeeded::E0282 => AnnotationRequired {\n+                span,\n+                source_kind,\n+                source_name: &name,\n+                failure_span,\n+                infer_subdiags,\n+                multi_suggestions,\n+                bad_label: None,\n+            }\n+            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            TypeAnnotationNeeded::E0283 => AmbigousImpl {\n+                span,\n+                source_kind,\n+                source_name: &name,\n+                failure_span,\n+                infer_subdiags,\n+                multi_suggestions,\n+                bad_label: None,\n+            }\n+            .into_diagnostic(&self.tcx.sess.parse_sess),\n+            TypeAnnotationNeeded::E0284 => AmbigousReturn {\n+                span,\n+                source_kind,\n+                source_name: &name,\n+                failure_span,\n+                infer_subdiags,\n+                multi_suggestions,\n+                bad_label: None,\n             }\n+            .into_diagnostic(&self.tcx.sess.parse_sess),\n         }\n-        err\n     }\n \n     pub fn need_type_info_err_in_generator(\n@@ -510,15 +570,26 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let ty = self.resolve_vars_if_possible(ty);\n         let data = self.extract_inference_diagnostics_data(ty.into(), None);\n \n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n+        NeedTypeInfoInGenerator {\n+            bad_label: data.make_bad_error(span),\n             span,\n-            E0698,\n-            \"type inside {} must be known in this context\",\n-            kind,\n-        );\n-        err.span_label(span, data.cannot_infer_msg());\n-        err\n+            generator_kind: GeneratorKindAsDiagArg(kind),\n+        }\n+        .into_diagnostic(&self.tcx.sess.parse_sess)\n+    }\n+}\n+\n+pub struct GeneratorKindAsDiagArg(pub hir::GeneratorKind);\n+\n+impl IntoDiagnosticArg for GeneratorKindAsDiagArg {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        let kind = match self.0 {\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) => \"async_block\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Closure) => \"async_closure\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Fn) => \"async_fn\",\n+            hir::GeneratorKind::Gen => \"generator\",\n+        };\n+        rustc_errors::DiagnosticArgValue::Str(kind.into())\n     }\n }\n \n@@ -579,22 +650,22 @@ impl<'tcx> InferSource<'tcx> {\n }\n \n impl<'tcx> InferSourceKind<'tcx> {\n-    fn ty_msg(&self, infcx: &InferCtxt<'_, 'tcx>) -> String {\n+    fn ty_localized_msg(&self, infcx: &InferCtxt<'_, 'tcx>) -> (&'static str, String) {\n         match *self {\n             InferSourceKind::LetBinding { ty, .. }\n             | InferSourceKind::ClosureArg { ty, .. }\n             | InferSourceKind::ClosureReturn { ty, .. } => {\n                 if ty.is_closure() {\n-                    format!(\" for the closure `{}`\", closure_as_fn_str(infcx, ty))\n+                    (\"closure\", closure_as_fn_str(infcx, ty))\n                 } else if !ty.is_ty_infer() {\n-                    format!(\" for `{}`\", ty_to_string(infcx, ty))\n+                    (\"normal\", ty_to_string(infcx, ty))\n                 } else {\n-                    String::new()\n+                    (\"other\", String::new())\n                 }\n             }\n             // FIXME: We should be able to add some additional info here.\n             InferSourceKind::GenericArg { .. }\n-            | InferSourceKind::FullyQualifiedMethodCall { .. } => String::new(),\n+            | InferSourceKind::FullyQualifiedMethodCall { .. } => (\"other\", String::new()),\n         }\n     }\n }"}, {"sha": "cffdf56bb6d48f78a28eb2856b4a9816e3386a39", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 48, "deletions": 66, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -1,96 +1,78 @@\n-use crate::infer::error_reporting::{note_and_explain_region, ObligationCauseExt};\n+use crate::errors::RegionOriginNote;\n+use crate::infer::error_reporting::note_and_explain_region;\n use crate::infer::{self, InferCtxt, SubregionOrigin};\n-use rustc_errors::{struct_span_err, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{\n+    fluent, struct_span_err, AddSubdiagnostic, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n+};\n use rustc_middle::traits::ObligationCauseCode;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::{self, Region};\n \n+use super::ObligationCauseAsDiagArg;\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub(super) fn note_region_origin(&self, err: &mut Diagnostic, origin: &SubregionOrigin<'tcx>) {\n-        let mut label_or_note = |span, msg: &str| {\n-            let sub_count = err.children.iter().filter(|d| d.span.is_dummy()).count();\n-            let expanded_sub_count = err.children.iter().filter(|d| !d.span.is_dummy()).count();\n-            let span_is_primary = err.span.primary_spans().iter().all(|&sp| sp == span);\n-            if span_is_primary && sub_count == 0 && expanded_sub_count == 0 {\n-                err.span_label(span, msg);\n-            } else if span_is_primary && expanded_sub_count == 0 {\n-                err.note(msg);\n-            } else {\n-                err.span_note(span, msg);\n-            }\n-        };\n         match *origin {\n-            infer::Subtype(ref trace) => {\n-                if let Some((expected, found)) = self.values_str(trace.values) {\n-                    label_or_note(\n-                        trace.cause.span,\n-                        &format!(\"...so that the {}\", trace.cause.as_requirement_str()),\n-                    );\n-\n-                    err.note_expected_found(&\"\", expected, &\"\", found);\n-                } else {\n-                    // FIXME: this really should be handled at some earlier stage. Our\n-                    // handling of region checking when type errors are present is\n-                    // *terrible*.\n-\n-                    label_or_note(\n-                        trace.cause.span,\n-                        &format!(\"...so that {}\", trace.cause.as_requirement_str()),\n-                    );\n-                }\n-            }\n-            infer::Reborrow(span) => {\n-                label_or_note(span, \"...so that reference does not outlive borrowed content\");\n+            infer::Subtype(ref trace) => RegionOriginNote::WithRequirement {\n+                span: trace.cause.span,\n+                requirement: ObligationCauseAsDiagArg(trace.cause.clone()),\n+                expected_found: self.values_str(trace.values),\n             }\n+            .add_to_diagnostic(err),\n+            infer::Reborrow(span) => RegionOriginNote::Plain { span, msg: fluent::infer::reborrow }\n+                .add_to_diagnostic(err),\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n                 let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n-                label_or_note(span, &format!(\"...so that closure can access `{}`\", var_name));\n+                RegionOriginNote::WithName {\n+                    span,\n+                    msg: fluent::infer::reborrow,\n+                    name: &var_name.to_string(),\n+                    continues: false,\n+                }\n+                .add_to_diagnostic(err);\n             }\n             infer::RelateObjectBound(span) => {\n-                label_or_note(span, \"...so that it can be closed over into an object\");\n+                RegionOriginNote::Plain { span, msg: fluent::infer::relate_object_bound }\n+                    .add_to_diagnostic(err);\n             }\n             infer::DataBorrowed(ty, span) => {\n-                label_or_note(\n+                RegionOriginNote::WithName {\n                     span,\n-                    &format!(\n-                        \"...so that the type `{}` is not borrowed for too long\",\n-                        self.ty_to_string(ty)\n-                    ),\n-                );\n+                    msg: fluent::infer::data_borrowed,\n+                    name: &self.ty_to_string(ty),\n+                    continues: false,\n+                }\n+                .add_to_diagnostic(err);\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n-                label_or_note(\n+                RegionOriginNote::WithName {\n                     span,\n-                    &format!(\n-                        \"...so that the reference type `{}` does not outlive the data it points at\",\n-                        self.ty_to_string(ty)\n-                    ),\n-                );\n+                    msg: fluent::infer::reference_outlives_referent,\n+                    name: &self.ty_to_string(ty),\n+                    continues: false,\n+                }\n+                .add_to_diagnostic(err);\n             }\n-            infer::RelateParamBound(span, t, opt_span) => {\n-                label_or_note(\n+            infer::RelateParamBound(span, ty, opt_span) => {\n+                RegionOriginNote::WithName {\n                     span,\n-                    &format!(\n-                        \"...so that the type `{}` will meet its required lifetime bounds{}\",\n-                        self.ty_to_string(t),\n-                        if opt_span.is_some() { \"...\" } else { \"\" },\n-                    ),\n-                );\n+                    msg: fluent::infer::relate_param_bound,\n+                    name: &self.ty_to_string(ty),\n+                    continues: opt_span.is_some(),\n+                }\n+                .add_to_diagnostic(err);\n                 if let Some(span) = opt_span {\n-                    err.span_note(span, \"...that is required by this bound\");\n+                    RegionOriginNote::Plain { span, msg: fluent::infer::relate_param_bound_2 }\n+                        .add_to_diagnostic(err);\n                 }\n             }\n             infer::RelateRegionParamBound(span) => {\n-                label_or_note(\n-                    span,\n-                    \"...so that the declared lifetime parameter bounds are satisfied\",\n-                );\n+                RegionOriginNote::Plain { span, msg: fluent::infer::relate_region_param_bound }\n+                    .add_to_diagnostic(err);\n             }\n             infer::CompareImplItemObligation { span, .. } => {\n-                label_or_note(\n-                    span,\n-                    \"...so that the definition in impl matches the definition from the trait\",\n-                );\n+                RegionOriginNote::Plain { span, msg: fluent::infer::compare_impl_item_obligation }\n+                    .add_to_diagnostic(err);\n             }\n             infer::CheckAssociatedTypeBounds { ref parent, .. } => {\n                 self.note_region_origin(err, &parent);"}, {"sha": "233a5004a3931f53444eaf75538edc8f89d65e6a", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors::OpaqueHiddenTypeDiag;\n use crate::infer::{DefiningAnchor, InferCtxt, InferOk};\n use crate::traits;\n use hir::def_id::{DefId, LocalDefId};\n@@ -153,22 +154,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     if let Some(OpaqueTyOrigin::TyAlias) =\n                         did2.as_local().and_then(|did2| self.opaque_type_origin(did2, cause.span))\n                     {\n-                        self.tcx\n-                                .sess\n-                                .struct_span_err(\n-                                    cause.span,\n-                                    \"opaque type's hidden type cannot be another opaque type from the same scope\",\n-                                )\n-                                .span_label(cause.span, \"one of the two opaque types used here has to be outside its defining scope\")\n-                                .span_note(\n-                                    self.tcx.def_span(def_id),\n-                                    \"opaque type whose hidden type is being assigned\",\n-                                )\n-                                .span_note(\n-                                    self.tcx.def_span(did2),\n-                                    \"opaque type being used as hidden type\",\n-                                )\n-                                .emit();\n+                        self.tcx.sess.emit_err(OpaqueHiddenTypeDiag {\n+                            span: cause.span,\n+                            hidden_type: self.tcx.def_span(did2),\n+                            opaque_type: self.tcx.def_span(def_id),\n+                        });\n                     }\n                 }\n                 Some(self.register_hidden_type("}, {"sha": "602a9ab13f37792b9a0fdadce06d4f839aadba0e", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -34,5 +34,6 @@ extern crate tracing;\n #[macro_use]\n extern crate rustc_middle;\n \n+mod errors;\n pub mod infer;\n pub mod traits;"}, {"sha": "a4ccfcace1923e6bc81cc18519649c75c407eb59", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -148,9 +148,9 @@ impl DiagnosticDeriveBuilder {\n             // `#[help(..)]`/`#[note(..)]` when the user is specifying a alternative slug.\n             Meta::List(MetaList { ref nested, .. }) => nested,\n             // Subdiagnostics without spans can be applied to the type too, and these are just\n-            // paths: `#[help]`, `#[note]` and `#[warn_]`\n+            // paths: `#[help]`, `#[note]` and `#[warning]`\n             Meta::Path(_) if !is_diag => {\n-                let fn_name = if name == \"warn_\" {\n+                let fn_name = if name == \"warning\" {\n                     Ident::new(\"warn\", attr.span())\n                 } else {\n                     Ident::new(name, attr.span())\n@@ -163,12 +163,15 @@ impl DiagnosticDeriveBuilder {\n         // Check the kind before doing any further processing so that there aren't misleading\n         // \"no kind specified\" errors if there are failures later.\n         match name {\n-            \"error\" | \"warning\" | \"lint\" => throw_invalid_attr!(attr, &meta, |diag| {\n-                diag.help(\"`error`, `warning` and `lint` have been replaced by `diag`\")\n+            \"error\" | \"lint\" => throw_invalid_attr!(attr, &meta, |diag| {\n+                diag.help(\"`error` and `lint` have been replaced by `diag`\")\n             }),\n-            \"diag\" | \"help\" | \"note\" | \"warn_\" => (),\n+            \"warn_\" => throw_invalid_attr!(attr, &meta, |diag| {\n+                diag.help(\"`warn_` have been replaced by `warning`\")\n+            }),\n+            \"diag\" | \"help\" | \"note\" | \"warning\" => (),\n             _ => throw_invalid_attr!(attr, &meta, |diag| {\n-                diag.help(\"only `diag`, `help`, `note` and `warn_` are valid attributes\")\n+                diag.help(\"only `diag`, `help`, `note` and `warning` are valid attributes\")\n             }),\n         }\n \n@@ -180,7 +183,7 @@ impl DiagnosticDeriveBuilder {\n             if !is_diag && nested_iter.next().is_some() {\n                 throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n                     diag.help(\n-                        \"`help`, `note` and `warn_` struct attributes can only have one argument\",\n+                        \"`help`, `note` and `warning` struct attributes can only have one argument\",\n                     )\n                 });\n             }\n@@ -348,12 +351,12 @@ impl DiagnosticDeriveBuilder {\n                 report_error_if_not_applied_to_span(attr, &info)?;\n                 Ok(self.add_spanned_subdiagnostic(binding, ident, parse_quote! { _subdiag::label }))\n             }\n-            \"note\" | \"help\" | \"warn_\" => {\n+            \"note\" | \"help\" | \"warning\" => {\n                 let warn_ident = Ident::new(\"warn\", Span::call_site());\n                 let (ident, path) = match name {\n                     \"note\" => (ident, parse_quote! { _subdiag::note }),\n                     \"help\" => (ident, parse_quote! { _subdiag::help }),\n-                    \"warn_\" => (&warn_ident, parse_quote! { _subdiag::warn }),\n+                    \"warning\" => (&warn_ident, parse_quote! { _subdiag::warn }),\n                     _ => unreachable!(),\n                 };\n                 if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n@@ -390,7 +393,7 @@ impl DiagnosticDeriveBuilder {\n             \"suggestion\" | \"suggestion_short\" | \"suggestion_hidden\" | \"suggestion_verbose\" => {\n                 return self.generate_inner_field_code_suggestion(attr, info);\n             }\n-            \"label\" | \"help\" | \"note\" | \"warn_\" => (),\n+            \"label\" | \"help\" | \"note\" | \"warning\" => (),\n             _ => throw_invalid_attr!(attr, &meta, |diag| {\n                 diag.help(\n                     \"only `label`, `help`, `note`, `warn` or `suggestion{,_short,_hidden,_verbose}` are \\\n@@ -422,14 +425,14 @@ impl DiagnosticDeriveBuilder {\n                 Ok(self.add_spanned_subdiagnostic(binding, ident, msg))\n             }\n             \"note\" | \"help\" if type_is_unit(&info.ty) => Ok(self.add_subdiagnostic(ident, msg)),\n-            // `warn_` must be special-cased because the attribute `warn` already has meaning and\n+            // `warning` must be special-cased because the attribute `warn` already has meaning and\n             // so isn't used, despite the diagnostic API being named `warn`.\n-            \"warn_\" if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) => Ok(self\n+            \"warning\" if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) => Ok(self\n                 .add_spanned_subdiagnostic(binding, &Ident::new(\"warn\", Span::call_site()), msg)),\n-            \"warn_\" if type_is_unit(&info.ty) => {\n+            \"warning\" if type_is_unit(&info.ty) => {\n                 Ok(self.add_subdiagnostic(&Ident::new(\"warn\", Span::call_site()), msg))\n             }\n-            \"note\" | \"help\" | \"warn_\" => report_type_error(attr, \"`Span` or `()`\")?,\n+            \"note\" | \"help\" | \"warning\" => report_type_error(attr, \"`Span` or `()`\")?,\n             _ => unreachable!(),\n         }\n     }"}, {"sha": "666dbc23c287cb3daef7efb7ed219f4e94a172da", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -37,7 +37,7 @@ enum SubdiagnosticKind {\n     Note,\n     /// `#[help(...)]`\n     Help,\n-    /// `#[warn_(...)]`\n+    /// `#[warning(...)]`\n     Warn,\n     /// `#[suggestion{,_short,_hidden,_verbose}]`\n     Suggestion(SubdiagnosticSuggestionKind),\n@@ -51,7 +51,7 @@ impl FromStr for SubdiagnosticKind {\n             \"label\" => Ok(SubdiagnosticKind::Label),\n             \"note\" => Ok(SubdiagnosticKind::Note),\n             \"help\" => Ok(SubdiagnosticKind::Help),\n-            \"warn_\" => Ok(SubdiagnosticKind::Warn),\n+            \"warning\" => Ok(SubdiagnosticKind::Warn),\n             \"suggestion\" => Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Normal)),\n             \"suggestion_short\" => {\n                 Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Short))"}, {"sha": "8faac8ef36a53a216a4787d7ecf58de0b252211f", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -132,7 +132,7 @@ decl_derive!(\n         diag,\n         help,\n         note,\n-        warn_,\n+        warning,\n         // field attributes\n         skip_arg,\n         primary_span,\n@@ -149,7 +149,7 @@ decl_derive!(\n         diag,\n         help,\n         note,\n-        warn_,\n+        warning,\n         // field attributes\n         skip_arg,\n         primary_span,\n@@ -166,7 +166,7 @@ decl_derive!(\n         label,\n         help,\n         note,\n-        warn_,\n+        warning,\n         suggestion,\n         suggestion_short,\n         suggestion_hidden,"}, {"sha": "d1f3561c02c5d52c0b9bf4d72e4783fbefb25011", "filename": "compiler/rustc_middle/src/mir/generic_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgeneric_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgeneric_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgeneric_graph.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -12,14 +12,14 @@ pub fn mir_fn_to_generic_graph<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'_>) -> Grap\n \n     // Nodes\n     let nodes: Vec<Node> = body\n-        .basic_blocks()\n+        .basic_blocks\n         .iter_enumerated()\n         .map(|(block, _)| bb_to_graph_node(block, body, dark_mode))\n         .collect();\n \n     // Edges\n     let mut edges = Vec::new();\n-    for (source, _) in body.basic_blocks().iter_enumerated() {\n+    for (source, _) in body.basic_blocks.iter_enumerated() {\n         let def_id = body.source.def_id();\n         let terminator = body[source].terminator();\n         let labels = terminator.kind.fmt_successor_labels();"}, {"sha": "f7a1e9b2864888b2f6b5eecfcb37fe96bf87b2f4", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -331,11 +331,6 @@ impl<'tcx> Body<'tcx> {\n         body\n     }\n \n-    #[inline]\n-    pub fn basic_blocks(&self) -> &IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n-        &self.basic_blocks\n-    }\n-\n     #[inline]\n     pub fn basic_blocks_mut(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n         self.basic_blocks.as_mut()\n@@ -490,7 +485,7 @@ impl<'tcx> Index<BasicBlock> for Body<'tcx> {\n \n     #[inline]\n     fn index(&self, index: BasicBlock) -> &BasicBlockData<'tcx> {\n-        &self.basic_blocks()[index]\n+        &self.basic_blocks[index]\n     }\n }\n "}, {"sha": "24fe3b47256e2927f4fa0c1ceba971a94c73df80", "filename": "compiler/rustc_middle/src/mir/patch.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpatch.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -19,7 +19,7 @@ pub struct MirPatch<'tcx> {\n impl<'tcx> MirPatch<'tcx> {\n     pub fn new(body: &Body<'tcx>) -> Self {\n         let mut result = MirPatch {\n-            patch_map: IndexVec::from_elem(None, body.basic_blocks()),\n+            patch_map: IndexVec::from_elem(None, &body.basic_blocks),\n             new_blocks: vec![],\n             new_statements: vec![],\n             new_locals: vec![],\n@@ -29,7 +29,7 @@ impl<'tcx> MirPatch<'tcx> {\n         };\n \n         // Check if we already have a resume block\n-        for (bb, block) in body.basic_blocks().iter_enumerated() {\n+        for (bb, block) in body.basic_blocks.iter_enumerated() {\n             if let TerminatorKind::Resume = block.terminator().kind && block.statements.is_empty() {\n                 result.resume_block = Some(bb);\n                 break;\n@@ -61,7 +61,7 @@ impl<'tcx> MirPatch<'tcx> {\n     }\n \n     pub fn terminator_loc(&self, body: &Body<'tcx>, bb: BasicBlock) -> Location {\n-        let offset = match bb.index().checked_sub(body.basic_blocks().len()) {\n+        let offset = match bb.index().checked_sub(body.basic_blocks.len()) {\n             Some(index) => self.new_blocks[index].statements.len(),\n             None => body[bb].statements.len(),\n         };\n@@ -129,7 +129,7 @@ impl<'tcx> MirPatch<'tcx> {\n         debug!(\n             \"MirPatch: {} new blocks, starting from index {}\",\n             self.new_blocks.len(),\n-            body.basic_blocks().len()\n+            body.basic_blocks.len()\n         );\n         let bbs = if self.patch_map.is_empty() && self.new_blocks.is_empty() {\n             body.basic_blocks.as_mut_preserves_cfg()\n@@ -173,7 +173,7 @@ impl<'tcx> MirPatch<'tcx> {\n     }\n \n     pub fn source_info_for_location(&self, body: &Body<'tcx>, loc: Location) -> SourceInfo {\n-        let data = match loc.block.index().checked_sub(body.basic_blocks().len()) {\n+        let data = match loc.block.index().checked_sub(body.basic_blocks.len()) {\n             Some(new) => &self.new_blocks[new],\n             None => &body[loc.block],\n         };"}, {"sha": "da6af89b09b9b9a22cee906b971b7407b0887f4c", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -318,10 +318,10 @@ where\n     F: FnMut(PassWhere, &mut dyn Write) -> io::Result<()>,\n {\n     write_mir_intro(tcx, body, w)?;\n-    for block in body.basic_blocks().indices() {\n+    for block in body.basic_blocks.indices() {\n         extra_data(PassWhere::BeforeBlock(block), w)?;\n         write_basic_block(tcx, block, body, extra_data, w)?;\n-        if block.index() + 1 != body.basic_blocks().len() {\n+        if block.index() + 1 != body.basic_blocks.len() {\n             writeln!(w)?;\n         }\n     }"}, {"sha": "6e64a3b80c1fb18beaff270d864d96235c348890", "filename": "compiler/rustc_middle/src/mir/spanview.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -105,7 +105,7 @@ where\n     }\n     let body_span = hir_body.unwrap().value.span;\n     let mut span_viewables = Vec::new();\n-    for (bb, data) in body.basic_blocks().iter_enumerated() {\n+    for (bb, data) in body.basic_blocks.iter_enumerated() {\n         match spanview {\n             MirSpanview::Statement => {\n                 for (i, statement) in data.statements.iter().enumerate() {"}, {"sha": "55b2c592795bff6eb4a18ad2ccff5e9b953e166d", "filename": "compiler/rustc_middle/src/mir/traversal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -37,7 +37,7 @@ impl<'a, 'tcx> Preorder<'a, 'tcx> {\n \n         Preorder {\n             body,\n-            visited: BitSet::new_empty(body.basic_blocks().len()),\n+            visited: BitSet::new_empty(body.basic_blocks.len()),\n             worklist,\n             root_is_start_block: root == START_BLOCK,\n         }\n@@ -71,7 +71,7 @@ impl<'a, 'tcx> Iterator for Preorder<'a, 'tcx> {\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n         // All the blocks, minus the number of blocks we've visited.\n-        let upper = self.body.basic_blocks().len() - self.visited.count();\n+        let upper = self.body.basic_blocks.len() - self.visited.count();\n \n         let lower = if self.root_is_start_block {\n             // We will visit all remaining blocks exactly once."}, {"sha": "7bd65f42e3f925a2b2d799cb681394ba2410a835", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -951,7 +951,7 @@ macro_rules! basic_blocks {\n         $body.basic_blocks.as_mut_preserves_cfg()\n     };\n     ($body:ident,) => {\n-        $body.basic_blocks()\n+        $body.basic_blocks\n     };\n }\n "}, {"sha": "ab7e5ba3a1067f56cae54bf1e87489231a80114b", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -469,6 +469,13 @@ impl<'tcx> ObligationCauseCode<'tcx> {\n             _ => None,\n         }\n     }\n+\n+    pub fn peel_match_impls(&self) -> &Self {\n+        match self {\n+            MatchImpl(cause, _) => cause.code(),\n+            _ => self,\n+        }\n+    }\n }\n \n // `ObligationCauseCode` is used a lot. Make sure it doesn't unintentionally get bigger."}, {"sha": "684b228e87fa983ef3b778fe587c41f354fc7c3b", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -272,7 +272,7 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n         // by borrow checking.\n         debug_assert!(\n             !(body.local_decls.has_free_regions()\n-                || body.basic_blocks().has_free_regions()\n+                || body.basic_blocks.has_free_regions()\n                 || body.var_debug_info.has_free_regions()\n                 || body.yield_ty().has_free_regions()),\n             \"Unexpected free regions in MIR: {:?}\","}, {"sha": "bc75645e7c9579abc12b8df22ced1a0aa73f7861", "filename": "compiler/rustc_mir_dataflow/src/framework/engine.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -111,9 +111,9 @@ where\n         // Otherwise, compute and store the cumulative transfer function for each block.\n \n         let identity = GenKillSet::identity(analysis.bottom_value(body).domain_size());\n-        let mut trans_for_block = IndexVec::from_elem(identity, body.basic_blocks());\n+        let mut trans_for_block = IndexVec::from_elem(identity, &body.basic_blocks);\n \n-        for (block, block_data) in body.basic_blocks().iter_enumerated() {\n+        for (block, block_data) in body.basic_blocks.iter_enumerated() {\n             let trans = &mut trans_for_block[block];\n             A::Direction::gen_kill_effects_in_block(&analysis, trans, block, block_data);\n         }\n@@ -147,7 +147,7 @@ where\n         apply_trans_for_block: Option<Box<dyn Fn(BasicBlock, &mut A::Domain)>>,\n     ) -> Self {\n         let bottom_value = analysis.bottom_value(body);\n-        let mut entry_sets = IndexVec::from_elem(bottom_value.clone(), body.basic_blocks());\n+        let mut entry_sets = IndexVec::from_elem(bottom_value.clone(), &body.basic_blocks);\n         analysis.initialize_start_block(body, &mut entry_sets[mir::START_BLOCK]);\n \n         if A::Direction::IS_BACKWARD && entry_sets[mir::START_BLOCK] != bottom_value {\n@@ -200,8 +200,7 @@ where\n             ..\n         } = self;\n \n-        let mut dirty_queue: WorkQueue<BasicBlock> =\n-            WorkQueue::with_none(body.basic_blocks().len());\n+        let mut dirty_queue: WorkQueue<BasicBlock> = WorkQueue::with_none(body.basic_blocks.len());\n \n         if A::Direction::IS_FORWARD {\n             for (bb, _) in traversal::reverse_postorder(body) {"}, {"sha": "579fe68a14935573e213fe616d954825a697c4a6", "filename": "compiler/rustc_mir_dataflow/src/framework/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -108,12 +108,12 @@ where\n     type Edge = CfgEdge;\n \n     fn nodes(&self) -> dot::Nodes<'_, Self::Node> {\n-        self.body.basic_blocks().indices().collect::<Vec<_>>().into()\n+        self.body.basic_blocks.indices().collect::<Vec<_>>().into()\n     }\n \n     fn edges(&self) -> dot::Edges<'_, Self::Edge> {\n         self.body\n-            .basic_blocks()\n+            .basic_blocks\n             .indices()\n             .flat_map(|bb| dataflow_successors(self.body, bb))\n             .collect::<Vec<_>>()"}, {"sha": "17102454a88defed44db4e8abccd676594ac2958", "filename": "compiler/rustc_mir_dataflow/src/framework/tests.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Ftests.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -100,9 +100,9 @@ impl<D: Direction> MockAnalysis<'_, D> {\n \n     fn mock_entry_sets(&self) -> IndexVec<BasicBlock, BitSet<usize>> {\n         let empty = self.bottom_value(self.body);\n-        let mut ret = IndexVec::from_elem(empty, &self.body.basic_blocks());\n+        let mut ret = IndexVec::from_elem(empty, &self.body.basic_blocks);\n \n-        for (bb, _) in self.body.basic_blocks().iter_enumerated() {\n+        for (bb, _) in self.body.basic_blocks.iter_enumerated() {\n             ret[bb] = self.mock_entry_set(bb);\n         }\n \n@@ -169,7 +169,7 @@ impl<'tcx, D: Direction> AnalysisDomain<'tcx> for MockAnalysis<'tcx, D> {\n     const NAME: &'static str = \"mock\";\n \n     fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n-        BitSet::new_empty(Self::BASIC_BLOCK_OFFSET + body.basic_blocks().len())\n+        BitSet::new_empty(Self::BASIC_BLOCK_OFFSET + body.basic_blocks.len())\n     }\n \n     fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut Self::Domain) {\n@@ -271,9 +271,7 @@ fn test_cursor<D: Direction>(analysis: MockAnalysis<'_, D>) {\n     cursor.allow_unreachable();\n \n     let every_target = || {\n-        body.basic_blocks()\n-            .iter_enumerated()\n-            .flat_map(|(bb, _)| SeekTarget::iter_in_block(body, bb))\n+        body.basic_blocks.iter_enumerated().flat_map(|(bb, _)| SeekTarget::iter_in_block(body, bb))\n     };\n \n     let mut seek_to_target = |targ| {"}, {"sha": "c325838622399e7c32d16b2e9ca1fe49df42068c", "filename": "compiler/rustc_mir_dataflow/src/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -243,7 +243,7 @@ pub(super) fn gather_moves<'tcx>(\n \n     builder.gather_args();\n \n-    for (bb, block) in body.basic_blocks().iter_enumerated() {\n+    for (bb, block) in body.basic_blocks.iter_enumerated() {\n         for (i, stmt) in block.statements.iter().enumerate() {\n             let source = Location { block: bb, statement_index: i };\n             builder.gather_statement(source, stmt);"}, {"sha": "b36e268cf8bf78cc0f29604bc56f36050600c121", "filename": "compiler/rustc_mir_dataflow/src/move_paths/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fmod.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -217,7 +217,7 @@ where\n     fn new(body: &Body<'_>) -> Self {\n         LocationMap {\n             map: body\n-                .basic_blocks()\n+                .basic_blocks\n                 .iter()\n                 .map(|block| vec![T::default(); block.statements.len() + 1])\n                 .collect(),"}, {"sha": "7cae68efbecc3e7aec07a9316c49d933fcc8b255", "filename": "compiler/rustc_mir_dataflow/src/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -101,7 +101,7 @@ pub fn sanity_check_via_rustc_peek<'tcx, A>(\n \n     let mut cursor = ResultsCursor::new(body, results);\n \n-    let peek_calls = body.basic_blocks().iter_enumerated().filter_map(|(bb, block_data)| {\n+    let peek_calls = body.basic_blocks.iter_enumerated().filter_map(|(bb, block_data)| {\n         PeekCall::from_terminator(tcx, block_data.terminator()).map(|call| (bb, block_data, call))\n     });\n "}, {"sha": "e5a0e1d312eaede55fa60815ef6efc16df7cfeec", "filename": "compiler/rustc_mir_dataflow/src/storage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_dataflow%2Fsrc%2Fstorage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_dataflow%2Fsrc%2Fstorage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fstorage.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -7,7 +7,7 @@ use rustc_middle::mir::{self, Local};\n pub fn always_storage_live_locals(body: &mir::Body<'_>) -> BitSet<Local> {\n     let mut always_live_locals = BitSet::new_filled(body.local_decls.len());\n \n-    for block in body.basic_blocks() {\n+    for block in &*body.basic_blocks {\n         for statement in &block.statements {\n             use mir::StatementKind::{StorageDead, StorageLive};\n             if let StorageLive(l) | StorageDead(l) = statement.kind {"}, {"sha": "d8f85d2e3798290d8a722bf8cc6daa620b5055e2", "filename": "compiler/rustc_mir_transform/src/abort_unwinding_calls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -56,7 +56,7 @@ impl<'tcx> MirPass<'tcx> for AbortUnwindingCalls {\n         // example.\n         let mut calls_to_terminate = Vec::new();\n         let mut cleanups_to_remove = Vec::new();\n-        for (id, block) in body.basic_blocks().iter_enumerated() {\n+        for (id, block) in body.basic_blocks.iter_enumerated() {\n             if block.is_cleanup {\n                 continue;\n             }"}, {"sha": "30966d22e2f6d03a092317da794cff03d335fd36", "filename": "compiler/rustc_mir_transform/src/add_call_guards.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_call_guards.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -45,7 +45,7 @@ impl AddCallGuards {\n         // We need a place to store the new blocks generated\n         let mut new_blocks = Vec::new();\n \n-        let cur_len = body.basic_blocks().len();\n+        let cur_len = body.basic_blocks.len();\n \n         for block in body.basic_blocks_mut() {\n             match block.terminator {"}, {"sha": "ffb5d8c6d95f279852bd50834478c1db71633665", "filename": "compiler/rustc_mir_transform/src/add_moves_for_packed_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_moves_for_packed_drops.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -55,7 +55,7 @@ fn add_moves_for_packed_drops_patch<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>)\n     let mut patch = MirPatch::new(body);\n     let param_env = tcx.param_env(def_id);\n \n-    for (bb, data) in body.basic_blocks().iter_enumerated() {\n+    for (bb, data) in body.basic_blocks.iter_enumerated() {\n         let loc = Location { block: bb, statement_index: data.statements.len() };\n         let terminator = data.terminator();\n "}, {"sha": "036b5589849a274542145f19e7876cc252fd6cf1", "filename": "compiler/rustc_mir_transform/src/add_retag.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -66,7 +66,6 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n         // We need an `AllCallEdges` pass before we can do any work.\n         super::add_call_guards::AllCallEdges.run_pass(tcx, body);\n \n-        let (span, arg_count) = (body.span, body.arg_count);\n         let basic_blocks = body.basic_blocks.as_mut();\n         let local_decls = &body.local_decls;\n         let needs_retag = |place: &Place<'tcx>| {\n@@ -90,20 +89,18 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n         // PART 1\n         // Retag arguments at the beginning of the start block.\n         {\n-            // FIXME: Consider using just the span covering the function\n-            // argument declaration.\n-            let source_info = SourceInfo::outermost(span);\n             // Gather all arguments, skip return value.\n-            let places = local_decls\n-                .iter_enumerated()\n-                .skip(1)\n-                .take(arg_count)\n-                .map(|(local, _)| Place::from(local))\n-                .filter(needs_retag);\n+            let places = local_decls.iter_enumerated().skip(1).take(body.arg_count).filter_map(\n+                |(local, decl)| {\n+                    let place = Place::from(local);\n+                    needs_retag(&place).then_some((place, decl.source_info))\n+                },\n+            );\n+\n             // Emit their retags.\n             basic_blocks[START_BLOCK].statements.splice(\n                 0..0,\n-                places.map(|place| Statement {\n+                places.map(|(place, source_info)| Statement {\n                     source_info,\n                     kind: StatementKind::Retag(RetagKind::FnEntry, Box::new(place)),\n                 }),"}, {"sha": "0a305a402095d758aecbe4ca5287f357f3c1a61e", "filename": "compiler/rustc_mir_transform/src/const_goto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_goto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_goto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_goto.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -61,14 +61,14 @@ impl<'tcx> Visitor<'tcx> for ConstGotoOptimizationFinder<'_, 'tcx> {\n         let _: Option<_> = try {\n             let target = terminator.kind.as_goto()?;\n             // We only apply this optimization if the last statement is a const assignment\n-            let last_statement = self.body.basic_blocks()[location.block].statements.last()?;\n+            let last_statement = self.body.basic_blocks[location.block].statements.last()?;\n \n             if let (place, Rvalue::Use(Operand::Constant(_const))) =\n                 last_statement.kind.as_assign()?\n             {\n                 // We found a constant being assigned to `place`.\n                 // Now check that the target of this Goto switches on this place.\n-                let target_bb = &self.body.basic_blocks()[target];\n+                let target_bb = &self.body.basic_blocks[target];\n \n                 // The `StorageDead(..)` statement does not affect the functionality of mir.\n                 // We can move this part of the statement up to the predecessor."}, {"sha": "5c9f4f57243b7bc5cf265bf61ee965c22fc7f39c", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -131,7 +131,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n \n         let dummy_body = &Body::new(\n             body.source,\n-            body.basic_blocks().clone(),\n+            (*body.basic_blocks).clone(),\n             body.source_scopes.clone(),\n             body.local_decls.clone(),\n             Default::default(),"}, {"sha": "74b146833d03f27ecdfe7778ff083cca442adccd", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -105,7 +105,7 @@ impl<'tcx> MirLint<'tcx> for ConstProp {\n \n         let dummy_body = &Body::new(\n             body.source,\n-            body.basic_blocks().clone(),\n+            (*body.basic_blocks).clone(),\n             body.source_scopes.clone(),\n             body.local_decls.clone(),\n             Default::default(),\n@@ -522,7 +522,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n     fn visit_body(&mut self, body: &Body<'tcx>) {\n-        for (bb, data) in body.basic_blocks().iter_enumerated() {\n+        for (bb, data) in body.basic_blocks.iter_enumerated() {\n             self.visit_basic_block_data(bb, data);\n         }\n     }"}, {"sha": "782129be088b68ce979b6323463ba8525a512f41", "filename": "compiler/rustc_mir_transform/src/coverage/graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -713,7 +713,7 @@ impl<\n \n         ShortCircuitPreorder {\n             body,\n-            visited: BitSet::new_empty(body.basic_blocks().len()),\n+            visited: BitSet::new_empty(body.basic_blocks.len()),\n             worklist,\n             filtered_successors,\n         }\n@@ -747,7 +747,7 @@ impl<\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let size = self.body.basic_blocks().len() - self.visited.count();\n+        let size = self.body.basic_blocks.len() - self.visited.count();\n         (size, Some(size))\n     }\n }"}, {"sha": "604810144887adda513733764f55f068a7882992", "filename": "compiler/rustc_mir_transform/src/coverage/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -80,7 +80,7 @@ impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n             return;\n         }\n \n-        match mir_body.basic_blocks()[mir::START_BLOCK].terminator().kind {\n+        match mir_body.basic_blocks[mir::START_BLOCK].terminator().kind {\n             TerminatorKind::Unreachable => {\n                 trace!(\"InstrumentCoverage skipped for unreachable `START_BLOCK`\");\n                 return;"}, {"sha": "dc1e68b253e7267b401b08472370cb7a6708c060", "filename": "compiler/rustc_mir_transform/src/coverage/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fquery.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -84,7 +84,7 @@ impl CoverageVisitor {\n     }\n \n     fn visit_body(&mut self, body: &Body<'_>) {\n-        for bb_data in body.basic_blocks().iter() {\n+        for bb_data in body.basic_blocks.iter() {\n             for statement in bb_data.statements.iter() {\n                 if let StatementKind::Coverage(box ref coverage) = statement.kind {\n                     if is_inlined(body, statement) {\n@@ -138,7 +138,7 @@ fn coverageinfo<'tcx>(tcx: TyCtxt<'tcx>, instance_def: ty::InstanceDef<'tcx>) ->\n \n fn covered_code_regions<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Vec<&'tcx CodeRegion> {\n     let body = mir_body(tcx, def_id);\n-    body.basic_blocks()\n+    body.basic_blocks\n         .iter()\n         .flat_map(|data| {\n             data.statements.iter().filter_map(|statement| match statement.kind {"}, {"sha": "9c9ed5fa5105eda71866b54d8dd8b24f99abcda3", "filename": "compiler/rustc_mir_transform/src/coverage/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -176,7 +176,7 @@ fn debug_basic_blocks<'tcx>(mir_body: &Body<'tcx>) -> String {\n     format!(\n         \"{:?}\",\n         mir_body\n-            .basic_blocks()\n+            .basic_blocks\n             .iter_enumerated()\n             .map(|(bb, data)| {\n                 let term = &data.terminator();\n@@ -213,7 +213,7 @@ fn print_mir_graphviz(name: &str, mir_body: &Body<'_>) {\n             \"digraph {} {{\\n{}\\n}}\",\n             name,\n             mir_body\n-                .basic_blocks()\n+                .basic_blocks\n                 .iter_enumerated()\n                 .map(|(bb, data)| {\n                     format!(\n@@ -653,7 +653,7 @@ fn test_traverse_coverage_with_loops() {\n \n fn synthesize_body_span_from_terminators(mir_body: &Body<'_>) -> Span {\n     let mut some_span: Option<Span> = None;\n-    for (_, data) in mir_body.basic_blocks().iter_enumerated() {\n+    for (_, data) in mir_body.basic_blocks.iter_enumerated() {\n         let term_span = data.terminator().source_info.span;\n         if let Some(span) = some_span.as_mut() {\n             *span = span.to(term_span);"}, {"sha": "909116a77f54f73e910c9952d060e0959e48d638", "filename": "compiler/rustc_mir_transform/src/deduplicate_blocks.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduplicate_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduplicate_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduplicate_blocks.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -58,7 +58,7 @@ fn find_duplicates(body: &Body<'_>) -> FxHashMap<BasicBlock, BasicBlock> {\n     let mut duplicates = FxHashMap::default();\n \n     let bbs_to_go_through =\n-        body.basic_blocks().iter_enumerated().filter(|(_, bbd)| !bbd.is_cleanup).count();\n+        body.basic_blocks.iter_enumerated().filter(|(_, bbd)| !bbd.is_cleanup).count();\n \n     let mut same_hashes =\n         FxHashMap::with_capacity_and_hasher(bbs_to_go_through, Default::default());\n@@ -71,8 +71,7 @@ fn find_duplicates(body: &Body<'_>) -> FxHashMap<BasicBlock, BasicBlock> {\n     // When we see bb1, we see that it is a duplicate of bb3, and therefore insert it in the duplicates list\n     // with replacement bb3.\n     // When the duplicates are removed, we will end up with only bb3.\n-    for (bb, bbd) in body.basic_blocks().iter_enumerated().rev().filter(|(_, bbd)| !bbd.is_cleanup)\n-    {\n+    for (bb, bbd) in body.basic_blocks.iter_enumerated().rev().filter(|(_, bbd)| !bbd.is_cleanup) {\n         // Basic blocks can get really big, so to avoid checking for duplicates in basic blocks\n         // that are unlikely to have duplicates, we stop early. The early bail number has been\n         // found experimentally by eprintln while compiling the crates in the rustc-perf suite."}, {"sha": "da55510920e12ec6eaf3de10dd0bbfebcd2170b3", "filename": "compiler/rustc_mir_transform/src/dest_prop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -150,7 +150,7 @@ impl<'tcx> MirPass<'tcx> for DestinationPropagation {\n             def_id,\n             body.local_decls.len(),\n             relevant,\n-            body.basic_blocks().len()\n+            body.basic_blocks.len()\n         );\n         if relevant > MAX_LOCALS {\n             warn!(\n@@ -159,11 +159,11 @@ impl<'tcx> MirPass<'tcx> for DestinationPropagation {\n             );\n             return;\n         }\n-        if body.basic_blocks().len() > MAX_BLOCKS {\n+        if body.basic_blocks.len() > MAX_BLOCKS {\n             warn!(\n                 \"too many blocks in {:?} ({}, max is {}), not optimizing\",\n                 def_id,\n-                body.basic_blocks().len(),\n+                body.basic_blocks.len(),\n                 MAX_BLOCKS\n             );\n             return;"}, {"sha": "32e738bbcea44b108c47e2dd948cef4f242dbbdb", "filename": "compiler/rustc_mir_transform/src/early_otherwise_branch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fearly_otherwise_branch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fearly_otherwise_branch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fearly_otherwise_branch.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -104,8 +104,8 @@ impl<'tcx> MirPass<'tcx> for EarlyOtherwiseBranch {\n         let mut should_cleanup = false;\n \n         // Also consider newly generated bbs in the same pass\n-        for i in 0..body.basic_blocks().len() {\n-            let bbs = body.basic_blocks();\n+        for i in 0..body.basic_blocks.len() {\n+            let bbs = &*body.basic_blocks;\n             let parent = BasicBlock::from_usize(i);\n             let Some(opt_data) = evaluate_candidate(tcx, body, parent) else {\n                 continue\n@@ -316,7 +316,7 @@ fn evaluate_candidate<'tcx>(\n     body: &Body<'tcx>,\n     parent: BasicBlock,\n ) -> Option<OptimizationData<'tcx>> {\n-    let bbs = body.basic_blocks();\n+    let bbs = &body.basic_blocks;\n     let TerminatorKind::SwitchInt {\n         targets,\n         switch_ty: parent_ty,"}, {"sha": "61118ecc8ed51b0a89c8d2b64a11b57a8e9ac274", "filename": "compiler/rustc_mir_transform/src/elaborate_drops.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -89,13 +89,13 @@ fn find_dead_unwinds<'tcx>(\n     debug!(\"find_dead_unwinds({:?})\", body.span);\n     // We only need to do this pass once, because unwind edges can only\n     // reach cleanup blocks, which can't have unwind edges themselves.\n-    let mut dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n+    let mut dead_unwinds = BitSet::new_empty(body.basic_blocks.len());\n     let mut flow_inits = MaybeInitializedPlaces::new(tcx, body, &env)\n         .into_engine(tcx, body)\n         .pass_name(\"find_dead_unwinds\")\n         .iterate_to_fixpoint()\n         .into_results_cursor(body);\n-    for (bb, bb_data) in body.basic_blocks().iter_enumerated() {\n+    for (bb, bb_data) in body.basic_blocks.iter_enumerated() {\n         let place = match bb_data.terminator().kind {\n             TerminatorKind::Drop { ref place, unwind: Some(_), .. }\n             | TerminatorKind::DropAndReplace { ref place, unwind: Some(_), .. } => {\n@@ -303,7 +303,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     }\n \n     fn collect_drop_flags(&mut self) {\n-        for (bb, data) in self.body.basic_blocks().iter_enumerated() {\n+        for (bb, data) in self.body.basic_blocks.iter_enumerated() {\n             let terminator = data.terminator();\n             let place = match terminator.kind {\n                 TerminatorKind::Drop { ref place, .. }\n@@ -358,7 +358,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     }\n \n     fn elaborate_drops(&mut self) {\n-        for (bb, data) in self.body.basic_blocks().iter_enumerated() {\n+        for (bb, data) in self.body.basic_blocks.iter_enumerated() {\n             let loc = Location { block: bb, statement_index: data.statements.len() };\n             let terminator = data.terminator();\n \n@@ -515,7 +515,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     }\n \n     fn drop_flags_for_fn_rets(&mut self) {\n-        for (bb, data) in self.body.basic_blocks().iter_enumerated() {\n+        for (bb, data) in self.body.basic_blocks.iter_enumerated() {\n             if let TerminatorKind::Call {\n                 destination, target: Some(tgt), cleanup: Some(_), ..\n             } = data.terminator().kind\n@@ -550,7 +550,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         // drop flags by themselves, to avoid the drop flags being\n         // clobbered before they are read.\n \n-        for (bb, data) in self.body.basic_blocks().iter_enumerated() {\n+        for (bb, data) in self.body.basic_blocks.iter_enumerated() {\n             debug!(\"drop_flags_for_locs({:?})\", data);\n             for i in 0..(data.statements.len() + 1) {\n                 debug!(\"drop_flag_for_locs: stmt {}\", i);"}, {"sha": "7522a50a8c6436ebf94fee1af0bf79f80cf1b41f", "filename": "compiler/rustc_mir_transform/src/ffi_unwind_calls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -65,7 +65,7 @@ fn has_ffi_unwind_calls(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> bool {\n \n     let mut tainted = false;\n \n-    for block in body.basic_blocks() {\n+    for block in body.basic_blocks.iter() {\n         if block.is_cleanup {\n             continue;\n         }"}, {"sha": "c260611b40712cd5c10d0bfd542f81a38e4f5981", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -490,12 +490,12 @@ fn locals_live_across_suspend_points<'tcx>(\n         .iterate_to_fixpoint()\n         .into_results_cursor(body_ref);\n \n-    let mut storage_liveness_map = IndexVec::from_elem(None, body.basic_blocks());\n+    let mut storage_liveness_map = IndexVec::from_elem(None, &body.basic_blocks);\n     let mut live_locals_at_suspension_points = Vec::new();\n     let mut source_info_at_suspension_points = Vec::new();\n     let mut live_locals_at_any_suspension_point = BitSet::new_empty(body.local_decls.len());\n \n-    for (block, data) in body.basic_blocks().iter_enumerated() {\n+    for (block, data) in body.basic_blocks.iter_enumerated() {\n         if let TerminatorKind::Yield { .. } = data.terminator().kind {\n             let loc = Location { block, statement_index: data.statements.len() };\n \n@@ -704,7 +704,7 @@ impl<'mir, 'tcx> rustc_mir_dataflow::ResultsVisitor<'mir, 'tcx>\n impl StorageConflictVisitor<'_, '_, '_> {\n     fn apply_state(&mut self, flow_state: &BitSet<Local>, loc: Location) {\n         // Ignore unreachable blocks.\n-        if self.body.basic_blocks()[loc.block].terminator().kind == TerminatorKind::Unreachable {\n+        if self.body.basic_blocks[loc.block].terminator().kind == TerminatorKind::Unreachable {\n             return;\n         }\n \n@@ -886,7 +886,7 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n \n     let mut elaborator = DropShimElaborator { body, patch: MirPatch::new(body), tcx, param_env };\n \n-    for (block, block_data) in body.basic_blocks().iter_enumerated() {\n+    for (block, block_data) in body.basic_blocks.iter_enumerated() {\n         let (target, unwind, source_info) = match block_data.terminator() {\n             Terminator { source_info, kind: TerminatorKind::Drop { place, target, unwind } } => {\n                 if let Some(local) = place.as_local() {\n@@ -991,7 +991,7 @@ fn insert_panic_block<'tcx>(\n     body: &mut Body<'tcx>,\n     message: AssertMessage<'tcx>,\n ) -> BasicBlock {\n-    let assert_block = BasicBlock::new(body.basic_blocks().len());\n+    let assert_block = BasicBlock::new(body.basic_blocks.len());\n     let term = TerminatorKind::Assert {\n         cond: Operand::Constant(Box::new(Constant {\n             span: body.span,\n@@ -1021,7 +1021,7 @@ fn can_return<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, param_env: ty::ParamEn\n     }\n \n     // If there's a return terminator the function may return.\n-    for block in body.basic_blocks() {\n+    for block in body.basic_blocks.iter() {\n         if let TerminatorKind::Return = block.terminator().kind {\n             return true;\n         }\n@@ -1038,7 +1038,7 @@ fn can_unwind<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) -> bool {\n     }\n \n     // Unwinds can only start at certain terminators.\n-    for block in body.basic_blocks() {\n+    for block in body.basic_blocks.iter() {\n         match block.terminator().kind {\n             // These never unwind.\n             TerminatorKind::Goto { .. }"}, {"sha": "ba00f16308eaee28770f632bfea55360ecacc472", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -95,7 +95,7 @@ fn inline<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) -> bool {\n         history: Vec::new(),\n         changed: false,\n     };\n-    let blocks = BasicBlock::new(0)..body.basic_blocks().next_index();\n+    let blocks = BasicBlock::new(0)..body.basic_blocks.next_index();\n     this.process_blocks(body, blocks);\n     this.changed\n }\n@@ -217,9 +217,9 @@ impl<'tcx> Inliner<'tcx> {\n             }\n         }\n \n-        let old_blocks = caller_body.basic_blocks().next_index();\n+        let old_blocks = caller_body.basic_blocks.next_index();\n         self.inline_call(caller_body, &callsite, callee_body);\n-        let new_blocks = old_blocks..caller_body.basic_blocks().next_index();\n+        let new_blocks = old_blocks..caller_body.basic_blocks.next_index();\n \n         Ok(new_blocks)\n     }\n@@ -409,14 +409,14 @@ impl<'tcx> Inliner<'tcx> {\n         // Give a bonus functions with a small number of blocks,\n         // We normally have two or three blocks for even\n         // very small functions.\n-        if callee_body.basic_blocks().len() <= 3 {\n+        if callee_body.basic_blocks.len() <= 3 {\n             threshold += threshold / 4;\n         }\n         debug!(\"    final inline threshold = {}\", threshold);\n \n         // FIXME: Give a bonus to functions with only a single caller\n         let diverges = matches!(\n-            callee_body.basic_blocks()[START_BLOCK].terminator().kind,\n+            callee_body.basic_blocks[START_BLOCK].terminator().kind,\n             TerminatorKind::Unreachable | TerminatorKind::Call { target: None, .. }\n         );\n         if diverges && !matches!(callee_attrs.inline, InlineAttr::Always) {\n@@ -434,13 +434,13 @@ impl<'tcx> Inliner<'tcx> {\n \n         // Traverse the MIR manually so we can account for the effects of inlining on the CFG.\n         let mut work_list = vec![START_BLOCK];\n-        let mut visited = BitSet::new_empty(callee_body.basic_blocks().len());\n+        let mut visited = BitSet::new_empty(callee_body.basic_blocks.len());\n         while let Some(bb) = work_list.pop() {\n             if !visited.insert(bb.index()) {\n                 continue;\n             }\n \n-            let blk = &callee_body.basic_blocks()[bb];\n+            let blk = &callee_body.basic_blocks[bb];\n             checker.visit_basic_block_data(bb, blk);\n \n             let term = blk.terminator();\n@@ -541,7 +541,7 @@ impl<'tcx> Inliner<'tcx> {\n                     args: &args,\n                     new_locals: Local::new(caller_body.local_decls.len())..,\n                     new_scopes: SourceScope::new(caller_body.source_scopes.len())..,\n-                    new_blocks: BasicBlock::new(caller_body.basic_blocks().len())..,\n+                    new_blocks: BasicBlock::new(caller_body.basic_blocks.len())..,\n                     destination: dest,\n                     callsite_scope: caller_body.source_scopes[callsite.source_info.scope].clone(),\n                     callsite,"}, {"sha": "b027f94925d2f303595c5bc9312839c8deea55da", "filename": "compiler/rustc_mir_transform/src/inline/cycle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -153,7 +153,7 @@ pub(crate) fn mir_inliner_callees<'tcx>(\n         _ => tcx.instance_mir(instance),\n     };\n     let mut calls = FxIndexSet::default();\n-    for bb_data in body.basic_blocks() {\n+    for bb_data in body.basic_blocks.iter() {\n         let terminator = bb_data.terminator();\n         if let TerminatorKind::Call { func, .. } = &terminator.kind {\n             let ty = func.ty(&body.local_decls, tcx);"}, {"sha": "3957cd92c4e3940250ebd8dfc5b945d332d810d8", "filename": "compiler/rustc_mir_transform/src/multiple_return_terminators.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fmultiple_return_terminators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fmultiple_return_terminators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fmultiple_return_terminators.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -15,7 +15,7 @@ impl<'tcx> MirPass<'tcx> for MultipleReturnTerminators {\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         // find basic blocks with no statement and a return terminator\n-        let mut bbs_simple_returns = BitSet::new_empty(body.basic_blocks().len());\n+        let mut bbs_simple_returns = BitSet::new_empty(body.basic_blocks.len());\n         let def_id = body.source.def_id();\n         let bbs = body.basic_blocks_mut();\n         for idx in bbs.indices() {"}, {"sha": "a159e61717823e5847d01641fc9f9762bae81139", "filename": "compiler/rustc_mir_transform/src/normalize_array_len.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -21,10 +21,10 @@ impl<'tcx> MirPass<'tcx> for NormalizeArrayLen {\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         // early returns for edge cases of highly unrolled functions\n-        if body.basic_blocks().len() > MAX_NUM_BLOCKS {\n+        if body.basic_blocks.len() > MAX_NUM_BLOCKS {\n             return;\n         }\n-        if body.local_decls().len() > MAX_NUM_LOCALS {\n+        if body.local_decls.len() > MAX_NUM_LOCALS {\n             return;\n         }\n         normalize_array_len_calls(tcx, body)"}, {"sha": "4291e81c78c2523144272658572fa019e9a14b4c", "filename": "compiler/rustc_mir_transform/src/nrvo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -89,7 +89,7 @@ fn local_eligible_for_nrvo(body: &mut mir::Body<'_>) -> Option<Local> {\n     }\n \n     let mut copied_to_return_place = None;\n-    for block in body.basic_blocks().indices() {\n+    for block in body.basic_blocks.indices() {\n         // Look for blocks with a `Return` terminator.\n         if !matches!(body[block].terminator().kind, mir::TerminatorKind::Return) {\n             continue;\n@@ -122,7 +122,7 @@ fn find_local_assigned_to_return_place(\n     body: &mut mir::Body<'_>,\n ) -> Option<Local> {\n     let mut block = start;\n-    let mut seen = HybridBitSet::new_empty(body.basic_blocks().len());\n+    let mut seen = HybridBitSet::new_empty(body.basic_blocks.len());\n \n     // Iterate as long as `block` has exactly one predecessor that we have not yet visited.\n     while seen.insert(block) {"}, {"sha": "41a0bfac41aed2151cf9771f906fc693d25e4951", "filename": "compiler/rustc_mir_transform/src/remove_noop_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_noop_landing_pads.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -94,7 +94,7 @@ impl RemoveNoopLandingPads {\n \n         let mut jumps_folded = 0;\n         let mut landing_pads_removed = 0;\n-        let mut nop_landing_pads = BitSet::new_empty(body.basic_blocks().len());\n+        let mut nop_landing_pads = BitSet::new_empty(body.basic_blocks.len());\n \n         // This is a post-order traversal, so that if A post-dominates B\n         // then A will be visited before B."}, {"sha": "78b6f714a9b0baf7cd02c5039d4c64a20eb1fe2b", "filename": "compiler/rustc_mir_transform/src/remove_uninit_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -35,7 +35,7 @@ impl<'tcx> MirPass<'tcx> for RemoveUninitDrops {\n             .into_results_cursor(body);\n \n         let mut to_remove = vec![];\n-        for (bb, block) in body.basic_blocks().iter_enumerated() {\n+        for (bb, block) in body.basic_blocks.iter_enumerated() {\n             let terminator = block.terminator();\n             let (TerminatorKind::Drop { place, .. } | TerminatorKind::DropAndReplace { place, .. })\n                 = &terminator.kind"}, {"sha": "190f9c1ac158c39bea8b48beb819ad5f0595e4e9", "filename": "compiler/rustc_mir_transform/src/separate_const_switch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fseparate_const_switch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fseparate_const_switch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fseparate_const_switch.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -62,7 +62,7 @@ impl<'tcx> MirPass<'tcx> for SeparateConstSwitch {\n pub fn separate_const_switch(body: &mut Body<'_>) -> usize {\n     let mut new_blocks: SmallVec<[(BasicBlock, BasicBlock); 6]> = SmallVec::new();\n     let predecessors = body.basic_blocks.predecessors();\n-    'block_iter: for (block_id, block) in body.basic_blocks().iter_enumerated() {\n+    'block_iter: for (block_id, block) in body.basic_blocks.iter_enumerated() {\n         if let TerminatorKind::SwitchInt {\n             discr: Operand::Copy(switch_place) | Operand::Move(switch_place),\n             ..\n@@ -90,7 +90,7 @@ pub fn separate_const_switch(body: &mut Body<'_>) -> usize {\n \n                 let mut predecessors_left = predecessors[block_id].len();\n                 'predec_iter: for predecessor_id in predecessors[block_id].iter().copied() {\n-                    let predecessor = &body.basic_blocks()[predecessor_id];\n+                    let predecessor = &body.basic_blocks[predecessor_id];\n \n                     // First we make sure the predecessor jumps\n                     // in a reasonable way"}, {"sha": "bed48db959a53a2e7b9e289c975c6bb41cfcc434", "filename": "compiler/rustc_mir_transform/src/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -74,7 +74,7 @@ pub struct CfgSimplifier<'a, 'tcx> {\n \n impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n     pub fn new(body: &'a mut Body<'tcx>) -> Self {\n-        let mut pred_count = IndexVec::from_elem(0u32, body.basic_blocks());\n+        let mut pred_count = IndexVec::from_elem(0u32, &body.basic_blocks);\n \n         // we can't use mir.predecessors() here because that counts\n         // dead blocks, which we don't want to.\n@@ -263,7 +263,7 @@ impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n \n pub fn remove_dead_blocks<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     let reachable = traversal::reachable_as_bitset(body);\n-    let num_blocks = body.basic_blocks().len();\n+    let num_blocks = body.basic_blocks.len();\n     if num_blocks == reachable.count() {\n         return;\n     }"}, {"sha": "321d8c63b6e028c3d7c9b68d5dd0991c1db4879d", "filename": "compiler/rustc_mir_transform/src/simplify_comparison_integral.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_comparison_integral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_comparison_integral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_comparison_integral.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -151,7 +151,7 @@ struct OptimizationFinder<'a, 'tcx> {\n impl<'tcx> OptimizationFinder<'_, 'tcx> {\n     fn find_optimizations(&self) -> Vec<OptimizationInfo<'tcx>> {\n         self.body\n-            .basic_blocks()\n+            .basic_blocks\n             .iter_enumerated()\n             .filter_map(|(bb_idx, bb)| {\n                 // find switch"}, {"sha": "baeb620ef240393d1d8678c1b305883adc532713", "filename": "compiler/rustc_mir_transform/src/simplify_try.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -596,7 +596,7 @@ struct SimplifyBranchSameOptimizationFinder<'a, 'tcx> {\n impl<'tcx> SimplifyBranchSameOptimizationFinder<'_, 'tcx> {\n     fn find(&self) -> Vec<SimplifyBranchSameOptimization> {\n         self.body\n-            .basic_blocks()\n+            .basic_blocks\n             .iter_enumerated()\n             .filter_map(|(bb_idx, bb)| {\n                 let (discr_switched_on, targets_and_values) = match &bb.terminator().kind {\n@@ -632,7 +632,7 @@ impl<'tcx> SimplifyBranchSameOptimizationFinder<'_, 'tcx> {\n \n                 let mut iter_bbs_reachable = targets_and_values\n                     .iter()\n-                    .map(|target_and_value| (target_and_value, &self.body.basic_blocks()[target_and_value.target]))\n+                    .map(|target_and_value| (target_and_value, &self.body.basic_blocks[target_and_value.target]))\n                     .filter(|(_, bb)| {\n                         // Reaching `unreachable` is UB so assume it doesn't happen.\n                         bb.terminator().kind != TerminatorKind::Unreachable"}, {"sha": "96ea15f1b80970bf59dda11d271446f88a521e01", "filename": "compiler/rustc_mir_transform/src/uninhabited_enum_branching.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Funinhabited_enum_branching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_mir_transform%2Fsrc%2Funinhabited_enum_branching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Funinhabited_enum_branching.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -79,7 +79,7 @@ fn ensure_otherwise_unreachable<'tcx>(\n     targets: &SwitchTargets,\n ) -> Option<BasicBlockData<'tcx>> {\n     let otherwise = targets.otherwise();\n-    let bb = &body.basic_blocks()[otherwise];\n+    let bb = &body.basic_blocks[otherwise];\n     if bb.terminator().kind == TerminatorKind::Unreachable\n         && bb.statements.iter().all(|s| matches!(&s.kind, StatementKind::StorageDead(_)))\n     {\n@@ -102,10 +102,10 @@ impl<'tcx> MirPass<'tcx> for UninhabitedEnumBranching {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         trace!(\"UninhabitedEnumBranching starting for {:?}\", body.source);\n \n-        for bb in body.basic_blocks().indices() {\n+        for bb in body.basic_blocks.indices() {\n             trace!(\"processing block {:?}\", bb);\n \n-            let Some(discriminant_ty) = get_switched_on_type(&body.basic_blocks()[bb], tcx, body) else {\n+            let Some(discriminant_ty) = get_switched_on_type(&body.basic_blocks[bb], tcx, body) else {\n                 continue;\n             };\n "}, {"sha": "43319dc5862e6e79372fdee53c1c995fe36861db", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -481,7 +481,7 @@ fn codegened_and_inlined_items<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> &'tcx DefIdSe\n                     continue;\n                 }\n                 let body = tcx.instance_mir(instance.def);\n-                for block in body.basic_blocks() {\n+                for block in body.basic_blocks.iter() {\n                     for statement in &block.statements {\n                         let mir::StatementKind::Coverage(_) = statement.kind else { continue };\n                         let scope = statement.source_info.scope;"}, {"sha": "901f56ad96d1792385a747fd930c36ccd5aba52e", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -28,7 +28,7 @@ pub struct IgnoredInlineAttrFnProto;\n \n #[derive(LintDiagnostic)]\n #[diag(passes::inline_ignored_constants)]\n-#[warn_]\n+#[warning]\n #[note]\n pub struct IgnoredInlineAttrConstants;\n \n@@ -347,23 +347,23 @@ pub struct MustNotSuspend {\n \n #[derive(LintDiagnostic)]\n #[diag(passes::cold)]\n-#[warn_]\n+#[warning]\n pub struct Cold {\n     #[label]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n #[diag(passes::link)]\n-#[warn_]\n+#[warning]\n pub struct Link {\n     #[label]\n     pub span: Option<Span>,\n }\n \n #[derive(LintDiagnostic)]\n #[diag(passes::link_name)]\n-#[warn_]\n+#[warning]\n pub struct LinkName<'a> {\n     #[help]\n     pub attr_span: Option<Span>,\n@@ -449,15 +449,15 @@ pub struct RustcDirtyClean {\n \n #[derive(LintDiagnostic)]\n #[diag(passes::link_section)]\n-#[warn_]\n+#[warning]\n pub struct LinkSection {\n     #[label]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n #[diag(passes::no_mangle_foreign)]\n-#[warn_]\n+#[warning]\n #[note]\n pub struct NoMangleForeign {\n     #[label]\n@@ -469,7 +469,7 @@ pub struct NoMangleForeign {\n \n #[derive(LintDiagnostic)]\n #[diag(passes::no_mangle)]\n-#[warn_]\n+#[warning]\n pub struct NoMangle {\n     #[label]\n     pub span: Span,\n@@ -617,7 +617,7 @@ pub struct UnusedDuplicate {\n     pub this: Span,\n     #[note]\n     pub other: Span,\n-    #[warn_]\n+    #[warning]\n     pub warning: Option<()>,\n }\n "}, {"sha": "e4af7022239b83fa2492b0754ea1688096a76854", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -1506,13 +1506,28 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                 .emit();\n             }\n             FulfillmentErrorCode::CodeConstEquateError(ref expected_found, ref err) => {\n-                self.report_mismatched_consts(\n+                let mut diag = self.report_mismatched_consts(\n                     &error.obligation.cause,\n                     expected_found.expected,\n                     expected_found.found,\n                     err.clone(),\n-                )\n-                .emit();\n+                );\n+                let code = error.obligation.cause.code().peel_derives().peel_match_impls();\n+                if let ObligationCauseCode::BindingObligation(..)\n+                | ObligationCauseCode::ItemObligation(..)\n+                | ObligationCauseCode::ExprBindingObligation(..)\n+                | ObligationCauseCode::ExprItemObligation(..) = code\n+                {\n+                    self.note_obligation_cause_code(\n+                        &mut diag,\n+                        &error.obligation.predicate,\n+                        error.obligation.param_env,\n+                        code,\n+                        &mut vec![],\n+                        &mut Default::default(),\n+                    );\n+                }\n+                diag.emit();\n             }\n         }\n     }"}, {"sha": "acfeefb4d12d535d9d7a03477a90049cde370ac6", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -348,7 +348,7 @@ fn instance_def_size_estimate<'tcx>(\n     match instance_def {\n         InstanceDef::Item(..) | InstanceDef::DropGlue(..) => {\n             let mir = tcx.instance_mir(instance_def);\n-            mir.basic_blocks().iter().map(|bb| bb.statements.len() + 1).sum()\n+            mir.basic_blocks.iter().map(|bb| bb.statements.len() + 1).sum()\n         }\n         // Estimate the size of other compiler-generated shims to be 1.\n         _ => 1,"}, {"sha": "a38031c48c86251d2c9c0b3e05246de82e3adc10", "filename": "library/std/src/net/parser.rs", "status": "modified", "additions": 125, "deletions": 13, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -39,8 +39,8 @@ struct Parser<'a> {\n }\n \n impl<'a> Parser<'a> {\n-    fn new(input: &'a str) -> Parser<'a> {\n-        Parser { state: input.as_bytes() }\n+    fn new(input: &'a [u8]) -> Parser<'a> {\n+        Parser { state: input }\n     }\n \n     /// Run a parser, and restore the pre-parse state if it fails.\n@@ -273,56 +273,168 @@ impl<'a> Parser<'a> {\n     }\n }\n \n+impl IpAddr {\n+    /// Parse an IP address from a slice of bytes.\n+    ///\n+    /// ```\n+    /// #![feature(addr_parse_ascii)]\n+    ///\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// let localhost_v4 = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));\n+    /// let localhost_v6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n+    ///\n+    /// assert_eq!(IpAddr::parse_ascii(b\"127.0.0.1\"), Ok(localhost_v4));\n+    /// assert_eq!(IpAddr::parse_ascii(b\"::1\"), Ok(localhost_v6));\n+    /// ```\n+    #[unstable(feature = \"addr_parse_ascii\", issue = \"101035\")]\n+    pub fn parse_ascii(b: &[u8]) -> Result<Self, AddrParseError> {\n+        Parser::new(b).parse_with(|p| p.read_ip_addr(), AddrKind::Ip)\n+    }\n+}\n+\n #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n impl FromStr for IpAddr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<IpAddr, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_ip_addr(), AddrKind::Ip)\n+        Self::parse_ascii(s.as_bytes())\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl FromStr for Ipv4Addr {\n-    type Err = AddrParseError;\n-    fn from_str(s: &str) -> Result<Ipv4Addr, AddrParseError> {\n+impl Ipv4Addr {\n+    /// Parse an IPv4 address from a slice of bytes.\n+    ///\n+    /// ```\n+    /// #![feature(addr_parse_ascii)]\n+    ///\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let localhost = Ipv4Addr::new(127, 0, 0, 1);\n+    ///\n+    /// assert_eq!(Ipv4Addr::parse_ascii(b\"127.0.0.1\"), Ok(localhost));\n+    /// ```\n+    #[unstable(feature = \"addr_parse_ascii\", issue = \"101035\")]\n+    pub fn parse_ascii(b: &[u8]) -> Result<Self, AddrParseError> {\n         // don't try to parse if too long\n-        if s.len() > 15 {\n+        if b.len() > 15 {\n             Err(AddrParseError(AddrKind::Ipv4))\n         } else {\n-            Parser::new(s).parse_with(|p| p.read_ipv4_addr(), AddrKind::Ipv4)\n+            Parser::new(b).parse_with(|p| p.read_ipv4_addr(), AddrKind::Ipv4)\n         }\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl FromStr for Ipv4Addr {\n+    type Err = AddrParseError;\n+    fn from_str(s: &str) -> Result<Ipv4Addr, AddrParseError> {\n+        Self::parse_ascii(s.as_bytes())\n+    }\n+}\n+\n+impl Ipv6Addr {\n+    /// Parse an IPv6 address from a slice of bytes.\n+    ///\n+    /// ```\n+    /// #![feature(addr_parse_ascii)]\n+    ///\n+    /// use std::net::Ipv6Addr;\n+    ///\n+    /// let localhost = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n+    ///\n+    /// assert_eq!(Ipv6Addr::parse_ascii(b\"::1\"), Ok(localhost));\n+    /// ```\n+    #[unstable(feature = \"addr_parse_ascii\", issue = \"101035\")]\n+    pub fn parse_ascii(b: &[u8]) -> Result<Self, AddrParseError> {\n+        Parser::new(b).parse_with(|p| p.read_ipv6_addr(), AddrKind::Ipv6)\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for Ipv6Addr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<Ipv6Addr, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_ipv6_addr(), AddrKind::Ipv6)\n+        Self::parse_ascii(s.as_bytes())\n+    }\n+}\n+\n+impl SocketAddrV4 {\n+    /// Parse an IPv4 socket address from a slice of bytes.\n+    ///\n+    /// ```\n+    /// #![feature(addr_parse_ascii)]\n+    ///\n+    /// use std::net::{Ipv4Addr, SocketAddrV4};\n+    ///\n+    /// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n+    ///\n+    /// assert_eq!(SocketAddrV4::parse_ascii(b\"127.0.0.1:8080\"), Ok(socket));\n+    /// ```\n+    #[unstable(feature = \"addr_parse_ascii\", issue = \"101035\")]\n+    pub fn parse_ascii(b: &[u8]) -> Result<Self, AddrParseError> {\n+        Parser::new(b).parse_with(|p| p.read_socket_addr_v4(), AddrKind::SocketV4)\n     }\n }\n \n #[stable(feature = \"socket_addr_from_str\", since = \"1.5.0\")]\n impl FromStr for SocketAddrV4 {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<SocketAddrV4, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_socket_addr_v4(), AddrKind::SocketV4)\n+        Self::parse_ascii(s.as_bytes())\n+    }\n+}\n+\n+impl SocketAddrV6 {\n+    /// Parse an IPv6 socket address from a slice of bytes.\n+    ///\n+    /// ```\n+    /// #![feature(addr_parse_ascii)]\n+    ///\n+    /// use std::net::{Ipv6Addr, SocketAddrV6};\n+    ///\n+    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n+    ///\n+    /// assert_eq!(SocketAddrV6::parse_ascii(b\"[2001:db8::1]:8080\"), Ok(socket));\n+    /// ```\n+    #[unstable(feature = \"addr_parse_ascii\", issue = \"101035\")]\n+    pub fn parse_ascii(b: &[u8]) -> Result<Self, AddrParseError> {\n+        Parser::new(b).parse_with(|p| p.read_socket_addr_v6(), AddrKind::SocketV6)\n     }\n }\n \n #[stable(feature = \"socket_addr_from_str\", since = \"1.5.0\")]\n impl FromStr for SocketAddrV6 {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<SocketAddrV6, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_socket_addr_v6(), AddrKind::SocketV6)\n+        Self::parse_ascii(s.as_bytes())\n+    }\n+}\n+\n+impl SocketAddr {\n+    /// Parse a socket address from a slice of bytes.\n+    ///\n+    /// ```\n+    /// #![feature(addr_parse_ascii)]\n+    ///\n+    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr};\n+    ///\n+    /// let socket_v4 = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// let socket_v6 = SocketAddr::new(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), 8080);\n+    ///\n+    /// assert_eq!(SocketAddr::parse_ascii(b\"127.0.0.1:8080\"), Ok(socket_v4));\n+    /// assert_eq!(SocketAddr::parse_ascii(b\"[::1]:8080\"), Ok(socket_v6));\n+    /// ```\n+    #[unstable(feature = \"addr_parse_ascii\", issue = \"101035\")]\n+    pub fn parse_ascii(b: &[u8]) -> Result<Self, AddrParseError> {\n+        Parser::new(b).parse_with(|p| p.read_socket_addr(), AddrKind::Socket)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for SocketAddr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<SocketAddr, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_socket_addr(), AddrKind::Socket)\n+        Self::parse_ascii(s.as_bytes())\n     }\n }\n "}, {"sha": "f758f88d0a37026b0c9da8ce6de9d95d8572203c", "filename": "library/std/src/os/unix/net/datagram.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fdatagram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fdatagram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fdatagram.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -838,6 +838,31 @@ impl UnixDatagram {\n         self.0.passcred()\n     }\n \n+    /// Set the id of the socket for network filtering purpose\n+    ///\n+    #[cfg_attr(\n+        any(target_os = \"linux\", target_os = \"freebsd\", target_os = \"openbsd\"),\n+        doc = \"```no_run\"\n+    )]\n+    #[cfg_attr(\n+        not(any(target_os = \"linux\", target_os = \"freebsd\", target_os = \"openbsd\")),\n+        doc = \"```ignore\"\n+    )]\n+    /// #![feature(unix_set_mark)]\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.set_mark(32)?;\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[cfg(any(doc, target_os = \"linux\", target_os = \"freebsd\", target_os = \"openbsd\",))]\n+    #[unstable(feature = \"unix_set_mark\", issue = \"96467\")]\n+    pub fn set_mark(&self, mark: u32) -> io::Result<()> {\n+        self.0.set_mark(mark)\n+    }\n+\n     /// Returns the value of the `SO_ERROR` option.\n     ///\n     /// # Examples"}, {"sha": "dff8f6e8567508cdcf4aa49a1929c348bf2684d6", "filename": "library/std/src/os/unix/net/stream.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fstream.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -427,6 +427,31 @@ impl UnixStream {\n         self.0.passcred()\n     }\n \n+    /// Set the id of the socket for network filtering purpose\n+    ///\n+    #[cfg_attr(\n+        any(target_os = \"linux\", target_os = \"freebsd\", target_os = \"openbsd\"),\n+        doc = \"```no_run\"\n+    )]\n+    #[cfg_attr(\n+        not(any(target_os = \"linux\", target_os = \"freebsd\", target_os = \"openbsd\")),\n+        doc = \"```ignore\"\n+    )]\n+    /// #![feature(unix_set_mark)]\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     sock.set_mark(32)?;\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[cfg(any(doc, target_os = \"linux\", target_os = \"freebsd\", target_os = \"openbsd\",))]\n+    #[unstable(feature = \"unix_set_mark\", issue = \"96467\")]\n+    pub fn set_mark(&self, mark: u32) -> io::Result<()> {\n+        self.0.set_mark(mark)\n+    }\n+\n     /// Returns the value of the `SO_ERROR` option.\n     ///\n     /// # Examples"}, {"sha": "b84bf8f9264a405821f6453296c0d43de65f42f4", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -438,6 +438,17 @@ impl Socket {\n         self.0.set_nonblocking(nonblocking)\n     }\n \n+    #[cfg(any(target_os = \"linux\", target_os = \"freebsd\", target_os = \"openbsd\"))]\n+    pub fn set_mark(&self, mark: u32) -> io::Result<()> {\n+        #[cfg(target_os = \"linux\")]\n+        let option = libc::SO_MARK;\n+        #[cfg(target_os = \"freebsd\")]\n+        let option = libc::SO_USER_COOKIE;\n+        #[cfg(target_os = \"openbsd\")]\n+        let option = libc::SO_RTABLE;\n+        setsockopt(self, libc::SOL_SOCKET, option, mark as libc::c_int)\n+    }\n+\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         let raw: c_int = getsockopt(self, libc::SOL_SOCKET, libc::SO_ERROR)?;\n         if raw == 0 { Ok(None) } else { Ok(Some(io::Error::from_raw_os_error(raw as i32))) }"}, {"sha": "31b805f2ed7edf919a82ff6d41b064158010b6c6", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -24,8 +24,6 @@ use crate::clean::{\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n \n-type Attrs<'hir> = &'hir [ast::Attribute];\n-\n /// Attempt to inline a definition into this AST.\n ///\n /// This function will fetch the definition specified, and if it is\n@@ -46,7 +44,7 @@ pub(crate) fn try_inline(\n     import_def_id: Option<DefId>,\n     res: Res,\n     name: Symbol,\n-    attrs: Option<Attrs<'_>>,\n+    attrs: Option<&[ast::Attribute]>,\n     visited: &mut FxHashSet<DefId>,\n ) -> Option<Vec<clean::Item>> {\n     let did = res.opt_def_id()?;\n@@ -172,7 +170,7 @@ pub(crate) fn try_inline_glob(\n     }\n }\n \n-pub(crate) fn load_attrs<'hir>(cx: &DocContext<'hir>, did: DefId) -> Attrs<'hir> {\n+pub(crate) fn load_attrs<'hir>(cx: &DocContext<'hir>, did: DefId) -> &'hir [ast::Attribute] {\n     cx.tcx.get_attrs_unchecked(did)\n }\n \n@@ -287,7 +285,7 @@ pub(crate) fn build_impls(\n     cx: &mut DocContext<'_>,\n     parent_module: Option<DefId>,\n     did: DefId,\n-    attrs: Option<Attrs<'_>>,\n+    attrs: Option<&[ast::Attribute]>,\n     ret: &mut Vec<clean::Item>,\n ) {\n     let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_inherent_impls\");\n@@ -303,8 +301,8 @@ pub(crate) fn build_impls(\n pub(crate) fn merge_attrs(\n     cx: &mut DocContext<'_>,\n     parent_module: Option<DefId>,\n-    old_attrs: Attrs<'_>,\n-    new_attrs: Option<Attrs<'_>>,\n+    old_attrs: &[ast::Attribute],\n+    new_attrs: Option<&[ast::Attribute]>,\n ) -> (clean::Attributes, Option<Arc<clean::cfg::Cfg>>) {\n     // NOTE: If we have additional attributes (from a re-export),\n     // always insert them first. This ensure that re-export\n@@ -331,7 +329,7 @@ pub(crate) fn build_impl(\n     cx: &mut DocContext<'_>,\n     parent_module: Option<DefId>,\n     did: DefId,\n-    attrs: Option<Attrs<'_>>,\n+    attrs: Option<&[ast::Attribute]>,\n     ret: &mut Vec<clean::Item>,\n ) {\n     if !cx.inlined.insert(did.into()) {"}, {"sha": "b5f98233b3d7a68de3451802fb4fb4c3f8ebf543", "filename": "src/test/mir-opt/dead-store-elimination/provenance_soundness.retags.DeadStoreElimination.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fprovenance_soundness.retags.DeadStoreElimination.diff", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fprovenance_soundness.retags.DeadStoreElimination.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fprovenance_soundness.retags.DeadStoreElimination.diff?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -6,7 +6,7 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/provenance_soundness.rs:+0:25: +0:25\n   \n       bb0: {\n-          Retag([fn entry] _1);            // scope 0 at $DIR/provenance_soundness.rs:+0:1: +0:27\n+          Retag([fn entry] _1);            // scope 0 at $DIR/provenance_soundness.rs:+0:11: +0:13\n           _0 = const ();                   // scope 0 at $DIR/provenance_soundness.rs:+0:25: +0:27\n           return;                          // scope 0 at $DIR/provenance_soundness.rs:+0:27: +0:27\n       }"}, {"sha": "d5410d3afd4a5d0168e68ca357204d211b6e84b6", "filename": "src/test/mir-opt/inline/inline_retag.bar.Inline.after.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fmir-opt%2Finline%2Finline_retag.bar.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fmir-opt%2Finline%2Finline_retag.bar.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_retag.bar.Inline.after.mir?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -52,8 +52,8 @@ fn bar() -> bool {\n         Retag(_7);                       // scope 1 at $DIR/inline-retag.rs:+2:11: +2:14\n         _6 = &(*_7);                     // scope 1 at $DIR/inline-retag.rs:+2:11: +2:14\n         Retag(_6);                       // scope 1 at $DIR/inline-retag.rs:+2:11: +2:14\n-        Retag(_3);                       // scope 2 at $DIR/inline-retag.rs:16:1: 18:2\n-        Retag(_6);                       // scope 2 at $DIR/inline-retag.rs:16:1: 18:2\n+        Retag(_3);                       // scope 2 at $DIR/inline-retag.rs:16:8: 16:9\n+        Retag(_6);                       // scope 2 at $DIR/inline-retag.rs:16:17: 16:18\n         StorageLive(_11);                // scope 2 at $DIR/inline-retag.rs:17:5: 17:7\n         _11 = (*_3);                     // scope 2 at $DIR/inline-retag.rs:17:5: 17:7\n         StorageLive(_12);                // scope 2 at $DIR/inline-retag.rs:17:11: 17:13"}, {"sha": "d254a95e06bea2b2f13973e696bcd2d715253268", "filename": "src/test/mir-opt/retag.main-{closure#0}.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fmir-opt%2Fretag.main-%7Bclosure%230%7D.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fmir-opt%2Fretag.main-%7Bclosure%230%7D.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.main-%7Bclosure%230%7D.SimplifyCfg-elaborate-drops.after.mir?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -10,7 +10,7 @@ fn main::{closure#0}(_1: &[closure@main::{closure#0}], _2: &i32) -> &i32 {\n \n     bb0: {\n         Retag([fn entry] _1);            // scope 0 at $DIR/retag.rs:+0:31: +0:48\n-        Retag([fn entry] _2);            // scope 0 at $DIR/retag.rs:+0:31: +0:48\n+        Retag([fn entry] _2);            // scope 0 at $DIR/retag.rs:+0:32: +0:33\n         StorageLive(_3);                 // scope 0 at $DIR/retag.rs:42:13: 42:15\n         _3 = _2;                         // scope 0 at $DIR/retag.rs:42:18: 42:19\n         Retag(_3);                       // scope 0 at $DIR/retag.rs:42:18: 42:19"}, {"sha": "08fd655ae29bb979f6161bc63c8886cadee45b50", "filename": "src/test/mir-opt/retag.{impl#0}-foo.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fmir-opt%2Fretag.%7Bimpl%230%7D-foo.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fmir-opt%2Fretag.%7Bimpl%230%7D-foo.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.%7Bimpl%230%7D-foo.SimplifyCfg-elaborate-drops.after.mir?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -7,8 +7,8 @@ fn <impl at $DIR/retag.rs:12:1: 12:10>::foo(_1: &Test, _2: &mut i32) -> &mut i32\n     let mut _3: &mut i32;                // in scope 0 at $DIR/retag.rs:+1:9: +1:10\n \n     bb0: {\n-        Retag([fn entry] _1);            // scope 0 at $DIR/retag.rs:+0:5: +2:6\n-        Retag([fn entry] _2);            // scope 0 at $DIR/retag.rs:+0:5: +2:6\n+        Retag([fn entry] _1);            // scope 0 at $DIR/retag.rs:+0:16: +0:21\n+        Retag([fn entry] _2);            // scope 0 at $DIR/retag.rs:+0:23: +0:24\n         StorageLive(_3);                 // scope 0 at $DIR/retag.rs:+1:9: +1:10\n         _3 = &mut (*_2);                 // scope 0 at $DIR/retag.rs:+1:9: +1:10\n         Retag(_3);                       // scope 0 at $DIR/retag.rs:+1:9: +1:10"}, {"sha": "f32a84e4c791b9238d813cd9a62a8ece9198dd85", "filename": "src/test/mir-opt/retag.{impl#0}-foo_shr.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fmir-opt%2Fretag.%7Bimpl%230%7D-foo_shr.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fmir-opt%2Fretag.%7Bimpl%230%7D-foo_shr.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.%7Bimpl%230%7D-foo_shr.SimplifyCfg-elaborate-drops.after.mir?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -6,8 +6,8 @@ fn <impl at $DIR/retag.rs:12:1: 12:10>::foo_shr(_1: &Test, _2: &i32) -> &i32 {\n     let mut _0: &i32;                    // return place in scope 0 at $DIR/retag.rs:+0:42: +0:49\n \n     bb0: {\n-        Retag([fn entry] _1);            // scope 0 at $DIR/retag.rs:+0:5: +2:6\n-        Retag([fn entry] _2);            // scope 0 at $DIR/retag.rs:+0:5: +2:6\n+        Retag([fn entry] _1);            // scope 0 at $DIR/retag.rs:+0:20: +0:25\n+        Retag([fn entry] _2);            // scope 0 at $DIR/retag.rs:+0:27: +0:28\n         _0 = _2;                         // scope 0 at $DIR/retag.rs:+1:9: +1:10\n         Retag(_0);                       // scope 0 at $DIR/retag.rs:+1:9: +1:10\n         return;                          // scope 0 at $DIR/retag.rs:+2:6: +2:6"}, {"sha": "b1f557cb94de8538e58ef71051a7628f05fbf842", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -549,7 +549,7 @@ struct ErrorWithMultiSpan {\n \n #[derive(SessionDiagnostic)]\n #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-#[warn_]\n+#[warning]\n struct ErrorWithWarn {\n     val: String,\n }\n@@ -562,11 +562,11 @@ struct ErrorWithWarn {\n struct ErrorAttribute {}\n \n #[derive(SessionDiagnostic)]\n-#[warning(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-//~^ ERROR `#[warning(...)]` is not a valid attribute\n+#[warn_(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+//~^ ERROR `#[warn_(...)]` is not a valid attribute\n //~| ERROR diagnostic slug not specified\n-//~| ERROR cannot find attribute `warning` in this scope\n-struct WarningAttribute {}\n+//~| ERROR cannot find attribute `warn_` in this scope\n+struct WarnAttribute {}\n \n #[derive(SessionDiagnostic)]\n #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]"}, {"sha": "621c59f448951ed0d972684a86272be7438063bf", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -21,7 +21,7 @@ error: `#[nonsense(...)]` is not a valid attribute\n LL | #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: only `diag`, `help`, `note` and `warn_` are valid attributes\n+   = help: only `diag`, `help`, `note` and `warning` are valid attributes\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:53:1\n@@ -329,7 +329,7 @@ error: `#[error(...)]` is not a valid attribute\n LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: `error`, `warning` and `lint` have been replaced by `diag`\n+   = help: `error` and `lint` have been replaced by `diag`\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:558:1\n@@ -343,23 +343,23 @@ LL | | struct ErrorAttribute {}\n    |\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n-error: `#[warning(...)]` is not a valid attribute\n+error: `#[warn_(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:565:1\n    |\n-LL | #[warning(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[warn_(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: `error`, `warning` and `lint` have been replaced by `diag`\n+   = help: `warn_` have been replaced by `warning`\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:565:1\n    |\n-LL | / #[warning(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+LL | / #[warn_(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n LL | |\n LL | |\n LL | |\n-LL | | struct WarningAttribute {}\n-   | |__________________________^\n+LL | | struct WarnAttribute {}\n+   | |_______________________^\n    |\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n@@ -369,7 +369,7 @@ error: `#[lint(...)]` is not a valid attribute\n LL | #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: `error`, `warning` and `lint` have been replaced by `diag`\n+   = help: `error` and `lint` have been replaced by `diag`\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:572:1\n@@ -389,7 +389,7 @@ error: `#[lint(...)]` is not a valid attribute\n LL | #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: `error`, `warning` and `lint` have been replaced by `diag`\n+   = help: `error` and `lint` have been replaced by `diag`\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:579:1\n@@ -421,11 +421,11 @@ error: cannot find attribute `error` in this scope\n LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |   ^^^^^\n \n-error: cannot find attribute `warning` in this scope\n+error: cannot find attribute `warn_` in this scope\n   --> $DIR/diagnostic-derive.rs:565:3\n    |\n-LL | #[warning(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-   |   ^^^^^^^\n+LL | #[warn_(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+   |   ^^^^^ help: a built-in attribute with a similar name exists: `warn`\n \n error: cannot find attribute `lint` in this scope\n   --> $DIR/diagnostic-derive.rs:572:3"}, {"sha": "ddfc0d3365df0710e3457d5f233cb0c89736853c", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -510,12 +510,11 @@ enum AX {\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[warn_(parser::add_paren)]\n-struct AY {\n-}\n+#[warning(parser::add_paren)]\n+struct AY {}\n \n #[derive(SessionSubdiagnostic)]\n-#[warn_(parser::add_paren)]\n+#[warning(parser::add_paren)]\n struct AZ {\n     #[primary_span]\n     span: Span,"}, {"sha": "61b3551182c905e141716decd33b4d1dec7065aa", "filename": "src/test/ui/const-generics/defaults/generic-expr-default-concrete.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fgeneric-expr-default-concrete.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fgeneric-expr-default-concrete.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fgeneric-expr-default-concrete.stderr?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -4,8 +4,8 @@ error[E0308]: mismatched types\n LL |     Foo::<10, 12>\n    |     ^^^^^^^^^^^^^ expected `11`, found `12`\n    |\n-   = note: expected type `11`\n-              found type `12`\n+   = note: expected constant `11`\n+              found constant `12`\n \n error: aborting due to previous error\n "}, {"sha": "e83f89a60333fd131b4cf46577a6882c7beab2f4", "filename": "src/test/ui/const-generics/defaults/generic-expr-default-mismatched-types.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fgeneric-expr-default-mismatched-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fgeneric-expr-default-mismatched-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fgeneric-expr-default-mismatched-types.stderr?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -4,8 +4,8 @@ error[E0308]: mismatched types\n LL |     Foo::<N, { N + 2 }>\n    |     ^^^^^^^^^^^^^^^^^^^ expected `{ N + 1 }`, found `{ N + 2 }`\n    |\n-   = note: expected type `{ N + 1 }`\n-              found type `{ N + 2 }`\n+   = note: expected constant `{ N + 1 }`\n+              found constant `{ N + 2 }`\n \n error: aborting due to previous error\n "}, {"sha": "ada1050d35f35a3f6a26a78fab0127f7b456f2f6", "filename": "src/test/ui/const-generics/generic_const_exprs/abstract-const-as-cast-3.stderr", "status": "modified", "additions": 56, "deletions": 16, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fabstract-const-as-cast-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fabstract-const-as-cast-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fabstract-const-as-cast-3.stderr?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -22,8 +22,13 @@ error[E0308]: mismatched types\n LL |     assert_impl::<HasCastInTraitImpl<{ N + 1 }, { N as u128 }>>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `{ N as u128 }`, found `{ O as u128 }`\n    |\n-   = note: expected type `{ N as u128 }`\n-              found type `{ O as u128 }`\n+   = note: expected constant `{ N as u128 }`\n+              found constant `{ O as u128 }`\n+note: required by a bound in `use_trait_impl::assert_impl`\n+  --> $DIR/abstract-const-as-cast-3.rs:14:23\n+   |\n+LL |     fn assert_impl<T: Trait>() {}\n+   |                       ^^^^^ required by this bound in `use_trait_impl::assert_impl`\n \n error: unconstrained generic constant\n   --> $DIR/abstract-const-as-cast-3.rs:20:19\n@@ -49,26 +54,41 @@ error[E0308]: mismatched types\n LL |     assert_impl::<HasCastInTraitImpl<{ N + 1 }, { N as _ }>>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `{ N as _ }`, found `{ O as u128 }`\n    |\n-   = note: expected type `{ N as _ }`\n-              found type `{ O as u128 }`\n+   = note: expected constant `{ N as _ }`\n+              found constant `{ O as u128 }`\n+note: required by a bound in `use_trait_impl::assert_impl`\n+  --> $DIR/abstract-const-as-cast-3.rs:14:23\n+   |\n+LL |     fn assert_impl<T: Trait>() {}\n+   |                       ^^^^^ required by this bound in `use_trait_impl::assert_impl`\n \n error[E0308]: mismatched types\n   --> $DIR/abstract-const-as-cast-3.rs:23:5\n    |\n LL |     assert_impl::<HasCastInTraitImpl<13, { 12 as u128 }>>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `12`, found `13`\n    |\n-   = note: expected type `12`\n-              found type `13`\n+   = note: expected constant `12`\n+              found constant `13`\n+note: required by a bound in `use_trait_impl::assert_impl`\n+  --> $DIR/abstract-const-as-cast-3.rs:14:23\n+   |\n+LL |     fn assert_impl<T: Trait>() {}\n+   |                       ^^^^^ required by this bound in `use_trait_impl::assert_impl`\n \n error[E0308]: mismatched types\n   --> $DIR/abstract-const-as-cast-3.rs:25:5\n    |\n LL |     assert_impl::<HasCastInTraitImpl<14, 13>>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `13`, found `14`\n    |\n-   = note: expected type `13`\n-              found type `14`\n+   = note: expected constant `13`\n+              found constant `14`\n+note: required by a bound in `use_trait_impl::assert_impl`\n+  --> $DIR/abstract-const-as-cast-3.rs:14:23\n+   |\n+LL |     fn assert_impl<T: Trait>() {}\n+   |                       ^^^^^ required by this bound in `use_trait_impl::assert_impl`\n \n error: unconstrained generic constant\n   --> $DIR/abstract-const-as-cast-3.rs:35:19\n@@ -94,8 +114,13 @@ error[E0308]: mismatched types\n LL |     assert_impl::<HasCastInTraitImpl<{ N + 1 }, { N as u128 }>>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `{ N as u128 }`, found `{ O as u128 }`\n    |\n-   = note: expected type `{ N as u128 }`\n-              found type `{ O as u128 }`\n+   = note: expected constant `{ N as u128 }`\n+              found constant `{ O as u128 }`\n+note: required by a bound in `use_trait_impl_2::assert_impl`\n+  --> $DIR/abstract-const-as-cast-3.rs:32:23\n+   |\n+LL |     fn assert_impl<T: Trait>() {}\n+   |                       ^^^^^ required by this bound in `use_trait_impl_2::assert_impl`\n \n error: unconstrained generic constant\n   --> $DIR/abstract-const-as-cast-3.rs:38:19\n@@ -121,26 +146,41 @@ error[E0308]: mismatched types\n LL |     assert_impl::<HasCastInTraitImpl<{ N + 1 }, { N as _ }>>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `{ N as _ }`, found `{ O as u128 }`\n    |\n-   = note: expected type `{ N as _ }`\n-              found type `{ O as u128 }`\n+   = note: expected constant `{ N as _ }`\n+              found constant `{ O as u128 }`\n+note: required by a bound in `use_trait_impl_2::assert_impl`\n+  --> $DIR/abstract-const-as-cast-3.rs:32:23\n+   |\n+LL |     fn assert_impl<T: Trait>() {}\n+   |                       ^^^^^ required by this bound in `use_trait_impl_2::assert_impl`\n \n error[E0308]: mismatched types\n   --> $DIR/abstract-const-as-cast-3.rs:41:5\n    |\n LL |     assert_impl::<HasCastInTraitImpl<13, { 12 as u128 }>>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `12`, found `13`\n    |\n-   = note: expected type `12`\n-              found type `13`\n+   = note: expected constant `12`\n+              found constant `13`\n+note: required by a bound in `use_trait_impl_2::assert_impl`\n+  --> $DIR/abstract-const-as-cast-3.rs:32:23\n+   |\n+LL |     fn assert_impl<T: Trait>() {}\n+   |                       ^^^^^ required by this bound in `use_trait_impl_2::assert_impl`\n \n error[E0308]: mismatched types\n   --> $DIR/abstract-const-as-cast-3.rs:43:5\n    |\n LL |     assert_impl::<HasCastInTraitImpl<14, 13>>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `13`, found `14`\n    |\n-   = note: expected type `13`\n-              found type `14`\n+   = note: expected constant `13`\n+              found constant `14`\n+note: required by a bound in `use_trait_impl_2::assert_impl`\n+  --> $DIR/abstract-const-as-cast-3.rs:32:23\n+   |\n+LL |     fn assert_impl<T: Trait>() {}\n+   |                       ^^^^^ required by this bound in `use_trait_impl_2::assert_impl`\n \n error: aborting due to 12 previous errors\n "}, {"sha": "83a2f3740b14600ba06552c46f23977654c61d53", "filename": "src/test/ui/const-generics/generic_const_exprs/different-fn.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fdifferent-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fdifferent-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fdifferent-fn.stderr?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -4,8 +4,8 @@ error[E0308]: mismatched types\n LL |     [0; size_of::<Foo<T>>()]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ expected `size_of::<T>()`, found `size_of::<Foo<T>>()`\n    |\n-   = note: expected type `size_of::<T>()`\n-              found type `size_of::<Foo<T>>()`\n+   = note: expected constant `size_of::<T>()`\n+              found constant `size_of::<Foo<T>>()`\n \n error: unconstrained generic constant\n   --> $DIR/different-fn.rs:10:9"}, {"sha": "0742db398c9c4fd17b6cb8694edf9eb89f87cd06", "filename": "src/test/ui/const-generics/generic_const_exprs/issue-62504.full.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-62504.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-62504.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-62504.full.stderr?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -4,8 +4,8 @@ error[E0308]: mismatched types\n LL |         ArrayHolder([0; Self::SIZE])\n    |                     ^^^^^^^^^^^^^^^ expected `X`, found `Self::SIZE`\n    |\n-   = note: expected type `X`\n-              found type `Self::SIZE`\n+   = note: expected constant `X`\n+              found constant `Self::SIZE`\n \n error: unconstrained generic constant\n   --> $DIR/issue-62504.rs:18:25"}, {"sha": "f2fddfbfbb52adbdd1bef8be46edf9dc43616601", "filename": "src/test/ui/const-generics/generic_const_exprs/issue-72819-generic-in-const-eval.full.stderr", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-72819-generic-in-const-eval.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-72819-generic-in-const-eval.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-72819-generic-in-const-eval.full.stderr?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -4,17 +4,31 @@ error[E0308]: mismatched types\n LL |     let x: Arr<{usize::MAX}> = Arr {};\n    |            ^^^^^^^^^^^^^^^^^ expected `false`, found `true`\n    |\n-   = note: expected type `false`\n-              found type `true`\n+   = note: expected constant `false`\n+              found constant `true`\n+note: required by a bound in `Arr`\n+  --> $DIR/issue-72819-generic-in-const-eval.rs:8:39\n+   |\n+LL | struct Arr<const N: usize>\n+   |        --- required by a bound in this\n+LL | where Assert::<{N < usize::MAX / 2}>: IsTrue,\n+   |                                       ^^^^^^ required by this bound in `Arr`\n \n error[E0308]: mismatched types\n   --> $DIR/issue-72819-generic-in-const-eval.rs:20:32\n    |\n LL |     let x: Arr<{usize::MAX}> = Arr {};\n    |                                ^^^ expected `false`, found `true`\n    |\n-   = note: expected type `false`\n-              found type `true`\n+   = note: expected constant `false`\n+              found constant `true`\n+note: required by a bound in `Arr`\n+  --> $DIR/issue-72819-generic-in-const-eval.rs:8:39\n+   |\n+LL | struct Arr<const N: usize>\n+   |        --- required by a bound in this\n+LL | where Assert::<{N < usize::MAX / 2}>: IsTrue,\n+   |                                       ^^^^^^ required by this bound in `Arr`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "b693023f125a4565d8006e3c8677fb83d5b14eba", "filename": "src/test/ui/const-generics/generic_const_exprs/issue-83765.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-83765.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-83765.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-83765.stderr?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -4,8 +4,8 @@ error[E0308]: method not compatible with trait\n LL |     fn size(&self) -> [usize; DIM] {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Self::DIM`, found `DIM`\n    |\n-   = note: expected type `Self::DIM`\n-              found type `DIM`\n+   = note: expected constant `Self::DIM`\n+              found constant `DIM`\n \n error: unconstrained generic constant\n   --> $DIR/issue-83765.rs:32:24\n@@ -26,8 +26,8 @@ error[E0308]: mismatched types\n LL |         self.reference.size()\n    |         ^^^^^^^^^^^^^^^^^^^^^ expected `DIM`, found `Self::DIM`\n    |\n-   = note: expected type `DIM`\n-              found type `Self::DIM`\n+   = note: expected constant `DIM`\n+              found constant `Self::DIM`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "09bcb0860b71bee07e498a54e9d79682ef86519a", "filename": "src/test/ui/const-generics/generic_const_exprs/issue-85848.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-85848.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-85848.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-85848.stderr?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -54,8 +54,8 @@ error[E0308]: mismatched types\n LL |     writes_to_specific_path(&cap);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ expected `true`, found `{ contains::<T, U>() }`\n    |\n-   = note: expected type `true`\n-              found type `{ contains::<T, U>() }`\n+   = note: expected constant `true`\n+              found constant `{ contains::<T, U>() }`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "e7c8e4f667d05f72e84d9c5a06d4a679772a8b3e", "filename": "src/test/ui/const-generics/generic_const_exprs/obligation-cause.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fobligation-cause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fobligation-cause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fobligation-cause.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -0,0 +1,24 @@\n+#![allow(incomplete_features)]\n+#![feature(generic_const_exprs)]\n+\n+trait True {}\n+\n+struct Is<const V: bool>;\n+\n+impl True for Is<true> {}\n+\n+fn g<T>()\n+//~^ NOTE required by a bound in this\n+where\n+    Is<{ std::mem::size_of::<T>() == 0 }>: True,\n+    //~^ NOTE required by a bound in `g`\n+    //~| NOTE required by this bound in `g`\n+{\n+}\n+\n+fn main() {\n+    g::<usize>();\n+    //~^ ERROR mismatched types\n+    //~| NOTE expected `false`, found `true`\n+    //~| NOTE expected constant `false`\n+}"}, {"sha": "a253ec676f7163e06faba5bca88a7f8682d5d5ff", "filename": "src/test/ui/const-generics/generic_const_exprs/obligation-cause.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fobligation-cause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fobligation-cause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fobligation-cause.stderr?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -0,0 +1,20 @@\n+error[E0308]: mismatched types\n+  --> $DIR/obligation-cause.rs:20:5\n+   |\n+LL |     g::<usize>();\n+   |     ^^^^^^^^^^ expected `false`, found `true`\n+   |\n+   = note: expected constant `false`\n+              found constant `true`\n+note: required by a bound in `g`\n+  --> $DIR/obligation-cause.rs:13:44\n+   |\n+LL | fn g<T>()\n+   |    - required by a bound in this\n+...\n+LL |     Is<{ std::mem::size_of::<T>() == 0 }>: True,\n+   |                                            ^^^^ required by this bound in `g`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "7670032e5b758dc86f23505b457ab6b1f8f20136", "filename": "src/test/ui/const-generics/issues/issue-73260.stderr", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-73260.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-73260.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-73260.stderr?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -4,17 +4,33 @@ error[E0308]: mismatched types\n LL |     let x: Arr<{usize::MAX}> = Arr {};\n    |            ^^^^^^^^^^^^^^^^^ expected `false`, found `true`\n    |\n-   = note: expected type `false`\n-              found type `true`\n+   = note: expected constant `false`\n+              found constant `true`\n+note: required by a bound in `Arr`\n+  --> $DIR/issue-73260.rs:6:37\n+   |\n+LL | struct Arr<const N: usize>\n+   |        --- required by a bound in this\n+LL | where\n+LL |     Assert::<{N < usize::MAX / 2}>: IsTrue,\n+   |                                     ^^^^^^ required by this bound in `Arr`\n \n error[E0308]: mismatched types\n   --> $DIR/issue-73260.rs:16:32\n    |\n LL |     let x: Arr<{usize::MAX}> = Arr {};\n    |                                ^^^ expected `false`, found `true`\n    |\n-   = note: expected type `false`\n-              found type `true`\n+   = note: expected constant `false`\n+              found constant `true`\n+note: required by a bound in `Arr`\n+  --> $DIR/issue-73260.rs:6:37\n+   |\n+LL | struct Arr<const N: usize>\n+   |        --- required by a bound in this\n+LL | where\n+LL |     Assert::<{N < usize::MAX / 2}>: IsTrue,\n+   |                                     ^^^^^^ required by this bound in `Arr`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "02b48b55f8b38e364b499d01af21e64ab0ea4e18", "filename": "src/test/ui/const-generics/issues/issue-79674.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-79674.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-79674.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-79674.stderr?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -4,8 +4,16 @@ error[E0308]: mismatched types\n LL |     requires_distinct(\"str\", 12);\n    |     ^^^^^^^^^^^^^^^^^ expected `true`, found `false`\n    |\n-   = note: expected type `true`\n-              found type `false`\n+   = note: expected constant `true`\n+              found constant `false`\n+note: required by a bound in `requires_distinct`\n+  --> $DIR/issue-79674.rs:23:37\n+   |\n+LL | fn requires_distinct<A, B>(_a: A, _b: B) where\n+   |    ----------------- required by a bound in this\n+LL |     A: MiniTypeId, B: MiniTypeId,\n+LL |     Lift<{is_same_type::<A, B>()}>: IsFalse {}\n+   |                                     ^^^^^^^ required by this bound in `requires_distinct`\n \n error: aborting due to previous error\n "}, {"sha": "b6a22df74369a3ebc849e884d4f0ebd6869fae0b", "filename": "src/test/ui/const-generics/types-mismatch-const-args.full.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.full.stderr?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -4,8 +4,8 @@ error[E0308]: mismatched types\n LL |     let _: A<'a, u32, {2u32}, {3u32}> = A::<'a, u32, {2u32 + 2u32}, {3u32}> { data: PhantomData };\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `2`, found `4`\n    |\n-   = note: expected type `2`\n-              found type `4`\n+   = note: expected constant `2`\n+              found constant `4`\n \n error[E0308]: mismatched types\n   --> $DIR/types-mismatch-const-args.rs:16:41"}, {"sha": "c7a435a1ee3fc9ce7465cc77ecfcd65815286a9e", "filename": "src/test/ui/consts/const-points-to-static.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.32bit.stderr?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -2,7 +2,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-points-to-static.rs:6:1\n    |\n LL | const TEST: &u8 = &MY_STATIC;\n-   | ^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to a static variable\n+   | ^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to a static variable in a constant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {"}, {"sha": "4d5b8eac541dfd28ac0123e2629efdb73102cd23", "filename": "src/test/ui/consts/const-points-to-static.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.64bit.stderr?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -2,7 +2,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-points-to-static.rs:6:1\n    |\n LL | const TEST: &u8 = &MY_STATIC;\n-   | ^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to a static variable\n+   | ^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to a static variable in a constant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {"}, {"sha": "14173ac9f69b4aff5e376db4e1a4f6892c71baf2", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static2.32bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.32bit.stderr?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -2,7 +2,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const_refers_to_static2.rs:11:1\n    |\n LL | const REF_INTERIOR_MUT: &usize = {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to a static variable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to a static variable in a constant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n@@ -13,7 +13,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const_refers_to_static2.rs:18:1\n    |\n LL | const READ_IMMUT: &usize = {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to a static variable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to a static variable in a constant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {"}, {"sha": "e7e51a41856e2bbd3c7acf45bf76fe601081747e", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static2.64bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.64bit.stderr?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -2,7 +2,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const_refers_to_static2.rs:11:1\n    |\n LL | const REF_INTERIOR_MUT: &usize = {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to a static variable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to a static variable in a constant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n@@ -13,7 +13,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const_refers_to_static2.rs:18:1\n    |\n LL | const READ_IMMUT: &usize = {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to a static variable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to a static variable in a constant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {"}, {"sha": "3a22b06891629c86f509f44330d5f78caaa7a21a", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static_cross_crate.32bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.32bit.stderr?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -2,7 +2,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const_refers_to_static_cross_crate.rs:12:1\n    |\n LL | const SLICE_MUT: &[u8; 1] = {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to a static variable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to a static variable in a constant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n@@ -19,7 +19,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const_refers_to_static_cross_crate.rs:17:1\n    |\n LL | const U8_MUT: &u8 = {\n-   | ^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to a static variable\n+   | ^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to a static variable in a constant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {"}, {"sha": "39c874d6498b28064841db20c2a2d06805ef0e6e", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static_cross_crate.64bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.64bit.stderr?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -2,7 +2,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const_refers_to_static_cross_crate.rs:12:1\n    |\n LL | const SLICE_MUT: &[u8; 1] = {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to a static variable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to a static variable in a constant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n@@ -19,7 +19,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const_refers_to_static_cross_crate.rs:17:1\n    |\n LL | const U8_MUT: &u8 = {\n-   | ^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to a static variable\n+   | ^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a reference pointing to a static variable in a constant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {"}, {"sha": "9fd86331ec755d8fbeafb87bce01d4f98f4786af", "filename": "src/tools/clippy/clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -105,7 +105,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n             vis.into_map(cx, maybe_storage_live_result)\n         };\n \n-        for (bb, bbdata) in mir.basic_blocks().iter_enumerated() {\n+        for (bb, bbdata) in mir.basic_blocks.iter_enumerated() {\n             let terminator = bbdata.terminator();\n \n             if terminator.source_info.span.from_expansion() {\n@@ -186,7 +186,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n                     unwrap_or_continue!(find_stmt_assigns_to(cx, mir, pred_arg, true, ps[0]));\n                 let loc = mir::Location {\n                     block: bb,\n-                    statement_index: mir.basic_blocks()[bb].statements.len(),\n+                    statement_index: mir.basic_blocks[bb].statements.len(),\n                 };\n \n                 // This can be turned into `res = move local` if `arg` and `cloned` are not borrowed\n@@ -310,7 +310,7 @@ fn find_stmt_assigns_to<'tcx>(\n     by_ref: bool,\n     bb: mir::BasicBlock,\n ) -> Option<(mir::Local, CannotMoveOut)> {\n-    let rvalue = mir.basic_blocks()[bb].statements.iter().rev().find_map(|stmt| {\n+    let rvalue = mir.basic_blocks[bb].statements.iter().rev().find_map(|stmt| {\n         if let mir::StatementKind::Assign(box (mir::Place { local, .. }, v)) = &stmt.kind {\n             return if *local == to_local { Some(v) } else { None };\n         }"}, {"sha": "74c222bbcbeb99e6bda141ed4af1033c47915b3a", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9", "patch": "@@ -55,7 +55,7 @@ pub fn is_min_const_fn<'a, 'tcx>(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, msrv:\n         body.local_decls.iter().next().unwrap().source_info.span,\n     )?;\n \n-    for bb in body.basic_blocks() {\n+    for bb in body.basic_blocks.iter() {\n         check_terminator(tcx, body, bb.terminator(), msrv)?;\n         for stmt in &bb.statements {\n             check_statement(tcx, body, def_id, stmt)?;"}]}