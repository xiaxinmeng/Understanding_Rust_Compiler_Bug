{"sha": "d7b6fcba2978cbbcfccce83e6f4f54c5eec998f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3YjZmY2JhMjk3OGNiYmNmY2NjZTgzZTZmNGY1NGM1ZWVjOTk4ZjM=", "commit": {"author": {"name": "Eric Reed", "email": "ecreed@cs.washington.edu", "date": "2013-08-07T09:57:33Z"}, "committer": {"name": "Eric Reed", "email": "ecreed@cs.washington.edu", "date": "2013-08-19T23:26:50Z"}, "message": "Working homing UDP socket prototype.", "tree": {"sha": "5c32b1b39f4e67259b05c9491da58540160d2b8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c32b1b39f4e67259b05c9491da58540160d2b8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7b6fcba2978cbbcfccce83e6f4f54c5eec998f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7b6fcba2978cbbcfccce83e6f4f54c5eec998f3", "html_url": "https://github.com/rust-lang/rust/commit/d7b6fcba2978cbbcfccce83e6f4f54c5eec998f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7b6fcba2978cbbcfccce83e6f4f54c5eec998f3/comments", "author": {"login": "anasazi", "id": 591682, "node_id": "MDQ6VXNlcjU5MTY4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/591682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anasazi", "html_url": "https://github.com/anasazi", "followers_url": "https://api.github.com/users/anasazi/followers", "following_url": "https://api.github.com/users/anasazi/following{/other_user}", "gists_url": "https://api.github.com/users/anasazi/gists{/gist_id}", "starred_url": "https://api.github.com/users/anasazi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anasazi/subscriptions", "organizations_url": "https://api.github.com/users/anasazi/orgs", "repos_url": "https://api.github.com/users/anasazi/repos", "events_url": "https://api.github.com/users/anasazi/events{/privacy}", "received_events_url": "https://api.github.com/users/anasazi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "anasazi", "id": 591682, "node_id": "MDQ6VXNlcjU5MTY4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/591682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anasazi", "html_url": "https://github.com/anasazi", "followers_url": "https://api.github.com/users/anasazi/followers", "following_url": "https://api.github.com/users/anasazi/following{/other_user}", "gists_url": "https://api.github.com/users/anasazi/gists{/gist_id}", "starred_url": "https://api.github.com/users/anasazi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anasazi/subscriptions", "organizations_url": "https://api.github.com/users/anasazi/orgs", "repos_url": "https://api.github.com/users/anasazi/repos", "events_url": "https://api.github.com/users/anasazi/events{/privacy}", "received_events_url": "https://api.github.com/users/anasazi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88f718341ec279738c07f83289058aadf7c5d235", "url": "https://api.github.com/repos/rust-lang/rust/commits/88f718341ec279738c07f83289058aadf7c5d235", "html_url": "https://github.com/rust-lang/rust/commit/88f718341ec279738c07f83289058aadf7c5d235"}], "stats": {"total": 152, "additions": 151, "deletions": 1}, "files": [{"sha": "07ba44101c89f7a074a91beee428b892e6b96136", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 151, "deletions": 1, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/d7b6fcba2978cbbcfccce83e6f4f54c5eec998f3/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7b6fcba2978cbbcfccce83e6f4f54c5eec998f3/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=d7b6fcba2978cbbcfccce83e6f4f54c5eec998f3", "patch": "@@ -23,7 +23,7 @@ use rt::io::net::ip::{SocketAddr, IpAddr};\n use rt::io::{standard_error, OtherIoError};\n use rt::local::Local;\n use rt::rtio::*;\n-use rt::sched::Scheduler;\n+use rt::sched::{Scheduler, SchedHandle};\n use rt::tube::Tube;\n use rt::uv::*;\n use rt::uv::idle::IdleWatcher;\n@@ -239,6 +239,27 @@ impl UvIoFactory {\n     pub fn uv_loop<'a>(&'a mut self) -> &'a mut Loop {\n         match self { &UvIoFactory(ref mut ptr) => ptr }\n     }\n+\n+    pub fn homed_udp_bind(&mut self, addr: SocketAddr) -> Result<~HomedUvUdpSocket, IoError> {\n+        let mut watcher = UdpWatcher::new(self.uv_loop());\n+        match watcher.bind(addr) {\n+            Ok(_) => {\n+                let home = do Local::borrow::<Scheduler, SchedHandle> |sched| {sched.make_handle()};\n+                Ok(~HomedUvUdpSocket { watcher: watcher, home: home })\n+            }\n+            Err(uverr) => {\n+                let scheduler = Local::take::<Scheduler>();\n+                do scheduler.deschedule_running_task_and_then |_, task| {\n+                    let task_cell = Cell::new(task);\n+                    do watcher.close {\n+                        let scheduler = Local::take::<Scheduler>();\n+                        scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    }\n+                }\n+                Err(uv_error_to_io_error(uverr))\n+            }\n+        }\n+    }\n }\n \n impl IoFactory for UvIoFactory {\n@@ -582,6 +603,135 @@ impl RtioTcpStream for UvTcpStream {\n     }\n }\n \n+pub struct HomedUvUdpSocket {\n+    watcher: UdpWatcher,\n+    home: SchedHandle,\n+}\n+\n+impl HomedUvUdpSocket {\n+    fn go_home(&mut self) {\n+        use rt::sched::PinnedTask;\n+        let scheduler = Local::take::<Scheduler>();\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            do task.wake().map_move |task| { self.home.send(PinnedTask(task)); };\n+        }\n+    }\n+}\n+\n+impl Drop for HomedUvUdpSocket {\n+    fn drop(&self) {\n+        rtdebug!(\"closing homed udp socket\");\n+        // first go home\n+        // XXX need mutable finalizer\n+        let this = unsafe { transmute::<&HomedUvUdpSocket, &mut HomedUvUdpSocket>(self) };\n+        this.go_home();\n+        // now we're home so block the task and start IO\n+        let scheduler = Local::take::<Scheduler>();\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell::new(task);\n+            do this.watcher.close {\n+                // now IO is finished so resume the blocked task\n+                let scheduler = Local::take::<Scheduler>();\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n+            }\n+        }\n+    }\n+}\n+\n+impl RtioSocket for HomedUvUdpSocket {\n+    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n+        self.go_home();\n+        socket_name(Udp, self.watcher)\n+    }\n+}\n+\n+#[test]\n+fn test_simple_homed_udp_io_bind_only() {\n+    do run_in_newsched_task {\n+        unsafe {\n+            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            let addr = next_test_ip4();\n+            let maybe_socket = (*io).homed_udp_bind(addr);\n+            assert!(maybe_socket.is_ok());\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_simple_homed_udp_io_bind_then_move_then_home_and_close() {\n+    use rt::sleeper_list::SleeperList;\n+    use rt::work_queue::WorkQueue;\n+    use rt::thread::Thread;\n+    use rt::task::Task;\n+    use rt::sched::{Shutdown, TaskFromFriend};\n+    do run_in_bare_thread {\n+\tlet sleepers = SleeperList::new();\n+\tlet work_queue1 = WorkQueue::new();\n+\tlet work_queue2 = WorkQueue::new();\n+\tlet queues = ~[work_queue1.clone(), work_queue2.clone()];\n+\n+\tlet mut sched1 = ~Scheduler::new(~UvEventLoop::new(), work_queue1, queues.clone(),\n+\t\t\t\t\t sleepers.clone());\n+\tlet mut sched2 = ~Scheduler::new(~UvEventLoop::new(), work_queue2, queues.clone(),\n+\t\t\t\t\t sleepers.clone());\n+\n+\tlet handle1 = Cell::new(sched1.make_handle());\n+\tlet handle2 = Cell::new(sched2.make_handle());\n+\tlet tasksFriendHandle = Cell::new(sched2.make_handle());\n+\n+\tlet on_exit: ~fn(bool) = |exit_status| {\n+\t    handle1.take().send(Shutdown);\n+\t    handle2.take().send(Shutdown);\n+\t    rtassert!(exit_status);\n+\t};\n+\n+\tlet test_function: ~fn() = || {\n+\t    let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n+\t    let addr = next_test_ip4();\n+\t    let maybe_socket = unsafe { (*io).homed_udp_bind(addr) };\n+\t    // this socket is bound to this event loop\n+\t    assert!(maybe_socket.is_ok());\n+\n+\t    // block self on sched1\n+\t    let scheduler = Local::take::<Scheduler>();\n+\t    do scheduler.deschedule_running_task_and_then |_, task| {\n+\t\t// unblock task\n+\t\tdo task.wake().map_move |task| {\n+\t\t  // send self to sched2\n+\t\t  tasksFriendHandle.take().send(TaskFromFriend(task));\n+\t\t};\n+\t\t// sched1 should now sleep since it has nothing else to do\n+\t    }\n+\t    // sched2 will wake up and get the task\n+\t    // as we do nothing else, the function ends and the socket goes out of scope\n+\t    // sched2 will start to run the destructor\n+\t    // the destructor will first block the task, set it's home as sched1, then enqueue it\n+\t    // sched2 will dequeue the task, see that it has a home, and send it to sched1\n+\t    // sched1 will wake up, execute the close function on the correct loop, and then we're done\n+\t};\n+\n+\tlet mut main_task = ~Task::new_root(&mut sched1.stack_pool, None, test_function);\n+\tmain_task.death.on_exit = Some(on_exit);\n+\tlet main_task = Cell::new(main_task);\n+\n+\tlet null_task = Cell::new(~do Task::new_root(&mut sched2.stack_pool, None) || {});\n+\n+\tlet sched1 = Cell::new(sched1);\n+\tlet sched2 = Cell::new(sched2);\n+\n+\t// XXX could there be a race on the threads that causes a crash?\n+\tlet thread1 = do Thread::start {\n+\t    sched1.take().bootstrap(main_task.take());\n+\t};\n+\tlet thread2 = do Thread::start {\n+\t    sched2.take().bootstrap(null_task.take());\n+\t};\n+\n+\tthread1.join();\n+\tthread2.join();\n+    }\n+}\n+\n pub struct UvUdpSocket(UdpWatcher);\n \n impl Drop for UvUdpSocket {"}]}