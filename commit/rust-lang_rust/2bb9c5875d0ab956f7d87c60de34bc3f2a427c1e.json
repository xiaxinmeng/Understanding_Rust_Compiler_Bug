{"sha": "2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiYjljNTg3NWQwYWI5NTZmN2Q4N2M2MGRlMzRiYzNmMmE0MjdjMWU=", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2017-02-09T09:34:45Z"}, "committer": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2017-02-09T09:34:45Z"}, "message": "Add recursion limit to inhabitedness check\n\nFixes #39489.\nAdd test aswell.", "tree": {"sha": "83ed7f19957a8fdff80593ae94d30864e35dc714", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83ed7f19957a8fdff80593ae94d30864e35dc714"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e", "html_url": "https://github.com/rust-lang/rust/commit/2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3da24bba940831697a024b93569891c77675778", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3da24bba940831697a024b93569891c77675778", "html_url": "https://github.com/rust-lang/rust/commit/a3da24bba940831697a024b93569891c77675778"}], "stats": {"total": 66, "additions": 52, "deletions": 14}, "files": [{"sha": "51d046728c2bf7f911bd15f7f2862781b2c2125c", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e", "patch": "@@ -62,11 +62,14 @@ mod def_id_forest;\n // This code should only compile in modules where the uninhabitedness of Foo is\n // visible.\n \n+const ARBITRARY_RECURSION_LIMIT: u32 = 24;\n+\n impl<'a, 'gcx, 'tcx> AdtDef {\n     /// Calculate the forest of DefIds from which this adt is visibly uninhabited.\n     pub fn uninhabited_from(\n                 &self,\n                 visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                recursion_depth: u32,\n                 tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 substs: &'tcx Substs<'tcx>) -> DefIdForest\n     {\n@@ -75,7 +78,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n \n         let ret = DefIdForest::intersection(tcx, self.variants.iter().map(|v| {\n-            v.uninhabited_from(visited, tcx, substs, self.adt_kind())\n+            v.uninhabited_from(visited, recursion_depth, tcx, substs, self.adt_kind())\n         }));\n         visited.remove(&(self.did, substs));\n         ret\n@@ -87,24 +90,25 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n     pub fn uninhabited_from(\n                 &self,\n                 visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                recursion_depth: u32,\n                 tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 substs: &'tcx Substs<'tcx>,\n                 adt_kind: AdtKind) -> DefIdForest\n     {\n         match adt_kind {\n             AdtKind::Union => {\n                 DefIdForest::intersection(tcx, self.fields.iter().map(|f| {\n-                    f.uninhabited_from(visited, tcx, substs, false)\n+                    f.uninhabited_from(visited, recursion_depth, tcx, substs, false)\n                 }))\n             },\n             AdtKind::Struct => {\n                 DefIdForest::union(tcx, self.fields.iter().map(|f| {\n-                    f.uninhabited_from(visited, tcx, substs, false)\n+                    f.uninhabited_from(visited, recursion_depth, tcx, substs, false)\n                 }))\n             },\n             AdtKind::Enum => {\n                 DefIdForest::union(tcx, self.fields.iter().map(|f| {\n-                    f.uninhabited_from(visited, tcx, substs, true)\n+                    f.uninhabited_from(visited, recursion_depth, tcx, substs, true)\n                 }))\n             },\n         }\n@@ -116,11 +120,14 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n     pub fn uninhabited_from(\n                 &self,\n                 visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                recursion_depth: u32,\n                 tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 substs: &'tcx Substs<'tcx>,\n                 is_enum: bool) -> DefIdForest\n     {\n-        let mut data_uninhabitedness = move || self.ty(tcx, substs).uninhabited_from(visited, tcx);\n+        let mut data_uninhabitedness = move || {\n+            self.ty(tcx, substs).uninhabited_from(visited, recursion_depth, tcx)\n+        };\n         // FIXME(canndrew): Currently enum fields are (incorrectly) stored with\n         // Visibility::Invisible so we need to override self.vis if we're\n         // dealing with an enum.\n@@ -145,8 +152,14 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     pub fn uninhabited_from(\n                 &self,\n                 visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                mut recursion_depth: u32,\n                 tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n     {\n+        recursion_depth += 1;\n+        if recursion_depth >= ARBITRARY_RECURSION_LIMIT {\n+            return DefIdForest::empty();\n+        }\n+\n         match tcx.lift_to_global(&self) {\n             Some(global_ty) => {\n                 {\n@@ -155,13 +168,13 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                         return forest.clone();\n                     }\n                 }\n-                let forest = global_ty.uninhabited_from_inner(visited, tcx);\n+                let forest = global_ty.uninhabited_from_inner(visited, recursion_depth, tcx);\n                 let mut cache = tcx.inhabitedness_cache.borrow_mut();\n                 cache.insert(global_ty, forest.clone());\n                 forest\n             },\n             None => {\n-                let forest = self.uninhabited_from_inner(visited, tcx);\n+                let forest = self.uninhabited_from_inner(visited, recursion_depth, tcx);\n                 forest\n             },\n         }\n@@ -170,28 +183,29 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     fn uninhabited_from_inner(\n                 &self,\n                 visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                recursion_depth: u32,\n                 tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n     {\n         match self.sty {\n             TyAdt(def, substs) => {\n-                def.uninhabited_from(visited, tcx, substs)\n+                def.uninhabited_from(visited, recursion_depth, tcx, substs)\n             },\n \n             TyNever => DefIdForest::full(tcx),\n             TyTuple(ref tys, _) => {\n                 DefIdForest::union(tcx, tys.iter().map(|ty| {\n-                    ty.uninhabited_from(visited, tcx)\n+                    ty.uninhabited_from(visited, recursion_depth, tcx)\n                 }))\n             },\n             TyArray(ty, len) => {\n                 if len == 0 {\n                     DefIdForest::empty()\n                 } else {\n-                    ty.uninhabited_from(visited, tcx)\n+                    ty.uninhabited_from(visited, recursion_depth, tcx)\n                 }\n             }\n             TyRef(_, ref tm) => {\n-                tm.ty.uninhabited_from(visited, tcx)\n+                tm.ty.uninhabited_from(visited, recursion_depth, tcx)\n             }\n \n             _ => DefIdForest::empty(),"}, {"sha": "61b774924260d7138ea41f874efaba831e69a8ca", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e", "patch": "@@ -1019,7 +1019,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// visible.\n     pub fn is_uninhabited_from(&self, module: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n         let mut visited = FxHashSet::default();\n-        let forest = self.uninhabited_from(&mut visited, tcx);\n+        let forest = self.uninhabited_from(&mut visited, 0, tcx);\n \n         // To check whether this type is uninhabited at all (not just from the\n         // given node) you could check whether the forest is empty."}, {"sha": "101c43332a326313c66e1c8ddfc032b91ed14364", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e", "patch": "@@ -405,7 +405,7 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         ty::TyAdt(def, substs) if def.is_enum() && def.variants.len() != 1 => {\n             def.variants.iter().filter_map(|v| {\n                 let mut visited = FxHashSet::default();\n-                let forest = v.uninhabited_from(&mut visited,\n+                let forest = v.uninhabited_from(&mut visited, 0,\n                                                 cx.tcx, substs,\n                                                 AdtKind::Enum);\n                 if forest.contains(cx.tcx, cx.module)"}, {"sha": "f6bfed8c7ab5ccc41f375a653769c53f2dbbe5c0", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e", "patch": "@@ -103,7 +103,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let irrefutable = adt_def.variants.iter().enumerate().all(|(i, v)| {\n                         i == variant_index || {\n                             let mut visited = FxHashSet::default();\n-                            let node_set = v.uninhabited_from(&mut visited,\n+                            let node_set = v.uninhabited_from(&mut visited, 0,\n                                                               self.hir.tcx(),\n                                                               substs,\n                                                               adt_def.adt_kind());"}, {"sha": "eba0da3a216aa084bbb5bee6081db2acdb62d2cd", "filename": "src/test/compile-fail/inhabitedness-infinite-loop.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e/src%2Ftest%2Fcompile-fail%2Finhabitedness-infinite-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e/src%2Ftest%2Fcompile-fail%2Finhabitedness-infinite-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finhabitedness-infinite-loop.rs?ref=2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(never_type)]\n+\n+struct Foo<'a, T: 'a> {\n+    ph: std::marker::PhantomData<T>,\n+    foo: &'a Foo<'a, (T, T)>,\n+}\n+\n+fn wub(f: Foo<!>) {\n+    match f {}\n+    //~^ ERROR non-exhaustive\n+}\n+\n+fn main() {}\n+"}]}