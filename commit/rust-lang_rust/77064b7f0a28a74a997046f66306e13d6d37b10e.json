{"sha": "77064b7f0a28a74a997046f66306e13d6d37b10e", "node_id": "C_kwDOAAsO6NoAKDc3MDY0YjdmMGEyOGE3NGE5OTcwNDZmNjYzMDZlMTNkNmQzN2IxMGU", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-10-14T10:49:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-14T10:49:15Z"}, "message": "Rollup merge of #103018 - Rageking8:more-dupe-word-typos, r=TaKO8Ki\n\nMore dupe word typos\n\nI only picked those changes (from the regex search) that I am pretty certain doesn't change meaning and is just a typo fix. Do correct me if any fix is undesirable and I can revert those. Thanks.", "tree": {"sha": "3a754a565528b532611746e8346900d66d66553a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a754a565528b532611746e8346900d66d66553a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77064b7f0a28a74a997046f66306e13d6d37b10e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjST6rCRBK7hj4Ov3rIwAADfYIAH+NVMZCeQajdLMNtJgg0hyl\nh7b6YqfONXVbtB4j/x+0FiwXZXkbfkig+8EGWyrxrDn8I1iEmG/EReceFwrPAXDM\nTp1KeI0c39hlv75oHZWfvVMzT+DMOIrcnIDd8U0dpV++hspL+cTEI5q7Kkwz/Rir\nNDMrRpF1Ziq12FoZssTeLNzUXlohJf4q8JInTKJ0gw+wTq8OFLCEPpzSPbrOaD9k\nFV3dMF4T4YsFbIUAB9wd0I+wNQ+3ghOEuxNKzGTIalFBZQYo/dOnORGRwbms7R7U\n/p4PfR9YP4sHsfnNPGLL8Hdm6+gNLF1RgMGIhu4tR2EfwqcnY/7cGNIQd9lcExE=\n=7KJe\n-----END PGP SIGNATURE-----\n", "payload": "tree 3a754a565528b532611746e8346900d66d66553a\nparent 8c9ecbb7e3adf14a19e16568422026849822a7ad\nparent 7122abaddf2cf10ce26f86305ff540ae5b38c097\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1665744555 +0530\ncommitter GitHub <noreply@github.com> 1665744555 +0530\n\nRollup merge of #103018 - Rageking8:more-dupe-word-typos, r=TaKO8Ki\n\nMore dupe word typos\n\nI only picked those changes (from the regex search) that I am pretty certain doesn't change meaning and is just a typo fix. Do correct me if any fix is undesirable and I can revert those. Thanks.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77064b7f0a28a74a997046f66306e13d6d37b10e", "html_url": "https://github.com/rust-lang/rust/commit/77064b7f0a28a74a997046f66306e13d6d37b10e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77064b7f0a28a74a997046f66306e13d6d37b10e/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c9ecbb7e3adf14a19e16568422026849822a7ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c9ecbb7e3adf14a19e16568422026849822a7ad", "html_url": "https://github.com/rust-lang/rust/commit/8c9ecbb7e3adf14a19e16568422026849822a7ad"}, {"sha": "7122abaddf2cf10ce26f86305ff540ae5b38c097", "url": "https://api.github.com/repos/rust-lang/rust/commits/7122abaddf2cf10ce26f86305ff540ae5b38c097", "html_url": "https://github.com/rust-lang/rust/commit/7122abaddf2cf10ce26f86305ff540ae5b38c097"}], "stats": {"total": 140, "additions": 68, "deletions": 72}, "files": [{"sha": "2beb5e0ab5d20daf2c3e878c4462c0b71e571a78", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -414,7 +414,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n         let typeck_root_def_id = self.infcx.tcx.typeck_root_def_id(self.mir_def.did.to_def_id());\n \n-        // If this is is a 'root' body (not a closure/generator/inline const), then\n+        // If this is a 'root' body (not a closure/generator/inline const), then\n         // there are no extern regions, so the local regions start at the same\n         // position as the (empty) sub-list of extern regions\n         let first_local_index = if self.mir_def.did.to_def_id() == typeck_root_def_id {"}, {"sha": "3c08b6fa3894d61277a0c0b6499e23ddcdc544a9", "filename": "compiler/rustc_codegen_cranelift/build_system/rustc_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -65,7 +65,7 @@ pub(crate) fn get_file_name(crate_name: &str, crate_type: &str) -> String {\n }\n \n /// Similar to `get_file_name`, but converts any dashes (`-`) in the `crate_name` to\n-/// underscores (`_`). This is specially made for the the rustc and cargo wrappers\n+/// underscores (`_`). This is specially made for the rustc and cargo wrappers\n /// which have a dash in the name, and that is not allowed in a crate name.\n pub(crate) fn get_wrapper_file_name(crate_name: &str, crate_type: &str) -> String {\n     let crate_name = crate_name.replace('-', \"_\");"}, {"sha": "e5ad31eb9484a85530df617646b0897c739ae783", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -193,7 +193,7 @@ pub(super) fn from_casted_value<'tcx>(\n         kind: StackSlotKind::ExplicitSlot,\n         // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n         // specify stack slot alignment.\n-        // Stack slot size may be bigger for for example `[u8; 3]` which is packed into an `i32`.\n+        // Stack slot size may be bigger for example `[u8; 3]` which is packed into an `i32`.\n         // It may also be smaller for example when the type is a wrapper around an integer with a\n         // larger alignment than the integer.\n         size: (std::cmp::max(abi_param_size, layout_size) + 15) / 16 * 16,"}, {"sha": "433f043209e5314a08e3b7bb2cbc81b0bc0642db", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -129,7 +129,7 @@ impl CoverageMapGenerator {\n             // LLVM Coverage Mapping Format version 6 (zero-based encoded as 5)\n             // requires setting the first filename to the compilation directory.\n             // Since rustc generates coverage maps with relative paths, the\n-            // compilation directory can be combined with the the relative paths\n+            // compilation directory can be combined with the relative paths\n             // to get absolute paths, if needed.\n             let working_dir = tcx\n                 .sess"}, {"sha": "4977a5d6bbf0593f2edeeb33645d9e7b7d68a477", "filename": "compiler/rustc_const_eval/src/const_eval/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -64,7 +64,7 @@ pub struct ConstEvalErr<'tcx> {\n impl<'tcx> ConstEvalErr<'tcx> {\n     /// Turn an interpreter error into something to report to the user.\n     /// As a side-effect, if RUSTC_CTFE_BACKTRACE is set, this prints the backtrace.\n-    /// Should be called only if the error is actually going to to be reported!\n+    /// Should be called only if the error is actually going to be reported!\n     pub fn new<'mir, M: Machine<'mir, 'tcx>>(\n         ecx: &InterpCx<'mir, 'tcx, M>,\n         error: InterpErrorInfo<'tcx>,"}, {"sha": "e5e015c1e1802408293c16fae02a20bfd357b491", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -794,7 +794,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             todo.extend(static_roots);\n             while let Some(id) = todo.pop() {\n                 if reachable.insert(id) {\n-                    // This is a new allocation, add the allocation it points to to `todo`.\n+                    // This is a new allocation, add the allocation it points to `todo`.\n                     if let Some((_, alloc)) = self.memory.alloc_map.get(id) {\n                         todo.extend(\n                             alloc.provenance().values().filter_map(|prov| prov.get_alloc_id()),"}, {"sha": "e8efbd09a2c38c815647ec4cd62b5acae103bbc7", "filename": "compiler/rustc_data_structures/src/graph/vec_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Fmod.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -29,8 +29,8 @@ impl<N: Idx + Ord> VecGraph<N> {\n         // Store the *target* of each edge into `edge_targets`.\n         let edge_targets: Vec<N> = edge_pairs.iter().map(|&(_, target)| target).collect();\n \n-        // Create the *edge starts* array. We are iterating over over\n-        // the (sorted) edge pairs. We maintain the invariant that the\n+        // Create the *edge starts* array. We are iterating over the\n+        // (sorted) edge pairs. We maintain the invariant that the\n         // length of the `node_starts` array is enough to store the\n         // current source node -- so when we see that the source node\n         // for an edge is greater than the current length, we grow the"}, {"sha": "59f434b941e782e135dabe56ac5f18fa3bf4ef91", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -327,7 +327,7 @@ impl InvocationKind {\n     fn placeholder_visibility(&self) -> Option<ast::Visibility> {\n         // HACK: For unnamed fields placeholders should have the same visibility as the actual\n         // fields because for tuple structs/variants resolve determines visibilities of their\n-        // constructor using these field visibilities before attributes on them are are expanded.\n+        // constructor using these field visibilities before attributes on them are expanded.\n         // The assumption is that the attribute expansion cannot change field visibilities,\n         // and it holds because only inert attributes are supported in this position.\n         match self {"}, {"sha": "474d5651bbe2f137b9c6e29aeefced6a80791192", "filename": "compiler/rustc_hir_analysis/src/check/fallback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffallback.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     //\n     // - Unconstrained ints are replaced with `i32`.\n     //\n-    // - Unconstrained floats are replaced with with `f64`.\n+    // - Unconstrained floats are replaced with `f64`.\n     //\n     // - Non-numerics may get replaced with `()` or `!`, depending on\n     //   how they were categorized by `calculate_diverging_fallback`"}, {"sha": "122ad7009cb497181c76386740de783fb4ad0001", "filename": "compiler/rustc_hir_analysis/src/check/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -210,7 +210,7 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n     }\n \n     /// For an expression with an uninhabited return type (e.g. a function that returns !),\n-    /// this adds a self edge to to the CFG to model the fact that the function does not\n+    /// this adds a self edge to the CFG to model the fact that the function does not\n     /// return.\n     fn handle_uninhabited_return(&mut self, expr: &Expr<'tcx>) {\n         let ty = self.typeck_results.expr_ty(expr);"}, {"sha": "4dea40829f6221a2b4e4400789676b9bd5b8b4ce", "filename": "compiler/rustc_hir_analysis/src/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fupvar.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -352,7 +352,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// and that the path can be captured with required capture kind (depending on use in closure,\n     /// move closure etc.)\n     ///\n-    /// Returns the set of of adjusted information along with the inferred closure kind and span\n+    /// Returns the set of adjusted information along with the inferred closure kind and span\n     /// associated with the closure kind inference.\n     ///\n     /// Note that we *always* infer a minimal kind, even if"}, {"sha": "167ef2791040a8c95759da7ec67dd1b57b3e2161", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -1150,8 +1150,8 @@ impl<'tcx> InferCtxt<'tcx> {\n     /// Return the universe that the region `r` was created in.  For\n     /// most regions (e.g., `'static`, named regions from the user,\n     /// etc) this is the root universe U0. For inference variables or\n-    /// placeholders, however, it will return the universe which which\n-    /// they are associated.\n+    /// placeholders, however, it will return the universe which they\n+    /// are associated.\n     pub fn universe_of_region(&self, r: ty::Region<'tcx>) -> ty::UniverseIndex {\n         self.inner.borrow_mut().unwrap_region_constraints().universe(r)\n     }"}, {"sha": "886e25f2d788bc87345b00c897f4a87611a0174a", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -3310,7 +3310,7 @@ declare_lint! {\n     /// explicitly.\n     ///\n     /// To access a library from a binary target within the same crate,\n-    /// use `your_crate_name::` as the path path instead of `lib::`:\n+    /// use `your_crate_name::` as the path instead of `lib::`:\n     ///\n     /// ```rust,compile_fail\n     /// // bar/src/lib.rs"}, {"sha": "8390d80a458cfb437a155c8c3626ffb6a8056122", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -3937,7 +3937,7 @@ declare_lint! {\n     ///\n     /// The compiler disables the automatic implementation if an explicit one\n     /// exists for given type constructor. The exact rules governing this\n-    /// are currently unsound and quite subtle and and will be modified in the future.\n+    /// are currently unsound, quite subtle, and will be modified in the future.\n     /// This change will cause the automatic implementation to be disabled in more\n     /// cases, potentially breaking some code.\n     pub SUSPICIOUS_AUTO_TRAIT_IMPLS,"}, {"sha": "23c2ce6474c5a271694562d4fc5b3467d119b83f", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -43,7 +43,7 @@ pub trait PointerArithmetic: HasDataLayout {\n         let val = val as i64;\n         // Now wrap-around into the machine_isize range.\n         if val > self.machine_isize_max() {\n-            // This can only happen the the ptr size is < 64, so we know max_usize_plus_1 fits into\n+            // This can only happen if the ptr size is < 64, so we know max_usize_plus_1 fits into\n             // i64.\n             debug_assert!(self.pointer_size().bits() < 64);\n             let max_usize_plus_1 = 1u128 << self.pointer_size().bits();"}, {"sha": "ce4a46e362d80e231e34d731a113bcc076137c66", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -13,8 +13,7 @@\n //!\n //! There are three groups of traits involved in each traversal.\n //! - `TypeFoldable`. This is implemented once for many types, including:\n-//!   - Types of interest, for which the the methods delegate to the\n-//!     folder.\n+//!   - Types of interest, for which the methods delegate to the folder.\n //!   - All other types, including generic containers like `Vec` and `Option`.\n //!     It defines a \"skeleton\" of how they should be folded.\n //! - `TypeSuperFoldable`. This is implemented only for each type of interest,"}, {"sha": "f73d062ba30a6282d8d77667d1a7490a8ab705f0", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -958,7 +958,7 @@ impl<'tcx> Ty<'tcx> {\n         }\n     }\n \n-    /// Checks if `ty` has has a significant drop.\n+    /// Checks if `ty` has a significant drop.\n     ///\n     /// Note that this method can return false even if `ty` has a destructor\n     /// attached; even if that is the case then the adt has been marked with"}, {"sha": "6e1991b527fe3ed0bf35e64132b10745cf694e10", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -10,8 +10,7 @@\n //!\n //! There are three groups of traits involved in each traversal.\n //! - `TypeVisitable`. This is implemented once for many types, including:\n-//!   - Types of interest, for which the the methods delegate to the\n-//!     visitor.\n+//!   - Types of interest, for which the methods delegate to the visitor.\n //!   - All other types, including generic containers like `Vec` and `Option`.\n //!     It defines a \"skeleton\" of how they should be visited.\n //! - `TypeSuperVisitable`. This is implemented only for each type of interest,"}, {"sha": "8dc9976eaea8af13a0d8d98b282d9743151217e6", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -885,7 +885,7 @@ fn is_useful<'p, 'tcx>(\n             // that has the potential to trigger the `non_exhaustive_omitted_patterns` lint.\n             // To understand the workings checkout `Constructor::split` and `SplitWildcard::new/into_ctors`\n             if is_non_exhaustive_and_wild\n-                // We check that the match has a wildcard pattern and that that wildcard is useful,\n+                // We check that the match has a wildcard pattern and that wildcard is useful,\n                 // meaning there are variants that are covered by the wildcard. Without the check\n                 // for `witness_preference` the lint would trigger on `if let NonExhaustiveEnum::A = foo {}`\n                 && usefulness.is_useful() && matches!(witness_preference, RealArm)"}, {"sha": "828b7d2f2f7be6ea0435fcaec8daf8fce5a7cc98", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -2232,7 +2232,7 @@ impl<'a> Parser<'a> {\n     ///\n     /// When encountering code like `foo::< bar + 3 >` or `foo::< bar - baz >` we suggest\n     /// `foo::<{ bar + 3 }>` and `foo::<{ bar - baz }>`, respectively. We only provide a suggestion\n-    /// if we think that that the resulting expression would be well formed.\n+    /// if we think that the resulting expression would be well formed.\n     pub fn recover_const_arg(\n         &mut self,\n         start: Span,"}, {"sha": "dab8ae47779522106514164e11922392bfed8e15", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -268,7 +268,7 @@ impl CheckAttrVisitor<'_> {\n             }\n             // FIXME(#65833): We permit associated consts to have an `#[inline]` attribute with\n             // just a lint, because we previously erroneously allowed it and some crates used it\n-            // accidentally, to to be compatible with crates depending on them, we can't throw an\n+            // accidentally, to be compatible with crates depending on them, we can't throw an\n             // error here.\n             Target::AssocConst => {\n                 self.tcx.emit_spanned_lint(\n@@ -376,7 +376,7 @@ impl CheckAttrVisitor<'_> {\n             | Target::Method(MethodKind::Trait { body: true } | MethodKind::Inherent) => true,\n             // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n             // `#[allow_internal_unstable]` attribute with just a lint, because we previously\n-            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // erroneously allowed it and some crates used it accidentally, to be compatible\n             // with crates depending on them, we can't throw an error here.\n             Target::Field | Target::Arm | Target::MacroDef => {\n                 self.inline_attr_str_error_with_macro_def(hir_id, attr, \"naked\");\n@@ -456,7 +456,7 @@ impl CheckAttrVisitor<'_> {\n             Target::Fn | Target::Method(..) | Target::ForeignFn | Target::Closure => true,\n             // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n             // `#[track_caller]` attribute with just a lint, because we previously\n-            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // erroneously allowed it and some crates used it accidentally, to be compatible\n             // with crates depending on them, we can't throw an error here.\n             Target::Field | Target::Arm | Target::MacroDef => {\n                 for attr in attrs {\n@@ -485,7 +485,7 @@ impl CheckAttrVisitor<'_> {\n             Target::Struct | Target::Enum | Target::Variant => true,\n             // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n             // `#[non_exhaustive]` attribute with just a lint, because we previously\n-            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // erroneously allowed it and some crates used it accidentally, to be compatible\n             // with crates depending on them, we can't throw an error here.\n             Target::Field | Target::Arm | Target::MacroDef => {\n                 self.inline_attr_str_error_with_macro_def(hir_id, attr, \"non_exhaustive\");\n@@ -507,7 +507,7 @@ impl CheckAttrVisitor<'_> {\n             Target::Trait => true,\n             // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n             // `#[marker]` attribute with just a lint, because we previously\n-            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // erroneously allowed it and some crates used it accidentally, to be compatible\n             // with crates depending on them, we can't throw an error here.\n             Target::Field | Target::Arm | Target::MacroDef => {\n                 self.inline_attr_str_error_with_macro_def(hir_id, attr, \"marker\");\n@@ -566,7 +566,7 @@ impl CheckAttrVisitor<'_> {\n             }\n             // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n             // `#[target_feature]` attribute with just a lint, because we previously\n-            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // erroneously allowed it and some crates used it accidentally, to be compatible\n             // with crates depending on them, we can't throw an error here.\n             Target::Field | Target::Arm | Target::MacroDef => {\n                 self.inline_attr_str_error_with_macro_def(hir_id, attr, \"target_feature\");\n@@ -1205,7 +1205,7 @@ impl CheckAttrVisitor<'_> {\n             Target::Fn | Target::Method(..) | Target::ForeignFn | Target::Closure => {}\n             // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n             // `#[cold]` attribute with just a lint, because we previously\n-            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // erroneously allowed it and some crates used it accidentally, to be compatible\n             // with crates depending on them, we can't throw an error here.\n             Target::Field | Target::Arm | Target::MacroDef => {\n                 self.inline_attr_str_error_with_macro_def(hir_id, attr, \"cold\");\n@@ -1247,7 +1247,7 @@ impl CheckAttrVisitor<'_> {\n             Target::ForeignFn | Target::ForeignStatic => {}\n             // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n             // `#[link_name]` attribute with just a lint, because we previously\n-            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // erroneously allowed it and some crates used it accidentally, to be compatible\n             // with crates depending on them, we can't throw an error here.\n             Target::Field | Target::Arm | Target::MacroDef => {\n                 self.inline_attr_str_error_with_macro_def(hir_id, attr, \"link_name\");\n@@ -1281,7 +1281,7 @@ impl CheckAttrVisitor<'_> {\n             Target::ExternCrate => true,\n             // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n             // `#[no_link]` attribute with just a lint, because we previously\n-            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // erroneously allowed it and some crates used it accidentally, to be compatible\n             // with crates depending on them, we can't throw an error here.\n             Target::Field | Target::Arm | Target::MacroDef => {\n                 self.inline_attr_str_error_with_macro_def(hir_id, attr, \"no_link\");\n@@ -1311,7 +1311,7 @@ impl CheckAttrVisitor<'_> {\n             Target::Method(..) if self.is_impl_item(hir_id) => true,\n             // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n             // `#[export_name]` attribute with just a lint, because we previously\n-            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // erroneously allowed it and some crates used it accidentally, to be compatible\n             // with crates depending on them, we can't throw an error here.\n             Target::Field | Target::Arm | Target::MacroDef => {\n                 self.inline_attr_str_error_with_macro_def(hir_id, attr, \"export_name\");\n@@ -1503,7 +1503,7 @@ impl CheckAttrVisitor<'_> {\n             Target::Static | Target::Fn | Target::Method(..) => {}\n             // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n             // `#[link_section]` attribute with just a lint, because we previously\n-            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // erroneously allowed it and some crates used it accidentally, to be compatible\n             // with crates depending on them, we can't throw an error here.\n             Target::Field | Target::Arm | Target::MacroDef => {\n                 self.inline_attr_str_error_with_macro_def(hir_id, attr, \"link_section\");\n@@ -1528,7 +1528,7 @@ impl CheckAttrVisitor<'_> {\n             Target::Method(..) if self.is_impl_item(hir_id) => {}\n             // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n             // `#[no_mangle]` attribute with just a lint, because we previously\n-            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // erroneously allowed it and some crates used it accidentally, to be compatible\n             // with crates depending on them, we can't throw an error here.\n             Target::Field | Target::Arm | Target::MacroDef => {\n                 self.inline_attr_str_error_with_macro_def(hir_id, attr, \"no_mangle\");\n@@ -1782,7 +1782,7 @@ impl CheckAttrVisitor<'_> {\n             Target::MacroDef => true,\n             // FIXME(#80564): We permit struct fields and match arms to have an\n             // `#[allow_internal_unstable]` attribute with just a lint, because we previously\n-            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // erroneously allowed it and some crates used it accidentally, to be compatible\n             // with crates depending on them, we can't throw an error here.\n             Target::Field | Target::Arm => {\n                 self.inline_attr_str_error_without_macro_def(\n@@ -1877,7 +1877,7 @@ impl CheckAttrVisitor<'_> {\n             }\n             // FIXME(#80564): We permit struct fields and match arms to have an\n             // `#[allow_internal_unstable]` attribute with just a lint, because we previously\n-            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // erroneously allowed it and some crates used it accidentally, to be compatible\n             // with crates depending on them, we can't throw an error here.\n             Target::Field | Target::Arm | Target::MacroDef => {\n                 self.inline_attr_str_error_with_macro_def(hir_id, attr, \"allow_internal_unstable\");"}, {"sha": "1c1976af5054c24c25f23b2994f23eee0dd163fb", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -2060,7 +2060,7 @@ struct Finalize {\n     /// Span of the whole path or some its characteristic fragment.\n     /// E.g. span of `b` in `foo::{a, b, c}`, or full span for regular paths.\n     path_span: Span,\n-    /// Span of the path start, suitable for prepending something to to it.\n+    /// Span of the path start, suitable for prepending something to it.\n     /// E.g. span of `foo` in `foo::{a, b, c}`, or full span for regular paths.\n     root_span: Span,\n     /// Whether to report privacy errors or silently return \"no resolution\" for them,"}, {"sha": "a8be318dea8aeb1784ca263e948e94cd9666d617", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -186,7 +186,7 @@ top_level_options!(\n         /// Remap source path prefixes in all output (messages, object files, debug, etc.).\n         remap_path_prefix: Vec<(PathBuf, PathBuf)> [TRACKED_NO_CRATE_HASH],\n         /// Base directory containing the `src/` for the Rust standard library, and\n-        /// potentially `rustc` as well, if we can can find it. Right now it's always\n+        /// potentially `rustc` as well, if we can find it. Right now it's always\n         /// `$sysroot/lib/rustlib/src/rust` (i.e. the `rustup` `rust-src` component).\n         ///\n         /// This directory is what the virtual `/rustc/$hash` is translated back to,"}, {"sha": "6aa031c8378e64333ae3c0ba32e29234bc7e2f5f", "filename": "compiler/rustc_symbol_mangling/src/typeid/typeid_itanium_cxx_abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -540,7 +540,7 @@ fn encode_ty<'tcx>(\n             let mut s = String::new();\n             let def_id = adt_def.0.did;\n             if options.contains(EncodeTyOptions::GENERALIZE_REPR_C) && adt_def.repr().c() {\n-                // For for cross-language CFI support, the encoding must be compatible at the FFI\n+                // For cross-language CFI support, the encoding must be compatible at the FFI\n                 // boundary. For instance:\n                 //\n                 //     struct type1 {};"}, {"sha": "9e5f0e4d158b287b77460f68667c43163aac554d", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -47,7 +47,7 @@ pub enum PassMode {\n     /// Pass the argument indirectly via a hidden pointer.\n     /// The `extra_attrs` value, if any, is for the extra data (vtable or length)\n     /// which indicates that it refers to an unsized rvalue.\n-    /// `on_stack` defines that the the value should be passed at a fixed\n+    /// `on_stack` defines that the value should be passed at a fixed\n     /// stack offset in accordance to the ABI rather than passed using a\n     /// pointer. This corresponds to the `byval` LLVM argument attribute.\n     Indirect { attrs: ArgAttributes, extra_attrs: Option<ArgAttributes>, on_stack: bool },"}, {"sha": "7715874743192a4851cb686e2fe4bb098c85b113", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -193,7 +193,7 @@ fn overlap_within_probe<'cx, 'tcx>(\n         }\n     }\n \n-    // We disable the leak when when creating the `snapshot` by using\n+    // We disable the leak when creating the `snapshot` by using\n     // `infcx.probe_maybe_disable_leak_check`.\n     if infcx.leak_check(true, snapshot).is_err() {\n         debug!(\"overlap: leak check failed\");"}, {"sha": "b06f24ddf2e24bf653deb6982ee4306b2e88e03f", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -101,7 +101,7 @@ impl<'tcx> ConstUnifyCtxt<'tcx> {\n                         a_uv == b_uv\n                     }\n                     // FIXME(generic_const_exprs): We may want to either actually try\n-                    // to evaluate `a_ct` and `b_ct` if they are are fully concrete or something like\n+                    // to evaluate `a_ct` and `b_ct` if they are fully concrete or something like\n                     // this, for now we just return false here.\n                     _ => false,\n                 }"}, {"sha": "1ca9a1c1994f8e70c3914193219424252b3aa508", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -566,7 +566,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                     .unwrap_or_else(|| ty.super_fold_with(self).into())\n                 };\n                 // For cases like #95134 we would like to catch overflows early\n-                // otherwise they slip away away and cause ICE.\n+                // otherwise they slip away and cause ICE.\n                 let recursion_limit = self.tcx().recursion_limit();\n                 if !recursion_limit.value_within_limit(self.depth)\n                     // HACK: Don't overflow when running cargo doc see #100991"}, {"sha": "d390a30815307295d27f52cdfa1356f98b682b3c", "filename": "compiler/rustc_ty_utils/src/needs_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -264,7 +264,7 @@ fn adt_consider_insignificant_dtor<'tcx>(\n         if is_marked_insig {\n             // In some cases like `std::collections::HashMap` where the struct is a wrapper around\n             // a type that is a Drop type, and the wrapped type (eg: `hashbrown::HashMap`) lies\n-            // outside stdlib, we might choose to still annotate the the wrapper (std HashMap) with\n+            // outside stdlib, we might choose to still annotate the wrapper (std HashMap) with\n             // `rustc_insignificant_dtor`, even if the type itself doesn't have a `Drop` impl.\n             Some(DtorType::Insignificant)\n         } else if adt_def.destructor(tcx).is_some() {"}, {"sha": "f2f5dffc25d3a58710f1fc7f590f7a274cc1e808", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -1613,7 +1613,7 @@ impl<'a, T> CursorMut<'a, T> {\n             None\n         } else {\n             // We can't point to the node that we pop. Copying the behavior of\n-            // `remove_current`, we move on the the next node in the sequence.\n+            // `remove_current`, we move on to the next node in the sequence.\n             // If the list is of length 1 then we end pointing to the \"ghost\"\n             // node at index 0, which is expected.\n             if self.list.head == self.current {"}, {"sha": "789a87968d154d255c27017c25a4a70b468c0f36", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -692,7 +692,7 @@ pub trait Iterator {\n     /// assert_eq!(it.next(), Some(NotClone(99))); // The separator.\n     /// assert_eq!(it.next(), Some(NotClone(1)));  // The next element from `v`.\n     /// assert_eq!(it.next(), Some(NotClone(99))); // The separator.\n-    /// assert_eq!(it.next(), Some(NotClone(2)));  // The last element from from `v`.\n+    /// assert_eq!(it.next(), Some(NotClone(2)));  // The last element from `v`.\n     /// assert_eq!(it.next(), None);               // The iterator is finished.\n     /// ```\n     ///"}, {"sha": "e2ae39fbab3356fff1e473d4e370aceca09a21af", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -647,7 +647,7 @@ impl<T> MaybeUninit<T> {\n     /// implements the [`Copy`] trait or not. When using multiple copies of the\n     /// data (by calling `assume_init_read` multiple times, or first calling\n     /// `assume_init_read` and then [`assume_init`]), it is your responsibility\n-    /// to ensure that that data may indeed be duplicated.\n+    /// to ensure that data may indeed be duplicated.\n     ///\n     /// [inv]: #initialization-invariant\n     /// [`assume_init`]: MaybeUninit::assume_init"}, {"sha": "9f7594460a1d55ee7304bdb5256a2fc3ba31bf27", "filename": "library/core/src/num/dec2flt/lemire.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Flemire.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Flemire.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Flemire.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -76,7 +76,7 @@ pub fn compute_float<F: RawFloat>(q: i64, mut w: u64) -> BiasedFp {\n         return BiasedFp { f: mantissa, e: power2 };\n     }\n     // Need to handle rounding ties. Normally, we need to round up,\n-    // but if we fall right in between and and we have an even basis, we\n+    // but if we fall right in between and we have an even basis, we\n     // need to round down.\n     //\n     // This will only occur if:"}, {"sha": "80472528f6c3aedbaf7dabdf87c4025525b33637", "filename": "library/core/src/num/int_log10.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Fcore%2Fsrc%2Fnum%2Fint_log10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Fcore%2Fsrc%2Fnum%2Fint_log10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_log10.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -1,5 +1,5 @@\n /// These functions compute the integer logarithm of their type, assuming\n-/// that someone has already checked that the the value is strictly positive.\n+/// that someone has already checked that the value is strictly positive.\n \n // 0 < val <= u8::MAX\n #[inline]"}, {"sha": "67e59460d74b0e3d293652a62a8a48e9bf03eb52", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -694,7 +694,7 @@ impl<T: ?Sized> *const T {\n     /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n     ///\n     /// This computes the same value that [`offset_from`](#method.offset_from)\n-    /// would compute, but with the added precondition that that the offset is\n+    /// would compute, but with the added precondition that the offset is\n     /// guaranteed to be non-negative.  This method is equivalent to\n     /// `usize::from(self.offset_from(origin)).unwrap_unchecked()`,\n     /// but it provides slightly more information to the optimizer, which can"}, {"sha": "bbcc7c699e03612e8874e0f3172d80712874b964", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -867,7 +867,7 @@ impl<T: ?Sized> *mut T {\n     /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n     ///\n     /// This computes the same value that [`offset_from`](#method.offset_from)\n-    /// would compute, but with the added precondition that that the offset is\n+    /// would compute, but with the added precondition that the offset is\n     /// guaranteed to be non-negative.  This method is equivalent to\n     /// `usize::from(self.offset_from(origin)).unwrap_unchecked()`,\n     /// but it provides slightly more information to the optimizer, which can"}, {"sha": "cdc47e17938dc38e3e58e343f3015dd9a2545c11", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -1642,8 +1642,8 @@ impl<T> AtomicPtr<T> {\n     /// and the argument `val`, and stores a pointer with provenance of the\n     /// current pointer and the resulting address.\n     ///\n-    /// This is equivalent equivalent to using [`map_addr`] to atomically\n-    /// perform `ptr = ptr.map_addr(|a| a | val)`. This can be used in tagged\n+    /// This is equivalent to using [`map_addr`] to atomically perform\n+    /// `ptr = ptr.map_addr(|a| a | val)`. This can be used in tagged\n     /// pointer schemes to atomically set tag bits.\n     ///\n     /// **Caveat**: This operation returns the previous value. To compute the\n@@ -1693,8 +1693,8 @@ impl<T> AtomicPtr<T> {\n     /// pointer, and the argument `val`, and stores a pointer with provenance of\n     /// the current pointer and the resulting address.\n     ///\n-    /// This is equivalent equivalent to using [`map_addr`] to atomically\n-    /// perform `ptr = ptr.map_addr(|a| a & val)`. This can be used in tagged\n+    /// This is equivalent to using [`map_addr`] to atomically perform\n+    /// `ptr = ptr.map_addr(|a| a & val)`. This can be used in tagged\n     /// pointer schemes to atomically unset tag bits.\n     ///\n     /// **Caveat**: This operation returns the previous value. To compute the\n@@ -1743,8 +1743,8 @@ impl<T> AtomicPtr<T> {\n     /// pointer, and the argument `val`, and stores a pointer with provenance of\n     /// the current pointer and the resulting address.\n     ///\n-    /// This is equivalent equivalent to using [`map_addr`] to atomically\n-    /// perform `ptr = ptr.map_addr(|a| a ^ val)`. This can be used in tagged\n+    /// This is equivalent to using [`map_addr`] to atomically perform\n+    /// `ptr = ptr.map_addr(|a| a ^ val)`. This can be used in tagged\n     /// pointer schemes to atomically toggle tag bits.\n     ///\n     /// **Caveat**: This operation returns the previous value. To compute the"}, {"sha": "c79e909e41db80da89efba1b94d3b41f35523c64", "filename": "library/core/tests/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fmod.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -172,7 +172,7 @@ fn test_can_not_overflow() {\n \n            // Calcutate the string length for the smallest overflowing number:\n            let max_len_string = format_radix(num, base as u128);\n-           // Ensure that that string length is deemed to potentially overflow:\n+           // Ensure that string length is deemed to potentially overflow:\n            assert!(can_overflow::<$t>(base, &max_len_string));\n         }\n         )*)"}, {"sha": "b8249a027ad99445cc90a0f51f749b3ba12f7a93", "filename": "library/std/src/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -1629,7 +1629,7 @@ impl ExitStatusError {\n     ///\n     /// This is exactly like [`code()`](Self::code), except that it returns a `NonZeroI32`.\n     ///\n-    /// Plain `code`, returning a plain integer, is provided because is is often more convenient.\n+    /// Plain `code`, returning a plain integer, is provided because it is often more convenient.\n     /// The returned value from `code()` is indeed also nonzero; use `code_nonzero()` when you want\n     /// a type-level guarantee of nonzeroness.\n     ///"}, {"sha": "66ea3db2015a40fd3868d4a51077b5c29fda3ae2", "filename": "library/std/src/sys/unix/process/process_fuchsia.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -287,7 +287,7 @@ impl ExitStatus {\n         // SuS and POSIX) say a wait status is, but Fuchsia apparently uses a u64, so it won't\n         // necessarily fit.\n         //\n-        // It seems to me that that the right answer would be to provide std::os::fuchsia with its\n+        // It seems to me that the right answer would be to provide std::os::fuchsia with its\n         // own ExitStatusExt, rather that trying to provide a not very convincing imitation of\n         // Unix.  Ie, std::os::unix::process:ExitStatusExt ought not to exist on Fuchsia.  But\n         // fixing this up that is beyond the scope of my efforts now."}, {"sha": "4ccdabe4bb67d7a7dbbb1d83c5d432826e985d54", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -464,7 +464,7 @@ fn copy_sanitizers(\n         builder.copy(&runtime.path, &dst);\n \n         if target == \"x86_64-apple-darwin\" || target == \"aarch64-apple-darwin\" {\n-            // Update the library\u2019s install name to reflect that it has has been renamed.\n+            // Update the library\u2019s install name to reflect that it has been renamed.\n             apple_darwin_update_library_name(&dst, &format!(\"@rpath/{}\", &runtime.name));\n             // Upon renaming the install name, the code signature of the file will invalidate,\n             // so we will sign it again."}, {"sha": "5f674ed7441badc1eba2d6b8c8e4e7ea8bac8f9c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -1514,7 +1514,7 @@ pub(crate) fn clean_ty<'tcx>(ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> T\n                     // as we currently do not supply the parent generics to anonymous constants\n                     // but do allow `ConstKind::Param`.\n                     //\n-                    // `const_eval_poly` tries to to first substitute generic parameters which\n+                    // `const_eval_poly` tries to first substitute generic parameters which\n                     // results in an ICE while manually constructing the constant and using `eval`\n                     // does nothing for `ConstKind::Param`.\n                     let ct = ty::Const::from_anon_const(cx.tcx, def_id);"}, {"sha": "7d00002d05beee59852a1a9dde8462b35cadc2e5", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -612,7 +612,7 @@ fn generate_macro_def_id_path(\n     };\n     if path.len() < 2 {\n         // The minimum we can have is the crate name followed by the macro name. If shorter, then\n-        // it means that that `relative` was empty, which is an error.\n+        // it means that `relative` was empty, which is an error.\n         debug!(\"macro path cannot be empty!\");\n         return Err(HrefError::NotInExternalCache);\n     }"}, {"sha": "5df3669056d0ff674d88e275fcc18fbdf986be8b", "filename": "src/test/codegen/vec-in-place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/src%2Ftest%2Fcodegen%2Fvec-in-place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/src%2Ftest%2Fcodegen%2Fvec-in-place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fvec-in-place.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -17,7 +17,7 @@ pub struct Foo {\n \n // Going from an aggregate struct to another type currently requires Copy to\n // enable the TrustedRandomAccess specialization. Without it optimizations do not yet\n-// reliably recognize the loops as noop for for repr(C) or non-Copy structs.\n+// reliably recognize the loops as noop for repr(C) or non-Copy structs.\n #[derive(Copy, Clone)]\n pub struct Bar {\n     a: u64,"}, {"sha": "1a75310c94ff58c51f2e1f9e2fe2c9e437aff29a", "filename": "src/test/ui/let-else/let-else-then-diverge.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/src%2Ftest%2Fui%2Flet-else%2Flet-else-then-diverge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/src%2Ftest%2Fui%2Flet-else%2Flet-else-then-diverge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-then-diverge.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -1,8 +1,6 @@\n-//\n-// popped up in in #94012, where an alternative desugaring was\n+// popped up in #94012, where an alternative desugaring was\n // causing unreachable code errors\n \n-\n #![deny(unused_variables)]\n #![deny(unreachable_code)]\n "}, {"sha": "470a11d4769bc42dd401436a6b5fcfac0a78962f", "filename": "src/test/ui/let-else/let-else-then-diverge.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/src%2Ftest%2Fui%2Flet-else%2Flet-else-then-diverge.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/src%2Ftest%2Fui%2Flet-else%2Flet-else-then-diverge.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-then-diverge.stderr?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -1,11 +1,11 @@\n error: unused variable: `x`\n-  --> $DIR/let-else-then-diverge.rs:11:13\n+  --> $DIR/let-else-then-diverge.rs:9:13\n    |\n LL |         let x = 5;\n    |             ^ help: if this is intentional, prefix it with an underscore: `_x`\n    |\n note: the lint level is defined here\n-  --> $DIR/let-else-then-diverge.rs:6:9\n+  --> $DIR/let-else-then-diverge.rs:4:9\n    |\n LL | #![deny(unused_variables)]\n    |         ^^^^^^^^^^^^^^^^"}, {"sha": "cb634671bd4fa6c4661c62f3f1ab4de8fce2e3bb", "filename": "src/test/ui/proc-macro/call-deprecated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77064b7f0a28a74a997046f66306e13d6d37b10e/src%2Ftest%2Fui%2Fproc-macro%2Fcall-deprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77064b7f0a28a74a997046f66306e13d6d37b10e/src%2Ftest%2Fui%2Fproc-macro%2Fcall-deprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fcall-deprecated.rs?ref=77064b7f0a28a74a997046f66306e13d6d37b10e", "patch": "@@ -5,7 +5,7 @@ extern crate call_deprecated;\n \n // These first two `#[allow(deprecated)]` attributes\n // do nothing, since the AST nodes for `First` and `Second`\n-// haven't been been assigned a `NodeId`.\n+// haven't been assigned a `NodeId`.\n // See #63221 for a discussion about how we should\n // handle the interaction of 'inert' attributes and\n // proc-macro attributes."}]}