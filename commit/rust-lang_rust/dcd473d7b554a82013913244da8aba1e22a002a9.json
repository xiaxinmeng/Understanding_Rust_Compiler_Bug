{"sha": "dcd473d7b554a82013913244da8aba1e22a002a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjZDQ3M2Q3YjU1NGE4MjAxMzkxMzI0NGRhOGFiYTFlMjJhMDAyYTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-24T21:46:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-24T21:46:26Z"}, "message": "Auto merge of #64751 - Centril:rollup-hpbmcfj, r=Centril\n\nRollup of 16 pull requests\n\nSuccessful merges:\n\n - #63356 (Issue#63183: Add fs::read_dir() and ReadDir warning about iterator order + example)\n - #63934 (Fix coherence checking for impl trait in type aliases)\n - #64016 (Streamline `Compiler`)\n - #64296 (Document the unstable iter_order_by library feature)\n - #64443 (rustdoc: general cleanup)\n - #64622 (Add a cycle detector for generic `Graph`s and `mir::Body`s)\n - #64689 (Refactor macro by example)\n - #64698 (Recover on `const X = 42;` and infer type + Error Stash API)\n - #64702 (Remove unused dependencies)\n - #64717 (update mem::discriminant test to use assert_eq and assert_ne over comparison operators)\n - #64720 ( remove rtp.rs, and move rtpSpawn and RTP_ID_ERROR to libc)\n - #64721 (Fixed issue from #64447)\n - #64725 (fix one typo)\n - #64737 (fix several issues in String docs)\n - #64742 (relnotes: make compatibility section more sterile and fix rustc version)\n - #64748 (Fix #64744. Account for the Zero sub-pattern case.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "e3d95102edba19987d74cf0c961be6c86d5d8cab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3d95102edba19987d74cf0c961be6c86d5d8cab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcd473d7b554a82013913244da8aba1e22a002a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcd473d7b554a82013913244da8aba1e22a002a9", "html_url": "https://github.com/rust-lang/rust/commit/dcd473d7b554a82013913244da8aba1e22a002a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcd473d7b554a82013913244da8aba1e22a002a9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ef275e6c3cb1384ec78128eceeb4963ff788dca", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ef275e6c3cb1384ec78128eceeb4963ff788dca", "html_url": "https://github.com/rust-lang/rust/commit/6ef275e6c3cb1384ec78128eceeb4963ff788dca"}, {"sha": "aeb24142be8f39975c72a63f57c70d0adc6cc7a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/aeb24142be8f39975c72a63f57c70d0adc6cc7a6", "html_url": "https://github.com/rust-lang/rust/commit/aeb24142be8f39975c72a63f57c70d0adc6cc7a6"}], "stats": {"total": 5048, "additions": 2725, "deletions": 2323}, "files": [{"sha": "d03e1cd7432634d9ba598d1c01455771ea38ea49", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -3324,8 +3324,6 @@ dependencies = [\n  \"log\",\n  \"rustc\",\n  \"rustc_data_structures\",\n- \"rustc_errors\",\n- \"syntax\",\n  \"syntax_pos\",\n ]\n \n@@ -3347,7 +3345,6 @@ dependencies = [\n  \"log\",\n  \"memmap\",\n  \"num_cpus\",\n- \"parking_lot 0.9.0\",\n  \"rustc\",\n  \"rustc_apfloat\",\n  \"rustc_codegen_utils\",\n@@ -3366,7 +3363,6 @@ dependencies = [\n name = \"rustc_codegen_utils\"\n version = \"0.0.0\"\n dependencies = [\n- \"flate2\",\n  \"log\",\n  \"punycode\",\n  \"rustc\",\n@@ -3561,7 +3557,6 @@ name = \"rustc_mir\"\n version = \"0.0.0\"\n dependencies = [\n  \"arena\",\n- \"byteorder\",\n  \"either\",\n  \"graphviz\",\n  \"log\",\n@@ -3614,7 +3609,6 @@ name = \"rustc_plugin_impl\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc\",\n- \"rustc_errors\",\n  \"rustc_metadata\",\n  \"syntax\",\n  \"syntax_pos\",\n@@ -3638,7 +3632,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"arena\",\n  \"bitflags\",\n- \"indexmap\",\n  \"log\",\n  \"rustc\",\n  \"rustc_data_structures\",\n@@ -3660,7 +3653,6 @@ dependencies = [\n  \"rustc_codegen_utils\",\n  \"rustc_data_structures\",\n  \"rustc_target\",\n- \"rustc_typeck\",\n  \"serde_json\",\n  \"syntax\",\n  \"syntax_pos\",\n@@ -3691,9 +3683,7 @@ checksum = \"b725dadae9fabc488df69a287f5a99c5eaf5d10853842a8a3dfac52476f544ee\"\n name = \"rustc_traits\"\n version = \"0.0.0\"\n dependencies = [\n- \"bitflags\",\n  \"chalk-engine\",\n- \"graphviz\",\n  \"log\",\n  \"rustc\",\n  \"rustc_data_structures\",\n@@ -4056,7 +4046,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"alloc\",\n  \"backtrace\",\n- \"cc\",\n  \"cfg-if\",\n  \"compiler_builtins\",\n  \"core\",\n@@ -4241,7 +4230,6 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_lexer\",\n- \"rustc_macros\",\n  \"rustc_target\",\n  \"scoped-tls\",\n  \"serialize\",\n@@ -4257,7 +4245,6 @@ dependencies = [\n  \"log\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n- \"rustc_lexer\",\n  \"rustc_target\",\n  \"smallvec\",\n  \"syntax\","}, {"sha": "766cf64410c7728db06a21ef2f4ef80752d0a5e8", "filename": "RELEASES.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -70,10 +70,10 @@ Misc\n \n Compatibility Notes\n -------------------\n-- Unfortunately the [`x86_64-unknown-uefi` platform can not be built][62785]\n-  with rustc 1.39.0.\n-- The [`armv7-unknown-linux-gnueabihf` platform is also known to have\n-  issues][62896] for certain crates such as libc.\n+- The [`x86_64-unknown-uefi` platform can not be built][62785] with rustc\n+  1.38.0.\n+- The [`armv7-unknown-linux-gnueabihf` platform is known to have\n+  issues][62896] with certain crates such as libc.\n \n [60260]: https://github.com/rust-lang/rust/pull/60260/\n [61457]: https://github.com/rust-lang/rust/pull/61457/"}, {"sha": "e5f96ada6d5eee800aa40de213230d802e0663e5", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -429,7 +429,7 @@ impl String {\n \n     /// Converts a vector of bytes to a `String`.\n     ///\n-    /// A string slice ([`&str`]) is made of bytes ([`u8`]), and a vector of bytes\n+    /// A string ([`String`]) is made of bytes ([`u8`]), and a vector of bytes\n     /// ([`Vec<u8>`]) is made of bytes, so this function converts between the\n     /// two. Not all byte slices are valid `String`s, however: `String`\n     /// requires that it is valid UTF-8. `from_utf8()` checks to ensure that\n@@ -446,7 +446,7 @@ impl String {\n     /// If you need a [`&str`] instead of a `String`, consider\n     /// [`str::from_utf8`].\n     ///\n-    /// The inverse of this method is [`as_bytes`].\n+    /// The inverse of this method is [`into_bytes`].\n     ///\n     /// # Errors\n     ///\n@@ -480,11 +480,11 @@ impl String {\n     /// with this error.\n     ///\n     /// [`from_utf8_unchecked`]: struct.String.html#method.from_utf8_unchecked\n-    /// [`&str`]: ../../std/primitive.str.html\n+    /// [`String`]: struct.String.html\n     /// [`u8`]: ../../std/primitive.u8.html\n     /// [`Vec<u8>`]: ../../std/vec/struct.Vec.html\n     /// [`str::from_utf8`]: ../../std/str/fn.from_utf8.html\n-    /// [`as_bytes`]: struct.String.html#method.as_bytes\n+    /// [`into_bytes`]: struct.String.html#method.into_bytes\n     /// [`FromUtf8Error`]: struct.FromUtf8Error.html\n     /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n     #[inline]"}, {"sha": "0a9e076ec58690d43bb17315898ea9cdd30e129b", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -2581,7 +2581,7 @@ pub trait Iterator {\n     /// assert_eq!(xs.iter().cmp_by(&ys, |&x, &y| (x * x).cmp(&y)), Ordering::Equal);\n     /// assert_eq!(xs.iter().cmp_by(&ys, |&x, &y| (2 * x).cmp(&y)), Ordering::Greater);\n     /// ```\n-    #[unstable(feature = \"iter_order_by\", issue = \"0\")]\n+    #[unstable(feature = \"iter_order_by\", issue = \"64295\")]\n     fn cmp_by<I, F>(mut self, other: I, mut cmp: F) -> Ordering\n     where\n         Self: Sized,\n@@ -2664,7 +2664,7 @@ pub trait Iterator {\n     ///     Some(Ordering::Greater)\n     /// );\n     /// ```\n-    #[unstable(feature = \"iter_order_by\", issue = \"0\")]\n+    #[unstable(feature = \"iter_order_by\", issue = \"64295\")]\n     fn partial_cmp_by<I, F>(mut self, other: I, mut partial_cmp: F) -> Option<Ordering>\n     where\n         Self: Sized,\n@@ -2729,7 +2729,7 @@ pub trait Iterator {\n     ///\n     /// assert!(xs.iter().eq_by(&ys, |&x, &y| x * x == y));\n     /// ```\n-    #[unstable(feature = \"iter_order_by\", issue = \"0\")]\n+    #[unstable(feature = \"iter_order_by\", issue = \"64295\")]\n     fn eq_by<I, F>(mut self, other: I, mut eq: F) -> bool\n     where\n         Self: Sized,"}, {"sha": "8767625d4ed373e0783fe492dc51c1beef5449a0", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -818,9 +818,9 @@ impl<T> fmt::Debug for Discriminant<T> {\n ///\n /// enum Foo { A(&'static str), B(i32), C(i32) }\n ///\n-/// assert!(mem::discriminant(&Foo::A(\"bar\")) == mem::discriminant(&Foo::A(\"baz\")));\n-/// assert!(mem::discriminant(&Foo::B(1))     == mem::discriminant(&Foo::B(2)));\n-/// assert!(mem::discriminant(&Foo::B(3))     != mem::discriminant(&Foo::C(3)));\n+/// assert_eq!(mem::discriminant(&Foo::A(\"bar\")), mem::discriminant(&Foo::A(\"baz\")));\n+/// assert_eq!(mem::discriminant(&Foo::B(1)), mem::discriminant(&Foo::B(2)));\n+/// assert_ne!(mem::discriminant(&Foo::B(3)), mem::discriminant(&Foo::C(3)));\n /// ```\n #[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n pub fn discriminant<T>(v: &T) -> Discriminant<T> {"}, {"sha": "967d16fa0d902c74a13c1b8682f2e967bc5c9831", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -262,6 +262,12 @@ impl<'tcx> Body<'tcx> {\n         dominators(self)\n     }\n \n+    /// Returns `true` if a cycle exists in the control-flow graph that is reachable from the\n+    /// `START_BLOCK`.\n+    pub fn is_cfg_cyclic(&self) -> bool {\n+        graph::is_cyclic(self)\n+    }\n+\n     #[inline]\n     pub fn local_kind(&self, local: Local) -> LocalKind {\n         let index = local.as_usize();"}, {"sha": "49342d95fdb0359727a9d557a26341cf53762f39", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -321,6 +321,7 @@ impl Session {\n     }\n     pub fn compile_status(&self) -> Result<(), ErrorReported> {\n         if self.has_errors() {\n+            self.diagnostic().emit_stashed_diagnostics();\n             Err(ErrorReported)\n         } else {\n             Ok(())"}, {"sha": "ee318b127ae661158edf977172aab4a491f65880", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -432,7 +432,7 @@ fn orphan_check_trait_ref<'tcx>(\n }\n \n fn uncovered_tys<'tcx>(tcx: TyCtxt<'_>, ty: Ty<'tcx>, in_crate: InCrate) -> Vec<Ty<'tcx>> {\n-    if ty_is_local_constructor(ty, in_crate) {\n+    if ty_is_local_constructor(tcx, ty, in_crate) {\n         vec![]\n     } else if fundamental_ty(ty) {\n         ty.walk_shallow()\n@@ -451,7 +451,7 @@ fn is_possibly_remote_type(ty: Ty<'_>, _in_crate: InCrate) -> bool {\n }\n \n fn ty_is_local(tcx: TyCtxt<'_>, ty: Ty<'_>, in_crate: InCrate) -> bool {\n-    ty_is_local_constructor(ty, in_crate) ||\n+    ty_is_local_constructor(tcx, ty, in_crate) ||\n         fundamental_ty(ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, in_crate))\n }\n \n@@ -472,7 +472,7 @@ fn def_id_is_local(def_id: DefId, in_crate: InCrate) -> bool {\n     }\n }\n \n-fn ty_is_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> bool {\n+fn ty_is_local_constructor(tcx: TyCtxt<'_>, ty: Ty<'_>, in_crate: InCrate) -> bool {\n     debug!(\"ty_is_local_constructor({:?})\", ty);\n \n     match ty.sty {\n@@ -504,6 +504,15 @@ fn ty_is_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> bool {\n \n         ty::Adt(def, _) => def_id_is_local(def.did, in_crate),\n         ty::Foreign(did) => def_id_is_local(did, in_crate),\n+        ty::Opaque(did, _) => {\n+            // Check the underlying type that this opaque\n+            // type resolves to.\n+            // This recursion will eventually terminate,\n+            // since we've already managed to successfully\n+            // resolve all opaque types by this point\n+            let real_ty = tcx.type_of(did);\n+            ty_is_local_constructor(tcx, real_ty, in_crate)\n+        }\n \n         ty::Dynamic(ref tt, ..) => {\n             if let Some(principal) = tt.principal() {\n@@ -518,8 +527,7 @@ fn ty_is_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> bool {\n         ty::UnnormalizedProjection(..) |\n         ty::Closure(..) |\n         ty::Generator(..) |\n-        ty::GeneratorWitness(..) |\n-        ty::Opaque(..) => {\n+        ty::GeneratorWitness(..) => {\n             bug!(\"ty_is_local invoked on unexpected type: {:?}\", ty)\n         }\n     }"}, {"sha": "c9a40db41dfde03e9a53ee8328463c6003c37a95", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -395,7 +395,7 @@ impl<'tcx> Graph {\n     /// The parent of a given impl, which is the `DefId` of the trait when the\n     /// impl is a \"specialization root\".\n     pub fn parent(&self, child: DefId) -> DefId {\n-        *self.parent.get(&child).unwrap()\n+        *self.parent.get(&child).unwrap_or_else(|| panic!(\"Failed to get parent for {:?}\", child))\n     }\n }\n "}, {"sha": "40c4c1fc3fee692ae9d3d88a206a88335b0255a0", "filename": "src/librustc_ast_borrowck/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_ast_borrowck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_ast_borrowck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2FCargo.toml?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -12,11 +12,9 @@ doctest = false\n \n [dependencies]\n log = \"0.4\"\n-syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n # for \"clarity\", rename the graphviz crate to dot; graphviz within `borrowck`\n # refers to the borrowck-specific graphviz adapter traits.\n dot = { path = \"../libgraphviz\", package = \"graphviz\" }\n rustc = { path = \"../librustc\" }\n-errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "2e3666e6096573eda3bd08691807fdecf8f20c67", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -17,7 +17,6 @@ memmap = \"0.6\"\n log = \"0.4.5\"\n libc = \"0.2.44\"\n jobserver = \"0.1.11\"\n-parking_lot = \"0.9\"\n tempfile = \"3.1\"\n \n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }"}, {"sha": "c8c219d039a73af817c3f82ed13dbab9e2b70d8d", "filename": "src/librustc_codegen_utils/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_codegen_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_codegen_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2FCargo.toml?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -10,7 +10,6 @@ path = \"lib.rs\"\n test = false\n \n [dependencies]\n-flate2 = \"1.0\"\n log = \"0.4\"\n punycode = \"0.4.0\"\n rustc-demangle = \"0.1.16\""}, {"sha": "cbf6a0a3c03a0810d9c42a4ebe53210569ee99c1", "filename": "src/librustc_data_structures/graph/iterate/mod.rs", "status": "modified", "additions": 203, "deletions": 1, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -1,5 +1,5 @@\n use super::super::indexed_vec::IndexVec;\n-use super::{DirectedGraph, WithNumNodes, WithSuccessors};\n+use super::{DirectedGraph, WithNumNodes, WithSuccessors, WithStartNode};\n use crate::bit_set::BitSet;\n \n #[cfg(test)]\n@@ -85,3 +85,205 @@ where\n         Some(n)\n     }\n }\n+\n+/// Allows searches to terminate early with a value.\n+#[derive(Clone, Copy, Debug)]\n+pub enum ControlFlow<T> {\n+    Break(T),\n+    Continue,\n+}\n+\n+/// The status of a node in the depth-first search.\n+///\n+/// See the documentation of `TriColorDepthFirstSearch` to see how a node's status is updated\n+/// during DFS.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub enum NodeStatus {\n+    /// This node has been examined by the depth-first search but is not yet `Settled`.\n+    ///\n+    /// Also referred to as \"gray\" or \"discovered\" nodes in [CLR][].\n+    ///\n+    /// [CLR]: https://en.wikipedia.org/wiki/Introduction_to_Algorithms\n+    Visited,\n+\n+    /// This node and all nodes reachable from it have been examined by the depth-first search.\n+    ///\n+    /// Also referred to as \"black\" or \"finished\" nodes in [CLR][].\n+    ///\n+    /// [CLR]: https://en.wikipedia.org/wiki/Introduction_to_Algorithms\n+    Settled,\n+}\n+\n+struct Event<N> {\n+    node: N,\n+    becomes: NodeStatus,\n+}\n+\n+/// A depth-first search that also tracks when all successors of a node have been examined.\n+///\n+/// This is based on the DFS described in [Introduction to Algorithms (1st ed.)][CLR], hereby\n+/// referred to as **CLR**. However, we use the terminology in [`NodeStatus`][] above instead of\n+/// \"discovered\"/\"finished\" or \"white\"/\"grey\"/\"black\". Each node begins the search with no status,\n+/// becomes `Visited` when it is first examined by the DFS and is `Settled` when all nodes\n+/// reachable from it have been examined. This allows us to differentiate between \"tree\", \"back\"\n+/// and \"forward\" edges (see [`TriColorVisitor::node_examined`]).\n+///\n+/// Unlike the pseudocode in [CLR][], this implementation is iterative and does not use timestamps.\n+/// We accomplish this by storing `Event`s on the stack that result in a (possible) state change\n+/// for each node. A `Visited` event signifies that we should examine this node if it has not yet\n+/// been `Visited` or `Settled`. When a node is examined for the first time, we mark it as\n+/// `Visited` and push a `Settled` event for it on stack followed by `Visited` events for all of\n+/// its predecessors, scheduling them for examination. Multiple `Visited` events for a single node\n+/// may exist on the stack simultaneously if a node has multiple predecessors, but only one\n+/// `Settled` event will ever be created for each node. After all `Visited` events for a node's\n+/// successors have been popped off the stack (as well as any new events triggered by visiting\n+/// those successors), we will pop off that node's `Settled` event.\n+///\n+/// [CLR]: https://en.wikipedia.org/wiki/Introduction_to_Algorithms\n+/// [`NodeStatus`]: ./enum.NodeStatus.html\n+/// [`TriColorVisitor::node_examined`]: ./trait.TriColorVisitor.html#method.node_examined\n+pub struct TriColorDepthFirstSearch<'graph, G>\n+where\n+    G: ?Sized + DirectedGraph + WithNumNodes + WithSuccessors,\n+{\n+    graph: &'graph G,\n+    stack: Vec<Event<G::Node>>,\n+    visited: BitSet<G::Node>,\n+    settled: BitSet<G::Node>,\n+}\n+\n+impl<G> TriColorDepthFirstSearch<'graph, G>\n+where\n+    G: ?Sized + DirectedGraph + WithNumNodes + WithSuccessors,\n+{\n+    pub fn new(graph: &'graph G) -> Self {\n+        TriColorDepthFirstSearch {\n+            graph,\n+            stack: vec![],\n+            visited: BitSet::new_empty(graph.num_nodes()),\n+            settled: BitSet::new_empty(graph.num_nodes()),\n+        }\n+    }\n+\n+    /// Performs a depth-first search, starting from the given `root`.\n+    ///\n+    /// This won't visit nodes that are not reachable from `root`.\n+    pub fn run_from<V>(mut self, root: G::Node, visitor: &mut V) -> Option<V::BreakVal>\n+    where\n+        V: TriColorVisitor<G>,\n+    {\n+        use NodeStatus::{Visited, Settled};\n+\n+        self.stack.push(Event { node: root, becomes: Visited });\n+\n+        loop {\n+            match self.stack.pop()? {\n+                Event { node, becomes: Settled } => {\n+                    let not_previously_settled = self.settled.insert(node);\n+                    assert!(not_previously_settled, \"A node should be settled exactly once\");\n+                    if let ControlFlow::Break(val) = visitor.node_settled(node) {\n+                        return Some(val);\n+                    }\n+                }\n+\n+                Event { node, becomes: Visited } => {\n+                    let not_previously_visited = self.visited.insert(node);\n+                    let prior_status = if not_previously_visited {\n+                        None\n+                    } else if self.settled.contains(node) {\n+                        Some(Settled)\n+                    } else {\n+                        Some(Visited)\n+                    };\n+\n+                    if let ControlFlow::Break(val) = visitor.node_examined(node, prior_status) {\n+                        return Some(val);\n+                    }\n+\n+                    // If this node has already been examined, we are done.\n+                    if prior_status.is_some() {\n+                        continue;\n+                    }\n+\n+                    // Otherwise, push a `Settled` event for this node onto the stack, then\n+                    // schedule its successors for examination.\n+                    self.stack.push(Event { node, becomes: Settled });\n+                    for succ in self.graph.successors(node) {\n+                        self.stack.push(Event { node: succ, becomes: Visited });\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<G> TriColorDepthFirstSearch<'graph, G>\n+where\n+    G: ?Sized + DirectedGraph + WithNumNodes + WithSuccessors + WithStartNode,\n+{\n+    /// Performs a depth-first search, starting from `G::start_node()`.\n+    ///\n+    /// This won't visit nodes that are not reachable from the start node.\n+    pub fn run_from_start<V>(self, visitor: &mut V) -> Option<V::BreakVal>\n+    where\n+        V: TriColorVisitor<G>,\n+    {\n+        let root = self.graph.start_node();\n+        self.run_from(root, visitor)\n+    }\n+}\n+\n+/// What to do when a node is examined or becomes `Settled` during DFS.\n+pub trait TriColorVisitor<G>\n+where\n+    G: ?Sized + DirectedGraph,\n+{\n+    /// The value returned by this search.\n+    type BreakVal;\n+\n+    /// Called when a node is examined by the depth-first search.\n+    ///\n+    /// By checking the value of `prior_status`, this visitor can determine whether the edge\n+    /// leading to this node was a tree edge (`None`), forward edge (`Some(Settled)`) or back edge\n+    /// (`Some(Visited)`). For a full explanation of each edge type, see the \"Depth-first Search\"\n+    /// chapter in [CLR][] or [wikipedia][].\n+    ///\n+    /// If you want to know *both* nodes linked by each edge, you'll need to modify\n+    /// `TriColorDepthFirstSearch` to store a `source` node for each `Visited` event.\n+    ///\n+    /// [wikipedia]: https://en.wikipedia.org/wiki/Depth-first_search#Output_of_a_depth-first_search\n+    /// [CLR]: https://en.wikipedia.org/wiki/Introduction_to_Algorithms\n+    fn node_examined(\n+        &mut self,\n+        _target: G::Node,\n+        _prior_status: Option<NodeStatus>,\n+    ) -> ControlFlow<Self::BreakVal> {\n+        ControlFlow::Continue\n+    }\n+\n+    /// Called after all nodes reachable from this one have been examined.\n+    fn node_settled(&mut self, _target: G::Node) -> ControlFlow<Self::BreakVal> {\n+        ControlFlow::Continue\n+    }\n+}\n+\n+/// This `TriColorVisitor` looks for back edges in a graph, which indicate that a cycle exists.\n+pub struct CycleDetector;\n+\n+impl<G> TriColorVisitor<G> for CycleDetector\n+where\n+    G: ?Sized + DirectedGraph,\n+{\n+    type BreakVal = ();\n+\n+    fn node_examined(\n+        &mut self,\n+        _node: G::Node,\n+        prior_status: Option<NodeStatus>,\n+    ) -> ControlFlow<Self::BreakVal> {\n+        match prior_status {\n+            Some(NodeStatus::Visited) => ControlFlow::Break(()),\n+            _ => ControlFlow::Continue,\n+        }\n+    }\n+}"}, {"sha": "0e038e88b221dfed3f8d3b6aabbdb0b272d9ab96", "filename": "src/librustc_data_structures/graph/iterate/tests.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Ftests.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -9,3 +9,14 @@ fn diamond_post_order() {\n     let result = post_order_from(&graph, 0);\n     assert_eq!(result, vec![3, 1, 2, 0]);\n }\n+\n+#[test]\n+fn is_cyclic() {\n+    use super::super::is_cyclic;\n+\n+    let diamond_acyclic = TestGraph::new(0, &[(0, 1), (0, 2), (1, 3), (2, 3)]);\n+    let diamond_cyclic = TestGraph::new(0, &[(0, 1), (1, 2), (2, 3), (3, 0)]);\n+\n+    assert!(!is_cyclic(&diamond_acyclic));\n+    assert!(is_cyclic(&diamond_cyclic));\n+}"}, {"sha": "0a607659f3e246233bc74988269806fee7a9e44e", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -81,3 +81,13 @@ where\n         + WithNumNodes,\n {\n }\n+\n+/// Returns `true` if the graph has a cycle that is reachable from the start node.\n+pub fn is_cyclic<G>(graph: &G) -> bool\n+where\n+    G: ?Sized + DirectedGraph + WithStartNode + WithSuccessors + WithNumNodes,\n+{\n+    iterate::TriColorDepthFirstSearch::new(graph)\n+        .run_from_start(&mut iterate::CycleDetector)\n+        .is_some()\n+}"}, {"sha": "4a8681367410e3cd76c66feb5244df6dd922d013", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -296,7 +296,6 @@ pub fn run_compiler(\n                     );\n                     Ok(())\n                 })?;\n-                return sess.compile_status();\n             } else {\n                 let mut krate = compiler.parse()?.take();\n                 pretty::visit_crate(sess, &mut krate, ppm);\n@@ -307,8 +306,8 @@ pub fn run_compiler(\n                     ppm,\n                     compiler.output_file().as_ref().map(|p| &**p),\n                 );\n-                return sess.compile_status();\n             }\n+            return sess.compile_status();\n         }\n \n         if callbacks.after_parsing(compiler) == Compilation::Stop {"}, {"sha": "cc60bf89c7ecac3dd3104d89577a7ab6c07d5234", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -1,10 +1,6 @@\n-use crate::Diagnostic;\n-use crate::DiagnosticId;\n-use crate::DiagnosticStyledString;\n-use crate::Applicability;\n+use crate::{Diagnostic, DiagnosticId, DiagnosticStyledString};\n+use crate::{Applicability, Level, Handler, StashKey};\n \n-use crate::Level;\n-use crate::Handler;\n use std::fmt::{self, Debug};\n use std::ops::{Deref, DerefMut};\n use std::thread::panicking;\n@@ -117,18 +113,30 @@ impl<'a> DiagnosticBuilder<'a> {\n         }\n     }\n \n-    /// Buffers the diagnostic for later emission, unless handler\n-    /// has disabled such buffering.\n-    pub fn buffer(mut self, buffered_diagnostics: &mut Vec<Diagnostic>) {\n+    /// Stashes diagnostic for possible later improvement in a different,\n+    /// later stage of the compiler. The diagnostic can be accessed with\n+    /// the provided `span` and `key` through `.steal_diagnostic` on `Handler`.\n+    ///\n+    /// As with `buffer`, this is unless the handler has disabled such buffering.\n+    pub fn stash(self, span: Span, key: StashKey) {\n+        if let Some((diag, handler)) = self.into_diagnostic() {\n+            handler.stash_diagnostic(span, key, diag);\n+        }\n+    }\n+\n+    /// Converts the builder to a `Diagnostic` for later emission,\n+    /// unless handler has disabled such buffering.\n+    pub fn into_diagnostic(mut self) -> Option<(Diagnostic, &'a Handler)> {\n         if self.0.handler.flags.dont_buffer_diagnostics ||\n             self.0.handler.flags.treat_err_as_bug.is_some()\n         {\n             self.emit();\n-            return;\n+            return None;\n         }\n \n-        // We need to use `ptr::read` because `DiagnosticBuilder`\n-        // implements `Drop`.\n+        let handler = self.0.handler;\n+\n+        // We need to use `ptr::read` because `DiagnosticBuilder` implements `Drop`.\n         let diagnostic;\n         unsafe {\n             diagnostic = std::ptr::read(&self.0.diagnostic);\n@@ -137,7 +145,14 @@ impl<'a> DiagnosticBuilder<'a> {\n         // Logging here is useful to help track down where in logs an error was\n         // actually emitted.\n         debug!(\"buffer: diagnostic={:?}\", diagnostic);\n-        buffered_diagnostics.push(diagnostic);\n+\n+        Some((diagnostic, handler))\n+    }\n+\n+    /// Buffers the diagnostic for later emission,\n+    /// unless handler has disabled such buffering.\n+    pub fn buffer(self, buffered_diagnostics: &mut Vec<Diagnostic>) {\n+        buffered_diagnostics.extend(self.into_diagnostic().map(|(diag, _)| diag));\n     }\n \n     /// Convenience function for internal use, clients should use one of the"}, {"sha": "2a89c94652a249205a0decb301a551c1d3f32e36", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -1043,14 +1043,13 @@ impl EmitterWriter {\n     }\n \n     fn get_max_line_num(&mut self, span: &MultiSpan, children: &[SubDiagnostic]) -> usize {\n-        let mut max = 0;\n \n         let primary = self.get_multispan_max_line_num(span);\n-        max = if primary > max { primary } else { max };\n+        let mut max = primary;\n \n         for sub in children {\n             let sub_result = self.get_multispan_max_line_num(&sub.span);\n-            max = if sub_result > max { primary } else { max };\n+            max = std::cmp::max(sub_result, max);\n         }\n         max\n     }"}, {"sha": "c01dcd94c725e449e7ee87de5444866e19d762a5", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 249, "deletions": 149, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -17,7 +17,7 @@ use emitter::{Emitter, EmitterWriter};\n use registry::Registry;\n \n use rustc_data_structures::sync::{self, Lrc, Lock};\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n use rustc_data_structures::stable_hasher::StableHasher;\n \n use std::borrow::Cow;\n@@ -302,6 +302,9 @@ pub struct Handler {\n     inner: Lock<HandlerInner>,\n }\n \n+/// This inner struct exists to keep it all behind a single lock;\n+/// this is done to prevent possible deadlocks in a multi-threaded compiler,\n+/// as well as inconsistent state observation.\n struct HandlerInner {\n     flags: HandlerFlags,\n     /// The number of errors that have been emitted, including duplicates.\n@@ -326,6 +329,18 @@ struct HandlerInner {\n     /// this handler. These hashes is used to avoid emitting the same error\n     /// twice.\n     emitted_diagnostics: FxHashSet<u128>,\n+\n+    /// Stashed diagnostics emitted in one stage of the compiler that may be\n+    /// stolen by other stages (e.g. to improve them and add more information).\n+    /// The stashed diagnostics count towards the total error count.\n+    /// When `.abort_if_errors()` is called, these are also emitted.\n+    stashed_diagnostics: FxIndexMap<(Span, StashKey), Diagnostic>,\n+}\n+\n+/// A key denoting where from a diagnostic was stashed.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+pub enum StashKey {\n+    ItemNoType,\n }\n \n fn default_track_diagnostic(_: &Diagnostic) {}\n@@ -354,7 +369,9 @@ pub struct HandlerFlags {\n \n impl Drop for HandlerInner {\n     fn drop(&mut self) {\n-        if self.err_count == 0 {\n+        self.emit_stashed_diagnostics();\n+\n+        if !self.has_errors() {\n             let bugs = std::mem::replace(&mut self.delayed_span_bugs, Vec::new());\n             let has_bugs = !bugs.is_empty();\n             for bug in bugs {\n@@ -368,57 +385,71 @@ impl Drop for HandlerInner {\n }\n \n impl Handler {\n-    pub fn with_tty_emitter(color_config: ColorConfig,\n-                            can_emit_warnings: bool,\n-                            treat_err_as_bug: Option<usize>,\n-                            cm: Option<Lrc<SourceMapperDyn>>)\n-                            -> Handler {\n-        Handler::with_tty_emitter_and_flags(\n+    pub fn with_tty_emitter(\n+        color_config: ColorConfig,\n+        can_emit_warnings: bool,\n+        treat_err_as_bug: Option<usize>,\n+        cm: Option<Lrc<SourceMapperDyn>>,\n+    ) -> Self {\n+        Self::with_tty_emitter_and_flags(\n             color_config,\n             cm,\n             HandlerFlags {\n                 can_emit_warnings,\n                 treat_err_as_bug,\n                 .. Default::default()\n-            })\n+            },\n+        )\n     }\n \n-    pub fn with_tty_emitter_and_flags(color_config: ColorConfig,\n-                                      cm: Option<Lrc<SourceMapperDyn>>,\n-                                      flags: HandlerFlags)\n-                                      -> Handler {\n+    pub fn with_tty_emitter_and_flags(\n+        color_config: ColorConfig,\n+        cm: Option<Lrc<SourceMapperDyn>>,\n+        flags: HandlerFlags,\n+    ) -> Self {\n         let emitter = Box::new(EmitterWriter::stderr(\n-            color_config, cm, false, false, None, flags.external_macro_backtrace));\n-        Handler::with_emitter_and_flags(emitter, flags)\n-    }\n-\n-    pub fn with_emitter(can_emit_warnings: bool,\n-                        treat_err_as_bug: Option<usize>,\n-                        e: Box<dyn Emitter + sync::Send>)\n-                        -> Handler {\n+            color_config,\n+            cm,\n+            false,\n+            false,\n+            None,\n+            flags.external_macro_backtrace,\n+        ));\n+        Self::with_emitter_and_flags(emitter, flags)\n+    }\n+\n+    pub fn with_emitter(\n+        can_emit_warnings: bool,\n+        treat_err_as_bug: Option<usize>,\n+        emitter: Box<dyn Emitter + sync::Send>,\n+    ) -> Self {\n         Handler::with_emitter_and_flags(\n-            e,\n+            emitter,\n             HandlerFlags {\n                 can_emit_warnings,\n                 treat_err_as_bug,\n                 .. Default::default()\n-            })\n+            },\n+        )\n     }\n \n-    pub fn with_emitter_and_flags(e: Box<dyn Emitter + sync::Send>, flags: HandlerFlags) -> Handler\n-    {\n-        Handler {\n+    pub fn with_emitter_and_flags(\n+        emitter: Box<dyn Emitter + sync::Send>,\n+        flags: HandlerFlags\n+    ) -> Self {\n+        Self {\n             flags,\n             inner: Lock::new(HandlerInner {\n                 flags,\n                 err_count: 0,\n                 deduplicated_err_count: 0,\n-                emitter: e,\n+                emitter,\n                 continue_after_error: true,\n                 delayed_span_bugs: Vec::new(),\n                 taught_diagnostics: Default::default(),\n                 emitted_diagnostic_codes: Default::default(),\n                 emitted_diagnostics: Default::default(),\n+                stashed_diagnostics: Default::default(),\n             }),\n         }\n     }\n@@ -445,197 +476,239 @@ impl Handler {\n         inner.emitted_diagnostics = Default::default();\n         inner.deduplicated_err_count = 0;\n         inner.err_count = 0;\n+        inner.stashed_diagnostics.clear();\n+    }\n+\n+    /// Stash a given diagnostic with the given `Span` and `StashKey` as the key for later stealing.\n+    /// If the diagnostic with this `(span, key)` already exists, this will result in an ICE.\n+    pub fn stash_diagnostic(&self, span: Span, key: StashKey, diag: Diagnostic) {\n+        let mut inner = self.inner.borrow_mut();\n+        if let Some(mut old_diag) = inner.stashed_diagnostics.insert((span, key), diag) {\n+            // We are removing a previously stashed diagnostic which should not happen.\n+            old_diag.level = Bug;\n+            old_diag.note(&format!(\n+                \"{}:{}: already existing stashed diagnostic with (span = {:?}, key = {:?})\",\n+                file!(), line!(), span, key\n+            ));\n+            inner.emit_diag_at_span(old_diag, span);\n+            panic!(ExplicitBug);\n+        }\n+    }\n+\n+    /// Steal a previously stashed diagnostic with the given `Span` and `StashKey` as the key.\n+    pub fn steal_diagnostic(&self, span: Span, key: StashKey) -> Option<DiagnosticBuilder<'_>> {\n+        self.inner\n+            .borrow_mut()\n+            .stashed_diagnostics\n+            .remove(&(span, key))\n+            .map(|diag| DiagnosticBuilder::new_diagnostic(self, diag))\n+    }\n+\n+    /// Emit all stashed diagnostics.\n+    pub fn emit_stashed_diagnostics(&self) {\n+        self.inner.borrow_mut().emit_stashed_diagnostics();\n     }\n \n+    /// Construct a dummy builder with `Level::Cancelled`.\n+    ///\n+    /// Using this will neither report anything to the user (e.g. a warning),\n+    /// nor will compilation cancel as a result.\n     pub fn struct_dummy(&self) -> DiagnosticBuilder<'_> {\n         DiagnosticBuilder::new(self, Level::Cancelled, \"\")\n     }\n \n-    pub fn struct_span_warn<S: Into<MultiSpan>>(&self,\n-                                                sp: S,\n-                                                msg: &str)\n-                                                -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Warning, msg);\n-        result.set_span(sp);\n-        if !self.flags.can_emit_warnings {\n-            result.cancel();\n-        }\n+    /// Construct a builder at the `Warning` level at the given `span` and with the `msg`.\n+    pub fn struct_span_warn(&self, span: impl Into<MultiSpan>, msg: &str) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_warn(msg);\n+        result.set_span(span);\n         result\n     }\n-    pub fn struct_span_warn_with_code<S: Into<MultiSpan>>(&self,\n-                                                          sp: S,\n-                                                          msg: &str,\n-                                                          code: DiagnosticId)\n-                                                          -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Warning, msg);\n-        result.set_span(sp);\n+\n+    /// Construct a builder at the `Warning` level at the given `span` and with the `msg`.\n+    /// Also include a code.\n+    pub fn struct_span_warn_with_code(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: &str,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_span_warn(span, msg);\n         result.code(code);\n-        if !self.flags.can_emit_warnings {\n-            result.cancel();\n-        }\n         result\n     }\n+\n+    /// Construct a builder at the `Warning` level with the `msg`.\n     pub fn struct_warn(&self, msg: &str) -> DiagnosticBuilder<'_> {\n         let mut result = DiagnosticBuilder::new(self, Level::Warning, msg);\n         if !self.flags.can_emit_warnings {\n             result.cancel();\n         }\n         result\n     }\n-    pub fn struct_span_err<S: Into<MultiSpan>>(&self,\n-                                               sp: S,\n-                                               msg: &str)\n-                                               -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n-        result.set_span(sp);\n+\n+    /// Construct a builder at the `Error` level at the given `span` and with the `msg`.\n+    pub fn struct_span_err(&self, span: impl Into<MultiSpan>, msg: &str) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_err(msg);\n+        result.set_span(span);\n         result\n     }\n-    pub fn struct_span_err_with_code<S: Into<MultiSpan>>(&self,\n-                                                         sp: S,\n-                                                         msg: &str,\n-                                                         code: DiagnosticId)\n-                                                         -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n-        result.set_span(sp);\n+\n+    /// Construct a builder at the `Error` level at the given `span`, with the `msg`, and `code`.\n+    pub fn struct_span_err_with_code(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: &str,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_span_err(span, msg);\n         result.code(code);\n         result\n     }\n+\n+    /// Construct a builder at the `Error` level with the `msg`.\n     // FIXME: This method should be removed (every error should have an associated error code).\n     pub fn struct_err(&self, msg: &str) -> DiagnosticBuilder<'_> {\n         DiagnosticBuilder::new(self, Level::Error, msg)\n     }\n-    pub fn struct_err_with_code(\n-        &self,\n-        msg: &str,\n-        code: DiagnosticId,\n-    ) -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n+\n+    /// Construct a builder at the `Error` level with the `msg` and the `code`.\n+    pub fn struct_err_with_code(&self, msg: &str, code: DiagnosticId) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_err(msg);\n         result.code(code);\n         result\n     }\n-    pub fn struct_span_fatal<S: Into<MultiSpan>>(&self,\n-                                                 sp: S,\n-                                                 msg: &str)\n-                                                 -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Fatal, msg);\n-        result.set_span(sp);\n+\n+    /// Construct a builder at the `Fatal` level at the given `span` and with the `msg`.\n+    pub fn struct_span_fatal(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: &str,\n+    ) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_fatal(msg);\n+        result.set_span(span);\n         result\n     }\n-    pub fn struct_span_fatal_with_code<S: Into<MultiSpan>>(&self,\n-                                                           sp: S,\n-                                                           msg: &str,\n-                                                           code: DiagnosticId)\n-                                                           -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Fatal, msg);\n-        result.set_span(sp);\n+\n+    /// Construct a builder at the `Fatal` level at the given `span`, with the `msg`, and `code`.\n+    pub fn struct_span_fatal_with_code(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: &str,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_span_fatal(span, msg);\n         result.code(code);\n         result\n     }\n+\n+    /// Construct a builder at the `Error` level with the `msg`.\n     pub fn struct_fatal(&self, msg: &str) -> DiagnosticBuilder<'_> {\n         DiagnosticBuilder::new(self, Level::Fatal, msg)\n     }\n \n-    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> FatalError {\n-        self.emit_diagnostic(Diagnostic::new(Fatal, msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+    pub fn span_fatal(&self, span: impl Into<MultiSpan>, msg: &str) -> FatalError {\n+        self.emit_diag_at_span(Diagnostic::new(Fatal, msg), span);\n         FatalError\n     }\n-    pub fn span_fatal_with_code<S: Into<MultiSpan>>(&self,\n-                                                    sp: S,\n-                                                    msg: &str,\n-                                                    code: DiagnosticId)\n-                                                    -> FatalError {\n-        self.emit_diagnostic(Diagnostic::new_with_code(Fatal, Some(code), msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+\n+    pub fn span_fatal_with_code(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: &str,\n+        code: DiagnosticId,\n+    ) -> FatalError {\n+        self.emit_diag_at_span(Diagnostic::new_with_code(Fatal, Some(code), msg), span);\n         FatalError\n     }\n-    pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit_diagnostic(Diagnostic::new(Error, msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n-    }\n-    pub fn mut_span_err<S: Into<MultiSpan>>(&self,\n-                                            sp: S,\n-                                            msg: &str)\n-                                            -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n-        result.set_span(sp);\n-        result\n+\n+    pub fn span_err(&self, span: impl Into<MultiSpan>, msg: &str) {\n+        self.emit_diag_at_span(Diagnostic::new(Error, msg), span);\n     }\n-    pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: DiagnosticId) {\n-        self.emit_diagnostic(Diagnostic::new_with_code(Error, Some(code), msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+\n+    pub fn span_err_with_code(&self, span: impl Into<MultiSpan>, msg: &str, code: DiagnosticId) {\n+        self.emit_diag_at_span(Diagnostic::new_with_code(Error, Some(code), msg), span);\n     }\n-    pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit_diagnostic(Diagnostic::new(Warning, msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+\n+    pub fn span_warn(&self, span: impl Into<MultiSpan>, msg: &str) {\n+        self.emit_diag_at_span(Diagnostic::new(Warning, msg), span);\n     }\n-    pub fn span_warn_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: DiagnosticId) {\n-        self.emit_diagnostic(Diagnostic::new_with_code(Warning, Some(code), msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+\n+    pub fn span_warn_with_code(&self, span: impl Into<MultiSpan>, msg: &str, code: DiagnosticId) {\n+        self.emit_diag_at_span(Diagnostic::new_with_code(Warning, Some(code), msg), span);\n     }\n-    pub fn span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n-        self.inner.borrow_mut().span_bug(sp, msg)\n+\n+    pub fn span_bug(&self, span: impl Into<MultiSpan>, msg: &str) -> ! {\n+        self.inner.borrow_mut().span_bug(span, msg)\n     }\n-    pub fn delay_span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.inner.borrow_mut().delay_span_bug(sp, msg)\n+\n+    pub fn delay_span_bug(&self, span: impl Into<MultiSpan>, msg: &str) {\n+        self.inner.borrow_mut().delay_span_bug(span, msg)\n     }\n-    pub fn span_bug_no_panic<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit_diagnostic(Diagnostic::new(Bug, msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+\n+    pub fn span_bug_no_panic(&self, span: impl Into<MultiSpan>, msg: &str) {\n+        self.emit_diag_at_span(Diagnostic::new(Bug, msg), span);\n     }\n-    pub fn span_note_without_error<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit_diagnostic(Diagnostic::new(Note, msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+\n+    pub fn span_note_without_error(&self, span: impl Into<MultiSpan>, msg: &str) {\n+        self.emit_diag_at_span(Diagnostic::new(Note, msg), span);\n     }\n-    pub fn span_note_diag(&self,\n-                          sp: Span,\n-                          msg: &str)\n-                          -> DiagnosticBuilder<'_> {\n+\n+    pub fn span_note_diag(&self, span: Span, msg: &str) -> DiagnosticBuilder<'_> {\n         let mut db = DiagnosticBuilder::new(self, Note, msg);\n-        db.set_span(sp);\n+        db.set_span(span);\n         db\n     }\n+\n     pub fn failure(&self, msg: &str) {\n         self.inner.borrow_mut().failure(msg);\n     }\n+\n     pub fn fatal(&self, msg: &str) -> FatalError {\n         self.inner.borrow_mut().fatal(msg)\n     }\n+\n     pub fn err(&self, msg: &str) {\n         self.inner.borrow_mut().err(msg);\n     }\n+\n     pub fn warn(&self, msg: &str) {\n         let mut db = DiagnosticBuilder::new(self, Warning, msg);\n         db.emit();\n     }\n+\n     pub fn note_without_error(&self, msg: &str) {\n-        let mut db = DiagnosticBuilder::new(self, Note, msg);\n-        db.emit();\n+        DiagnosticBuilder::new(self, Note, msg).emit();\n     }\n+\n     pub fn bug(&self, msg: &str) -> ! {\n         self.inner.borrow_mut().bug(msg)\n     }\n \n     pub fn err_count(&self) -> usize {\n-        self.inner.borrow().err_count\n+        self.inner.borrow().err_count()\n     }\n \n     pub fn has_errors(&self) -> bool {\n-        self.err_count() > 0\n+        self.inner.borrow().has_errors()\n     }\n \n     pub fn print_error_count(&self, registry: &Registry) {\n         self.inner.borrow_mut().print_error_count(registry)\n     }\n \n     pub fn abort_if_errors(&self) {\n-        self.inner.borrow().abort_if_errors()\n+        self.inner.borrow_mut().abort_if_errors()\n     }\n \n     pub fn abort_if_errors_and_should_abort(&self) {\n-        self.inner.borrow().abort_if_errors_and_should_abort()\n+        self.inner.borrow_mut().abort_if_errors_and_should_abort()\n     }\n \n+    /// `true` if we haven't taught a diagnostic with this code already.\n+    /// The caller must then teach the user about such a diagnostic.\n+    ///\n+    /// Used to suppress emitting the same error multiple times with extended explanation when\n+    /// calling `-Zteach`.\n     pub fn must_teach(&self, code: &DiagnosticId) -> bool {\n         self.inner.borrow_mut().must_teach(code)\n     }\n@@ -648,6 +721,12 @@ impl Handler {\n         self.inner.borrow_mut().emit_diagnostic(diagnostic)\n     }\n \n+    fn emit_diag_at_span(&self, mut diag: Diagnostic, sp: impl Into<MultiSpan>) {\n+        let mut inner = self.inner.borrow_mut();\n+        inner.emit_diagnostic(diag.set_span(sp));\n+        inner.abort_if_errors_and_should_abort();\n+    }\n+\n     pub fn emit_artifact_notification(&self, path: &Path, artifact_type: &str) {\n         self.inner.borrow_mut().emit_artifact_notification(path, artifact_type)\n     }\n@@ -658,11 +737,6 @@ impl Handler {\n }\n \n impl HandlerInner {\n-    /// `true` if we haven't taught a diagnostic with this code already.\n-    /// The caller must then teach the user about such a diagnostic.\n-    ///\n-    /// Used to suppress emitting the same error multiple times with extended explanation when\n-    /// calling `-Zteach`.\n     fn must_teach(&mut self, code: &DiagnosticId) -> bool {\n         self.taught_diagnostics.insert(code.clone())\n     }\n@@ -671,6 +745,12 @@ impl HandlerInner {\n         self.emitter.emit_diagnostic(&db);\n     }\n \n+    /// Emit all stashed diagnostics.\n+    fn emit_stashed_diagnostics(&mut self) {\n+        let diags = self.stashed_diagnostics.drain(..).map(|x| x.1).collect::<Vec<_>>();\n+        diags.iter().for_each(|diag| self.emit_diagnostic(diag));\n+    }\n+\n     fn emit_diagnostic(&mut self, diagnostic: &Diagnostic) {\n         if diagnostic.cancelled() {\n             return;\n@@ -713,10 +793,12 @@ impl HandlerInner {\n     }\n \n     fn treat_err_as_bug(&self) -> bool {\n-        self.flags.treat_err_as_bug.map(|c| self.err_count >= c).unwrap_or(false)\n+        self.flags.treat_err_as_bug.map(|c| self.err_count() >= c).unwrap_or(false)\n     }\n \n     fn print_error_count(&mut self, registry: &Registry) {\n+        self.emit_stashed_diagnostics();\n+\n         let s = match self.deduplicated_err_count {\n             0 => return,\n             1 => \"aborting due to previous error\".to_string(),\n@@ -760,25 +842,41 @@ impl HandlerInner {\n         }\n     }\n \n-    fn abort_if_errors_and_should_abort(&self) {\n-        if self.err_count > 0 && !self.continue_after_error {\n+    fn err_count(&self) -> usize {\n+        self.err_count + self.stashed_diagnostics.len()\n+    }\n+\n+    fn has_errors(&self) -> bool {\n+        self.err_count() > 0\n+    }\n+\n+    fn abort_if_errors_and_should_abort(&mut self) {\n+        self.emit_stashed_diagnostics();\n+\n+        if self.has_errors() && !self.continue_after_error {\n             FatalError.raise();\n         }\n     }\n \n-    fn abort_if_errors(&self) {\n-        if self.err_count > 0 {\n+    fn abort_if_errors(&mut self) {\n+        self.emit_stashed_diagnostics();\n+\n+        if self.has_errors() {\n             FatalError.raise();\n         }\n     }\n \n-    fn span_bug<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> ! {\n-        self.emit_diagnostic(Diagnostic::new(Bug, msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+    fn span_bug(&mut self, sp: impl Into<MultiSpan>, msg: &str) -> ! {\n+        self.emit_diag_at_span(Diagnostic::new(Bug, msg), sp);\n         panic!(ExplicitBug);\n     }\n \n-    fn delay_span_bug<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) {\n+    fn emit_diag_at_span(&mut self, mut diag: Diagnostic, sp: impl Into<MultiSpan>) {\n+        self.emit_diagnostic(diag.set_span(sp));\n+        self.abort_if_errors_and_should_abort();\n+    }\n+\n+    fn delay_span_bug(&mut self, sp: impl Into<MultiSpan>, msg: &str) {\n         if self.treat_err_as_bug() {\n             // FIXME: don't abort here if report_delayed_bugs is off\n             self.span_bug(sp, msg);\n@@ -793,18 +891,20 @@ impl HandlerInner {\n     }\n \n     fn fatal(&mut self, msg: &str) -> FatalError {\n-        if self.treat_err_as_bug() {\n-            self.bug(msg);\n-        }\n-        self.emit_diagnostic(&Diagnostic::new(Fatal, msg));\n+        self.emit_error(Fatal, msg);\n         FatalError\n     }\n \n     fn err(&mut self, msg: &str) {\n+        self.emit_error(Error, msg);\n+    }\n+\n+    /// Emit an error; level should be `Error` or `Fatal`.\n+    fn emit_error(&mut self, level: Level, msg: &str,) {\n         if self.treat_err_as_bug() {\n             self.bug(msg);\n         }\n-        self.emit_diagnostic(&Diagnostic::new(Error, msg));\n+        self.emit_diagnostic(&Diagnostic::new(level, msg));\n     }\n \n     fn bug(&mut self, msg: &str) -> ! {\n@@ -826,7 +926,7 @@ impl HandlerInner {\n \n     fn panic_if_treat_err_as_bug(&self) {\n         if self.treat_err_as_bug() {\n-            let s = match (self.err_count, self.flags.treat_err_as_bug.unwrap_or(0)) {\n+            let s = match (self.err_count(), self.flags.treat_err_as_bug.unwrap_or(0)) {\n                 (0, _) => return,\n                 (1, 1) => \"aborting due to `-Z treat-err-as-bug=1`\".to_string(),\n                 (1, _) => return,"}, {"sha": "33de518c59675097ba835aad26096f6b5a64e683", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -221,7 +221,6 @@ pub struct PluginInfo {\n }\n \n pub fn register_plugins<'a>(\n-    compiler: &Compiler,\n     sess: &'a Session,\n     cstore: &'a CStore,\n     mut krate: ast::Crate,\n@@ -261,9 +260,6 @@ pub fn register_plugins<'a>(\n         });\n     }\n \n-    // If necessary, compute the dependency graph (in the background).\n-    compiler.dep_graph_future().ok();\n-\n     time(sess, \"recursion limit\", || {\n         middle::recursion_limit::update_limits(sess, &krate);\n     });"}, {"sha": "ff5cd8b8c695d2fbc2dac7efa04fc271fc6c0cce", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -114,29 +114,38 @@ impl Compiler {\n             let crate_name = self.crate_name()?.peek().clone();\n             let krate = self.parse()?.take();\n \n-            passes::register_plugins(\n-                self,\n+            let result = passes::register_plugins(\n                 self.session(),\n                 self.cstore(),\n                 krate,\n                 &crate_name,\n-            )\n+            );\n+\n+            // Compute the dependency graph (in the background). We want to do\n+            // this as early as possible, to give the DepGraph maximum time to\n+            // load before dep_graph() is called, but it also can't happen\n+            // until after rustc_incremental::prepare_session_directory() is\n+            // called, which happens within passes::register_plugins().\n+            self.dep_graph_future().ok();\n+\n+            result\n         })\n     }\n \n     pub fn crate_name(&self) -> Result<&Query<String>> {\n         self.queries.crate_name.compute(|| {\n-            let parse_result = self.parse()?;\n-            let krate = parse_result.peek();\n-            let result = match self.crate_name {\n+            Ok(match self.crate_name {\n                 Some(ref crate_name) => crate_name.clone(),\n-                None => rustc_codegen_utils::link::find_crate_name(\n-                    Some(self.session()),\n-                    &krate.attrs,\n-                    &self.input\n-                ),\n-            };\n-            Ok(result)\n+                None => {\n+                    let parse_result = self.parse()?;\n+                    let krate = parse_result.peek();\n+                    rustc_codegen_utils::link::find_crate_name(\n+                        Some(self.session()),\n+                        &krate.attrs,\n+                        &self.input\n+                    )\n+                }\n+            })\n         })\n     }\n \n@@ -194,7 +203,6 @@ impl Compiler {\n \n     pub fn prepare_outputs(&self) -> Result<&Query<OutputFilenames>> {\n         self.queries.prepare_outputs.compute(|| {\n-            self.lower_to_hir()?;\n             let krate = self.expansion()?;\n             let krate = krate.peek();\n             let crate_name = self.crate_name()?;\n@@ -267,6 +275,11 @@ impl Compiler {\n         })\n     }\n \n+    // This method is different to all the other methods in `Compiler` because\n+    // it lacks a `Queries` entry. It's also not currently used. It does serve\n+    // as an example of how `Compiler` can be used, with additional steps added\n+    // between some passes. And see `rustc_driver::run_compiler` for a more\n+    // complex example.\n     pub fn compile(&self) -> Result<()> {\n         self.prepare_outputs()?;\n \n@@ -278,12 +291,12 @@ impl Compiler {\n \n         self.global_ctxt()?;\n \n-        // Drop AST after creating GlobalCtxt to free memory\n+        // Drop AST after creating GlobalCtxt to free memory.\n         mem::drop(self.expansion()?.take());\n \n         self.ongoing_codegen()?;\n \n-        // Drop GlobalCtxt after starting codegen to free memory\n+        // Drop GlobalCtxt after starting codegen to free memory.\n         mem::drop(self.global_ctxt()?.take());\n \n         self.link().map(|_| ())"}, {"sha": "f296753a0304cfd125d7044885284f058f1f760d", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -24,6 +24,5 @@ rustc_lexer = { path = \"../librustc_lexer\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n-byteorder = { version = \"1.3\" }\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "3f11430dc82cba3bd5e0eefe94ef29b53d4c57da", "filename": "src/librustc_plugin/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_plugin%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_plugin%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2FCargo.toml?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -15,4 +15,3 @@ rustc = { path = \"../librustc\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n-rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "936e72ef2c571a4f620a6839be5f3048246640fa", "filename": "src/librustc_resolve/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2FCargo.toml?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -12,7 +12,6 @@ doctest = false\n \n [dependencies]\n bitflags = \"1.0\"\n-indexmap = \"1\"\n log = \"0.4\"\n syntax = { path = \"../libsyntax\" }\n rustc = { path = \"../librustc\" }"}, {"sha": "73ad0670659b5fd08633b44304b8a52ec32a6500", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -18,7 +18,7 @@ use syntax::ext::base::{self, InvocationRes, Indeterminate, SpecialDerives};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, AstFragmentKind, Invocation, InvocationKind};\n use syntax::ext::hygiene::{self, ExpnId, ExpnData, ExpnKind};\n-use syntax::ext::tt::macro_rules;\n+use syntax::ext::compile_declarative_macro;\n use syntax::feature_gate::{emit_feature_err, is_builtin_attr_name};\n use syntax::feature_gate::GateIssue;\n use syntax::symbol::{Symbol, kw, sym};\n@@ -843,7 +843,7 @@ impl<'a> Resolver<'a> {\n     /// Compile the macro into a `SyntaxExtension` and possibly replace it with a pre-defined\n     /// extension partially or entirely for built-in macros and legacy plugin macros.\n     crate fn compile_macro(&mut self, item: &ast::Item, edition: Edition) -> SyntaxExtension {\n-        let mut result = macro_rules::compile(\n+        let mut result = compile_declarative_macro(\n             &self.session.parse_sess, self.session.features_untracked(), item, edition\n         );\n "}, {"sha": "b89c83d630b7dfebb80943815f01f45b141f4116", "filename": "src/librustc_save_analysis/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2FCargo.toml?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -14,7 +14,6 @@ rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n rustc_target = { path = \"../librustc_target\" }\n-rustc_typeck = { path = \"../librustc_typeck\" }\n serde_json = \"1\"\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "b86a3a5e9639b3d69fd2cdb2b1689d003bd455b7", "filename": "src/librustc_traits/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2FCargo.toml?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -9,8 +9,6 @@ name = \"rustc_traits\"\n path = \"lib.rs\"\n \n [dependencies]\n-bitflags = \"1.0\"\n-graphviz = { path = \"../libgraphviz\" }\n log = { version = \"0.4\" }\n rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "4c681544978e550b925016520460a2439a32d3a3", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -232,7 +232,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n                 let mut err = if !actual.references_error() {\n                     // Suggest clamping down the type if the method that is being attempted to\n-                    // be used exists at all, and the type is an ambiuous numeric type\n+                    // be used exists at all, and the type is an ambiguous numeric type\n                     // ({integer}/{float}).\n                     let mut candidates = all_traits(self.tcx)\n                         .into_iter()"}, {"sha": "2cd8507d753a641d01493e0acdc1330ea4010170", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -676,7 +676,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         } else {\n             // Pattern has wrong number of fields.\n-            self.e0023(pat.span, res, &subpats, &variant.fields, expected);\n+            self.e0023(pat.span, res, qpath, subpats, &variant.fields, expected);\n             on_error();\n             return tcx.types.err;\n         }\n@@ -687,22 +687,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         pat_span: Span,\n         res: Res,\n+        qpath: &hir::QPath,\n         subpats: &'tcx [P<Pat>],\n         fields: &[ty::FieldDef],\n         expected: Ty<'tcx>\n     ) {\n         let subpats_ending = pluralise!(subpats.len());\n         let fields_ending = pluralise!(fields.len());\n-        let missing_parenthesis = match expected.sty {\n-            ty::Adt(_, substs) if fields.len() == 1 => {\n-                let field_ty = fields[0].ty(self.tcx, substs);\n-                match field_ty.sty {\n-                    ty::Tuple(_) => field_ty.tuple_fields().count() == subpats.len(),\n-                    _ => false,\n-                }\n-            }\n-            _ => false,\n-        };\n         let res_span = self.tcx.def_span(res.def_id());\n         let mut err = struct_span_err!(\n             self.tcx.sess,\n@@ -723,11 +714,53 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ))\n             .span_label(res_span, format!(\"{} defined here\", res.descr()));\n \n+        // Identify the case `Some(x, y)` where the expected type is e.g. `Option<(T, U)>`.\n+        // More generally, the expected type wants a tuple variant with one field of an\n+        // N-arity-tuple, e.g., `V_i((p_0, .., p_N))`. Meanwhile, the user supplied a pattern\n+        // with the subpatterns directly in the tuple variant pattern, e.g., `V_i(p_0, .., p_N)`.\n+        let missing_parenthesis = match expected.sty {\n+            ty::Adt(_, substs) if fields.len() == 1 => {\n+                let field_ty = fields[0].ty(self.tcx, substs);\n+                match field_ty.sty {\n+                    ty::Tuple(_) => field_ty.tuple_fields().count() == subpats.len(),\n+                    _ => false,\n+                }\n+            }\n+            _ => false,\n+        };\n         if missing_parenthesis {\n+            let (left, right) = match subpats {\n+                // This is the zero case; we aim to get the \"hi\" part of the `QPath`'s\n+                // span as the \"lo\" and then the \"hi\" part of the pattern's span as the \"hi\".\n+                // This looks like:\n+                //\n+                // help: missing parenthesis\n+                //   |\n+                // L |     let A(()) = A(());\n+                //   |          ^  ^\n+                [] => {\n+                    let qpath_span = match qpath {\n+                        hir::QPath::Resolved(_, path) => path.span,\n+                        hir::QPath::TypeRelative(_, ps) => ps.ident.span,\n+                    };\n+                    (qpath_span.shrink_to_hi(), pat_span)\n+                },\n+                // Easy case. Just take the \"lo\" of the first sub-pattern and the \"hi\" of the\n+                // last sub-pattern. In the case of `A(x)` the first and last may coincide.\n+                // This looks like:\n+                //\n+                // help: missing parenthesis\n+                //   |\n+                // L |     let A((x, y)) = A((1, 2));\n+                //   |           ^    ^\n+                [first, ..] => (first.span.shrink_to_lo(), subpats.last().unwrap().span),\n+            };\n             err.multipart_suggestion(\n                 \"missing parenthesis\",\n-                vec![(subpats[0].span.shrink_to_lo(), \"(\".to_string()),\n-                    (subpats[subpats.len()-1].span.shrink_to_hi(), \")\".to_string())],\n+                vec![\n+                    (left, \"(\".to_string()),\n+                    (right.shrink_to_hi(), \")\".to_string()),\n+                ],\n                 Applicability::MachineApplicable,\n             );\n         }"}, {"sha": "f7e766bb84d5740197ae84d16b64effcc475a877", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -832,7 +832,7 @@ fn check_method_receiver<'fcx, 'tcx>(\n }\n \n fn e0307(fcx: &FnCtxt<'fcx, 'tcx>, span: Span, receiver_ty: Ty<'_>) {\n-    fcx.tcx.sess.diagnostic().mut_span_err(\n+    fcx.tcx.sess.diagnostic().struct_span_err(\n         span,\n         &format!(\"invalid `self` parameter type: {:?}\", receiver_ty)\n     ).note(\"type of `self` must be `Self` or a type that dereferences to it\")"}, {"sha": "e6e0cb88fbd23435f030d3b7aad2079cc3042673", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -46,7 +46,7 @@ use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::hir::GenericParamKind;\n use rustc::hir::{self, CodegenFnAttrFlags, CodegenFnAttrs, Unsafety};\n \n-use errors::{Applicability, DiagnosticId};\n+use errors::{Applicability, DiagnosticId, StashKey};\n \n struct OnlySelfBounds(bool);\n \n@@ -1149,18 +1149,41 @@ fn infer_placeholder_type(\n     def_id: DefId,\n     body_id: hir::BodyId,\n     span: Span,\n+    item_ident: Ident,\n ) -> Ty<'_> {\n     let ty = tcx.typeck_tables_of(def_id).node_type(body_id.hir_id);\n-    let mut diag = bad_placeholder_type(tcx, span);\n-    if ty != tcx.types.err {\n-        diag.span_suggestion(\n-            span,\n-            \"replace `_` with the correct type\",\n-            ty.to_string(),\n-            Applicability::MaybeIncorrect,\n-        );\n+\n+    // If this came from a free `const` or `static mut?` item,\n+    // then the user may have written e.g. `const A = 42;`.\n+    // In this case, the parser has stashed a diagnostic for\n+    // us to improve in typeck so we do that now.\n+    match tcx.sess.diagnostic().steal_diagnostic(span, StashKey::ItemNoType) {\n+        Some(mut err) => {\n+            // The parser provided a sub-optimal `HasPlaceholders` suggestion for the type.\n+            // We are typeck and have the real type, so remove that and suggest the actual type.\n+            err.suggestions.clear();\n+            err.span_suggestion(\n+                span,\n+                \"provide a type for the item\",\n+                format!(\"{}: {}\", item_ident, ty),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n+        }\n+        None => {\n+            let mut diag = bad_placeholder_type(tcx, span);\n+            if ty != tcx.types.err {\n+                diag.span_suggestion(\n+                    span,\n+                    \"replace `_` with the correct type\",\n+                    ty.to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            diag.emit();\n+        }\n     }\n-    diag.emit();\n+\n     ty\n }\n \n@@ -1192,7 +1215,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n             TraitItemKind::Const(ref ty, body_id)  => {\n                 body_id.and_then(|body_id| {\n                     if let hir::TyKind::Infer = ty.node {\n-                        Some(infer_placeholder_type(tcx, def_id, body_id, ty.span))\n+                        Some(infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident))\n                     } else {\n                         None\n                     }\n@@ -1214,7 +1237,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n             }\n             ImplItemKind::Const(ref ty, body_id) => {\n                 if let hir::TyKind::Infer = ty.node {\n-                    infer_placeholder_type(tcx, def_id, body_id, ty.span)\n+                    infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n                 } else {\n                     icx.to_ty(ty)\n                 }\n@@ -1246,7 +1269,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                 ItemKind::Static(ref ty, .., body_id)\n                 | ItemKind::Const(ref ty, body_id) => {\n                     if let hir::TyKind::Infer = ty.node {\n-                        infer_placeholder_type(tcx, def_id, body_id, ty.span)\n+                        infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n                     } else {\n                         icx.to_ty(ty)\n                     }"}, {"sha": "18a84cd0eeb76fe24c0b7eaee03f1b53324c0b83", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -119,7 +119,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 source: Span::empty(),\n                 name: None,\n                 attrs: Default::default(),\n-                visibility: None,\n+                visibility: Inherited,\n                 def_id: self.cx.next_def_id(param_env_def_id.krate),\n                 stability: None,\n                 deprecation: None,"}, {"sha": "4cd1cc1a1cf50bd265a841927e22302a3e1fa8fd", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                     source: self.cx.tcx.def_span(impl_def_id).clean(self.cx),\n                     name: None,\n                     attrs: Default::default(),\n-                    visibility: None,\n+                    visibility: Inherited,\n                     def_id: self.cx.next_def_id(impl_def_id.krate),\n                     stability: None,\n                     deprecation: None,"}, {"sha": "031e77ff1dbe0d1da41b7a9a4ec55efd36b6ee7a", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -131,7 +131,7 @@ pub fn try_inline(\n         name: Some(name.clean(cx)),\n         attrs,\n         inner,\n-        visibility: Some(clean::Public),\n+        visibility: clean::Public,\n         stability: cx.tcx.lookup_stability(did).clean(cx),\n         deprecation: cx.tcx.lookup_deprecation(did).clean(cx),\n         def_id: did,\n@@ -418,7 +418,7 @@ pub fn build_impl(cx: &DocContext<'_>, did: DefId, attrs: Option<Attrs<'_>>,\n         source: tcx.def_span(did).clean(cx),\n         name: None,\n         attrs,\n-        visibility: Some(clean::Inherited),\n+        visibility: clean::Inherited,\n         stability: tcx.lookup_stability(did).clean(cx),\n         deprecation: tcx.lookup_deprecation(did).clean(cx),\n         def_id: did,"}, {"sha": "197c09ba759e7d2cc9d9a91f33bb1d1b12e9f5a6", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 18, "deletions": 28, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -187,7 +187,7 @@ pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n                 source: Span::empty(),\n                 name: Some(prim.to_url_str().to_string()),\n                 attrs: attrs.clone(),\n-                visibility: Some(Public),\n+                visibility: Public,\n                 stability: get_stability(cx, def_id),\n                 deprecation: get_deprecation(cx, def_id),\n                 def_id,\n@@ -199,7 +199,7 @@ pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n                 source: Span::empty(),\n                 name: Some(kw.clone()),\n                 attrs: attrs,\n-                visibility: Some(Public),\n+                visibility: Public,\n                 stability: get_stability(cx, def_id),\n                 deprecation: get_deprecation(cx, def_id),\n                 def_id,\n@@ -361,7 +361,7 @@ pub struct Item {\n     pub name: Option<String>,\n     pub attrs: Attributes,\n     pub inner: ItemEnum,\n-    pub visibility: Option<Visibility>,\n+    pub visibility: Visibility,\n     pub def_id: DefId,\n     pub stability: Option<Stability>,\n     pub deprecation: Option<Deprecation>,\n@@ -1849,7 +1849,7 @@ fn get_real_types(\n     cx: &DocContext<'_>,\n     recurse: i32,\n ) -> FxHashSet<Type> {\n-    let arg_s = arg.to_string();\n+    let arg_s = arg.print().to_string();\n     let mut res = FxHashSet::default();\n     if recurse >= 10 { // FIXME: remove this whole recurse thing when the recursion bug is fixed\n         return res;\n@@ -2311,7 +2311,7 @@ impl Clean<Item> for hir::TraitItem {\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n             def_id: local_did,\n-            visibility: None,\n+            visibility: Visibility::Inherited,\n             stability: get_stability(cx, local_did),\n             deprecation: get_deprecation(cx, local_did),\n             inner,\n@@ -2496,7 +2496,7 @@ impl Clean<Item> for ty::AssocItem {\n \n         let visibility = match self.container {\n             ty::ImplContainer(_) => self.vis.clean(cx),\n-            ty::TraitContainer(_) => None,\n+            ty::TraitContainer(_) => Inherited,\n         };\n \n         Item {\n@@ -3293,9 +3293,9 @@ pub enum Visibility {\n     Restricted(DefId, Path),\n }\n \n-impl Clean<Option<Visibility>> for hir::Visibility {\n-    fn clean(&self, cx: &DocContext<'_>) -> Option<Visibility> {\n-        Some(match self.node {\n+impl Clean<Visibility> for hir::Visibility {\n+    fn clean(&self, cx: &DocContext<'_>) -> Visibility {\n+        match self.node {\n             hir::VisibilityKind::Public => Visibility::Public,\n             hir::VisibilityKind::Inherited => Visibility::Inherited,\n             hir::VisibilityKind::Crate(_) => Visibility::Crate,\n@@ -3304,13 +3304,13 @@ impl Clean<Option<Visibility>> for hir::Visibility {\n                 let did = register_res(cx, path.res);\n                 Visibility::Restricted(did, path)\n             }\n-        })\n+        }\n     }\n }\n \n-impl Clean<Option<Visibility>> for ty::Visibility {\n-    fn clean(&self, _: &DocContext<'_>) -> Option<Visibility> {\n-        Some(if *self == ty::Visibility::Public { Public } else { Inherited })\n+impl Clean<Visibility> for ty::Visibility {\n+    fn clean(&self, _: &DocContext<'_>) -> Visibility {\n+        if *self == ty::Visibility::Public { Public } else { Inherited }\n     }\n }\n \n@@ -3427,7 +3427,7 @@ impl Clean<Item> for doctree::Variant<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            visibility: None,\n+            visibility: Inherited,\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id),\n@@ -3470,7 +3470,7 @@ impl Clean<Item> for ty::VariantDef {\n             name: Some(self.ident.clean(cx)),\n             attrs: inline::load_attrs(cx, self.def_id).clean(cx),\n             source: cx.tcx.def_span(self.def_id).clean(cx),\n-            visibility: Some(Inherited),\n+            visibility: Inherited,\n             def_id: self.def_id,\n             inner: VariantItem(Variant { kind }),\n             stability: get_stability(cx, self.def_id),\n@@ -3573,16 +3573,6 @@ pub enum GenericArg {\n     Const(Constant),\n }\n \n-impl fmt::Display for GenericArg {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            GenericArg::Lifetime(lt) => lt.fmt(f),\n-            GenericArg::Type(ty) => ty.fmt(f),\n-            GenericArg::Const(ct) => ct.fmt(f),\n-        }\n-    }\n-}\n-\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub enum GenericArgs {\n     AngleBracketed {\n@@ -4274,7 +4264,7 @@ fn resolve_type(cx: &DocContext<'_>,\n             return Generic(kw::SelfUpper.to_string());\n         }\n         Res::Def(DefKind::TyParam, _) if path.segments.len() == 1 => {\n-            return Generic(format!(\"{:#}\", path));\n+            return Generic(format!(\"{:#}\", path.print()));\n         }\n         Res::SelfTy(..)\n         | Res::Def(DefKind::TyParam, _)\n@@ -4343,7 +4333,7 @@ impl Clean<Item> for doctree::Macro<'_> {\n             name: Some(name.clone()),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            visibility: Some(Public),\n+            visibility: Public,\n             stability: cx.stability(self.hid).clean(cx),\n             deprecation: cx.deprecation(self.hid).clean(cx),\n             def_id: self.def_id,\n@@ -4371,7 +4361,7 @@ impl Clean<Item> for doctree::ProcMacro<'_> {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            visibility: Some(Public),\n+            visibility: Public,\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id),"}, {"sha": "fafd43cb60b69a4cb72a6e83ef8e1a71ba348746", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 495, "deletions": 469, "changes": 964, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -99,10 +99,6 @@ impl Buffer {\n         self.into_inner()\n     }\n \n-    crate fn with_formatter<T: FnOnce(&mut fmt::Formatter<'_>) -> fmt::Result>(&mut self, t: T) {\n-        self.from_display(display_fn(move |f| (t)(f)));\n-    }\n-\n     crate fn from_display<T: std::fmt::Display>(&mut self, t: T) {\n         if self.for_html {\n             write!(self, \"{}\", t);\n@@ -112,30 +108,6 @@ impl Buffer {\n     }\n }\n \n-/// Helper to render an optional visibility with a space after it (if the\n-/// visibility is preset)\n-#[derive(Copy, Clone)]\n-pub struct VisSpace<'a>(pub &'a Option<clean::Visibility>);\n-/// Similarly to VisSpace, this structure is used to render a function style with a\n-/// space after it.\n-#[derive(Copy, Clone)]\n-pub struct UnsafetySpace(pub hir::Unsafety);\n-/// Similarly to VisSpace, this structure is used to render a function constness\n-/// with a space after it.\n-#[derive(Copy, Clone)]\n-pub struct ConstnessSpace(pub hir::Constness);\n-/// Similarly to VisSpace, this structure is used to render a function asyncness\n-/// with a space after it.\n-#[derive(Copy, Clone)]\n-pub struct AsyncSpace(pub hir::IsAsync);\n-/// Similar to VisSpace, but used for mutability\n-#[derive(Copy, Clone)]\n-pub struct MutableSpace(pub clean::Mutability);\n-/// Wrapper struct for emitting type parameter bounds.\n-pub struct GenericBounds<'a>(pub &'a [clean::GenericBound]);\n-pub struct AbiSpace(pub Abi);\n-pub struct DefaultSpace(pub bool);\n-\n /// Wrapper struct for properly emitting a function or method declaration.\n pub struct Function<'a> {\n     /// The declaration to emit.\n@@ -161,102 +133,89 @@ pub struct WhereClause<'a>{\n     pub end_newline: bool,\n }\n \n-impl<'a> VisSpace<'a> {\n-    pub fn get(self) -> &'a Option<clean::Visibility> {\n-        let VisSpace(v) = self; v\n-    }\n-}\n-\n-impl UnsafetySpace {\n-    pub fn get(&self) -> hir::Unsafety {\n-        let UnsafetySpace(v) = *self; v\n-    }\n-}\n-\n-impl ConstnessSpace {\n-    pub fn get(&self) -> hir::Constness {\n-        let ConstnessSpace(v) = *self; v\n-    }\n-}\n-\n-fn comma_sep<T: fmt::Display>(items: &[T]) -> impl fmt::Display + '_ {\n+fn comma_sep<T: fmt::Display>(items: impl Iterator<Item=T>) -> impl fmt::Display {\n     display_fn(move |f| {\n-        for (i, item) in items.iter().enumerate() {\n+        for (i, item) in items.enumerate() {\n             if i != 0 { write!(f, \", \")?; }\n-            fmt::Display::fmt(item, f)?;\n+            fmt::Display::fmt(&item, f)?;\n         }\n         Ok(())\n     })\n }\n \n-impl<'a> fmt::Display for GenericBounds<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+crate fn print_generic_bounds(bounds: &[clean::GenericBound]) -> impl fmt::Display + '_ {\n+    display_fn(move |f| {\n         let mut bounds_dup = FxHashSet::default();\n-        let &GenericBounds(bounds) = self;\n \n-        for (i, bound) in bounds.iter().filter(|b| bounds_dup.insert(b.to_string())).enumerate() {\n+        for (i, bound) in bounds.iter().filter(|b| {\n+            bounds_dup.insert(b.print().to_string())\n+        }).enumerate() {\n             if i > 0 {\n                 f.write_str(\" + \")?;\n             }\n-            fmt::Display::fmt(bound, f)?;\n+            fmt::Display::fmt(&bound.print(), f)?;\n         }\n         Ok(())\n-    }\n+    })\n }\n \n-impl fmt::Display for clean::GenericParamDef {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.kind {\n-            clean::GenericParamDefKind::Lifetime => write!(f, \"{}\", self.name),\n-            clean::GenericParamDefKind::Type { ref bounds, ref default, .. } => {\n-                f.write_str(&self.name)?;\n+impl clean::GenericParamDef {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match self.kind {\n+                clean::GenericParamDefKind::Lifetime => write!(f, \"{}\", self.name),\n+                clean::GenericParamDefKind::Type { ref bounds, ref default, .. } => {\n+                    f.write_str(&self.name)?;\n \n-                if !bounds.is_empty() {\n-                    if f.alternate() {\n-                        write!(f, \": {:#}\", GenericBounds(bounds))?;\n-                    } else {\n-                        write!(f, \":&nbsp;{}\", GenericBounds(bounds))?;\n+                    if !bounds.is_empty() {\n+                        if f.alternate() {\n+                            write!(f, \": {:#}\", print_generic_bounds(bounds))?;\n+                        } else {\n+                            write!(f, \":&nbsp;{}\", print_generic_bounds(bounds))?;\n+                        }\n+                    }\n+\n+                    if let Some(ref ty) = default {\n+                        if f.alternate() {\n+                            write!(f, \" = {:#}\", ty.print())?;\n+                        } else {\n+                            write!(f, \"&nbsp;=&nbsp;{}\", ty.print())?;\n+                        }\n                     }\n+\n+                    Ok(())\n                 }\n+                clean::GenericParamDefKind::Const { ref ty, .. } => {\n+                    f.write_str(\"const \")?;\n+                    f.write_str(&self.name)?;\n \n-                if let Some(ref ty) = default {\n                     if f.alternate() {\n-                        write!(f, \" = {:#}\", ty)?;\n+                        write!(f, \": {:#}\", ty.print())\n                     } else {\n-                        write!(f, \"&nbsp;=&nbsp;{}\", ty)?;\n+                        write!(f, \":&nbsp;{}\", ty.print())\n                     }\n                 }\n-\n-                Ok(())\n             }\n-            clean::GenericParamDefKind::Const { ref ty, .. } => {\n-                f.write_str(\"const \")?;\n-                f.write_str(&self.name)?;\n-\n-                if f.alternate() {\n-                    write!(f, \": {:#}\", ty)\n-                } else {\n-                    write!(f, \":&nbsp;{}\", ty)\n-                }\n-            }\n-        }\n+        })\n     }\n }\n \n-impl fmt::Display for clean::Generics {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let real_params = self.params\n-            .iter()\n-            .filter(|p| !p.is_synthetic_type_param())\n-            .collect::<Vec<_>>();\n-        if real_params.is_empty() {\n-            return Ok(());\n-        }\n-        if f.alternate() {\n-            write!(f, \"<{:#}>\", comma_sep(&real_params))\n-        } else {\n-            write!(f, \"&lt;{}&gt;\", comma_sep(&real_params))\n-        }\n+impl clean::Generics {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            let real_params = self.params\n+                .iter()\n+                .filter(|p| !p.is_synthetic_type_param())\n+                .collect::<Vec<_>>();\n+            if real_params.is_empty() {\n+                return Ok(());\n+            }\n+            if f.alternate() {\n+                write!(f, \"<{:#}>\", comma_sep(real_params.iter().map(|g| g.print())))\n+            } else {\n+                write!(f, \"&lt;{}&gt;\", comma_sep(real_params.iter().map(|g| g.print())))\n+            }\n+        })\n     }\n }\n \n@@ -287,24 +246,26 @@ impl<'a> fmt::Display for WhereClause<'a> {\n                 &clean::WherePredicate::BoundPredicate { ref ty, ref bounds } => {\n                     let bounds = bounds;\n                     if f.alternate() {\n-                        clause.push_str(&format!(\"{:#}: {:#}\", ty, GenericBounds(bounds)));\n+                        clause.push_str(&format!(\"{:#}: {:#}\",\n+                                ty.print(), print_generic_bounds(bounds)));\n                     } else {\n-                        clause.push_str(&format!(\"{}: {}\", ty, GenericBounds(bounds)));\n+                        clause.push_str(&format!(\"{}: {}\",\n+                                ty.print(), print_generic_bounds(bounds)));\n                     }\n                 }\n                 &clean::WherePredicate::RegionPredicate { ref lifetime, ref bounds } => {\n                     clause.push_str(&format!(\"{}: {}\",\n-                                                lifetime,\n+                                                lifetime.print(),\n                                                 bounds.iter()\n-                                                    .map(|b| b.to_string())\n+                                                    .map(|b| b.print().to_string())\n                                                     .collect::<Vec<_>>()\n                                                     .join(\" + \")));\n                 }\n                 &clean::WherePredicate::EqPredicate { ref lhs, ref rhs } => {\n                     if f.alternate() {\n-                        clause.push_str(&format!(\"{:#} == {:#}\", lhs, rhs));\n+                        clause.push_str(&format!(\"{:#} == {:#}\", lhs.print(), rhs.print()));\n                     } else {\n-                        clause.push_str(&format!(\"{} == {}\", lhs, rhs));\n+                        clause.push_str(&format!(\"{} == {}\", lhs.print(), rhs.print()));\n                     }\n                 }\n             }\n@@ -336,153 +297,164 @@ impl<'a> fmt::Display for WhereClause<'a> {\n     }\n }\n \n-impl fmt::Display for clean::Lifetime {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(self.get_ref())?;\n-        Ok(())\n+impl clean::Lifetime {\n+    crate fn print(&self) -> &str {\n+        self.get_ref()\n     }\n }\n \n-impl fmt::Display for clean::Constant {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(&self.expr, f)\n+impl clean::Constant {\n+    crate fn print(&self) -> &str {\n+        &self.expr\n     }\n }\n \n-impl fmt::Display for clean::PolyTrait {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if !self.generic_params.is_empty() {\n+impl clean::PolyTrait {\n+    fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            if !self.generic_params.is_empty() {\n+                if f.alternate() {\n+                    write!(f, \"for<{:#}> \",\n+                        comma_sep(self.generic_params.iter().map(|g| g.print())))?;\n+                } else {\n+                    write!(f, \"for&lt;{}&gt; \",\n+                        comma_sep(self.generic_params.iter().map(|g| g.print())))?;\n+                }\n+            }\n             if f.alternate() {\n-                write!(f, \"for<{:#}> \", comma_sep(&self.generic_params))?;\n+                write!(f, \"{:#}\", self.trait_.print())\n             } else {\n-                write!(f, \"for&lt;{}&gt; \", comma_sep(&self.generic_params))?;\n+                write!(f, \"{}\", self.trait_.print())\n             }\n-        }\n-        if f.alternate() {\n-            write!(f, \"{:#}\", self.trait_)\n-        } else {\n-            write!(f, \"{}\", self.trait_)\n-        }\n+        })\n     }\n }\n \n-impl fmt::Display for clean::GenericBound {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            clean::GenericBound::Outlives(ref lt) => {\n-                write!(f, \"{}\", *lt)\n-            }\n-            clean::GenericBound::TraitBound(ref ty, modifier) => {\n-                let modifier_str = match modifier {\n-                    hir::TraitBoundModifier::None => \"\",\n-                    hir::TraitBoundModifier::Maybe => \"?\",\n-                };\n-                if f.alternate() {\n-                    write!(f, \"{}{:#}\", modifier_str, *ty)\n-                } else {\n-                    write!(f, \"{}{}\", modifier_str, *ty)\n+impl clean::GenericBound {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match self {\n+                clean::GenericBound::Outlives(lt) => {\n+                    write!(f, \"{}\", lt.print())\n+                }\n+                clean::GenericBound::TraitBound(ty, modifier) => {\n+                    let modifier_str = match modifier {\n+                        hir::TraitBoundModifier::None => \"\",\n+                        hir::TraitBoundModifier::Maybe => \"?\",\n+                    };\n+                    if f.alternate() {\n+                        write!(f, \"{}{:#}\", modifier_str, ty.print())\n+                    } else {\n+                        write!(f, \"{}{}\", modifier_str, ty.print())\n+                    }\n                 }\n             }\n-        }\n+        })\n     }\n }\n \n-impl fmt::Display for clean::GenericArgs {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            clean::GenericArgs::AngleBracketed { ref args, ref bindings } => {\n-                if !args.is_empty() || !bindings.is_empty() {\n-                    if f.alternate() {\n-                        f.write_str(\"<\")?;\n-                    } else {\n-                        f.write_str(\"&lt;\")?;\n-                    }\n-                    let mut comma = false;\n-                    for arg in args {\n-                        if comma {\n-                            f.write_str(\", \")?;\n+impl clean::GenericArgs {\n+    fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match *self {\n+                clean::GenericArgs::AngleBracketed { ref args, ref bindings } => {\n+                    if !args.is_empty() || !bindings.is_empty() {\n+                        if f.alternate() {\n+                            f.write_str(\"<\")?;\n+                        } else {\n+                            f.write_str(\"&lt;\")?;\n+                        }\n+                        let mut comma = false;\n+                        for arg in args {\n+                            if comma {\n+                                f.write_str(\", \")?;\n+                            }\n+                            comma = true;\n+                            if f.alternate() {\n+                                write!(f, \"{:#}\", arg.print())?;\n+                            } else {\n+                                write!(f, \"{}\", arg.print())?;\n+                            }\n+                        }\n+                        for binding in bindings {\n+                            if comma {\n+                                f.write_str(\", \")?;\n+                            }\n+                            comma = true;\n+                            if f.alternate() {\n+                                write!(f, \"{:#}\", binding.print())?;\n+                            } else {\n+                                write!(f, \"{}\", binding.print())?;\n+                            }\n                         }\n-                        comma = true;\n                         if f.alternate() {\n-                            write!(f, \"{:#}\", *arg)?;\n+                            f.write_str(\">\")?;\n                         } else {\n-                            write!(f, \"{}\", *arg)?;\n+                            f.write_str(\"&gt;\")?;\n                         }\n                     }\n-                    for binding in bindings {\n+                }\n+                clean::GenericArgs::Parenthesized { ref inputs, ref output } => {\n+                    f.write_str(\"(\")?;\n+                    let mut comma = false;\n+                    for ty in inputs {\n                         if comma {\n                             f.write_str(\", \")?;\n                         }\n                         comma = true;\n                         if f.alternate() {\n-                            write!(f, \"{:#}\", *binding)?;\n+                            write!(f, \"{:#}\", ty.print())?;\n                         } else {\n-                            write!(f, \"{}\", *binding)?;\n+                            write!(f, \"{}\", ty.print())?;\n                         }\n                     }\n-                    if f.alternate() {\n-                        f.write_str(\">\")?;\n-                    } else {\n-                        f.write_str(\"&gt;\")?;\n-                    }\n-                }\n-            }\n-            clean::GenericArgs::Parenthesized { ref inputs, ref output } => {\n-                f.write_str(\"(\")?;\n-                let mut comma = false;\n-                for ty in inputs {\n-                    if comma {\n-                        f.write_str(\", \")?;\n-                    }\n-                    comma = true;\n-                    if f.alternate() {\n-                        write!(f, \"{:#}\", *ty)?;\n-                    } else {\n-                        write!(f, \"{}\", *ty)?;\n-                    }\n-                }\n-                f.write_str(\")\")?;\n-                if let Some(ref ty) = *output {\n-                    if f.alternate() {\n-                        write!(f, \" -> {:#}\", ty)?;\n-                    } else {\n-                        write!(f, \" -&gt; {}\", ty)?;\n+                    f.write_str(\")\")?;\n+                    if let Some(ref ty) = *output {\n+                        if f.alternate() {\n+                            write!(f, \" -> {:#}\", ty.print())?;\n+                        } else {\n+                            write!(f, \" -&gt; {}\", ty.print())?;\n+                        }\n                     }\n                 }\n             }\n-        }\n-        Ok(())\n+            Ok(())\n+        })\n     }\n }\n \n-impl fmt::Display for clean::PathSegment {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.name)?;\n-        if f.alternate() {\n-            write!(f, \"{:#}\", self.args)\n-        } else {\n-            write!(f, \"{}\", self.args)\n-        }\n+impl clean::PathSegment {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            f.write_str(&self.name)?;\n+            if f.alternate() {\n+                write!(f, \"{:#}\", self.args.print())\n+            } else {\n+                write!(f, \"{}\", self.args.print())\n+            }\n+        })\n     }\n }\n \n-impl fmt::Display for clean::Path {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if self.global {\n-            f.write_str(\"::\")?\n-        }\n-\n-        for (i, seg) in self.segments.iter().enumerate() {\n-            if i > 0 {\n+impl clean::Path {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            if self.global {\n                 f.write_str(\"::\")?\n             }\n-            if f.alternate() {\n-                write!(f, \"{:#}\", seg)?;\n-            } else {\n-                write!(f, \"{}\", seg)?;\n+\n+            for (i, seg) in self.segments.iter().enumerate() {\n+                if i > 0 {\n+                    f.write_str(\"::\")?\n+                }\n+                if f.alternate() {\n+                    write!(f, \"{:#}\", seg.print())?;\n+                } else {\n+                    write!(f, \"{}\", seg.print())?;\n+                }\n             }\n-        }\n-        Ok(())\n+            Ok(())\n+        })\n     }\n }\n \n@@ -516,7 +488,7 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n             url.push_str(\"/index.html\");\n         }\n         _ => {\n-            url.push_str(shortty.css_class());\n+            url.push_str(shortty.as_str());\n             url.push_str(\".\");\n             url.push_str(fqp.last().unwrap());\n             url.push_str(\".html\");\n@@ -537,7 +509,7 @@ fn resolved_path(w: &mut fmt::Formatter<'_>, did: DefId, path: &clean::Path,\n         }\n     }\n     if w.alternate() {\n-        write!(w, \"{}{:#}\", &last.name, last.args)?;\n+        write!(w, \"{}{:#}\", &last.name, last.args.print())?;\n     } else {\n         let path = if use_absolute {\n             if let Some((_, _, fqp)) = href(did) {\n@@ -550,7 +522,7 @@ fn resolved_path(w: &mut fmt::Formatter<'_>, did: DefId, path: &clean::Path,\n         } else {\n             anchor(did, &last.name).to_string()\n         };\n-        write!(w, \"{}{}\", path, last.args)?;\n+        write!(w, \"{}{}\", path, last.args.print())?;\n     }\n     Ok(())\n }\n@@ -606,7 +578,7 @@ fn tybounds(param_names: &Option<Vec<clean::GenericBound>>) -> impl fmt::Display\n             Some(ref params) => {\n                 for param in params {\n                     write!(f, \" + \")?;\n-                    fmt::Display::fmt(param, f)?;\n+                    fmt::Display::fmt(&param.print(), f)?;\n                 }\n                 Ok(())\n             }\n@@ -644,14 +616,15 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n         clean::BareFunction(ref decl) => {\n             if f.alternate() {\n                 write!(f, \"{}{:#}fn{:#}{:#}\",\n-                       UnsafetySpace(decl.unsafety),\n-                       AbiSpace(decl.abi),\n-                       comma_sep(&decl.generic_params),\n-                       decl.decl)\n+                       decl.unsafety.print_with_space(),\n+                       print_abi_with_space(decl.abi),\n+                       decl.print_generic_params(),\n+                       decl.decl.print())\n             } else {\n-                write!(f, \"{}{}\", UnsafetySpace(decl.unsafety), AbiSpace(decl.abi))?;\n+                write!(f, \"{}{}\",\n+                    decl.unsafety.print_with_space(), print_abi_with_space(decl.abi))?;\n                 primitive_link(f, PrimitiveType::Fn, \"fn\")?;\n-                write!(f, \"{}{}\", comma_sep(&decl.generic_params), decl.decl)\n+                write!(f, \"{}{}\", decl.print_generic_params(), decl.decl.print())\n             }\n         }\n         clean::Tuple(ref typs) => {\n@@ -660,24 +633,27 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                 &[ref one] => {\n                     primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n                     // Carry `f.alternate()` into this display w/o branching manually.\n-                    fmt::Display::fmt(one, f)?;\n+                    fmt::Display::fmt(&one.print(), f)?;\n                     primitive_link(f, PrimitiveType::Tuple, \",)\")\n                 }\n                 many => {\n                     primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n-                    fmt::Display::fmt(&comma_sep(many), f)?;\n+                    for (i, item) in many.iter().enumerate() {\n+                        if i != 0 { write!(f, \", \")?; }\n+                        fmt::Display::fmt(&item.print(), f)?;\n+                    }\n                     primitive_link(f, PrimitiveType::Tuple, \")\")\n                 }\n             }\n         }\n         clean::Slice(ref t) => {\n             primitive_link(f, PrimitiveType::Slice, \"[\")?;\n-            fmt::Display::fmt(t, f)?;\n+            fmt::Display::fmt(&t.print(), f)?;\n             primitive_link(f, PrimitiveType::Slice, \"]\")\n         }\n         clean::Array(ref t, ref n) => {\n             primitive_link(f, PrimitiveType::Array, \"[\")?;\n-            fmt::Display::fmt(t, f)?;\n+            fmt::Display::fmt(&t.print(), f)?;\n             primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", n))\n         }\n         clean::Never => primitive_link(f, PrimitiveType::Never, \"!\"),\n@@ -691,24 +667,24 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                 clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n                     if f.alternate() {\n                         primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                       &format!(\"*{} {:#}\", m, t))\n+                                       &format!(\"*{} {:#}\", m, t.print()))\n                     } else {\n                         primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                       &format!(\"*{} {}\", m, t))\n+                                       &format!(\"*{} {}\", m, t.print()))\n                     }\n                 }\n                 _ => {\n                     primitive_link(f, clean::PrimitiveType::RawPointer, &format!(\"*{} \", m))?;\n-                    fmt::Display::fmt(t, f)\n+                    fmt::Display::fmt(&t.print(), f)\n                 }\n             }\n         }\n         clean::BorrowedRef{ lifetime: ref l, mutability, type_: ref ty} => {\n-            let lt = match *l {\n-                Some(ref l) => format!(\"{} \", *l),\n-                _ => String::new(),\n+            let lt = match l {\n+                Some(l) => format!(\"{} \", l.print()),\n+                _ => String::new()\n             };\n-            let m = MutableSpace(mutability);\n+            let m = mutability.print_with_space();\n             let amp = if f.alternate() {\n                 \"&\".to_string()\n             } else {\n@@ -720,19 +696,19 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                         clean::Generic(_) => {\n                             if f.alternate() {\n                                 primitive_link(f, PrimitiveType::Slice,\n-                                    &format!(\"{}{}{}[{:#}]\", amp, lt, m, **bt))\n+                                    &format!(\"{}{}{}[{:#}]\", amp, lt, m, bt.print()))\n                             } else {\n                                 primitive_link(f, PrimitiveType::Slice,\n-                                    &format!(\"{}{}{}[{}]\", amp, lt, m, **bt))\n+                                    &format!(\"{}{}{}[{}]\", amp, lt, m, bt.print()))\n                             }\n                         }\n                         _ => {\n                             primitive_link(f, PrimitiveType::Slice,\n                                            &format!(\"{}{}{}[\", amp, lt, m))?;\n                             if f.alternate() {\n-                                write!(f, \"{:#}\", **bt)?;\n+                                write!(f, \"{:#}\", bt.print())?;\n                             } else {\n-                                write!(f, \"{}\", **bt)?;\n+                                write!(f, \"{}\", bt.print())?;\n                             }\n                             primitive_link(f, PrimitiveType::Slice, \"]\")\n                         }\n@@ -756,9 +732,9 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n         }\n         clean::ImplTrait(ref bounds) => {\n             if f.alternate() {\n-                write!(f, \"impl {:#}\", GenericBounds(bounds))\n+                write!(f, \"impl {:#}\", print_generic_bounds(bounds))\n             } else {\n-                write!(f, \"impl {}\", GenericBounds(bounds))\n+                write!(f, \"impl {}\", print_generic_bounds(bounds))\n             }\n         }\n         clean::QPath { ref name, ref self_type, ref trait_ } => {\n@@ -770,15 +746,15 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n             };\n             if f.alternate() {\n                 if should_show_cast {\n-                    write!(f, \"<{:#} as {:#}>::\", self_type, trait_)?\n+                    write!(f, \"<{:#} as {:#}>::\", self_type.print(), trait_.print())?\n                 } else {\n-                    write!(f, \"{:#}::\", self_type)?\n+                    write!(f, \"{:#}::\", self_type.print())?\n                 }\n             } else {\n                 if should_show_cast {\n-                    write!(f, \"&lt;{} as {}&gt;::\", self_type, trait_)?\n+                    write!(f, \"&lt;{} as {}&gt;::\", self_type.print(), trait_.print())?\n                 } else {\n-                    write!(f, \"{}::\", self_type)?\n+                    write!(f, \"{}::\", self_type.print())?\n                 }\n             };\n             match *trait_ {\n@@ -818,331 +794,381 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n     }\n }\n \n-impl fmt::Display for clean::Type {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt_type(self, f, false)\n+impl clean::Type {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            fmt_type(self, f, false)\n+        })\n     }\n }\n \n-fn fmt_impl(i: &clean::Impl,\n-            f: &mut fmt::Formatter<'_>,\n-            link_trait: bool,\n-            use_absolute: bool) -> fmt::Result {\n-    if f.alternate() {\n-        write!(f, \"impl{:#} \", i.generics)?;\n-    } else {\n-        write!(f, \"impl{} \", i.generics)?;\n+impl clean::Impl {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        self.print_inner(true, false)\n     }\n \n-    if let Some(ref ty) = i.trait_ {\n-        if i.polarity == Some(clean::ImplPolarity::Negative) {\n-            write!(f, \"!\")?;\n-        }\n+    fn print_inner(\n+        &self,\n+        link_trait: bool,\n+        use_absolute: bool,\n+    ) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            if f.alternate() {\n+                write!(f, \"impl{:#} \", self.generics.print())?;\n+            } else {\n+                write!(f, \"impl{} \", self.generics.print())?;\n+            }\n \n-        if link_trait {\n-            fmt::Display::fmt(ty, f)?;\n-        } else {\n-            match *ty {\n-                clean::ResolvedPath { param_names: None, ref path, is_generic: false, .. } => {\n-                    let last = path.segments.last().unwrap();\n-                    fmt::Display::fmt(&last.name, f)?;\n-                    fmt::Display::fmt(&last.args, f)?;\n+            if let Some(ref ty) = self.trait_ {\n+                if self.polarity == Some(clean::ImplPolarity::Negative) {\n+                    write!(f, \"!\")?;\n                 }\n-                _ => unreachable!(),\n-            }\n-        }\n-        write!(f, \" for \")?;\n-    }\n \n-    if let Some(ref ty) = i.blanket_impl {\n-        fmt_type(ty, f, use_absolute)?;\n-    } else {\n-        fmt_type(&i.for_, f, use_absolute)?;\n-    }\n+                if link_trait {\n+                    fmt::Display::fmt(&ty.print(), f)?;\n+                } else {\n+                    match ty {\n+                        clean::ResolvedPath { param_names: None, path, is_generic: false, .. } => {\n+                            let last = path.segments.last().unwrap();\n+                            fmt::Display::fmt(&last.name, f)?;\n+                            fmt::Display::fmt(&last.args.print(), f)?;\n+                        }\n+                        _ => unreachable!(),\n+                    }\n+                }\n+                write!(f, \" for \")?;\n+            }\n \n-    fmt::Display::fmt(&WhereClause { gens: &i.generics, indent: 0, end_newline: true }, f)?;\n-    Ok(())\n-}\n+            if let Some(ref ty) = self.blanket_impl {\n+                fmt_type(ty, f, use_absolute)?;\n+            } else {\n+                fmt_type(&self.for_, f, use_absolute)?;\n+            }\n \n-impl fmt::Display for clean::Impl {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt_impl(self, f, true, false)\n+            fmt::Display::fmt(&WhereClause {\n+                gens: &self.generics,\n+                indent: 0,\n+                end_newline: true,\n+            }, f)?;\n+            Ok(())\n+        })\n     }\n }\n \n // The difference from above is that trait is not hyperlinked.\n pub fn fmt_impl_for_trait_page(i: &clean::Impl,\n                                f: &mut Buffer,\n                                use_absolute: bool) {\n-    f.with_formatter(|f| fmt_impl(i, f, false, use_absolute))\n+    f.from_display(i.print_inner(false, use_absolute))\n }\n \n-impl fmt::Display for clean::Arguments {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        for (i, input) in self.values.iter().enumerate() {\n-            if !input.name.is_empty() {\n-                write!(f, \"{}: \", input.name)?;\n-            }\n-            if f.alternate() {\n-                write!(f, \"{:#}\", input.type_)?;\n-            } else {\n-                write!(f, \"{}\", input.type_)?;\n+impl clean::Arguments {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            for (i, input) in self.values.iter().enumerate() {\n+                if !input.name.is_empty() {\n+                    write!(f, \"{}: \", input.name)?;\n+                }\n+                if f.alternate() {\n+                    write!(f, \"{:#}\", input.type_.print())?;\n+                } else {\n+                    write!(f, \"{}\", input.type_.print())?;\n+                }\n+                if i + 1 < self.values.len() { write!(f, \", \")?; }\n             }\n-            if i + 1 < self.values.len() { write!(f, \", \")?; }\n-        }\n-        Ok(())\n+            Ok(())\n+        })\n     }\n }\n \n-impl fmt::Display for clean::FunctionRetTy {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            clean::Return(clean::Tuple(ref tys)) if tys.is_empty() => Ok(()),\n-            clean::Return(ref ty) if f.alternate() => write!(f, \" -> {:#}\", ty),\n-            clean::Return(ref ty) => write!(f, \" -&gt; {}\", ty),\n-            clean::DefaultReturn => Ok(()),\n-        }\n+impl clean::FunctionRetTy {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match self {\n+                clean::Return(clean::Tuple(tys)) if tys.is_empty() => Ok(()),\n+                clean::Return(ty) if f.alternate() => write!(f, \" -> {:#}\", ty.print()),\n+                clean::Return(ty) => write!(f, \" -&gt; {}\", ty.print()),\n+                clean::DefaultReturn => Ok(()),\n+            }\n+        })\n     }\n }\n \n-impl fmt::Display for clean::FnDecl {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if f.alternate() {\n-            write!(f, \"({args:#}){arrow:#}\", args = self.inputs, arrow = self.output)\n-        } else {\n-            write!(f, \"({args}){arrow}\", args = self.inputs, arrow = self.output)\n-        }\n+impl clean::BareFunctionDecl {\n+    fn print_generic_params(&self) -> impl fmt::Display + '_ {\n+        comma_sep(self.generic_params.iter().map(|g| g.print()))\n     }\n }\n \n-impl<'a> fmt::Display for Function<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let &Function { decl, header_len, indent, asyncness } = self;\n-        let amp = if f.alternate() { \"&\" } else { \"&amp;\" };\n-        let mut args = String::new();\n-        let mut args_plain = String::new();\n-        for (i, input) in decl.inputs.values.iter().enumerate() {\n-            if i == 0 {\n-                args.push_str(\"<br>\");\n+impl clean::FnDecl {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            if f.alternate() {\n+                write!(f,\n+                    \"({args:#}){arrow:#}\", args = self.inputs.print(), arrow = self.output.print())\n+            } else {\n+                write!(f,\n+                    \"({args}){arrow}\", args = self.inputs.print(), arrow = self.output.print())\n             }\n+        })\n+    }\n+}\n \n-            if let Some(selfty) = input.to_self() {\n-                match selfty {\n-                    clean::SelfValue => {\n-                        args.push_str(\"self\");\n-                        args_plain.push_str(\"self\");\n+\n+impl Function<'_> {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            let &Function { decl, header_len, indent, asyncness } = self;\n+            let amp = if f.alternate() { \"&\" } else { \"&amp;\" };\n+            let mut args = String::new();\n+            let mut args_plain = String::new();\n+            for (i, input) in decl.inputs.values.iter().enumerate() {\n+                if i == 0 {\n+                    args.push_str(\"<br>\");\n+                }\n+\n+                if let Some(selfty) = input.to_self() {\n+                    match selfty {\n+                        clean::SelfValue => {\n+                            args.push_str(\"self\");\n+                            args_plain.push_str(\"self\");\n+                        }\n+                        clean::SelfBorrowed(Some(ref lt), mtbl) => {\n+                            args.push_str(\n+                                &format!(\"{}{} {}self\", amp, lt.print(), mtbl.print_with_space()));\n+                            args_plain.push_str(\n+                                &format!(\"&{} {}self\", lt.print(), mtbl.print_with_space()));\n+                        }\n+                        clean::SelfBorrowed(None, mtbl) => {\n+                            args.push_str(&format!(\"{}{}self\", amp, mtbl.print_with_space()));\n+                            args_plain.push_str(&format!(\"&{}self\", mtbl.print_with_space()));\n+                        }\n+                        clean::SelfExplicit(ref typ) => {\n+                            if f.alternate() {\n+                                args.push_str(&format!(\"self: {:#}\", typ.print()));\n+                            } else {\n+                                args.push_str(&format!(\"self: {}\", typ.print()));\n+                            }\n+                            args_plain.push_str(&format!(\"self: {:#}\", typ.print()));\n+                        }\n                     }\n-                    clean::SelfBorrowed(Some(ref lt), mtbl) => {\n-                        args.push_str(&format!(\"{}{} {}self\", amp, *lt, MutableSpace(mtbl)));\n-                        args_plain.push_str(&format!(\"&{} {}self\", *lt, MutableSpace(mtbl)));\n+                } else {\n+                    if i > 0 {\n+                        args.push_str(\" <br>\");\n+                        args_plain.push_str(\" \");\n                     }\n-                    clean::SelfBorrowed(None, mtbl) => {\n-                        args.push_str(&format!(\"{}{}self\", amp, MutableSpace(mtbl)));\n-                        args_plain.push_str(&format!(\"&{}self\", MutableSpace(mtbl)));\n+                    if !input.name.is_empty() {\n+                        args.push_str(&format!(\"{}: \", input.name));\n+                        args_plain.push_str(&format!(\"{}: \", input.name));\n                     }\n-                    clean::SelfExplicit(ref typ) => {\n-                        if f.alternate() {\n-                            args.push_str(&format!(\"self: {:#}\", *typ));\n-                        } else {\n-                            args.push_str(&format!(\"self: {}\", *typ));\n-                        }\n-                        args_plain.push_str(&format!(\"self: {:#}\", *typ));\n+\n+                    if f.alternate() {\n+                        args.push_str(&format!(\"{:#}\", input.type_.print()));\n+                    } else {\n+                        args.push_str(&input.type_.print().to_string());\n                     }\n+                    args_plain.push_str(&format!(\"{:#}\", input.type_.print()));\n                 }\n-            } else {\n-                if i > 0 {\n-                    args.push_str(\" <br>\");\n-                    args_plain.push_str(\" \");\n-                }\n-                if !input.name.is_empty() {\n-                    args.push_str(&format!(\"{}: \", input.name));\n-                    args_plain.push_str(&format!(\"{}: \", input.name));\n-                }\n-\n-                if f.alternate() {\n-                    args.push_str(&format!(\"{:#}\", input.type_));\n-                } else {\n-                    args.push_str(&input.type_.to_string());\n+                if i + 1 < decl.inputs.values.len() {\n+                    args.push(',');\n+                    args_plain.push(',');\n                 }\n-                args_plain.push_str(&format!(\"{:#}\", input.type_));\n-            }\n-            if i + 1 < decl.inputs.values.len() {\n-                args.push(',');\n-                args_plain.push(',');\n             }\n-        }\n \n-        let args_plain = format!(\"({})\", args_plain);\n+            let args_plain = format!(\"({})\", args_plain);\n \n-        let output = if let hir::IsAsync::Async = asyncness {\n-            Cow::Owned(decl.sugared_async_return_type())\n-        } else {\n-            Cow::Borrowed(&decl.output)\n-        };\n+            let output = if let hir::IsAsync::Async = asyncness {\n+                Cow::Owned(decl.sugared_async_return_type())\n+            } else {\n+                Cow::Borrowed(&decl.output)\n+            };\n \n-        let arrow_plain = format!(\"{:#}\", &output);\n-        let arrow = if f.alternate() {\n-            format!(\"{:#}\", &output)\n-        } else {\n-            output.to_string()\n-        };\n+            let arrow_plain = format!(\"{:#}\", &output.print());\n+            let arrow = if f.alternate() {\n+                format!(\"{:#}\", &output.print())\n+            } else {\n+                output.print().to_string()\n+            };\n \n-        let declaration_len = header_len + args_plain.len() + arrow_plain.len();\n-        let output = if declaration_len > 80 {\n-            let full_pad = format!(\"<br>{}\", \"&nbsp;\".repeat(indent + 4));\n-            let close_pad = format!(\"<br>{}\", \"&nbsp;\".repeat(indent));\n-            format!(\"({args}{close}){arrow}\",\n-                    args = args.replace(\"<br>\", &full_pad),\n-                    close = close_pad,\n-                    arrow = arrow)\n-        } else {\n-            format!(\"({args}){arrow}\", args = args.replace(\"<br>\", \"\"), arrow = arrow)\n-        };\n+            let declaration_len = header_len + args_plain.len() + arrow_plain.len();\n+            let output = if declaration_len > 80 {\n+                let full_pad = format!(\"<br>{}\", \"&nbsp;\".repeat(indent + 4));\n+                let close_pad = format!(\"<br>{}\", \"&nbsp;\".repeat(indent));\n+                format!(\"({args}{close}){arrow}\",\n+                        args = args.replace(\"<br>\", &full_pad),\n+                        close = close_pad,\n+                        arrow = arrow)\n+            } else {\n+                format!(\"({args}){arrow}\", args = args.replace(\"<br>\", \"\"), arrow = arrow)\n+            };\n \n-        if f.alternate() {\n-            write!(f, \"{}\", output.replace(\"<br>\", \"\\n\"))\n-        } else {\n-            write!(f, \"{}\", output)\n-        }\n+            if f.alternate() {\n+                write!(f, \"{}\", output.replace(\"<br>\", \"\\n\"))\n+            } else {\n+                write!(f, \"{}\", output)\n+            }\n+        })\n     }\n }\n \n-impl<'a> fmt::Display for VisSpace<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self.get() {\n-            Some(clean::Public) => f.write_str(\"pub \"),\n-            Some(clean::Inherited) | None => Ok(()),\n-            Some(clean::Visibility::Crate) => write!(f, \"pub(crate) \"),\n-            Some(clean::Visibility::Restricted(did, ref path)) => {\n-                f.write_str(\"pub(\")?;\n-                if path.segments.len() != 1\n-                    || (path.segments[0].name != \"self\" && path.segments[0].name != \"super\")\n-                {\n-                    f.write_str(\"in \")?;\n+impl clean::Visibility {\n+    crate fn print_with_space(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match *self {\n+                clean::Public => f.write_str(\"pub \"),\n+                clean::Inherited => Ok(()),\n+                clean::Visibility::Crate => write!(f, \"pub(crate) \"),\n+                clean::Visibility::Restricted(did, ref path) => {\n+                    f.write_str(\"pub(\")?;\n+                    if path.segments.len() != 1\n+                        || (path.segments[0].name != \"self\" && path.segments[0].name != \"super\")\n+                    {\n+                        f.write_str(\"in \")?;\n+                    }\n+                    resolved_path(f, did, path, true, false)?;\n+                    f.write_str(\") \")\n                 }\n-                resolved_path(f, did, path, true, false)?;\n-                f.write_str(\") \")\n             }\n-        }\n+        })\n     }\n }\n \n-impl fmt::Display for UnsafetySpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.get() {\n-            hir::Unsafety::Unsafe => write!(f, \"unsafe \"),\n-            hir::Unsafety::Normal => Ok(())\n+crate trait PrintWithSpace {\n+    fn print_with_space(&self) -> &str;\n+}\n+\n+impl PrintWithSpace for hir::Unsafety {\n+    fn print_with_space(&self) -> &str {\n+        match self {\n+            hir::Unsafety::Unsafe => \"unsafe \",\n+            hir::Unsafety::Normal => \"\"\n         }\n     }\n }\n \n-impl fmt::Display for ConstnessSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.get() {\n-            hir::Constness::Const => write!(f, \"const \"),\n-            hir::Constness::NotConst => Ok(())\n+impl PrintWithSpace for hir::Constness {\n+    fn print_with_space(&self) -> &str {\n+        match self {\n+            hir::Constness::Const => \"const \",\n+            hir::Constness::NotConst => \"\"\n         }\n     }\n }\n \n-impl fmt::Display for AsyncSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {\n-            hir::IsAsync::Async => write!(f, \"async \"),\n-            hir::IsAsync::NotAsync => Ok(()),\n+impl PrintWithSpace for hir::IsAsync {\n+    fn print_with_space(&self) -> &str {\n+        match self {\n+            hir::IsAsync::Async => \"async \",\n+            hir::IsAsync::NotAsync => \"\",\n         }\n     }\n }\n \n-impl fmt::Display for clean::Import {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            clean::Import::Simple(ref name, ref src) => {\n-                if *name == src.path.last_name() {\n-                    write!(f, \"use {};\", *src)\n-                } else {\n-                    write!(f, \"use {} as {};\", *src, *name)\n+impl clean::Import {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match *self {\n+                clean::Import::Simple(ref name, ref src) => {\n+                    if *name == src.path.last_name() {\n+                        write!(f, \"use {};\", src.print())\n+                    } else {\n+                        write!(f, \"use {} as {};\", src.print(), *name)\n+                    }\n                 }\n-            }\n-            clean::Import::Glob(ref src) => {\n-                if src.path.segments.is_empty() {\n-                    write!(f, \"use *;\")\n-                } else {\n-                    write!(f, \"use {}::*;\", *src)\n+                clean::Import::Glob(ref src) => {\n+                    if src.path.segments.is_empty() {\n+                        write!(f, \"use *;\")\n+                    } else {\n+                        write!(f, \"use {}::*;\", src.print())\n+                    }\n                 }\n             }\n-        }\n+        })\n     }\n }\n \n-impl fmt::Display for clean::ImportSource {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.did {\n-            Some(did) => resolved_path(f, did, &self.path, true, false),\n-            _ => {\n-                for (i, seg) in self.path.segments.iter().enumerate() {\n-                    if i > 0 {\n-                        write!(f, \"::\")?\n+impl clean::ImportSource {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match self.did {\n+                Some(did) => resolved_path(f, did, &self.path, true, false),\n+                _ => {\n+                    for (i, seg) in self.path.segments.iter().enumerate() {\n+                        if i > 0 {\n+                            write!(f, \"::\")?\n+                        }\n+                        write!(f, \"{}\", seg.name)?;\n                     }\n-                    write!(f, \"{}\", seg.name)?;\n+                    Ok(())\n                 }\n-                Ok(())\n             }\n-        }\n+        })\n     }\n }\n \n-impl fmt::Display for clean::TypeBinding {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.name)?;\n-        match self.kind {\n-            clean::TypeBindingKind::Equality { ref ty } => {\n-                if f.alternate() {\n-                    write!(f, \" = {:#}\", ty)?;\n-                } else {\n-                    write!(f, \" = {}\", ty)?;\n-                }\n-            }\n-            clean::TypeBindingKind::Constraint { ref bounds } => {\n-                if !bounds.is_empty() {\n+impl clean::TypeBinding {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            f.write_str(&self.name)?;\n+            match self.kind {\n+                clean::TypeBindingKind::Equality { ref ty } => {\n                     if f.alternate() {\n-                        write!(f, \": {:#}\", GenericBounds(bounds))?;\n+                        write!(f, \" = {:#}\", ty.print())?;\n                     } else {\n-                        write!(f, \":&nbsp;{}\", GenericBounds(bounds))?;\n+                        write!(f, \" = {}\", ty.print())?;\n+                    }\n+                }\n+                clean::TypeBindingKind::Constraint { ref bounds } => {\n+                    if !bounds.is_empty() {\n+                        if f.alternate() {\n+                            write!(f, \": {:#}\", print_generic_bounds(bounds))?;\n+                        } else {\n+                            write!(f, \":&nbsp;{}\", print_generic_bounds(bounds))?;\n+                        }\n                     }\n                 }\n             }\n-        }\n-        Ok(())\n+            Ok(())\n+        })\n     }\n }\n \n-impl fmt::Display for MutableSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            MutableSpace(clean::Immutable) => Ok(()),\n-            MutableSpace(clean::Mutable) => write!(f, \"mut \"),\n+impl clean::Mutability {\n+    crate fn print_with_space(&self) -> &str {\n+        match self {\n+            clean::Immutable => \"\",\n+            clean::Mutable => \"mut \",\n         }\n     }\n }\n \n-impl fmt::Display for AbiSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+crate fn print_abi_with_space(abi: Abi) -> impl fmt::Display {\n+    display_fn(move |f| {\n         let quot = if f.alternate() { \"\\\"\" } else { \"&quot;\" };\n-        match self.0 {\n+        match abi {\n             Abi::Rust => Ok(()),\n             abi => write!(f, \"extern {0}{1}{0} \", quot, abi.name()),\n         }\n+    })\n+}\n+\n+crate fn print_default_space<'a>(v: bool) -> &'a str {\n+    if v {\n+        \"default \"\n+    } else {\n+        \"\"\n     }\n }\n \n-impl fmt::Display for DefaultSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if self.0 {\n-            write!(f, \"default \")\n-        } else {\n-            Ok(())\n-        }\n+impl clean::GenericArg {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match self {\n+                clean::GenericArg::Lifetime(lt) => fmt::Display::fmt(&lt.print(), f),\n+                clean::GenericArg::Type(ty) => fmt::Display::fmt(&ty.print(), f),\n+                clean::GenericArg::Const(ct) => fmt::Display::fmt(&ct.print(), f),\n+            }\n+        })\n     }\n }\n "}, {"sha": "5fb9afd6c49a04abd4f5c2cf7c727267c138bca9", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 7, "deletions": 32, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -46,14 +46,6 @@ pub enum ItemType {\n }\n \n \n-#[derive(Copy, Eq, PartialEq, Clone)]\n-pub enum NameSpace {\n-    Type,\n-    Value,\n-    Macro,\n-    Keyword,\n-}\n-\n impl<'a> From<&'a clean::Item> for ItemType {\n     fn from(item: &'a clean::Item) -> ItemType {\n         let inner = match item.inner {\n@@ -120,7 +112,7 @@ impl From<clean::TypeKind> for ItemType {\n }\n \n impl ItemType {\n-    pub fn css_class(&self) -> &'static str {\n+    pub fn as_str(&self) -> &'static str {\n         match *self {\n             ItemType::Module          => \"mod\",\n             ItemType::ExternCrate     => \"externcrate\",\n@@ -151,7 +143,7 @@ impl ItemType {\n         }\n     }\n \n-    pub fn name_space(&self) -> NameSpace {\n+    pub fn name_space(&self) -> &'static str {\n         match *self {\n             ItemType::Struct |\n             ItemType::Union |\n@@ -163,7 +155,7 @@ impl ItemType {\n             ItemType::AssocType |\n             ItemType::OpaqueTy |\n             ItemType::TraitAlias |\n-            ItemType::ForeignType => NameSpace::Type,\n+            ItemType::ForeignType => NAMESPACE_TYPE,\n \n             ItemType::ExternCrate |\n             ItemType::Import |\n@@ -175,41 +167,24 @@ impl ItemType {\n             ItemType::StructField |\n             ItemType::Variant |\n             ItemType::Constant |\n-            ItemType::AssocConst => NameSpace::Value,\n+            ItemType::AssocConst => NAMESPACE_VALUE,\n \n             ItemType::Macro |\n             ItemType::ProcAttribute |\n-            ItemType::ProcDerive => NameSpace::Macro,\n+            ItemType::ProcDerive => NAMESPACE_MACRO,\n \n-            ItemType::Keyword => NameSpace::Keyword,\n+            ItemType::Keyword => NAMESPACE_KEYWORD,\n         }\n     }\n }\n \n impl fmt::Display for ItemType {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.css_class().fmt(f)\n+        write!(f, \"{}\", self.as_str())\n     }\n }\n \n pub const NAMESPACE_TYPE: &'static str = \"t\";\n pub const NAMESPACE_VALUE: &'static str = \"v\";\n pub const NAMESPACE_MACRO: &'static str = \"m\";\n pub const NAMESPACE_KEYWORD: &'static str = \"k\";\n-\n-impl NameSpace {\n-    pub fn to_static_str(&self) -> &'static str {\n-        match *self {\n-            NameSpace::Type => NAMESPACE_TYPE,\n-            NameSpace::Value => NAMESPACE_VALUE,\n-            NameSpace::Macro => NAMESPACE_MACRO,\n-            NameSpace::Keyword => NAMESPACE_KEYWORD,\n-        }\n-    }\n-}\n-\n-impl fmt::Display for NameSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.to_static_str().fmt(f)\n-    }\n-}"}, {"sha": "6414241727a722b2a577b9bb02a9a6fc8b08dede", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -1,7 +1,7 @@\n use std::path::PathBuf;\n \n use crate::externalfiles::ExternalHtml;\n-use crate::html::render::SlashChecker;\n+use crate::html::render::ensure_trailing_slash;\n use crate::html::format::{Buffer, Print};\n \n #[derive(Clone)]\n@@ -180,7 +180,7 @@ pub fn render<T: Print, S: Print>(\n     css_class = page.css_class,\n     logo      = {\n         let p = format!(\"{}{}\", page.root_path, layout.krate);\n-        let p = SlashChecker(&p);\n+        let p = ensure_trailing_slash(&p);\n         if layout.logo.is_empty() {\n             format!(\"<a href='{path}index.html'>\\\n                      <div class='logo-container'>\\"}, {"sha": "9ff1e1d31197d28d8538369a788da11130d16ad9", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -752,7 +752,7 @@ impl MarkdownWithToc<'_> {\n             html::push_html(&mut s, p);\n         }\n \n-        format!(\"<nav id=\\\"TOC\\\">{}</nav>{}\", toc.into_toc(), s)\n+        format!(\"<nav id=\\\"TOC\\\">{}</nav>{}\", toc.into_toc().print(), s)\n     }\n }\n "}, {"sha": "301dddbbfb9b2e748a51b02554270d83c44fa986", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 251, "deletions": 883, "changes": 1134, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -25,20 +25,17 @@\n //! These threads are not parallelized (they haven't been a bottleneck yet), and\n //! both occur before the crate is rendered.\n \n-pub use self::ExternalLocation::*;\n-\n use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n use std::cmp::Ordering;\n use std::collections::{BTreeMap, VecDeque};\n use std::default::Default;\n use std::error;\n-use std::fmt::{self, Display, Formatter, Write as FmtWrite};\n+use std::fmt::{self, Formatter, Write as FmtWrite};\n use std::ffi::OsStr;\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n-use std::mem;\n use std::path::{PathBuf, Path, Component};\n use std::str;\n use std::sync::Arc;\n@@ -52,7 +49,7 @@ use syntax::ext::base::MacroKind;\n use syntax::source_map::FileName;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::symbol::{Symbol, sym};\n-use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::DefId;\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n use rustc::hir;\n@@ -63,11 +60,10 @@ use crate::clean::{self, AttributesExt, Deprecation, GetDefId, SelfTy, Mutabilit\n use crate::config::RenderOptions;\n use crate::docfs::{DocFS, ErrorStorage, PathError};\n use crate::doctree;\n-use crate::fold::DocFolder;\n use crate::html::escape::Escape;\n-use crate::html::format::{Buffer, AsyncSpace, ConstnessSpace};\n-use crate::html::format::{GenericBounds, WhereClause, href, AbiSpace, DefaultSpace};\n-use crate::html::format::{VisSpace, Function, UnsafetySpace, MutableSpace};\n+use crate::html::format::{Buffer, PrintWithSpace, print_abi_with_space};\n+use crate::html::format::{print_generic_bounds, WhereClause, href, print_default_space};\n+use crate::html::format::{Function};\n use crate::html::format::fmt_impl_for_trait_page;\n use crate::html::item_type::ItemType;\n use crate::html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine, ErrorCodes, IdMap};\n@@ -79,19 +75,22 @@ use minifier;\n #[cfg(test)]\n mod tests;\n \n+mod cache;\n+\n+use cache::Cache;\n+crate use cache::ExternalLocation::{self, *};\n+\n /// A pair of name and its optional document.\n pub type NameDoc = (String, Option<String>);\n \n-pub struct SlashChecker<'a>(pub &'a str);\n-\n-impl<'a> Display for SlashChecker<'a> {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n-        if !self.0.ends_with(\"/\") && !self.0.is_empty() {\n-            write!(f, \"{}/\", self.0)\n+crate fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n+    crate::html::format::display_fn(move |f| {\n+        if !v.ends_with(\"/\") && !v.is_empty() {\n+            write!(f, \"{}/\", v)\n         } else {\n-            write!(f, \"{}\", self.0)\n+            write!(f, \"{}\", v)\n         }\n-    }\n+    })\n }\n \n #[derive(Debug)]\n@@ -106,7 +105,7 @@ impl error::Error for Error {\n     }\n }\n \n-impl Display for Error {\n+impl std::fmt::Display for Error {\n     fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n         let file = self.file.display().to_string();\n         if file.is_empty() {\n@@ -165,13 +164,10 @@ struct Context {\n     /// real location of an item. This is used to allow external links to\n     /// publicly reused items to redirect to the right location.\n     pub render_redirect_pages: bool,\n-    pub codes: ErrorCodes,\n-    /// The default edition used to parse doctests.\n-    pub edition: Edition,\n     /// The map used to ensure all generated 'id=' attributes are unique.\n     id_map: Rc<RefCell<IdMap>>,\n     pub shared: Arc<SharedContext>,\n-    playground: Option<markdown::Playground>,\n+    pub cache: Arc<Cache>,\n }\n \n crate struct SharedContext {\n@@ -210,6 +206,30 @@ crate struct SharedContext {\n     pub generate_redirect_pages: bool,\n     /// The fs handle we are working with.\n     pub fs: DocFS,\n+    /// The default edition used to parse doctests.\n+    pub edition: Edition,\n+    pub codes: ErrorCodes,\n+    playground: Option<markdown::Playground>,\n+}\n+\n+impl Context {\n+    fn path(&self, filename: &str) -> PathBuf {\n+        // We use splitn vs Path::extension here because we might get a filename\n+        // like `style.min.css` and we want to process that into\n+        // `style-suffix.min.css`.  Path::extension would just return `css`\n+        // which would result in `style.min-suffix.css` which isn't what we\n+        // want.\n+        let mut iter = filename.splitn(2, '.');\n+        let base = iter.next().unwrap();\n+        let ext = iter.next().unwrap();\n+        let filename = format!(\n+            \"{}{}.{}\",\n+            base,\n+            self.shared.resource_suffix,\n+            ext,\n+        );\n+        self.dst.join(&filename)\n+    }\n }\n \n impl SharedContext {\n@@ -222,9 +242,7 @@ impl SharedContext {\n \n         Ok(())\n     }\n-}\n \n-impl SharedContext {\n     /// Based on whether the `collapse-docs` pass was run, return either the `doc_value` or the\n     /// `collapsed_doc_value` of the given item.\n     pub fn maybe_collapsed_doc_value<'a>(&self, item: &'a clean::Item) -> Option<Cow<'a, str>> {\n@@ -236,16 +254,6 @@ impl SharedContext {\n     }\n }\n \n-/// Indicates where an external crate can be found.\n-pub enum ExternalLocation {\n-    /// Remote URL root of the external crate\n-    Remote(String),\n-    /// This external crate can be found in the local doc/ folder\n-    Local,\n-    /// The external crate could not be found.\n-    Unknown,\n-}\n-\n /// Metadata about implementations for a type or trait.\n #[derive(Clone, Debug)]\n pub struct Impl {\n@@ -265,106 +273,6 @@ impl Impl {\n     }\n }\n \n-/// This cache is used to store information about the `clean::Crate` being\n-/// rendered in order to provide more useful documentation. This contains\n-/// information like all implementors of a trait, all traits a type implements,\n-/// documentation for all known traits, etc.\n-///\n-/// This structure purposefully does not implement `Clone` because it's intended\n-/// to be a fairly large and expensive structure to clone. Instead this adheres\n-/// to `Send` so it may be stored in a `Arc` instance and shared among the various\n-/// rendering threads.\n-#[derive(Default)]\n-pub struct Cache {\n-    /// Maps a type ID to all known implementations for that type. This is only\n-    /// recognized for intra-crate `ResolvedPath` types, and is used to print\n-    /// out extra documentation on the page of an enum/struct.\n-    ///\n-    /// The values of the map are a list of implementations and documentation\n-    /// found on that implementation.\n-    pub impls: FxHashMap<DefId, Vec<Impl>>,\n-\n-    /// Maintains a mapping of local crate `NodeId`s to the fully qualified name\n-    /// and \"short type description\" of that node. This is used when generating\n-    /// URLs when a type is being linked to. External paths are not located in\n-    /// this map because the `External` type itself has all the information\n-    /// necessary.\n-    pub paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n-\n-    /// Similar to `paths`, but only holds external paths. This is only used for\n-    /// generating explicit hyperlinks to other crates.\n-    pub external_paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n-\n-    /// Maps local `DefId`s of exported types to fully qualified paths.\n-    /// Unlike 'paths', this mapping ignores any renames that occur\n-    /// due to 'use' statements.\n-    ///\n-    /// This map is used when writing out the special 'implementors'\n-    /// javascript file. By using the exact path that the type\n-    /// is declared with, we ensure that each path will be identical\n-    /// to the path used if the corresponding type is inlined. By\n-    /// doing this, we can detect duplicate impls on a trait page, and only display\n-    /// the impl for the inlined type.\n-    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n-\n-    /// This map contains information about all known traits of this crate.\n-    /// Implementations of a crate should inherit the documentation of the\n-    /// parent trait if no extra documentation is specified, and default methods\n-    /// should show up in documentation about trait implementations.\n-    pub traits: FxHashMap<DefId, clean::Trait>,\n-\n-    /// When rendering traits, it's often useful to be able to list all\n-    /// implementors of the trait, and this mapping is exactly, that: a mapping\n-    /// of trait ids to the list of known implementors of the trait\n-    pub implementors: FxHashMap<DefId, Vec<Impl>>,\n-\n-    /// Cache of where external crate documentation can be found.\n-    pub extern_locations: FxHashMap<CrateNum, (String, PathBuf, ExternalLocation)>,\n-\n-    /// Cache of where documentation for primitives can be found.\n-    pub primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n-\n-    // Note that external items for which `doc(hidden)` applies to are shown as\n-    // non-reachable while local items aren't. This is because we're reusing\n-    // the access levels from the privacy check pass.\n-    pub access_levels: AccessLevels<DefId>,\n-\n-    /// The version of the crate being documented, if given from the `--crate-version` flag.\n-    pub crate_version: Option<String>,\n-\n-    // Private fields only used when initially crawling a crate to build a cache\n-\n-    stack: Vec<String>,\n-    parent_stack: Vec<DefId>,\n-    parent_is_trait_impl: bool,\n-    search_index: Vec<IndexItem>,\n-    stripped_mod: bool,\n-    deref_trait_did: Option<DefId>,\n-    deref_mut_trait_did: Option<DefId>,\n-    owned_box_did: Option<DefId>,\n-    masked_crates: FxHashSet<CrateNum>,\n-\n-    // In rare case where a structure is defined in one module but implemented\n-    // in another, if the implementing module is parsed before defining module,\n-    // then the fully qualified name of the structure isn't presented in `paths`\n-    // yet when its implementation methods are being indexed. Caches such methods\n-    // and their parent id here and indexes them at the end of crate parsing.\n-    orphan_impl_items: Vec<(DefId, clean::Item)>,\n-\n-    // Similarly to `orphan_impl_items`, sometimes trait impls are picked up\n-    // even though the trait itself is not exported. This can happen if a trait\n-    // was defined in function/expression scope, since the impl will be picked\n-    // up by `collect-trait-impls` but the trait won't be scraped out in the HIR\n-    // crawl. In order to prevent crashes when looking for spotlight traits or\n-    // when gathering trait documentation on a type, hold impls here while\n-    // folding and add them to the cache later on if we find the trait.\n-    orphan_trait_impls: Vec<(DefId, FxHashSet<DefId>, Impl)>,\n-\n-    /// Aliases added through `#[doc(alias = \"...\")]`. Since a few items can have the same alias,\n-    /// we need the alias element to have an array of items.\n-    aliases: FxHashMap<String, Vec<IndexItem>>,\n-}\n-\n /// Temporary storage for data obtained during `RustdocVisitor::clean()`.\n /// Later on moved into `CACHE_KEY`.\n #[derive(Default)]\n@@ -520,29 +428,6 @@ pub fn run(mut krate: clean::Crate,\n         _ => PathBuf::new(),\n     };\n     let mut errors = Arc::new(ErrorStorage::new());\n-    let mut scx = SharedContext {\n-        collapsed: krate.collapsed,\n-        src_root,\n-        include_sources: true,\n-        local_sources: Default::default(),\n-        issue_tracker_base_url: None,\n-        layout: layout::Layout {\n-            logo: String::new(),\n-            favicon: String::new(),\n-            external_html,\n-            krate: krate.name.clone(),\n-            css_file_extension: extension_css,\n-            generate_search_filter,\n-        },\n-        created_dirs: Default::default(),\n-        sort_modules_alphabetically,\n-        themes,\n-        resource_suffix,\n-        static_root_path,\n-        generate_redirect_pages,\n-        fs: DocFS::new(&errors),\n-    };\n-\n     // If user passed in `--playground-url` arg, we fill in crate name here\n     let mut playground = None;\n     if let Some(url) = playground_url {\n@@ -551,17 +436,27 @@ pub fn run(mut krate: clean::Crate,\n             url,\n         });\n     }\n+    let mut layout = layout::Layout {\n+        logo: String::new(),\n+        favicon: String::new(),\n+        external_html,\n+        krate: krate.name.clone(),\n+        css_file_extension: extension_css,\n+        generate_search_filter,\n+    };\n+    let mut issue_tracker_base_url = None;\n+    let mut include_sources = true;\n \n     // Crawl the crate attributes looking for attributes which control how we're\n     // going to emit HTML\n     if let Some(attrs) = krate.module.as_ref().map(|m| &m.attrs) {\n         for attr in attrs.lists(sym::doc) {\n             match (attr.name_or_empty(), attr.value_str()) {\n                 (sym::html_favicon_url, Some(s)) => {\n-                    scx.layout.favicon = s.to_string();\n+                    layout.favicon = s.to_string();\n                 }\n                 (sym::html_logo_url, Some(s)) => {\n-                    scx.layout.logo = s.to_string();\n+                    layout.logo = s.to_string();\n                 }\n                 (sym::html_playground_url, Some(s)) => {\n                     playground = Some(markdown::Playground {\n@@ -570,122 +465,62 @@ pub fn run(mut krate: clean::Crate,\n                     });\n                 }\n                 (sym::issue_tracker_base_url, Some(s)) => {\n-                    scx.issue_tracker_base_url = Some(s.to_string());\n+                    issue_tracker_base_url = Some(s.to_string());\n                 }\n                 (sym::html_no_source, None) if attr.is_word() => {\n-                    scx.include_sources = false;\n+                    include_sources = false;\n                 }\n                 _ => {}\n             }\n         }\n     }\n+    let mut scx = SharedContext {\n+        collapsed: krate.collapsed,\n+        src_root,\n+        include_sources,\n+        local_sources: Default::default(),\n+        issue_tracker_base_url,\n+        layout,\n+        created_dirs: Default::default(),\n+        sort_modules_alphabetically,\n+        themes,\n+        resource_suffix,\n+        static_root_path,\n+        generate_redirect_pages,\n+        fs: DocFS::new(&errors),\n+        edition,\n+        codes: ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build()),\n+        playground,\n+    };\n+\n     let dst = output;\n     scx.ensure_dir(&dst)?;\n     krate = sources::render(&dst, &mut scx, krate)?;\n+    let (new_crate, index, cache) = Cache::from_krate(\n+        renderinfo,\n+        &extern_html_root_urls,\n+        &dst,\n+        krate,\n+    );\n+    krate = new_crate;\n+    let cache = Arc::new(cache);\n     let mut cx = Context {\n         current: Vec::new(),\n         dst,\n         render_redirect_pages: false,\n-        codes: ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build()),\n-        edition,\n         id_map: Rc::new(RefCell::new(id_map)),\n         shared: Arc::new(scx),\n-        playground,\n-    };\n-\n-    // Crawl the crate to build various caches used for the output\n-    let RenderInfo {\n-        inlined: _,\n-        external_paths,\n-        exact_paths,\n-        access_levels,\n-        deref_trait_did,\n-        deref_mut_trait_did,\n-        owned_box_did,\n-    } = renderinfo;\n-\n-    let external_paths = external_paths.into_iter()\n-        .map(|(k, (v, t))| (k, (v, ItemType::from(t))))\n-        .collect();\n-\n-    let mut cache = Cache {\n-        impls: Default::default(),\n-        external_paths,\n-        exact_paths,\n-        paths: Default::default(),\n-        implementors: Default::default(),\n-        stack: Vec::new(),\n-        parent_stack: Vec::new(),\n-        search_index: Vec::new(),\n-        parent_is_trait_impl: false,\n-        extern_locations: Default::default(),\n-        primitive_locations: Default::default(),\n-        stripped_mod: false,\n-        access_levels,\n-        crate_version: krate.version.take(),\n-        orphan_impl_items: Vec::new(),\n-        orphan_trait_impls: Vec::new(),\n-        traits: krate.external_traits.replace(Default::default()),\n-        deref_trait_did,\n-        deref_mut_trait_did,\n-        owned_box_did,\n-        masked_crates: mem::take(&mut krate.masked_crates),\n-        aliases: Default::default(),\n+        cache: cache.clone(),\n     };\n \n-    // Cache where all our extern crates are located\n-    for &(n, ref e) in &krate.externs {\n-        let src_root = match e.src {\n-            FileName::Real(ref p) => match p.parent() {\n-                Some(p) => p.to_path_buf(),\n-                None => PathBuf::new(),\n-            },\n-            _ => PathBuf::new(),\n-        };\n-        let extern_url = extern_html_root_urls.get(&e.name).map(|u| &**u);\n-        cache.extern_locations.insert(n, (e.name.clone(), src_root,\n-                                          extern_location(e, extern_url, &cx.dst)));\n-\n-        let did = DefId { krate: n, index: CRATE_DEF_INDEX };\n-        cache.external_paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n-    }\n-\n-    // Cache where all known primitives have their documentation located.\n-    //\n-    // Favor linking to as local extern as possible, so iterate all crates in\n-    // reverse topological order.\n-    for &(_, ref e) in krate.externs.iter().rev() {\n-        for &(def_id, prim, _) in &e.primitives {\n-            cache.primitive_locations.insert(prim, def_id);\n-        }\n-    }\n-    for &(def_id, prim, _) in &krate.primitives {\n-        cache.primitive_locations.insert(prim, def_id);\n-    }\n-\n-    cache.stack.push(krate.name.clone());\n-    krate = cache.fold_crate(krate);\n-\n-    for (trait_did, dids, impl_) in cache.orphan_trait_impls.drain(..) {\n-        if cache.traits.contains_key(&trait_did) {\n-            for did in dids {\n-                cache.impls.entry(did).or_insert(vec![]).push(impl_.clone());\n-            }\n-        }\n-    }\n-\n-    // Build our search index\n-    let index = build_index(&krate, &mut cache);\n-\n     // Freeze the cache now that the index has been built. Put an Arc into TLS\n     // for future parallelization opportunities\n-    let cache = Arc::new(cache);\n     CACHE_KEY.with(|v| *v.borrow_mut() = cache.clone());\n     CURRENT_DEPTH.with(|s| s.set(0));\n \n     // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n     Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n-    write_shared(&cx, &krate, &*cache, index, &md_opts, diag)?;\n+    write_shared(&cx, &krate, index, &md_opts, diag)?;\n     Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(false);\n \n     // And finally render the whole crate's documentation\n@@ -700,80 +535,9 @@ pub fn run(mut krate: clean::Crate,\n     }\n }\n \n-/// Builds the search index from the collected metadata\n-fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n-    let mut nodeid_to_pathid = FxHashMap::default();\n-    let mut crate_items = Vec::with_capacity(cache.search_index.len());\n-    let mut crate_paths = Vec::<Json>::new();\n-\n-    let Cache { ref mut search_index,\n-                ref orphan_impl_items,\n-                ref mut paths, .. } = *cache;\n-\n-    // Attach all orphan items to the type's definition if the type\n-    // has since been learned.\n-    for &(did, ref item) in orphan_impl_items {\n-        if let Some(&(ref fqp, _)) = paths.get(&did) {\n-            search_index.push(IndexItem {\n-                ty: item.type_(),\n-                name: item.name.clone().unwrap(),\n-                path: fqp[..fqp.len() - 1].join(\"::\"),\n-                desc: shorten(plain_summary_line(item.doc_value())),\n-                parent: Some(did),\n-                parent_idx: None,\n-                search_type: get_index_search_type(&item),\n-            });\n-        }\n-    }\n-\n-    // Reduce `NodeId` in paths into smaller sequential numbers,\n-    // and prune the paths that do not appear in the index.\n-    let mut lastpath = String::new();\n-    let mut lastpathid = 0usize;\n-\n-    for item in search_index {\n-        item.parent_idx = item.parent.map(|nodeid| {\n-            if nodeid_to_pathid.contains_key(&nodeid) {\n-                *nodeid_to_pathid.get(&nodeid).unwrap()\n-            } else {\n-                let pathid = lastpathid;\n-                nodeid_to_pathid.insert(nodeid, pathid);\n-                lastpathid += 1;\n-\n-                let &(ref fqp, short) = paths.get(&nodeid).unwrap();\n-                crate_paths.push(((short as usize), fqp.last().unwrap().clone()).to_json());\n-                pathid\n-            }\n-        });\n-\n-        // Omit the parent path if it is same to that of the prior item.\n-        if lastpath == item.path {\n-            item.path.clear();\n-        } else {\n-            lastpath = item.path.clone();\n-        }\n-        crate_items.push(item.to_json());\n-    }\n-\n-    let crate_doc = krate.module.as_ref().map(|module| {\n-        shorten(plain_summary_line(module.doc_value()))\n-    }).unwrap_or(String::new());\n-\n-    let mut crate_data = BTreeMap::new();\n-    crate_data.insert(\"doc\".to_owned(), Json::String(crate_doc));\n-    crate_data.insert(\"i\".to_owned(), Json::Array(crate_items));\n-    crate_data.insert(\"p\".to_owned(), Json::Array(crate_paths));\n-\n-    // Collect the index into a string\n-    format!(\"searchIndex[{}] = {};\",\n-            as_json(&krate.name),\n-            Json::Object(crate_data))\n-}\n-\n fn write_shared(\n     cx: &Context,\n     krate: &clean::Crate,\n-    cache: &Cache,\n     search_index: String,\n     options: &RenderOptions,\n     diag: &errors::Handler,\n@@ -786,13 +550,13 @@ fn write_shared(\n     // Add all the static files. These may already exist, but we just\n     // overwrite them anyway to make sure that they're fresh and up-to-date.\n \n-    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"rustdoc{}.css\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.path(\"rustdoc.css\"),\n                  static_files::RUSTDOC_CSS,\n                  options.enable_minification)?;\n-    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"settings{}.css\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.path(\"settings.css\"),\n                  static_files::SETTINGS_CSS,\n                  options.enable_minification)?;\n-    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"noscript{}.css\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.path(\"noscript.css\"),\n                  static_files::NOSCRIPT_CSS,\n                  options.enable_minification)?;\n \n@@ -804,34 +568,25 @@ fn write_shared(\n         let content = try_err!(fs::read(&entry), &entry);\n         let theme = try_none!(try_none!(entry.file_stem(), &entry).to_str(), &entry);\n         let extension = try_none!(try_none!(entry.extension(), &entry).to_str(), &entry);\n-        cx.shared.fs.write(\n-            cx.dst.join(format!(\"{}{}.{}\", theme, cx.shared.resource_suffix, extension)),\n-            content.as_slice())?;\n+        cx.shared.fs.write(cx.path(&format!(\"{}.{}\", theme, extension)), content.as_slice())?;\n         themes.insert(theme.to_owned());\n     }\n \n     let write = |p, c| { cx.shared.fs.write(p, c) };\n     if (*cx.shared).layout.logo.is_empty() {\n-        write(cx.dst.join(&format!(\"rust-logo{}.png\", cx.shared.resource_suffix)),\n-              static_files::RUST_LOGO)?;\n+        write(cx.path(\"rust-log.png\"), static_files::RUST_LOGO)?;\n     }\n     if (*cx.shared).layout.favicon.is_empty() {\n-        write(cx.dst.join(&format!(\"favicon{}.ico\", cx.shared.resource_suffix)),\n-              static_files::RUST_FAVICON)?;\n-    }\n-    write(cx.dst.join(&format!(\"brush{}.svg\", cx.shared.resource_suffix)),\n-          static_files::BRUSH_SVG)?;\n-    write(cx.dst.join(&format!(\"wheel{}.svg\", cx.shared.resource_suffix)),\n-          static_files::WHEEL_SVG)?;\n-    write(cx.dst.join(&format!(\"down-arrow{}.svg\", cx.shared.resource_suffix)),\n-          static_files::DOWN_ARROW_SVG)?;\n-    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"light{}.css\", cx.shared.resource_suffix)),\n-                 static_files::themes::LIGHT,\n-                 options.enable_minification)?;\n+        write(cx.path(\"favicon.ico\"), static_files::RUST_FAVICON)?;\n+    }\n+    write(cx.path(\"brush.svg\"), static_files::BRUSH_SVG)?;\n+    write(cx.path(\"wheel.svg\"), static_files::WHEEL_SVG)?;\n+    write(cx.path(\"down-arrow.svg\"), static_files::DOWN_ARROW_SVG)?;\n+    write_minify(&cx.shared.fs,\n+        cx.path(\"light.css\"), static_files::themes::LIGHT, options.enable_minification)?;\n     themes.insert(\"light\".to_owned());\n-    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"dark{}.css\", cx.shared.resource_suffix)),\n-                 static_files::themes::DARK,\n-                 options.enable_minification)?;\n+    write_minify(&cx.shared.fs,\n+        cx.path(\"dark.css\"), static_files::themes::DARK, options.enable_minification)?;\n     themes.insert(\"dark\".to_owned());\n \n     let mut themes: Vec<&String> = themes.iter().collect();\n@@ -894,40 +649,40 @@ themePicker.onblur = handleThemeButtonsBlur;\n           theme_js.as_bytes()\n     )?;\n \n-    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"main{}.js\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.path(\"main.js\"),\n                  static_files::MAIN_JS,\n                  options.enable_minification)?;\n-    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"settings{}.js\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.path(\"settings.js\"),\n                  static_files::SETTINGS_JS,\n                  options.enable_minification)?;\n     if cx.shared.include_sources {\n         write_minify(\n             &cx.shared.fs,\n-            cx.dst.join(&format!(\"source-script{}.js\", cx.shared.resource_suffix)),\n+            cx.path(\"source-script.js\"),\n             static_files::sidebar::SOURCE_SCRIPT,\n             options.enable_minification)?;\n     }\n \n     {\n         write_minify(\n             &cx.shared.fs,\n-            cx.dst.join(&format!(\"storage{}.js\", cx.shared.resource_suffix)),\n+            cx.path(\"storage.js\"),\n             &format!(\"var resourcesSuffix = \\\"{}\\\";{}\",\n                      cx.shared.resource_suffix,\n                      static_files::STORAGE_JS),\n             options.enable_minification)?;\n     }\n \n     if let Some(ref css) = cx.shared.layout.css_file_extension {\n-        let out = cx.dst.join(&format!(\"theme{}.css\", cx.shared.resource_suffix));\n+        let out = cx.path(\"theme.css\");\n         let buffer = try_err!(fs::read_to_string(css), css);\n         if !options.enable_minification {\n             cx.shared.fs.write(&out, &buffer)?;\n         } else {\n             write_minify(&cx.shared.fs, out, &buffer, options.enable_minification)?;\n         }\n     }\n-    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"normalize{}.css\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.path(\"normalize.css\"),\n                  static_files::NORMALIZE_CSS,\n                  options.enable_minification)?;\n     write(cx.dst.join(\"FiraSans-Regular.woff\"),\n@@ -1004,7 +759,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n     {\n         let (mut all_aliases, _, _) = try_err!(collect(&dst, &krate.name, \"ALIASES\", false), &dst);\n         let mut output = String::with_capacity(100);\n-        for (alias, items) in &cache.aliases {\n+        for (alias, items) in &cx.cache.aliases {\n             if items.is_empty() {\n                 continue\n             }\n@@ -1136,7 +891,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n             md_opts.output = cx.dst.clone();\n             md_opts.external_html = (*cx.shared).layout.external_html.clone();\n \n-            crate::markdown::render(index_page, md_opts, diag, cx.edition);\n+            crate::markdown::render(index_page, md_opts, diag, cx.shared.edition);\n         } else {\n             let dst = cx.dst.join(\"index.html\");\n             let page = layout::Page {\n@@ -1162,7 +917,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n                                     .iter()\n                                     .map(|s| {\n                                         format!(\"<li><a href=\\\"{}index.html\\\">{}</li>\",\n-                                                SlashChecker(s), s)\n+                                                ensure_trailing_slash(s), s)\n                                     })\n                                     .collect::<String>());\n             let v = layout::render(&cx.shared.layout,\n@@ -1174,17 +929,17 @@ themePicker.onblur = handleThemeButtonsBlur;\n \n     // Update the list of all implementors for traits\n     let dst = cx.dst.join(\"implementors\");\n-    for (&did, imps) in &cache.implementors {\n+    for (&did, imps) in &cx.cache.implementors {\n         // Private modules can leak through to this phase of rustdoc, which\n         // could contain implementations for otherwise private types. In some\n         // rare cases we could find an implementation for an item which wasn't\n         // indexed, so we just skip this step in that case.\n         //\n         // FIXME: this is a vague explanation for why this can't be a `get`, in\n         //        theory it should be...\n-        let &(ref remote_path, remote_item_type) = match cache.paths.get(&did) {\n+        let &(ref remote_path, remote_item_type) = match cx.cache.paths.get(&did) {\n             Some(p) => p,\n-            None => match cache.external_paths.get(&did) {\n+            None => match cx.cache.external_paths.get(&did) {\n                 Some(p) => p,\n                 None => continue,\n             }\n@@ -1203,7 +958,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n             if !imp.impl_item.def_id.is_local() { continue }\n             have_impls = true;\n             write!(implementors, \"{{text:{},synthetic:{},types:{}}},\",\n-                   as_json(&imp.inner_impl().to_string()),\n+                   as_json(&imp.inner_impl().print().to_string()),\n                    imp.inner_impl().synthetic,\n                    as_json(&collect_paths_for_type(imp.inner_impl().for_.clone()))).unwrap();\n         }\n@@ -1212,7 +967,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n         // Only create a js file if we have impls to add to it. If the trait is\n         // documented locally though we always create the file to avoid dead\n         // links.\n-        if !have_impls && !cache.paths.contains_key(&did) {\n+        if !have_impls && !cx.cache.paths.contains_key(&did) {\n             continue;\n         }\n \n@@ -1222,7 +977,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n         }\n         cx.shared.ensure_dir(&mydst)?;\n         mydst.push(&format!(\"{}.{}.js\",\n-                            remote_item_type.css_class(),\n+                            remote_item_type,\n                             remote_path[remote_path.len() - 1]));\n \n         let (mut all_implementors, _, _) = try_err!(collect(&mydst, &krate.name, \"implementors\",\n@@ -1326,327 +1081,6 @@ fn minify_replacer(\n     }\n }\n \n-/// Attempts to find where an external crate is located, given that we're\n-/// rendering in to the specified source destination.\n-fn extern_location(e: &clean::ExternalCrate, extern_url: Option<&str>, dst: &Path)\n-    -> ExternalLocation\n-{\n-    // See if there's documentation generated into the local directory\n-    let local_location = dst.join(&e.name);\n-    if local_location.is_dir() {\n-        return Local;\n-    }\n-\n-    if let Some(url) = extern_url {\n-        let mut url = url.to_string();\n-        if !url.ends_with(\"/\") {\n-            url.push('/');\n-        }\n-        return Remote(url);\n-    }\n-\n-    // Failing that, see if there's an attribute specifying where to find this\n-    // external crate\n-    e.attrs.lists(sym::doc)\n-     .filter(|a| a.check_name(sym::html_root_url))\n-     .filter_map(|a| a.value_str())\n-     .map(|url| {\n-        let mut url = url.to_string();\n-        if !url.ends_with(\"/\") {\n-            url.push('/')\n-        }\n-        Remote(url)\n-    }).next().unwrap_or(Unknown) // Well, at least we tried.\n-}\n-\n-impl DocFolder for Cache {\n-    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        if item.def_id.is_local() {\n-            debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.def_id);\n-        }\n-\n-        // If this is a stripped module,\n-        // we don't want it or its children in the search index.\n-        let orig_stripped_mod = match item.inner {\n-            clean::StrippedItem(box clean::ModuleItem(..)) => {\n-                mem::replace(&mut self.stripped_mod, true)\n-            }\n-            _ => self.stripped_mod,\n-        };\n-\n-        // If the impl is from a masked crate or references something from a\n-        // masked crate then remove it completely.\n-        if let clean::ImplItem(ref i) = item.inner {\n-            if self.masked_crates.contains(&item.def_id.krate) ||\n-               i.trait_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate)) ||\n-               i.for_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate)) {\n-                return None;\n-            }\n-        }\n-\n-        // Propagate a trait method's documentation to all implementors of the\n-        // trait.\n-        if let clean::TraitItem(ref t) = item.inner {\n-            self.traits.entry(item.def_id).or_insert_with(|| t.clone());\n-        }\n-\n-        // Collect all the implementors of traits.\n-        if let clean::ImplItem(ref i) = item.inner {\n-            if let Some(did) = i.trait_.def_id() {\n-                if i.blanket_impl.is_none() {\n-                    self.implementors.entry(did).or_default().push(Impl {\n-                        impl_item: item.clone(),\n-                    });\n-                }\n-            }\n-        }\n-\n-        // Index this method for searching later on.\n-        if let Some(ref s) = item.name {\n-            let (parent, is_inherent_impl_item) = match item.inner {\n-                clean::StrippedItem(..) => ((None, None), false),\n-                clean::AssocConstItem(..) |\n-                clean::TypedefItem(_, true) if self.parent_is_trait_impl => {\n-                    // skip associated items in trait impls\n-                    ((None, None), false)\n-                }\n-                clean::AssocTypeItem(..) |\n-                clean::TyMethodItem(..) |\n-                clean::StructFieldItem(..) |\n-                clean::VariantItem(..) => {\n-                    ((Some(*self.parent_stack.last().unwrap()),\n-                      Some(&self.stack[..self.stack.len() - 1])),\n-                     false)\n-                }\n-                clean::MethodItem(..) | clean::AssocConstItem(..) => {\n-                    if self.parent_stack.is_empty() {\n-                        ((None, None), false)\n-                    } else {\n-                        let last = self.parent_stack.last().unwrap();\n-                        let did = *last;\n-                        let path = match self.paths.get(&did) {\n-                            // The current stack not necessarily has correlation\n-                            // for where the type was defined. On the other\n-                            // hand, `paths` always has the right\n-                            // information if present.\n-                            Some(&(ref fqp, ItemType::Trait)) |\n-                            Some(&(ref fqp, ItemType::Struct)) |\n-                            Some(&(ref fqp, ItemType::Union)) |\n-                            Some(&(ref fqp, ItemType::Enum)) =>\n-                                Some(&fqp[..fqp.len() - 1]),\n-                            Some(..) => Some(&*self.stack),\n-                            None => None\n-                        };\n-                        ((Some(*last), path), true)\n-                    }\n-                }\n-                _ => ((None, Some(&*self.stack)), false)\n-            };\n-\n-            match parent {\n-                (parent, Some(path)) if is_inherent_impl_item || (!self.stripped_mod) => {\n-                    debug_assert!(!item.is_stripped());\n-\n-                    // A crate has a module at its root, containing all items,\n-                    // which should not be indexed. The crate-item itself is\n-                    // inserted later on when serializing the search-index.\n-                    if item.def_id.index != CRATE_DEF_INDEX {\n-                        self.search_index.push(IndexItem {\n-                            ty: item.type_(),\n-                            name: s.to_string(),\n-                            path: path.join(\"::\"),\n-                            desc: shorten(plain_summary_line(item.doc_value())),\n-                            parent,\n-                            parent_idx: None,\n-                            search_type: get_index_search_type(&item),\n-                        });\n-                    }\n-                }\n-                (Some(parent), None) if is_inherent_impl_item => {\n-                    // We have a parent, but we don't know where they're\n-                    // defined yet. Wait for later to index this item.\n-                    self.orphan_impl_items.push((parent, item.clone()));\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        // Keep track of the fully qualified path for this item.\n-        let pushed = match item.name {\n-            Some(ref n) if !n.is_empty() => {\n-                self.stack.push(n.to_string());\n-                true\n-            }\n-            _ => false,\n-        };\n-\n-        match item.inner {\n-            clean::StructItem(..) | clean::EnumItem(..) |\n-            clean::TypedefItem(..) | clean::TraitItem(..) |\n-            clean::FunctionItem(..) | clean::ModuleItem(..) |\n-            clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) |\n-            clean::ConstantItem(..) | clean::StaticItem(..) |\n-            clean::UnionItem(..) | clean::ForeignTypeItem |\n-            clean::MacroItem(..) | clean::ProcMacroItem(..)\n-            if !self.stripped_mod => {\n-                // Re-exported items mean that the same id can show up twice\n-                // in the rustdoc ast that we're looking at. We know,\n-                // however, that a re-exported item doesn't show up in the\n-                // `public_items` map, so we can skip inserting into the\n-                // paths map if there was already an entry present and we're\n-                // not a public item.\n-                if !self.paths.contains_key(&item.def_id) ||\n-                   self.access_levels.is_public(item.def_id)\n-                {\n-                    self.paths.insert(item.def_id,\n-                                      (self.stack.clone(), item.type_()));\n-                }\n-                self.add_aliases(&item);\n-            }\n-            // Link variants to their parent enum because pages aren't emitted\n-            // for each variant.\n-            clean::VariantItem(..) if !self.stripped_mod => {\n-                let mut stack = self.stack.clone();\n-                stack.pop();\n-                self.paths.insert(item.def_id, (stack, ItemType::Enum));\n-            }\n-\n-            clean::PrimitiveItem(..) if item.visibility.is_some() => {\n-                self.add_aliases(&item);\n-                self.paths.insert(item.def_id, (self.stack.clone(),\n-                                                item.type_()));\n-            }\n-\n-            _ => {}\n-        }\n-\n-        // Maintain the parent stack\n-        let orig_parent_is_trait_impl = self.parent_is_trait_impl;\n-        let parent_pushed = match item.inner {\n-            clean::TraitItem(..) | clean::EnumItem(..) | clean::ForeignTypeItem |\n-            clean::StructItem(..) | clean::UnionItem(..) => {\n-                self.parent_stack.push(item.def_id);\n-                self.parent_is_trait_impl = false;\n-                true\n-            }\n-            clean::ImplItem(ref i) => {\n-                self.parent_is_trait_impl = i.trait_.is_some();\n-                match i.for_ {\n-                    clean::ResolvedPath{ did, .. } => {\n-                        self.parent_stack.push(did);\n-                        true\n-                    }\n-                    ref t => {\n-                        let prim_did = t.primitive_type().and_then(|t| {\n-                            self.primitive_locations.get(&t).cloned()\n-                        });\n-                        match prim_did {\n-                            Some(did) => {\n-                                self.parent_stack.push(did);\n-                                true\n-                            }\n-                            None => false,\n-                        }\n-                    }\n-                }\n-            }\n-            _ => false\n-        };\n-\n-        // Once we've recursively found all the generics, hoard off all the\n-        // implementations elsewhere.\n-        let ret = self.fold_item_recur(item).and_then(|item| {\n-            if let clean::Item { inner: clean::ImplItem(_), .. } = item {\n-                // Figure out the id of this impl. This may map to a\n-                // primitive rather than always to a struct/enum.\n-                // Note: matching twice to restrict the lifetime of the `i` borrow.\n-                let mut dids = FxHashSet::default();\n-                if let clean::Item { inner: clean::ImplItem(ref i), .. } = item {\n-                    match i.for_ {\n-                        clean::ResolvedPath { did, .. } |\n-                        clean::BorrowedRef {\n-                            type_: box clean::ResolvedPath { did, .. }, ..\n-                        } => {\n-                            dids.insert(did);\n-                        }\n-                        ref t => {\n-                            let did = t.primitive_type().and_then(|t| {\n-                                self.primitive_locations.get(&t).cloned()\n-                            });\n-\n-                            if let Some(did) = did {\n-                                dids.insert(did);\n-                            }\n-                        }\n-                    }\n-\n-                    if let Some(generics) = i.trait_.as_ref().and_then(|t| t.generics()) {\n-                        for bound in generics {\n-                            if let Some(did) = bound.def_id() {\n-                                dids.insert(did);\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    unreachable!()\n-                };\n-                let impl_item = Impl {\n-                    impl_item: item,\n-                };\n-                if impl_item.trait_did().map_or(true, |d| self.traits.contains_key(&d)) {\n-                    for did in dids {\n-                        self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n-                    }\n-                } else {\n-                    let trait_did = impl_item.trait_did().unwrap();\n-                    self.orphan_trait_impls.push((trait_did, dids, impl_item));\n-                }\n-                None\n-            } else {\n-                Some(item)\n-            }\n-        });\n-\n-        if pushed { self.stack.pop().unwrap(); }\n-        if parent_pushed { self.parent_stack.pop().unwrap(); }\n-        self.stripped_mod = orig_stripped_mod;\n-        self.parent_is_trait_impl = orig_parent_is_trait_impl;\n-        ret\n-    }\n-}\n-\n-impl Cache {\n-    fn add_aliases(&mut self, item: &clean::Item) {\n-        if item.def_id.index == CRATE_DEF_INDEX {\n-            return\n-        }\n-        if let Some(ref item_name) = item.name {\n-            let path = self.paths.get(&item.def_id)\n-                                 .map(|p| p.0[..p.0.len() - 1].join(\"::\"))\n-                                 .unwrap_or(\"std\".to_owned());\n-            for alias in item.attrs.lists(sym::doc)\n-                                   .filter(|a| a.check_name(sym::alias))\n-                                   .filter_map(|a| a.value_str()\n-                                                    .map(|s| s.to_string().replace(\"\\\"\", \"\")))\n-                                   .filter(|v| !v.is_empty())\n-                                   .collect::<FxHashSet<_>>()\n-                                   .into_iter() {\n-                self.aliases.entry(alias)\n-                            .or_insert(Vec::with_capacity(1))\n-                            .push(IndexItem {\n-                                ty: item.type_(),\n-                                name: item_name.to_string(),\n-                                path: path.clone(),\n-                                desc: shorten(plain_summary_line(item.doc_value())),\n-                                parent: None,\n-                                parent_idx: None,\n-                                search_type: get_index_search_type(&item),\n-                            });\n-            }\n-        }\n-    }\n-}\n-\n #[derive(Debug, Eq, PartialEq, Hash)]\n struct ItemEntry {\n     url: String,\n@@ -1665,9 +1099,11 @@ impl ItemEntry {\n     }\n }\n \n-impl fmt::Display for ItemEntry {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"<a href='{}'>{}</a>\", self.url, Escape(&self.name))\n+impl ItemEntry {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        crate::html::format::display_fn(move |f| {\n+            write!(f, \"<a href='{}'>{}</a>\", self.url, Escape(&self.name))\n+        })\n     }\n }\n \n@@ -1759,7 +1195,7 @@ fn print_entries(f: &mut Buffer, e: &FxHashSet<ItemEntry>, title: &str, class: &\n                title,\n                Escape(title),\n                class,\n-               e.iter().map(|s| format!(\"<li>{}</li>\", s)).collect::<String>());\n+               e.iter().map(|s| format!(\"<li>{}</li>\", s.print())).collect::<String>());\n     }\n }\n \n@@ -1882,7 +1318,7 @@ impl Context {\n             extra_scripts: &[],\n             static_extra_scripts: &[],\n         };\n-        let sidebar = if let Some(ref version) = cache().crate_version {\n+        let sidebar = if let Some(ref version) = self.cache.crate_version {\n             format!(\"<p class='location'>Crate {}</p>\\\n                      <div class='block version'>\\\n                          <p>Version {}</p>\\\n@@ -1939,7 +1375,7 @@ impl Context {\n             title.push_str(it.name.as_ref().unwrap());\n         }\n         title.push_str(\" - Rust\");\n-        let tyname = it.type_().css_class();\n+        let tyname = it.type_();\n         let desc = if it.is_crate() {\n             format!(\"API documentation for the Rust `{}` crate.\",\n                     self.shared.layout.krate)\n@@ -1949,7 +1385,7 @@ impl Context {\n         };\n         let keywords = make_item_keywords(it);\n         let page = layout::Page {\n-            css_class: tyname,\n+            css_class: tyname.as_str(),\n             root_path: &self.root_path(),\n             static_root_path: self.shared.static_root_path.as_deref(),\n             title: &title,\n@@ -1972,7 +1408,7 @@ impl Context {\n                            &self.shared.themes)\n         } else {\n             let mut url = self.root_path();\n-            if let Some(&(ref names, ty)) = cache().paths.get(&it.def_id) {\n+            if let Some(&(ref names, ty)) = self.cache.paths.get(&it.def_id) {\n                 for name in &names[..names.len() - 1] {\n                     url.push_str(name);\n                     url.push_str(\"/\");\n@@ -2090,7 +1526,7 @@ impl Context {\n         for item in &m.items {\n             if item.is_stripped() { continue }\n \n-            let short = item.type_().css_class();\n+            let short = item.type_();\n             let myname = match item.name {\n                 None => continue,\n                 Some(ref s) => s.to_string(),\n@@ -2122,7 +1558,6 @@ impl Context {\n     fn src_href(&self, item: &clean::Item) -> Option<String> {\n         let mut root = self.root_path();\n \n-        let cache = cache();\n         let mut path = String::new();\n \n         // We can safely ignore macros from other libraries\n@@ -2138,7 +1573,7 @@ impl Context {\n                 return None;\n             }\n         } else {\n-            let (krate, src_root) = match *cache.extern_locations.get(&item.def_id.krate)? {\n+            let (krate, src_root) = match *self.cache.extern_locations.get(&item.def_id.krate)? {\n                 (ref name, ref src, Local) => (name, src),\n                 (ref name, ref src, Remote(ref s)) => {\n                     root = s.to_string();\n@@ -2267,12 +1702,12 @@ fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer) {\n         clean::TypedefItem(ref t, _) => item_typedef(buf, cx, item, t),\n         clean::MacroItem(ref m) => item_macro(buf, cx, item, m),\n         clean::ProcMacroItem(ref m) => item_proc_macro(buf, cx, item, m),\n-        clean::PrimitiveItem(ref p) => item_primitive(buf, cx, item, p),\n+        clean::PrimitiveItem(_) => item_primitive(buf, cx, item),\n         clean::StaticItem(ref i) | clean::ForeignStaticItem(ref i) =>\n             item_static(buf, cx, item, i),\n         clean::ConstantItem(ref c) => item_constant(buf, cx, item, c),\n         clean::ForeignTypeItem => item_foreign_type(buf, cx, item),\n-        clean::KeywordItem(ref k) => item_keyword(buf, cx, item, k),\n+        clean::KeywordItem(_) => item_keyword(buf, cx, item),\n         clean::OpaqueTyItem(ref e, _) => item_opaque_ty(buf, cx, item, e),\n         clean::TraitAliasItem(ref ta) => item_trait_alias(buf, cx, item, ta),\n         _ => {\n@@ -2284,8 +1719,8 @@ fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer) {\n \n fn item_path(ty: ItemType, name: &str) -> String {\n     match ty {\n-        ItemType::Module => format!(\"{}index.html\", SlashChecker(name)),\n-        _ => format!(\"{}.{}.html\", ty.css_class(), name),\n+        ItemType::Module => format!(\"{}index.html\", ensure_trailing_slash(name)),\n+        _ => format!(\"{}.{}.html\", ty, name),\n     }\n }\n \n@@ -2353,7 +1788,7 @@ fn render_markdown(\n            if is_hidden { \" hidden\" } else { \"\" },\n            prefix,\n            Markdown(md_text, &links, &mut ids,\n-           cx.codes, cx.edition, &cx.playground).to_string())\n+           cx.shared.codes, cx.shared.edition, &cx.shared.playground).to_string())\n }\n \n fn document_short(\n@@ -2571,13 +2006,13 @@ fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean:\n                 match *src {\n                     Some(ref src) => {\n                         write!(w, \"<tr><td><code>{}extern crate {} as {};\",\n-                               VisSpace(&myitem.visibility),\n+                               myitem.visibility.print_with_space(),\n                                anchor(myitem.def_id, src),\n                                name)\n                     }\n                     None => {\n                         write!(w, \"<tr><td><code>{}extern crate {};\",\n-                               VisSpace(&myitem.visibility),\n+                               myitem.visibility.print_with_space(),\n                                anchor(myitem.def_id, name))\n                     }\n                 }\n@@ -2586,7 +2021,7 @@ fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean:\n \n             clean::ImportItem(ref import) => {\n                 write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n-                       VisSpace(&myitem.visibility), *import);\n+                       myitem.visibility.print_with_space(), import.print());\n             }\n \n             _ => {\n@@ -2688,7 +2123,7 @@ fn stability_tags(item: &clean::Item) -> String {\n /// documentation.\n fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n     let mut stability = vec![];\n-    let error_codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n+    let error_codes = cx.shared.codes;\n \n     if let Some(Deprecation { note, since }) = &item.deprecation() {\n         // We display deprecation messages for #[deprecated] and #[rustc_deprecated]\n@@ -2710,7 +2145,8 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n \n         if let Some(note) = note {\n             let mut ids = cx.id_map.borrow_mut();\n-            let html = MarkdownHtml(&note, &mut ids, error_codes, cx.edition, &cx.playground);\n+            let html = MarkdownHtml(\n+                &note, &mut ids, error_codes, cx.shared.edition, &cx.shared.playground);\n             message.push_str(&format!(\": {}\", html.to_string()));\n         }\n         stability.push(format!(\"<div class='stab deprecated'>{}</div>\", message));\n@@ -2763,8 +2199,8 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n                     &unstable_reason,\n                     &mut ids,\n                     error_codes,\n-                    cx.edition,\n-                    &cx.playground,\n+                    cx.shared.edition,\n+                    &cx.shared.playground,\n                 ).to_string()\n             );\n         }\n@@ -2792,9 +2228,9 @@ fn item_constant(w: &mut Buffer, cx: &Context, it: &clean::Item, c: &clean::Cons\n     render_attributes(w, it, false);\n     write!(w, \"{vis}const \\\n                {name}: {typ}</pre>\",\n-           vis = VisSpace(&it.visibility),\n+           vis = it.visibility.print_with_space(),\n            name = it.name.as_ref().unwrap(),\n-           typ = c.type_);\n+           typ = c.type_.print());\n     document(w, cx, it)\n }\n \n@@ -2803,43 +2239,43 @@ fn item_static(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Static\n     render_attributes(w, it, false);\n     write!(w, \"{vis}static {mutability}\\\n                {name}: {typ}</pre>\",\n-           vis = VisSpace(&it.visibility),\n-           mutability = MutableSpace(s.mutability),\n+           vis = it.visibility.print_with_space(),\n+           mutability = s.mutability.print_with_space(),\n            name = it.name.as_ref().unwrap(),\n-           typ = s.type_);\n+           typ = s.type_.print());\n     document(w, cx, it)\n }\n \n fn item_function(w: &mut Buffer, cx: &Context, it: &clean::Item, f: &clean::Function) {\n     let header_len = format!(\n         \"{}{}{}{}{:#}fn {}{:#}\",\n-        VisSpace(&it.visibility),\n-        ConstnessSpace(f.header.constness),\n-        UnsafetySpace(f.header.unsafety),\n-        AsyncSpace(f.header.asyncness),\n-        AbiSpace(f.header.abi),\n+        it.visibility.print_with_space(),\n+        f.header.constness.print_with_space(),\n+        f.header.unsafety.print_with_space(),\n+        f.header.asyncness.print_with_space(),\n+        print_abi_with_space(f.header.abi),\n         it.name.as_ref().unwrap(),\n-        f.generics\n+        f.generics.print()\n     ).len();\n     write!(w, \"{}<pre class='rust fn'>\", render_spotlight_traits(it));\n     render_attributes(w, it, false);\n     write!(w,\n            \"{vis}{constness}{unsafety}{asyncness}{abi}fn \\\n            {name}{generics}{decl}{where_clause}</pre>\",\n-           vis = VisSpace(&it.visibility),\n-           constness = ConstnessSpace(f.header.constness),\n-           unsafety = UnsafetySpace(f.header.unsafety),\n-           asyncness = AsyncSpace(f.header.asyncness),\n-           abi = AbiSpace(f.header.abi),\n+           vis = it.visibility.print_with_space(),\n+           constness = f.header.constness.print_with_space(),\n+           unsafety = f.header.unsafety.print_with_space(),\n+           asyncness = f.header.asyncness.print_with_space(),\n+           abi = print_abi_with_space(f.header.abi),\n            name = it.name.as_ref().unwrap(),\n-           generics = f.generics,\n+           generics = f.generics.print(),\n            where_clause = WhereClause { gens: &f.generics, indent: 0, end_newline: true },\n            decl = Function {\n               decl: &f.decl,\n               header_len,\n               indent: 0,\n               asyncness: f.header.asyncness,\n-           });\n+           }.print());\n     document(w, cx, it)\n }\n \n@@ -2880,15 +2316,15 @@ fn bounds(t_bounds: &[clean::GenericBound], trait_alias: bool) -> String {\n             if i > 0 {\n                 bounds.push_str(\" + \");\n             }\n-            bounds.push_str(&(*p).to_string());\n+            bounds.push_str(&p.print().to_string());\n         }\n     }\n     bounds\n }\n \n fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl) -> Ordering {\n-    let lhs = format!(\"{}\", lhs.inner_impl());\n-    let rhs = format!(\"{}\", rhs.inner_impl());\n+    let lhs = format!(\"{}\", lhs.inner_impl().print());\n+    let rhs = format!(\"{}\", rhs.inner_impl().print());\n \n     // lhs and rhs are formatted as HTML, which may be unnecessary\n     name_key(&lhs).cmp(&name_key(&rhs))\n@@ -2911,11 +2347,11 @@ fn item_trait(\n         write!(w, \"<pre class='rust trait'>\");\n         render_attributes(w, it, true);\n         write!(w, \"{}{}{}trait {}{}{}\",\n-               VisSpace(&it.visibility),\n-               UnsafetySpace(t.unsafety),\n+               it.visibility.print_with_space(),\n+               t.unsafety.print_with_space(),\n                if t.is_auto { \"auto \" } else { \"\" },\n                it.name.as_ref().unwrap(),\n-               t.generics,\n+               t.generics.print(),\n                bounds);\n \n         if !t.generics.where_predicates.is_empty() {\n@@ -3047,11 +2483,9 @@ fn item_trait(\n     // If there are methods directly on this trait object, render them here.\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All);\n \n-    let cache = cache();\n-\n     let mut synthetic_types = Vec::new();\n \n-    if let Some(implementors) = cache.implementors.get(&it.def_id) {\n+    if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n         // The DefId is for the first Type found with that name. The bool is\n         // if any Types with the same name but different DefId have been found.\n         let mut implementor_dups: FxHashMap<&str, (DefId, bool)> = FxHashMap::default();\n@@ -3074,7 +2508,7 @@ fn item_trait(\n \n         let (local, foreign) = implementors.iter()\n             .partition::<Vec<_>, _>(|i| i.inner_impl().for_.def_id()\n-                                         .map_or(true, |d| cache.paths.contains_key(&d)));\n+                                         .map_or(true, |d| cx.cache.paths.contains_key(&d)));\n \n \n         let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) = local.iter()\n@@ -3139,10 +2573,10 @@ fn item_trait(\n            path = if it.def_id.is_local() {\n                cx.current.join(\"/\")\n            } else {\n-               let (ref path, _) = cache.external_paths[&it.def_id];\n+               let (ref path, _) = cx.cache.external_paths[&it.def_id];\n                path[..path.len() - 1].join(\"/\")\n            },\n-           ty = it.type_().css_class(),\n+           ty = it.type_(),\n            name = *it.name.as_ref().unwrap());\n }\n \n@@ -3173,10 +2607,10 @@ fn assoc_const(w: &mut Buffer,\n                extra: &str) {\n     write!(w, \"{}{}const <a href='{}' class=\\\"constant\\\"><b>{}</b></a>: {}\",\n            extra,\n-           VisSpace(&it.visibility),\n+           it.visibility.print_with_space(),\n            naive_assoc_href(it, link),\n            it.name.as_ref().unwrap(),\n-           ty);\n+           ty.print());\n }\n \n fn assoc_type(w: &mut Buffer, it: &clean::Item,\n@@ -3189,10 +2623,10 @@ fn assoc_type(w: &mut Buffer, it: &clean::Item,\n            naive_assoc_href(it, link),\n            it.name.as_ref().unwrap());\n     if !bounds.is_empty() {\n-        write!(w, \": {}\", GenericBounds(bounds))\n+        write!(w, \": {}\", print_generic_bounds(bounds))\n     }\n     if let Some(default) = default {\n-        write!(w, \" = {}\", default)\n+        write!(w, \" = {}\", default.print())\n     }\n }\n \n@@ -3238,14 +2672,14 @@ fn render_assoc_item(w: &mut Buffer,\n         };\n         let mut header_len = format!(\n             \"{}{}{}{}{}{:#}fn {}{:#}\",\n-            VisSpace(&meth.visibility),\n-            ConstnessSpace(header.constness),\n-            UnsafetySpace(header.unsafety),\n-            AsyncSpace(header.asyncness),\n-            DefaultSpace(meth.is_default()),\n-            AbiSpace(header.abi),\n+            meth.visibility.print_with_space(),\n+            header.constness.print_with_space(),\n+            header.unsafety.print_with_space(),\n+            header.asyncness.print_with_space(),\n+            print_default_space(meth.is_default()),\n+            print_abi_with_space(header.abi),\n             name,\n-            *g\n+            g.print()\n         ).len();\n         let (indent, end_newline) = if parent == ItemType::Trait {\n             header_len += 4;\n@@ -3257,21 +2691,21 @@ fn render_assoc_item(w: &mut Buffer,\n         write!(w, \"{}{}{}{}{}{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n                    {generics}{decl}{where_clause}\",\n                if parent == ItemType::Trait { \"    \" } else { \"\" },\n-               VisSpace(&meth.visibility),\n-               ConstnessSpace(header.constness),\n-               UnsafetySpace(header.unsafety),\n-               AsyncSpace(header.asyncness),\n-               DefaultSpace(meth.is_default()),\n-               AbiSpace(header.abi),\n+               meth.visibility.print_with_space(),\n+               header.constness.print_with_space(),\n+               header.unsafety.print_with_space(),\n+               header.asyncness.print_with_space(),\n+               print_default_space(meth.is_default()),\n+               print_abi_with_space(header.abi),\n                href = href,\n                name = name,\n-               generics = *g,\n+               generics = g.print(),\n                decl = Function {\n                    decl: d,\n                    header_len,\n                    indent,\n                    asyncness: header.asyncness,\n-               },\n+               }.print(),\n                where_clause = WhereClause {\n                    gens: g,\n                    indent,\n@@ -3340,7 +2774,7 @@ fn item_struct(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Struct\n                        id = id,\n                        ns_id = ns_id,\n                        name = field.name.as_ref().unwrap(),\n-                       ty = ty);\n+                       ty = ty.print());\n                 document(w, cx, field);\n             }\n         }\n@@ -3381,7 +2815,7 @@ fn item_union(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Union)\n                    id = id,\n                    name = name,\n                    shortty = ItemType::StructField,\n-                   ty = ty);\n+                   ty = ty.print());\n             if let Some(stability_class) = field.stability_class() {\n                 write!(w, \"<span class='stab {stab}'></span>\",\n                     stab = stability_class);\n@@ -3397,9 +2831,9 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n         write!(w, \"<pre class='rust enum'>\");\n         render_attributes(w, it, true);\n         write!(w, \"{}enum {}{}{}\",\n-               VisSpace(&it.visibility),\n+               it.visibility.print_with_space(),\n                it.name.as_ref().unwrap(),\n-               e.generics,\n+               e.generics.print(),\n                WhereClause { gens: &e.generics, indent: 0, end_newline: true });\n         if e.variants.is_empty() && !e.variants_stripped {\n             write!(w, \" {{}}\");\n@@ -3418,7 +2852,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n                                     if i > 0 {\n                                         write!(w, \",&nbsp;\")\n                                     }\n-                                    write!(w, \"{}\", *ty);\n+                                    write!(w, \"{}\", ty.print());\n                                 }\n                                 write!(w, \")\");\n                             }\n@@ -3472,7 +2906,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n                         if i > 0 {\n                             write!(w, \",&nbsp;\");\n                         }\n-                        write!(w, \"{}\", *ty);\n+                        write!(w, \"{}\", ty.print());\n                     }\n                     write!(w, \")\");\n                 }\n@@ -3510,7 +2944,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n                                id = id,\n                                ns_id = ns_id,\n                                f = field.name.as_ref().unwrap(),\n-                               t = *ty);\n+                               t = ty.print());\n                         document(w, cx, field);\n                     }\n                 }\n@@ -3586,11 +3020,11 @@ fn render_struct(w: &mut Buffer, it: &clean::Item,\n                  tab: &str,\n                  structhead: bool) {\n     write!(w, \"{}{}{}\",\n-           VisSpace(&it.visibility),\n+           it.visibility.print_with_space(),\n            if structhead {\"struct \"} else {\"\"},\n            it.name.as_ref().unwrap());\n     if let Some(g) = g {\n-        write!(w, \"{}\", g)\n+        write!(w, \"{}\", g.print())\n     }\n     match ty {\n         doctree::Plain => {\n@@ -3603,9 +3037,9 @@ fn render_struct(w: &mut Buffer, it: &clean::Item,\n                 if let clean::StructFieldItem(ref ty) = field.inner {\n                     write!(w, \"\\n{}    {}{}: {},\",\n                            tab,\n-                           VisSpace(&field.visibility),\n+                           field.visibility.print_with_space(),\n                            field.name.as_ref().unwrap(),\n-                           *ty);\n+                           ty.print());\n                     has_visible_fields = true;\n                 }\n             }\n@@ -3633,7 +3067,7 @@ fn render_struct(w: &mut Buffer, it: &clean::Item,\n                         write!(w, \"_\")\n                     }\n                     clean::StructFieldItem(ref ty) => {\n-                        write!(w, \"{}{}\", VisSpace(&field.visibility), *ty)\n+                        write!(w, \"{}{}\", field.visibility.print_with_space(), ty.print())\n                     }\n                     _ => unreachable!()\n                 }\n@@ -3660,21 +3094,21 @@ fn render_union(w: &mut Buffer, it: &clean::Item,\n                 tab: &str,\n                 structhead: bool) {\n     write!(w, \"{}{}{}\",\n-           VisSpace(&it.visibility),\n+           it.visibility.print_with_space(),\n            if structhead {\"union \"} else {\"\"},\n            it.name.as_ref().unwrap());\n     if let Some(g) = g {\n-        write!(w, \"{}\", g);\n+        write!(w, \"{}\", g.print());\n         write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true });\n     }\n \n     write!(w, \" {{\\n{}\", tab);\n     for field in fields {\n         if let clean::StructFieldItem(ref ty) = field.inner {\n             write!(w, \"    {}{}: {},\\n{}\",\n-                   VisSpace(&field.visibility),\n+                   field.visibility.print_with_space(),\n                    field.name.as_ref().unwrap(),\n-                   *ty,\n+                   ty.print(),\n                    tab);\n         }\n     }\n@@ -3716,7 +3150,7 @@ fn render_assoc_items(w: &mut Buffer,\n                       containing_item: &clean::Item,\n                       it: DefId,\n                       what: AssocItemRender<'_>) {\n-    let c = cache();\n+    let c = &cx.cache;\n     let v = match c.impls.get(&it) {\n         Some(v) => v,\n         None => return,\n@@ -3740,7 +3174,7 @@ fn render_assoc_items(w: &mut Buffer,\n                       Methods from {}&lt;Target = {}&gt;\\\n                       <a href='#deref-methods' class='anchor'></a>\\\n                     </h2>\\\n-                \", trait_, type_);\n+                \", trait_.print(), type_.print());\n                 RenderMode::ForDeref { mut_: deref_mut_ }\n             }\n         };\n@@ -3822,7 +3256,7 @@ fn render_deref_methods(w: &mut Buffer, cx: &Context, impl_: &Impl,\n         render_assoc_items(w, cx, container_item, did, what)\n     } else {\n         if let Some(prim) = target.primitive_type() {\n-            if let Some(&did) = cache().primitive_locations.get(&prim) {\n+            if let Some(&did) = cx.cache.primitive_locations.get(&prim) {\n                 render_assoc_items(w, cx, container_item, did, what);\n             }\n         }\n@@ -3856,19 +3290,15 @@ fn should_render_item(item: &clean::Item, deref_mut_: bool) -> bool {\n }\n \n fn render_spotlight_traits(item: &clean::Item) -> String {\n-    let mut out = String::new();\n-\n     match item.inner {\n         clean::FunctionItem(clean::Function { ref decl, .. }) |\n         clean::TyMethodItem(clean::TyMethod { ref decl, .. }) |\n         clean::MethodItem(clean::Method { ref decl, .. }) |\n         clean::ForeignFunctionItem(clean::Function { ref decl, .. }) => {\n-            out = spotlight_decl(decl);\n+            spotlight_decl(decl)\n         }\n-        _ => {}\n+        _ => String::new()\n     }\n-\n-    out\n }\n \n fn spotlight_decl(decl: &clean::FnDecl) -> String {\n@@ -3885,12 +3315,13 @@ fn spotlight_decl(decl: &clean::FnDecl) -> String {\n                         out.push_str(\n                             &format!(\"<h3 class=\\\"important\\\">Important traits for {}</h3>\\\n                                       <code class=\\\"content\\\">\",\n-                                     impl_.for_));\n-                        trait_.push_str(&impl_.for_.to_string());\n+                                     impl_.for_.print()));\n+                        trait_.push_str(&impl_.for_.print().to_string());\n                     }\n \n                     //use the \"where\" class here to make it small\n-                    out.push_str(&format!(\"<span class=\\\"where fmt-newline\\\">{}</span>\", impl_));\n+                    out.push_str(\n+                        &format!(\"<span class=\\\"where fmt-newline\\\">{}</span>\", impl_.print()));\n                     let t_did = impl_.trait_.def_id().unwrap();\n                     for it in &impl_.items {\n                         if let clean::TypedefItem(ref tydef, _) = it.inner {\n@@ -3927,7 +3358,7 @@ fn render_impl(w: &mut Buffer, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n             Some(ref t) => if is_on_foreign_type {\n                 get_id_for_impl_on_foreign_type(&i.inner_impl().for_, t)\n             } else {\n-                format!(\"impl-{}\", small_url_encode(&format!(\"{:#}\", t)))\n+                format!(\"impl-{}\", small_url_encode(&format!(\"{:#}\", t.print())))\n             },\n             None => \"impl\".to_string(),\n         });\n@@ -3948,7 +3379,7 @@ fn render_impl(w: &mut Buffer, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n             write!(w, \"</code>\");\n         } else {\n             write!(w, \"<h3 id='{}' class='impl'><code class='in-band'>{}</code>\",\n-                id, i.inner_impl()\n+                id, i.inner_impl().print()\n             );\n         }\n         write!(w, \"<a href='#{}' class='anchor'></a>\", id);\n@@ -3963,7 +3394,7 @@ fn render_impl(w: &mut Buffer, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n             let mut ids = cx.id_map.borrow_mut();\n             write!(w, \"<div class='docblock'>{}</div>\",\n                    Markdown(&*dox, &i.impl_item.links(), &mut ids,\n-                            cx.codes, cx.edition, &cx.playground).to_string());\n+                            cx.shared.codes, cx.shared.edition, &cx.shared.playground).to_string());\n         }\n     }\n \n@@ -3974,7 +3405,7 @@ fn render_impl(w: &mut Buffer, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n         let item_type = item.type_();\n         let name = item.name.as_ref().unwrap();\n \n-        let render_method_item: bool = match render_mode {\n+        let render_method_item = match render_mode {\n             RenderMode::Normal => true,\n             RenderMode::ForDeref { mut_: deref_mut_ } => should_render_item(&item, deref_mut_),\n         };\n@@ -3993,8 +3424,10 @@ fn render_impl(w: &mut Buffer, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n                 // Only render when the method is not static or we allow static methods\n                 if render_method_item {\n                     let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n-                    let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                    write!(w, \"<h4 id='{}' class=\\\"{}{}\\\">\", id, item_type, extra_class);\n+                    let ns_id = cx.derive_id(format!(\"{}.{}\",\n+                            name, item_type.name_space()));\n+                    write!(w, \"<h4 id='{}' class=\\\"{}{}\\\">\",\n+                        id, item_type, extra_class);\n                     write!(w, \"{}\", spotlight_decl(decl));\n                     write!(w, \"<code id='{}'>\", ns_id);\n                     render_assoc_item(w, item, link.anchor(&id), ItemType::Impl);\n@@ -4041,7 +3474,7 @@ fn render_impl(w: &mut Buffer, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n         }\n \n-        if render_method_item || render_mode == RenderMode::Normal {\n+        if render_method_item {\n             if !is_default_item {\n                 if let Some(t) = trait_ {\n                     // The trait item may have been stripped so we might not\n@@ -4073,7 +3506,7 @@ fn render_impl(w: &mut Buffer, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n         }\n     }\n \n-    let traits = &cache().traits;\n+    let traits = &cx.cache.traits;\n     let trait_ = i.trait_did().map(|did| &traits[&did]);\n \n     write!(w, \"<div class='impl-items'>\");\n@@ -4125,7 +3558,7 @@ fn item_opaque_ty(\n     render_attributes(w, it, false);\n     write!(w, \"type {}{}{where_clause} = impl {bounds};</pre>\",\n            it.name.as_ref().unwrap(),\n-           t.generics,\n+           t.generics.print(),\n            where_clause = WhereClause { gens: &t.generics, indent: 0, end_newline: true },\n            bounds = bounds(&t.bounds, false));\n \n@@ -4144,7 +3577,7 @@ fn item_trait_alias(w: &mut Buffer, cx: &Context, it: &clean::Item,\n     render_attributes(w, it, false);\n     write!(w, \"trait {}{}{} = {};</pre>\",\n            it.name.as_ref().unwrap(),\n-           t.generics,\n+           t.generics.print(),\n            WhereClause { gens: &t.generics, indent: 0, end_newline: true },\n            bounds(&t.bounds, true));\n \n@@ -4162,9 +3595,9 @@ fn item_typedef(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Typed\n     render_attributes(w, it, false);\n     write!(w, \"type {}{}{where_clause} = {type_};</pre>\",\n            it.name.as_ref().unwrap(),\n-           t.generics,\n+           t.generics.print(),\n            where_clause = WhereClause { gens: &t.generics, indent: 0, end_newline: true },\n-           type_ = t.type_);\n+           type_ = t.type_.print());\n \n     document(w, cx, it);\n \n@@ -4181,7 +3614,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n     write!(\n         w,\n         \"    {}type {};\\n}}</pre>\",\n-        VisSpace(&it.visibility),\n+        it.visibility.print_with_space(),\n         it.name.as_ref().unwrap(),\n     );\n \n@@ -4215,7 +3648,7 @@ fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer) {\n     }\n \n     if it.is_crate() {\n-        if let Some(ref version) = cache().crate_version {\n+        if let Some(ref version) = cx.cache.crate_version {\n             write!(buffer,\n                     \"<div class='block version'>\\\n                     <p>Version {}</p>\\\n@@ -4232,11 +3665,11 @@ fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer) {\n     match it.inner {\n         clean::StructItem(ref s) => sidebar_struct(buffer, it, s),\n         clean::TraitItem(ref t) => sidebar_trait(buffer, it, t),\n-        clean::PrimitiveItem(ref p) => sidebar_primitive(buffer, it, p),\n+        clean::PrimitiveItem(_) => sidebar_primitive(buffer, it),\n         clean::UnionItem(ref u) => sidebar_union(buffer, it, u),\n         clean::EnumItem(ref e) => sidebar_enum(buffer, it, e),\n-        clean::TypedefItem(ref t, _) => sidebar_typedef(buffer, it, t),\n-        clean::ModuleItem(ref m) => sidebar_module(buffer, it, &m.items),\n+        clean::TypedefItem(_, _) => sidebar_typedef(buffer, it),\n+        clean::ModuleItem(ref m) => sidebar_module(buffer, &m.items),\n         clean::ForeignTypeItem => sidebar_foreign_type(buffer, it),\n         _ => (),\n     }\n@@ -4269,7 +3702,7 @@ fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer) {\n                 relpath: '{path}'\\\n             }};</script>\",\n             name = it.name.as_ref().map(|x| &x[..]).unwrap_or(\"\"),\n-            ty = it.type_().css_class(),\n+            ty = it.type_(),\n             path = relpath);\n     if parentlen == 0 {\n         // There is no sidebar-items.js beyond the crate root path\n@@ -4301,8 +3734,7 @@ fn get_methods(\n ) -> Vec<String> {\n     i.items.iter().filter_map(|item| {\n         match item.name {\n-            // Maybe check with clean::Visibility::Public as well?\n-            Some(ref name) if !name.is_empty() && item.visibility.is_some() && item.is_method() => {\n+            Some(ref name) if !name.is_empty() && item.is_method() => {\n                 if !for_deref || should_render_item(item, deref_mut) {\n                     Some(format!(\"<a href=\\\"#{}\\\">{}</a>\",\n                                  get_next_url(used_links, format!(\"method.{}\", name)),\n@@ -4339,12 +3771,12 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n         let mut used_links = FxHashSet::default();\n \n         {\n-            let used_links_bor = Rc::new(RefCell::new(&mut used_links));\n+            let used_links_bor = &mut used_links;\n             let mut ret = v.iter()\n                            .filter(|i| i.inner_impl().trait_.is_none())\n                            .flat_map(move |i| get_methods(i.inner_impl(),\n                                                           false,\n-                                                          &mut used_links_bor.borrow_mut(), false))\n+                                                          used_links_bor, false))\n                            .collect::<Vec<_>>();\n             // We want links' order to be reproducible so we don't use unstable sort.\n             ret.sort();\n@@ -4370,9 +3802,10 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                     if let Some(impls) = inner_impl {\n                         out.push_str(\"<a class=\\\"sidebar-title\\\" href=\\\"#deref-methods\\\">\");\n                         out.push_str(&format!(\"Methods from {}&lt;Target={}&gt;\",\n-                                              Escape(&format!(\"{:#}\",\n-                                                     impl_.inner_impl().trait_.as_ref().unwrap())),\n-                                              Escape(&format!(\"{:#}\", target))));\n+                            Escape(&format!(\n+                                \"{:#}\", impl_.inner_impl().trait_.as_ref().unwrap().print()\n+                            )),\n+                            Escape(&format!(\"{:#}\", target.print()))));\n                         out.push_str(\"</a>\");\n                         let mut ret = impls.iter()\n                                            .filter(|i| i.inner_impl().trait_.is_none())\n@@ -4397,9 +3830,9 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                     .filter_map(|i| {\n                         let is_negative_impl = is_negative_impl(i.inner_impl());\n                         if let Some(ref i) = i.inner_impl().trait_ {\n-                            let i_display = format!(\"{:#}\", i);\n+                            let i_display = format!(\"{:#}\", i.print());\n                             let out = Escape(&i_display);\n-                            let encoded = small_url_encode(&format!(\"{:#}\", i));\n+                            let encoded = small_url_encode(&format!(\"{:#}\", i.print()));\n                             let generated = format!(\"<a href=\\\"#impl-{}\\\">{}{}</a>\",\n                                                     encoded,\n                                                     if is_negative_impl { \"!\" } else { \"\" },\n@@ -4471,14 +3904,17 @@ fn sidebar_struct(buf: &mut Buffer, it: &clean::Item, s: &clean::Struct) {\n }\n \n fn get_id_for_impl_on_foreign_type(for_: &clean::Type, trait_: &clean::Type) -> String {\n-    small_url_encode(&format!(\"impl-{:#}-for-{:#}\", trait_, for_))\n+    small_url_encode(&format!(\"impl-{:#}-for-{:#}\", trait_.print(), for_.print()))\n }\n \n fn extract_for_impl_name(item: &clean::Item) -> Option<(String, String)> {\n     match item.inner {\n         clean::ItemEnum::ImplItem(ref i) => {\n             if let Some(ref trait_) = i.trait_ {\n-                Some((format!(\"{:#}\", i.for_), get_id_for_impl_on_foreign_type(&i.for_, trait_)))\n+                Some((\n+                    format!(\"{:#}\", i.for_.print()),\n+                    get_id_for_impl_on_foreign_type(&i.for_, trait_),\n+                ))\n             } else {\n                 None\n             }\n@@ -4602,15 +4038,15 @@ fn sidebar_trait(buf: &mut Buffer, it: &clean::Item, t: &clean::Trait) {\n     write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar)\n }\n \n-fn sidebar_primitive(buf: &mut Buffer, it: &clean::Item, _p: &clean::PrimitiveType) {\n+fn sidebar_primitive(buf: &mut Buffer, it: &clean::Item) {\n     let sidebar = sidebar_assoc_items(it);\n \n     if !sidebar.is_empty() {\n         write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar);\n     }\n }\n \n-fn sidebar_typedef(buf: &mut Buffer, it: &clean::Item, _t: &clean::Typedef) {\n+fn sidebar_typedef(buf: &mut Buffer, it: &clean::Item) {\n     let sidebar = sidebar_assoc_items(it);\n \n     if !sidebar.is_empty() {\n@@ -4702,7 +4138,7 @@ fn item_ty_to_strs(ty: &ItemType) -> (&'static str, &'static str) {\n     }\n }\n \n-fn sidebar_module(buf: &mut Buffer, _it: &clean::Item, items: &[clean::Item]) {\n+fn sidebar_module(buf: &mut Buffer, items: &[clean::Item]) {\n     let mut sidebar = String::new();\n \n     if items.iter().any(|it| it.type_() == ItemType::ExternCrate ||\n@@ -4780,16 +4216,12 @@ fn item_proc_macro(w: &mut Buffer, cx: &Context, it: &clean::Item, m: &clean::Pr\n     document(w, cx, it)\n }\n \n-fn item_primitive(w: &mut Buffer, cx: &Context,\n-                  it: &clean::Item,\n-                  _p: &clean::PrimitiveType) {\n+fn item_primitive(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n     document(w, cx, it);\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_keyword(w: &mut Buffer, cx: &Context,\n-                it: &clean::Item,\n-                _p: &str) {\n+fn item_keyword(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n     document(w, cx, it)\n }\n \n@@ -4799,37 +4231,6 @@ fn make_item_keywords(it: &clean::Item) -> String {\n     format!(\"{}, {}\", BASIC_KEYWORDS, it.name.as_ref().unwrap())\n }\n \n-fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n-    let (all_types, ret_types) = match item.inner {\n-        clean::FunctionItem(ref f) => (&f.all_types, &f.ret_types),\n-        clean::MethodItem(ref m) => (&m.all_types, &m.ret_types),\n-        clean::TyMethodItem(ref m) => (&m.all_types, &m.ret_types),\n-        _ => return None,\n-    };\n-\n-    let inputs = all_types.iter().map(|arg| {\n-        get_index_type(&arg)\n-    }).filter(|a| a.name.is_some()).collect();\n-    let output = ret_types.iter().map(|arg| {\n-        get_index_type(&arg)\n-    }).filter(|a| a.name.is_some()).collect::<Vec<_>>();\n-    let output = if output.is_empty() {\n-        None\n-    } else {\n-        Some(output)\n-    };\n-\n-    Some(IndexItemFunctionType { inputs, output })\n-}\n-\n-fn get_index_type(clean_type: &clean::Type) -> Type {\n-    let t = Type {\n-        name: get_index_type_name(clean_type, true).map(|s| s.to_ascii_lowercase()),\n-        generics: get_generics(clean_type),\n-    };\n-    t\n-}\n-\n /// Returns a list of all paths used in the type.\n /// This is used to help deduplicate imported impls\n /// for reexported types. If any of the contained\n@@ -4887,39 +4288,6 @@ fn collect_paths_for_type(first_ty: clean::Type) -> Vec<String> {\n     out\n }\n \n-fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option<String> {\n-    match *clean_type {\n-        clean::ResolvedPath { ref path, .. } => {\n-            let segments = &path.segments;\n-            let path_segment = segments.into_iter().last().unwrap_or_else(|| panic!(\n-                \"get_index_type_name(clean_type: {:?}, accept_generic: {:?}) had length zero path\",\n-                clean_type, accept_generic\n-            ));\n-            Some(path_segment.name.clone())\n-        }\n-        clean::Generic(ref s) if accept_generic => Some(s.clone()),\n-        clean::Primitive(ref p) => Some(format!(\"{:?}\", p)),\n-        clean::BorrowedRef { ref type_, .. } => get_index_type_name(type_, accept_generic),\n-        // FIXME: add all from clean::Type.\n-        _ => None\n-    }\n-}\n-\n-fn get_generics(clean_type: &clean::Type) -> Option<Vec<String>> {\n-    clean_type.generics()\n-              .and_then(|types| {\n-                  let r = types.iter()\n-                               .filter_map(|t| get_index_type_name(t, false))\n-                               .map(|s| s.to_ascii_lowercase())\n-                               .collect::<Vec<_>>();\n-                  if r.is_empty() {\n-                      None\n-                  } else {\n-                      Some(r)\n-                  }\n-              })\n-}\n-\n-pub fn cache() -> Arc<Cache> {\n+crate fn cache() -> Arc<Cache> {\n     CACHE_KEY.with(|c| c.borrow().clone())\n }"}, {"sha": "65dd119c27cb7e958d78dddcf2d9eaef91271d33", "filename": "src/librustdoc/html/render/cache.rs", "status": "added", "additions": 675, "deletions": 0, "changes": 675, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -0,0 +1,675 @@\n+use crate::clean::{self, GetDefId, AttributesExt};\n+use crate::fold::DocFolder;\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n+use rustc::middle::privacy::AccessLevels;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use std::mem;\n+use std::path::{Path, PathBuf};\n+use std::collections::BTreeMap;\n+use syntax::source_map::FileName;\n+use syntax::symbol::sym;\n+use serialize::json::{ToJson, Json, as_json};\n+\n+use super::{ItemType, IndexItem, IndexItemFunctionType, Impl, shorten, plain_summary_line};\n+use super::{Type, RenderInfo};\n+\n+/// Indicates where an external crate can be found.\n+pub enum ExternalLocation {\n+    /// Remote URL root of the external crate\n+    Remote(String),\n+    /// This external crate can be found in the local doc/ folder\n+    Local,\n+    /// The external crate could not be found.\n+    Unknown,\n+}\n+\n+/// This cache is used to store information about the `clean::Crate` being\n+/// rendered in order to provide more useful documentation. This contains\n+/// information like all implementors of a trait, all traits a type implements,\n+/// documentation for all known traits, etc.\n+///\n+/// This structure purposefully does not implement `Clone` because it's intended\n+/// to be a fairly large and expensive structure to clone. Instead this adheres\n+/// to `Send` so it may be stored in a `Arc` instance and shared among the various\n+/// rendering threads.\n+#[derive(Default)]\n+crate struct Cache {\n+    /// Maps a type ID to all known implementations for that type. This is only\n+    /// recognized for intra-crate `ResolvedPath` types, and is used to print\n+    /// out extra documentation on the page of an enum/struct.\n+    ///\n+    /// The values of the map are a list of implementations and documentation\n+    /// found on that implementation.\n+    pub impls: FxHashMap<DefId, Vec<Impl>>,\n+\n+    /// Maintains a mapping of local crate `NodeId`s to the fully qualified name\n+    /// and \"short type description\" of that node. This is used when generating\n+    /// URLs when a type is being linked to. External paths are not located in\n+    /// this map because the `External` type itself has all the information\n+    /// necessary.\n+    pub paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n+\n+    /// Similar to `paths`, but only holds external paths. This is only used for\n+    /// generating explicit hyperlinks to other crates.\n+    pub external_paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n+\n+    /// Maps local `DefId`s of exported types to fully qualified paths.\n+    /// Unlike 'paths', this mapping ignores any renames that occur\n+    /// due to 'use' statements.\n+    ///\n+    /// This map is used when writing out the special 'implementors'\n+    /// javascript file. By using the exact path that the type\n+    /// is declared with, we ensure that each path will be identical\n+    /// to the path used if the corresponding type is inlined. By\n+    /// doing this, we can detect duplicate impls on a trait page, and only display\n+    /// the impl for the inlined type.\n+    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n+\n+    /// This map contains information about all known traits of this crate.\n+    /// Implementations of a crate should inherit the documentation of the\n+    /// parent trait if no extra documentation is specified, and default methods\n+    /// should show up in documentation about trait implementations.\n+    pub traits: FxHashMap<DefId, clean::Trait>,\n+\n+    /// When rendering traits, it's often useful to be able to list all\n+    /// implementors of the trait, and this mapping is exactly, that: a mapping\n+    /// of trait ids to the list of known implementors of the trait\n+    pub implementors: FxHashMap<DefId, Vec<Impl>>,\n+\n+    /// Cache of where external crate documentation can be found.\n+    pub extern_locations: FxHashMap<CrateNum, (String, PathBuf, ExternalLocation)>,\n+\n+    /// Cache of where documentation for primitives can be found.\n+    pub primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n+\n+    // Note that external items for which `doc(hidden)` applies to are shown as\n+    // non-reachable while local items aren't. This is because we're reusing\n+    // the access levels from the privacy check pass.\n+    pub access_levels: AccessLevels<DefId>,\n+\n+    /// The version of the crate being documented, if given from the `--crate-version` flag.\n+    pub crate_version: Option<String>,\n+\n+    // Private fields only used when initially crawling a crate to build a cache\n+\n+    stack: Vec<String>,\n+    parent_stack: Vec<DefId>,\n+    parent_is_trait_impl: bool,\n+    search_index: Vec<IndexItem>,\n+    stripped_mod: bool,\n+    pub deref_trait_did: Option<DefId>,\n+    pub deref_mut_trait_did: Option<DefId>,\n+    pub owned_box_did: Option<DefId>,\n+    masked_crates: FxHashSet<CrateNum>,\n+\n+    // In rare case where a structure is defined in one module but implemented\n+    // in another, if the implementing module is parsed before defining module,\n+    // then the fully qualified name of the structure isn't presented in `paths`\n+    // yet when its implementation methods are being indexed. Caches such methods\n+    // and their parent id here and indexes them at the end of crate parsing.\n+    orphan_impl_items: Vec<(DefId, clean::Item)>,\n+\n+    // Similarly to `orphan_impl_items`, sometimes trait impls are picked up\n+    // even though the trait itself is not exported. This can happen if a trait\n+    // was defined in function/expression scope, since the impl will be picked\n+    // up by `collect-trait-impls` but the trait won't be scraped out in the HIR\n+    // crawl. In order to prevent crashes when looking for spotlight traits or\n+    // when gathering trait documentation on a type, hold impls here while\n+    // folding and add them to the cache later on if we find the trait.\n+    orphan_trait_impls: Vec<(DefId, FxHashSet<DefId>, Impl)>,\n+\n+    /// Aliases added through `#[doc(alias = \"...\")]`. Since a few items can have the same alias,\n+    /// we need the alias element to have an array of items.\n+    pub(super) aliases: FxHashMap<String, Vec<IndexItem>>,\n+}\n+\n+impl Cache {\n+    pub fn from_krate(\n+        renderinfo: RenderInfo,\n+        extern_html_root_urls: &BTreeMap<String, String>,\n+        dst: &Path,\n+        mut krate: clean::Crate,\n+    ) -> (clean::Crate, String, Cache) {\n+        // Crawl the crate to build various caches used for the output\n+        let RenderInfo {\n+            inlined: _,\n+            external_paths,\n+            exact_paths,\n+            access_levels,\n+            deref_trait_did,\n+            deref_mut_trait_did,\n+            owned_box_did,\n+        } = renderinfo;\n+\n+        let external_paths = external_paths.into_iter()\n+            .map(|(k, (v, t))| (k, (v, ItemType::from(t))))\n+            .collect();\n+\n+        let mut cache = Cache {\n+            impls: Default::default(),\n+            external_paths,\n+            exact_paths,\n+            paths: Default::default(),\n+            implementors: Default::default(),\n+            stack: Vec::new(),\n+            parent_stack: Vec::new(),\n+            search_index: Vec::new(),\n+            parent_is_trait_impl: false,\n+            extern_locations: Default::default(),\n+            primitive_locations: Default::default(),\n+            stripped_mod: false,\n+            access_levels,\n+            crate_version: krate.version.take(),\n+            orphan_impl_items: Vec::new(),\n+            orphan_trait_impls: Vec::new(),\n+            traits: krate.external_traits.replace(Default::default()),\n+            deref_trait_did,\n+            deref_mut_trait_did,\n+            owned_box_did,\n+            masked_crates: mem::take(&mut krate.masked_crates),\n+            aliases: Default::default(),\n+        };\n+\n+        // Cache where all our extern crates are located\n+        for &(n, ref e) in &krate.externs {\n+            let src_root = match e.src {\n+                FileName::Real(ref p) => match p.parent() {\n+                    Some(p) => p.to_path_buf(),\n+                    None => PathBuf::new(),\n+                },\n+                _ => PathBuf::new(),\n+            };\n+            let extern_url = extern_html_root_urls.get(&e.name).map(|u| &**u);\n+            cache.extern_locations.insert(n, (e.name.clone(), src_root,\n+                                            extern_location(e, extern_url, &dst)));\n+\n+            let did = DefId { krate: n, index: CRATE_DEF_INDEX };\n+            cache.external_paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n+        }\n+\n+        // Cache where all known primitives have their documentation located.\n+        //\n+        // Favor linking to as local extern as possible, so iterate all crates in\n+        // reverse topological order.\n+        for &(_, ref e) in krate.externs.iter().rev() {\n+            for &(def_id, prim, _) in &e.primitives {\n+                cache.primitive_locations.insert(prim, def_id);\n+            }\n+        }\n+        for &(def_id, prim, _) in &krate.primitives {\n+            cache.primitive_locations.insert(prim, def_id);\n+        }\n+\n+        cache.stack.push(krate.name.clone());\n+        krate = cache.fold_crate(krate);\n+\n+        for (trait_did, dids, impl_) in cache.orphan_trait_impls.drain(..) {\n+            if cache.traits.contains_key(&trait_did) {\n+                for did in dids {\n+                    cache.impls.entry(did).or_insert(vec![]).push(impl_.clone());\n+                }\n+            }\n+        }\n+\n+        // Build our search index\n+        let index = build_index(&krate, &mut cache);\n+\n+        (krate, index, cache)\n+    }\n+}\n+\n+impl DocFolder for Cache {\n+    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+        if item.def_id.is_local() {\n+            debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.def_id);\n+        }\n+\n+        // If this is a stripped module,\n+        // we don't want it or its children in the search index.\n+        let orig_stripped_mod = match item.inner {\n+            clean::StrippedItem(box clean::ModuleItem(..)) => {\n+                mem::replace(&mut self.stripped_mod, true)\n+            }\n+            _ => self.stripped_mod,\n+        };\n+\n+        // If the impl is from a masked crate or references something from a\n+        // masked crate then remove it completely.\n+        if let clean::ImplItem(ref i) = item.inner {\n+            if self.masked_crates.contains(&item.def_id.krate) ||\n+               i.trait_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate)) ||\n+               i.for_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate)) {\n+                return None;\n+            }\n+        }\n+\n+        // Propagate a trait method's documentation to all implementors of the\n+        // trait.\n+        if let clean::TraitItem(ref t) = item.inner {\n+            self.traits.entry(item.def_id).or_insert_with(|| t.clone());\n+        }\n+\n+        // Collect all the implementors of traits.\n+        if let clean::ImplItem(ref i) = item.inner {\n+            if let Some(did) = i.trait_.def_id() {\n+                if i.blanket_impl.is_none() {\n+                    self.implementors.entry(did).or_default().push(Impl {\n+                        impl_item: item.clone(),\n+                    });\n+                }\n+            }\n+        }\n+\n+        // Index this method for searching later on.\n+        if let Some(ref s) = item.name {\n+            let (parent, is_inherent_impl_item) = match item.inner {\n+                clean::StrippedItem(..) => ((None, None), false),\n+                clean::AssocConstItem(..) |\n+                clean::TypedefItem(_, true) if self.parent_is_trait_impl => {\n+                    // skip associated items in trait impls\n+                    ((None, None), false)\n+                }\n+                clean::AssocTypeItem(..) |\n+                clean::TyMethodItem(..) |\n+                clean::StructFieldItem(..) |\n+                clean::VariantItem(..) => {\n+                    ((Some(*self.parent_stack.last().unwrap()),\n+                      Some(&self.stack[..self.stack.len() - 1])),\n+                     false)\n+                }\n+                clean::MethodItem(..) | clean::AssocConstItem(..) => {\n+                    if self.parent_stack.is_empty() {\n+                        ((None, None), false)\n+                    } else {\n+                        let last = self.parent_stack.last().unwrap();\n+                        let did = *last;\n+                        let path = match self.paths.get(&did) {\n+                            // The current stack not necessarily has correlation\n+                            // for where the type was defined. On the other\n+                            // hand, `paths` always has the right\n+                            // information if present.\n+                            Some(&(ref fqp, ItemType::Trait)) |\n+                            Some(&(ref fqp, ItemType::Struct)) |\n+                            Some(&(ref fqp, ItemType::Union)) |\n+                            Some(&(ref fqp, ItemType::Enum)) =>\n+                                Some(&fqp[..fqp.len() - 1]),\n+                            Some(..) => Some(&*self.stack),\n+                            None => None\n+                        };\n+                        ((Some(*last), path), true)\n+                    }\n+                }\n+                _ => ((None, Some(&*self.stack)), false)\n+            };\n+\n+            match parent {\n+                (parent, Some(path)) if is_inherent_impl_item || (!self.stripped_mod) => {\n+                    debug_assert!(!item.is_stripped());\n+\n+                    // A crate has a module at its root, containing all items,\n+                    // which should not be indexed. The crate-item itself is\n+                    // inserted later on when serializing the search-index.\n+                    if item.def_id.index != CRATE_DEF_INDEX {\n+                        self.search_index.push(IndexItem {\n+                            ty: item.type_(),\n+                            name: s.to_string(),\n+                            path: path.join(\"::\"),\n+                            desc: shorten(plain_summary_line(item.doc_value())),\n+                            parent,\n+                            parent_idx: None,\n+                            search_type: get_index_search_type(&item),\n+                        });\n+                    }\n+                }\n+                (Some(parent), None) if is_inherent_impl_item => {\n+                    // We have a parent, but we don't know where they're\n+                    // defined yet. Wait for later to index this item.\n+                    self.orphan_impl_items.push((parent, item.clone()));\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        // Keep track of the fully qualified path for this item.\n+        let pushed = match item.name {\n+            Some(ref n) if !n.is_empty() => {\n+                self.stack.push(n.to_string());\n+                true\n+            }\n+            _ => false,\n+        };\n+\n+        match item.inner {\n+            clean::StructItem(..) | clean::EnumItem(..) |\n+            clean::TypedefItem(..) | clean::TraitItem(..) |\n+            clean::FunctionItem(..) | clean::ModuleItem(..) |\n+            clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) |\n+            clean::ConstantItem(..) | clean::StaticItem(..) |\n+            clean::UnionItem(..) | clean::ForeignTypeItem |\n+            clean::MacroItem(..) | clean::ProcMacroItem(..)\n+            if !self.stripped_mod => {\n+                // Re-exported items mean that the same id can show up twice\n+                // in the rustdoc ast that we're looking at. We know,\n+                // however, that a re-exported item doesn't show up in the\n+                // `public_items` map, so we can skip inserting into the\n+                // paths map if there was already an entry present and we're\n+                // not a public item.\n+                if !self.paths.contains_key(&item.def_id) ||\n+                   self.access_levels.is_public(item.def_id)\n+                {\n+                    self.paths.insert(item.def_id,\n+                                      (self.stack.clone(), item.type_()));\n+                }\n+                self.add_aliases(&item);\n+            }\n+            // Link variants to their parent enum because pages aren't emitted\n+            // for each variant.\n+            clean::VariantItem(..) if !self.stripped_mod => {\n+                let mut stack = self.stack.clone();\n+                stack.pop();\n+                self.paths.insert(item.def_id, (stack, ItemType::Enum));\n+            }\n+\n+            clean::PrimitiveItem(..) => {\n+                self.add_aliases(&item);\n+                self.paths.insert(item.def_id, (self.stack.clone(),\n+                                                item.type_()));\n+            }\n+\n+            _ => {}\n+        }\n+\n+        // Maintain the parent stack\n+        let orig_parent_is_trait_impl = self.parent_is_trait_impl;\n+        let parent_pushed = match item.inner {\n+            clean::TraitItem(..) | clean::EnumItem(..) | clean::ForeignTypeItem |\n+            clean::StructItem(..) | clean::UnionItem(..) => {\n+                self.parent_stack.push(item.def_id);\n+                self.parent_is_trait_impl = false;\n+                true\n+            }\n+            clean::ImplItem(ref i) => {\n+                self.parent_is_trait_impl = i.trait_.is_some();\n+                match i.for_ {\n+                    clean::ResolvedPath{ did, .. } => {\n+                        self.parent_stack.push(did);\n+                        true\n+                    }\n+                    ref t => {\n+                        let prim_did = t.primitive_type().and_then(|t| {\n+                            self.primitive_locations.get(&t).cloned()\n+                        });\n+                        match prim_did {\n+                            Some(did) => {\n+                                self.parent_stack.push(did);\n+                                true\n+                            }\n+                            None => false,\n+                        }\n+                    }\n+                }\n+            }\n+            _ => false\n+        };\n+\n+        // Once we've recursively found all the generics, hoard off all the\n+        // implementations elsewhere.\n+        let ret = self.fold_item_recur(item).and_then(|item| {\n+            if let clean::Item { inner: clean::ImplItem(_), .. } = item {\n+                // Figure out the id of this impl. This may map to a\n+                // primitive rather than always to a struct/enum.\n+                // Note: matching twice to restrict the lifetime of the `i` borrow.\n+                let mut dids = FxHashSet::default();\n+                if let clean::Item { inner: clean::ImplItem(ref i), .. } = item {\n+                    match i.for_ {\n+                        clean::ResolvedPath { did, .. } |\n+                        clean::BorrowedRef {\n+                            type_: box clean::ResolvedPath { did, .. }, ..\n+                        } => {\n+                            dids.insert(did);\n+                        }\n+                        ref t => {\n+                            let did = t.primitive_type().and_then(|t| {\n+                                self.primitive_locations.get(&t).cloned()\n+                            });\n+\n+                            if let Some(did) = did {\n+                                dids.insert(did);\n+                            }\n+                        }\n+                    }\n+\n+                    if let Some(generics) = i.trait_.as_ref().and_then(|t| t.generics()) {\n+                        for bound in generics {\n+                            if let Some(did) = bound.def_id() {\n+                                dids.insert(did);\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    unreachable!()\n+                };\n+                let impl_item = Impl {\n+                    impl_item: item,\n+                };\n+                if impl_item.trait_did().map_or(true, |d| self.traits.contains_key(&d)) {\n+                    for did in dids {\n+                        self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n+                    }\n+                } else {\n+                    let trait_did = impl_item.trait_did().unwrap();\n+                    self.orphan_trait_impls.push((trait_did, dids, impl_item));\n+                }\n+                None\n+            } else {\n+                Some(item)\n+            }\n+        });\n+\n+        if pushed { self.stack.pop().unwrap(); }\n+        if parent_pushed { self.parent_stack.pop().unwrap(); }\n+        self.stripped_mod = orig_stripped_mod;\n+        self.parent_is_trait_impl = orig_parent_is_trait_impl;\n+        ret\n+    }\n+}\n+\n+impl Cache {\n+    fn add_aliases(&mut self, item: &clean::Item) {\n+        if item.def_id.index == CRATE_DEF_INDEX {\n+            return\n+        }\n+        if let Some(ref item_name) = item.name {\n+            let path = self.paths.get(&item.def_id)\n+                                 .map(|p| p.0[..p.0.len() - 1].join(\"::\"))\n+                                 .unwrap_or(\"std\".to_owned());\n+            for alias in item.attrs.lists(sym::doc)\n+                                   .filter(|a| a.check_name(sym::alias))\n+                                   .filter_map(|a| a.value_str()\n+                                                    .map(|s| s.to_string().replace(\"\\\"\", \"\")))\n+                                   .filter(|v| !v.is_empty())\n+                                   .collect::<FxHashSet<_>>()\n+                                   .into_iter() {\n+                self.aliases.entry(alias)\n+                            .or_insert(Vec::with_capacity(1))\n+                            .push(IndexItem {\n+                                ty: item.type_(),\n+                                name: item_name.to_string(),\n+                                path: path.clone(),\n+                                desc: shorten(plain_summary_line(item.doc_value())),\n+                                parent: None,\n+                                parent_idx: None,\n+                                search_type: get_index_search_type(&item),\n+                            });\n+            }\n+        }\n+    }\n+}\n+\n+/// Attempts to find where an external crate is located, given that we're\n+/// rendering in to the specified source destination.\n+fn extern_location(e: &clean::ExternalCrate, extern_url: Option<&str>, dst: &Path)\n+    -> ExternalLocation\n+{\n+    use ExternalLocation::*;\n+    // See if there's documentation generated into the local directory\n+    let local_location = dst.join(&e.name);\n+    if local_location.is_dir() {\n+        return Local;\n+    }\n+\n+    if let Some(url) = extern_url {\n+        let mut url = url.to_string();\n+        if !url.ends_with(\"/\") {\n+            url.push('/');\n+        }\n+        return Remote(url);\n+    }\n+\n+    // Failing that, see if there's an attribute specifying where to find this\n+    // external crate\n+    e.attrs.lists(sym::doc)\n+     .filter(|a| a.check_name(sym::html_root_url))\n+     .filter_map(|a| a.value_str())\n+     .map(|url| {\n+        let mut url = url.to_string();\n+        if !url.ends_with(\"/\") {\n+            url.push('/')\n+        }\n+        Remote(url)\n+    }).next().unwrap_or(Unknown) // Well, at least we tried.\n+}\n+\n+/// Builds the search index from the collected metadata\n+fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n+    let mut nodeid_to_pathid = FxHashMap::default();\n+    let mut crate_items = Vec::with_capacity(cache.search_index.len());\n+    let mut crate_paths = Vec::<Json>::new();\n+\n+    let Cache { ref mut search_index,\n+                ref orphan_impl_items,\n+                ref paths, .. } = *cache;\n+\n+    // Attach all orphan items to the type's definition if the type\n+    // has since been learned.\n+    for &(did, ref item) in orphan_impl_items {\n+        if let Some(&(ref fqp, _)) = paths.get(&did) {\n+            search_index.push(IndexItem {\n+                ty: item.type_(),\n+                name: item.name.clone().unwrap(),\n+                path: fqp[..fqp.len() - 1].join(\"::\"),\n+                desc: shorten(plain_summary_line(item.doc_value())),\n+                parent: Some(did),\n+                parent_idx: None,\n+                search_type: get_index_search_type(&item),\n+            });\n+        }\n+    }\n+\n+    // Reduce `NodeId` in paths into smaller sequential numbers,\n+    // and prune the paths that do not appear in the index.\n+    let mut lastpath = String::new();\n+    let mut lastpathid = 0usize;\n+\n+    for item in search_index {\n+        item.parent_idx = item.parent.map(|nodeid| {\n+            if nodeid_to_pathid.contains_key(&nodeid) {\n+                *nodeid_to_pathid.get(&nodeid).unwrap()\n+            } else {\n+                let pathid = lastpathid;\n+                nodeid_to_pathid.insert(nodeid, pathid);\n+                lastpathid += 1;\n+\n+                let &(ref fqp, short) = paths.get(&nodeid).unwrap();\n+                crate_paths.push(((short as usize), fqp.last().unwrap().clone()).to_json());\n+                pathid\n+            }\n+        });\n+\n+        // Omit the parent path if it is same to that of the prior item.\n+        if lastpath == item.path {\n+            item.path.clear();\n+        } else {\n+            lastpath = item.path.clone();\n+        }\n+        crate_items.push(item.to_json());\n+    }\n+\n+    let crate_doc = krate.module.as_ref().map(|module| {\n+        shorten(plain_summary_line(module.doc_value()))\n+    }).unwrap_or(String::new());\n+\n+    let mut crate_data = BTreeMap::new();\n+    crate_data.insert(\"doc\".to_owned(), Json::String(crate_doc));\n+    crate_data.insert(\"i\".to_owned(), Json::Array(crate_items));\n+    crate_data.insert(\"p\".to_owned(), Json::Array(crate_paths));\n+\n+    // Collect the index into a string\n+    format!(\"searchIndex[{}] = {};\",\n+            as_json(&krate.name),\n+            Json::Object(crate_data))\n+}\n+\n+fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n+    let (all_types, ret_types) = match item.inner {\n+        clean::FunctionItem(ref f) => (&f.all_types, &f.ret_types),\n+        clean::MethodItem(ref m) => (&m.all_types, &m.ret_types),\n+        clean::TyMethodItem(ref m) => (&m.all_types, &m.ret_types),\n+        _ => return None,\n+    };\n+\n+    let inputs = all_types.iter().map(|arg| {\n+        get_index_type(&arg)\n+    }).filter(|a| a.name.is_some()).collect();\n+    let output = ret_types.iter().map(|arg| {\n+        get_index_type(&arg)\n+    }).filter(|a| a.name.is_some()).collect::<Vec<_>>();\n+    let output = if output.is_empty() {\n+        None\n+    } else {\n+        Some(output)\n+    };\n+\n+    Some(IndexItemFunctionType { inputs, output })\n+}\n+\n+fn get_index_type(clean_type: &clean::Type) -> Type {\n+    let t = Type {\n+        name: get_index_type_name(clean_type, true).map(|s| s.to_ascii_lowercase()),\n+        generics: get_generics(clean_type),\n+    };\n+    t\n+}\n+\n+fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option<String> {\n+    match *clean_type {\n+        clean::ResolvedPath { ref path, .. } => {\n+            let segments = &path.segments;\n+            let path_segment = segments.into_iter().last().unwrap_or_else(|| panic!(\n+                \"get_index_type_name(clean_type: {:?}, accept_generic: {:?}) had length zero path\",\n+                clean_type, accept_generic\n+            ));\n+            Some(path_segment.name.clone())\n+        }\n+        clean::Generic(ref s) if accept_generic => Some(s.clone()),\n+        clean::Primitive(ref p) => Some(format!(\"{:?}\", p)),\n+        clean::BorrowedRef { ref type_, .. } => get_index_type_name(type_, accept_generic),\n+        // FIXME: add all from clean::Type.\n+        _ => None\n+    }\n+}\n+\n+fn get_generics(clean_type: &clean::Type) -> Option<Vec<String>> {\n+    clean_type.generics()\n+              .and_then(|types| {\n+                  let r = types.iter()\n+                               .filter_map(|t| get_index_type_name(t, false))\n+                               .map(|s| s.to_ascii_lowercase())\n+                               .collect::<Vec<_>>();\n+                  if r.is_empty() {\n+                      None\n+                  } else {\n+                      Some(r)\n+                  }\n+              })\n+}"}, {"sha": "0fb2f8dd7962ab09774069176b92b7cec5bc500d", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -1,10 +1,7 @@\n //! Table-of-contents creation.\n \n-use std::fmt;\n-use std::string::String;\n-\n /// A (recursive) table of contents\n-#[derive(PartialEq)]\n+#[derive(Debug, PartialEq)]\n pub struct Toc {\n     /// The levels are strictly decreasing, i.e.\n     ///\n@@ -28,7 +25,7 @@ impl Toc {\n     }\n }\n \n-#[derive(PartialEq)]\n+#[derive(Debug, PartialEq)]\n pub struct TocEntry {\n     level: u32,\n     sec_number: String,\n@@ -165,25 +162,23 @@ impl TocBuilder {\n     }\n }\n \n-impl fmt::Debug for Toc {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n-    }\n-}\n-\n-impl fmt::Display for Toc {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(fmt, \"<ul>\")?;\n+impl Toc {\n+    fn print_inner(&self, v: &mut String) {\n+        v.push_str(\"<ul>\");\n         for entry in &self.entries {\n-            // recursively format this table of contents (the\n-            // `{children}` is the key).\n-            write!(fmt,\n-                   \"\\n<li><a href=\\\"#{id}\\\">{num} {name}</a>{children}</li>\",\n+            // recursively format this table of contents\n+            v.push_str(&format!(\"\\n<li><a href=\\\"#{id}\\\">{num} {name}</a>\",\n                    id = entry.id,\n-                   num = entry.sec_number, name = entry.name,\n-                   children = entry.children)?\n+                   num = entry.sec_number, name = entry.name));\n+            entry.children.print_inner(&mut *v);\n+            v.push_str(\"</li>\");\n         }\n-        write!(fmt, \"</ul>\")\n+        v.push_str(\"</ul>\");\n+    }\n+    crate fn print(&self) -> String {\n+        let mut v = String::new();\n+        self.print_inner(&mut v);\n+        v\n     }\n }\n "}, {"sha": "dc1ca8d7668ae156aec2316eb1958d6e18552cf4", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -142,7 +142,8 @@ impl fold::DocFolder for CoverageCalculator {\n             }\n             clean::ImplItem(ref impl_) => {\n                 if let Some(ref tr) = impl_.trait_ {\n-                    debug!(\"impl {:#} for {:#} in {}\", tr, impl_.for_, i.source.filename);\n+                    debug!(\"impl {:#} for {:#} in {}\",\n+                        tr.print(), impl_.for_.print(), i.source.filename);\n \n                     // don't count trait impls, the missing-docs lint doesn't so we shouldn't\n                     // either\n@@ -151,11 +152,11 @@ impl fold::DocFolder for CoverageCalculator {\n                     // inherent impls *can* be documented, and those docs show up, but in most\n                     // cases it doesn't make sense, as all methods on a type are in one single\n                     // impl block\n-                    debug!(\"impl {:#} in {}\", impl_.for_, i.source.filename);\n+                    debug!(\"impl {:#} in {}\", impl_.for_.print(), i.source.filename);\n                 }\n             }\n             _ => {\n-                debug!(\"counting {} {:?} in {}\", i.type_(), i.name, i.source.filename);\n+                debug!(\"counting {:?} {:?} in {}\", i.type_(), i.name, i.source.filename);\n                 self.items.entry(i.source.filename.clone())\n                           .or_default()\n                           .count_item(has_docs);"}, {"sha": "b67f39d328015962fa245dd73bac70f554701284", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -237,7 +237,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         });\n \n         if parent_node.is_some() {\n-            debug!(\"got parent node for {} {:?}, id {:?}\", item.type_(), item.name, item.def_id);\n+            debug!(\"got parent node for {:?} {:?}, id {:?}\", item.type_(), item.name, item.def_id);\n         }\n \n         let current_item = match item.inner {"}, {"sha": "f6560218a78c82935454dd7b9d5fa88529b576b7", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -153,7 +153,7 @@ impl<'a> DocFolder for Stripper<'a> {\n                 // We need to recurse into stripped modules to strip things\n                 // like impl methods but when doing so we must not add any\n                 // items to the `retained` set.\n-                debug!(\"Stripper: recursing into stripped {} {:?}\", i.type_(), i.name);\n+                debug!(\"Stripper: recursing into stripped {:?} {:?}\", i.type_(), i.name);\n                 let old = mem::replace(&mut self.update_retained, false);\n                 let ret = self.fold_item_recur(i);\n                 self.update_retained = old;\n@@ -178,20 +178,20 @@ impl<'a> DocFolder for Stripper<'a> {\n             | clean::ForeignTypeItem => {\n                 if i.def_id.is_local() {\n                     if !self.access_levels.is_exported(i.def_id) {\n-                        debug!(\"Stripper: stripping {} {:?}\", i.type_(), i.name);\n+                        debug!(\"Stripper: stripping {:?} {:?}\", i.type_(), i.name);\n                         return None;\n                     }\n                 }\n             }\n \n             clean::StructFieldItem(..) => {\n-                if i.visibility != Some(clean::Public) {\n+                if i.visibility != clean::Public {\n                     return StripItem(i).strip();\n                 }\n             }\n \n             clean::ModuleItem(..) => {\n-                if i.def_id.is_local() && i.visibility != Some(clean::Public) {\n+                if i.def_id.is_local() && i.visibility != clean::Public {\n                     debug!(\"Stripper: stripping module {:?}\", i.name);\n                     let old = mem::replace(&mut self.update_retained, false);\n                     let ret = StripItem(self.fold_item_recur(i).unwrap()).strip();\n@@ -299,7 +299,7 @@ impl DocFolder for ImportStripper {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match i.inner {\n             clean::ExternCrateItem(..) | clean::ImportItem(..)\n-                if i.visibility != Some(clean::Public) =>\n+                if i.visibility != clean::Public =>\n             {\n                 None\n             }"}, {"sha": "0159e03f6f2997c41a287a97fcae11a07a62a7a4", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -39,7 +39,7 @@ struct Stripper<'a> {\n impl<'a> DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if i.attrs.lists(sym::doc).has_word(sym::hidden) {\n-            debug!(\"strip_hidden: stripping {} {:?}\", i.type_(), i.name);\n+            debug!(\"strip_hidden: stripping {:?} {:?}\", i.type_(), i.name);\n             // use a dedicated hidden item for given item type if any\n             match i.inner {\n                 clean::StructFieldItem(..) | clean::ModuleItem(..) => {"}, {"sha": "ee4b367b5c5b93040c781dd7c71d18b68e5e509d", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -53,9 +53,6 @@ fortanix-sgx-abi = { version = \"0.3.2\", features = ['rustc-dep-of-std'] }\n [target.wasm32-wasi.dependencies]\n wasi = { version = \"0.7.0\", features = ['rustc-dep-of-std', 'alloc'] }\n \n-[build-dependencies]\n-cc = \"1.0\"\n-\n [features]\n default = [\"std_detect_file_io\", \"std_detect_dlsym_getauxval\"]\n "}, {"sha": "8933f027a065f8c0b727d085c4f976bfb565a354", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -114,6 +114,9 @@ pub struct Metadata(fs_imp::FileAttr);\n /// information like the entry's path and possibly other metadata can be\n /// learned.\n ///\n+/// The order in which this iterator returns entries is platform and filesystem\n+/// dependent.\n+///\n /// # Errors\n ///\n /// This [`io::Result`] will be an [`Err`] if there's some sort of intermittent\n@@ -1962,6 +1965,9 @@ pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n ///\n /// [changes]: ../io/index.html#platform-specific-behavior\n ///\n+/// The order in which this iterator returns entries is platform and filesystem\n+/// dependent.\n+///\n /// # Errors\n ///\n /// This function will return an error in the following situations, but is not\n@@ -1994,6 +2000,25 @@ pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n ///     Ok(())\n /// }\n /// ```\n+///\n+/// ```rust,no_run\n+/// use std::{fs, io};\n+///\n+/// fn main() -> io::Result<()> {\n+///     let mut entries = fs::read_dir(\".\")?\n+///         .map(|res| res.map(|e| e.path()))\n+///         .collect::<Result<Vec<_>, io::Error>>()?;\n+///\n+///     // The order in which `read_dir` returns entries is not guaranteed. If reproducible\n+///     // ordering is required the entries should be explicitly sorted.\n+///\n+///     entries.sort();\n+///\n+///     // The entries have now been sorted by their path.\n+///\n+///     Ok(())\n+/// }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn read_dir<P: AsRef<Path>>(path: P) -> io::Result<ReadDir> {\n     fs_imp::readdir(path.as_ref()).map(ReadDir)"}, {"sha": "3ecbe4e3b28bade683b37fd9b6b07382ee895331", "filename": "src/libstd/sys/vxworks/process/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fmod.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -5,4 +5,3 @@ pub use crate::ffi::OsString as EnvKey;\n mod process_common;\n #[path = \"process_vxworks.rs\"]\n mod process_inner;\n-mod rtp;"}, {"sha": "beb20aa48169a7a25eac1f7bfed6a2471927a993", "filename": "src/libstd/sys/vxworks/process/process_vxworks.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_vxworks.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -3,7 +3,6 @@ use libc::{self, c_int, c_char};\n use libc::{RTP_ID};\n use crate::sys;\n use crate::sys::cvt;\n-use crate::sys::process::rtp;\n use crate::sys::process::process_common::*;\n use crate::sys_common::thread;\n \n@@ -53,7 +52,7 @@ impl Command {\n                 t!(cvt(libc::chdir(cwd.as_ptr())));\n             }\n \n-            let ret = rtp::rtpSpawn(\n+            let ret = libc::rtpSpawn(\n                 self.get_argv()[0],                   // executing program\n                 self.get_argv().as_ptr() as *const _, // argv\n                 *sys::os::environ() as *const *const c_char,\n@@ -78,7 +77,7 @@ impl Command {\n                 libc::close(orig_stderr);\n             }\n \n-            if ret != rtp::RTP_ID_ERROR {\n+            if ret != libc::RTP_ID_ERROR {\n                 p.pid = ret;\n                 Ok((p, ours))\n             } else {"}, {"sha": "3e6e0017abcb582e31772cb2f3f0bf6b370b5c26", "filename": "src/libstd/sys/vxworks/process/rtp.rs", "status": "removed", "additions": 0, "deletions": 298, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/6ef275e6c3cb1384ec78128eceeb4963ff788dca/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Frtp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef275e6c3cb1384ec78128eceeb4963ff788dca/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Frtp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Frtp.rs?ref=6ef275e6c3cb1384ec78128eceeb4963ff788dca", "patch": "@@ -1,298 +0,0 @@\n-#![allow(non_camel_case_types, unused)]\n-\n-use libc::{self, c_int, size_t, c_char, BOOL, RTP_DESC, RTP_ID, TASK_ID};\n-\n-\n-// Copied directly from rtpLibCommon.h, rtpLib.h, signal.h and taskLibCommon.h (for task options)\n-\n-// ****     definitions for rtpLibCommon.h    ****\n-\n-pub const RTP_GLOBAL_SYMBOLS     : c_int = 0x01; // register global symbols for RTP\n-pub const RTP_LOCAL_SYMBOLS      : c_int = 0x02; // idem for local symbols\n-pub const RTP_ALL_SYMBOLS        : c_int = (RTP_GLOBAL_SYMBOLS | RTP_LOCAL_SYMBOLS);\n-pub const RTP_DEBUG              : c_int = 0x10; // set RTP in debug mode when created\n-pub const RTP_BUFFER_VAL_OFF     : c_int = 0x20; // disable buffer validation for all\n-                                                 // system calls issued from the RTP\n-pub const RTP_LOADED_WAIT        : c_int = 0x40; // Wait until the RTP is loaded\n-pub const RTP_CPU_AFFINITY_NONE  : c_int = 0x80; // Remove any CPU affinity (SMP)\n-\n-// Error Status codes\n-\n-pub const M_rtpLib : c_int = 178 << 16;\n-\n-pub const S_rtpLib_INVALID_FILE                   : c_int = (M_rtpLib | 1);\n-pub const S_rtpLib_INVALID_OPTION                 : c_int = (M_rtpLib | 2);\n-pub const S_rtpLib_ACCESS_DENIED                  : c_int = (M_rtpLib | 3);\n-pub const S_rtpLib_INVALID_RTP_ID                 : c_int = (M_rtpLib | 4);\n-pub const S_rtpLib_NO_SYMBOL_TABLE                : c_int = (M_rtpLib | 5);\n-pub const S_rtpLib_INVALID_SEGMENT_START_ADDRESS  : c_int = (M_rtpLib | 6);\n-pub const S_rtpLib_INVALID_SYMBOL_REGISTR_POLICY  : c_int = (M_rtpLib | 7);\n-pub const S_rtpLib_INSTANTIATE_FAILED             : c_int = (M_rtpLib | 8);\n-pub const S_rtpLib_INVALID_TASK_OPTION            : c_int = (M_rtpLib | 9);\n-pub const S_rtpLib_RTP_NAME_LENGTH_EXCEEDED       : c_int = (M_rtpLib | 10);    // rtpInfoGet\n-\n-pub const VX_RTP_NAME_LENGTH                      : c_int  = 255;    // max name length for diplay\n-\n-\n-// The 'status' field (32 bit integer) of a RTP holds the RTP state and status.\n-//\n-// NOTE: RTP_STATE_GET()    : read the RTP state(s)\n-//       RTP_STATE_PUT()    : write the RTP state(s)\n-//       RTP_STATE_SET()    : set a RTP state\n-//       RTP_STATE_UNSET()  : unset a RTP state\n-//\n-//       RTP_STATUS_GET()   : read the RTP status\n-//       RTP_STATUS_PUT()   : write the RTP status\n-//       RTP_STATUS_SET()   : set a RTP status\n-//       RTP_STATUS_UNSET() : unset a RTP status\n-//\n-// The PUT/SET/UNSET macros are available only in the kernel headers.\n-\n-\n-// RTP states\n-\n-pub const RTP_STATE_CREATE           : c_int  = 0x0001; // RrtpStructTP is under construction\n-pub const RTP_STATE_NORMAL           : c_int  = 0x0002; // RrtpStructTP is ready\n-pub const RTP_STATE_DELETE           : c_int  = 0x0004; // RrtpStructTP is being deleted\n-\n-pub const RTP_STATUS_STOP            : c_int  = 0x0100; // RTP hrtpStructas recieved stopped signal\n-pub const RTP_STATUS_ELECTED_DELETER : c_int  = 0x0200; // RTP drtpStructelete has started\n-\n-pub const RTP_STATE_MASK             : c_int  = (RTP_STATE_CREATE | RTP_STATE_NORMAL |\n-                                                 RTP_STATE_DELETE);\n-pub const RTP_STATUS_MASK            : c_int  = (RTP_STATUS_STOP | RTP_STATUS_ELECTED_DELETER);\n-\n-pub fn RTP_STATE_GET  (value : c_int) -> c_int {\n-    value & RTP_STATE_MASK\n-}\n-pub fn RTP_STATUS_GET (value : c_int) -> c_int {\n-    value & RTP_STATUS_MASK\n-}\n-\n-// Indicates that the RTP_ID returned is not valid.\n-\n-// RTP_ID_ERROR is supposed to be set to -1, but you can't set\n-// an unsigned value to a negative without casting, and you\n-// can't cast unless the size of the integer types are the same,\n-// but the size of RTP_ID may differ between kernel and user space.\n-// Bitwise or-ing min and max should get the same result.\n-pub const RTP_ID_ERROR : RTP_ID = RTP_ID::min_value() | RTP_ID::max_value();\n-\n-// IS_RTP_ C macros\n-\n-pub fn IS_RTP_STATE_NORMAL           (value : c_int) -> bool {\n-    (RTP_STATE_GET(value)  & RTP_STATE_NORMAL) == RTP_STATE_NORMAL\n-}\n-pub fn IS_RTP_STATE_CREATE           (value : c_int) -> bool {\n-    (RTP_STATE_GET(value)  & RTP_STATE_CREATE) == RTP_STATE_CREATE\n-}\n-pub fn IS_RTP_STATE_DELETE           (value : c_int) -> bool {\n-    (RTP_STATE_GET(value)  & RTP_STATE_DELETE) == RTP_STATE_DELETE\n-}\n-pub fn IS_RTP_STATUS_STOP            (value : c_int) -> bool {\n-    (RTP_STATUS_GET(value) & RTP_STATUS_STOP ) == RTP_STATUS_STOP\n-}\n-pub fn IS_RTP_STATUS_ELECTED_DELETER (value : c_int) -> bool {\n-    (RTP_STATUS_GET(value) &  RTP_STATUS_ELECTED_DELETER) == RTP_STATUS_ELECTED_DELETER\n-}\n-\n-// **** end of definitions for rtpLibCommon.h ****\n-\n-\n-\n-\n-// ****    definitions for rtpLib.h     ****\n-\n-pub fn rtpExit(exitCode : c_int) -> ! {\n-    unsafe{ libc::exit (exitCode) }\n-}\n-\n-/* rtpLib.h in the kernel\n-pub const RTP_DEL_VIA_TASK_DELETE : c_int  = 0x1;          // rtpDelete() via taskDestroy()\n-pub const RTP_DEL_FORCE           : c_int  = 0x2;          // Forceful  rtpDelete()\n-pub const RTP_ID_ANY              : RTP_ID = 0;            // used for when a kernel task\n-                                                           // wants to wait for the next\n-                                                           // RTP to finish\n-\n-\n-// Function pointers\n-\n-pub type RTP_PRE_CREATE_HOOK    = size_t;\n-pub type RTP_POST_CREATE_HOOK   = size_t;\n-pub type RTP_INIT_COMPLETE_HOOK = size_t;\n-pub type RTP_DELETE_HOOK        = size_t;\n-*/\n-\n-// **** end of definitions for rtpLib.h ****\n-\n-\n-\n-\n-\n-// ****     definitions for signal.h    ****\n-pub fn rtpKill(rtpId : RTP_ID, signo : c_int) -> c_int {\n-    unsafe{ libc::kill(rtpId as c_int, signo) }\n-}\n-\n-pub fn rtpSigqueue(rtpId : RTP_ID, signo : c_int, value : size_t) -> c_int {\n-    unsafe{ libc::sigqueue(rtpId as c_int, signo, value) }\n-}\n-\n-pub fn _rtpSigqueue(rtpId : RTP_ID, signo : c_int, value : *mut size_t, code : c_int) -> c_int {\n-    unsafe{ libc::_sigqueue(rtpId, signo, value, code) }\n-}\n-\n-pub fn taskRaise(signo : c_int) -> c_int {\n-    unsafe{ libc::taskKill(libc::taskIdSelf(), signo) }\n-}\n-pub fn rtpRaise(signo : c_int) -> c_int {\n-    unsafe{ libc::raise(signo) }\n-}\n-\n-// **** end of definitions for signal.h ****\n-\n-\n-\n-// ****     definitions for taskLibCommon.h    ****\n-pub const VX_PRIVATE_ENV      : c_int = 0x0080;  // 1 = private environment variables\n-pub const VX_NO_STACK_FILL    : c_int = 0x0100;  // 1 = avoid stack fill of 0xee\n-pub const VX_PRIVATE_UMASK    : c_int = 0x0400;  // 1 = private file creation mode mask\n-pub const VX_TASK_NOACTIVATE  : c_int = 0x2000;  // taskOpen() does not taskActivate()\n-pub const VX_NO_STACK_PROTECT : c_int = 0x4000;  // no over/underflow stack protection,\n-                                                 // stack space remains executable\n-\n-// define for all valid user task options\n-\n-pub const VX_USR_TASK_OPTIONS_BASE: c_int = (VX_PRIVATE_ENV      |\n-                                             VX_NO_STACK_FILL    |\n-                                             VX_TASK_NOACTIVATE  |\n-                                             VX_NO_STACK_PROTECT |\n-                                             VX_PRIVATE_UMASK);\n-\n-// **** end of definitions for taskLibCommon.h ****\n-\n-\n-\n-extern \"C\" {\n-// functions in rtpLibCommon.h\n-\n-// forward declarations\n-    pub fn rtpSpawn (\n-        pubrtpFileName : *const c_char,\n-        argv           : *const *const c_char,\n-        envp           : *const *const c_char,\n-        priority       : c_int,\n-        uStackSize     : size_t,\n-        options        : c_int,\n-        taskOptions    : c_int,\n-    ) -> RTP_ID;\n-\n-    pub fn rtpInfoGet (\n-        rtpId     : RTP_ID,\n-        rtpStruct : *mut RTP_DESC,\n-    ) -> c_int;\n-\n-/* functions in rtpLib.h for kernel\n-\n-\n-    // function declarations\n-\n-    pub fn rtpDelete (\n-        id      : RTP_ID,\n-        options : c_int,\n-        status  : c_int,\n-    ) -> c_int;\n-\n-    pub fn rtpDeleteForce (\n-        rtpId : RTP_ID\n-    ) -> c_int;\n-\n-    pub fn rtpShow (\n-        rtpNameOrId : *mut c_char,\n-        level       : c_int,\n-    ) -> BOOL;\n-\n-    // RTP signals are always present when RTPs are included.  The public RTP\n-    // signal APIs are declared here.\n-\n-\n-    pub fn rtpKill (\n-        rtpId : RTP_ID,\n-        signo : c_int,\n-    ) -> c_int;\n-\n-    pub fn rtpSigqueue (\n-        rtpId : RTP_ID,\n-        signo : c_int,\n-        value : size_t, // Actual type is const union sigval value,\n-                        // which is a union of int and void *\n-    ) -> c_int;\n-\n-    pub fn rtpTaskKill (\n-        tid   : TASK_ID,\n-        signo : c_int,\n-    ) -> c_int;\n-\n-    pub fn rtpTaskSigqueue (\n-        tid   : TASK_ID,\n-        signo : c_int,\n-        value : const size_t, // Actual type is const union sigval,\n-                        // which is a union of int and void *\n-    ) -> c_int;\n-\n-    pub fn rtpWait (\n-        rtpWaitId : RTP_ID,\n-        timeout   : libc::alloc_jemalloc_Vx_ticks_t,\n-        pRtpId    : *mut RTP_ID,\n-        pStatus   : *mut c_int,\n-    ) -> c_int;\n-\n-                             // Other public functions\n-\n-\n-    pub fn rtpPreCreateHookAdd     (\n-        hook      : RTP_PRE_CREATE_HOOK,\n-        addToHead : BOOL,\n-    ) -> c_int;\n-\n-    pub fn rtpPreCreateHookDelete  (\n-        hook      : RTP_POST_CREATE_HOOK,\n-    ) -> c_int;\n-\n-    pub fn rtpPostCreateHookAdd    (\n-        hook      : RTP_POST_CREATE_HOOK,\n-        addToHead : BOOL,\n-    ) -> c_int;\n-\n-    pub fn rtpPostCreateHookDelete (\n-        hook      : RTP_POST_CREATE_HOOK,\n-    ) -> c_int;\n-\n-    pub fn rtpInitCompleteHookAdd  (\n-        hook      : RTP_INIT_COMPLETE_HOOK,\n-        addToHead : BOOL,\n-    ) -> c_int;\n-\n-    pub fn rtpInitCompleteHookDelete (\n-        hook      : RTP_INIT_COMPLETE_HOOK,\n-    ) -> c_int;\n-\n-    pub fn rtpDeleteHookAdd        (\n-        hook      : RTP_DELETE_HOOK,\n-        addToHead : BOOL,\n-    ) -> c_int;\n-\n-    pub fn rtpDeleteHookDelete     (\n-        hook      : RTP_DELETE_HOOK,\n-    ) -> c_int;\n-\n-    pub fn rtpMemShow              (\n-        rtpNameOrId : *mut c_char,\n-        level       : c_int,\n-    ) -> c_int;\n-\n-    pub fn rtpHookShow             (\n-\n-    );\n-*/\n-}"}, {"sha": "196cf4d9dfae8d3fb35b0c6a697f3528d991d50c", "filename": "src/libsyntax/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2FCargo.toml?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -19,6 +19,5 @@ syntax_pos = { path = \"../libsyntax_pos\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_lexer = { path = \"../librustc_lexer\" }\n-rustc_macros = { path = \"../librustc_macros\" }\n rustc_target = { path = \"../librustc_target\" }\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "aa76667c2e90189d7bcbcabc92f0492d8d72a094", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -1017,10 +1017,6 @@ impl<'a> ExtCtxt<'a> {\n     pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: DiagnosticId) {\n         self.parse_sess.span_diagnostic.span_err_with_code(sp, msg, code);\n     }\n-    pub fn mut_span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str)\n-                        -> DiagnosticBuilder<'a> {\n-        self.parse_sess.span_diagnostic.mut_span_err(sp, msg)\n-    }\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.parse_sess.span_diagnostic.span_warn(sp, msg);\n     }"}, {"sha": "c8078d2bb712e0c82929c958221cdfcd31c6785d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -6,7 +6,7 @@ use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n use crate::ext::proc_macro::{collect_derives, MarkAttrs};\n use crate::ext::hygiene::{ExpnId, SyntaxContext, ExpnData, ExpnKind};\n-use crate::ext::tt::macro_rules::annotate_err_with_kind;\n+use crate::ext::mbe::macro_rules::annotate_err_with_kind;\n use crate::ext::placeholders::{placeholder, PlaceholderExpander};\n use crate::feature_gate::{self, Features, GateIssue, is_builtin_attr, emit_feature_err};\n use crate::mut_visit::*;\n@@ -115,8 +115,8 @@ macro_rules! ast_fragments {\n             }\n         }\n \n-        impl<'a> MacResult for crate::ext::tt::macro_rules::ParserAnyMacro<'a> {\n-            $(fn $make_ast(self: Box<crate::ext::tt::macro_rules::ParserAnyMacro<'a>>)\n+        impl<'a> MacResult for crate::ext::mbe::macro_rules::ParserAnyMacro<'a> {\n+            $(fn $make_ast(self: Box<crate::ext::mbe::macro_rules::ParserAnyMacro<'a>>)\n                            -> Option<$AstTy> {\n                 Some(self.make(AstFragmentKind::$Kind).$make_ast())\n             })*\n@@ -384,7 +384,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         let attr = attr::find_by_name(item.attrs(), sym::derive)\n                             .expect(\"`derive` attribute should exist\");\n                         let span = attr.span;\n-                        let mut err = self.cx.mut_span_err(span,\n+                        let mut err = self.cx.struct_span_err(span,\n                             \"`derive` may only be applied to structs, enums and unions\");\n                         if let ast::AttrStyle::Inner = attr.style {\n                             let trait_list = derives.iter()"}, {"sha": "a87da791c9b4f6de2971f5905c782172503b33d7", "filename": "src/libsyntax/ext/mbe.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Fext%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Fext%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -0,0 +1,166 @@\n+//! This module implements declarative macros: old `macro_rules` and the newer\n+//! `macro`. Declarative macros are also known as \"macro by example\", and that's\n+//! why we call this module `mbe`. For external documentation, prefer the\n+//! official terminology: \"declarative macros\".\n+\n+crate mod transcribe;\n+crate mod macro_check;\n+crate mod macro_parser;\n+crate mod macro_rules;\n+crate mod quoted;\n+\n+use crate::ast;\n+use crate::parse::token::{self, Token, TokenKind};\n+use crate::tokenstream::{DelimSpan};\n+\n+use syntax_pos::{BytePos, Span};\n+\n+use rustc_data_structures::sync::Lrc;\n+\n+/// Contains the sub-token-trees of a \"delimited\" token tree, such as the contents of `(`. Note\n+/// that the delimiter itself might be `NoDelim`.\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+struct Delimited {\n+    delim: token::DelimToken,\n+    tts: Vec<TokenTree>,\n+}\n+\n+impl Delimited {\n+    /// Returns a `self::TokenTree` with a `Span` corresponding to the opening delimiter.\n+    fn open_tt(&self, span: Span) -> TokenTree {\n+        let open_span = if span.is_dummy() {\n+            span\n+        } else {\n+            span.with_hi(span.lo() + BytePos(self.delim.len() as u32))\n+        };\n+        TokenTree::token(token::OpenDelim(self.delim), open_span)\n+    }\n+\n+    /// Returns a `self::TokenTree` with a `Span` corresponding to the closing delimiter.\n+    fn close_tt(&self, span: Span) -> TokenTree {\n+        let close_span = if span.is_dummy() {\n+            span\n+        } else {\n+            span.with_lo(span.hi() - BytePos(self.delim.len() as u32))\n+        };\n+        TokenTree::token(token::CloseDelim(self.delim), close_span)\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+struct SequenceRepetition {\n+    /// The sequence of token trees\n+    tts: Vec<TokenTree>,\n+    /// The optional separator\n+    separator: Option<Token>,\n+    /// Whether the sequence can be repeated zero (*), or one or more times (+)\n+    kleene: KleeneToken,\n+    /// The number of `Match`s that appear in the sequence (and subsequences)\n+    num_captures: usize,\n+}\n+\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+struct KleeneToken {\n+    span: Span,\n+    op: KleeneOp,\n+}\n+\n+impl KleeneToken {\n+    fn new(op: KleeneOp, span: Span) -> KleeneToken {\n+        KleeneToken { span, op }\n+    }\n+}\n+\n+/// A Kleene-style [repetition operator](http://en.wikipedia.org/wiki/Kleene_star)\n+/// for token sequences.\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+enum KleeneOp {\n+    /// Kleene star (`*`) for zero or more repetitions\n+    ZeroOrMore,\n+    /// Kleene plus (`+`) for one or more repetitions\n+    OneOrMore,\n+    /// Kleene optional (`?`) for zero or one reptitions\n+    ZeroOrOne,\n+}\n+\n+/// Similar to `tokenstream::TokenTree`, except that `$i`, `$i:ident`, and `$(...)`\n+/// are \"first-class\" token trees. Useful for parsing macros.\n+#[derive(Debug, Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+enum TokenTree {\n+    Token(Token),\n+    Delimited(DelimSpan, Lrc<Delimited>),\n+    /// A kleene-style repetition sequence\n+    Sequence(DelimSpan, Lrc<SequenceRepetition>),\n+    /// e.g., `$var`\n+    MetaVar(Span, ast::Ident),\n+    /// e.g., `$var:expr`. This is only used in the left hand side of MBE macros.\n+    MetaVarDecl(\n+        Span,\n+        ast::Ident, /* name to bind */\n+        ast::Ident, /* kind of nonterminal */\n+    ),\n+}\n+\n+impl TokenTree {\n+    /// Return the number of tokens in the tree.\n+    fn len(&self) -> usize {\n+        match *self {\n+            TokenTree::Delimited(_, ref delimed) => match delimed.delim {\n+                token::NoDelim => delimed.tts.len(),\n+                _ => delimed.tts.len() + 2,\n+            },\n+            TokenTree::Sequence(_, ref seq) => seq.tts.len(),\n+            _ => 0,\n+        }\n+    }\n+\n+    /// Returns `true` if the given token tree is delimited.\n+    fn is_delimited(&self) -> bool {\n+        match *self {\n+            TokenTree::Delimited(..) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns `true` if the given token tree is a token of the given kind.\n+    fn is_token(&self, expected_kind: &TokenKind) -> bool {\n+        match self {\n+            TokenTree::Token(Token { kind: actual_kind, .. }) => actual_kind == expected_kind,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Gets the `index`-th sub-token-tree. This only makes sense for delimited trees and sequences.\n+    fn get_tt(&self, index: usize) -> TokenTree {\n+        match (self, index) {\n+            (&TokenTree::Delimited(_, ref delimed), _) if delimed.delim == token::NoDelim => {\n+                delimed.tts[index].clone()\n+            }\n+            (&TokenTree::Delimited(span, ref delimed), _) => {\n+                if index == 0 {\n+                    return delimed.open_tt(span.open);\n+                }\n+                if index == delimed.tts.len() + 1 {\n+                    return delimed.close_tt(span.close);\n+                }\n+                delimed.tts[index - 1].clone()\n+            }\n+            (&TokenTree::Sequence(_, ref seq), _) => seq.tts[index].clone(),\n+            _ => panic!(\"Cannot expand a token tree\"),\n+        }\n+    }\n+\n+    /// Retrieves the `TokenTree`'s span.\n+    fn span(&self) -> Span {\n+        match *self {\n+            TokenTree::Token(Token { span, .. })\n+            | TokenTree::MetaVar(span, _)\n+            | TokenTree::MetaVarDecl(span, _, _) => span,\n+            TokenTree::Delimited(span, _) | TokenTree::Sequence(span, _) => span.entire(),\n+        }\n+    }\n+\n+    fn token(kind: TokenKind, span: Span) -> TokenTree {\n+        TokenTree::Token(Token::new(kind, span))\n+    }\n+}"}, {"sha": "97074f5cbe46c995015052001076b8e0d5c0aceb", "filename": "src/libsyntax/ext/mbe/macro_check.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_check.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -106,7 +106,7 @@\n //! bound.\n use crate::ast::NodeId;\n use crate::early_buffered_lints::BufferedEarlyLintId;\n-use crate::ext::tt::quoted::{KleeneToken, TokenTree};\n+use crate::ext::mbe::{KleeneToken, TokenTree};\n use crate::parse::token::TokenKind;\n use crate::parse::token::{DelimToken, Token};\n use crate::parse::ParseSess;\n@@ -196,7 +196,7 @@ struct MacroState<'a> {\n /// - `node_id` is used to emit lints\n /// - `span` is used when no spans are available\n /// - `lhses` and `rhses` should have the same length and represent the macro definition\n-pub fn check_meta_variables(\n+pub(super) fn check_meta_variables(\n     sess: &ParseSess,\n     node_id: NodeId,\n     span: Span,", "previous_filename": "src/libsyntax/ext/tt/macro_check.rs"}, {"sha": "b51384d3b15e10b80941956246505c175cbf0a34", "filename": "src/libsyntax/ext/mbe/macro_parser.rs", "status": "renamed", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_parser.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -70,12 +70,12 @@\n //! eof: [a $( a )* a b \u00b7]\n //! ```\n \n-pub use NamedMatch::*;\n-pub use ParseResult::*;\n+crate use NamedMatch::*;\n+crate use ParseResult::*;\n use TokenTreeOrTokenTreeSlice::*;\n \n use crate::ast::{Ident, Name};\n-use crate::ext::tt::quoted::{self, TokenTree};\n+use crate::ext::mbe::{self, TokenTree};\n use crate::parse::{Directory, ParseSess};\n use crate::parse::parser::{Parser, PathStyle};\n use crate::parse::token::{self, DocComment, Nonterminal, Token};\n@@ -195,7 +195,7 @@ struct MatcherPos<'root, 'tt> {\n     // `None`.\n \n     /// The KleeneOp of this sequence if we are in a repetition.\n-    seq_op: Option<quoted::KleeneOp>,\n+    seq_op: Option<mbe::KleeneOp>,\n \n     /// The separator if we are in a repetition.\n     sep: Option<Token>,\n@@ -267,7 +267,7 @@ impl<'root, 'tt> DerefMut for MatcherPosHandle<'root, 'tt> {\n }\n \n /// Represents the possible results of an attempted parse.\n-pub enum ParseResult<T> {\n+crate enum ParseResult<T> {\n     /// Parsed successfully.\n     Success(T),\n     /// Arm failed to match. If the second parameter is `token::Eof`, it indicates an unexpected\n@@ -279,10 +279,10 @@ pub enum ParseResult<T> {\n \n /// A `ParseResult` where the `Success` variant contains a mapping of `Ident`s to `NamedMatch`es.\n /// This represents the mapping of metavars to the token trees they bind to.\n-pub type NamedParseResult = ParseResult<FxHashMap<Ident, NamedMatch>>;\n+crate type NamedParseResult = ParseResult<FxHashMap<Ident, NamedMatch>>;\n \n /// Count how many metavars are named in the given matcher `ms`.\n-pub fn count_names(ms: &[TokenTree]) -> usize {\n+pub(super) fn count_names(ms: &[TokenTree]) -> usize {\n     ms.iter().fold(0, |count, elt| {\n         count + match *elt {\n             TokenTree::Sequence(_, ref seq) => seq.num_captures,\n@@ -352,7 +352,7 @@ fn initial_matcher_pos<'root, 'tt>(ms: &'tt [TokenTree], open: Span) -> MatcherP\n /// only on the nesting depth of `ast::TTSeq`s in the originating\n /// token tree it was derived from.\n #[derive(Debug, Clone)]\n-pub enum NamedMatch {\n+crate enum NamedMatch {\n     MatchedSeq(Lrc<NamedMatchVec>, DelimSpan),\n     MatchedNonterminal(Lrc<Nonterminal>),\n }\n@@ -415,7 +415,7 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n \n /// Generates an appropriate parsing failure message. For EOF, this is \"unexpected end...\". For\n /// other tokens, this is \"unexpected token...\".\n-pub fn parse_failure_msg(tok: &Token) -> String {\n+crate fn parse_failure_msg(tok: &Token) -> String {\n     match tok.kind {\n         token::Eof => \"unexpected end of macro invocation\".to_string(),\n         _ => format!(\n@@ -532,7 +532,7 @@ fn inner_parse_loop<'root, 'tt>(\n                 }\n                 // We don't need a separator. Move the \"dot\" back to the beginning of the matcher\n                 // and try to match again UNLESS we are only allowed to have _one_ repetition.\n-                else if item.seq_op != Some(quoted::KleeneOp::ZeroOrOne) {\n+                else if item.seq_op != Some(mbe::KleeneOp::ZeroOrOne) {\n                     item.match_cur = item.match_lo;\n                     item.idx = 0;\n                     cur_items.push(item);\n@@ -555,8 +555,8 @@ fn inner_parse_loop<'root, 'tt>(\n                     // implicitly disallowing OneOrMore from having 0 matches here. Thus, that will\n                     // result in a \"no rules expected token\" error by virtue of this matcher not\n                     // working.\n-                    if seq.kleene.op == quoted::KleeneOp::ZeroOrMore\n-                        || seq.kleene.op == quoted::KleeneOp::ZeroOrOne\n+                    if seq.kleene.op == mbe::KleeneOp::ZeroOrMore\n+                        || seq.kleene.op == mbe::KleeneOp::ZeroOrOne\n                     {\n                         let mut new_item = item.clone();\n                         new_item.match_cur += seq.num_captures;\n@@ -648,7 +648,7 @@ fn inner_parse_loop<'root, 'tt>(\n /// - `directory`: Information about the file locations (needed for the black-box parser)\n /// - `recurse_into_modules`: Whether or not to recurse into modules (needed for the black-box\n ///   parser)\n-pub fn parse(\n+pub(super) fn parse(\n     sess: &ParseSess,\n     tts: TokenStream,\n     ms: &[TokenTree],", "previous_filename": "src/libsyntax/ext/tt/macro_parser.rs"}, {"sha": "816baadb12fbb67052a7146297d10c18831de5e0", "filename": "src/libsyntax/ext/mbe/macro_rules.rs", "status": "renamed", "additions": 85, "deletions": 68, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_rules.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -4,12 +4,12 @@ use crate::edition::Edition;\n use crate::ext::base::{DummyResult, ExtCtxt, MacResult, TTMacroExpander};\n use crate::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use crate::ext::expand::{AstFragment, AstFragmentKind};\n-use crate::ext::tt::macro_check;\n-use crate::ext::tt::macro_parser::{parse, parse_failure_msg};\n-use crate::ext::tt::macro_parser::{Error, Failure, Success};\n-use crate::ext::tt::macro_parser::{MatchedNonterminal, MatchedSeq};\n-use crate::ext::tt::quoted;\n-use crate::ext::tt::transcribe::transcribe;\n+use crate::ext::mbe;\n+use crate::ext::mbe::macro_check;\n+use crate::ext::mbe::macro_parser::{parse, parse_failure_msg};\n+use crate::ext::mbe::macro_parser::{Error, Failure, Success};\n+use crate::ext::mbe::macro_parser::{MatchedNonterminal, MatchedSeq, NamedParseResult};\n+use crate::ext::mbe::transcribe::transcribe;\n use crate::feature_gate::Features;\n use crate::parse::parser::Parser;\n use crate::parse::token::TokenKind::*;\n@@ -35,7 +35,7 @@ const VALID_FRAGMENT_NAMES_MSG: &str = \"valid fragment specifiers are \\\n                                         `ident`, `block`, `stmt`, `expr`, `pat`, `ty`, `lifetime`, \\\n                                         `literal`, `path`, `meta`, `tt`, `item` and `vis`\";\n \n-pub struct ParserAnyMacro<'a> {\n+crate struct ParserAnyMacro<'a> {\n     parser: Parser<'a>,\n \n     /// Span of the expansion site of the macro this parser is for\n@@ -45,7 +45,11 @@ pub struct ParserAnyMacro<'a> {\n     arm_span: Span,\n }\n \n-pub fn annotate_err_with_kind(err: &mut DiagnosticBuilder<'_>, kind: AstFragmentKind, span: Span) {\n+crate fn annotate_err_with_kind(\n+    err: &mut DiagnosticBuilder<'_>,\n+    kind: AstFragmentKind,\n+    span: Span,\n+) {\n     match kind {\n         AstFragmentKind::Ty => {\n             err.span_label(span, \"this macro call doesn't expand to a type\");\n@@ -58,7 +62,7 @@ pub fn annotate_err_with_kind(err: &mut DiagnosticBuilder<'_>, kind: AstFragment\n }\n \n impl<'a> ParserAnyMacro<'a> {\n-    pub fn make(mut self: Box<ParserAnyMacro<'a>>, kind: AstFragmentKind) -> AstFragment {\n+    crate fn make(mut self: Box<ParserAnyMacro<'a>>, kind: AstFragmentKind) -> AstFragment {\n         let ParserAnyMacro { site_span, macro_ident, ref mut parser, arm_span } = *self;\n         let fragment = panictry!(parser.parse_ast_fragment(kind, true).map_err(|mut e| {\n             if parser.token == token::Eof && e.message().ends_with(\", found `<eof>`\") {\n@@ -131,8 +135,8 @@ struct MacroRulesMacroExpander {\n     name: ast::Ident,\n     span: Span,\n     transparency: Transparency,\n-    lhses: Vec<quoted::TokenTree>,\n-    rhses: Vec<quoted::TokenTree>,\n+    lhses: Vec<mbe::TokenTree>,\n+    rhses: Vec<mbe::TokenTree>,\n     valid: bool,\n }\n \n@@ -165,8 +169,8 @@ fn generic_extension<'cx>(\n     name: ast::Ident,\n     transparency: Transparency,\n     arg: TokenStream,\n-    lhses: &[quoted::TokenTree],\n-    rhses: &[quoted::TokenTree],\n+    lhses: &[mbe::TokenTree],\n+    rhses: &[mbe::TokenTree],\n ) -> Box<dyn MacResult + 'cx> {\n     if cx.trace_macros() {\n         trace_macros_note(cx, sp, format!(\"expanding `{}! {{ {} }}`\", name, arg));\n@@ -178,15 +182,15 @@ fn generic_extension<'cx>(\n     for (i, lhs) in lhses.iter().enumerate() {\n         // try each arm's matchers\n         let lhs_tt = match *lhs {\n-            quoted::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n+            mbe::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n             _ => cx.span_bug(sp, \"malformed macro lhs\"),\n         };\n \n         match TokenTree::parse(cx, lhs_tt, arg.clone()) {\n             Success(named_matches) => {\n                 let rhs = match rhses[i] {\n                     // ignore delimiters\n-                    quoted::TokenTree::Delimited(_, ref delimed) => delimed.tts.clone(),\n+                    mbe::TokenTree::Delimited(_, ref delimed) => delimed.tts.clone(),\n                     _ => cx.span_bug(sp, \"malformed macro rhs\"),\n                 };\n                 let arm_span = rhses[i].span();\n@@ -254,7 +258,7 @@ fn generic_extension<'cx>(\n         for lhs in lhses {\n             // try each arm's matchers\n             let lhs_tt = match *lhs {\n-                quoted::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n+                mbe::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n                 _ => continue,\n             };\n             match TokenTree::parse(cx, lhs_tt, arg.clone()) {\n@@ -284,8 +288,8 @@ fn generic_extension<'cx>(\n //\n // Holy self-referential!\n \n-/// Converts a `macro_rules!` invocation into a syntax extension.\n-pub fn compile(\n+/// Converts a macro item into a syntax extension.\n+pub fn compile_declarative_macro(\n     sess: &ParseSess,\n     features: &Features,\n     def: &ast::Item,\n@@ -308,32 +312,32 @@ pub fn compile(\n     // ...quasiquoting this would be nice.\n     // These spans won't matter, anyways\n     let argument_gram = vec![\n-        quoted::TokenTree::Sequence(\n+        mbe::TokenTree::Sequence(\n             DelimSpan::dummy(),\n-            Lrc::new(quoted::SequenceRepetition {\n+            Lrc::new(mbe::SequenceRepetition {\n                 tts: vec![\n-                    quoted::TokenTree::MetaVarDecl(def.span, lhs_nm, tt_spec),\n-                    quoted::TokenTree::token(token::FatArrow, def.span),\n-                    quoted::TokenTree::MetaVarDecl(def.span, rhs_nm, tt_spec),\n+                    mbe::TokenTree::MetaVarDecl(def.span, lhs_nm, tt_spec),\n+                    mbe::TokenTree::token(token::FatArrow, def.span),\n+                    mbe::TokenTree::MetaVarDecl(def.span, rhs_nm, tt_spec),\n                 ],\n                 separator: Some(Token::new(\n                     if body.legacy { token::Semi } else { token::Comma },\n                     def.span,\n                 )),\n-                kleene: quoted::KleeneToken::new(quoted::KleeneOp::OneOrMore, def.span),\n+                kleene: mbe::KleeneToken::new(mbe::KleeneOp::OneOrMore, def.span),\n                 num_captures: 2,\n             }),\n         ),\n         // to phase into semicolon-termination instead of semicolon-separation\n-        quoted::TokenTree::Sequence(\n+        mbe::TokenTree::Sequence(\n             DelimSpan::dummy(),\n-            Lrc::new(quoted::SequenceRepetition {\n-                tts: vec![quoted::TokenTree::token(\n+            Lrc::new(mbe::SequenceRepetition {\n+                tts: vec![mbe::TokenTree::token(\n                     if body.legacy { token::Semi } else { token::Comma },\n                     def.span,\n                 )],\n                 separator: None,\n-                kleene: quoted::KleeneToken::new(quoted::KleeneOp::ZeroOrMore, def.span),\n+                kleene: mbe::KleeneToken::new(mbe::KleeneOp::ZeroOrMore, def.span),\n                 num_captures: 0,\n             }),\n         ),\n@@ -363,7 +367,7 @@ pub fn compile(\n             .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        let tt = quoted::parse(\n+                        let tt = mbe::quoted::parse(\n                             tt.clone().into(),\n                             true,\n                             sess,\n@@ -380,7 +384,7 @@ pub fn compile(\n                 }\n                 sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n             })\n-            .collect::<Vec<quoted::TokenTree>>(),\n+            .collect::<Vec<mbe::TokenTree>>(),\n         _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\"),\n     };\n \n@@ -390,7 +394,7 @@ pub fn compile(\n             .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        return quoted::parse(\n+                        return mbe::quoted::parse(\n                             tt.clone().into(),\n                             false,\n                             sess,\n@@ -405,7 +409,7 @@ pub fn compile(\n                 }\n                 sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n             })\n-            .collect::<Vec<quoted::TokenTree>>(),\n+            .collect::<Vec<mbe::TokenTree>>(),\n         _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured rhs\"),\n     };\n \n@@ -450,11 +454,11 @@ fn check_lhs_nt_follows(\n     sess: &ParseSess,\n     features: &Features,\n     attrs: &[ast::Attribute],\n-    lhs: &quoted::TokenTree,\n+    lhs: &mbe::TokenTree,\n ) -> bool {\n     // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n-    if let quoted::TokenTree::Delimited(_, ref tts) = *lhs {\n+    if let mbe::TokenTree::Delimited(_, ref tts) = *lhs {\n         check_matcher(sess, features, attrs, &tts.tts)\n     } else {\n         let msg = \"invalid macro matcher; matchers must be contained in balanced delimiters\";\n@@ -467,8 +471,8 @@ fn check_lhs_nt_follows(\n \n /// Checks that the lhs contains no repetition which could match an empty token\n /// tree, because then the matcher would hang indefinitely.\n-fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[quoted::TokenTree]) -> bool {\n-    use quoted::TokenTree;\n+fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[mbe::TokenTree]) -> bool {\n+    use mbe::TokenTree;\n     for tt in tts {\n         match *tt {\n             TokenTree::Token(..) | TokenTree::MetaVar(..) | TokenTree::MetaVarDecl(..) => (),\n@@ -482,8 +486,8 @@ fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[quoted::TokenTree]) -> bool {\n                     && seq.tts.iter().all(|seq_tt| match *seq_tt {\n                         TokenTree::MetaVarDecl(_, _, id) => id.name == sym::vis,\n                         TokenTree::Sequence(_, ref sub_seq) => {\n-                            sub_seq.kleene.op == quoted::KleeneOp::ZeroOrMore\n-                                || sub_seq.kleene.op == quoted::KleeneOp::ZeroOrOne\n+                            sub_seq.kleene.op == mbe::KleeneOp::ZeroOrMore\n+                                || sub_seq.kleene.op == mbe::KleeneOp::ZeroOrOne\n                         }\n                         _ => false,\n                     })\n@@ -502,9 +506,9 @@ fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[quoted::TokenTree]) -> bool {\n     true\n }\n \n-fn check_rhs(sess: &ParseSess, rhs: &quoted::TokenTree) -> bool {\n+fn check_rhs(sess: &ParseSess, rhs: &mbe::TokenTree) -> bool {\n     match *rhs {\n-        quoted::TokenTree::Delimited(..) => return true,\n+        mbe::TokenTree::Delimited(..) => return true,\n         _ => sess.span_diagnostic.span_err(rhs.span(), \"macro rhs must be delimited\"),\n     }\n     false\n@@ -514,7 +518,7 @@ fn check_matcher(\n     sess: &ParseSess,\n     features: &Features,\n     attrs: &[ast::Attribute],\n-    matcher: &[quoted::TokenTree],\n+    matcher: &[mbe::TokenTree],\n ) -> bool {\n     let first_sets = FirstSets::new(matcher);\n     let empty_suffix = TokenSet::empty();\n@@ -546,8 +550,8 @@ struct FirstSets {\n }\n \n impl FirstSets {\n-    fn new(tts: &[quoted::TokenTree]) -> FirstSets {\n-        use quoted::TokenTree;\n+    fn new(tts: &[mbe::TokenTree]) -> FirstSets {\n+        use mbe::TokenTree;\n \n         let mut sets = FirstSets { first: FxHashMap::default() };\n         build_recur(&mut sets, tts);\n@@ -594,8 +598,8 @@ impl FirstSets {\n \n                         // Reverse scan: Sequence comes before `first`.\n                         if subfirst.maybe_empty\n-                            || seq_rep.kleene.op == quoted::KleeneOp::ZeroOrMore\n-                            || seq_rep.kleene.op == quoted::KleeneOp::ZeroOrOne\n+                            || seq_rep.kleene.op == mbe::KleeneOp::ZeroOrMore\n+                            || seq_rep.kleene.op == mbe::KleeneOp::ZeroOrOne\n                         {\n                             // If sequence is potentially empty, then\n                             // union them (preserving first emptiness).\n@@ -615,8 +619,8 @@ impl FirstSets {\n \n     // walks forward over `tts` until all potential FIRST tokens are\n     // identified.\n-    fn first(&self, tts: &[quoted::TokenTree]) -> TokenSet {\n-        use quoted::TokenTree;\n+    fn first(&self, tts: &[mbe::TokenTree]) -> TokenSet {\n+        use mbe::TokenTree;\n \n         let mut first = TokenSet::empty();\n         for tt in tts.iter() {\n@@ -652,8 +656,8 @@ impl FirstSets {\n                     assert!(first.maybe_empty);\n                     first.add_all(subfirst);\n                     if subfirst.maybe_empty\n-                        || seq_rep.kleene.op == quoted::KleeneOp::ZeroOrMore\n-                        || seq_rep.kleene.op == quoted::KleeneOp::ZeroOrOne\n+                        || seq_rep.kleene.op == mbe::KleeneOp::ZeroOrMore\n+                        || seq_rep.kleene.op == mbe::KleeneOp::ZeroOrOne\n                     {\n                         // Continue scanning for more first\n                         // tokens, but also make sure we\n@@ -674,7 +678,7 @@ impl FirstSets {\n     }\n }\n \n-// A set of `quoted::TokenTree`s, which may include `TokenTree::Match`s\n+// A set of `mbe::TokenTree`s, which may include `TokenTree::Match`s\n // (for macro-by-example syntactic variables). It also carries the\n // `maybe_empty` flag; that is true if and only if the matcher can\n // match an empty token sequence.\n@@ -686,7 +690,7 @@ impl FirstSets {\n // (Notably, we must allow for *-op to occur zero times.)\n #[derive(Clone, Debug)]\n struct TokenSet {\n-    tokens: Vec<quoted::TokenTree>,\n+    tokens: Vec<mbe::TokenTree>,\n     maybe_empty: bool,\n }\n \n@@ -698,13 +702,13 @@ impl TokenSet {\n \n     // Returns the set `{ tok }` for the single-token (and thus\n     // non-empty) sequence [tok].\n-    fn singleton(tok: quoted::TokenTree) -> Self {\n+    fn singleton(tok: mbe::TokenTree) -> Self {\n         TokenSet { tokens: vec![tok], maybe_empty: false }\n     }\n \n     // Changes self to be the set `{ tok }`.\n     // Since `tok` is always present, marks self as non-empty.\n-    fn replace_with(&mut self, tok: quoted::TokenTree) {\n+    fn replace_with(&mut self, tok: mbe::TokenTree) {\n         self.tokens.clear();\n         self.tokens.push(tok);\n         self.maybe_empty = false;\n@@ -719,15 +723,15 @@ impl TokenSet {\n     }\n \n     // Adds `tok` to the set for `self`, marking sequence as non-empy.\n-    fn add_one(&mut self, tok: quoted::TokenTree) {\n+    fn add_one(&mut self, tok: mbe::TokenTree) {\n         if !self.tokens.contains(&tok) {\n             self.tokens.push(tok);\n         }\n         self.maybe_empty = false;\n     }\n \n     // Adds `tok` to the set for `self`. (Leaves `maybe_empty` flag alone.)\n-    fn add_one_maybe(&mut self, tok: quoted::TokenTree) {\n+    fn add_one_maybe(&mut self, tok: mbe::TokenTree) {\n         if !self.tokens.contains(&tok) {\n             self.tokens.push(tok);\n         }\n@@ -768,10 +772,10 @@ fn check_matcher_core(\n     features: &Features,\n     attrs: &[ast::Attribute],\n     first_sets: &FirstSets,\n-    matcher: &[quoted::TokenTree],\n+    matcher: &[mbe::TokenTree],\n     follow: &TokenSet,\n ) -> TokenSet {\n-    use quoted::TokenTree;\n+    use mbe::TokenTree;\n \n     let mut last = TokenSet::empty();\n \n@@ -946,8 +950,8 @@ fn check_matcher_core(\n     last\n }\n \n-fn token_can_be_followed_by_any(tok: &quoted::TokenTree) -> bool {\n-    if let quoted::TokenTree::MetaVarDecl(_, _, frag_spec) = *tok {\n+fn token_can_be_followed_by_any(tok: &mbe::TokenTree) -> bool {\n+    if let mbe::TokenTree::MetaVarDecl(_, _, frag_spec) = *tok {\n         frag_can_be_followed_by_any(frag_spec.name)\n     } else {\n         // (Non NT's can always be followed by anthing in matchers.)\n@@ -993,8 +997,8 @@ enum IsInFollow {\n /// break macros that were relying on that binary operator as a\n /// separator.\n // when changing this do not forget to update doc/book/macros.md!\n-fn is_in_follow(tok: &quoted::TokenTree, frag: Symbol) -> IsInFollow {\n-    use quoted::TokenTree;\n+fn is_in_follow(tok: &mbe::TokenTree, frag: Symbol) -> IsInFollow {\n+    use mbe::TokenTree;\n \n     if let TokenTree::Token(Token { kind: token::CloseDelim(_), .. }) = *tok {\n         // closing a token tree can never be matched by any fragment;\n@@ -1112,10 +1116,10 @@ fn has_legal_fragment_specifier(\n     sess: &ParseSess,\n     features: &Features,\n     attrs: &[ast::Attribute],\n-    tok: &quoted::TokenTree,\n+    tok: &mbe::TokenTree,\n ) -> Result<(), String> {\n     debug!(\"has_legal_fragment_specifier({:?})\", tok);\n-    if let quoted::TokenTree::MetaVarDecl(_, _, ref frag_spec) = *tok {\n+    if let mbe::TokenTree::MetaVarDecl(_, _, ref frag_spec) = *tok {\n         let frag_span = tok.span();\n         if !is_legal_fragment_specifier(sess, features, attrs, frag_spec.name, frag_span) {\n             return Err(frag_spec.to_string());\n@@ -1156,14 +1160,27 @@ fn is_legal_fragment_specifier(\n     }\n }\n \n-fn quoted_tt_to_string(tt: &quoted::TokenTree) -> String {\n+fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n     match *tt {\n-        quoted::TokenTree::Token(ref token) => crate::print::pprust::token_to_string(&token),\n-        quoted::TokenTree::MetaVar(_, name) => format!(\"${}\", name),\n-        quoted::TokenTree::MetaVarDecl(_, name, kind) => format!(\"${}:{}\", name, kind),\n+        mbe::TokenTree::Token(ref token) => crate::print::pprust::token_to_string(&token),\n+        mbe::TokenTree::MetaVar(_, name) => format!(\"${}\", name),\n+        mbe::TokenTree::MetaVarDecl(_, name, kind) => format!(\"${}:{}\", name, kind),\n         _ => panic!(\n-            \"unexpected quoted::TokenTree::{{Sequence or Delimited}} \\\n+            \"unexpected mbe::TokenTree::{{Sequence or Delimited}} \\\n              in follow set checker\"\n         ),\n     }\n }\n+\n+impl TokenTree {\n+    /// Use this token tree as a matcher to parse given tts.\n+    fn parse(cx: &ExtCtxt<'_>, mtch: &[mbe::TokenTree], tts: TokenStream)\n+             -> NamedParseResult {\n+        // `None` is because we're not interpolating\n+        let directory = Directory {\n+            path: Cow::from(cx.current_expansion.module.directory.as_path()),\n+            ownership: cx.current_expansion.directory_ownership,\n+        };\n+        parse(cx.parse_sess(), tts, mtch, Some(directory), true)\n+    }\n+}", "previous_filename": "src/libsyntax/ext/tt/macro_rules.rs"}, {"sha": "3952e29a5f0d1fbdb489a1912bb186173fecdf53", "filename": "src/libsyntax/ext/mbe/quoted.rs", "status": "renamed", "additions": 6, "deletions": 166, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Fext%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Fext%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe%2Fquoted.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -1,179 +1,19 @@\n use crate::ast;\n use crate::ast::NodeId;\n-use crate::ext::tt::macro_parser;\n+use crate::ext::mbe::macro_parser;\n+use crate::ext::mbe::{TokenTree, KleeneOp, KleeneToken, SequenceRepetition, Delimited};\n use crate::feature_gate::Features;\n-use crate::parse::token::{self, Token, TokenKind};\n+use crate::parse::token::{self, Token};\n use crate::parse::ParseSess;\n use crate::print::pprust;\n use crate::symbol::kw;\n-use crate::tokenstream::{self, DelimSpan};\n+use crate::tokenstream;\n \n-use syntax_pos::{edition::Edition, BytePos, Span};\n+use syntax_pos::{edition::Edition, Span};\n \n use rustc_data_structures::sync::Lrc;\n use std::iter::Peekable;\n \n-/// Contains the sub-token-trees of a \"delimited\" token tree, such as the contents of `(`. Note\n-/// that the delimiter itself might be `NoDelim`.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n-pub struct Delimited {\n-    pub delim: token::DelimToken,\n-    pub tts: Vec<TokenTree>,\n-}\n-\n-impl Delimited {\n-    /// Returns a `self::TokenTree` with a `Span` corresponding to the opening delimiter.\n-    pub fn open_tt(&self, span: Span) -> TokenTree {\n-        let open_span = if span.is_dummy() {\n-            span\n-        } else {\n-            span.with_hi(span.lo() + BytePos(self.delim.len() as u32))\n-        };\n-        TokenTree::token(token::OpenDelim(self.delim), open_span)\n-    }\n-\n-    /// Returns a `self::TokenTree` with a `Span` corresponding to the closing delimiter.\n-    pub fn close_tt(&self, span: Span) -> TokenTree {\n-        let close_span = if span.is_dummy() {\n-            span\n-        } else {\n-            span.with_lo(span.hi() - BytePos(self.delim.len() as u32))\n-        };\n-        TokenTree::token(token::CloseDelim(self.delim), close_span)\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n-pub struct SequenceRepetition {\n-    /// The sequence of token trees\n-    pub tts: Vec<TokenTree>,\n-    /// The optional separator\n-    pub separator: Option<Token>,\n-    /// Whether the sequence can be repeated zero (*), or one or more times (+)\n-    pub kleene: KleeneToken,\n-    /// The number of `Match`s that appear in the sequence (and subsequences)\n-    pub num_captures: usize,\n-}\n-\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n-pub struct KleeneToken {\n-    pub span: Span,\n-    pub op: KleeneOp,\n-}\n-\n-impl KleeneToken {\n-    pub fn new(op: KleeneOp, span: Span) -> KleeneToken {\n-        KleeneToken { span, op }\n-    }\n-}\n-\n-/// A Kleene-style [repetition operator](http://en.wikipedia.org/wiki/Kleene_star)\n-/// for token sequences.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub enum KleeneOp {\n-    /// Kleene star (`*`) for zero or more repetitions\n-    ZeroOrMore,\n-    /// Kleene plus (`+`) for one or more repetitions\n-    OneOrMore,\n-    /// Kleene optional (`?`) for zero or one reptitions\n-    ZeroOrOne,\n-}\n-\n-/// Similar to `tokenstream::TokenTree`, except that `$i`, `$i:ident`, and `$(...)`\n-/// are \"first-class\" token trees. Useful for parsing macros.\n-#[derive(Debug, Clone, PartialEq, RustcEncodable, RustcDecodable)]\n-pub enum TokenTree {\n-    Token(Token),\n-    Delimited(DelimSpan, Lrc<Delimited>),\n-    /// A kleene-style repetition sequence\n-    Sequence(DelimSpan, Lrc<SequenceRepetition>),\n-    /// e.g., `$var`\n-    MetaVar(Span, ast::Ident),\n-    /// e.g., `$var:expr`. This is only used in the left hand side of MBE macros.\n-    MetaVarDecl(\n-        Span,\n-        ast::Ident, /* name to bind */\n-        ast::Ident, /* kind of nonterminal */\n-    ),\n-}\n-\n-impl TokenTree {\n-    /// Return the number of tokens in the tree.\n-    pub fn len(&self) -> usize {\n-        match *self {\n-            TokenTree::Delimited(_, ref delimed) => match delimed.delim {\n-                token::NoDelim => delimed.tts.len(),\n-                _ => delimed.tts.len() + 2,\n-            },\n-            TokenTree::Sequence(_, ref seq) => seq.tts.len(),\n-            _ => 0,\n-        }\n-    }\n-\n-    /// Returns `true` if the given token tree contains no other tokens. This is vacuously true for\n-    /// single tokens or metavar/decls, but may be false for delimited trees or sequences.\n-    pub fn is_empty(&self) -> bool {\n-        match *self {\n-            TokenTree::Delimited(_, ref delimed) => match delimed.delim {\n-                token::NoDelim => delimed.tts.is_empty(),\n-                _ => false,\n-            },\n-            TokenTree::Sequence(_, ref seq) => seq.tts.is_empty(),\n-            _ => true,\n-        }\n-    }\n-\n-    /// Returns `true` if the given token tree is delimited.\n-    pub fn is_delimited(&self) -> bool {\n-        match *self {\n-            TokenTree::Delimited(..) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    /// Returns `true` if the given token tree is a token of the given kind.\n-    pub fn is_token(&self, expected_kind: &TokenKind) -> bool {\n-        match self {\n-            TokenTree::Token(Token { kind: actual_kind, .. }) => actual_kind == expected_kind,\n-            _ => false,\n-        }\n-    }\n-\n-    /// Gets the `index`-th sub-token-tree. This only makes sense for delimited trees and sequences.\n-    pub fn get_tt(&self, index: usize) -> TokenTree {\n-        match (self, index) {\n-            (&TokenTree::Delimited(_, ref delimed), _) if delimed.delim == token::NoDelim => {\n-                delimed.tts[index].clone()\n-            }\n-            (&TokenTree::Delimited(span, ref delimed), _) => {\n-                if index == 0 {\n-                    return delimed.open_tt(span.open);\n-                }\n-                if index == delimed.tts.len() + 1 {\n-                    return delimed.close_tt(span.close);\n-                }\n-                delimed.tts[index - 1].clone()\n-            }\n-            (&TokenTree::Sequence(_, ref seq), _) => seq.tts[index].clone(),\n-            _ => panic!(\"Cannot expand a token tree\"),\n-        }\n-    }\n-\n-    /// Retrieves the `TokenTree`'s span.\n-    pub fn span(&self) -> Span {\n-        match *self {\n-            TokenTree::Token(Token { span, .. })\n-            | TokenTree::MetaVar(span, _)\n-            | TokenTree::MetaVarDecl(span, _, _) => span,\n-            TokenTree::Delimited(span, _) | TokenTree::Sequence(span, _) => span.entire(),\n-        }\n-    }\n-\n-    crate fn token(kind: TokenKind, span: Span) -> TokenTree {\n-        TokenTree::Token(Token::new(kind, span))\n-    }\n-}\n-\n /// Takes a `tokenstream::TokenStream` and returns a `Vec<self::TokenTree>`. Specifically, this\n /// takes a generic `TokenStream`, such as is used in the rest of the compiler, and returns a\n /// collection of `TokenTree` for use in parsing a macro.\n@@ -195,7 +35,7 @@ impl TokenTree {\n /// # Returns\n ///\n /// A collection of `self::TokenTree`. There may also be some errors emitted to `sess`.\n-pub fn parse(\n+pub(super) fn parse(\n     input: tokenstream::TokenStream,\n     expect_matchers: bool,\n     sess: &ParseSess,", "previous_filename": "src/libsyntax/ext/tt/quoted.rs"}, {"sha": "ba818ebd35c7fdb1aac48e40b0417b7abfb59e51", "filename": "src/libsyntax/ext/mbe/transcribe.rs", "status": "renamed", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Fext%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Fext%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe%2Ftranscribe.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -1,7 +1,7 @@\n use crate::ast::{Ident, Mac};\n use crate::ext::base::ExtCtxt;\n-use crate::ext::tt::macro_parser::{MatchedNonterminal, MatchedSeq, NamedMatch};\n-use crate::ext::tt::quoted;\n+use crate::ext::mbe;\n+use crate::ext::mbe::macro_parser::{MatchedNonterminal, MatchedSeq, NamedMatch};\n use crate::mut_visit::{self, MutVisitor};\n use crate::parse::token::{self, NtTT, Token};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n@@ -38,22 +38,22 @@ impl Marker {\n \n /// An iterator over the token trees in a delimited token tree (`{ ... }`) or a sequence (`$(...)`).\n enum Frame {\n-    Delimited { forest: Lrc<quoted::Delimited>, idx: usize, span: DelimSpan },\n-    Sequence { forest: Lrc<quoted::SequenceRepetition>, idx: usize, sep: Option<Token> },\n+    Delimited { forest: Lrc<mbe::Delimited>, idx: usize, span: DelimSpan },\n+    Sequence { forest: Lrc<mbe::SequenceRepetition>, idx: usize, sep: Option<Token> },\n }\n \n impl Frame {\n     /// Construct a new frame around the delimited set of tokens.\n-    fn new(tts: Vec<quoted::TokenTree>) -> Frame {\n-        let forest = Lrc::new(quoted::Delimited { delim: token::NoDelim, tts });\n+    fn new(tts: Vec<mbe::TokenTree>) -> Frame {\n+        let forest = Lrc::new(mbe::Delimited { delim: token::NoDelim, tts });\n         Frame::Delimited { forest, idx: 0, span: DelimSpan::dummy() }\n     }\n }\n \n impl Iterator for Frame {\n-    type Item = quoted::TokenTree;\n+    type Item = mbe::TokenTree;\n \n-    fn next(&mut self) -> Option<quoted::TokenTree> {\n+    fn next(&mut self) -> Option<mbe::TokenTree> {\n         match *self {\n             Frame::Delimited { ref forest, ref mut idx, .. } => {\n                 *idx += 1;\n@@ -90,7 +90,7 @@ impl Iterator for Frame {\n pub(super) fn transcribe(\n     cx: &ExtCtxt<'_>,\n     interp: &FxHashMap<Ident, NamedMatch>,\n-    src: Vec<quoted::TokenTree>,\n+    src: Vec<mbe::TokenTree>,\n     transparency: Transparency,\n ) -> TokenStream {\n     // Nothing for us to transcribe...\n@@ -178,7 +178,7 @@ pub(super) fn transcribe(\n             // We are descending into a sequence. We first make sure that the matchers in the RHS\n             // and the matches in `interp` have the same shape. Otherwise, either the caller or the\n             // macro writer has made a mistake.\n-            seq @ quoted::TokenTree::Sequence(..) => {\n+            seq @ mbe::TokenTree::Sequence(..) => {\n                 match lockstep_iter_size(&seq, interp, &repeats) {\n                     LockstepIterSize::Unconstrained => {\n                         cx.span_fatal(\n@@ -199,15 +199,15 @@ pub(super) fn transcribe(\n                     LockstepIterSize::Constraint(len, _) => {\n                         // We do this to avoid an extra clone above. We know that this is a\n                         // sequence already.\n-                        let (sp, seq) = if let quoted::TokenTree::Sequence(sp, seq) = seq {\n+                        let (sp, seq) = if let mbe::TokenTree::Sequence(sp, seq) = seq {\n                             (sp, seq)\n                         } else {\n                             unreachable!()\n                         };\n \n                         // Is the repetition empty?\n                         if len == 0 {\n-                            if seq.kleene.op == quoted::KleeneOp::OneOrMore {\n+                            if seq.kleene.op == mbe::KleeneOp::OneOrMore {\n                                 // FIXME: this really ought to be caught at macro definition\n                                 // time... It happens when the Kleene operator in the matcher and\n                                 // the body for the same meta-variable do not match.\n@@ -232,7 +232,7 @@ pub(super) fn transcribe(\n             }\n \n             // Replace the meta-var with the matched token tree from the invocation.\n-            quoted::TokenTree::MetaVar(mut sp, mut ident) => {\n+            mbe::TokenTree::MetaVar(mut sp, mut ident) => {\n                 // Find the matched nonterminal from the macro invocation, and use it to replace\n                 // the meta-var.\n                 if let Some(cur_matched) = lookup_cur_matched(ident, interp, &repeats) {\n@@ -269,22 +269,22 @@ pub(super) fn transcribe(\n             // We will produce all of the results of the inside of the `Delimited` and then we will\n             // jump back out of the Delimited, pop the result_stack and add the new results back to\n             // the previous results (from outside the Delimited).\n-            quoted::TokenTree::Delimited(mut span, delimited) => {\n+            mbe::TokenTree::Delimited(mut span, delimited) => {\n                 marker.visit_delim_span(&mut span);\n                 stack.push(Frame::Delimited { forest: delimited, idx: 0, span });\n                 result_stack.push(mem::take(&mut result));\n             }\n \n             // Nothing much to do here. Just push the token to the result, being careful to\n             // preserve syntax context.\n-            quoted::TokenTree::Token(token) => {\n+            mbe::TokenTree::Token(token) => {\n                 let mut tt = TokenTree::Token(token);\n                 marker.visit_tt(&mut tt);\n                 result.push(tt.into());\n             }\n \n             // There should be no meta-var declarations in the invocation of a macro.\n-            quoted::TokenTree::MetaVarDecl(..) => panic!(\"unexpected `TokenTree::MetaVarDecl\"),\n+            mbe::TokenTree::MetaVarDecl(..) => panic!(\"unexpected `TokenTree::MetaVarDecl\"),\n         }\n     }\n }\n@@ -368,11 +368,11 @@ impl LockstepIterSize {\n /// `lookup_cur_matched` will return `None`, which is why this still works even in the presnece of\n /// multiple nested matcher sequences.\n fn lockstep_iter_size(\n-    tree: &quoted::TokenTree,\n+    tree: &mbe::TokenTree,\n     interpolations: &FxHashMap<Ident, NamedMatch>,\n     repeats: &[(usize, usize)],\n ) -> LockstepIterSize {\n-    use quoted::TokenTree;\n+    use mbe::TokenTree;\n     match *tree {\n         TokenTree::Delimited(_, ref delimed) => {\n             delimed.tts.iter().fold(LockstepIterSize::Unconstrained, |size, tt| {", "previous_filename": "src/libsyntax/ext/tt/transcribe.rs"}, {"sha": "b0833010fe071ce5920455c17f8097ae25ebf32c", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -162,19 +162,14 @@ pub mod ext {\n     mod proc_macro_server;\n \n     pub use syntax_pos::hygiene;\n+    pub use mbe::macro_rules::compile_declarative_macro;\n     pub mod allocator;\n     pub mod base;\n     pub mod build;\n     pub mod expand;\n     pub mod proc_macro;\n \n-    pub mod tt {\n-        pub mod transcribe;\n-        pub mod macro_check;\n-        pub mod macro_parser;\n-        pub mod macro_rules;\n-        pub mod quoted;\n-    }\n+    crate mod mbe;\n }\n \n pub mod early_buffered_lints;"}, {"sha": "0d073f0cc97b135315bcc7fed64a94d524ecfbf6", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -24,7 +24,7 @@ use crate::symbol::{kw, sym};\n use std::mem;\n use log::debug;\n use rustc_target::spec::abi::Abi;\n-use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n+use errors::{Applicability, DiagnosticBuilder, DiagnosticId, StashKey};\n \n /// Whether the type alias or associated type is a concrete type or an opaque type.\n #[derive(Debug)]\n@@ -1477,10 +1477,23 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Parse `[\"const\" | (\"static\" \"mut\"?)] $ident \":\" $ty = $expr` with\n+    /// `[\"const\" | (\"static\" \"mut\"?)]` already parsed and stored in `m`.\n+    ///\n+    /// When `m` is `\"const\"`, `$ident` may also be `\"_\"`.\n     fn parse_item_const(&mut self, m: Option<Mutability>) -> PResult<'a, ItemInfo> {\n         let id = if m.is_none() { self.parse_ident_or_underscore() } else { self.parse_ident() }?;\n-        self.expect(&token::Colon)?;\n-        let ty = self.parse_ty()?;\n+\n+        // Parse the type of a `const` or `static mut?` item.\n+        // That is, the `\":\" $ty` fragment.\n+        let ty = if self.token == token::Eq {\n+            self.recover_missing_const_type(id, m)\n+        } else {\n+            // Not `=` so expect `\":\"\" $ty` as usual.\n+            self.expect(&token::Colon)?;\n+            self.parse_ty()?\n+        };\n+\n         self.expect(&token::Eq)?;\n         let e = self.parse_expr()?;\n         self.expect(&token::Semi)?;\n@@ -1491,6 +1504,34 @@ impl<'a> Parser<'a> {\n         Ok((id, item, None))\n     }\n \n+    /// We were supposed to parse `:` but instead, we're already at `=`.\n+    /// This means that the type is missing.\n+    fn recover_missing_const_type(&mut self, id: Ident, m: Option<Mutability>) -> P<Ty> {\n+        // Construct the error and stash it away with the hope\n+        // that typeck will later enrich the error with a type.\n+        let kind = match m {\n+            Some(Mutability::Mutable) => \"static mut\",\n+            Some(Mutability::Immutable) => \"static\",\n+            None => \"const\",\n+        };\n+        let mut err = self.struct_span_err(id.span, &format!(\"missing type for `{}` item\", kind));\n+        err.span_suggestion(\n+            id.span,\n+            \"provide a type for the item\",\n+            format!(\"{}: <type>\", id),\n+            Applicability::HasPlaceholders,\n+        );\n+        err.stash(id.span, StashKey::ItemNoType);\n+\n+        // The user intended that the type be inferred,\n+        // so treat this as if the user wrote e.g. `const A: _ = expr;`.\n+        P(Ty {\n+            node: TyKind::Infer,\n+            span: id.span,\n+            id: ast::DUMMY_NODE_ID,\n+        })\n+    }\n+\n     /// Parses `type Foo = Bar;` or returns `None`\n     /// without modifying the parser state.\n     fn eat_type(&mut self) -> Option<PResult<'a, (Ident, AliasKind, Generics)>> {"}, {"sha": "26cae2a8e7c42fb2d598bf5e6e03b8d1b1d7d740", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -13,9 +13,6 @@\n //! and a borrowed `TokenStream` is sufficient to build an owned `TokenStream` without taking\n //! ownership of the original.\n \n-use crate::ext::base;\n-use crate::ext::tt::{macro_parser, quoted};\n-use crate::parse::Directory;\n use crate::parse::token::{self, DelimToken, Token, TokenKind};\n use crate::print::pprust;\n \n@@ -26,7 +23,6 @@ use rustc_data_structures::sync::Lrc;\n use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use smallvec::{SmallVec, smallvec};\n \n-use std::borrow::Cow;\n use std::{fmt, iter, mem};\n \n #[cfg(test)]\n@@ -63,17 +59,6 @@ where\n {}\n \n impl TokenTree {\n-    /// Use this token tree as a matcher to parse given tts.\n-    pub fn parse(cx: &base::ExtCtxt<'_>, mtch: &[quoted::TokenTree], tts: TokenStream)\n-                 -> macro_parser::NamedParseResult {\n-        // `None` is because we're not interpolating\n-        let directory = Directory {\n-            path: Cow::from(cx.current_expansion.module.directory.as_path()),\n-            ownership: cx.current_expansion.directory_ownership,\n-        };\n-        macro_parser::parse(cx.parse_sess(), tts, mtch, Some(directory), true)\n-    }\n-\n     /// Checks if this TokenTree is equal to the other, regardless of span information.\n     pub fn eq_unspanned(&self, other: &TokenTree) -> bool {\n         match (self, other) {"}, {"sha": "73310df305b32cb9892b5e5ce2e1327f6ac794c7", "filename": "src/libsyntax_ext/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax_ext%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax_ext%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2FCargo.toml?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -18,4 +18,3 @@ rustc_target = { path = \"../librustc_target\" }\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n-rustc_lexer = { path = \"../librustc_lexer\" }"}, {"sha": "2765346b333cf3e9fe68571574441322727955d2", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -295,7 +295,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             .filter(|fmt| fmt.precision_span.is_some())\n             .count();\n         if self.names.is_empty() && !numbered_position_args && count != self.args.len() {\n-            e = self.ecx.mut_span_err(\n+            e = self.ecx.struct_span_err(\n                 sp,\n                 &format!(\n                     \"{} positional argument{} in format string, but {}\",\n@@ -336,7 +336,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 sp = MultiSpan::from_span(self.fmtsp);\n             }\n \n-            e = self.ecx.mut_span_err(sp,\n+            e = self.ecx.struct_span_err(sp,\n                 &format!(\"invalid reference to positional {} ({})\",\n                          arg_list,\n                          self.describe_num_args()));"}, {"sha": "e290f7fa6b13a97d0fbb1e08fe2d43c55448f683", "filename": "src/test/run-make-fulldeps/issue-19371/foo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -62,6 +62,7 @@ fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n     };\n \n     interface::run_compiler(config, |compiler| {\n-        compiler.compile().ok();\n+        // This runs all the passes prior to linking, too.\n+        compiler.link().ok();\n     });\n }"}, {"sha": "7ac22bb71092e1d245ca2dd3afac865673fd09ca", "filename": "src/test/ui/error-codes/E0023.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Ferror-codes%2FE0023.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Ferror-codes%2FE0023.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0023.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -2,15 +2,16 @@ enum Fruit {\n     Apple(String, String),\n     Pear(u32),\n     Orange((String, String)),\n+    Banana(()),\n }\n \n-\n fn main() {\n     let x = Fruit::Apple(String::new(), String::new());\n     match x {\n         Fruit::Apple(a) => {}, //~ ERROR E0023\n         Fruit::Apple(a, b, c) => {}, //~ ERROR E0023\n         Fruit::Pear(1, 2) => {}, //~ ERROR E0023\n         Fruit::Orange(a, b) => {}, //~ ERROR E0023\n+        Fruit::Banana() => {}, //~ ERROR E0023\n     }\n }"}, {"sha": "dbce6003a2bad386b398ddb124a346183916954f", "filename": "src/test/ui/error-codes/E0023.stderr", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Ferror-codes%2FE0023.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Ferror-codes%2FE0023.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0023.stderr?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -38,6 +38,19 @@ help: missing parenthesis\n LL |         Fruit::Orange((a, b)) => {},\n    |                       ^    ^\n \n-error: aborting due to 4 previous errors\n+error[E0023]: this pattern has 0 fields, but the corresponding tuple variant has 1 field\n+  --> $DIR/E0023.rs:15:9\n+   |\n+LL |     Banana(()),\n+   |     ---------- tuple variant defined here\n+...\n+LL |         Fruit::Banana() => {},\n+   |         ^^^^^^^^^^^^^^^ expected 1 field, found 0\n+help: missing parenthesis\n+   |\n+LL |         Fruit::Banana(()) => {},\n+   |                      ^  ^\n+\n+error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0023`."}, {"sha": "c767578120883a01d34bb99957329727a95faba9", "filename": "src/test/ui/impl-trait/auto-trait.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -0,0 +1,23 @@\n+// Tests that type alias impls traits do not leak auto-traits for\n+// the purposes of coherence checking\n+#![feature(type_alias_impl_trait)]\n+\n+trait OpaqueTrait { }\n+impl<T> OpaqueTrait for T { }\n+type OpaqueType = impl OpaqueTrait;\n+fn mk_opaque() -> OpaqueType { () }\n+\n+#[derive(Debug)]\n+struct D<T>(T);\n+\n+trait AnotherTrait { }\n+impl<T: Send> AnotherTrait for T { }\n+\n+// This is in error, because we cannot assume that `OpaqueType: !Send`.\n+// (We treat opaque types as \"foreign types\" that could grow more impls\n+// in the future.)\n+impl AnotherTrait for D<OpaqueType> {\n+    //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n+}\n+\n+fn main() {}"}, {"sha": "5e72ca7a47ba1d82538efd9c17fece77a3000748", "filename": "src/test/ui/impl-trait/auto-trait.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -0,0 +1,12 @@\n+error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`:\n+  --> $DIR/auto-trait.rs:19:1\n+   |\n+LL | impl<T: Send> AnotherTrait for T { }\n+   | -------------------------------- first implementation here\n+...\n+LL | impl AnotherTrait for D<OpaqueType> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<OpaqueType>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "4977f9bdbacd9a34fa72f9ad0414157c6dd4e504", "filename": "src/test/ui/impl-trait/negative-reasoning.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -0,0 +1,22 @@\n+// Tests that we cannot assume that an opaque type does *not* implement some\n+// other trait\n+#![feature(type_alias_impl_trait)]\n+\n+trait OpaqueTrait { }\n+impl<T> OpaqueTrait for T { }\n+type OpaqueType = impl OpaqueTrait;\n+fn mk_opaque() -> OpaqueType { () }\n+\n+#[derive(Debug)]\n+struct D<T>(T);\n+\n+trait AnotherTrait { }\n+impl<T: std::fmt::Debug> AnotherTrait for T { }\n+\n+\n+// This is in error, because we cannot assume that `OpaqueType: !Debug`\n+impl AnotherTrait for D<OpaqueType> {\n+    //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n+}\n+\n+fn main() {}"}, {"sha": "526a664726ac26fa6da82b4b18b384f81be7b898", "filename": "src/test/ui/impl-trait/negative-reasoning.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -0,0 +1,14 @@\n+error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`:\n+  --> $DIR/negative-reasoning.rs:18:1\n+   |\n+LL | impl<T: std::fmt::Debug> AnotherTrait for T { }\n+   | ------------------------------------------- first implementation here\n+...\n+LL | impl AnotherTrait for D<OpaqueType> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<OpaqueType>`\n+   |\n+   = note: upstream crates may add a new impl of trait `std::fmt::Debug` for type `OpaqueType` in future versions\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "99200a965dd2160b58e2f3d43e8d0324ba0340f4", "filename": "src/test/ui/suggestions/const-no-type.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -0,0 +1,46 @@\n+// In the cases below, the type is missing from the `const` and `static` items.\n+//\n+// Here, we test that we:\n+//\n+// a) Perform parser recovery.\n+//\n+// b) Emit a diagnostic with the actual inferred type to RHS of `=` as the suggestion.\n+\n+fn main() {}\n+\n+// These will not reach typeck:\n+\n+#[cfg(FALSE)]\n+const C2 = 42;\n+//~^ ERROR missing type for `const` item\n+//~| HELP provide a type for the item\n+//~| SUGGESTION C2: <type>\n+\n+#[cfg(FALSE)]\n+static S2 = \"abc\";\n+//~^ ERROR missing type for `static` item\n+//~| HELP provide a type for the item\n+//~| SUGGESTION S2: <type>\n+\n+#[cfg(FALSE)]\n+static mut SM2 = \"abc\";\n+//~^ ERROR missing type for `static mut` item\n+//~| HELP provide a type for the item\n+//~| SUGGESTION SM2: <type>\n+\n+// These will, so the diagnostics should be stolen by typeck:\n+\n+const C = 42;\n+//~^ ERROR missing type for `const` item\n+//~| HELP provide a type for the item\n+//~| SUGGESTION C: i32\n+\n+static S = Vec::<String>::new();\n+//~^ ERROR missing type for `static` item\n+//~| HELP provide a type for the item\n+//~| SUGGESTION S: std::vec::Vec<std::string::String>\n+\n+static mut SM = \"abc\";\n+//~^ ERROR missing type for `static mut` item\n+//~| HELP provide a type for the item\n+//~| SUGGESTION &'static str"}, {"sha": "c4f17109dc5c75e48c558bbaa7c3e54268c45e87", "filename": "src/test/ui/suggestions/const-no-type.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.stderr?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -0,0 +1,38 @@\n+error: missing type for `const` item\n+  --> $DIR/const-no-type.rs:33:7\n+   |\n+LL | const C = 42;\n+   |       ^ help: provide a type for the item: `C: i32`\n+\n+error: missing type for `static` item\n+  --> $DIR/const-no-type.rs:38:8\n+   |\n+LL | static S = Vec::<String>::new();\n+   |        ^ help: provide a type for the item: `S: std::vec::Vec<std::string::String>`\n+\n+error: missing type for `static mut` item\n+  --> $DIR/const-no-type.rs:43:12\n+   |\n+LL | static mut SM = \"abc\";\n+   |            ^^ help: provide a type for the item: `SM: &'static str`\n+\n+error: missing type for `const` item\n+  --> $DIR/const-no-type.rs:14:7\n+   |\n+LL | const C2 = 42;\n+   |       ^^ help: provide a type for the item: `C2: <type>`\n+\n+error: missing type for `static` item\n+  --> $DIR/const-no-type.rs:20:8\n+   |\n+LL | static S2 = \"abc\";\n+   |        ^^ help: provide a type for the item: `S2: <type>`\n+\n+error: missing type for `static mut` item\n+  --> $DIR/const-no-type.rs:26:12\n+   |\n+LL | static mut SM2 = \"abc\";\n+   |            ^^^ help: provide a type for the item: `SM2: <type>`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "52802dd8fbb477b5e1ec4150693d1ea7bb32e0d2", "filename": "src/test/ui/type-alias-impl-trait/auxiliary/foreign-crate.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauxiliary%2Fforeign-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauxiliary%2Fforeign-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauxiliary%2Fforeign-crate.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -0,0 +1,2 @@\n+pub trait ForeignTrait {}\n+pub struct ForeignType<T>(pub T);"}, {"sha": "1c0f83d6c12da643ed6803a60db80bd303345c3a", "filename": "src/test/ui/type-alias-impl-trait/coherence.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -0,0 +1,17 @@\n+// aux-build:foreign-crate.rs\n+#![feature(type_alias_impl_trait)]\n+\n+extern crate foreign_crate;\n+\n+trait LocalTrait {}\n+impl<T> LocalTrait for foreign_crate::ForeignType<T> {}\n+\n+type AliasOfForeignType<T> = impl LocalTrait;\n+fn use_alias<T>(val: T) -> AliasOfForeignType<T> {\n+    foreign_crate::ForeignType(val)\n+}\n+\n+impl<T> foreign_crate::ForeignTrait for AliasOfForeignType<T> {}\n+//~^ ERROR the type parameter `T` is not constrained by the impl trait, self type, or predicates\n+\n+fn main() {}"}, {"sha": "6ede0fa14ba707abf6d2b180935d86e69d52ac19", "filename": "src/test/ui/type-alias-impl-trait/coherence.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -0,0 +1,9 @@\n+error[E0207]: the type parameter `T` is not constrained by the impl trait, self type, or predicates\n+  --> $DIR/coherence.rs:14:6\n+   |\n+LL | impl<T> foreign_crate::ForeignTrait for AliasOfForeignType<T> {}\n+   |      ^ unconstrained type parameter\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0207`."}, {"sha": "28f4a85c9f29039b45a1391c184361e67a43e2e2", "filename": "src/test/ui/type-alias-impl-trait/issue-63677-type-alias-coherence.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63677-type-alias-coherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd473d7b554a82013913244da8aba1e22a002a9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63677-type-alias-coherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63677-type-alias-coherence.rs?ref=dcd473d7b554a82013913244da8aba1e22a002a9", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+// Regression test for issue #63677 - ensure that\n+// coherence checking can properly handle 'impl trait'\n+// in type aliases\n+#![feature(type_alias_impl_trait)]\n+\n+pub trait Trait {}\n+pub struct S1<T>(T);\n+pub struct S2<T>(T);\n+\n+pub type T1 = impl Trait;\n+pub type T2 = S1<T1>;\n+pub type T3 = S2<T2>;\n+\n+impl<T> Trait for S1<T> {}\n+impl<T: Trait> S2<T> {}\n+impl T3 {}\n+\n+pub fn use_t1() -> T1 { S1(()) }\n+\n+fn main() {}"}]}