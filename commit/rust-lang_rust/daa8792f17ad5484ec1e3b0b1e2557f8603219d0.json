{"sha": "daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhYTg3OTJmMTdhZDU0ODRlYzFlM2IwYjFlMjU1N2Y4NjAzMjE5ZDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-19T22:51:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-19T22:51:39Z"}, "message": "Auto merge of #54252 - arielb1:deref-query, r=nikomatsakis\n\nprocess nested obligations in autoderef\n\nFixes #53843.\n\nr? @nikomatsakis", "tree": {"sha": "526ffe35c2e094649bc7c142b8f15ee08a4a10ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/526ffe35c2e094649bc7c142b8f15ee08a4a10ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "html_url": "https://github.com/rust-lang/rust/commit/daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "790f4c566d9802dfcadc26398dde2051cfe6ec9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/790f4c566d9802dfcadc26398dde2051cfe6ec9f", "html_url": "https://github.com/rust-lang/rust/commit/790f4c566d9802dfcadc26398dde2051cfe6ec9f"}, {"sha": "b4db387a6c886d4242a94d997c48967abd63314c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4db387a6c886d4242a94d997c48967abd63314c", "html_url": "https://github.com/rust-lang/rust/commit/b4db387a6c886d4242a94d997c48967abd63314c"}], "stats": {"total": 680, "additions": 488, "deletions": 192}, "files": [{"sha": "f4d7ef59404cca050ad4beda0002d6aab48636b5", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "patch": "@@ -669,6 +669,7 @@ define_dep_nodes!( <'tcx>\n     [] TypeOpNormalizeFnSig(CanonicalTypeOpNormalizeGoal<'tcx, FnSig<'tcx>>),\n \n     [] SubstituteNormalizeAndTestPredicates { key: (DefId, &'tcx Substs<'tcx>) },\n+    [] MethodAutoderefSteps(CanonicalTyGoal<'tcx>),\n \n     [input] TargetFeaturesWhitelist,\n "}, {"sha": "2a8a340ab545280717bbe2a67817fd396f36cdf1", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "patch": "@@ -117,6 +117,31 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         Ok(Lrc::new(canonical_result))\n     }\n \n+    /// A version of `make_canonicalized_query_response` that does\n+    /// not pack in obligations, for contexts that want to drop\n+    /// pending obligations instead of treating them as an ambiguity (e.g.\n+    /// typeck \"probing\" contexts).\n+    ///\n+    /// If you DO want to keep track of pending obligations (which\n+    /// include all region obligations, so this includes all cases\n+    /// that care about regions) with this function, you have to\n+    /// do it yourself, by e.g. having them be a part of the answer.\n+    pub fn make_query_response_ignoring_pending_obligations<T>(\n+        &self,\n+        inference_vars: CanonicalVarValues<'tcx>,\n+        answer: T\n+    ) -> Canonical<'gcx, QueryResponse<'gcx, <T as Lift<'gcx>>::Lifted>>\n+    where\n+        T: Debug + Lift<'gcx> + TypeFoldable<'tcx>,\n+    {\n+        self.canonicalize_response(&QueryResponse {\n+            var_values: inference_vars,\n+            region_constraints: vec![],\n+            certainty: Certainty::Proven, // Ambiguities are OK!\n+            value: answer,\n+        })\n+    }\n+\n     /// Helper for `make_canonicalized_query_response` that does\n     /// everything up until the final canonicalization.\n     fn make_query_response<T>("}, {"sha": "09c7bd679705a8c3e27e2c270677e90698ceb548", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "patch": "@@ -61,6 +61,16 @@ pub struct FulfillmentContext<'tcx> {\n     // type-lives-for-region constraints, and because the type\n     // is well-formed, the constraints should hold.\n     register_region_obligations: bool,\n+    // Is it OK to register obligations into this infcx inside\n+    // an infcx snapshot?\n+    //\n+    // The \"primary fulfillment\" in many cases in typeck lives\n+    // outside of any snapshot, so any use of it inside a snapshot\n+    // will lead to trouble and therefore is checked against, but\n+    // other fulfillment contexts sometimes do live inside of\n+    // a snapshot (they don't *straddle* a snapshot, so there\n+    // is no trouble there).\n+    usable_in_snapshot: bool\n }\n \n #[derive(Clone, Debug)]\n@@ -74,14 +84,24 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n-            register_region_obligations: true\n+            register_region_obligations: true,\n+            usable_in_snapshot: false,\n+        }\n+    }\n+\n+    pub fn new_in_snapshot() -> FulfillmentContext<'tcx> {\n+        FulfillmentContext {\n+            predicates: ObligationForest::new(),\n+            register_region_obligations: true,\n+            usable_in_snapshot: true,\n         }\n     }\n \n     pub fn new_ignoring_regions() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n-            register_region_obligations: false\n+            register_region_obligations: false,\n+            usable_in_snapshot: false\n         }\n     }\n \n@@ -195,7 +215,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n \n         debug!(\"register_predicate_obligation(obligation={:?})\", obligation);\n \n-        assert!(!infcx.is_in_snapshot());\n+        assert!(!infcx.is_in_snapshot() || self.usable_in_snapshot);\n \n         self.predicates.register_obligation(PendingPredicateObligation {\n             obligation,"}, {"sha": "175883eb2a73458febddcd9faab1b8d7cf415353", "filename": "src/librustc/traits/query/method_autoderef.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs?ref=daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc_data_structures::sync::Lrc;\n+use infer::canonical::{Canonical, QueryResponse};\n+use ty::Ty;\n+\n+#[derive(Debug)]\n+pub struct CandidateStep<'tcx> {\n+    pub self_ty: Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n+    pub autoderefs: usize,\n+    // true if the type results from a dereference of a raw pointer.\n+    // when assembling candidates, we include these steps, but not when\n+    // picking methods. This so that if we have `foo: *const Foo` and `Foo` has methods\n+    // `fn by_raw_ptr(self: *const Self)` and `fn by_ref(&self)`, then\n+    // `foo.by_raw_ptr()` will work and `foo.by_ref()` won't.\n+    pub from_unsafe_deref: bool,\n+    pub unsize: bool,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct MethodAutoderefStepsResult<'tcx> {\n+    /// The valid autoderef steps that could be find.\n+    pub steps: Lrc<Vec<CandidateStep<'tcx>>>,\n+    /// If Some(T), a type autoderef reported an error on.\n+    pub opt_bad_ty: Option<Lrc<MethodAutoderefBadTy<'tcx>>>,\n+    /// If `true`, `steps` has been truncated due to reaching the\n+    /// recursion limit.\n+    pub reached_recursion_limit: bool,\n+}\n+\n+#[derive(Debug)]\n+pub struct MethodAutoderefBadTy<'tcx> {\n+    pub reached_raw_pointer: bool,\n+    pub ty: Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n+}\n+\n+impl_stable_hash_for!(struct MethodAutoderefBadTy<'tcx> {\n+    reached_raw_pointer, ty\n+});\n+\n+impl_stable_hash_for!(struct MethodAutoderefStepsResult<'tcx> {\n+    reached_recursion_limit, steps, opt_bad_ty\n+});\n+\n+impl_stable_hash_for!(struct CandidateStep<'tcx> {\n+    self_ty, autoderefs, from_unsafe_deref, unsize\n+});"}, {"sha": "b11cb7377645c3a5344e21c60dce6526998e52f2", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "patch": "@@ -21,6 +21,7 @@ use ty::{self, Ty};\n \n pub mod dropck_outlives;\n pub mod evaluate_obligation;\n+pub mod method_autoderef;\n pub mod normalize;\n pub mod normalize_erasing_regions;\n pub mod outlives_bounds;"}, {"sha": "b320c29dfada5f10a1aad4301ab1bbab70eb06b9", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "patch": "@@ -827,6 +827,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::substitute_normalize_and_test_pre\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::method_autoderef_steps<'tcx> {\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTyGoal<'tcx>) -> Cow<'static, str> {\n+        format!(\"computing autoderef types for `{:?}`\", goal).into()\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::target_features_whitelist<'tcx> {\n     fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n         \"looking up the whitelist of target features\".into()"}, {"sha": "c9ffab21b786ccfadf3beb718767cb64a7dc87ff", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "patch": "@@ -40,6 +40,7 @@ use traits::query::{\n     CanonicalTypeOpSubtypeGoal, CanonicalTypeOpProvePredicateGoal,\n     CanonicalTypeOpNormalizeGoal, NoSolution,\n };\n+use traits::query::method_autoderef::MethodAutoderefStepsResult;\n use traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n use traits::query::normalize::NormalizationResult;\n use traits::query::outlives_bounds::OutlivesBound;\n@@ -668,6 +669,10 @@ define_queries! { <'tcx>\n \n         [] fn substitute_normalize_and_test_predicates:\n             substitute_normalize_and_test_predicates_node((DefId, &'tcx Substs<'tcx>)) -> bool,\n+\n+        [] fn method_autoderef_steps: MethodAutoderefSteps(\n+            CanonicalTyGoal<'tcx>\n+        ) -> MethodAutoderefStepsResult<'tcx>,\n     },\n \n     Other {"}, {"sha": "a73b92ed713ecaf36649cecd9187e3814193a451", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "patch": "@@ -1116,6 +1116,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::TypeOpNormalizePolyFnSig |\n         DepKind::TypeOpNormalizeFnSig |\n         DepKind::SubstituteNormalizeAndTestPredicates |\n+        DepKind::MethodAutoderefSteps |\n         DepKind::InstanceDefSizeEstimate |\n         DepKind::ProgramClausesForEnv |\n "}, {"sha": "d240f45c7d9a459a7da18758531160d0b4e0b880", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 103, "deletions": 61, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "patch": "@@ -8,20 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use astconv::AstConv;\n-\n use super::{FnCtxt, PlaceOp, Needs};\n use super::method::MethodCallee;\n \n-use rustc::infer::InferOk;\n+use rustc::infer::{InferCtxt, InferOk};\n use rustc::session::DiagnosticMessageId;\n-use rustc::traits;\n-use rustc::ty::{self, Ty, TraitRef};\n+use rustc::traits::{self, TraitEngine};\n+use rustc::ty::{self, Ty, TyCtxt, TraitRef};\n use rustc::ty::{ToPredicate, TypeFoldable};\n use rustc::ty::adjustment::{Adjustment, Adjust, OverloadedDeref};\n \n use syntax_pos::Span;\n-use syntax::ast::Ident;\n+use syntax::ast::{self, Ident};\n \n use std::iter;\n \n@@ -32,20 +30,24 @@ enum AutoderefKind {\n }\n \n pub struct Autoderef<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    body_id: ast::NodeId,\n+    param_env: ty::ParamEnv<'tcx>,\n     steps: Vec<(Ty<'tcx>, AutoderefKind)>,\n     cur_ty: Ty<'tcx>,\n     obligations: Vec<traits::PredicateObligation<'tcx>>,\n     at_start: bool,\n     include_raw_pointers: bool,\n     span: Span,\n+    silence_errors: bool,\n+    reached_recursion_limit: bool\n }\n \n impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n     type Item = (Ty<'tcx>, usize);\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        let tcx = self.fcx.tcx;\n+        let tcx = self.infcx.tcx;\n \n         debug!(\"autoderef: steps={:?}, cur_ty={:?}\",\n                self.steps,\n@@ -57,24 +59,10 @@ impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n         }\n \n         if self.steps.len() >= *tcx.sess.recursion_limit.get() {\n-            // We've reached the recursion limit, error gracefully.\n-            let suggested_limit = *tcx.sess.recursion_limit.get() * 2;\n-            let msg = format!(\"reached the recursion limit while auto-dereferencing `{:?}`\",\n-                              self.cur_ty);\n-            let error_id = (DiagnosticMessageId::ErrorId(55), Some(self.span), msg);\n-            let fresh = tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n-            if fresh {\n-                struct_span_err!(tcx.sess,\n-                                 self.span,\n-                                 E0055,\n-                                 \"reached the recursion limit while auto-dereferencing `{:?}`\",\n-                                 self.cur_ty)\n-                    .span_label(self.span, \"deref recursion limit reached\")\n-                    .help(&format!(\n-                        \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n-                        suggested_limit))\n-                    .emit();\n+            if !self.silence_errors {\n+                report_autoderef_recursion_limit_error(tcx, self.span, self.cur_ty);\n             }\n+            self.reached_recursion_limit = true;\n             return None;\n         }\n \n@@ -107,74 +95,105 @@ impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+               param_env: ty::ParamEnv<'tcx>,\n+               body_id: ast::NodeId,\n+               span: Span,\n+               base_ty: Ty<'tcx>)\n+               -> Autoderef<'a, 'gcx, 'tcx>\n+    {\n+        Autoderef {\n+            infcx,\n+            body_id,\n+            param_env,\n+            steps: vec![],\n+            cur_ty: infcx.resolve_type_vars_if_possible(&base_ty),\n+            obligations: vec![],\n+            at_start: true,\n+            include_raw_pointers: false,\n+            silence_errors: false,\n+            reached_recursion_limit: false,\n+            span,\n+        }\n+    }\n+\n     fn overloaded_deref_ty(&mut self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n         debug!(\"overloaded_deref_ty({:?})\", ty);\n \n-        let tcx = self.fcx.tcx();\n+        let tcx = self.infcx.tcx;\n \n         // <cur_ty as Deref>\n         let trait_ref = TraitRef {\n             def_id: tcx.lang_items().deref_trait()?,\n             substs: tcx.mk_substs_trait(self.cur_ty, &[]),\n         };\n \n-        let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n+        let cause = traits::ObligationCause::misc(self.span, self.body_id);\n \n         let obligation = traits::Obligation::new(cause.clone(),\n-                                                 self.fcx.param_env,\n+                                                 self.param_env,\n                                                  trait_ref.to_predicate());\n-        if !self.fcx.predicate_may_hold(&obligation) {\n+        if !self.infcx.predicate_may_hold(&obligation) {\n             debug!(\"overloaded_deref_ty: cannot match obligation\");\n             return None;\n         }\n \n-        let mut selcx = traits::SelectionContext::new(self.fcx);\n-        let normalized_ty = traits::normalize_projection_type(&mut selcx,\n-                                                              self.fcx.param_env,\n-                                                              ty::ProjectionTy::from_ref_and_name(\n-                                                                  tcx,\n-                                                                  trait_ref,\n-                                                                  Ident::from_str(\"Target\"),\n-                                                              ),\n-                                                              cause,\n-                                                              0,\n-                                                              &mut self.obligations);\n-\n-        debug!(\"overloaded_deref_ty({:?}) = {:?}\", ty, normalized_ty);\n+        let mut fulfillcx = traits::FulfillmentContext::new_in_snapshot();\n+        let normalized_ty = fulfillcx.normalize_projection_type(\n+            &self.infcx,\n+            self.param_env,\n+            ty::ProjectionTy::from_ref_and_name(\n+                tcx,\n+                trait_ref,\n+                Ident::from_str(\"Target\"),\n+            ),\n+            cause);\n+        if let Err(e) = fulfillcx.select_where_possible(&self.infcx) {\n+            // This shouldn't happen, except for evaluate/fulfill mismatches,\n+            // but that's not a reason for an ICE (`predicate_may_hold` is conservative\n+            // by design).\n+            debug!(\"overloaded_deref_ty: encountered errors {:?} while fulfilling\",\n+                   e);\n+            return None;\n+        }\n+        let obligations = fulfillcx.pending_obligations();\n+        debug!(\"overloaded_deref_ty({:?}) = ({:?}, {:?})\",\n+               ty, normalized_ty, obligations);\n+        self.obligations.extend(obligations);\n \n-        Some(self.fcx.resolve_type_vars_if_possible(&normalized_ty))\n+        Some(self.infcx.resolve_type_vars_if_possible(&normalized_ty))\n     }\n \n     /// Returns the final type, generating an error if it is an\n     /// unresolved inference variable.\n-    pub fn unambiguous_final_ty(&self) -> Ty<'tcx> {\n-        self.fcx.structurally_resolved_type(self.span, self.cur_ty)\n+    pub fn unambiguous_final_ty(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+        fcx.structurally_resolved_type(self.span, self.cur_ty)\n     }\n \n     /// Returns the final type we ended up with, which may well be an\n     /// inference variable (we will resolve it first, if possible).\n     pub fn maybe_ambiguous_final_ty(&self) -> Ty<'tcx> {\n-        self.fcx.resolve_type_vars_if_possible(&self.cur_ty)\n+        self.infcx.resolve_type_vars_if_possible(&self.cur_ty)\n     }\n \n     pub fn step_count(&self) -> usize {\n         self.steps.len()\n     }\n \n     /// Returns the adjustment steps.\n-    pub fn adjust_steps(&self, needs: Needs)\n+    pub fn adjust_steps(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>, needs: Needs)\n                         -> Vec<Adjustment<'tcx>> {\n-        self.fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(needs))\n+        fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(fcx, needs))\n     }\n \n-    pub fn adjust_steps_as_infer_ok(&self, needs: Needs)\n+    pub fn adjust_steps_as_infer_ok(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>, needs: Needs)\n                                     -> InferOk<'tcx, Vec<Adjustment<'tcx>>> {\n         let mut obligations = vec![];\n         let targets = self.steps.iter().skip(1).map(|&(ty, _)| ty)\n             .chain(iter::once(self.cur_ty));\n         let steps: Vec<_> = self.steps.iter().map(|&(source, kind)| {\n             if let AutoderefKind::Overloaded = kind {\n-                self.fcx.try_overloaded_deref(self.span, source, needs)\n+                fcx.try_overloaded_deref(self.span, source, needs)\n                     .and_then(|InferOk { value: method, obligations: o }| {\n                         obligations.extend(o);\n                         if let ty::Ref(region, _, mutbl) = method.sig.output().sty {\n@@ -211,8 +230,16 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         self\n     }\n \n-    pub fn finalize(self) {\n-        let fcx = self.fcx;\n+    pub fn silence_errors(mut self) -> Self {\n+        self.silence_errors = true;\n+        self\n+    }\n+\n+    pub fn reached_recursion_limit(&self) -> bool {\n+        self.reached_recursion_limit\n+    }\n+\n+    pub fn finalize(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) {\n         fcx.register_predicates(self.into_obligations());\n     }\n \n@@ -221,17 +248,32 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n     }\n }\n \n+pub fn report_autoderef_recursion_limit_error<'a, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>, span: Span, ty: Ty<'tcx>)\n+{\n+    // We've reached the recursion limit, error gracefully.\n+    let suggested_limit = *tcx.sess.recursion_limit.get() * 2;\n+    let msg = format!(\"reached the recursion limit while auto-dereferencing `{:?}`\",\n+                      ty);\n+    let error_id = (DiagnosticMessageId::ErrorId(55), Some(span), msg);\n+    let fresh = tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n+    if fresh {\n+        struct_span_err!(tcx.sess,\n+                         span,\n+                         E0055,\n+                         \"reached the recursion limit while auto-dereferencing `{:?}`\",\n+                         ty)\n+            .span_label(span, \"deref recursion limit reached\")\n+            .help(&format!(\n+                \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n+                suggested_limit))\n+            .emit();\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn autoderef(&'a self, span: Span, base_ty: Ty<'tcx>) -> Autoderef<'a, 'gcx, 'tcx> {\n-        Autoderef {\n-            fcx: self,\n-            steps: vec![],\n-            cur_ty: self.resolve_type_vars_if_possible(&base_ty),\n-            obligations: vec![],\n-            at_start: true,\n-            include_raw_pointers: false,\n-            span,\n-        }\n+        Autoderef::new(self, self.param_env, self.body_id, span, base_ty)\n     }\n \n     pub fn try_overloaded_deref(&self,"}, {"sha": "0ec181e59d0bf9d9ba83f20771e8eabd36506df0", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "patch": "@@ -57,7 +57,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         while result.is_none() && autoderef.next().is_some() {\n             result = self.try_overloaded_call_step(call_expr, callee_expr, &autoderef);\n         }\n-        autoderef.finalize();\n+        autoderef.finalize(self);\n \n         let output = match result {\n             None => {\n@@ -89,15 +89,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 callee_expr: &'gcx hir::Expr,\n                                 autoderef: &Autoderef<'a, 'gcx, 'tcx>)\n                                 -> Option<CallStep<'tcx>> {\n-        let adjusted_ty = autoderef.unambiguous_final_ty();\n+        let adjusted_ty = autoderef.unambiguous_final_ty(self);\n         debug!(\"try_overloaded_call_step(call_expr={:?}, adjusted_ty={:?})\",\n                call_expr,\n                adjusted_ty);\n \n         // If the callee is a bare function or a closure, then we're all set.\n         match adjusted_ty.sty {\n             ty::FnDef(..) | ty::FnPtr(_) => {\n-                let adjustments = autoderef.adjust_steps(Needs::None);\n+                let adjustments = autoderef.adjust_steps(self, Needs::None);\n                 self.apply_adjustments(callee_expr, adjustments);\n                 return Some(CallStep::Builtin(adjusted_ty));\n             }\n@@ -115,7 +115,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         infer::FnCall,\n                         &closure_ty\n                     ).0;\n-                    let adjustments = autoderef.adjust_steps(Needs::None);\n+                    let adjustments = autoderef.adjust_steps(self, Needs::None);\n                     self.record_deferred_call_resolution(def_id, DeferredCallResolution {\n                         call_expr,\n                         callee_expr,\n@@ -145,7 +145,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         self.try_overloaded_call_traits(call_expr, adjusted_ty).map(|(autoref, method)| {\n-            let mut adjustments = autoderef.adjust_steps(Needs::None);\n+            let mut adjustments = autoderef.adjust_steps(self, Needs::None);\n             adjustments.extend(autoref);\n             self.apply_adjustments(callee_expr, adjustments);\n             CallStep::Overloaded(method)"}, {"sha": "d616d88905bbf298a9abff93de591c5fc5931887", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "patch": "@@ -419,7 +419,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         let needs = Needs::maybe_mut_place(mt_b.mutbl);\n         let InferOk { value: mut adjustments, obligations: o }\n-            = autoderef.adjust_steps_as_infer_ok(needs);\n+            = autoderef.adjust_steps_as_infer_ok(self, needs);\n         obligations.extend(o);\n         obligations.extend(autoderef.into_obligations());\n "}, {"sha": "3902dddd0d4761d1007d57b6fae75e44a4fcaec6", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "patch": "@@ -161,9 +161,9 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         let (_, n) = autoderef.nth(pick.autoderefs).unwrap();\n         assert_eq!(n, pick.autoderefs);\n \n-        let mut adjustments = autoderef.adjust_steps(Needs::None);\n+        let mut adjustments = autoderef.adjust_steps(self, Needs::None);\n \n-        let mut target = autoderef.unambiguous_final_ty();\n+        let mut target = autoderef.unambiguous_final_ty(self);\n \n         if let Some(mutbl) = pick.autoref {\n             let region = self.next_region_var(infer::Autoref(self.span));\n@@ -202,7 +202,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             assert!(pick.unsize.is_none());\n         }\n \n-        autoderef.finalize();\n+        autoderef.finalize(self);\n \n         // Write out the final adjustments.\n         self.apply_adjustments(self.self_expr, adjustments);"}, {"sha": "5ecbfcd132cf31c7310d6c1c30ca93ba55e43fe2", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "patch": "@@ -39,6 +39,7 @@ use self::probe::{IsSuggestion, ProbeScope};\n \n pub fn provide(providers: &mut ty::query::Providers) {\n     suggest::provide(providers);\n+    probe::provide(providers);\n }\n \n #[derive(Clone, Copy, Debug)]"}, {"sha": "190419048b4b562b9ca48283a1fa3313e5a7d562", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 196, "deletions": 109, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "patch": "@@ -13,28 +13,35 @@ use super::NoMatchData;\n use super::{CandidateSource, ImplSource, TraitSource};\n use super::suggest;\n \n+use check::autoderef::{self, Autoderef};\n use check::FnCtxt;\n use hir::def_id::DefId;\n use hir::def::Def;\n use namespace::Namespace;\n+\n+use rustc_data_structures::sync::Lrc;\n use rustc::hir;\n use rustc::lint;\n use rustc::session::config::nightly_options;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::{self, ObligationCause};\n-use rustc::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TraitRef, TypeFoldable};\n+use rustc::traits::query::{CanonicalTyGoal};\n+use rustc::traits::query::method_autoderef::{CandidateStep, MethodAutoderefStepsResult};\n+use rustc::traits::query::method_autoderef::{MethodAutoderefBadTy};\n+use rustc::ty::{self, ParamEnvAnd, Ty, TyCtxt, ToPolyTraitRef, ToPredicate, TraitRef, TypeFoldable};\n use rustc::ty::GenericParamDefKind;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::util::nodemap::FxHashSet;\n use rustc::infer::{self, InferOk};\n+use rustc::infer::canonical::{Canonical, QueryResponse};\n+use rustc::infer::canonical::{OriginalQueryValues};\n use rustc::middle::stability;\n use syntax::ast;\n use syntax::util::lev_distance::{lev_distance, find_best_match_for_name};\n-use syntax_pos::{Span, symbol::Symbol};\n+use syntax_pos::{DUMMY_SP, Span, symbol::Symbol};\n use std::iter;\n use std::mem;\n use std::ops::Deref;\n-use std::rc::Rc;\n use std::cmp::max;\n \n use self::CandidateKind::*;\n@@ -51,7 +58,12 @@ struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     mode: Mode,\n     method_name: Option<ast::Ident>,\n     return_type: Option<Ty<'tcx>>,\n-    steps: Rc<Vec<CandidateStep<'tcx>>>,\n+\n+    /// This is the OriginalQueryValues for the steps queries\n+    /// that are answered in steps.\n+    orig_steps_var_values: OriginalQueryValues<'tcx>,\n+    steps: Lrc<Vec<CandidateStep<'gcx>>>,\n+\n     inherent_candidates: Vec<Candidate<'tcx>>,\n     extension_candidates: Vec<Candidate<'tcx>>,\n     impl_dups: FxHashSet<DefId>,\n@@ -81,19 +93,6 @@ impl<'a, 'gcx, 'tcx> Deref for ProbeContext<'a, 'gcx, 'tcx> {\n     }\n }\n \n-#[derive(Debug)]\n-struct CandidateStep<'tcx> {\n-    self_ty: Ty<'tcx>,\n-    autoderefs: usize,\n-    // true if the type results from a dereference of a raw pointer.\n-    // when assembling candidates, we include these steps, but not when\n-    // picking methods. This so that if we have `foo: *const Foo` and `Foo` has methods\n-    // `fn by_raw_ptr(self: *const Self)` and `fn by_ref(&self)`, then\n-    // `foo.by_raw_ptr()` will work and `foo.by_ref()` won't.\n-    from_unsafe_deref: bool,\n-    unsize: bool,\n-}\n-\n #[derive(Debug)]\n struct Candidate<'tcx> {\n     xform_self_ty: Ty<'tcx>,\n@@ -249,42 +248,111 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       -> Result<R, MethodError<'tcx>>\n         where OP: FnOnce(ProbeContext<'a, 'gcx, 'tcx>) -> Result<R, MethodError<'tcx>>\n     {\n-        // FIXME(#18741) -- right now, creating the steps involves evaluating the\n-        // `*` operator, which registers obligations that then escape into\n-        // the global fulfillment context and thus has global\n-        // side-effects. This is a bit of a pain to refactor. So just let\n-        // it ride, although it's really not great, and in fact could I\n-        // think cause spurious errors. Really though this part should\n-        // take place in the `self.probe` below.\n+        let mut orig_values = OriginalQueryValues::default();\n+        let param_env_and_self_ty =\n+            self.infcx.canonicalize_query(\n+                &ParamEnvAnd {\n+                    param_env: self.param_env,\n+                    value: self_ty\n+                }, &mut orig_values);\n+\n         let steps = if mode == Mode::MethodCall {\n-            match self.create_steps(span, scope_expr_id, self_ty, is_suggestion) {\n-                Some(steps) => steps,\n-                None => {\n-                    return Err(MethodError::NoMatch(NoMatchData::new(Vec::new(),\n-                                                                     Vec::new(),\n-                                                                     Vec::new(),\n-                                                                     None,\n-                                                                     mode)))\n-                }\n-            }\n+            self.tcx.method_autoderef_steps(param_env_and_self_ty)\n         } else {\n-            vec![CandidateStep {\n-                     self_ty,\n-                     autoderefs: 0,\n-                     from_unsafe_deref: false,\n-                     unsize: false,\n-                 }]\n+            self.infcx.probe(|_| {\n+                // Mode::Path - the deref steps is \"trivial\". This turns\n+                // our CanonicalQuery into a \"trivial\" QueryResponse. This\n+                // is a bit inefficient, but I don't think that writing\n+                // special handling for this \"trivial case\" is a good idea.\n+\n+                let infcx = &self.infcx;\n+                let (ParamEnvAnd {\n+                    param_env: _,\n+                    value: self_ty\n+                }, canonical_inference_vars) =\n+                    infcx.instantiate_canonical_with_fresh_inference_vars(\n+                        span, &param_env_and_self_ty);\n+                debug!(\"probe_op: Mode::Path, param_env_and_self_ty={:?} self_ty={:?}\",\n+                       param_env_and_self_ty, self_ty);\n+                MethodAutoderefStepsResult {\n+                    steps: Lrc::new(vec![CandidateStep {\n+                        self_ty: self.make_query_response_ignoring_pending_obligations(\n+                            canonical_inference_vars, self_ty),\n+                        autoderefs: 0,\n+                        from_unsafe_deref: false,\n+                        unsize: false,\n+                    }]),\n+                    opt_bad_ty: None,\n+                    reached_recursion_limit: false\n+                }\n+            })\n         };\n \n+        // If our autoderef loop had reached the recursion limit,\n+        // report an overflow error, but continue going on with\n+        // the truncated autoderef list.\n+        if steps.reached_recursion_limit {\n+            self.probe(|_| {\n+                let ty = &steps.steps.last().unwrap_or_else(|| {\n+                    span_bug!(span, \"reached the recursion limit in 0 steps?\")\n+                }).self_ty;\n+                let ty = self.probe_instantiate_query_response(span, &orig_values, ty)\n+                    .unwrap_or_else(|_| span_bug!(span, \"instantiating {:?} failed?\", ty));\n+                autoderef::report_autoderef_recursion_limit_error(self.tcx, span,\n+                                                                  ty.value);\n+            });\n+        }\n+\n+\n+        // If we encountered an `_` type or an error type during autoderef, this is\n+        // ambiguous.\n+        if let Some(bad_ty) = &steps.opt_bad_ty {\n+            if is_suggestion.0 {\n+                // Ambiguity was encountered during a suggestion. Just keep going.\n+                debug!(\"ProbeContext: encountered ambiguity in suggestion\");\n+            } else if bad_ty.reached_raw_pointer && !self.tcx.features().arbitrary_self_types {\n+                // this case used to be allowed by the compiler,\n+                // so we do a future-compat lint here for the 2015 edition\n+                // (see https://github.com/rust-lang/rust/issues/46906)\n+                if self.tcx.sess.rust_2018() {\n+                    span_err!(self.tcx.sess, span, E0699,\n+                              \"the type of this value must be known \\\n+                               to call a method on a raw pointer on it\");\n+                } else {\n+                   self.tcx.lint_node(\n+                        lint::builtin::TYVAR_BEHIND_RAW_POINTER,\n+                        scope_expr_id,\n+                        span,\n+                        \"type annotations needed\");\n+                }\n+            } else {\n+                // Encountered a real ambiguity, so abort the lookup. If `ty` is not\n+                // an `Err`, report the right \"type annotations needed\" error pointing\n+                // to it.\n+                let ty = &bad_ty.ty;\n+                let ty = self.probe_instantiate_query_response(span, &orig_values, ty)\n+                    .unwrap_or_else(|_| span_bug!(span, \"instantiating {:?} failed?\", ty));\n+                let ty = self.structurally_resolved_type(span, ty.value);\n+                assert_eq!(ty, self.tcx.types.err);\n+                return Err(MethodError::NoMatch(NoMatchData::new(Vec::new(),\n+                                                                 Vec::new(),\n+                                                                 Vec::new(),\n+                                                                 None,\n+                                                                 mode)));\n+            }\n+        }\n+\n         debug!(\"ProbeContext: steps for self_ty={:?} are {:?}\",\n                self_ty,\n                steps);\n \n+\n         // this creates one big transaction so that all type variables etc\n         // that we create during the probe process are removed later\n         self.probe(|_| {\n             let mut probe_cx = ProbeContext::new(\n-                self, span, mode, method_name, return_type, Rc::new(steps), is_suggestion,\n+                self, span, mode, method_name, return_type, orig_values,\n+                steps.steps, is_suggestion,\n             );\n \n             probe_cx.assemble_inherent_candidates();\n@@ -297,21 +365,30 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             op(probe_cx)\n         })\n     }\n+}\n+\n+pub fn provide(providers: &mut ty::query::Providers) {\n+    providers.method_autoderef_steps = method_autoderef_steps;\n+}\n+\n+fn method_autoderef_steps<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+                                          goal: CanonicalTyGoal<'tcx>)\n+                                          -> MethodAutoderefStepsResult<'gcx>\n+{\n+    debug!(\"method_autoderef_steps({:?})\", goal);\n \n-    fn create_steps(&self,\n-                    span: Span,\n-                    scope_expr_id: ast::NodeId,\n-                    self_ty: Ty<'tcx>,\n-                    is_suggestion: IsSuggestion)\n-                    -> Option<Vec<CandidateStep<'tcx>>> {\n-        // FIXME: we don't need to create the entire steps in one pass\n+    tcx.infer_ctxt().enter_with_canonical(DUMMY_SP, &goal, |ref infcx, goal, inference_vars| {\n+        let ParamEnvAnd { param_env, value: self_ty } = goal;\n \n-        let mut autoderef = self.autoderef(span, self_ty).include_raw_pointers();\n+        let mut autoderef = Autoderef::new(infcx, param_env, ast::DUMMY_NODE_ID, DUMMY_SP, self_ty)\n+            .include_raw_pointers()\n+            .silence_errors();\n         let mut reached_raw_pointer = false;\n         let mut steps: Vec<_> = autoderef.by_ref()\n             .map(|(ty, d)| {\n                 let step = CandidateStep {\n-                    self_ty: ty,\n+                    self_ty: infcx.make_query_response_ignoring_pending_obligations(\n+                        inference_vars.clone(), ty),\n                     autoderefs: d,\n                     from_unsafe_deref: reached_raw_pointer,\n                     unsize: false,\n@@ -325,68 +402,52 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             .collect();\n \n         let final_ty = autoderef.maybe_ambiguous_final_ty();\n-        match final_ty.sty {\n-            ty::Infer(ty::TyVar(_)) => {\n-                // Ended in an inference variable. If we are doing\n-                // a real method lookup, this is a hard error because it's\n-                // possible that there will be multiple applicable methods.\n-                if !is_suggestion.0 {\n-                    if reached_raw_pointer\n-                    && !self.tcx.features().arbitrary_self_types {\n-                        // this case used to be allowed by the compiler,\n-                        // so we do a future-compat lint here for the 2015 edition\n-                        // (see https://github.com/rust-lang/rust/issues/46906)\n-                        if self.tcx.sess.rust_2018() {\n-                          span_err!(self.tcx.sess, span, E0699,\n-                                    \"the type of this value must be known \\\n-                                     to call a method on a raw pointer on it\");\n-                        } else {\n-                            self.tcx.lint_node(\n-                                lint::builtin::TYVAR_BEHIND_RAW_POINTER,\n-                                scope_expr_id,\n-                                span,\n-                                \"type annotations needed\");\n-                        }\n-                    } else {\n-                        let t = self.structurally_resolved_type(span, final_ty);\n-                        assert_eq!(t, self.tcx.types.err);\n-                        return None\n-                    }\n-                } else {\n-                    // If we're just looking for suggestions,\n-                    // though, ambiguity is no big thing, we can\n-                    // just ignore it.\n-                }\n+        let opt_bad_ty = match final_ty.sty {\n+            ty::Infer(ty::TyVar(_)) |\n+            ty::Error => {\n+                Some(MethodAutoderefBadTy {\n+                    reached_raw_pointer,\n+                    ty: infcx.make_query_response_ignoring_pending_obligations(\n+                        inference_vars, final_ty)\n+                })\n             }\n             ty::Array(elem_ty, _) => {\n                 let dereferences = steps.len() - 1;\n \n                 steps.push(CandidateStep {\n-                    self_ty: self.tcx.mk_slice(elem_ty),\n+                    self_ty: infcx.make_query_response_ignoring_pending_obligations(\n+                        inference_vars, infcx.tcx.mk_slice(elem_ty)),\n                     autoderefs: dereferences,\n                     // this could be from an unsafe deref if we had\n                     // a *mut/const [T; N]\n                     from_unsafe_deref: reached_raw_pointer,\n                     unsize: true,\n                 });\n+\n+                None\n             }\n-            ty::Error => return None,\n-            _ => (),\n-        }\n+            _ => None\n+        };\n \n-        debug!(\"create_steps: steps={:?}\", steps);\n+        debug!(\"method_autoderef_steps: steps={:?} opt_bad_ty={:?}\", steps, opt_bad_ty);\n \n-        Some(steps)\n-    }\n+        MethodAutoderefStepsResult {\n+            steps: Lrc::new(steps),\n+            opt_bad_ty: opt_bad_ty.map(Lrc::new),\n+            reached_recursion_limit: autoderef.reached_recursion_limit()\n+        }\n+    })\n }\n \n+\n impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n            span: Span,\n            mode: Mode,\n            method_name: Option<ast::Ident>,\n            return_type: Option<Ty<'tcx>>,\n-           steps: Rc<Vec<CandidateStep<'tcx>>>,\n+           orig_steps_var_values: OriginalQueryValues<'tcx>,\n+           steps: Lrc<Vec<CandidateStep<'gcx>>>,\n            is_suggestion: IsSuggestion)\n            -> ProbeContext<'a, 'gcx, 'tcx> {\n         ProbeContext {\n@@ -398,7 +459,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             inherent_candidates: Vec::new(),\n             extension_candidates: Vec::new(),\n             impl_dups: FxHashSet::default(),\n-            steps: steps,\n+            orig_steps_var_values,\n+            steps,\n             static_candidates: Vec::new(),\n             allow_similar_names: false,\n             private_candidate: None,\n@@ -443,18 +505,26 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn assemble_inherent_candidates(&mut self) {\n         let steps = self.steps.clone();\n         for step in steps.iter() {\n-            self.assemble_probe(step.self_ty);\n+            self.assemble_probe(&step.self_ty);\n         }\n     }\n \n-    fn assemble_probe(&mut self, self_ty: Ty<'tcx>) {\n+    fn assemble_probe(&mut self, self_ty: &Canonical<'gcx, QueryResponse<'gcx, Ty<'gcx>>>) {\n         debug!(\"assemble_probe: self_ty={:?}\", self_ty);\n         let lang_items = self.tcx.lang_items();\n \n-        match self_ty.sty {\n+        match self_ty.value.value.sty {\n             ty::Dynamic(ref data, ..) => {\n                 let p = data.principal();\n-                self.assemble_inherent_candidates_from_object(self_ty, p);\n+                self.fcx.probe(|_| {\n+                    let InferOk { value: self_ty, obligations: _ } =\n+                        self.fcx.probe_instantiate_query_response(\n+                            self.span, &self.orig_steps_var_values, self_ty)\n+                        .unwrap_or_else(|_| {\n+                            span_bug!(self.span, \"{:?} was applicable but now isn't?\", self_ty)\n+                        });\n+                    self.assemble_inherent_candidates_from_object(self_ty);\n+                });\n                 self.assemble_inherent_impl_candidates_for_type(p.def_id());\n             }\n             ty::Adt(def, _) => {\n@@ -464,7 +534,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 self.assemble_inherent_impl_candidates_for_type(did);\n             }\n             ty::Param(p) => {\n-                self.assemble_inherent_candidates_from_param(self_ty, p);\n+                self.assemble_inherent_candidates_from_param(p);\n             }\n             ty::Char => {\n                 let lang_def_id = lang_items.char_impl();\n@@ -615,11 +685,16 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn assemble_inherent_candidates_from_object(&mut self,\n-                                                self_ty: Ty<'tcx>,\n-                                                principal: ty::PolyExistentialTraitRef<'tcx>) {\n+                                                self_ty: Ty<'tcx>) {\n         debug!(\"assemble_inherent_candidates_from_object(self_ty={:?})\",\n                self_ty);\n \n+        let principal = match self_ty.sty {\n+            ty::Dynamic(ref data, ..) => data.principal(),\n+            _ => span_bug!(self.span, \"non-object {:?} in assemble_inherent_candidates_from_object\",\n+                           self_ty)\n+        };\n+\n         // It is illegal to invoke a method on a trait instance that\n         // refers to the `Self` type. An error will be reported by\n         // `enforce_object_limitations()` if the method refers to the\n@@ -642,7 +717,6 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn assemble_inherent_candidates_from_param(&mut self,\n-                                               _rcvr_ty: Ty<'tcx>,\n                                                param_ty: ty::ParamTy) {\n         // FIXME -- Do we want to commit to this behavior for param bounds?\n \n@@ -898,14 +972,22 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 // a raw pointer\n                 !step.self_ty.references_error() && !step.from_unsafe_deref\n             }).flat_map(|step| {\n-                self.pick_by_value_method(step).or_else(|| {\n-                self.pick_autorefd_method(step, hir::MutImmutable).or_else(|| {\n-                self.pick_autorefd_method(step, hir::MutMutable)\n+                let InferOk { value: self_ty, obligations: _ } =\n+                    self.fcx.probe_instantiate_query_response(\n+                        self.span, &self.orig_steps_var_values, &step.self_ty\n+                    ).unwrap_or_else(|_| {\n+                        span_bug!(self.span, \"{:?} was applicable but now isn't?\", step.self_ty)\n+                    });\n+                self.pick_by_value_method(step, self_ty).or_else(|| {\n+                self.pick_autorefd_method(step, self_ty, hir::MutImmutable).or_else(|| {\n+                self.pick_autorefd_method(step, self_ty, hir::MutMutable)\n             })})})\n             .next()\n     }\n \n-    fn pick_by_value_method(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> {\n+    fn pick_by_value_method(&mut self, step: &CandidateStep<'gcx>, self_ty: Ty<'tcx>)\n+                            -> Option<PickResult<'tcx>>\n+    {\n         //! For each type `T` in the step list, this attempts to find a\n         //! method where the (transformed) self type is exactly `T`. We\n         //! do however do one transformation on the adjustment: if we\n@@ -918,12 +1000,12 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             return None;\n         }\n \n-        self.pick_method(step.self_ty).map(|r| {\n+        self.pick_method(self_ty).map(|r| {\n             r.map(|mut pick| {\n                 pick.autoderefs = step.autoderefs;\n \n                 // Insert a `&*` or `&mut *` if this is a reference type:\n-                if let ty::Ref(_, _, mutbl) = step.self_ty.sty {\n+                if let ty::Ref(_, _, mutbl) = step.self_ty.value.value.sty {\n                     pick.autoderefs += 1;\n                     pick.autoref = Some(mutbl);\n                 }\n@@ -933,7 +1015,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn pick_autorefd_method(&mut self, step: &CandidateStep<'tcx>, mutbl: hir::Mutability)\n+    fn pick_autorefd_method(&mut self,\n+                            step: &CandidateStep<'gcx>,\n+                            self_ty: Ty<'tcx>,\n+                            mutbl: hir::Mutability)\n                             -> Option<PickResult<'tcx>> {\n         let tcx = self.tcx;\n \n@@ -943,14 +1028,14 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         let autoref_ty = tcx.mk_ref(region,\n                                     ty::TypeAndMut {\n-                                        ty: step.self_ty, mutbl\n+                                        ty: self_ty, mutbl\n                                     });\n         self.pick_method(autoref_ty).map(|r| {\n             r.map(|mut pick| {\n                 pick.autoderefs = step.autoderefs;\n                 pick.autoref = Some(mutbl);\n                 pick.unsize = if step.unsize {\n-                    Some(step.self_ty)\n+                    Some(self_ty)\n                 } else {\n                     None\n                 };\n@@ -1288,7 +1373,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         let steps = self.steps.clone();\n         self.probe(|_| {\n             let mut pcx = ProbeContext::new(self.fcx, self.span, self.mode, self.method_name,\n-                                            self.return_type, steps, IsSuggestion(true));\n+                                            self.return_type,\n+                                            self.orig_steps_var_values.clone(),\n+                                            steps, IsSuggestion(true));\n             pcx.allow_similar_names = true;\n             pcx.assemble_inherent_candidates();\n             pcx.assemble_extension_candidates_for_traits_in_scope(ast::DUMMY_NODE_ID)?;"}, {"sha": "77ffdc6811a99be34b7aeee73bc550fe517ecb9b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "patch": "@@ -102,10 +102,11 @@ use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use middle::lang_items;\n use namespace::Namespace;\n+use rustc::infer::{self, InferCtxt, InferOk, InferResult, RegionVariableOrigin};\n+use rustc::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::sync::Lrc;\n use rustc_target::spec::abi::Abi;\n-use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin};\n use rustc::infer::opaque_types::OpaqueTypeDecl;\n use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n@@ -2555,7 +2556,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         while result.is_none() && autoderef.next().is_some() {\n             result = self.try_index_step(expr, base_expr, &autoderef, needs, idx_ty);\n         }\n-        autoderef.finalize();\n+        autoderef.finalize(self);\n         result\n     }\n \n@@ -2572,7 +2573,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       index_ty: Ty<'tcx>)\n                       -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)>\n     {\n-        let adjusted_ty = autoderef.unambiguous_final_ty();\n+        let adjusted_ty = autoderef.unambiguous_final_ty(self);\n         debug!(\"try_index_step(expr={:?}, base_expr={:?}, adjusted_ty={:?}, \\\n                                index_ty={:?})\",\n                expr,\n@@ -2602,7 +2603,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 debug!(\"try_index_step: success, using overloaded indexing\");\n                 let method = self.register_infer_ok_obligations(ok);\n \n-                let mut adjustments = autoderef.adjust_steps(needs);\n+                let mut adjustments = autoderef.adjust_steps(self, needs);\n                 if let ty::Ref(region, _, r_mutbl) = method.sig.inputs()[0].sty {\n                     let mutbl = match r_mutbl {\n                         hir::MutImmutable => AutoBorrowMutability::Immutable,\n@@ -3296,9 +3297,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // of error recovery.\n                         self.write_field_index(expr.id, index);\n                         if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                            let adjustments = autoderef.adjust_steps(needs);\n+                            let adjustments = autoderef.adjust_steps(self, needs);\n                             self.apply_adjustments(base, adjustments);\n-                            autoderef.finalize();\n+                            autoderef.finalize(self);\n \n                             self.tcx.check_stability(field.did, Some(expr.id), expr.span);\n                             return field_ty;\n@@ -3311,9 +3312,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if let Ok(index) = fstr.parse::<usize>() {\n                         if fstr == index.to_string() {\n                             if let Some(field_ty) = tys.get(index) {\n-                                let adjustments = autoderef.adjust_steps(needs);\n+                                let adjustments = autoderef.adjust_steps(self, needs);\n                                 self.apply_adjustments(base, adjustments);\n-                                autoderef.finalize();\n+                                autoderef.finalize(self);\n \n                                 self.write_field_index(expr.id, index);\n                                 return field_ty;\n@@ -3324,7 +3325,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 _ => {}\n             }\n         }\n-        autoderef.unambiguous_final_ty();\n+        autoderef.unambiguous_final_ty(self);\n \n         if let Some((did, field_ty)) = private_candidate {\n             let struct_path = self.tcx().item_path_str(did);\n@@ -5372,6 +5373,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n         (ctxt, result)\n     }\n+\n+    /// Instantiate a QueryResponse in a probe context, without a\n+    /// good ObligationCause.\n+    fn probe_instantiate_query_response(\n+        &self,\n+        span: Span,\n+        original_values: &OriginalQueryValues<'tcx>,\n+        query_result: &Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n+    ) -> InferResult<'tcx, Ty<'tcx>>\n+    {\n+        self.instantiate_query_response_and_region_obligations(\n+            &traits::ObligationCause::misc(span, self.body_id),\n+            self.param_env,\n+            original_values,\n+            query_result)\n+    }\n }\n \n pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "e24548cfb239fd6cdcd0e5b1b1fc2ab24a442958", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "patch": "@@ -766,7 +766,7 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                 potential_self_ty, self_ty);\n \n             if fcx.infcx.can_eq(fcx.param_env, self_ty, potential_self_ty).is_ok() {\n-                autoderef.finalize();\n+                autoderef.finalize(fcx);\n                 if let Some(mut err) = fcx.demand_eqtype_with_origin(\n                     &cause, self_ty, potential_self_ty) {\n                     err.emit();"}, {"sha": "fdc81a6ed1a9c3821954ef1fb74f7f9a3fdbcc9e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "patch": "@@ -90,6 +90,7 @@ This API is completely unstable and subject to change.\n extern crate syntax_pos;\n \n extern crate arena;\n+\n #[macro_use] extern crate rustc;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_data_structures;"}, {"sha": "4b15ecb3e542b1fdd26dba150c75e10dc60b78ed", "filename": "src/test/run-pass/issue-53843.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Ftest%2Frun-pass%2Fissue-53843.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa8792f17ad5484ec1e3b0b1e2557f8603219d0/src%2Ftest%2Frun-pass%2Fissue-53843.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-53843.rs?ref=daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::Deref;\n+\n+pub struct Pin<P>(P);\n+\n+impl<P, T> Deref for Pin<P>\n+where\n+    P: Deref<Target=T>,\n+{\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &*self.0\n+    }\n+}\n+\n+impl<P> Pin<P> {\n+    fn poll(self) {}\n+}\n+\n+fn main() {\n+    let mut unit = ();\n+    let pin = Pin(&mut unit);\n+    pin.poll();\n+}"}]}