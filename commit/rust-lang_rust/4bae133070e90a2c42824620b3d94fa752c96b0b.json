{"sha": "4bae133070e90a2c42824620b3d94fa752c96b0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiYWUxMzMwNzBlOTBhMmM0MjgyNDYyMGIzZDk0ZmE3NTJjOTZiMGI=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2015-02-19T16:54:41Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-02-22T11:43:08Z"}, "message": "revise handling of match expressions so that arms branch to next arm.\n\nUpdate the graphviz tests accordingly.\n\nFixes #22073. (Includes regression test for the issue.)\n\n(Factoring of aatch CFG code, Part 4.)", "tree": {"sha": "69eec40a928f2a78579342b96803c039b4fdb1b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69eec40a928f2a78579342b96803c039b4fdb1b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bae133070e90a2c42824620b3d94fa752c96b0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bae133070e90a2c42824620b3d94fa752c96b0b", "html_url": "https://github.com/rust-lang/rust/commit/4bae133070e90a2c42824620b3d94fa752c96b0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bae133070e90a2c42824620b3d94fa752c96b0b/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb4961b9610beb988e51f4a6e3cf9161fa00e266", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb4961b9610beb988e51f4a6e3cf9161fa00e266", "html_url": "https://github.com/rust-lang/rust/commit/eb4961b9610beb988e51f4a6e3cf9161fa00e266"}], "stats": {"total": 268, "additions": 203, "deletions": 65}, "files": [{"sha": "52eedc460eb8749695fcb74cca6efab951c950cd", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 104, "deletions": 56, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/4bae133070e90a2c42824620b3d94fa752c96b0b/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bae133070e90a2c42824620b3d94fa752c96b0b/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=4bae133070e90a2c42824620b3d94fa752c96b0b", "patch": "@@ -11,6 +11,7 @@\n use middle::cfg::*;\n use middle::def;\n use middle::graph;\n+use middle::pat_util;\n use middle::region::CodeExtent;\n use middle::ty;\n use syntax::ast;\n@@ -149,23 +150,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         pats.fold(pred, |pred, pat| self.pat(&**pat, pred))\n     }\n \n-    fn pats_any(&mut self,\n-                pats: &[P<ast::Pat>],\n-                pred: CFGIndex) -> CFGIndex {\n-        //! Handles case where just one of the patterns must match.\n-\n-        if pats.len() == 1 {\n-            self.pat(&*pats[0], pred)\n-        } else {\n-            let collect = self.add_dummy_node(&[]);\n-            for pat in pats {\n-                let pat_exit = self.pat(&**pat, pred);\n-                self.add_contained_edge(pat_exit, collect);\n-            }\n-            collect\n-        }\n-    }\n-\n     fn expr(&mut self, expr: &ast::Expr, pred: CFGIndex) -> CFGIndex {\n         match expr.node {\n             ast::ExprBlock(ref blk) => {\n@@ -288,45 +272,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             ast::ExprMatch(ref discr, ref arms, _) => {\n-                //\n-                //     [pred]\n-                //       |\n-                //       v 1\n-                //    [discr]\n-                //       |\n-                //       v 2\n-                //    [cond1]\n-                //      /  \\\n-                //     |    \\\n-                //     v 3   \\\n-                //  [pat1]    \\\n-                //     |       |\n-                //     v 4     |\n-                //  [guard1]   |\n-                //     |       |\n-                //     |       |\n-                //     v 5     v\n-                //  [body1]  [cond2]\n-                //     |      /  \\\n-                //     |    ...  ...\n-                //     |     |    |\n-                //     v 6   v    v\n-                //  [.....expr.....]\n-                //\n-                let discr_exit = self.expr(&**discr, pred);              // 1\n-\n-                let expr_exit = self.add_ast_node(expr.id, &[]);\n-                let mut cond_exit = discr_exit;\n-                for arm in arms {\n-                    cond_exit = self.add_dummy_node(&[cond_exit]);        // 2\n-                    let pats_exit = self.pats_any(&arm.pats,\n-                                                  cond_exit);            // 3\n-                    let guard_exit = self.opt_expr(&arm.guard,\n-                                                   pats_exit);           // 4\n-                    let body_exit = self.expr(&*arm.body, guard_exit);   // 5\n-                    self.add_contained_edge(body_exit, expr_exit);       // 6\n-                }\n-                expr_exit\n+                self.match_(expr.id, &discr, &arms, pred)\n             }\n \n             ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op.node) => {\n@@ -503,6 +449,108 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         self.add_ast_node(expr.id, &[subexprs_exit])\n     }\n \n+    fn match_(&mut self, id: ast::NodeId, discr: &ast::Expr,\n+              arms: &[ast::Arm], pred: CFGIndex) -> CFGIndex {\n+        // The CFG for match expression is quite complex, so no ASCII\n+        // art for it (yet).\n+        //\n+        // The CFG generated below matches roughly what trans puts\n+        // out. Each pattern and guard is visited in parallel, with\n+        // arms containing multiple patterns generating multiple nodes\n+        // for the same guard expression. The guard expressions chain\n+        // into each other from top to bottom, with a specific\n+        // exception to allow some additional valid programs\n+        // (explained below). Trans differs slightly in that the\n+        // pattern matching may continue after a guard but the visible\n+        // behaviour should be the same.\n+        //\n+        // What is going on is explained in further comments.\n+\n+        // Visit the discriminant expression\n+        let discr_exit = self.expr(discr, pred);\n+\n+        // Add a node for the exit of the match expression as a whole.\n+        let expr_exit = self.add_ast_node(id, &[]);\n+\n+        // Keep track of the previous guard expressions\n+        let mut prev_guards = Vec::new();\n+        // Track if the previous pattern contained bindings or wildcards\n+        let mut prev_has_bindings = false;\n+\n+        for arm in arms {\n+            // Add an exit node for when we've visited all the\n+            // patterns and the guard (if there is one) in the arm.\n+            let arm_exit = self.add_dummy_node(&[]);\n+\n+            for pat in &arm.pats {\n+                // Visit the pattern, coming from the discriminant exit\n+                let mut pat_exit = self.pat(&**pat, discr_exit);\n+\n+                // If there is a guard expression, handle it here\n+                if let Some(ref guard) = arm.guard {\n+                    // Add a dummy node for the previous guard\n+                    // expression to target\n+                    let guard_start = self.add_dummy_node(&[pat_exit]);\n+                    // Visit the guard expression\n+                    let guard_exit = self.expr(&**guard, guard_start);\n+\n+                    let this_has_bindings = pat_util::pat_contains_bindings_or_wild(\n+                        &self.tcx.def_map, &**pat);\n+\n+                    // If both this pattern and the previous pattern\n+                    // were free of bindings, they must consist only\n+                    // of \"constant\" patterns. Note we cannot match an\n+                    // all-constant pattern, fail the guard, and then\n+                    // match *another* all-constant pattern. This is\n+                    // because if the previous pattern matches, then\n+                    // we *cannot* match this one, unless all the\n+                    // constants are the same (which is rejected by\n+                    // `check_match`).\n+                    //\n+                    // We can use this to be smarter about the flow\n+                    // along guards. If the previous pattern matched,\n+                    // then we know we will not visit the guard in\n+                    // this one (whether or not the guard succeeded),\n+                    // if the previous pattern failed, then we know\n+                    // the guard for that pattern will not have been\n+                    // visited. Thus, it is not possible to visit both\n+                    // the previous guard and the current one when\n+                    // both patterns consist only of constant\n+                    // sub-patterns.\n+                    //\n+                    // However, if the above does not hold, then all\n+                    // previous guards need to be wired to visit the\n+                    // current guard pattern.\n+                    if prev_has_bindings || this_has_bindings {\n+                        while let Some(prev) = prev_guards.pop() {\n+                            self.add_contained_edge(prev, guard_start);\n+                        }\n+                    }\n+\n+                    prev_has_bindings = this_has_bindings;\n+\n+                    // Push the guard onto the list of previous guards\n+                    prev_guards.push(guard_exit);\n+\n+                    // Update the exit node for the pattern\n+                    pat_exit = guard_exit;\n+                }\n+\n+                // Add an edge from the exit of this pattern to the\n+                // exit of the arm\n+                self.add_contained_edge(pat_exit, arm_exit);\n+            }\n+\n+            // Visit the body of this arm\n+            let body_exit = self.expr(&arm.body, arm_exit);\n+\n+            // Link the body to the exit of the expression\n+            self.add_contained_edge(body_exit, expr_exit);\n+        }\n+\n+        expr_exit\n+    }\n+\n     fn add_dummy_node(&mut self, preds: &[CFGIndex]) -> CFGIndex {\n         self.add_node(CFGNodeData::Dummy, preds)\n     }"}, {"sha": "a7df2f4a5dafb4dfe3e4b90e6a2a0b748ca05f2f", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4bae133070e90a2c42824620b3d94fa752c96b0b/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bae133070e90a2c42824620b3d94fa752c96b0b/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=4bae133070e90a2c42824620b3d94fa752c96b0b", "patch": "@@ -119,6 +119,21 @@ pub fn pat_contains_bindings(dm: &DefMap, pat: &ast::Pat) -> bool {\n     contains_bindings\n }\n \n+/// Checks if the pattern contains any patterns that bind something to\n+/// an ident or wildcard, e.g. `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n+pub fn pat_contains_bindings_or_wild(dm: &DefMap, pat: &ast::Pat) -> bool {\n+    let mut contains_bindings = false;\n+    walk_pat(pat, |p| {\n+        if pat_is_binding_or_wild(dm, p) {\n+            contains_bindings = true;\n+            false // there's at least one binding/wildcard, can short circuit now.\n+        } else {\n+            true\n+        }\n+    });\n+    contains_bindings\n+}\n+\n pub fn simple_identifier<'a>(pat: &'a ast::Pat) -> Option<&'a ast::Ident> {\n     match pat.node {\n         ast::PatIdent(ast::BindByValue(_), ref path1, None) => {"}, {"sha": "5d29d0e1fd083914964e45c8bb686ab5da2a082f", "filename": "src/test/compile-fail/move-in-guard-1.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4bae133070e90a2c42824620b3d94fa752c96b0b/src%2Ftest%2Fcompile-fail%2Fmove-in-guard-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bae133070e90a2c42824620b3d94fa752c96b0b/src%2Ftest%2Fcompile-fail%2Fmove-in-guard-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-in-guard-1.rs?ref=4bae133070e90a2c42824620b3d94fa752c96b0b", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax)]\n+\n+pub fn main() {\n+    let x = box 1;\n+\n+    let v = (1, 2);\n+\n+    match v {\n+        (1, _) if take(x) => (),\n+        (_, 2) if take(x) => (), //~ ERROR use of moved value: `x`\n+        _ => (),\n+    }\n+}\n+\n+fn take<T>(_: T) -> bool { false }"}, {"sha": "23af25797975f3720843c415adf2ef098ffbd48a", "filename": "src/test/compile-fail/move-in-guard-2.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4bae133070e90a2c42824620b3d94fa752c96b0b/src%2Ftest%2Fcompile-fail%2Fmove-in-guard-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bae133070e90a2c42824620b3d94fa752c96b0b/src%2Ftest%2Fcompile-fail%2Fmove-in-guard-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-in-guard-2.rs?ref=4bae133070e90a2c42824620b3d94fa752c96b0b", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax)]\n+\n+pub fn main() {\n+    let x = box 1;\n+\n+    let v = (1, 2);\n+\n+    match v {\n+        (1, _) |\n+        (_, 2) if take(x) => (), //~ ERROR use of moved value: `x`\n+        _ => (),\n+    }\n+}\n+\n+fn take<T>(_: T) -> bool { false }"}, {"sha": "51c6b14e1deedb01fed39975d73f22ed15b113cf", "filename": "src/test/run-make/graphviz-flowgraph/f07.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bae133070e90a2c42824620b3d94fa752c96b0b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/4bae133070e90a2c42824620b3d94fa752c96b0b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot?ref=4bae133070e90a2c42824620b3d94fa752c96b0b", "patch": "@@ -22,12 +22,12 @@ digraph block {\n     N3 -> N4;\n     N4 -> N5;\n     N5 -> N6;\n-    N6 -> N8;\n-    N8 -> N9;\n+    N6 -> N9;\n     N9 -> N10;\n     N10 -> N11;\n     N11 -> N12;\n-    N12 -> N13;\n+    N12 -> N8;\n+    N8 -> N13;\n     N13 -> N14;\n     N14 -> N15;\n     N15 -> N7;"}, {"sha": "fb7d2ad97bd5f553277f80ae09dfcba4cbd3f1bd", "filename": "src/test/run-make/graphviz-flowgraph/f13.dot-expected.dot", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bae133070e90a2c42824620b3d94fa752c96b0b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/4bae133070e90a2c42824620b3d94fa752c96b0b/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot?ref=4bae133070e90a2c42824620b3d94fa752c96b0b", "patch": "@@ -32,16 +32,16 @@ digraph block {\n     N6 -> N7;\n     N7 -> N8;\n     N8 -> N9;\n-    N9 -> N11;\n-    N11 -> N12;\n-    N12 -> N13;\n+    N9 -> N12;\n+    N12 -> N11;\n+    N11 -> N13;\n     N13 -> N14;\n     N14 -> N15;\n     N15 -> N10;\n-    N11 -> N16;\n-    N16 -> N17;\n+    N9 -> N17;\n     N17 -> N18;\n-    N18 -> N19;\n+    N18 -> N16;\n+    N16 -> N19;\n     N19 -> N20;\n     N20 -> N21;\n     N21 -> N22;"}, {"sha": "64c4f1fdbaeabf6e2d9e06bdb80646e4063c4ede", "filename": "src/test/run-pass/move-guard-const.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4bae133070e90a2c42824620b3d94fa752c96b0b/src%2Ftest%2Frun-pass%2Fmove-guard-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bae133070e90a2c42824620b3d94fa752c96b0b/src%2Ftest%2Frun-pass%2Fmove-guard-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-guard-const.rs?ref=4bae133070e90a2c42824620b3d94fa752c96b0b", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    let x = box 1;\n+\n+    let v = (1, 2);\n+\n+    match v {\n+        (2, 1) if take(x) => (),\n+        (1, 2) if take(x) => (),\n+        _ => (),\n+    }\n+}\n+\n+fn take<T>(_: T) -> bool { false }"}]}