{"sha": "f472cd9c02e77654ba6ba324c0b4b15aefa96f48", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0NzJjZDljMDJlNzc2NTRiYTZiYTMyNGMwYjRiMTVhZWZhOTZmNDg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-05-08T19:57:06Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-06-05T20:09:27Z"}, "message": "Addressed points raised in review.", "tree": {"sha": "1e92e8111031db832d7b5e530b0f4962896a1dd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e92e8111031db832d7b5e530b0f4962896a1dd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f472cd9c02e77654ba6ba324c0b4b15aefa96f48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f472cd9c02e77654ba6ba324c0b4b15aefa96f48", "html_url": "https://github.com/rust-lang/rust/commit/f472cd9c02e77654ba6ba324c0b4b15aefa96f48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f472cd9c02e77654ba6ba324c0b4b15aefa96f48/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bf5994d922744c1d9e44b53a6ad54005fe3489e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bf5994d922744c1d9e44b53a6ad54005fe3489e", "html_url": "https://github.com/rust-lang/rust/commit/5bf5994d922744c1d9e44b53a6ad54005fe3489e"}], "stats": {"total": 241, "additions": 172, "deletions": 69}, "files": [{"sha": "1c66f8bdf81bdd865b77c3196b06acdfd1ba2c10", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f472cd9c02e77654ba6ba324c0b4b15aefa96f48/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f472cd9c02e77654ba6ba324c0b4b15aefa96f48/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=f472cd9c02e77654ba6ba324c0b4b15aefa96f48", "patch": "@@ -626,9 +626,6 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         TyKind::CVarArgs(ref lt) => {\n             visitor.visit_lifetime(lt)\n         }\n-        TyKind::AssocTyExistential(ref bounds) => {\n-            walk_list!(visitor, visit_param_bound, bounds);\n-        }\n         TyKind::Infer | TyKind::Err => {}\n     }\n }\n@@ -677,7 +674,14 @@ pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                    type_binding: &'v TypeBinding) {\n     visitor.visit_id(type_binding.hir_id);\n     visitor.visit_ident(type_binding.ident);\n-    visitor.visit_ty(&type_binding.ty);\n+    match type_binding.kind {\n+        TypeBindingKind::Equality { ref ty } => {\n+            visitor.visit_ty(ty);\n+        }\n+        TypeBindingKind::Constraint { ref bounds } => {\n+            walk_list!(visitor, visit_param_bound, bounds);\n+        }\n+    }\n }\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {"}, {"sha": "1bfff138d8dca0f4f629586bd30f63f8b2413889", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f472cd9c02e77654ba6ba324c0b4b15aefa96f48/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f472cd9c02e77654ba6ba324c0b4b15aefa96f48/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=f472cd9c02e77654ba6ba324c0b4b15aefa96f48", "patch": "@@ -1377,9 +1377,10 @@ impl<'a> LoweringContext<'a> {\n                                  -> hir::TypeBinding {\n         debug!(\"lower_assoc_ty_constraint(constraint={:?}, itctx={:?})\", c, itctx);\n \n-        // Convert to a type representing the `T::Item` value.\n-        let ty = match c.kind {\n-            AssocTyConstraintKind::Equality { ref ty } => self.lower_ty(ty, itctx),\n+        let kind = match c.kind {\n+            AssocTyConstraintKind::Equality { ref ty } => hir::TypeBindingKind::Equality {\n+                ty: self.lower_ty(ty, itctx)\n+            },\n             AssocTyConstraintKind::Bound { ref bounds } => {\n                 // Piggy-back on the `impl Trait` context to figure out the correct behavior.\n                 let (desugar_to_impl_trait, itctx) = match itctx {\n@@ -1422,7 +1423,7 @@ impl<'a> LoweringContext<'a> {\n \n                 if desugar_to_impl_trait {\n                     // Desugar `AssocTy: Bounds` into `AssocTy = impl Bounds`. We do this by\n-                    // constructing the HIR for \"impl bounds\" and then lowering that.\n+                    // constructing the HIR for `impl bounds...` and then lowering that.\n \n                     let impl_trait_node_id = self.sess.next_node_id();\n                     let parent_def_index = self.current_hir_id_owner.last().unwrap().0;\n@@ -1436,35 +1437,35 @@ impl<'a> LoweringContext<'a> {\n                     );\n \n                     self.with_dyn_type_scope(false, |this| {\n-                        this.lower_ty(\n+                        let ty = this.lower_ty(\n                             &Ty {\n                                 id: this.sess.next_node_id(),\n                                 node: TyKind::ImplTrait(impl_trait_node_id, bounds.clone()),\n                                 span: DUMMY_SP,\n                             },\n                             itctx,\n-                        )\n+                        );\n+\n+                        hir::TypeBindingKind::Equality {\n+                            ty\n+                        }\n                     })\n                 } else {\n-                    // Desugar `AssocTy: Bounds` into `AssocTy = \u2203 T (T: Bounds)`, where the\n-                    // \"false existential\" later desugars into a trait predicate.\n-\n+                    // Desugar `AssocTy: Bounds` into a type binding where the\n+                    // later desugars into a trait predicate.\n                     let bounds = self.lower_param_bounds(bounds, itctx);\n \n-                    let id = self.sess.next_node_id();\n-                    P(hir::Ty {\n-                        hir_id: self.lower_node_id(id),\n-                        node: hir::TyKind::AssocTyExistential(bounds),\n-                        span: DUMMY_SP,\n-                    })\n+                    hir::TypeBindingKind::Constraint {\n+                        bounds\n+                    }\n                 }\n             }\n         };\n \n         hir::TypeBinding {\n             hir_id: self.lower_node_id(c.id),\n             ident: c.ident,\n-            ty,\n+            kind,\n             span: c.span,\n         }\n     }\n@@ -2359,10 +2360,17 @@ impl<'a> LoweringContext<'a> {\n                             hir::TypeBinding {\n                                 hir_id: this.next_id(),\n                                 ident: Ident::with_empty_ctxt(FN_OUTPUT_NAME),\n-                                ty: output\n-                                    .as_ref()\n-                                    .map(|ty| this.lower_ty(&ty, ImplTraitContext::disallowed()))\n-                                    .unwrap_or_else(|| P(mk_tup(this, hir::HirVec::new(), span))),\n+                                kind: hir::TypeBindingKind::Equality {\n+                                    ty: output\n+                                        .as_ref()\n+                                        .map(|ty| this.lower_ty(\n+                                            &ty,\n+                                            ImplTraitContext::disallowed()\n+                                        ))\n+                                        .unwrap_or_else(||\n+                                            P(mk_tup(this, hir::HirVec::new(), span))\n+                                        ),\n+                                },\n                                 span: output.as_ref().map_or(span, |ty| ty.span),\n                             }\n                         ],\n@@ -2666,7 +2674,9 @@ impl<'a> LoweringContext<'a> {\n             args: hir_vec![],\n             bindings: hir_vec![hir::TypeBinding {\n                 ident: Ident::with_empty_ctxt(FN_OUTPUT_NAME),\n-                ty: output_ty,\n+                kind: hir::TypeBindingKind::Equality {\n+                    ty: output_ty,\n+                },\n                 hir_id: self.next_id(),\n                 span,\n             }],"}, {"sha": "2aaf5ec775d49f98cb47398834696e74f9298dd5", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f472cd9c02e77654ba6ba324c0b4b15aefa96f48/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f472cd9c02e77654ba6ba324c0b4b15aefa96f48/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=f472cd9c02e77654ba6ba324c0b4b15aefa96f48", "patch": "@@ -1780,7 +1780,7 @@ pub struct ImplItem {\n     pub span: Span,\n }\n \n-/// Represents different contents within `impl`s.\n+/// Represents various kinds of content within an `impl`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ImplItemKind {\n     /// An associated constant of the given type, set to the constant result\n@@ -1794,16 +1794,51 @@ pub enum ImplItemKind {\n     Existential(GenericBounds),\n }\n \n-// Bind a type to an associated type (`A = Foo`).\n+/// Bind a type to an associated type (i.e., `A = Foo`).\n+///\n+/// Bindings like `A: Debug` are represented as a special type `A =\n+/// $::Debug` that is understood by the astconv code.\n+///\n+/// FIXME(alexreg) -- why have a separate type for the binding case,\n+/// wouldn't it be better to make the `ty` field an enum like:\n+///\n+/// ```\n+/// enum TypeBindingKind {\n+///    Equals(...),\n+///    Binding(...),\n+/// }\n+/// ```\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct TypeBinding {\n     pub hir_id: HirId,\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n-    pub ty: P<Ty>,\n+    pub kind: TypeBindingKind,\n     pub span: Span,\n }\n \n+// Represents the two kinds of type bindings.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+pub enum TypeBindingKind {\n+    /// E.g., `Foo<Bar: Send>`.\n+    Constraint {\n+        bounds: HirVec<GenericBound>,\n+    },\n+    /// E.g., `Foo<Bar = ()>`.\n+    Equality {\n+        ty: P<Ty>,\n+    },\n+}\n+\n+impl TypeBinding {\n+    pub fn ty(&self) -> &Ty {\n+        match self.kind {\n+            TypeBindingKind::Equality { ref ty } => ty,\n+            _ => bug!(\"expected equality type binding for parenthesized generic args\"),\n+        }\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Ty {\n     pub hir_id: HirId,\n@@ -1898,8 +1933,6 @@ pub enum TyKind {\n     /// Placeholder for C-variadic arguments. We \"spoof\" the `VaList` created\n     /// from the variadic arguments. This type is only valid up to typeck.\n     CVarArgs(Lifetime),\n-    /// The existential type (i.e., `impl Trait`) that constrains an associated type.\n-    AssocTyExistential(HirVec<GenericBound>),\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n@@ -2236,18 +2269,18 @@ impl StructField {\n     }\n }\n \n-/// Fields and constructor ids of enum variants and structs\n+/// Fields and constructor IDs of enum variants and structs.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum VariantData {\n-    /// Struct variant.\n+    /// A struct variant.\n     ///\n-    /// e.g., `Bar { .. }` as in `enum Foo { Bar { .. } }`.\n+    /// E.g., `Bar { .. }` as in `enum Foo { Bar { .. } }`.\n     Struct(HirVec<StructField>, /* recovered */ bool),\n-    /// Tuple variant.\n+    /// A tuple variant.\n     ///\n     /// E.g., `Bar(..)` as in `enum Foo { Bar(..) }`.\n     Tuple(HirVec<StructField>, HirId),\n-    /// Unit variant.\n+    /// A unit variant.\n     ///\n     /// E.g., `Bar = ..` as in `enum Foo { Bar = .. }`.\n     Unit(HirId),"}, {"sha": "c8615f0ed1b93b0e8440ae89da3e798c115014be", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f472cd9c02e77654ba6ba324c0b4b15aefa96f48/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f472cd9c02e77654ba6ba324c0b4b15aefa96f48/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=f472cd9c02e77654ba6ba324c0b4b15aefa96f48", "patch": "@@ -409,9 +409,6 @@ impl<'a> State<'a> {\n             hir::TyKind::CVarArgs(_) => {\n                 self.s.word(\"...\")?;\n             }\n-            hir::TyKind::AssocTyExistential(ref bounds) => {\n-                self.print_bounds(\":\", bounds)?;\n-            }\n         }\n         self.end()\n     }\n@@ -1648,7 +1645,7 @@ impl<'a> State<'a> {\n \n             self.space_if_not_bol()?;\n             self.word_space(\"->\")?;\n-            self.print_type(&generic_args.bindings[0].ty)?;\n+            self.print_type(generic_args.bindings[0].ty())?;\n         } else {\n             let start = if colons_before_params { \"::<\" } else { \"<\" };\n             let empty = Cell::new(true);\n@@ -1693,8 +1690,15 @@ impl<'a> State<'a> {\n                 start_or_comma(self)?;\n                 self.print_ident(binding.ident)?;\n                 self.s.space()?;\n-                self.word_space(\"=\")?;\n-                self.print_type(&binding.ty)?;\n+                match generic_args.bindings[0].kind {\n+                    hir::TypeBindingKind::Equality { ref ty } => {\n+                        self.word_space(\"=\")?;\n+                        self.print_type(ty)?;\n+                    }\n+                    hir::TypeBindingKind::Constraint { ref bounds } => {\n+                        self.print_bounds(\":\", bounds)?;\n+                    }\n+                }\n             }\n \n             if !empty.get() {"}, {"sha": "331b74db080bf6234fff770832ff86dfc4277f65", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f472cd9c02e77654ba6ba324c0b4b15aefa96f48/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f472cd9c02e77654ba6ba324c0b4b15aefa96f48/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=f472cd9c02e77654ba6ba324c0b4b15aefa96f48", "patch": "@@ -923,7 +923,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_fn_decl(&mut self, fd: &'tcx hir::FnDecl) {\n         let output = match fd.output {\n             hir::DefaultReturn(_) => None,\n-            hir::Return(ref ty) => Some(ty),\n+            hir::Return(ref ty) => Some(&**ty),\n         };\n         self.visit_fn_like_elision(&fd.inputs, output);\n     }\n@@ -1884,7 +1884,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         if generic_args.parenthesized {\n             let was_in_fn_syntax = self.is_in_fn_syntax;\n             self.is_in_fn_syntax = true;\n-            self.visit_fn_like_elision(generic_args.inputs(), Some(&generic_args.bindings[0].ty));\n+            self.visit_fn_like_elision(generic_args.inputs(), Some(generic_args.bindings[0].ty()));\n             self.is_in_fn_syntax = was_in_fn_syntax;\n             return;\n         }\n@@ -2020,7 +2020,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_fn_like_elision(&mut self, inputs: &'tcx [hir::Ty], output: Option<&'tcx P<hir::Ty>>) {\n+    fn visit_fn_like_elision(&mut self, inputs: &'tcx [hir::Ty], output: Option<&'tcx hir::Ty>) {\n         debug!(\"visit_fn_like_elision: enter\");\n         let mut arg_elide = Elide::FreshLateAnon(Cell::new(0));\n         let arg_scope = Scope::Elision {"}, {"sha": "4a2949fa6b069f0765637531605a37b886c7c060", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f472cd9c02e77654ba6ba324c0b4b15aefa96f48/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f472cd9c02e77654ba6ba324c0b4b15aefa96f48/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f472cd9c02e77654ba6ba324c0b4b15aefa96f48", "patch": "@@ -710,10 +710,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         // back separately.\n         let assoc_bindings = generic_args.bindings.iter()\n             .map(|binding| {\n-                let kind = if let hir::TyKind::AssocTyExistential(ref bounds) = binding.ty.node {\n-                    ConvertedBindingKind::Constraint(bounds.clone())\n-                } else {\n-                    ConvertedBindingKind::Equality(self.ast_ty_to_ty(&binding.ty))\n+                let kind = match binding.kind {\n+                    hir::TypeBindingKind::Equality { ref ty } =>\n+                        ConvertedBindingKind::Equality(self.ast_ty_to_ty(ty)),\n+                    hir::TypeBindingKind::Constraint { ref bounds } =>\n+                        ConvertedBindingKind::Constraint(bounds.clone()),\n                 };\n                 ConvertedBinding {\n                     item_name: binding.ident,\n@@ -2060,10 +2061,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 let region = self.ast_region_to_region(&lt, None);\n                 tcx.type_of(va_list_did).subst(tcx, &[region.into()])\n             }\n-            hir::TyKind::AssocTyExistential(..) => {\n-                // Type is never actually used.\n-                tcx.types.err\n-            }\n             hir::TyKind::Err => {\n                 tcx.types.err\n             }"}, {"sha": "60d6c33f81afcf910d930682f846411a8f3a8f4a", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f472cd9c02e77654ba6ba324c0b4b15aefa96f48/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f472cd9c02e77654ba6ba324c0b4b15aefa96f48/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=f472cd9c02e77654ba6ba324c0b4b15aefa96f48", "patch": "@@ -626,7 +626,9 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                             } => {\n                                                 bindings.push(TypeBinding {\n                                                     name: left_name.clone(),\n-                                                    ty: rhs,\n+                                                    kind: TypeBindingKind::Equality {\n+                                                        ty: rhs,\n+                                                    },\n                                                 });\n                                             }\n                                             &mut GenericArgs::Parenthesized { .. } => {"}, {"sha": "03d16feb483a9c5110bc1e257e5115d2429f58ab", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 47, "deletions": 11, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f472cd9c02e77654ba6ba324c0b4b15aefa96f48/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f472cd9c02e77654ba6ba324c0b4b15aefa96f48/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f472cd9c02e77654ba6ba324c0b4b15aefa96f48", "patch": "@@ -1979,7 +1979,7 @@ impl FnDecl {\n                 match &bounds[0] {\n                     GenericBound::TraitBound(PolyTrait { trait_, .. }, ..) => {\n                         let bindings = trait_.bindings().unwrap();\n-                        FunctionRetTy::Return(bindings[0].ty.clone())\n+                        FunctionRetTy::Return(bindings[0].ty().clone())\n                     }\n                     _ => panic!(\"unexpected desugaring of async function\"),\n                 }\n@@ -2937,11 +2937,8 @@ impl Clean<Type> for hir::Ty {\n             }\n             TyKind::BareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n             TyKind::Infer | TyKind::Err => Infer,\n-            TyKind::Typeof(..) => panic!(\"Unimplemented type {:?}\", self.node),\n+            TyKind::Typeof(..) => panic!(\"unimplemented type {:?}\", self.node),\n             TyKind::CVarArgs(_) => CVarArgs,\n-            TyKind::AssocTyExistential(ref bounds) => {\n-                ImplTrait(bounds.into_iter().map(|b| b.clean(cx)).collect())\n-            }\n         }\n     }\n }\n@@ -3057,7 +3054,9 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 for pb in obj.projection_bounds() {\n                     bindings.push(TypeBinding {\n                         name: cx.tcx.associated_item(pb.item_def_id()).ident.name.clean(cx),\n-                        ty: pb.skip_binder().ty.clean(cx)\n+                        kind: TypeBindingKind::Equality {\n+                            ty: pb.skip_binder().ty.clean(cx)\n+                        },\n                     });\n                 }\n \n@@ -3113,7 +3112,9 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                                 Some(TypeBinding {\n                                     name: cx.tcx.associated_item(proj.projection_ty.item_def_id)\n                                                 .ident.name.clean(cx),\n-                                    ty: proj.ty.clean(cx),\n+                                    kind: TypeBindingKind::Equality {\n+                                        ty: proj.ty.clean(cx),\n+                                    },\n                                 })\n                             } else {\n                                 None\n@@ -3498,7 +3499,7 @@ pub enum GenericArgs {\n impl Clean<GenericArgs> for hir::GenericArgs {\n     fn clean(&self, cx: &DocContext<'_>) -> GenericArgs {\n         if self.parenthesized {\n-            let output = self.bindings[0].ty.clean(cx);\n+            let output = self.bindings[0].ty().clean(cx);\n             GenericArgs::Parenthesized {\n                 inputs: self.inputs().clean(cx),\n                 output: if output != Type::Tuple(Vec::new()) { Some(output) } else { None }\n@@ -4346,18 +4347,53 @@ impl Clean<Deprecation> for attr::Deprecation {\n     }\n }\n \n-/// An equality constraint on an associated type, e.g., `A = Bar` in `Foo<A = Bar>`\n+/// An type binding on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or\n+/// `A: Send + Sync` in `Foo<A: Send + Sync>`).\n #[derive(Clone, PartialEq, Eq, RustcDecodable, RustcEncodable, Debug, Hash)]\n pub struct TypeBinding {\n     pub name: String,\n-    pub ty: Type\n+    pub kind: TypeBindingKind,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcDecodable, RustcEncodable, Debug, Hash)]\n+pub enum TypeBindingKind {\n+    Equality {\n+        ty: Type,\n+    },\n+    Constraint {\n+        bounds: Vec<GenericBound>,\n+    },\n+}\n+\n+impl TypeBinding {\n+    pub fn ty(&self) -> &Type {\n+        match self.kind {\n+            TypeBindingKind::Equality { ref ty } => ty,\n+            _ => panic!(\"expected equality type binding for parenthesized generic args\"),\n+        }\n+    }\n }\n \n impl Clean<TypeBinding> for hir::TypeBinding {\n     fn clean(&self, cx: &DocContext<'_>) -> TypeBinding {\n         TypeBinding {\n             name: self.ident.name.clean(cx),\n-            ty: self.ty.clean(cx)\n+            kind: self.kind.clean(cx),\n+        }\n+    }\n+}\n+\n+impl Clean<TypeBindingKind> for hir::TypeBindingKind {\n+    fn clean(&self, cx: &DocContext<'_>) -> TypeBindingKind {\n+        match *self {\n+            hir::TypeBindingKind::Equality { ref ty } =>\n+                TypeBindingKind::Equality {\n+                    ty: ty.clean(cx),\n+                },\n+            hir::TypeBindingKind::Constraint { ref bounds } =>\n+                TypeBindingKind::Constraint {\n+                    bounds: bounds.into_iter().map(|b| b.clean(cx)).collect(),\n+                },\n         }\n     }\n }"}, {"sha": "36e6a6003df0943ed821f854e1a41161a0eb4b18", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f472cd9c02e77654ba6ba324c0b4b15aefa96f48/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f472cd9c02e77654ba6ba324c0b4b15aefa96f48/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=f472cd9c02e77654ba6ba324c0b4b15aefa96f48", "patch": "@@ -91,7 +91,9 @@ pub fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n                 PP::AngleBracketed { ref mut bindings, .. } => {\n                     bindings.push(clean::TypeBinding {\n                         name: name.clone(),\n-                        ty: rhs.clone(),\n+                        kind: clean::TypeBindingKind::Equality {\n+                            ty: rhs.clone(),\n+                        },\n                     });\n                 }\n                 PP::Parenthesized { ref mut output, .. } => {"}, {"sha": "fa3bc3f5f4f8bda6064f139d92431490ae147a5a", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f472cd9c02e77654ba6ba324c0b4b15aefa96f48/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f472cd9c02e77654ba6ba324c0b4b15aefa96f48/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=f472cd9c02e77654ba6ba324c0b4b15aefa96f48", "patch": "@@ -1019,11 +1019,26 @@ impl fmt::Display for clean::ImportSource {\n \n impl fmt::Display for clean::TypeBinding {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if f.alternate() {\n-            write!(f, \"{} = {:#}\", self.name, self.ty)\n-        } else {\n-            write!(f, \"{} = {}\", self.name, self.ty)\n+        f.write_str(&self.name)?;\n+        match self.kind {\n+            clean::TypeBindingKind::Equality { ref ty } => {\n+                if f.alternate() {\n+                    write!(f, \" = {:#}\", ty)?;\n+                } else {\n+                    write!(f, \" = {}\", ty)?;\n+                }\n+            }\n+            clean::TypeBindingKind::Constraint { ref bounds } => {\n+                if !bounds.is_empty() {\n+                    if f.alternate() {\n+                        write!(f, \": {:#}\", GenericBounds(bounds))?;\n+                    } else {\n+                        write!(f, \":&nbsp;{}\", GenericBounds(bounds))?;\n+                    }\n+                }\n+            }\n         }\n+        Ok(())\n     }\n }\n "}]}