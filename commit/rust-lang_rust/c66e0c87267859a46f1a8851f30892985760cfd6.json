{"sha": "c66e0c87267859a46f1a8851f30892985760cfd6", "node_id": "C_kwDOAAsO6NoAKGM2NmUwYzg3MjY3ODU5YTQ2ZjFhODg1MWYzMDg5Mjk4NTc2MGNmZDY", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-03-25T00:34:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-25T00:34:29Z"}, "message": "Rollup merge of #94655 - JakobDegen:mir-phase-docs, r=oli-obk\n\nClarify which kinds of MIR are allowed during which phases.\n\nThis enhances documentation with these details and extends the validator to check these requirements more thoroughly. Most of these conditions were already being checked.\n\nThere was also some disagreement between the `MirPhase` docs and validator as to what it meant for the `body.phase` field to have a certain value. This PR resolves those disagreements in favor of the `MirPhase` docs (which is what the pass manager implemented), adjusting the validator accordingly. The result is now that the `DropLowering` phase begins with the end of the elaborate drops pass, and lasts until the beginning of the generator lowring pass. This doesn't feel entirely natural to me, but as long as it's documented accurately it should be ok.\n\nr? rust-lang/mir-opt", "tree": {"sha": "6f4ad2c8f2abd0ad0819e5d9878f3725451815af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f4ad2c8f2abd0ad0819e5d9878f3725451815af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c66e0c87267859a46f1a8851f30892985760cfd6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiPQ4VCRBK7hj4Ov3rIwAAl0oIAHxCgkQfdRlDkHo+6CE8s3fS\nl3p9gQ3QyMLvBG6TBkXwbE6NB+je22EMHxeuFj4vPz2ePOCkzsr3ZxFi3fN/SoVI\ncsogbOzeXVrf4146VvDlsTdUZOp9Ir6TdHsAtfIX3tsOMeFVNUSOmjnrH6BGP1kC\nlUcFoBXU/uBvTRAlGyfGih7ncraJnNovJ3G7Wcozm15lQ8al0t6wy1Q5YwK8gxjD\nd5OzXv1zUk8iH1T3+2hVJxLyLwwGFyil/Sar+ExwQOJn9ljpXpa/Ky23aQK6RIes\n3GgIlMgpd43tUFS0ZfBkYabYYyDmxiC9FC4E/eN929kaBXRj9Cf2pT/PQaFaYc0=\n=MQ0j\n-----END PGP SIGNATURE-----\n", "payload": "tree 6f4ad2c8f2abd0ad0819e5d9878f3725451815af\nparent d1d4613ead1896eff612903edb5da42630821b29\nparent 26d7b8ddb2d323e2d6cb77c04caf7c58ce5af267\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1648168469 +0100\ncommitter GitHub <noreply@github.com> 1648168469 +0100\n\nRollup merge of #94655 - JakobDegen:mir-phase-docs, r=oli-obk\n\nClarify which kinds of MIR are allowed during which phases.\n\nThis enhances documentation with these details and extends the validator to check these requirements more thoroughly. Most of these conditions were already being checked.\n\nThere was also some disagreement between the `MirPhase` docs and validator as to what it meant for the `body.phase` field to have a certain value. This PR resolves those disagreements in favor of the `MirPhase` docs (which is what the pass manager implemented), adjusting the validator accordingly. The result is now that the `DropLowering` phase begins with the end of the elaborate drops pass, and lasts until the beginning of the generator lowring pass. This doesn't feel entirely natural to me, but as long as it's documented accurately it should be ok.\n\nr? rust-lang/mir-opt\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c66e0c87267859a46f1a8851f30892985760cfd6", "html_url": "https://github.com/rust-lang/rust/commit/c66e0c87267859a46f1a8851f30892985760cfd6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c66e0c87267859a46f1a8851f30892985760cfd6/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1d4613ead1896eff612903edb5da42630821b29", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1d4613ead1896eff612903edb5da42630821b29", "html_url": "https://github.com/rust-lang/rust/commit/d1d4613ead1896eff612903edb5da42630821b29"}, {"sha": "26d7b8ddb2d323e2d6cb77c04caf7c58ce5af267", "url": "https://api.github.com/repos/rust-lang/rust/commits/26d7b8ddb2d323e2d6cb77c04caf7c58ce5af267", "html_url": "https://github.com/rust-lang/rust/commit/26d7b8ddb2d323e2d6cb77c04caf7c58ce5af267"}], "stats": {"total": 165, "additions": 113, "deletions": 52}, "files": [{"sha": "faea2111d9210b204164a0aa98efe2edf239c73b", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c66e0c87267859a46f1a8851f30892985760cfd6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66e0c87267859a46f1a8851f30892985760cfd6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=c66e0c87267859a46f1a8851f30892985760cfd6", "patch": "@@ -42,7 +42,7 @@ pub struct PromoteTemps<'tcx> {\n \n impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n     fn phase_change(&self) -> Option<MirPhase> {\n-        Some(MirPhase::ConstPromotion)\n+        Some(MirPhase::ConstsPromoted)\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {"}, {"sha": "deeca78b75d99d18df33b0760a7c6d9d212aaec3", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 47, "deletions": 27, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/c66e0c87267859a46f1a8851f30892985760cfd6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66e0c87267859a46f1a8851f30892985760cfd6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=c66e0c87267859a46f1a8851f30892985760cfd6", "patch": "@@ -266,30 +266,23 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                             );\n                         }\n                     }\n-                    // The deaggregator currently does not deaggreagate arrays.\n-                    // So for now, we ignore them here.\n-                    Rvalue::Aggregate(box AggregateKind::Array { .. }, _) => {}\n-                    // All other aggregates must be gone after some phases.\n-                    Rvalue::Aggregate(box kind, _) => {\n-                        if self.mir_phase > MirPhase::DropLowering\n-                            && !matches!(kind, AggregateKind::Generator(..))\n-                        {\n-                            // Generators persist until the state machine transformation, but all\n-                            // other aggregates must have been lowered.\n-                            self.fail(\n-                                location,\n-                                format!(\"{:?} have been lowered to field assignments\", rvalue),\n-                            )\n-                        } else if self.mir_phase > MirPhase::GeneratorLowering {\n-                            // No more aggregates after drop and generator lowering.\n+                    Rvalue::Aggregate(agg_kind, _) => {\n+                        let disallowed = match **agg_kind {\n+                            AggregateKind::Array(..) => false,\n+                            AggregateKind::Generator(..) => {\n+                                self.mir_phase >= MirPhase::GeneratorsLowered\n+                            }\n+                            _ => self.mir_phase >= MirPhase::Deaggregated,\n+                        };\n+                        if disallowed {\n                             self.fail(\n                                 location,\n                                 format!(\"{:?} have been lowered to field assignments\", rvalue),\n                             )\n                         }\n                     }\n                     Rvalue::Ref(_, BorrowKind::Shallow, _) => {\n-                        if self.mir_phase > MirPhase::DropLowering {\n+                        if self.mir_phase >= MirPhase::DropsLowered {\n                             self.fail(\n                                 location,\n                                 \"`Assign` statement with a `Shallow` borrow should have been removed after drop lowering phase\",\n@@ -300,15 +293,15 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             StatementKind::AscribeUserType(..) => {\n-                if self.mir_phase > MirPhase::DropLowering {\n+                if self.mir_phase >= MirPhase::DropsLowered {\n                     self.fail(\n                         location,\n                         \"`AscribeUserType` should have been removed after drop lowering phase\",\n                     );\n                 }\n             }\n             StatementKind::FakeRead(..) => {\n-                if self.mir_phase > MirPhase::DropLowering {\n+                if self.mir_phase >= MirPhase::DropsLowered {\n                     self.fail(\n                         location,\n                         \"`FakeRead` should have been removed after drop lowering phase\",\n@@ -351,10 +344,18 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     self.fail(location, format!(\"bad arg ({:?} != usize)\", op_cnt_ty))\n                 }\n             }\n-            StatementKind::SetDiscriminant { .. }\n-            | StatementKind::StorageLive(..)\n+            StatementKind::SetDiscriminant { .. } => {\n+                if self.mir_phase < MirPhase::DropsLowered {\n+                    self.fail(location, \"`SetDiscriminant` is not allowed until drop elaboration\");\n+                }\n+            }\n+            StatementKind::Retag(_, _) => {\n+                // FIXME(JakobDegen) The validator should check that `self.mir_phase <\n+                // DropsLowered`. However, this causes ICEs with generation of drop shims, which\n+                // seem to fail to set their `MirPhase` correctly.\n+            }\n+            StatementKind::StorageLive(..)\n             | StatementKind::StorageDead(..)\n-            | StatementKind::Retag(_, _)\n             | StatementKind::Coverage(_)\n             | StatementKind::Nop => {}\n         }\n@@ -424,10 +425,10 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::DropAndReplace { target, unwind, .. } => {\n-                if self.mir_phase > MirPhase::DropLowering {\n+                if self.mir_phase >= MirPhase::DropsLowered {\n                     self.fail(\n                         location,\n-                        \"`DropAndReplace` is not permitted to exist after drop elaboration\",\n+                        \"`DropAndReplace` should have been removed during drop elaboration\",\n                     );\n                 }\n                 self.check_edge(location, *target, EdgeKind::Normal);\n@@ -494,7 +495,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::Yield { resume, drop, .. } => {\n-                if self.mir_phase > MirPhase::GeneratorLowering {\n+                if self.mir_phase >= MirPhase::GeneratorsLowered {\n                     self.fail(location, \"`Yield` should have been replaced by generator lowering\");\n                 }\n                 self.check_edge(location, *resume, EdgeKind::Normal);\n@@ -503,10 +504,22 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::FalseEdge { real_target, imaginary_target } => {\n+                if self.mir_phase >= MirPhase::DropsLowered {\n+                    self.fail(\n+                        location,\n+                        \"`FalseEdge` should have been removed after drop elaboration\",\n+                    );\n+                }\n                 self.check_edge(location, *real_target, EdgeKind::Normal);\n                 self.check_edge(location, *imaginary_target, EdgeKind::Normal);\n             }\n             TerminatorKind::FalseUnwind { real_target, unwind } => {\n+                if self.mir_phase >= MirPhase::DropsLowered {\n+                    self.fail(\n+                        location,\n+                        \"`FalseUnwind` should have been removed after drop elaboration\",\n+                    );\n+                }\n                 self.check_edge(location, *real_target, EdgeKind::Normal);\n                 if let Some(unwind) = unwind {\n                     self.check_edge(location, *unwind, EdgeKind::Unwind);\n@@ -520,12 +533,19 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     self.check_edge(location, *cleanup, EdgeKind::Unwind);\n                 }\n             }\n+            TerminatorKind::GeneratorDrop => {\n+                if self.mir_phase >= MirPhase::GeneratorsLowered {\n+                    self.fail(\n+                        location,\n+                        \"`GeneratorDrop` should have been replaced by generator lowering\",\n+                    );\n+                }\n+            }\n             // Nothing to validate for these.\n             TerminatorKind::Resume\n             | TerminatorKind::Abort\n             | TerminatorKind::Return\n-            | TerminatorKind::Unreachable\n-            | TerminatorKind::GeneratorDrop => {}\n+            | TerminatorKind::Unreachable => {}\n         }\n \n         self.super_terminator(terminator, location);"}, {"sha": "ea71cff161612ab47a033180669452b2079d2d50", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 54, "deletions": 17, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c66e0c87267859a46f1a8851f30892985760cfd6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66e0c87267859a46f1a8851f30892985760cfd6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=c66e0c87267859a46f1a8851f30892985760cfd6", "patch": "@@ -127,32 +127,44 @@ pub trait MirPass<'tcx> {\n /// These phases all describe dialects of MIR. Since all MIR uses the same datastructures, the\n /// dialects forbid certain variants or values in certain phases.\n ///\n-/// Note: Each phase's validation checks all invariants of the *previous* phases' dialects. A phase\n-/// that changes the dialect documents what invariants must be upheld *after* that phase finishes.\n-///\n /// Warning: ordering of variants is significant.\n #[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, PartialEq, Eq, PartialOrd, Ord)]\n #[derive(HashStable)]\n pub enum MirPhase {\n-    Build = 0,\n+    Built = 0,\n     // FIXME(oli-obk): it's unclear whether we still need this phase (and its corresponding query).\n     // We used to have this for pre-miri MIR based const eval.\n     Const = 1,\n     /// This phase checks the MIR for promotable elements and takes them out of the main MIR body\n     /// by creating a new MIR body per promoted element. After this phase (and thus the termination\n     /// of the `mir_promoted` query), these promoted elements are available in the `promoted_mir`\n     /// query.\n-    ConstPromotion = 2,\n-    /// After this phase\n-    /// * the only `AggregateKind`s allowed are `Array` and `Generator`,\n-    /// * `DropAndReplace` is gone for good\n-    /// * `Drop` now uses explicit drop flags visible in the MIR and reaching a `Drop` terminator\n-    ///   means that the auto-generated drop glue will be invoked.\n-    DropLowering = 3,\n-    /// After this phase, generators are explicit state machines (no more `Yield`).\n-    /// `AggregateKind::Generator` is gone for good.\n-    GeneratorLowering = 4,\n-    Optimization = 5,\n+    ConstsPromoted = 2,\n+    /// Beginning with this phase, the following variants are disallowed:\n+    /// * [`TerminatorKind::DropAndReplace`](terminator::TerminatorKind::DropAndReplace)\n+    /// * [`TerminatorKind::FalseUnwind`](terminator::TerminatorKind::FalseUnwind)\n+    /// * [`TerminatorKind::FalseEdge`](terminator::TerminatorKind::FalseEdge)\n+    /// * [`StatementKind::FakeRead`]\n+    /// * [`StatementKind::AscribeUserType`]\n+    /// * [`Rvalue::Ref`] with `BorrowKind::Shallow`\n+    ///\n+    /// And the following variant is allowed:\n+    /// * [`StatementKind::Retag`]\n+    ///\n+    /// Furthermore, `Drop` now uses explicit drop flags visible in the MIR and reaching a `Drop`\n+    /// terminator means that the auto-generated drop glue will be invoked.\n+    DropsLowered = 3,\n+    /// Beginning with this phase, the following variant is disallowed:\n+    /// * [`Rvalue::Aggregate`] for any `AggregateKind` except `Array`\n+    ///\n+    /// And the following variant is allowed:\n+    /// * [`StatementKind::SetDiscriminant`]\n+    Deaggregated = 4,\n+    /// Beginning with this phase, the following variants are disallowed:\n+    /// * [`TerminatorKind::Yield`](terminator::TerminatorKind::Yield)\n+    /// * [`TerminatorKind::GeneratorDrop](terminator::TerminatorKind::GeneratorDrop)\n+    GeneratorsLowered = 5,\n+    Optimized = 6,\n }\n \n impl MirPhase {\n@@ -311,7 +323,7 @@ impl<'tcx> Body<'tcx> {\n         );\n \n         let mut body = Body {\n-            phase: MirPhase::Build,\n+            phase: MirPhase::Built,\n             source,\n             basic_blocks,\n             source_scopes,\n@@ -346,7 +358,7 @@ impl<'tcx> Body<'tcx> {\n     /// crate.\n     pub fn new_cfg_only(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>) -> Self {\n         let mut body = Body {\n-            phase: MirPhase::Build,\n+            phase: MirPhase::Built,\n             source: MirSource::item(DefId::local(CRATE_DEF_INDEX)),\n             basic_blocks,\n             source_scopes: IndexVec::new(),\n@@ -1541,9 +1553,16 @@ impl Statement<'_> {\n     }\n }\n \n+/// The various kinds of statements that can appear in MIR.\n+///\n+/// Not all of these are allowed at every [`MirPhase`]. Check the documentation there to see which\n+/// ones you do not have to worry about. The MIR validator will generally enforce such restrictions,\n+/// causing an ICE if they are violated.\n #[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, Hash, HashStable, TypeFoldable)]\n pub enum StatementKind<'tcx> {\n     /// Write the RHS Rvalue to the LHS Place.\n+    ///\n+    /// The LHS place may not overlap with any memory accessed on the RHS.\n     Assign(Box<(Place<'tcx>, Rvalue<'tcx>)>),\n \n     /// This represents all the reading that a pattern match may do\n@@ -1761,6 +1780,19 @@ static_assert_size!(Place<'_>, 16);\n pub enum ProjectionElem<V, T> {\n     Deref,\n     Field(Field, T),\n+    /// Index into a slice/array.\n+    ///\n+    /// Note that this does not also dereference, and so it does not exactly correspond to slice\n+    /// indexing in Rust. In other words, in the below Rust code:\n+    ///\n+    /// ```rust\n+    /// let x = &[1, 2, 3, 4];\n+    /// let i = 2;\n+    /// x[i];\n+    /// ```\n+    ///\n+    /// The `x[i]` is turned into a `Deref` followed by an `Index`, not just an `Index`. The same\n+    /// thing is true of the `ConstantIndex` and `Subslice` projections below.\n     Index(V),\n \n     /// These indices are generated by slice patterns. Easiest to explain\n@@ -2223,6 +2255,11 @@ impl<'tcx> Operand<'tcx> {\n /// Rvalues\n \n #[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq)]\n+/// The various kinds of rvalues that can appear in MIR.\n+///\n+/// Not all of these are allowed at every [`MirPhase`]. Check the documentation there to see which\n+/// ones you do not have to worry about. The MIR validator will generally enforce such restrictions,\n+/// causing an ICE if they are violated.\n pub enum Rvalue<'tcx> {\n     /// x (either a move or copy, depending on type of x)\n     Use(Operand<'tcx>),"}, {"sha": "616ba819982ec981807f591f906b95e9c5c4c28e", "filename": "compiler/rustc_mir_transform/src/deaggregator.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c66e0c87267859a46f1a8851f30892985760cfd6/compiler%2Frustc_mir_transform%2Fsrc%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66e0c87267859a46f1a8851f30892985760cfd6/compiler%2Frustc_mir_transform%2Fsrc%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdeaggregator.rs?ref=c66e0c87267859a46f1a8851f30892985760cfd6", "patch": "@@ -6,6 +6,10 @@ use rustc_middle::ty::TyCtxt;\n pub struct Deaggregator;\n \n impl<'tcx> MirPass<'tcx> for Deaggregator {\n+    fn phase_change(&self) -> Option<MirPhase> {\n+        Some(MirPhase::Deaggregated)\n+    }\n+\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n         let local_decls = &*local_decls;"}, {"sha": "f78c7a084d89acc72bfccd2bd0865082f3b5e904", "filename": "compiler/rustc_mir_transform/src/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c66e0c87267859a46f1a8851f30892985760cfd6/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66e0c87267859a46f1a8851f30892985760cfd6/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs?ref=c66e0c87267859a46f1a8851f30892985760cfd6", "patch": "@@ -20,7 +20,7 @@ pub struct ElaborateDrops;\n \n impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n     fn phase_change(&self) -> Option<MirPhase> {\n-        Some(MirPhase::DropLowering)\n+        Some(MirPhase::DropsLowered)\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {"}, {"sha": "ad96bf544cbd339b41a1f95dd665cc2b5a0baa78", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c66e0c87267859a46f1a8851f30892985760cfd6/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66e0c87267859a46f1a8851f30892985760cfd6/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=c66e0c87267859a46f1a8851f30892985760cfd6", "patch": "@@ -1235,7 +1235,7 @@ fn create_cases<'tcx>(\n \n impl<'tcx> MirPass<'tcx> for StateTransform {\n     fn phase_change(&self) -> Option<MirPhase> {\n-        Some(MirPhase::GeneratorLowering)\n+        Some(MirPhase::GeneratorsLowered)\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {"}, {"sha": "2fca498a125021460a6c7d8790bdd199fa970f8c", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c66e0c87267859a46f1a8851f30892985760cfd6/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66e0c87267859a46f1a8851f30892985760cfd6/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=c66e0c87267859a46f1a8851f30892985760cfd6", "patch": "@@ -342,7 +342,7 @@ fn inner_mir_for_ctfe(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -\n             pm::run_passes(\n                 tcx,\n                 &mut body,\n-                &[&const_prop::ConstProp, &marker::PhaseChange(MirPhase::Optimization)],\n+                &[&const_prop::ConstProp, &marker::PhaseChange(MirPhase::Optimized)],\n             );\n         }\n     }\n@@ -399,7 +399,7 @@ fn mir_drops_elaborated_and_const_checked<'tcx>(\n     }\n \n     run_post_borrowck_cleanup_passes(tcx, &mut body);\n-    assert!(body.phase == MirPhase::DropLowering);\n+    assert!(body.phase == MirPhase::Deaggregated);\n     tcx.alloc_steal_mir(body)\n }\n \n@@ -460,7 +460,7 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         ],\n     );\n \n-    assert!(body.phase == MirPhase::GeneratorLowering);\n+    assert!(body.phase == MirPhase::GeneratorsLowered);\n \n     // The main optimizations that we do on MIR.\n     pm::run_passes(\n@@ -497,7 +497,7 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n             &deduplicate_blocks::DeduplicateBlocks,\n             // Some cleanup necessary at least for LLVM and potentially other codegen backends.\n             &add_call_guards::CriticalCallEdges,\n-            &marker::PhaseChange(MirPhase::Optimization),\n+            &marker::PhaseChange(MirPhase::Optimized),\n             // Dump the end result for testing and debugging purposes.\n             &dump_mir::Marker(\"PreCodegen\"),\n         ],"}, {"sha": "740a2168b41cc52865c92782309d41f5beeb2331", "filename": "compiler/rustc_mir_transform/src/pass_manager.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c66e0c87267859a46f1a8851f30892985760cfd6/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66e0c87267859a46f1a8851f30892985760cfd6/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs?ref=c66e0c87267859a46f1a8851f30892985760cfd6", "patch": "@@ -114,7 +114,7 @@ pub fn run_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, passes: &[&dyn\n         }\n     }\n \n-    if validate || body.phase == MirPhase::Optimization {\n+    if validate || body.phase == MirPhase::Optimized {\n         validate_body(tcx, body, format!(\"end of phase transition to {:?}\", body.phase));\n     }\n }"}]}