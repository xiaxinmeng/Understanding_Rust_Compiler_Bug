{"sha": "5e6bbc6bfa82f3ad0a014df24b40cbc042f24035", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNmJiYzZiZmE4MmYzYWQwYTAxNGRmMjRiNDBjYmMwNDJmMjQwMzU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-06T07:29:11Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-10T09:37:11Z"}, "message": "Assorted test fixes and merge conflicts", "tree": {"sha": "08a64c33bf88ad4c750db52f5f64e0717302b91f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08a64c33bf88ad4c750db52f5f64e0717302b91f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035", "html_url": "https://github.com/rust-lang/rust/commit/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b545751597a8cdeee4554338318f0ed6339634fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/b545751597a8cdeee4554338318f0ed6339634fd", "html_url": "https://github.com/rust-lang/rust/commit/b545751597a8cdeee4554338318f0ed6339634fd"}], "stats": {"total": 278, "additions": 134, "deletions": 144}, "files": [{"sha": "ac89ef38e8ecb3455bd8574b8a98155400f6c998", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 32, "deletions": 46, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=5e6bbc6bfa82f3ad0a014df24b40cbc042f24035", "patch": "@@ -95,27 +95,6 @@ impl FsRequest {\n         }\n     }\n \n-    pub fn close(loop_: &Loop, fd: c_int, sync: bool) -> Result<(), UvError> {\n-        if sync {\n-            execute_nop(|req, cb| unsafe {\n-                uvll::uv_fs_close(loop_.handle, req, fd, cb)\n-            })\n-        } else {\n-            unsafe {\n-                let req = uvll::malloc_req(uvll::UV_FS);\n-                uvll::uv_fs_close(loop_.handle, req, fd, close_cb);\n-                return Ok(());\n-            }\n-\n-            extern fn close_cb(req: *uvll::uv_fs_t) {\n-                unsafe {\n-                    uvll::uv_fs_req_cleanup(req);\n-                    uvll::free_req(req);\n-                }\n-            }\n-        }\n-    }\n-\n     pub fn mkdir(loop_: &Loop, path: &CString, mode: c_int)\n         -> Result<(), UvError>\n     {\n@@ -240,10 +219,12 @@ impl FsRequest {\n     pub fn utime(loop_: &Loop, path: &CString, atime: u64, mtime: u64)\n         -> Result<(), UvError>\n     {\n+        // libuv takes seconds\n+        let atime = atime as libc::c_double / 1000.0;\n+        let mtime = mtime as libc::c_double / 1000.0;\n         execute_nop(|req, cb| unsafe {\n             uvll::uv_fs_utime(loop_.handle, req, path.with_ref(|p| p),\n-                              atime as libc::c_double, mtime as libc::c_double,\n-                              cb)\n+                              atime, mtime, cb)\n         })\n     }\n \n@@ -368,12 +349,12 @@ impl FileWatcher {\n     }\n \n     fn base_read(&mut self, buf: &mut [u8], offset: i64) -> Result<int, IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         let r = FsRequest::read(&self.loop_, self.fd, buf, offset);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn base_write(&mut self, buf: &[u8], offset: i64) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         let r = FsRequest::write(&self.loop_, self.fd, buf, offset);\n         r.map_err(uv_error_to_io_error)\n     }\n@@ -397,14 +378,26 @@ impl FileWatcher {\n \n impl Drop for FileWatcher {\n     fn drop(&mut self) {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         match self.close {\n             rtio::DontClose => {}\n             rtio::CloseAsynchronously => {\n-                FsRequest::close(&self.loop_, self.fd, false);\n+                unsafe {\n+                    let req = uvll::malloc_req(uvll::UV_FS);\n+                    uvll::uv_fs_close(self.loop_.handle, req, self.fd, close_cb);\n+                }\n+\n+                extern fn close_cb(req: *uvll::uv_fs_t) {\n+                    unsafe {\n+                        uvll::uv_fs_req_cleanup(req);\n+                        uvll::free_req(req);\n+                    }\n+                }\n             }\n             rtio::CloseSynchronously => {\n-                FsRequest::close(&self.loop_, self.fd, true);\n+                execute_nop(|req, cb| unsafe {\n+                    uvll::uv_fs_close(self.loop_.handle, req, self.fd, cb)\n+                });\n             }\n         }\n     }\n@@ -439,15 +432,15 @@ impl rtio::RtioFileStream for FileWatcher {\n         self_.seek_common(0, SEEK_CUR)\n     }\n     fn fsync(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         FsRequest::fsync(&self.loop_, self.fd).map_err(uv_error_to_io_error)\n     }\n     fn datasync(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         FsRequest::datasync(&self.loop_, self.fd).map_err(uv_error_to_io_error)\n     }\n     fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         let r = FsRequest::truncate(&self.loop_, self.fd, offset);\n         r.map_err(uv_error_to_io_error)\n     }\n@@ -482,10 +475,6 @@ mod test {\n                 // write\n                 let result = FsRequest::write(l, fd, \"hello\".as_bytes(), -1);\n                 assert!(result.is_ok());\n-\n-                // close\n-                let result = FsRequest::close(l, fd, true);\n-                assert!(result.is_ok());\n             }\n \n             {\n@@ -505,15 +494,10 @@ mod test {\n                 assert!(nread > 0);\n                 let read_str = str::from_utf8(read_mem.slice(0, nread as uint));\n                 assert_eq!(read_str, ~\"hello\");\n-\n-                // close\n-                let result = FsRequest::close(l, fd, true);\n-                assert!(result.is_ok());\n-\n-                // unlink\n-                let result = FsRequest::unlink(l, &path_str.to_c_str());\n-                assert!(result.is_ok());\n             }\n+            // unlink\n+            let result = FsRequest::unlink(l, &path_str.to_c_str());\n+            assert!(result.is_ok());\n         }\n     }\n \n@@ -570,12 +554,14 @@ mod test {\n             let path = &\"./tmp/double_create_dir\".to_c_str();\n             let mode = S_IWUSR | S_IRUSR;\n \n+            let result = FsRequest::stat(l, path);\n+            assert!(result.is_err(), \"{:?}\", result);\n             let result = FsRequest::mkdir(l, path, mode as c_int);\n-            assert!(result.is_ok());\n+            assert!(result.is_ok(), \"{:?}\", result);\n             let result = FsRequest::mkdir(l, path, mode as c_int);\n-            assert!(result.is_err());\n+            assert!(result.is_err(), \"{:?}\", result);\n             let result = FsRequest::rmdir(l, path);\n-            assert!(result.is_ok());\n+            assert!(result.is_ok(), \"{:?}\", result);\n         }\n     }\n "}, {"sha": "5d228cd78486b23f75d715d16287dcf0ba99499d", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=5e6bbc6bfa82f3ad0a014df24b40cbc042f24035", "patch": "@@ -259,51 +259,51 @@ impl HomingIO for TcpWatcher {\n \n impl rtio::RtioSocket for TcpWatcher {\n     fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         socket_name(Tcp, self.handle)\n     }\n }\n \n impl rtio::RtioTcpStream for TcpWatcher {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         self.stream.read(buf).map_err(uv_error_to_io_error)\n     }\n \n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         self.stream.write(buf).map_err(uv_error_to_io_error)\n     }\n \n     fn peer_name(&mut self) -> Result<SocketAddr, IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         socket_name(TcpPeer, self.handle)\n     }\n \n     fn control_congestion(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n             uvll::uv_tcp_nodelay(self.handle, 0 as c_int)\n         })\n     }\n \n     fn nodelay(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n             uvll::uv_tcp_nodelay(self.handle, 1 as c_int)\n         })\n     }\n \n     fn keepalive(&mut self, delay_in_seconds: uint) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n             uvll::uv_tcp_keepalive(self.handle, 1 as c_int,\n                                    delay_in_seconds as c_uint)\n         })\n     }\n \n     fn letdie(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n             uvll::uv_tcp_keepalive(self.handle, 0 as c_int, 0 as c_uint)\n         })\n@@ -312,7 +312,7 @@ impl rtio::RtioTcpStream for TcpWatcher {\n \n impl Drop for TcpWatcher {\n     fn drop(&mut self) {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         self.stream.close();\n     }\n }\n@@ -356,7 +356,7 @@ impl UvHandle<uvll::uv_tcp_t> for TcpListener {\n \n impl rtio::RtioSocket for TcpListener {\n     fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         socket_name(Tcp, self.handle)\n     }\n }\n@@ -370,7 +370,7 @@ impl rtio::RtioTcpListener for TcpListener {\n             incoming: incoming,\n         };\n \n-        let _m = acceptor.fire_missiles();\n+        let _m = acceptor.fire_homing_missile();\n         // XXX: the 128 backlog should be configurable\n         match unsafe { uvll::uv_listen(acceptor.listener.handle, 128, listen_cb) } {\n             0 => Ok(acceptor as ~rtio::RtioTcpAcceptor),\n@@ -399,7 +399,7 @@ extern fn listen_cb(server: *uvll::uv_stream_t, status: c_int) {\n \n impl Drop for TcpListener {\n     fn drop(&mut self) {\n-        let (_m, sched) = self.fire_missiles_sched();\n+        let (_m, sched) = self.fire_homing_missile_sched();\n \n         do sched.deschedule_running_task_and_then |_, task| {\n             self.closing_task = Some(task);\n@@ -424,26 +424,26 @@ impl HomingIO for TcpAcceptor {\n \n impl rtio::RtioSocket for TcpAcceptor {\n     fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         socket_name(Tcp, self.listener.handle)\n     }\n }\n \n impl rtio::RtioTcpAcceptor for TcpAcceptor {\n     fn accept(&mut self) -> Result<~rtio::RtioTcpStream, IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         self.incoming.recv()\n     }\n \n     fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n             uvll::uv_tcp_simultaneous_accepts(self.listener.handle, 1)\n         })\n     }\n \n     fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n             uvll::uv_tcp_simultaneous_accepts(self.listener.handle, 0)\n         })\n@@ -489,7 +489,7 @@ impl HomingIO for UdpWatcher {\n \n impl rtio::RtioSocket for UdpWatcher {\n     fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         socket_name(Udp, self.handle)\n     }\n }\n@@ -503,7 +503,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n             buf: Option<Buf>,\n             result: Option<(ssize_t, SocketAddr)>,\n         }\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n \n         return match unsafe {\n             uvll::uv_udp_recv_start(self.handle, alloc_cb, recv_cb)\n@@ -564,7 +564,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n     fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> Result<(), IoError> {\n         struct Ctx { task: Option<BlockedTask>, result: c_int }\n \n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n \n         let req = Request::new(uvll::UV_UDP_SEND);\n         let buf = slice_to_uv_buf(buf);\n@@ -607,7 +607,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n     }\n \n     fn join_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n             do multi.to_str().with_c_str |m_addr| {\n                 uvll::uv_udp_set_membership(self.handle,\n@@ -618,7 +618,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n     }\n \n     fn leave_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n             do multi.to_str().with_c_str |m_addr| {\n                 uvll::uv_udp_set_membership(self.handle,\n@@ -629,46 +629,46 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n     }\n \n     fn loop_multicast_locally(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n             uvll::uv_udp_set_multicast_loop(self.handle,\n                                             1 as c_int)\n         })\n     }\n \n     fn dont_loop_multicast_locally(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n             uvll::uv_udp_set_multicast_loop(self.handle,\n                                             0 as c_int)\n         })\n     }\n \n     fn multicast_time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n             uvll::uv_udp_set_multicast_ttl(self.handle,\n                                            ttl as c_int)\n         })\n     }\n \n     fn time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n             uvll::uv_udp_set_ttl(self.handle, ttl as c_int)\n         })\n     }\n \n     fn hear_broadcasts(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n             uvll::uv_udp_set_broadcast(self.handle,\n                                        1 as c_int)\n         })\n     }\n \n     fn ignore_broadcasts(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n             uvll::uv_udp_set_broadcast(self.handle,\n                                        0 as c_int)\n@@ -679,7 +679,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n impl Drop for UdpWatcher {\n     fn drop(&mut self) {\n         // Send ourselves home to close this handle (blocking while doing so).\n-        let (_m, sched) = self.fire_missiles_sched();\n+        let (_m, sched) = self.fire_homing_missile_sched();\n         let mut slot = None;\n         unsafe {\n             uvll::set_data_for_uv_handle(self.handle, &slot);\n@@ -693,6 +693,7 @@ impl Drop for UdpWatcher {\n             let slot: &mut Option<BlockedTask> = unsafe {\n                 cast::transmute(uvll::get_data_for_uv_handle(handle))\n             };\n+            unsafe { uvll::free_handle(handle) }\n             let sched: ~Scheduler = Local::take();\n             sched.resume_blocked_task_immediately(slot.take_unwrap());\n         }"}, {"sha": "1f28e043dfb4988881cfa37a24df6802a9b8b704", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 52, "deletions": 50, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=5e6bbc6bfa82f3ad0a014df24b40cbc042f24035", "patch": "@@ -26,6 +26,7 @@ use uvll;\n pub struct PipeWatcher {\n     stream: StreamWatcher,\n     home: SchedHandle,\n+    priv defused: bool,\n }\n \n pub struct PipeListener {\n@@ -43,47 +44,43 @@ pub struct PipeAcceptor {\n // PipeWatcher implementation and traits\n \n impl PipeWatcher {\n-    pub fn new(pipe: *uvll::uv_pipe_t) -> PipeWatcher {\n-        PipeWatcher {\n-            stream: StreamWatcher::new(pipe),\n-            home: get_handle_to_current_scheduler!(),\n-        }\n-    }\n-\n-    pub fn alloc(loop_: &Loop, ipc: bool) -> *uvll::uv_pipe_t {\n-        unsafe {\n+    // Creates an uninitialized pipe watcher. The underlying uv pipe is ready to\n+    // get bound to some other source (this is normally a helper method paired\n+    // with another call).\n+    pub fn new(loop_: &Loop, ipc: bool) -> PipeWatcher {\n+        let handle = unsafe {\n             let handle = uvll::malloc_handle(uvll::UV_NAMED_PIPE);\n             assert!(!handle.is_null());\n             let ipc = ipc as libc::c_int;\n             assert_eq!(uvll::uv_pipe_init(loop_.handle, handle, ipc), 0);\n             handle\n+        };\n+        PipeWatcher {\n+            stream: StreamWatcher::new(handle),\n+            home: get_handle_to_current_scheduler!(),\n+            defused: false,\n         }\n     }\n \n     pub fn open(loop_: &Loop, file: libc::c_int) -> Result<PipeWatcher, UvError>\n     {\n-        let handle = PipeWatcher::alloc(loop_, false);\n-        match unsafe { uvll::uv_pipe_open(handle, file) } {\n-            0 => Ok(PipeWatcher::new(handle)),\n-            n => {\n-                unsafe { uvll::uv_close(handle, pipe_close_cb) }\n-                Err(UvError(n))\n-            }\n+        let pipe = PipeWatcher::new(loop_, false);\n+        match unsafe { uvll::uv_pipe_open(pipe.handle(), file) } {\n+            0 => Ok(pipe),\n+            n => Err(UvError(n))\n         }\n     }\n \n     pub fn connect(loop_: &Loop, name: &CString) -> Result<PipeWatcher, UvError>\n     {\n-        struct Ctx {\n-            task: Option<BlockedTask>,\n-            result: Option<Result<PipeWatcher, UvError>>,\n-        }\n-        let mut cx = Ctx { task: None, result: None };\n+        struct Ctx { task: Option<BlockedTask>, result: libc::c_int, }\n+        let mut cx = Ctx { task: None, result: 0 };\n         let req = Request::new(uvll::UV_CONNECT);\n+        let pipe = PipeWatcher::new(loop_, false);\n         unsafe {\n             uvll::set_data_for_req(req.handle, &cx as *Ctx);\n             uvll::uv_pipe_connect(req.handle,\n-                                  PipeWatcher::alloc(loop_, false),\n+                                  pipe.handle(),\n                                   name.with_ref(|p| p),\n                                   connect_cb)\n         }\n@@ -93,38 +90,41 @@ impl PipeWatcher {\n         do sched.deschedule_running_task_and_then |_, task| {\n             cx.task = Some(task);\n         }\n-        assert!(cx.task.is_none());\n-        return cx.result.take().expect(\"pipe connect needs a result\");\n+        return match cx.result {\n+            0 => Ok(pipe),\n+            n => Err(UvError(n))\n+        };\n \n         extern fn connect_cb(req: *uvll::uv_connect_t, status: libc::c_int) {\n             let _req = Request::wrap(req);\n             if status == uvll::ECANCELED { return }\n             unsafe {\n                 let cx: &mut Ctx = cast::transmute(uvll::get_data_for_req(req));\n-                let stream = uvll::get_stream_handle_from_connect_req(req);\n-                cx.result = Some(match status {\n-                    0 => Ok(PipeWatcher::new(stream)),\n-                    n => {\n-                        uvll::free_handle(stream);\n-                        Err(UvError(n))\n-                    }\n-                });\n-\n+                cx.result = status;\n                 let sched: ~Scheduler = Local::take();\n                 sched.resume_blocked_task_immediately(cx.task.take_unwrap());\n             }\n         }\n     }\n+\n+    pub fn handle(&self) -> *uvll::uv_pipe_t { self.stream.handle }\n+\n+    // Unwraps the underlying uv pipe. This cancels destruction of the pipe and\n+    // allows the pipe to get moved elsewhere\n+    fn unwrap(mut self) -> *uvll::uv_pipe_t {\n+        self.defused = true;\n+        return self.stream.handle;\n+    }\n }\n \n impl RtioPipe for PipeWatcher {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         self.stream.read(buf).map_err(uv_error_to_io_error)\n     }\n \n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         self.stream.write(buf).map_err(uv_error_to_io_error)\n     }\n }\n@@ -135,8 +135,10 @@ impl HomingIO for PipeWatcher {\n \n impl Drop for PipeWatcher {\n     fn drop(&mut self) {\n-        let _m = self.fire_missiles();\n-        self.stream.close();\n+        if !self.defused {\n+            let _m = self.fire_homing_missile();\n+            self.stream.close();\n+        }\n     }\n }\n \n@@ -148,21 +150,21 @@ extern fn pipe_close_cb(handle: *uvll::uv_handle_t) {\n \n impl PipeListener {\n     pub fn bind(loop_: &Loop, name: &CString) -> Result<~PipeListener, UvError> {\n-        let pipe = PipeWatcher::alloc(loop_, false);\n-        match unsafe { uvll::uv_pipe_bind(pipe, name.with_ref(|p| p)) } {\n+        let pipe = PipeWatcher::new(loop_, false);\n+        match unsafe { uvll::uv_pipe_bind(pipe.handle(), name.with_ref(|p| p)) } {\n             0 => {\n+                // If successful, unwrap the PipeWatcher because we control how\n+                // we close the pipe differently. We can't rely on\n+                // StreamWatcher's default close method.\n                 let p = ~PipeListener {\n                     home: get_handle_to_current_scheduler!(),\n-                    pipe: pipe,\n+                    pipe: pipe.unwrap(),\n                     closing_task: None,\n                     outgoing: Tube::new(),\n                 };\n                 Ok(p.install())\n             }\n-            n => {\n-                unsafe { uvll::uv_close(pipe, pipe_close_cb) }\n-                Err(UvError(n))\n-            }\n+            n => Err(UvError(n))\n         }\n     }\n }\n@@ -176,7 +178,7 @@ impl RtioUnixListener for PipeListener {\n             incoming: incoming,\n         };\n \n-        let _m = acceptor.fire_missiles();\n+        let _m = acceptor.fire_homing_missile();\n         // XXX: the 128 backlog should be configurable\n         match unsafe { uvll::uv_listen(acceptor.listener.pipe, 128, listen_cb) } {\n             0 => Ok(acceptor as ~RtioUnixAcceptor),\n@@ -199,9 +201,9 @@ extern fn listen_cb(server: *uvll::uv_stream_t, status: libc::c_int) {\n             let loop_ = Loop::wrap(unsafe {\n                 uvll::get_loop_for_uv_handle(server)\n             });\n-            let client = PipeWatcher::alloc(&loop_, false);\n-            assert_eq!(unsafe { uvll::uv_accept(server, client) }, 0);\n-            Ok(~PipeWatcher::new(client) as ~RtioPipe)\n+            let client = PipeWatcher::new(&loop_, false);\n+            assert_eq!(unsafe { uvll::uv_accept(server, client.handle()) }, 0);\n+            Ok(~client as ~RtioPipe)\n         }\n         uvll::ECANCELED => return,\n         n => Err(uv_error_to_io_error(UvError(n)))\n@@ -213,7 +215,7 @@ extern fn listen_cb(server: *uvll::uv_stream_t, status: libc::c_int) {\n \n impl Drop for PipeListener {\n     fn drop(&mut self) {\n-        let (_m, sched) = self.fire_missiles_sched();\n+        let (_m, sched) = self.fire_homing_missile_sched();\n \n         do sched.deschedule_running_task_and_then |_, task| {\n             self.closing_task = Some(task);\n@@ -234,7 +236,7 @@ extern fn listener_close_cb(handle: *uvll::uv_handle_t) {\n \n impl RtioUnixAcceptor for PipeAcceptor {\n     fn accept(&mut self) -> Result<~RtioPipe, IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         self.incoming.recv()\n     }\n }"}, {"sha": "15d5ae1c33ca5514918a4c83c62d6729bf7886e7", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=5e6bbc6bfa82f3ad0a014df24b40cbc042f24035", "patch": "@@ -144,10 +144,10 @@ unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,\n             if writable {\n                 flags |= uvll::STDIO_WRITABLE_PIPE as libc::c_int;\n             }\n-            let pipe_handle = PipeWatcher::alloc(loop_, false);\n+            let pipe = PipeWatcher::new(loop_, false);\n             uvll::set_stdio_container_flags(dst, flags);\n-            uvll::set_stdio_container_stream(dst, pipe_handle);\n-            Some(PipeWatcher::new(pipe_handle))\n+            uvll::set_stdio_container_stream(dst, pipe.handle());\n+            Some(pipe)\n         }\n     }\n }\n@@ -204,7 +204,7 @@ impl RtioProcess for Process {\n     }\n \n     fn kill(&mut self, signal: int) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         match unsafe {\n             uvll::uv_process_kill(self.handle, signal as libc::c_int)\n         } {\n@@ -215,7 +215,7 @@ impl RtioProcess for Process {\n \n     fn wait(&mut self) -> int {\n         // Make sure (on the home scheduler) that we have an exit status listed\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         match self.exit_status {\n             Some(*) => {}\n             None => {\n@@ -238,7 +238,7 @@ impl RtioProcess for Process {\n \n impl Drop for Process {\n     fn drop(&mut self) {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         assert!(self.to_wake.is_none());\n         self.close_async_();\n     }"}, {"sha": "b7a37473fb944010d7acde1a5f8c58c70a20a8af", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=5e6bbc6bfa82f3ad0a014df24b40cbc042f24035", "patch": "@@ -73,7 +73,7 @@ impl RtioSignal for SignalWatcher {}\n \n impl Drop for SignalWatcher {\n     fn drop(&mut self) {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         self.close_async_();\n     }\n }"}, {"sha": "df35a4892e97876cff1a3d0999bb32e311b0f1b4", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=5e6bbc6bfa82f3ad0a014df24b40cbc042f24035", "patch": "@@ -66,7 +66,7 @@ impl UvHandle<uvll::uv_timer_t> for TimerWatcher {\n \n impl RtioTimer for TimerWatcher {\n     fn sleep(&mut self, msecs: u64) {\n-        let (_m, sched) = self.fire_missiles_sched();\n+        let (_m, sched) = self.fire_homing_missile_sched();\n         do sched.deschedule_running_task_and_then |_sched, task| {\n             self.action = Some(WakeTask(task));\n             self.start(msecs, 0);\n@@ -77,7 +77,7 @@ impl RtioTimer for TimerWatcher {\n     fn oneshot(&mut self, msecs: u64) -> PortOne<()> {\n         let (port, chan) = oneshot();\n \n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         self.action = Some(SendOnce(chan));\n         self.start(msecs, 0);\n \n@@ -87,7 +87,7 @@ impl RtioTimer for TimerWatcher {\n     fn period(&mut self, msecs: u64) -> Port<()> {\n         let (port, chan) = stream();\n \n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         self.action = Some(SendMany(chan));\n         self.start(msecs, msecs);\n \n@@ -113,7 +113,7 @@ extern fn timer_cb(handle: *uvll::uv_timer_t, _status: c_int) {\n \n impl Drop for TimerWatcher {\n     fn drop(&mut self) {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         self.action = None;\n         self.stop();\n         self.close_async_();"}, {"sha": "c072ab5156121cc7cd9ff716641ec12deb7a02e1", "filename": "src/librustuv/tty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035/src%2Flibrustuv%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035/src%2Flibrustuv%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftty.rs?ref=5e6bbc6bfa82f3ad0a014df24b40cbc042f24035", "patch": "@@ -54,18 +54,18 @@ impl TtyWatcher {\n \n impl RtioTTY for TtyWatcher {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         self.stream.read(buf).map_err(uv_error_to_io_error)\n     }\n \n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         self.stream.write(buf).map_err(uv_error_to_io_error)\n     }\n \n     fn set_raw(&mut self, raw: bool) -> Result<(), IoError> {\n         let raw = raw as libc::c_int;\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         match unsafe { uvll::uv_tty_set_mode(self.tty, raw) } {\n             0 => Ok(()),\n             n => Err(uv_error_to_io_error(UvError(n)))\n@@ -79,7 +79,7 @@ impl RtioTTY for TtyWatcher {\n         let widthptr: *libc::c_int = &width;\n         let heightptr: *libc::c_int = &width;\n \n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         match unsafe { uvll::uv_tty_get_winsize(self.tty,\n                                                 widthptr, heightptr) } {\n             0 => Ok((width as int, height as int)),\n@@ -102,7 +102,7 @@ impl HomingIO for TtyWatcher {\n \n impl Drop for TtyWatcher {\n     fn drop(&mut self) {\n-        let _m = self.fire_missiles();\n+        let _m = self.fire_homing_missile();\n         self.stream.close();\n     }\n }"}, {"sha": "06c07308cf634fa78335c6cb6322c5824ae75fb0", "filename": "src/libstd/rt/io/fs.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035/src%2Flibstd%2Frt%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6bbc6bfa82f3ad0a014df24b40cbc042f24035/src%2Flibstd%2Frt%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffs.rs?ref=5e6bbc6bfa82f3ad0a014df24b40cbc042f24035", "patch": "@@ -589,7 +589,8 @@ pub fn rmdir_recursive(path: &Path) {\n \n /// Changes the timestamps for a file's last modification and access time.\n /// The file at the path specified will have its last access time set to\n-/// `atime` and its modification time set to `mtime`.\n+/// `atime` and its modification time set to `mtime`. The times specified should\n+/// be in milliseconds.\n ///\n /// # Errors\n ///\n@@ -1266,9 +1267,9 @@ mod test {\n         let path = tmpdir.join(\"a\");\n         File::create(&path);\n \n-        change_file_times(&path, 100, 200);\n-        assert_eq!(path.stat().accessed, 100);\n-        assert_eq!(path.stat().modified, 200);\n+        change_file_times(&path, 1000, 2000);\n+        assert_eq!(path.stat().accessed, 1000);\n+        assert_eq!(path.stat().modified, 2000);\n \n         rmdir_recursive(&tmpdir);\n     }"}]}