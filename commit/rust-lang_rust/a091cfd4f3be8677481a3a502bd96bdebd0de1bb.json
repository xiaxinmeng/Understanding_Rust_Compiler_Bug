{"sha": "a091cfd4f3be8677481a3a502bd96bdebd0de1bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwOTFjZmQ0ZjNiZTg2Nzc0ODFhM2E1MDJiZDk2YmRlYmQwZGUxYmI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-05-16T23:26:18Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-06-03T13:11:18Z"}, "message": "implement drop elaboration\n\nFixes #30380", "tree": {"sha": "5c493419c53f456c04922247e550ad6c2741d4f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c493419c53f456c04922247e550ad6c2741d4f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a091cfd4f3be8677481a3a502bd96bdebd0de1bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a091cfd4f3be8677481a3a502bd96bdebd0de1bb", "html_url": "https://github.com/rust-lang/rust/commit/a091cfd4f3be8677481a3a502bd96bdebd0de1bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a091cfd4f3be8677481a3a502bd96bdebd0de1bb/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de7cb0fdd69c95158d217b9a913f1e25f3bfeef0", "url": "https://api.github.com/repos/rust-lang/rust/commits/de7cb0fdd69c95158d217b9a913f1e25f3bfeef0", "html_url": "https://github.com/rust-lang/rust/commit/de7cb0fdd69c95158d217b9a913f1e25f3bfeef0"}], "stats": {"total": 1433, "additions": 1431, "deletions": 2}, "files": [{"sha": "d22b7bd6d5a9fb59c4277f2dc71be0fe3db727e2", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a091cfd4f3be8677481a3a502bd96bdebd0de1bb/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a091cfd4f3be8677481a3a502bd96bdebd0de1bb/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=a091cfd4f3be8677481a3a502bd96bdebd0de1bb", "patch": "@@ -613,6 +613,24 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             value.trans_normalize(&infcx)\n         })\n     }\n+\n+    pub fn normalize_associated_type_in_env<T>(\n+        self, value: &T, env: &'a ty::ParameterEnvironment<'tcx>\n+    ) -> T\n+        where T: TransNormalize<'tcx>\n+    {\n+        debug!(\"normalize_associated_type_in_env(t={:?})\", value);\n+\n+        let value = self.erase_regions(value);\n+\n+        if !value.has_projection_types() {\n+            return value;\n+        }\n+\n+        self.infer_ctxt(None, Some(env.clone()), ProjectionMode::Any).enter(|infcx| {\n+            value.trans_normalize(&infcx)\n+       })\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "113d3ff8512b14885a59a0f5f11a44fbb6318b94", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a091cfd4f3be8677481a3a502bd96bdebd0de1bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a091cfd4f3be8677481a3a502bd96bdebd0de1bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs?ref=a091cfd4f3be8677481a3a502bd96bdebd0de1bb", "patch": "@@ -200,6 +200,12 @@ impl<'a, 'tcx: 'a, O> DataflowAnalysis<'a, 'tcx, O>\n \n pub struct DataflowResults<O>(DataflowState<O>) where O: BitDenotation;\n \n+impl<O: BitDenotation> DataflowResults<O> {\n+    pub fn sets(&self) -> &AllSets {\n+        &self.0.sets\n+    }\n+}\n+\n // FIXME: This type shouldn't be public, but the graphviz::MirWithFlowState trait\n // references it in a method signature. Look into using `pub(crate)` to address this.\n pub struct DataflowState<O: BitDenotation>"}, {"sha": "e299d47aee61c42882a3bde1a7f88b0a1cc22932", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "added", "additions": 1038, "deletions": 0, "changes": 1038, "blob_url": "https://github.com/rust-lang/rust/blob/a091cfd4f3be8677481a3a502bd96bdebd0de1bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a091cfd4f3be8677481a3a502bd96bdebd0de1bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=a091cfd4f3be8677481a3a502bd96bdebd0de1bb", "patch": "@@ -0,0 +1,1038 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use bitslice::BitSlice;\n+use super::gather_moves::{MoveData, MovePathIndex, MovePathContent, Location};\n+use super::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n+use super::dataflow::{DataflowResults};\n+use super::{drop_flag_effects_for_location, on_all_children_bits};\n+use super::{DropFlagState};\n+use super::patch::MirPatch;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::subst::{Subst, Substs, VecPerParamSpace};\n+use rustc::mir::repr::*;\n+use rustc::mir::transform::{Pass, MirPass, MirSource};\n+use rustc::middle::const_val::ConstVal;\n+use rustc::middle::lang_items;\n+use rustc::util::nodemap::FnvHashMap;\n+use rustc_mir::pretty;\n+use syntax::codemap::Span;\n+\n+use std::fmt;\n+use std::u32;\n+\n+pub struct ElaborateDrops;\n+\n+impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    src: MirSource, mir: &mut Mir<'tcx>)\n+    {\n+        debug!(\"elaborate_drops({:?} @ {:?})\", src, mir.span);\n+        match src {\n+            MirSource::Fn(..) => {},\n+            _ => return\n+        }\n+        let id = src.item_id();\n+        let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+        let move_data = MoveData::gather_moves(mir, tcx);\n+        let elaborate_patch = {\n+            let mir = &*mir;\n+            let ((_, _, move_data), flow_inits) =\n+                super::do_dataflow(tcx, mir, id, &[], (tcx, mir, move_data),\n+                                   MaybeInitializedLvals::default());\n+            let ((_, _, move_data), flow_uninits) =\n+                super::do_dataflow(tcx, mir, id, &[], (tcx, mir, move_data),\n+                                   MaybeUninitializedLvals::default());\n+\n+            match (tcx, mir, move_data) {\n+                ref ctxt => ElaborateDropsCtxt {\n+                    ctxt: ctxt,\n+                    param_env: &param_env,\n+                    flow_inits: flow_inits,\n+                    flow_uninits: flow_uninits,\n+                    drop_flags: FnvHashMap(),\n+                    patch: MirPatch::new(mir),\n+                }.elaborate()\n+            }\n+        };\n+        pretty::dump_mir(tcx, \"elaborate_drops\", &0, src, mir, None);\n+        elaborate_patch.apply(mir);\n+        pretty::dump_mir(tcx, \"elaborate_drops\", &1, src, mir, None);\n+    }\n+}\n+\n+impl Pass for ElaborateDrops {}\n+\n+struct InitializationData {\n+    live: Vec<usize>,\n+    dead: Vec<usize>\n+}\n+\n+impl InitializationData {\n+    fn apply_location<'a,'tcx>(&mut self,\n+                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                               mir: &Mir<'tcx>,\n+                               move_data: &MoveData<'tcx>,\n+                               loc: Location)\n+    {\n+        drop_flag_effects_for_location(tcx, mir, move_data, loc, |path, df| {\n+            debug!(\"at location {:?}: setting {:?} to {:?}\",\n+                   loc, path, df);\n+            match df {\n+                DropFlagState::Live => {\n+                    self.live.set_bit(path.idx());\n+                    self.dead.clear_bit(path.idx());\n+                }\n+                DropFlagState::Dead => {\n+                    self.dead.set_bit(path.idx());\n+                    self.live.clear_bit(path.idx());\n+                }\n+            }\n+        });\n+    }\n+\n+    fn state(&self, path: MovePathIndex) -> (bool, bool) {\n+        (self.live.get_bit(path.idx()), self.dead.get_bit(path.idx()))\n+    }\n+}\n+\n+impl fmt::Debug for InitializationData {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        Ok(())\n+    }\n+}\n+\n+struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n+    ctxt: &'a (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>),\n+    param_env: &'a ty::ParameterEnvironment<'tcx>,\n+    flow_inits: DataflowResults<MaybeInitializedLvals<'a, 'tcx>>,\n+    flow_uninits:  DataflowResults<MaybeUninitializedLvals<'a, 'tcx>>,\n+    drop_flags: FnvHashMap<MovePathIndex, u32>,\n+    patch: MirPatch<'tcx>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+struct DropCtxt<'a, 'tcx: 'a> {\n+    span: Span,\n+    scope: ScopeId,\n+    is_cleanup: bool,\n+\n+    init_data: &'a InitializationData,\n+\n+    lvalue: &'a Lvalue<'tcx>,\n+    path: MovePathIndex,\n+    succ: BasicBlock,\n+    unwind: Option<BasicBlock>\n+}\n+\n+impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'b, 'tcx, 'tcx> { self.ctxt.0 }\n+    fn mir(&self) -> &'b Mir<'tcx> { self.ctxt.1 }\n+    fn move_data(&self) -> &'b MoveData<'tcx> { &self.ctxt.2 }\n+\n+    fn initialization_data_at(&self, loc: Location) -> InitializationData {\n+        let mut data = InitializationData {\n+            live: self.flow_inits.sets().on_entry_set_for(loc.block.index())\n+                .to_owned(),\n+            dead: self.flow_uninits.sets().on_entry_set_for(loc.block.index())\n+                .to_owned(),\n+        };\n+        for stmt in 0..loc.index {\n+            data.apply_location(self.ctxt.0, self.ctxt.1, &self.ctxt.2,\n+                                Location { block: loc.block, index: stmt });\n+        }\n+        data\n+    }\n+\n+    fn create_drop_flag(&mut self, index: MovePathIndex) {\n+        let tcx = self.tcx();\n+        let patch = &mut self.patch;\n+        self.drop_flags.entry(index).or_insert_with(|| {\n+            patch.new_temp(tcx.types.bool)\n+        });\n+    }\n+\n+    fn drop_flag(&mut self, index: MovePathIndex) -> Option<Lvalue<'tcx>> {\n+        self.drop_flags.get(&index).map(|t| Lvalue::Temp(*t))\n+    }\n+\n+    /// create a patch that elaborates all drops in the input\n+    /// MIR.\n+    fn elaborate(mut self) -> MirPatch<'tcx>\n+    {\n+        self.collect_drop_flags();\n+\n+        self.elaborate_drops();\n+\n+        self.drop_flags_on_init();\n+        self.drop_flags_for_fn_rets();\n+        self.drop_flags_for_args();\n+        self.drop_flags_for_locs();\n+\n+        self.patch\n+    }\n+\n+    fn path_needs_drop(&self, path: MovePathIndex) -> bool\n+    {\n+        match self.move_data().move_paths[path].content {\n+            MovePathContent::Lvalue(ref lvalue) => {\n+                let ty = self.mir().lvalue_ty(self.tcx(), lvalue)\n+                    .to_ty(self.tcx());\n+                debug!(\"path_needs_drop({:?}, {:?} : {:?})\", path, lvalue, ty);\n+\n+                self.tcx().type_needs_drop_given_env(ty, &self.param_env)\n+            }\n+            _ => false\n+        }\n+    }\n+\n+    /// Returns whether this lvalue is tracked by drop elaboration. This\n+    /// includes all lvalues, except these behind references or arrays.\n+    ///\n+    /// Lvalues behind references or arrays are not tracked by elaboration\n+    /// and are always assumed to be initialized when accessible. As\n+    /// references and indexes can be reseated, trying to track them\n+    /// can only lead to trouble.\n+    fn lvalue_is_tracked(&self, lv: &Lvalue<'tcx>) -> bool\n+    {\n+        if let &Lvalue::Projection(ref data) = lv {\n+            self.lvalue_contents_are_tracked(&data.base)\n+        } else {\n+            true\n+        }\n+    }\n+\n+    fn lvalue_contents_are_tracked(&self, lv: &Lvalue<'tcx>) -> bool {\n+        let ty = self.mir().lvalue_ty(self.tcx(), lv).to_ty(self.tcx());\n+        match ty.sty {\n+            ty::TyArray(..) | ty::TySlice(..) | ty::TyRef(..) | ty::TyRawPtr(..) => {\n+                false\n+            }\n+            _ => self.lvalue_is_tracked(lv)\n+        }\n+    }\n+\n+    fn collect_drop_flags(&mut self)\n+    {\n+        for bb in self.mir().all_basic_blocks() {\n+            let data = self.mir().basic_block_data(bb);\n+            let terminator = data.terminator();\n+            let location = match terminator.kind {\n+                TerminatorKind::Drop { ref location, .. } |\n+                TerminatorKind::DropAndReplace { ref location, .. } => location,\n+                _ => continue\n+            };\n+\n+            if !self.lvalue_is_tracked(location) {\n+                continue\n+            }\n+\n+            let init_data = self.initialization_data_at(Location {\n+                block: bb,\n+                index: data.statements.len()\n+            });\n+\n+            let path = self.move_data().rev_lookup.find(location);\n+            debug!(\"collect_drop_flags: {:?}, lv {:?} (index {:?})\",\n+                   bb, location, path);\n+\n+            on_all_children_bits(self.tcx(), self.mir(), self.move_data(), path, |child| {\n+                if self.path_needs_drop(child) {\n+                    let (maybe_live, maybe_dead) = init_data.state(child);\n+                    debug!(\"collect_drop_flags: collecting {:?} from {:?}@{:?} - {:?}\",\n+                           child, location, path, (maybe_live, maybe_dead));\n+                    if maybe_live && maybe_dead {\n+                        self.create_drop_flag(child)\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    fn elaborate_drops(&mut self)\n+    {\n+        for bb in self.mir().all_basic_blocks() {\n+            let data = self.mir().basic_block_data(bb);\n+            let loc = Location { block: bb, index: data.statements.len() };\n+            let terminator = data.terminator();\n+\n+            let resume_block = self.patch.resume_block();\n+            match terminator.kind {\n+                TerminatorKind::Drop { ref location, target, unwind } => {\n+                    let init_data = self.initialization_data_at(loc);\n+                    let path = self.move_data().rev_lookup.find(location);\n+                    self.elaborate_drop(&DropCtxt {\n+                        span: terminator.span,\n+                        scope: terminator.scope,\n+                        is_cleanup: data.is_cleanup,\n+                        init_data: &init_data,\n+                        lvalue: location,\n+                        path: path,\n+                        succ: target,\n+                        unwind: if data.is_cleanup {\n+                            None\n+                        } else {\n+                            Some(Option::unwrap_or(unwind, resume_block))\n+                        }\n+                    }, bb);\n+                }\n+                TerminatorKind::DropAndReplace { ref location, ref value,\n+                                                 target, unwind } =>\n+                {\n+                    assert!(!data.is_cleanup);\n+\n+                    self.elaborate_replace(\n+                        loc,\n+                        location, value,\n+                        target, unwind\n+                    );\n+                }\n+                _ => continue\n+            }\n+        }\n+    }\n+\n+    /// Elaborate a MIR `replace` terminator. This instruction\n+    /// is not directly handled by translation, and therefore\n+    /// must be desugared.\n+    ///\n+    /// The desugaring drops the location if needed, and then writes\n+    /// the value (including setting the drop flag) over it in *both* arms.\n+    ///\n+    /// The `replace` terminator can also be called on lvalues that\n+    /// are not tracked by elaboration (for example,\n+    /// `replace x[i] <- tmp0`). The borrow checker requires that\n+    /// these locations are initialized before the assignment,\n+    /// so we just generate an unconditional drop.\n+    fn elaborate_replace(\n+        &mut self,\n+        loc: Location,\n+        location: &Lvalue<'tcx>,\n+        value: &Operand<'tcx>,\n+        target: BasicBlock,\n+        unwind: Option<BasicBlock>)\n+    {\n+        let bb = loc.block;\n+        let data = self.mir().basic_block_data(bb);\n+        let terminator = data.terminator();\n+\n+        let unwind = Some(unwind.unwrap_or_else(|| {\n+            // we can't use the resume block directly, because we\n+            // may want to add a drop flag write.\n+            self.jump_to_resume_block(terminator.scope,\n+                                      terminator.span)\n+        }));\n+\n+        if !self.lvalue_is_tracked(location) {\n+            // drop and replace behind a pointer/array/whatever. The location\n+            // must be initialized.\n+            debug!(\"elaborate_drop_and_replace({:?}) - untracked\", terminator);\n+            self.patch.patch_terminator(bb, TerminatorKind::Drop {\n+                location: location.clone(),\n+                target: target,\n+                unwind: unwind\n+            });\n+        } else {\n+            debug!(\"elaborate_drop_and_replace({:?}) - tracked\", terminator);\n+            let init_data = self.initialization_data_at(loc);\n+            let path = self.move_data().rev_lookup.find(location);\n+\n+            self.elaborate_drop(&DropCtxt {\n+                span: terminator.span,\n+                scope: terminator.scope,\n+                is_cleanup: data.is_cleanup,\n+                init_data: &init_data,\n+                lvalue: location,\n+                path: path,\n+                succ: target,\n+                unwind: unwind\n+            }, bb);\n+            on_all_children_bits(self.tcx(), self.mir(), self.move_data(), path, |child| {\n+                self.set_drop_flag(Location { block: target, index: 0 },\n+                                   child, DropFlagState::Live);\n+                if let Some(unwind) = unwind {\n+                    self.set_drop_flag(Location { block: unwind, index: 0 },\n+                                       child, DropFlagState::Live);\n+                }\n+            });\n+        }\n+\n+        self.patch.add_assign(Location { block: target, index: 0 },\n+                              location.clone(), Rvalue::Use(value.clone()));\n+        if let Some(unwind) = unwind {\n+            self.patch.add_assign(Location { block: unwind, index: 0 },\n+                                  location.clone(), Rvalue::Use(value.clone()));\n+        }\n+    }\n+\n+    /// This elaborates a single drop instruction, located at `bb`, and\n+    /// patches over it.\n+    ///\n+    /// The elaborated drop checks the drop flags to only drop what\n+    /// is initialized.\n+    ///\n+    /// In addition, the relevant drop flags also need to be cleared\n+    /// to avoid double-drops. However, in the middle of a complex\n+    /// drop, one must avoid clearing some of the flags before they\n+    /// are read, as that would cause a memory leak.\n+    ///\n+    /// In particular, when dropping an ADT, multiple fields may be\n+    /// joined together under the `rest` subpath. They are all controlled\n+    /// by the primary drop flag, but only the last rest-field dropped\n+    /// should clear it (and it must also not clear anything else).\n+    ///\n+    /// FIXME: I think we should just control the flags externally\n+    /// and then we do not need this machinery.\n+    fn elaborate_drop<'a>(&mut self, c: &DropCtxt<'a, 'tcx>, bb: BasicBlock) {\n+        debug!(\"elaborate_drop({:?})\", c);\n+\n+        let mut some_live = false;\n+        let mut some_dead = false;\n+        let mut children_count = 0;\n+        on_all_children_bits(\n+            self.tcx(), self.mir(), self.move_data(),\n+            c.path, |child| {\n+                if self.path_needs_drop(child) {\n+                    let (live, dead) = c.init_data.state(child);\n+                    debug!(\"elaborate_drop: state({:?}) = {:?}\",\n+                           child, (live, dead));\n+                    some_live |= live;\n+                    some_dead |= dead;\n+                    children_count += 1;\n+                }\n+            });\n+\n+        debug!(\"elaborate_drop({:?}): live - {:?}\", c,\n+               (some_live, some_dead));\n+        match (some_live, some_dead) {\n+            (false, false) | (false, true) => {\n+                // dead drop - patch it out\n+                self.patch.patch_terminator(bb, TerminatorKind::Goto {\n+                    target: c.succ\n+                });\n+            }\n+            (true, false) => {\n+                // static drop - just set the flag\n+                self.patch.patch_terminator(bb, TerminatorKind::Drop {\n+                    location: c.lvalue.clone(),\n+                    target: c.succ,\n+                    unwind: c.unwind\n+                });\n+                self.drop_flags_for_drop(c, bb);\n+            }\n+            (true, true) => {\n+                // dynamic drop\n+                let drop_bb = if children_count == 1 || self.must_complete_drop(c) {\n+                    self.conditional_drop(c)\n+                } else {\n+                    self.open_drop(c)\n+                };\n+                self.patch.patch_terminator(bb, TerminatorKind::Goto {\n+                    target: drop_bb\n+                });\n+            }\n+        }\n+    }\n+\n+    /// Return the lvalue and move path for each field of `variant`,\n+    /// (the move path is `None` if the field is a rest field).\n+    fn move_paths_for_fields(&self,\n+                             base_lv: &Lvalue<'tcx>,\n+                             variant_path: MovePathIndex,\n+                             variant: ty::VariantDef<'tcx>,\n+                             substs: &'tcx Substs<'tcx>)\n+                             -> Vec<(Lvalue<'tcx>, Option<MovePathIndex>)>\n+    {\n+        let move_paths = &self.move_data().move_paths;\n+        variant.fields.iter().enumerate().map(|(i, f)| {\n+            let subpath =\n+                super::move_path_children_matching(move_paths, variant_path, |p| {\n+                    match p {\n+                        &Projection {\n+                            elem: ProjectionElem::Field(idx, _), ..\n+                        } => idx.index() == i,\n+                        _ => false\n+                    }\n+                });\n+\n+            let field_ty =\n+                self.tcx().normalize_associated_type_in_env(\n+                    &f.ty(self.tcx(), substs),\n+                    &self.param_env\n+                );\n+            (base_lv.clone().field(Field::new(i), field_ty), subpath)\n+        }).collect()\n+    }\n+\n+    /// Create one-half of the drop ladder for a list of fields, and return\n+    /// the list of steps in it in reverse order.\n+    ///\n+    /// `unwind_ladder` is such a list of steps in reverse order,\n+    /// which is called instead of the next step if the drop unwinds\n+    /// (the first field is never reached). If it is `None`, all\n+    /// unwind targets are left blank.\n+    fn drop_halfladder<'a>(&mut self,\n+                           c: &DropCtxt<'a, 'tcx>,\n+                           unwind_ladder: Option<Vec<BasicBlock>>,\n+                           succ: BasicBlock,\n+                           fields: &[(Lvalue<'tcx>, Option<MovePathIndex>)],\n+                           is_cleanup: bool)\n+                           -> Vec<BasicBlock>\n+    {\n+        let mut succ = succ;\n+        let mut unwind_succ = if is_cleanup {\n+            None\n+        } else {\n+            c.unwind\n+        };\n+        let mut update_drop_flag = true;\n+\n+        fields.iter().rev().enumerate().map(|(i, &(ref lv, path))| {\n+            let drop_block = match path {\n+                Some(path) => {\n+                    debug!(\"drop_ladder: for std field {} ({:?})\", i, lv);\n+\n+                    self.elaborated_drop_block(&DropCtxt {\n+                        span: c.span,\n+                        scope: c.scope,\n+                        is_cleanup: is_cleanup,\n+                        init_data: c.init_data,\n+                        lvalue: lv,\n+                        path: path,\n+                        succ: succ,\n+                        unwind: unwind_succ,\n+                    })\n+                }\n+                None => {\n+                    debug!(\"drop_ladder: for rest field {} ({:?})\", i, lv);\n+\n+                    let blk = self.complete_drop(&DropCtxt {\n+                        span: c.span,\n+                        scope: c.scope,\n+                        is_cleanup: is_cleanup,\n+                        init_data: c.init_data,\n+                        lvalue: lv,\n+                        path: c.path,\n+                        succ: succ,\n+                        unwind: unwind_succ,\n+                    }, update_drop_flag);\n+\n+                    // the drop flag has been updated - updating\n+                    // it again would clobber it.\n+                    update_drop_flag = false;\n+\n+                    blk\n+                }\n+            };\n+\n+            succ = drop_block;\n+            unwind_succ = unwind_ladder.as_ref().map(|p| p[i]);\n+\n+            drop_block\n+        }).collect()\n+    }\n+\n+    /// Create a full drop ladder, consisting of 2 connected half-drop-ladders\n+    ///\n+    /// For example, with 3 fields, the drop ladder is\n+    ///\n+    /// .d0:\n+    ///     ELAB(drop location.0 [target=.d1, unwind=.c1])\n+    /// .d1:\n+    ///     ELAB(drop location.1 [target=.d2, unwind=.c2])\n+    /// .d2:\n+    ///     ELAB(drop location.2 [target=`c.succ`, unwind=`c.unwind`])\n+    /// .c1:\n+    ///     ELAB(drop location.1 [target=.c2])\n+    /// .c2:\n+    ///     ELAB(drop location.2 [target=`c.unwind])\n+    fn drop_ladder<'a>(&mut self,\n+                       c: &DropCtxt<'a, 'tcx>,\n+                       fields: &[(Lvalue<'tcx>, Option<MovePathIndex>)])\n+                       -> BasicBlock\n+    {\n+        debug!(\"drop_ladder({:?}, {:?})\", c, fields);\n+        let unwind_ladder = if c.is_cleanup {\n+            None\n+        } else {\n+            Some(self.drop_halfladder(c, None, c.unwind.unwrap(), &fields, true))\n+        };\n+\n+        self.drop_halfladder(c, unwind_ladder, c.succ, fields, c.is_cleanup)\n+            .last().cloned().unwrap_or(c.succ)\n+    }\n+\n+    fn open_drop_for_tuple<'a>(&mut self, c: &DropCtxt<'a, 'tcx>, tys: &[Ty<'tcx>])\n+                               -> BasicBlock\n+    {\n+        debug!(\"open_drop_for_tuple({:?}, {:?})\", c, tys);\n+\n+        let fields: Vec<_> = tys.iter().enumerate().map(|(i, &ty)| {\n+            (c.lvalue.clone().field(Field::new(i), ty),\n+             super::move_path_children_matching(\n+                 &self.move_data().move_paths, c.path, |proj| match proj {\n+                     &Projection {\n+                         elem: ProjectionElem::Field(f, _), ..\n+                     } => f.index() == i,\n+                     _ => false\n+                 }\n+            ))\n+        }).collect();\n+\n+        self.drop_ladder(c, &fields)\n+    }\n+\n+    fn open_drop_for_box<'a>(&mut self, c: &DropCtxt<'a, 'tcx>, ty: Ty<'tcx>)\n+                             -> BasicBlock\n+    {\n+        debug!(\"open_drop_for_box({:?}, {:?})\", c, ty);\n+\n+        let interior_path = super::move_path_children_matching(\n+            &self.move_data().move_paths, c.path, |proj| match proj {\n+                &Projection { elem: ProjectionElem::Deref, .. } => true,\n+                _ => false\n+            }).unwrap();\n+\n+        let interior = c.lvalue.clone().deref();\n+        let inner_c = DropCtxt {\n+            lvalue: &interior,\n+            unwind: c.unwind.map(|u| {\n+                self.box_free_block(c, ty, u, true)\n+            }),\n+            succ: self.box_free_block(c, ty, c.succ, c.is_cleanup),\n+            path: interior_path,\n+            ..*c\n+        };\n+\n+        self.elaborated_drop_block(&inner_c)\n+    }\n+\n+    fn open_drop_for_variant<'a>(&mut self,\n+                                 c: &DropCtxt<'a, 'tcx>,\n+                                 drop_block: &mut Option<BasicBlock>,\n+                                 adt: ty::AdtDef<'tcx>,\n+                                 substs: &'tcx Substs<'tcx>,\n+                                 variant_index: usize)\n+                                 -> BasicBlock\n+    {\n+        let move_paths = &self.move_data().move_paths;\n+\n+        let subpath = super::move_path_children_matching(\n+            move_paths, c.path, |proj| match proj {\n+                &Projection {\n+                    elem: ProjectionElem::Downcast(_, idx), ..\n+                } => idx == variant_index,\n+                _ => false\n+            });\n+\n+        if let Some(variant_path) = subpath {\n+            let base_lv = c.lvalue.clone().elem(\n+                ProjectionElem::Downcast(adt, variant_index)\n+            );\n+            let fields = self.move_paths_for_fields(\n+                &base_lv,\n+                variant_path,\n+                &adt.variants[variant_index],\n+                substs);\n+            self.drop_ladder(c, &fields)\n+        } else {\n+            // variant not found - drop the entire enum\n+            if let None = *drop_block {\n+                *drop_block = Some(self.complete_drop(c, true));\n+            }\n+            return drop_block.unwrap();\n+        }\n+    }\n+\n+    fn open_drop_for_adt<'a>(&mut self, c: &DropCtxt<'a, 'tcx>,\n+                             adt: ty::AdtDef<'tcx>, substs: &'tcx Substs<'tcx>)\n+                             -> BasicBlock {\n+        debug!(\"open_drop_for_adt({:?}, {:?}, {:?})\", c, adt, substs);\n+\n+        let mut drop_block = None;\n+\n+        match adt.variants.len() {\n+            1 => {\n+                let fields = self.move_paths_for_fields(\n+                    c.lvalue,\n+                    c.path,\n+                    &adt.variants[0],\n+                    substs\n+                );\n+                self.drop_ladder(c, &fields)\n+            }\n+            _ => {\n+                let variant_drops : Vec<BasicBlock> =\n+                    (0..adt.variants.len()).map(|i| {\n+                        self.open_drop_for_variant(c, &mut drop_block,\n+                                                   adt, substs, i)\n+                    }).collect();\n+\n+                // If there are multiple variants, then if something\n+                // is present within the enum the discriminant, tracked\n+                // by the rest path, must be initialized.\n+                //\n+                // Additionally, we do not want to switch on the\n+                // discriminant after it is free-ed, because that\n+                // way lies only trouble.\n+\n+                let switch_block = self.new_block(\n+                    c, c.is_cleanup, TerminatorKind::Switch {\n+                        discr: c.lvalue.clone(),\n+                        adt_def: adt,\n+                        targets: variant_drops\n+                    });\n+\n+                self.drop_flag_test_block(c, c.is_cleanup, switch_block)\n+            }\n+        }\n+    }\n+\n+    /// The slow-path - create an \"open\", elaborated drop for a type\n+    /// which is moved-out-of only partially, and patch `bb` to a jump\n+    /// to it. This must not be called on ADTs with a destructor,\n+    /// as these can't be moved-out-of, except for `Box<T>`, which is\n+    /// special-cased.\n+    ///\n+    /// This creates a \"drop ladder\" that drops the needed fields of the\n+    /// ADT, both in the success case or if one of the destructors fail.\n+    fn open_drop<'a>(&mut self, c: &DropCtxt<'a, 'tcx>) -> BasicBlock {\n+        let ty = self.mir().lvalue_ty(self.tcx(), c.lvalue).to_ty(self.tcx());\n+        match ty.sty {\n+            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+                self.open_drop_for_adt(c, def, substs)\n+            }\n+            ty::TyTuple(tys) | ty::TyClosure(_, ty::ClosureSubsts {\n+                upvar_tys: tys, ..\n+            }) => {\n+                self.open_drop_for_tuple(c, tys)\n+            }\n+            ty::TyBox(ty) => {\n+                self.open_drop_for_box(c, ty)\n+            }\n+            _ => bug!(\"open drop from non-ADT `{:?}`\", ty)\n+        }\n+    }\n+\n+    /// Return a basic block that drop an lvalue using the context\n+    /// and path in `c`. If `update_drop_flag` is true, also\n+    /// clear `c`.\n+    ///\n+    /// if FLAG(c.path)\n+    ///     if(update_drop_flag) FLAG(c.path) = false\n+    ///     drop(c.lv)\n+    fn complete_drop<'a>(\n+        &mut self,\n+        c: &DropCtxt<'a, 'tcx>,\n+        update_drop_flag: bool)\n+        -> BasicBlock\n+    {\n+        debug!(\"complete_drop({:?},{:?})\", c, update_drop_flag);\n+\n+        let drop_block = self.drop_block(c);\n+        if update_drop_flag {\n+            self.set_drop_flag(\n+                Location { block: drop_block, index: 0 },\n+                c.path,\n+                DropFlagState::Dead\n+            );\n+        }\n+\n+        self.drop_flag_test_block(c, c.is_cleanup, drop_block)\n+    }\n+\n+    /// Create a simple conditional drop.\n+    ///\n+    /// if FLAG(c.lv)\n+    ///     FLAGS(c.lv) = false\n+    ///     drop(c.lv)\n+    fn conditional_drop<'a>(&mut self, c: &DropCtxt<'a, 'tcx>)\n+                            -> BasicBlock\n+    {\n+        debug!(\"conditional_drop({:?})\", c);\n+        let drop_bb = self.drop_block(c);\n+        self.drop_flags_for_drop(c, drop_bb);\n+\n+        self.drop_flag_test_block(c, c.is_cleanup, drop_bb)\n+    }\n+\n+    fn new_block<'a>(&mut self,\n+                     c: &DropCtxt<'a, 'tcx>,\n+                     is_cleanup: bool,\n+                     k: TerminatorKind<'tcx>)\n+                     -> BasicBlock\n+    {\n+        self.patch.new_block(BasicBlockData {\n+            statements: vec![],\n+            terminator: Some(Terminator {\n+                scope: c.scope, span: c.span, kind: k\n+            }),\n+            is_cleanup: is_cleanup\n+        })\n+    }\n+\n+    fn elaborated_drop_block<'a>(&mut self, c: &DropCtxt<'a, 'tcx>) -> BasicBlock {\n+        debug!(\"elaborated_drop_block({:?})\", c);\n+        let blk = self.drop_block(c);\n+        self.elaborate_drop(c, blk);\n+        blk\n+    }\n+\n+    fn drop_flag_test_block<'a>(&mut self,\n+                                c: &DropCtxt<'a, 'tcx>,\n+                                is_cleanup: bool,\n+                                on_set: BasicBlock)\n+                                -> BasicBlock\n+    {\n+        let (maybe_live, maybe_dead) = c.init_data.state(c.path);\n+        debug!(\"drop_flag_test_block({:?},{:?},{:?}) - {:?}\",\n+               c, is_cleanup, on_set, (maybe_live, maybe_dead));\n+\n+        match (maybe_live, maybe_dead) {\n+            (false, _) => c.succ,\n+            (true, false) => on_set,\n+            (true, true) => {\n+                let flag = self.drop_flag(c.path).unwrap();\n+                self.new_block(c, is_cleanup, TerminatorKind::If {\n+                    cond: Operand::Consume(flag),\n+                    targets: (on_set, c.succ)\n+                })\n+            }\n+        }\n+    }\n+\n+    fn drop_block<'a>(&mut self, c: &DropCtxt<'a, 'tcx>) -> BasicBlock {\n+        self.new_block(c, c.is_cleanup, TerminatorKind::Drop {\n+            location: c.lvalue.clone(),\n+            target: c.succ,\n+            unwind: c.unwind\n+        })\n+    }\n+\n+    fn jump_to_resume_block<'a>(&mut self, scope: ScopeId, span: Span) -> BasicBlock {\n+        let resume_block = self.patch.resume_block();\n+        self.patch.new_block(BasicBlockData {\n+            statements: vec![],\n+            terminator: Some(Terminator {\n+                scope: scope, span: span, kind: TerminatorKind::Goto {\n+                    target: resume_block\n+                }\n+            }),\n+            is_cleanup: true\n+       })\n+    }\n+\n+    fn box_free_block<'a>(\n+        &mut self,\n+        c: &DropCtxt<'a, 'tcx>,\n+        ty: Ty<'tcx>,\n+        target: BasicBlock,\n+        is_cleanup: bool\n+    ) -> BasicBlock {\n+        let block = self.unelaborated_free_block(c, ty, target, is_cleanup);\n+        self.drop_flag_test_block(c, is_cleanup, block)\n+    }\n+\n+    fn unelaborated_free_block<'a>(\n+        &mut self,\n+        c: &DropCtxt<'a, 'tcx>,\n+        ty: Ty<'tcx>,\n+        target: BasicBlock,\n+        is_cleanup: bool\n+    ) -> BasicBlock {\n+        let mut statements = vec![];\n+        if let Some(&flag) = self.drop_flags.get(&c.path) {\n+            statements.push(Statement {\n+                span: c.span,\n+                scope: c.scope,\n+                kind: StatementKind::Assign(\n+                    Lvalue::Temp(flag),\n+                    self.constant_bool(c.span, false)\n+                )\n+            });\n+        }\n+\n+        let tcx = self.tcx();\n+        let unit_temp = Lvalue::Temp(self.patch.new_temp(tcx.mk_nil()));\n+        let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n+            .unwrap_or_else(|e| tcx.sess.fatal(&e));\n+        let substs = tcx.mk_substs(Substs::new(\n+            VecPerParamSpace::new(vec![], vec![], vec![ty]),\n+            VecPerParamSpace::new(vec![], vec![], vec![])\n+        ));\n+        let fty = tcx.lookup_item_type(free_func).ty.subst(tcx, substs);\n+\n+        self.patch.new_block(BasicBlockData {\n+            statements: statements,\n+            terminator: Some(Terminator {\n+                scope: c.scope, span: c.span, kind: TerminatorKind::Call {\n+                    func: Operand::Constant(Constant {\n+                        span: c.span,\n+                        ty: fty,\n+                        literal: Literal::Item {\n+                            def_id: free_func,\n+                            substs: substs\n+                        }\n+                    }),\n+                    args: vec![Operand::Consume(c.lvalue.clone())],\n+                    destination: Some((unit_temp, target)),\n+                    cleanup: None\n+                }\n+            }),\n+            is_cleanup: is_cleanup\n+        })\n+    }\n+\n+    fn must_complete_drop<'a>(&self, c: &DropCtxt<'a, 'tcx>) -> bool {\n+        // if we have a destuctor, we must *not* split the drop.\n+\n+        // dataflow can create unneeded children in some cases\n+        // - be sure to ignore them.\n+\n+        let ty = self.mir().lvalue_ty(self.tcx(), c.lvalue).to_ty(self.tcx());\n+\n+        match ty.sty {\n+            ty::TyStruct(def, _) | ty::TyEnum(def, _) => {\n+                if def.has_dtor() {\n+                    self.tcx().sess.span_warn(\n+                        c.span,\n+                        &format!(\"dataflow bug??? moving out of type with dtor {:?}\",\n+                                 c));\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+            _ => false\n+        }\n+    }\n+\n+    fn constant_bool(&self, span: Span, val: bool) -> Rvalue<'tcx> {\n+        Rvalue::Use(Operand::Constant(Constant {\n+            span: span,\n+            ty: self.tcx().types.bool,\n+            literal: Literal::Value { value: ConstVal::Bool(val) }\n+        }))\n+    }\n+\n+    fn set_drop_flag(&mut self, loc: Location, path: MovePathIndex, val: DropFlagState) {\n+        if let Some(&flag) = self.drop_flags.get(&path) {\n+            let span = self.patch.context_for_location(self.mir(), loc).0;\n+            let val = self.constant_bool(span, val.value());\n+            self.patch.add_assign(loc, Lvalue::Temp(flag), val);\n+        }\n+    }\n+\n+    fn drop_flags_on_init(&mut self) {\n+        let loc = Location { block: START_BLOCK, index: 0 };\n+        let span = self.patch.context_for_location(self.mir(), loc).0;\n+        let false_ = self.constant_bool(span, false);\n+        for flag in self.drop_flags.values() {\n+            self.patch.add_assign(loc, Lvalue::Temp(*flag), false_.clone());\n+        }\n+    }\n+\n+    fn drop_flags_for_fn_rets(&mut self) {\n+        for bb in self.mir().all_basic_blocks() {\n+            let data = self.mir().basic_block_data(bb);\n+            if let TerminatorKind::Call {\n+                destination: Some((ref lv, tgt)), cleanup: Some(_), ..\n+            } = data.terminator().kind {\n+                assert!(!self.patch.is_patched(bb));\n+\n+                let loc = Location { block: tgt, index: 0 };\n+                let path = self.move_data().rev_lookup.find(lv);\n+                on_all_children_bits(\n+                    self.tcx(), self.mir(), self.move_data(), path,\n+                    |child| self.set_drop_flag(loc, child, DropFlagState::Live)\n+                );\n+            }\n+        }\n+    }\n+\n+    fn drop_flags_for_args(&mut self) {\n+        let loc = Location { block: START_BLOCK, index: 0 };\n+        super::drop_flag_effects_for_function_entry(\n+            self.tcx(), self.mir(), self.move_data(), |path, ds| {\n+                self.set_drop_flag(loc, path, ds);\n+            }\n+        )\n+    }\n+\n+    fn drop_flags_for_locs(&mut self) {\n+        // We intentionally iterate only over the *old* basic blocks.\n+        //\n+        // Basic blocks created by drop elaboration update their\n+        // drop flags by themselves, to avoid the drop flags being\n+        // clobbered before they are read.\n+\n+        for bb in self.mir().all_basic_blocks() {\n+            let data = self.mir().basic_block_data(bb);\n+            debug!(\"drop_flags_for_locs({:?})\", data);\n+            for i in 0..(data.statements.len()+1) {\n+                debug!(\"drop_flag_for_locs: stmt {}\", i);\n+                let mut allow_initializations = true;\n+                if i == data.statements.len() {\n+                    match data.terminator().kind {\n+                        TerminatorKind::Drop { .. } => {\n+                            // drop elaboration should handle that by itself\n+                            continue\n+                        }\n+                        TerminatorKind::DropAndReplace { .. } => {\n+                            // this contains the consume of the source and\n+                            // the initialization of the destination. We\n+                            // only want the latter\n+                            assert!(self.patch.is_patched(bb));\n+                            allow_initializations = false;\n+                        }\n+                        _ => {\n+                            assert!(!self.patch.is_patched(bb));\n+                        }\n+                    }\n+                }\n+                let loc = Location { block: bb, index: i };\n+                super::drop_flag_effects_for_location(\n+                    self.tcx(), self.mir(), self.move_data(), loc, |path, ds| {\n+                        if ds == DropFlagState::Dead || allow_initializations {\n+                            self.set_drop_flag(loc, path, ds)\n+                        }\n+                    }\n+                )\n+            }\n+\n+            // There may be a critical edge after this call,\n+            // so mark the return as initialized *before* the\n+            // call.\n+            if let TerminatorKind::Call {\n+                destination: Some((ref lv, _)), cleanup: None, ..\n+            } = data.terminator().kind {\n+                assert!(!self.patch.is_patched(bb));\n+\n+                let loc = Location { block: bb, index: data.statements.len() };\n+                let path = self.move_data().rev_lookup.find(lv);\n+                on_all_children_bits(\n+                    self.tcx(), self.mir(), self.move_data(), path,\n+                    |child| self.set_drop_flag(loc, child, DropFlagState::Live)\n+                );\n+            }\n+        }\n+    }\n+\n+    fn drop_flags_for_drop<'a>(&mut self,\n+                               c: &DropCtxt<'a, 'tcx>,\n+                               bb: BasicBlock)\n+    {\n+        let loc = self.patch.terminator_loc(self.mir(), bb);\n+        on_all_children_bits(\n+            self.tcx(), self.mir(), self.move_data(), c.path,\n+            |child| self.set_drop_flag(loc, child, DropFlagState::Dead)\n+        );\n+    }\n+}"}, {"sha": "7e1a196629f54dc258a7f235b8da03ecf6b14504", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a091cfd4f3be8677481a3a502bd96bdebd0de1bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a091cfd4f3be8677481a3a502bd96bdebd0de1bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=a091cfd4f3be8677481a3a502bd96bdebd0de1bb", "patch": "@@ -24,8 +24,10 @@ use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n \n mod abs_domain;\n+pub mod elaborate_drops;\n mod dataflow;\n mod gather_moves;\n+mod patch;\n // mod graphviz;\n \n use self::dataflow::{BitDenotation};\n@@ -34,7 +36,7 @@ use self::dataflow::{Dataflow, DataflowAnalysis, DataflowResults};\n use self::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use self::dataflow::{DefinitelyInitializedLvals};\n use self::gather_moves::{MoveData, MovePathIndex, Location};\n-use self::gather_moves::{MovePathContent};\n+use self::gather_moves::{MovePathContent, MovePathData};\n \n fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<P<MetaItem>> {\n     for attr in attrs {\n@@ -202,6 +204,37 @@ enum DropFlagState {\n     Absent, // i.e. deinitialized or \"moved\"\n }\n \n+impl DropFlagState {\n+    fn value(self) -> bool {\n+        match self {\n+            DropFlagState::Live => true,\n+            DropFlagState::Dead => false\n+        }\n+    }\n+}\n+\n+fn move_path_children_matching<'tcx, F>(move_paths: &MovePathData<'tcx>,\n+                                        path: MovePathIndex,\n+                                        mut cond: F)\n+                                        -> Option<MovePathIndex>\n+    where F: FnMut(&repr::LvalueProjection<'tcx>) -> bool\n+{\n+    let mut next_child = move_paths[path].first_child;\n+    while let Some(child_index) = next_child {\n+        match move_paths[child_index].content {\n+            MovePathContent::Lvalue(repr::Lvalue::Projection(ref proj)) => {\n+                if cond(proj) {\n+                    return Some(child_index)\n+                }\n+            }\n+            _ => {}\n+        }\n+        next_child = move_paths[child_index].next_sibling;\n+    }\n+\n+    None\n+}\n+\n fn on_all_children_bits<'a, 'tcx, F>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &Mir<'tcx>,"}, {"sha": "b390c19af1a5beadccbd90556e37f8d25281aa1b", "filename": "src/librustc_borrowck/borrowck/mir/patch.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/a091cfd4f3be8677481a3a502bd96bdebd0de1bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a091cfd4f3be8677481a3a502bd96bdebd0de1bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs?ref=a091cfd4f3be8677481a3a502bd96bdebd0de1bb", "patch": "@@ -0,0 +1,184 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::gather_moves::Location;\n+use rustc::ty::Ty;\n+use rustc::mir::repr::*;\n+use syntax::codemap::Span;\n+\n+use std::iter;\n+use std::u32;\n+\n+/// This struct represents a patch to MIR, which can add\n+/// new statements and basic blocks and patch over block\n+/// terminators.\n+pub struct MirPatch<'tcx> {\n+    patch_map: Vec<Option<TerminatorKind<'tcx>>>,\n+    new_blocks: Vec<BasicBlockData<'tcx>>,\n+    new_statements: Vec<(Location, StatementKind<'tcx>)>,\n+    new_temps: Vec<TempDecl<'tcx>>,\n+    resume_block: BasicBlock,\n+    next_temp: u32,\n+}\n+\n+impl<'tcx> MirPatch<'tcx> {\n+    pub fn new(mir: &Mir<'tcx>) -> Self {\n+        let mut result = MirPatch {\n+            patch_map: iter::repeat(None)\n+                .take(mir.basic_blocks.len()).collect(),\n+            new_blocks: vec![],\n+            new_temps: vec![],\n+            new_statements: vec![],\n+            next_temp: mir.temp_decls.len() as u32,\n+            resume_block: START_BLOCK\n+        };\n+\n+        // make sure the MIR we create has a resume block. It is\n+        // completely legal to convert jumps to the resume block\n+        // to jumps to None, but we occasionally have to add\n+        // instructions just before that.\n+\n+        let mut resume_block = None;\n+        let mut resume_stmt_block = None;\n+        for block in mir.all_basic_blocks() {\n+            let data = mir.basic_block_data(block);\n+            if let TerminatorKind::Resume = data.terminator().kind {\n+                if data.statements.len() > 0 {\n+                    resume_stmt_block = Some(block);\n+                } else {\n+                    resume_block = Some(block);\n+                }\n+                break\n+            }\n+        }\n+        let resume_block = resume_block.unwrap_or_else(|| {\n+            result.new_block(BasicBlockData {\n+                statements: vec![],\n+                terminator: Some(Terminator {\n+                    span: mir.span,\n+                    scope: ScopeId::new(0),\n+                    kind: TerminatorKind::Resume\n+                }),\n+                is_cleanup: true\n+            })});\n+        result.resume_block = resume_block;\n+        if let Some(resume_stmt_block) = resume_stmt_block {\n+            result.patch_terminator(resume_stmt_block, TerminatorKind::Goto {\n+                target: resume_block\n+            });\n+        }\n+        result\n+    }\n+\n+    pub fn resume_block(&self) -> BasicBlock {\n+        self.resume_block\n+    }\n+\n+    pub fn is_patched(&self, bb: BasicBlock) -> bool {\n+        self.patch_map[bb.index()].is_some()\n+    }\n+\n+    pub fn terminator_loc(&self, mir: &Mir<'tcx>, bb: BasicBlock) -> Location {\n+        let offset = match bb.index().checked_sub(mir.basic_blocks.len()) {\n+            Some(index) => self.new_blocks[index].statements.len(),\n+            None => mir.basic_block_data(bb).statements.len()\n+        };\n+        Location {\n+            block: bb,\n+            index: offset\n+        }\n+    }\n+\n+    pub fn new_temp(&mut self, ty: Ty<'tcx>) -> u32 {\n+        let index = self.next_temp;\n+        assert!(self.next_temp < u32::MAX);\n+        self.next_temp += 1;\n+        self.new_temps.push(TempDecl { ty: ty });\n+        index\n+    }\n+\n+    pub fn new_block(&mut self, data: BasicBlockData<'tcx>) -> BasicBlock {\n+        let block = BasicBlock::new(self.patch_map.len());\n+        debug!(\"MirPatch: new_block: {:?}: {:?}\", block, data);\n+        self.new_blocks.push(data);\n+        self.patch_map.push(None);\n+        block\n+    }\n+\n+    pub fn patch_terminator(&mut self, block: BasicBlock, new: TerminatorKind<'tcx>) {\n+        assert!(self.patch_map[block.index()].is_none());\n+        debug!(\"MirPatch: patch_terminator({:?}, {:?})\", block, new);\n+        self.patch_map[block.index()] = Some(new);\n+    }\n+\n+    pub fn add_statement(&mut self, loc: Location, stmt: StatementKind<'tcx>) {\n+        debug!(\"MirPatch: add_statement({:?}, {:?})\", loc, stmt);\n+        self.new_statements.push((loc, stmt));\n+    }\n+\n+    pub fn add_assign(&mut self, loc: Location, lv: Lvalue<'tcx>, rv: Rvalue<'tcx>) {\n+        self.add_statement(loc, StatementKind::Assign(lv, rv));\n+    }\n+\n+    pub fn apply(self, mir: &mut Mir<'tcx>) {\n+        debug!(\"MirPatch: {:?} new temps, starting from index {}: {:?}\",\n+               self.new_temps.len(), mir.temp_decls.len(), self.new_temps);\n+        debug!(\"MirPatch: {} new blocks, starting from index {}\",\n+               self.new_blocks.len(), mir.basic_blocks.len());\n+        mir.basic_blocks.extend(self.new_blocks);\n+        mir.temp_decls.extend(self.new_temps);\n+        for (src, patch) in self.patch_map.into_iter().enumerate() {\n+            if let Some(patch) = patch {\n+                debug!(\"MirPatch: patching block {:?}\", src);\n+                mir.basic_blocks[src].terminator_mut().kind = patch;\n+            }\n+        }\n+\n+        let mut new_statements = self.new_statements;\n+        new_statements.sort_by(|u,v| u.0.cmp(&v.0));\n+\n+        let mut delta = 0;\n+        let mut last_bb = START_BLOCK;\n+        for (mut loc, stmt) in new_statements {\n+            if loc.block != last_bb {\n+                delta = 0;\n+                last_bb = loc.block;\n+            }\n+            debug!(\"MirPatch: adding statement {:?} at loc {:?}+{}\",\n+                   stmt, loc, delta);\n+            loc.index += delta;\n+            let (span, scope) = Self::context_for_index(\n+                mir.basic_block_data(loc.block), loc\n+            );\n+            mir.basic_block_data_mut(loc.block).statements.insert(\n+                loc.index, Statement {\n+                    span: span,\n+                    scope: scope,\n+                    kind: stmt\n+                });\n+            delta += 1;\n+        }\n+    }\n+\n+    pub fn context_for_index(data: &BasicBlockData, loc: Location) -> (Span, ScopeId) {\n+        match data.statements.get(loc.index) {\n+            Some(stmt) => (stmt.span, stmt.scope),\n+            None => (data.terminator().span, data.terminator().scope)\n+        }\n+    }\n+\n+    pub fn context_for_location(&self, mir: &Mir, loc: Location) -> (Span, ScopeId) {\n+        let data = match loc.block.index().checked_sub(mir.basic_blocks.len()) {\n+            Some(new) => &self.new_blocks[new],\n+            None => mir.basic_block_data(loc.block)\n+        };\n+        Self::context_for_index(data, loc)\n+    }\n+}"}, {"sha": "5acbb18a2ffee857e2e9cff38f2271115d4ccaf6", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a091cfd4f3be8677481a3a502bd96bdebd0de1bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a091cfd4f3be8677481a3a502bd96bdebd0de1bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=a091cfd4f3be8677481a3a502bd96bdebd0de1bb", "patch": "@@ -18,6 +18,8 @@ pub use self::bckerr_code::*;\n pub use self::AliasableViolationKind::*;\n pub use self::MovedValueUseKind::*;\n \n+pub use self::mir::elaborate_drops::ElaborateDrops;\n+\n use self::InteriorKind::*;\n \n use rustc::dep_graph::DepNode;"}, {"sha": "cc694c59245f7f0ee41788eeffd4cff5bd267152", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a091cfd4f3be8677481a3a502bd96bdebd0de1bb/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a091cfd4f3be8677481a3a502bd96bdebd0de1bb/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=a091cfd4f3be8677481a3a502bd96bdebd0de1bb", "patch": "@@ -39,7 +39,7 @@ extern crate core; // for NonZero\n \n pub use borrowck::check_crate;\n pub use borrowck::build_borrowck_dataflow_data_for_fn;\n-pub use borrowck::{AnalysisData, BorrowckCtxt};\n+pub use borrowck::{AnalysisData, BorrowckCtxt, ElaborateDrops};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used."}, {"sha": "bfad281702fd0bba9d2ee59394a4943b1543fe78", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a091cfd4f3be8677481a3a502bd96bdebd0de1bb/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a091cfd4f3be8677481a3a502bd96bdebd0de1bb/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=a091cfd4f3be8677481a3a502bd96bdebd0de1bb", "patch": "@@ -1033,6 +1033,10 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         passes.push_pass(box mir::transform::remove_dead_blocks::RemoveDeadBlocks);\n         passes.push_pass(box mir::transform::erase_regions::EraseRegions);\n         passes.push_pass(box mir::transform::break_cleanup_edges::BreakCleanupEdges);\n+        passes.push_pass(box borrowck::ElaborateDrops);\n+        passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n+        passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg);\n+        passes.push_pass(box mir::transform::break_cleanup_edges::BreakCleanupEdges);\n         passes.run_passes(tcx, &mut mir_map);\n     });\n "}, {"sha": "7bd9adcba9bd1eebd3ef3fceb2d73d1f3237860d", "filename": "src/test/run-fail/issue-30380.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a091cfd4f3be8677481a3a502bd96bdebd0de1bb/src%2Ftest%2Frun-fail%2Fissue-30380.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a091cfd4f3be8677481a3a502bd96bdebd0de1bb/src%2Ftest%2Frun-fail%2Fissue-30380.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-30380.rs?ref=a091cfd4f3be8677481a3a502bd96bdebd0de1bb", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that panics in destructors during assignment do not leave\n+// destroyed values lying around for other destructors to observe.\n+\n+// error-pattern:panicking destructors ftw!\n+\n+struct Observer<'a>(&'a mut FilledOnDrop);\n+\n+struct FilledOnDrop(u32);\n+impl Drop for FilledOnDrop {\n+    fn drop(&mut self) {\n+        if self.0 == 0 {\n+            // this is only set during the destructor - safe\n+            // code should not be able to observe this.\n+            self.0 = 0x1c1c1c1c;\n+            panic!(\"panicking destructors ftw!\");\n+        }\n+    }\n+}\n+\n+impl<'a> Drop for Observer<'a> {\n+    fn drop(&mut self) {\n+        assert_eq!(self.0 .0, 1);\n+    }\n+}\n+\n+fn foo(b: &mut Observer) {\n+    *b.0 = FilledOnDrop(1);\n+}\n+\n+fn main() {\n+    let mut bomb = FilledOnDrop(0);\n+    let mut observer = Observer(&mut bomb);\n+    foo(&mut observer);\n+}"}, {"sha": "48e7b7ca576961312afe2d1ae8e33843e2d3dd0b", "filename": "src/test/run-pass/dynamic-drop.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a091cfd4f3be8677481a3a502bd96bdebd0de1bb/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a091cfd4f3be8677481a3a502bd96bdebd0de1bb/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs?ref=a091cfd4f3be8677481a3a502bd96bdebd0de1bb", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::RefCell;\n+\n+struct Allocator {\n+    data: RefCell<Vec<bool>>,\n+}\n+\n+impl Drop for Allocator {\n+    fn drop(&mut self) {\n+        let data = self.data.borrow();\n+        if data.iter().any(|d| *d) {\n+            panic!(\"missing free: {:?}\", data);\n+        }\n+    }\n+}\n+\n+impl Allocator {\n+    fn new() -> Self { Allocator { data: RefCell::new(vec![]) } }\n+    fn alloc(&self) -> Ptr {\n+        let mut data = self.data.borrow_mut();\n+        let addr = data.len();\n+        data.push(true);\n+        Ptr(addr, self)\n+    }\n+}\n+\n+struct Ptr<'a>(usize, &'a Allocator);\n+impl<'a> Drop for Ptr<'a> {\n+    fn drop(&mut self) {\n+        match self.1.data.borrow_mut()[self.0] {\n+            false => {\n+                panic!(\"double free at index {:?}\", self.0)\n+            }\n+            ref mut d => *d = false\n+        }\n+    }\n+}\n+\n+fn dynamic_init(a: &Allocator, c: bool) {\n+    let _x;\n+    if c {\n+        _x = Some(a.alloc());\n+    }\n+}\n+\n+fn dynamic_drop(a: &Allocator, c: bool) -> Option<Ptr> {\n+    let x = a.alloc();\n+    if c {\n+        Some(x)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn assignment2(a: &Allocator, c0: bool, c1: bool) {\n+    let mut _v = a.alloc();\n+    let mut _w = a.alloc();\n+    if c0 {\n+        drop(_v);\n+    }\n+    _v = _w;\n+    if c1 {\n+        _w = a.alloc();\n+    }\n+}\n+\n+fn assignment1(a: &Allocator, c0: bool) {\n+    let mut _v = a.alloc();\n+    let mut _w = a.alloc();\n+    if c0 {\n+        drop(_v);\n+    }\n+    _v = _w;\n+}\n+\n+\n+fn main() {\n+    let a = Allocator::new();\n+    dynamic_init(&a, false);\n+    dynamic_init(&a, true);\n+    dynamic_drop(&a, false);\n+    dynamic_drop(&a, true);\n+\n+    assignment2(&a, false, false);\n+    assignment2(&a, false, true);\n+    assignment2(&a, true, false);\n+    assignment2(&a, true, true);\n+\n+    assignment1(&a, false);\n+    assignment1(&a, true);\n+}"}]}