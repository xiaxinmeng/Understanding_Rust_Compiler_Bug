{"sha": "e3293b84af91d37ba2cd1a5f6ed246b23590e5d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMjkzYjg0YWY5MWQzN2JhMmNkMWE1ZjZlZDI0NmIyMzU5MGU1ZDM=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2016-09-27T00:03:35Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2016-09-27T00:03:35Z"}, "message": "Address review comments", "tree": {"sha": "bdd4b9ead2b2608a1715411c615dae9e0e029ef1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdd4b9ead2b2608a1715411c615dae9e0e029ef1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3293b84af91d37ba2cd1a5f6ed246b23590e5d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3293b84af91d37ba2cd1a5f6ed246b23590e5d3", "html_url": "https://github.com/rust-lang/rust/commit/e3293b84af91d37ba2cd1a5f6ed246b23590e5d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3293b84af91d37ba2cd1a5f6ed246b23590e5d3/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0fa2048a8a7695ded7e932a6f7acf4182f9ef73", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0fa2048a8a7695ded7e932a6f7acf4182f9ef73", "html_url": "https://github.com/rust-lang/rust/commit/a0fa2048a8a7695ded7e932a6f7acf4182f9ef73"}], "stats": {"total": 102, "additions": 51, "deletions": 51}, "files": [{"sha": "34b46ed66a24636d9b6fe4543c213affe01f8c80", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e3293b84af91d37ba2cd1a5f6ed246b23590e5d3/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3293b84af91d37ba2cd1a5f6ed246b23590e5d3/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=e3293b84af91d37ba2cd1a5f6ed246b23590e5d3", "patch": "@@ -222,8 +222,10 @@ impl<'tcx> Mir<'tcx> {\n     /// Returns an iterator over all user-defined variables and compiler-generated temporaries (all\n     /// locals that are neither arguments nor the return pointer).\n     #[inline]\n-    pub fn vars_and_temps_iter<'a>(&'a self) -> impl Iterator<Item=Local> + 'a {\n-        (self.arg_count+1..self.local_decls.len()).map(Local::new)\n+    pub fn vars_and_temps_iter(&self) -> impl Iterator<Item=Local> {\n+        let arg_count = self.arg_count;\n+        let local_count = self.local_decls.len();\n+        (arg_count+1..local_count).map(Local::new)\n     }\n \n     /// Changes a statement to a nop. This is both faster than deleting instructions and avoids"}, {"sha": "fe71023ea34dea34dc16af6908eaee6cc12f5da6", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 47, "deletions": 49, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/e3293b84af91d37ba2cd1a5f6ed246b23590e5d3/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3293b84af91d37ba2cd1a5f6ed246b23590e5d3/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=e3293b84af91d37ba2cd1a5f6ed246b23590e5d3", "patch": "@@ -360,59 +360,57 @@ fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n         let arg_decl = &mir.local_decls[local];\n         let arg_ty = bcx.monomorphize(&arg_decl.ty);\n \n-        if let Some(spread_local) = mir.spread_arg {\n-            if local == spread_local {\n-                // This argument (e.g. the last argument in the \"rust-call\" ABI)\n-                // is a tuple that was spread at the ABI level and now we have\n-                // to reconstruct it into a tuple local variable, from multiple\n-                // individual LLVM function arguments.\n-\n-                let tupled_arg_tys = match arg_ty.sty {\n-                    ty::TyTuple(ref tys) => tys,\n-                    _ => bug!(\"spread argument isn't a tuple?!\")\n-                };\n+        if Some(local) == mir.spread_arg {\n+            // This argument (e.g. the last argument in the \"rust-call\" ABI)\n+            // is a tuple that was spread at the ABI level and now we have\n+            // to reconstruct it into a tuple local variable, from multiple\n+            // individual LLVM function arguments.\n+\n+            let tupled_arg_tys = match arg_ty.sty {\n+                ty::TyTuple(ref tys) => tys,\n+                _ => bug!(\"spread argument isn't a tuple?!\")\n+            };\n \n-                let lltuplety = type_of::type_of(bcx.ccx(), arg_ty);\n-                let lltemp = bcx.with_block(|bcx| {\n-                    base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index))\n-                });\n-                for (i, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n-                    let dst = bcx.struct_gep(lltemp, i);\n-                    let arg = &fcx.fn_ty.args[idx];\n+            let lltuplety = type_of::type_of(bcx.ccx(), arg_ty);\n+            let lltemp = bcx.with_block(|bcx| {\n+                base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index))\n+            });\n+            for (i, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n+                let dst = bcx.struct_gep(lltemp, i);\n+                let arg = &fcx.fn_ty.args[idx];\n+                idx += 1;\n+                if common::type_is_fat_ptr(tcx, tupled_arg_ty) {\n+                    // We pass fat pointers as two words, but inside the tuple\n+                    // they are the two sub-fields of a single aggregate field.\n+                    let meta = &fcx.fn_ty.args[idx];\n                     idx += 1;\n-                    if common::type_is_fat_ptr(tcx, tupled_arg_ty) {\n-                        // We pass fat pointers as two words, but inside the tuple\n-                        // they are the two sub-fields of a single aggregate field.\n-                        let meta = &fcx.fn_ty.args[idx];\n-                        idx += 1;\n-                        arg.store_fn_arg(bcx, &mut llarg_idx, get_dataptr(bcx, dst));\n-                        meta.store_fn_arg(bcx, &mut llarg_idx, get_meta(bcx, dst));\n-                    } else {\n-                        arg.store_fn_arg(bcx, &mut llarg_idx, dst);\n-                    }\n-\n-                    bcx.with_block(|bcx| arg_scope.map(|scope| {\n-                        let byte_offset_of_var_in_tuple =\n-                            machine::llelement_offset(bcx.ccx(), lltuplety, i);\n-\n-                        let ops = unsafe {\n-                            [llvm::LLVMRustDIBuilderCreateOpDeref(),\n-                             llvm::LLVMRustDIBuilderCreateOpPlus(),\n-                             byte_offset_of_var_in_tuple as i64]\n-                        };\n-\n-                        let variable_access = VariableAccess::IndirectVariable {\n-                            alloca: lltemp,\n-                            address_operations: &ops\n-                        };\n-                        declare_local(bcx, keywords::Invalid.name(),\n-                                      tupled_arg_ty, scope, variable_access,\n-                                      VariableKind::ArgumentVariable(arg_index + i + 1),\n-                                      bcx.fcx().span.unwrap_or(DUMMY_SP));\n-                    }));\n+                    arg.store_fn_arg(bcx, &mut llarg_idx, get_dataptr(bcx, dst));\n+                    meta.store_fn_arg(bcx, &mut llarg_idx, get_meta(bcx, dst));\n+                } else {\n+                    arg.store_fn_arg(bcx, &mut llarg_idx, dst);\n                 }\n-                return LocalRef::Lvalue(LvalueRef::new_sized(lltemp, LvalueTy::from_ty(arg_ty)));\n+\n+                bcx.with_block(|bcx| arg_scope.map(|scope| {\n+                    let byte_offset_of_var_in_tuple =\n+                        machine::llelement_offset(bcx.ccx(), lltuplety, i);\n+\n+                    let ops = unsafe {\n+                        [llvm::LLVMRustDIBuilderCreateOpDeref(),\n+                         llvm::LLVMRustDIBuilderCreateOpPlus(),\n+                         byte_offset_of_var_in_tuple as i64]\n+                    };\n+\n+                    let variable_access = VariableAccess::IndirectVariable {\n+                        alloca: lltemp,\n+                        address_operations: &ops\n+                    };\n+                    declare_local(bcx, keywords::Invalid.name(),\n+                                  tupled_arg_ty, scope, variable_access,\n+                                  VariableKind::ArgumentVariable(arg_index + i + 1),\n+                                  bcx.fcx().span.unwrap_or(DUMMY_SP));\n+                }));\n             }\n+            return LocalRef::Lvalue(LvalueRef::new_sized(lltemp, LvalueTy::from_ty(arg_ty)));\n         }\n \n         let arg = &fcx.fn_ty.args[idx];"}]}