{"sha": "633c593bc3f9787decfaf943cdc5659f132ade50", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzM2M1OTNiYzNmOTc4N2RlY2ZhZjk0M2NkYzU2NTlmMTMyYWRlNTA=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-03-11T04:13:29Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-03-17T02:56:31Z"}, "message": "impl<T> [T]", "tree": {"sha": "a2fbb04334457b3f8fdbe47690c40b5e8835529f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2fbb04334457b3f8fdbe47690c40b5e8835529f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/633c593bc3f9787decfaf943cdc5659f132ade50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/633c593bc3f9787decfaf943cdc5659f132ade50", "html_url": "https://github.com/rust-lang/rust/commit/633c593bc3f9787decfaf943cdc5659f132ade50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/633c593bc3f9787decfaf943cdc5659f132ade50/comments", "author": null, "committer": null, "parents": [{"sha": "5b118f5ecde796ad62fa349a045d7ad8129b711c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b118f5ecde796ad62fa349a045d7ad8129b711c", "html_url": "https://github.com/rust-lang/rust/commit/5b118f5ecde796ad62fa349a045d7ad8129b711c"}], "stats": {"total": 943, "additions": 943, "deletions": 0}, "files": [{"sha": "cb84e01e4f79a6d6347fa3eef521256a4934a0dc", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[cfg(stage0)]\n /// Creates a `Vec` containing the arguments.\n ///\n /// `vec!` allows `Vec`s to be defined with the same syntax as array expressions.\n@@ -45,6 +46,43 @@ macro_rules! vec {\n     ($($x:expr,)*) => (vec![$($x),*])\n }\n \n+#[cfg(not(stage0))]\n+/// Creates a `Vec` containing the arguments.\n+///\n+/// `vec!` allows `Vec`s to be defined with the same syntax as array expressions.\n+/// There are two forms of this macro:\n+///\n+/// - Create a `Vec` containing a given list of elements:\n+///\n+/// ```\n+/// let v = vec![1, 2, 3];\n+/// assert_eq!(v[0], 1);\n+/// assert_eq!(v[1], 2);\n+/// assert_eq!(v[2], 3);\n+/// ```\n+///\n+/// - Create a `Vec` from a given element and size:\n+///\n+/// ```\n+/// let v = vec![1; 3];\n+/// assert_eq!(v, [1, 1, 1]);\n+/// ```\n+///\n+/// Note that unlike array expressions this syntax supports all elements\n+/// which implement `Clone` and the number of elements doesn't have to be\n+/// a constant.\n+#[macro_export]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+macro_rules! vec {\n+    ($elem:expr; $n:expr) => (\n+        $crate::vec::from_elem($elem, $n)\n+    );\n+    ($($x:expr),*) => (\n+        <[_]>::into_vec($crate::boxed::Box::new([$($x),*]))\n+    );\n+    ($($x:expr,)*) => (vec![$($x),*])\n+}\n+\n /// Use the syntax described in `std::fmt` to create a value of type `String`.\n /// See `std::fmt` for more information.\n ///"}, {"sha": "c98d0cb35e1d53b80484bac286baee753fb1aefe", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 832, "deletions": 0, "changes": 832, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -120,6 +120,7 @@ pub use core::slice::{from_raw_buf, from_raw_mut_buf};\n // Basic slice extension methods\n ////////////////////////////////////////////////////////////////////////////////\n \n+#[cfg(stage0)]\n /// Allocating extension methods for slices.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait SliceExt {\n@@ -795,6 +796,7 @@ pub trait SliceExt {\n     fn into_vec(self: Box<Self>) -> Vec<Self::Item>;\n }\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> SliceExt for [T] {\n     type Item = T;\n@@ -1080,6 +1082,836 @@ impl<T> SliceExt for [T] {\n     }\n }\n \n+#[cfg(not(stage0))]\n+/// Allocating extension methods for slices.\n+#[lang = \"slice\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> [T] {\n+    /// Sorts the slice, in place, using `compare` to compare\n+    /// elements.\n+    ///\n+    /// This sort is `O(n log n)` worst-case and stable, but allocates\n+    /// approximately `2 * n`, where `n` is the length of `self`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// let mut v = [5, 4, 1, 3, 2];\n+    /// v.sort_by(|a, b| a.cmp(b));\n+    /// assert!(v == [1, 2, 3, 4, 5]);\n+    ///\n+    /// // reverse sorting\n+    /// v.sort_by(|a, b| b.cmp(a));\n+    /// assert!(v == [5, 4, 3, 2, 1]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering {\n+        merge_sort(self, compare)\n+    }\n+\n+    /// Consumes `src` and moves as many elements as it can into `self`\n+    /// from the range [start,end).\n+    ///\n+    /// Returns the number of elements copied (the shorter of `self.len()`\n+    /// and `end - start`).\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * src - A mutable vector of `T`\n+    /// * start - The index into `src` to start copying from\n+    /// * end - The index into `src` to stop copying from\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// let mut a = [1, 2, 3, 4, 5];\n+    /// let b = vec![6, 7, 8];\n+    /// let num_moved = a.move_from(b, 0, 3);\n+    /// assert_eq!(num_moved, 3);\n+    /// assert!(a == [6, 7, 8, 4, 5]);\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"uncertain about this API approach\")]\n+    #[inline]\n+    pub fn move_from(&mut self, mut src: Vec<T>, start: usize, end: usize) -> usize {\n+        for (a, b) in self.iter_mut().zip(src[start .. end].iter_mut()) {\n+            mem::swap(a, b);\n+        }\n+        cmp::min(self.len(), end-start)\n+    }\n+\n+    /// Deprecated: use `&s[start .. end]` notation instead.\n+    #[unstable(feature = \"collections\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &s[start .. end] instead\")]\n+    #[inline]\n+    pub fn slice(&self, start: usize, end: usize) -> &[T] {\n+        &self[start .. end]\n+    }\n+\n+    /// Deprecated: use `&s[start..]` notation instead.\n+    #[unstable(feature = \"collections\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &s[start..] instead\")]\n+    #[inline]\n+    pub fn slice_from(&self, start: usize) -> &[T] {\n+        &self[start ..]\n+    }\n+\n+    /// Deprecated: use `&s[..end]` notation instead.\n+    #[unstable(feature = \"collections\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &s[..end] instead\")]\n+    #[inline]\n+    pub fn slice_to(&self, end: usize) -> &[T] {\n+        &self[.. end]\n+    }\n+\n+    /// Divides one slice into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// Panics if `mid > len`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30, 20, 50];\n+    /// let (v1, v2) = v.split_at(2);\n+    /// assert_eq!([10, 40], v1);\n+    /// assert_eq!([30, 20, 50], v2);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n+        core_slice::SliceExt::split_at(self, mid)\n+    }\n+\n+    /// Returns an iterator over the slice.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn iter(&self) -> Iter<T> {\n+        core_slice::SliceExt::iter(self)\n+    }\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`.  The matched element is not contained in the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Print the slice split by numbers divisible by 3 (i.e. `[10, 40]`,\n+    /// `[20]`, `[50]`):\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30, 20, 60, 50];\n+    /// for group in v.split(|num| *num % 3 == 0) {\n+    ///     println!(\"{:?}\", group);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn split<F>(&self, pred: F) -> Split<T, F> where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::split(self, pred)\n+    }\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, limited to splitting at most `n` times.  The matched element is\n+    /// not contained in the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Print the slice split once by numbers divisible by 3 (i.e. `[10, 40]`,\n+    /// `[20, 60, 50]`):\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30, 20, 60, 50];\n+    /// for group in v.splitn(1, |num| *num % 3 == 0) {\n+    ///     println!(\"{:?}\", group);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn splitn<F>(&self, n: usize, pred: F) -> SplitN<T, F> where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::splitn(self, n, pred)\n+    }\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred` limited to splitting at most `n` times. This starts at the end of\n+    /// the slice and works backwards.  The matched element is not contained in\n+    /// the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Print the slice split once, starting from the end, by numbers divisible\n+    /// by 3 (i.e. `[50]`, `[10, 40, 30, 20]`):\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30, 20, 60, 50];\n+    /// for group in v.rsplitn(1, |num| *num % 3 == 0) {\n+    ///     println!(\"{:?}\", group);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<T, F> where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::rsplitn(self, n, pred)\n+    }\n+\n+    /// Returns an iterator over all contiguous windows of length\n+    /// `size`. The windows overlap. If the slice is shorter than\n+    /// `size`, the iterator returns no values.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `size` is 0.\n+    ///\n+    /// # Example\n+    ///\n+    /// Print the adjacent pairs of a slice (i.e. `[1,2]`, `[2,3]`,\n+    /// `[3,4]`):\n+    ///\n+    /// ```rust\n+    /// let v = &[1, 2, 3, 4];\n+    /// for win in v.windows(2) {\n+    ///     println!(\"{:?}\", win);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn windows(&self, size: usize) -> Windows<T> {\n+        core_slice::SliceExt::windows(self, size)\n+    }\n+\n+    /// Returns an iterator over `size` elements of the slice at a\n+    /// time. The chunks do not overlap. If `size` does not divide the\n+    /// length of the slice, then the last chunk will not have length\n+    /// `size`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `size` is 0.\n+    ///\n+    /// # Example\n+    ///\n+    /// Print the slice two elements at a time (i.e. `[1,2]`,\n+    /// `[3,4]`, `[5]`):\n+    ///\n+    /// ```rust\n+    /// let v = &[1, 2, 3, 4, 5];\n+    /// for win in v.chunks(2) {\n+    ///     println!(\"{:?}\", win);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn chunks(&self, size: usize) -> Chunks<T> {\n+        core_slice::SliceExt::chunks(self, size)\n+    }\n+\n+    /// Returns the element of a slice at the given index, or `None` if the\n+    /// index is out of bounds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert_eq!(Some(&40), v.get(1));\n+    /// assert_eq!(None, v.get(3));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn get(&self, index: usize) -> Option<&T> {\n+        core_slice::SliceExt::get(self, index)\n+    }\n+\n+    /// Returns the first element of a slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert_eq!(Some(&10), v.first());\n+    ///\n+    /// let w: &[i32] = &[];\n+    /// assert_eq!(None, w.first());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn first(&self) -> Option<&T> {\n+        core_slice::SliceExt::first(self)\n+    }\n+\n+    /// Returns all but the first element of a slice.\n+    #[unstable(feature = \"collections\", reason = \"likely to be renamed\")]\n+    #[inline]\n+    pub fn tail(&self) -> &[T] {\n+        core_slice::SliceExt::tail(self)\n+    }\n+\n+    /// Returns all but the last element of a slice.\n+    #[unstable(feature = \"collections\", reason = \"likely to be renamed\")]\n+    #[inline]\n+    pub fn init(&self) -> &[T] {\n+        core_slice::SliceExt::init(self)\n+    }\n+\n+    /// Returns the last element of a slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert_eq!(Some(&30), v.last());\n+    ///\n+    /// let w: &[i32] = &[];\n+    /// assert_eq!(None, w.last());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn last(&self) -> Option<&T> {\n+        core_slice::SliceExt::last(self)\n+    }\n+\n+    /// Returns a pointer to the element at the given index, without doing\n+    /// bounds checking.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked(&self, index: usize) -> &T {\n+        core_slice::SliceExt::get_unchecked(self, index)\n+    }\n+\n+    /// Returns an unsafe pointer to the slice's buffer\n+    ///\n+    /// The caller must ensure that the slice outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the slice may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn as_ptr(&self) -> *const T {\n+        core_slice::SliceExt::as_ptr(self)\n+    }\n+\n+    /// Binary search a sorted slice with a comparator function.\n+    ///\n+    /// The comparator function should implement an order consistent\n+    /// with the sort order of the underlying slice, returning an\n+    /// order code that indicates whether its argument is `Less`,\n+    /// `Equal` or `Greater` the desired target.\n+    ///\n+    /// If a matching value is found then returns `Ok`, containing\n+    /// the index for the matched element; if no match is found then\n+    /// `Err` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Example\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1,4]`.\n+    ///\n+    /// ```rust\n+    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// let s = s.as_slice();\n+    ///\n+    /// let seek = 13;\n+    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\n+    /// let seek = 4;\n+    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));\n+    /// let seek = 100;\n+    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));\n+    /// let seek = 1;\n+    /// let r = s.binary_search_by(|probe| probe.cmp(&seek));\n+    /// assert!(match r { Ok(1...4) => true, _ => false, });\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn binary_search_by<F>(&self, f: F) -> Result<usize, usize> where F: FnMut(&T) -> Ordering {\n+        core_slice::SliceExt::binary_search_by(self, f)\n+    }\n+\n+    /// Return the number of elements in the slice\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.len(), 3);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        core_slice::SliceExt::len(self)\n+    }\n+\n+    /// Returns true if the slice has a length of 0\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    /// assert!(!a.is_empty());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        core_slice::SliceExt::is_empty(self)\n+    }\n+\n+    /// Returns a mutable reference to the element at the given index,\n+    /// or `None` if the index is out of bounds\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn get_mut(&mut self, index: usize) -> Option<&mut T> {\n+        core_slice::SliceExt::get_mut(self, index)\n+    }\n+\n+    /// Work with `self` as a mut slice.\n+    /// Primarily intended for getting a &mut [T] from a [T; N].\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn as_mut_slice(&mut self) -> &mut [T] {\n+        core_slice::SliceExt::as_mut_slice(self)\n+    }\n+\n+    /// Deprecated: use `&mut s[start .. end]` instead.\n+    #[unstable(feature = \"collections\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[start .. end] instead\")]\n+    #[inline]\n+    pub fn slice_mut(&mut self, start: usize, end: usize) -> &mut [T] {\n+        &mut self[start .. end]\n+    }\n+\n+    /// Deprecated: use `&mut s[start ..]` instead.\n+    #[unstable(feature = \"collections\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[start ..] instead\")]\n+    #[inline]\n+    pub fn slice_from_mut(&mut self, start: usize) -> &mut [T] {\n+        &mut self[start ..]\n+    }\n+\n+    /// Deprecated: use `&mut s[.. end]` instead.\n+    #[unstable(feature = \"collections\",\n+               reason = \"will be replaced by slice syntax\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[.. end] instead\")]\n+    #[inline]\n+    pub fn slice_to_mut(&mut self, end: usize) -> &mut [T] {\n+        &mut self[.. end]\n+    }\n+\n+    /// Returns an iterator that allows modifying each value\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn iter_mut(&mut self) -> IterMut<T> {\n+        core_slice::SliceExt::iter_mut(self)\n+    }\n+\n+    /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn first_mut(&mut self) -> Option<&mut T> {\n+        core_slice::SliceExt::first_mut(self)\n+    }\n+\n+    /// Returns all but the first element of a mutable slice\n+    #[unstable(feature = \"collections\",\n+               reason = \"likely to be renamed or removed\")]\n+    #[inline]\n+    pub fn tail_mut(&mut self) -> &mut [T] {\n+        core_slice::SliceExt::tail_mut(self)\n+    }\n+\n+    /// Returns all but the last element of a mutable slice\n+    #[unstable(feature = \"collections\",\n+               reason = \"likely to be renamed or removed\")]\n+    #[inline]\n+    pub fn init_mut(&mut self) -> &mut [T] {\n+        core_slice::SliceExt::init_mut(self)\n+    }\n+\n+    /// Returns a mutable pointer to the last item in the slice.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn last_mut(&mut self) -> Option<&mut T> {\n+        core_slice::SliceExt::last_mut(self)\n+    }\n+\n+    /// Returns an iterator over mutable subslices separated by elements that\n+    /// match `pred`.  The matched element is not contained in the subslices.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F> where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::split_mut(self, pred)\n+    }\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, limited to splitting at most `n` times.  The matched element is\n+    /// not contained in the subslices.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<T, F>\n+                         where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::splitn_mut(self, n, pred)\n+    }\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred` limited to splitting at most `n` times. This starts at the end of\n+    /// the slice and works backwards.  The matched element is not contained in\n+    /// the subslices.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn rsplitn_mut<F>(&mut self,  n: usize, pred: F) -> RSplitNMut<T, F>\n+                      where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::rsplitn_mut(self, n, pred)\n+    }\n+\n+    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n+    /// The chunks are mutable and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last chunk will not\n+    /// have length `chunk_size`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n+        core_slice::SliceExt::chunks_mut(self, chunk_size)\n+    }\n+\n+    /// Swaps two elements in a slice.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * a - The index of the first element\n+    /// * b - The index of the second element\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `a` or `b` are out of bounds.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n+    /// v.swap(1, 3);\n+    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn swap(&mut self, a: usize, b: usize) {\n+        core_slice::SliceExt::swap(self, a, b)\n+    }\n+\n+    /// Divides one `&mut` into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `mid > len`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1, 2, 3, 4, 5, 6];\n+    ///\n+    /// // scoped to restrict the lifetime of the borrows\n+    /// {\n+    ///    let (left, right) = v.split_at_mut(0);\n+    ///    assert!(left == []);\n+    ///    assert!(right == [1, 2, 3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_at_mut(2);\n+    ///     assert!(left == [1, 2]);\n+    ///     assert!(right == [3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_at_mut(6);\n+    ///     assert!(left == [1, 2, 3, 4, 5, 6]);\n+    ///     assert!(right == []);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n+        core_slice::SliceExt::split_at_mut(self, mid)\n+    }\n+\n+    /// Reverse the order of elements in a slice, in place.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1, 2, 3];\n+    /// v.reverse();\n+    /// assert!(v == [3, 2, 1]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn reverse(&mut self) {\n+        core_slice::SliceExt::reverse(self)\n+    }\n+\n+    /// Returns an unsafe mutable pointer to the element in index\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut T {\n+        core_slice::SliceExt::get_unchecked_mut(self, index)\n+    }\n+\n+    /// Return an unsafe mutable pointer to the slice's buffer.\n+    ///\n+    /// The caller must ensure that the slice outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the slice may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn as_mut_ptr(&mut self) -> *mut T {\n+        core_slice::SliceExt::as_mut_ptr(self)\n+    }\n+\n+    /// Copies `self` into a new `Vec`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn to_vec(&self) -> Vec<T> where T: Clone {\n+        let mut vector = Vec::with_capacity(self.len());\n+        vector.push_all(self);\n+        vector\n+    }\n+\n+    /// Creates an iterator that yields every possible permutation of the\n+    /// vector in succession.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// let v = [1, 2, 3];\n+    /// let mut perms = v.permutations();\n+    ///\n+    /// for p in perms {\n+    ///   println!(\"{:?}\", p);\n+    /// }\n+    /// ```\n+    ///\n+    /// Iterating through permutations one by one.\n+    ///\n+    /// ```rust\n+    /// let v = [1, 2, 3];\n+    /// let mut perms = v.permutations();\n+    ///\n+    /// assert_eq!(Some(vec![1, 2, 3]), perms.next());\n+    /// assert_eq!(Some(vec![1, 3, 2]), perms.next());\n+    /// assert_eq!(Some(vec![3, 1, 2]), perms.next());\n+    /// ```\n+    #[unstable(feature = \"collections\")]\n+    pub fn permutations(&self) -> Permutations<T> where T: Clone {\n+        Permutations{\n+            swaps: ElementSwaps::new(self.len()),\n+            v: self.to_vec(),\n+        }\n+    }\n+\n+    /// Copies as many elements from `src` as it can into `self` (the\n+    /// shorter of `self.len()` and `src.len()`). Returns the number\n+    /// of elements copied.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut dst = [0, 0, 0];\n+    /// let src = [1, 2];\n+    ///\n+    /// assert!(dst.clone_from_slice(&src) == 2);\n+    /// assert!(dst == [1, 2, 0]);\n+    ///\n+    /// let src2 = [3, 4, 5, 6];\n+    /// assert!(dst.clone_from_slice(&src2) == 3);\n+    /// assert!(dst == [3, 4, 5]);\n+    /// ```\n+    #[unstable(feature = \"collections\")]\n+    pub fn clone_from_slice(&mut self, src: &[T]) -> usize where T: Clone {\n+        core_slice::SliceExt::clone_from_slice(self, src)\n+    }\n+\n+    /// Sorts the slice, in place.\n+    ///\n+    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// let mut v = [-5, 4, 1, -3, 2];\n+    ///\n+    /// v.sort();\n+    /// assert!(v == [-5, -3, 1, 2, 4]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn sort(&mut self) where T: Ord {\n+        self.sort_by(|a, b| a.cmp(b))\n+    }\n+\n+    /// Binary search a sorted slice for a given element.\n+    ///\n+    /// If the value is found then `Ok` is returned, containing the\n+    /// index of the matching element; if the value is not found then\n+    /// `Err` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Example\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1,4]`.\n+    ///\n+    /// ```rust\n+    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// let s = s.as_slice();\n+    ///\n+    /// assert_eq!(s.binary_search(&13),  Ok(9));\n+    /// assert_eq!(s.binary_search(&4),   Err(7));\n+    /// assert_eq!(s.binary_search(&100), Err(13));\n+    /// let r = s.binary_search(&1);\n+    /// assert!(match r { Ok(1...4) => true, _ => false, });\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn binary_search(&self, x: &T) -> Result<usize, usize> where T: Ord {\n+        core_slice::SliceExt::binary_search(self, x)\n+    }\n+\n+    /// Deprecated: use `binary_search` instead.\n+    #[unstable(feature = \"collections\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use binary_search instead\")]\n+    pub fn binary_search_elem(&self, x: &T) -> Result<usize, usize> where T: Ord {\n+        self.binary_search(x)\n+    }\n+\n+    /// Mutates the slice to the next lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// last-ordered permutation.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: &mut [_] = &mut [0, 1, 2];\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [0, 2, 1];\n+    /// assert!(v == b);\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [1, 0, 2];\n+    /// assert!(v == b);\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"uncertain if this merits inclusion in std\")]\n+    pub fn next_permutation(&mut self) -> bool where T: Ord {\n+        core_slice::SliceExt::next_permutation(self)\n+    }\n+\n+    /// Mutates the slice to the previous lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// first-ordered permutation.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: &mut [_] = &mut [1, 0, 2];\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0, 2, 1];\n+    /// assert!(v == b);\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0, 1, 2];\n+    /// assert!(v == b);\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"uncertain if this merits inclusion in std\")]\n+    pub fn prev_permutation(&mut self) -> bool where T: Ord {\n+        core_slice::SliceExt::prev_permutation(self)\n+    }\n+\n+    /// Find the first index containing a matching value.\n+    #[unstable(feature = \"collections\")]\n+    pub fn position_elem(&self, t: &T) -> Option<usize> where T: PartialEq {\n+        core_slice::SliceExt::position_elem(self, t)\n+    }\n+\n+    /// Find the last index containing a matching value.\n+    #[unstable(feature = \"collections\")]\n+    pub fn rposition_elem(&self, t: &T) -> Option<usize> where T: PartialEq {\n+        core_slice::SliceExt::rposition_elem(self, t)\n+    }\n+\n+    /// Returns true if the slice contains an element with the given value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert!(v.contains(&30));\n+    /// assert!(!v.contains(&50));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn contains(&self, x: &T) -> bool where T: PartialEq {\n+        core_slice::SliceExt::contains(self, x)\n+    }\n+\n+    /// Returns true if `needle` is a prefix of the slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert!(v.starts_with(&[10]));\n+    /// assert!(v.starts_with(&[10, 40]));\n+    /// assert!(!v.starts_with(&[50]));\n+    /// assert!(!v.starts_with(&[10, 50]));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq {\n+        core_slice::SliceExt::starts_with(self, needle)\n+    }\n+\n+    /// Returns true if `needle` is a suffix of the slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = [10, 40, 30];\n+    /// assert!(v.ends_with(&[30]));\n+    /// assert!(v.ends_with(&[40, 30]));\n+    /// assert!(!v.ends_with(&[50]));\n+    /// assert!(!v.ends_with(&[50, 30]));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n+        core_slice::SliceExt::ends_with(self, needle)\n+    }\n+\n+    /// Convert `self` into a vector without clones or allocation.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn into_vec(mut self: Box<Self>) -> Vec<T> {\n+        unsafe {\n+            let xs = Vec::from_raw_parts(self.as_mut_ptr(), self.len(), self.len());\n+            mem::forget(self);\n+            xs\n+        }\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Extension traits for slices over specific kinds of data\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "06674f6f0ab7576491e91f94442b4981cb608e46", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -72,6 +72,7 @@ use unicode::str::{UnicodeStr, Utf16Encoder};\n \n use vec_deque::VecDeque;\n use borrow::{Borrow, ToOwned};\n+#[cfg(stage0)]\n use slice::SliceExt;\n use string::String;\n use unicode;"}, {"sha": "64dec9731ec21cc4fd5afb56e7d8a62aaf6757cb", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -85,6 +85,7 @@ impl String {\n         }\n     }\n \n+    #[cfg(stage0)]\n     /// Creates a new string buffer from the given string.\n     ///\n     /// # Examples\n@@ -100,6 +101,22 @@ impl String {\n         String { vec: ::slice::SliceExt::to_vec(string.as_bytes()) }\n     }\n \n+    #[cfg(not(stage0))]\n+    /// Creates a new string buffer from the given string.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = String::from_str(\"hello\");\n+    /// assert_eq!(s.as_slice(), \"hello\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"collections\",\n+               reason = \"needs investigation to see if to_string() can match perf\")]\n+    pub fn from_str(string: &str) -> String {\n+        String { vec: <[_]>::to_vec(string.as_bytes()) }\n+    }\n+\n     /// Returns the vector as a string buffer, if possible, taking care not to\n     /// copy it.\n     ///"}, {"sha": "937df5494dffa955563a192702de70947c59e8c5", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -1282,8 +1282,12 @@ pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {\n \n #[unstable(feature = \"collections\")]\n impl<T:Clone> Clone for Vec<T> {\n+    #[cfg(stage0)]\n     fn clone(&self) -> Vec<T> { ::slice::SliceExt::to_vec(&**self) }\n \n+    #[cfg(not(stage0))]\n+    fn clone(&self) -> Vec<T> { <[T]>::to_vec(&**self) }\n+\n     fn clone_from(&mut self, other: &Vec<T>) {\n         // drop anything in self that will not be overwritten\n         if self.len() > other.len() {"}, {"sha": "48526f2bf2db40adde9e472e0331933354cdcaf6", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -22,7 +22,10 @@ use old_io;\n use ops::Deref;\n use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n+#[cfg(stage0)]\n use slice::{self, SliceExt};\n+#[cfg(not(stage0))]\n+use slice;\n #[cfg(stage0)]\n use str::StrExt;\n use string::String;"}, {"sha": "c89edf7284293b061436fced2ce389f274cd07d8", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -23,7 +23,10 @@ use option::Option::{self, Some, None};\n use ptr::PtrExt;\n use result::Result::{Ok, Err};\n use result;\n+#[cfg(stage0)]\n use slice::{self, SliceExt};\n+#[cfg(not(stage0))]\n+use slice;\n use string::String;\n #[cfg(stage0)]\n use str::{self, StrExt};"}, {"sha": "ea1e05df85f75cb888bf0f3576c3cb9063c3f114", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -23,6 +23,7 @@ use char;\n use num::{self, Int, Float, ToPrimitive};\n use num::FpCategory as Fp;\n use ops::FnMut;\n+#[cfg(stage0)]\n use slice::SliceExt;\n #[cfg(stage0)]\n use str::StrExt;"}, {"sha": "2f4e1e870997d277913e879aad70963b4f2a0dea", "filename": "src/libstd/old_io/buffered.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -20,6 +20,7 @@ use ops::Drop;\n use option::Option;\n use option::Option::{Some, None};\n use result::Result::Ok;\n+#[cfg(stage0)]\n use slice::{SliceExt};\n use slice;\n use vec::Vec;"}, {"sha": "33928d638e064b8114bad5659d411c600c43e6e7", "filename": "src/libstd/old_io/comm_adapters.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -14,7 +14,10 @@ use sync::mpsc::{Sender, Receiver};\n use old_io;\n use option::Option::{None, Some};\n use result::Result::{Ok, Err};\n+#[cfg(stage0)]\n use slice::{bytes, SliceExt};\n+#[cfg(not(stage0))]\n+use slice::bytes;\n use super::{Buffer, Reader, Writer, IoResult};\n use vec::Vec;\n "}, {"sha": "b67ec847c79ae008976bef2bb0ec75ea82fd569f", "filename": "src/libstd/old_io/extensions.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_io%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_io%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fextensions.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -28,6 +28,7 @@ use option::Option;\n use option::Option::{Some, None};\n use ptr::PtrExt;\n use result::Result::{Ok, Err};\n+#[cfg(stage0)]\n use slice::SliceExt;\n \n /// An iterator that reads a single byte on each iteration,\n@@ -162,6 +163,7 @@ pub fn u64_to_be_bytes<T, F>(n: u64, size: uint, f: F) -> T where\n ///           32-bit value is parsed.\n pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n     use ptr::{copy_nonoverlapping_memory};\n+    #[cfg(stage0)]\n     use slice::SliceExt;\n \n     assert!(size <= 8);"}, {"sha": "a6ed76688ca685b0e47d08c3671796cb9e250f46", "filename": "src/libstd/old_io/fs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_io%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_io%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ffs.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -64,6 +64,7 @@ use option::Option::{Some, None};\n use old_path::{Path, GenericPath};\n use old_path;\n use result::Result::{Err, Ok};\n+#[cfg(stage0)]\n use slice::SliceExt;\n use string::String;\n use vec::Vec;"}, {"sha": "a31b2e7627def79f236e3a1b816f25b6fcf4c119", "filename": "src/libstd/old_io/mem.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -17,7 +17,10 @@ use option::Option::None;\n use result::Result::{Err, Ok};\n use old_io;\n use old_io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n+#[cfg(stage0)]\n use slice::{self, SliceExt};\n+#[cfg(not(stage0))]\n+use slice;\n use vec::Vec;\n \n const BUF_CAPACITY: uint = 128;"}, {"sha": "89e813de5b6289a914fbf504d3d3bbe090f94ef1", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -268,6 +268,7 @@ use boxed::Box;\n use result::Result;\n use result::Result::{Ok, Err};\n use sys;\n+#[cfg(stage0)]\n use slice::SliceExt;\n #[cfg(stage0)]\n use str::StrExt;"}, {"sha": "2dda2c1277a34bc8ff686783b92c46d55b410f6d", "filename": "src/libstd/old_io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -26,6 +26,7 @@ use ops::{FnOnce, FnMut};\n use option::Option;\n use option::Option::{None, Some};\n use result::Result::{self, Ok, Err};\n+#[cfg(stage0)]\n use slice::SliceExt;\n #[cfg(stage0)]\n use str::{FromStr, StrExt};"}, {"sha": "92fad2316714ccb7b1bf5dbc657a29efa7e92b92", "filename": "src/libstd/old_io/stdio.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -43,6 +43,7 @@ use ops::{Deref, DerefMut, FnOnce};\n use ptr;\n use result::Result::{Ok, Err};\n use rt;\n+#[cfg(stage0)]\n use slice::SliceExt;\n #[cfg(stage0)]\n use str::StrExt;"}, {"sha": "37875658ae0916a4ce2f95ea732152185b64a42f", "filename": "src/libstd/old_path/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_path%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_path%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fmod.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -75,6 +75,7 @@ use str;\n #[cfg(stage0)]\n use str::StrExt;\n use string::{String, CowString};\n+#[cfg(stage0)]\n use slice::SliceExt;\n use vec::Vec;\n "}, {"sha": "9ac7512c00b7090d23d9d2556ef43dbe5dc7dcd7", "filename": "src/libstd/old_path/posix.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_path%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_path%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fposix.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -20,7 +20,10 @@ use iter::{Iterator, IteratorExt, Map};\n use marker::Sized;\n use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n+#[cfg(stage0)]\n use slice::{AsSlice, Split, SliceExt, SliceConcatExt};\n+#[cfg(not(stage0))]\n+use slice::{AsSlice, Split, SliceConcatExt};\n #[cfg(stage0)]\n use str::{self, FromStr, StrExt};\n #[cfg(not(stage0))]"}, {"sha": "b74bee1242de7ae5998f634b345a2954b17f526e", "filename": "src/libstd/old_path/windows.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -27,7 +27,10 @@ use iter::{Iterator, IteratorExt, Map, repeat};\n use mem;\n use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n+#[cfg(stage0)]\n use slice::{SliceExt, SliceConcatExt};\n+#[cfg(not(stage0))]\n+use slice::SliceConcatExt;\n #[cfg(stage0)]\n use str::{SplitTerminator, FromStr, StrExt};\n #[cfg(not(stage0))]"}, {"sha": "e04d7f3f240cb186407821885899509f86ade21a", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -56,7 +56,10 @@ use ptr::PtrExt;\n use ptr;\n use result::Result::{Err, Ok};\n use result::Result;\n+#[cfg(stage0)]\n use slice::{AsSlice, SliceExt};\n+#[cfg(not(stage0))]\n+use slice::AsSlice;\n #[cfg(stage0)]\n use str::{Str, StrExt};\n #[cfg(not(stage0))]"}, {"sha": "e21ae1657ee51ba1f55824ddb07d8c8ccc4fda3c", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -44,8 +44,12 @@\n #[doc(no_inline)] pub use ptr::{PtrExt, MutPtrExt};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use result::Result::{self, Ok, Err};\n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use slice::{SliceExt, SliceConcatExt, AsSlice};\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use slice::{SliceConcatExt, AsSlice};\n #[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use str::{Str, StrExt};"}, {"sha": "46e35e0fa8bf091e6ab5206329ef6aff8d1a4be3", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -24,6 +24,7 @@ mod imp {\n     use rand::Rng;\n     use rand::reader::ReaderRng;\n     use result::Result::Ok;\n+    #[cfg(stage0)]\n     use slice::SliceExt;\n     use mem;\n     use os::errno;\n@@ -193,6 +194,7 @@ mod imp {\n     use rand::Rng;\n     use result::Result::{Ok};\n     use self::libc::{c_int, size_t};\n+    #[cfg(stage0)]\n     use slice::SliceExt;\n \n     /// A random number generator that retrieves randomness straight from\n@@ -263,6 +265,7 @@ mod imp {\n     use result::Result::{Ok, Err};\n     use self::libc::{DWORD, BYTE, LPCSTR, BOOL};\n     use self::libc::types::os::arch::extra::{LONG_PTR};\n+    #[cfg(stage0)]\n     use slice::SliceExt;\n \n     type HCRYPTPROV = LONG_PTR;"}, {"sha": "eac5aa4256c8c3fd29ac58bf648d8169e8e18ae3", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -13,6 +13,7 @@\n use old_io::Reader;\n use rand::Rng;\n use result::Result::{Ok, Err};\n+#[cfg(stage0)]\n use slice::SliceExt;\n \n /// An RNG that reads random bytes straight from a `Reader`. This will"}, {"sha": "dfc88571a8282326937f1e0b86ec58570ba0af27", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -172,6 +172,7 @@ impl Wtf8Buf {\n         Wtf8Buf { bytes: string.into_bytes() }\n     }\n \n+    #[cfg(stage0)]\n     /// Create a WTF-8 string from an UTF-8 `&str` slice.\n     ///\n     /// This copies the content of the slice.\n@@ -182,6 +183,17 @@ impl Wtf8Buf {\n         Wtf8Buf { bytes: slice::SliceExt::to_vec(str.as_bytes()) }\n     }\n \n+    #[cfg(not(stage0))]\n+    /// Create a WTF-8 string from an UTF-8 `&str` slice.\n+    ///\n+    /// This copies the content of the slice.\n+    ///\n+    /// Since WTF-8 is a superset of UTF-8, this always succeeds.\n+    #[inline]\n+    pub fn from_str(str: &str) -> Wtf8Buf {\n+        Wtf8Buf { bytes: <[_]>::to_vec(str.as_bytes()) }\n+    }\n+\n     /// Create a WTF-8 string from a potentially ill-formed UTF-16 slice of 16-bit code units.\n     ///\n     /// This is lossless: calling `.encode_wide()` on the resulting string"}, {"sha": "995914807528b185fba3051b4653f690bb669bcd", "filename": "src/libstd/sys/unix/os_str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/633c593bc3f9787decfaf943cdc5659f132ade50/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs?ref=633c593bc3f9787decfaf943cdc5659f132ade50", "patch": "@@ -16,6 +16,7 @@ use core::prelude::*;\n use borrow::Cow;\n use fmt::{self, Debug};\n use vec::Vec;\n+#[cfg(stage0)]\n use slice::SliceExt as StdSliceExt;\n use str;\n use string::String;"}]}