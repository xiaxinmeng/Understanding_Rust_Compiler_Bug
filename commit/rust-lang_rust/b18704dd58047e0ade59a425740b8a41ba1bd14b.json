{"sha": "b18704dd58047e0ade59a425740b8a41ba1bd14b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxODcwNGRkNTgwNDdlMGFkZTU5YTQyNTc0MGI4YTQxYmExYmQxNGI=", "commit": {"author": {"name": "jam1garner", "email": "8260240+jam1garner@users.noreply.github.com", "date": "2021-06-19T22:42:24Z"}, "committer": {"name": "jam1garner", "email": "8260240+jam1garner@users.noreply.github.com", "date": "2021-06-19T22:42:24Z"}, "message": "Fix future_prelude_collision for object calls and use as _", "tree": {"sha": "b4271156c499547956acc9b7ad75471c7a947ee8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4271156c499547956acc9b7ad75471c7a947ee8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b18704dd58047e0ade59a425740b8a41ba1bd14b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b18704dd58047e0ade59a425740b8a41ba1bd14b", "html_url": "https://github.com/rust-lang/rust/commit/b18704dd58047e0ade59a425740b8a41ba1bd14b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b18704dd58047e0ade59a425740b8a41ba1bd14b/comments", "author": {"login": "jam1garner", "id": 8260240, "node_id": "MDQ6VXNlcjgyNjAyNDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8260240?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jam1garner", "html_url": "https://github.com/jam1garner", "followers_url": "https://api.github.com/users/jam1garner/followers", "following_url": "https://api.github.com/users/jam1garner/following{/other_user}", "gists_url": "https://api.github.com/users/jam1garner/gists{/gist_id}", "starred_url": "https://api.github.com/users/jam1garner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jam1garner/subscriptions", "organizations_url": "https://api.github.com/users/jam1garner/orgs", "repos_url": "https://api.github.com/users/jam1garner/repos", "events_url": "https://api.github.com/users/jam1garner/events{/privacy}", "received_events_url": "https://api.github.com/users/jam1garner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jam1garner", "id": 8260240, "node_id": "MDQ6VXNlcjgyNjAyNDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8260240?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jam1garner", "html_url": "https://github.com/jam1garner", "followers_url": "https://api.github.com/users/jam1garner/followers", "following_url": "https://api.github.com/users/jam1garner/following{/other_user}", "gists_url": "https://api.github.com/users/jam1garner/gists{/gist_id}", "starred_url": "https://api.github.com/users/jam1garner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jam1garner/subscriptions", "organizations_url": "https://api.github.com/users/jam1garner/orgs", "repos_url": "https://api.github.com/users/jam1garner/repos", "events_url": "https://api.github.com/users/jam1garner/events{/privacy}", "received_events_url": "https://api.github.com/users/jam1garner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bee7f0d0e1fee2a6a3ec2d04689d94ec238f034", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bee7f0d0e1fee2a6a3ec2d04689d94ec238f034", "html_url": "https://github.com/rust-lang/rust/commit/9bee7f0d0e1fee2a6a3ec2d04689d94ec238f034"}], "stats": {"total": 372, "additions": 313, "deletions": 59}, "files": [{"sha": "0750567d3dd60fbf8e18a3c4884886cf4c8d3ccc", "filename": "compiler/rustc_typeck/src/check/method/prelude2021.rs", "status": "modified", "additions": 138, "deletions": 57, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/b18704dd58047e0ade59a425740b8a41ba1bd14b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b18704dd58047e0ade59a425740b8a41ba1bd14b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs?ref=b18704dd58047e0ade59a425740b8a41ba1bd14b", "patch": "@@ -4,7 +4,7 @@ use hir::ItemKind;\n use rustc_ast::Mutability;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_middle::ty::Ty;\n+use rustc_middle::ty::{Ref, Ty};\n use rustc_session::lint::builtin::FUTURE_PRELUDE_COLLISION;\n use rustc_span::symbol::kw::Underscore;\n use rustc_span::symbol::{sym, Ident};\n@@ -46,21 +46,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        self.tcx.struct_span_lint_hir(\n-            FUTURE_PRELUDE_COLLISION,\n-            call_expr.hir_id,\n-            call_expr.span,\n-            |lint| {\n-                let sp = call_expr.span;\n-                let trait_name =\n-                    self.trait_path_or_bare_name(span, call_expr.hir_id, pick.item.container.id());\n-\n-                let mut lint = lint.build(&format!(\n-                    \"trait method `{}` will become ambiguous in Rust 2021\",\n-                    segment.ident.name\n-                ));\n-\n-                if let Ok(self_expr) = self.sess().source_map().span_to_snippet(self_expr.span) {\n+        if matches!(pick.kind, probe::PickKind::InherentImplPick | probe::PickKind::ObjectPick) {\n+            // avoid repeatedly adding unneeded `&*`s\n+            if pick.autoderefs == 1\n+                && matches!(\n+                    pick.autoref_or_ptr_adjustment,\n+                    Some(probe::AutorefOrPtrAdjustment::Autoref { .. })\n+                )\n+                && matches!(self_ty.kind(), Ref(..))\n+            {\n+                return;\n+            }\n+            // Inherent impls only require not relying on autoref and autoderef in order to\n+            // ensure that the trait implementation won't be used\n+            self.tcx.struct_span_lint_hir(\n+                FUTURE_PRELUDE_COLLISION,\n+                self_expr.hir_id,\n+                self_expr.span,\n+                |lint| {\n+                    let sp = self_expr.span;\n+\n+                    let mut lint = lint.build(&format!(\n+                        \"trait method `{}` will become ambiguous in Rust 2021\",\n+                        segment.ident.name\n+                    ));\n+\n                     let derefs = \"*\".repeat(pick.autoderefs);\n \n                     let autoref = match pick.autoref_or_ptr_adjustment {\n@@ -74,46 +84,115 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }) => \"&\",\n                         Some(probe::AutorefOrPtrAdjustment::ToConstPtr) | None => \"\",\n                     };\n-                    let self_adjusted = if let Some(probe::AutorefOrPtrAdjustment::ToConstPtr) =\n-                        pick.autoref_or_ptr_adjustment\n+                    if let Ok(self_expr) = self.sess().source_map().span_to_snippet(self_expr.span)\n                     {\n-                        format!(\"{}{} as *const _\", derefs, self_expr)\n+                        let self_adjusted = if let Some(probe::AutorefOrPtrAdjustment::ToConstPtr) =\n+                            pick.autoref_or_ptr_adjustment\n+                        {\n+                            format!(\"{}{} as *const _\", derefs, self_expr)\n+                        } else {\n+                            format!(\"{}{}{}\", autoref, derefs, self_expr)\n+                        };\n+\n+                        lint.span_suggestion(\n+                            sp,\n+                            \"disambiguate the method call\",\n+                            format!(\"({})\", self_adjusted),\n+                            Applicability::MachineApplicable,\n+                        );\n                     } else {\n-                        format!(\"{}{}{}\", autoref, derefs, self_expr)\n-                    };\n-                    let args = args\n-                        .iter()\n-                        .skip(1)\n-                        .map(|arg| {\n-                            format!(\n-                                \", {}\",\n-                                self.sess().source_map().span_to_snippet(arg.span).unwrap()\n-                            )\n-                        })\n-                        .collect::<String>();\n-\n-                    lint.span_suggestion(\n-                        sp,\n-                        \"disambiguate the associated function\",\n-                        format!(\n-                            \"{}::{}({}{})\",\n-                            trait_name, segment.ident.name, self_adjusted, args\n-                        ),\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else {\n-                    lint.span_help(\n-                        sp,\n-                        &format!(\n-                            \"disambiguate the associated function with `{}::{}(...)`\",\n-                            trait_name, segment.ident,\n-                        ),\n+                        let self_adjusted = if let Some(probe::AutorefOrPtrAdjustment::ToConstPtr) =\n+                            pick.autoref_or_ptr_adjustment\n+                        {\n+                            format!(\"{}(...) as *const _\", derefs)\n+                        } else {\n+                            format!(\"{}{}...\", autoref, derefs)\n+                        };\n+                        lint.span_help(\n+                            sp,\n+                            &format!(\"disambiguate the method call with `({})`\", self_adjusted,),\n+                        );\n+                    }\n+\n+                    lint.emit();\n+                },\n+            );\n+        } else {\n+            // trait implementations require full disambiguation to not clash with the new prelude\n+            // additions (i.e. convert from dot-call to fully-qualified call)\n+            self.tcx.struct_span_lint_hir(\n+                FUTURE_PRELUDE_COLLISION,\n+                call_expr.hir_id,\n+                call_expr.span,\n+                |lint| {\n+                    let sp = call_expr.span;\n+                    let trait_name = self.trait_path_or_bare_name(\n+                        span,\n+                        call_expr.hir_id,\n+                        pick.item.container.id(),\n                     );\n-                }\n \n-                lint.emit();\n-            },\n-        );\n+                    let mut lint = lint.build(&format!(\n+                        \"trait method `{}` will become ambiguous in Rust 2021\",\n+                        segment.ident.name\n+                    ));\n+\n+                    if let Ok(self_expr) = self.sess().source_map().span_to_snippet(self_expr.span)\n+                    {\n+                        let derefs = \"*\".repeat(pick.autoderefs);\n+\n+                        let autoref = match pick.autoref_or_ptr_adjustment {\n+                            Some(probe::AutorefOrPtrAdjustment::Autoref {\n+                                mutbl: Mutability::Mut,\n+                                ..\n+                            }) => \"&mut \",\n+                            Some(probe::AutorefOrPtrAdjustment::Autoref {\n+                                mutbl: Mutability::Not,\n+                                ..\n+                            }) => \"&\",\n+                            Some(probe::AutorefOrPtrAdjustment::ToConstPtr) | None => \"\",\n+                        };\n+                        let self_adjusted = if let Some(probe::AutorefOrPtrAdjustment::ToConstPtr) =\n+                            pick.autoref_or_ptr_adjustment\n+                        {\n+                            format!(\"{}{} as *const _\", derefs, self_expr)\n+                        } else {\n+                            format!(\"{}{}{}\", autoref, derefs, self_expr)\n+                        };\n+                        let args = args\n+                            .iter()\n+                            .skip(1)\n+                            .map(|arg| {\n+                                format!(\n+                                    \", {}\",\n+                                    self.sess().source_map().span_to_snippet(arg.span).unwrap()\n+                                )\n+                            })\n+                            .collect::<String>();\n+\n+                        lint.span_suggestion(\n+                            sp,\n+                            \"disambiguate the associated function\",\n+                            format!(\n+                                \"{}::{}({}{})\",\n+                                trait_name, segment.ident.name, self_adjusted, args\n+                            ),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    } else {\n+                        lint.span_help(\n+                            sp,\n+                            &format!(\n+                                \"disambiguate the associated function with `{}::{}(...)`\",\n+                                trait_name, segment.ident,\n+                            ),\n+                        );\n+                    }\n+\n+                    lint.emit();\n+                },\n+            );\n+        }\n     }\n \n     pub(super) fn lint_fully_qualified_call_from_2018(\n@@ -226,11 +305,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // All that is left is `_`! We need to use the full path. It doesn't matter which one we pick,\n         // so just take the first one.\n         match import_items[0].kind {\n-            ItemKind::Use(path, _) => {\n-                // FIXME: serialize path into something readable like a::b, there must be a fn for this\n-                debug!(\"no name for trait, found import of path: {:?}\", path);\n-                return None;\n-            }\n+            ItemKind::Use(path, _) => Some(\n+                path.segments\n+                    .iter()\n+                    .map(|segment| segment.ident.to_string())\n+                    .collect::<Vec<_>>()\n+                    .join(\"::\"),\n+            ),\n             _ => {\n                 span_bug!(span, \"unexpected item kind, expected a use: {:?}\", import_items[0].kind);\n             }"}, {"sha": "4f8fd9b345b2821cac490016138656e986e4b612", "filename": "src/test/ui/rust-2021/future-prelude-collision-imported.fixed", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b18704dd58047e0ade59a425740b8a41ba1bd14b/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-imported.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b18704dd58047e0ade59a425740b8a41ba1bd14b/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-imported.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-imported.fixed?ref=b18704dd58047e0ade59a425740b8a41ba1bd14b", "patch": "@@ -0,0 +1,59 @@\n+// run-rustfix\n+// edition:2018\n+// check-pass\n+#![warn(future_prelude_collision)]\n+#![allow(dead_code)]\n+#![allow(unused_imports)]\n+\n+mod m {\n+    pub trait TryIntoU32 {\n+        fn try_into(self) -> Result<u32, ()>;\n+    }\n+\n+    impl TryIntoU32 for u8 {\n+        fn try_into(self) -> Result<u32, ()> {\n+            Ok(self as u32)\n+        }\n+    }\n+\n+    pub trait AnotherTrick {}\n+}\n+\n+mod a {\n+    use crate::m::TryIntoU32;\n+\n+    fn main() {\n+        // In this case, we can just use `TryIntoU32`\n+        let _: u32 = TryIntoU32::try_into(3u8).unwrap();\n+        //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+        //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+    }\n+}\n+\n+mod b {\n+    use crate::m::AnotherTrick as TryIntoU32;\n+    use crate::m::TryIntoU32 as _;\n+\n+    fn main() {\n+        // In this case, a `TryIntoU32::try_into` rewrite will not work, and we need to use\n+        // the path `crate::m::TryIntoU32` (with which it was imported).\n+        let _: u32 = crate::m::TryIntoU32::try_into(3u8).unwrap();\n+        //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+        //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+    }\n+}\n+\n+mod c {\n+    use super::m::TryIntoU32 as _;\n+    use crate::m::AnotherTrick as TryIntoU32;\n+\n+    fn main() {\n+        // In this case, a `TryIntoU32::try_into` rewrite will not work, and we need to use\n+        // the path `super::m::TryIntoU32` (with which it was imported).\n+        let _: u32 = super::m::TryIntoU32::try_into(3u8).unwrap();\n+        //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+        //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2ce1be6151b11759bb30825c2acd6ee614681edc", "filename": "src/test/ui/rust-2021/future-prelude-collision-imported.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b18704dd58047e0ade59a425740b8a41ba1bd14b/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-imported.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b18704dd58047e0ade59a425740b8a41ba1bd14b/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-imported.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-imported.rs?ref=b18704dd58047e0ade59a425740b8a41ba1bd14b", "patch": "@@ -3,6 +3,7 @@\n // check-pass\n #![warn(future_prelude_collision)]\n #![allow(dead_code)]\n+#![allow(unused_imports)]\n \n mod m {\n     pub trait TryIntoU32 {\n@@ -24,6 +25,8 @@ mod a {\n     fn main() {\n         // In this case, we can just use `TryIntoU32`\n         let _: u32 = 3u8.try_into().unwrap();\n+        //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+        //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n     }\n }\n \n@@ -35,6 +38,8 @@ mod b {\n         // In this case, a `TryIntoU32::try_into` rewrite will not work, and we need to use\n         // the path `crate::m::TryIntoU32` (with which it was imported).\n         let _: u32 = 3u8.try_into().unwrap();\n+        //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+        //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n     }\n }\n \n@@ -46,6 +51,8 @@ mod c {\n         // In this case, a `TryIntoU32::try_into` rewrite will not work, and we need to use\n         // the path `super::m::TryIntoU32` (with which it was imported).\n         let _: u32 = 3u8.try_into().unwrap();\n+        //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+        //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n     }\n }\n "}, {"sha": "3903cbfe824904445ccc97d4e0c4b7d4a6269e1d", "filename": "src/test/ui/rust-2021/future-prelude-collision-imported.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b18704dd58047e0ade59a425740b8a41ba1bd14b/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-imported.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b18704dd58047e0ade59a425740b8a41ba1bd14b/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-imported.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-imported.stderr?ref=b18704dd58047e0ade59a425740b8a41ba1bd14b", "patch": "@@ -0,0 +1,34 @@\n+warning: trait method `try_into` will become ambiguous in Rust 2021\n+  --> $DIR/future-prelude-collision-imported.rs:27:22\n+   |\n+LL |         let _: u32 = 3u8.try_into().unwrap();\n+   |                      ^^^^^^^^^^^^^^ help: disambiguate the associated function: `TryIntoU32::try_into(3u8)`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/future-prelude-collision-imported.rs:4:9\n+   |\n+LL | #![warn(future_prelude_collision)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+   = note: for more information, see issue #85684 <https://github.com/rust-lang/rust/issues/85684>\n+\n+warning: trait method `try_into` will become ambiguous in Rust 2021\n+  --> $DIR/future-prelude-collision-imported.rs:40:22\n+   |\n+LL |         let _: u32 = 3u8.try_into().unwrap();\n+   |                      ^^^^^^^^^^^^^^ help: disambiguate the associated function: `crate::m::TryIntoU32::try_into(3u8)`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+   = note: for more information, see issue #85684 <https://github.com/rust-lang/rust/issues/85684>\n+\n+warning: trait method `try_into` will become ambiguous in Rust 2021\n+  --> $DIR/future-prelude-collision-imported.rs:53:22\n+   |\n+LL |         let _: u32 = 3u8.try_into().unwrap();\n+   |                      ^^^^^^^^^^^^^^ help: disambiguate the associated function: `super::m::TryIntoU32::try_into(3u8)`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+   = note: for more information, see issue #85684 <https://github.com/rust-lang/rust/issues/85684>\n+\n+warning: 3 warnings emitted\n+"}, {"sha": "588ab6255fa5cb9e649968bb13976b434ca89b4d", "filename": "src/test/ui/rust-2021/future-prelude-collision-shadow.fixed", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b18704dd58047e0ade59a425740b8a41ba1bd14b/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-shadow.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b18704dd58047e0ade59a425740b8a41ba1bd14b/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-shadow.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-shadow.fixed?ref=b18704dd58047e0ade59a425740b8a41ba1bd14b", "patch": "@@ -0,0 +1,33 @@\n+// run-rustfix\n+// edition:2018\n+#![warn(future_prelude_collision)]\n+#![allow(dead_code)]\n+#![allow(unused_imports)]\n+\n+mod m {\n+    pub trait TryIntoU32 {\n+        fn try_into(self) -> Result<u32, ()>;\n+    }\n+\n+    impl TryIntoU32 for u8 {\n+        fn try_into(self) -> Result<u32, ()> {\n+            Ok(self as u32)\n+        }\n+    }\n+\n+    pub trait AnotherTrick {}\n+}\n+\n+mod d {\n+    use crate::m::AnotherTrick as TryIntoU32;\n+    use crate::m::*;\n+\n+    fn main() {\n+        // Here, `TryIntoU32` is imported but shadowed, but in that case we don't permit its methods\n+        // to be available.\n+        let _: u32 = 3u8.try_into().unwrap();\n+        //~^ ERROR no method named `try_into` found for type `u8` in the current scope\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "588ab6255fa5cb9e649968bb13976b434ca89b4d", "filename": "src/test/ui/rust-2021/future-prelude-collision-shadow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b18704dd58047e0ade59a425740b8a41ba1bd14b/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b18704dd58047e0ade59a425740b8a41ba1bd14b/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-shadow.rs?ref=b18704dd58047e0ade59a425740b8a41ba1bd14b", "patch": "@@ -1,8 +1,8 @@\n // run-rustfix\n // edition:2018\n-// check-pass\n #![warn(future_prelude_collision)]\n #![allow(dead_code)]\n+#![allow(unused_imports)]\n \n mod m {\n     pub trait TryIntoU32 {\n@@ -26,7 +26,7 @@ mod d {\n         // Here, `TryIntoU32` is imported but shadowed, but in that case we don't permit its methods\n         // to be available.\n         let _: u32 = 3u8.try_into().unwrap();\n-        //~^ ERROR no method name `try_into` found\n+        //~^ ERROR no method named `try_into` found for type `u8` in the current scope\n     }\n }\n "}, {"sha": "3019b2aa5e2102124adb4175c7acab2a3a339a27", "filename": "src/test/ui/rust-2021/future-prelude-collision-shadow.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b18704dd58047e0ade59a425740b8a41ba1bd14b/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-shadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b18704dd58047e0ade59a425740b8a41ba1bd14b/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-shadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-shadow.stderr?ref=b18704dd58047e0ade59a425740b8a41ba1bd14b", "patch": "@@ -0,0 +1,40 @@\n+error[E0599]: no method named `try_into` found for type `u8` in the current scope\n+  --> $DIR/future-prelude-collision-shadow.rs:28:26\n+   |\n+LL |         let _: u32 = 3u8.try_into().unwrap();\n+   |                          ^^^^^^^^ method not found in `u8`\n+   | \n+  ::: $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+   |\n+LL |     fn try_into(self) -> Result<T, Self::Error>;\n+   |        --------\n+   |        |\n+   |        the method is available for `Box<u8>` here\n+   |        the method is available for `Pin<u8>` here\n+   |        the method is available for `Arc<u8>` here\n+   |        the method is available for `Rc<u8>` here\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+   = note: the following traits are implemented but not in scope; perhaps add a `use` for one of them:\n+           candidate #1: `use crate::m::TryIntoU32;`\n+           candidate #2: `use std::convert::TryInto;`\n+help: consider wrapping the receiver expression with the appropriate type\n+   |\n+LL |         let _: u32 = Box::new(3u8).try_into().unwrap();\n+   |                      ^^^^^^^^^   ^\n+help: consider wrapping the receiver expression with the appropriate type\n+   |\n+LL |         let _: u32 = Pin::new(3u8).try_into().unwrap();\n+   |                      ^^^^^^^^^   ^\n+help: consider wrapping the receiver expression with the appropriate type\n+   |\n+LL |         let _: u32 = Arc::new(3u8).try_into().unwrap();\n+   |                      ^^^^^^^^^   ^\n+help: consider wrapping the receiver expression with the appropriate type\n+   |\n+LL |         let _: u32 = Rc::new(3u8).try_into().unwrap();\n+   |                      ^^^^^^^^   ^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}]}