{"sha": "0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNmEwYjU4ZjlkYmMzYTc0MWFiZDg5OGYyZDA2YThiYTc4YTkzOGQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-06T02:23:57Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-10T22:08:31Z"}, "message": "std: Stabilize more of the `char` module\n\nThis commit performs another pass over the `std::char` module for stabilization.\nSome minor cleanup is performed such as migrating documentation from libcore to\nlibunicode (where the `std`-facing trait resides) as well as a slight\nreorganiation in libunicode itself. Otherwise, the stability modifications made\nare:\n\n* `char::from_digit` is now stable\n* `CharExt::is_digit` is now stable\n* `CharExt::to_digit` is now stable\n* `CharExt::to_{lower,upper}case` are now stable after being modified to return\n  an iterator over characters. While the implementation today has not changed\n  this should allow us to implement the full set of case conversions in unicode\n  where some characters can map to multiple when doing an upper or lower case\n  mapping.\n* `StrExt::to_{lower,upper}case` was added as unstable for a convenience of not\n  having to worry about characters expanding to more characters when you just\n  want the whole string to get into upper or lower case.\n\nThis is a breaking change due to the change in the signatures of the\n`CharExt::to_{upper,lower}case` methods. Code can be updated to use functions\nlike `flat_map` or `collect` to handle the difference.\n\n[breaking-change]", "tree": {"sha": "645a80f459c7da59405fc2dc8874a954b4aeb007", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/645a80f459c7da59405fc2dc8874a954b4aeb007"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d", "html_url": "https://github.com/rust-lang/rust/commit/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2574009af0ff70dc233beab246db8f2d715be2cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/2574009af0ff70dc233beab246db8f2d715be2cb", "html_url": "https://github.com/rust-lang/rust/commit/2574009af0ff70dc233beab246db8f2d715be2cb"}], "stats": {"total": 722, "additions": 333, "deletions": 389}, "files": [{"sha": "7348c85aa82ddc1a5a431b92b8a11c3367edc061", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d", "patch": "@@ -19,7 +19,6 @@\n #![feature(unboxed_closures)]\n #![feature(std_misc)]\n #![feature(test)]\n-#![feature(unicode)]\n #![feature(core)]\n #![feature(path)]\n #![feature(io)]"}, {"sha": "2b0e7985229e2bd85e81ba97b5a0b8c05b52dc35", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d", "patch": "@@ -71,7 +71,7 @@ fn parse_expected(last_nonfollow_error: Option<uint>,\n     let letters = line[kind_start..].chars();\n     let kind = letters.skip_while(|c| c.is_whitespace())\n                       .take_while(|c| !c.is_whitespace())\n-                      .map(|c| c.to_lowercase())\n+                      .flat_map(|c| c.to_lowercase())\n                       .collect::<String>();\n     let letters = line[kind_start..].chars();\n     let msg = letters.skip_while(|c| c.is_whitespace())"}, {"sha": "9dd5e2dd9bc028c9c209c8d8a6781ae9fd3b5281", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 55, "deletions": 24, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d", "patch": "@@ -12,13 +12,14 @@\n \n //! Unicode string manipulation (the [`str`](../primitive.str.html) type).\n //!\n-//! Rust's [`str`](../primitive.str.html) type is one of the core primitive types of the\n-//! language. `&str` is the borrowed string type. This type of string can only be created\n-//! from other strings, unless it is a `&'static str` (see below). It is not possible to\n-//! move out of borrowed strings because they are owned elsewhere.\n+//! Rust's [`str`](../primitive.str.html) type is one of the core primitive\n+//! types of the language. `&str` is the borrowed string type. This type of\n+//! string can only be created from other strings, unless it is a `&'static str`\n+//! (see below). It is not possible to move out of borrowed strings because they\n+//! are owned elsewhere.\n //!\n-//! Basic operations are implemented directly by the compiler, but more advanced operations are\n-//! defined on the [`StrExt`](trait.StrExt.html) trait.\n+//! Basic operations are implemented directly by the compiler, but more advanced\n+//! operations are defined on the [`StrExt`](trait.StrExt.html) trait.\n //!\n //! # Examples\n //!\n@@ -28,8 +29,9 @@\n //! let s = \"Hello, world.\";\n //! ```\n //!\n-//! This `&str` is a `&'static str`, which is the type of string literals. They're `'static`\n-//! because literals are available for the entire lifetime of the program.\n+//! This `&str` is a `&'static str`, which is the type of string literals.\n+//! They're `'static` because literals are available for the entire lifetime of\n+//! the program.\n //!\n //! You can get a non-`'static` `&str` by taking a slice of a `String`:\n //!\n@@ -40,29 +42,30 @@\n //!\n //! # Representation\n //!\n-//! Rust's string type, `str`, is a sequence of Unicode scalar values encoded as a stream of UTF-8\n-//! bytes. All [strings](../../reference.html#literals) are guaranteed to be validly encoded UTF-8\n-//! sequences. Additionally, strings are not null-terminated and can thus contain null bytes.\n+//! Rust's string type, `str`, is a sequence of Unicode scalar values encoded as\n+//! a stream of UTF-8 bytes. All [strings](../../reference.html#literals) are\n+//! guaranteed to be validly encoded UTF-8 sequences. Additionally, strings are\n+//! not null-terminated and can thus contain null bytes.\n //!\n-//! The actual representation of `str`s have direct mappings to slices: `&str` is the same as\n-//! `&[u8]`.\n+//! The actual representation of `str`s have direct mappings to slices: `&str`\n+//! is the same as `&[u8]`.\n \n #![doc(primitive = \"str\")]\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::RecompositionState::*;\n use self::DecompositionType::*;\n \n-use core::char::CharExt;\n use core::clone::Clone;\n use core::iter::AdditiveIterator;\n-use core::iter::{Iterator, IteratorExt};\n+use core::iter::{Iterator, IteratorExt, Extend};\n use core::ops::Index;\n use core::ops::RangeFull;\n use core::option::Option::{self, Some, None};\n use core::result::Result;\n use core::slice::AsSlice;\n use core::str as core_str;\n+use unicode::char::CharExt;\n use unicode::str::{UnicodeStr, Utf16Encoder};\n \n use vec_deque::VecDeque;\n@@ -836,17 +839,19 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n \n     /// Returns a slice of the string from the character range [`begin`..`end`).\n     ///\n-    /// That is, start at the `begin`-th code point of the string and continue to the `end`-th code\n-    /// point. This does not detect or handle edge cases such as leaving a combining character as\n-    /// the first code point of the string.\n+    /// That is, start at the `begin`-th code point of the string and continue\n+    /// to the `end`-th code point. This does not detect or handle edge cases\n+    /// such as leaving a combining character as the first code point of the\n+    /// string.\n     ///\n-    /// Due to the design of UTF-8, this operation is `O(end)`. See `slice`, `slice_to` and\n-    /// `slice_from` for `O(1)` variants that use byte indices rather than code point indices.\n+    /// Due to the design of UTF-8, this operation is `O(end)`. See `slice`,\n+    /// `slice_to` and `slice_from` for `O(1)` variants that use byte indices\n+    /// rather than code point indices.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `begin` > `end` or the either `begin` or `end` are beyond the last character of\n-    /// the string.\n+    /// Panics if `begin` > `end` or the either `begin` or `end` are beyond the\n+    /// last character of the string.\n     ///\n     /// # Examples\n     ///\n@@ -868,8 +873,8 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// # Unsafety\n     ///\n-    /// Caller must check both UTF-8 character boundaries and the boundaries of the entire slice as\n-    /// well.\n+    /// Caller must check both UTF-8 character boundaries and the boundaries of\n+    /// the entire slice as well.\n     ///\n     /// # Examples\n     ///\n@@ -1506,6 +1511,32 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     fn trim_right(&self) -> &str {\n         UnicodeStr::trim_right(&self[..])\n     }\n+\n+    /// Returns the lowercase equivalent of this string.\n+    ///\n+    /// # Examples\n+    ///\n+    /// let s = \"HELLO\";\n+    /// assert_eq!(s.to_lowercase(), \"hello\");\n+    #[unstable(feature = \"collections\")]\n+    fn to_lowercase(&self) -> String {\n+        let mut s = String::with_capacity(self.len());\n+        s.extend(self[..].chars().flat_map(|c| c.to_lowercase()));\n+        return s;\n+    }\n+\n+    /// Returns the uppercase equivalent of this string.\n+    ///\n+    /// # Examples\n+    ///\n+    /// let s = \"hello\";\n+    /// assert_eq!(s.to_uppercase(), \"HELLO\");\n+    #[unstable(feature = \"collections\")]\n+    fn to_uppercase(&self) -> String {\n+        let mut s = String::with_capacity(self.len());\n+        s.extend(self[..].chars().flat_map(|c| c.to_uppercase()));\n+        return s;\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "010415b364aa04a75506c86f7d6d82a83e3d0602", "filename": "src/libcore/char.rs", "status": "modified", "additions": 4, "deletions": 221, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d", "patch": "@@ -118,7 +118,7 @@ pub fn from_u32(i: u32) -> Option<char> {\n /// assert_eq!(c, Some('4'));\n /// ```\n #[inline]\n-#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_digit(num: u32, radix: u32) -> Option<char> {\n     if radix > 36 {\n         panic!(\"from_digit: radix is too high (maximum 36)\");\n@@ -136,230 +136,25 @@ pub fn from_digit(num: u32, radix: u32) -> Option<char> {\n     }\n }\n \n-/// Basic `char` manipulations.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+// NB: the stabilization and documentation for this trait is in\n+// unicode/char.rs, not here\n+#[allow(missing_docs)] // docs in libunicode/u_char.rs\n pub trait CharExt {\n-    /// Checks if a `char` parses as a numeric digit in the given radix.\n-    ///\n-    /// Compared to `is_numeric()`, this function only recognizes the characters\n-    /// `0-9`, `a-z` and `A-Z`.\n-    ///\n-    /// # Return value\n-    ///\n-    /// Returns `true` if `c` is a valid digit under `radix`, and `false`\n-    /// otherwise.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if given a radix > 36.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let c = '1';\n-    ///\n-    /// assert!(c.is_digit(10));\n-    ///\n-    /// assert!('f'.is_digit(16));\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n     fn is_digit(self, radix: u32) -> bool;\n-\n-    /// Converts a character to the corresponding digit.\n-    ///\n-    /// # Return value\n-    ///\n-    /// If `c` is between '0' and '9', the corresponding value between 0 and\n-    /// 9. If `c` is 'a' or 'A', 10. If `c` is 'b' or 'B', 11, etc. Returns\n-    /// none if the character does not refer to a digit in the given radix.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if given a radix outside the range [0..36].\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let c = '1';\n-    ///\n-    /// assert_eq!(c.to_digit(10), Some(1));\n-    ///\n-    /// assert_eq!('f'.to_digit(16), Some(15));\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n     fn to_digit(self, radix: u32) -> Option<u32>;\n-\n-    /// Returns an iterator that yields the hexadecimal Unicode escape of a character, as `char`s.\n-    ///\n-    /// All characters are escaped with Rust syntax of the form `\\\\u{NNNN}` where `NNNN` is the\n-    /// shortest hexadecimal representation of the code point.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// for i in '\u2764'.escape_unicode() {\n-    ///     println!(\"{}\", i);\n-    /// }\n-    /// ```\n-    ///\n-    /// This prints:\n-    ///\n-    /// ```text\n-    /// \\\n-    /// u\n-    /// {\n-    /// 2\n-    /// 7\n-    /// 6\n-    /// 4\n-    /// }\n-    /// ```\n-    ///\n-    /// Collecting into a `String`:\n-    ///\n-    /// ```\n-    /// let heart: String = '\u2764'.escape_unicode().collect();\n-    ///\n-    /// assert_eq!(heart, r\"\\u{2764}\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_unicode(self) -> EscapeUnicode;\n-\n-    /// Returns an iterator that yields the 'default' ASCII and\n-    /// C++11-like literal escape of a character, as `char`s.\n-    ///\n-    /// The default is chosen with a bias toward producing literals that are\n-    /// legal in a variety of languages, including C++11 and similar C-family\n-    /// languages. The exact rules are:\n-    ///\n-    /// * Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n-    /// * Single-quote, double-quote and backslash chars are backslash-\n-    ///   escaped.\n-    /// * Any other chars in the range [0x20,0x7e] are not escaped.\n-    /// * Any other chars are given hex Unicode escapes; see `escape_unicode`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// for i in '\"'.escape_default() {\n-    ///     println!(\"{}\", i);\n-    /// }\n-    /// ```\n-    ///\n-    /// This prints:\n-    ///\n-    /// ```text\n-    /// \\\n-    /// \"\n-    /// ```\n-    ///\n-    /// Collecting into a `String`:\n-    ///\n-    /// ```\n-    /// let quote: String = '\"'.escape_default().collect();\n-    ///\n-    /// assert_eq!(quote, \"\\\\\\\"\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_default(self) -> EscapeDefault;\n-\n-    /// Returns the number of bytes this character would need if encoded in UTF-8.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let n = '\u00df'.len_utf8();\n-    ///\n-    /// assert_eq!(n, 2);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf8(self) -> usize;\n-\n-    /// Returns the number of bytes this character would need if encoded in UTF-16.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let n = '\u00df'.len_utf16();\n-    ///\n-    /// assert_eq!(n, 1);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf16(self) -> usize;\n-\n-    /// Encodes this character as UTF-8 into the provided byte buffer, and then returns the number\n-    /// of bytes written.\n-    ///\n-    /// If the buffer is not large enough, nothing will be written into it and a `None` will be\n-    /// returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// In both of these examples, '\u00df' takes two bytes to encode.\n-    ///\n-    /// ```\n-    /// let mut b = [0; 2];\n-    ///\n-    /// let result = '\u00df'.encode_utf8(&mut b);\n-    ///\n-    /// assert_eq!(result, Some(2));\n-    /// ```\n-    ///\n-    /// A buffer that's too small:\n-    ///\n-    /// ```\n-    /// let mut b = [0; 1];\n-    ///\n-    /// let result = '\u00df'.encode_utf8(&mut b);\n-    ///\n-    /// assert_eq!(result, None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn encode_utf8(self, dst: &mut [u8]) -> Option<usize>;\n-\n-    /// Encodes this character as UTF-16 into the provided `u16` buffer, and then returns the\n-    /// number of `u16`s written.\n-    ///\n-    /// If the buffer is not large enough, nothing will be written into it and a `None` will be\n-    /// returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// In both of these examples, '\u00df' takes one byte to encode.\n-    ///\n-    /// ```\n-    /// let mut b = [0; 1];\n-    ///\n-    /// let result = '\u00df'.encode_utf16(&mut b);\n-    ///\n-    /// assert_eq!(result, Some(1));\n-    /// ```\n-    ///\n-    /// A buffer that's too small:\n-    ///\n-    /// ```\n-    /// let mut b = [0; 0];\n-    ///\n-    /// let result = '\u00df'.encode_utf8(&mut b);\n-    ///\n-    /// assert_eq!(result, None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn encode_utf16(self, dst: &mut [u16]) -> Option<usize>;\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl CharExt for char {\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n     fn is_digit(self, radix: u32) -> bool {\n         self.to_digit(radix).is_some()\n     }\n \n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n     fn to_digit(self, radix: u32) -> Option<u32> {\n         if radix > 36 {\n             panic!(\"to_digit: radix is too high (maximum 36)\");\n@@ -374,12 +169,10 @@ impl CharExt for char {\n         else { None }\n     }\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_unicode(self) -> EscapeUnicode {\n         EscapeUnicode { c: self, state: EscapeUnicodeState::Backslash }\n     }\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_default(self) -> EscapeDefault {\n         let init_state = match self {\n             '\\t' => EscapeDefaultState::Backslash('t'),\n@@ -395,7 +188,6 @@ impl CharExt for char {\n     }\n \n     #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf8(self) -> usize {\n         let code = self as u32;\n         if code < MAX_ONE_B {\n@@ -410,22 +202,17 @@ impl CharExt for char {\n     }\n \n     #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf16(self) -> usize {\n         let ch = self as u32;\n         if (ch & 0xFFFF) == ch { 1 } else { 2 }\n     }\n \n     #[inline]\n-    #[unstable(feature = \"core\",\n-               reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf8(self, dst: &mut [u8]) -> Option<usize> {\n         encode_utf8_raw(self as u32, dst)\n     }\n \n     #[inline]\n-    #[unstable(feature = \"core\",\n-               reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf16(self, dst: &mut [u16]) -> Option<usize> {\n         encode_utf16_raw(self as u32, dst)\n     }\n@@ -437,7 +224,6 @@ impl CharExt for char {\n /// If the buffer is not large enough, nothing will be written into it\n /// and a `None` will be returned.\n #[inline]\n-#[unstable(feature = \"core\")]\n pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<usize> {\n     // Marked #[inline] to allow llvm optimizing it away\n     if code < MAX_ONE_B && dst.len() >= 1 {\n@@ -469,7 +255,6 @@ pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<usize> {\n /// If the buffer is not large enough, nothing will be written into it\n /// and a `None` will be returned.\n #[inline]\n-#[unstable(feature = \"core\")]\n pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<usize> {\n     // Marked #[inline] to allow llvm optimizing it away\n     if (ch & 0xFFFF) == ch  && dst.len() >= 1 {\n@@ -497,7 +282,6 @@ pub struct EscapeUnicode {\n }\n \n #[derive(Clone)]\n-#[unstable(feature = \"core\")]\n enum EscapeUnicodeState {\n     Backslash,\n     Type,\n@@ -559,7 +343,6 @@ pub struct EscapeDefault {\n }\n \n #[derive(Clone)]\n-#[unstable(feature = \"core\")]\n enum EscapeDefaultState {\n     Backslash(char),\n     Char(char),"}, {"sha": "65e941d160d0453d0fce8e837c2c1dda14f12c41", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d", "patch": "@@ -57,35 +57,47 @@ fn test_to_digit() {\n \n #[test]\n fn test_to_lowercase() {\n-    assert_eq!('A'.to_lowercase(), 'a');\n-    assert_eq!('\u00d6'.to_lowercase(), '\u00f6');\n-    assert_eq!('\u00df'.to_lowercase(), '\u00df');\n-    assert_eq!('\u00dc'.to_lowercase(), '\u00fc');\n-    assert_eq!('\ud83d\udca9'.to_lowercase(), '\ud83d\udca9');\n-    assert_eq!('\u03a3'.to_lowercase(), '\u03c3');\n-    assert_eq!('\u03a4'.to_lowercase(), '\u03c4');\n-    assert_eq!('\u0399'.to_lowercase(), '\u03b9');\n-    assert_eq!('\u0393'.to_lowercase(), '\u03b3');\n-    assert_eq!('\u039c'.to_lowercase(), '\u03bc');\n-    assert_eq!('\u0391'.to_lowercase(), '\u03b1');\n-    assert_eq!('\u03a3'.to_lowercase(), '\u03c3');\n+    fn lower(c: char) -> char {\n+        let mut it = c.to_lowercase();\n+        let c = it.next().unwrap();\n+        assert!(it.next().is_none());\n+        c\n+    }\n+    assert_eq!(lower('A'), 'a');\n+    assert_eq!(lower('\u00d6'), '\u00f6');\n+    assert_eq!(lower('\u00df'), '\u00df');\n+    assert_eq!(lower('\u00dc'), '\u00fc');\n+    assert_eq!(lower('\ud83d\udca9'), '\ud83d\udca9');\n+    assert_eq!(lower('\u03a3'), '\u03c3');\n+    assert_eq!(lower('\u03a4'), '\u03c4');\n+    assert_eq!(lower('\u0399'), '\u03b9');\n+    assert_eq!(lower('\u0393'), '\u03b3');\n+    assert_eq!(lower('\u039c'), '\u03bc');\n+    assert_eq!(lower('\u0391'), '\u03b1');\n+    assert_eq!(lower('\u03a3'), '\u03c3');\n }\n \n #[test]\n fn test_to_uppercase() {\n-    assert_eq!('a'.to_uppercase(), 'A');\n-    assert_eq!('\u00f6'.to_uppercase(), '\u00d6');\n-    assert_eq!('\u00df'.to_uppercase(), '\u00df'); // not \u1e9e: Latin capital letter sharp s\n-    assert_eq!('\u00fc'.to_uppercase(), '\u00dc');\n-    assert_eq!('\ud83d\udca9'.to_uppercase(), '\ud83d\udca9');\n-\n-    assert_eq!('\u03c3'.to_uppercase(), '\u03a3');\n-    assert_eq!('\u03c4'.to_uppercase(), '\u03a4');\n-    assert_eq!('\u03b9'.to_uppercase(), '\u0399');\n-    assert_eq!('\u03b3'.to_uppercase(), '\u0393');\n-    assert_eq!('\u03bc'.to_uppercase(), '\u039c');\n-    assert_eq!('\u03b1'.to_uppercase(), '\u0391');\n-    assert_eq!('\u03c2'.to_uppercase(), '\u03a3');\n+    fn upper(c: char) -> char {\n+        let mut it = c.to_uppercase();\n+        let c = it.next().unwrap();\n+        assert!(it.next().is_none());\n+        c\n+    }\n+    assert_eq!(upper('a'), 'A');\n+    assert_eq!(upper('\u00f6'), '\u00d6');\n+    assert_eq!(upper('\u00df'), '\u00df'); // not \u1e9e: Latin capital letter sharp s\n+    assert_eq!(upper('\u00fc'), '\u00dc');\n+    assert_eq!(upper('\ud83d\udca9'), '\ud83d\udca9');\n+\n+    assert_eq!(upper('\u03c3'), '\u03a3');\n+    assert_eq!(upper('\u03c4'), '\u03a4');\n+    assert_eq!(upper('\u03b9'), '\u0399');\n+    assert_eq!(upper('\u03b3'), '\u0393');\n+    assert_eq!(upper('\u03bc'), '\u039c');\n+    assert_eq!(upper('\u03b1'), '\u0391');\n+    assert_eq!(upper('\u03c2'), '\u03a3');\n }\n \n #[test]"}, {"sha": "716b1116a2062aba42f2a9ccbc9a0304398f341d", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d", "patch": "@@ -36,7 +36,6 @@\n #![feature(rustc_private)]\n #![feature(unsafe_destructor)]\n #![feature(staged_api)]\n-#![feature(unicode)]\n #![feature(exit_status)]\n #![feature(path)]\n #![feature(io)]\n@@ -618,8 +617,7 @@ Available lint options:\n \n     let print_lint_groups = |lints: Vec<(&'static str, Vec<lint::LintId>)>| {\n         for (name, to) in lints {\n-            let name = name.chars().map(|x| x.to_lowercase())\n-                           .collect::<String>().replace(\"_\", \"-\");\n+            let name = name.to_lowercase().replace(\"_\", \"-\");\n             let desc = to.into_iter().map(|x| x.as_str().replace(\"_\", \"-\"))\n                          .collect::<Vec<String>>().connect(\", \");\n             println!(\"    {}  {}\","}, {"sha": "7e4d3e3ca5952b14599497d020f4f6f09e1d1f04", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d", "patch": "@@ -810,11 +810,11 @@ impl NonCamelCaseTypes {\n         fn to_camel_case(s: &str) -> String {\n             s.split('_').flat_map(|word| word.chars().enumerate().map(|(i, c)|\n                 if i == 0 {\n-                    c.to_uppercase()\n+                    c.to_uppercase().collect::<String>()\n                 } else {\n-                    c\n+                    c.to_string()\n                 }\n-            )).collect()\n+            )).collect::<Vec<_>>().concat()\n         }\n \n         let s = token::get_ident(ident);\n@@ -947,7 +947,7 @@ impl NonSnakeCase {\n                     buf = String::new();\n                 }\n                 last_upper = ch.is_uppercase();\n-                buf.push(ch.to_lowercase());\n+                buf.extend(ch.to_lowercase());\n             }\n             words.push(buf);\n         }\n@@ -1064,8 +1064,7 @@ impl NonUpperCaseGlobals {\n         let s = token::get_ident(ident);\n \n         if s.chars().any(|c| c.is_lowercase()) {\n-            let uc: String = NonSnakeCase::to_snake_case(&s).chars()\n-                                           .map(|c| c.to_uppercase()).collect();\n+            let uc = NonSnakeCase::to_snake_case(&s).to_uppercase();\n             if uc != &s[..] {\n                 cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n                     &format!(\"{} `{}` should have an upper case name such as `{}`\","}, {"sha": "a49c9db07a0e948fa1b5cb0dac286d3d517256e3", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d", "patch": "@@ -41,7 +41,6 @@\n #![feature(unsafe_destructor)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n-#![feature(unicode)]\n #![cfg_attr(test, feature(test))]\n \n extern crate syntax;"}, {"sha": "f2042b384ceea3cce97d5f0ea877e87a5eab6e8f", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d", "patch": "@@ -343,8 +343,7 @@ impl IoError {\n     pub fn from_errno(errno: i32, detail: bool) -> IoError {\n         let mut err = sys::decode_error(errno as i32);\n         if detail && err.kind == OtherIoError {\n-            err.detail = Some(os::error_string(errno).chars()\n-                                 .map(|c| c.to_lowercase()).collect())\n+            err.detail = Some(os::error_string(errno).to_lowercase());\n         }\n         err\n     }"}, {"sha": "a30dcd9d9f0ab72ce9a8f927b58d5847564d9d3a", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d", "patch": "@@ -110,10 +110,11 @@ struct EnvKey(CString);\n #[cfg(windows)]\n impl hash::Hash for EnvKey {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        use ascii::AsciiExt;\n         let &EnvKey(ref x) = self;\n         match str::from_utf8(x.as_bytes()) {\n             Ok(s) => for ch in s.chars() {\n-                (ch as u8 as char).to_lowercase().hash(state);\n+                ch.to_ascii_lowercase().hash(state);\n             },\n             Err(..) => x.hash(state)\n         }\n@@ -123,6 +124,7 @@ impl hash::Hash for EnvKey {\n #[cfg(windows)]\n impl PartialEq for EnvKey {\n     fn eq(&self, other: &EnvKey) -> bool {\n+        use ascii::AsciiExt;\n         let &EnvKey(ref x) = self;\n         let &EnvKey(ref y) = other;\n         match (str::from_utf8(x.as_bytes()), str::from_utf8(y.as_bytes())) {\n@@ -131,7 +133,7 @@ impl PartialEq for EnvKey {\n                     return false\n                 } else {\n                     for (xch, ych) in xs.chars().zip(ys.chars()) {\n-                        if xch.to_lowercase() != ych.to_lowercase() {\n+                        if xch.to_ascii_lowercase() != ych.to_ascii_lowercase() {\n                             return false;\n                         }\n                     }"}, {"sha": "d3be5b5683063aa7957124f34e5bf58edb8d3699", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d", "patch": "@@ -61,7 +61,6 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n-#![feature(unicode)]\n #![feature(path_ext)]\n #![cfg_attr(windows, feature(libc))]\n "}, {"sha": "bcc2820e381ac649b723babf7ca631c57c05b233", "filename": "src/libunicode/char.rs", "status": "renamed", "additions": 223, "deletions": 71, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibunicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibunicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fchar.rs?ref=0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d", "patch": "@@ -8,16 +8,39 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Unicode-intensive `char` methods along with the `core` methods.\n+//! Character manipulation (`char` type, Unicode Scalar Value)\n //!\n-//! These methods implement functionality for `char` that requires knowledge of\n-//! Unicode definitions, including normalization, categorization, and display information.\n+//! This module provides the `CharExt` trait, as well as its\n+//! implementation for the primitive `char` type, in order to allow\n+//! basic character manipulation.\n+//!\n+//! A `char` actually represents a\n+//! *[Unicode Scalar\n+//! Value](http://www.unicode.org/glossary/#unicode_scalar_value)*, as it can\n+//! contain any Unicode code point except high-surrogate and low-surrogate code\n+//! points.\n+//!\n+//! As such, only values in the ranges \\[0x0,0xD7FF\\] and \\[0xE000,0x10FFFF\\]\n+//! (inclusive) are allowed. A `char` can always be safely cast to a `u32`;\n+//! however the converse is not always true due to the above range limits\n+//! and, as such, should be performed via the `from_u32` function.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![doc(primitive = \"char\")]\n \n-use core::char;\n use core::char::CharExt as C;\n-use core::option::Option;\n+use core::option::Option::{self, Some};\n+use core::iter::Iterator;\n use tables::{derived_property, property, general_category, conversions, charwidth};\n \n+// stable reexports\n+pub use core::char::{MAX, from_u32, from_digit, EscapeUnicode, EscapeDefault};\n+\n+// unstable reexports\n+pub use normalize::{decompose_canonical, decompose_compatible, compose};\n+pub use tables::normalization::canonical_combining_class;\n+pub use tables::UNICODE_VERSION;\n+\n /// Functionality for manipulating `char`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait CharExt {\n@@ -34,8 +57,17 @@ pub trait CharExt {\n     /// # Panics\n     ///\n     /// Panics if given a radix > 36.\n-    #[unstable(feature = \"unicode\",\n-               reason = \"pending integer conventions\")]\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let c = '1';\n+    ///\n+    /// assert!(c.is_digit(10));\n+    ///\n+    /// assert!('f'.is_digit(16));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_digit(self, radix: u32) -> bool;\n \n     /// Converts a character to the corresponding digit.\n@@ -49,18 +81,56 @@ pub trait CharExt {\n     /// # Panics\n     ///\n     /// Panics if given a radix outside the range [0..36].\n-    #[unstable(feature = \"unicode\",\n-               reason = \"pending integer conventions\")]\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let c = '1';\n+    ///\n+    /// assert_eq!(c.to_digit(10), Some(1));\n+    ///\n+    /// assert_eq!('f'.to_digit(16), Some(15));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn to_digit(self, radix: u32) -> Option<u32>;\n \n-    /// Returns an iterator that yields the hexadecimal Unicode escape\n-    /// of a character, as `char`s.\n+    /// Returns an iterator that yields the hexadecimal Unicode escape of a\n+    /// character, as `char`s.\n     ///\n     /// All characters are escaped with Rust syntax of the form `\\\\u{NNNN}`\n     /// where `NNNN` is the shortest hexadecimal representation of the code\n     /// point.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// for i in '\u2764'.escape_unicode() {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    ///\n+    /// This prints:\n+    ///\n+    /// ```text\n+    /// \\\n+    /// u\n+    /// {\n+    /// 2\n+    /// 7\n+    /// 6\n+    /// 4\n+    /// }\n+    /// ```\n+    ///\n+    /// Collecting into a `String`:\n+    ///\n+    /// ```\n+    /// let heart: String = '\u2764'.escape_unicode().collect();\n+    ///\n+    /// assert_eq!(heart, r\"\\u{2764}\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn escape_unicode(self) -> char::EscapeUnicode;\n+    fn escape_unicode(self) -> EscapeUnicode;\n \n     /// Returns an iterator that yields the 'default' ASCII and\n     /// C++11-like literal escape of a character, as `char`s.\n@@ -74,33 +144,118 @@ pub trait CharExt {\n     ///   escaped.\n     /// * Any other chars in the range [0x20,0x7e] are not escaped.\n     /// * Any other chars are given hex Unicode escapes; see `escape_unicode`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// for i in '\"'.escape_default() {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    ///\n+    /// This prints:\n+    ///\n+    /// ```text\n+    /// \\\n+    /// \"\n+    /// ```\n+    ///\n+    /// Collecting into a `String`:\n+    ///\n+    /// ```\n+    /// let quote: String = '\"'.escape_default().collect();\n+    ///\n+    /// assert_eq!(quote, \"\\\\\\\"\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn escape_default(self) -> char::EscapeDefault;\n+    fn escape_default(self) -> EscapeDefault;\n \n-    /// Returns the amount of bytes this character would need if encoded in\n+    /// Returns the number of bytes this character would need if encoded in\n     /// UTF-8.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let n = '\u00df'.len_utf8();\n+    ///\n+    /// assert_eq!(n, 2);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf8(self) -> usize;\n \n-    /// Returns the amount of bytes this character would need if encoded in\n-    /// UTF-16.\n+    /// Returns the number of 16-bit code units this character would need if\n+    /// encoded in UTF-16.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let n = '\u00df'.len_utf16();\n+    ///\n+    /// assert_eq!(n, 1);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf16(self) -> usize;\n \n-    /// Encodes this character as UTF-8 into the provided byte buffer,\n-    /// and then returns the number of bytes written.\n+    /// Encodes this character as UTF-8 into the provided byte buffer, and then\n+    /// returns the number of bytes written.\n+    ///\n+    /// If the buffer is not large enough, nothing will be written into it and a\n+    /// `None` will be returned. A buffer of length four is large enough to\n+    /// encode any `char`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// In both of these examples, '\u00df' takes two bytes to encode.\n+    ///\n+    /// ```\n+    /// let mut b = [0; 2];\n+    ///\n+    /// let result = '\u00df'.encode_utf8(&mut b);\n     ///\n-    /// If the buffer is not large enough, nothing will be written into it\n-    /// and a `None` will be returned.\n+    /// assert_eq!(result, Some(2));\n+    /// ```\n+    ///\n+    /// A buffer that's too small:\n+    ///\n+    /// ```\n+    /// let mut b = [0; 1];\n+    ///\n+    /// let result = '\u00df'.encode_utf8(&mut b);\n+    ///\n+    /// assert_eq!(result, None);\n+    /// ```\n     #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf8(self, dst: &mut [u8]) -> Option<usize>;\n \n-    /// Encodes this character as UTF-16 into the provided `u16` buffer,\n-    /// and then returns the number of `u16`s written.\n+    /// Encodes this character as UTF-16 into the provided `u16` buffer, and\n+    /// then returns the number of `u16`s written.\n+    ///\n+    /// If the buffer is not large enough, nothing will be written into it and a\n+    /// `None` will be returned. A buffer of length 2 is large enough to encode\n+    /// any `char`.\n+    ///\n+    /// # Examples\n     ///\n-    /// If the buffer is not large enough, nothing will be written into it\n-    /// and a `None` will be returned.\n+    /// In both of these examples, '\u00df' takes one `u16` to encode.\n+    ///\n+    /// ```\n+    /// let mut b = [0; 1];\n+    ///\n+    /// let result = '\u00df'.encode_utf16(&mut b);\n+    ///\n+    /// assert_eq!(result, Some(1));\n+    /// ```\n+    ///\n+    /// A buffer that's too small:\n+    ///\n+    /// ```\n+    /// let mut b = [0; 0];\n+    ///\n+    /// let result = '\u00df'.encode_utf8(&mut b);\n+    ///\n+    /// assert_eq!(result, None);\n+    /// ```\n     #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf16(self, dst: &mut [u16]) -> Option<usize>;\n@@ -175,35 +330,35 @@ pub trait CharExt {\n     ///\n     /// # Return value\n     ///\n-    /// Returns the lowercase equivalent of the character, or the character\n-    /// itself if no conversion is possible.\n-    #[unstable(feature = \"unicode\",\n-               reason = \"pending case transformation decisions\")]\n-    fn to_lowercase(self) -> char;\n+    /// Returns an iterator which yields the characters corresponding to the\n+    /// lowercase equivalent of the character. If no conversion is possible then\n+    /// the input character is returned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn to_lowercase(self) -> ToLowercase;\n \n     /// Converts a character to its uppercase equivalent.\n     ///\n     /// The case-folding performed is the common or simple mapping: it maps\n-    /// one Unicode codepoint (one character in Rust) to its uppercase\n-    /// equivalent according to the Unicode database [1]. The additional\n-    /// [`SpecialCasing.txt`] is not considered here, as it expands to multiple\n-    /// codepoints in some cases.\n+    /// one Unicode codepoint to its uppercase equivalent according to the\n+    /// Unicode database [1]. The additional [`SpecialCasing.txt`] is not yet\n+    /// considered here, but the iterator returned will soon support this form\n+    /// of case folding.\n     ///\n     /// A full reference can be found here [2].\n     ///\n     /// # Return value\n     ///\n-    /// Returns the uppercase equivalent of the character, or the character\n-    /// itself if no conversion was made.\n+    /// Returns an iterator which yields the characters corresponding to the\n+    /// uppercase equivalent of the character. If no conversion is possible then\n+    /// the input character is returned.\n     ///\n     /// [1]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n     ///\n     /// [`SpecialCasing`.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n     ///\n     /// [2]: http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992\n-    #[unstable(feature = \"unicode\",\n-               reason = \"pending case transformation decisions\")]\n-    fn to_uppercase(self) -> char;\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn to_uppercase(self) -> ToUppercase;\n \n     /// Returns this character's displayed width in columns, or `None` if it is a\n     /// control character other than `'\\x00'`.\n@@ -221,28 +376,15 @@ pub trait CharExt {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl CharExt for char {\n-    #[unstable(feature = \"unicode\",\n-               reason = \"pending integer conventions\")]\n     fn is_digit(self, radix: u32) -> bool { C::is_digit(self, radix) }\n-    #[unstable(feature = \"unicode\",\n-               reason = \"pending integer conventions\")]\n     fn to_digit(self, radix: u32) -> Option<u32> { C::to_digit(self, radix) }\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn escape_unicode(self) -> char::EscapeUnicode { C::escape_unicode(self) }\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn escape_default(self) -> char::EscapeDefault { C::escape_default(self) }\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn escape_unicode(self) -> EscapeUnicode { C::escape_unicode(self) }\n+    fn escape_default(self) -> EscapeDefault { C::escape_default(self) }\n     fn len_utf8(self) -> usize { C::len_utf8(self) }\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf16(self) -> usize { C::len_utf16(self) }\n-    #[unstable(feature = \"unicode\",\n-               reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf8(self, dst: &mut [u8]) -> Option<usize> { C::encode_utf8(self, dst) }\n-    #[unstable(feature = \"unicode\",\n-               reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf16(self, dst: &mut [u16]) -> Option<usize> { C::encode_utf16(self, dst) }\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_alphabetic(self) -> bool {\n         match self {\n             'a' ... 'z' | 'A' ... 'Z' => true,\n@@ -251,15 +393,10 @@ impl CharExt for char {\n         }\n     }\n \n-    #[unstable(feature = \"unicode\",\n-               reason = \"mainly needed for compiler internals\")]\n     fn is_xid_start(self) -> bool { derived_property::XID_Start(self) }\n \n-    #[unstable(feature = \"unicode\",\n-               reason = \"mainly needed for compiler internals\")]\n     fn is_xid_continue(self) -> bool { derived_property::XID_Continue(self) }\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_lowercase(self) -> bool {\n         match self {\n             'a' ... 'z' => true,\n@@ -268,7 +405,6 @@ impl CharExt for char {\n         }\n     }\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_uppercase(self) -> bool {\n         match self {\n             'A' ... 'Z' => true,\n@@ -277,7 +413,6 @@ impl CharExt for char {\n         }\n     }\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_whitespace(self) -> bool {\n         match self {\n             ' ' | '\\x09' ... '\\x0d' => true,\n@@ -286,15 +421,12 @@ impl CharExt for char {\n         }\n     }\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_alphanumeric(self) -> bool {\n         self.is_alphabetic() || self.is_numeric()\n     }\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_control(self) -> bool { general_category::Cc(self) }\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_numeric(self) -> bool {\n         match self {\n             '0' ... '9' => true,\n@@ -303,15 +435,35 @@ impl CharExt for char {\n         }\n     }\n \n-    #[unstable(feature = \"unicode\",\n-               reason = \"pending case transformation decisions\")]\n-    fn to_lowercase(self) -> char { conversions::to_lower(self) }\n+    fn to_lowercase(self) -> ToLowercase {\n+        ToLowercase(Some(conversions::to_lower(self)))\n+    }\n \n-    #[unstable(feature = \"unicode\",\n-               reason = \"pending case transformation decisions\")]\n-    fn to_uppercase(self) -> char { conversions::to_upper(self) }\n+    fn to_uppercase(self) -> ToUppercase {\n+        ToUppercase(Some(conversions::to_upper(self)))\n+    }\n \n-    #[unstable(feature = \"unicode\",\n-               reason = \"needs expert opinion. is_cjk flag stands out as ugly\")]\n     fn width(self, is_cjk: bool) -> Option<usize> { charwidth::width(self, is_cjk) }\n }\n+\n+/// An iterator over the lowercase mapping of a given character, returned from\n+/// the `lowercase` method on characters.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct ToLowercase(Option<char>);\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Iterator for ToLowercase {\n+    type Item = char;\n+    fn next(&mut self) -> Option<char> { self.0.take() }\n+}\n+\n+/// An iterator over the uppercase mapping of a given character, returned from\n+/// the `uppercase` method on characters.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct ToUppercase(Option<char>);\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Iterator for ToUppercase {\n+    type Item = char;\n+    fn next(&mut self) -> Option<char> { self.0.take() }\n+}", "previous_filename": "src/libunicode/u_char.rs"}, {"sha": "fadf91f33bce83a3a6d667b3266ddb08ddfb27c0", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d", "patch": "@@ -42,37 +42,8 @@ pub use tables::regex;\n \n mod normalize;\n mod tables;\n-mod u_char;\n mod u_str;\n-\n-// re-export char so that std et al see it correctly\n-/// Character manipulation (`char` type, Unicode Scalar Value)\n-///\n-/// This module provides the `CharExt` trait, as well as its\n-/// implementation for the primitive `char` type, in order to allow\n-/// basic character manipulation.\n-///\n-/// A `char` actually represents a\n-/// *[Unicode Scalar Value](http://www.unicode.org/glossary/#unicode_scalar_value)*,\n-/// as it can contain any Unicode code point except high-surrogate and\n-/// low-surrogate code points.\n-///\n-/// As such, only values in the ranges \\[0x0,0xD7FF\\] and \\[0xE000,0x10FFFF\\]\n-/// (inclusive) are allowed. A `char` can always be safely cast to a `u32`;\n-/// however the converse is not always true due to the above range limits\n-/// and, as such, should be performed via the `from_u32` function.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(primitive = \"char\")]\n-pub mod char {\n-    pub use core::char::{MAX, from_u32, from_digit};\n-\n-    pub use normalize::{decompose_canonical, decompose_compatible, compose};\n-\n-    pub use tables::normalization::canonical_combining_class;\n-    pub use tables::UNICODE_VERSION;\n-\n-    pub use u_char::CharExt;\n-}\n+pub mod char;\n \n pub mod str {\n     pub use u_str::{UnicodeStr, Words, Graphemes, GraphemeIndices};"}, {"sha": "9b3f4b0521da3fadfe986078e80523368514ff46", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=0f6a0b58f9dbc3a741abd898f2d06a8ba78a938d", "patch": "@@ -26,7 +26,7 @@ use core::num::Int;\n use core::slice;\n use core::str::Split;\n \n-use u_char::CharExt as UCharExt; // conflicts with core::prelude::CharExt\n+use char::CharExt as UCharExt; // conflicts with core::prelude::CharExt\n use tables::grapheme::GraphemeCat;\n \n /// An iterator over the words of a string, separated by a sequence of whitespace"}]}