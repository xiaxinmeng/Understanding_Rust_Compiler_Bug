{"sha": "1a2597b64a9d76eb336878e9b0b9dd4021b0240c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhMjU5N2I2NGE5ZDc2ZWIzMzY4NzhlOWIwYjlkZDQwMjFiMDI0MGM=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-09-09T20:04:26Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-10-15T20:12:04Z"}, "message": "Don't use `gensym_if_underscore` to resolve `_` bindings\n\nInstead add a disambiguator to the keys used for distinguishing\nresolutions.", "tree": {"sha": "2a2422f55c2f1d3dd6059ea31ae126dfa20093fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a2422f55c2f1d3dd6059ea31ae126dfa20093fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a2597b64a9d76eb336878e9b0b9dd4021b0240c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a2597b64a9d76eb336878e9b0b9dd4021b0240c", "html_url": "https://github.com/rust-lang/rust/commit/1a2597b64a9d76eb336878e9b0b9dd4021b0240c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a2597b64a9d76eb336878e9b0b9dd4021b0240c/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9752596d3d377e34f99512eb6bc256512509610", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9752596d3d377e34f99512eb6bc256512509610", "html_url": "https://github.com/rust-lang/rust/commit/a9752596d3d377e34f99512eb6bc256512509610"}], "stats": {"total": 154, "additions": 91, "deletions": 63}, "files": [{"sha": "d1c2fa77c0166159fd7fe560a9527f944d6b8c2a", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1a2597b64a9d76eb336878e9b0b9dd4021b0240c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a2597b64a9d76eb336878e9b0b9dd4021b0240c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=1a2597b64a9d76eb336878e9b0b9dd4021b0240c", "patch": "@@ -93,7 +93,8 @@ impl<'a> Resolver<'a> {\n         where T: ToNameBinding<'a>,\n     {\n         let binding = def.to_name_binding(self.arenas);\n-        if let Err(old_binding) = self.try_define(parent, ident, ns, binding) {\n+        let key = self.new_key(ident, ns);\n+        if let Err(old_binding) = self.try_define(parent, key, binding) {\n             self.report_conflict(parent, ident, ns, old_binding, &binding);\n         }\n     }\n@@ -349,9 +350,12 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n         self.r.indeterminate_imports.push(directive);\n         match directive.subclass {\n+            // Don't add unresolved underscore imports to modules\n+            SingleImport { target: Ident { name: kw::Underscore, .. }, .. } => {}\n             SingleImport { target, type_ns_only, .. } => {\n                 self.r.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n-                    let mut resolution = this.resolution(current_module, target, ns).borrow_mut();\n+                    let key = this.new_key(target, ns);\n+                    let mut resolution = this.resolution(current_module, key).borrow_mut();\n                     resolution.add_single_import(directive);\n                 });\n             }\n@@ -407,7 +411,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         };\n         match use_tree.kind {\n             ast::UseTreeKind::Simple(rename, ..) => {\n-                let mut ident = use_tree.ident().gensym_if_underscore();\n+                let mut ident = use_tree.ident();\n                 let mut module_path = prefix;\n                 let mut source = module_path.pop().unwrap();\n                 let mut type_ns_only = false;\n@@ -585,7 +589,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         let parent_scope = &self.parent_scope;\n         let parent = parent_scope.module;\n         let expansion = parent_scope.expansion;\n-        let ident = item.ident.gensym_if_underscore();\n+        let ident = item.ident;\n         let sp = item.span;\n         let vis = self.resolve_visibility(&item.vis);\n \n@@ -850,10 +854,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn build_reduced_graph_for_external_crate_res(&mut self, child: Export<NodeId>) {\n         let parent = self.parent_scope.module;\n         let Export { ident, res, vis, span } = child;\n-        // FIXME: We shouldn't create the gensym here, it should come from metadata,\n-        // but metadata cannot encode gensyms currently, so we create it here.\n-        // This is only a guess, two equivalent idents may incorrectly get different gensyms here.\n-        let ident = ident.gensym_if_underscore();\n         let expansion = ExpnId::root(); // FIXME(jseyfried) intercrate hygiene\n         // Record primary definitions.\n         match res {"}, {"sha": "de8758086709f16111abc78acae82dd618502330", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1a2597b64a9d76eb336878e9b0b9dd4021b0240c/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a2597b64a9d76eb336878e9b0b9dd4021b0240c/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=1a2597b64a9d76eb336878e9b0b9dd4021b0240c", "patch": "@@ -80,11 +80,11 @@ impl<'a> Resolver<'a> {\n         names: &mut Vec<TypoSuggestion>,\n         filter_fn: &impl Fn(Res) -> bool,\n     ) {\n-        for (&(ident, _), resolution) in self.resolutions(module).borrow().iter() {\n+        for (key, resolution) in self.resolutions(module).borrow().iter() {\n             if let Some(binding) = resolution.borrow().binding {\n                 let res = binding.res();\n                 if filter_fn(res) {\n-                    names.push(TypoSuggestion::from_res(ident.name, res));\n+                    names.push(TypoSuggestion::from_res(key.ident.name, res));\n                 }\n             }\n         }\n@@ -849,7 +849,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         }\n \n         let resolutions = self.r.resolutions(crate_module).borrow();\n-        let resolution = resolutions.get(&(ident, MacroNS))?;\n+        let resolution = resolutions.get(&self.r.new_key(ident, MacroNS))?;\n         let binding = resolution.borrow().binding()?;\n         if let Res::Def(DefKind::Macro(MacroKind::Bang), _) = binding.res() {\n             let module_name = crate_module.kind.name().unwrap();"}, {"sha": "e86d2231fa19e6a2889cbeb0b19a7ab80b182163", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1a2597b64a9d76eb336878e9b0b9dd4021b0240c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a2597b64a9d76eb336878e9b0b9dd4021b0240c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1a2597b64a9d76eb336878e9b0b9dd4021b0240c", "patch": "@@ -431,7 +431,22 @@ impl ModuleKind {\n     }\n }\n \n-type Resolutions<'a> = RefCell<FxIndexMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>;\n+/// A key that identifies a binding in a given `Module`.\n+///\n+/// Multiple bindings in the same module can have the same key (in a valid\n+/// program) if all but one of them come from glob imports.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+struct BindingKey {\n+    /// The identifier for the binding, aways the `modern` version of the\n+    /// identifier.\n+    ident: Ident,\n+    ns: Namespace,\n+    /// 0 if ident is not `_`, otherwise a value that's unique to the specific\n+    /// `_` in the expanded AST that introduced this binding.\n+    disambiguator: u32,\n+}\n+\n+type Resolutions<'a> = RefCell<FxIndexMap<BindingKey, &'a RefCell<NameResolution<'a>>>>;\n \n /// One node in the tree of modules.\n pub struct ModuleData<'a> {\n@@ -491,8 +506,8 @@ impl<'a> ModuleData<'a> {\n     fn for_each_child<R, F>(&'a self, resolver: &mut R, mut f: F)\n         where R: AsMut<Resolver<'a>>, F: FnMut(&mut R, Ident, Namespace, &'a NameBinding<'a>)\n     {\n-        for (&(ident, ns), name_resolution) in resolver.as_mut().resolutions(self).borrow().iter() {\n-            name_resolution.borrow().binding.map(|binding| f(resolver, ident, ns, binding));\n+        for (key, name_resolution) in resolver.as_mut().resolutions(self).borrow().iter() {\n+            name_resolution.borrow().binding.map(|binding| f(resolver, key.ident, key.ns, binding));\n         }\n     }\n \n@@ -879,6 +894,7 @@ pub struct Resolver<'a> {\n     module_map: FxHashMap<DefId, Module<'a>>,\n     extern_module_map: FxHashMap<(DefId, bool /* MacrosOnly? */), Module<'a>>,\n     binding_parent_modules: FxHashMap<PtrKey<'a, NameBinding<'a>>, Module<'a>>,\n+    underscore_disambiguator: u32,\n \n     /// Maps glob imports to the names of items actually imported.\n     pub glob_map: GlobMap,\n@@ -1156,6 +1172,7 @@ impl<'a> Resolver<'a> {\n             label_res_map: Default::default(),\n             export_map: FxHashMap::default(),\n             trait_map: Default::default(),\n+            underscore_disambiguator: 0,\n             empty_module,\n             module_map,\n             block_map: Default::default(),\n@@ -1280,6 +1297,17 @@ impl<'a> Resolver<'a> {\n         self.arenas.alloc_module(module)\n     }\n \n+    fn new_key(&mut self, ident: Ident, ns: Namespace) -> BindingKey {\n+        let ident = ident.modern();\n+        let disambiguator = if ident.name == kw::Underscore {\n+            self.underscore_disambiguator += 1;\n+            self.underscore_disambiguator\n+        } else {\n+            0\n+        };\n+        BindingKey { ident, ns, disambiguator }\n+    }\n+\n     fn resolutions(&mut self, module: Module<'a>) -> &'a Resolutions<'a> {\n         if module.populate_on_access.get() {\n             module.populate_on_access.set(false);\n@@ -1288,9 +1316,9 @@ impl<'a> Resolver<'a> {\n         &module.lazy_resolutions\n     }\n \n-    fn resolution(&mut self, module: Module<'a>, ident: Ident, ns: Namespace)\n+    fn resolution(&mut self, module: Module<'a>, key: BindingKey)\n                   -> &'a RefCell<NameResolution<'a>> {\n-        *self.resolutions(module).borrow_mut().entry((ident.modern(), ns))\n+        *self.resolutions(module).borrow_mut().entry(key)\n                .or_insert_with(|| self.arenas.alloc_name_resolution())\n     }\n "}, {"sha": "56fd2da2576fbf8c68745cf0c7b5068816fb7bb7", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/1a2597b64a9d76eb336878e9b0b9dd4021b0240c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a2597b64a9d76eb336878e9b0b9dd4021b0240c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=1a2597b64a9d76eb336878e9b0b9dd4021b0240c", "patch": "@@ -7,7 +7,7 @@ use crate::{CrateLint, Module, ModuleOrUniformRoot, PerNS, ScopeSet, ParentScope\n use crate::Determinacy::{self, *};\n use crate::Namespace::{self, TypeNS, MacroNS};\n use crate::{NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n-use crate::{Resolver, ResolutionError, Segment, ModuleKind};\n+use crate::{Resolver, ResolutionError, BindingKey, Segment, ModuleKind};\n use crate::{names_to_string, module_to_string};\n use crate::diagnostics::Suggestion;\n \n@@ -235,7 +235,8 @@ impl<'a> Resolver<'a> {\n             }\n         };\n \n-        let resolution = self.resolution(module, ident, ns)\n+        let key = self.new_key(ident, ns);\n+        let resolution = self.resolution(module, key)\n             .try_borrow_mut()\n             .map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n \n@@ -447,17 +448,16 @@ impl<'a> Resolver<'a> {\n     }\n \n     // Define the name or return the existing binding if there is a collision.\n-    pub fn try_define(\n+    crate fn try_define(\n         &mut self,\n         module: Module<'a>,\n-        ident: Ident,\n-        ns: Namespace,\n+        key: BindingKey,\n         binding: &'a NameBinding<'a>,\n     ) -> Result<(), &'a NameBinding<'a>> {\n         let res = binding.res();\n-        self.check_reserved_macro_name(ident, res);\n+        self.check_reserved_macro_name(key.ident, res);\n         self.set_binding_parent_module(binding, module);\n-        self.update_resolution(module, ident, ns, |this, resolution| {\n+        self.update_resolution(module, key, |this, resolution| {\n             if let Some(old_binding) = resolution.binding {\n                 if res == Res::Err {\n                     // Do not override real bindings with `Res::Err`s from error recovery.\n@@ -479,8 +479,9 @@ impl<'a> Resolver<'a> {\n                         } else {\n                             (binding, old_binding)\n                         };\n-                        if glob_binding.res() != nonglob_binding.res() &&\n-                           ns == MacroNS && nonglob_binding.expansion != ExpnId::root() {\n+                        if glob_binding.res() != nonglob_binding.res()\n+                            && key.ns == MacroNS && nonglob_binding.expansion != ExpnId::root()\n+                        {\n                             resolution.binding = Some(this.ambiguity(\n                                 AmbiguityKind::GlobVsExpanded,\n                                 nonglob_binding,\n@@ -499,9 +500,9 @@ impl<'a> Resolver<'a> {\n                                 DUPLICATE_MACRO_EXPORTS,\n                                 CRATE_NODE_ID,\n                                 binding.span,\n-                                &format!(\"a macro named `{}` has already been exported\", ident),\n+                                &format!(\"a macro named `{}` has already been exported\", key.ident),\n                                 BuiltinLintDiagnostics::DuplicatedMacroExports(\n-                                    ident, old_binding.span, binding.span));\n+                                    key.ident, old_binding.span, binding.span));\n \n                             resolution.binding = Some(binding);\n                         } else {\n@@ -531,17 +532,17 @@ impl<'a> Resolver<'a> {\n     // Use `f` to mutate the resolution of the name in the module.\n     // If the resolution becomes a success, define it in the module's glob importers.\n     fn update_resolution<T, F>(\n-        &mut self, module: Module<'a>,\n-        ident: Ident,\n-        ns: Namespace,\n+        &mut self,\n+        module: Module<'a>,\n+        key: BindingKey,\n         f: F,\n     ) -> T\n         where F: FnOnce(&mut Resolver<'a>, &mut NameResolution<'a>) -> T\n     {\n         // Ensure that `resolution` isn't borrowed when defining in the module's glob importers,\n         // during which the resolution might end up getting re-defined via a glob cycle.\n         let (binding, t) = {\n-            let resolution = &mut *self.resolution(module, ident, ns).borrow_mut();\n+            let resolution = &mut *self.resolution(module, key).borrow_mut();\n             let old_binding = resolution.binding();\n \n             let t = f(self, resolution);\n@@ -558,15 +559,16 @@ impl<'a> Resolver<'a> {\n \n         // Define `binding` in `module`s glob importers.\n         for directive in module.glob_importers.borrow_mut().iter() {\n-            let mut ident = ident.modern();\n+            let mut ident = key.ident;\n             let scope = match ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n                 Some(Some(def)) => self.macro_def_scope(def),\n                 Some(None) => directive.parent_scope.module,\n                 None => continue,\n             };\n             if self.is_accessible_from(binding.vis, scope) {\n                 let imported_binding = self.import(binding, directive);\n-                let _ = self.try_define(directive.parent_scope.module, ident, ns, imported_binding);\n+                let key = BindingKey { ident, ..key };\n+                let _ = self.try_define(directive.parent_scope.module, key, imported_binding);\n             }\n         }\n \n@@ -580,7 +582,8 @@ impl<'a> Resolver<'a> {\n             let dummy_binding = self.dummy_binding;\n             let dummy_binding = self.import(dummy_binding, directive);\n             self.per_ns(|this, ns| {\n-                let _ = this.try_define(directive.parent_scope.module, target, ns, dummy_binding);\n+                let key = this.new_key(target, ns);\n+                let _ = this.try_define(directive.parent_scope.module, key, dummy_binding);\n                 // Consider erroneous imports used to avoid duplicate diagnostics.\n                 this.record_use(target, ns, dummy_binding, false);\n             });\n@@ -820,8 +823,11 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             let parent = directive.parent_scope.module;\n             match source_bindings[ns].get() {\n                 Err(Undetermined) => indeterminate = true,\n+                // Don't update the resolution, because it was never added.\n+                Err(Determined) if target.name == kw::Underscore => {}\n                 Err(Determined) => {\n-                    this.update_resolution(parent, target, ns, |_, resolution| {\n+                    let key = this.new_key(target, ns);\n+                    this.update_resolution(parent, key, |_, resolution| {\n                         resolution.single_imports.remove(&PtrKey(directive));\n                     });\n                 }\n@@ -1052,7 +1058,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     _ => None,\n                 };\n                 let resolutions = resolutions.as_ref().into_iter().flat_map(|r| r.iter());\n-                let names = resolutions.filter_map(|(&(ref i, _), resolution)| {\n+                let names = resolutions.filter_map(|(BindingKey { ident: i, .. }, resolution)| {\n                     if *i == ident { return None; } // Never suggest the same name\n                     match *resolution.borrow() {\n                         NameResolution { binding: Some(name_binding), .. } => {\n@@ -1301,19 +1307,18 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n-        let bindings = self.r.resolutions(module).borrow().iter().filter_map(|(ident, resolution)| {\n-            resolution.borrow().binding().map(|binding| (*ident, binding))\n+        let bindings = self.r.resolutions(module).borrow().iter().filter_map(|(key, resolution)| {\n+            resolution.borrow().binding().map(|binding| (*key, binding))\n         }).collect::<Vec<_>>();\n-        for ((mut ident, ns), binding) in bindings {\n-            let scope = match ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n+        for (mut key, binding) in bindings {\n+            let scope = match key.ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n                 Some(Some(def)) => self.r.macro_def_scope(def),\n                 Some(None) => directive.parent_scope.module,\n                 None => continue,\n             };\n             if self.r.is_accessible_from(binding.pseudo_vis(), scope) {\n                 let imported_binding = self.r.import(binding, directive);\n-                let _ =\n-                    self.r.try_define(directive.parent_scope.module, ident, ns, imported_binding);\n+                let _ = self.r.try_define(directive.parent_scope.module, key, imported_binding);\n             }\n         }\n \n@@ -1329,29 +1334,23 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         let mut reexports = Vec::new();\n \n-        for (&(ident, ns), resolution) in self.r.resolutions(module).borrow().iter() {\n-            let resolution = &mut *resolution.borrow_mut();\n-            let binding = match resolution.binding {\n-                Some(binding) => binding,\n-                None => continue,\n-            };\n-\n+        module.for_each_child(self.r, |this, ident, ns, binding| {\n             // Filter away ambiguous imports and anything that has def-site\n             // hygiene.\n             // FIXME: Implement actual cross-crate hygiene.\n             let is_good_import = binding.is_import() && !binding.is_ambiguity()\n-                && !ident.span.modern().from_expansion();\n+                && !ident.span.from_expansion();\n             if is_good_import || binding.is_macro_def() {\n                 let res = binding.res();\n                 if res != Res::Err {\n                     if let Some(def_id) = res.opt_def_id() {\n                         if !def_id.is_local() {\n-                            self.r.cstore.export_macros_untracked(def_id.krate);\n+                            this.cstore.export_macros_untracked(def_id.krate);\n                         }\n                     }\n                     reexports.push(Export {\n-                        ident: ident.modern(),\n-                        res: res,\n+                        ident,\n+                        res,\n                         span: binding.span,\n                         vis: binding.vis,\n                     });\n@@ -1360,7 +1359,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n             if let NameBindingKind::Import { binding: orig_binding, directive, .. } = binding.kind {\n                 if ns == TypeNS && orig_binding.is_variant() &&\n-                    !orig_binding.vis.is_at_least(binding.vis, &*self) {\n+                    !orig_binding.vis.is_at_least(binding.vis, &*this) {\n                         let msg = match directive.subclass {\n                             ImportDirectiveSubclass::SingleImport { .. } => {\n                                 format!(\"variant `{}` is private and cannot be re-exported\",\n@@ -1372,41 +1371,42 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                 let error_id = (DiagnosticMessageId::ErrorId(0), // no code?!\n                                                 Some(binding.span),\n                                                 msg.clone());\n-                                let fresh = self.r.session.one_time_diagnostics\n+                                let fresh = this.session.one_time_diagnostics\n                                     .borrow_mut().insert(error_id);\n                                 if !fresh {\n-                                    continue;\n+                                    return;\n                                 }\n                                 msg\n                             },\n                             ref s @ _ => bug!(\"unexpected import subclass {:?}\", s)\n                         };\n-                        let mut err = self.r.session.struct_span_err(binding.span, &msg);\n+                        let mut err = this.session.struct_span_err(binding.span, &msg);\n \n                         let imported_module = match directive.imported_module.get() {\n                             Some(ModuleOrUniformRoot::Module(module)) => module,\n                             _ => bug!(\"module should exist\"),\n                         };\n                         let parent_module = imported_module.parent.expect(\"parent should exist\");\n-                        let resolutions = self.r.resolutions(parent_module).borrow();\n+                        let resolutions = this.resolutions(parent_module).borrow();\n                         let enum_path_segment_index = directive.module_path.len() - 1;\n                         let enum_ident = directive.module_path[enum_path_segment_index].ident;\n \n-                        let enum_resolution = resolutions.get(&(enum_ident, TypeNS))\n+                        let key = this.new_key(enum_ident, TypeNS);\n+                        let enum_resolution = resolutions.get(&key)\n                             .expect(\"resolution should exist\");\n                         let enum_span = enum_resolution.borrow()\n                             .binding.expect(\"binding should exist\")\n                             .span;\n-                        let enum_def_span = self.r.session.source_map().def_span(enum_span);\n-                        let enum_def_snippet = self.r.session.source_map()\n+                        let enum_def_span = this.session.source_map().def_span(enum_span);\n+                        let enum_def_snippet = this.session.source_map()\n                             .span_to_snippet(enum_def_span).expect(\"snippet should exist\");\n                         // potentially need to strip extant `crate`/`pub(path)` for suggestion\n                         let after_vis_index = enum_def_snippet.find(\"enum\")\n                             .expect(\"`enum` keyword should exist in snippet\");\n                         let suggestion = format!(\"pub {}\",\n                                                  &enum_def_snippet[after_vis_index..]);\n \n-                        self.r.session\n+                        this.session\n                             .diag_span_suggestion_once(&mut err,\n                                                        DiagnosticMessageId::ErrorId(0),\n                                                        enum_def_span,\n@@ -1415,7 +1415,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         err.emit();\n                 }\n             }\n-        }\n+        });\n \n         if reexports.len() > 0 {\n             if let Some(def_id) = module.def_id() {"}]}