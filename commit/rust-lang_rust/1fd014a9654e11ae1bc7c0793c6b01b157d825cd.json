{"sha": "1fd014a9654e11ae1bc7c0793c6b01b157d825cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmZDAxNGE5NjU0ZTExYWUxYmM3YzA3OTNjNmIwMWIxNTdkODI1Y2Q=", "commit": {"author": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-07-13T21:53:42Z"}, "committer": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-07-14T11:57:46Z"}, "message": "Add fix for tabs. Move error unit tests->ui tests", "tree": {"sha": "4216ec70bb7a69c2400685a209cde15ce7bcdd24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4216ec70bb7a69c2400685a209cde15ce7bcdd24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fd014a9654e11ae1bc7c0793c6b01b157d825cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fd014a9654e11ae1bc7c0793c6b01b157d825cd", "html_url": "https://github.com/rust-lang/rust/commit/1fd014a9654e11ae1bc7c0793c6b01b157d825cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/comments", "author": null, "committer": null, "parents": [{"sha": "2e8e73cb951e2095e444c5cc91403f7e9c5f1065", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e8e73cb951e2095e444c5cc91403f7e9c5f1065", "html_url": "https://github.com/rust-lang/rust/commit/2e8e73cb951e2095e444c5cc91403f7e9c5f1065"}], "stats": {"total": 1186, "additions": 414, "deletions": 772}, "files": [{"sha": "9768b68619e7945ec38648300874f9507d4cf12f", "filename": "src/librustc_errors/styled_buffer.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Flibrustc_errors%2Fstyled_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Flibrustc_errors%2Fstyled_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fstyled_buffer.rs?ref=1fd014a9654e11ae1bc7c0793c6b01b157d825cd", "patch": "@@ -26,10 +26,27 @@ impl StyledBuffer {\n         }\n     }\n \n-    pub fn render(&self) -> Vec<Vec<StyledString>> {\n+    pub fn copy_tabs(&mut self, row: usize) {\n+        if row < self.text.len() {\n+            for i in row+1..self.text.len() {\n+                for j in 0..self.text[i].len() {\n+                    if self.text[row].len() > j &&\n+                       self.text[row][j] == '\\t' &&\n+                       self.text[i][j] == ' ' {\n+                        self.text[i][j] = '\\t';\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn render(&mut self) -> Vec<Vec<StyledString>> {\n         let mut output: Vec<Vec<StyledString>> = vec![];\n         let mut styled_vec: Vec<StyledString> = vec![];\n \n+        //before we render, do a little patch-up work to support tabs\n+        self.copy_tabs(3);\n+\n         for (row, row_style) in self.text.iter().zip(&self.styles) {\n             let mut current_style = Style::NoStyle;\n             let mut current_text = String::new();\n@@ -78,11 +95,7 @@ impl StyledBuffer {\n         } else {\n             let mut i = self.text[line].len();\n             while i < col {\n-                let s = match self.text[0].get(i) {\n-                    Some(&'\\t') => '\\t',\n-                    _ => ' ',\n-                };\n-                self.text[line].push(s);\n+                self.text[line].push(' ');\n                 self.styles[line].push(Style::NoStyle);\n                 i += 1;\n             }"}, {"sha": "afa5a3b38ba2748ba5c6106f2035099fde2f1fdf", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 766, "changes": 770, "blob_url": "https://github.com/rust-lang/rust/blob/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=1fd014a9654e11ae1bc7c0793c6b01b157d825cd", "patch": "@@ -827,12 +827,7 @@ impl CodeMapper for CodeMap {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use errors::{Level, CodeSuggestion};\n-    use errors::emitter::EmitterWriter;\n-    use errors::snippet::{SnippetData, RenderedLine, FormatMode};\n-    use std::sync::{Arc, Mutex};\n     use std::io::{self, Write};\n-    use std::str::from_utf8;\n     use std::rc::Rc;\n \n     #[test]\n@@ -1130,12 +1125,12 @@ mod tests {\n         }\n     }\n \n-    fn make_string(lines: &[RenderedLine]) -> String {\n+    fn make_string(lines: Vec<Vec<StyledString>>) -> String {\n         lines.iter()\n             .flat_map(|rl| {\n-                rl.text.iter()\n-                        .map(|s| &s.text[..])\n-                        .chain(Some(\"\\n\"))\n+                rl.iter()\n+                    .map(|s| &s.text[..])\n+                    .chain(Some(\"\\n\"))\n             })\n             .collect()\n     }\n@@ -1219,761 +1214,4 @@ r\"blork2.rs:2:1: 2:12\n \";\n         assert_eq!(sstr, res_str);\n     }\n-\n-    struct Sink(Arc<Mutex<Vec<u8>>>);\n-    impl Write for Sink {\n-        fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-            Write::write(&mut *self.0.lock().unwrap(), data)\n-        }\n-        fn flush(&mut self) -> io::Result<()> { Ok(()) }\n-    }\n-\n-    // Diagnostic doesn't align properly in span where line number increases by one digit\n-    #[test]\n-    fn test_hilight_suggestion_issue_11715() {\n-        let data = Arc::new(Mutex::new(Vec::new()));\n-        let cm = Rc::new(CodeMap::new());\n-        let mut ew = EmitterWriter::new(Box::new(Sink(data.clone())),\n-                                        None,\n-                                        Some(cm.clone()),\n-                                        FormatMode::NewErrorFormat);\n-        let content = \"abcdefg\n-        koksi\n-        line3\n-        line4\n-        cinq\n-        line6\n-        line7\n-        line8\n-        line9\n-        line10\n-        e-l\u00e4-v\u00e4n\n-        tolv\n-        dreizehn\n-        \";\n-        let file = cm.new_filemap_and_lines(\"dummy.txt\", None, content);\n-        let start = file.lines.borrow()[10];\n-        let end = file.lines.borrow()[11];\n-        let sp = mk_sp(start, end);\n-        let lvl = Level::Error;\n-        println!(\"highlight_lines\");\n-        ew.highlight_lines(&sp.into(), lvl).unwrap();\n-        println!(\"done\");\n-        let vec = data.lock().unwrap().clone();\n-        let vec: &[u8] = &vec;\n-        let str = from_utf8(vec).unwrap();\n-        println!(\"r#\\\"\\n{}\\\"#\", str);\n-        assert_eq!(str, &r#\"\n-  --> dummy.txt:11:1\n-   |\n-11 |          e-l\u00e4-v\u00e4n\n-   |  ^\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn test_single_span_splice() {\n-        // Test that a `MultiSpan` containing a single span splices a substition correctly\n-        let cm = CodeMap::new();\n-        let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n-        let selection = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n-        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n-        let sp = span_from_selection(inputtext, selection);\n-        let msp: MultiSpan = sp.into();\n-\n-        // check that we are extracting the text we thought we were extracting\n-        assert_eq!(&cm.span_to_snippet(sp).unwrap(), \"BB\\nCCC\\nDDDDD\");\n-\n-        let substitute = \"ZZZZZZ\".to_owned();\n-        let expected = \"bbbbZZZZZZddddd\";\n-        let suggest = CodeSuggestion {\n-            msp: msp,\n-            substitutes: vec![substitute],\n-        };\n-        assert_eq!(suggest.splice_lines(&cm), expected);\n-    }\n-\n-    #[test]\n-    fn test_multi_span_splice() {\n-        // Test that a `MultiSpan` containing multiple spans splices a substition correctly\n-        let cm = CodeMap::new();\n-        let inputtext  = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n-        let selection1 = \"     \\n      \\n   \\n          \\n ~ \\n\"; // intentionally out of order\n-        let selection2 = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n-        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n-        let sp1 = span_from_selection(inputtext, selection1);\n-        let sp2 = span_from_selection(inputtext, selection2);\n-        let msp: MultiSpan = MultiSpan::from_spans(vec![sp1, sp2]);\n-\n-        let expected = \"bbbbZZZZZZddddd\\neXYZe\";\n-        let suggest = CodeSuggestion {\n-            msp: msp,\n-            substitutes: vec![\"ZZZZZZ\".to_owned(),\n-                              \"XYZ\".to_owned()]\n-        };\n-\n-        assert_eq!(suggest.splice_lines(&cm), expected);\n-    }\n-\n-    #[test]\n-    fn test_multispan_highlight() {\n-        let data = Arc::new(Mutex::new(Vec::new()));\n-        let cm = Rc::new(CodeMap::new());\n-        let mut diag = EmitterWriter::new(Box::new(Sink(data.clone())),\n-                                          None,\n-                                          Some(cm.clone()),\n-                                          FormatMode::NewErrorFormat);\n-\n-        let inp =       \"_____aaaaaa____bbbbbb__cccccdd_\";\n-        let sp1 =       \"     ~~~~~~                    \";\n-        let sp2 =       \"               ~~~~~~          \";\n-        let sp3 =       \"                       ~~~~~   \";\n-        let sp4 =       \"                          ~~~~ \";\n-        let sp34 =      \"                       ~~~~~~~ \";\n-\n-        let expect_start = &r#\"\n- --> dummy.txt:1:6\n-  |\n-1 |  _____aaaaaa____bbbbbb__cccccdd_\n-  |       ^^^^^^    ^^^^^^  ^^^^^^^\n-\"#[1..];\n-\n-        let span = |sp, expected| {\n-            let sp = span_from_selection(inp, sp);\n-            assert_eq!(&cm.span_to_snippet(sp).unwrap(), expected);\n-            sp\n-        };\n-        cm.new_filemap_and_lines(\"dummy.txt\", None, inp);\n-        let sp1 = span(sp1, \"aaaaaa\");\n-        let sp2 = span(sp2, \"bbbbbb\");\n-        let sp3 = span(sp3, \"ccccc\");\n-        let sp4 = span(sp4, \"ccdd\");\n-        let sp34 = span(sp34, \"cccccdd\");\n-\n-        let spans = vec![sp1, sp2, sp3, sp4];\n-\n-        let test = |expected, highlight: &mut FnMut()| {\n-            data.lock().unwrap().clear();\n-            highlight();\n-            let vec = data.lock().unwrap().clone();\n-            let actual = from_utf8(&vec[..]).unwrap();\n-            println!(\"actual=\\n{}\", actual);\n-            assert_eq!(actual, expected);\n-        };\n-\n-        let msp = MultiSpan::from_spans(vec![sp1, sp2, sp34]);\n-        test(expect_start, &mut || {\n-            diag.highlight_lines(&msp, Level::Error).unwrap();\n-        });\n-        test(expect_start, &mut || {\n-            let msp = MultiSpan::from_spans(spans.clone());\n-            diag.highlight_lines(&msp, Level::Error).unwrap();\n-        });\n-    }\n-\n-    #[test]\n-    fn test_huge_multispan_highlight() {\n-        let data = Arc::new(Mutex::new(Vec::new()));\n-        let cm = Rc::new(CodeMap::new());\n-        let mut diag = EmitterWriter::new(Box::new(Sink(data.clone())),\n-                                          None,\n-                                          Some(cm.clone()),\n-                                          FormatMode::NewErrorFormat);\n-\n-        let inp = \"aaaaa\\n\\\n-                   aaaaa\\n\\\n-                   aaaaa\\n\\\n-                   bbbbb\\n\\\n-                   ccccc\\n\\\n-                   xxxxx\\n\\\n-                   yyyyy\\n\\\n-                   _____\\n\\\n-                   ddd__eee_\\n\\\n-                   elided\\n\\\n-                   __f_gg\";\n-        let file = cm.new_filemap_and_lines(\"dummy.txt\", None, inp);\n-\n-        let span = |lo, hi, (off_lo, off_hi)| {\n-            let lines = file.lines.borrow();\n-            let (mut lo, mut hi): (BytePos, BytePos) = (lines[lo], lines[hi]);\n-            lo.0 += off_lo;\n-            hi.0 += off_hi;\n-            mk_sp(lo, hi)\n-        };\n-        let sp0 = span(4, 6, (0, 5));\n-        let sp1 = span(0, 6, (0, 5));\n-        let sp2 = span(8, 8, (0, 3));\n-        let sp3 = span(8, 8, (5, 8));\n-        let sp4 = span(10, 10, (2, 3));\n-        let sp5 = span(10, 10, (4, 6));\n-\n-        let expect0 = &r#\"\n-   --> dummy.txt:5:1\n-    |\n-5   |  ccccc\n-    |  ^\n-...\n-9   |  ddd__eee_\n-    |  ^^^  ^^^\n-10  |  elided\n-11  |  __f_gg\n-    |    ^ ^^\n-\"#[1..];\n-\n-        let expect = &r#\"\n-   --> dummy.txt:1:1\n-    |\n-1   |  aaaaa\n-    |  ^\n-...\n-9   |  ddd__eee_\n-    |  ^^^  ^^^\n-10  |  elided\n-11  |  __f_gg\n-    |    ^ ^^\n-\"#[1..];\n-\n-        macro_rules! test {\n-            ($expected: expr, $highlight: expr) => ({\n-                data.lock().unwrap().clear();\n-                $highlight();\n-                let vec = data.lock().unwrap().clone();\n-                let actual = from_utf8(&vec[..]).unwrap();\n-                println!(\"actual:\");\n-                println!(\"{}\", actual);\n-                println!(\"expected:\");\n-                println!(\"{}\", $expected);\n-                assert_eq!(&actual[..], &$expected[..]);\n-            });\n-        }\n-\n-        let msp0 = MultiSpan::from_spans(vec![sp0, sp2, sp3, sp4, sp5]);\n-        let msp = MultiSpan::from_spans(vec![sp1, sp2, sp3, sp4, sp5]);\n-\n-        test!(expect0, || {\n-            diag.highlight_lines(&msp0, Level::Error).unwrap();\n-        });\n-        test!(expect, || {\n-            diag.highlight_lines(&msp, Level::Error).unwrap();\n-        });\n-    }\n-\n-    #[test]\n-    fn tab() {\n-        let file_text = \"\n-fn foo() {\n-\\tbar;\n-}\n-\";\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-        let span_bar = cm.span_substr(&foo, file_text, \"bar\", 0);\n-\n-        let mut snippet = SnippetData::new(cm, Some(span_bar), FormatMode::NewErrorFormat);\n-        snippet.push(span_bar, true, None);\n-\n-        let lines = snippet.render_lines();\n-        let text = make_string(&lines);\n-        assert_eq!(&text[..], &\"\n- --> foo.rs:3:2\n-  |\n-3 |  \\tbar;\n-  |  \\t^^^\n-\"[1..]);\n-    }\n-\n-    #[test]\n-    fn one_line() {\n-        let file_text = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-        let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n-        let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n-        let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n-\n-        let mut snippet = SnippetData::new(cm, None, FormatMode::NewErrorFormat);\n-        snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n-        snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n-        snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n-\n-        let lines = snippet.render_lines();\n-        println!(\"{:#?}\", lines);\n-\n-        let text: String = make_string(&lines);\n-\n-        println!(\"text=\\n{}\", text);\n-        assert_eq!(&text[..], &r#\"\n- ::: foo.rs\n-  |\n-3 |      vec.push(vec.pop().unwrap());\n-  |      ---      ---                - previous borrow ends here\n-  |      |        |\n-  |      |        error occurs here\n-  |      previous borrow of `vec` occurs here\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn two_files() {\n-        let file_text_foo = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-        let file_text_bar = r#\"\n-fn bar() {\n-    // these blank links here\n-    // serve to ensure that the line numbers\n-    // from bar.rs\n-    // require more digits\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-    vec.push();\n-\n-    // this line will get elided\n-\n-    vec.pop().unwrap());\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo_map = cm.new_filemap_and_lines(\"foo.rs\", None, file_text_foo);\n-        let span_foo_vec0 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 0);\n-        let span_foo_vec1 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 1);\n-        let span_foo_semi = cm.span_substr(&foo_map, file_text_foo, \";\", 0);\n-\n-        let bar_map = cm.new_filemap_and_lines(\"bar.rs\", None, file_text_bar);\n-        let span_bar_vec0 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 0);\n-        let span_bar_vec1 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 1);\n-        let span_bar_semi = cm.span_substr(&bar_map, file_text_bar, \";\", 0);\n-\n-        let mut snippet = SnippetData::new(cm, Some(span_foo_vec1), FormatMode::NewErrorFormat);\n-        snippet.push(span_foo_vec0, false, Some(format!(\"a\")));\n-        snippet.push(span_foo_vec1, true, Some(format!(\"b\")));\n-        snippet.push(span_foo_semi, false, Some(format!(\"c\")));\n-        snippet.push(span_bar_vec0, false, Some(format!(\"d\")));\n-        snippet.push(span_bar_vec1, false, Some(format!(\"e\")));\n-        snippet.push(span_bar_semi, false, Some(format!(\"f\")));\n-\n-        let lines = snippet.render_lines();\n-        println!(\"{:#?}\", lines);\n-\n-        let text: String = make_string(&lines);\n-\n-        println!(\"text=\\n{}\", text);\n-\n-        // Note that the `|` remain aligned across both files:\n-        assert_eq!(&text[..], &r#\"\n-   --> foo.rs:3:14\n-    |\n-3   |      vec.push(vec.pop().unwrap());\n-    |      ---      ^^^                - c\n-    |      |        |\n-    |      |        b\n-    |      a\n-   ::: bar.rs\n-    |\n-17  |      vec.push();\n-    |      ---       - f\n-    |      |\n-    |      d\n-...\n-21  |      vec.pop().unwrap());\n-    |      --- e\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn multi_line() {\n-        let file_text = r#\"\n-fn foo() {\n-    let name = find_id(&data, 22).unwrap();\n-\n-    // Add one more item we forgot to the vector. Silly us.\n-    data.push(Data { name: format!(\"Hera\"), id: 66 });\n-\n-    // Print everything out.\n-    println!(\"Name: {:?}\", name);\n-    println!(\"Data: {:?}\", data);\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-        let span_data0 = cm.span_substr(&foo, file_text, \"data\", 0);\n-        let span_data1 = cm.span_substr(&foo, file_text, \"data\", 1);\n-        let span_rbrace = cm.span_substr(&foo, file_text, \"}\", 3);\n-\n-        let mut snippet = SnippetData::new(cm, None, FormatMode::NewErrorFormat);\n-        snippet.push(span_data0, false, Some(format!(\"immutable borrow begins here\")));\n-        snippet.push(span_data1, false, Some(format!(\"mutable borrow occurs here\")));\n-        snippet.push(span_rbrace, false, Some(format!(\"immutable borrow ends here\")));\n-\n-        let lines = snippet.render_lines();\n-        println!(\"{:#?}\", lines);\n-\n-        let text: String = make_string(&lines);\n-\n-        println!(\"text=\\n{}\", text);\n-        assert_eq!(&text[..], &r#\"\n-   ::: foo.rs\n-    |\n-3   |      let name = find_id(&data, 22).unwrap();\n-    |                          ---- immutable borrow begins here\n-...\n-6   |      data.push(Data { name: format!(\"Hera\"), id: 66 });\n-    |      ---- mutable borrow occurs here\n-...\n-11  |  }\n-    |  - immutable borrow ends here\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn overlapping() {\n-        let file_text = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-        let span0 = cm.span_substr(&foo, file_text, \"vec.push\", 0);\n-        let span1 = cm.span_substr(&foo, file_text, \"vec\", 0);\n-        let span2 = cm.span_substr(&foo, file_text, \"ec.push\", 0);\n-        let span3 = cm.span_substr(&foo, file_text, \"unwrap\", 0);\n-\n-        let mut snippet = SnippetData::new(cm, None, FormatMode::NewErrorFormat);\n-        snippet.push(span0, false, Some(format!(\"A\")));\n-        snippet.push(span1, false, Some(format!(\"B\")));\n-        snippet.push(span2, false, Some(format!(\"C\")));\n-        snippet.push(span3, false, Some(format!(\"D\")));\n-\n-        let lines = snippet.render_lines();\n-        println!(\"{:#?}\", lines);\n-        let text: String = make_string(&lines);\n-\n-        println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n-        assert_eq!(&text[..], &r#\"\n- ::: foo.rs\n-  |\n-3 |      vec.push(vec.pop().unwrap());\n-  |      --------           ------ D\n-  |      ||\n-  |      |C\n-  |      A\n-  |      B\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn one_line_out_of_order() {\n-        let file_text = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-        let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n-        let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n-        let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n-\n-        // intentionally don't push the snippets left to right\n-        let mut snippet = SnippetData::new(cm, None, FormatMode::NewErrorFormat);\n-        snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n-        snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n-        snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n-\n-        let lines = snippet.render_lines();\n-        println!(\"{:#?}\", lines);\n-        let text: String = make_string(&lines);\n-\n-        println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n-        assert_eq!(&text[..], &r#\"\n- ::: foo.rs\n-  |\n-3 |      vec.push(vec.pop().unwrap());\n-  |      ---      ---                - previous borrow ends here\n-  |      |        |\n-  |      |        error occurs here\n-  |      previous borrow of `vec` occurs here\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn elide_unnecessary_lines() {\n-        let file_text = r#\"\n-fn foo() {\n-    let mut vec = vec![0, 1, 2];\n-    let mut vec2 = vec;\n-    vec2.push(3);\n-    vec2.push(4);\n-    vec2.push(5);\n-    vec2.push(6);\n-    vec.push(7);\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-        let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 3);\n-        let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 8);\n-\n-        let mut snippet = SnippetData::new(cm, None, FormatMode::NewErrorFormat);\n-        snippet.push(span_vec0, false, Some(format!(\"`vec` moved here because it \\\n-            has type `collections::vec::Vec<i32>`\")));\n-        snippet.push(span_vec1, false, Some(format!(\"use of moved value: `vec`\")));\n-\n-        let lines = snippet.render_lines();\n-        println!(\"{:#?}\", lines);\n-        let text: String = make_string(&lines);\n-        println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n-        assert_eq!(&text[..], &r#\"\n-   ::: foo.rs\n-    |\n-4   |      let mut vec2 = vec;\n-    |                     --- `vec` moved here because it has type `collections::vec::Vec<i32>`\n-...\n-9   |      vec.push(7);\n-    |      --- use of moved value: `vec`\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn spans_without_labels() {\n-        let file_text = r#\"\n-fn foo() {\n-    let mut vec = vec![0, 1, 2];\n-    let mut vec2 = vec;\n-    vec2.push(3);\n-    vec2.push(4);\n-    vec2.push(5);\n-    vec2.push(6);\n-    vec.push(7);\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-        let mut snippet = SnippetData::new(cm.clone(), None, FormatMode::NewErrorFormat);\n-        for i in 0..4 {\n-            let span_veci = cm.span_substr(&foo, file_text, \"vec\", i);\n-            snippet.push(span_veci, false, None);\n-        }\n-\n-        let lines = snippet.render_lines();\n-        let text: String = make_string(&lines);\n-        println!(\"text=&r#\\\"\\n{}\\n\\\"#[1..]\", text);\n-        assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |\n-3 |      let mut vec = vec![0, 1, 2];\n-  |              ---   ---\n-4 |      let mut vec2 = vec;\n-  |              ---    ---\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn span_long_selection() {\n-        let file_text = r#\"\n-impl SomeTrait for () {\n-    fn foo(x: u32) {\n-        // impl 1\n-        // impl 2\n-        // impl 3\n-    }\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-        let mut snippet = SnippetData::new(cm.clone(), None, FormatMode::NewErrorFormat);\n-        let fn_span = cm.span_substr(&foo, file_text, \"fn\", 0);\n-        let rbrace_span = cm.span_substr(&foo, file_text, \"}\", 0);\n-        snippet.push(splice(fn_span, rbrace_span), false, None);\n-        let lines = snippet.render_lines();\n-        let text: String = make_string(&lines);\n-        println!(\"r#\\\"\\n{}\\\"\", text);\n-        assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |\n-3 |      fn foo(x: u32) {\n-  |      -\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn span_overlap_label() {\n-        // Test that we don't put `x_span` to the right of its highlight,\n-        // since there is another highlight that overlaps it.\n-\n-        let file_text = r#\"\n-    fn foo(x: u32) {\n-    }\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-        let mut snippet = SnippetData::new(cm.clone(), None, FormatMode::NewErrorFormat);\n-        let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x: u32)\", 0);\n-        let x_span = cm.span_substr(&foo, file_text, \"x\", 0);\n-        snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n-        snippet.push(x_span, false, Some(format!(\"x_span\")));\n-        let lines = snippet.render_lines();\n-        let text: String = make_string(&lines);\n-        println!(\"r#\\\"\\n{}\\\"\", text);\n-        assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |\n-2 |      fn foo(x: u32) {\n-  |      --------------\n-  |      |      |\n-  |      |      x_span\n-  |      fn_span\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn span_overlap_label2() {\n-        // Test that we don't put `x_span` to the right of its highlight,\n-        // since there is another highlight that overlaps it. In this\n-        // case, the overlap is only at the beginning, but it's still\n-        // better to show the beginning more clearly.\n-\n-        let file_text = r#\"\n-    fn foo(x: u32) {\n-    }\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-        let mut snippet = SnippetData::new(cm.clone(), None, FormatMode::NewErrorFormat);\n-        let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x\", 0);\n-        let x_span = cm.span_substr(&foo, file_text, \"x: u32)\", 0);\n-        snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n-        snippet.push(x_span, false, Some(format!(\"x_span\")));\n-        let lines = snippet.render_lines();\n-        let text: String = make_string(&lines);\n-        println!(\"r#\\\"\\n{}\\\"\", text);\n-        assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |\n-2 |      fn foo(x: u32) {\n-  |      --------------\n-  |      |      |\n-  |      |      x_span\n-  |      fn_span\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn span_overlap_label3() {\n-        // Test that we don't put `x_span` to the right of its highlight,\n-        // since there is another highlight that overlaps it. In this\n-        // case, the overlap is only at the beginning, but it's still\n-        // better to show the beginning more clearly.\n-\n-        let file_text = r#\"\n-    fn foo() {\n-       let closure = || {\n-           inner\n-       };\n-    }\n-}\n-\"#;\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-        let mut snippet = SnippetData::new(cm.clone(), None, FormatMode::NewErrorFormat);\n-\n-        let closure_span = {\n-            let closure_start_span = cm.span_substr(&foo, file_text, \"||\", 0);\n-            let closure_end_span = cm.span_substr(&foo, file_text, \"}\", 0);\n-            splice(closure_start_span, closure_end_span)\n-        };\n-\n-        let inner_span = cm.span_substr(&foo, file_text, \"inner\", 0);\n-\n-        snippet.push(closure_span, false, Some(format!(\"foo\")));\n-        snippet.push(inner_span, false, Some(format!(\"bar\")));\n-\n-        let lines = snippet.render_lines();\n-        let text: String = make_string(&lines);\n-        println!(\"r#\\\"\\n{}\\\"\", text);\n-        assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |\n-3 |         let closure = || {\n-  |                       - foo\n-4 |             inner\n-  |             ----- bar\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn span_empty() {\n-        // In one of the unit tests, we found that the parser sometimes\n-        // gives empty spans, and in particular it supplied an EOF span\n-        // like this one, which points at the very end. We want to\n-        // fallback gracefully in this case.\n-\n-        let file_text = r#\"\n-fn main() {\n-    struct Foo;\n-\n-    impl !Sync for Foo {}\n-\n-    unsafe impl Send for &'static Foo {\n-    // error: cross-crate traits with a default impl, like `core::marker::Send`,\n-    //        can only be implemented for a struct/enum type, not\n-    //        `&'static Foo`\n-}\"#;\n-\n-\n-        let cm = Rc::new(CodeMap::new());\n-        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-        let mut rbrace_span = cm.span_substr(&foo, file_text, \"}\", 1);\n-        rbrace_span.lo = rbrace_span.hi;\n-\n-        let mut snippet = SnippetData::new(cm.clone(),\n-                                           Some(rbrace_span),\n-                                           FormatMode::NewErrorFormat);\n-        snippet.push(rbrace_span, false, None);\n-        let lines = snippet.render_lines();\n-        let text: String = make_string(&lines);\n-        println!(\"r#\\\"\\n{}\\\"\", text);\n-        assert_eq!(text, &r#\"\n-  --> foo.rs:11:2\n-   |\n-11 |  }\n-   |   -\n-\"#[1..]);\n-    }\n }"}, {"sha": "c78a586763429ebc12e5e5417edc859015036ef5", "filename": "src/test/ui/codemap_tests/empty_span.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.rs?ref=1fd014a9654e11ae1bc7c0793c6b01b157d825cd", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+#![feature(optin_builtin_traits)]\n+fn main() {\n+    struct Foo;\n+\n+    impl !Sync for Foo {}\n+\n+    unsafe impl Send for &'static Foo { }\n+}"}, {"sha": "f3e04ef02409b86af8f99f942db21804f974d864", "filename": "src/test/ui/codemap_tests/empty_span.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fempty_span.stderr?ref=1fd014a9654e11ae1bc7c0793c6b01b157d825cd", "patch": "@@ -0,0 +1,8 @@\n+error[E0321]: cross-crate traits with a default impl, like `std::marker::Send`, can only be implemented for a struct/enum type, not `&'static main::Foo`\n+  --> $DIR/empty_span.rs:18:5\n+   |\n+18 |     unsafe impl Send for &'static Foo { }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "b06832c7628ed9f4df3c92aa4d5256020683c394", "filename": "src/test/ui/codemap_tests/huge_multispan_highlight.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.rs?ref=1fd014a9654e11ae1bc7c0793c6b01b157d825cd", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+\n+fn main() {\n+    let x = \"foo\";\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    let y = &mut x;\n+}\n+\n+\n+"}, {"sha": "6a898a434778e2af416723401227d83f02bc805e", "filename": "src/test/ui/codemap_tests/huge_multispan_highlight.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.stderr?ref=1fd014a9654e11ae1bc7c0793c6b01b157d825cd", "patch": "@@ -0,0 +1,11 @@\n+error: cannot borrow immutable local variable `x` as mutable\n+   --> $DIR/huge_multispan_highlight.rs:100:18\n+    |\n+14  |     let x = \"foo\";\n+    |         - use `mut x` here to make mutable\n+...\n+100 |     let y = &mut x;\n+    |                  ^ cannot borrow mutably\n+\n+error: aborting due to previous error\n+"}, {"sha": "7ea497a25c8321f81aac9ecf610a8e036d306ae7", "filename": "src/test/ui/codemap_tests/issue-11715.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-11715.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-11715.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-11715.rs?ref=1fd014a9654e11ae1bc7c0793c6b01b157d825cd", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+fn main() {\n+    let mut x = \"foo\";\n+    let y = &mut x;\n+    let z = &mut x;\n+}\n+\n+\n+"}, {"sha": "4947cbedd200e45ec424e508881480505c313b57", "filename": "src/test/ui/codemap_tests/issue-11715.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-11715.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-11715.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-11715.stderr?ref=1fd014a9654e11ae1bc7c0793c6b01b157d825cd", "patch": "@@ -0,0 +1,12 @@\n+error[E0499]: cannot borrow `x` as mutable more than once at a time\n+   --> $DIR/issue-11715.rs:100:18\n+    |\n+99  |     let y = &mut x;\n+    |                  - first mutable borrow occurs here\n+100 |     let z = &mut x;\n+    |                  ^ second mutable borrow occurs here\n+101 | }\n+    | - first borrow ends here\n+\n+error: aborting due to previous error\n+"}, {"sha": "2a5ee6f8711ef92846a867bce0cb20fbabbcb94a", "filename": "src/test/ui/codemap_tests/one_line.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.rs?ref=1fd014a9654e11ae1bc7c0793c6b01b157d825cd", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+\n+fn main() {\n+    let mut v = vec![Some(\"foo\"), Some(\"bar\")];\n+    v.push(v.pop().unwrap());\n+}"}, {"sha": "8f80489ea1aeb02539dc589d40bc4c4dc1b1a630", "filename": "src/test/ui/codemap_tests/one_line.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.stderr?ref=1fd014a9654e11ae1bc7c0793c6b01b157d825cd", "patch": "@@ -0,0 +1,11 @@\n+error[E0499]: cannot borrow `v` as mutable more than once at a time\n+  --> $DIR/one_line.rs:15:12\n+   |\n+15 |     v.push(v.pop().unwrap());\n+   |     -      ^               - first borrow ends here\n+   |     |      |\n+   |     |      second mutable borrow occurs here\n+   |     first mutable borrow occurs here\n+\n+error: aborting due to previous error\n+"}, {"sha": "5a90852392c081263c56f81c48c3b368e9e6bc24", "filename": "src/test/ui/codemap_tests/overlapping_spans.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.rs?ref=1fd014a9654e11ae1bc7c0793c6b01b157d825cd", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+#[derive(Debug)]\n+struct Foo { }\n+\n+struct S {f:String}\n+impl Drop for S {\n+    fn drop(&mut self) { println!(\"{}\", self.f); }\n+}\n+\n+fn main() {\n+    match (S {f:\"foo\".to_string()}) {\n+        S {f:_s} => {}\n+    }\n+}"}, {"sha": "cbcf154eaba50d79473f4a103ab3feb145e52614", "filename": "src/test/ui/codemap_tests/overlapping_spans.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.stderr?ref=1fd014a9654e11ae1bc7c0793c6b01b157d825cd", "patch": "@@ -0,0 +1,11 @@\n+error[E0509]: cannot move out of type `S`, which implements the `Drop` trait\n+  --> $DIR/overlapping_spans.rs:22:9\n+   |\n+22 |         S {f:_s} => {}\n+   |         ^^^^^--^\n+   |         |    |\n+   |         |    hint: to prevent move, use `ref _s` or `ref mut _s`\n+   |         cannot move out of here\n+\n+error: aborting due to previous error\n+"}, {"sha": "aaaee8c5577fe02700876f1d659f324215c55e19", "filename": "src/test/ui/codemap_tests/tab.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.rs?ref=1fd014a9654e11ae1bc7c0793c6b01b157d825cd", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+// ignore-tidy-tab\n+fn main() {\n+\tbar;\n+}\n+"}, {"sha": "543c02fb701f35507034ad505ca50eac76cd3fa0", "filename": "src/test/ui/codemap_tests/tab.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.stderr?ref=1fd014a9654e11ae1bc7c0793c6b01b157d825cd", "patch": "@@ -0,0 +1,8 @@\n+error[E0425]: unresolved name `bar`\n+  --> $DIR/tab.rs:14:2\n+   |\n+14 | \\tbar;\n+   | \\t^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "53e240e8c4738ca494e26fffa9d31891955e3f5e", "filename": "src/test/ui/codemap_tests/two_files.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.rs?ref=1fd014a9654e11ae1bc7c0793c6b01b157d825cd", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+include!(\"two_files_data.rs\");\n+\n+struct Baz { }\n+\n+impl Bar for Baz { }\n+\n+fn main() { }"}, {"sha": "6c388cd69395b272b7dc7d224e8a1b9ac708d09d", "filename": "src/test/ui/codemap_tests/two_files.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr?ref=1fd014a9654e11ae1bc7c0793c6b01b157d825cd", "patch": "@@ -0,0 +1,13 @@\n+error[E0404]: `Bar` is not a trait\n+  --> $DIR/two_files.rs:16:6\n+   |\n+16 | impl Bar for Baz { }\n+   |      ^^^ `Bar` is not a trait\n+   | \n+  ::: $DIR/two_files_data.rs\n+   |\n+15 | type Bar = Foo;\n+   | --------------- type aliases cannot be used for traits\n+\n+error: cannot continue compilation due to previous error\n+"}, {"sha": "412c40f8e811b9e52d54a41f35c4af45371cc213", "filename": "src/test/ui/codemap_tests/two_files_data.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fd014a9654e11ae1bc7c0793c6b01b157d825cd/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files_data.rs?ref=1fd014a9654e11ae1bc7c0793c6b01b157d825cd", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustc-env:RUST_NEW_ERROR_FORMAT\n+// ignore-test\n+trait Foo { }\n+\n+type Bar = Foo;\n+"}]}