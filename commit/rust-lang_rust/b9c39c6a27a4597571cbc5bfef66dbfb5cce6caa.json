{"sha": "b9c39c6a27a4597571cbc5bfef66dbfb5cce6caa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5YzM5YzZhMjdhNDU5NzU3MWNiYzViZmVmNjZkYmZiNWNjZTZjYWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-03T12:32:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-03T12:32:07Z"}, "message": "auto merge of #11228 : sfackler/rust/syntaxenv, r=pcwalton\n\nI'd really like to be able to do something like\r\n\r\n```rust\r\nstruct MapChain<'next, K, V> {\r\n    info: BlockInfo,\r\n    map: HashMap<K, V>,\r\n    next: Option<&'next mut MapChain<'next, K, V>\r\n}\r\n```\r\n\r\nbut I can't get the lifetimes to work out.", "tree": {"sha": "a36ddd17930b37372ad4bdb856f800d1310ac9fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a36ddd17930b37372ad4bdb856f800d1310ac9fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9c39c6a27a4597571cbc5bfef66dbfb5cce6caa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9c39c6a27a4597571cbc5bfef66dbfb5cce6caa", "html_url": "https://github.com/rust-lang/rust/commit/b9c39c6a27a4597571cbc5bfef66dbfb5cce6caa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9c39c6a27a4597571cbc5bfef66dbfb5cce6caa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfde02924777711986fa783288fd9e65efe1ba5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfde02924777711986fa783288fd9e65efe1ba5e", "html_url": "https://github.com/rust-lang/rust/commit/bfde02924777711986fa783288fd9e65efe1ba5e"}, {"sha": "b74613bdc4c25fd2dc1c93db9de2eca8cd6d3399", "url": "https://api.github.com/repos/rust-lang/rust/commits/b74613bdc4c25fd2dc1c93db9de2eca8cd6d3399", "html_url": "https://github.com/rust-lang/rust/commit/b74613bdc4c25fd2dc1c93db9de2eca8cd6d3399"}], "stats": {"total": 376, "additions": 129, "deletions": 247}, "files": [{"sha": "03e028ea1f12eb0eb5e97720f86fe2f11e7d16a9", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 88, "deletions": 178, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/b9c39c6a27a4597571cbc5bfef66dbfb5cce6caa/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c39c6a27a4597571cbc5bfef66dbfb5cce6caa/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=b9c39c6a27a4597571cbc5bfef66dbfb5cce6caa", "patch": "@@ -155,57 +155,48 @@ pub enum SyntaxExtension {\n // The SyntaxEnv is the environment that's threaded through the expansion\n // of macros. It contains bindings for macros, and also a special binding\n // for \" block\" (not a legal identifier) that maps to a BlockInfo\n-pub type SyntaxEnv = @mut MapChain<Name, Transformer>;\n-\n-// Transformer : the codomain of SyntaxEnvs\n-\n-pub enum Transformer {\n-    // this identifier maps to a syntax extension or macro\n-    SE(SyntaxExtension),\n-    // blockinfo : this is ... well, it's simpler than threading\n-    // another whole data stack-structured data structure through\n-    // expansion. Basically, there's an invariant that every\n-    // map must contain a binding for \" block\".\n-    BlockInfo(BlockInfo)\n-}\n+pub type SyntaxEnv = MapChain<Name, SyntaxExtension>;\n \n pub struct BlockInfo {\n     // should macros escape from this scope?\n     macros_escape : bool,\n     // what are the pending renames?\n-    pending_renames : @mut RenameList\n+    pending_renames : RenameList\n+}\n+\n+impl BlockInfo {\n+    pub fn new() -> BlockInfo {\n+        BlockInfo {\n+            macros_escape: false,\n+            pending_renames: ~[]\n+        }\n+    }\n }\n \n // a list of ident->name renamings\n-type RenameList = ~[(ast::Ident,Name)];\n+pub type RenameList = ~[(ast::Ident,Name)];\n \n // The base map of methods for expanding syntax extension\n // AST nodes into full ASTs\n pub fn syntax_expander_table() -> SyntaxEnv {\n     // utility function to simplify creating NormalTT syntax extensions\n     fn builtin_normal_tt_no_ctxt(f: SyntaxExpanderTTFunNoCtxt)\n-                                 -> @Transformer {\n-        @SE(NormalTT(@SyntaxExpanderTT{\n+                                 -> SyntaxExtension {\n+        NormalTT(@SyntaxExpanderTT{\n             expander: SyntaxExpanderTTExpanderWithoutContext(f),\n             span: None,\n         } as @SyntaxExpanderTTTrait,\n-        None))\n+        None)\n     }\n \n-    let mut syntax_expanders = HashMap::new();\n-    // NB identifier starts with space, and can't conflict with legal idents\n-    syntax_expanders.insert(intern(&\" block\"),\n-                            @BlockInfo(BlockInfo{\n-                                macros_escape : false,\n-                                pending_renames : @mut ~[]\n-                            }));\n+    let mut syntax_expanders = MapChain::new();\n     syntax_expanders.insert(intern(&\"macro_rules\"),\n-                            @SE(IdentTT(@SyntaxExpanderTTItem {\n+                            IdentTT(@SyntaxExpanderTTItem {\n                                 expander: SyntaxExpanderTTItemExpanderWithContext(\n                                     ext::tt::macro_rules::add_new_extension),\n                                 span: None,\n                             } as @SyntaxExpanderTTItemTrait,\n-                            None)));\n+                            None));\n     syntax_expanders.insert(intern(&\"fmt\"),\n                             builtin_normal_tt_no_ctxt(\n                                 ext::fmt::expand_syntax_ext));\n@@ -231,8 +222,7 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n                             builtin_normal_tt_no_ctxt(\n                                     ext::log_syntax::expand_syntax_ext));\n     syntax_expanders.insert(intern(&\"deriving\"),\n-                            @SE(ItemDecorator(\n-                                ext::deriving::expand_meta_deriving)));\n+                            ItemDecorator(ext::deriving::expand_meta_deriving));\n \n     // Quasi-quoting expanders\n     syntax_expanders.insert(intern(&\"quote_tokens\"),\n@@ -287,7 +277,7 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n     syntax_expanders.insert(intern(&\"trace_macros\"),\n                             builtin_normal_tt_no_ctxt(\n                                     ext::trace_macros::expand_trace_macros));\n-    MapChain::new(~syntax_expanders)\n+    syntax_expanders\n }\n \n // One of these is made during expansion and incrementally updated as we go;\n@@ -298,11 +288,6 @@ pub struct ExtCtxt {\n     cfg: ast::CrateConfig,\n     backtrace: Option<@ExpnInfo>,\n \n-    // These two @mut's should really not be here,\n-    // but the self types for CtxtRepr are all wrong\n-    // and there are bugs in the code for object\n-    // types that make this hard to get right at the\n-    // moment. - nmatsakis\n     mod_path: ~[ast::Ident],\n     trace_mac: bool\n }\n@@ -324,7 +309,7 @@ impl ExtCtxt {\n             match e.node {\n                 ast::ExprMac(..) => {\n                     let mut expander = expand::MacroExpander {\n-                        extsbox: @mut syntax_expander_table(),\n+                        extsbox: syntax_expander_table(),\n                         cx: self,\n                     };\n                     e = expand::expand_expr(e, &mut expander);\n@@ -459,11 +444,7 @@ pub fn get_exprs_from_tts(cx: &ExtCtxt,\n // we want to implement the notion of a transformation\n // environment.\n \n-// This environment maps Names to Transformers.\n-// Initially, this includes macro definitions and\n-// block directives.\n-\n-\n+// This environment maps Names to SyntaxExtensions.\n \n // Actually, the following implementation is parameterized\n // by both key and value types.\n@@ -478,169 +459,98 @@ pub fn get_exprs_from_tts(cx: &ExtCtxt,\n // able to refer to a macro that was added to an enclosing\n // scope lexically later than the deeper scope.\n \n-// Note on choice of representation: I've been pushed to\n-// use a top-level managed pointer by some difficulties\n-// with pushing and popping functionally, and the ownership\n-// issues.  As a result, the values returned by the table\n-// also need to be managed; the &'a ... type that Maps\n-// return won't work for things that need to get outside\n-// of that managed pointer.  The easiest way to do this\n-// is just to insist that the values in the tables are\n-// managed to begin with.\n-\n-// a transformer env is either a base map or a map on top\n-// of another chain.\n-pub enum MapChain<K,V> {\n-    BaseMapChain(~HashMap<K,@V>),\n-    ConsMapChain(~HashMap<K,@V>,@mut MapChain<K,V>)\n+// Only generic to make it easy to test\n+struct MapChainFrame<K, V> {\n+    info: BlockInfo,\n+    map: HashMap<K, V>,\n }\n \n+// Only generic to make it easy to test\n+pub struct MapChain<K, V> {\n+    priv chain: ~[MapChainFrame<K, V>],\n+}\n \n-// get the map from an env frame\n-impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n-    // Constructor. I don't think we need a zero-arg one.\n-    pub fn new(init: ~HashMap<K,@V>) -> @mut MapChain<K,V> {\n-        @mut BaseMapChain(init)\n+impl<K: Hash+Eq, V> MapChain<K, V> {\n+    pub fn new() -> MapChain<K, V> {\n+        let mut map = MapChain { chain: ~[] };\n+        map.push_frame();\n+        map\n     }\n \n-    // add a new frame to the environment (functionally)\n-    pub fn push_frame (@mut self) -> @mut MapChain<K,V> {\n-        @mut ConsMapChain(~HashMap::new() ,self)\n+    pub fn push_frame(&mut self) {\n+        self.chain.push(MapChainFrame {\n+            info: BlockInfo::new(),\n+            map: HashMap::new(),\n+        });\n     }\n \n-// no need for pop, it'll just be functional.\n-\n-    // utility fn...\n-\n-    // ugh: can't get this to compile with mut because of the\n-    // lack of flow sensitivity.\n-    pub fn get_map<'a>(&'a self) -> &'a HashMap<K,@V> {\n-        match *self {\n-            BaseMapChain (~ref map) => map,\n-            ConsMapChain (~ref map,_) => map\n-        }\n+    pub fn pop_frame(&mut self) {\n+        assert!(self.chain.len() > 1, \"too many pops on MapChain!\");\n+        self.chain.pop();\n     }\n \n-// traits just don't work anywhere...?\n-//impl Map<Name,SyntaxExtension> for MapChain {\n-\n-    pub fn contains_key (&self, key: &K) -> bool {\n-        match *self {\n-            BaseMapChain (ref map) => map.contains_key(key),\n-            ConsMapChain (ref map,ref rest) =>\n-            (map.contains_key(key)\n-             || rest.contains_key(key))\n+    fn find_escape_frame<'a>(&'a mut self) -> &'a mut MapChainFrame<K, V> {\n+        for (i, frame) in self.chain.mut_iter().enumerate().invert() {\n+            if !frame.info.macros_escape || i == 0 {\n+                return frame\n+            }\n         }\n-    }\n-    // should each_key and each_value operate on shadowed\n-    // names? I think not.\n-    // delaying implementing this....\n-    pub fn each_key (&self, _f: |&K| -> bool) {\n-        fail!(\"unimplemented 2013-02-15T10:01\");\n-    }\n-\n-    pub fn each_value (&self, _f: |&V| -> bool) {\n-        fail!(\"unimplemented 2013-02-15T10:02\");\n+        unreachable!()\n     }\n \n-    // Returns a copy of the value that the name maps to.\n-    // Goes down the chain 'til it finds one (or bottom out).\n-    pub fn find (&self, key: &K) -> Option<@V> {\n-        match self.get_map().find (key) {\n-            Some(ref v) => Some(**v),\n-            None => match *self {\n-                BaseMapChain (_) => None,\n-                ConsMapChain (_,ref rest) => rest.find(key)\n+    pub fn find<'a>(&'a self, k: &K) -> Option<&'a V> {\n+        for frame in self.chain.iter().invert() {\n+            match frame.map.find(k) {\n+                Some(v) => return Some(v),\n+                None => {}\n             }\n         }\n+        None\n     }\n \n-    pub fn find_in_topmost_frame(&self, key: &K) -> Option<@V> {\n-        let map = match *self {\n-            BaseMapChain(ref map) => map,\n-            ConsMapChain(ref map,_) => map\n-        };\n-        // strip one layer of indirection off the pointer.\n-        map.find(key).map(|r| {*r})\n-    }\n-\n-    // insert the binding into the top-level map\n-    pub fn insert (&mut self, key: K, ext: @V) -> bool {\n-        // can't abstract over get_map because of flow sensitivity...\n-        match *self {\n-            BaseMapChain (~ref mut map) => map.insert(key, ext),\n-            ConsMapChain (~ref mut map,_) => map.insert(key,ext)\n-        }\n+    pub fn insert(&mut self, k: K, v: V) {\n+        self.find_escape_frame().map.insert(k, v);\n     }\n-    // insert the binding into the topmost frame for which the binding\n-    // associated with 'n' exists and satisfies pred\n-    // ... there are definitely some opportunities for abstraction\n-    // here that I'm ignoring. (e.g., manufacturing a predicate on\n-    // the maps in the chain, and using an abstract \"find\".\n-    pub fn insert_into_frame(&mut self,\n-                             key: K,\n-                             ext: @V,\n-                             n: K,\n-                             pred: |&@V| -> bool) {\n-        match *self {\n-            BaseMapChain (~ref mut map) => {\n-                if satisfies_pred(map,&n,pred) {\n-                    map.insert(key,ext);\n-                } else {\n-                    fail!(\"expected map chain containing satisfying frame\")\n-                }\n-            },\n-            ConsMapChain (~ref mut map, rest) => {\n-                if satisfies_pred(map,&n,|v|pred(v)) {\n-                    map.insert(key,ext);\n-                } else {\n-                    rest.insert_into_frame(key,ext,n,pred)\n-                }\n-            }\n-        }\n-    }\n-}\n \n-// returns true if the binding for 'n' satisfies 'pred' in 'map'\n-fn satisfies_pred<K:Eq + Hash + IterBytes,\n-                  V>(\n-                  map: &mut HashMap<K,V>,\n-                  n: &K,\n-                  pred: |&V| -> bool)\n-                  -> bool {\n-    match map.find(n) {\n-        Some(ref v) => (pred(*v)),\n-        None => false\n+    pub fn info<'a>(&'a mut self) -> &'a mut BlockInfo {\n+        &mut self.chain[self.chain.len()-1].info\n     }\n }\n \n #[cfg(test)]\n mod test {\n     use super::MapChain;\n-    use std::hashmap::HashMap;\n \n     #[test]\n     fn testenv() {\n-        let mut a = HashMap::new();\n-        a.insert (@\"abc\",@15);\n-        let m = MapChain::new(~a);\n-        m.insert (@\"def\",@16);\n-        assert_eq!(m.find(&@\"abc\"),Some(@15));\n-        assert_eq!(m.find(&@\"def\"),Some(@16));\n-        assert_eq!(*(m.find(&@\"abc\").unwrap()),15);\n-        assert_eq!(*(m.find(&@\"def\").unwrap()),16);\n-        let n = m.push_frame();\n-        // old bindings are still present:\n-        assert_eq!(*(n.find(&@\"abc\").unwrap()),15);\n-        assert_eq!(*(n.find(&@\"def\").unwrap()),16);\n-        n.insert (@\"def\",@17);\n-        // n shows the new binding\n-        assert_eq!(*(n.find(&@\"abc\").unwrap()),15);\n-        assert_eq!(*(n.find(&@\"def\").unwrap()),17);\n-        // ... but m still has the old ones\n-        assert_eq!(m.find(&@\"abc\"),Some(@15));\n-        assert_eq!(m.find(&@\"def\"),Some(@16));\n-        assert_eq!(*(m.find(&@\"abc\").unwrap()),15);\n-        assert_eq!(*(m.find(&@\"def\").unwrap()),16);\n+        let mut m = MapChain::new();\n+        let (a,b,c,d) = (\"a\", \"b\", \"c\", \"d\");\n+        m.insert(1, a);\n+        assert_eq!(Some(&a), m.find(&1));\n+\n+        m.push_frame();\n+        m.info().macros_escape = true;\n+        m.insert(2, b);\n+        assert_eq!(Some(&a), m.find(&1));\n+        assert_eq!(Some(&b), m.find(&2));\n+        m.pop_frame();\n+\n+        assert_eq!(Some(&a), m.find(&1));\n+        assert_eq!(Some(&b), m.find(&2));\n+\n+        m.push_frame();\n+        m.push_frame();\n+        m.info().macros_escape = true;\n+        m.insert(3, c);\n+        assert_eq!(Some(&c), m.find(&3));\n+        m.pop_frame();\n+        assert_eq!(Some(&c), m.find(&3));\n+        m.pop_frame();\n+        assert_eq!(None, m.find(&3));\n+\n+        m.push_frame();\n+        m.insert(4, d);\n+        m.pop_frame();\n+        assert_eq!(None, m.find(&4));\n     }\n }"}, {"sha": "1d9620d405f80be0fb8b199ccccc253130fbabe0", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 41, "deletions": 69, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/b9c39c6a27a4597571cbc5bfef66dbfb5cce6caa/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9c39c6a27a4597571cbc5bfef66dbfb5cce6caa/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b9c39c6a27a4597571cbc5bfef66dbfb5cce6caa", "patch": "@@ -53,13 +53,13 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                     let extname = &pth.segments[0].identifier;\n                     let extnamestr = ident_to_str(extname);\n                     // leaving explicit deref here to highlight unbox op:\n-                    match (*fld.extsbox).find(&extname.name) {\n+                    match fld.extsbox.find(&extname.name) {\n                         None => {\n                             fld.cx.span_fatal(\n                                 pth.span,\n                                 format!(\"macro undefined: '{}'\", extnamestr))\n                         }\n-                        Some(@SE(NormalTT(expandfun, exp_span))) => {\n+                        Some(&NormalTT(expandfun, exp_span)) => {\n                             fld.cx.bt_push(ExpnInfo {\n                                 call_site: e.span,\n                                 callee: NameAndSpan {\n@@ -221,8 +221,8 @@ pub fn expand_mod_items(module_: &ast::_mod, fld: &mut MacroExpander) -> ast::_m\n         item.attrs.rev_iter().fold(~[*item], |items, attr| {\n             let mname = attr.name();\n \n-            match (*fld.extsbox).find(&intern(mname)) {\n-              Some(@SE(ItemDecorator(dec_fn))) => {\n+            match fld.extsbox.find(&intern(mname)) {\n+              Some(&ItemDecorator(dec_fn)) => {\n                   fld.cx.bt_push(ExpnInfo {\n                       call_site: attr.span,\n                       callee: NameAndSpan {\n@@ -249,19 +249,14 @@ pub fn expand_mod_items(module_: &ast::_mod, fld: &mut MacroExpander) -> ast::_m\n // eval $e with a new exts frame:\n macro_rules! with_exts_frame (\n     ($extsboxexpr:expr,$macros_escape:expr,$e:expr) =>\n-    ({let extsbox = $extsboxexpr;\n-      let oldexts = *extsbox;\n-      *extsbox = oldexts.push_frame();\n-      extsbox.insert(intern(special_block_name),\n-                     @BlockInfo(BlockInfo{macros_escape:$macros_escape,pending_renames:@mut ~[]}));\n+    ({$extsboxexpr.push_frame();\n+      $extsboxexpr.info().macros_escape = $macros_escape;\n       let result = $e;\n-      *extsbox = oldexts;\n+      $extsboxexpr.pop_frame();\n       result\n      })\n )\n \n-static special_block_name : &'static str = \" block\";\n-\n // When we enter a module, record it, for the sake of `module!`\n pub fn expand_item(it: @ast::item, fld: &mut MacroExpander)\n                    -> SmallVector<@ast::item> {\n@@ -302,11 +297,11 @@ pub fn expand_item_mac(it: @ast::item, fld: &mut MacroExpander)\n     let extname = &pth.segments[0].identifier;\n     let extnamestr = ident_to_str(extname);\n     let fm = fresh_mark();\n-    let expanded = match (*fld.extsbox).find(&extname.name) {\n+    let expanded = match fld.extsbox.find(&extname.name) {\n         None => fld.cx.span_fatal(pth.span,\n                                   format!(\"macro undefined: '{}!'\", extnamestr)),\n \n-        Some(@SE(NormalTT(expander, span))) => {\n+        Some(&NormalTT(expander, span)) => {\n             if it.ident.name != parse::token::special_idents::invalid.name {\n                 fld.cx.span_fatal(pth.span,\n                                   format!(\"macro {}! expects no ident argument, \\\n@@ -326,7 +321,7 @@ pub fn expand_item_mac(it: @ast::item, fld: &mut MacroExpander)\n             let marked_ctxt = new_mark(fm,ctxt);\n             expander.expand(fld.cx, it.span, marked_before, marked_ctxt)\n         }\n-        Some(@SE(IdentTT(expander, span))) => {\n+        Some(&IdentTT(expander, span)) => {\n             if it.ident.name == parse::token::special_idents::invalid.name {\n                 fld.cx.span_fatal(pth.span,\n                                   format!(\"macro {}! expects an ident argument\",\n@@ -369,31 +364,14 @@ pub fn expand_item_mac(it: @ast::item, fld: &mut MacroExpander)\n         MRDef(ref mdef) => {\n             // yikes... no idea how to apply the mark to this. I'm afraid\n             // we're going to have to wait-and-see on this one.\n-            insert_macro(*fld.extsbox,intern(mdef.name), @SE((*mdef).ext));\n+            fld.extsbox.insert(intern(mdef.name), (*mdef).ext);\n             SmallVector::zero()\n         }\n     };\n     fld.cx.bt_pop();\n     return items;\n }\n \n-\n-// insert a macro into the innermost frame that doesn't have the\n-// macro_escape tag.\n-fn insert_macro(exts: SyntaxEnv, name: ast::Name, transformer: @Transformer) {\n-    let is_non_escaping_block =\n-        |t : &@Transformer| -> bool{\n-        match t {\n-            &@BlockInfo(BlockInfo {macros_escape:false,..}) => true,\n-            &@BlockInfo(BlockInfo {..}) => false,\n-            _ => fail!(\"special identifier {:?} was bound to a non-BlockInfo\",\n-                        special_block_name)\n-        }\n-    };\n-    exts.insert_into_frame(name,transformer,intern(special_block_name),\n-                           is_non_escaping_block)\n-}\n-\n // expand a stmt\n pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n     // why the copying here and not in expand_expr?\n@@ -414,12 +392,12 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n     }\n     let extname = &pth.segments[0].identifier;\n     let extnamestr = ident_to_str(extname);\n-    let fully_expanded: SmallVector<@Stmt> = match (*fld.extsbox).find(&extname.name) {\n+    let fully_expanded: SmallVector<@Stmt> = match fld.extsbox.find(&extname.name) {\n         None => {\n             fld.cx.span_fatal(pth.span, format!(\"macro undefined: '{}'\", extnamestr))\n         }\n \n-        Some(@SE(NormalTT(expandfun, exp_span))) => {\n+        Some(&NormalTT(expandfun, exp_span)) => {\n             fld.cx.bt_push(ExpnInfo {\n                 call_site: s.span,\n                 callee: NameAndSpan {\n@@ -497,8 +475,6 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n             span: stmt_span\n         },\n         node_id) => {\n-            let block_info = get_block_info(*fld.extsbox);\n-            let pending_renames = block_info.pending_renames;\n \n             // take it apart:\n             let @Local {\n@@ -522,12 +498,16 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n                 let new_name = fresh_name(ident);\n                 new_pending_renames.push((*ident,new_name));\n             }\n-            let mut rename_fld = renames_to_fold(new_pending_renames);\n-            // rewrite the pattern using the new names (the old ones\n-            // have already been applied):\n-            let rewritten_pat = rename_fld.fold_pat(expanded_pat);\n+            let rewritten_pat = {\n+                let mut rename_fld = renames_to_fold(new_pending_renames);\n+                // rewrite the pattern using the new names (the old ones\n+                // have already been applied):\n+                rename_fld.fold_pat(expanded_pat)\n+            };\n             // add them to the existing pending renames:\n-            for pr in new_pending_renames.iter() {pending_renames.push(*pr)}\n+            for pr in new_pending_renames.iter() {\n+                fld.extsbox.info().pending_renames.push(*pr)\n+            }\n             // also, don't forget to expand the init:\n             let new_init_opt = init.map(|e| fld.fold_expr(e));\n             let rewritten_local =\n@@ -618,16 +598,23 @@ pub fn expand_block(blk: &Block, fld: &mut MacroExpander) -> P<Block> {\n \n // expand the elements of a block.\n pub fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n-    let block_info = get_block_info(*fld.extsbox);\n-    let pending_renames = block_info.pending_renames;\n-    let mut rename_fld = renames_to_fold(pending_renames);\n     let new_view_items = b.view_items.map(|x| fld.fold_view_item(x));\n     let new_stmts = b.stmts.iter()\n-            .map(|x| rename_fld.fold_stmt(*x)\n-                 .expect_one(\"rename_fold didn't return one value\"))\n+            .map(|x| {\n+                let pending_renames = &mut fld.extsbox.info().pending_renames;\n+                let mut rename_fld = renames_to_fold(pending_renames);\n+                rename_fld.fold_stmt(*x).expect_one(\"rename_fold didn't return one value\")\n+             })\n             .flat_map(|x| fld.fold_stmt(x).move_iter())\n             .collect();\n-    let new_expr = b.expr.map(|x| fld.fold_expr(rename_fld.fold_expr(x)));\n+    let new_expr = b.expr.map(|x| {\n+        let expr = {\n+            let pending_renames = &mut fld.extsbox.info().pending_renames;\n+            let mut rename_fld = renames_to_fold(pending_renames);\n+            rename_fld.fold_expr(x)\n+        };\n+        fld.fold_expr(expr)\n+    });\n     P(Block {\n         view_items: new_view_items,\n         stmts: new_stmts,\n@@ -638,20 +625,11 @@ pub fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n     })\n }\n \n-// get the (innermost) BlockInfo from an exts stack\n-fn get_block_info(exts : SyntaxEnv) -> BlockInfo {\n-    match exts.find_in_topmost_frame(&intern(special_block_name)) {\n-        Some(@BlockInfo(bi)) => bi,\n-        _ => fail!(\"special identifier {:?} was bound to a non-BlockInfo\",\n-                    @\" block\")\n-    }\n-}\n-\n-struct IdentRenamer {\n-    renames: @mut ~[(ast::Ident,ast::Name)],\n+struct IdentRenamer<'a> {\n+    renames: &'a mut RenameList,\n }\n \n-impl ast_fold for IdentRenamer {\n+impl<'a> ast_fold for IdentRenamer<'a> {\n     fn fold_ident(&mut self, id: ast::Ident) -> ast::Ident {\n         let new_ctxt = self.renames.iter().fold(id.ctxt, |ctxt, &(from, to)| {\n             new_rename(from, to, ctxt)\n@@ -665,7 +643,7 @@ impl ast_fold for IdentRenamer {\n \n // given a mutable list of renames, return a tree-folder that applies those\n // renames.\n-pub fn renames_to_fold(renames: @mut ~[(ast::Ident,ast::Name)]) -> IdentRenamer {\n+pub fn renames_to_fold<'a>(renames: &'a mut RenameList) -> IdentRenamer<'a> {\n     IdentRenamer {\n         renames: renames,\n     }\n@@ -931,7 +909,7 @@ pub fn inject_std_macros(parse_sess: @mut parse::ParseSess,\n }\n \n pub struct MacroExpander<'a> {\n-    extsbox: @mut SyntaxEnv,\n+    extsbox: SyntaxEnv,\n     cx: &'a mut ExtCtxt,\n }\n \n@@ -964,15 +942,9 @@ impl<'a> ast_fold for MacroExpander<'a> {\n pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n                     cfg: ast::CrateConfig,\n                     c: Crate) -> Crate {\n-    // adding *another* layer of indirection here so that the block\n-    // visitor can swap out one exts table for another for the duration\n-    // of the block.  The cleaner alternative would be to thread the\n-    // exts table through the fold, but that would require updating\n-    // every method/element of AstFoldFns in fold.rs.\n-    let extsbox = syntax_expander_table();\n     let mut cx = ExtCtxt::new(parse_sess, cfg.clone());\n     let mut expander = MacroExpander {\n-        extsbox: @mut extsbox,\n+        extsbox: syntax_expander_table(),\n         cx: &mut cx,\n     };\n "}]}