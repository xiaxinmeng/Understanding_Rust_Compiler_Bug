{"sha": "147330cc3603260d17085f3abcf7e62ca01b44ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0NzMzMGNjMzYwMzI2MGQxNzA4NWYzYWJjZjdlNjJjYTAxYjQ0ZWY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-08T18:08:11Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-17T15:29:19Z"}, "message": "even when not linking, create stub .rlib files to fool cargo", "tree": {"sha": "cab4c35343ec16495a21db0f41d74e86c5b8dc12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cab4c35343ec16495a21db0f41d74e86c5b8dc12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/147330cc3603260d17085f3abcf7e62ca01b44ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/147330cc3603260d17085f3abcf7e62ca01b44ef", "html_url": "https://github.com/rust-lang/rust/commit/147330cc3603260d17085f3abcf7e62ca01b44ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/147330cc3603260d17085f3abcf7e62ca01b44ef/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0019fe2459eb353688c8578459eded7d17359d22", "url": "https://api.github.com/repos/rust-lang/rust/commits/0019fe2459eb353688c8578459eded7d17359d22", "html_url": "https://github.com/rust-lang/rust/commit/0019fe2459eb353688c8578459eded7d17359d22"}], "stats": {"total": 99, "additions": 61, "deletions": 38}, "files": [{"sha": "1aa1d4d87e4476849e818979d7066f90465e87b0", "filename": "cargo-miri/bin.rs", "status": "modified", "additions": 61, "deletions": 38, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/147330cc3603260d17085f3abcf7e62ca01b44ef/cargo-miri%2Fbin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/147330cc3603260d17085f3abcf7e62ca01b44ef/cargo-miri%2Fbin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fbin.rs?ref=147330cc3603260d17085f3abcf7e62ca01b44ef", "patch": "@@ -136,9 +136,13 @@ fn xargo_check() -> Command {\n     Command::new(env::var_os(\"XARGO_CHECK\").unwrap_or_else(|| OsString::from(\"xargo-check\")))\n }\n \n-fn exec(mut cmd: Command) -> ! {\n+/// Execute the command if it fails, fail this process with the same exit code.\n+/// Otherwise, continue.\n+fn exec(mut cmd: Command) {\n     let exit_status = cmd.status().expect(\"failed to run command\");\n-    std::process::exit(exit_status.code().unwrap_or(-1))\n+    if exit_status.success().not() {\n+        std::process::exit(exit_status.code().unwrap_or(-1))\n+    }\n }\n \n fn xargo_version() -> Option<(u32, u32, u32)> {\n@@ -454,6 +458,20 @@ fn phase_cargo_rustc(args: env::Args) {\n         (is_bin || is_test) && !print\n     }\n \n+    fn out_filename(prefix: &str, suffix: &str) -> PathBuf {\n+        let mut path = PathBuf::from(get_arg_flag_value(\"--out-dir\").unwrap());\n+        path.push(format!(\n+            \"{}{}{}{}\",\n+            prefix,\n+            get_arg_flag_value(\"--crate-name\").unwrap(),\n+            // This is technically a `-C` flag but the prefix seems unique enough...\n+            // (and cargo passes this before the filename so it should be unique)\n+            get_arg_flag_value(\"extra-filename\").unwrap_or(String::new()),\n+            suffix,\n+        ));\n+        path\n+    }\n+\n     let verbose = std::env::var_os(\"MIRI_VERBOSE\").is_some();\n     let target_crate = is_target_crate();\n \n@@ -464,59 +482,57 @@ fn phase_cargo_rustc(args: env::Args) {\n         // Instead of compiling, we write JSON into the output file with all the relevant command-line flags\n         // and environment variables; this is used when cargo calls us again in the CARGO_TARGET_RUNNER phase.\n         let info = CrateRunInfo::collect(args);\n+        // FIXME: Windows might need a \".exe\" suffix.\n+        let filename = out_filename(\"\", \"\");\n \n-        let mut path = PathBuf::from(get_arg_flag_value(\"--out-dir\").unwrap());\n-        path.push(format!(\n-            \"{}{}\",\n-            get_arg_flag_value(\"--crate-name\").unwrap(),\n-            // This is technically a `-C` flag but the prefix seems unique enough...\n-            // (and cargo passes this before the filename so it should be unique)\n-            get_arg_flag_value(\"extra-filename\").unwrap_or(String::new()),\n-        ));\n         if verbose {\n-            eprintln!(\"[cargo-miri rustc] writing run info to {:?}\", path.display());\n+            eprintln!(\"[cargo-miri rustc] writing run info to {:?}\", filename.display());\n         }\n \n-        let file = File::create(&path)\n-            .unwrap_or_else(|_| show_error(format!(\"Cannot create {:?}\", path.display())));\n+        let file = File::create(&filename)\n+            .unwrap_or_else(|_| show_error(format!(\"Cannot create {:?}\", filename.display())));\n         let file = BufWriter::new(file);\n         serde_json::ser::to_writer(file, &info)\n-            .unwrap_or_else(|_| show_error(format!(\"Cannot write to {:?}\", path.display())));\n+            .unwrap_or_else(|_| show_error(format!(\"Cannot write to {:?}\", filename.display())));\n         return;\n     }\n \n     let mut cmd = miri();\n-    // Forward arguments, but (only for target crates!) remove \"link\" from \"--emit\" to make this a check-only build.\n-    let emit_flag = \"--emit\";\n-    for arg in args {\n-        if target_crate && arg.starts_with(emit_flag) {\n-            // Patch this argument. First, extract its value.\n-            let val = &arg[emit_flag.len()..];\n-            assert!(val.starts_with(\"=\"), \"`cargo` should pass `--emit=X` as one argument\");\n-            let val = &val[1..];\n-            let mut val: Vec<_> = val.split(',').collect();\n-            // Now make sure \"link\" is not in there, but \"metadata\" is.\n-            if let Some(i) = val.iter().position(|&s| s == \"link\") {\n-                val.remove(i);\n-                if !val.iter().any(|&s| s == \"metadata\") {\n-                    val.push(\"metadata\");\n+    let mut emit_link_hack = false;\n+    // Arguments are treated very differently depending on whether this crate is\n+    // for interpretation by Miri, or for use by a build script / proc macro.\n+    if target_crate {\n+        // Forward arguments, butremove \"link\" from \"--emit\" to make this a check-only build.\n+        let emit_flag = \"--emit\";\n+        for arg in args {\n+            if arg.starts_with(emit_flag) {\n+                // Patch this argument. First, extract its value.\n+                let val = &arg[emit_flag.len()..];\n+                assert!(val.starts_with(\"=\"), \"`cargo` should pass `--emit=X` as one argument\");\n+                let val = &val[1..];\n+                let mut val: Vec<_> = val.split(',').collect();\n+                // Now make sure \"link\" is not in there, but \"metadata\" is.\n+                if let Some(i) = val.iter().position(|&s| s == \"link\") {\n+                    emit_link_hack = true;\n+                    val.remove(i);\n+                    if !val.iter().any(|&s| s == \"metadata\") {\n+                        val.push(\"metadata\");\n+                    }\n                 }\n+                cmd.arg(format!(\"{}={}\", emit_flag, val.join(\",\")));\n+            } else {\n+                cmd.arg(arg);\n             }\n-            cmd.arg(format!(\"{}={}\", emit_flag, val.join(\",\")));\n-            // FIXME: due to this, the `.rlib` file does not get created and cargo re-triggers the build each time.\n-        } else {\n-            cmd.arg(arg);\n         }\n-    }\n \n-    // We make sure to only specify our custom Xargo sysroot for target crates - that is,\n-    // crates which are needed for interpretation by Miri. proc-macros and build scripts\n-    // should use the default sysroot.\n-    if target_crate {\n+        // Use our custom sysroot.\n         let sysroot =\n             env::var_os(\"MIRI_SYSROOT\").expect(\"The wrapper should have set MIRI_SYSROOT\");\n         cmd.arg(\"--sysroot\");\n         cmd.arg(sysroot);\n+    } else {\n+        // For host crates, just forward everything.\n+        cmd.args(args);\n     }\n \n     // We want to compile, not interpret. We still use Miri to make sure the compiler version etc\n@@ -527,7 +543,14 @@ fn phase_cargo_rustc(args: env::Args) {\n     if verbose {\n         eprintln!(\"[cargo-miri rustc] {:?}\", cmd);\n     }\n-    exec(cmd)\n+    exec(cmd);\n+\n+    // Create a stub .rlib file if \"link\" was requested by cargo.\n+    if emit_link_hack {\n+        // FIXME: is \"lib\" always right?\n+        let filename = out_filename(\"lib\", \".rlib\");\n+        File::create(filename).expect(\"Failed to create rlib file\");\n+    }\n }\n \n fn phase_cargo_runner(binary: &str, binary_args: env::Args) {"}]}