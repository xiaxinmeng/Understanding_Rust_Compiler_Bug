{"sha": "84c3fcd2a0285c06a682c9b064640084e4c7271b", "node_id": "C_kwDOAAsO6NoAKDg0YzNmY2QyYTAyODVjMDZhNjgyYzliMDY0NjQwMDg0ZTRjNzI3MWI", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-07-21T09:51:09Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-07-21T09:51:09Z"}, "message": "rewrite the orphan check to use a type visitor", "tree": {"sha": "11d6ecea5e151c329795375d258f5d80f011f435", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11d6ecea5e151c329795375d258f5d80f011f435"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84c3fcd2a0285c06a682c9b064640084e4c7271b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84c3fcd2a0285c06a682c9b064640084e4c7271b", "html_url": "https://github.com/rust-lang/rust/commit/84c3fcd2a0285c06a682c9b064640084e4c7271b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84c3fcd2a0285c06a682c9b064640084e4c7271b/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d0a18239e72fe170818d1cf5ebea8def3830364", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d0a18239e72fe170818d1cf5ebea8def3830364", "html_url": "https://github.com/rust-lang/rust/commit/7d0a18239e72fe170818d1cf5ebea8def3830364"}], "stats": {"total": 293, "additions": 124, "deletions": 169}, "files": [{"sha": "9983438233e1ef129275b506f53ab82d1f57a2e6", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 124, "deletions": 169, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/84c3fcd2a0285c06a682c9b064640084e4c7271b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84c3fcd2a0285c06a682c9b064640084e4c7271b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=84c3fcd2a0285c06a682c9b064640084e4c7271b", "patch": "@@ -22,11 +22,12 @@ use rustc_middle::traits::specialization_graph::OverlapMode;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, ImplSubject, Ty, TyCtxt};\n+use rustc_middle::ty::{self, ImplSubject, Ty, TyCtxt, TypeVisitor};\n use rustc_span::symbol::sym;\n use rustc_span::DUMMY_SP;\n use std::fmt::Debug;\n use std::iter;\n+use std::ops::ControlFlow;\n \n /// Whether we do the orphan check relative to this crate or\n /// to some remote crate.\n@@ -578,192 +579,146 @@ fn orphan_check_trait_ref<'tcx>(\n         );\n     }\n \n-    // Given impl<P1..=Pn> Trait<T1..=Tn> for T0, an impl is valid only\n-    // if at least one of the following is true:\n-    //\n-    // - Trait is a local trait\n-    // (already checked in orphan_check prior to calling this function)\n-    // - All of\n-    //     - At least one of the types T0..=Tn must be a local type.\n-    //      Let Ti be the first such type.\n-    //     - No uncovered type parameters P1..=Pn may appear in T0..Ti (excluding Ti)\n-    //\n-    fn uncover_fundamental_ty<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n-        ty: Ty<'tcx>,\n-        in_crate: InCrate,\n-    ) -> Vec<Ty<'tcx>> {\n-        // FIXME: this is currently somewhat overly complicated,\n-        // but fixing this requires a more complicated refactor.\n-        if !contained_non_local_types(tcx, ty, in_crate).is_empty() {\n-            if let Some(inner_tys) = fundamental_ty_inner_tys(tcx, ty) {\n-                return inner_tys\n-                    .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n-                    .collect();\n+    let mut checker = OrphanChecker::new(tcx, in_crate);\n+    match trait_ref.visit_with(&mut checker) {\n+        ControlFlow::Continue(()) => Err(OrphanCheckErr::NonLocalInputType(checker.non_local_tys)),\n+        ControlFlow::Break(OrphanCheckEarlyExit::ParamTy(ty)) => {\n+            // Does there exist some local type after the `ParamTy`.\n+            checker.search_first_local_ty = true;\n+            if let Some(OrphanCheckEarlyExit::LocalTy(local_ty)) =\n+                trait_ref.visit_with(&mut checker).break_value()\n+            {\n+                Err(OrphanCheckErr::UncoveredTy(ty, Some(local_ty)))\n+            } else {\n+                Err(OrphanCheckErr::UncoveredTy(ty, None))\n             }\n         }\n-\n-        vec![ty]\n-    }\n-\n-    let mut non_local_spans = vec![];\n-    for (i, input_ty) in trait_ref\n-        .substs\n-        .types()\n-        .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n-        .enumerate()\n-    {\n-        debug!(\"orphan_check_trait_ref: check ty `{:?}`\", input_ty);\n-        let non_local_tys = contained_non_local_types(tcx, input_ty, in_crate);\n-        if non_local_tys.is_empty() {\n-            debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n-            return Ok(());\n-        } else if let ty::Param(_) = input_ty.kind() {\n-            debug!(\"orphan_check_trait_ref: uncovered ty: `{:?}`\", input_ty);\n-            let local_type = trait_ref\n-                .substs\n-                .types()\n-                .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n-                .find(|&ty| ty_is_local_constructor(tcx, ty, in_crate));\n-\n-            debug!(\"orphan_check_trait_ref: uncovered ty local_type: `{:?}`\", local_type);\n-\n-            return Err(OrphanCheckErr::UncoveredTy(input_ty, local_type));\n-        }\n-\n-        non_local_spans.extend(non_local_tys.into_iter().map(|input_ty| (input_ty, i == 0)));\n+        ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(_)) => Ok(()),\n     }\n-    // If we exit above loop, never found a local type.\n-    debug!(\"orphan_check_trait_ref: no local type\");\n-    Err(OrphanCheckErr::NonLocalInputType(non_local_spans))\n }\n \n-/// Returns a list of relevant non-local types for `ty`.\n-///\n-/// This is just `ty` itself unless `ty` is `#[fundamental]`,\n-/// in which case we recursively look into this type.\n-///\n-/// If `ty` is local itself, this method returns an empty `Vec`.\n-///\n-/// # Examples\n-///\n-/// - `u32` is not local, so this returns `[u32]`.\n-/// - for `Foo<u32>`, where `Foo` is a local type, this returns `[]`.\n-/// - `&mut u32` returns `[u32]`, as `&mut` is a fundamental type, similar to `Box`.\n-/// - `Box<Foo<u32>>` returns `[]`, as `Box` is a fundamental type and `Foo` is local.\n-fn contained_non_local_types<'tcx>(\n+struct OrphanChecker<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    ty: Ty<'tcx>,\n     in_crate: InCrate,\n-) -> Vec<Ty<'tcx>> {\n-    if ty_is_local_constructor(tcx, ty, in_crate) {\n-        Vec::new()\n-    } else {\n-        match fundamental_ty_inner_tys(tcx, ty) {\n-            Some(inner_tys) => {\n-                inner_tys.flat_map(|ty| contained_non_local_types(tcx, ty, in_crate)).collect()\n-            }\n-            None => vec![ty],\n+    in_self_ty: bool,\n+    /// Ignore orphan check failures and exclusively search for the first\n+    /// local type.\n+    search_first_local_ty: bool,\n+    non_local_tys: Vec<(Ty<'tcx>, bool)>,\n+}\n+\n+impl<'tcx> OrphanChecker<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>, in_crate: InCrate) -> Self {\n+        OrphanChecker {\n+            tcx,\n+            in_crate,\n+            in_self_ty: true,\n+            search_first_local_ty: false,\n+            non_local_tys: Vec::new(),\n         }\n     }\n-}\n \n-/// For `#[fundamental]` ADTs and `&T` / `&mut T`, returns `Some` with the\n-/// type parameters of the ADT, or `T`, respectively. For non-fundamental\n-/// types, returns `None`.\n-fn fundamental_ty_inner_tys<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> Option<impl Iterator<Item = Ty<'tcx>>> {\n-    let (first_ty, rest_tys) = match *ty.kind() {\n-        ty::Ref(_, ty, _) => (ty, ty::subst::InternalSubsts::empty().types()),\n-        ty::Adt(def, substs) if def.is_fundamental() => {\n-            let mut types = substs.types();\n-\n-            // FIXME(eddyb) actually validate `#[fundamental]` up-front.\n-            match types.next() {\n-                None => {\n-                    tcx.sess.span_err(\n-                        tcx.def_span(def.did()),\n-                        \"`#[fundamental]` requires at least one type parameter\",\n-                    );\n-\n-                    return None;\n-                }\n+    fn found_non_local_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<OrphanCheckEarlyExit<'tcx>> {\n+        self.non_local_tys.push((t, self.in_self_ty));\n+        ControlFlow::CONTINUE\n+    }\n \n-                Some(first_ty) => (first_ty, types),\n-            }\n+    fn found_param_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<OrphanCheckEarlyExit<'tcx>> {\n+        if self.search_first_local_ty {\n+            ControlFlow::CONTINUE\n+        } else {\n+            ControlFlow::Break(OrphanCheckEarlyExit::ParamTy(t))\n         }\n-        _ => return None,\n-    };\n+    }\n+\n+    fn def_id_is_local(&mut self, def_id: DefId) -> bool {\n+        match self.in_crate {\n+            InCrate::Local => def_id.is_local(),\n+            InCrate::Remote => false,\n+        }\n+    }\n+}\n \n-    Some(iter::once(first_ty).chain(rest_tys))\n+enum OrphanCheckEarlyExit<'tcx> {\n+    ParamTy(Ty<'tcx>),\n+    LocalTy(Ty<'tcx>),\n }\n \n-fn def_id_is_local(def_id: DefId, in_crate: InCrate) -> bool {\n-    match in_crate {\n-        // The type is local to *this* crate - it will not be\n-        // local in any other crate.\n-        InCrate::Remote => false,\n-        InCrate::Local => def_id.is_local(),\n+impl<'tcx> TypeVisitor<'tcx> for OrphanChecker<'tcx> {\n+    type BreakTy = OrphanCheckEarlyExit<'tcx>;\n+    fn visit_region(&mut self, _r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        ControlFlow::CONTINUE\n     }\n-}\n \n-fn ty_is_local_constructor(tcx: TyCtxt<'_>, ty: Ty<'_>, in_crate: InCrate) -> bool {\n-    debug!(\"ty_is_local_constructor({:?})\", ty);\n-\n-    match *ty.kind() {\n-        ty::Bool\n-        | ty::Char\n-        | ty::Int(..)\n-        | ty::Uint(..)\n-        | ty::Float(..)\n-        | ty::Str\n-        | ty::FnDef(..)\n-        | ty::FnPtr(_)\n-        | ty::Array(..)\n-        | ty::Slice(..)\n-        | ty::RawPtr(..)\n-        | ty::Ref(..)\n-        | ty::Never\n-        | ty::Tuple(..)\n-        | ty::Param(..)\n-        | ty::Projection(..) => false,\n-\n-        ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) => match in_crate {\n-            InCrate::Local => false,\n-            // The inference variable might be unified with a local\n-            // type in that remote crate.\n-            InCrate::Remote => true,\n-        },\n-\n-        ty::Adt(def, _) => def_id_is_local(def.did(), in_crate),\n-        ty::Foreign(did) => def_id_is_local(did, in_crate),\n-\n-        ty::Dynamic(ref tt, ..) => {\n-            if let Some(principal) = tt.principal() {\n-                def_id_is_local(principal.def_id(), in_crate)\n-            } else {\n-                false\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        let result = match *ty.kind() {\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(..)\n+            | ty::Uint(..)\n+            | ty::Float(..)\n+            | ty::Str\n+            | ty::FnDef(..)\n+            | ty::FnPtr(_)\n+            | ty::Array(..)\n+            | ty::Slice(..)\n+            | ty::RawPtr(..)\n+            | ty::Never\n+            | ty::Tuple(..)\n+            | ty::Projection(..) => self.found_non_local_ty(ty),\n+\n+            ty::Param(..) => self.found_param_ty(ty),\n+\n+            ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) => match self.in_crate {\n+                InCrate::Local => self.found_non_local_ty(ty),\n+                // The inference variable might be unified with a local\n+                // type in that remote crate.\n+                InCrate::Remote => ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty)),\n+            },\n+\n+            // For fundamental types, we just look inside of them.\n+            ty::Ref(_, ty, _) => ty.visit_with(self),\n+            ty::Adt(def, substs) => {\n+                if self.def_id_is_local(def.did()) {\n+                    ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n+                } else if def.is_fundamental() {\n+                    substs.visit_with(self)\n+                } else {\n+                    self.found_non_local_ty(ty)\n+                }\n             }\n-        }\n+            ty::Foreign(def_id) => {\n+                if self.def_id_is_local(def_id) {\n+                    ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n+                } else {\n+                    self.found_non_local_ty(ty)\n+                }\n+            }\n+            ty::Dynamic(tt, ..) => {\n+                let principal = tt.principal().map(|p| p.def_id());\n+                if principal.map_or(false, |p| self.def_id_is_local(p)) {\n+                    ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n+                } else {\n+                    self.found_non_local_ty(ty)\n+                }\n+            }\n+            ty::Error(_) => ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty)),\n+            ty::Opaque(..) | ty::Closure(..) | ty::Generator(..) | ty::GeneratorWitness(..) => {\n+                self.tcx.sess.delay_span_bug(\n+                    DUMMY_SP,\n+                    format!(\"ty_is_local invoked on closure or generator: {:?}\", ty),\n+                );\n+                ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n+            }\n+        };\n+        // A bit of a hack, the `OrphanChecker` is only used to visit a `TraitRef`, so\n+        // the first type we visit is always the self type.\n+        self.in_self_ty = false;\n+        result\n+    }\n \n-        ty::Error(_) => true,\n-\n-        // These variants should never appear during coherence checking because they\n-        // cannot be named directly.\n-        //\n-        // They could be indirectly used through an opaque type. While using opaque types\n-        // in impls causes an error, this path can still be hit afterwards.\n-        //\n-        // See `test/ui/coherence/coherence-with-closure.rs` for an example where this\n-        // could happens.\n-        ty::Opaque(..) | ty::Closure(..) | ty::Generator(..) | ty::GeneratorWitness(..) => {\n-            tcx.sess.delay_span_bug(\n-                DUMMY_SP,\n-                format!(\"ty_is_local invoked on closure or generator: {:?}\", ty),\n-            );\n-            true\n-        }\n+    // FIXME: Constants should participate in orphan checking.\n+    fn visit_const(&mut self, _c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        ControlFlow::CONTINUE\n     }\n }"}]}