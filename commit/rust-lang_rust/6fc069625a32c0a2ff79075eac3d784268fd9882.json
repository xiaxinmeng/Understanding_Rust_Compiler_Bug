{"sha": "6fc069625a32c0a2ff79075eac3d784268fd9882", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmYzA2OTYyNWEzMmMwYTJmZjc5MDc1ZWFjM2Q3ODQyNjhmZDk4ODI=", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2021-08-14T14:06:05Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2021-08-14T14:06:05Z"}, "message": "Merge commit '0c89065b934397b62838fe3e4ef6f6352fc52daf' into libgccjit-codegen", "tree": {"sha": "122c2093047826e4a5dd124c2bdb504be78482c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/122c2093047826e4a5dd124c2bdb504be78482c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6fc069625a32c0a2ff79075eac3d784268fd9882", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6fc069625a32c0a2ff79075eac3d784268fd9882", "html_url": "https://github.com/rust-lang/rust/commit/6fc069625a32c0a2ff79075eac3d784268fd9882", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6fc069625a32c0a2ff79075eac3d784268fd9882/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7132ce63cf9b61618020eb321500795b455cfdc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7132ce63cf9b61618020eb321500795b455cfdc1", "html_url": "https://github.com/rust-lang/rust/commit/7132ce63cf9b61618020eb321500795b455cfdc1"}, {"sha": "0c89065b934397b62838fe3e4ef6f6352fc52daf", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c89065b934397b62838fe3e4ef6f6352fc52daf", "html_url": "https://github.com/rust-lang/rust/commit/0c89065b934397b62838fe3e4ef6f6352fc52daf"}], "stats": {"total": 61, "additions": 42, "deletions": 19}, "files": [{"sha": "4e9771311efbdf057464c8c454ce135e66b06d30", "filename": "compiler/rustc_codegen_gcc/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fc069625a32c0a2ff79075eac3d784268fd9882/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/6fc069625a32c0a2ff79075eac3d784268fd9882/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Frust-toolchain?ref=6fc069625a32c0a2ff79075eac3d784268fd9882", "patch": "@@ -1 +1 @@\n-nightly-2021-07-21\n+nightly-2021-08-12"}, {"sha": "bb864c27e1b4d03f90b2480b31afef580d1c237d", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6fc069625a32c0a2ff79075eac3d784268fd9882/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fc069625a32c0a2ff79075eac3d784268fd9882/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=6fc069625a32c0a2ff79075eac3d784268fd9882", "patch": "@@ -25,6 +25,7 @@ use rustc_codegen_ssa::traits::{\n     BuilderMethods,\n     ConstMethods,\n     DerivedTypeMethods,\n+    LayoutTypeMethods,\n     HasCodegen,\n     OverflowOp,\n     StaticBuilderMethods,\n@@ -514,8 +515,12 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         self.block.expect(\"block\").end_with_switch(None, value, default_block, &gcc_cases);\n     }\n \n-    fn invoke(&mut self, _func: RValue<'gcc>, _args: &[RValue<'gcc>], _then: Block<'gcc>, _catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn invoke(&mut self, _typ: Type<'gcc>, _func: RValue<'gcc>, _args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+        let condition = self.context.new_rvalue_from_int(self.bool_type, 0);\n+        self.llbb().end_with_conditional(None, condition, then, catch);\n+        self.context.new_rvalue_from_int(self.int_type, 0)\n+\n+        // TODO\n         /*debug!(\"invoke {:?} with args ({:?})\", func, args);\n \n         let args = self.check_call(\"invoke\", func, args);\n@@ -1001,9 +1006,10 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n             }\n             else if let abi::Abi::ScalarPair(ref a, ref b) = place.layout.abi {\n                 let b_offset = a.value.size(self).align_to(b.value.align(self).abi);\n+                let pair_type = place.layout.gcc_type(self, false);\n \n                 let mut load = |i, scalar: &abi::Scalar, align| {\n-                    let llptr = self.struct_gep(place.llval, i as u64);\n+                    let llptr = self.struct_gep(pair_type, place.llval, i as u64);\n                     let load = self.load(llptr.get_type(), llptr, align);\n                     scalar_load_metadata(self, load, scalar);\n                     if scalar.is_bool() { self.trunc(load, self.type_i1()) } else { load }\n@@ -1044,7 +1050,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let align = dest.align.restrict_for_offset(dest.layout.field(self.cx(), 0).size);\n         cg_elem.val.store(&mut body_bx, PlaceRef::new_sized_aligned(current_val, cg_elem.layout, align));\n \n-        let next = body_bx.inbounds_gep(current.to_rvalue(), &[self.const_usize(1)]);\n+        let next = body_bx.inbounds_gep(self.backend_type(cg_elem.layout), current.to_rvalue(), &[self.const_usize(1)]);\n         body_bx.llbb().add_assignment(None, current, next);\n         body_bx.br(header_bx.llbb());\n \n@@ -1130,15 +1136,15 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n             .add_eval(None, self.context.new_call(None, atomic_store, &[ptr, value, ordering]));\n     }\n \n-    fn gep(&mut self, ptr: RValue<'gcc>, indices: &[RValue<'gcc>]) -> RValue<'gcc> {\n+    fn gep(&mut self, _typ: Type<'gcc>, ptr: RValue<'gcc>, indices: &[RValue<'gcc>]) -> RValue<'gcc> {\n         let mut result = ptr;\n         for index in indices {\n             result = self.context.new_array_access(None, result, *index).get_address(None).to_rvalue();\n         }\n         result\n     }\n \n-    fn inbounds_gep(&mut self, ptr: RValue<'gcc>, indices: &[RValue<'gcc>]) -> RValue<'gcc> {\n+    fn inbounds_gep(&mut self, _typ: Type<'gcc>, ptr: RValue<'gcc>, indices: &[RValue<'gcc>]) -> RValue<'gcc> {\n         // FIXME: would be safer if doing the same thing (loop) as gep.\n         // TODO: specify inbounds somehow.\n         match indices.len() {\n@@ -1153,11 +1159,10 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         }\n     }\n \n-    fn struct_gep(&mut self, ptr: RValue<'gcc>, idx: u64) -> RValue<'gcc> {\n+    fn struct_gep(&mut self, value_type: Type<'gcc>, ptr: RValue<'gcc>, idx: u64) -> RValue<'gcc> {\n         // FIXME: it would be better if the API only called this on struct, not on arrays.\n         assert_eq!(idx as usize as u64, idx);\n         let value = ptr.dereference(None).to_rvalue();\n-        let value_type = value.get_type();\n \n         if value_type.is_array().is_some() {\n             let index = self.context.new_rvalue_from_long(self.u64_type, i64::try_from(idx).expect(\"i64::try_from\"));\n@@ -1449,14 +1454,19 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn landing_pad(&mut self, _ty: Type<'gcc>, _pers_fn: RValue<'gcc>, _num_clauses: usize) -> RValue<'gcc> {\n-        unimplemented!();\n+        let field1 = self.context.new_field(None, self.u8_type, \"landing_pad_field_1\");\n+        let field2 = self.context.new_field(None, self.i32_type, \"landing_pad_field_1\");\n+        let struct_type = self.context.new_struct_type(None, \"landing_pad\", &[field1, field2]);\n+        self.current_func().new_local(None, struct_type.as_type(), \"landing_pad\")\n+            .to_rvalue()\n+        // TODO\n         /*unsafe {\n             llvm::LLVMBuildLandingPad(self.llbuilder, ty, pers_fn, num_clauses as c_uint, UNNAMED)\n         }*/\n     }\n \n     fn set_cleanup(&mut self, _landing_pad: RValue<'gcc>) {\n-        unimplemented!();\n+        // TODO\n         /*unsafe {\n             llvm::LLVMSetCleanup(landing_pad, llvm::True);\n         }*/\n@@ -1527,7 +1537,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn set_personality_fn(&mut self, _personality: RValue<'gcc>) {\n-        unimplemented!();\n+        // TODO\n         /*unsafe {\n             llvm::LLVMSetPersonalityFn(self.llfn(), personality);\n         }*/\n@@ -1620,7 +1630,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         //self.call_lifetime_intrinsic(\"llvm.lifetime.end.p0i8\", ptr, size);\n     }\n \n-    fn call(&mut self, func: RValue<'gcc>, args: &[RValue<'gcc>], funclet: Option<&Funclet>) -> RValue<'gcc> {\n+    fn call(&mut self, _typ: Type<'gcc>, func: RValue<'gcc>, args: &[RValue<'gcc>], funclet: Option<&Funclet>) -> RValue<'gcc> {\n         // FIXME: remove when having a proper API.\n         let gcc_func = unsafe { std::mem::transmute(func) };\n         if self.functions.borrow().values().find(|value| **value == gcc_func).is_some() {"}, {"sha": "19243b0cbce5d3bb2533164f885b719450c22e09", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6fc069625a32c0a2ff79075eac3d784268fd9882/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fc069625a32c0a2ff79075eac3d784268fd9882/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=6fc069625a32c0a2ff79075eac3d784268fd9882", "patch": "@@ -14,7 +14,6 @@ use gccjit::{\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::traits::{\n     BackendTypes,\n-    BaseTypeMethods,\n     MiscMethods,\n };\n use rustc_data_structures::base_n;\n@@ -349,12 +348,15 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                 .unwrap().unwrap(),\n             ),\n             _ => {\n-                let name = if wants_msvc_seh(self.sess()) {\n+                let _name = if wants_msvc_seh(self.sess()) {\n                     \"__CxxFrameHandler3\"\n                 } else {\n                     \"rust_eh_personality\"\n                 };\n-                self.declare_func(name, self.type_i32(), &[], true)\n+                //let func = self.declare_func(name, self.type_i32(), &[], true);\n+                // FIXME: this hack should not be needed. That will probably be removed when\n+                // unwinding support is added.\n+                self.context.new_rvalue_from_int(self.int_type, 0)\n             }\n         };\n         //attributes::apply_target_cpu_attr(self, llfn);"}, {"sha": "ad6dfbffbac96ebb055e1f118d885cfa3900b09c", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6fc069625a32c0a2ff79075eac3d784268fd9882/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fc069625a32c0a2ff79075eac3d784268fd9882/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=6fc069625a32c0a2ff79075eac3d784268fd9882", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 _ if simple.is_some() => {\n                     // FIXME: remove this cast when the API supports function.\n                     let func = unsafe { std::mem::transmute(simple.expect(\"simple\")) };\n-                    self.call(func, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None)\n+                    self.call(self.type_void(), func, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None)\n                 },\n                 sym::likely => {\n                     self.expect(args[0].immediate(), true)\n@@ -392,7 +392,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n     fn abort(&mut self) {\n         let func = self.context.get_builtin_function(\"abort\");\n         let func: RValue<'gcc> = unsafe { std::mem::transmute(func) };\n-        self.call(func, &[], None);\n+        self.call(self.type_void(), func, &[], None);\n     }\n \n     fn assume(&mut self, value: Self::Value) {\n@@ -1075,7 +1075,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n fn try_intrinsic<'gcc, 'tcx>(bx: &mut Builder<'_, 'gcc, 'tcx>, try_func: RValue<'gcc>, data: RValue<'gcc>, _catch_func: RValue<'gcc>, dest: RValue<'gcc>) {\n     if bx.sess().panic_strategy() == PanicStrategy::Abort {\n-        bx.call(try_func, &[data], None);\n+        bx.call(bx.type_void(), try_func, &[data], None);\n         // Return 0 unconditionally from the intrinsic call;\n         // we can never unwind.\n         let ret_align = bx.tcx.data_layout.i32_align.abi;"}, {"sha": "2ef90bca5ac20d7db69d6581ee1ff72e589874d1", "filename": "compiler/rustc_codegen_gcc/src/type_.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6fc069625a32c0a2ff79075eac3d784268fd9882/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fc069625a32c0a2ff79075eac3d784268fd9882/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs?ref=6fc069625a32c0a2ff79075eac3d784268fd9882", "patch": "@@ -293,6 +293,11 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             }\n         }\n \n+        // NOTE: see note above. Some other test uses usize::MAX.\n+        if len == u64::MAX {\n+            len = 0;\n+        }\n+\n         let len: i32 = len.try_into().expect(\"array len\");\n \n         self.context.new_array_type(None, ty, len)"}, {"sha": "010805808d2a34cc49cc92ad668e04b17d0f0190", "filename": "compiler/rustc_codegen_gcc/src/type_of.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6fc069625a32c0a2ff79075eac3d784268fd9882/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fc069625a32c0a2ff79075eac3d784268fd9882/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs?ref=6fc069625a32c0a2ff79075eac3d784268fd9882", "patch": "@@ -363,4 +363,10 @@ impl<'gcc, 'tcx> LayoutTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         unimplemented!();\n         //ty.gcc_type(self)\n     }\n+\n+    fn fn_decl_backend_type(&self, _fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Type<'gcc> {\n+        // FIXME: return correct type.\n+        self.type_void()\n+        //fn_abi.gcc_type(self)\n+    }\n }"}]}