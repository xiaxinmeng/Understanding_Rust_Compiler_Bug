{"sha": "55cbef611a25431c9614c2f4343472014977f5df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1Y2JlZjYxMWEyNTQzMWM5NjE0YzJmNDM0MzQ3MjAxNDk3N2Y1ZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-22T08:41:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-22T08:41:39Z"}, "message": "auto merge of #11064 : huonw/rust/vec-sort, r=alexcrichton\n\nThis uses quite a bit of unsafe code for speed and failure safety, and allocates `2*n` temporary storage.\r\n\r\n[Performance](https://gist.github.com/huonw/5547f2478380288a28c2):\r\n\r\n|      n |      new | priority_queue |   quick3 |\r\n|-------:|---------:|---------------:|---------:|\r\n|      5 |      200 |            155 |      106 |\r\n|    100 |     6490 |           8750 |     5810 |\r\n|  10000 |  1300000 |        1790000 |  1060000 |\r\n| 100000 | 16700000 |       23600000 | 12700000 |\r\n| sorted |   520000 |        1380000 | 53900000 |\r\n|  trend |  1310000 |        1690000 |  1100000 |\r\n\r\n(The times are in nanoseconds, having subtracted the set-up time (i.e. the `just_generate` bench target).)\r\n\r\nI imagine that there is still significant room for improvement, particularly because both priority_queue and quick3 are doing a static call via `Ord` or `TotalOrd` for the comparisons, while this is using a (boxed) closure.\r\n\r\nAlso, this code does not `clone`, unlike `quick_sort3`; and is stable, unlike both of the others.", "tree": {"sha": "fae66837778d53647275abbaab0b7f232179a4f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fae66837778d53647275abbaab0b7f232179a4f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55cbef611a25431c9614c2f4343472014977f5df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55cbef611a25431c9614c2f4343472014977f5df", "html_url": "https://github.com/rust-lang/rust/commit/55cbef611a25431c9614c2f4343472014977f5df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55cbef611a25431c9614c2f4343472014977f5df/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd13f4d599ec747708ae8e7dec79b21818352e36", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd13f4d599ec747708ae8e7dec79b21818352e36", "html_url": "https://github.com/rust-lang/rust/commit/cd13f4d599ec747708ae8e7dec79b21818352e36"}, {"sha": "645fff4bc88f25c36a8260d66d9af027fc0532f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/645fff4bc88f25c36a8260d66d9af027fc0532f2", "html_url": "https://github.com/rust-lang/rust/commit/645fff4bc88f25c36a8260d66d9af027fc0532f2"}], "stats": {"total": 1796, "additions": 493, "deletions": 1303}, "files": [{"sha": "1182d526fa4532fda20847baac00ff3a15703032", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=55cbef611a25431c9614c2f4343472014977f5df", "patch": "@@ -28,8 +28,6 @@ use std::io;\n use std::io::fs;\n use std::path::is_sep;\n \n-use sort;\n-\n /**\n  * An iterator that yields Paths from the filesystem that match a particular\n  * pattern - see the `glob` function for more details.\n@@ -149,9 +147,8 @@ impl Iterator<Path> for GlobIterator {\n \n fn list_dir_sorted(path: &Path) -> ~[Path] {\n     match io::result(|| fs::readdir(path)) {\n-        Ok(children) => {\n-            let mut children = children;\n-            sort::quick_sort(children, |p1, p2| p2.filename() <= p1.filename());\n+        Ok(mut children) => {\n+            children.sort_by(|p1, p2| p2.filename().cmp(&p1.filename()));\n             children\n         }\n         Err(..) => ~[]\n@@ -771,4 +768,3 @@ mod test {\n         assert!(Pattern::new(\"a/b\").matches_path(&Path::new(\"a/b\")));\n     }\n }\n-"}, {"sha": "51e105d23f78297f5766073e6f3a54db47b622bd", "filename": "src/libextra/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibextra%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibextra%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flib.rs?ref=55cbef611a25431c9614c2f4343472014977f5df", "patch": "@@ -61,8 +61,6 @@ pub mod ringbuf;\n pub mod priority_queue;\n pub mod smallintmap;\n \n-pub mod sort;\n-\n pub mod dlist;\n pub mod treemap;\n pub mod btree;"}, {"sha": "bba7d767732935ec6c3544f642433438fef74b88", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=55cbef611a25431c9614c2f4343472014977f5df", "patch": "@@ -213,7 +213,6 @@ impl<T: Ord> Extendable<T> for PriorityQueue<T> {\n \n #[cfg(test)]\n mod tests {\n-    use sort::merge_sort;\n     use priority_queue::PriorityQueue;\n \n     #[test]\n@@ -231,7 +230,8 @@ mod tests {\n     #[test]\n     fn test_top_and_pop() {\n         let data = ~[2u, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n-        let mut sorted = merge_sort(data, |x, y| x.le(y));\n+        let mut sorted = data.clone();\n+        sorted.sort();\n         let mut heap = PriorityQueue::from_vec(data);\n         while !heap.is_empty() {\n             assert_eq!(heap.top(), sorted.last());\n@@ -311,11 +311,14 @@ mod tests {\n         assert_eq!(heap.len(), 5);\n     }\n \n-    fn check_to_vec(data: ~[int]) {\n+    fn check_to_vec(mut data: ~[int]) {\n         let heap = PriorityQueue::from_vec(data.clone());\n-        assert_eq!(merge_sort(heap.clone().to_vec(), |x, y| x.le(y)),\n-                   merge_sort(data, |x, y| x.le(y)));\n-        assert_eq!(heap.to_sorted_vec(), merge_sort(data, |x, y| x.le(y)));\n+        let mut v = heap.clone().to_vec();\n+        v.sort();\n+        data.sort();\n+\n+        assert_eq!(v, data);\n+        assert_eq!(heap.to_sorted_vec(), data);\n     }\n \n     #[test]"}, {"sha": "bba26a16d4dadc4dc9d1dc63a41040889b20b10d", "filename": "src/libextra/sort.rs", "status": "removed", "additions": 0, "deletions": 1181, "changes": 1181, "blob_url": "https://github.com/rust-lang/rust/blob/cd13f4d599ec747708ae8e7dec79b21818352e36/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd13f4d599ec747708ae8e7dec79b21818352e36/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=cd13f4d599ec747708ae8e7dec79b21818352e36", "patch": "@@ -1,1181 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Sorting methods\n-\n-\n-use std::cmp::{Eq, Ord};\n-use std::util::swap;\n-use std::vec;\n-\n-type Le<'a, T> = 'a |v1: &T, v2: &T| -> bool;\n-\n-/**\n- * Merge sort. Returns a new vector containing the sorted list.\n- *\n- * Has worst case O(n log n) performance, best case O(n), but\n- * is not space efficient. This is a stable sort.\n- */\n-pub fn merge_sort<T:Clone>(v: &[T], le: Le<T>) -> ~[T] {\n-    type Slice = (uint, uint);\n-\n-    return merge_sort_(v, (0u, v.len()), le);\n-\n-    fn merge_sort_<T:Clone>(v: &[T], slice: Slice, le: Le<T>) -> ~[T] {\n-        let begin = slice.first();\n-        let end = slice.second();\n-\n-        let v_len = end - begin;\n-        if v_len == 0 { return ~[]; }\n-        if v_len == 1 { return ~[v[begin].clone()]; }\n-\n-        let mid = v_len / 2 + begin;\n-        let a = (begin, mid);\n-        let b = (mid, end);\n-        return merge(|x,y| le(x,y), merge_sort_(v, a, |x,y| le(x,y)),\n-                                    merge_sort_(v, b, |x,y| le(x,y)));\n-    }\n-\n-    fn merge<T:Clone>(le: Le<T>, a: &[T], b: &[T]) -> ~[T] {\n-        let mut rs = vec::with_capacity(a.len() + b.len());\n-        let a_len = a.len();\n-        let mut a_ix = 0;\n-        let b_len = b.len();\n-        let mut b_ix = 0;\n-        while a_ix < a_len && b_ix < b_len {\n-            if le(&a[a_ix], &b[b_ix]) {\n-                rs.push(a[a_ix].clone());\n-                a_ix += 1;\n-            } else {\n-                rs.push(b[b_ix].clone());\n-                b_ix += 1;\n-            }\n-        }\n-        rs.push_all(a.slice(a_ix, a_len));\n-        rs.push_all(b.slice(b_ix, b_len));\n-        rs\n-    }\n-}\n-\n-fn part<T>(arr: &mut [T], left: uint,\n-           right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n-    arr.swap(pivot, right);\n-    let mut storage_index: uint = left;\n-    let mut i: uint = left;\n-    while i < right {\n-        if compare_func(&arr[i], &arr[right]) {\n-            arr.swap(i, storage_index);\n-            storage_index += 1;\n-        }\n-        i += 1;\n-    }\n-    arr.swap(storage_index, right);\n-    return storage_index;\n-}\n-\n-fn qsort<T>(arr: &mut [T], left: uint,\n-            right: uint, compare_func: Le<T>) {\n-    if right > left {\n-        let pivot = (left + right) / 2u;\n-        let new_pivot = part::<T>(arr, left, right, pivot, |x,y| compare_func(x,y));\n-        if new_pivot != 0u {\n-            // Need to do this check before recursing due to overflow\n-            qsort::<T>(arr, left, new_pivot - 1u, |x,y| compare_func(x,y));\n-        }\n-        qsort::<T>(arr, new_pivot + 1u, right, compare_func);\n-    }\n-}\n-\n-/**\n- * Quicksort. Sorts a mut vector in place.\n- *\n- * Has worst case O(n^2) performance, average case O(n log n).\n- * This is an unstable sort.\n- */\n-pub fn quick_sort<T>(arr: &mut [T], compare_func: Le<T>) {\n-    let len = arr.len();\n-    if len == 0u { return; }\n-    qsort::<T>(arr, 0u, len - 1u, compare_func);\n-}\n-\n-fn qsort3<T:Clone + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n-    if right <= left { return; }\n-    let v: T = arr[right].clone();\n-    let mut i: int = left - 1;\n-    let mut j: int = right;\n-    let mut p: int = i;\n-    let mut q: int = j;\n-    loop {\n-        i += 1;\n-        while arr[i] < v { i += 1; }\n-        j -= 1;\n-        while v < arr[j] {\n-            if j == left { break; }\n-            j -= 1;\n-        }\n-        if i >= j { break; }\n-        arr.swap(i as uint, j as uint);\n-        if arr[i] == v {\n-            p += 1;\n-            arr.swap(p as uint, i as uint);\n-        }\n-        if v == arr[j] {\n-            q -= 1;\n-            arr.swap(j as uint, q as uint);\n-        }\n-    }\n-    arr.swap(i as uint, right as uint);\n-    j = i - 1;\n-    i += 1;\n-    let mut k: int = left;\n-    while k < p {\n-        arr.swap(k as uint, j as uint);\n-        k += 1;\n-        j -= 1;\n-        if k == arr.len() as int { break; }\n-    }\n-    k = right - 1;\n-    while k > q {\n-        arr.swap(i as uint, k as uint);\n-        k -= 1;\n-        i += 1;\n-        if k == 0 { break; }\n-    }\n-    qsort3::<T>(arr, left, j);\n-    qsort3::<T>(arr, i, right);\n-}\n-\n-/**\n- * Fancy quicksort. Sorts a mut vector in place.\n- *\n- * Based on algorithm presented by ~[Sedgewick and Bentley]\n- * (http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf).\n- * According to these slides this is the algorithm of choice for\n- * 'randomly ordered keys, abstract compare' & 'small number of key values'.\n- *\n- * This is an unstable sort.\n- */\n-pub fn quick_sort3<T:Clone + Ord + Eq>(arr: &mut [T]) {\n-    if arr.len() <= 1 { return; }\n-    let len = arr.len(); // FIXME(#5074) nested calls\n-    qsort3(arr, 0, (len - 1) as int);\n-}\n-\n-#[allow(missing_doc)]\n-pub trait Sort {\n-    fn qsort(self);\n-}\n-\n-impl<'a, T:Clone + Ord + Eq> Sort for &'a mut [T] {\n-    fn qsort(self) { quick_sort3(self); }\n-}\n-\n-static MIN_MERGE: uint = 64;\n-static MIN_GALLOP: uint = 7;\n-\n-#[allow(missing_doc)]\n-pub fn tim_sort<T:Clone + Ord>(array: &mut [T]) {\n-    let size = array.len();\n-    if size < 2 {\n-        return;\n-    }\n-\n-    if size < MIN_MERGE {\n-        let init_run_len = count_run_ascending(array);\n-        binarysort(array, init_run_len);\n-        return;\n-    }\n-\n-    let mut ms = MergeState();\n-    let min_run = min_run_length(size);\n-\n-    let mut idx = 0;\n-    let mut remaining = size;\n-    loop {\n-        let run_len: uint = {\n-            // This scope contains the slice `arr` here:\n-            let arr = array.mut_slice(idx, size);\n-            let mut run_len: uint = count_run_ascending(arr);\n-\n-            if run_len < min_run {\n-                let force = if remaining <= min_run {remaining} else {min_run};\n-                let slice = arr.mut_slice(0, force);\n-                binarysort(slice, run_len);\n-                run_len = force;\n-            }\n-\n-            run_len\n-        };\n-\n-        ms.push_run(idx, run_len);\n-        ms.merge_collapse(array);\n-\n-        idx += run_len;\n-        remaining -= run_len;\n-        if remaining == 0 { break; }\n-    }\n-\n-    ms.merge_force_collapse(array);\n-}\n-\n-fn binarysort<T:Clone + Ord>(array: &mut [T], start: uint) {\n-    let size = array.len();\n-    let mut start = start;\n-    assert!(start <= size);\n-\n-    if start == 0 { start += 1; }\n-\n-    while start < size {\n-        let pivot = array[start].clone();\n-        let mut left = 0;\n-        let mut right = start;\n-        assert!(left <= right);\n-\n-        while left < right {\n-            let mid = (left + right) >> 1;\n-            if pivot < array[mid] {\n-                right = mid;\n-            } else {\n-                left = mid+1;\n-            }\n-        }\n-        assert_eq!(left, right);\n-        let n = start-left;\n-\n-        shift_vec(array, left+1, left, n);\n-        array[left] = pivot;\n-        start += 1;\n-    }\n-}\n-\n-// Reverse the order of elements in a slice, in place\n-fn reverse_slice<T>(v: &mut [T], start: uint, end:uint) {\n-    let mut i = start;\n-    while i < end / 2 {\n-        v.swap(i, end - i - 1);\n-        i += 1;\n-    }\n-}\n-\n-fn min_run_length(n: uint) -> uint {\n-    let mut n = n;\n-    let mut r = 0;   // becomes 1 if any 1 bits are shifted off\n-\n-    while n >= MIN_MERGE {\n-        r |= n & 1;\n-        n >>= 1;\n-    }\n-    return n + r;\n-}\n-\n-fn count_run_ascending<T:Clone + Ord>(array: &mut [T]) -> uint {\n-    let size = array.len();\n-    assert!(size > 0);\n-    if size == 1 { return 1; }\n-\n-    let mut run = 2;\n-    if array[1] < array[0] {\n-        while run < size && array[run] < array[run-1] {\n-            run += 1;\n-        }\n-        reverse_slice(array, 0, run);\n-    } else {\n-        while run < size && array[run] >= array[run-1] {\n-            run += 1;\n-        }\n-    }\n-\n-    return run;\n-}\n-\n-fn gallop_left<T:Clone + Ord>(key: &T,\n-                             array: &[T],\n-                             hint: uint)\n-                          -> uint {\n-    let size = array.len();\n-    assert!(size != 0 && hint < size);\n-\n-    let mut last_ofs = 0;\n-    let mut ofs = 1;\n-\n-    if *key > array[hint] {\n-        // Gallop right until array[hint+last_ofs] < key <= array[hint+ofs]\n-        let max_ofs = size - hint;\n-        while ofs < max_ofs && *key > array[hint+ofs] {\n-            last_ofs = ofs;\n-            ofs = (ofs << 1) + 1;\n-            if ofs < last_ofs { ofs = max_ofs; } // uint overflow guard\n-        }\n-        if ofs > max_ofs { ofs = max_ofs; }\n-\n-        last_ofs += hint;\n-        ofs += hint;\n-    } else {\n-        let max_ofs = hint + 1;\n-        while ofs < max_ofs && *key <= array[hint-ofs] {\n-            last_ofs = ofs;\n-            ofs = (ofs << 1) + 1;\n-            if ofs < last_ofs { ofs = max_ofs; } // uint overflow guard\n-        }\n-\n-        if ofs > max_ofs { ofs = max_ofs; }\n-\n-        let tmp = last_ofs;\n-        last_ofs = hint - ofs;\n-        ofs = hint - tmp;\n-    }\n-    assert!((last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size);\n-\n-    last_ofs += 1;\n-    while last_ofs < ofs {\n-        let m = last_ofs + ((ofs - last_ofs) >> 1);\n-        if *key > array[m] {\n-            last_ofs = m+1;\n-        } else {\n-            ofs = m;\n-        }\n-    }\n-    assert_eq!(last_ofs, ofs);\n-    return ofs;\n-}\n-\n-fn gallop_right<T:Clone + Ord>(key: &T,\n-                              array: &[T],\n-                              hint: uint)\n-                           -> uint {\n-    let size = array.len();\n-    assert!(size != 0 && hint < size);\n-\n-    let mut last_ofs = 0;\n-    let mut ofs = 1;\n-\n-    if *key >= array[hint] {\n-        // Gallop right until array[hint+last_ofs] <= key < array[hint+ofs]\n-        let max_ofs = size - hint;\n-        while ofs < max_ofs && *key >= array[hint+ofs] {\n-            last_ofs = ofs;\n-            ofs = (ofs << 1) + 1;\n-            if ofs < last_ofs { ofs = max_ofs; }\n-        }\n-        if ofs > max_ofs { ofs = max_ofs; }\n-\n-        last_ofs += hint;\n-        ofs += hint;\n-    } else {\n-        // Gallop left until array[hint-ofs] <= key < array[hint-last_ofs]\n-        let max_ofs = hint + 1;\n-        while ofs < max_ofs && *key < array[hint-ofs] {\n-            last_ofs = ofs;\n-            ofs = (ofs << 1) + 1;\n-            if ofs < last_ofs { ofs = max_ofs; }\n-        }\n-        if ofs > max_ofs { ofs = max_ofs; }\n-\n-        let tmp = last_ofs;\n-        last_ofs = hint - ofs;\n-        ofs = hint - tmp;\n-    }\n-\n-    assert!((last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size);\n-\n-    last_ofs += 1;\n-    while last_ofs < ofs {\n-        let m = last_ofs + ((ofs - last_ofs) >> 1);\n-\n-        if *key >= array[m] {\n-            last_ofs = m + 1;\n-        } else {\n-            ofs = m;\n-        }\n-    }\n-    assert_eq!(last_ofs, ofs);\n-    return ofs;\n-}\n-\n-struct RunState {\n-    base: uint,\n-    len: uint,\n-}\n-\n-struct MergeState<T> {\n-    min_gallop: uint,\n-    runs: ~[RunState],\n-}\n-\n-// Fixme (#3853) Move into MergeState\n-fn MergeState<T>() -> MergeState<T> {\n-    MergeState {\n-        min_gallop: MIN_GALLOP,\n-        runs: ~[],\n-    }\n-}\n-\n-impl<T:Clone + Ord> MergeState<T> {\n-    fn push_run(&mut self, run_base: uint, run_len: uint) {\n-        let tmp = RunState{base: run_base, len: run_len};\n-        self.runs.push(tmp);\n-    }\n-\n-    fn merge_at(&mut self, n: uint, array: &mut [T]) {\n-        let size = self.runs.len();\n-        assert!(size >= 2);\n-        assert!(n == size-2 || n == size-3);\n-\n-        let mut b1 = self.runs[n].base;\n-        let mut l1 = self.runs[n].len;\n-        let b2 = self.runs[n+1].base;\n-        let l2 = self.runs[n+1].len;\n-\n-        assert!(l1 > 0 && l2 > 0);\n-        assert_eq!(b1 + l1, b2);\n-\n-        self.runs[n].len = l1 + l2;\n-        if n == size-3 {\n-            self.runs[n+1].base = self.runs[n+2].base;\n-            self.runs[n+1].len = self.runs[n+2].len;\n-        }\n-\n-        let k = { // constrain lifetime of slice below\n-            let slice = array.slice(b1, b1+l1);\n-            gallop_right(&array[b2], slice, 0)\n-        };\n-        b1 += k;\n-        l1 -= k;\n-        if l1 != 0 {\n-            let l2 = { // constrain lifetime of slice below\n-                let slice = array.slice(b2, b2+l2);\n-                gallop_left(&array[b1+l1-1],slice,l2-1)\n-            };\n-            if l2 > 0 {\n-                if l1 <= l2 {\n-                    self.merge_lo(array, b1, l1, b2, l2);\n-                } else {\n-                    self.merge_hi(array, b1, l1, b2, l2);\n-                }\n-            }\n-        }\n-        self.runs.pop();\n-    }\n-\n-    fn merge_lo(&mut self, array: &mut [T], base1: uint, len1: uint,\n-                base2: uint, len2: uint) {\n-        assert!(len1 != 0 && len2 != 0 && base1+len1 == base2);\n-\n-        let mut tmp = array.slice(base1, base1 + len1).to_owned();\n-\n-        let mut c1 = 0;\n-        let mut c2 = base2;\n-        let mut dest = base1;\n-        let mut len1 = len1;\n-        let mut len2 = len2;\n-\n-        array.swap(dest, c2);\n-        dest += 1; c2 += 1; len2 -= 1;\n-\n-        if len2 == 0 {\n-            copy_vec(array, dest, tmp.slice(0, len1));\n-            return;\n-        }\n-        if len1 == 1 {\n-            shift_vec(array, dest, c2, len2);\n-            swap(&mut tmp[c1], &mut array[dest+len2]);\n-            return;\n-        }\n-\n-        let mut min_gallop = self.min_gallop;\n-        loop {\n-            let mut count1 = 0;\n-            let mut count2 = 0;\n-            let mut break_outer = false;\n-\n-            loop {\n-                assert!(len1 > 1 && len2 != 0);\n-                if array[c2] < tmp[c1] {\n-                    array.swap(dest, c2);\n-                    dest += 1; c2 += 1; len2 -= 1;\n-                    count2 += 1; count1 = 0;\n-                    if len2 == 0 {\n-                        break_outer = true;\n-                    }\n-                } else {\n-                    swap(&mut array[dest], &mut tmp[c1]);\n-                    dest += 1; c1 += 1; len1 -= 1;\n-                    count1 += 1; count2 = 0;\n-                    if len1 == 1 {\n-                        break_outer = true;\n-                    }\n-                }\n-                if break_outer || ((count1 | count2) >= min_gallop) {\n-                    break;\n-                }\n-            }\n-            if break_outer { break; }\n-\n-            // Start to gallop\n-            loop {\n-                assert!(len1 > 1 && len2 != 0);\n-\n-                count1 = {\n-                    let tmp_view = tmp.slice(c1, c1+len1);\n-                    gallop_right(&array[c2], tmp_view, 0)\n-                };\n-                if count1 != 0 {\n-                    copy_vec(array, dest, tmp.slice(c1, c1+count1));\n-                    dest += count1; c1 += count1; len1 -= count1;\n-                    if len1 <= 1 { break_outer = true; break; }\n-                }\n-                array.swap(dest, c2);\n-                dest += 1; c2 += 1; len2 -= 1;\n-                if len2 == 0 { break_outer = true; break; }\n-\n-                count2 = {\n-                    let tmp_view = array.slice(c2, c2+len2);\n-                    gallop_left(&tmp[c1], tmp_view, 0)\n-                };\n-                if count2 != 0 {\n-                    shift_vec(array, dest, c2, count2);\n-                    dest += count2; c2 += count2; len2 -= count2;\n-                    if len2 == 0 { break_outer = true; break; }\n-                }\n-                swap(&mut array[dest], &mut tmp[c1]);\n-                dest += 1; c1 += 1; len1 -= 1;\n-                if len1 == 1 { break_outer = true; break; }\n-                min_gallop -= 1;\n-                if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) {\n-                    break;\n-                }\n-            }\n-            if break_outer { break; }\n-            if min_gallop < 0 { min_gallop = 0; }\n-            min_gallop += 2; // Penalize for leaving gallop\n-        }\n-        self.min_gallop = if min_gallop < 1 { 1 } else { min_gallop };\n-\n-        if len1 == 1 {\n-            assert!(len2 > 0);\n-            shift_vec(array, dest, c2, len2);\n-            swap(&mut array[dest+len2], &mut tmp[c1]);\n-        } else if len1 == 0 {\n-            fail!(\"Comparison violates its contract!\");\n-        } else {\n-            assert_eq!(len2, 0);\n-            assert!(len1 > 1);\n-            copy_vec(array, dest, tmp.slice(c1, c1+len1));\n-        }\n-    }\n-\n-    fn merge_hi(&mut self, array: &mut [T], base1: uint, len1: uint,\n-                base2: uint, len2: uint) {\n-        assert!(len1 != 1 && len2 != 0 && base1 + len1 == base2);\n-\n-        let mut tmp = array.slice(base2, base2 + len2).to_owned();\n-\n-        let mut c1 = base1 + len1 - 1;\n-        let mut c2 = len2 - 1;\n-        let mut dest = base2 + len2 - 1;\n-        let mut len1 = len1;\n-        let mut len2 = len2;\n-\n-        array.swap(dest, c1);\n-        dest -= 1; c1 -= 1; len1 -= 1;\n-\n-        if len1 == 0 {\n-            copy_vec(array, dest-(len2-1), tmp.slice(0, len2));\n-            return;\n-        }\n-        if len2 == 1 {\n-            dest -= len1;\n-            c1 -= len1;\n-            shift_vec(array, dest+1, c1+1, len1);\n-            swap(&mut array[dest], &mut tmp[c2]);\n-            return;\n-        }\n-\n-        let mut min_gallop = self.min_gallop;\n-        loop {\n-            let mut count1 = 0;\n-            let mut count2 = 0;\n-            let mut break_outer = false;\n-\n-            loop {\n-                assert!(len1 != 0 && len2 > 1);\n-                if tmp[c2] < array[c1] {\n-                    array.swap(dest, c1);\n-                    dest -= 1; c1 -= 1; len1 -= 1;\n-                    count1 += 1; count2 = 0;\n-                    if len1 == 0 {\n-                        break_outer = true;\n-                    }\n-                } else {\n-                    swap(&mut array[dest], &mut tmp[c2]);\n-                    dest -= 1; c2 -= 1; len2 -= 1;\n-                    count2 += 1; count1 = 0;\n-                    if len2 == 1 {\n-                        break_outer = true;\n-                    }\n-                }\n-                if break_outer || ((count1 | count2) >= min_gallop) {\n-                    break;\n-                }\n-            }\n-            if break_outer { break; }\n-\n-            // Start to gallop\n-            loop {\n-                assert!(len2 > 1 && len1 != 0);\n-\n-                { // constrain scope of tmp_view:\n-                    let tmp_view = array.mut_slice(base1, base1+len1);\n-                    count1 = len1 - gallop_right(\n-                        &tmp[c2], tmp_view, len1-1);\n-                }\n-\n-                if count1 != 0 {\n-                    dest -= count1; c1 -= count1; len1 -= count1;\n-                    shift_vec(array, dest+1, c1+1, count1);\n-                    if len1 == 0 { break_outer = true; break; }\n-                }\n-\n-                swap(&mut array[dest], &mut tmp[c2]);\n-                dest -= 1; c2 -= 1; len2 -= 1;\n-                if len2 == 1 { break_outer = true; break; }\n-\n-                let count2;\n-                { // constrain scope of tmp_view\n-                    let tmp_view = tmp.mut_slice(0, len2);\n-                    count2 = len2 - gallop_left(&array[c1],\n-                                                tmp_view,\n-                                                len2-1);\n-                }\n-\n-                if count2 != 0 {\n-                    dest -= count2; c2 -= count2; len2 -= count2;\n-                    copy_vec(array, dest+1, tmp.slice(c2+1, c2+1+count2));\n-                    if len2 <= 1 { break_outer = true; break; }\n-                }\n-                array.swap(dest, c1);\n-                dest -= 1; c1 -= 1; len1 -= 1;\n-                if len1 == 0 { break_outer = true; break; }\n-                min_gallop -= 1;\n-                if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) {\n-                    break;\n-                }\n-            }\n-\n-            if break_outer { break; }\n-            if min_gallop < 0 { min_gallop = 0; }\n-            min_gallop += 2; // Penalize for leaving gallop\n-        }\n-        self.min_gallop = if min_gallop < 1 { 1 } else { min_gallop };\n-\n-        if len2 == 1 {\n-            assert!(len1 > 0);\n-            dest -= len1;\n-            c1 -= len1;\n-            shift_vec(array, dest+1, c1+1, len1);\n-            swap(&mut array[dest], &mut tmp[c2]);\n-        } else if len2 == 0 {\n-            fail!(\"Comparison violates its contract!\");\n-        } else {\n-            assert_eq!(len1, 0);\n-            assert!(len2 != 0);\n-            copy_vec(array, dest-(len2-1), tmp.slice(0, len2));\n-        }\n-    }\n-\n-    fn merge_collapse(&mut self, array: &mut [T]) {\n-        while self.runs.len() > 1 {\n-            let mut n = self.runs.len()-2;\n-            if n > 0 &&\n-                self.runs[n-1].len <= self.runs[n].len + self.runs[n+1].len\n-            {\n-                if self.runs[n-1].len < self.runs[n+1].len { n -= 1; }\n-            } else if self.runs[n].len <= self.runs[n+1].len {\n-                /* keep going */\n-            } else {\n-                break;\n-            }\n-            self.merge_at(n, array);\n-        }\n-    }\n-\n-    fn merge_force_collapse(&mut self, array: &mut [T]) {\n-        while self.runs.len() > 1 {\n-            let mut n = self.runs.len()-2;\n-            if n > 0 {\n-                if self.runs[n-1].len < self.runs[n+1].len {\n-                    n -= 1;\n-                }\n-            }\n-            self.merge_at(n, array);\n-        }\n-    }\n-}\n-\n-#[inline]\n-fn copy_vec<T:Clone>(dest: &mut [T],\n-                    s1: uint,\n-                    from: &[T]) {\n-    assert!(s1+from.len() <= dest.len());\n-\n-    for (i, v) in from.iter().enumerate() {\n-        dest[s1+i] = (*v).clone();\n-    }\n-}\n-\n-#[inline]\n-fn shift_vec<T:Clone>(dest: &mut [T], s1: uint, s2: uint, len: uint) {\n-    assert!(s1+len <= dest.len());\n-\n-    let tmp = dest.slice(s2, s2+len).to_owned();\n-    copy_vec(dest, s1, tmp);\n-}\n-\n-#[cfg(test)]\n-mod test_qsort3 {\n-    use sort::*;\n-\n-\n-    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n-        let len = v1.len();\n-        quick_sort3::<int>(v1);\n-        let mut i = 0;\n-        while i < len {\n-            assert_eq!(v2[i], v1[i]);\n-            i += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test() {\n-        {\n-            let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n-            let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n-            check_sort(v1, v2);\n-        }\n-        {\n-            let mut v1 = ~[1, 1, 1];\n-            let mut v2 = ~[1, 1, 1];\n-            check_sort(v1, v2);\n-        }\n-        {\n-            let mut v1: ~[int] = ~[];\n-            let mut v2: ~[int] = ~[];\n-            check_sort(v1, v2);\n-        }\n-        { let mut v1 = ~[9]; let mut v2 = ~[9]; check_sort(v1, v2); }\n-        {\n-            let mut v1 = ~[9, 3, 3, 3, 9];\n-            let mut v2 = ~[3, 3, 3, 9, 9];\n-            check_sort(v1, v2);\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test_qsort {\n-    use sort::*;\n-\n-    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n-        let len = v1.len();\n-        fn leual(a: &int, b: &int) -> bool { *a <= *b }\n-        quick_sort::<int>(v1, leual);\n-        let mut i = 0u;\n-        while i < len {\n-            // debug!(v2[i]);\n-            assert_eq!(v2[i], v1[i]);\n-            i += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test() {\n-        {\n-            let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n-            let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n-            check_sort(v1, v2);\n-        }\n-        {\n-            let mut v1 = ~[1, 1, 1];\n-            let mut v2 = ~[1, 1, 1];\n-            check_sort(v1, v2);\n-        }\n-        {\n-            let mut v1: ~[int] = ~[];\n-            let mut v2: ~[int] = ~[];\n-            check_sort(v1, v2);\n-        }\n-        { let mut v1 = ~[9]; let mut v2 = ~[9]; check_sort(v1, v2); }\n-        {\n-            let mut v1 = ~[9, 3, 3, 3, 9];\n-            let mut v2 = ~[3, 3, 3, 9, 9];\n-            check_sort(v1, v2);\n-        }\n-    }\n-\n-    // Regression test for #750\n-    #[test]\n-    fn test_simple() {\n-        let mut names = ~[2, 1, 3];\n-\n-        let expected = ~[1, 2, 3];\n-\n-        quick_sort(names, |x, y| *x < *y);\n-\n-        let immut_names = names;\n-\n-        for (&a, &b) in expected.iter().zip(immut_names.iter()) {\n-            debug!(\"{} {}\", a, b);\n-            assert_eq!(a, b);\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-\n-    use sort::*;\n-\n-    fn check_sort(v1: &[int], v2: &[int]) {\n-        let len = v1.len();\n-        fn le(a: &int, b: &int) -> bool { *a <= *b }\n-        let f = le;\n-        let v3 = merge_sort::<int>(v1, f);\n-        let mut i = 0u;\n-        while i < len {\n-            debug!(\"{:?}\", v3[i]);\n-            assert_eq!(v3[i], v2[i]);\n-            i += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test() {\n-        {\n-            let v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n-            let v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n-            check_sort(v1, v2);\n-        }\n-        { let v1 = ~[1, 1, 1]; let v2 = ~[1, 1, 1]; check_sort(v1, v2); }\n-        { let v1:~[int] = ~[]; let v2:~[int] = ~[]; check_sort(v1, v2); }\n-        { let v1 = ~[9]; let v2 = ~[9]; check_sort(v1, v2); }\n-        {\n-            let v1 = ~[9, 3, 3, 3, 9];\n-            let v2 = ~[3, 3, 3, 9, 9];\n-            check_sort(v1, v2);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_merge_sort_mutable() {\n-        fn le(a: &int, b: &int) -> bool { *a <= *b }\n-        let v1 = ~[3, 2, 1];\n-        let v2 = merge_sort(v1, le);\n-        assert_eq!(v2, ~[1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_merge_sort_stability() {\n-        // tjc: funny that we have to use parens\n-        fn ile(x: &(&'static str), y: &(&'static str)) -> bool\n-        {\n-            let x = x.to_ascii().to_lower().into_str();\n-            let y = y.to_ascii().to_lower().into_str();\n-            x <= y\n-        }\n-\n-        let names1 = ~[\"joe bob\", \"Joe Bob\", \"Jack Brown\", \"JOE Bob\",\n-                       \"Sally Mae\", \"JOE BOB\", \"Alex Andy\"];\n-        let names2 = ~[\"Alex Andy\", \"Jack Brown\", \"joe bob\", \"Joe Bob\",\n-                       \"JOE Bob\", \"JOE BOB\", \"Sally Mae\"];\n-        let names3 = merge_sort(names1, ile);\n-        assert_eq!(names3, names2);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test_tim_sort {\n-\n-    use sort::tim_sort;\n-    use std::rand::Rng;\n-    use std::rand;\n-    use std::vec;\n-\n-    #[deriving(Clone)]\n-    struct CVal {\n-        val: f64,\n-    }\n-\n-    impl Ord for CVal {\n-        fn lt(&self, other: &CVal) -> bool {\n-            let mut rng = rand::rng();\n-            if rng.gen::<f64>() > 0.995 {\n-                fail!(\"It's happening!!!\");\n-            }\n-            (*self).val < other.val\n-        }\n-        fn le(&self, other: &CVal) -> bool { (*self).val <= other.val }\n-        fn gt(&self, other: &CVal) -> bool { (*self).val > other.val }\n-        fn ge(&self, other: &CVal) -> bool { (*self).val >= other.val }\n-    }\n-\n-    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n-        let len = v1.len();\n-        tim_sort::<int>(v1);\n-        let mut i = 0u;\n-        while i < len {\n-            // debug!(v2[i]);\n-            assert_eq!(v2[i], v1[i]);\n-            i += 1u;\n-        }\n-    }\n-\n-    #[test]\n-    fn test() {\n-        {\n-            let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n-            let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n-            check_sort(v1, v2);\n-        }\n-        {\n-            let mut v1 = ~[1, 1, 1];\n-            let mut v2 = ~[1, 1, 1];\n-            check_sort(v1, v2);\n-        }\n-        {\n-            let mut v1: ~[int] = ~[];\n-            let mut v2: ~[int] = ~[];\n-            check_sort(v1, v2);\n-        }\n-        { let mut v1 = ~[9]; let mut v2 = ~[9]; check_sort(v1, v2); }\n-        {\n-            let mut v1 = ~[9, 3, 3, 3, 9];\n-            let mut v2 = ~[3, 3, 3, 9, 9];\n-            check_sort(v1, v2);\n-        }\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    #[cfg(unix)]\n-    fn crash_test() {\n-        let mut rng = rand::rng();\n-        let mut arr = vec::from_fn(1000, |_i| {\n-            CVal { val: rng.gen() }\n-        });\n-\n-        tim_sort(arr);\n-        fail!(\"Guarantee the fail\");\n-    }\n-\n-    #[deriving(Clone)]\n-    struct DVal {\n-        val: uint,\n-    }\n-\n-    impl Ord for DVal {\n-        fn lt(&self, _x: &DVal) -> bool { true }\n-        fn le(&self, _x: &DVal) -> bool { true }\n-        fn gt(&self, _x: &DVal) -> bool { true }\n-        fn ge(&self, _x: &DVal) -> bool { true }\n-    }\n-\n-    #[test]\n-    fn test_bad_Ord_impl() {\n-        let mut rng = rand::rng();\n-        let mut arr = vec::from_fn(500, |_i| {\n-            DVal { val: rng.gen() }\n-        });\n-\n-        tim_sort(arr);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod big_tests {\n-\n-    use sort::*;\n-\n-    use std::rand::Rng;\n-    use std::rand;\n-    use std::vec;\n-\n-    #[test]\n-    fn test_unique() {\n-        let low = 5;\n-        let high = 10;\n-        tabulate_unique(low, high);\n-    }\n-\n-    #[test]\n-    fn test_managed() {\n-        let low = 5;\n-        let high = 10;\n-        tabulate_managed(low, high);\n-    }\n-\n-    fn multiplyVec<T:Clone>(arr: &[T], num: uint) -> ~[T] {\n-        let size = arr.len();\n-        let res = vec::from_fn(num, |i| {\n-            arr[i % size].clone()\n-        });\n-        res\n-    }\n-\n-    fn makeRange(n: uint) -> ~[uint] {\n-        let one = vec::from_fn(n, |i| i);\n-        let mut two = one.clone();\n-        two.reverse();\n-        vec::append(two, one)\n-    }\n-\n-    fn tabulate_unique(lo: uint, hi: uint) {\n-        fn isSorted<T:Ord>(arr: &[T]) {\n-            for i in range(0u, arr.len() - 1) {\n-                if arr[i] > arr[i+1] {\n-                    fail!(\"Array not sorted\");\n-                }\n-            }\n-        }\n-\n-        let mut rng = rand::rng();\n-\n-        for i in range(lo, hi) {\n-            let n = 1 << i;\n-            let mut arr: ~[f64] = vec::from_fn(n, |_i| {\n-                rng.gen()\n-            });\n-\n-            tim_sort(arr); // *sort\n-            isSorted(arr);\n-\n-            arr.reverse();\n-            tim_sort(arr); // \\sort\n-            isSorted(arr);\n-\n-            tim_sort(arr); // /sort\n-            isSorted(arr);\n-\n-            3.times(|| {\n-                let i1 = rng.gen_range(0u, n);\n-                let i2 = rng.gen_range(0u, n);\n-                arr.swap(i1, i2);\n-            });\n-            tim_sort(arr); // 3sort\n-            isSorted(arr);\n-\n-            if n >= 10 {\n-                let size = arr.len();\n-                let mut idx = 1;\n-                while idx <= 10 {\n-                    arr[size-idx] = rng.gen();\n-                    idx += 1;\n-                }\n-            }\n-            tim_sort(arr); // +sort\n-            isSorted(arr);\n-\n-            (n/100).times(|| {\n-                let idx = rng.gen_range(0u, n);\n-                arr[idx] = rng.gen();\n-            });\n-            tim_sort(arr);\n-            isSorted(arr);\n-\n-            let mut arr = if n > 4 {\n-                let part = arr.slice(0, 4);\n-                multiplyVec(part, n)\n-            } else { arr };\n-            tim_sort(arr); // ~sort\n-            isSorted(arr);\n-\n-            let mut arr = vec::from_elem(n, -0.5);\n-            tim_sort(arr); // =sort\n-            isSorted(arr);\n-\n-            let half = n / 2;\n-            let mut arr = makeRange(half).map(|i| *i as f64);\n-            tim_sort(arr); // !sort\n-            isSorted(arr);\n-        }\n-    }\n-\n-    fn tabulate_managed(lo: uint, hi: uint) {\n-        fn isSorted<T:Ord>(arr: &[@T]) {\n-            for i in range(0u, arr.len() - 1) {\n-                if arr[i] > arr[i+1] {\n-                    fail!(\"Array not sorted\");\n-                }\n-            }\n-        }\n-\n-        let mut rng = rand::rng();\n-\n-        for i in range(lo, hi) {\n-            let n = 1 << i;\n-            let arr: ~[@f64] = vec::from_fn(n, |_i| {\n-                @rng.gen()\n-            });\n-            let mut arr = arr;\n-\n-            tim_sort(arr); // *sort\n-            isSorted(arr);\n-\n-            arr.reverse();\n-            tim_sort(arr); // \\sort\n-            isSorted(arr);\n-\n-            tim_sort(arr); // /sort\n-            isSorted(arr);\n-\n-            3.times(|| {\n-                let i1 = rng.gen_range(0u, n);\n-                let i2 = rng.gen_range(0u, n);\n-                arr.swap(i1, i2);\n-            });\n-            tim_sort(arr); // 3sort\n-            isSorted(arr);\n-\n-            if n >= 10 {\n-                let size = arr.len();\n-                let mut idx = 1;\n-                while idx <= 10 {\n-                    arr[size-idx] = @rng.gen();\n-                    idx += 1;\n-                }\n-            }\n-            tim_sort(arr); // +sort\n-            isSorted(arr);\n-\n-            (n/100).times(|| {\n-                let idx = rng.gen_range(0u, n);\n-                arr[idx] = @rng.gen();\n-            });\n-            tim_sort(arr);\n-            isSorted(arr);\n-\n-            let mut arr = if n > 4 {\n-                let part = arr.slice(0, 4);\n-                multiplyVec(part, n)\n-            } else { arr };\n-            tim_sort(arr); // ~sort\n-            isSorted(arr);\n-\n-            let mut arr = vec::from_elem(n, @(-0.5));\n-            tim_sort(arr); // =sort\n-            isSorted(arr);\n-\n-            let half = n / 2;\n-            let mut arr = makeRange(half).map(|i| @(*i as f64));\n-            tim_sort(arr); // !sort\n-            isSorted(arr);\n-        }\n-    }\n-}"}, {"sha": "5f3700fec07900b1317751a004f3702fdf7dfc9c", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=55cbef611a25431c9614c2f4343472014977f5df", "patch": "@@ -10,7 +10,6 @@\n \n #[allow(missing_doc)];\n \n-use sort;\n use std::cmp;\n use std::hashmap;\n use std::io;\n@@ -20,6 +19,25 @@ use std::util;\n // NB: this can probably be rewritten in terms of num::Num\n // to be less f64-specific.\n \n+fn f64_cmp(x: f64, y: f64) -> Ordering {\n+    // arbitrarily decide that NaNs are larger than everything.\n+    if y.is_nan() {\n+        Less\n+    } else if x.is_nan() {\n+        Greater\n+    } else if x < y {\n+        Less\n+    } else if x == y {\n+        Equal\n+    } else {\n+        Greater\n+    }\n+}\n+\n+fn f64_sort(v: &mut [f64]) {\n+    v.sort_by(|x: &f64, y: &f64| f64_cmp(*x, *y));\n+}\n+\n /// Trait that provides simple descriptive statistics on a univariate set of numeric samples.\n pub trait Stats {\n \n@@ -240,13 +258,13 @@ impl<'a> Stats for &'a [f64] {\n \n     fn percentile(self, pct: f64) -> f64 {\n         let mut tmp = self.to_owned();\n-        sort::tim_sort(tmp);\n+        f64_sort(tmp);\n         percentile_of_sorted(tmp, pct)\n     }\n \n     fn quartiles(self) -> (f64,f64,f64) {\n         let mut tmp = self.to_owned();\n-        sort::tim_sort(tmp);\n+        f64_sort(tmp);\n         let a = percentile_of_sorted(tmp, 25.0);\n         let b = percentile_of_sorted(tmp, 50.0);\n         let c = percentile_of_sorted(tmp, 75.0);\n@@ -291,7 +309,7 @@ fn percentile_of_sorted(sorted_samples: &[f64],\n /// See: http://en.wikipedia.org/wiki/Winsorising\n pub fn winsorize(samples: &mut [f64], pct: f64) {\n     let mut tmp = samples.to_owned();\n-    sort::tim_sort(tmp);\n+    f64_sort(tmp);\n     let lo = percentile_of_sorted(tmp, pct);\n     let hi = percentile_of_sorted(tmp, 100.0-pct);\n     for samp in samples.mut_iter() {"}, {"sha": "3d6dfd612f25442c31892dc1fa1620f4bd671d69", "filename": "src/libextra/test.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=55cbef611a25431c9614c2f4343472014977f5df", "patch": "@@ -21,7 +21,6 @@ use getopts::groups;\n use json::ToJson;\n use json;\n use serialize::Decodable;\n-use sort;\n use stats::Stats;\n use stats;\n use term;\n@@ -38,7 +37,6 @@ use std::to_str::ToStr;\n use std::f64;\n use std::os;\n \n-\n // The name of a test. By convention this follows the rules for rust\n // paths; i.e. it should be a series of identifiers separated by double\n // colons. This way if some test runner wants to arrange the tests\n@@ -488,7 +486,7 @@ impl<T: Writer> ConsoleTestState<T> {\n         for f in self.failures.iter() {\n             failures.push(f.name.to_str());\n         }\n-        sort::tim_sort(failures);\n+        failures.sort();\n         for name in failures.iter() {\n             self.write_plain(format!(\"    {}\\n\", name.to_str()));\n         }\n@@ -839,10 +837,7 @@ pub fn filter_tests(\n     };\n \n     // Sort the tests alphabetically\n-    fn lteq(t1: &TestDescAndFn, t2: &TestDescAndFn) -> bool {\n-        t1.desc.name.to_str() < t2.desc.name.to_str()\n-    }\n-    sort::quick_sort(filtered, lteq);\n+    filtered.sort_by(|t1, t2| t1.desc.name.to_str().cmp(&t2.desc.name.to_str()));\n \n     // Shard the remaining tests, if sharding requested.\n     match opts.test_shard {"}, {"sha": "a516c2b819adc40da5057cf7a710e788598f9fc2", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=55cbef611a25431c9614c2f4343472014977f5df", "patch": "@@ -151,7 +151,6 @@ Additional help:\n }\n \n pub fn describe_warnings() {\n-    use extra::sort::Sort;\n     println(\"\n Available lint options:\n     -W <foo>           Warn about <foo>\n@@ -164,7 +163,7 @@ Available lint options:\n     let mut lint_dict = lint_dict.move_iter()\n                                  .map(|(k, v)| (v, k))\n                                  .collect::<~[(lint::LintSpec, &'static str)]>();\n-    lint_dict.qsort();\n+    lint_dict.sort();\n \n     let mut max_key = 0;\n     for &(_, name) in lint_dict.iter() {"}, {"sha": "577ef8af9f86722d97149d0d3a53cd2163cda347", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=55cbef611a25431c9614c2f4343472014977f5df", "patch": "@@ -18,7 +18,6 @@ use metadata::decoder;\n use metadata::loader;\n \n use std::hashmap::HashMap;\n-use extra;\n use syntax::ast;\n use syntax::parse::token::ident_interner;\n \n@@ -174,7 +173,7 @@ pub fn find_extern_mod_stmt_cnum(cstore: &CStore,\n     cstore.extern_mod_crate_map.find(&emod_id).map(|x| *x)\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, TotalEq, TotalOrd)]\n struct crate_hash {\n     name: @str,\n     vers: @str,\n@@ -198,16 +197,14 @@ pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n         });\n     }\n \n-    let sorted = extra::sort::merge_sort(result, |a, b| {\n-        (a.name, a.vers, a.hash) <= (b.name, b.vers, b.hash)\n-    });\n+    result.sort();\n \n     debug!(\"sorted:\");\n-    for x in sorted.iter() {\n+    for x in result.iter() {\n         debug!(\"  hash[{}]: {}\", x.name, x.hash);\n     }\n \n-    sorted.map(|ch| ch.hash)\n+    result.map(|ch| ch.hash)\n }\n \n impl crate_metadata {"}, {"sha": "9494ea5c4a89ad822b4d01c6b5e2b47bef58dfe0", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=55cbef611a25431c9614c2f4343472014977f5df", "patch": "@@ -30,7 +30,6 @@ use std::util;\n use std::vec;\n \n use extra::serialize::Encodable;\n-use extra;\n \n use syntax::abi::AbiSet;\n use syntax::ast::*;\n@@ -1532,7 +1531,7 @@ fn encode_crate_deps(ecx: &EncodeContext,\n         });\n \n         // Sort by cnum\n-        extra::sort::quick_sort(deps, |kv1, kv2| kv1.cnum <= kv2.cnum);\n+        deps.sort_by(|kv1, kv2| kv1.cnum.cmp(&kv2.cnum));\n \n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;"}, {"sha": "948c7932ca0dc592e239a7f84ddca9a3fcf7fed7", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=55cbef611a25431c9614c2f4343472014977f5df", "patch": "@@ -21,7 +21,6 @@ use util::ppaux::ty_to_str;\n use std::iter;\n use std::num;\n use std::vec;\n-use extra::sort;\n use syntax::ast::*;\n use syntax::ast_util::{unguarded_pat, walk_pat};\n use syntax::codemap::{Span, dummy_sp, Spanned};\n@@ -454,7 +453,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n       ty::ty_unboxed_vec(..) | ty::ty_evec(..) => {\n \n         // Find the lengths and slices of all vector patterns.\n-        let vec_pat_lens = m.iter().filter_map(|r| {\n+        let mut vec_pat_lens = m.iter().filter_map(|r| {\n             match r[0].node {\n                 PatVec(ref before, ref slice, ref after) => {\n                     Some((before.len() + after.len(), slice.is_some()))\n@@ -465,21 +464,19 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n \n         // Sort them by length such that for patterns of the same length,\n         // those with a destructured slice come first.\n-        let mut sorted_vec_lens = sort::merge_sort(vec_pat_lens,\n-            |&(len1, slice1), &(len2, slice2)| {\n-                if len1 == len2 {\n-                    slice1 > slice2\n-                } else {\n-                    len1 <= len2\n-                }\n-            }\n-        );\n-        sorted_vec_lens.dedup();\n+        vec_pat_lens.sort_by(|&(len1, slice1), &(len2, slice2)| {\n+                    if len1 == len2 {\n+                        slice2.cmp(&slice1)\n+                    } else {\n+                        len1.cmp(&len2)\n+                    }\n+                });\n+        vec_pat_lens.dedup();\n \n         let mut found_slice = false;\n         let mut next = 0;\n         let mut missing = None;\n-        for &(length, slice) in sorted_vec_lens.iter() {\n+        for &(length, slice) in vec_pat_lens.iter() {\n             if length != next {\n                 missing = Some(next);\n                 break;"}, {"sha": "9ec0fa337168cbaac97bbc080f421b797b5c7676", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=55cbef611a25431c9614c2f4343472014977f5df", "patch": "@@ -63,7 +63,7 @@ use syntax::{ast, ast_util, visit};\n use syntax::ast_util::IdVisitingOperation;\n use syntax::visit::Visitor;\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd)]\n pub enum lint {\n     ctypes,\n     unused_imports,\n@@ -110,20 +110,16 @@ pub fn level_to_str(lv: level) -> &'static str {\n     }\n }\n \n-#[deriving(Clone, Eq, Ord)]\n+#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd)]\n pub enum level {\n     allow, warn, deny, forbid\n }\n \n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd)]\n pub struct LintSpec {\n+    default: level,\n     lint: lint,\n     desc: &'static str,\n-    default: level\n-}\n-\n-impl Ord for LintSpec {\n-    fn lt(&self, other: &LintSpec) -> bool { self.default < other.default }\n }\n \n pub type LintDict = HashMap<&'static str, LintSpec>;"}, {"sha": "2f128e59d9dca4ef4ba04d963498fcd08c7a944c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=55cbef611a25431c9614c2f4343472014977f5df", "patch": "@@ -73,7 +73,6 @@ use std::libc::c_uint;\n use std::vec;\n use std::local_data;\n use extra::time;\n-use extra::sort;\n use syntax::ast::Name;\n use syntax::ast_map::{path, path_elt_to_str, path_name, path_pretty_name};\n use syntax::ast_util::{local_def, is_local};\n@@ -3163,10 +3162,9 @@ pub fn trans_crate(sess: session::Session,\n         println!(\"n_inlines: {}\", ccx.stats.n_inlines);\n         println!(\"n_closures: {}\", ccx.stats.n_closures);\n         println(\"fn stats:\");\n-        sort::quick_sort(ccx.stats.fn_stats,\n-                         |&(_, _, insns_a), &(_, _, insns_b)| {\n-            insns_a > insns_b\n-        });\n+\n+        ccx.stats.fn_stats.sort_by(|&(_, _, insns_a), &(_, _, insns_b)| insns_b.cmp(&insns_a));\n+\n         for tuple in ccx.stats.fn_stats.iter() {\n             match *tuple {\n                 (ref name, ms, insns) => {"}, {"sha": "8a14e37c816899137edfb18f2d8d318d57e4db4c", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=55cbef611a25431c9614c2f4343472014977f5df", "patch": "@@ -45,8 +45,6 @@ use std::vec;\n \n use extra::arc::Arc;\n use extra::json::ToJson;\n-use extra::sort;\n-\n use syntax::ast;\n use syntax::attr;\n \n@@ -900,44 +898,44 @@ fn item_module(w: &mut Writer, cx: &Context,\n     debug!(\"{:?}\", items);\n     let mut indices = vec::from_fn(items.len(), |i| i);\n \n-    fn lt(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> bool {\n+    fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> Ordering {\n         if shortty(i1) == shortty(i2) {\n-            return i1.name < i2.name;\n+            return i1.name.cmp(&i2.name);\n         }\n         match (&i1.inner, &i2.inner) {\n             (&clean::ViewItemItem(ref a), &clean::ViewItemItem(ref b)) => {\n                 match (&a.inner, &b.inner) {\n-                    (&clean::ExternMod(..), _) => true,\n-                    (_, &clean::ExternMod(..)) => false,\n-                    _ => idx1 < idx2,\n+                    (&clean::ExternMod(..), _) => Less,\n+                    (_, &clean::ExternMod(..)) => Greater,\n+                    _ => idx1.cmp(&idx2),\n                 }\n             }\n-            (&clean::ViewItemItem(..), _) => true,\n-            (_, &clean::ViewItemItem(..)) => false,\n-            (&clean::ModuleItem(..), _) => true,\n-            (_, &clean::ModuleItem(..)) => false,\n-            (&clean::StructItem(..), _) => true,\n-            (_, &clean::StructItem(..)) => false,\n-            (&clean::EnumItem(..), _) => true,\n-            (_, &clean::EnumItem(..)) => false,\n-            (&clean::StaticItem(..), _) => true,\n-            (_, &clean::StaticItem(..)) => false,\n-            (&clean::ForeignFunctionItem(..), _) => true,\n-            (_, &clean::ForeignFunctionItem(..)) => false,\n-            (&clean::ForeignStaticItem(..), _) => true,\n-            (_, &clean::ForeignStaticItem(..)) => false,\n-            (&clean::TraitItem(..), _) => true,\n-            (_, &clean::TraitItem(..)) => false,\n-            (&clean::FunctionItem(..), _) => true,\n-            (_, &clean::FunctionItem(..)) => false,\n-            (&clean::TypedefItem(..), _) => true,\n-            (_, &clean::TypedefItem(..)) => false,\n-            _ => idx1 < idx2,\n+            (&clean::ViewItemItem(..), _) => Less,\n+            (_, &clean::ViewItemItem(..)) => Greater,\n+            (&clean::ModuleItem(..), _) => Less,\n+            (_, &clean::ModuleItem(..)) => Greater,\n+            (&clean::StructItem(..), _) => Less,\n+            (_, &clean::StructItem(..)) => Greater,\n+            (&clean::EnumItem(..), _) => Less,\n+            (_, &clean::EnumItem(..)) => Greater,\n+            (&clean::StaticItem(..), _) => Less,\n+            (_, &clean::StaticItem(..)) => Greater,\n+            (&clean::ForeignFunctionItem(..), _) => Less,\n+            (_, &clean::ForeignFunctionItem(..)) => Greater,\n+            (&clean::ForeignStaticItem(..), _) => Less,\n+            (_, &clean::ForeignStaticItem(..)) => Greater,\n+            (&clean::TraitItem(..), _) => Less,\n+            (_, &clean::TraitItem(..)) => Greater,\n+            (&clean::FunctionItem(..), _) => Less,\n+            (_, &clean::FunctionItem(..)) => Greater,\n+            (&clean::TypedefItem(..), _) => Less,\n+            (_, &clean::TypedefItem(..)) => Greater,\n+            _ => idx1.cmp(&idx2),\n         }\n     }\n \n     debug!(\"{:?}\", indices);\n-    sort::quick_sort(indices, |&i1, &i2| lt(&items[i1], &items[i2], i1, i2));\n+    indices.sort_by(|&i1, &i2| cmp(&items[i1], &items[i2], i1, i2));\n \n     debug!(\"{:?}\", indices);\n     let mut curty = \"\";\n@@ -1532,7 +1530,7 @@ fn build_sidebar(m: &clean::Module) -> HashMap<~str, ~[~str]> {\n     }\n \n     for (_, items) in map.mut_iter() {\n-        sort::quick_sort(*items, |i1, i2| i1 < i2);\n+        items.sort();\n     }\n     return map;\n }"}, {"sha": "583e87370bc72f11a46f441328ca4f209127fb36", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=55cbef611a25431c9614c2f4343472014977f5df", "patch": "@@ -79,7 +79,8 @@ pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n pub use vec::{ImmutableEqVector, ImmutableTotalOrdVector, ImmutableCopyableVector};\n-pub use vec::{OwnedVector, OwnedCopyableVector,OwnedEqVector, MutableVector};\n+pub use vec::{OwnedVector, OwnedCopyableVector,OwnedEqVector};\n+pub use vec::{MutableVector, MutableTotalOrdVector};\n pub use vec::{Vector, VectorVector, CopyableVector, ImmutableVector};\n \n // Reexported runtime types"}, {"sha": "e52243d6724f6174a70c06539ded13d61026ef48", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 295, "deletions": 1, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=55cbef611a25431c9614c2f4343472014977f5df", "patch": "@@ -1921,6 +1921,151 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n     }\n }\n \n+fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n+    // warning: this wildly uses unsafe.\n+    static INSERTION: uint = 8;\n+\n+    let len = v.len();\n+\n+    // allocate some memory to use as scratch memory, we keep the\n+    // length 0 so we can keep shallow copies of the contents of `v`\n+    // without risking the dtors running on an object twice if\n+    // `compare` fails.\n+    let mut working_space = with_capacity(2 * len);\n+    // these both are buffers of length `len`.\n+    let mut buf_dat = working_space.as_mut_ptr();\n+    let mut buf_tmp = unsafe {buf_dat.offset(len as int)};\n+\n+    // length `len`.\n+    let buf_v = v.as_ptr();\n+\n+    // step 1. sort short runs with insertion sort. This takes the\n+    // values from `v` and sorts them into `buf_dat`, leaving that\n+    // with sorted runs of length INSERTION.\n+\n+    // We could hardcode the sorting comparisons here, and we could\n+    // manipulate/step the pointers themselves, rather than repeatedly\n+    // .offset-ing.\n+    for start in range_step(0, len, INSERTION) {\n+        // start <= i <= len;\n+        for i in range(start, cmp::min(start + INSERTION, len)) {\n+            // j satisfies: start <= j <= i;\n+            let mut j = i as int;\n+            unsafe {\n+                // `i` is in bounds.\n+                let read_ptr = buf_v.offset(i as int);\n+\n+                // find where to insert, we need to do strict <,\n+                // rather than <=, to maintain stability.\n+\n+                // start <= j - 1 < len, so .offset(j - 1) is in\n+                // bounds.\n+                while j > start as int &&\n+                        compare(&*read_ptr, &*buf_dat.offset(j - 1)) == Less {\n+                    j -= 1;\n+                }\n+\n+                // shift everything to the right, to make space to\n+                // insert this value.\n+\n+                // j + 1 could be `len` (for the last `i`), but in\n+                // that case, `i == j` so we don't copy. The\n+                // `.offset(j)` is always in bounds.\n+                ptr::copy_memory(buf_dat.offset(j + 1),\n+                                 buf_dat.offset(j),\n+                                 i - j as uint);\n+                ptr::copy_nonoverlapping_memory(buf_dat.offset(j), read_ptr, 1);\n+            }\n+        }\n+    }\n+\n+    // step 2. merge the sorted runs.\n+    let mut width = INSERTION;\n+    while width < len {\n+        // merge the sorted runs of length `width` in `buf_dat` two at\n+        // a time, placing the result in `buf_tmp`.\n+\n+        // 0 <= start <= len.\n+        for start in range_step(0, len, 2 * width) {\n+            // manipulate pointers directly for speed (rather than\n+            // using a `for` loop with `range` and `.offset` inside\n+            // that loop).\n+            unsafe {\n+                // the end of the first run & start of the\n+                // second. Offset of `len` is defined, since this is\n+                // precisely one byte past the end of the object.\n+                let right_start = buf_dat.offset(cmp::min(start + width, len) as int);\n+                // end of the second. Similar reasoning to the above re safety.\n+                let right_end_idx = cmp::min(start + 2 * width, len);\n+                let right_end = buf_dat.offset(right_end_idx as int);\n+\n+                // the pointers to the elements under consideration\n+                // from the two runs.\n+\n+                // both of these are in bounds.\n+                let mut left = buf_dat.offset(start as int);\n+                let mut right = right_start;\n+\n+                // where we're putting the results, it is a run of\n+                // length `2*width`, so we step it once for each step\n+                // of either `left` or `right`.  `buf_tmp` has length\n+                // `len`, so these are in bounds.\n+                let mut out = buf_tmp.offset(start as int);\n+                let out_end = buf_tmp.offset(right_end_idx as int);\n+\n+                while out < out_end {\n+                    // Either the left or the right run are exhausted,\n+                    // so just copy the remainder from the other run\n+                    // and move on; this gives a huge speed-up (order\n+                    // of 25%) for mostly sorted vectors (the best\n+                    // case).\n+                    if left == right_start {\n+                        // the number remaining in this run.\n+                        let elems = (right_end as uint - right as uint) / mem::size_of::<T>();\n+                        ptr::copy_nonoverlapping_memory(out, right, elems);\n+                        break;\n+                    } else if right == right_end {\n+                        let elems = (right_start as uint - left as uint) / mem::size_of::<T>();\n+                        ptr::copy_nonoverlapping_memory(out, left, elems);\n+                        break;\n+                    }\n+\n+                    // check which side is smaller, and that's the\n+                    // next element for the new run.\n+\n+                    // `left < right_start` and `right < right_end`,\n+                    // so these are valid.\n+                    let to_copy = if compare(&*left, &*right) == Greater {\n+                        step(&mut right)\n+                    } else {\n+                        step(&mut left)\n+                    };\n+                    ptr::copy_nonoverlapping_memory(out, to_copy, 1);\n+                    step(&mut out);\n+                }\n+            }\n+        }\n+\n+        util::swap(&mut buf_dat, &mut buf_tmp);\n+\n+        width *= 2;\n+    }\n+\n+    // write the result to `v` in one go, so that there are never two copies\n+    // of the same object in `v`.\n+    unsafe {\n+        ptr::copy_nonoverlapping_memory(v.as_mut_ptr(), buf_dat, len);\n+    }\n+\n+    // increment the pointer, returning the old pointer.\n+    #[inline(always)]\n+    unsafe fn step<T>(ptr: &mut *mut T) -> *mut T {\n+        let old = *ptr;\n+        *ptr = ptr.offset(1);\n+        old\n+    }\n+}\n+\n /// Extension methods for vectors such that their elements are\n /// mutable.\n pub trait MutableVector<'a, T> {\n@@ -2020,6 +2165,25 @@ pub trait MutableVector<'a, T> {\n     /// Reverse the order of elements in a vector, in place\n     fn reverse(self);\n \n+    /// Sort the vector, in place, using `compare` to compare\n+    /// elements.\n+    ///\n+    /// This sort is `O(n log n)` worst-case and stable, but allocates\n+    /// approximately `2 * n`, where `n` is the length of `self`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [5, 4, 1, 3, 2];\n+    /// v.sort(|a, b| a.cmp(b));\n+    /// assert_eq!(v, [1, 2, 3, 4, 5]);\n+    ///\n+    /// // reverse sorting\n+    /// v.sort(|a, b| b.cmp(a));\n+    /// assert_eq!(v, [5, 4, 3, 2, 1]);\n+    /// ```\n+    fn sort_by(self, compare: |&T, &T| -> Ordering);\n+\n     /**\n      * Consumes `src` and moves as many elements as it can into `self`\n      * from the range [start,end).\n@@ -2163,6 +2327,11 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n         }\n     }\n \n+    #[inline]\n+    fn sort_by(self, compare: |&T, &T| -> Ordering) {\n+        merge_sort(self, compare)\n+    }\n+\n     #[inline]\n     fn move_from(self, mut src: ~[T], start: uint, end: uint) -> uint {\n         for (a, b) in self.mut_iter().zip(src.mut_slice(start, end).mut_iter()) {\n@@ -2216,6 +2385,32 @@ impl<'a, T:Clone> MutableCloneableVector<T> for &'a mut [T] {\n     }\n }\n \n+/// Methods for mutable vectors with orderable elements, such as\n+/// in-place sorting.\n+pub trait MutableTotalOrdVector<T> {\n+    /// Sort the vector, in place.\n+    ///\n+    /// This is equivalent to `self.sort_by(std::vec::SortForward)`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::vec;\n+    ///\n+    /// let mut v = [-5, 4, 1, -3, 2];\n+    ///\n+    /// v.sort();\n+    /// assert_eq!(v, [-5, -3, 1, 2, 4]);\n+    /// ```\n+    fn sort(self);\n+}\n+impl<'a, T: TotalOrd> MutableTotalOrdVector<T> for &'a mut [T] {\n+    #[inline]\n+    fn sort(self) {\n+        self.sort_by(|a,b| a.cmp(b))\n+    }\n+}\n+\n /**\n * Constructs a vector from an unsafe pointer to a buffer\n *\n@@ -2686,6 +2881,7 @@ mod tests {\n     use vec::*;\n     use cmp::*;\n     use prelude::*;\n+    use rand::{Rng, task_rng};\n \n     fn square(n: uint) -> uint { n * n }\n \n@@ -3279,6 +3475,64 @@ mod tests {\n         assert!(v3.is_empty());\n     }\n \n+    #[test]\n+    fn test_sort() {\n+        for len in range(4u, 25) {\n+            for _ in range(0, 100) {\n+                let mut v = task_rng().gen_vec::<uint>(len);\n+                let mut v1 = v.clone();\n+\n+                v.sort();\n+                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+\n+                v1.sort_by(|a, b| a.cmp(b));\n+                assert!(v1.windows(2).all(|w| w[0] <= w[1]));\n+\n+                v1.sort_by(|a, b| b.cmp(a));\n+                assert!(v1.windows(2).all(|w| w[0] >= w[1]));\n+            }\n+        }\n+\n+        // shouldn't fail/crash\n+        let mut v: [uint, .. 0] = [];\n+        v.sort();\n+\n+        let mut v = [0xDEADBEEF];\n+        v.sort();\n+        assert_eq!(v, [0xDEADBEEF]);\n+    }\n+\n+    #[test]\n+    fn test_sort_stability() {\n+        for len in range(4, 25) {\n+            for _ in range(0 , 10) {\n+                let mut counts = [0, .. 10];\n+\n+                // create a vector like [(6, 1), (5, 1), (6, 2), ...],\n+                // where the first item of each tuple is random, but\n+                // the second item represents which occurrence of that\n+                // number this element is, i.e. the second elements\n+                // will occur in sorted order.\n+                let mut v = range(0, len).map(|_| {\n+                        let n = task_rng().gen::<uint>() % 10;\n+                        counts[n] += 1;\n+                        (n, counts[n])\n+                    }).to_owned_vec();\n+\n+                // only sort on the first element, so an unstable sort\n+                // may mix up the counts.\n+                v.sort_by(|&(a,_), &(b,_)| a.cmp(&b));\n+\n+                // this comparison includes the count (the second item\n+                // of the tuple), so elements with equal first items\n+                // will need to be ordered with increasing\n+                // counts... i.e. exactly asserting that this sort is\n+                // stable.\n+                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+            }\n+        }\n+    }\n+\n     #[test]\n     fn test_partition() {\n         assert_eq!((~[]).partition(|x: &int| *x < 3), (~[], ~[]));\n@@ -4102,10 +4356,11 @@ mod bench {\n     use extra::test::BenchHarness;\n     use iter::range;\n     use vec;\n-    use vec::VectorVector;\n+    use vec::{VectorVector, MutableTotalOrdVector};\n     use option::*;\n     use ptr;\n     use rand::{weak_rng, Rng};\n+    use mem;\n \n     #[bench]\n     fn iterator(bh: &mut BenchHarness) {\n@@ -4306,4 +4561,43 @@ mod bench {\n                 }\n             })\n     }\n+\n+    #[bench]\n+    fn sort_random_small(bh: &mut BenchHarness) {\n+        let mut rng = weak_rng();\n+        bh.iter(|| {\n+            let mut v: ~[u64] = rng.gen_vec(5);\n+            v.sort();\n+        });\n+        bh.bytes = 5 * mem::size_of::<u64>() as u64;\n+    }\n+\n+    #[bench]\n+    fn sort_random_medium(bh: &mut BenchHarness) {\n+        let mut rng = weak_rng();\n+        bh.iter(|| {\n+            let mut v: ~[u64] = rng.gen_vec(100);\n+            v.sort();\n+        });\n+        bh.bytes = 100 * mem::size_of::<u64>() as u64;\n+    }\n+\n+    #[bench]\n+    fn sort_random_large(bh: &mut BenchHarness) {\n+        let mut rng = weak_rng();\n+        bh.iter(|| {\n+            let mut v: ~[u64] = rng.gen_vec(10000);\n+            v.sort();\n+        });\n+        bh.bytes = 10000 * mem::size_of::<u64>() as u64;\n+    }\n+\n+    #[bench]\n+    fn sort_sorted(bh: &mut BenchHarness) {\n+        let mut v = vec::from_fn(10000, |i| i);\n+        bh.iter(|| {\n+            v.sort();\n+        });\n+        bh.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n+    }\n }"}, {"sha": "8dff321ca0e6a2d94120beb6aba2f4f217feeeea", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cbef611a25431c9614c2f4343472014977f5df/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=55cbef611a25431c9614c2f4343472014977f5df", "patch": "@@ -10,8 +10,6 @@\n \n // Functions dealing with attributes and meta items\n \n-use extra;\n-\n use ast;\n use ast::{Attribute, Attribute_, MetaItem, MetaWord, MetaNameValue, MetaList};\n use codemap::{Span, Spanned, spanned, dummy_spanned};\n@@ -205,7 +203,7 @@ pub fn sort_meta_items(items: &[@MetaItem]) -> ~[@MetaItem] {\n         .map(|&mi| (mi.name(), mi))\n         .collect::<~[(@str, @MetaItem)]>();\n \n-    extra::sort::quick_sort(v, |&(a, _), &(b, _)| a <= b);\n+    v.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n \n     // There doesn't seem to be a more optimal way to do this\n     v.move_iter().map(|(_, m)| {"}, {"sha": "2f63c6046f80fedec7b9508166cb26921b2845a2", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/55cbef611a25431c9614c2f4343472014977f5df/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cbef611a25431c9614c2f4343472014977f5df/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=55cbef611a25431c9614c2f4343472014977f5df", "patch": "@@ -15,7 +15,6 @@\n \n extern mod extra;\n \n-use extra::sort;\n use std::cmp::Ord;\n use std::comm;\n use std::hashmap::HashMap;\n@@ -27,35 +26,32 @@ use std::task;\n use std::util;\n use std::vec;\n \n+fn f64_cmp(x: f64, y: f64) -> Ordering {\n+    // arbitrarily decide that NaNs are larger than everything.\n+    if y.is_nan() {\n+        Less\n+    } else if x.is_nan() {\n+        Greater\n+    } else if x < y {\n+        Less\n+    } else if x == y {\n+        Equal\n+    } else {\n+        Greater\n+    }\n+}\n+\n // given a map, print a sorted version of it\n fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n    fn pct(xx: uint, yy: uint) -> f64 {\n       return (xx as f64) * 100.0 / (yy as f64);\n    }\n \n-   fn le_by_val<TT:Clone,\n-                UU:Clone + Ord>(\n-                kv0: &(TT,UU),\n-                kv1: &(TT,UU))\n-                -> bool {\n-      let (_, v0) = (*kv0).clone();\n-      let (_, v1) = (*kv1).clone();\n-      return v0 >= v1;\n-   }\n-\n-   fn le_by_key<TT:Clone + Ord,\n-                UU:Clone>(\n-                kv0: &(TT,UU),\n-                kv1: &(TT,UU))\n-                -> bool {\n-      let (k0, _) = (*kv0).clone();\n-      let (k1, _) = (*kv1).clone();\n-      return k0 <= k1;\n-   }\n-\n    // sort by key, then by value\n-   fn sortKV<TT:Clone + Ord, UU:Clone + Ord>(orig: ~[(TT,UU)]) -> ~[(TT,UU)] {\n-      return sort::merge_sort(sort::merge_sort(orig, le_by_key), le_by_val);\n+   fn sortKV(mut orig: ~[(~[u8],f64)]) -> ~[(~[u8],f64)] {\n+        orig.sort_by(|&(ref a, _), &(ref b, _)| a.cmp(b));\n+        orig.sort_by(|&(_, a), &(_, b)| f64_cmp(b, a));\n+        orig\n    }\n \n    let mut pairs = ~[];"}, {"sha": "067ef873fd3d2e4d019c4d5457262f7521f6a45b", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55cbef611a25431c9614c2f4343472014977f5df/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cbef611a25431c9614c2f4343472014977f5df/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=55cbef611a25431c9614c2f4343472014977f5df", "patch": "@@ -9,7 +9,6 @@ use std::libc::{stat, strlen};\n use std::ptr::null;\n use std::unstable::intrinsics::init;\n use std::vec::{reverse};\n-use extra::sort::quick_sort3;\n \n static LINE_LEN: uint = 80;\n static TABLE: [u8, ..4] = [ 'A' as u8, 'C' as u8, 'G' as u8, 'T' as u8 ];\n@@ -267,7 +266,7 @@ fn print_frequencies(frequencies: &Table, frame: i32) {\n     for frequencies.each |entry| {\n         vector.push((entry.code, entry.count));\n     }\n-    quick_sort3(vector);\n+    vector.sort();\n \n     let mut total_count = 0;\n     for vector.each |&(_, count)| {"}, {"sha": "74f27e480909c06598d3ea82c262c8cf67189713", "filename": "src/test/run-pass/vector-sort-failure-safe.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/55cbef611a25431c9614c2f4343472014977f5df/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cbef611a25431c9614c2f4343472014977f5df/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs?ref=55cbef611a25431c9614c2f4343472014977f5df", "patch": "@@ -0,0 +1,89 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::task;\n+use std::rand::{task_rng, Rng};\n+\n+static MAX_LEN: uint = 20;\n+static mut drop_counts: [uint, .. MAX_LEN] = [0, .. MAX_LEN];\n+static mut clone_count: uint = 0;\n+\n+#[deriving(Rand, Ord, TotalEq, TotalOrd)]\n+struct DropCounter { x: uint, clone_num: uint }\n+\n+impl Clone for DropCounter {\n+    fn clone(&self) -> DropCounter {\n+        let num = unsafe { clone_count };\n+        unsafe { clone_count += 1; }\n+        DropCounter {\n+            x: self.x,\n+            clone_num: num\n+        }\n+    }\n+}\n+\n+impl Drop for DropCounter {\n+    fn drop(&mut self) {\n+        unsafe {\n+            // Rand creates some with arbitrary clone_nums\n+            if self.clone_num < MAX_LEN {\n+                drop_counts[self.clone_num] += 1;\n+            }\n+        }\n+    }\n+}\n+\n+pub fn main() {\n+    // len can't go above 64.\n+    for len in range(2u, MAX_LEN) {\n+        for _ in range(0, 10) {\n+            let main = task_rng().gen_vec::<DropCounter>(len);\n+\n+            // work out the total number of comparisons required to sort\n+            // this array...\n+            let mut count = 0;\n+            main.clone().sort_by(|a, b| { count += 1; a.cmp(b) });\n+\n+            // ... and then fail on each and every single one.\n+            for fail_countdown in range(0, count) {\n+                // refresh the counters.\n+                unsafe {\n+                    drop_counts = [0, .. MAX_LEN];\n+                    clone_count = 0;\n+                }\n+\n+                let v = main.clone();\n+\n+                task::try(proc() {\n+                        let mut v = v;\n+                        let mut fail_countdown = fail_countdown;\n+                        v.sort_by(|a, b| {\n+                                if fail_countdown == 0 {\n+                                    fail!()\n+                                }\n+                                fail_countdown -= 1;\n+                                a.cmp(b)\n+                            })\n+                    });\n+\n+                // check that the number of things dropped is exactly\n+                // what we expect (i.e. the contents of `v`).\n+                unsafe {\n+                    for (i, &c) in drop_counts.iter().enumerate() {\n+                        let expected = if i < len {1} else {0};\n+                        assert!(c == expected,\n+                                \"found drop count == {} for i == {}, len == {}\",\n+                                c, i, len);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}]}