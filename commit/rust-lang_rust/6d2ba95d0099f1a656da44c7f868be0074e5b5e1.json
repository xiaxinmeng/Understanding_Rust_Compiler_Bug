{"sha": "6d2ba95d0099f1a656da44c7f868be0074e5b5e1", "node_id": "C_kwDOAAsO6NoAKDZkMmJhOTVkMDA5OWYxYTY1NmRhNDRjN2Y4NjhiZTAwNzRlNWI1ZTE", "commit": {"author": {"name": "y21", "email": "30553356+y21@users.noreply.github.com", "date": "2023-05-14T17:10:52Z"}, "committer": {"name": "y21", "email": "30553356+y21@users.noreply.github.com", "date": "2023-05-16T20:14:51Z"}, "message": "suggest `Option::as_deref(_mut)`", "tree": {"sha": "dffd027a8420daf74893c642103fd7ce131bdf70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dffd027a8420daf74893c642103fd7ce131bdf70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d2ba95d0099f1a656da44c7f868be0074e5b5e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d2ba95d0099f1a656da44c7f868be0074e5b5e1", "html_url": "https://github.com/rust-lang/rust/commit/6d2ba95d0099f1a656da44c7f868be0074e5b5e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d2ba95d0099f1a656da44c7f868be0074e5b5e1/comments", "author": {"login": "y21", "id": 30553356, "node_id": "MDQ6VXNlcjMwNTUzMzU2", "avatar_url": "https://avatars.githubusercontent.com/u/30553356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/y21", "html_url": "https://github.com/y21", "followers_url": "https://api.github.com/users/y21/followers", "following_url": "https://api.github.com/users/y21/following{/other_user}", "gists_url": "https://api.github.com/users/y21/gists{/gist_id}", "starred_url": "https://api.github.com/users/y21/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/y21/subscriptions", "organizations_url": "https://api.github.com/users/y21/orgs", "repos_url": "https://api.github.com/users/y21/repos", "events_url": "https://api.github.com/users/y21/events{/privacy}", "received_events_url": "https://api.github.com/users/y21/received_events", "type": "User", "site_admin": false}, "committer": {"login": "y21", "id": 30553356, "node_id": "MDQ6VXNlcjMwNTUzMzU2", "avatar_url": "https://avatars.githubusercontent.com/u/30553356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/y21", "html_url": "https://github.com/y21", "followers_url": "https://api.github.com/users/y21/followers", "following_url": "https://api.github.com/users/y21/following{/other_user}", "gists_url": "https://api.github.com/users/y21/gists{/gist_id}", "starred_url": "https://api.github.com/users/y21/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/y21/subscriptions", "organizations_url": "https://api.github.com/users/y21/orgs", "repos_url": "https://api.github.com/users/y21/repos", "events_url": "https://api.github.com/users/y21/events{/privacy}", "received_events_url": "https://api.github.com/users/y21/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69fef92ab2f287f072b66fb7b4f62c8bb4acba43", "url": "https://api.github.com/repos/rust-lang/rust/commits/69fef92ab2f287f072b66fb7b4f62c8bb4acba43", "html_url": "https://github.com/rust-lang/rust/commit/69fef92ab2f287f072b66fb7b4f62c8bb4acba43"}], "stats": {"total": 364, "additions": 355, "deletions": 9}, "files": [{"sha": "9f2740a3898dbba013501a6400f0e63a394f1a84", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 96, "deletions": 9, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/6d2ba95d0099f1a656da44c7f868be0074e5b5e1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d2ba95d0099f1a656da44c7f868be0074e5b5e1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=6d2ba95d0099f1a656da44c7f868be0074e5b5e1", "patch": "@@ -13,7 +13,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{\n     error_code, pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder,\n-    ErrorGuaranteed, MultiSpan, Style,\n+    ErrorGuaranteed, MultiSpan, Style, SuggestionStyle,\n };\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n@@ -27,6 +27,7 @@ use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{DefineOpaqueTypes, InferOk, LateBoundRegionConversionTime};\n use rustc_middle::hir::map;\n+use rustc_middle::query::Key;\n use rustc_middle::ty::error::TypeError::{self, Sorts};\n use rustc_middle::ty::{\n     self, suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind,\n@@ -357,6 +358,15 @@ pub trait TypeErrCtxtExt<'tcx> {\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n+\n+    fn suggest_option_method_if_applicable(\n+        &self,\n+        failed_pred: ty::Predicate<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+    );\n+\n     fn note_function_argument_obligation(\n         &self,\n         body_id: LocalDefId,\n@@ -3660,15 +3670,92 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 err.replace_span_with(path.ident.span, true);\n             }\n         }\n-        if let Some(Node::Expr(hir::Expr {\n-            kind:\n-                hir::ExprKind::Call(hir::Expr { span, .. }, _)\n-                | hir::ExprKind::MethodCall(hir::PathSegment { ident: Ident { span, .. }, .. }, ..),\n-            ..\n-        })) = hir.find(call_hir_id)\n+\n+        if let Some(Node::Expr(expr)) = hir.find(call_hir_id) {\n+            if let hir::ExprKind::Call(hir::Expr { span, .. }, _)\n+            | hir::ExprKind::MethodCall(\n+                hir::PathSegment { ident: Ident { span, .. }, .. },\n+                ..,\n+            ) = expr.kind\n+            {\n+                if Some(*span) != err.span.primary_span() {\n+                    err.span_label(*span, \"required by a bound introduced by this call\");\n+                }\n+            }\n+\n+            if let hir::ExprKind::MethodCall(_, expr, ..) = expr.kind {\n+                self.suggest_option_method_if_applicable(failed_pred, param_env, err, expr);\n+            }\n+        }\n+    }\n+\n+    fn suggest_option_method_if_applicable(\n+        &self,\n+        failed_pred: ty::Predicate<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+    ) {\n+        let tcx = self.tcx;\n+        let infcx = self.infcx;\n+        let Some(typeck_results) = self.typeck_results.as_ref() else { return };\n+\n+        // Make sure we're dealing with the `Option` type.\n+        let Some(ty_adt_did) = typeck_results.expr_ty_adjusted(expr).ty_adt_id() else { return };\n+        if !tcx.is_diagnostic_item(sym::Option, ty_adt_did) {\n+            return;\n+        }\n+\n+        // Given the predicate `fn(&T): FnOnce<(U,)>`, extract `fn(&T)` and `(U,)`,\n+        // then suggest `Option::as_deref(_mut)` if `U` can deref to `T`\n+        if let ty::PredicateKind::Clause(ty::Clause::Trait(ty::TraitPredicate { trait_ref, .. }))\n+            = failed_pred.kind().skip_binder()\n+            && tcx.is_fn_trait(trait_ref.def_id)\n+            && let [self_ty, found_ty] = trait_ref.substs.as_slice()\n+            && let Some(fn_ty) = self_ty.as_type().filter(|ty| ty.is_fn())\n+            && let fn_sig @ ty::FnSig {\n+                abi: abi::Abi::Rust,\n+                c_variadic: false,\n+                unsafety: hir::Unsafety::Normal,\n+                ..\n+            } = fn_ty.fn_sig(tcx).skip_binder()\n+\n+            // Extract first param of fn sig with peeled refs, e.g. `fn(&T)` -> `T`\n+            && let Some(&ty::Ref(_, target_ty, needs_mut)) = fn_sig.inputs().first().map(|t| t.kind())\n+            && !target_ty.has_escaping_bound_vars()\n+\n+            // Extract first tuple element out of fn trait, e.g. `FnOnce<(U,)>` -> `U`\n+            && let Some(ty::Tuple(tys)) = found_ty.as_type().map(Ty::kind)\n+            && let &[found_ty] = tys.as_slice()\n+            && !found_ty.has_escaping_bound_vars()\n+\n+            // Extract `<U as Deref>::Target` assoc type and check that it is `T`\n+            && let Some(deref_target_did) = tcx.lang_items().deref_target()\n+            && let projection = tcx.mk_projection(deref_target_did, tcx.mk_substs(&[ty::GenericArg::from(found_ty)]))\n+            && let Ok(deref_target) = tcx.try_normalize_erasing_regions(param_env, projection)\n+            && deref_target == target_ty\n         {\n-            if Some(*span) != err.span.primary_span() {\n-                err.span_label(*span, \"required by a bound introduced by this call\");\n+            let help = if let hir::Mutability::Mut = needs_mut\n+                && let Some(deref_mut_did) = tcx.lang_items().deref_mut_trait()\n+                && infcx\n+                    .type_implements_trait(deref_mut_did, iter::once(found_ty), param_env)\n+                    .must_apply_modulo_regions()\n+            {\n+                Some((\"call `Option::as_deref_mut()` first\", \".as_deref_mut()\"))\n+            } else if let hir::Mutability::Not = needs_mut {\n+                Some((\"call `Option::as_deref()` first\", \".as_deref()\"))\n+            } else {\n+                None\n+            };\n+\n+            if let Some((msg, sugg)) = help {\n+                err.span_suggestion_with_style(\n+                    expr.span.shrink_to_hi(),\n+                    msg,\n+                    sugg,\n+                    Applicability::MaybeIncorrect,\n+                    SuggestionStyle::ShowAlways\n+                );\n             }\n         }\n     }"}, {"sha": "cc9ba5514fef129c1b75f24850d74131049d5080", "filename": "tests/ui/mismatched_types/suggest-option-asderef-unfixable.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6d2ba95d0099f1a656da44c7f868be0074e5b5e1/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d2ba95d0099f1a656da44c7f868be0074e5b5e1/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-unfixable.rs?ref=6d2ba95d0099f1a656da44c7f868be0074e5b5e1", "patch": "@@ -0,0 +1,40 @@\n+fn produces_string() -> Option<String> {\n+    Some(\"my cool string\".to_owned())\n+}\n+\n+fn takes_str_but_too_many_refs(_: &&str) -> Option<()> {\n+    Some(())\n+}\n+\n+fn no_args() -> Option<()> {\n+    Some(())\n+}\n+\n+fn generic_ref<T>(_: &T) -> Option<()> {\n+    Some(())\n+}\n+\n+extern \"C\" fn takes_str_but_wrong_abi(_: &str) -> Option<()> {\n+    Some(())\n+}\n+\n+unsafe fn takes_str_but_unsafe(_: &str) -> Option<()> {\n+    Some(())\n+}\n+\n+struct TypeWithoutDeref;\n+\n+fn main() {\n+    let _ = produces_string().and_then(takes_str_but_too_many_refs);\n+    //~^ ERROR type mismatch in function arguments\n+    let _ = produces_string().and_then(takes_str_but_wrong_abi);\n+    //~^ ERROR expected a `FnOnce<(String,)>` closure, found `for<'a> extern \"C\" fn(&'a str) -> Option<()> {takes_str_but_wrong_abi}`\n+    let _ = produces_string().and_then(takes_str_but_unsafe);\n+    //~^ ERROR expected a `FnOnce<(String,)>` closure, found `for<'a> unsafe fn(&'a str) -> Option<()> {takes_str_but_unsafe}`\n+    let _ = produces_string().and_then(no_args);\n+    //~^ ERROR function is expected to take 1 argument, but it takes 0 arguments\n+    let _ = produces_string().and_then(generic_ref);\n+    //~^ ERROR type mismatch in function arguments\n+    let _ = Some(TypeWithoutDeref).and_then(takes_str_but_too_many_refs);\n+    //~^ ERROR type mismatch in function arguments\n+}"}, {"sha": "079909eb48d1d188a1d20623885076793628ddca", "filename": "tests/ui/mismatched_types/suggest-option-asderef-unfixable.stderr", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/6d2ba95d0099f1a656da44c7f868be0074e5b5e1/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d2ba95d0099f1a656da44c7f868be0074e5b5e1/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef-unfixable.stderr?ref=6d2ba95d0099f1a656da44c7f868be0074e5b5e1", "patch": "@@ -0,0 +1,96 @@\n+error[E0631]: type mismatch in function arguments\n+  --> $DIR/suggest-option-asderef-unfixable.rs:28:40\n+   |\n+LL | fn takes_str_but_too_many_refs(_: &&str) -> Option<()> {\n+   | ------------------------------------------------------ found signature defined here\n+...\n+LL |     let _ = produces_string().and_then(takes_str_but_too_many_refs);\n+   |                               -------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected due to this\n+   |                               |\n+   |                               required by a bound introduced by this call\n+   |\n+   = note: expected function signature `fn(String) -> _`\n+              found function signature `for<'a, 'b> fn(&'a &'b str) -> _`\n+note: required by a bound in `Option::<T>::and_then`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+\n+error[E0277]: expected a `FnOnce<(String,)>` closure, found `for<'a> extern \"C\" fn(&'a str) -> Option<()> {takes_str_but_wrong_abi}`\n+  --> $DIR/suggest-option-asderef-unfixable.rs:30:40\n+   |\n+LL |     let _ = produces_string().and_then(takes_str_but_wrong_abi);\n+   |                               -------- ^^^^^^^^^^^^^^^^^^^^^^^ expected an `FnOnce<(String,)>` closure, found `for<'a> extern \"C\" fn(&'a str) -> Option<()> {takes_str_but_wrong_abi}`\n+   |                               |\n+   |                               required by a bound introduced by this call\n+   |\n+   = help: the trait `FnOnce<(String,)>` is not implemented for fn item `for<'a> extern \"C\" fn(&'a str) -> Option<()> {takes_str_but_wrong_abi}`\n+note: required by a bound in `Option::<T>::and_then`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+\n+error[E0277]: expected a `FnOnce<(String,)>` closure, found `for<'a> unsafe fn(&'a str) -> Option<()> {takes_str_but_unsafe}`\n+  --> $DIR/suggest-option-asderef-unfixable.rs:32:40\n+   |\n+LL |     let _ = produces_string().and_then(takes_str_but_unsafe);\n+   |                               -------- ^^^^^^^^^^^^^^^^^^^^ call the function in a closure: `|| unsafe { /* code */ }`\n+   |                               |\n+   |                               required by a bound introduced by this call\n+   |\n+   = help: the trait `FnOnce<(String,)>` is not implemented for fn item `for<'a> unsafe fn(&'a str) -> Option<()> {takes_str_but_unsafe}`\n+   = note: unsafe function cannot be called generically without an unsafe block\n+note: required by a bound in `Option::<T>::and_then`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+\n+error[E0593]: function is expected to take 1 argument, but it takes 0 arguments\n+  --> $DIR/suggest-option-asderef-unfixable.rs:34:40\n+   |\n+LL | fn no_args() -> Option<()> {\n+   | -------------------------- takes 0 arguments\n+...\n+LL |     let _ = produces_string().and_then(no_args);\n+   |                               -------- ^^^^^^^ expected function that takes 1 argument\n+   |                               |\n+   |                               required by a bound introduced by this call\n+   |\n+note: required by a bound in `Option::<T>::and_then`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+\n+error[E0631]: type mismatch in function arguments\n+  --> $DIR/suggest-option-asderef-unfixable.rs:36:40\n+   |\n+LL | fn generic_ref<T>(_: &T) -> Option<()> {\n+   | -------------------------------------- found signature defined here\n+...\n+LL |     let _ = produces_string().and_then(generic_ref);\n+   |                               -------- ^^^^^^^^^^^ expected due to this\n+   |                               |\n+   |                               required by a bound introduced by this call\n+   |\n+   = note: expected function signature `fn(String) -> _`\n+              found function signature `for<'a> fn(&'a _) -> _`\n+note: required by a bound in `Option::<T>::and_then`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+help: do not borrow the argument\n+   |\n+LL - fn generic_ref<T>(_: &T) -> Option<()> {\n+LL + fn generic_ref<T>(_: T) -> Option<()> {\n+   |\n+\n+error[E0631]: type mismatch in function arguments\n+  --> $DIR/suggest-option-asderef-unfixable.rs:38:45\n+   |\n+LL | fn takes_str_but_too_many_refs(_: &&str) -> Option<()> {\n+   | ------------------------------------------------------ found signature defined here\n+...\n+LL |     let _ = Some(TypeWithoutDeref).and_then(takes_str_but_too_many_refs);\n+   |                                    -------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected due to this\n+   |                                    |\n+   |                                    required by a bound introduced by this call\n+   |\n+   = note: expected function signature `fn(TypeWithoutDeref) -> _`\n+              found function signature `for<'a, 'b> fn(&'a &'b str) -> _`\n+note: required by a bound in `Option::<T>::and_then`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0277, E0593, E0631.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "08805999341ffbbd1aa77e393458d779de4fe904", "filename": "tests/ui/mismatched_types/suggest-option-asderef.fixed", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6d2ba95d0099f1a656da44c7f868be0074e5b5e1/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6d2ba95d0099f1a656da44c7f868be0074e5b5e1/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.fixed?ref=6d2ba95d0099f1a656da44c7f868be0074e5b5e1", "patch": "@@ -0,0 +1,30 @@\n+// run-rustfix\n+\n+fn produces_string() -> Option<String> {\n+    Some(\"my cool string\".to_owned())\n+}\n+\n+fn takes_str(_: &str) -> Option<()> {\n+    Some(())\n+}\n+\n+fn takes_str_mut(_: &mut str) -> Option<()> {\n+    Some(())\n+}\n+\n+fn generic<T>(_: T) -> Option<()> {\n+    Some(())\n+}\n+\n+fn main() {\n+    let _: Option<()> = produces_string().as_deref().and_then(takes_str);\n+    //~^ ERROR type mismatch in function arguments\n+    //~| HELP call `Option::as_deref()` first\n+    let _: Option<Option<()>> = produces_string().as_deref().map(takes_str);\n+    //~^ ERROR type mismatch in function arguments\n+    //~| HELP call `Option::as_deref()` first\n+    let _: Option<Option<()>> = produces_string().as_deref_mut().map(takes_str_mut);\n+    //~^ ERROR type mismatch in function arguments\n+    //~| HELP call `Option::as_deref_mut()` first\n+    let _ = produces_string().and_then(generic);\n+}"}, {"sha": "3cfb2ffa828c6687f4ab0cf5dd50e57299ebeeb1", "filename": "tests/ui/mismatched_types/suggest-option-asderef.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6d2ba95d0099f1a656da44c7f868be0074e5b5e1/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d2ba95d0099f1a656da44c7f868be0074e5b5e1/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.rs?ref=6d2ba95d0099f1a656da44c7f868be0074e5b5e1", "patch": "@@ -0,0 +1,30 @@\n+// run-rustfix\n+\n+fn produces_string() -> Option<String> {\n+    Some(\"my cool string\".to_owned())\n+}\n+\n+fn takes_str(_: &str) -> Option<()> {\n+    Some(())\n+}\n+\n+fn takes_str_mut(_: &mut str) -> Option<()> {\n+    Some(())\n+}\n+\n+fn generic<T>(_: T) -> Option<()> {\n+    Some(())\n+}\n+\n+fn main() {\n+    let _: Option<()> = produces_string().and_then(takes_str);\n+    //~^ ERROR type mismatch in function arguments\n+    //~| HELP call `Option::as_deref()` first\n+    let _: Option<Option<()>> = produces_string().map(takes_str);\n+    //~^ ERROR type mismatch in function arguments\n+    //~| HELP call `Option::as_deref()` first\n+    let _: Option<Option<()>> = produces_string().map(takes_str_mut);\n+    //~^ ERROR type mismatch in function arguments\n+    //~| HELP call `Option::as_deref_mut()` first\n+    let _ = produces_string().and_then(generic);\n+}"}, {"sha": "46da19d2bf4f2da1829561e9a74124c42253f9cc", "filename": "tests/ui/mismatched_types/suggest-option-asderef.stderr", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6d2ba95d0099f1a656da44c7f868be0074e5b5e1/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d2ba95d0099f1a656da44c7f868be0074e5b5e1/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fsuggest-option-asderef.stderr?ref=6d2ba95d0099f1a656da44c7f868be0074e5b5e1", "patch": "@@ -0,0 +1,63 @@\n+error[E0631]: type mismatch in function arguments\n+  --> $DIR/suggest-option-asderef.rs:20:52\n+   |\n+LL | fn takes_str(_: &str) -> Option<()> {\n+   | ----------------------------------- found signature defined here\n+...\n+LL |     let _: Option<()> = produces_string().and_then(takes_str);\n+   |                                           -------- ^^^^^^^^^ expected due to this\n+   |                                           |\n+   |                                           required by a bound introduced by this call\n+   |\n+   = note: expected function signature `fn(String) -> _`\n+              found function signature `for<'a> fn(&'a str) -> _`\n+note: required by a bound in `Option::<T>::and_then`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+help: call `Option::as_deref()` first\n+   |\n+LL |     let _: Option<()> = produces_string().as_deref().and_then(takes_str);\n+   |                                          +++++++++++\n+\n+error[E0631]: type mismatch in function arguments\n+  --> $DIR/suggest-option-asderef.rs:23:55\n+   |\n+LL | fn takes_str(_: &str) -> Option<()> {\n+   | ----------------------------------- found signature defined here\n+...\n+LL |     let _: Option<Option<()>> = produces_string().map(takes_str);\n+   |                                                   --- ^^^^^^^^^ expected due to this\n+   |                                                   |\n+   |                                                   required by a bound introduced by this call\n+   |\n+   = note: expected function signature `fn(String) -> _`\n+              found function signature `for<'a> fn(&'a str) -> _`\n+note: required by a bound in `Option::<T>::map`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+help: call `Option::as_deref()` first\n+   |\n+LL |     let _: Option<Option<()>> = produces_string().as_deref().map(takes_str);\n+   |                                                  +++++++++++\n+\n+error[E0631]: type mismatch in function arguments\n+  --> $DIR/suggest-option-asderef.rs:26:55\n+   |\n+LL | fn takes_str_mut(_: &mut str) -> Option<()> {\n+   | ------------------------------------------- found signature defined here\n+...\n+LL |     let _: Option<Option<()>> = produces_string().map(takes_str_mut);\n+   |                                                   --- ^^^^^^^^^^^^^ expected due to this\n+   |                                                   |\n+   |                                                   required by a bound introduced by this call\n+   |\n+   = note: expected function signature `fn(String) -> _`\n+              found function signature `for<'a> fn(&'a mut str) -> _`\n+note: required by a bound in `Option::<T>::map`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+help: call `Option::as_deref_mut()` first\n+   |\n+LL |     let _: Option<Option<()>> = produces_string().as_deref_mut().map(takes_str_mut);\n+   |                                                  +++++++++++++++\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0631`."}]}