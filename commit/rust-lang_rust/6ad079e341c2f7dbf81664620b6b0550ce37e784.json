{"sha": "6ad079e341c2f7dbf81664620b6b0550ce37e784", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZDA3OWUzNDFjMmY3ZGJmODE2NjQ2MjBiNmIwNTUwY2UzN2U3ODQ=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2015-10-08T23:26:21Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2015-10-09T23:15:36Z"}, "message": "Set proper alignment on constants\n\nFor enum variants, the default alignment for a specific variant might be\nlower than the alignment of the enum type itself. In such cases we, for\nexample, generate memcpy calls with an alignment that's higher than the\nalignment of the constant we copy from.\n\nTo avoid that, we need to explicitly set the required alignment on\nconstants.\n\nFixes #28912.", "tree": {"sha": "516881179d32e0eb84106a6a3f0e747f7e23a77b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/516881179d32e0eb84106a6a3f0e747f7e23a77b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ad079e341c2f7dbf81664620b6b0550ce37e784", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ad079e341c2f7dbf81664620b6b0550ce37e784", "html_url": "https://github.com/rust-lang/rust/commit/6ad079e341c2f7dbf81664620b6b0550ce37e784", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ad079e341c2f7dbf81664620b6b0550ce37e784/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ff4524e54cb4c396903fa8d0260dd27d9463c24", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ff4524e54cb4c396903fa8d0260dd27d9463c24", "html_url": "https://github.com/rust-lang/rust/commit/7ff4524e54cb4c396903fa8d0260dd27d9463c24"}], "stats": {"total": 112, "additions": 98, "deletions": 14}, "files": [{"sha": "09bf1beb22baf9a8d3cb3b355919749696b81236", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6ad079e341c2f7dbf81664620b6b0550ce37e784/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ad079e341c2f7dbf81664620b6b0550ce37e784/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=6ad079e341c2f7dbf81664620b6b0550ce37e784", "patch": "@@ -98,7 +98,7 @@ pub fn const_lit(cx: &CrateContext, e: &hir::Expr, lit: &ast::Lit)\n         ast::LitBool(b) => C_bool(cx, b),\n         ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n         ast::LitByteStr(ref data) => {\n-            addr_of(cx, C_bytes(cx, &data[..]), \"byte_str\")\n+            addr_of(cx, C_bytes(cx, &data[..]), 1, \"byte_str\")\n         }\n     }\n }\n@@ -111,6 +111,7 @@ pub fn ptrcast(val: ValueRef, ty: Type) -> ValueRef {\n \n fn addr_of_mut(ccx: &CrateContext,\n                cv: ValueRef,\n+               align: machine::llalign,\n                kind: &str)\n                -> ValueRef {\n     unsafe {\n@@ -122,6 +123,7 @@ fn addr_of_mut(ccx: &CrateContext,\n             ccx.sess().bug(&format!(\"symbol `{}` is already defined\", name));\n         });\n         llvm::LLVMSetInitializer(gv, cv);\n+        llvm::LLVMSetAlignment(gv, align);\n         SetLinkage(gv, InternalLinkage);\n         SetUnnamedAddr(gv, true);\n         gv\n@@ -130,13 +132,23 @@ fn addr_of_mut(ccx: &CrateContext,\n \n pub fn addr_of(ccx: &CrateContext,\n                cv: ValueRef,\n+               align: machine::llalign,\n                kind: &str)\n                -> ValueRef {\n     match ccx.const_globals().borrow().get(&cv) {\n-        Some(&gv) => return gv,\n+        Some(&gv) => {\n+            unsafe {\n+                // Upgrade the alignment in cases where the same constant is used with different\n+                // alignment requirements\n+                if align > llvm::LLVMGetAlignment(gv) {\n+                    llvm::LLVMSetAlignment(gv, align);\n+                }\n+            }\n+            return gv;\n+        }\n         None => {}\n     }\n-    let gv = addr_of_mut(ccx, cv, kind);\n+    let gv = addr_of_mut(ccx, cv, align, kind);\n     unsafe {\n         llvm::LLVMSetGlobalConstant(gv, True);\n     }\n@@ -254,11 +266,11 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         Some(&val) => return val,\n         None => {}\n     }\n+    let ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs,\n+                                              &ccx.tcx().expr_ty(expr));\n     let val = if qualif.intersects(check_const::ConstQualif::NON_STATIC_BORROWS) {\n         // Avoid autorefs as they would create global instead of stack\n         // references, even when only the latter are correct.\n-        let ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs,\n-                                                  &ccx.tcx().expr_ty(expr));\n         const_expr_unadjusted(ccx, expr, ty, param_substs, None)\n     } else {\n         const_expr(ccx, expr, param_substs, None).0\n@@ -274,7 +286,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     };\n \n-    let lvalue = addr_of(ccx, val, \"const\");\n+    let lvalue = addr_of(ccx, val, type_of::align_of(ccx, ty), \"const\");\n     ccx.const_values().borrow_mut().insert(key, lvalue);\n     lvalue\n }\n@@ -314,7 +326,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 if adj.autoderefs == 0 {\n                     // Don't copy data to do a deref+ref\n                     // (i.e., skip the last auto-deref).\n-                    llconst = addr_of(cx, llconst, \"autoref\");\n+                    llconst = addr_of(cx, llconst, type_of::align_of(cx, ty), \"autoref\");\n                     ty = cx.tcx().mk_imm_ref(cx.tcx().mk_region(ty::ReStatic), ty);\n                 }\n             } else {\n@@ -720,13 +732,13 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             } else {\n                 // If this isn't the address of a static, then keep going through\n                 // normal constant evaluation.\n-                let (v, _) = const_expr(cx, &**sub, param_substs, fn_args);\n-                addr_of(cx, v, \"ref\")\n+                let (v, ty) = const_expr(cx, &**sub, param_substs, fn_args);\n+                addr_of(cx, v, type_of::align_of(cx, ty), \"ref\")\n             }\n         },\n         hir::ExprAddrOf(hir::MutMutable, ref sub) => {\n-            let (v, _) = const_expr(cx, &**sub, param_substs, fn_args);\n-            addr_of_mut(cx, v, \"ref_mut_slice\")\n+            let (v, ty) = const_expr(cx, &**sub, param_substs, fn_args);\n+            addr_of_mut(cx, v, type_of::align_of(cx, ty), \"ref_mut_slice\")\n         },\n         hir::ExprTup(ref es) => {\n             let repr = adt::represent_type(cx, ety);\n@@ -934,6 +946,7 @@ pub fn trans_static(ccx: &CrateContext,\n             ccx.statics_to_rauw().borrow_mut().push((g, new_g));\n             new_g\n         };\n+        llvm::LLVMSetAlignment(g, type_of::align_of(ccx, ty));\n         llvm::LLVMSetInitializer(g, v);\n \n         // As an optimization, all shared statics which do not have interior"}, {"sha": "5f83abc065fed327adde9fb7a980c54efa235c28", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6ad079e341c2f7dbf81664620b6b0550ce37e784/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ad079e341c2f7dbf81664620b6b0550ce37e784/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=6ad079e341c2f7dbf81664620b6b0550ce37e784", "patch": "@@ -22,6 +22,7 @@ use trans::consts;\n use trans::debuginfo;\n use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::expr;\n+use trans::machine;\n use trans;\n use middle::ty;\n \n@@ -401,7 +402,8 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let filename = C_str_slice(ccx, filename);\n     let line = C_u32(ccx, loc.line as u32);\n     let expr_file_line_const = C_struct(ccx, &[v_str, filename, line], false);\n-    let expr_file_line = consts::addr_of(ccx, expr_file_line_const, \"panic_loc\");\n+    let align = machine::llalign_of_min(ccx, val_ty(expr_file_line_const));\n+    let expr_file_line = consts::addr_of(ccx, expr_file_line_const, align, \"panic_loc\");\n     let args = vec!(expr_file_line);\n     let did = langcall(bcx, Some(call_info.span), \"\", PanicFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n@@ -433,7 +435,8 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let filename = C_str_slice(ccx,  filename);\n     let line = C_u32(ccx, loc.line as u32);\n     let file_line_const = C_struct(ccx, &[filename, line], false);\n-    let file_line = consts::addr_of(ccx, file_line_const, \"panic_bounds_check_loc\");\n+    let align = machine::llalign_of_min(ccx, val_ty(file_line_const));\n+    let file_line = consts::addr_of(ccx, file_line_const, align, \"panic_bounds_check_loc\");\n     let args = vec!(file_line, index, len);\n     let did = langcall(bcx, Some(call_info.span), \"\", PanicBoundsCheckFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,"}, {"sha": "9a119d0a0e4a3e9c0d391c07c26a574eb3dd118d", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ad079e341c2f7dbf81664620b6b0550ce37e784/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ad079e341c2f7dbf81664620b6b0550ce37e784/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=6ad079e341c2f7dbf81664620b6b0550ce37e784", "patch": "@@ -651,7 +651,9 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         C_uint(ccx, align)\n     ].into_iter().chain(methods).collect();\n \n-    let vtable = consts::addr_of(ccx, C_struct(ccx, &components, false), \"vtable\");\n+    let vtable_const = C_struct(ccx, &components, false);\n+    let align = machine::llalign_of_pref(ccx, val_ty(vtable_const));\n+    let vtable = consts::addr_of(ccx, vtable_const, align, \"vtable\");\n \n     ccx.vtables().borrow_mut().insert(trait_ref, vtable);\n     vtable"}, {"sha": "6b4e626df924bf020be2e9d5d6e8ebb201bfc765", "filename": "src/test/codegen/consts.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6ad079e341c2f7dbf81664620b6b0550ce37e784/src%2Ftest%2Fcodegen%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ad079e341c2f7dbf81664620b6b0550ce37e784/src%2Ftest%2Fcodegen%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fconsts.rs?ref=6ad079e341c2f7dbf81664620b6b0550ce37e784", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+// Below, these constants are defined as enum variants that by itself would\n+// have a lower alignment than the enum type. Ensure that we mark them\n+// correctly with the higher alignment of the enum.\n+\n+// CHECK: @STATIC = {{.*}}, align 4\n+\n+// This checks the constants from inline_enum_const\n+// CHECK: @const{{[0-9]+}} = {{.*}}, align 2\n+\n+// This checks the constants from {low,high}_align_const, they share the same\n+// constant, but the alignment differs, so the higher one should be used\n+// CHECK: @const{{[0-9]+}} = {{.*}}, align 4\n+\n+#[derive(Copy, Clone)]\n+\n+// repr(i16) is required for the {low,high}_align_const test\n+#[repr(i16)]\n+pub enum E<A, B> {\n+    A(A),\n+    B(B),\n+}\n+\n+#[no_mangle]\n+pub static STATIC: E<i16, i32> = E::A(0);\n+\n+// CHECK-LABEL: @static_enum_const\n+#[no_mangle]\n+pub fn static_enum_const() -> E<i16, i32> {\n+   STATIC\n+}\n+\n+// CHECK-LABEL: @inline_enum_const\n+#[no_mangle]\n+pub fn inline_enum_const() -> E<i8, i16> {\n+    E::A(0)\n+}\n+\n+// CHECK-LABEL: @low_align_const\n+#[no_mangle]\n+pub fn low_align_const() -> E<i16, [i16; 3]> {\n+// Check that low_align_const and high_align_const use the same constant\n+// CHECK: call void @llvm.memcpy.{{.*}}(i8* %{{[0-9]+}}, i8* {{.*}} [[LOW_HIGH:@const[0-9]+]]\n+    E::A(0)\n+}\n+\n+// CHECK-LABEL: @high_align_const\n+#[no_mangle]\n+pub fn high_align_const() -> E<i16, i32> {\n+// Check that low_align_const and high_align_const use the same constant\n+// CHECK: call void @llvm.memcpy.{{.*}}(i8* %{{[0-9]}}, i8* {{.*}} [[LOW_HIGH]]\n+    E::A(0)\n+}"}]}