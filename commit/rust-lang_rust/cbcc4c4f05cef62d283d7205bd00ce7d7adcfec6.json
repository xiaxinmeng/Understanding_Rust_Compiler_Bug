{"sha": "cbcc4c4f05cef62d283d7205bd00ce7d7adcfec6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiY2M0YzRmMDVjZWY2MmQyODNkNzIwNWJkMDBjZTdkN2FkY2ZlYzY=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-29T18:21:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-29T18:21:11Z"}, "message": "Rollup merge of #72310 - jyn514:peekable-next-if, r=dtolnay\n\nAdd Peekable::next_if\n\nPrior art:\n\n`rust_analyzer` uses [`Parser::eat`](https://github.com/rust-analyzer/rust-analyzer/blob/50f4ae798b7c54d417ee88455b87fd0477473150/crates/ra_parser/src/parser.rs#L94), which is `next_if` specialized to `|y| self.next_if(|x| x == y)`.\n\nBasically every other parser I've run into in Rust has an equivalent of `Parser::eat`; see for example\n\n- [cranelift](https://github.com/bytecodealliance/wasmtime/blob/94190d57244b26baf36629c88104b0ba516510cf/cranelift/reader/src/parser.rs#L498)\n- [rcc](https://github.com/jyn514/rcc/blob/a8159c3904a0c950fbba817bf9109023fad69033/src/parse/mod.rs#L231)\n- [crunch](https://github.com/Kixiron/crunch-lang/blob/8521874fab8a7d62bfa7dea8bd1da94b63e31be8/crates/crunch-parser/src/parser/mod.rs#L213-L241)\n\nPossible extensions: A specialization of `next_if` to using `Eq::eq`. The only difficulty here is the naming - maybe `next_if_eq`?\n\nAlternatives:\n- Instead of `func: impl FnOnce(&I::Item) -> bool`, use `func: impl FnOnce(I::Item) -> Option<I::Item>`. This has the advantage that `func` can move the value if necessary, but means that there is no guarantee `func` will return the same value it was given.\n- Instead of `fn next_if(...) -> Option<I::Item>`, use `fn next_if(...) -> bool`. This makes the common case of `iter.next_if(f).is_some()` easier, but makes the unusual case impossible.\n\nBikeshedding on naming:\n- `next_if` could be renamed to `consume_if` (to match `eat`, but a little more formally)\n- `next_if_eq` could be renamed to `consume`. This is more concise but less self-explanatory if you haven't written a lot of parsers.\n- Both of the above, but with `consume` replaced by `eat`.", "tree": {"sha": "b1c51c39322fe56b97e3151b9ecd0502d8cf5b68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1c51c39322fe56b97e3151b9ecd0502d8cf5b68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbcc4c4f05cef62d283d7205bd00ce7d7adcfec6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe0VKXCRBK7hj4Ov3rIwAAdHIIAFuONGFReho7fhB0mJOphXS3\nP5MF3BumdgvGnpISPX/R1l516DqF9LjhKJW7K4yFsGdTIdenrbyvlKwiMJGsvwAX\nRI+na3xfEumfZ6qRONgwn8KXmzlUcs5jzZ0Ox5tmgMnwWp8h4FIMYrGU4o9udve3\nhQbdOKKGR9iwutJXuCe/MK6Qv2JYjKEtmVX8LSfmW6J/FJzFOYo9GGZ74duWjb6l\n0r1x0PJ6vRXNcPdbhzLiOROXnaRk+sUmufC1MW2XVfsJ1Lc6ajazJtNQAGik4byg\n/b558awA+Qf9f9ifD7utztJMf29/5MQXNb6WHL7r3xuaQDU43G6zgQeLElxjNwg=\n=w/Ve\n-----END PGP SIGNATURE-----\n", "payload": "tree b1c51c39322fe56b97e3151b9ecd0502d8cf5b68\nparent 96dd4690c3aa70ec312448c3f2d50e6dc6fb87df\nparent 822ad87325d6436a6aea5ae61ca34d9ad45dd839\nauthor Dylan DPC <dylan.dpc@gmail.com> 1590776471 +0200\ncommitter GitHub <noreply@github.com> 1590776471 +0200\n\nRollup merge of #72310 - jyn514:peekable-next-if, r=dtolnay\n\nAdd Peekable::next_if\n\nPrior art:\n\n`rust_analyzer` uses [`Parser::eat`](https://github.com/rust-analyzer/rust-analyzer/blob/50f4ae798b7c54d417ee88455b87fd0477473150/crates/ra_parser/src/parser.rs#L94), which is `next_if` specialized to `|y| self.next_if(|x| x == y)`.\n\nBasically every other parser I've run into in Rust has an equivalent of `Parser::eat`; see for example\n\n- [cranelift](https://github.com/bytecodealliance/wasmtime/blob/94190d57244b26baf36629c88104b0ba516510cf/cranelift/reader/src/parser.rs#L498)\n- [rcc](https://github.com/jyn514/rcc/blob/a8159c3904a0c950fbba817bf9109023fad69033/src/parse/mod.rs#L231)\n- [crunch](https://github.com/Kixiron/crunch-lang/blob/8521874fab8a7d62bfa7dea8bd1da94b63e31be8/crates/crunch-parser/src/parser/mod.rs#L213-L241)\n\nPossible extensions: A specialization of `next_if` to using `Eq::eq`. The only difficulty here is the naming - maybe `next_if_eq`?\n\nAlternatives:\n- Instead of `func: impl FnOnce(&I::Item) -> bool`, use `func: impl FnOnce(I::Item) -> Option<I::Item>`. This has the advantage that `func` can move the value if necessary, but means that there is no guarantee `func` will return the same value it was given.\n- Instead of `fn next_if(...) -> Option<I::Item>`, use `fn next_if(...) -> bool`. This makes the common case of `iter.next_if(f).is_some()` easier, but makes the unusual case impossible.\n\nBikeshedding on naming:\n- `next_if` could be renamed to `consume_if` (to match `eat`, but a little more formally)\n- `next_if_eq` could be renamed to `consume`. This is more concise but less self-explanatory if you haven't written a lot of parsers.\n- Both of the above, but with `consume` replaced by `eat`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbcc4c4f05cef62d283d7205bd00ce7d7adcfec6", "html_url": "https://github.com/rust-lang/rust/commit/cbcc4c4f05cef62d283d7205bd00ce7d7adcfec6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbcc4c4f05cef62d283d7205bd00ce7d7adcfec6/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96dd4690c3aa70ec312448c3f2d50e6dc6fb87df", "url": "https://api.github.com/repos/rust-lang/rust/commits/96dd4690c3aa70ec312448c3f2d50e6dc6fb87df", "html_url": "https://github.com/rust-lang/rust/commit/96dd4690c3aa70ec312448c3f2d50e6dc6fb87df"}, {"sha": "822ad87325d6436a6aea5ae61ca34d9ad45dd839", "url": "https://api.github.com/repos/rust-lang/rust/commits/822ad87325d6436a6aea5ae61ca34d9ad45dd839", "html_url": "https://github.com/rust-lang/rust/commit/822ad87325d6436a6aea5ae61ca34d9ad45dd839"}], "stats": {"total": 88, "additions": 88, "deletions": 0}, "files": [{"sha": "00529f0e2d54f4dcc0ac8ad3ea1c30bfab8efe42", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/cbcc4c4f05cef62d283d7205bd00ce7d7adcfec6/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcc4c4f05cef62d283d7205bd00ce7d7adcfec6/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=cbcc4c4f05cef62d283d7205bd00ce7d7adcfec6", "patch": "@@ -1619,6 +1619,69 @@ impl<I: Iterator> Peekable<I> {\n         let iter = &mut self.iter;\n         self.peeked.get_or_insert_with(|| iter.next()).as_ref()\n     }\n+\n+    /// Consume the next value of this iterator if a condition is true.\n+    ///\n+    /// If `func` returns `true` for the next value of this iterator, consume and return it.\n+    /// Otherwise, return `None`.\n+    ///\n+    /// # Examples\n+    /// Consume a number if it's equal to 0.\n+    /// ```\n+    /// #![feature(peekable_next_if)]\n+    /// let mut iter = (0..5).peekable();\n+    /// // The first item of the iterator is 0; consume it.\n+    /// assert_eq!(iter.next_if(|&x| x == 0), Some(0));\n+    /// // The next item returned is now 1, so `consume` will return `false`.\n+    /// assert_eq!(iter.next_if(|&x| x == 0), None);\n+    /// // `next_if` saves the value of the next item if it was not equal to `expected`.\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// ```\n+    ///\n+    /// Consume any number less than 10.\n+    /// ```\n+    /// #![feature(peekable_next_if)]\n+    /// let mut iter = (1..20).peekable();\n+    /// // Consume all numbers less than 10\n+    /// while iter.next_if(|&x| x < 10).is_some() {}\n+    /// // The next value returned will be 10\n+    /// assert_eq!(iter.next(), Some(10));\n+    /// ```\n+    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n+    pub fn next_if(&mut self, func: impl FnOnce(&I::Item) -> bool) -> Option<I::Item> {\n+        match self.next() {\n+            Some(matched) if func(&matched) => Some(matched),\n+            other => {\n+                // Since we called `self.next()`, we consumed `self.peeked`.\n+                assert!(self.peeked.is_none());\n+                self.peeked = Some(other);\n+                None\n+            }\n+        }\n+    }\n+\n+    /// Consume the next item if it is equal to `expected`.\n+    ///\n+    /// # Example\n+    /// Consume a number if it's equal to 0.\n+    /// ```\n+    /// #![feature(peekable_next_if)]\n+    /// let mut iter = (0..5).peekable();\n+    /// // The first item of the iterator is 0; consume it.\n+    /// assert_eq!(iter.next_if_eq(&0), Some(0));\n+    /// // The next item returned is now 1, so `consume` will return `false`.\n+    /// assert_eq!(iter.next_if_eq(&0), None);\n+    /// // `next_if_eq` saves the value of the next item if it was not equal to `expected`.\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// ```\n+    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n+    pub fn next_if_eq<R>(&mut self, expected: &R) -> Option<I::Item>\n+    where\n+        R: ?Sized,\n+        I::Item: PartialEq<R>,\n+    {\n+        self.next_if(|next| next == expected)\n+    }\n }\n \n /// An iterator that rejects elements while `predicate` returns `true`."}, {"sha": "0265235a65a35562a5b462982668cf604d4f5c96", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cbcc4c4f05cef62d283d7205bd00ce7d7adcfec6/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcc4c4f05cef62d283d7205bd00ce7d7adcfec6/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=cbcc4c4f05cef62d283d7205bd00ce7d7adcfec6", "patch": "@@ -813,6 +813,30 @@ fn test_iterator_peekable_rfold() {\n     assert_eq!(i, xs.len());\n }\n \n+#[test]\n+fn test_iterator_peekable_next_if_eq() {\n+    // first, try on references\n+    let xs = vec![\"Heart\", \"of\", \"Gold\"];\n+    let mut it = xs.into_iter().peekable();\n+    // try before `peek()`\n+    assert_eq!(it.next_if_eq(&\"trillian\"), None);\n+    assert_eq!(it.next_if_eq(&\"Heart\"), Some(\"Heart\"));\n+    // try after peek()\n+    assert_eq!(it.peek(), Some(&\"of\"));\n+    assert_eq!(it.next_if_eq(&\"of\"), Some(\"of\"));\n+    assert_eq!(it.next_if_eq(&\"zaphod\"), None);\n+    // make sure `next()` still behaves\n+    assert_eq!(it.next(), Some(\"Gold\"));\n+\n+    // make sure comparison works for owned values\n+    let xs = vec![String::from(\"Ludicrous\"), \"speed\".into()];\n+    let mut it = xs.into_iter().peekable();\n+    // make sure basic functionality works\n+    assert_eq!(it.next_if_eq(\"Ludicrous\"), Some(\"Ludicrous\".into()));\n+    assert_eq!(it.next_if_eq(\"speed\"), Some(\"speed\".into()));\n+    assert_eq!(it.next_if_eq(\"\"), None);\n+}\n+\n /// This is an iterator that follows the Iterator contract,\n /// but it is not fused. After having returned None once, it will start\n /// producing elements if .next() is called again."}, {"sha": "37ebf4112808e77ecfeb193acb91e3887ea5e28a", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbcc4c4f05cef62d283d7205bd00ce7d7adcfec6/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcc4c4f05cef62d283d7205bd00ce7d7adcfec6/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=cbcc4c4f05cef62d283d7205bd00ce7d7adcfec6", "patch": "@@ -43,6 +43,7 @@\n #![feature(leading_trailing_ones)]\n #![feature(const_forget)]\n #![feature(option_unwrap_none)]\n+#![feature(peekable_next_if)]\n \n extern crate test;\n "}]}