{"sha": "4142792d1fd21a512d1dd37d5822ac2ba470c547", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxNDI3OTJkMWZkMjFhNTEyZDFkZDM3ZDU4MjJhYzJiYTQ3MGM1NDc=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-29T19:27:13Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-29T19:27:13Z"}, "message": "Add more docs in ty.rs\n\nAlso get rid of the indirection through query_definitions for the type-related\nqueries.", "tree": {"sha": "d624a2b4ad749517f7946f28ad1d2874867e2032", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d624a2b4ad749517f7946f28ad1d2874867e2032"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4142792d1fd21a512d1dd37d5822ac2ba470c547", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4142792d1fd21a512d1dd37d5822ac2ba470c547", "html_url": "https://github.com/rust-lang/rust/commit/4142792d1fd21a512d1dd37d5822ac2ba470c547", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4142792d1fd21a512d1dd37d5822ac2ba470c547/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a3d6aa26a1c71dadc91f37f9d5f8662b51c138a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a3d6aa26a1c71dadc91f37f9d5f8662b51c138a", "html_url": "https://github.com/rust-lang/rust/commit/4a3d6aa26a1c71dadc91f37f9d5f8662b51c138a"}], "stats": {"total": 97, "additions": 61, "deletions": 36}, "files": [{"sha": "5a8ca3b47ae7f752103ac288cc7c4af88db3dd59", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4142792d1fd21a512d1dd37d5822ac2ba470c547/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4142792d1fd21a512d1dd37d5822ac2ba470c547/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=4142792d1fd21a512d1dd37d5822ac2ba470c547", "patch": "@@ -36,17 +36,17 @@ pub trait HirDatabase: SyntaxDatabase\n \n     fn infer(def_id: DefId) -> Cancelable<Arc<InferenceResult>> {\n         type InferQuery;\n-        use fn query_definitions::infer;\n+        use fn crate::ty::infer;\n     }\n \n     fn type_for_def(def_id: DefId) -> Cancelable<Ty> {\n         type TypeForDefQuery;\n-        use fn query_definitions::type_for_def;\n+        use fn crate::ty::type_for_def;\n     }\n \n     fn type_for_field(def_id: DefId, field: Name) -> Cancelable<Ty> {\n         type TypeForFieldQuery;\n-        use fn query_definitions::type_for_field;\n+        use fn crate::ty::type_for_field;\n     }\n \n     fn file_items(file_id: FileId) -> Arc<SourceFileItems> {"}, {"sha": "721bd4195a37366ddc4403f9e851b79f9fcb505b", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4142792d1fd21a512d1dd37d5822ac2ba470c547/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4142792d1fd21a512d1dd37d5822ac2ba470c547/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=4142792d1fd21a512d1dd37d5822ac2ba470c547", "patch": "@@ -19,7 +19,6 @@ use crate::{\n         imp::Submodule,\n         nameres::{InputModuleItems, ItemMap, Resolver},\n     },\n-    ty::{self, InferenceResult, Ty},\n     adt::{StructData, EnumData},\n };\n \n@@ -30,19 +29,6 @@ pub(super) fn fn_scopes(db: &impl HirDatabase, def_id: DefId) -> Arc<FnScopes> {\n     Arc::new(res)\n }\n \n-pub(super) fn infer(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<InferenceResult>> {\n-    let function = Function::new(def_id);\n-    ty::infer(db, function).map(Arc::new)\n-}\n-\n-pub(super) fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Ty> {\n-    ty::type_for_def(db, def_id)\n-}\n-\n-pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name) -> Cancelable<Ty> {\n-    ty::type_for_field(db, def_id, field)\n-}\n-\n pub(super) fn struct_data(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<StructData>> {\n     let def_loc = def_id.loc(db);\n     assert!(def_loc.kind == DefKind::Struct);"}, {"sha": "719b3f7cd70035230745bbd04a866566bea996a8", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 58, "deletions": 19, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/4142792d1fd21a512d1dd37d5822ac2ba470c547/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4142792d1fd21a512d1dd37d5822ac2ba470c547/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=4142792d1fd21a512d1dd37d5822ac2ba470c547", "patch": "@@ -1,3 +1,18 @@\n+//! The type system. We currently use this to infer types for completion.\n+//!\n+//! For type inference, compare the implementations in rustc (the various\n+//! check_* methods in librustc_typeck/check/mod.rs are a good entry point) and\n+//! IntelliJ-Rust (org.rust.lang.core.types.infer). Our entry point for\n+//! inference here is the `infer` function, which infers the types of all\n+//! expressions in a given function.\n+//!\n+//! The central struct here is `Ty`, which represents a type. During inference,\n+//! it can contain type 'variables' which represent currently unknown types; as\n+//! we walk through the expressions, we might determine that certain variables\n+//! need to be equal to each other, or to certain types. To record this, we use\n+//! the union-find implementation from the `ena` crate, which is extracted from\n+//! rustc.\n+\n mod primitive;\n #[cfg(test)]\n mod tests;\n@@ -21,6 +36,7 @@ use crate::{\n     type_ref::{TypeRef, Mutability},\n };\n \n+/// The ID of a type variable.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct TypeVarId(u32);\n \n@@ -40,14 +56,16 @@ impl UnifyKey for TypeVarId {\n     }\n }\n \n+/// The value of a type variable: either we already know the type, or we don't\n+/// know it yet.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub enum TypeVarValue {\n     Known(Ty),\n     Unknown,\n }\n \n impl TypeVarValue {\n-    pub fn known(&self) -> Option<&Ty> {\n+    fn known(&self) -> Option<&Ty> {\n         match self {\n             TypeVarValue::Known(ty) => Some(ty),\n             TypeVarValue::Unknown => None,\n@@ -75,10 +93,13 @@ impl UnifyValue for TypeVarValue {\n     }\n }\n \n+/// The kinds of placeholders we need during type inference. Currently, we only\n+/// have type variables; in the future, we will probably also need int and float\n+/// variables, for inference of literal values (e.g. `100` could be one of\n+/// several integer types).\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum InferTy {\n     TypeVar(TypeVarId),\n-    // later we'll have IntVar and FloatVar as well\n }\n \n /// When inferring an expression, we propagate downward whatever type hint we\n@@ -92,15 +113,21 @@ struct Expectation {\n }\n \n impl Expectation {\n+    /// The expectation that the type of the expression needs to equal the given\n+    /// type.\n     fn has_type(ty: Ty) -> Self {\n         Expectation { ty }\n     }\n \n+    /// This expresses no expectation on the type.\n     fn none() -> Self {\n         Expectation { ty: Ty::Unknown }\n     }\n }\n \n+/// A type. This is based on the `TyKind` enum in rustc (librustc/ty/sty.rs).\n+///\n+/// This should be cheap to clone.\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Ty {\n     /// The primitive boolean type. Written as `bool`.\n@@ -134,14 +161,14 @@ pub enum Ty {\n     // An array with the given length. Written as `[T; n]`.\n     // Array(Ty, ty::Const),\n     /// The pointee of an array slice.  Written as `[T]`.\n-    Slice(TyRef),\n+    Slice(Arc<Ty>),\n \n     /// A raw pointer. Written as `*mut T` or `*const T`\n-    RawPtr(TyRef, Mutability),\n+    RawPtr(Arc<Ty>, Mutability),\n \n     /// A reference; a pointer with an associated lifetime. Written as\n     /// `&'a mut T` or `&'a T`.\n-    Ref(TyRef, Mutability),\n+    Ref(Arc<Ty>, Mutability),\n \n     /// A pointer to a function.  Written as `fn() -> i32`.\n     ///\n@@ -153,6 +180,10 @@ pub enum Ty {\n     /// ```\n     FnPtr(Arc<FnSig>),\n \n+    // rustc has a separate type for each function, which just coerces to the\n+    // above function pointer type. Once we implement generics, we will probably\n+    // need this as well.\n+\n     // A trait, defined with `dyn trait`.\n     // Dynamic(),\n     // The anonymous type of a closure. Used to represent the type of\n@@ -166,7 +197,7 @@ pub enum Ty {\n     // A type representin the types stored inside a generator.\n     // This should only appear in GeneratorInteriors.\n     // GeneratorWitness(Binder<&'tcx List<Ty<'tcx>>>),\n-    /// The never type `!`\n+    /// The never type `!`.\n     Never,\n \n     /// A tuple type.  For example, `(i32, bool)`.\n@@ -177,10 +208,6 @@ pub enum Ty {\n     // Projection(ProjectionTy),\n \n     // Opaque (`impl Trait`) type found in a return type.\n-    // The `DefId` comes either from\n-    // * the `impl Trait` ast::Ty node,\n-    // * or the `existential type` declaration\n-    // The substitutions are for the generics of the function in question.\n     // Opaque(DefId, Substs),\n \n     // A type parameter; for example, `T` in `fn f<T>(x: T) {}\n@@ -192,12 +219,12 @@ pub enum Ty {\n     /// A placeholder for a type which could not be computed; this is propagated\n     /// to avoid useless error messages. Doubles as a placeholder where type\n     /// variables are inserted before type checking, since we want to try to\n-    /// infer a better type here anyway.\n+    /// infer a better type here anyway -- for the IDE use case, we want to try\n+    /// to infer as much as possible even in the presence of type errors.\n     Unknown,\n }\n \n-type TyRef = Arc<Ty>;\n-\n+/// A function signature.\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct FnSig {\n     input: Vec<Ty>,\n@@ -368,7 +395,11 @@ impl fmt::Display for Ty {\n     }\n }\n \n-pub fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n+// Functions returning declared types for items\n+\n+/// Compute the declared type of a function. This should not need to look at the\n+/// function body (but currently uses the function AST, so does anyway - TODO).\n+fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n     let syntax = f.syntax(db);\n     let module = f.module(db)?;\n     let node = syntax.borrowed();\n@@ -390,7 +421,7 @@ pub fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n     Ok(Ty::FnPtr(Arc::new(sig)))\n }\n \n-pub fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Cancelable<Ty> {\n+fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Cancelable<Ty> {\n     Ok(Ty::Adt {\n         def_id: s.def_id(),\n         name: s.name(db)?.unwrap_or_else(Name::missing),\n@@ -404,7 +435,7 @@ pub fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Cancelable<Ty> {\n     })\n }\n \n-pub fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Ty> {\n+pub(super) fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Ty> {\n     let def = def_id.resolve(db)?;\n     match def {\n         Def::Module(..) => {\n@@ -444,19 +475,25 @@ pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name)\n     Ty::from_hir(db, &module, &type_ref)\n }\n \n+/// The result of type inference: A mapping from expressions and patterns to types.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct InferenceResult {\n     type_of: FxHashMap<LocalSyntaxPtr, Ty>,\n }\n \n impl InferenceResult {\n+    /// Returns the type of the given syntax node, if it was inferred. Will\n+    /// return `None` for syntax nodes not in the inferred function or not\n+    /// pointing to an expression/pattern, `Some(Ty::Unknown)` for\n+    /// expressions/patterns that could not be inferred.\n     pub fn type_of_node(&self, node: SyntaxNodeRef) -> Option<Ty> {\n         self.type_of.get(&LocalSyntaxPtr::new(node)).cloned()\n     }\n }\n \n+/// The inference context contains all information needed during type inference.\n #[derive(Clone, Debug)]\n-pub struct InferenceContext<'a, D: HirDatabase> {\n+struct InferenceContext<'a, D: HirDatabase> {\n     db: &'a D,\n     scopes: Arc<FnScopes>,\n     module: Module,\n@@ -738,6 +775,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             ast::Expr::ParenExpr(e) => self.infer_expr_opt(e.expr(), expected)?,\n             ast::Expr::Label(_e) => Ty::Unknown,\n             ast::Expr::ReturnExpr(e) => {\n+                // TODO expect return type of function\n                 self.infer_expr_opt(e.expr(), &Expectation::none())?;\n                 Ty::Never\n             }\n@@ -870,7 +908,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n }\n \n-pub fn infer(db: &impl HirDatabase, function: Function) -> Cancelable<InferenceResult> {\n+pub fn infer(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<InferenceResult>> {\n+    let function = Function::new(def_id); // TODO: consts also need inference\n     let scopes = function.scopes(db);\n     let module = function.module(db)?;\n     let mut ctx = InferenceContext::new(db, scopes, module);\n@@ -909,5 +948,5 @@ pub fn infer(db: &impl HirDatabase, function: Function) -> Cancelable<InferenceR\n         ctx.infer_block(block, &Expectation::has_type(ret_ty))?;\n     }\n \n-    Ok(ctx.resolve_all())\n+    Ok(Arc::new(ctx.resolve_all()))\n }"}]}