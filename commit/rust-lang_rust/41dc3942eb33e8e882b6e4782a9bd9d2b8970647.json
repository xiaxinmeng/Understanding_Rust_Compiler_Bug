{"sha": "41dc3942eb33e8e882b6e4782a9bd9d2b8970647", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxZGMzOTQyZWIzM2U4ZTg4MmI2ZTQ3ODJhOWJkOWQyYjg5NzA2NDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-14T19:57:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-14T19:57:57Z"}, "message": "Auto merge of #75608 - estebank:suggest-boxed-match-exprs, r=lcnr,varkor\n\nMore structured suggestions for boxed trait objects instead of impl Trait on non-coerceable tail expressions\n\nWhen encountering a `match` or `if` as a tail expression where the\ndifferent arms do not have the same type *and* the return type of that\n`fn` is an `impl Trait`, check whether those arms can implement `Trait`\nand if so, suggest using boxed trait objects.\n\nUse structured suggestion for `impl T` to `Box<dyn T>`.\n\nFix https://github.com/rust-lang/rust/issues/69107", "tree": {"sha": "a1b4335d6ba112f9d8ba5a1e2c8ca89bb49c817d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1b4335d6ba112f9d8ba5a1e2c8ca89bb49c817d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41dc3942eb33e8e882b6e4782a9bd9d2b8970647", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41dc3942eb33e8e882b6e4782a9bd9d2b8970647", "html_url": "https://github.com/rust-lang/rust/commit/41dc3942eb33e8e882b6e4782a9bd9d2b8970647", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41dc3942eb33e8e882b6e4782a9bd9d2b8970647/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb0067c75ea82efa8a09213bfba0dc2583ac0a4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb0067c75ea82efa8a09213bfba0dc2583ac0a4c", "html_url": "https://github.com/rust-lang/rust/commit/bb0067c75ea82efa8a09213bfba0dc2583ac0a4c"}, {"sha": "c6f2ddf1cb1e328245da59a4fb42f90403389a07", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6f2ddf1cb1e328245da59a4fb42f90403389a07", "html_url": "https://github.com/rust-lang/rust/commit/c6f2ddf1cb1e328245da59a4fb42f90403389a07"}], "stats": {"total": 524, "additions": 466, "deletions": 58}, "files": [{"sha": "bcfcee23d13fee878ff5efe780f611cd8958b6d9", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 62, "deletions": 2, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/41dc3942eb33e8e882b6e4782a9bd9d2b8970647/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41dc3942eb33e8e882b6e4782a9bd9d2b8970647/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=41dc3942eb33e8e882b6e4782a9bd9d2b8970647", "patch": "@@ -70,7 +70,7 @@ use rustc_middle::ty::{\n     subst::{Subst, SubstsRef},\n     Region, Ty, TyCtxt, TypeFoldable,\n };\n-use rustc_span::{DesugaringKind, Pos, Span};\n+use rustc_span::{BytePos, DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n use std::{cmp, fmt};\n \n@@ -617,11 +617,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 ref prior_arms,\n                 last_ty,\n                 scrut_hir_id,\n+                opt_suggest_box_span,\n+                arm_span,\n                 ..\n             }) => match source {\n                 hir::MatchSource::IfLetDesugar { .. } => {\n                     let msg = \"`if let` arms have incompatible types\";\n                     err.span_label(cause.span, msg);\n+                    if let Some(ret_sp) = opt_suggest_box_span {\n+                        self.suggest_boxing_for_return_impl_trait(\n+                            err,\n+                            ret_sp,\n+                            prior_arms.iter().chain(std::iter::once(&arm_span)).map(|s| *s),\n+                        );\n+                    }\n                 }\n                 hir::MatchSource::TryDesugar => {\n                     if let Some(ty::error::ExpectedFound { expected, .. }) = exp_found {\n@@ -675,9 +684,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             Applicability::MachineApplicable,\n                         );\n                     }\n+                    if let Some(ret_sp) = opt_suggest_box_span {\n+                        // Get return type span and point to it.\n+                        self.suggest_boxing_for_return_impl_trait(\n+                            err,\n+                            ret_sp,\n+                            prior_arms.iter().chain(std::iter::once(&arm_span)).map(|s| *s),\n+                        );\n+                    }\n                 }\n             },\n-            ObligationCauseCode::IfExpression(box IfExpressionCause { then, outer, semicolon }) => {\n+            ObligationCauseCode::IfExpression(box IfExpressionCause {\n+                then,\n+                else_sp,\n+                outer,\n+                semicolon,\n+                opt_suggest_box_span,\n+            }) => {\n                 err.span_label(then, \"expected because of this\");\n                 if let Some(sp) = outer {\n                     err.span_label(sp, \"`if` and `else` have incompatible types\");\n@@ -690,11 +713,48 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         Applicability::MachineApplicable,\n                     );\n                 }\n+                if let Some(ret_sp) = opt_suggest_box_span {\n+                    self.suggest_boxing_for_return_impl_trait(\n+                        err,\n+                        ret_sp,\n+                        vec![then, else_sp].into_iter(),\n+                    );\n+                }\n             }\n             _ => (),\n         }\n     }\n \n+    fn suggest_boxing_for_return_impl_trait(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        return_sp: Span,\n+        arm_spans: impl Iterator<Item = Span>,\n+    ) {\n+        err.multipart_suggestion(\n+            \"you could change the return type to be a boxed trait object\",\n+            vec![\n+                (return_sp.with_hi(return_sp.lo() + BytePos(4)), \"Box<dyn\".to_string()),\n+                (return_sp.shrink_to_hi(), \">\".to_string()),\n+            ],\n+            Applicability::MaybeIncorrect,\n+        );\n+        let sugg = arm_spans\n+            .flat_map(|sp| {\n+                vec![\n+                    (sp.shrink_to_lo(), \"Box::new(\".to_string()),\n+                    (sp.shrink_to_hi(), \")\".to_string()),\n+                ]\n+                .into_iter()\n+            })\n+            .collect::<Vec<_>>();\n+        err.multipart_suggestion(\n+            \"if you change the return type to expect trait objects, box the returned expressions\",\n+            sugg,\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+\n     /// Given that `other_ty` is the same as a type argument for `name` in `sub`, populate `value`\n     /// highlighting `name` and every type argument that isn't at `pos` (which is `other_ty`), and\n     /// populate `other_value` with `other_ty`."}, {"sha": "a554c80cdaa1a055ada188899a0f8893686e6a18", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/41dc3942eb33e8e882b6e4782a9bd9d2b8970647/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41dc3942eb33e8e882b6e4782a9bd9d2b8970647/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=41dc3942eb33e8e882b6e4782a9bd9d2b8970647", "patch": "@@ -348,13 +348,16 @@ pub struct MatchExpressionArmCause<'tcx> {\n     pub prior_arms: Vec<Span>,\n     pub last_ty: Ty<'tcx>,\n     pub scrut_hir_id: hir::HirId,\n+    pub opt_suggest_box_span: Option<Span>,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct IfExpressionCause {\n     pub then: Span,\n+    pub else_sp: Span,\n     pub outer: Option<Span>,\n     pub semicolon: Option<Span>,\n+    pub opt_suggest_box_span: Option<Span>,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]"}, {"sha": "836a4ff78c79e1705c48a0b8cd19a7466564cb61", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 77, "deletions": 9, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/41dc3942eb33e8e882b6e4782a9bd9d2b8970647/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41dc3942eb33e8e882b6e4782a9bd9d2b8970647/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=41dc3942eb33e8e882b6e4782a9bd9d2b8970647", "patch": "@@ -1,28 +1,31 @@\n use crate::check::coercion::CoerceMany;\n use crate::check::{Diverges, Expectation, FnCtxt, Needs};\n-use rustc_hir as hir;\n-use rustc_hir::ExprKind;\n+use rustc_hir::{self as hir, ExprKind};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_middle::ty::Ty;\n+use rustc_infer::traits::Obligation;\n+use rustc_middle::ty::{self, ToPredicate, Ty};\n use rustc_span::Span;\n-use rustc_trait_selection::traits::ObligationCauseCode;\n-use rustc_trait_selection::traits::{IfExpressionCause, MatchExpressionArmCause, ObligationCause};\n+use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n+use rustc_trait_selection::traits::{\n+    IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n+};\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_match(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         scrut: &'tcx hir::Expr<'tcx>,\n         arms: &'tcx [hir::Arm<'tcx>],\n-        expected: Expectation<'tcx>,\n+        orig_expected: Expectation<'tcx>,\n         match_src: hir::MatchSource,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n \n         use hir::MatchSource::*;\n         let (source_if, if_no_else, force_scrutinee_bool) = match match_src {\n             IfDesugar { contains_else_clause } => (true, !contains_else_clause, true),\n-            IfLetDesugar { contains_else_clause } => (true, !contains_else_clause, false),\n+            IfLetDesugar { contains_else_clause, .. } => (true, !contains_else_clause, false),\n             WhileDesugar => (false, false, true),\n             _ => (false, false, false),\n         };\n@@ -69,7 +72,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // type in that case)\n         let mut all_arms_diverge = Diverges::WarnedAlways;\n \n-        let expected = expected.adjust_for_branches(self);\n+        let expected = orig_expected.adjust_for_branches(self);\n \n         let mut coercion = {\n             let coerce_first = match expected {\n@@ -112,14 +115,75 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_expr_with_expectation(&arm.body, expected)\n             };\n             all_arms_diverge &= self.diverges.get();\n+\n+            // When we have a `match` as a tail expression in a `fn` with a returned `impl Trait`\n+            // we check if the different arms would work with boxed trait objects instead and\n+            // provide a structured suggestion in that case.\n+            let opt_suggest_box_span = match (\n+                orig_expected,\n+                self.ret_coercion_impl_trait.map(|ty| (self.body_id.owner, ty)),\n+            ) {\n+                (Expectation::ExpectHasType(expected), Some((id, ty)))\n+                    if self.in_tail_expr && self.can_coerce(arm_ty, expected) =>\n+                {\n+                    let impl_trait_ret_ty = self.infcx.instantiate_opaque_types(\n+                        id,\n+                        self.body_id,\n+                        self.param_env,\n+                        &ty,\n+                        arm.body.span,\n+                    );\n+                    let mut suggest_box = !impl_trait_ret_ty.obligations.is_empty();\n+                    for o in impl_trait_ret_ty.obligations {\n+                        match o.predicate.skip_binders_unchecked() {\n+                            ty::PredicateAtom::Trait(t, constness) => {\n+                                let pred = ty::PredicateAtom::Trait(\n+                                    ty::TraitPredicate {\n+                                        trait_ref: ty::TraitRef {\n+                                            def_id: t.def_id(),\n+                                            substs: self.infcx.tcx.mk_substs_trait(arm_ty, &[]),\n+                                        },\n+                                    },\n+                                    constness,\n+                                );\n+                                let obl = Obligation::new(\n+                                    o.cause.clone(),\n+                                    self.param_env,\n+                                    pred.to_predicate(self.infcx.tcx),\n+                                );\n+                                suggest_box &= self.infcx.predicate_must_hold_modulo_regions(&obl);\n+                                if !suggest_box {\n+                                    // We've encountered some obligation that didn't hold, so the\n+                                    // return expression can't just be boxed. We don't need to\n+                                    // evaluate the rest of the obligations.\n+                                    break;\n+                                }\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                    // If all the obligations hold (or there are no obligations) the tail expression\n+                    // we can suggest to return a boxed trait object instead of an opaque type.\n+                    if suggest_box { self.ret_type_span.clone() } else { None }\n+                }\n+                _ => None,\n+            };\n+\n             if source_if {\n                 let then_expr = &arms[0].body;\n                 match (i, if_no_else) {\n                     (0, _) => coercion.coerce(self, &self.misc(expr.span), &arm.body, arm_ty),\n                     (_, true) => {} // Handled above to avoid duplicated type errors (#60254).\n                     (_, _) => {\n                         let then_ty = prior_arm_ty.unwrap();\n-                        let cause = self.if_cause(expr.span, then_expr, &arm.body, then_ty, arm_ty);\n+                        let cause = self.if_cause(\n+                            expr.span,\n+                            then_expr,\n+                            &arm.body,\n+                            then_ty,\n+                            arm_ty,\n+                            opt_suggest_box_span,\n+                        );\n                         coercion.coerce(self, &cause, &arm.body, arm_ty);\n                     }\n                 }\n@@ -142,6 +206,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             prior_arms: other_arms.clone(),\n                             last_ty: prior_arm_ty.unwrap(),\n                             scrut_hir_id: scrut.hir_id,\n+                            opt_suggest_box_span,\n                         }),\n                     ),\n                 };\n@@ -266,6 +331,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         else_expr: &'tcx hir::Expr<'tcx>,\n         then_ty: Ty<'tcx>,\n         else_ty: Ty<'tcx>,\n+        opt_suggest_box_span: Option<Span>,\n     ) -> ObligationCause<'tcx> {\n         let mut outer_sp = if self.tcx.sess.source_map().is_multiline(span) {\n             // The `if`/`else` isn't in one line in the output, include some context to make it\n@@ -353,8 +419,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             error_sp,\n             ObligationCauseCode::IfExpression(box IfExpressionCause {\n                 then: then_sp,\n+                else_sp: error_sp,\n                 outer: outer_sp,\n                 semicolon: remove_semicolon,\n+                opt_suggest_box_span,\n             }),\n         )\n     }"}, {"sha": "4addee1a4c97643c1d094b4d646c163005ae12cf", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/41dc3942eb33e8e882b6e4782a9bd9d2b8970647/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41dc3942eb33e8e882b6e4782a9bd9d2b8970647/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=41dc3942eb33e8e882b6e4782a9bd9d2b8970647", "patch": "@@ -37,7 +37,7 @@\n \n use crate::astconv::AstConv;\n use crate::check::FnCtxt;\n-use rustc_errors::{struct_span_err, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{Coercion, InferOk, InferResult};\n@@ -51,7 +51,7 @@ use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TypeAndMut};\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;\n-use rustc_span::{self, Span};\n+use rustc_span::{self, BytePos, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n@@ -1459,14 +1459,15 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             }\n         }\n         if let (Some(sp), Some(fn_output)) = (fcx.ret_coercion_span.borrow().as_ref(), fn_output) {\n-            self.add_impl_trait_explanation(&mut err, fcx, expected, *sp, fn_output);\n+            self.add_impl_trait_explanation(&mut err, cause, fcx, expected, *sp, fn_output);\n         }\n         err\n     }\n \n     fn add_impl_trait_explanation<'a>(\n         &self,\n         err: &mut DiagnosticBuilder<'a>,\n+        cause: &ObligationCause<'tcx>,\n         fcx: &FnCtxt<'a, 'tcx>,\n         expected: Ty<'tcx>,\n         sp: Span,\n@@ -1523,10 +1524,30 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         };\n         if has_impl {\n             if is_object_safe {\n-                err.help(&format!(\n-                    \"you can instead return a boxed trait object using `Box<dyn {}>`\",\n-                    &snippet[5..]\n-                ));\n+                err.multipart_suggestion(\n+                    \"you could change the return type to be a boxed trait object\",\n+                    vec![\n+                        (return_sp.with_hi(return_sp.lo() + BytePos(4)), \"Box<dyn\".to_string()),\n+                        (return_sp.shrink_to_hi(), \">\".to_string()),\n+                    ],\n+                    Applicability::MachineApplicable,\n+                );\n+                let sugg = vec![sp, cause.span]\n+                    .into_iter()\n+                    .flat_map(|sp| {\n+                        vec![\n+                            (sp.shrink_to_lo(), \"Box::new(\".to_string()),\n+                            (sp.shrink_to_hi(), \")\".to_string()),\n+                        ]\n+                        .into_iter()\n+                    })\n+                    .collect::<Vec<_>>();\n+                err.multipart_suggestion(\n+                    \"if you change the return type to expect trait objects, box the returned \\\n+                     expressions\",\n+                    sugg,\n+                    Applicability::MaybeIncorrect,\n+                );\n             } else {\n                 err.help(&format!(\n                     \"if the trait `{}` were object safe, you could return a boxed trait object\",\n@@ -1535,7 +1556,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             }\n             err.note(trait_obj_msg);\n         }\n-        err.help(\"alternatively, create a new `enum` with a variant for each returned type\");\n+        err.help(\"you could instead create a new `enum` with a variant for each returned type\");\n     }\n \n     fn is_return_ty_unsized(&self, fcx: &FnCtxt<'a, 'tcx>, blk_id: hir::HirId) -> bool {"}, {"sha": "e3846d9c4efcc92e908a2d262afe2761d7e9ab7d", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/41dc3942eb33e8e882b6e4782a9bd9d2b8970647/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41dc3942eb33e8e882b6e4782a9bd9d2b8970647/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=41dc3942eb33e8e882b6e4782a9bd9d2b8970647", "patch": "@@ -570,6 +570,14 @@ pub struct FnCtxt<'a, 'tcx> {\n     /// any).\n     ret_coercion: Option<RefCell<DynamicCoerceMany<'tcx>>>,\n \n+    ret_coercion_impl_trait: Option<Ty<'tcx>>,\n+\n+    ret_type_span: Option<Span>,\n+\n+    /// Used exclusively to reduce cost of advanced evaluation used for\n+    /// more helpful diagnostics.\n+    in_tail_expr: bool,\n+\n     /// First span of a return site that we find. Used in error messages.\n     ret_coercion_span: RefCell<Option<Span>>,\n \n@@ -1302,10 +1310,15 @@ fn check_fn<'a, 'tcx>(\n     let hir = tcx.hir();\n \n     let declared_ret_ty = fn_sig.output();\n+\n     let revealed_ret_ty =\n         fcx.instantiate_opaque_types_from_value(fn_id, &declared_ret_ty, decl.output.span());\n     debug!(\"check_fn: declared_ret_ty: {}, revealed_ret_ty: {}\", declared_ret_ty, revealed_ret_ty);\n     fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(revealed_ret_ty)));\n+    fcx.ret_type_span = Some(decl.output.span());\n+    if let ty::Opaque(..) = declared_ret_ty.kind() {\n+        fcx.ret_coercion_impl_trait = Some(declared_ret_ty);\n+    }\n     fn_sig = tcx.mk_fn_sig(\n         fn_sig.inputs().iter().cloned(),\n         revealed_ret_ty,\n@@ -1366,6 +1379,7 @@ fn check_fn<'a, 'tcx>(\n \n     inherited.typeck_results.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n \n+    fcx.in_tail_expr = true;\n     if let ty::Dynamic(..) = declared_ret_ty.kind() {\n         // FIXME: We need to verify that the return type is `Sized` after the return expression has\n         // been evaluated so that we have types available for all the nodes being returned, but that\n@@ -1385,6 +1399,7 @@ fn check_fn<'a, 'tcx>(\n         fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n         fcx.check_return_expr(&body.value);\n     }\n+    fcx.in_tail_expr = false;\n \n     // We insert the deferred_generator_interiors entry after visiting the body.\n     // This ensures that all nested generators appear before the entry of this generator.\n@@ -3084,6 +3099,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             param_env,\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_coercion: None,\n+            ret_coercion_impl_trait: None,\n+            ret_type_span: None,\n+            in_tail_expr: false,\n             ret_coercion_span: RefCell::new(None),\n             resume_yield_tys: None,\n             ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal, hir::CRATE_HIR_ID)),"}, {"sha": "cdaa61ac323dd490fda9c16c930992a0f9487454", "filename": "src/test/ui/impl-trait/equality.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41dc3942eb33e8e882b6e4782a9bd9d2b8970647/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41dc3942eb33e8e882b6e4782a9bd9d2b8970647/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr?ref=41dc3942eb33e8e882b6e4782a9bd9d2b8970647", "patch": "@@ -23,7 +23,7 @@ LL |     0_u32\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n    = help: if the trait `Foo` were object safe, you could return a boxed trait object\n    = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: alternatively, create a new `enum` with a variant for each returned type\n+   = help: you could instead create a new `enum` with a variant for each returned type\n \n error[E0277]: cannot add `impl Foo` to `u32`\n   --> $DIR/equality.rs:24:11"}, {"sha": "66043267f91cd71979f72ae93fabbba300952e0c", "filename": "src/test/ui/impl-trait/object-unsafe-trait-in-return-position-impl-trait.stderr", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/41dc3942eb33e8e882b6e4782a9bd9d2b8970647/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41dc3942eb33e8e882b6e4782a9bd9d2b8970647/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr?ref=41dc3942eb33e8e882b6e4782a9bd9d2b8970647", "patch": "@@ -14,7 +14,7 @@ LL |     B\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n    = help: if the trait `NotObjectSafe` were object safe, you could return a boxed trait object\n    = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: alternatively, create a new `enum` with a variant for each returned type\n+   = help: you could instead create a new `enum` with a variant for each returned type\n \n error[E0308]: mismatched types\n   --> $DIR/object-unsafe-trait-in-return-position-impl-trait.rs:43:5\n@@ -30,9 +30,18 @@ LL |     B\n    |\n    = note: to return `impl Trait`, all returned values must be of the same type\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = help: you can instead return a boxed trait object using `Box<dyn ObjectSafe>`\n    = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: alternatively, create a new `enum` with a variant for each returned type\n+   = help: you could instead create a new `enum` with a variant for each returned type\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn cat() -> Box<dyn ObjectSafe> {\n+   |             ^^^^^^^           ^\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL |         return Box::new(A);\n+LL |     }\n+LL |     Box::new(B)\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "fa7664a83eee073f7588794011a8f5f73f336117", "filename": "src/test/ui/point-to-type-err-cause-on-impl-trait-return.rs", "status": "modified", "additions": 49, "deletions": 13, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/41dc3942eb33e8e882b6e4782a9bd9d2b8970647/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41dc3942eb33e8e882b6e4782a9bd9d2b8970647/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.rs?ref=41dc3942eb33e8e882b6e4782a9bd9d2b8970647", "patch": "@@ -2,64 +2,100 @@ fn foo() -> impl std::fmt::Display {\n     if false {\n         return 0i32;\n     }\n-    1u32\n-    //~^ ERROR mismatched types\n+    1u32 //~ ERROR mismatched types\n }\n \n fn bar() -> impl std::fmt::Display {\n     if false {\n         return 0i32;\n     } else {\n-        return 1u32;\n-        //~^ ERROR mismatched types\n+        return 1u32; //~ ERROR mismatched types\n     }\n }\n \n fn baz() -> impl std::fmt::Display {\n     if false {\n         return 0i32;\n     } else {\n-        1u32\n-        //~^ ERROR mismatched types\n+        1u32 //~ ERROR mismatched types\n     }\n }\n \n fn qux() -> impl std::fmt::Display {\n     if false {\n         0i32\n     } else {\n-        1u32\n-        //~^ ERROR `if` and `else` have incompatible types\n+        1u32 //~ ERROR `if` and `else` have incompatible types\n     }\n }\n \n fn bat() -> impl std::fmt::Display {\n     match 13 {\n         0 => return 0i32,\n-        _ => 1u32,\n-        //~^ ERROR mismatched types\n+        _ => 1u32, //~ ERROR mismatched types\n     }\n }\n \n fn can() -> impl std::fmt::Display {\n-    match 13 {\n-    //~^ ERROR mismatched types\n+    match 13 { //~ ERROR mismatched types\n         0 => return 0i32,\n         1 => 1u32,\n         _ => 2u32,\n     }\n }\n \n fn cat() -> impl std::fmt::Display {\n+    match 13 {\n+        0 => {\n+            return 0i32;\n+        }\n+        _ => {\n+            1u32 //~ ERROR mismatched types\n+        }\n+    }\n+}\n+\n+fn dog() -> impl std::fmt::Display {\n+    match 13 {\n+        0 => 0i32,\n+        1 => 1u32, //~ ERROR `match` arms have incompatible types\n+        _ => 2u32,\n+    }\n+}\n+\n+fn hat() -> dyn std::fmt::Display { //~ ERROR return type cannot have an unboxed trait object\n     match 13 {\n         0 => {\n             return 0i32;\n         }\n         _ => {\n             1u32\n-            //~^ ERROR mismatched types\n         }\n     }\n }\n \n+fn pug() -> dyn std::fmt::Display { //~ ERROR return type cannot have an unboxed trait object\n+    match 13 {\n+        0 => 0i32,\n+        1 => 1u32, //~ ERROR `match` arms have incompatible types\n+        _ => 2u32,\n+    }\n+}\n+\n+fn man() -> dyn std::fmt::Display { //~ ERROR return type cannot have an unboxed trait object\n+    if false {\n+        0i32\n+    } else {\n+        1u32 //~ ERROR `if` and `else` have incompatible types\n+    }\n+}\n+\n+fn apt() -> impl std::fmt::Display {\n+    if let Some(42) = Some(42) {\n+        0i32\n+    } else {\n+        1u32 //~ ERROR `if` and `else` have incompatible types\n+    }\n+}\n+\n fn main() {}"}, {"sha": "eb4dc45c8a9320e136428e8b6699a3e560de9ef9", "filename": "src/test/ui/point-to-type-err-cause-on-impl-trait-return.stderr", "status": "modified", "additions": 215, "deletions": 22, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/41dc3942eb33e8e882b6e4782a9bd9d2b8970647/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41dc3942eb33e8e882b6e4782a9bd9d2b8970647/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr?ref=41dc3942eb33e8e882b6e4782a9bd9d2b8970647", "patch": "@@ -12,12 +12,21 @@ LL |     1u32\n    |\n    = note: to return `impl Trait`, all returned values must be of the same type\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = help: you can instead return a boxed trait object using `Box<dyn std::fmt::Display>`\n    = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: alternatively, create a new `enum` with a variant for each returned type\n+   = help: you could instead create a new `enum` with a variant for each returned type\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn foo() -> Box<dyn std::fmt::Display> {\n+   |             ^^^^^^^                  ^\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL |         return Box::new(0i32);\n+LL |     }\n+LL |     Box::new(1u32)\n+   |\n \n error[E0308]: mismatched types\n-  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:13:16\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:12:16\n    |\n LL | fn bar() -> impl std::fmt::Display {\n    |             ---------------------- expected because this return type...\n@@ -30,12 +39,21 @@ LL |         return 1u32;\n    |\n    = note: to return `impl Trait`, all returned values must be of the same type\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = help: you can instead return a boxed trait object using `Box<dyn std::fmt::Display>`\n    = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: alternatively, create a new `enum` with a variant for each returned type\n+   = help: you could instead create a new `enum` with a variant for each returned type\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn bar() -> Box<dyn std::fmt::Display> {\n+   |             ^^^^^^^                  ^\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL |         return Box::new(0i32);\n+LL |     } else {\n+LL |         return Box::new(1u32);\n+   |\n \n error[E0308]: mismatched types\n-  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:22:9\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:20:9\n    |\n LL | fn baz() -> impl std::fmt::Display {\n    |             ---------------------- expected because this return type...\n@@ -48,25 +66,44 @@ LL |         1u32\n    |\n    = note: to return `impl Trait`, all returned values must be of the same type\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = help: you can instead return a boxed trait object using `Box<dyn std::fmt::Display>`\n    = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: alternatively, create a new `enum` with a variant for each returned type\n+   = help: you could instead create a new `enum` with a variant for each returned type\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn baz() -> Box<dyn std::fmt::Display> {\n+   |             ^^^^^^^                  ^\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL |         return Box::new(0i32);\n+LL |     } else {\n+LL |         Box::new(1u32)\n+   |\n \n error[E0308]: `if` and `else` have incompatible types\n-  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:31:9\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:28:9\n    |\n LL | /     if false {\n LL | |         0i32\n    | |         ---- expected because of this\n LL | |     } else {\n LL | |         1u32\n    | |         ^^^^ expected `i32`, found `u32`\n-LL | |\n LL | |     }\n    | |_____- `if` and `else` have incompatible types\n+   |\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn qux() -> Box<dyn std::fmt::Display> {\n+   |             ^^^^^^^                  ^\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL |         Box::new(0i32)\n+LL |     } else {\n+LL |         Box::new(1u32)\n+   |\n \n error[E0308]: mismatched types\n-  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:39:14\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:35:14\n    |\n LL | fn bat() -> impl std::fmt::Display {\n    |             ---------------------- expected because this return type...\n@@ -78,17 +115,24 @@ LL |         _ => 1u32,\n    |\n    = note: to return `impl Trait`, all returned values must be of the same type\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = help: you can instead return a boxed trait object using `Box<dyn std::fmt::Display>`\n    = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: alternatively, create a new `enum` with a variant for each returned type\n+   = help: you could instead create a new `enum` with a variant for each returned type\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn bat() -> Box<dyn std::fmt::Display> {\n+   |             ^^^^^^^                  ^\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL |         0 => return Box::new(0i32),\n+LL |         _ => Box::new(1u32),\n+   |\n \n error[E0308]: mismatched types\n-  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:45:5\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:40:5\n    |\n LL |   fn can() -> impl std::fmt::Display {\n    |               ---------------------- expected because this return type...\n LL | /     match 13 {\n-LL | |\n LL | |         0 => return 0i32,\n    | |                     ---- ...is found to be `i32` here\n LL | |         1 => 1u32,\n@@ -98,12 +142,23 @@ LL | |     }\n    |\n    = note: to return `impl Trait`, all returned values must be of the same type\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = help: you can instead return a boxed trait object using `Box<dyn std::fmt::Display>`\n    = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: alternatively, create a new `enum` with a variant for each returned type\n+   = help: you could instead create a new `enum` with a variant for each returned type\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn can() -> Box<dyn std::fmt::Display> {\n+   |             ^^^^^^^                  ^\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL |     Box::new(match 13 {\n+LL |         0 => return Box::new(0i32),\n+LL |         1 => 1u32,\n+LL |         _ => 2u32,\n+LL |     })\n+   |\n \n error[E0308]: mismatched types\n-  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:59:13\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:53:13\n    |\n LL | fn cat() -> impl std::fmt::Display {\n    |             ---------------------- expected because this return type...\n@@ -116,10 +171,148 @@ LL |             1u32\n    |\n    = note: to return `impl Trait`, all returned values must be of the same type\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = help: you can instead return a boxed trait object using `Box<dyn std::fmt::Display>`\n    = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: alternatively, create a new `enum` with a variant for each returned type\n+   = help: you could instead create a new `enum` with a variant for each returned type\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn cat() -> Box<dyn std::fmt::Display> {\n+   |             ^^^^^^^                  ^\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL |             return Box::new(0i32);\n+LL |         }\n+LL |         _ => {\n+LL |             Box::new(1u32)\n+   |\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:61:14\n+   |\n+LL | /     match 13 {\n+LL | |         0 => 0i32,\n+   | |              ---- this is found to be of type `i32`\n+LL | |         1 => 1u32,\n+   | |              ^^^^ expected `i32`, found `u32`\n+LL | |         _ => 2u32,\n+LL | |     }\n+   | |_____- `match` arms have incompatible types\n+   |\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn dog() -> Box<dyn std::fmt::Display> {\n+   |             ^^^^^^^                  ^\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL |         0 => Box::new(0i32),\n+LL |         1 => Box::new(1u32),\n+   |\n+\n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:97:9\n+   |\n+LL | /     if let Some(42) = Some(42) {\n+LL | |         0i32\n+   | |         ---- expected because of this\n+LL | |     } else {\n+LL | |         1u32\n+   | |         ^^^^ expected `i32`, found `u32`\n+LL | |     }\n+   | |_____- `if` and `else` have incompatible types\n+   |\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn apt() -> Box<dyn std::fmt::Display> {\n+   |             ^^^^^^^                  ^\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL |         Box::new(0i32)\n+LL |     } else {\n+LL |         Box::new(1u32)\n+   |\n+\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:66:13\n+   |\n+LL | fn hat() -> dyn std::fmt::Display {\n+   |             ^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = note: if all the returned values were of the same type you could use `impl std::fmt::Display` as the return type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = note: you can create a new `enum` with a variant for each returned type\n+help: return a boxed trait object instead\n+   |\n+LL | fn hat() -> Box<dyn std::fmt::Display> {\n+LL |     match 13 {\n+LL |         0 => {\n+LL |             return Box::new(0i32);\n+LL |         }\n+LL |         _ => {\n+ ...\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:80:14\n+   |\n+LL | /     match 13 {\n+LL | |         0 => 0i32,\n+   | |              ---- this is found to be of type `i32`\n+LL | |         1 => 1u32,\n+   | |              ^^^^ expected `i32`, found `u32`\n+LL | |         _ => 2u32,\n+LL | |     }\n+   | |_____- `match` arms have incompatible types\n+\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:77:13\n+   |\n+LL | fn pug() -> dyn std::fmt::Display {\n+   |             ^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = note: if all the returned values were of the same type you could use `impl std::fmt::Display` as the return type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = note: you can create a new `enum` with a variant for each returned type\n+help: return a boxed trait object instead\n+   |\n+LL | fn pug() -> Box<dyn std::fmt::Display> {\n+LL |     match 13 {\n+LL |         0 => Box::new(0i32),\n+LL |         1 => Box::new(1u32),\n+LL |         _ => Box::new(2u32),\n+   |\n+\n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:89:9\n+   |\n+LL | /     if false {\n+LL | |         0i32\n+   | |         ---- expected because of this\n+LL | |     } else {\n+LL | |         1u32\n+   | |         ^^^^ expected `i32`, found `u32`\n+LL | |     }\n+   | |_____- `if` and `else` have incompatible types\n+\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:85:13\n+   |\n+LL | fn man() -> dyn std::fmt::Display {\n+   |             ^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = note: if all the returned values were of the same type you could use `impl std::fmt::Display` as the return type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = note: you can create a new `enum` with a variant for each returned type\n+help: return a boxed trait object instead\n+   |\n+LL | fn man() -> Box<dyn std::fmt::Display> {\n+LL |     if false {\n+LL |         Box::new(0i32)\n+LL |     } else {\n+LL |         Box::new(1u32)\n+   |\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 14 previous errors\n \n-For more information about this error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0308, E0746.\n+For more information about an error, try `rustc --explain E0308`."}]}