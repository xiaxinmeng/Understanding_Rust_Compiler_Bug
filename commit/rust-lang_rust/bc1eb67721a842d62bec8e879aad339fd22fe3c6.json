{"sha": "bc1eb67721a842d62bec8e879aad339fd22fe3c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMWViNjc3MjFhODQyZDYyYmVjOGU4NzlhYWQzMzlmZDIyZmUzYzY=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-06-07T14:28:36Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2016-06-09T11:26:08Z"}, "message": "introduce the type-safe IdxVec and use it instead of loose indexes", "tree": {"sha": "5252d92b89129951ea2bfc3c0c20831b8d76c6c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5252d92b89129951ea2bfc3c0c20831b8d76c6c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc1eb67721a842d62bec8e879aad339fd22fe3c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc1eb67721a842d62bec8e879aad339fd22fe3c6", "html_url": "https://github.com/rust-lang/rust/commit/bc1eb67721a842d62bec8e879aad339fd22fe3c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc1eb67721a842d62bec8e879aad339fd22fe3c6/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e9003c5574bbc90b219266a56d3e4dcd0cae59b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9003c5574bbc90b219266a56d3e4dcd0cae59b3", "html_url": "https://github.com/rust-lang/rust/commit/e9003c5574bbc90b219266a56d3e4dcd0cae59b3"}], "stats": {"total": 1031, "additions": 594, "deletions": 437}, "files": [{"sha": "f25075f79122dcc7c68c1408dd4f7822a608f69f", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 51, "deletions": 90, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -11,6 +11,7 @@\n use graphviz::IntoCow;\n use middle::const_val::ConstVal;\n use rustc_const_math::{ConstUsize, ConstInt, ConstMathErr};\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use hir::def_id::DefId;\n use ty::subst::Substs;\n use ty::{self, AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n@@ -25,37 +26,61 @@ use std::ops::{Index, IndexMut};\n use syntax::ast::{self, Name};\n use syntax::codemap::Span;\n \n+macro_rules! newtype_index {\n+    ($name:ident, $debug_name:expr) => (\n+        #[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord,\n+         RustcEncodable, RustcDecodable)]\n+        pub struct $name(u32);\n+\n+        impl Idx for $name {\n+            fn new(value: usize) -> Self {\n+                assert!(value < (u32::MAX) as usize);\n+                $name(value as u32)\n+            }\n+            fn index(self) -> usize {\n+                self.0 as usize\n+            }\n+        }\n+\n+        impl Debug for $name {\n+            fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n+                write!(fmt, \"{}{}\", $debug_name, self.0)\n+            }\n+        }\n+    )\n+}\n+\n /// Lowered representation of a single function.\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Mir<'tcx> {\n     /// List of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n     /// that indexes into this vector.\n-    pub basic_blocks: Vec<BasicBlockData<'tcx>>,\n+    pub basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n \n     /// List of visibility (lexical) scopes; these are referenced by statements\n     /// and used (eventually) for debuginfo. Indexed by a `VisibilityScope`.\n-    pub visibility_scopes: Vec<VisibilityScopeData>,\n+    pub visibility_scopes: IndexVec<VisibilityScope, VisibilityScopeData>,\n \n     /// Rvalues promoted from this function, such as borrows of constants.\n     /// Each of them is the Mir of a constant with the fn's type parameters\n     /// in scope, but no vars or args and a separate set of temps.\n-    pub promoted: Vec<Mir<'tcx>>,\n+    pub promoted: IndexVec<Promoted, Mir<'tcx>>,\n \n     /// Return type of the function.\n     pub return_ty: FnOutput<'tcx>,\n \n     /// Variables: these are stack slots corresponding to user variables. They may be\n     /// assigned many times.\n-    pub var_decls: Vec<VarDecl<'tcx>>,\n+    pub var_decls: IndexVec<Var, VarDecl<'tcx>>,\n \n     /// Args: these are stack slots corresponding to the input arguments.\n-    pub arg_decls: Vec<ArgDecl<'tcx>>,\n+    pub arg_decls: IndexVec<Arg, ArgDecl<'tcx>>,\n \n     /// Temp declarations: stack slots that for temporaries created by\n     /// the compiler. These are assigned once, but they are not SSA\n     /// values in that it is possible to borrow them and mutate them\n     /// through the resulting reference.\n-    pub temp_decls: Vec<TempDecl<'tcx>>,\n+    pub temp_decls: IndexVec<Temp, TempDecl<'tcx>>,\n \n     /// Names and capture modes of all the closure upvars, assuming\n     /// the first argument is either the closure or a reference to it.\n@@ -76,11 +101,11 @@ impl<'tcx> Mir<'tcx> {\n     }\n \n     pub fn basic_block_data(&self, bb: BasicBlock) -> &BasicBlockData<'tcx> {\n-        &self.basic_blocks[bb.index()]\n+        &self.basic_blocks[bb]\n     }\n \n     pub fn basic_block_data_mut(&mut self, bb: BasicBlock) -> &mut BasicBlockData<'tcx> {\n-        &mut self.basic_blocks[bb.index()]\n+        &mut self.basic_blocks[bb]\n     }\n }\n \n@@ -231,31 +256,7 @@ pub struct UpvarDecl {\n ///////////////////////////////////////////////////////////////////////////\n // BasicBlock\n \n-/// The index of a particular basic block. The index is into the `basic_blocks`\n-/// list of the `Mir`.\n-///\n-/// (We use a `u32` internally just to save memory.)\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord,\n-         RustcEncodable, RustcDecodable)]\n-pub struct BasicBlock(u32);\n-\n-impl BasicBlock {\n-    pub fn new(index: usize) -> BasicBlock {\n-        assert!(index < (u32::MAX as usize));\n-        BasicBlock(index as u32)\n-    }\n-\n-    /// Extract the index.\n-    pub fn index(self) -> usize {\n-        self.0 as usize\n-    }\n-}\n-\n-impl Debug for BasicBlock {\n-    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n-        write!(fmt, \"bb{}\", self.0)\n-    }\n-}\n+newtype_index!(BasicBlock, \"bb\");\n \n ///////////////////////////////////////////////////////////////////////////\n // BasicBlockData and Terminator\n@@ -616,19 +617,23 @@ impl<'tcx> Debug for Statement<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Lvalues\n \n+newtype_index!(Var, \"var\");\n+newtype_index!(Temp, \"tmp\");\n+newtype_index!(Arg, \"arg\");\n+\n /// A path to a value; something that can be evaluated without\n /// changing or disturbing program state.\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Lvalue<'tcx> {\n     /// local variable declared by the user\n-    Var(u32),\n+    Var(Var),\n \n     /// temporary introduced during lowering into MIR\n-    Temp(u32),\n+    Temp(Temp),\n \n     /// formal parameter of the function; note that these are NOT the\n     /// bindings that the user declares, which are vars\n-    Arg(u32),\n+    Arg(Arg),\n \n     /// static or static mut variable\n     Static(DefId),\n@@ -696,20 +701,7 @@ pub type LvalueProjection<'tcx> = Projection<'tcx, Lvalue<'tcx>, Operand<'tcx>>;\n /// and the index is an operand.\n pub type LvalueElem<'tcx> = ProjectionElem<'tcx, Operand<'tcx>>;\n \n-/// Index into the list of fields found in a `VariantDef`\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-pub struct Field(u32);\n-\n-impl Field {\n-    pub fn new(value: usize) -> Field {\n-        assert!(value < (u32::MAX) as usize);\n-        Field(value as u32)\n-    }\n-\n-    pub fn index(self) -> usize {\n-        self.0 as usize\n-    }\n-}\n+newtype_index!(Field, \"field\");\n \n impl<'tcx> Lvalue<'tcx> {\n     pub fn field(self, f: Field, ty: Ty<'tcx>) -> Lvalue<'tcx> {\n@@ -737,12 +729,9 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n         use self::Lvalue::*;\n \n         match *self {\n-            Var(id) =>\n-                write!(fmt, \"var{:?}\", id),\n-            Arg(id) =>\n-                write!(fmt, \"arg{:?}\", id),\n-            Temp(id) =>\n-                write!(fmt, \"tmp{:?}\", id),\n+            Var(id) => write!(fmt, \"{:?}\", id),\n+            Arg(id) => write!(fmt, \"{:?}\", id),\n+            Temp(id) => write!(fmt, \"{:?}\", id),\n             Static(def_id) =>\n                 write!(fmt, \"{}\", ty::tls::with(|tcx| tcx.item_path_str(def_id))),\n             ReturnPointer =>\n@@ -777,38 +766,8 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Scopes\n \n-impl Index<VisibilityScope> for Vec<VisibilityScopeData> {\n-    type Output = VisibilityScopeData;\n-\n-    #[inline]\n-    fn index(&self, index: VisibilityScope) -> &VisibilityScopeData {\n-        &self[index.index()]\n-    }\n-}\n-\n-impl IndexMut<VisibilityScope> for Vec<VisibilityScopeData> {\n-    #[inline]\n-    fn index_mut(&mut self, index: VisibilityScope) -> &mut VisibilityScopeData {\n-        &mut self[index.index()]\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n-pub struct VisibilityScope(u32);\n-\n-/// The visibility scope all arguments go into.\n-pub const ARGUMENT_VISIBILITY_SCOPE: VisibilityScope = VisibilityScope(0);\n-\n-impl VisibilityScope {\n-    pub fn new(index: usize) -> VisibilityScope {\n-        assert!(index < (u32::MAX as usize));\n-        VisibilityScope(index as u32)\n-    }\n-\n-    pub fn index(self) -> usize {\n-        self.0 as usize\n-    }\n-}\n+newtype_index!(VisibilityScope, \"scope\");\n+pub const ARGUMENT_VISIBILITY_SCOPE : VisibilityScope = VisibilityScope(0);\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct VisibilityScopeData {\n@@ -1080,6 +1039,8 @@ impl<'tcx> Debug for TypedConstVal<'tcx> {\n     }\n }\n \n+newtype_index!(Promoted, \"promoted\");\n+\n #[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Literal<'tcx> {\n     Item {\n@@ -1091,7 +1052,7 @@ pub enum Literal<'tcx> {\n     },\n     Promoted {\n         // Index into the `promoted` vector of `Mir`.\n-        index: usize\n+        index: Promoted\n     },\n }\n \n@@ -1115,7 +1076,7 @@ impl<'tcx> Debug for Literal<'tcx> {\n                 fmt_const_val(fmt, value)\n             }\n             Promoted { index } => {\n-                write!(fmt, \"promoted{}\", index)\n+                write!(fmt, \"{:?}\", index)\n             }\n         }\n     }"}, {"sha": "e3905c39daa9c593d1d750ea54858bb40542e5bc", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -154,11 +154,11 @@ impl<'a, 'gcx, 'tcx> Mir<'tcx> {\n     {\n         match *lvalue {\n             Lvalue::Var(index) =>\n-                LvalueTy::Ty { ty: self.var_decls[index as usize].ty },\n+                LvalueTy::Ty { ty: self.var_decls[index].ty },\n             Lvalue::Temp(index) =>\n-                LvalueTy::Ty { ty: self.temp_decls[index as usize].ty },\n+                LvalueTy::Ty { ty: self.temp_decls[index].ty },\n             Lvalue::Arg(index) =>\n-                LvalueTy::Ty { ty: self.arg_decls[index as usize].ty },\n+                LvalueTy::Ty { ty: self.arg_decls[index].ty },\n             Lvalue::Static(def_id) =>\n                 LvalueTy::Ty { ty: tcx.lookup_item_type(def_id).ty },\n             Lvalue::ReturnPointer =>"}, {"sha": "73481b6643d2d706ed8a639d19423b4198de9538", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -11,6 +11,7 @@\n use std::vec;\n \n use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::indexed_vec::Idx;\n \n use super::repr::*;\n "}, {"sha": "f37f6386bd8dc26fa1446adc35d361bd4fd400fa", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -15,6 +15,7 @@ use ty::{ClosureSubsts, FnOutput, Region, Ty};\n use mir::repr::*;\n use rustc_const_math::ConstUsize;\n use rustc_data_structures::tuple_slice::TupleSlice;\n+use rustc_data_structures::indexed_vec::Idx;\n use syntax::codemap::Span;\n \n // # The MIR Visitor"}, {"sha": "c8a71ea350555fc6405184abf1ad42a6ba99dd9b", "filename": "src/librustc_borrowck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2FCargo.toml?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -14,4 +14,5 @@ log = { path = \"../liblog\" }\n syntax = { path = \"../libsyntax\" }\n graphviz = { path = \"../libgraphviz\" }\n rustc = { path = \"../librustc\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_mir = { path = \"../librustc_mir\" }"}, {"sha": "3b04f34af2b9ffcc07e9a9baa131a5bb2940eb7e", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/graphviz.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -12,6 +12,7 @@\n \n use syntax::ast::NodeId;\n use rustc::mir::repr::{BasicBlock, Mir};\n+use rustc_data_structures::indexed_vec::Idx;\n \n use dot;\n use dot::IntoCow;\n@@ -27,7 +28,7 @@ use std::path::Path;\n use super::super::MoveDataParamEnv;\n use super::super::MirBorrowckCtxtPreDataflow;\n use bitslice::bits_to_string;\n-use indexed_set::{Idx, IdxSet};\n+use indexed_set::{IdxSet};\n use super::{BitDenotation, DataflowState};\n \n impl<O: BitDenotation> DataflowState<O> {"}, {"sha": "fe399b9790858d9ce0c9070f6af604a35e119e6b", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/impls.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -10,6 +10,7 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::repr::{self, Mir};\n+use rustc_data_structures::indexed_vec::Idx;\n \n use super::super::gather_moves::{Location};\n use super::super::gather_moves::{MoveOutIndex, MovePathIndex};\n@@ -23,7 +24,7 @@ use super::{BitDenotation, BlockSets, DataflowOperator};\n \n use bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n use bitslice::{BitwiseOperator};\n-use indexed_set::{Idx, IdxSet};\n+use indexed_set::{IdxSet};\n \n // Dataflow analyses are built upon some interpretation of the\n // bitvectors attached to each basic block, represented via a\n@@ -451,7 +452,7 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n                                      move_data,\n                                      move_path_index,\n                                      |mpi| for moi in &path_map[mpi] {\n-                                         assert!(moi.idx() < bits_per_block);\n+                                         assert!(moi.index() < bits_per_block);\n                                          sets.kill_set.add(&moi);\n                                      });\n             }\n@@ -472,7 +473,7 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n                term, loc, &loc_map[loc]);\n         let bits_per_block = self.bits_per_block(ctxt);\n         for move_index in &loc_map[loc] {\n-            assert!(move_index.idx() < bits_per_block);\n+            assert!(move_index.index() < bits_per_block);\n             zero_to_one(sets.gen_set.words_mut(), *move_index);\n         }\n     }\n@@ -493,14 +494,14 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n                              move_data,\n                              move_path_index,\n                              |mpi| for moi in &path_map[mpi] {\n-                                 assert!(moi.idx() < bits_per_block);\n+                                 assert!(moi.index() < bits_per_block);\n                                  in_out.remove(&moi);\n                              });\n     }\n }\n \n fn zero_to_one(bitvec: &mut [usize], move_index: MoveOutIndex) {\n-    let retval = bitvec.set_bit(move_index.idx());\n+    let retval = bitvec.set_bit(move_index.index());\n     assert!(retval);\n }\n "}, {"sha": "3b6121449b498a585f2e89bea9e0b207ef763bce", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc_data_structures::indexed_vec::Idx;\n+\n use rustc::ty::TyCtxt;\n use rustc::mir::repr::{self, Mir};\n \n@@ -21,7 +23,7 @@ use super::MirBorrowckCtxtPreDataflow;\n use super::MoveDataParamEnv;\n \n use bitslice::{bitwise, BitwiseOperator};\n-use indexed_set::{Idx, IdxSet, IdxSetBuf};\n+use indexed_set::{IdxSet, IdxSetBuf};\n \n pub use self::sanity_check::sanity_check_via_rustc_peek;\n pub use self::impls::{MaybeInitializedLvals, MaybeUninitializedLvals};"}, {"sha": "735fffb8ef81d8666c16b11127fdda573b79cbdf", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -14,6 +14,7 @@ use syntax::codemap::Span;\n \n use rustc::ty::{self, TyCtxt};\n use rustc::mir::repr::{self, Mir};\n+use rustc_data_structures::indexed_vec::Idx;\n \n use super::super::gather_moves::{MovePathIndex};\n use super::super::MoveDataParamEnv;"}, {"sha": "d4cdb695ffbe4ae4305d978f61b57a8a510851e5", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -22,6 +22,7 @@ use rustc::mir::transform::{Pass, MirPass, MirSource};\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::lang_items;\n use rustc::util::nodemap::FnvHashMap;\n+use rustc_data_structures::indexed_vec::Idx;\n use rustc_mir::pretty;\n use syntax::codemap::Span;\n \n@@ -118,7 +119,7 @@ struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n     env: &'a MoveDataParamEnv<'tcx>,\n     flow_inits: DataflowResults<MaybeInitializedLvals<'a, 'tcx>>,\n     flow_uninits:  DataflowResults<MaybeUninitializedLvals<'a, 'tcx>>,\n-    drop_flags: FnvHashMap<MovePathIndex, u32>,\n+    drop_flags: FnvHashMap<MovePathIndex, Temp>,\n     patch: MirPatch<'tcx>,\n }\n "}, {"sha": "110633b1388a6045498d42f39d1b1abc0d75d8c1", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 50, "deletions": 55, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -12,6 +12,7 @@\n use rustc::ty::{FnOutput, TyCtxt};\n use rustc::mir::repr::*;\n use rustc::util::nodemap::FnvHashMap;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n use std::cell::{Cell};\n use std::collections::hash_map::Entry;\n@@ -20,7 +21,6 @@ use std::iter;\n use std::ops::Index;\n \n use super::abs_domain::{AbstractElem, Lift};\n-use indexed_set::{Idx};\n \n // This submodule holds some newtype'd Index wrappers that are using\n // NonZero to ensure that Option<Index> occupies only a single word.\n@@ -29,7 +29,7 @@ use indexed_set::{Idx};\n // (which is likely to yield a subtle off-by-one error).\n mod indexes {\n     use core::nonzero::NonZero;\n-    use indexed_set::Idx;\n+    use rustc_data_structures::indexed_vec::Idx;\n \n     macro_rules! new_index {\n         ($Index:ident) => {\n@@ -43,7 +43,7 @@ mod indexes {\n                 fn new(idx: usize) -> Self {\n                     unsafe { $Index(NonZero::new(idx + 1)) }\n                 }\n-                fn idx(&self) -> usize {\n+                fn index(self) -> usize {\n                     *self.0 - 1\n                 }\n             }\n@@ -62,7 +62,7 @@ pub use self::indexes::MoveOutIndex;\n \n impl self::indexes::MoveOutIndex {\n     pub fn move_path_index(&self, move_data: &MoveData) -> MovePathIndex {\n-        move_data.moves[self.idx()].path\n+        move_data.moves[self.index()].path\n     }\n }\n \n@@ -176,7 +176,7 @@ pub struct PathMap {\n impl Index<MovePathIndex> for PathMap {\n     type Output = [MoveOutIndex];\n     fn index(&self, index: MovePathIndex) -> &Self::Output {\n-        &self.map[index.idx()]\n+        &self.map[index.index()]\n     }\n }\n \n@@ -196,7 +196,7 @@ pub struct MoveOut {\n \n impl fmt::Debug for MoveOut {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"p{}@{:?}\", self.path.idx(), self.source)\n+        write!(fmt, \"p{}@{:?}\", self.path.index(), self.source)\n     }\n }\n \n@@ -227,14 +227,10 @@ impl<'tcx> MovePathData<'tcx> {\n impl<'tcx> Index<MovePathIndex> for MovePathData<'tcx> {\n     type Output = MovePath<'tcx>;\n     fn index(&self, i: MovePathIndex) -> &MovePath<'tcx> {\n-        &self.move_paths[i.idx()]\n+        &self.move_paths[i.index()]\n     }\n }\n \n-/// MovePathInverseMap maps from a uint in an lvalue-category to the\n-/// MovePathIndex for the MovePath for that lvalue.\n-type MovePathInverseMap = Vec<Option<MovePathIndex>>;\n-\n struct MovePathDataBuilder<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n     pre_move_paths: Vec<PreMovePath<'tcx>>,\n@@ -244,9 +240,9 @@ struct MovePathDataBuilder<'a, 'tcx: 'a> {\n /// Tables mapping from an l-value to its MovePathIndex.\n #[derive(Debug)]\n pub struct MovePathLookup<'tcx> {\n-    vars: MovePathInverseMap,\n-    temps: MovePathInverseMap,\n-    args: MovePathInverseMap,\n+    vars: IndexVec<Var, Option<MovePathIndex>>,\n+    temps: IndexVec<Temp, Option<MovePathIndex>>,\n+    args: IndexVec<Arg, Option<MovePathIndex>>,\n \n     /// The move path representing the return value is constructed\n     /// lazily when we first encounter it in the input MIR.\n@@ -295,15 +291,15 @@ enum LookupKind { Generate, Reuse }\n struct Lookup<T>(LookupKind, T);\n \n impl Lookup<MovePathIndex> {\n-    fn idx(&self) -> usize { (self.1).idx() }\n+    fn index(&self) -> usize { (self.1).index() }\n }\n \n impl<'tcx> MovePathLookup<'tcx> {\n-    fn new() -> Self {\n+    fn new(mir: &Mir) -> Self {\n         MovePathLookup {\n-            vars: vec![],\n-            temps: vec![],\n-            args: vec![],\n+            vars: IndexVec::from_elem(None, &mir.var_decls),\n+            temps: IndexVec::from_elem(None, &mir.temp_decls),\n+            args: IndexVec::from_elem(None, &mir.arg_decls),\n             statics: None,\n             return_ptr: None,\n             projections: vec![],\n@@ -313,15 +309,14 @@ impl<'tcx> MovePathLookup<'tcx> {\n \n     fn next_index(next: &mut MovePathIndex) -> MovePathIndex {\n         let i = *next;\n-        *next = MovePathIndex::new(i.idx() + 1);\n+        *next = MovePathIndex::new(i.index() + 1);\n         i\n     }\n \n-    fn lookup_or_generate(vec: &mut Vec<Option<MovePathIndex>>,\n-                          idx: u32,\n-                          next_index: &mut MovePathIndex) -> Lookup<MovePathIndex> {\n-        let idx = idx as usize;\n-        vec.fill_to_with(idx, None);\n+    fn lookup_or_generate<I: Idx>(vec: &mut IndexVec<I, Option<MovePathIndex>>,\n+                                  idx: I,\n+                                  next_index: &mut MovePathIndex)\n+                                  -> Lookup<MovePathIndex> {\n         let entry = &mut vec[idx];\n         match *entry {\n             None => {\n@@ -335,19 +330,19 @@ impl<'tcx> MovePathLookup<'tcx> {\n         }\n     }\n \n-    fn lookup_var(&mut self, var_idx: u32) -> Lookup<MovePathIndex> {\n+    fn lookup_var(&mut self, var_idx: Var) -> Lookup<MovePathIndex> {\n         Self::lookup_or_generate(&mut self.vars,\n                                  var_idx,\n                                  &mut self.next_index)\n     }\n \n-    fn lookup_temp(&mut self, temp_idx: u32) -> Lookup<MovePathIndex> {\n+    fn lookup_temp(&mut self, temp_idx: Temp) -> Lookup<MovePathIndex> {\n         Self::lookup_or_generate(&mut self.temps,\n                                  temp_idx,\n                                  &mut self.next_index)\n     }\n \n-    fn lookup_arg(&mut self, arg_idx: u32) -> Lookup<MovePathIndex> {\n+    fn lookup_arg(&mut self, arg_idx: Arg) -> Lookup<MovePathIndex> {\n         Self::lookup_or_generate(&mut self.args,\n                                  arg_idx,\n                                  &mut self.next_index)\n@@ -384,8 +379,8 @@ impl<'tcx> MovePathLookup<'tcx> {\n                    base: MovePathIndex) -> Lookup<MovePathIndex> {\n         let MovePathLookup { ref mut projections,\n                              ref mut next_index, .. } = *self;\n-        projections.fill_to(base.idx());\n-        match projections[base.idx()].entry(proj.elem.lift()) {\n+        projections.fill_to(base.index());\n+        match projections[base.index()].entry(proj.elem.lift()) {\n             Entry::Occupied(ent) => {\n                 Lookup(LookupKind::Reuse, *ent.get())\n             }\n@@ -404,14 +399,14 @@ impl<'tcx> MovePathLookup<'tcx> {\n     // unknown l-value; it will simply panic.\n     pub fn find(&self, lval: &Lvalue<'tcx>) -> MovePathIndex {\n         match *lval {\n-            Lvalue::Var(var_idx) => self.vars[var_idx as usize].unwrap(),\n-            Lvalue::Temp(temp_idx) => self.temps[temp_idx as usize].unwrap(),\n-            Lvalue::Arg(arg_idx) => self.args[arg_idx as usize].unwrap(),\n+            Lvalue::Var(var) => self.vars[var].unwrap(),\n+            Lvalue::Temp(temp) => self.temps[temp].unwrap(),\n+            Lvalue::Arg(arg) => self.args[arg].unwrap(),\n             Lvalue::Static(ref _def_id) => self.statics.unwrap(),\n             Lvalue::ReturnPointer => self.return_ptr.unwrap(),\n             Lvalue::Projection(ref proj) => {\n                 let base_index = self.find(&proj.base);\n-                self.projections[base_index.idx()][&proj.elem.lift()]\n+                self.projections[base_index.index()][&proj.elem.lift()]\n             }\n         }\n     }\n@@ -451,7 +446,7 @@ impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n \n         // `lookup` is either the previously assigned index or a\n         // newly-allocated one.\n-        debug_assert!(lookup.idx() <= self.pre_move_paths.len());\n+        debug_assert!(lookup.index() <= self.pre_move_paths.len());\n \n         if let Lookup(LookupKind::Generate, mpi) = lookup {\n             let parent;\n@@ -482,7 +477,7 @@ impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n                     let idx = self.move_path_for(&proj.base);\n                     parent = Some(idx);\n \n-                    let parent_move_path = &mut self.pre_move_paths[idx.idx()];\n+                    let parent_move_path = &mut self.pre_move_paths[idx.index()];\n \n                     // At last: Swap in the new first_child.\n                     sibling = parent_move_path.first_child.get();\n@@ -535,7 +530,7 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n     let mut builder = MovePathDataBuilder {\n         mir: mir,\n         pre_move_paths: Vec::new(),\n-        rev_lookup: MovePathLookup::new(),\n+        rev_lookup: MovePathLookup::new(mir),\n     };\n \n     // Before we analyze the program text, we create the MovePath's\n@@ -546,17 +541,17 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n     assert!(mir.var_decls.len() <= ::std::u32::MAX as usize);\n     assert!(mir.arg_decls.len() <= ::std::u32::MAX as usize);\n     assert!(mir.temp_decls.len() <= ::std::u32::MAX as usize);\n-    for var_idx in 0..mir.var_decls.len() {\n-        let path_idx = builder.move_path_for(&Lvalue::Var(var_idx as u32));\n-        path_map.fill_to(path_idx.idx());\n+    for (var, _) in mir.var_decls.iter_enumerated() {\n+        let path_idx = builder.move_path_for(&Lvalue::Var(var));\n+        path_map.fill_to(path_idx.index());\n     }\n-    for arg_idx in 0..mir.arg_decls.len() {\n-        let path_idx = builder.move_path_for(&Lvalue::Arg(arg_idx as u32));\n-        path_map.fill_to(path_idx.idx());\n+    for (arg, _) in mir.arg_decls.iter_enumerated() {\n+        let path_idx = builder.move_path_for(&Lvalue::Arg(arg));\n+        path_map.fill_to(path_idx.index());\n     }\n-    for temp_idx in 0..mir.temp_decls.len() {\n-        let path_idx = builder.move_path_for(&Lvalue::Temp(temp_idx as u32));\n-        path_map.fill_to(path_idx.idx());\n+    for (temp, _) in mir.temp_decls.iter_enumerated() {\n+        let path_idx = builder.move_path_for(&Lvalue::Temp(temp));\n+        path_map.fill_to(path_idx.index());\n     }\n \n     for bb in bbs {\n@@ -585,7 +580,7 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n                     // Ensure that the path_map contains entries even\n                     // if the lvalue is assigned and never read.\n                     let assigned_path = bb_ctxt.builder.move_path_for(lval);\n-                    bb_ctxt.path_map.fill_to(assigned_path.idx());\n+                    bb_ctxt.path_map.fill_to(assigned_path.index());\n \n                     match *rval {\n                         Rvalue::Use(ref operand) => {\n@@ -679,7 +674,7 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n             }\n             TerminatorKind::DropAndReplace { ref location, ref value, .. } => {\n                 let assigned_path = bb_ctxt.builder.move_path_for(location);\n-                bb_ctxt.path_map.fill_to(assigned_path.idx());\n+                bb_ctxt.path_map.fill_to(assigned_path.index());\n \n                 let source = Location { block: bb,\n                                         index: bb_data.statements.len() };\n@@ -699,7 +694,7 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n                     // Ensure that the path_map contains entries even\n                     // if the lvalue is assigned and never read.\n                     let assigned_path = bb_ctxt.builder.move_path_for(destination);\n-                    bb_ctxt.path_map.fill_to(assigned_path.idx());\n+                    bb_ctxt.path_map.fill_to(assigned_path.index());\n \n                     bb_ctxt.builder.create_move_path(destination);\n                 }\n@@ -729,8 +724,8 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n         let mut seen: Vec<_> = move_paths.iter().map(|_| false).collect();\n         for (j, &MoveOut { ref path, ref source }) in moves.iter().enumerate() {\n             debug!(\"MovePathData moves[{}]: MoveOut {{ path: {:?} = {:?}, source: {:?} }}\",\n-                   j, path, move_paths[path.idx()], source);\n-            seen[path.idx()] = true;\n+                   j, path, move_paths[path.index()], source);\n+            seen[path.index()] = true;\n         }\n         for (j, path) in move_paths.iter().enumerate() {\n             if !seen[j] {\n@@ -767,20 +762,20 @@ impl<'b, 'a: 'b, 'tcx: 'a> BlockContext<'b, 'a, 'tcx> {\n \n         let path = self.builder.move_path_for(lval);\n         self.moves.push(MoveOut { path: path, source: source.clone() });\n-        self.path_map.fill_to(path.idx());\n+        self.path_map.fill_to(path.index());\n \n         debug!(\"ctxt: {:?} add consume of lval: {:?} \\\n                 at index: {:?} \\\n                 to path_map for path: {:?} and \\\n                 to loc_map for loc: {:?}\",\n                stmt_kind, lval, index, path, source);\n \n-        debug_assert!(path.idx() < self.path_map.len());\n+        debug_assert!(path.index() < self.path_map.len());\n         // this is actually a questionable assert; at the very\n         // least, incorrect input code can probably cause it to\n         // fire.\n-        assert!(self.path_map[path.idx()].iter().find(|idx| **idx == index).is_none());\n-        self.path_map[path.idx()].push(index);\n+        assert!(self.path_map[path.index()].iter().find(|idx| **idx == index).is_none());\n+        self.path_map[path.index()].push(index);\n \n         debug_assert!(i < self.loc_map_bb.len());\n         debug_assert!(self.loc_map_bb[i].iter().find(|idx| **idx == index).is_none());"}, {"sha": "53dc62d5f713896984ec152bacb0810fa0b80c0b", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -298,8 +298,8 @@ fn drop_flag_effects_for_function_entry<'a, 'tcx, F>(\n     where F: FnMut(MovePathIndex, DropFlagState)\n {\n     let move_data = &ctxt.move_data;\n-    for i in 0..(mir.arg_decls.len() as u32) {\n-        let lvalue = repr::Lvalue::Arg(i);\n+    for (arg, _) in mir.arg_decls.iter_enumerated() {\n+        let lvalue = repr::Lvalue::Arg(arg);\n         let move_path_index = move_data.rev_lookup.find(&lvalue);\n         on_all_children_bits(tcx, mir, move_data,\n                              move_path_index,"}, {"sha": "0e342e0c293a1cd8d62744c9d11f70b6b7a9039a", "filename": "src/librustc_borrowck/borrowck/mir/patch.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -11,31 +11,28 @@\n use super::gather_moves::Location;\n use rustc::ty::Ty;\n use rustc::mir::repr::*;\n-\n-use std::iter;\n-use std::u32;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n /// This struct represents a patch to MIR, which can add\n /// new statements and basic blocks and patch over block\n /// terminators.\n pub struct MirPatch<'tcx> {\n-    patch_map: Vec<Option<TerminatorKind<'tcx>>>,\n+    patch_map: IndexVec<BasicBlock, Option<TerminatorKind<'tcx>>>,\n     new_blocks: Vec<BasicBlockData<'tcx>>,\n     new_statements: Vec<(Location, StatementKind<'tcx>)>,\n     new_temps: Vec<TempDecl<'tcx>>,\n     resume_block: BasicBlock,\n-    next_temp: u32,\n+    next_temp: usize,\n }\n \n impl<'tcx> MirPatch<'tcx> {\n     pub fn new(mir: &Mir<'tcx>) -> Self {\n         let mut result = MirPatch {\n-            patch_map: iter::repeat(None)\n-                .take(mir.basic_blocks.len()).collect(),\n+            patch_map: IndexVec::from_elem(None, &mir.basic_blocks),\n             new_blocks: vec![],\n             new_temps: vec![],\n             new_statements: vec![],\n-            next_temp: mir.temp_decls.len() as u32,\n+            next_temp: mir.temp_decls.len(),\n             resume_block: START_BLOCK\n         };\n \n@@ -83,7 +80,7 @@ impl<'tcx> MirPatch<'tcx> {\n     }\n \n     pub fn is_patched(&self, bb: BasicBlock) -> bool {\n-        self.patch_map[bb.index()].is_some()\n+        self.patch_map[bb].is_some()\n     }\n \n     pub fn terminator_loc(&self, mir: &Mir<'tcx>, bb: BasicBlock) -> Location {\n@@ -97,12 +94,11 @@ impl<'tcx> MirPatch<'tcx> {\n         }\n     }\n \n-    pub fn new_temp(&mut self, ty: Ty<'tcx>) -> u32 {\n+    pub fn new_temp(&mut self, ty: Ty<'tcx>) -> Temp {\n         let index = self.next_temp;\n-        assert!(self.next_temp < u32::MAX);\n         self.next_temp += 1;\n         self.new_temps.push(TempDecl { ty: ty });\n-        index\n+        Temp::new(index as usize)\n     }\n \n     pub fn new_block(&mut self, data: BasicBlockData<'tcx>) -> BasicBlock {\n@@ -114,9 +110,9 @@ impl<'tcx> MirPatch<'tcx> {\n     }\n \n     pub fn patch_terminator(&mut self, block: BasicBlock, new: TerminatorKind<'tcx>) {\n-        assert!(self.patch_map[block.index()].is_none());\n+        assert!(self.patch_map[block].is_none());\n         debug!(\"MirPatch: patch_terminator({:?}, {:?})\", block, new);\n-        self.patch_map[block.index()] = Some(new);\n+        self.patch_map[block] = Some(new);\n     }\n \n     pub fn add_statement(&mut self, loc: Location, stmt: StatementKind<'tcx>) {\n@@ -135,7 +131,7 @@ impl<'tcx> MirPatch<'tcx> {\n                self.new_blocks.len(), mir.basic_blocks.len());\n         mir.basic_blocks.extend(self.new_blocks);\n         mir.temp_decls.extend(self.new_temps);\n-        for (src, patch) in self.patch_map.into_iter().enumerate() {\n+        for (src, patch) in self.patch_map.into_iter_enumerated() {\n             if let Some(patch) = patch {\n                 debug!(\"MirPatch: patching block {:?}\", src);\n                 mir.basic_blocks[src].terminator_mut().kind = patch;"}, {"sha": "671aff97d20aa7ff0afafad2ec2978cc4f1d391d", "filename": "src/librustc_borrowck/indexed_set.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Findexed_set.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -17,13 +17,7 @@ use std::ops::{Deref, DerefMut, Range};\n use bitslice::{BitSlice, Word};\n use bitslice::{bitwise, Union, Subtract};\n \n-/// Represents some newtyped `usize` wrapper.\n-///\n-/// (purpose: avoid mixing indexes for different bitvector domains.)\n-pub trait Idx: 'static {\n-    fn new(usize) -> Self;\n-    fn idx(&self) -> usize;\n-}\n+use rustc_data_structures::indexed_vec::Idx;\n \n /// Represents a set (or packed family of sets), of some element type\n /// E, where each E is identified by some unique index type `T`.\n@@ -120,27 +114,27 @@ impl<T: Idx> IdxSet<T> {\n \n     /// Removes `elem` from the set `self`; returns true iff this changed `self`.\n     pub fn remove(&mut self, elem: &T) -> bool {\n-        self.bits.clear_bit(elem.idx())\n+        self.bits.clear_bit(elem.index())\n     }\n \n     /// Adds `elem` to the set `self`; returns true iff this changed `self`.\n     pub fn add(&mut self, elem: &T) -> bool {\n-        self.bits.set_bit(elem.idx())\n+        self.bits.set_bit(elem.index())\n     }\n \n     pub fn range(&self, elems: &Range<T>) -> &Self {\n-        let elems = elems.start.idx()..elems.end.idx();\n+        let elems = elems.start.index()..elems.end.index();\n         unsafe { Self::from_slice(&self.bits[elems]) }\n     }\n \n     pub fn range_mut(&mut self, elems: &Range<T>) -> &mut Self {\n-        let elems = elems.start.idx()..elems.end.idx();\n+        let elems = elems.start.index()..elems.end.index();\n         unsafe { Self::from_slice_mut(&mut self.bits[elems]) }\n     }\n \n     /// Returns true iff set `self` contains `elem`.\n     pub fn contains(&self, elem: &T) -> bool {\n-        self.bits.get_bit(elem.idx())\n+        self.bits.get_bit(elem.index())\n     }\n \n     pub fn words(&self) -> &[Word] {"}, {"sha": "f3c39bd5fd165ad667ceba2b176598f8c21d8ff9", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -34,6 +34,7 @@\n extern crate graphviz as dot;\n #[macro_use]\n extern crate rustc;\n+extern crate rustc_data_structures;\n extern crate rustc_mir;\n extern crate core; // for NonZero\n "}, {"sha": "b76972112411f84b97dd8b2003eae69f2261a41b", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -0,0 +1,209 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::iter::{self, FromIterator};\n+use std::slice;\n+use std::marker::PhantomData;\n+use std::ops::{Index, IndexMut};\n+use std::fmt;\n+use std::vec;\n+\n+use rustc_serialize as serialize;\n+\n+/// Represents some newtyped `usize` wrapper.\n+///\n+/// (purpose: avoid mixing indexes for different bitvector domains.)\n+pub trait Idx: Copy + 'static {\n+    fn new(usize) -> Self;\n+    fn index(self) -> usize;\n+}\n+\n+impl Idx for usize {\n+    fn new(idx: usize) -> Self { idx }\n+    fn index(self) -> usize { self }\n+}\n+\n+#[derive(Clone)]\n+pub struct IndexVec<I: Idx, T> {\n+    pub raw: Vec<T>,\n+    _marker: PhantomData<Fn(&I)>\n+}\n+\n+impl<I: Idx, T: serialize::Encodable> serialize::Encodable for IndexVec<I, T> {\n+    fn encode<S: serialize::Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        serialize::Encodable::encode(&self.raw, s)\n+    }\n+}\n+\n+impl<I: Idx, T: serialize::Decodable> serialize::Decodable for IndexVec<I, T> {\n+    fn decode<D: serialize::Decoder>(d: &mut D) -> Result<Self, D::Error> {\n+        serialize::Decodable::decode(d).map(|v| {\n+            IndexVec { raw: v, _marker: PhantomData }\n+        })\n+    }\n+}\n+\n+impl<I: Idx, T: fmt::Debug> fmt::Debug for IndexVec<I, T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.raw, fmt)\n+    }\n+}\n+\n+pub type Enumerated<I, J> = iter::Map<iter::Enumerate<J>, IntoIdx<I>>;\n+\n+impl<I: Idx, T> IndexVec<I, T> {\n+    #[inline]\n+    pub fn new() -> Self {\n+        IndexVec { raw: Vec::new(), _marker: PhantomData }\n+    }\n+\n+    #[inline]\n+    pub fn with_capacity(capacity: usize) -> Self {\n+        IndexVec { raw: Vec::with_capacity(capacity), _marker: PhantomData }\n+    }\n+\n+    #[inline]\n+    pub fn from_elem<S>(elem: T, universe: &IndexVec<I, S>) -> Self\n+        where T: Clone\n+    {\n+        IndexVec { raw: vec![elem; universe.len()], _marker: PhantomData }\n+    }\n+\n+    #[inline]\n+    pub fn push(&mut self, d: T) -> I {\n+        let idx = I::new(self.len());\n+        self.raw.push(d);\n+        idx\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.raw.len()\n+    }\n+\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.raw.is_empty()\n+    }\n+\n+    #[inline]\n+    pub fn into_iter(self) -> vec::IntoIter<T> {\n+        self.raw.into_iter()\n+    }\n+\n+    #[inline]\n+    pub fn into_iter_enumerated(self) -> Enumerated<I, vec::IntoIter<T>>\n+    {\n+        self.raw.into_iter().enumerate().map(IntoIdx { _marker: PhantomData })\n+    }\n+\n+    #[inline]\n+    pub fn iter(&self) -> slice::Iter<T> {\n+        self.raw.iter()\n+    }\n+\n+    #[inline]\n+    pub fn iter_enumerated(&self) -> Enumerated<I, slice::Iter<T>>\n+    {\n+        self.raw.iter().enumerate().map(IntoIdx { _marker: PhantomData })\n+    }\n+\n+    #[inline]\n+    pub fn iter_mut(&mut self) -> slice::IterMut<T> {\n+        self.raw.iter_mut()\n+    }\n+\n+    #[inline]\n+    pub fn iter_enumerated_mut(&mut self) -> Enumerated<I, slice::IterMut<T>>\n+    {\n+        self.raw.iter_mut().enumerate().map(IntoIdx { _marker: PhantomData })\n+    }\n+\n+    #[inline]\n+    pub fn last(&self) -> Option<I> {\n+        self.len().checked_sub(1).map(I::new)\n+    }\n+}\n+\n+impl<I: Idx, T> Index<I> for IndexVec<I, T> {\n+    type Output = T;\n+\n+    #[inline]\n+    fn index(&self, index: I) -> &T {\n+        &self.raw[index.index()]\n+    }\n+}\n+\n+impl<I: Idx, T> IndexMut<I> for IndexVec<I, T> {\n+    #[inline]\n+    fn index_mut(&mut self, index: I) -> &mut T {\n+        &mut self.raw[index.index()]\n+    }\n+}\n+\n+impl<I: Idx, T> Extend<T> for IndexVec<I, T> {\n+    #[inline]\n+    fn extend<J: IntoIterator<Item = T>>(&mut self, iter: J) {\n+        self.raw.extend(iter);\n+    }\n+}\n+\n+impl<I: Idx, T> FromIterator<T> for IndexVec<I, T> {\n+    #[inline]\n+    fn from_iter<J>(iter: J) -> Self where J: IntoIterator<Item=T> {\n+        IndexVec { raw: FromIterator::from_iter(iter), _marker: PhantomData }\n+    }\n+}\n+\n+impl<I: Idx, T> IntoIterator for IndexVec<I, T> {\n+    type Item = T;\n+    type IntoIter = vec::IntoIter<T>;\n+\n+    #[inline]\n+    fn into_iter(self) -> vec::IntoIter<T> {\n+        self.raw.into_iter()\n+    }\n+\n+}\n+\n+impl<'a, I: Idx, T> IntoIterator for &'a IndexVec<I, T> {\n+    type Item = &'a T;\n+    type IntoIter = slice::Iter<'a, T>;\n+\n+    #[inline]\n+    fn into_iter(self) -> slice::Iter<'a, T> {\n+        self.raw.iter()\n+    }\n+}\n+\n+impl<'a, I: Idx, T> IntoIterator for &'a mut IndexVec<I, T> {\n+    type Item = &'a mut T;\n+    type IntoIter = slice::IterMut<'a, T>;\n+\n+    #[inline]\n+    fn into_iter(mut self) -> slice::IterMut<'a, T> {\n+        self.raw.iter_mut()\n+    }\n+}\n+\n+pub struct IntoIdx<I: Idx> { _marker: PhantomData<fn(&I)> }\n+impl<I: Idx, T> FnOnce<((usize, T),)> for IntoIdx<I> {\n+    type Output = (I, T);\n+\n+    extern \"rust-call\" fn call_once(self, ((n, t),): ((usize, T),)) -> Self::Output {\n+        (I::new(n), t)\n+    }\n+}\n+\n+impl<I: Idx, T> FnMut<((usize, T),)> for IntoIdx<I> {\n+    extern \"rust-call\" fn call_mut(&mut self, ((n, t),): ((usize, T),)) -> Self::Output {\n+        (I::new(n), t)\n+    }\n+}"}, {"sha": "9370ad016ef1ed604af5d4da75ed2452675df02c", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -41,6 +41,7 @@ extern crate serialize as rustc_serialize; // used by deriving\n pub mod bitvec;\n pub mod graph;\n pub mod ivar;\n+pub mod indexed_vec;\n pub mod obligation_forest;\n pub mod snapshot_map;\n pub mod snapshot_vec;"}, {"sha": "3bd6a7e1dd11821a56b95c8be27a01cdf26e6b85", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -18,17 +18,15 @@ use rustc::mir::repr::*;\n \n impl<'tcx> CFG<'tcx> {\n     pub fn block_data(&self, blk: BasicBlock) -> &BasicBlockData<'tcx> {\n-        &self.basic_blocks[blk.index()]\n+        &self.basic_blocks[blk]\n     }\n \n     pub fn block_data_mut(&mut self, blk: BasicBlock) -> &mut BasicBlockData<'tcx> {\n-        &mut self.basic_blocks[blk.index()]\n+        &mut self.basic_blocks[blk]\n     }\n \n     pub fn start_new_block(&mut self) -> BasicBlock {\n-        let node_index = self.basic_blocks.len();\n-        self.basic_blocks.push(BasicBlockData::new(None));\n-        BasicBlock::new(node_index)\n+        self.basic_blocks.push(BasicBlockData::new(None))\n     }\n \n     pub fn start_new_cleanup_block(&mut self) -> BasicBlock {"}, {"sha": "dd6c9c02f56446e802a792f5490ba0cc1faf504b", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -15,6 +15,8 @@ use build::expr::category::Category;\n use hair::*;\n use rustc::mir::repr::*;\n \n+use rustc_data_structures::indexed_vec::Idx;\n+\n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr`, yielding an lvalue that we can move from etc.\n     pub fn as_lvalue<M>(&mut self,\n@@ -75,7 +77,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 success.and(slice.index(idx))\n             }\n             ExprKind::SelfRef => {\n-                block.and(Lvalue::Arg(0))\n+                block.and(Lvalue::Arg(Arg::new(0)))\n             }\n             ExprKind::VarRef { id } => {\n                 let index = this.var_indices[&id];"}, {"sha": "c0c27ac5943aadc5d8b9e5bff696052600584ceb", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -14,6 +14,7 @@ use std;\n \n use rustc_const_math::{ConstMathErr, Op};\n use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::indexed_vec::Idx;\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::{Category, RvalueFunc};"}, {"sha": "ab102460603dad699a9f83c125130d3cf2324c6b", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -667,25 +667,23 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                        name: Name,\n                        var_id: NodeId,\n                        var_ty: Ty<'tcx>)\n-                       -> u32\n+                       -> Var\n     {\n         debug!(\"declare_binding(var_id={:?}, name={:?}, var_ty={:?}, source_info={:?})\",\n                var_id, name, var_ty, source_info);\n \n-        let index = self.var_decls.len();\n-        self.var_decls.push(VarDecl::<'tcx> {\n+        let var = self.var_decls.push(VarDecl::<'tcx> {\n             source_info: source_info,\n             mutability: mutability,\n             name: name,\n             ty: var_ty.clone(),\n         });\n-        let index = index as u32;\n         let extent = self.extent_of_innermost_scope();\n-        self.schedule_drop(source_info.span, extent, &Lvalue::Var(index), var_ty);\n-        self.var_indices.insert(var_id, index);\n+        self.schedule_drop(source_info.span, extent, &Lvalue::Var(var), var_ty);\n+        self.var_indices.insert(var_id, var);\n \n-        debug!(\"declare_binding: index={:?}\", index);\n+        debug!(\"declare_binding: var={:?}\", var);\n \n-        index\n+        var\n     }\n }"}, {"sha": "0d7a502834881e6988ce2621bf0e8b62337d2fbc", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -18,7 +18,6 @@ use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n \n use rustc::mir::repr::*;\n-use std::u32;\n use syntax::ast;\n use syntax::codemap::Span;\n \n@@ -29,12 +28,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// NB: **No cleanup is scheduled for this temporary.** You should\n     /// call `schedule_drop` once the temporary is initialized.\n     pub fn temp(&mut self, ty: Ty<'tcx>) -> Lvalue<'tcx> {\n-        let index = self.temp_decls.len();\n-        self.temp_decls.push(TempDecl { ty: ty });\n-        assert!(index < (u32::MAX) as usize);\n-        let lvalue = Lvalue::Temp(index as u32);\n+        let temp = self.temp_decls.push(TempDecl { ty: ty });\n+        let lvalue = Lvalue::Temp(temp);\n         debug!(\"temp: created temp {:?} with type {:?}\",\n-               lvalue, self.temp_decls.last().unwrap().ty);\n+               lvalue, self.temp_decls[temp].ty);\n         lvalue\n     }\n "}, {"sha": "dce64d2f3b7a9ed0f821fe64c926b16a97944142", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 28, "deletions": 44, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -12,15 +12,17 @@ use hair::cx::Cx;\n use rustc::middle::region::{CodeExtent, CodeExtentData, ROOT_CODE_EXTENT};\n use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc::util::nodemap::NodeMap;\n use rustc::hir;\n-use std::ops::{Index, IndexMut};\n-use std::u32;\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token::keywords;\n \n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+\n+use std::u32;\n+\n pub struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     hir: Cx<'a, 'gcx, 'tcx>,\n     cfg: CFG<'tcx>,\n@@ -36,20 +38,20 @@ pub struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     ///  but these are liable to get out of date once optimization\n     ///  begins. They are also hopefully temporary, and will be\n     ///  no longer needed when we adopt graph-based regions.\n-    scope_auxiliary: ScopeAuxiliaryVec,\n+    scope_auxiliary: IndexVec<ScopeId, ScopeAuxiliary>,\n \n     /// the current set of loops; see the `scope` module for more\n     /// details\n     loop_scopes: Vec<scope::LoopScope>,\n \n     /// the vector of all scopes that we have created thus far;\n     /// we track this for debuginfo later\n-    visibility_scopes: Vec<VisibilityScopeData>,\n+    visibility_scopes: IndexVec<VisibilityScope, VisibilityScopeData>,\n     visibility_scope: VisibilityScope,\n \n-    var_decls: Vec<VarDecl<'tcx>>,\n-    var_indices: FnvHashMap<ast::NodeId, u32>,\n-    temp_decls: Vec<TempDecl<'tcx>>,\n+    var_decls: IndexVec<Var, VarDecl<'tcx>>,\n+    var_indices: NodeMap<Var>,\n+    temp_decls: IndexVec<Temp, TempDecl<'tcx>>,\n     unit_temp: Option<Lvalue<'tcx>>,\n \n     /// cached block with the RESUME terminator; this is created\n@@ -60,19 +62,19 @@ pub struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n }\n \n struct CFG<'tcx> {\n-    basic_blocks: Vec<BasicBlockData<'tcx>>,\n+    basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct ScopeId(u32);\n \n-impl ScopeId {\n-    pub fn new(index: usize) -> ScopeId {\n+impl Idx for ScopeId {\n+    fn new(index: usize) -> ScopeId {\n         assert!(index < (u32::MAX as usize));\n         ScopeId(index as u32)\n     }\n \n-    pub fn index(self) -> usize {\n+    fn index(self) -> usize {\n         self.0 as usize\n     }\n }\n@@ -109,25 +111,7 @@ pub struct Location {\n     pub statement_index: usize,\n }\n \n-pub struct ScopeAuxiliaryVec {\n-    pub vec: Vec<ScopeAuxiliary>\n-}\n-\n-impl Index<ScopeId> for ScopeAuxiliaryVec {\n-    type Output = ScopeAuxiliary;\n-\n-    #[inline]\n-    fn index(&self, index: ScopeId) -> &ScopeAuxiliary {\n-        &self.vec[index.index()]\n-    }\n-}\n-\n-impl IndexMut<ScopeId> for ScopeAuxiliaryVec {\n-    #[inline]\n-    fn index_mut(&mut self, index: ScopeId) -> &mut ScopeAuxiliary {\n-        &mut self.vec[index.index()]\n-    }\n-}\n+pub type ScopeAuxiliaryVec = IndexVec<ScopeId, ScopeAuxiliary>;\n \n ///////////////////////////////////////////////////////////////////////////\n /// The `BlockAnd` \"monad\" packages up the new basic block along with a\n@@ -213,8 +197,8 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     match tcx.node_id_to_type(fn_id).sty {\n         ty::TyFnDef(_, _, f) if f.abi == Abi::RustCall => {\n             // RustCall pseudo-ABI untuples the last argument.\n-            if let Some(arg_decl) = arg_decls.last_mut() {\n-                arg_decl.spread = true;\n+            if let Some(last_arg) = arg_decls.last() {\n+                arg_decls[last_arg].spread = true;\n             }\n         }\n         _ => {}\n@@ -271,23 +255,23 @@ pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     });\n \n     let ty = tcx.expr_ty_adjusted(ast_expr);\n-    builder.finish(vec![], vec![], ty::FnConverging(ty))\n+    builder.finish(vec![], IndexVec::new(), ty::FnConverging(ty))\n }\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn new(hir: Cx<'a, 'gcx, 'tcx>, span: Span) -> Builder<'a, 'gcx, 'tcx> {\n         let mut builder = Builder {\n             hir: hir,\n-            cfg: CFG { basic_blocks: vec![] },\n+            cfg: CFG { basic_blocks: IndexVec::new() },\n             fn_span: span,\n             scopes: vec![],\n-            visibility_scopes: vec![],\n+            visibility_scopes: IndexVec::new(),\n             visibility_scope: ARGUMENT_VISIBILITY_SCOPE,\n-            scope_auxiliary: ScopeAuxiliaryVec { vec: vec![] },\n+            scope_auxiliary: IndexVec::new(),\n             loop_scopes: vec![],\n-            temp_decls: vec![],\n-            var_decls: vec![],\n-            var_indices: FnvHashMap(),\n+            temp_decls: IndexVec::new(),\n+            var_decls: IndexVec::new(),\n+            var_indices: NodeMap(),\n             unit_temp: None,\n             cached_resume_block: None,\n             cached_return_block: None\n@@ -302,7 +286,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn finish(self,\n               upvar_decls: Vec<UpvarDecl>,\n-              arg_decls: Vec<ArgDecl<'tcx>>,\n+              arg_decls: IndexVec<Arg, ArgDecl<'tcx>>,\n               return_ty: ty::FnOutput<'tcx>)\n               -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n         for (index, block) in self.cfg.basic_blocks.iter().enumerate() {\n@@ -314,7 +298,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         (Mir {\n             basic_blocks: self.cfg.basic_blocks,\n             visibility_scopes: self.visibility_scopes,\n-            promoted: vec![],\n+            promoted: IndexVec::new(),\n             var_decls: self.var_decls,\n             arg_decls: arg_decls,\n             temp_decls: self.temp_decls,\n@@ -330,13 +314,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         arguments: A,\n                         argument_extent: CodeExtent,\n                         ast_block: &'gcx hir::Block)\n-                        -> BlockAnd<Vec<ArgDecl<'tcx>>>\n+                        -> BlockAnd<IndexVec<Arg, ArgDecl<'tcx>>>\n         where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n     {\n         // to start, translate the argument patterns and collect the argument types.\n         let mut scope = None;\n         let arg_decls = arguments.enumerate().map(|(index, (ty, pattern))| {\n-            let lvalue = Lvalue::Arg(index as u32);\n+            let lvalue = Lvalue::Arg(Arg::new(index));\n             if let Some(pattern) = pattern {\n                 let pattern = self.hir.irrefutable_pat(pattern);\n                 scope = self.declare_bindings(scope, ast_block.span, &pattern);"}, {"sha": "2c34b13671b0c44725495f85663996f2fa654d5e", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -96,6 +96,7 @@ use syntax::codemap::{Span, DUMMY_SP};\n use syntax::parse::token::intern_and_get_ident;\n use rustc::middle::const_val::ConstVal;\n use rustc_const_math::ConstInt;\n+use rustc_data_structures::indexed_vec::Idx;\n \n pub struct Scope<'tcx> {\n     /// the scope-id within the scope_auxiliary\n@@ -264,7 +265,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// wrapper maybe preferable.\n     pub fn push_scope(&mut self, extent: CodeExtent, entry: BasicBlock) {\n         debug!(\"push_scope({:?})\", extent);\n-        let id = ScopeId::new(self.scope_auxiliary.vec.len());\n+        let id = ScopeId::new(self.scope_auxiliary.len());\n         let vis_scope = self.visibility_scope;\n         self.scopes.push(Scope {\n             id: id,\n@@ -274,7 +275,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             free: None,\n             cached_block: None,\n         });\n-        self.scope_auxiliary.vec.push(ScopeAuxiliary {\n+        self.scope_auxiliary.push(ScopeAuxiliary {\n             extent: extent,\n             dom: self.cfg.current_location(entry),\n             postdoms: vec![]"}, {"sha": "17bd41a81d223c2b390d2d6b719458c6f48e9857", "filename": "src/librustc_mir/graphviz.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -15,6 +15,8 @@ use std::fmt::Debug;\n use std::io::{self, Write};\n use syntax::ast::NodeId;\n \n+use rustc_data_structures::indexed_vec::Idx;\n+\n /// Write a graphviz DOT graph of a list of MIRs.\n pub fn write_mir_graphviz<'a, 'b, 'tcx, W, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                                               iter: I, w: &mut W)\n@@ -130,7 +132,7 @@ fn write_graph_label<'a, 'tcx, W: Write>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         if i > 0 {\n             write!(w, \", \")?;\n         }\n-        write!(w, \"{:?}: {}\", Lvalue::Arg(i as u32), escape(&arg.ty))?;\n+        write!(w, \"{:?}: {}\", Lvalue::Arg(Arg::new(i)), escape(&arg.ty))?;\n     }\n \n     write!(w, \") -&gt; \")?;\n@@ -150,13 +152,13 @@ fn write_graph_label<'a, 'tcx, W: Write>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             write!(w, \"mut \")?;\n         }\n         write!(w, r#\"{:?}: {}; // {}<br align=\"left\"/>\"#,\n-               Lvalue::Var(i as u32), escape(&var.ty), var.name)?;\n+               Lvalue::Var(Var::new(i)), escape(&var.ty), var.name)?;\n     }\n \n     // Compiler-introduced temporary types.\n     for (i, temp) in mir.temp_decls.iter().enumerate() {\n         write!(w, r#\"let mut {:?}: {};<br align=\"left\"/>\"#,\n-               Lvalue::Temp(i as u32), escape(&temp.ty))?;\n+               Lvalue::Temp(Temp::new(i)), escape(&temp.ty))?;\n     }\n \n     writeln!(w, \">;\")"}, {"sha": "cebdaad13db48c2bed1df5d7171c4a5152aa1e98", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -10,6 +10,7 @@\n \n use hair::*;\n use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::indexed_vec::Idx;\n use rustc_const_math::ConstInt;\n use hair::cx::Cx;\n use hair::cx::block;"}, {"sha": "81b098281d6a19c578b84fac946526e7685c55b6", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -21,6 +21,7 @@ use rustc::mir::transform::MirSource;\n \n use rustc::middle::const_val::ConstVal;\n use rustc_const_eval as const_eval;\n+use rustc_data_structures::indexed_vec::Idx;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::FnKind;\n use rustc::hir::map::blocks::FnLikeNode;"}, {"sha": "d527936c8993f70edb49bf7941a512e8464be734", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -11,6 +11,7 @@\n use hair::*;\n use hair::cx::Cx;\n use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::indexed_vec::Idx;\n use rustc_const_eval as const_eval;\n use rustc::hir::def::Def;\n use rustc::hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const};"}, {"sha": "b913f2ae6cf1baaee268d26a65e36ee2c30244a5", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -14,6 +14,7 @@ use rustc::mir::repr::*;\n use rustc::mir::transform::MirSource;\n use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::indexed_vec::{Idx};\n use std::fmt::Display;\n use std::fs;\n use std::io::{self, Write};\n@@ -111,9 +112,7 @@ fn scope_entry_exit_annotations(auxiliary: Option<&ScopeAuxiliaryVec>)\n     // compute scope/entry exit annotations\n     let mut annotations = FnvHashMap();\n     if let Some(auxiliary) = auxiliary {\n-        for (index, auxiliary) in auxiliary.vec.iter().enumerate() {\n-            let scope_id = ScopeId::new(index);\n-\n+        for (scope_id, auxiliary) in auxiliary.iter_enumerated() {\n             annotations.entry(auxiliary.dom)\n                        .or_insert(vec![])\n                        .push(Annotation::EnterScope(scope_id));\n@@ -218,7 +217,7 @@ fn write_scope_tree(tcx: TyCtxt,\n         writeln!(w, \"{0:1$}scope {2} {{\", \"\", indent, child.index())?;\n \n         // User variable types (including the user's name in a comment).\n-        for (i, var) in mir.var_decls.iter().enumerate() {\n+        for (id, var) in mir.var_decls.iter_enumerated() {\n             // Skip if not declared in this scope.\n             if var.source_info.scope != child {\n                 continue;\n@@ -235,7 +234,7 @@ fn write_scope_tree(tcx: TyCtxt,\n                                        INDENT,\n                                        indent,\n                                        mut_str,\n-                                       Lvalue::Var(i as u32),\n+                                       id,\n                                        var.ty);\n             writeln!(w, \"{0:1$} // \\\"{2}\\\" in {3}\",\n                      indented_var,\n@@ -297,11 +296,11 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n         write!(w, \"(\")?;\n \n         // fn argument types.\n-        for (i, arg) in mir.arg_decls.iter().enumerate() {\n-            if i > 0 {\n+        for (i, arg) in mir.arg_decls.iter_enumerated() {\n+            if i.index() != 0 {\n                 write!(w, \", \")?;\n             }\n-            write!(w, \"{:?}: {}\", Lvalue::Arg(i as u32), arg.ty)?;\n+            write!(w, \"{:?}: {}\", Lvalue::Arg(i), arg.ty)?;\n         }\n \n         write!(w, \") -> \")?;\n@@ -319,8 +318,8 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n \n fn write_mir_decls(mir: &Mir, w: &mut Write) -> io::Result<()> {\n     // Compiler-introduced temporary types.\n-    for (i, temp) in mir.temp_decls.iter().enumerate() {\n-        writeln!(w, \"{}let mut {:?}: {};\", INDENT, Lvalue::Temp(i as u32), temp.ty)?;\n+    for (id, temp) in mir.temp_decls.iter_enumerated() {\n+        writeln!(w, \"{}let mut {:?}: {};\", INDENT, id, temp.ty)?;\n     }\n \n     // Wrote any declaration? Add an empty line before the first block is printed."}, {"sha": "f829865255d95f0a1edf519b66eb5b192408b2b4", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -12,6 +12,8 @@ use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc::mir::traversal;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+\n use pretty;\n \n pub struct AddCallGuards;\n@@ -38,13 +40,13 @@ pub struct AddCallGuards;\n \n impl<'tcx> MirPass<'tcx> for AddCallGuards {\n     fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n-        let mut pred_count = vec![0u32; mir.basic_blocks.len()];\n+        let mut pred_count = IndexVec::from_elem(0u32, &mir.basic_blocks);\n \n         // Build the precedecessor map for the MIR\n         for (_, data) in traversal::preorder(mir) {\n             if let Some(ref term) = data.terminator {\n                 for &tgt in term.successors().iter() {\n-                    pred_count[tgt.index()] += 1;\n+                    pred_count[tgt] += 1;\n                 }\n             }\n         }\n@@ -65,7 +67,7 @@ impl<'tcx> MirPass<'tcx> for AddCallGuards {\n                         cleanup: Some(_),\n                         ..\n                     }, source_info\n-                }) if pred_count[destination.index()] > 1 => {\n+                }) if pred_count[*destination] > 1 => {\n                     // It's a critical edge, break it\n                     let call_guard = BasicBlockData {\n                         statements: vec![],\n@@ -88,7 +90,7 @@ impl<'tcx> MirPass<'tcx> for AddCallGuards {\n         pretty::dump_mir(tcx, \"break_cleanup_edges\", &0, src, mir, None);\n         debug!(\"Broke {} N edges\", new_blocks.len());\n \n-        mir.basic_blocks.extend_from_slice(&new_blocks);\n+        mir.basic_blocks.extend(new_blocks);\n     }\n }\n "}, {"sha": "4d6838052dec7f7ff759796fc14c10c2b727bcd0", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -30,6 +30,8 @@ use syntax::codemap::Span;\n \n use build::Location;\n \n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+\n use std::mem;\n \n /// State of a temporary during collection and promotion.\n@@ -74,7 +76,7 @@ pub enum Candidate {\n }\n \n struct TempCollector {\n-    temps: Vec<TempState>,\n+    temps: IndexVec<Temp, TempState>,\n     location: Location,\n     span: Span\n }\n@@ -89,7 +91,7 @@ impl<'tcx> Visitor<'tcx> for TempCollector {\n                 return;\n             }\n \n-            let temp = &mut self.temps[index as usize];\n+            let temp = &mut self.temps[index];\n             if *temp == TempState::Undefined {\n                 match context {\n                     LvalueContext::Store |\n@@ -134,9 +136,9 @@ impl<'tcx> Visitor<'tcx> for TempCollector {\n     }\n }\n \n-pub fn collect_temps(mir: &Mir, rpo: &mut ReversePostorder) -> Vec<TempState> {\n+pub fn collect_temps(mir: &Mir, rpo: &mut ReversePostorder) -> IndexVec<Temp, TempState> {\n     let mut collector = TempCollector {\n-        temps: vec![TempState::Undefined; mir.temp_decls.len()],\n+        temps: IndexVec::from_elem(TempState::Undefined, &mir.temp_decls),\n         location: Location {\n             block: START_BLOCK,\n             statement_index: 0\n@@ -152,7 +154,7 @@ pub fn collect_temps(mir: &Mir, rpo: &mut ReversePostorder) -> Vec<TempState> {\n struct Promoter<'a, 'tcx: 'a> {\n     source: &'a mut Mir<'tcx>,\n     promoted: Mir<'tcx>,\n-    temps: &'a mut Vec<TempState>,\n+    temps: &'a mut IndexVec<Temp, TempState>,\n \n     /// If true, all nested temps are also kept in the\n     /// source MIR, not moved to the promoted MIR.\n@@ -161,7 +163,6 @@ struct Promoter<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     fn new_block(&mut self) -> BasicBlock {\n-        let index = self.promoted.basic_blocks.len();\n         self.promoted.basic_blocks.push(BasicBlockData {\n             statements: vec![],\n             terminator: Some(Terminator {\n@@ -172,12 +173,12 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 kind: TerminatorKind::Return\n             }),\n             is_cleanup: false\n-        });\n-        BasicBlock::new(index)\n+        })\n     }\n \n     fn assign(&mut self, dest: Lvalue<'tcx>, rvalue: Rvalue<'tcx>, span: Span) {\n-        let data = self.promoted.basic_blocks.last_mut().unwrap();\n+        let last = self.promoted.basic_blocks.last().unwrap();\n+        let data = &mut self.promoted.basic_blocks[last];\n         data.statements.push(Statement {\n             source_info: SourceInfo {\n                 span: span,\n@@ -189,10 +190,9 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n \n     /// Copy the initialization of this temp to the\n     /// promoted MIR, recursing through temps.\n-    fn promote_temp(&mut self, index: u32) -> u32 {\n-        let index = index as usize;\n+    fn promote_temp(&mut self, temp: Temp) -> Temp {\n         let old_keep_original = self.keep_original;\n-        let (bb, stmt_idx) = match self.temps[index] {\n+        let (bb, stmt_idx) = match self.temps[temp] {\n             TempState::Defined {\n                 location: Location { block, statement_index },\n                 uses\n@@ -202,13 +202,13 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 }\n                 (block, statement_index)\n             }\n-            temp =>  {\n-                span_bug!(self.promoted.span, \"tmp{} not promotable: {:?}\",\n-                          index, temp);\n+            state =>  {\n+                span_bug!(self.promoted.span, \"{:?} not promotable: {:?}\",\n+                          temp, state);\n             }\n         };\n         if !self.keep_original {\n-            self.temps[index] = TempState::PromotedOut;\n+            self.temps[temp] = TempState::PromotedOut;\n         }\n \n         let no_stmts = self.source[bb].statements.len();\n@@ -260,22 +260,20 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             self.visit_terminator_kind(bb, call.as_mut().unwrap());\n         }\n \n-        let new_index = self.promoted.temp_decls.len() as u32;\n-        let new_temp = Lvalue::Temp(new_index);\n-        self.promoted.temp_decls.push(TempDecl {\n-            ty: self.source.temp_decls[index].ty\n+        let new_temp = self.promoted.temp_decls.push(TempDecl {\n+            ty: self.source.temp_decls[temp].ty\n         });\n \n         // Inject the Rvalue or Call into the promoted MIR.\n         if stmt_idx < no_stmts {\n-            self.assign(new_temp, rvalue.unwrap(), source_info.span);\n+            self.assign(Lvalue::Temp(new_temp), rvalue.unwrap(), source_info.span);\n         } else {\n-            let last = self.promoted.basic_blocks.len() - 1;\n+            let last = self.promoted.basic_blocks.last().unwrap();\n             let new_target = self.new_block();\n             let mut call = call.unwrap();\n             match call {\n                 TerminatorKind::Call { ref mut destination, ..}  => {\n-                    *destination = Some((new_temp, new_target));\n+                    *destination = Some((Lvalue::Temp(new_temp), new_target));\n                 }\n                 _ => bug!()\n             }\n@@ -287,7 +285,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         // Restore the old duplication state.\n         self.keep_original = old_keep_original;\n \n-        new_index\n+        new_temp\n     }\n \n     fn promote_candidate(mut self, candidate: Candidate) {\n@@ -296,7 +294,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             span: span,\n             ty: self.promoted.return_ty.unwrap(),\n             literal: Literal::Promoted {\n-                index: self.source.promoted.len()\n+                index: Promoted::new(self.source.promoted.len())\n             }\n         });\n         let mut rvalue = match candidate {\n@@ -325,16 +323,16 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n /// Replaces all temporaries with their promoted counterparts.\n impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n     fn visit_lvalue(&mut self, lvalue: &mut Lvalue<'tcx>, context: LvalueContext) {\n-        if let Lvalue::Temp(ref mut index) = *lvalue {\n-            *index = self.promote_temp(*index);\n+        if let Lvalue::Temp(ref mut temp) = *lvalue {\n+            *temp = self.promote_temp(*temp);\n         }\n         self.super_lvalue(lvalue, context);\n     }\n }\n \n pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    mut temps: Vec<TempState>,\n+                                    mut temps: IndexVec<Temp, TempState>,\n                                     candidates: Vec<Candidate>) {\n     // Visit candidates in reverse, in case they're nested.\n     for candidate in candidates.into_iter().rev() {\n@@ -343,7 +341,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                 let statement = &mir[bb].statements[stmt_idx];\n                 let StatementKind::Assign(ref dest, _) = statement.kind;\n                 if let Lvalue::Temp(index) = *dest {\n-                    if temps[index as usize] == TempState::PromotedOut {\n+                    if temps[index] == TempState::PromotedOut {\n                         // Already promoted.\n                         continue;\n                     }\n@@ -368,16 +366,16 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n         let mut promoter = Promoter {\n             source: mir,\n             promoted: Mir {\n-                basic_blocks: vec![],\n-                visibility_scopes: vec![VisibilityScopeData {\n+                basic_blocks: IndexVec::new(),\n+                visibility_scopes: Some(VisibilityScopeData {\n                     span: span,\n                     parent_scope: None\n-                }],\n-                promoted: vec![],\n+                }).into_iter().collect(),\n+                promoted: IndexVec::new(),\n                 return_ty: ty::FnConverging(ty),\n-                var_decls: vec![],\n-                arg_decls: vec![],\n-                temp_decls: vec![],\n+                var_decls: IndexVec::new(),\n+                arg_decls: IndexVec::new(),\n+                temp_decls: IndexVec::new(),\n                 upvar_decls: vec![],\n                 span: span\n             },\n@@ -389,7 +387,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n     }\n \n     // Eliminate assignments to, and drops of promoted temps.\n-    let promoted = |index: u32| temps[index as usize] == TempState::PromotedOut;\n+    let promoted = |index: Temp| temps[index] == TempState::PromotedOut;\n     for block in &mut mir.basic_blocks {\n         block.statements.retain(|statement| {\n             match statement.kind {"}, {"sha": "3272d7276d5f109d80872bd2c83f684ab84eadb3", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -15,6 +15,7 @@\n //! diagnostics as to why a constant rvalue wasn't promoted.\n \n use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::FnKind;\n@@ -141,12 +142,12 @@ struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     param_env: ty::ParameterEnvironment<'tcx>,\n     qualif_map: &'a mut DefIdMap<Qualif>,\n     mir_map: Option<&'a MirMap<'tcx>>,\n-    temp_qualif: Vec<Option<Qualif>>,\n+    temp_qualif: IndexVec<Temp, Option<Qualif>>,\n     return_qualif: Option<Qualif>,\n     qualif: Qualif,\n     const_fn_arg_vars: BitVector,\n     location: Location,\n-    temp_promotion_state: Vec<TempState>,\n+    temp_promotion_state: IndexVec<Temp, TempState>,\n     promotion_candidates: Vec<Candidate>\n }\n \n@@ -172,7 +173,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             param_env: param_env,\n             qualif_map: qualif_map,\n             mir_map: mir_map,\n-            temp_qualif: vec![None; mir.temp_decls.len()],\n+            temp_qualif: IndexVec::from_elem(None, &mir.temp_decls),\n             return_qualif: None,\n             qualif: Qualif::empty(),\n             const_fn_arg_vars: BitVector::new(mir.var_decls.len()),\n@@ -301,22 +302,22 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n         // Only handle promotable temps in non-const functions.\n         if self.mode == Mode::Fn {\n             if let Lvalue::Temp(index) = *dest {\n-                if self.temp_promotion_state[index as usize].is_promotable() {\n-                    store(&mut self.temp_qualif[index as usize]);\n+                if self.temp_promotion_state[index].is_promotable() {\n+                    store(&mut self.temp_qualif[index]);\n                 }\n             }\n             return;\n         }\n \n         match *dest {\n-            Lvalue::Temp(index) => store(&mut self.temp_qualif[index as usize]),\n+            Lvalue::Temp(index) => store(&mut self.temp_qualif[index]),\n             Lvalue::ReturnPointer => store(&mut self.return_qualif),\n \n             Lvalue::Projection(box Projection {\n                 base: Lvalue::Temp(index),\n                 elem: ProjectionElem::Deref\n-            }) if self.mir.temp_decls[index as usize].ty.is_unique()\n-               && self.temp_qualif[index as usize].map_or(false, |qualif| {\n+            }) if self.mir.temp_decls[index].ty.is_unique()\n+               && self.temp_qualif[index].map_or(false, |qualif| {\n                     qualif.intersects(Qualif::NOT_CONST)\n                }) => {\n                 // Part of `box expr`, we should've errored\n@@ -366,7 +367,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                 TerminatorKind::Return => {\n                     // Check for unused values. This usually means\n                     // there are extra statements in the AST.\n-                    for i in 0..mir.temp_decls.len() {\n+                    for (i, _) in mir.temp_decls.iter_enumerated() {\n                         if self.temp_qualif[i].is_none() {\n                             continue;\n                         }\n@@ -393,7 +394,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                     self.qualif = Qualif::NOT_CONST;\n                     for index in 0..mir.var_decls.len() {\n                         if !self.const_fn_arg_vars.contains(index) {\n-                            self.assign(&Lvalue::Var(index as u32));\n+                            self.assign(&Lvalue::Var(Var::new(index)));\n                         }\n                     }\n \n@@ -448,11 +449,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 self.add(Qualif::NOT_CONST);\n             }\n             Lvalue::Temp(index) => {\n-                if !self.temp_promotion_state[index as usize].is_promotable() {\n+                if !self.temp_promotion_state[index].is_promotable() {\n                     self.add(Qualif::NOT_PROMOTABLE);\n                 }\n \n-                if let Some(qualif) = self.temp_qualif[index as usize] {\n+                if let Some(qualif) = self.temp_qualif[index] {\n                     self.add(qualif);\n                 } else {\n                     self.not_const();\n@@ -822,15 +823,15 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n         // Check the allowed const fn argument forms.\n         if let (Mode::ConstFn, &Lvalue::Var(index)) = (self.mode, dest) {\n-            if self.const_fn_arg_vars.insert(index as usize) {\n+            if self.const_fn_arg_vars.insert(index.index()) {\n                 // Direct use of an argument is permitted.\n                 if let Rvalue::Use(Operand::Consume(Lvalue::Arg(_))) = *rvalue {\n                     return;\n                 }\n \n                 // Avoid a generic error for other uses of arguments.\n                 if self.qualif.intersects(Qualif::FN_ARGUMENT) {\n-                    let decl = &self.mir.var_decls[index as usize];\n+                    let decl = &self.mir.var_decls[index];\n                     span_err!(self.tcx.sess, decl.source_info.span, E0022,\n                               \"arguments of constant functions can only \\\n                                be immutable by-value bindings\");"}, {"sha": "a65e9b8c414d6a365e6b2abb5a2a63dff56da14a", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -33,6 +33,7 @@\n \n \n use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n@@ -59,19 +60,19 @@ impl<'l, 'tcx> MirPass<'tcx> for SimplifyCfg<'l> {\n         pretty::dump_mir(tcx, \"simplify_cfg\", &format!(\"{}-after\", self.label), src, mir, None);\n \n         // FIXME: Should probably be moved into some kind of pass manager\n-        mir.basic_blocks.shrink_to_fit();\n+        mir.basic_blocks.raw.shrink_to_fit();\n     }\n }\n \n impl<'l> Pass for SimplifyCfg<'l> {}\n \n fn merge_consecutive_blocks(mir: &mut Mir) {\n     // Build the precedecessor map for the MIR\n-    let mut pred_count = vec![0u32; mir.basic_blocks.len()];\n+    let mut pred_count = IndexVec::from_elem(0u32, &mir.basic_blocks);\n     for (_, data) in traversal::preorder(mir) {\n         if let Some(ref term) = data.terminator {\n             for &tgt in term.successors().iter() {\n-                pred_count[tgt.index()] += 1;\n+                pred_count[tgt] += 1;\n             }\n         }\n     }\n@@ -100,10 +101,10 @@ fn merge_consecutive_blocks(mir: &mut Mir) {\n                         TerminatorKind::Goto { target: new_target } if num_insts == 0 => {\n                             inner_change = true;\n                             terminator.kind = TerminatorKind::Goto { target: new_target };\n-                            pred_count[target.index()] -= 1;\n-                            pred_count[new_target.index()] += 1;\n+                            pred_count[target] -= 1;\n+                            pred_count[new_target] += 1;\n                         }\n-                        _ if pred_count[target.index()] == 1 => {\n+                        _ if pred_count[target] == 1 => {\n                             inner_change = true;\n                             let mut stmts = Vec::new();\n                             {\n@@ -126,8 +127,8 @@ fn merge_consecutive_blocks(mir: &mut Mir) {\n                     };\n                     if *target != new_target {\n                         inner_change = true;\n-                        pred_count[target.index()] -= 1;\n-                        pred_count[new_target.index()] += 1;\n+                        pred_count[*target] -= 1;\n+                        pred_count[new_target] += 1;\n                         *target = new_target;\n                     }\n                 }\n@@ -234,18 +235,18 @@ fn remove_dead_blocks(mir: &mut Mir) {\n \n     let num_blocks = mir.basic_blocks.len();\n \n-    let mut replacements: Vec<_> = (0..num_blocks).map(BasicBlock::new).collect();\n+    let mut replacements : Vec<_> = (0..num_blocks).map(BasicBlock::new).collect();\n     let mut used_blocks = 0;\n     for alive_index in seen.iter() {\n         replacements[alive_index] = BasicBlock::new(used_blocks);\n         if alive_index != used_blocks {\n             // Swap the next alive block data with the current available slot. Since alive_index is\n             // non-decreasing this is a valid operation.\n-            mir.basic_blocks.swap(alive_index, used_blocks);\n+            mir.basic_blocks.raw.swap(alive_index, used_blocks);\n         }\n         used_blocks += 1;\n     }\n-    mir.basic_blocks.truncate(used_blocks);\n+    mir.basic_blocks.raw.truncate(used_blocks);\n \n     for bb in mir.all_basic_blocks() {\n         for target in mir.basic_block_data_mut(bb).terminator_mut().successors_mut() {"}, {"sha": "ab402a7f8813cd9a946be031850e5a30ad0597e5", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -24,6 +24,8 @@ use rustc::mir::visit::{self, Visitor};\n use std::fmt;\n use syntax::codemap::{Span, DUMMY_SP};\n \n+use rustc_data_structures::indexed_vec::Idx;\n+\n macro_rules! span_mirbug {\n     ($context:expr, $elem:expr, $($message:tt)*) => ({\n         $context.tcx().sess.span_warn(\n@@ -129,11 +131,9 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     fn sanitize_lvalue(&mut self, lvalue: &Lvalue<'tcx>) -> LvalueTy<'tcx> {\n         debug!(\"sanitize_lvalue: {:?}\", lvalue);\n         match *lvalue {\n-            Lvalue::Var(index) => LvalueTy::Ty { ty: self.mir.var_decls[index as usize].ty },\n-            Lvalue::Temp(index) =>\n-                LvalueTy::Ty { ty: self.mir.temp_decls[index as usize].ty },\n-            Lvalue::Arg(index) =>\n-                LvalueTy::Ty { ty: self.mir.arg_decls[index as usize].ty },\n+            Lvalue::Var(index) => LvalueTy::Ty { ty: self.mir.var_decls[index].ty },\n+            Lvalue::Temp(index) => LvalueTy::Ty { ty: self.mir.temp_decls[index].ty },\n+            Lvalue::Arg(index) => LvalueTy::Ty { ty: self.mir.arg_decls[index].ty },\n             Lvalue::Static(def_id) =>\n                 LvalueTy::Ty { ty: self.tcx().lookup_item_type(def_id).ty },\n             Lvalue::ReturnPointer => {"}, {"sha": "f1d9e2c5a571052f3d1fed4cabbb8aeb91b52f3b", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -26,6 +26,7 @@ use syntax::codemap::{Span, Pos};\n use syntax::{ast, codemap};\n \n use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::hir::{self, PatKind};\n \n // This procedure builds the *scope map* for a given function, which maps any\n@@ -69,9 +70,9 @@ pub fn create_scope_map(cx: &CrateContext,\n \n /// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n /// If debuginfo is disabled, the returned vector is empty.\n-pub fn create_mir_scopes(fcx: &FunctionContext) -> Vec<DIScope> {\n+pub fn create_mir_scopes(fcx: &FunctionContext) -> IndexVec<VisibilityScope, DIScope> {\n     let mir = fcx.mir.clone().expect(\"create_mir_scopes: missing MIR for fn\");\n-    let mut scopes = vec![ptr::null_mut(); mir.visibility_scopes.len()];\n+    let mut scopes = IndexVec::from_elem(ptr::null_mut(), &mir.visibility_scopes);\n \n     let fn_metadata = match fcx.debug_context {\n         FunctionDebugContext::RegularContext(box ref data) => data.fn_metadata,\n@@ -101,38 +102,37 @@ fn make_mir_scope(ccx: &CrateContext,\n                   has_variables: &BitVector,\n                   fn_metadata: DISubprogram,\n                   scope: VisibilityScope,\n-                  scopes: &mut [DIScope]) {\n-    let idx = scope.index();\n-    if !scopes[idx].is_null() {\n+                  scopes: &mut IndexVec<VisibilityScope, DIScope>) {\n+    if !scopes[scope].is_null() {\n         return;\n     }\n \n     let scope_data = &mir.visibility_scopes[scope];\n     let parent_scope = if let Some(parent) = scope_data.parent_scope {\n         make_mir_scope(ccx, mir, has_variables, fn_metadata, parent, scopes);\n-        scopes[parent.index()]\n+        scopes[parent]\n     } else {\n         // The root is the function itself.\n-        scopes[idx] = fn_metadata;\n+        scopes[scope] = fn_metadata;\n         return;\n     };\n \n-    if !has_variables.contains(idx) {\n+    if !has_variables.contains(scope.index()) {\n         // Do not create a DIScope if there are no variables\n         // defined in this MIR Scope, to avoid debuginfo bloat.\n \n         // However, we don't skip creating a nested scope if\n         // our parent is the root, because we might want to\n         // put arguments in the root and not have shadowing.\n         if parent_scope != fn_metadata {\n-            scopes[idx] = parent_scope;\n+            scopes[scope] = parent_scope;\n             return;\n         }\n     }\n \n     let loc = span_start(ccx, scope_data.span);\n     let file_metadata = file_metadata(ccx, &loc.file.name);\n-    scopes[idx] = unsafe {\n+    scopes[scope] = unsafe {\n         llvm::LLVMDIBuilderCreateLexicalBlock(\n             DIB(ccx),\n             parent_scope,"}, {"sha": "0ac9b52274803bc59cfbe3f3abe211eb065648ad", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -12,6 +12,7 @@\n //! which do not.\n \n use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::mir::repr as mir;\n use rustc::mir::repr::TerminatorKind;\n use rustc::mir::visit::{Visitor, LvalueContext};\n@@ -94,10 +95,10 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for TempAnalyzer<'mir, 'bcx, 'tcx> {\n         debug!(\"visit_assign(block={:?}, lvalue={:?}, rvalue={:?})\", block, lvalue, rvalue);\n \n         match *lvalue {\n-            mir::Lvalue::Temp(index) => {\n-                self.mark_assigned(index as usize);\n+            mir::Lvalue::Temp(temp) => {\n+                self.mark_assigned(temp.index());\n                 if !rvalue::rvalue_creates_operand(self.mir, self.bcx, rvalue) {\n-                    self.mark_as_lvalue(index as usize);\n+                    self.mark_as_lvalue(temp.index());\n                 }\n             }\n             _ => {\n@@ -115,8 +116,8 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for TempAnalyzer<'mir, 'bcx, 'tcx> {\n \n         // Allow uses of projections of immediate pair fields.\n         if let mir::Lvalue::Projection(ref proj) = *lvalue {\n-            if let mir::Lvalue::Temp(index) = proj.base {\n-                let ty = self.mir.temp_decls[index as usize].ty;\n+            if let mir::Lvalue::Temp(temp) = proj.base {\n+                let ty = self.mir.temp_decls[temp].ty;\n                 let ty = self.bcx.monomorphize(&ty);\n                 if common::type_is_imm_pair(self.bcx.ccx(), ty) {\n                     if let mir::ProjectionElem::Field(..) = proj.elem {\n@@ -129,10 +130,10 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for TempAnalyzer<'mir, 'bcx, 'tcx> {\n         }\n \n         match *lvalue {\n-            mir::Lvalue::Temp(index) => {\n+            mir::Lvalue::Temp(temp) => {\n                 match context {\n                     LvalueContext::Call => {\n-                        self.mark_assigned(index as usize);\n+                        self.mark_assigned(temp.index());\n                     }\n                     LvalueContext::Consume => {\n                     }\n@@ -142,7 +143,7 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for TempAnalyzer<'mir, 'bcx, 'tcx> {\n                     LvalueContext::Borrow { .. } |\n                     LvalueContext::Slice { .. } |\n                     LvalueContext::Projection => {\n-                        self.mark_as_lvalue(index as usize);\n+                        self.mark_as_lvalue(temp.index());\n                     }\n                 }\n             }\n@@ -163,9 +164,10 @@ pub enum CleanupKind {\n \n pub fn cleanup_kinds<'bcx,'tcx>(_bcx: Block<'bcx,'tcx>,\n                                 mir: &mir::Mir<'tcx>)\n-                                -> Vec<CleanupKind>\n+                                -> IndexVec<mir::BasicBlock, CleanupKind>\n {\n-    fn discover_masters<'tcx>(result: &mut [CleanupKind], mir: &mir::Mir<'tcx>) {\n+    fn discover_masters<'tcx>(result: &mut IndexVec<mir::BasicBlock, CleanupKind>,\n+                              mir: &mir::Mir<'tcx>) {\n         for bb in mir.all_basic_blocks() {\n             let data = mir.basic_block_data(bb);\n             match data.terminator().kind {\n@@ -184,19 +186,19 @@ pub fn cleanup_kinds<'bcx,'tcx>(_bcx: Block<'bcx,'tcx>,\n                     if let Some(unwind) = unwind {\n                         debug!(\"cleanup_kinds: {:?}/{:?} registering {:?} as funclet\",\n                                bb, data, unwind);\n-                        result[unwind.index()] = CleanupKind::Funclet;\n+                        result[unwind] = CleanupKind::Funclet;\n                     }\n                 }\n             }\n         }\n     }\n \n-    fn propagate<'tcx>(result: &mut [CleanupKind], mir: &mir::Mir<'tcx>) {\n-        let mut funclet_succs : Vec<_> =\n-            mir.all_basic_blocks().iter().map(|_| None).collect();\n+    fn propagate<'tcx>(result: &mut IndexVec<mir::BasicBlock, CleanupKind>,\n+                       mir: &mir::Mir<'tcx>) {\n+        let mut funclet_succs = IndexVec::from_elem(None, &mir.basic_blocks);\n \n         let mut set_successor = |funclet: mir::BasicBlock, succ| {\n-            match funclet_succs[funclet.index()] {\n+            match funclet_succs[funclet] {\n                 ref mut s @ None => {\n                     debug!(\"set_successor: updating successor of {:?} to {:?}\",\n                            funclet, succ);\n@@ -210,22 +212,22 @@ pub fn cleanup_kinds<'bcx,'tcx>(_bcx: Block<'bcx,'tcx>,\n         };\n \n         for (bb, data) in traversal::reverse_postorder(mir) {\n-            let funclet = match result[bb.index()] {\n+            let funclet = match result[bb] {\n                 CleanupKind::NotCleanup => continue,\n                 CleanupKind::Funclet => bb,\n                 CleanupKind::Internal { funclet } => funclet,\n             };\n \n             debug!(\"cleanup_kinds: {:?}/{:?}/{:?} propagating funclet {:?}\",\n-                   bb, data, result[bb.index()], funclet);\n+                   bb, data, result[bb], funclet);\n \n             for &succ in data.terminator().successors().iter() {\n-                let kind = result[succ.index()];\n+                let kind = result[succ];\n                 debug!(\"cleanup_kinds: propagating {:?} to {:?}/{:?}\",\n                        funclet, succ, kind);\n                 match kind {\n                     CleanupKind::NotCleanup => {\n-                        result[succ.index()] = CleanupKind::Internal { funclet: funclet };\n+                        result[succ] = CleanupKind::Internal { funclet: funclet };\n                     }\n                     CleanupKind::Funclet => {\n                         set_successor(funclet, succ);\n@@ -237,7 +239,7 @@ pub fn cleanup_kinds<'bcx,'tcx>(_bcx: Block<'bcx,'tcx>,\n \n                             debug!(\"promoting {:?} to a funclet and updating {:?}\", succ,\n                                    succ_funclet);\n-                            result[succ.index()] = CleanupKind::Funclet;\n+                            result[succ] = CleanupKind::Funclet;\n                             set_successor(succ_funclet, succ);\n                             set_successor(funclet, succ);\n                         }\n@@ -247,8 +249,7 @@ pub fn cleanup_kinds<'bcx,'tcx>(_bcx: Block<'bcx,'tcx>,\n         }\n     }\n \n-    let mut result : Vec<_> =\n-        mir.all_basic_blocks().iter().map(|_| CleanupKind::NotCleanup).collect();\n+    let mut result = IndexVec::from_elem(CleanupKind::NotCleanup, &mir.basic_blocks);\n \n     discover_masters(&mut result, mir);\n     propagate(&mut result, mir);"}, {"sha": "03a9e977b1af2664e74ecfaaa28c9d79f2eaf12e", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -52,9 +52,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let cleanup_bundle = bcx.lpad().and_then(|l| l.bundle());\n \n         let funclet_br = |this: &Self, bcx: BlockAndBuilder, bb: mir::BasicBlock| {\n-            let lltarget = this.blocks[bb.index()].llbb;\n+            let lltarget = this.blocks[bb].llbb;\n             if let Some(cp) = cleanup_pad {\n-                match this.cleanup_kind(bb) {\n+                match this.cleanup_kinds[bb] {\n                     CleanupKind::Funclet => {\n                         // micro-optimization: generate a `ret` rather than a jump\n                         // to a return block\n@@ -69,10 +69,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         };\n \n         let llblock = |this: &mut Self, target: mir::BasicBlock| {\n-            let lltarget = this.blocks[target.index()].llbb;\n+            let lltarget = this.blocks[target].llbb;\n \n             if let Some(cp) = cleanup_pad {\n-                match this.cleanup_kind(target) {\n+                match this.cleanup_kinds[target] {\n                     CleanupKind::Funclet => {\n                         // MSVC cross-funclet jump - need a trampoline\n \n@@ -89,7 +89,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 }\n             } else {\n                 if let (CleanupKind::NotCleanup, CleanupKind::Funclet) =\n-                    (this.cleanup_kind(bb), this.cleanup_kind(target))\n+                    (this.cleanup_kinds[bb], this.cleanup_kinds[target])\n                 {\n                     // jump *into* cleanup - need a landing pad if GNU\n                     this.landing_pad_to(target).llbb\n@@ -209,7 +209,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 if let Some(unwind) = unwind {\n                     bcx.invoke(drop_fn,\n                                &[llvalue],\n-                               self.blocks[target.index()].llbb,\n+                               self.blocks[target].llbb,\n                                llblock(self, unwind),\n                                cleanup_bundle);\n                 } else {\n@@ -488,7 +488,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 // Many different ways to call a function handled here\n                 if let &Some(cleanup) = cleanup {\n                     let ret_bcx = if let Some((_, target)) = *destination {\n-                        self.blocks[target.index()]\n+                        self.blocks[target]\n                     } else {\n                         self.unreachable_block()\n                     };\n@@ -693,27 +693,23 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         }\n     }\n \n-    fn cleanup_kind(&self, bb: mir::BasicBlock) -> CleanupKind {\n-        self.cleanup_kinds[bb.index()]\n-    }\n-\n     /// Return the landingpad wrapper around the given basic block\n     ///\n     /// No-op in MSVC SEH scheme.\n     fn landing_pad_to(&mut self, target_bb: mir::BasicBlock) -> Block<'bcx, 'tcx>\n     {\n-        if let Some(block) = self.landing_pads[target_bb.index()] {\n+        if let Some(block) = self.landing_pads[target_bb] {\n             return block;\n         }\n \n         if base::wants_msvc_seh(self.fcx.ccx.sess()) {\n-            return self.blocks[target_bb.index()];\n+            return self.blocks[target_bb];\n         }\n \n         let target = self.bcx(target_bb);\n \n         let block = self.fcx.new_block(\"cleanup\", None);\n-        self.landing_pads[target_bb.index()] = Some(block);\n+        self.landing_pads[target_bb] = Some(block);\n \n         let bcx = block.build();\n         let ccx = bcx.ccx();\n@@ -732,7 +728,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let data = self.mir.basic_block_data(bb);\n         debug!(\"init_cpad({:?})\", data);\n \n-        match self.cleanup_kinds[bb.index()] {\n+        match self.cleanup_kinds[bb] {\n             CleanupKind::NotCleanup => {\n                 bcx.set_lpad(None)\n             }\n@@ -763,7 +759,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n \n     fn bcx(&self, bb: mir::BasicBlock) -> BlockAndBuilder<'bcx, 'tcx> {\n-        self.blocks[bb.index()].build()\n+        self.blocks[bb].build()\n     }\n \n     fn make_return_dest(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>,\n@@ -776,7 +772,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let dest = match *dest {\n             mir::Lvalue::Temp(idx) => {\n                 let ret_ty = self.lvalue_ty(dest);\n-                match self.temps[idx as usize] {\n+                match self.temps[idx] {\n                     TempRef::Lvalue(dest) => dest,\n                     TempRef::Operand(None) => {\n                         // Handle temporary lvalues, specifically Operand ones, as\n@@ -838,6 +834,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         self.store_operand(bcx, cast_ptr, val);\n     }\n \n+\n     // Stores the return value of a function call into it's final location.\n     fn store_return(&mut self,\n                     bcx: &BlockAndBuilder<'bcx, 'tcx>,\n@@ -851,7 +848,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             Store(dst) => ret_ty.store(bcx, op.immediate(), dst),\n             IndirectOperand(tmp, idx) => {\n                 let op = self.trans_load(bcx, tmp, op.ty);\n-                self.temps[idx as usize] = TempRef::Operand(Some(op));\n+                self.temps[idx] = TempRef::Operand(Some(op));\n             }\n             DirectOperand(idx) => {\n                 // If there is a cast, we have to store and reload.\n@@ -864,7 +861,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 } else {\n                     op.unpack_if_pair(bcx)\n                 };\n-                self.temps[idx as usize] = TempRef::Operand(Some(op));\n+                self.temps[idx] = TempRef::Operand(Some(op));\n             }\n         }\n     }\n@@ -876,7 +873,7 @@ enum ReturnDest {\n     // Store the return value to the pointer\n     Store(ValueRef),\n     // Stores an indirect return value to an operand temporary lvalue\n-    IndirectOperand(ValueRef, u32),\n+    IndirectOperand(ValueRef, mir::Temp),\n     // Stores a direct return value to an operand temporary lvalue\n-    DirectOperand(u32)\n+    DirectOperand(mir::Temp)\n }"}, {"sha": "488c913d88dba900e7eafc76b2ce8996de952bab", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -22,6 +22,7 @@ use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::Substs;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use {abi, adt, base, Disr};\n use callee::Callee;\n use common::{self, BlockAndBuilder, CrateContext, const_get_elt, val_ty};\n@@ -203,13 +204,13 @@ struct MirConstContext<'a, 'tcx: 'a> {\n     substs: &'tcx Substs<'tcx>,\n \n     /// Arguments passed to a const fn.\n-    args: Vec<Const<'tcx>>,\n+    args: IndexVec<mir::Arg, Const<'tcx>>,\n \n     /// Variable values - specifically, argument bindings of a const fn.\n-    vars: Vec<Option<Const<'tcx>>>,\n+    vars: IndexVec<mir::Var, Option<Const<'tcx>>>,\n \n     /// Temp values.\n-    temps: Vec<Option<Const<'tcx>>>,\n+    temps: IndexVec<mir::Temp, Option<Const<'tcx>>>,\n \n     /// Value assigned to Return, which is the resulting constant.\n     return_value: Option<Const<'tcx>>\n@@ -220,22 +221,22 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     fn new(ccx: &'a CrateContext<'a, 'tcx>,\n            mir: &'a mir::Mir<'tcx>,\n            substs: &'tcx Substs<'tcx>,\n-           args: Vec<Const<'tcx>>)\n+           args: IndexVec<mir::Arg, Const<'tcx>>)\n            -> MirConstContext<'a, 'tcx> {\n         MirConstContext {\n             ccx: ccx,\n             mir: mir,\n             substs: substs,\n             args: args,\n-            vars: vec![None; mir.var_decls.len()],\n-            temps: vec![None; mir.temp_decls.len()],\n+            vars: IndexVec::from_elem(None, &mir.var_decls),\n+            temps: IndexVec::from_elem(None, &mir.temp_decls),\n             return_value: None\n         }\n     }\n \n     fn trans_def(ccx: &'a CrateContext<'a, 'tcx>,\n                  mut instance: Instance<'tcx>,\n-                 args: Vec<Const<'tcx>>)\n+                 args: IndexVec<mir::Arg, Const<'tcx>>)\n                  -> Result<Const<'tcx>, ConstEvalFailure> {\n         // Try to resolve associated constants.\n         if instance.substs.self_ty().is_some() {\n@@ -342,10 +343,10 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                        func, fn_ty)\n                     };\n \n-                    let mut const_args = Vec::with_capacity(args.len());\n+                    let mut const_args = IndexVec::with_capacity(args.len());\n                     for arg in args {\n                         match self.const_operand(arg, span) {\n-                            Ok(arg) => const_args.push(arg),\n+                            Ok(arg) => { const_args.push(arg); },\n                             Err(err) => if failure.is_ok() { failure = Err(err); }\n                         }\n                     }\n@@ -366,8 +367,8 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n     fn store(&mut self, dest: &mir::Lvalue<'tcx>, value: Const<'tcx>, span: Span) {\n         let dest = match *dest {\n-            mir::Lvalue::Var(index) => &mut self.vars[index as usize],\n-            mir::Lvalue::Temp(index) => &mut self.temps[index as usize],\n+            mir::Lvalue::Var(var) => &mut self.vars[var],\n+            mir::Lvalue::Temp(temp) => &mut self.temps[temp],\n             mir::Lvalue::ReturnPointer => &mut self.return_value,\n             _ => span_bug!(span, \"assignment to {:?} in constant\", dest)\n         };\n@@ -378,17 +379,17 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     -> Result<ConstLvalue<'tcx>, ConstEvalFailure> {\n         let tcx = self.ccx.tcx();\n         let lvalue = match *lvalue {\n-            mir::Lvalue::Var(index) => {\n-                self.vars[index as usize].unwrap_or_else(|| {\n-                    span_bug!(span, \"var{} not initialized\", index)\n+            mir::Lvalue::Var(var) => {\n+                self.vars[var].unwrap_or_else(|| {\n+                    span_bug!(span, \"{:?} not initialized\", var)\n                 }).as_lvalue()\n             }\n-            mir::Lvalue::Temp(index) => {\n-                self.temps[index as usize].unwrap_or_else(|| {\n-                    span_bug!(span, \"tmp{} not initialized\", index)\n+            mir::Lvalue::Temp(temp) => {\n+                self.temps[temp].unwrap_or_else(|| {\n+                    span_bug!(span, \"{:?} not initialized\", temp)\n                 }).as_lvalue()\n             }\n-            mir::Lvalue::Arg(index) => self.args[index as usize].as_lvalue(),\n+            mir::Lvalue::Arg(arg) => self.args[arg].as_lvalue(),\n             mir::Lvalue::Static(def_id) => {\n                 ConstLvalue {\n                     base: Base::Static(consts::get_static(self.ccx, def_id).val),\n@@ -489,11 +490,11 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n                         let substs = self.monomorphize(&substs);\n                         let instance = Instance::new(def_id, substs);\n-                        MirConstContext::trans_def(self.ccx, instance, vec![])\n+                        MirConstContext::trans_def(self.ccx, instance, IndexVec::new())\n                     }\n                     mir::Literal::Promoted { index } => {\n                         let mir = &self.mir.promoted[index];\n-                        MirConstContext::new(self.ccx, mir, self.substs, vec![]).trans()\n+                        MirConstContext::new(self.ccx, mir, self.substs, IndexVec::new()).trans()\n                     }\n                     mir::Literal::Value { value } => {\n                         Ok(Const::from_constval(self.ccx, value, ty))\n@@ -914,11 +915,12 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 let substs = bcx.monomorphize(&substs);\n                 let instance = Instance::new(def_id, substs);\n-                MirConstContext::trans_def(bcx.ccx(), instance, vec![])\n+                MirConstContext::trans_def(bcx.ccx(), instance, IndexVec::new())\n             }\n             mir::Literal::Promoted { index } => {\n                 let mir = &self.mir.promoted[index];\n-                MirConstContext::new(bcx.ccx(), mir, bcx.fcx().param_substs, vec![]).trans()\n+                MirConstContext::new(bcx.ccx(), mir, bcx.fcx().param_substs,\n+                                     IndexVec::new()).trans()\n             }\n             mir::Literal::Value { value } => {\n                 Ok(Const::from_constval(bcx.ccx(), value, ty))\n@@ -945,5 +947,5 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n pub fn trans_static_initializer(ccx: &CrateContext, def_id: DefId)\n                                 -> Result<ValueRef, ConstEvalFailure> {\n     let instance = Instance::mono(ccx.shared(), def_id);\n-    MirConstContext::trans_def(ccx, instance, vec![]).map(|c| c.llval)\n+    MirConstContext::trans_def(ccx, instance, IndexVec::new()).map(|c| c.llval)\n }"}, {"sha": "0a66a147568e6b986265080bbb066e4882fa11da", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -12,6 +12,7 @@ use llvm::ValueRef;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n+use rustc_data_structures::indexed_vec::Idx;\n use abi;\n use adt;\n use base;\n@@ -90,14 +91,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let ccx = bcx.ccx();\n         let tcx = bcx.tcx();\n         let result = match *lvalue {\n-            mir::Lvalue::Var(index) => self.vars[index as usize],\n-            mir::Lvalue::Temp(index) => match self.temps[index as usize] {\n+            mir::Lvalue::Var(var) => self.vars[var],\n+            mir::Lvalue::Temp(temp) => match self.temps[temp] {\n                 TempRef::Lvalue(lvalue) =>\n                     lvalue,\n                 TempRef::Operand(..) =>\n                     bug!(\"using operand temp {:?} as lvalue\", lvalue),\n             },\n-            mir::Lvalue::Arg(index) => self.args[index as usize],\n+            mir::Lvalue::Arg(arg) => self.args[arg],\n             mir::Lvalue::Static(def_id) => {\n                 let const_ty = self.lvalue_ty(lvalue);\n                 LvalueRef::new_sized(consts::get_static(ccx, def_id).val,\n@@ -233,8 +234,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     where F: FnOnce(&mut Self, LvalueRef<'tcx>) -> U\n     {\n         match *lvalue {\n-            mir::Lvalue::Temp(idx) => {\n-                match self.temps[idx as usize] {\n+            mir::Lvalue::Temp(temp) => {\n+                match self.temps[temp] {\n                     TempRef::Lvalue(lvalue) => f(self, lvalue),\n                     TempRef::Operand(None) => {\n                         let lvalue_ty = self.lvalue_ty(lvalue);\n@@ -243,7 +244,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                        \"lvalue_temp\");\n                         let ret = f(self, lvalue);\n                         let op = self.trans_load(bcx, lvalue.llval, lvalue_ty);\n-                        self.temps[idx as usize] = TempRef::Operand(Some(op));\n+                        self.temps[temp] = TempRef::Operand(Some(op));\n                         ret\n                     }\n                     TempRef::Operand(Some(_)) => {"}, {"sha": "fe9f4419f6c2ea0c2d2e41baf92cfd51aff618ce", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -30,6 +30,7 @@ use std::rc::Rc;\n use basic_block::BasicBlock;\n \n use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n pub use self::constant::trans_static_initializer;\n \n@@ -71,20 +72,20 @@ pub struct MirContext<'bcx, 'tcx:'bcx> {\n     llpersonalityslot: Option<ValueRef>,\n \n     /// A `Block` for each MIR `BasicBlock`\n-    blocks: Vec<Block<'bcx, 'tcx>>,\n+    blocks: IndexVec<mir::BasicBlock, Block<'bcx, 'tcx>>,\n \n     /// The funclet status of each basic block\n-    cleanup_kinds: Vec<analyze::CleanupKind>,\n+    cleanup_kinds: IndexVec<mir::BasicBlock, analyze::CleanupKind>,\n \n     /// This stores the landing-pad block for a given BB, computed lazily on GNU\n     /// and eagerly on MSVC.\n-    landing_pads: Vec<Option<Block<'bcx, 'tcx>>>,\n+    landing_pads: IndexVec<mir::BasicBlock, Option<Block<'bcx, 'tcx>>>,\n \n     /// Cached unreachable block\n     unreachable_block: Option<Block<'bcx, 'tcx>>,\n \n     /// An LLVM alloca for each MIR `VarDecl`\n-    vars: Vec<LvalueRef<'tcx>>,\n+    vars: IndexVec<mir::Var, LvalueRef<'tcx>>,\n \n     /// The location where each MIR `TempDecl` is stored. This is\n     /// usually an `LvalueRef` representing an alloca, but not always:\n@@ -101,20 +102,20 @@ pub struct MirContext<'bcx, 'tcx:'bcx> {\n     ///\n     /// Avoiding allocs can also be important for certain intrinsics,\n     /// notably `expect`.\n-    temps: Vec<TempRef<'tcx>>,\n+    temps: IndexVec<mir::Temp, TempRef<'tcx>>,\n \n     /// The arguments to the function; as args are lvalues, these are\n     /// always indirect, though we try to avoid creating an alloca\n     /// when we can (and just reuse the pointer the caller provided).\n-    args: Vec<LvalueRef<'tcx>>,\n+    args: IndexVec<mir::Arg, LvalueRef<'tcx>>,\n \n     /// Debug information for MIR scopes.\n-    scopes: Vec<DIScope>\n+    scopes: IndexVec<mir::VisibilityScope, DIScope>\n }\n \n impl<'blk, 'tcx> MirContext<'blk, 'tcx> {\n     pub fn debug_loc(&self, source_info: mir::SourceInfo) -> DebugLoc {\n-        DebugLoc::ScopeAt(self.scopes[source_info.scope.index()], source_info.span)\n+        DebugLoc::ScopeAt(self.scopes[source_info.scope], source_info.span)\n     }\n }\n \n@@ -173,7 +174,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n                             .map(|(mty, decl)| {\n         let lvalue = LvalueRef::alloca(&bcx, mty, &decl.name.as_str());\n \n-        let scope = scopes[decl.source_info.scope.index()];\n+        let scope = scopes[decl.source_info.scope];\n         if !scope.is_null() && bcx.sess().opts.debuginfo == FullDebugInfo {\n             bcx.with_block(|bcx| {\n                 declare_local(bcx, decl.name, mty, scope,\n@@ -200,9 +201,9 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n                               .collect();\n \n     // Allocate a `Block` for every basic block\n-    let block_bcxs: Vec<Block<'blk,'tcx>> =\n+    let block_bcxs: IndexVec<mir::BasicBlock, Block<'blk,'tcx>> =\n         mir_blocks.iter()\n-                  .map(|&bb|{\n+                  .map(|&bb| {\n                       if bb == mir::START_BLOCK {\n                           fcx.new_block(\"start\", None)\n                       } else {\n@@ -212,7 +213,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n                   .collect();\n \n     // Branch to the START block\n-    let start_bcx = block_bcxs[mir::START_BLOCK.index()];\n+    let start_bcx = block_bcxs[mir::START_BLOCK];\n     bcx.br(start_bcx.llbb);\n \n     // Up until here, IR instructions for this function have explicitly not been annotated with\n@@ -253,7 +254,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n     // Remove blocks that haven't been visited, or have no\n     // predecessors.\n     for &bb in &mir_blocks {\n-        let block = mircx.blocks[bb.index()];\n+        let block = mircx.blocks[bb];\n         let block = BasicBlock(block.llbb);\n         // Unreachable block\n         if !visited.contains(bb.index()) {\n@@ -271,15 +272,15 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n /// indirect.\n fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                               mir: &mir::Mir<'tcx>,\n-                              scopes: &[DIScope])\n-                              -> Vec<LvalueRef<'tcx>> {\n+                              scopes: &IndexVec<mir::VisibilityScope, DIScope>)\n+                              -> IndexVec<mir::Arg, LvalueRef<'tcx>> {\n     let fcx = bcx.fcx();\n     let tcx = bcx.tcx();\n     let mut idx = 0;\n     let mut llarg_idx = fcx.fn_ty.ret.is_indirect() as usize;\n \n     // Get the argument scope, if it exists and if we need it.\n-    let arg_scope = scopes[mir::ARGUMENT_VISIBILITY_SCOPE.index()];\n+    let arg_scope = scopes[mir::ARGUMENT_VISIBILITY_SCOPE];\n     let arg_scope = if !arg_scope.is_null() && bcx.sess().opts.debuginfo == FullDebugInfo {\n         Some(arg_scope)\n     } else {"}, {"sha": "80ff0a92d8d4630e517ced286bf62f27c1def5cb", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -11,6 +11,8 @@\n use llvm::ValueRef;\n use rustc::ty::Ty;\n use rustc::mir::repr as mir;\n+use rustc_data_structures::indexed_vec::Idx;\n+\n use base;\n use common::{self, Block, BlockAndBuilder};\n use value::Value;\n@@ -174,7 +176,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 // watch out for temporaries that do not have an\n                 // alloca; they are handled somewhat differently\n                 if let &mir::Lvalue::Temp(index) = lvalue {\n-                    match self.temps[index as usize] {\n+                    match self.temps[index] {\n                         TempRef::Operand(Some(o)) => {\n                             return o;\n                         }\n@@ -190,7 +192,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 // Moves out of pair fields are trivial.\n                 if let &mir::Lvalue::Projection(ref proj) = lvalue {\n                     if let mir::Lvalue::Temp(index) = proj.base {\n-                        let temp_ref = &self.temps[index as usize];\n+                        let temp_ref = &self.temps[index];\n                         if let &TempRef::Operand(Some(o)) = temp_ref {\n                             match (o.val, &proj.elem) {\n                                 (OperandValue::Pair(a, b),"}, {"sha": "d592f5ee1b936fde2adf9a94e94964e9fc4e56c0", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1eb67721a842d62bec8e879aad339fd22fe3c6/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=bc1eb67721a842d62bec8e879aad339fd22fe3c6", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use rustc::mir::repr as mir;\n+\n use common::{self, BlockAndBuilder};\n \n use super::MirContext;\n@@ -28,8 +29,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n                 match *lvalue {\n                     mir::Lvalue::Temp(index) => {\n-                        let index = index as usize;\n-                        match self.temps[index as usize] {\n+                        match self.temps[index] {\n                             TempRef::Lvalue(tr_dest) => {\n                                 self.trans_rvalue(bcx, tr_dest, rvalue, debug_loc)\n                             }"}]}