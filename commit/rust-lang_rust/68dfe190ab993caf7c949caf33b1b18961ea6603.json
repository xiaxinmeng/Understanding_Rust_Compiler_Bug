{"sha": "68dfe190ab993caf7c949caf33b1b18961ea6603", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4ZGZlMTkwYWI5OTNjYWY3Yzk0OWNhZjMzYjFiMTg5NjFlYTY2MDM=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-09-12T11:03:12Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-09-12T11:03:12Z"}, "message": "Improve resilience of match checking\n\nIn bug condition the match checking strives to recover giving false no-error diagnostic.", "tree": {"sha": "274410c61152249a4fc6343f5b32c95a17167002", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/274410c61152249a4fc6343f5b32c95a17167002"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68dfe190ab993caf7c949caf33b1b18961ea6603", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68dfe190ab993caf7c949caf33b1b18961ea6603", "html_url": "https://github.com/rust-lang/rust/commit/68dfe190ab993caf7c949caf33b1b18961ea6603", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68dfe190ab993caf7c949caf33b1b18961ea6603/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abdb75912c8d9297289df95e312e1b53df4960f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/abdb75912c8d9297289df95e312e1b53df4960f7", "html_url": "https://github.com/rust-lang/rust/commit/abdb75912c8d9297289df95e312e1b53df4960f7"}], "stats": {"total": 72, "additions": 32, "deletions": 40}, "files": [{"sha": "abcb84401b4af04b32dd645e21bba5c0d0d7d955", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/68dfe190ab993caf7c949caf33b1b18961ea6603/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68dfe190ab993caf7c949caf33b1b18961ea6603/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=68dfe190ab993caf7c949caf33b1b18961ea6603", "patch": "@@ -22,7 +22,7 @@ use crate::{\n };\n \n pub(crate) use hir_def::{\n-    body::{Body, BodySourceMap},\n+    body::Body,\n     expr::{Expr, ExprId, MatchArm, Pat, PatId},\n     LocalFieldId, VariantId,\n };\n@@ -264,8 +264,7 @@ impl ExprValidator {\n         db: &dyn HirDatabase,\n         infer: Arc<InferenceResult>,\n     ) {\n-        let (body, source_map): (Arc<Body>, Arc<BodySourceMap>) =\n-            db.body_with_source_map(self.owner);\n+        let body = db.body(self.owner);\n \n         let match_expr_ty = if infer.type_of_expr[match_expr].is_unknown() {\n             return;\n@@ -330,21 +329,6 @@ impl ExprValidator {\n             infer: &infer,\n             db,\n             pattern_arena: &pattern_arena,\n-            panic_context: &|| {\n-                use syntax::AstNode;\n-                let match_expr_text = source_map\n-                    .expr_syntax(match_expr)\n-                    .ok()\n-                    .and_then(|scrutinee_sptr| {\n-                        let root = scrutinee_sptr.file_syntax(db.upcast());\n-                        scrutinee_sptr.value.to_node(&root).syntax().parent()\n-                    })\n-                    .map(|node| node.to_string());\n-                format!(\n-                    \"expression:\\n{}\",\n-                    match_expr_text.as_deref().unwrap_or(\"<synthesized expr>\")\n-                )\n-            },\n         };\n         let report = compute_match_usefulness(&cx, &m_arms);\n "}, {"sha": "2fa456a035a3323b63964faf510f3c77acdd7f27", "filename": "crates/hir_ty/src/diagnostics/match_check/deconstruct_pat.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/68dfe190ab993caf7c949caf33b1b18961ea6603/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68dfe190ab993caf7c949caf33b1b18961ea6603/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs?ref=68dfe190ab993caf7c949caf33b1b18961ea6603", "patch": "@@ -49,6 +49,7 @@ use std::{\n \n use hir_def::{EnumVariantId, HasModule, LocalFieldId, VariantId};\n use smallvec::{smallvec, SmallVec};\n+use stdx::never;\n \n use crate::{AdtId, Interner, Scalar, Ty, TyExt, TyKind};\n \n@@ -324,7 +325,10 @@ impl Constructor {\n             PatKind::Leaf { .. } | PatKind::Deref { .. } => Single,\n             &PatKind::Variant { enum_variant, .. } => Variant(enum_variant),\n             &PatKind::LiteralBool { value } => IntRange(IntRange::from_bool(value)),\n-            PatKind::Or { .. } => cx.bug(\"Or-pattern should have been expanded earlier on.\"),\n+            PatKind::Or { .. } => {\n+                never!(\"Or-pattern should have been expanded earlier on.\");\n+                Wildcard\n+            }\n         }\n     }\n \n@@ -371,7 +375,7 @@ impl Constructor {\n     /// this checks for inclusion.\n     // We inline because this has a single call site in `Matrix::specialize_constructor`.\n     #[inline]\n-    pub(super) fn is_covered_by(&self, pcx: PatCtxt<'_>, other: &Self) -> bool {\n+    pub(super) fn is_covered_by(&self, _pcx: PatCtxt<'_>, other: &Self) -> bool {\n         // This must be kept in sync with `is_covered_by_any`.\n         match (self, other) {\n             // Wildcards cover anything\n@@ -396,17 +400,18 @@ impl Constructor {\n             // Only a wildcard pattern can match the special extra constructor.\n             (NonExhaustive, _) => false,\n \n-            _ => pcx.cx.bug(&format!(\n-                \"trying to compare incompatible constructors {:?} and {:?}\",\n-                self, other\n-            )),\n+            _ => {\n+                never!(\"trying to compare incompatible constructors {:?} and {:?}\", self, other);\n+                // Continue with 'whatever is covered' supposed to result in false no-error diagnostic.\n+                true\n+            }\n         }\n     }\n \n     /// Faster version of `is_covered_by` when applied to many constructors. `used_ctors` is\n     /// assumed to be built from `matrix.head_ctors()` with wildcards filtered out, and `self` is\n     /// assumed to have been split from a wildcard.\n-    fn is_covered_by_any(&self, pcx: PatCtxt<'_>, used_ctors: &[Constructor]) -> bool {\n+    fn is_covered_by_any(&self, _pcx: PatCtxt<'_>, used_ctors: &[Constructor]) -> bool {\n         if used_ctors.is_empty() {\n             return false;\n         }\n@@ -427,7 +432,8 @@ impl Constructor {\n             // This constructor is never covered by anything else\n             NonExhaustive => false,\n             Str(..) | FloatRange(..) | Opaque | Missing | Wildcard => {\n-                pcx.cx.bug(&format!(\"found unexpected ctor in all_ctors: {:?}\", self))\n+                never!(\"found unexpected ctor in all_ctors: {:?}\", self);\n+                true\n             }\n         }\n     }\n@@ -683,7 +689,8 @@ impl Fields {\n                     }\n                 }\n                 ty_kind => {\n-                    cx.bug(&format!(\"Unexpected type for `Single` constructor: {:?}\", ty_kind))\n+                    never!(\"Unexpected type for `Single` constructor: {:?}\", ty_kind);\n+                    Fields::from_single_pattern(wildcard_from_ty(ty))\n                 }\n             },\n             Slice(..) => {\n@@ -745,7 +752,8 @@ impl Fields {\n                 // can ignore this issue.\n                 TyKind::Ref(..) => PatKind::Deref { subpattern: subpatterns.next().unwrap() },\n                 TyKind::Slice(..) | TyKind::Array(..) => {\n-                    pcx.cx.bug(&format!(\"bad slice pattern {:?} {:?}\", ctor, pcx.ty))\n+                    never!(\"bad slice pattern {:?} {:?}\", ctor, pcx.ty);\n+                    PatKind::Wild\n                 }\n                 _ => PatKind::Wild,\n             },\n@@ -755,11 +763,17 @@ impl Fields {\n             Constructor::IntRange(_) => UNHANDLED,\n             NonExhaustive => PatKind::Wild,\n             Wildcard => return Pat::wildcard_from_ty(pcx.ty.clone()),\n-            Opaque => pcx.cx.bug(\"we should not try to apply an opaque constructor\"),\n-            Missing => pcx.cx.bug(\n-                \"trying to apply the `Missing` constructor;\\\n-                this should have been done in `apply_constructors`\",\n-            ),\n+            Opaque => {\n+                never!(\"we should not try to apply an opaque constructor\");\n+                PatKind::Wild\n+            }\n+            Missing => {\n+                never!(\n+                    \"trying to apply the `Missing` constructor; \\\n+                    this should have been done in `apply_constructors`\",\n+                );\n+                PatKind::Wild\n+            }\n         };\n \n         Pat { ty: pcx.ty.clone(), kind: Box::new(pat) }"}, {"sha": "bb072ae70ad73a9b3b7d8d31426b4d257a6bc2aa", "filename": "crates/hir_ty/src/diagnostics/match_check/usefulness.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68dfe190ab993caf7c949caf33b1b18961ea6603/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68dfe190ab993caf7c949caf33b1b18961ea6603/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs?ref=68dfe190ab993caf7c949caf33b1b18961ea6603", "patch": "@@ -295,7 +295,6 @@ pub(crate) struct MatchCheckCtx<'a> {\n     pub(crate) db: &'a dyn HirDatabase,\n     /// Lowered patterns from arms plus generated by the check.\n     pub(crate) pattern_arena: &'a RefCell<PatternArena>,\n-    pub(crate) panic_context: &'a dyn Fn() -> String,\n }\n \n impl<'a> MatchCheckCtx<'a> {\n@@ -328,11 +327,6 @@ impl<'a> MatchCheckCtx<'a> {\n     pub(super) fn type_of(&self, pat: PatId) -> Ty {\n         self.pattern_arena.borrow()[pat].ty.clone()\n     }\n-\n-    #[track_caller]\n-    pub(super) fn bug(&self, info: &str) -> ! {\n-        panic!(\"bug: {}\\n{}\", info, (self.panic_context)());\n-    }\n }\n \n #[derive(Copy, Clone)]\n@@ -1131,7 +1125,7 @@ pub(crate) fn compute_match_usefulness(\n     arms: &[MatchArm],\n ) -> UsefulnessReport {\n     let mut matrix = Matrix::empty();\n-    let arm_usefulness: Vec<_> = arms\n+    let arm_usefulness = arms\n         .iter()\n         .copied()\n         .map(|arm| {"}]}