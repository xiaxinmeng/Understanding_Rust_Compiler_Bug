{"sha": "c7e7e1fe0fa8468b3cd8bc7db7d0332d7257b74e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3ZTdlMWZlMGZhODQ2OGIzY2Q4YmM3ZGI3ZDAzMzJkNzI1N2I3NGU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-22T17:18:53Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-22T17:18:53Z"}, "message": "Split common utils out of base.rs", "tree": {"sha": "98115a82a3cba8ff764d637d929869e42b5f0669", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98115a82a3cba8ff764d637d929869e42b5f0669"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7e7e1fe0fa8468b3cd8bc7db7d0332d7257b74e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7e7e1fe0fa8468b3cd8bc7db7d0332d7257b74e", "html_url": "https://github.com/rust-lang/rust/commit/c7e7e1fe0fa8468b3cd8bc7db7d0332d7257b74e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7e7e1fe0fa8468b3cd8bc7db7d0332d7257b74e/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0dce914e397d7dd0b655805c936c8692766c371", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0dce914e397d7dd0b655805c936c8692766c371", "html_url": "https://github.com/rust-lang/rust/commit/c0dce914e397d7dd0b655805c936c8692766c371"}], "stats": {"total": 485, "additions": 248, "deletions": 237}, "files": [{"sha": "0b9f1253c912e0e12a8544b0d9161c79c02f5c8a", "filename": "src/base.rs", "status": "modified", "additions": 0, "deletions": 237, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/c7e7e1fe0fa8468b3cd8bc7db7d0332d7257b74e/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e7e1fe0fa8468b3cd8bc7db7d0332d7257b74e/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=c7e7e1fe0fa8468b3cd8bc7db7d0332d7257b74e", "patch": "@@ -1,15 +1,5 @@\n-use syntax::ast::{IntTy, UintTy};\n use rustc_mir::monomorphize::MonoItem;\n \n-use cretonne::prelude::*;\n-use cretonne::codegen::Context;\n-use cretonne::codegen::ir::{\n-    ExternalName,\n-    FuncRef,\n-    StackSlot,\n-    function::Function,\n-};\n-\n use cretonne_module::{Module, Backend, FuncId, Linkage};\n use cretonne_simplejit::{SimpleJITBuilder, SimpleJITBackend};\n \n@@ -18,142 +8,6 @@ use std::collections::HashMap;\n \n use prelude::*;\n \n-#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n-struct Variable(Local);\n-\n-type CurrentBackend = SimpleJITBackend;\n-\n-impl EntityRef for Variable {\n-    fn new(u: usize) -> Self {\n-        Variable(Local::new(u))\n-    }\n-\n-    fn index(self) -> usize {\n-        self.0.index()\n-    }\n-}\n-\n-// FIXME(cretonne) fix load.i8\n-fn load_workaround(fx: &mut FunctionCx, ty: Type, addr: Value, offset: i32) -> Value {\n-    use cretonne::codegen::ir::types::*;\n-    match ty {\n-        I8 => fx.bcx.ins().uload8(I32, MemFlags::new(), addr, offset),\n-        I16 => fx.bcx.ins().uload16(I32, MemFlags::new(), addr, offset),\n-        // I32 and I64 work\n-        _ => fx.bcx.ins().load(ty, MemFlags::new(), addr, offset),\n-    }\n-}\n-\n-// FIXME(cretonne) fix store.i8\n-fn store_workaround(fx: &mut FunctionCx, ty: Type, addr: Value, val: Value, offset: i32) {\n-    use cretonne::codegen::ir::types::*;\n-    match ty {\n-        I8 => fx.bcx.ins().istore8(MemFlags::new(), val, addr, offset),\n-        I16 => fx.bcx.ins().istore16(MemFlags::new(), val, addr, offset),\n-        // I32 and I64 work\n-        _ => fx.bcx.ins().store(MemFlags::new(), val, addr, offset),\n-    };\n-}\n-\n-#[derive(Copy, Clone)]\n-enum CValue {\n-    ByRef(Value),\n-    ByVal(Value),\n-    Func(FuncRef),\n-}\n-\n-impl CValue {\n-    fn force_stack<'a, 'tcx: 'a>(self, fx: &mut FunctionCx<'a, 'tcx>, ty: Ty<'tcx>) -> Value {\n-        match self {\n-            CValue::ByRef(value) => value,\n-            CValue::ByVal(value) => {\n-                let layout = fx.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n-                let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n-                    kind: StackSlotKind::ExplicitSlot,\n-                    size: layout.size.bytes() as u32,\n-                    offset: None,\n-                });\n-                fx.bcx.ins().stack_store(value, stack_slot, 0);\n-                fx.bcx.ins().stack_addr(types::I64, stack_slot, 0)\n-            }\n-            CValue::Func(func) => {\n-                let func = fx.bcx.ins().func_addr(types::I64, func);\n-                CValue::ByVal(func).force_stack(fx, ty)\n-            }\n-        }\n-    }\n-\n-    fn load_value<'a, 'tcx: 'a>(self, fx: &mut FunctionCx<'a, 'tcx>, ty: Ty<'tcx>) -> Value {\n-        match self {\n-            CValue::ByRef(value) => {\n-                let cton_ty = cton_type_from_ty(ty).unwrap();\n-                load_workaround(fx, cton_ty, value, 0)\n-            }\n-            CValue::ByVal(value) => value,\n-            CValue::Func(func) => {\n-                fx.bcx.ins().func_addr(types::I64, func)\n-            }\n-        }\n-    }\n-\n-    fn expect_byref(self) -> Value {\n-        match self {\n-            CValue::ByRef(value) => value,\n-            CValue::ByVal(_) => bug!(\"Expected CValue::ByRef, found CValue::ByVal\"),\n-            CValue::Func(_) => bug!(\"Expected CValue::ByRef, found CValue::Func\"),\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-enum CPlace {\n-    Var(Variable),\n-    Addr(Value),\n-}\n-\n-impl<'a, 'tcx: 'a> CPlace {\n-    fn from_stack_slot(fx: &mut FunctionCx<'a, 'tcx>, stack_slot: StackSlot) -> CPlace {\n-        CPlace::Addr(fx.bcx.ins().stack_addr(types::I64, stack_slot, 0))\n-    }\n-\n-    fn to_cvalue(self, fx: &mut FunctionCx<'a, 'tcx>) -> CValue {\n-        match self {\n-            CPlace::Var(var) => CValue::ByVal(fx.bcx.use_var(var)),\n-            CPlace::Addr(addr) => CValue::ByRef(addr),\n-        }\n-    }\n-\n-    fn expect_addr(self) -> Value {\n-        match self {\n-            CPlace::Addr(addr) => addr,\n-            CPlace::Var(_) => bug!(\"Expected CPlace::Addr, found CPlace::Var\"),\n-        }\n-    }\n-\n-    fn write_cvalue(self, fx: &mut FunctionCx<'a, 'tcx>, from: CValue, ty: Ty<'tcx>) {\n-        let layout = fx.tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n-        let size = layout.size.bytes() as i32;\n-        match self {\n-            CPlace::Var(var) => {\n-                let data = from.load_value(fx, ty);\n-                fx.bcx.def_var(var, data)\n-            },\n-            CPlace::Addr(addr) => {\n-                if let Some(cton_ty) = cton_type_from_ty(ty) {\n-                    let data = from.load_value(fx, ty);\n-                    store_workaround(fx, cton_ty, addr, data, 0);\n-                } else {\n-                    for i in 0..size {\n-                        let from = from.expect_byref();\n-                        let byte = load_workaround(fx, types::I8, from, i);\n-                        store_workaround(fx, types::I8, addr, byte, i);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n pub fn trans_crate<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Box<Any> {\n     let link_meta = ::build_link_meta(tcx.crate_hash(LOCAL_CRATE));\n     let metadata = tcx.encode_metadata(&link_meta);\n@@ -249,36 +103,6 @@ struct CodegenCx<'a, 'tcx: 'a, B: Backend + 'a> {\n     def_id_fn_id_map: &'a mut HashMap<Instance<'tcx>, FuncId>,\n }\n \n-struct FunctionCx<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    module: &'a mut Module<CurrentBackend>,\n-    def_id_fn_id_map: &'a mut HashMap<Instance<'tcx>, FuncId>,\n-    bcx: FunctionBuilder<'a, Variable>,\n-    mir: &'tcx Mir<'tcx>,\n-    ebb_map: HashMap<BasicBlock, Ebb>,\n-    local_map: HashMap<Local, CPlace>,\n-}\n-\n-impl<'f, 'tcx> FunctionCx<'f, 'tcx> {\n-    fn get_ebb(&self, bb: BasicBlock) -> Ebb {\n-        *self.ebb_map.get(&bb).unwrap()\n-    }\n-\n-    fn get_local_place(&mut self, local: Local) -> CPlace {\n-        *self.local_map.get(&local).unwrap()\n-    }\n-\n-    fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n-        let tcx = self.tcx;\n-        let module = &mut self.module;\n-        let func_id = *self.def_id_fn_id_map.entry(inst).or_insert_with(|| {\n-            let sig = cton_sig_from_instance(tcx, inst);\n-            module.declare_function(&tcx.absolute_item_path_str(inst.def_id()), Linkage::Local, &sig).unwrap()\n-        });\n-        module.declare_func_in_func(func_id, &mut self.bcx.func)\n-    }\n-}\n-\n fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &mut Function, def_id: DefId, substs: &Substs<'tcx>) {\n     let mir = cx.tcx.optimized_mir(def_id);\n     let mut func_ctx = FunctionBuilderContext::new();\n@@ -553,64 +377,3 @@ fn trans_operand<'a, 'tcx>(fx: &mut FunctionCx<'a, 'tcx>, operand: &Operand<'tcx\n         }\n     }\n }\n-\n-fn ext_name_from_did(def_id: DefId) -> ExternalName {\n-    ExternalName::user(def_id.krate.as_u32(), def_id.index.as_raw_u32())\n-}\n-\n-fn cton_sig_from_fn_sig<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sig: PolyFnSig<'tcx>, substs: &Substs<'tcx>) -> Signature {\n-    let sig = tcx.subst_and_normalize_erasing_regions(substs, ParamEnv::reveal_all(), &sig);\n-    cton_sig_from_mono_fn_sig(sig)\n-}\n-\n-fn cton_sig_from_instance<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, inst: Instance<'tcx>) -> Signature {\n-    let fn_ty = inst.ty(tcx);\n-    let sig = fn_ty.fn_sig(tcx);\n-    cton_sig_from_mono_fn_sig(sig)\n-}\n-\n-fn cton_sig_from_mono_fn_sig<'a ,'tcx: 'a>(sig: PolyFnSig<'tcx>) -> Signature {\n-    let sig = sig.skip_binder();\n-    let inputs = sig.inputs();\n-    let _output = sig.output();\n-    assert!(!sig.variadic, \"Variadic function are not yet supported\");\n-    let call_conv = match sig.abi {\n-        _ => CallConv::SystemV,\n-    };\n-    Signature {\n-        params: Some(types::I64).into_iter() // First param is place to put return val\n-            .chain(inputs.into_iter().map(|ty| cton_type_from_ty(ty).unwrap_or(types::I64)))\n-            .map(AbiParam::new).collect(),\n-        returns: vec![],\n-        call_conv,\n-        argument_bytes: None,\n-    }\n-}\n-\n-fn cton_type_from_ty(ty: Ty) -> Option<types::Type> {\n-    Some(match ty.sty {\n-        TypeVariants::TyBool => types::I8,\n-        TypeVariants::TyUint(size) => {\n-            match size {\n-                UintTy::U8 => types::I8,\n-                UintTy::U16 => types::I16,\n-                UintTy::U32 => types::I32,\n-                UintTy::U64 => types::I64,\n-                UintTy::U128 => unimplemented!(),\n-                UintTy::Usize => unimplemented!(),\n-            }\n-        }\n-        TypeVariants::TyInt(size) => {\n-            match size {\n-                IntTy::I8 => types::I8,\n-                IntTy::I16 => types::I16,\n-                IntTy::I32 => types::I32,\n-                IntTy::I64 => types::I64,\n-                IntTy::I128 => unimplemented!(),\n-                IntTy::Isize => unimplemented!(),\n-            }\n-        }\n-        TypeVariants::TyFnPtr(_) => types::I64,\n-        _ => return None,\n-    })\n-}"}, {"sha": "34196c6fc59654e9d9701f9b9da36bdb878feb2e", "filename": "src/common.rs", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/c7e7e1fe0fa8468b3cd8bc7db7d0332d7257b74e/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e7e1fe0fa8468b3cd8bc7db7d0332d7257b74e/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=c7e7e1fe0fa8468b3cd8bc7db7d0332d7257b74e", "patch": "@@ -0,0 +1,232 @@\n+use syntax::ast::{IntTy, UintTy};\n+\n+use cretonne_module::{Module, Linkage, FuncId};\n+\n+use prelude::*;\n+\n+pub type CurrentBackend = ::cretonne_simplejit::SimpleJITBackend;\n+\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+pub struct Variable(Local);\n+\n+impl EntityRef for Variable {\n+    fn new(u: usize) -> Self {\n+        Variable(Local::new(u))\n+    }\n+\n+    fn index(self) -> usize {\n+        self.0.index()\n+    }\n+}\n+\n+pub fn cton_type_from_ty(ty: Ty) -> Option<types::Type> {\n+    Some(match ty.sty {\n+        TypeVariants::TyBool => types::I8,\n+        TypeVariants::TyUint(size) => {\n+            match size {\n+                UintTy::U8 => types::I8,\n+                UintTy::U16 => types::I16,\n+                UintTy::U32 => types::I32,\n+                UintTy::U64 => types::I64,\n+                UintTy::U128 => unimplemented!(),\n+                UintTy::Usize => unimplemented!(),\n+            }\n+        }\n+        TypeVariants::TyInt(size) => {\n+            match size {\n+                IntTy::I8 => types::I8,\n+                IntTy::I16 => types::I16,\n+                IntTy::I32 => types::I32,\n+                IntTy::I64 => types::I64,\n+                IntTy::I128 => unimplemented!(),\n+                IntTy::Isize => unimplemented!(),\n+            }\n+        }\n+        TypeVariants::TyFnPtr(_) => types::I64,\n+        _ => return None,\n+    })\n+}\n+\n+// FIXME(cretonne) fix load.i8\n+fn load_workaround(fx: &mut FunctionCx, ty: Type, addr: Value, offset: i32) -> Value {\n+    use cretonne::codegen::ir::types::*;\n+    match ty {\n+        I8 => fx.bcx.ins().uload8(I32, MemFlags::new(), addr, offset),\n+        I16 => fx.bcx.ins().uload16(I32, MemFlags::new(), addr, offset),\n+        // I32 and I64 work\n+        _ => fx.bcx.ins().load(ty, MemFlags::new(), addr, offset),\n+    }\n+}\n+\n+// FIXME(cretonne) fix store.i8\n+fn store_workaround(fx: &mut FunctionCx, ty: Type, addr: Value, val: Value, offset: i32) {\n+    use cretonne::codegen::ir::types::*;\n+    match ty {\n+        I8 => fx.bcx.ins().istore8(MemFlags::new(), val, addr, offset),\n+        I16 => fx.bcx.ins().istore16(MemFlags::new(), val, addr, offset),\n+        // I32 and I64 work\n+        _ => fx.bcx.ins().store(MemFlags::new(), val, addr, offset),\n+    };\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum CValue {\n+    ByRef(Value),\n+    ByVal(Value),\n+    Func(FuncRef),\n+}\n+\n+impl CValue {\n+    pub fn force_stack<'a, 'tcx: 'a>(self, fx: &mut FunctionCx<'a, 'tcx>, ty: Ty<'tcx>) -> Value {\n+        match self {\n+            CValue::ByRef(value) => value,\n+            CValue::ByVal(value) => {\n+                let layout = fx.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n+                let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+                    kind: StackSlotKind::ExplicitSlot,\n+                    size: layout.size.bytes() as u32,\n+                    offset: None,\n+                });\n+                fx.bcx.ins().stack_store(value, stack_slot, 0);\n+                fx.bcx.ins().stack_addr(types::I64, stack_slot, 0)\n+            }\n+            CValue::Func(func) => {\n+                let func = fx.bcx.ins().func_addr(types::I64, func);\n+                CValue::ByVal(func).force_stack(fx, ty)\n+            }\n+        }\n+    }\n+\n+    pub fn load_value<'a, 'tcx: 'a>(self, fx: &mut FunctionCx<'a, 'tcx>, ty: Ty<'tcx>) -> Value {\n+        match self {\n+            CValue::ByRef(value) => {\n+                let cton_ty = cton_type_from_ty(ty).unwrap();\n+                load_workaround(fx, cton_ty, value, 0)\n+            }\n+            CValue::ByVal(value) => value,\n+            CValue::Func(func) => {\n+                fx.bcx.ins().func_addr(types::I64, func)\n+            }\n+        }\n+    }\n+\n+    pub fn expect_byref(self) -> Value {\n+        match self {\n+            CValue::ByRef(value) => value,\n+            CValue::ByVal(_) => bug!(\"Expected CValue::ByRef, found CValue::ByVal\"),\n+            CValue::Func(_) => bug!(\"Expected CValue::ByRef, found CValue::Func\"),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum CPlace {\n+    Var(Variable),\n+    Addr(Value),\n+}\n+\n+impl<'a, 'tcx: 'a> CPlace {\n+    pub fn from_stack_slot(fx: &mut FunctionCx<'a, 'tcx>, stack_slot: StackSlot) -> CPlace {\n+        CPlace::Addr(fx.bcx.ins().stack_addr(types::I64, stack_slot, 0))\n+    }\n+\n+    pub fn to_cvalue(self, fx: &mut FunctionCx<'a, 'tcx>) -> CValue {\n+        match self {\n+            CPlace::Var(var) => CValue::ByVal(fx.bcx.use_var(var)),\n+            CPlace::Addr(addr) => CValue::ByRef(addr),\n+        }\n+    }\n+\n+    pub fn expect_addr(self) -> Value {\n+        match self {\n+            CPlace::Addr(addr) => addr,\n+            CPlace::Var(_) => bug!(\"Expected CPlace::Addr, found CPlace::Var\"),\n+        }\n+    }\n+\n+    pub fn write_cvalue(self, fx: &mut FunctionCx<'a, 'tcx>, from: CValue, ty: Ty<'tcx>) {\n+        let layout = fx.tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n+        let size = layout.size.bytes() as i32;\n+        match self {\n+            CPlace::Var(var) => {\n+                let data = from.load_value(fx, ty);\n+                fx.bcx.def_var(var, data)\n+            },\n+            CPlace::Addr(addr) => {\n+                if let Some(cton_ty) = cton_type_from_ty(ty) {\n+                    let data = from.load_value(fx, ty);\n+                    store_workaround(fx, cton_ty, addr, data, 0);\n+                } else {\n+                    for i in 0..size {\n+                        let from = from.expect_byref();\n+                        let byte = load_workaround(fx, types::I8, from, i);\n+                        store_workaround(fx, types::I8, addr, byte, i);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub fn ext_name_from_did(def_id: DefId) -> ExternalName {\n+    ExternalName::user(def_id.krate.as_u32(), def_id.index.as_raw_u32())\n+}\n+\n+pub fn cton_sig_from_fn_sig<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sig: PolyFnSig<'tcx>, substs: &Substs<'tcx>) -> Signature {\n+    let sig = tcx.subst_and_normalize_erasing_regions(substs, ParamEnv::reveal_all(), &sig);\n+    cton_sig_from_mono_fn_sig(sig)\n+}\n+\n+pub fn cton_sig_from_instance<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, inst: Instance<'tcx>) -> Signature {\n+    let fn_ty = inst.ty(tcx);\n+    let sig = fn_ty.fn_sig(tcx);\n+    cton_sig_from_mono_fn_sig(sig)\n+}\n+\n+pub fn cton_sig_from_mono_fn_sig<'a ,'tcx: 'a>(sig: PolyFnSig<'tcx>) -> Signature {\n+    let sig = sig.skip_binder();\n+    let inputs = sig.inputs();\n+    let _output = sig.output();\n+    assert!(!sig.variadic, \"Variadic function are not yet supported\");\n+    let call_conv = match sig.abi {\n+        _ => CallConv::SystemV,\n+    };\n+    Signature {\n+        params: Some(types::I64).into_iter() // First param is place to put return val\n+            .chain(inputs.into_iter().map(|ty| cton_type_from_ty(ty).unwrap_or(types::I64)))\n+            .map(AbiParam::new).collect(),\n+        returns: vec![],\n+        call_conv,\n+        argument_bytes: None,\n+    }\n+}\n+\n+pub struct FunctionCx<'a, 'tcx: 'a> {\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub module: &'a mut Module<CurrentBackend>,\n+    pub def_id_fn_id_map: &'a mut HashMap<Instance<'tcx>, FuncId>,\n+    pub bcx: FunctionBuilder<'a, Variable>,\n+    pub mir: &'tcx Mir<'tcx>,\n+    pub ebb_map: HashMap<BasicBlock, Ebb>,\n+    pub local_map: HashMap<Local, CPlace>,\n+}\n+\n+impl<'f, 'tcx> FunctionCx<'f, 'tcx> {\n+    pub fn get_ebb(&self, bb: BasicBlock) -> Ebb {\n+        *self.ebb_map.get(&bb).unwrap()\n+    }\n+\n+    pub fn get_local_place(&mut self, local: Local) -> CPlace {\n+        *self.local_map.get(&local).unwrap()\n+    }\n+\n+    pub fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n+        let tcx = self.tcx;\n+        let module = &mut self.module;\n+        let func_id = *self.def_id_fn_id_map.entry(inst).or_insert_with(|| {\n+            let sig = cton_sig_from_instance(tcx, inst);\n+            module.declare_function(&tcx.absolute_item_path_str(inst.def_id()), Linkage::Local, &sig).unwrap()\n+        });\n+        module.declare_func_in_func(func_id, &mut self.bcx.func)\n+    }\n+}"}, {"sha": "039fdbd8e6171d08d33ff9e61738821adf11f104", "filename": "src/lib.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c7e7e1fe0fa8468b3cd8bc7db7d0332d7257b74e/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e7e1fe0fa8468b3cd8bc7db7d0332d7257b74e/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c7e7e1fe0fa8468b3cd8bc7db7d0332d7257b74e", "patch": "@@ -33,8 +33,11 @@ use std::fs::File;\n use std::io::Write;\n \n mod base;\n+mod common;\n \n mod prelude {\n+    pub use std::collections::HashMap;\n+\n     pub use rustc::session::Session;\n     pub use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n     pub use rustc::ty::{TyCtxt, Ty, TypeVariants, Instance, InstanceDef, ParamEnv, FnSig, PolyFnSig, subst::Substs};\n@@ -44,6 +47,19 @@ mod prelude {\n         sync::Lrc,\n         indexed_vec::Idx,\n     };\n+\n+    pub use cretonne::prelude::*;\n+    pub use cretonne::codegen::Context;\n+    pub use cretonne::codegen::ir::{\n+        ExternalName,\n+        FuncRef,\n+        StackSlot,\n+        function::Function,\n+    };\n+\n+\n+    pub use common::*;\n+    pub use common::Variable;\n }\n \n use prelude::*;"}]}