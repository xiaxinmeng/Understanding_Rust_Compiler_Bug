{"sha": "6f1f91cdcfc03e2a49cc66b76caff645f8b33d42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmMWY5MWNkY2ZjMDNlMmE0OWNjNjZiNzZjYWZmNjQ1ZjhiMzNkNDI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-22T12:08:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-22T12:08:25Z"}, "message": "Merge #8136 #8146\n\n8136: Introduce QuantifiedWhereClause and DynTy analogous to Chalk r=flodiebold a=flodiebold\n\nThis introduces a bunch of new binders in lots of places, which we have to be careful about, but we had to add them at some point. There's a lot of skipping of the binders; once we're done with the Chalk move, we should review the remaining ones.\n\n8146: Document patch policy r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "efcde2674a32e359c03c74b4d5eebd1071b4f88b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efcde2674a32e359c03c74b4d5eebd1071b4f88b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgWIi5CRBK7hj4Ov3rIwAAdHIIAAWii6V62k0erWFaRSttJVv9\nC1E3+8JrDcdi13g6EqwzCTrIlTDSDgUTdDvdQoYYYwSYa8CGkSeM1EWSF2xRJsl3\n9wuotrMhoXIh/QW3dG0A0WZKs27X2h7A3nV7ZZ0WlhCwjRGvHSs9YhN8H/6hzt60\n+zafvwUGFq+jJiowaJtJsKwB6iuPTDx+XRFi+mT5yDyafiG8IL1Brr1qhEq4QDRR\nph3vaN48mv3H0yaK/BLCFfRm0GbTWf4Nnaa/ArjXNYJygDaO+9kn14LEPnyfZrln\nL4Sm1fDKu7NCQLmISz3CA3FjxcGuwNlqbF5a1FY2S5Pe2hgIBSOpYc+T5/aqDQU=\n=GBNz\n-----END PGP SIGNATURE-----\n", "payload": "tree efcde2674a32e359c03c74b4d5eebd1071b4f88b\nparent ad39959361f32551ab788126b0a5b8b4b09138ef\nparent 1d5c4a77fb33cab7bf8f9d2edc6dd26b09ef65f3\nparent 79b4c89b8959fe62ba31962dd4ec7609127970de\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1616414905 +0000\ncommitter GitHub <noreply@github.com> 1616414905 +0000\n\nMerge #8136 #8146\n\n8136: Introduce QuantifiedWhereClause and DynTy analogous to Chalk r=flodiebold a=flodiebold\n\nThis introduces a bunch of new binders in lots of places, which we have to be careful about, but we had to add them at some point. There's a lot of skipping of the binders; once we're done with the Chalk move, we should review the remaining ones.\n\n8146: Document patch policy r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42", "html_url": "https://github.com/rust-lang/rust/commit/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad39959361f32551ab788126b0a5b8b4b09138ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad39959361f32551ab788126b0a5b8b4b09138ef", "html_url": "https://github.com/rust-lang/rust/commit/ad39959361f32551ab788126b0a5b8b4b09138ef"}, {"sha": "1d5c4a77fb33cab7bf8f9d2edc6dd26b09ef65f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d5c4a77fb33cab7bf8f9d2edc6dd26b09ef65f3", "html_url": "https://github.com/rust-lang/rust/commit/1d5c4a77fb33cab7bf8f9d2edc6dd26b09ef65f3"}, {"sha": "79b4c89b8959fe62ba31962dd4ec7609127970de", "url": "https://api.github.com/repos/rust-lang/rust/commits/79b4c89b8959fe62ba31962dd4ec7609127970de", "html_url": "https://github.com/rust-lang/rust/commit/79b4c89b8959fe62ba31962dd4ec7609127970de"}], "stats": {"total": 328, "additions": 215, "deletions": 113}, "files": [{"sha": "a325b6691a0023c48e63b54e3f7132716e88c854", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=6f1f91cdcfc03e2a49cc66b76caff645f8b33d42", "patch": "@@ -57,8 +57,8 @@ use hir_ty::{\n     to_assoc_type_id,\n     traits::{FnTrait, Solution, SolutionVariables},\n     AliasEq, AliasTy, BoundVar, CallableDefId, CallableSig, Canonical, Cast, DebruijnIndex,\n-    InEnvironment, Interner, ProjectionTy, Scalar, Substitution, Ty, TyDefId, TyKind,\n-    TyVariableKind, WhereClause,\n+    InEnvironment, Interner, ProjectionTy, QuantifiedWhereClause, Scalar, Substitution, Ty,\n+    TyDefId, TyKind, TyVariableKind, WhereClause,\n };\n use itertools::Itertools;\n use rustc_hash::FxHashSet;\n@@ -1460,7 +1460,7 @@ impl TypeParam {\n     pub fn trait_bounds(self, db: &dyn HirDatabase) -> Vec<Trait> {\n         db.generic_predicates_for_param(self.id)\n             .into_iter()\n-            .filter_map(|pred| match &pred.value {\n+            .filter_map(|pred| match &pred.skip_binders().skip_binders() {\n                 hir_ty::WhereClause::Implemented(trait_ref) => {\n                     Some(Trait::from(trait_ref.hir_trait_id()))\n                 }\n@@ -2022,7 +2022,7 @@ impl Type {\n     pub fn as_impl_traits(&self, db: &dyn HirDatabase) -> Option<Vec<Trait>> {\n         self.ty.value.impl_trait_bounds(db).map(|it| {\n             it.into_iter()\n-                .filter_map(|pred| match pred {\n+                .filter_map(|pred| match pred.skip_binders() {\n                     hir_ty::WhereClause::Implemented(trait_ref) => {\n                         Some(Trait::from(trait_ref.hir_trait_id()))\n                     }\n@@ -2061,11 +2061,11 @@ impl Type {\n         fn walk_bounds(\n             db: &dyn HirDatabase,\n             type_: &Type,\n-            bounds: &[WhereClause],\n+            bounds: &[QuantifiedWhereClause],\n             cb: &mut impl FnMut(Type),\n         ) {\n             for pred in bounds {\n-                match pred {\n+                match pred.skip_binders() {\n                     WhereClause::Implemented(trait_ref) => {\n                         cb(type_.clone());\n                         // skip the self type. it's likely the type we just got the bounds from\n@@ -2107,7 +2107,12 @@ impl Type {\n                     }\n                 }\n                 TyKind::Dyn(bounds) => {\n-                    walk_bounds(db, &type_.derived(ty.clone()), bounds.as_ref(), cb);\n+                    walk_bounds(\n+                        db,\n+                        &type_.derived(ty.clone()),\n+                        bounds.bounds.skip_binders().interned(),\n+                        cb,\n+                    );\n                 }\n \n                 TyKind::Ref(_, ty) | TyKind::Raw(_, ty) | TyKind::Array(ty) | TyKind::Slice(ty) => {"}, {"sha": "58e4247c6ae7c824ebabbf019aa5a3da933fb17a", "filename": "crates/hir_ty/src/db.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdb.rs?ref=6f1f91cdcfc03e2a49cc66b76caff645f8b33d42", "patch": "@@ -12,8 +12,8 @@ use la_arena::ArenaMap;\n use crate::{\n     method_resolution::{InherentImpls, TraitImpls},\n     traits::chalk,\n-    Binders, CallableDefId, FnDefId, ImplTraitId, InferenceResult, PolyFnSig, ReturnTypeImplTraits,\n-    TraitRef, Ty, TyDefId, ValueTyDefId, WhereClause,\n+    Binders, CallableDefId, FnDefId, ImplTraitId, InferenceResult, PolyFnSig,\n+    QuantifiedWhereClause, ReturnTypeImplTraits, TraitRef, Ty, TyDefId, ValueTyDefId,\n };\n use hir_expand::name::Name;\n \n@@ -57,10 +57,13 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n \n     #[salsa::invoke(crate::lower::generic_predicates_for_param_query)]\n     #[salsa::cycle(crate::lower::generic_predicates_for_param_recover)]\n-    fn generic_predicates_for_param(&self, param_id: TypeParamId) -> Arc<[Binders<WhereClause>]>;\n+    fn generic_predicates_for_param(\n+        &self,\n+        param_id: TypeParamId,\n+    ) -> Arc<[Binders<QuantifiedWhereClause>]>;\n \n     #[salsa::invoke(crate::lower::generic_predicates_query)]\n-    fn generic_predicates(&self, def: GenericDefId) -> Arc<[Binders<WhereClause>]>;\n+    fn generic_predicates(&self, def: GenericDefId) -> Arc<[Binders<QuantifiedWhereClause>]>;\n \n     #[salsa::invoke(crate::lower::trait_environment_query)]\n     fn trait_environment(&self, def: GenericDefId) -> Arc<crate::TraitEnvironment>;"}, {"sha": "cc6b93d37ad92da1b4c8990ec2f70c5f3e3c9f85", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=6f1f91cdcfc03e2a49cc66b76caff645f8b33d42", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use std::{borrow::Cow, fmt};\n+use std::fmt;\n \n use arrayvec::ArrayVec;\n use chalk_ir::Mutability;\n@@ -20,7 +20,7 @@ use crate::{\n     db::HirDatabase, from_assoc_type_id, from_foreign_def_id, from_placeholder_idx, primitive,\n     to_assoc_type_id, traits::chalk::from_chalk, utils::generics, AdtId, AliasEq, AliasTy,\n     CallableDefId, CallableSig, DomainGoal, ImplTraitId, Interner, Lifetime, OpaqueTy,\n-    ProjectionTy, Scalar, Substitution, TraitRef, Ty, TyKind, WhereClause,\n+    ProjectionTy, QuantifiedWhereClause, Scalar, Substitution, TraitRef, Ty, TyKind, WhereClause,\n };\n \n pub struct HirFormatter<'a> {\n@@ -328,9 +328,9 @@ impl HirDisplay for Ty {\n \n                 // FIXME: all this just to decide whether to use parentheses...\n                 let datas;\n-                let predicates = match t.interned(&Interner) {\n-                    TyKind::Dyn(predicates) if predicates.len() > 1 => {\n-                        Cow::Borrowed(predicates.as_ref())\n+                let predicates: Vec<_> = match t.interned(&Interner) {\n+                    TyKind::Dyn(dyn_ty) if dyn_ty.bounds.skip_binders().interned().len() > 1 => {\n+                        dyn_ty.bounds.skip_binders().interned().iter().cloned().collect()\n                     }\n                     &TyKind::Alias(AliasTy::Opaque(OpaqueTy {\n                         opaque_ty_id,\n@@ -345,17 +345,21 @@ impl HirDisplay for Ty {\n                                 .as_ref()\n                                 .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n                             let bounds = data.subst(parameters);\n-                            Cow::Owned(bounds.value)\n+                            bounds.value\n                         } else {\n-                            Cow::Borrowed(&[][..])\n+                            Vec::new()\n                         }\n                     }\n-                    _ => Cow::Borrowed(&[][..]),\n+                    _ => Vec::new(),\n                 };\n \n-                if let [WhereClause::Implemented(trait_ref), _] = predicates.as_ref() {\n+                if let Some(WhereClause::Implemented(trait_ref)) =\n+                    predicates.get(0).map(|b| b.skip_binders())\n+                {\n                     let trait_ = trait_ref.hir_trait_id();\n-                    if fn_traits(f.db.upcast(), trait_).any(|it| it == trait_) {\n+                    if fn_traits(f.db.upcast(), trait_).any(|it| it == trait_)\n+                        && predicates.len() <= 2\n+                    {\n                         return write!(f, \"{}\", ty_display);\n                     }\n                 }\n@@ -577,7 +581,7 @@ impl HirDisplay for Ty {\n                             .generic_predicates(id.parent)\n                             .into_iter()\n                             .map(|pred| pred.clone().subst(&substs))\n-                            .filter(|wc| match &wc {\n+                            .filter(|wc| match &wc.skip_binders() {\n                                 WhereClause::Implemented(tr) => tr.self_type_parameter() == self,\n                                 WhereClause::AliasEq(AliasEq {\n                                     alias: AliasTy::Projection(proj),\n@@ -591,8 +595,12 @@ impl HirDisplay for Ty {\n                 }\n             }\n             TyKind::BoundVar(idx) => write!(f, \"?{}.{}\", idx.debruijn.depth(), idx.index)?,\n-            TyKind::Dyn(predicates) => {\n-                write_bounds_like_dyn_trait_with_prefix(\"dyn\", predicates, f)?;\n+            TyKind::Dyn(dyn_ty) => {\n+                write_bounds_like_dyn_trait_with_prefix(\n+                    \"dyn\",\n+                    dyn_ty.bounds.skip_binders().interned(),\n+                    f,\n+                )?;\n             }\n             TyKind::Alias(AliasTy::Projection(p_ty)) => p_ty.hir_fmt(f)?,\n             TyKind::Alias(AliasTy::Opaque(opaque_ty)) => {\n@@ -661,7 +669,7 @@ fn fn_traits(db: &dyn DefDatabase, trait_: TraitId) -> impl Iterator<Item = Trai\n \n pub fn write_bounds_like_dyn_trait_with_prefix(\n     prefix: &str,\n-    predicates: &[WhereClause],\n+    predicates: &[QuantifiedWhereClause],\n     f: &mut HirFormatter,\n ) -> Result<(), HirDisplayError> {\n     write!(f, \"{}\", prefix)?;\n@@ -674,7 +682,7 @@ pub fn write_bounds_like_dyn_trait_with_prefix(\n }\n \n fn write_bounds_like_dyn_trait(\n-    predicates: &[WhereClause],\n+    predicates: &[QuantifiedWhereClause],\n     f: &mut HirFormatter,\n ) -> Result<(), HirDisplayError> {\n     // Note: This code is written to produce nice results (i.e.\n@@ -687,7 +695,7 @@ fn write_bounds_like_dyn_trait(\n     let mut angle_open = false;\n     let mut is_fn_trait = false;\n     for p in predicates.iter() {\n-        match p {\n+        match p.skip_binders() {\n             WhereClause::Implemented(trait_ref) => {\n                 let trait_ = trait_ref.hir_trait_id();\n                 if !is_fn_trait {"}, {"sha": "05cbde4e3fb65705ac7ab6526772e87ce6bf74f3", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=6f1f91cdcfc03e2a49cc66b76caff645f8b33d42", "patch": "@@ -11,6 +11,7 @@ use hir_def::{\n     AssocContainerId, FieldId, Lookup,\n };\n use hir_expand::name::{name, Name};\n+use stdx::always;\n use syntax::ast::RangeOp;\n \n use crate::{\n@@ -936,7 +937,9 @@ impl<'a> InferenceContext<'a> {\n             let def: CallableDefId = from_chalk(self.db, *fn_def);\n             let generic_predicates = self.db.generic_predicates(def.into());\n             for predicate in generic_predicates.iter() {\n-                let predicate = predicate.clone().subst(parameters);\n+                let (predicate, binders) =\n+                    predicate.clone().subst(parameters).into_value_and_skipped_binders();\n+                always!(binders == 0); // quantified where clauses not yet handled\n                 self.obligations.push(predicate.cast(&Interner));\n             }\n             // add obligation for trait implementation, if this is a trait method"}, {"sha": "35b0a20597ac6f1b5a3ca0a9b45085ef1fdf1eb0", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=6f1f91cdcfc03e2a49cc66b76caff645f8b33d42", "patch": "@@ -310,9 +310,18 @@ impl InferenceTable {\n \n             (TyKind::Placeholder(p1), TyKind::Placeholder(p2)) if *p1 == *p2 => true,\n \n-            (TyKind::Dyn(dyn1), TyKind::Dyn(dyn2)) if dyn1.len() == dyn2.len() => {\n-                for (pred1, pred2) in dyn1.iter().zip(dyn2.iter()) {\n-                    if !self.unify_preds(pred1, pred2, depth + 1) {\n+            (TyKind::Dyn(dyn1), TyKind::Dyn(dyn2))\n+                if dyn1.bounds.skip_binders().interned().len()\n+                    == dyn2.bounds.skip_binders().interned().len() =>\n+            {\n+                for (pred1, pred2) in dyn1\n+                    .bounds\n+                    .skip_binders()\n+                    .interned()\n+                    .iter()\n+                    .zip(dyn2.bounds.skip_binders().interned().iter())\n+                {\n+                    if !self.unify_preds(pred1.skip_binders(), pred2.skip_binders(), depth + 1) {\n                         return false;\n                     }\n                 }"}, {"sha": "90b5b17e2a411fbfdd86b906ab5a0cf918fd74f2", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 61, "deletions": 17, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=6f1f91cdcfc03e2a49cc66b76caff645f8b33d42", "patch": "@@ -132,6 +132,12 @@ impl TypeWalk for ProjectionTy {\n     }\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct DynTy {\n+    /// The unknown self type.\n+    pub bounds: Binders<QuantifiedWhereClauses>,\n+}\n+\n pub type FnSig = chalk_ir::FnSig<Interner>;\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n@@ -283,7 +289,7 @@ pub enum TyKind {\n     /// represents the `Self` type inside the bounds. This is currently\n     /// implicit; Chalk has the `Binders` struct to make it explicit, but it\n     /// didn't seem worth the overhead yet.\n-    Dyn(Arc<[WhereClause]>),\n+    Dyn(DynTy),\n \n     /// A placeholder for a type which could not be computed; this is propagated\n     /// to avoid useless error messages. Doubles as a placeholder where type\n@@ -490,6 +496,13 @@ impl<T> Binders<T> {\n         Self { num_binders, value }\n     }\n \n+    pub fn wrap_empty(value: T) -> Self\n+    where\n+        T: TypeWalk,\n+    {\n+        Self { num_binders: 0, value: value.shift_bound_vars(DebruijnIndex::ONE) }\n+    }\n+\n     pub fn as_ref(&self) -> Binders<&T> {\n         Binders { num_binders: self.num_binders, value: &self.value }\n     }\n@@ -501,6 +514,14 @@ impl<T> Binders<T> {\n     pub fn filter_map<U>(self, f: impl FnOnce(T) -> Option<U>) -> Option<Binders<U>> {\n         Some(Binders { num_binders: self.num_binders, value: f(self.value)? })\n     }\n+\n+    pub fn skip_binders(&self) -> &T {\n+        &self.value\n+    }\n+\n+    pub fn into_value_and_skipped_binders(self) -> (T, usize) {\n+        (self.value, self.num_binders)\n+    }\n }\n \n impl<T: Clone> Binders<&T> {\n@@ -614,6 +635,24 @@ impl TypeWalk for WhereClause {\n     }\n }\n \n+pub type QuantifiedWhereClause = Binders<WhereClause>;\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct QuantifiedWhereClauses(Arc<[QuantifiedWhereClause]>);\n+\n+impl QuantifiedWhereClauses {\n+    pub fn from_iter(\n+        _interner: &Interner,\n+        elements: impl IntoIterator<Item = QuantifiedWhereClause>,\n+    ) -> Self {\n+        QuantifiedWhereClauses(elements.into_iter().collect())\n+    }\n+\n+    pub fn interned(&self) -> &Arc<[QuantifiedWhereClause]> {\n+        &self.0\n+    }\n+}\n+\n /// Basically a claim (currently not validated / checked) that the contained\n /// type / trait ref contains no inference variables; any inference variables it\n /// contained have been replaced by bound variables, and `kinds` tells us how\n@@ -810,12 +849,14 @@ impl Ty {\n     }\n \n     /// If this is a `dyn Trait` type, this returns the `Trait` part.\n-    pub fn dyn_trait_ref(&self) -> Option<&TraitRef> {\n+    fn dyn_trait_ref(&self) -> Option<&TraitRef> {\n         match self.interned(&Interner) {\n-            TyKind::Dyn(bounds) => bounds.get(0).and_then(|b| match b {\n-                WhereClause::Implemented(trait_ref) => Some(trait_ref),\n-                _ => None,\n-            }),\n+            TyKind::Dyn(dyn_ty) => {\n+                dyn_ty.bounds.value.interned().get(0).and_then(|b| match b.skip_binders() {\n+                    WhereClause::Implemented(trait_ref) => Some(trait_ref),\n+                    _ => None,\n+                })\n+            }\n             _ => None,\n         }\n     }\n@@ -892,7 +933,7 @@ impl Ty {\n         }\n     }\n \n-    pub fn impl_trait_bounds(&self, db: &dyn HirDatabase) -> Option<Vec<WhereClause>> {\n+    pub fn impl_trait_bounds(&self, db: &dyn HirDatabase) -> Option<Vec<QuantifiedWhereClause>> {\n         match self.interned(&Interner) {\n             TyKind::OpaqueType(opaque_ty_id, ..) => {\n                 match db.lookup_intern_impl_trait_id((*opaque_ty_id).into()) {\n@@ -905,10 +946,13 @@ impl Ty {\n                             // This is only used by type walking.\n                             // Parameters will be walked outside, and projection predicate is not used.\n                             // So just provide the Future trait.\n-                            let impl_bound = WhereClause::Implemented(TraitRef {\n-                                trait_id: to_chalk_trait_id(future_trait),\n-                                substitution: Substitution::empty(),\n-                            });\n+                            let impl_bound = Binders::new(\n+                                0,\n+                                WhereClause::Implemented(TraitRef {\n+                                    trait_id: to_chalk_trait_id(future_trait),\n+                                    substitution: Substitution::empty(),\n+                                }),\n+                            );\n                             Some(vec![impl_bound])\n                         } else {\n                             None\n@@ -945,7 +989,7 @@ impl Ty {\n                             .generic_predicates(id.parent)\n                             .into_iter()\n                             .map(|pred| pred.clone().subst(&substs))\n-                            .filter(|wc| match &wc {\n+                            .filter(|wc| match &wc.skip_binders() {\n                                 WhereClause::Implemented(tr) => tr.self_type_parameter() == self,\n                                 WhereClause::AliasEq(AliasEq {\n                                     alias: AliasTy::Projection(proj),\n@@ -1094,8 +1138,8 @@ impl TypeWalk for Ty {\n                     t.walk(f);\n                 }\n             }\n-            TyKind::Dyn(predicates) => {\n-                for p in predicates.iter() {\n+            TyKind::Dyn(dyn_ty) => {\n+                for p in dyn_ty.bounds.value.interned().iter() {\n                     p.walk(f);\n                 }\n             }\n@@ -1122,8 +1166,8 @@ impl TypeWalk for Ty {\n             TyKind::Alias(AliasTy::Projection(p_ty)) => {\n                 p_ty.substitution.walk_mut_binders(f, binders);\n             }\n-            TyKind::Dyn(predicates) => {\n-                for p in make_mut_slice(predicates) {\n+            TyKind::Dyn(dyn_ty) => {\n+                for p in make_mut_slice(&mut dyn_ty.bounds.value.0) {\n                     p.walk_mut_binders(f, binders.shifted_in());\n                 }\n             }\n@@ -1173,7 +1217,7 @@ pub struct ReturnTypeImplTraits {\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub(crate) struct ReturnTypeImplTrait {\n-    pub(crate) bounds: Binders<Vec<WhereClause>>,\n+    pub(crate) bounds: Binders<Vec<QuantifiedWhereClause>>,\n }\n \n pub fn to_foreign_def_id(id: TypeAliasId) -> ForeignDefId {"}, {"sha": "f60cec649b4104c4cac1aede64db65d251526b62", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=6f1f91cdcfc03e2a49cc66b76caff645f8b33d42", "patch": "@@ -33,9 +33,10 @@ use crate::{\n         all_super_trait_refs, associated_type_by_name_including_super_traits, generics,\n         variant_data,\n     },\n-    AliasEq, AliasTy, Binders, BoundVar, CallableSig, DebruijnIndex, FnPointer, FnSig, ImplTraitId,\n-    OpaqueTy, PolyFnSig, ProjectionTy, ReturnTypeImplTrait, ReturnTypeImplTraits, Substitution,\n-    TraitEnvironment, TraitRef, Ty, TyKind, TypeWalk, WhereClause,\n+    AliasEq, AliasTy, Binders, BoundVar, CallableSig, DebruijnIndex, DynTy, FnPointer, FnSig,\n+    ImplTraitId, OpaqueTy, PolyFnSig, ProjectionTy, QuantifiedWhereClause, QuantifiedWhereClauses,\n+    ReturnTypeImplTrait, ReturnTypeImplTraits, Substitution, TraitEnvironment, TraitRef, Ty,\n+    TyKind, TypeWalk, WhereClause,\n };\n \n #[derive(Debug)]\n@@ -188,13 +189,14 @@ impl<'a> TyLoweringContext<'a> {\n             TypeRef::DynTrait(bounds) => {\n                 let self_ty =\n                     TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)).intern(&Interner);\n-                let predicates = self.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n-                    bounds\n-                        .iter()\n-                        .flat_map(|b| ctx.lower_type_bound(b, self_ty.clone(), false))\n-                        .collect()\n+                let bounds = self.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n+                    QuantifiedWhereClauses::from_iter(\n+                        &Interner,\n+                        bounds.iter().flat_map(|b| ctx.lower_type_bound(b, self_ty.clone(), false)),\n+                    )\n                 });\n-                TyKind::Dyn(predicates).intern(&Interner)\n+                let bounds = Binders::new(1, bounds);\n+                TyKind::Dyn(DynTy { bounds }).intern(&Interner)\n             }\n             TypeRef::ImplTrait(bounds) => {\n                 match self.impl_trait_mode {\n@@ -376,7 +378,16 @@ impl<'a> TyLoweringContext<'a> {\n                     // FIXME report error (ambiguous associated type)\n                     TyKind::Unknown.intern(&Interner)\n                 } else {\n-                    TyKind::Dyn(Arc::new([WhereClause::Implemented(trait_ref)])).intern(&Interner)\n+                    let dyn_ty = DynTy {\n+                        bounds: Binders::new(\n+                            1,\n+                            QuantifiedWhereClauses::from_iter(\n+                                &Interner,\n+                                Some(Binders::wrap_empty(WhereClause::Implemented(trait_ref))),\n+                            ),\n+                        ),\n+                    };\n+                    TyKind::Dyn(dyn_ty).intern(&Interner)\n                 };\n                 return (ty, None);\n             }\n@@ -670,7 +681,7 @@ impl<'a> TyLoweringContext<'a> {\n         &'a self,\n         where_predicate: &'a WherePredicate,\n         ignore_bindings: bool,\n-    ) -> impl Iterator<Item = WhereClause> + 'a {\n+    ) -> impl Iterator<Item = QuantifiedWhereClause> + 'a {\n         match where_predicate {\n             WherePredicate::ForLifetime { target, bound, .. }\n             | WherePredicate::TypeBound { target, bound } => {\n@@ -705,12 +716,12 @@ impl<'a> TyLoweringContext<'a> {\n         bound: &'a TypeBound,\n         self_ty: Ty,\n         ignore_bindings: bool,\n-    ) -> impl Iterator<Item = WhereClause> + 'a {\n+    ) -> impl Iterator<Item = QuantifiedWhereClause> + 'a {\n         let mut bindings = None;\n         let trait_ref = match bound {\n             TypeBound::Path(path) => {\n                 bindings = self.lower_trait_ref_from_path(path, Some(self_ty));\n-                bindings.clone().map(WhereClause::Implemented)\n+                bindings.clone().map(WhereClause::Implemented).map(|b| Binders::wrap_empty(b))\n             }\n             TypeBound::Lifetime(_) => None,\n             TypeBound::Error => None,\n@@ -727,7 +738,7 @@ impl<'a> TyLoweringContext<'a> {\n         &'a self,\n         bound: &'a TypeBound,\n         trait_ref: TraitRef,\n-    ) -> impl Iterator<Item = WhereClause> + 'a {\n+    ) -> impl Iterator<Item = QuantifiedWhereClause> + 'a {\n         let last_segment = match bound {\n             TypeBound::Path(path) => path.segments().last(),\n             TypeBound::Error | TypeBound::Lifetime(_) => None,\n@@ -743,7 +754,7 @@ impl<'a> TyLoweringContext<'a> {\n                     &binding.name,\n                 );\n                 let (super_trait_ref, associated_ty) = match found {\n-                    None => return SmallVec::<[WhereClause; 1]>::new(),\n+                    None => return SmallVec::<[QuantifiedWhereClause; 1]>::new(),\n                     Some(t) => t,\n                 };\n                 let projection_ty = ProjectionTy {\n@@ -757,7 +768,7 @@ impl<'a> TyLoweringContext<'a> {\n                     let ty = self.lower_ty(type_ref);\n                     let alias_eq =\n                         AliasEq { alias: AliasTy::Projection(projection_ty.clone()), ty };\n-                    preds.push(WhereClause::AliasEq(alias_eq));\n+                    preds.push(Binders::wrap_empty(WhereClause::AliasEq(alias_eq)));\n                 }\n                 for bound in &binding.bounds {\n                     preds.extend(self.lower_type_bound(\n@@ -814,7 +825,7 @@ pub fn associated_type_shorthand_candidates<R>(\n             let predicates = db.generic_predicates_for_param(param_id);\n             let mut traits_: Vec<_> = predicates\n                 .iter()\n-                .filter_map(|pred| match &pred.value {\n+                .filter_map(|pred| match &pred.value.value {\n                     WhereClause::Implemented(tr) => Some(tr.clone()),\n                     _ => None,\n                 })\n@@ -887,7 +898,7 @@ pub(crate) fn field_types_query(\n pub(crate) fn generic_predicates_for_param_query(\n     db: &dyn HirDatabase,\n     param_id: TypeParamId,\n-) -> Arc<[Binders<WhereClause>]> {\n+) -> Arc<[Binders<QuantifiedWhereClause>]> {\n     let resolver = param_id.parent.resolver(db.upcast());\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n@@ -915,7 +926,7 @@ pub(crate) fn generic_predicates_for_param_recover(\n     _db: &dyn HirDatabase,\n     _cycle: &[String],\n     _param_id: &TypeParamId,\n-) -> Arc<[Binders<WhereClause>]> {\n+) -> Arc<[Binders<QuantifiedWhereClause>]> {\n     Arc::new([])\n }\n \n@@ -930,7 +941,7 @@ pub(crate) fn trait_environment_query(\n     let mut clauses = Vec::new();\n     for pred in resolver.where_predicates_in_scope() {\n         for pred in ctx.lower_where_predicate(pred, false) {\n-            if let WhereClause::Implemented(tr) = &pred {\n+            if let WhereClause::Implemented(tr) = &pred.skip_binders() {\n                 traits_in_scope.push((tr.self_type_parameter().clone(), tr.hir_trait_id()));\n             }\n             let program_clause: chalk_ir::ProgramClause<Interner> =\n@@ -970,7 +981,7 @@ pub(crate) fn trait_environment_query(\n pub(crate) fn generic_predicates_query(\n     db: &dyn HirDatabase,\n     def: GenericDefId,\n-) -> Arc<[Binders<WhereClause>]> {\n+) -> Arc<[Binders<QuantifiedWhereClause>]> {\n     let resolver = def.resolver(db.upcast());\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);"}, {"sha": "4019fdf173112b12f76f58720d0785bdd7543ef0", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=6f1f91cdcfc03e2a49cc66b76caff645f8b33d42", "patch": "@@ -238,7 +238,10 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                     });\n                     let bound = OpaqueTyDatumBound {\n                         bounds: make_binders(\n-                            vec![impl_bound.to_chalk(self.db), proj_bound.to_chalk(self.db)],\n+                            vec![\n+                                wrap_in_empty_binders(impl_bound).to_chalk(self.db),\n+                                wrap_in_empty_binders(proj_bound).to_chalk(self.db),\n+                            ],\n                             1,\n                         ),\n                         where_clauses: make_binders(vec![], 0),\n@@ -397,7 +400,6 @@ pub(crate) fn associated_ty_data_query(\n         .iter()\n         .flat_map(|bound| ctx.lower_type_bound(bound, self_ty.clone(), false))\n         .filter_map(|pred| generic_predicate_to_inline_bound(db, &pred, &self_ty))\n-        .map(|bound| make_binders(bound.shifted_in(&Interner), 0))\n         .collect();\n \n     let where_clauses = convert_where_clauses(db, type_alias.into(), &bound_vars);\n@@ -720,3 +722,7 @@ impl From<crate::db::InternedClosureId> for chalk_ir::ClosureId<Interner> {\n         chalk_ir::ClosureId(id.as_intern_id())\n     }\n }\n+\n+fn wrap_in_empty_binders<T: crate::TypeWalk>(value: T) -> crate::Binders<T> {\n+    crate::Binders::wrap_empty(value)\n+}"}, {"sha": "7209dd14ec9e555cd62f7dae239a0754686539ad", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 51, "deletions": 41, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=6f1f91cdcfc03e2a49cc66b76caff645f8b33d42", "patch": "@@ -7,15 +7,14 @@ use chalk_ir::{cast::Cast, fold::shift::Shift, interner::HasInterner, LifetimeDa\n use chalk_solve::rust_ir;\n \n use base_db::salsa::InternKey;\n-use hir_def::{AssocContainerId, GenericDefId, Lookup, TypeAliasId};\n+use hir_def::{GenericDefId, TypeAliasId};\n \n use crate::{\n     db::HirDatabase,\n-    from_assoc_type_id,\n     primitive::UintTy,\n     traits::{Canonical, DomainGoal},\n-    AliasTy, CallableDefId, FnPointer, InEnvironment, OpaqueTy, ProjectionTy, Scalar, Substitution,\n-    TraitRef, Ty, WhereClause,\n+    AliasTy, CallableDefId, FnPointer, InEnvironment, OpaqueTy, ProjectionTy,\n+    QuantifiedWhereClause, Scalar, Substitution, TraitRef, Ty, TypeWalk, WhereClause,\n };\n \n use super::interner::*;\n@@ -95,10 +94,10 @@ impl ToChalk for Ty {\n             TyKind::Placeholder(idx) => idx.to_ty::<Interner>(&Interner),\n             TyKind::BoundVar(idx) => chalk_ir::TyKind::BoundVar(idx).intern(&Interner),\n             TyKind::InferenceVar(..) => panic!(\"uncanonicalized infer ty\"),\n-            TyKind::Dyn(predicates) => {\n+            TyKind::Dyn(dyn_ty) => {\n                 let where_clauses = chalk_ir::QuantifiedWhereClauses::from_iter(\n                     &Interner,\n-                    predicates.iter().cloned().map(|p| p.to_chalk(db)),\n+                    dyn_ty.bounds.value.interned().iter().cloned().map(|p| p.to_chalk(db)),\n                 );\n                 let bounded_ty = chalk_ir::DynTy {\n                     bounds: make_binders(where_clauses, 1),\n@@ -144,13 +143,17 @@ impl ToChalk for Ty {\n             chalk_ir::TyKind::InferenceVar(_iv, _kind) => TyKind::Unknown,\n             chalk_ir::TyKind::Dyn(where_clauses) => {\n                 assert_eq!(where_clauses.bounds.binders.len(&Interner), 1);\n-                let predicates = where_clauses\n+                let bounds = where_clauses\n                     .bounds\n                     .skip_binders()\n                     .iter(&Interner)\n-                    .map(|c| from_chalk(db, c.clone()))\n-                    .collect();\n-                TyKind::Dyn(predicates)\n+                    .map(|c| from_chalk(db, c.clone()));\n+                TyKind::Dyn(crate::DynTy {\n+                    bounds: crate::Binders::new(\n+                        1,\n+                        crate::QuantifiedWhereClauses::from_iter(&Interner, bounds),\n+                    ),\n+                })\n             }\n \n             chalk_ir::TyKind::Adt(adt_id, subst) => TyKind::Adt(adt_id, from_chalk(db, subst)),\n@@ -305,33 +308,22 @@ impl ToChalk for TypeAliasAsValue {\n }\n \n impl ToChalk for WhereClause {\n-    type Chalk = chalk_ir::QuantifiedWhereClause<Interner>;\n+    type Chalk = chalk_ir::WhereClause<Interner>;\n \n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::QuantifiedWhereClause<Interner> {\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::WhereClause<Interner> {\n         match self {\n             WhereClause::Implemented(trait_ref) => {\n-                let chalk_trait_ref = trait_ref.to_chalk(db);\n-                let chalk_trait_ref = chalk_trait_ref.shifted_in(&Interner);\n-                make_binders(chalk_ir::WhereClause::Implemented(chalk_trait_ref), 0)\n+                chalk_ir::WhereClause::Implemented(trait_ref.to_chalk(db))\n             }\n-            WhereClause::AliasEq(alias_eq) => make_binders(\n-                chalk_ir::WhereClause::AliasEq(alias_eq.to_chalk(db).shifted_in(&Interner)),\n-                0,\n-            ),\n+            WhereClause::AliasEq(alias_eq) => chalk_ir::WhereClause::AliasEq(alias_eq.to_chalk(db)),\n         }\n     }\n \n     fn from_chalk(\n         db: &dyn HirDatabase,\n-        where_clause: chalk_ir::QuantifiedWhereClause<Interner>,\n+        where_clause: chalk_ir::WhereClause<Interner>,\n     ) -> WhereClause {\n-        // we don't produce any where clauses with binders and can't currently deal with them\n-        match where_clause\n-            .skip_binders()\n-            .clone()\n-            .shifted_out(&Interner)\n-            .expect(\"unexpected bound vars in where clause\")\n-        {\n+        match where_clause {\n             chalk_ir::WhereClause::Implemented(tr) => WhereClause::Implemented(from_chalk(db, tr)),\n             chalk_ir::WhereClause::AliasEq(alias_eq) => {\n                 WhereClause::AliasEq(from_chalk(db, alias_eq))\n@@ -500,6 +492,29 @@ where\n     }\n }\n \n+impl<T: ToChalk> ToChalk for crate::Binders<T>\n+where\n+    T::Chalk: chalk_ir::interner::HasInterner<Interner = Interner>,\n+{\n+    type Chalk = chalk_ir::Binders<T::Chalk>;\n+\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Binders<T::Chalk> {\n+        chalk_ir::Binders::new(\n+            chalk_ir::VariableKinds::from_iter(\n+                &Interner,\n+                std::iter::repeat(chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General))\n+                    .take(self.num_binders),\n+            ),\n+            self.value.to_chalk(db),\n+        )\n+    }\n+\n+    fn from_chalk(db: &dyn HirDatabase, binders: chalk_ir::Binders<T::Chalk>) -> crate::Binders<T> {\n+        let (v, b) = binders.into_value_and_skipped_binders();\n+        crate::Binders::new(b.len(&Interner), from_chalk(db, v))\n+    }\n+}\n+\n pub(super) fn make_binders<T>(value: T, num_vars: usize) -> chalk_ir::Binders<T>\n where\n     T: HasInterner<Interner = Interner>,\n@@ -529,14 +544,15 @@ pub(super) fn convert_where_clauses(\n \n pub(super) fn generic_predicate_to_inline_bound(\n     db: &dyn HirDatabase,\n-    pred: &WhereClause,\n+    pred: &QuantifiedWhereClause,\n     self_ty: &Ty,\n-) -> Option<rust_ir::InlineBound<Interner>> {\n+) -> Option<chalk_ir::Binders<rust_ir::InlineBound<Interner>>> {\n     // An InlineBound is like a GenericPredicate, except the self type is left out.\n     // We don't have a special type for this, but Chalk does.\n-    match pred {\n+    let self_ty_shifted_in = self_ty.clone().shift_bound_vars(DebruijnIndex::ONE);\n+    match &pred.value {\n         WhereClause::Implemented(trait_ref) => {\n-            if &trait_ref.substitution[0] != self_ty {\n+            if trait_ref.self_type_parameter() != &self_ty_shifted_in {\n                 // we can only convert predicates back to type bounds if they\n                 // have the expected self type\n                 return None;\n@@ -546,19 +562,13 @@ pub(super) fn generic_predicate_to_inline_bound(\n                 .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n                 .collect();\n             let trait_bound = rust_ir::TraitBound { trait_id: trait_ref.trait_id, args_no_self };\n-            Some(rust_ir::InlineBound::TraitBound(trait_bound))\n+            Some(make_binders(rust_ir::InlineBound::TraitBound(trait_bound), pred.num_binders))\n         }\n         WhereClause::AliasEq(AliasEq { alias: AliasTy::Projection(projection_ty), ty }) => {\n-            if &projection_ty.substitution[0] != self_ty {\n+            if projection_ty.self_type_parameter() != &self_ty_shifted_in {\n                 return None;\n             }\n-            let trait_ = match from_assoc_type_id(projection_ty.associated_ty_id)\n-                .lookup(db.upcast())\n-                .container\n-            {\n-                AssocContainerId::TraitId(t) => t,\n-                _ => panic!(\"associated type not in trait\"),\n-            };\n+            let trait_ = projection_ty.trait_(db);\n             let args_no_self = projection_ty.substitution[1..]\n                 .iter()\n                 .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n@@ -569,7 +579,7 @@ pub(super) fn generic_predicate_to_inline_bound(\n                 associated_ty_id: projection_ty.associated_ty_id,\n                 parameters: Vec::new(), // FIXME we don't support generic associated types yet\n             };\n-            Some(rust_ir::InlineBound::AliasEqBound(alias_eq_bound))\n+            Some(make_binders(rust_ir::InlineBound::AliasEqBound(alias_eq_bound), pred.num_binders))\n         }\n         _ => None,\n     }"}, {"sha": "19874e42b130d0171edf0fd94ffc4101ee65774d", "filename": "crates/hir_ty/src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/crates%2Fhir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/crates%2Fhir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Futils.rs?ref=6f1f91cdcfc03e2a49cc66b76caff645f8b33d42", "patch": "@@ -63,7 +63,7 @@ fn direct_super_trait_refs(db: &dyn HirDatabase, trait_ref: &TraitRef) -> Vec<Tr\n     db.generic_predicates_for_param(trait_self)\n         .iter()\n         .filter_map(|pred| {\n-            pred.as_ref().filter_map(|pred| match pred {\n+            pred.as_ref().filter_map(|pred| match pred.skip_binders() {\n                 WhereClause::Implemented(tr) => Some(tr.clone()),\n                 _ => None,\n             })"}, {"sha": "57162a47de8350aa495e710873e13fadd48b35c6", "filename": "docs/dev/README.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/docs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42/docs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2FREADME.md?ref=6f1f91cdcfc03e2a49cc66b76caff645f8b33d42", "patch": "@@ -226,6 +226,9 @@ If the GitHub Actions release fails because of a transient problem like a timeou\n If it fails because of something that needs to be fixed, remove the release tag (if needed), fix the problem, then start over.\n Make sure to remove the new changelog post created when running `cargo xtask release` a second time.\n \n+We release \"nightly\" every night automatically and promote the latest nightly to \"stable\" manually, every week.\n+We don't do \"patch\" releases, unless something truly egregious comes up.\n+\n # Permissions\n \n There are three sets of people with extra permissions:"}]}