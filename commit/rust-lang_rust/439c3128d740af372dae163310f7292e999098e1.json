{"sha": "439c3128d740af372dae163310f7292e999098e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzOWMzMTI4ZDc0MGFmMzcyZGFlMTYzMzEwZjcyOTJlOTk5MDk4ZTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-21T07:28:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-21T07:28:16Z"}, "message": "Auto merge of #38099 - GuillaumeGomez:cast_suggestions, r=nikomatsakis\n\nCast suggestions\n\nr? @nikomatsakis", "tree": {"sha": "1c25753335b6a4b4d3c8eb882f521727bb30d90a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c25753335b6a4b4d3c8eb882f521727bb30d90a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/439c3128d740af372dae163310f7292e999098e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/439c3128d740af372dae163310f7292e999098e1", "html_url": "https://github.com/rust-lang/rust/commit/439c3128d740af372dae163310f7292e999098e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/439c3128d740af372dae163310f7292e999098e1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92d46006bbb3d26e78aa3dc02e45a1761c7421e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/92d46006bbb3d26e78aa3dc02e45a1761c7421e7", "html_url": "https://github.com/rust-lang/rust/commit/92d46006bbb3d26e78aa3dc02e45a1761c7421e7"}, {"sha": "28e2c6aff90b8afef7722c825b381fc24172ac6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/28e2c6aff90b8afef7722c825b381fc24172ac6b", "html_url": "https://github.com/rust-lang/rust/commit/28e2c6aff90b8afef7722c825b381fc24172ac6b"}], "stats": {"total": 501, "additions": 401, "deletions": 100}, "files": [{"sha": "3e7cc0b1e3e9c2150b8235b1576b478f938901ee", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/439c3128d740af372dae163310f7292e999098e1/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439c3128d740af372dae163310f7292e999098e1/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=439c3128d740af372dae163310f7292e999098e1", "patch": "@@ -1367,9 +1367,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                    cause: &ObligationCause<'tcx>,\n                                    expected: Ty<'tcx>,\n                                    actual: Ty<'tcx>,\n-                                   err: TypeError<'tcx>) {\n+                                   err: TypeError<'tcx>)\n+                                   -> DiagnosticBuilder<'tcx> {\n         let trace = TypeTrace::types(cause, true, expected, actual);\n-        self.report_and_explain_type_error(trace, &err).emit();\n+        self.report_and_explain_type_error(trace, &err)\n     }\n \n     pub fn report_conflicting_default_types(&self,"}, {"sha": "638345608c2f5d9743595101ff8352a506d07d4d", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/439c3128d740af372dae163310f7292e999098e1/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439c3128d740af372dae163310f7292e999098e1/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=439c3128d740af372dae163310f7292e999098e1", "patch": "@@ -543,6 +543,7 @@ pub struct ProjectionTy<'tcx> {\n pub struct BareFnTy<'tcx> {\n     pub unsafety: hir::Unsafety,\n     pub abi: abi::Abi,\n+    /// Signature (inputs and output) of this function type.\n     pub sig: PolyFnSig<'tcx>,\n }\n "}, {"sha": "ff50ee11b390e674a703b9cdd9837a22676da5af", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/439c3128d740af372dae163310f7292e999098e1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439c3128d740af372dae163310f7292e999098e1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=439c3128d740af372dae163310f7292e999098e1", "patch": "@@ -481,7 +481,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     } else {\n                         (result_ty, arm_ty)\n                     };\n-                    self.report_mismatched_types(&cause, expected, found, e);\n+                    self.report_mismatched_types(&cause, expected, found, e).emit();\n                     self.tcx.types.err\n                 }\n             };"}, {"sha": "b4647df3f4f0a6bed7b874084131c44b06379522", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/439c3128d740af372dae163310f7292e999098e1/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439c3128d740af372dae163310f7292e999098e1/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=439c3128d740af372dae163310f7292e999098e1", "patch": "@@ -131,10 +131,18 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         Some(self.fcx.resolve_type_vars_if_possible(&normalized.value))\n     }\n \n+    /// Returns the final type, generating an error if it is an\n+    /// unresolved inference variable.\n     pub fn unambiguous_final_ty(&self) -> Ty<'tcx> {\n         self.fcx.structurally_resolved_type(self.span, self.cur_ty)\n     }\n \n+    /// Returns the final type we ended up with, which may well be an\n+    /// inference variable (we will resolve it first, if possible).\n+    pub fn maybe_ambiguous_final_ty(&self) -> Ty<'tcx> {\n+        self.fcx.resolve_type_vars_if_possible(&self.cur_ty)\n+    }\n+\n     pub fn finalize<'b, I>(self, pref: LvaluePreference, exprs: I)\n         where I: IntoIterator<Item = &'b hir::Expr>\n     {"}, {"sha": "393d9341a08432151876eb73941c90d3e5d50964", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 67, "deletions": 4, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/439c3128d740af372dae163310f7292e999098e1/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439c3128d740af372dae163310f7292e999098e1/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=439c3128d740af372dae163310f7292e999098e1", "patch": "@@ -14,8 +14,13 @@ use rustc::ty::Ty;\n use rustc::infer::{InferOk};\n use rustc::traits::ObligationCause;\n \n-use syntax_pos::Span;\n+use syntax::ast;\n+use syntax_pos::{self, Span};\n use rustc::hir;\n+use rustc::hir::def::Def;\n+use rustc::ty::{self, AssociatedItem};\n+\n+use super::method::probe;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Requires that the two types unify, and prints an error message if\n@@ -27,7 +32,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.register_predicates(obligations);\n             },\n             Err(e) => {\n-                self.report_mismatched_types(&cause, expected, actual, e);\n+                self.report_mismatched_types(&cause, expected, actual, e).emit();\n             }\n         }\n     }\n@@ -46,7 +51,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.register_predicates(obligations);\n             },\n             Err(e) => {\n-                self.report_mismatched_types(cause, expected, actual, e);\n+                self.report_mismatched_types(cause, expected, actual, e).emit();\n             }\n         }\n     }\n@@ -57,7 +62,65 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Err(e) = self.try_coerce(expr, checked_ty, expected) {\n             let cause = self.misc(expr.span);\n             let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n-            self.report_mismatched_types(&cause, expected, expr_ty, e);\n+            let mode = probe::Mode::MethodCall;\n+            let suggestions = self.probe_for_return_type(syntax_pos::DUMMY_SP,\n+                                                         mode,\n+                                                         expected,\n+                                                         checked_ty,\n+                                                         ast::DUMMY_NODE_ID);\n+            let mut err = self.report_mismatched_types(&cause, expected, expr_ty, e);\n+            if suggestions.len() > 0 {\n+                err.help(&format!(\"here are some functions which \\\n+                                   might fulfill your needs:\\n - {}\",\n+                                  self.get_best_match(&suggestions)));\n+            };\n+            err.emit();\n+        }\n+    }\n+\n+    fn format_method_suggestion(&self, method: &AssociatedItem) -> String {\n+        format!(\".{}({})\",\n+                method.name,\n+                if self.has_no_input_arg(method) {\n+                    \"\"\n+                } else {\n+                    \"...\"\n+                })\n+    }\n+\n+    fn display_suggested_methods(&self, methods: &[AssociatedItem]) -> String {\n+        methods.iter()\n+               .take(5)\n+               .map(|method| self.format_method_suggestion(&*method))\n+               .collect::<Vec<String>>()\n+               .join(\"\\n - \")\n+    }\n+\n+    fn get_best_match(&self, methods: &[AssociatedItem]) -> String {\n+        let no_argument_methods: Vec<_> =\n+            methods.iter()\n+                   .filter(|ref x| self.has_no_input_arg(&*x))\n+                   .map(|x| x.clone())\n+                   .collect();\n+        if no_argument_methods.len() > 0 {\n+            self.display_suggested_methods(&no_argument_methods)\n+        } else {\n+            self.display_suggested_methods(&methods)\n+        }\n+    }\n+\n+    // This function checks if the method isn't static and takes other arguments than `self`.\n+    fn has_no_input_arg(&self, method: &AssociatedItem) -> bool {\n+        match method.def() {\n+            Def::Method(def_id) => {\n+                match self.tcx.item_type(def_id).sty {\n+                    ty::TypeVariants::TyFnDef(_, _, fty) => {\n+                        fty.sig.skip_binder().inputs().len() == 1\n+                    }\n+                    _ => false,\n+                }\n+            }\n+            _ => false,\n         }\n     }\n }"}, {"sha": "6353b45200bc977db61b89d3b985c86d27fb18eb", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/439c3128d740af372dae163310f7292e999098e1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439c3128d740af372dae163310f7292e999098e1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=439c3128d740af372dae163310f7292e999098e1", "patch": "@@ -30,9 +30,11 @@ pub use self::CandidateSource::*;\n pub use self::suggest::AllTraitsVec;\n \n mod confirm;\n-mod probe;\n+pub mod probe;\n mod suggest;\n \n+use self::probe::IsSuggestion;\n+\n pub enum MethodError<'tcx> {\n     // Did not find an applicable method, but we did find various near-misses that may work.\n     NoMatch(NoMatchData<'tcx>),\n@@ -91,7 +93,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          allow_private: bool)\n                          -> bool {\n         let mode = probe::Mode::MethodCall;\n-        match self.probe_method(span, mode, method_name, self_ty, call_expr_id) {\n+        match self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n+                                  self_ty, call_expr_id) {\n             Ok(..) => true,\n             Err(NoMatch(..)) => false,\n             Err(Ambiguity(..)) => true,\n@@ -130,7 +133,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let mode = probe::Mode::MethodCall;\n         let self_ty = self.resolve_type_vars_if_possible(&self_ty);\n-        let pick = self.probe_method(span, mode, method_name, self_ty, call_expr.id)?;\n+        let pick = self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n+                                       self_ty, call_expr.id)?;\n \n         if let Some(import_id) = pick.import_id {\n             self.tcx.used_trait_imports.borrow_mut().insert(import_id);\n@@ -328,7 +332,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         expr_id: ast::NodeId)\n                         -> Result<Def, MethodError<'tcx>> {\n         let mode = probe::Mode::Path;\n-        let pick = self.probe_method(span, mode, method_name, self_ty, expr_id)?;\n+        let pick = self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n+                                       self_ty, expr_id)?;\n \n         if let Some(import_id) = pick.import_id {\n             self.tcx.used_trait_imports.borrow_mut().insert(import_id);"}, {"sha": "06158366f5cda18dd7cbdf28cf337ca4aabffb36", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 201, "deletions": 84, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/439c3128d740af372dae163310f7292e999098e1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439c3128d740af372dae163310f7292e999098e1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=439c3128d740af372dae163310f7292e999098e1", "patch": "@@ -16,12 +16,12 @@ use super::suggest;\n use check::FnCtxt;\n use hir::def_id::DefId;\n use hir::def::Def;\n-use rustc::infer::InferOk;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::{self, ObligationCause};\n use rustc::ty::{self, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::util::nodemap::FxHashSet;\n+use rustc::infer::{self, InferOk};\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n@@ -32,11 +32,24 @@ use std::rc::Rc;\n use self::CandidateKind::*;\n pub use self::PickKind::*;\n \n+pub enum LookingFor<'tcx> {\n+    /// looking for methods with the given name; this is the normal case\n+    MethodName(ast::Name),\n+\n+    /// looking for methods that return a given type; this is used to\n+    /// assemble suggestions\n+    ReturnType(Ty<'tcx>),\n+}\n+\n+/// Boolean flag used to indicate if this search is for a suggestion\n+/// or not.  If true, we can allow ambiguity and so forth.\n+pub struct IsSuggestion(pub bool);\n+\n struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     span: Span,\n     mode: Mode,\n-    item_name: ast::Name,\n+    looking_for: LookingFor<'tcx>,\n     steps: Rc<Vec<CandidateStep<'tcx>>>,\n     opt_simplified_steps: Option<Vec<ty::fast_reject::SimplifiedType>>,\n     inherent_candidates: Vec<Candidate<'tcx>>,\n@@ -144,18 +157,72 @@ pub enum Mode {\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn probe_method(&self,\n-                        span: Span,\n-                        mode: Mode,\n-                        item_name: ast::Name,\n-                        self_ty: Ty<'tcx>,\n-                        scope_expr_id: ast::NodeId)\n-                        -> PickResult<'tcx> {\n+    /// This is used to offer suggestions to users. It returns methods\n+    /// that could have been called which have the desired return\n+    /// type. Some effort is made to rule out methods that, if called,\n+    /// would result in an error (basically, the same criteria we\n+    /// would use to decide if a method is a plausible fit for\n+    /// ambiguity purposes).\n+    pub fn probe_for_return_type(&self,\n+                                 span: Span,\n+                                 mode: Mode,\n+                                 return_type: Ty<'tcx>,\n+                                 self_ty: Ty<'tcx>,\n+                                 scope_expr_id: ast::NodeId)\n+                                 -> Vec<ty::AssociatedItem> {\n+        debug!(\"probe(self_ty={:?}, return_type={}, scope_expr_id={})\",\n+               self_ty,\n+               return_type,\n+               scope_expr_id);\n+        let method_names =\n+            self.probe_op(span, mode, LookingFor::ReturnType(return_type), IsSuggestion(true),\n+                          self_ty, scope_expr_id,\n+                          |probe_cx| Ok(probe_cx.candidate_method_names()))\n+                .unwrap_or(vec![]);\n+        method_names\n+            .iter()\n+            .flat_map(|&method_name| {\n+                match self.probe_for_name(span, mode, method_name, IsSuggestion(true), self_ty,\n+                                          scope_expr_id) {\n+                    Ok(pick) => Some(pick.item),\n+                    Err(_) => None,\n+                }\n+            })\n+            .collect()\n+    }\n+\n+    pub fn probe_for_name(&self,\n+                          span: Span,\n+                          mode: Mode,\n+                          item_name: ast::Name,\n+                          is_suggestion: IsSuggestion,\n+                          self_ty: Ty<'tcx>,\n+                          scope_expr_id: ast::NodeId)\n+                          -> PickResult<'tcx> {\n         debug!(\"probe(self_ty={:?}, item_name={}, scope_expr_id={})\",\n                self_ty,\n                item_name,\n                scope_expr_id);\n+        self.probe_op(span,\n+                      mode,\n+                      LookingFor::MethodName(item_name),\n+                      is_suggestion,\n+                      self_ty,\n+                      scope_expr_id,\n+                      |probe_cx| probe_cx.pick())\n+    }\n \n+    fn probe_op<OP,R>(&'a self,\n+                      span: Span,\n+                      mode: Mode,\n+                      looking_for: LookingFor<'tcx>,\n+                      is_suggestion: IsSuggestion,\n+                      self_ty: Ty<'tcx>,\n+                      scope_expr_id: ast::NodeId,\n+                      op: OP)\n+                      -> Result<R, MethodError<'tcx>>\n+        where OP: FnOnce(ProbeContext<'a, 'gcx, 'tcx>) -> Result<R, MethodError<'tcx>>\n+    {\n         // FIXME(#18741) -- right now, creating the steps involves evaluating the\n         // `*` operator, which registers obligations that then escape into\n         // the global fulfillment context and thus has global\n@@ -164,7 +231,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // think cause spurious errors. Really though this part should\n         // take place in the `self.probe` below.\n         let steps = if mode == Mode::MethodCall {\n-            match self.create_steps(span, self_ty) {\n+            match self.create_steps(span, self_ty, is_suggestion) {\n                 Some(steps) => steps,\n                 None => {\n                     return Err(MethodError::NoMatch(NoMatchData::new(Vec::new(),\n@@ -207,14 +274,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // that we create during the probe process are removed later\n         self.probe(|_| {\n             let mut probe_cx =\n-                ProbeContext::new(self, span, mode, item_name, steps, opt_simplified_steps);\n+                ProbeContext::new(self, span, mode, looking_for,\n+                                  steps, opt_simplified_steps);\n             probe_cx.assemble_inherent_candidates();\n             probe_cx.assemble_extension_candidates_for_traits_in_scope(scope_expr_id)?;\n-            probe_cx.pick()\n+            op(probe_cx)\n         })\n     }\n \n-    fn create_steps(&self, span: Span, self_ty: Ty<'tcx>) -> Option<Vec<CandidateStep<'tcx>>> {\n+    fn create_steps(&self,\n+                    span: Span,\n+                    self_ty: Ty<'tcx>,\n+                    is_suggestion: IsSuggestion)\n+                    -> Option<Vec<CandidateStep<'tcx>>> {\n         // FIXME: we don't need to create the entire steps in one pass\n \n         let mut autoderef = self.autoderef(span, self_ty);\n@@ -228,8 +300,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             })\n             .collect();\n \n-        let final_ty = autoderef.unambiguous_final_ty();\n+        let final_ty = autoderef.maybe_ambiguous_final_ty();\n         match final_ty.sty {\n+            ty::TyInfer(ty::TyVar(_)) => {\n+                // Ended in an inference variable. If we are doing\n+                // a real method lookup, this is a hard error (it's an\n+                // ambiguity and we can't make progress).\n+                if !is_suggestion.0 {\n+                    let t = self.structurally_resolved_type(span, final_ty);\n+                    assert_eq!(t, self.tcx.types.err);\n+                    return None\n+                } else {\n+                    // If we're just looking for suggestions,\n+                    // though, ambiguity is no big thing, we can\n+                    // just ignore it.\n+                }\n+            }\n             ty::TyArray(elem_ty, _) => {\n                 let dereferences = steps.len() - 1;\n \n@@ -253,15 +339,15 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n            span: Span,\n            mode: Mode,\n-           item_name: ast::Name,\n+           looking_for: LookingFor<'tcx>,\n            steps: Vec<CandidateStep<'tcx>>,\n            opt_simplified_steps: Option<Vec<ty::fast_reject::SimplifiedType>>)\n            -> ProbeContext<'a, 'gcx, 'tcx> {\n         ProbeContext {\n             fcx: fcx,\n             span: span,\n             mode: mode,\n-            item_name: item_name,\n+            looking_for: looking_for,\n             inherent_candidates: Vec::new(),\n             extension_candidates: Vec::new(),\n             impl_dups: FxHashSet(),\n@@ -410,44 +496,40 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         debug!(\"assemble_inherent_impl_probe {:?}\", impl_def_id);\n \n-        let item = match self.associated_item(impl_def_id) {\n-            Some(m) => m,\n-            None => {\n-                return;\n-            } // No method with correct name on this impl\n-        };\n+        for item in self.impl_or_trait_item(impl_def_id) {\n+            if !self.has_applicable_self(&item) {\n+                // No receiver declared. Not a candidate.\n+                self.record_static_candidate(ImplSource(impl_def_id));\n+                continue\n+            }\n \n-        if !self.has_applicable_self(&item) {\n-            // No receiver declared. Not a candidate.\n-            return self.record_static_candidate(ImplSource(impl_def_id));\n-        }\n+            if !item.vis.is_accessible_from(self.body_id, &self.tcx.map) {\n+                self.private_candidate = Some(item.def());\n+                continue\n+            }\n \n-        if !item.vis.is_accessible_from(self.body_id, &self.tcx.map) {\n-            self.private_candidate = Some(item.def());\n-            return;\n-        }\n+            let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n+            let impl_ty = impl_ty.subst(self.tcx, impl_substs);\n \n-        let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n-        let impl_ty = impl_ty.subst(self.tcx, impl_substs);\n-\n-        // Determine the receiver type that the method itself expects.\n-        let xform_self_ty = self.xform_self_ty(&item, impl_ty, impl_substs);\n-\n-        // We can't use normalize_associated_types_in as it will pollute the\n-        // fcx's fulfillment context after this probe is over.\n-        let cause = traits::ObligationCause::misc(self.span, self.body_id);\n-        let mut selcx = &mut traits::SelectionContext::new(self.fcx);\n-        let traits::Normalized { value: xform_self_ty, obligations } =\n-            traits::normalize(selcx, cause, &xform_self_ty);\n-        debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}\",\n-               xform_self_ty);\n-\n-        self.inherent_candidates.push(Candidate {\n-            xform_self_ty: xform_self_ty,\n-            item: item,\n-            kind: InherentImplCandidate(impl_substs, obligations),\n-            import_id: self.import_id,\n-        });\n+            // Determine the receiver type that the method itself expects.\n+            let xform_self_ty = self.xform_self_ty(&item, impl_ty, impl_substs);\n+\n+            // We can't use normalize_associated_types_in as it will pollute the\n+            // fcx's fulfillment context after this probe is over.\n+            let cause = traits::ObligationCause::misc(self.span, self.body_id);\n+            let mut selcx = &mut traits::SelectionContext::new(self.fcx);\n+            let traits::Normalized { value: xform_self_ty, obligations } =\n+                traits::normalize(selcx, cause, &xform_self_ty);\n+            debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}\",\n+                   xform_self_ty);\n+\n+            self.inherent_candidates.push(Candidate {\n+                xform_self_ty: xform_self_ty,\n+                item: item,\n+                kind: InherentImplCandidate(impl_substs, obligations),\n+                import_id: self.import_id,\n+            });\n+        }\n     }\n \n     fn assemble_inherent_candidates_from_object(&mut self,\n@@ -540,17 +622,12 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         let tcx = self.tcx;\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n-            let item = match self.associated_item(bound_trait_ref.def_id()) {\n-                Some(v) => v,\n-                None => {\n-                    continue;\n+            for item in self.impl_or_trait_item(bound_trait_ref.def_id()) {\n+                if !self.has_applicable_self(&item) {\n+                    self.record_static_candidate(TraitSource(bound_trait_ref.def_id()));\n+                } else {\n+                    mk_cand(self, bound_trait_ref, item);\n                 }\n-            };\n-\n-            if !self.has_applicable_self(&item) {\n-                self.record_static_candidate(TraitSource(bound_trait_ref.def_id()));\n-            } else {\n-                mk_cand(self, bound_trait_ref, item);\n             }\n         }\n     }\n@@ -584,36 +661,45 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n+    pub fn matches_return_type(&self, method: &ty::AssociatedItem,\n+                               expected: ty::Ty<'tcx>) -> bool {\n+        match method.def() {\n+            Def::Method(def_id) => {\n+                let fty = self.tcx.item_type(def_id).fn_sig();\n+                self.probe(|_| {\n+                    let substs = self.fresh_substs_for_item(self.span, method.def_id);\n+                    let output = fty.output().subst(self.tcx, substs);\n+                    let (output, _) = self.replace_late_bound_regions_with_fresh_var(\n+                        self.span, infer::FnCall, &output);\n+                    self.can_sub_types(output, expected).is_ok()\n+                })\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     fn assemble_extension_candidates_for_trait(&mut self,\n                                                trait_def_id: DefId)\n                                                -> Result<(), MethodError<'tcx>> {\n         debug!(\"assemble_extension_candidates_for_trait(trait_def_id={:?})\",\n                trait_def_id);\n \n-        // Check whether `trait_def_id` defines a method with suitable name:\n-        let maybe_item = self.tcx.associated_items(trait_def_id)\n-                             .find(|item| item.name == self.item_name);\n-        let item = match maybe_item {\n-            Some(i) => i,\n-            None => {\n-                return Ok(());\n+        for item in self.impl_or_trait_item(trait_def_id) {\n+            // Check whether `trait_def_id` defines a method with suitable name:\n+            if !self.has_applicable_self(&item) {\n+                debug!(\"method has inapplicable self\");\n+                self.record_static_candidate(TraitSource(trait_def_id));\n+                continue;\n             }\n-        };\n \n-        // Check whether `trait_def_id` defines a method with suitable name:\n-        if !self.has_applicable_self(&item) {\n-            debug!(\"method has inapplicable self\");\n-            self.record_static_candidate(TraitSource(trait_def_id));\n-            return Ok(());\n-        }\n+            self.assemble_extension_candidates_for_trait_impls(trait_def_id, item.clone());\n \n-        self.assemble_extension_candidates_for_trait_impls(trait_def_id, item.clone());\n+            self.assemble_closure_candidates(trait_def_id, item.clone())?;\n \n-        self.assemble_closure_candidates(trait_def_id, item.clone())?;\n+            self.assemble_projection_candidates(trait_def_id, item.clone());\n \n-        self.assemble_projection_candidates(trait_def_id, item.clone());\n-\n-        self.assemble_where_clause_candidates(trait_def_id, item.clone());\n+            self.assemble_where_clause_candidates(trait_def_id, item.clone());\n+        }\n \n         Ok(())\n     }\n@@ -833,10 +919,30 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn candidate_method_names(&self) -> Vec<ast::Name> {\n+        let mut set = FxHashSet();\n+        let mut names: Vec<_> =\n+            self.inherent_candidates\n+                .iter()\n+                .chain(&self.extension_candidates)\n+                .map(|candidate| candidate.item.name)\n+                .filter(|&name| set.insert(name))\n+                .collect();\n+\n+        // sort them by the name so we have a stable result\n+        names.sort_by_key(|n| n.as_str());\n+        names\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // THE ACTUAL SEARCH\n \n     fn pick(mut self) -> PickResult<'tcx> {\n+        assert!(match self.looking_for {\n+            LookingFor::MethodName(_) => true,\n+            LookingFor::ReturnType(_) => false,\n+        });\n+\n         if let Some(r) = self.pick_core() {\n             return r;\n         }\n@@ -855,6 +961,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         let out_of_scope_traits = match self.pick_core() {\n             Some(Ok(p)) => vec![p.item.container.id()],\n+            //Some(Ok(p)) => p.iter().map(|p| p.item.container().id()).collect(),\n             Some(Err(MethodError::Ambiguity(v))) => {\n                 v.into_iter()\n                     .map(|source| {\n@@ -1257,10 +1364,20 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         self.tcx.erase_late_bound_regions(value)\n     }\n \n-    /// Find item with name `item_name` defined in impl/trait `def_id`\n-    /// and return it, or `None`, if no such item was defined there.\n-    fn associated_item(&self, def_id: DefId) -> Option<ty::AssociatedItem> {\n-        self.fcx.associated_item(def_id, self.item_name)\n+    /// Find the method with the appropriate name (or return type, as the case may be).\n+    fn impl_or_trait_item(&self, def_id: DefId) -> Vec<ty::AssociatedItem> {\n+        match self.looking_for {\n+            LookingFor::MethodName(name) => {\n+                self.fcx.associated_item(def_id, name).map_or(Vec::new(), |x| vec![x])\n+            }\n+            LookingFor::ReturnType(return_ty) => {\n+                self.tcx\n+                    .associated_items(def_id)\n+                    .map(|did| self.tcx.associated_item(did.def_id))\n+                    .filter(|m| self.matches_return_type(m, return_ty))\n+                    .collect()\n+            }\n+        }\n     }\n }\n "}, {"sha": "3086721852deb82732883dc9de9e50057d11d718", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/439c3128d740af372dae163310f7292e999098e1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439c3128d740af372dae163310f7292e999098e1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=439c3128d740af372dae163310f7292e999098e1", "patch": "@@ -2986,7 +2986,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             Err(e) => {\n-                self.report_mismatched_types(&cause, expected_ty, found_ty, e);\n+                self.report_mismatched_types(&cause, expected_ty, found_ty, e).emit();\n                 self.tcx.types.err\n             }\n         }\n@@ -3697,7 +3697,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 match result {\n                     Ok(ty) => ctxt.unified = ty,\n                     Err(err) => {\n-                        self.report_mismatched_types(&cause, ctxt.unified, e_ty, err);\n+                        self.report_mismatched_types(&cause, ctxt.unified, e_ty, err).emit();\n                     }\n                 }\n \n@@ -3880,7 +3880,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 match result {\n                     Ok(ty) => unified = ty,\n                     Err(e) => {\n-                        self.report_mismatched_types(&cause, unified, e_ty, e);\n+                        self.report_mismatched_types(&cause, unified, e_ty, e).emit();\n                     }\n                 }\n             }"}, {"sha": "0e5a16987c12e408e9315cadd82ca3848872ae16", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/439c3128d740af372dae163310f7292e999098e1/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439c3128d740af372dae163310f7292e999098e1/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=439c3128d740af372dae163310f7292e999098e1", "patch": "@@ -356,7 +356,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                         infcx.report_mismatched_types(&cause,\n                                                       mk_ptr(mt_b.ty),\n                                                       target,\n-                                                      ty::error::TypeError::Mutability);\n+                                                      ty::error::TypeError::Mutability).emit();\n                     }\n                     (mt_a.ty, mt_b.ty, unsize_trait, None)\n                 };"}, {"sha": "ec17813ed2a521fb479a0e012d1546890c31af33", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/439c3128d740af372dae163310f7292e999098e1/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439c3128d740af372dae163310f7292e999098e1/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=439c3128d740af372dae163310f7292e999098e1", "patch": "@@ -185,7 +185,7 @@ fn require_same_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 true\n             }\n             Err(err) => {\n-                infcx.report_mismatched_types(cause, expected, actual, err);\n+                infcx.report_mismatched_types(cause, expected, actual, err).emit();\n                 false\n             }\n         }"}, {"sha": "e04cc11f15e14dc2deba84907cadc8a7b3b49942", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/439c3128d740af372dae163310f7292e999098e1/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439c3128d740af372dae163310f7292e999098e1/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=439c3128d740af372dae163310f7292e999098e1", "patch": "@@ -304,6 +304,7 @@ declare_features! (\n     // Allows using `Self` and associated types in struct expressions and patterns.\n     (active, more_struct_aliases, \"1.14.0\", Some(37544)),\n \n+\n     // Allows #[link(..., cfg(..))]\n     (active, link_cfg, \"1.14.0\", Some(37406)),\n \n@@ -314,6 +315,9 @@ declare_features! (\n \n     // Allows #[target_feature(...)]\n     (active, target_feature, \"1.15.0\", None),\n+\n+    // Allow safe suggestions for potential type conversions.\n+    (active, safe_suggestion, \"1.0.0\", Some(37384)),\n );\n \n declare_features! ("}, {"sha": "3177e858ff4fd3b89ada820f849ce3a9889ffc66", "filename": "src/test/ui/span/coerce-suggestions.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/439c3128d740af372dae163310f7292e999098e1/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439c3128d740af372dae163310f7292e999098e1/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.rs?ref=439c3128d740af372dae163310f7292e999098e1", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax)]\n+\n+fn test(_x: &mut String) {}\n+fn test2(_x: &mut i32) {}\n+\n+fn main() {\n+    let x: usize = String::new();\n+    //~^ ERROR E0308\n+    //~| NOTE expected usize, found struct `std::string::String`\n+    //~| NOTE expected type `usize`\n+    //~| NOTE found type `std::string::String`\n+    //~| HELP here are some functions which might fulfill your needs:\n+    let x: &str = String::new();\n+    //~^ ERROR E0308\n+    //~| NOTE expected &str, found struct `std::string::String`\n+    //~| NOTE expected type `&str`\n+    //~| NOTE found type `std::string::String`\n+    //~| HELP try with `&String::new()`\n+    let y = String::new();\n+    test(&y);\n+    //~^ ERROR E0308\n+    //~| NOTE types differ in mutability\n+    //~| NOTE expected type `&mut std::string::String`\n+    //~| NOTE found type `&std::string::String`\n+    //~| HELP try with `&mut y`\n+    test2(&y);\n+    //~^ ERROR E0308\n+    //~| NOTE types differ in mutability\n+    //~| NOTE expected type `&mut i32`\n+    //~| NOTE found type `&std::string::String`\n+    let f;\n+    f = box f;\n+    //~^ ERROR E0308\n+    //~| NOTE cyclic type of infinite size\n+    //~| NOTE expected type `_`\n+    //~| NOTE found type `Box<_>`\n+}"}, {"sha": "e316466150703c3dbf66ca61c049ab74a2d1c463", "filename": "src/test/ui/span/coerce-suggestions.stderr", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/439c3128d740af372dae163310f7292e999098e1/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/439c3128d740af372dae163310f7292e999098e1/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr?ref=439c3128d740af372dae163310f7292e999098e1", "patch": "@@ -0,0 +1,55 @@\n+error[E0308]: mismatched types\n+  --> $DIR/coerce-suggestions.rs:17:20\n+   |\n+17 |     let x: usize = String::new();\n+   |                    ^^^^^^^^^^^^^ expected usize, found struct `std::string::String`\n+   |\n+   = note: expected type `usize`\n+   = note:    found type `std::string::String`\n+   = help: here are some functions which might fulfill your needs:\n+ - .capacity()\n+ - .len()\n+\n+error[E0308]: mismatched types\n+  --> $DIR/coerce-suggestions.rs:23:19\n+   |\n+23 |     let x: &str = String::new();\n+   |                   ^^^^^^^^^^^^^ expected &str, found struct `std::string::String`\n+   |\n+   = note: expected type `&str`\n+   = note:    found type `std::string::String`\n+   = help: here are some functions which might fulfill your needs:\n+ - .as_str()\n+ - .trim()\n+ - .trim_left()\n+ - .trim_right()\n+\n+error[E0308]: mismatched types\n+  --> $DIR/coerce-suggestions.rs:30:10\n+   |\n+30 |     test(&y);\n+   |          ^^ types differ in mutability\n+   |\n+   = note: expected type `&mut std::string::String`\n+   = note:    found type `&std::string::String`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/coerce-suggestions.rs:36:11\n+   |\n+36 |     test2(&y);\n+   |           ^^ types differ in mutability\n+   |\n+   = note: expected type `&mut i32`\n+   = note:    found type `&std::string::String`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/coerce-suggestions.rs:42:9\n+   |\n+42 |     f = box f;\n+   |         ^^^^^ cyclic type of infinite size\n+   |\n+   = note: expected type `_`\n+   = note:    found type `Box<_>`\n+\n+error: aborting due to 5 previous errors\n+"}]}