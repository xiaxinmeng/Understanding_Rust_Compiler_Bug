{"sha": "144ff955d61597371e927850e3fb5ccf7ec3da02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0NGZmOTU1ZDYxNTk3MzcxZTkyNzg1MGUzZmI1Y2NmN2VjM2RhMDI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-01-02T13:03:56Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-01-02T13:03:56Z"}, "message": "Use layout.abi", "tree": {"sha": "6e34852a1cb8c02f1dadb01e0ae06df646bc23cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e34852a1cb8c02f1dadb01e0ae06df646bc23cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/144ff955d61597371e927850e3fb5ccf7ec3da02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/144ff955d61597371e927850e3fb5ccf7ec3da02", "html_url": "https://github.com/rust-lang/rust/commit/144ff955d61597371e927850e3fb5ccf7ec3da02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/144ff955d61597371e927850e3fb5ccf7ec3da02/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a15af1ccba0564073514d04f804ff9d2ed8d8172", "url": "https://api.github.com/repos/rust-lang/rust/commits/a15af1ccba0564073514d04f804ff9d2ed8d8172", "html_url": "https://github.com/rust-lang/rust/commit/a15af1ccba0564073514d04f804ff9d2ed8d8172"}], "stats": {"total": 59, "additions": 29, "deletions": 30}, "files": [{"sha": "864fc26927f650a380ac49c416b315db864839ab", "filename": "src/abi.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/144ff955d61597371e927850e3fb5ccf7ec3da02/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144ff955d61597371e927850e3fb5ccf7ec3da02/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=144ff955d61597371e927850e3fb5ccf7ec3da02", "patch": "@@ -43,46 +43,45 @@ pub fn scalar_to_clif_type(tcx: TyCtxt, scalar: Scalar) -> Type {\n \n fn get_pass_mode<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    abi: Abi,\n     ty: Ty<'tcx>,\n     is_return: bool,\n ) -> PassMode {\n-    assert!(!tcx\n+    let layout = tcx\n         .layout_of(ParamEnv::reveal_all().and(ty))\n-        .unwrap()\n-        .is_unsized());\n-    if let ty::Never = ty.sty {\n-        if is_return {\n-            PassMode::NoPass\n-        } else {\n-            PassMode::ByRef\n-        }\n-    } else if ty.sty == tcx.mk_unit().sty {\n+        .unwrap();\n+    assert!(!layout.is_unsized());\n+\n+    if layout.size.bytes() == 0 {\n         if is_return {\n             PassMode::NoPass\n         } else {\n             PassMode::ByRef\n         }\n-    } else if let Some(ret_ty) = crate::common::clif_type_from_ty(tcx, ty) {\n-        PassMode::ByVal(ret_ty)\n     } else {\n-        if abi == Abi::C {\n-            unimpl!(\n-                \"Non scalars are not yet supported for \\\"C\\\" abi ({:?}) is_return: {:?}\",\n-                ty,\n-                is_return\n-            );\n+        match &layout.abi {\n+            layout::Abi::Uninhabited => {\n+                if is_return {\n+                    PassMode::NoPass\n+                } else {\n+                    PassMode::ByRef\n+                }\n+            }\n+            layout::Abi::Scalar(scalar) => PassMode::ByVal(scalar_to_clif_type(tcx, scalar.clone())),\n+\n+            // FIXME implement ScalarPair and Vector Abi in a cg_llvm compatible way\n+            layout::Abi::ScalarPair(_, _) => PassMode::ByRef,\n+            layout::Abi::Vector { .. } => PassMode::ByRef,\n+\n+            layout::Abi::Aggregate { .. } => PassMode::ByRef,\n         }\n-        PassMode::ByRef\n     }\n }\n \n fn adjust_arg_for_abi<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n-    sig: FnSig<'tcx>,\n     arg: CValue<'tcx>,\n ) -> Value {\n-    match get_pass_mode(fx.tcx, sig.abi, arg.layout().ty, false) {\n+    match get_pass_mode(fx.tcx, arg.layout().ty, false) {\n         PassMode::NoPass => unimplemented!(\"pass mode nopass\"),\n         PassMode::ByVal(_) => arg.load_scalar(fx),\n         PassMode::ByRef => arg.force_stack(fx),\n@@ -113,13 +112,13 @@ fn clif_sig_from_fn_sig<'a, 'tcx: 'a>(\n \n     let inputs = inputs\n         .into_iter()\n-        .filter_map(|ty| match get_pass_mode(tcx, sig.abi, ty, false) {\n+        .filter_map(|ty| match get_pass_mode(tcx, ty, false) {\n             PassMode::ByVal(clif_ty) => Some(clif_ty),\n             PassMode::NoPass => unimplemented!(\"pass mode nopass\"),\n             PassMode::ByRef => Some(pointer_ty(tcx)),\n         });\n \n-    let (params, returns) = match get_pass_mode(tcx, sig.abi, output, true) {\n+    let (params, returns) = match get_pass_mode(tcx, output, true) {\n         PassMode::NoPass => (inputs.map(AbiParam::new).collect(), vec![]),\n         PassMode::ByVal(ret_ty) => (\n             inputs.map(AbiParam::new).collect(),\n@@ -374,7 +373,7 @@ fn cvalue_for_param<'a, 'tcx: 'a>(\n     ssa_flags: crate::analyze::Flags,\n ) -> CValue<'tcx> {\n     let layout = fx.layout_of(arg_ty);\n-    let pass_mode = get_pass_mode(fx.tcx, fx.self_sig().abi, arg_ty, false);\n+    let pass_mode = get_pass_mode(fx.tcx, arg_ty, false);\n     let clif_type = pass_mode.get_param_ty(fx);\n     let ebb_param = fx.bcx.append_ebb_param(start_ebb, clif_type);\n \n@@ -398,7 +397,7 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n     fx.add_global_comment(format!(\"ssa {:?}\", ssa_analyzed));\n \n     let ret_layout = fx.layout_of(fx.return_type());\n-    let output_pass_mode = get_pass_mode(fx.tcx, fx.self_sig().abi, fx.return_type(), true);\n+    let output_pass_mode = get_pass_mode(fx.tcx, fx.return_type(), true);\n     let ret_param = match output_pass_mode {\n         PassMode::NoPass => None,\n         PassMode::ByVal(_) => None,\n@@ -603,7 +602,7 @@ pub fn codegen_call_inner<'a, 'tcx: 'a>(\n \n     let ret_layout = fx.layout_of(fn_sig.output());\n \n-    let output_pass_mode = get_pass_mode(fx.tcx, fn_sig.abi, fn_sig.output(), true);\n+    let output_pass_mode = get_pass_mode(fx.tcx, fn_sig.output(), true);\n     let return_ptr = match output_pass_mode {\n         PassMode::NoPass => None,\n         PassMode::ByRef => match ret_place {\n@@ -639,7 +638,7 @@ pub fn codegen_call_inner<'a, 'tcx: 'a>(\n                 None\n             };\n \n-            args.get(0).map(|arg| adjust_arg_for_abi(fx, fn_sig, *arg))\n+            args.get(0).map(|arg| adjust_arg_for_abi(fx, *arg))\n         }\n         .into_iter()\n     };\n@@ -650,7 +649,7 @@ pub fn codegen_call_inner<'a, 'tcx: 'a>(\n         .chain(\n             args.into_iter()\n                 .skip(1)\n-                .map(|arg| adjust_arg_for_abi(fx, fn_sig, arg)),\n+                .map(|arg| adjust_arg_for_abi(fx, arg)),\n         )\n         .collect::<Vec<_>>();\n \n@@ -675,7 +674,7 @@ pub fn codegen_call_inner<'a, 'tcx: 'a>(\n }\n \n pub fn codegen_return(fx: &mut FunctionCx<impl Backend>) {\n-    match get_pass_mode(fx.tcx, fx.self_sig().abi, fx.return_type(), true) {\n+    match get_pass_mode(fx.tcx, fx.return_type(), true) {\n         PassMode::NoPass | PassMode::ByRef => {\n             fx.bcx.ins().return_(&[]);\n         }"}]}