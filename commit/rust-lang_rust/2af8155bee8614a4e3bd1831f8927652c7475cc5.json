{"sha": "2af8155bee8614a4e3bd1831f8927652c7475cc5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhZjgxNTViZWU4NjE0YTRlM2JkMTgzMWY4OTI3NjUyYzc0NzVjYzU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-21T08:03:59Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-21T17:26:41Z"}, "message": "rollup merge of #19898: Aatch/issue-19684\n\n#16081 fixed an issue where a nested return statement would cause incorrect behaviour due to the inner return writing over the return stack slot that had already been written too. However, the check was very broad and picked many cases that wouldn't ever be affected by this issue.\n\nAs a result, the number of allocas increased dramatically and therefore stack-size increased. LLVM is not able to remove all of the extraneous allocas. Any code that had multiple return values in a compound expression at the end of a function (including loops) would be hit by the issue.\n\nThe check now uses a control-flow graph to only consider the case when the inner return is executed conditionally. By itself, this narrowed definition causes #15763 to return, so the control-flow graph is also used to avoid passing the return slot as a destination when the result won't be used.\n\nThis change allows the stack-size of the main rustc task to be reduced to 8MB from 32MB.", "tree": {"sha": "2301b36dbd546cac3e36710e18a1d40053f634cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2301b36dbd546cac3e36710e18a1d40053f634cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2af8155bee8614a4e3bd1831f8927652c7475cc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2af8155bee8614a4e3bd1831f8927652c7475cc5", "html_url": "https://github.com/rust-lang/rust/commit/2af8155bee8614a4e3bd1831f8927652c7475cc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2af8155bee8614a4e3bd1831f8927652c7475cc5/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25f8051f2ebdc9444e0f75e91dc0cbb45d194181", "url": "https://api.github.com/repos/rust-lang/rust/commits/25f8051f2ebdc9444e0f75e91dc0cbb45d194181", "html_url": "https://github.com/rust-lang/rust/commit/25f8051f2ebdc9444e0f75e91dc0cbb45d194181"}, {"sha": "5722410f72d0698f6ad9ba668e2282ff0bac5043", "url": "https://api.github.com/repos/rust-lang/rust/commits/5722410f72d0698f6ad9ba668e2282ff0bac5043", "html_url": "https://github.com/rust-lang/rust/commit/5722410f72d0698f6ad9ba668e2282ff0bac5043"}], "stats": {"total": 182, "additions": 137, "deletions": 45}, "files": [{"sha": "e1c5906f0fb83f5d49f33959a89b806697f5e60b", "filename": "src/librustc/middle/cfg/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2af8155bee8614a4e3bd1831f8927652c7475cc5/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2af8155bee8614a4e3bd1831f8927652c7475cc5/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs?ref=2af8155bee8614a4e3bd1831f8927652c7475cc5", "patch": "@@ -48,4 +48,8 @@ impl CFG {\n                blk: &ast::Block) -> CFG {\n         construct::construct(tcx, blk)\n     }\n+\n+    pub fn node_is_reachable(&self, id: ast::NodeId) -> bool {\n+        self.graph.depth_traverse(self.entry).any(|node| node.id == id)\n+    }\n }"}, {"sha": "06e6ef30f74dacadc64ff42e6d1f5e6a3443498d", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2af8155bee8614a4e3bd1831f8927652c7475cc5/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2af8155bee8614a4e3bd1831f8927652c7475cc5/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=2af8155bee8614a4e3bd1831f8927652c7475cc5", "patch": "@@ -34,6 +34,7 @@\n \n use std::fmt::{Formatter, Error, Show};\n use std::uint;\n+use std::collections::BitvSet;\n \n pub struct Graph<N,E> {\n     nodes: Vec<Node<N>> ,\n@@ -288,6 +289,40 @@ impl<N,E> Graph<N,E> {\n             }\n         }\n     }\n+\n+    pub fn depth_traverse<'a>(&'a self, start: NodeIndex) -> DepthFirstTraversal<'a, N, E>  {\n+        DepthFirstTraversal {\n+            graph: self,\n+            stack: vec![start],\n+            visited: BitvSet::new()\n+        }\n+    }\n+}\n+\n+pub struct DepthFirstTraversal<'g, N:'g, E:'g> {\n+    graph: &'g Graph<N, E>,\n+    stack: Vec<NodeIndex>,\n+    visited: BitvSet\n+}\n+\n+impl<'g, N, E> Iterator<&'g N> for DepthFirstTraversal<'g, N, E> {\n+    fn next(&mut self) -> Option<&'g N> {\n+        while let Some(idx) = self.stack.pop() {\n+            if !self.visited.insert(idx.node_id()) {\n+                continue;\n+            }\n+            self.graph.each_outgoing_edge(idx, |_, e| -> bool {\n+                if !self.visited.contains(&e.target().node_id()) {\n+                    self.stack.push(e.target());\n+                }\n+                true\n+            });\n+\n+            return Some(self.graph.node_data(idx));\n+        }\n+\n+        return None;\n+    }\n }\n \n pub fn each_edge_index<F>(max_edge_index: EdgeIndex, mut f: F) where"}, {"sha": "6944c733456f6bc919c552a1d4b9fdc4182bbdf9", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2af8155bee8614a4e3bd1831f8927652c7475cc5/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2af8155bee8614a4e3bd1831f8927652c7475cc5/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=2af8155bee8614a4e3bd1831f8927652c7475cc5", "patch": "@@ -480,7 +480,7 @@ pub fn list_metadata(sess: &Session, path: &Path,\n /// The diagnostic emitter yielded to the procedure should be used for reporting\n /// errors of the compiler.\n pub fn monitor<F:FnOnce()+Send>(f: F) {\n-    static STACK_SIZE: uint = 32000000; // 32MB\n+    static STACK_SIZE: uint = 8 * 1024 * 1024; // 8MB\n \n     let (tx, rx) = channel();\n     let w = io::ChanWriter::new(tx);"}, {"sha": "ca1e0d7de72102c169943d62aa17e1716123b3f0", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 62, "deletions": 43, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/2af8155bee8614a4e3bd1831f8927652c7475cc5/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2af8155bee8614a4e3bd1831f8927652c7475cc5/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=2af8155bee8614a4e3bd1831f8927652c7475cc5", "patch": "@@ -38,6 +38,7 @@ use llvm::{BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n use llvm;\n use metadata::{csearch, encoder, loader};\n use middle::astencode;\n+use middle::cfg;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::subst;\n use middle::weak_lang_items;\n@@ -1306,47 +1307,33 @@ pub fn make_return_slot_pointer<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n     }\n }\n \n-struct CheckForNestedReturnsVisitor {\n+struct FindNestedReturn {\n     found: bool,\n-    in_return: bool\n }\n \n-impl CheckForNestedReturnsVisitor {\n-    fn explicit() -> CheckForNestedReturnsVisitor {\n-        CheckForNestedReturnsVisitor { found: false, in_return: false }\n-    }\n-    fn implicit() -> CheckForNestedReturnsVisitor {\n-        CheckForNestedReturnsVisitor { found: false, in_return: true }\n+impl FindNestedReturn {\n+    fn new() -> FindNestedReturn {\n+        FindNestedReturn { found: false }\n     }\n }\n \n-impl<'v> Visitor<'v> for CheckForNestedReturnsVisitor {\n+impl<'v> Visitor<'v> for FindNestedReturn {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n             ast::ExprRet(..) => {\n-                if self.in_return {\n-                    self.found = true;\n-                } else {\n-                    self.in_return = true;\n-                    visit::walk_expr(self, e);\n-                    self.in_return = false;\n-                }\n+                self.found = true;\n             }\n             _ => visit::walk_expr(self, e)\n         }\n     }\n }\n \n-fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n-    match tcx.map.find(id) {\n+fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>) {\n+    let blk = match tcx.map.find(id) {\n         Some(ast_map::NodeItem(i)) => {\n             match i.node {\n                 ast::ItemFn(_, _, _, _, ref blk) => {\n-                    let mut explicit = CheckForNestedReturnsVisitor::explicit();\n-                    let mut implicit = CheckForNestedReturnsVisitor::implicit();\n-                    visit::walk_item(&mut explicit, &*i);\n-                    visit::walk_expr_opt(&mut implicit, &blk.expr);\n-                    explicit.found || implicit.found\n+                    blk\n                 }\n                 _ => tcx.sess.bug(\"unexpected item variant in has_nested_returns\")\n             }\n@@ -1356,11 +1343,7 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n                 ast::ProvidedMethod(ref m) => {\n                     match m.node {\n                         ast::MethDecl(_, _, _, _, _, _, ref blk, _) => {\n-                            let mut explicit = CheckForNestedReturnsVisitor::explicit();\n-                            let mut implicit = CheckForNestedReturnsVisitor::implicit();\n-                            visit::walk_method_helper(&mut explicit, &**m);\n-                            visit::walk_expr_opt(&mut implicit, &blk.expr);\n-                            explicit.found || implicit.found\n+                            blk\n                         }\n                         ast::MethMac(_) => tcx.sess.bug(\"unexpanded macro\")\n                     }\n@@ -1380,11 +1363,7 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n                 ast::MethodImplItem(ref m) => {\n                     match m.node {\n                         ast::MethDecl(_, _, _, _, _, _, ref blk, _) => {\n-                            let mut explicit = CheckForNestedReturnsVisitor::explicit();\n-                            let mut implicit = CheckForNestedReturnsVisitor::implicit();\n-                            visit::walk_method_helper(&mut explicit, &**m);\n-                            visit::walk_expr_opt(&mut implicit, &blk.expr);\n-                            explicit.found || implicit.found\n+                            blk\n                         }\n                         ast::MethMac(_) => tcx.sess.bug(\"unexpanded macro\")\n                     }\n@@ -1398,24 +1377,58 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n         Some(ast_map::NodeExpr(e)) => {\n             match e.node {\n                 ast::ExprClosure(_, _, _, ref blk) => {\n-                    let mut explicit = CheckForNestedReturnsVisitor::explicit();\n-                    let mut implicit = CheckForNestedReturnsVisitor::implicit();\n-                    visit::walk_expr(&mut explicit, e);\n-                    visit::walk_expr_opt(&mut implicit, &blk.expr);\n-                    explicit.found || implicit.found\n+                    blk\n                 }\n                 _ => tcx.sess.bug(\"unexpected expr variant in has_nested_returns\")\n             }\n         }\n-\n-        Some(ast_map::NodeVariant(..)) | Some(ast_map::NodeStructCtor(..)) => false,\n+        Some(ast_map::NodeVariant(..)) |\n+        Some(ast_map::NodeStructCtor(..)) => return (ast::DUMMY_NODE_ID, None),\n \n         // glue, shims, etc\n-        None if id == ast::DUMMY_NODE_ID => false,\n+        None if id == ast::DUMMY_NODE_ID => return (ast::DUMMY_NODE_ID, None),\n \n         _ => tcx.sess.bug(format!(\"unexpected variant in has_nested_returns: {}\",\n                                   tcx.map.path_to_string(id)).as_slice())\n+    };\n+\n+    (blk.id, Some(cfg::CFG::new(tcx, &**blk)))\n+}\n+\n+// Checks for the presence of \"nested returns\" in a function.\n+// Nested returns are when the inner expression of a return expression\n+// (the 'expr' in 'return expr') contains a return expression. Only cases\n+// where the outer return is actually reachable are considered. Implicit\n+// returns from the end of blocks are considered as well.\n+//\n+// This check is needed to handle the case where the inner expression is\n+// part of a larger expression that may have already partially-filled the\n+// return slot alloca. This can cause errors related to clean-up due to\n+// the clobbering of the existing value in the return slot.\n+fn has_nested_returns(tcx: &ty::ctxt, cfg: &cfg::CFG, blk_id: ast::NodeId) -> bool {\n+    for n in cfg.graph.depth_traverse(cfg.entry) {\n+        match tcx.map.find(n.id) {\n+            Some(ast_map::NodeExpr(ex)) => {\n+                if let ast::ExprRet(Some(ref ret_expr)) = ex.node {\n+                    let mut visitor = FindNestedReturn::new();\n+                    visit::walk_expr(&mut visitor, &**ret_expr);\n+                    if visitor.found {\n+                        return true;\n+                    }\n+                }\n+            }\n+            Some(ast_map::NodeBlock(blk)) if blk.id == blk_id => {\n+                let mut visitor = FindNestedReturn::new();\n+                visit::walk_expr_opt(&mut visitor, &blk.expr);\n+                if visitor.found {\n+                    return true;\n+                }\n+            }\n+            _ => {}\n+        }\n     }\n+\n+    return false;\n }\n \n // NB: must keep 4 fns in sync:\n@@ -1454,7 +1467,12 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n         ty::FnDiverging => false\n     };\n     let debug_context = debuginfo::create_function_debug_context(ccx, id, param_substs, llfndecl);\n-    let nested_returns = has_nested_returns(ccx.tcx(), id);\n+    let (blk_id, cfg) = build_cfg(ccx.tcx(), id);\n+    let nested_returns = if let Some(ref cfg) = cfg {\n+        has_nested_returns(ccx.tcx(), cfg, blk_id)\n+    } else {\n+        false\n+    };\n \n     let mut fcx = FunctionContext {\n           llfn: llfndecl,\n@@ -1473,7 +1491,8 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n           block_arena: block_arena,\n           ccx: ccx,\n           debug_context: debug_context,\n-          scopes: RefCell::new(Vec::new())\n+          scopes: RefCell::new(Vec::new()),\n+          cfg: cfg\n     };\n \n     if has_env {"}, {"sha": "61f27bcfa7ad384e217ef6ee02216abefb6b53c9", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2af8155bee8614a4e3bd1831f8927652c7475cc5/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2af8155bee8614a4e3bd1831f8927652c7475cc5/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=2af8155bee8614a4e3bd1831f8927652c7475cc5", "patch": "@@ -18,6 +18,7 @@ use session::Session;\n use llvm;\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef};\n use llvm::{True, False, Bool};\n+use middle::cfg;\n use middle::def;\n use middle::infer;\n use middle::lang_items::LangItem;\n@@ -262,6 +263,8 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n \n     // Cleanup scopes.\n     pub scopes: RefCell<Vec<cleanup::CleanupScope<'a, 'tcx>>>,\n+\n+    pub cfg: Option<cfg::CFG>,\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {"}, {"sha": "2b73944d2b0ae51f1f817af078bd2a31bf35d4b5", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2af8155bee8614a4e3bd1831f8927652c7475cc5/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2af8155bee8614a4e3bd1831f8927652c7475cc5/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=2af8155bee8614a4e3bd1831f8927652c7475cc5", "patch": "@@ -112,8 +112,17 @@ pub fn trans_block<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     if dest != expr::Ignore {\n         let block_ty = node_id_type(bcx, b.id);\n+\n         if b.expr.is_none() || type_is_zero_size(bcx.ccx(), block_ty) {\n             dest = expr::Ignore;\n+        } else if b.expr.is_some() {\n+            // If the block has an expression, but that expression isn't reachable,\n+            // don't save into the destination given, ignore it.\n+            if let Some(ref cfg) = bcx.fcx.cfg {\n+                if !cfg.node_is_reachable(b.expr.as_ref().unwrap().id) {\n+                    dest = expr::Ignore;\n+                }\n+            }\n         }\n     }\n "}, {"sha": "81892e5fa83219923b1b7a58cfffd6f45d5ca7e6", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2af8155bee8614a4e3bd1831f8927652c7475cc5/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2af8155bee8614a4e3bd1831f8927652c7475cc5/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=2af8155bee8614a4e3bd1831f8927652c7475cc5", "patch": "@@ -926,7 +926,29 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             controlflow::trans_cont(bcx, expr.id, label_opt)\n         }\n         ast::ExprRet(ref ex) => {\n-            controlflow::trans_ret(bcx, ex.as_ref().map(|e| &**e))\n+            // Check to see if the return expression itself is reachable.\n+            // This can occur when the inner expression contains a return\n+            let reachable = if let Some(ref cfg) = bcx.fcx.cfg {\n+                cfg.node_is_reachable(expr.id)\n+            } else {\n+                true\n+            };\n+\n+            if reachable {\n+                controlflow::trans_ret(bcx, ex.as_ref().map(|e| &**e))\n+            } else {\n+                // If it's not reachable, just translate the inner expression\n+                // directly. This avoids having to manage a return slot when\n+                // it won't actually be used anyway.\n+                if let &Some(ref x) = ex {\n+                    bcx = trans_into(bcx, &**x, Ignore);\n+                }\n+                // Mark the end of the block as unreachable. Once we get to\n+                // a return expression, there's no more we should be doing\n+                // after this.\n+                Unreachable(bcx);\n+                bcx\n+            }\n         }\n         ast::ExprWhile(ref cond, ref body, _) => {\n             controlflow::trans_while(bcx, expr.id, &**cond, &**body)"}]}