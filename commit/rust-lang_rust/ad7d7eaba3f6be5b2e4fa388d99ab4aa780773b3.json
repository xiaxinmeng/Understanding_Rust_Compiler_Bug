{"sha": "ad7d7eaba3f6be5b2e4fa388d99ab4aa780773b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkN2Q3ZWFiYTNmNmJlNWIyZTRmYTM4OGQ5OWFiNGFhNzgwNzczYjM=", "commit": {"author": {"name": "Andre Bogus", "email": "andre.bogus@ankordata.de", "date": "2016-06-28T10:32:45Z"}, "committer": {"name": "Andre Bogus", "email": "andre.bogus@ankordata.de", "date": "2016-06-28T10:32:45Z"}, "message": "extend+improve HIR types documentation", "tree": {"sha": "11726c36b8922d97ad08a531a587936ac3c8a348", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11726c36b8922d97ad08a531a587936ac3c8a348"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad7d7eaba3f6be5b2e4fa388d99ab4aa780773b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad7d7eaba3f6be5b2e4fa388d99ab4aa780773b3", "html_url": "https://github.com/rust-lang/rust/commit/ad7d7eaba3f6be5b2e4fa388d99ab4aa780773b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad7d7eaba3f6be5b2e4fa388d99ab4aa780773b3/comments", "author": null, "committer": null, "parents": [{"sha": "ea0dc9297283daff6486807f43e190b4eb561412", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea0dc9297283daff6486807f43e190b4eb561412", "html_url": "https://github.com/rust-lang/rust/commit/ea0dc9297283daff6486807f43e190b4eb561412"}], "stats": {"total": 34, "additions": 26, "deletions": 8}, "files": [{"sha": "9caf0791398c4b937dd712fb64a200962bf4a6a6", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ad7d7eaba3f6be5b2e4fa388d99ab4aa780773b3/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad7d7eaba3f6be5b2e4fa388d99ab4aa780773b3/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=ad7d7eaba3f6be5b2e4fa388d99ab4aa780773b3", "patch": "@@ -836,7 +836,7 @@ pub enum Expr_ {\n     ExprVec(HirVec<P<Expr>>),\n     /// A function call\n     ///\n-    /// The first field resolves to the function itself,\n+    /// The first field resolves to the function itself (usually an `ExprPath`),\n     /// and the second field is the list of arguments\n     ExprCall(P<Expr>, HirVec<P<Expr>>),\n     /// A method call (`x.foo::<Bar, Baz>(a, b, c, d)`)\n@@ -845,9 +845,9 @@ pub enum Expr_ {\n     /// The vector of `Ty`s are the ascripted type parameters for the method\n     /// (within the angle brackets).\n     ///\n-    /// The first element of the vector of `Expr`s is the expression that evaluates\n-    /// to the object on which the method is being called on (the receiver),\n-    /// and the remaining elements are the rest of the arguments.\n+    /// The first element of the vector of `Expr`s is the expression that\n+    /// evaluates to the object on which the method is being called on (the\n+    /// receiver), and the remaining elements are the rest of the arguments.\n     ///\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n     /// `ExprMethodCall(foo, [Bar, Baz], [x, a, b, c, d])`.\n@@ -919,13 +919,13 @@ pub enum Expr_ {\n     /// Inline assembly (from `asm!`), with its outputs and inputs.\n     ExprInlineAsm(InlineAsm, Vec<P<Expr>>, Vec<P<Expr>>),\n \n-    /// A struct literal expression.\n+    /// A struct or enum variant literal expression.\n     ///\n     /// For example, `Foo {x: 1, y: 2}`, or\n     /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`.\n     ExprStruct(Path, HirVec<Field>, Option<P<Expr>>),\n \n-    /// A vector literal constructed from one repeated element.\n+    /// An array literal constructed from one repeated element.\n     ///\n     /// For example, `[1; 5]`. The first expression is the element\n     /// to be repeated; the second is the number of times to repeat it.\n@@ -950,14 +950,21 @@ pub struct QSelf {\n     pub position: usize,\n }\n \n+/// Hints at the original code for a `match _ { .. }`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum MatchSource {\n+    /// A `match _ { .. }`\n     Normal,\n+    /// An `if let _ = _ { .. }` (optionally with `else { .. }`\n     IfLetDesugar {\n         contains_else_clause: bool,\n     },\n+    /// A `while let _ = _ { .. }` (which was desugared to a\n+    /// `loop { match _ { .. } }`\n     WhileLetDesugar,\n+    /// A desugared `for _ in _ { .. }` loop\n     ForLoopDesugar,\n+    /// A desugared `?` operator\n     TryDesugar,\n }\n \n@@ -975,8 +982,7 @@ pub struct MutTy {\n     pub mutbl: Mutability,\n }\n \n-/// Represents a method's signature in a trait declaration,\n-/// or in an implementation.\n+/// Represents a method's signature in a trait declaration or implementation.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MethodSig {\n     pub unsafety: Unsafety,\n@@ -999,13 +1005,20 @@ pub struct TraitItem {\n     pub span: Span,\n }\n \n+/// Represents a trait method or associated constant or type\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum TraitItem_ {\n+    /// An associated constant with an optional value (otherwise `impl`s\n+    /// must contain a value)\n     ConstTraitItem(P<Ty>, Option<P<Expr>>),\n+    /// A method with an optional body\n     MethodTraitItem(MethodSig, Option<P<Block>>),\n+    /// An associated type with (possibly empty) bounds and optional concrete\n+    /// type\n     TypeTraitItem(TyParamBounds, Option<P<Ty>>),\n }\n \n+/// Represents anything within an `impl` block\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ImplItem {\n     pub id: NodeId,\n@@ -1017,10 +1030,15 @@ pub struct ImplItem {\n     pub span: Span,\n }\n \n+/// Represents different contents within `impl`s\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ImplItemKind {\n+    /// An associated constant of the given type, set to the constant result\n+    /// of the expression\n     Const(P<Ty>, P<Expr>),\n+    /// A method implementation with the given signature and body\n     Method(MethodSig, P<Block>),\n+    /// An associated type\n     Type(P<Ty>),\n }\n "}]}