{"sha": "7c7753d370ee186219bf369cb0910a20198ea79e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNzc1M2QzNzBlZTE4NjIxOWJmMzY5Y2IwOTEwYTIwMTk4ZWE3OWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-23T03:53:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-23T03:53:06Z"}, "message": "Auto merge of #40752 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 6 pull requests\n\n- Successful merges: #39891, #40518, #40542, #40617, #40678, #40696\n- Failed merges:", "tree": {"sha": "7447808378b144534bdac51dce3a48670cda23a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7447808378b144534bdac51dce3a48670cda23a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c7753d370ee186219bf369cb0910a20198ea79e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c7753d370ee186219bf369cb0910a20198ea79e", "html_url": "https://github.com/rust-lang/rust/commit/7c7753d370ee186219bf369cb0910a20198ea79e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c7753d370ee186219bf369cb0910a20198ea79e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c62e532f3de4c0254b772c36fe629b2042efd107", "url": "https://api.github.com/repos/rust-lang/rust/commits/c62e532f3de4c0254b772c36fe629b2042efd107", "html_url": "https://github.com/rust-lang/rust/commit/c62e532f3de4c0254b772c36fe629b2042efd107"}, {"sha": "93074187b6c7aeeec6a8fd28574bfad7a4608e1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/93074187b6c7aeeec6a8fd28574bfad7a4608e1f", "html_url": "https://github.com/rust-lang/rust/commit/93074187b6c7aeeec6a8fd28574bfad7a4608e1f"}], "stats": {"total": 2642, "additions": 1711, "deletions": 931}, "files": [{"sha": "cd4c81912dff5a6ca37e3086305cabaf20e3cde5", "filename": "src/ci/docker/dist-x86-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Fci%2Fdocker%2Fdist-x86-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Fci%2Fdocker%2Fdist-x86-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86-linux%2FDockerfile?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -6,6 +6,7 @@ RUN yum upgrade -y && yum install -y \\\n       curl \\\n       bzip2 \\\n       gcc \\\n+      gcc-c++ \\\n       make \\\n       glibc-devel \\\n       perl \\"}, {"sha": "ab2562538d6d7376e942a219ce0f00664082be9f", "filename": "src/ci/docker/dist-x86-linux/build-gcc.sh", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Fci%2Fdocker%2Fdist-x86-linux%2Fbuild-gcc.sh", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Fci%2Fdocker%2Fdist-x86-linux%2Fbuild-gcc.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86-linux%2Fbuild-gcc.sh?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -13,12 +13,14 @@ set -ex\n \n source shared.sh\n \n-curl https://ftp.gnu.org/gnu/gcc/gcc-4.7.4/gcc-4.7.4.tar.bz2 | tar xjf -\n-cd gcc-4.7.4\n+GCC=4.8.5\n+\n+curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.bz2 | tar xjf -\n+cd gcc-$GCC\n ./contrib/download_prerequisites\n mkdir ../gcc-build\n cd ../gcc-build\n-hide_output ../gcc-4.7.4/configure \\\n+hide_output ../gcc-$GCC/configure \\\n     --prefix=/rustroot \\\n     --enable-languages=c,c++\n hide_output make -j10\n@@ -27,5 +29,5 @@ ln -nsf gcc /rustroot/bin/cc\n \n cd ..\n rm -rf gcc-build\n-rm -rf gcc-4.7.4\n-yum erase -y gcc binutils\n+rm -rf gcc-$GCC\n+yum erase -y gcc gcc-c++ binutils"}, {"sha": "a6b18ac10a79074bb35d0c3e39a5c590fce391f5", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -78,33 +78,86 @@ impl serialize::UseSpecializedDecodable for CrateNum {\n /// A DefIndex is an index into the hir-map for a crate, identifying a\n /// particular definition. It should really be considered an interned\n /// shorthand for a particular DefPath.\n+///\n+/// At the moment we are allocating the numerical values of DefIndexes into two\n+/// ranges: the \"low\" range (starting at zero) and the \"high\" range (starting at\n+/// DEF_INDEX_HI_START). This allows us to allocate the DefIndexes of all\n+/// item-likes (Items, TraitItems, and ImplItems) into one of these ranges and\n+/// consequently use a simple array for lookup tables keyed by DefIndex and\n+/// known to be densely populated. This is especially important for the HIR map.\n+///\n+/// Since the DefIndex is mostly treated as an opaque ID, you probably\n+/// don't have to care about these ranges.\n #[derive(Clone, Debug, Eq, Ord, PartialOrd, PartialEq, RustcEncodable,\n            RustcDecodable, Hash, Copy)]\n pub struct DefIndex(u32);\n \n impl DefIndex {\n+    #[inline]\n     pub fn new(x: usize) -> DefIndex {\n         assert!(x < (u32::MAX as usize));\n         DefIndex(x as u32)\n     }\n \n+    #[inline]\n     pub fn from_u32(x: u32) -> DefIndex {\n         DefIndex(x)\n     }\n \n+    #[inline]\n     pub fn as_usize(&self) -> usize {\n         self.0 as usize\n     }\n \n+    #[inline]\n     pub fn as_u32(&self) -> u32 {\n         self.0\n     }\n+\n+    #[inline]\n+    pub fn address_space(&self) -> DefIndexAddressSpace {\n+        if self.0 < DEF_INDEX_HI_START.0 {\n+            DefIndexAddressSpace::Low\n+        } else {\n+            DefIndexAddressSpace::High\n+        }\n+    }\n+\n+    /// Converts this DefIndex into a zero-based array index.\n+    /// This index is the offset within the given \"range\" of the DefIndex,\n+    /// that is, if the DefIndex is part of the \"high\" range, the resulting\n+    /// index will be (DefIndex - DEF_INDEX_HI_START).\n+    #[inline]\n+    pub fn as_array_index(&self) -> usize {\n+        (self.0 & !DEF_INDEX_HI_START.0) as usize\n+    }\n }\n \n+/// The start of the \"high\" range of DefIndexes.\n+const DEF_INDEX_HI_START: DefIndex = DefIndex(1 << 31);\n+\n /// The crate root is always assigned index 0 by the AST Map code,\n /// thanks to `NodeCollector::new`.\n pub const CRATE_DEF_INDEX: DefIndex = DefIndex(0);\n \n+#[derive(Copy, Clone, Eq, PartialEq, Hash)]\n+pub enum DefIndexAddressSpace {\n+    Low = 0,\n+    High = 1,\n+}\n+\n+impl DefIndexAddressSpace {\n+    #[inline]\n+    pub fn index(&self) -> usize {\n+        *self as usize\n+    }\n+\n+    #[inline]\n+    pub fn start(&self) -> usize {\n+        self.index() * DEF_INDEX_HI_START.as_usize()\n+    }\n+}\n+\n /// A DefId identifies a particular *definition*, by combining a crate\n /// index and a def index.\n #[derive(Clone, Eq, Ord, PartialOrd, PartialEq, RustcEncodable, RustcDecodable, Hash, Copy)]"}, {"sha": "2ac1a036f99e1a996a85f60c1f653c0693474181", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1006, "deletions": 774, "changes": 1780, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e"}, {"sha": "cae358a303e028ea17a60d9a7745d30de4af558b", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 46, "deletions": 21, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -9,13 +9,15 @@\n // except according to those terms.\n \n use hir::map::definitions::*;\n-use hir::def_id::{CRATE_DEF_INDEX, DefIndex};\n+use hir::def_id::{CRATE_DEF_INDEX, DefIndex, DefIndexAddressSpace};\n \n use syntax::ast::*;\n use syntax::ext::hygiene::Mark;\n use syntax::visit;\n use syntax::symbol::{Symbol, keywords};\n \n+use hir::map::{ITEM_LIKE_SPACE, REGULAR_SPACE};\n+\n /// Creates def ids for nodes in the AST.\n pub struct DefCollector<'a> {\n     definitions: &'a mut Definitions,\n@@ -39,23 +41,31 @@ impl<'a> DefCollector<'a> {\n     }\n \n     pub fn collect_root(&mut self) {\n-        let root = self.create_def_with_parent(None, CRATE_NODE_ID, DefPathData::CrateRoot);\n+        let root = self.create_def_with_parent(None,\n+                                               CRATE_NODE_ID,\n+                                               DefPathData::CrateRoot,\n+                                               ITEM_LIKE_SPACE);\n         assert_eq!(root, CRATE_DEF_INDEX);\n         self.parent_def = Some(root);\n     }\n \n-    fn create_def(&mut self, node_id: NodeId, data: DefPathData) -> DefIndex {\n+    fn create_def(&mut self,\n+                  node_id: NodeId,\n+                  data: DefPathData,\n+                  address_space: DefIndexAddressSpace)\n+                  -> DefIndex {\n         let parent_def = self.parent_def;\n         debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n-        self.definitions.create_def_with_parent(parent_def, node_id, data)\n+        self.definitions.create_def_with_parent(parent_def, node_id, data, address_space)\n     }\n \n     fn create_def_with_parent(&mut self,\n                               parent: Option<DefIndex>,\n                               node_id: NodeId,\n-                              data: DefPathData)\n+                              data: DefPathData,\n+                              address_space: DefIndexAddressSpace)\n                               -> DefIndex {\n-        self.definitions.create_def_with_parent(parent, node_id, data)\n+        self.definitions.create_def_with_parent(parent, node_id, data, address_space)\n     }\n \n     pub fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n@@ -76,7 +86,7 @@ impl<'a> DefCollector<'a> {\n             _ => {}\n         }\n \n-        self.create_def(expr.id, DefPathData::Initializer);\n+        self.create_def(expr.id, DefPathData::Initializer, REGULAR_SPACE);\n     }\n \n     fn visit_macro_invoc(&mut self, id: NodeId, const_expr: bool) {\n@@ -118,27 +128,32 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     ViewPathSimple(..) => {}\n                     ViewPathList(_, ref imports) => {\n                         for import in imports {\n-                            self.create_def(import.node.id, DefPathData::Misc);\n+                            self.create_def(import.node.id,\n+                                            DefPathData::Misc,\n+                                            ITEM_LIKE_SPACE);\n                         }\n                     }\n                 }\n                 DefPathData::Misc\n             }\n         };\n-        let def = self.create_def(i.id, def_data);\n+        let def = self.create_def(i.id, def_data, ITEM_LIKE_SPACE);\n \n         self.with_parent(def, |this| {\n             match i.node {\n                 ItemKind::Enum(ref enum_definition, _) => {\n                     for v in &enum_definition.variants {\n                         let variant_def_index =\n                             this.create_def(v.node.data.id(),\n-                                            DefPathData::EnumVariant(v.node.name.name.as_str()));\n+                                            DefPathData::EnumVariant(v.node.name.name.as_str()),\n+                                            REGULAR_SPACE);\n                         this.with_parent(variant_def_index, |this| {\n                             for (index, field) in v.node.data.fields().iter().enumerate() {\n                                 let name = field.ident.map(|ident| ident.name)\n                                     .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n-                                this.create_def(field.id, DefPathData::Field(name.as_str()));\n+                                this.create_def(field.id,\n+                                                DefPathData::Field(name.as_str()),\n+                                                REGULAR_SPACE);\n                             }\n \n                             if let Some(ref expr) = v.node.disr_expr {\n@@ -151,13 +166,14 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     // If this is a tuple-like struct, register the constructor.\n                     if !struct_def.is_struct() {\n                         this.create_def(struct_def.id(),\n-                                        DefPathData::StructCtor);\n+                                        DefPathData::StructCtor,\n+                                        REGULAR_SPACE);\n                     }\n \n                     for (index, field) in struct_def.fields().iter().enumerate() {\n                         let name = field.ident.map(|ident| ident.name.as_str())\n                             .unwrap_or(Symbol::intern(&index.to_string()).as_str());\n-                        this.create_def(field.id, DefPathData::Field(name));\n+                        this.create_def(field.id, DefPathData::Field(name), REGULAR_SPACE);\n                     }\n                 }\n                 _ => {}\n@@ -168,7 +184,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_foreign_item(&mut self, foreign_item: &'a ForeignItem) {\n         let def = self.create_def(foreign_item.id,\n-                                  DefPathData::ValueNs(foreign_item.ident.name.as_str()));\n+                                  DefPathData::ValueNs(foreign_item.ident.name.as_str()),\n+                                  REGULAR_SPACE);\n \n         self.with_parent(def, |this| {\n             visit::walk_foreign_item(this, foreign_item);\n@@ -177,7 +194,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_generics(&mut self, generics: &'a Generics) {\n         for ty_param in generics.ty_params.iter() {\n-            self.create_def(ty_param.id, DefPathData::TypeParam(ty_param.ident.name.as_str()));\n+            self.create_def(ty_param.id,\n+                            DefPathData::TypeParam(ty_param.ident.name.as_str()),\n+                            REGULAR_SPACE);\n         }\n \n         visit::walk_generics(self, generics);\n@@ -191,7 +210,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             TraitItemKind::Macro(..) => return self.visit_macro_invoc(ti.id, false),\n         };\n \n-        let def = self.create_def(ti.id, def_data);\n+        let def = self.create_def(ti.id, def_data, ITEM_LIKE_SPACE);\n         self.with_parent(def, |this| {\n             if let TraitItemKind::Const(_, Some(ref expr)) = ti.node {\n                 this.visit_const_expr(expr);\n@@ -209,7 +228,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id, false),\n         };\n \n-        let def = self.create_def(ii.id, def_data);\n+        let def = self.create_def(ii.id, def_data, ITEM_LIKE_SPACE);\n         self.with_parent(def, |this| {\n             if let ImplItemKind::Const(_, ref expr) = ii.node {\n                 this.visit_const_expr(expr);\n@@ -225,7 +244,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         match pat.node {\n             PatKind::Mac(..) => return self.visit_macro_invoc(pat.id, false),\n             PatKind::Ident(_, id, _) => {\n-                let def = self.create_def(pat.id, DefPathData::Binding(id.node.name.as_str()));\n+                let def = self.create_def(pat.id,\n+                                          DefPathData::Binding(id.node.name.as_str()),\n+                                          REGULAR_SPACE);\n                 self.parent_def = Some(def);\n             }\n             _ => {}\n@@ -242,7 +263,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ExprKind::Mac(..) => return self.visit_macro_invoc(expr.id, false),\n             ExprKind::Repeat(_, ref count) => self.visit_const_expr(count),\n             ExprKind::Closure(..) => {\n-                let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n+                let def = self.create_def(expr.id,\n+                                          DefPathData::ClosureExpr,\n+                                          REGULAR_SPACE);\n                 self.parent_def = Some(def);\n             }\n             _ => {}\n@@ -257,7 +280,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             TyKind::Mac(..) => return self.visit_macro_invoc(ty.id, false),\n             TyKind::Array(_, ref length) => self.visit_const_expr(length),\n             TyKind::ImplTrait(..) => {\n-                self.create_def(ty.id, DefPathData::ImplTrait);\n+                self.create_def(ty.id, DefPathData::ImplTrait, REGULAR_SPACE);\n             }\n             TyKind::Typeof(ref expr) => self.visit_const_expr(expr),\n             _ => {}\n@@ -266,7 +289,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_lifetime_def(&mut self, def: &'a LifetimeDef) {\n-        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name.as_str()));\n+        self.create_def(def.lifetime.id,\n+                        DefPathData::LifetimeDef(def.lifetime.name.as_str()),\n+                        REGULAR_SPACE);\n     }\n \n     fn visit_stmt(&mut self, stmt: &'a Stmt) {"}, {"sha": "809d5db3071d7be75607974035a056b28ef3c377", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 108, "deletions": 26, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -14,8 +14,10 @@\n //! There are also some rather random cases (like const initializer\n //! expressions) that are mostly just leftovers.\n \n-use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n+use hir;\n+use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE, DefIndexAddressSpace};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::stable_hasher::StableHasher;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::fmt::Write;\n@@ -29,24 +31,44 @@ use util::nodemap::NodeMap;\n /// Internally the DefPathTable holds a tree of DefKeys, where each DefKey\n /// stores the DefIndex of its parent.\n /// There is one DefPathTable for each crate.\n-#[derive(Clone)]\n pub struct DefPathTable {\n-    index_to_key: Vec<DefKey>,\n+    index_to_key: [Vec<DefKey>; 2],\n     key_to_index: FxHashMap<DefKey, DefIndex>,\n }\n \n+// Unfortunately we have to provide a manual impl of Clone because of the\n+// fixed-sized array field.\n+impl Clone for DefPathTable {\n+    fn clone(&self) -> Self {\n+        DefPathTable {\n+            index_to_key: [self.index_to_key[0].clone(),\n+                           self.index_to_key[1].clone()],\n+            key_to_index: self.key_to_index.clone(),\n+        }\n+    }\n+}\n+\n impl DefPathTable {\n-    fn insert(&mut self, key: DefKey) -> DefIndex {\n-        let index = DefIndex::new(self.index_to_key.len());\n-        debug!(\"DefPathTable::insert() - {:?} <-> {:?}\", key, index);\n-        self.index_to_key.push(key.clone());\n+\n+    fn allocate(&mut self,\n+                key: DefKey,\n+                address_space: DefIndexAddressSpace)\n+                -> DefIndex {\n+        let index = {\n+            let index_to_key = &mut self.index_to_key[address_space.index()];\n+            let index = DefIndex::new(index_to_key.len() + address_space.start());\n+            debug!(\"DefPathTable::insert() - {:?} <-> {:?}\", key, index);\n+            index_to_key.push(key.clone());\n+            index\n+        };\n         self.key_to_index.insert(key, index);\n         index\n     }\n \n     #[inline(always)]\n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n-        self.index_to_key[index.as_usize()].clone()\n+        self.index_to_key[index.address_space().index()]\n+                         [index.as_array_index()].clone()\n     }\n \n     #[inline(always)]\n@@ -94,17 +116,28 @@ impl DefPathTable {\n \n impl Encodable for DefPathTable {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        self.index_to_key.encode(s)\n+        self.index_to_key[DefIndexAddressSpace::Low.index()].encode(s)?;\n+        self.index_to_key[DefIndexAddressSpace::High.index()].encode(s)\n     }\n }\n \n impl Decodable for DefPathTable {\n     fn decode<D: Decoder>(d: &mut D) -> Result<DefPathTable, D::Error> {\n-        let index_to_key: Vec<DefKey> = Decodable::decode(d)?;\n-        let key_to_index = index_to_key.iter()\n-                                       .enumerate()\n-                                       .map(|(index, key)| (key.clone(), DefIndex::new(index)))\n-                                       .collect();\n+        let index_to_key_lo: Vec<DefKey> = Decodable::decode(d)?;\n+        let index_to_key_high: Vec<DefKey> = Decodable::decode(d)?;\n+\n+        let index_to_key = [index_to_key_lo, index_to_key_high];\n+\n+        let mut key_to_index = FxHashMap();\n+\n+        for space in &[DefIndexAddressSpace::Low, DefIndexAddressSpace::High] {\n+            key_to_index.extend(index_to_key[space.index()]\n+                .iter()\n+                .enumerate()\n+                .map(|(index, key)| (key.clone(),\n+                                     DefIndex::new(index + space.start()))))\n+        }\n+\n         Ok(DefPathTable {\n             index_to_key: index_to_key,\n             key_to_index: key_to_index,\n@@ -116,11 +149,27 @@ impl Decodable for DefPathTable {\n /// The definition table containing node definitions.\n /// It holds the DefPathTable for local DefIds/DefPaths and it also stores a\n /// mapping from NodeIds to local DefIds.\n-#[derive(Clone)]\n pub struct Definitions {\n     table: DefPathTable,\n     node_to_def_index: NodeMap<DefIndex>,\n-    def_index_to_node: Vec<ast::NodeId>,\n+    def_index_to_node: [Vec<ast::NodeId>; 2],\n+    pub(super) node_to_hir_id: IndexVec<ast::NodeId, hir::HirId>,\n+}\n+\n+// Unfortunately we have to provide a manual impl of Clone because of the\n+// fixed-sized array field.\n+impl Clone for Definitions {\n+    fn clone(&self) -> Self {\n+        Definitions {\n+            table: self.table.clone(),\n+            node_to_def_index: self.node_to_def_index.clone(),\n+            def_index_to_node: [\n+                self.def_index_to_node[0].clone(),\n+                self.def_index_to_node[1].clone(),\n+            ],\n+            node_to_hir_id: self.node_to_hir_id.clone(),\n+        }\n+    }\n }\n \n /// A unique identifier that we can use to lookup a definition\n@@ -206,6 +255,23 @@ impl DefPath {\n         s\n     }\n \n+    /// Returns a string representation of the DefPath without\n+    /// the crate-prefix. This method is useful if you don't have\n+    /// a TyCtxt available.\n+    pub fn to_string_no_crate(&self) -> String {\n+        let mut s = String::with_capacity(self.data.len() * 16);\n+\n+        for component in &self.data {\n+            write!(s,\n+                   \"::{}[{}]\",\n+                   component.data.as_interned_str(),\n+                   component.disambiguator)\n+                .unwrap();\n+        }\n+\n+        s\n+    }\n+\n     pub fn deterministic_hash(&self, tcx: TyCtxt) -> u64 {\n         debug!(\"deterministic_hash({:?})\", self);\n         let mut state = StableHasher::new();\n@@ -270,11 +336,12 @@ impl Definitions {\n     pub fn new() -> Definitions {\n         Definitions {\n             table: DefPathTable {\n-                index_to_key: vec![],\n+                index_to_key: [vec![], vec![]],\n                 key_to_index: FxHashMap(),\n             },\n             node_to_def_index: NodeMap(),\n-            def_index_to_node: vec![],\n+            def_index_to_node: [vec![], vec![]],\n+            node_to_hir_id: IndexVec::new(),\n         }\n     }\n \n@@ -283,8 +350,9 @@ impl Definitions {\n     }\n \n     /// Get the number of definitions.\n-    pub fn len(&self) -> usize {\n-        self.def_index_to_node.len()\n+    pub fn def_index_counts_lo_hi(&self) -> (usize, usize) {\n+        (self.def_index_to_node[DefIndexAddressSpace::Low.index()].len(),\n+         self.def_index_to_node[DefIndexAddressSpace::High.index()].len())\n     }\n \n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n@@ -318,8 +386,9 @@ impl Definitions {\n \n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n         if def_id.krate == LOCAL_CRATE {\n-            assert!(def_id.index.as_usize() < self.def_index_to_node.len());\n-            Some(self.def_index_to_node[def_id.index.as_usize()])\n+            let space_index = def_id.index.address_space().index();\n+            let array_index = def_id.index.as_array_index();\n+            Some(self.def_index_to_node[space_index][array_index])\n         } else {\n             None\n         }\n@@ -329,7 +398,9 @@ impl Definitions {\n     pub fn create_def_with_parent(&mut self,\n                                   parent: Option<DefIndex>,\n                                   node_id: ast::NodeId,\n-                                  data: DefPathData)\n+                                  data: DefPathData,\n+                                  // is_owner: bool)\n+                                  address_space: DefIndexAddressSpace)\n                                   -> DefIndex {\n         debug!(\"create_def_with_parent(parent={:?}, node_id={:?}, data={:?})\",\n                parent, node_id, data);\n@@ -359,14 +430,25 @@ impl Definitions {\n         debug!(\"create_def_with_parent: after disambiguation, key = {:?}\", key);\n \n         // Create the definition.\n-        let index = self.table.insert(key);\n+        let index = self.table.allocate(key, address_space);\n+        assert_eq!(index.as_array_index(),\n+                   self.def_index_to_node[address_space.index()].len());\n+        self.def_index_to_node[address_space.index()].push(node_id);\n+\n         debug!(\"create_def_with_parent: def_index_to_node[{:?} <-> {:?}\", index, node_id);\n         self.node_to_def_index.insert(node_id, index);\n-        assert_eq!(index.as_usize(), self.def_index_to_node.len());\n-        self.def_index_to_node.push(node_id);\n \n         index\n     }\n+\n+    /// Initialize the ast::NodeId to HirId mapping once it has been generated during\n+    /// AST to HIR lowering.\n+    pub fn init_node_id_to_hir_id_mapping(&mut self,\n+                                          mapping: IndexVec<ast::NodeId, hir::HirId>) {\n+        assert!(self.node_to_hir_id.is_empty(),\n+                \"Trying initialize NodeId -> HirId mapping twice\");\n+        self.node_to_hir_id = mapping;\n+    }\n }\n \n impl DefPathData {"}, {"sha": "b3cc0c542ef9da217dfb225c0bcbc9746e193397", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -0,0 +1,184 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n+use hir::{self, intravisit, HirId, ItemLocalId};\n+use syntax::ast::NodeId;\n+use hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_data_structures::fx::FxHashMap;\n+\n+pub fn check_crate<'hir>(hir_map: &hir::map::Map<'hir>) {\n+    let mut outer_visitor = OuterVisitor {\n+        hir_map: hir_map,\n+        errors: vec![],\n+    };\n+\n+    hir_map.dep_graph.with_ignore(|| {\n+        hir_map.krate().visit_all_item_likes(&mut outer_visitor);\n+        if !outer_visitor.errors.is_empty() {\n+            let message = outer_visitor\n+                .errors\n+                .iter()\n+                .fold(String::new(), |s1, s2| s1 + \"\\n\" + s2);\n+            bug!(\"{}\", message);\n+        }\n+    });\n+}\n+\n+struct HirIdValidator<'a, 'hir: 'a> {\n+    hir_map: &'a hir::map::Map<'hir>,\n+    owner_def_index: Option<DefIndex>,\n+    hir_ids_seen: FxHashMap<ItemLocalId, NodeId>,\n+    errors: Vec<String>,\n+}\n+\n+struct OuterVisitor<'a, 'hir: 'a> {\n+    hir_map: &'a hir::map::Map<'hir>,\n+    errors: Vec<String>,\n+}\n+\n+impl<'a, 'hir: 'a> OuterVisitor<'a, 'hir> {\n+    fn new_inner_visitor(&self,\n+                         hir_map: &'a hir::map::Map<'hir>)\n+                         -> HirIdValidator<'a, 'hir> {\n+        HirIdValidator {\n+            hir_map: hir_map,\n+            owner_def_index: None,\n+            hir_ids_seen: FxHashMap(),\n+            errors: Vec::new(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'hir: 'a> ItemLikeVisitor<'hir> for OuterVisitor<'a, 'hir> {\n+    fn visit_item(&mut self, i: &'hir hir::Item) {\n+        let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n+        inner_visitor.check(i.id, |this| intravisit::walk_item(this, i));\n+        self.errors.extend(inner_visitor.errors.drain(..));\n+    }\n+\n+    fn visit_trait_item(&mut self, i: &'hir hir::TraitItem) {\n+        let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n+        inner_visitor.check(i.id, |this| intravisit::walk_trait_item(this, i));\n+        self.errors.extend(inner_visitor.errors.drain(..));\n+    }\n+\n+    fn visit_impl_item(&mut self, i: &'hir hir::ImplItem) {\n+        let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n+        inner_visitor.check(i.id, |this| intravisit::walk_impl_item(this, i));\n+        self.errors.extend(inner_visitor.errors.drain(..));\n+    }\n+}\n+\n+impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n+\n+    fn check<F: FnOnce(&mut HirIdValidator<'a, 'hir>)>(&mut self,\n+                                                       node_id: NodeId,\n+                                                       walk: F) {\n+        assert!(self.owner_def_index.is_none());\n+        let owner_def_index = self.hir_map.local_def_id(node_id).index;\n+        self.owner_def_index = Some(owner_def_index);\n+        walk(self);\n+\n+        if owner_def_index == CRATE_DEF_INDEX {\n+            return\n+        }\n+\n+        // There's always at least one entry for the owning item itself\n+        let max = self.hir_ids_seen\n+                      .keys()\n+                      .map(|local_id| local_id.as_usize())\n+                      .max()\n+                      .unwrap();\n+\n+        if max != self.hir_ids_seen.len() - 1 {\n+            // Collect the missing ItemLocalIds\n+            let missing: Vec<_> = (0 .. max + 1)\n+              .filter(|&i| !self.hir_ids_seen.contains_key(&ItemLocalId(i as u32)))\n+              .collect();\n+\n+            // Try to map those to something more useful\n+            let mut missing_items = vec![];\n+\n+            for local_id in missing {\n+                let hir_id = HirId {\n+                    owner: owner_def_index,\n+                    local_id: ItemLocalId(local_id as u32),\n+                };\n+\n+                // We are already in ICE mode here, so doing a linear search\n+                // should be fine.\n+                let (node_id, _) = self.hir_map\n+                                       .definitions()\n+                                       .node_to_hir_id\n+                                       .iter()\n+                                       .enumerate()\n+                                       .find(|&(_, &entry)| hir_id == entry)\n+                                       .unwrap();\n+                let node_id = NodeId::new(node_id);\n+                missing_items.push(format!(\"[local_id: {}, node:{}]\",\n+                                           local_id,\n+                                           self.hir_map.node_to_string(node_id)));\n+            }\n+\n+            self.errors.push(format!(\n+                \"ItemLocalIds not assigned densely in {}. \\\n+                Max ItemLocalId = {}, missing IDs = {:?}\",\n+                self.hir_map.def_path(DefId::local(owner_def_index)).to_string_no_crate(),\n+                max,\n+                missing_items));\n+        }\n+    }\n+}\n+\n+impl<'a, 'hir: 'a> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n+\n+    fn nested_visit_map<'this>(&'this mut self)\n+                               -> intravisit::NestedVisitorMap<'this, 'hir> {\n+        intravisit::NestedVisitorMap::OnlyBodies(self.hir_map)\n+    }\n+\n+    fn visit_id(&mut self, node_id: NodeId) {\n+        let owner = self.owner_def_index.unwrap();\n+        let stable_id = self.hir_map.definitions().node_to_hir_id[node_id];\n+\n+        if stable_id == hir::DUMMY_HIR_ID {\n+            self.errors.push(format!(\"HirIdValidator: No HirId assigned for NodeId {}: {:?}\",\n+                                     node_id,\n+                                     self.hir_map.node_to_string(node_id)));\n+        }\n+\n+        if owner != stable_id.owner {\n+            self.errors.push(format!(\n+                \"HirIdValidator: The recorded owner of {} is {} instead of {}\",\n+                self.hir_map.node_to_string(node_id),\n+                self.hir_map.def_path(DefId::local(stable_id.owner)).to_string_no_crate(),\n+                self.hir_map.def_path(DefId::local(owner)).to_string_no_crate()));\n+        }\n+\n+        if let Some(prev) = self.hir_ids_seen.insert(stable_id.local_id, node_id) {\n+            if prev != node_id {\n+                self.errors.push(format!(\n+                    \"HirIdValidator: Same HirId {}/{} assigned for nodes {} and {}\",\n+                    self.hir_map.def_path(DefId::local(stable_id.owner)).to_string_no_crate(),\n+                    stable_id.local_id.as_usize(),\n+                    self.hir_map.node_to_string(prev),\n+                    self.hir_map.node_to_string(node_id)));\n+            }\n+        }\n+    }\n+\n+    fn visit_impl_item_ref(&mut self, _: &'hir hir::ImplItemRef) {\n+        // Explicitly do nothing here. ImplItemRefs contain hir::Visibility\n+        // values that actually belong to an ImplItem instead of the ItemImpl\n+        // we are currently in. So for those it's correct that they have a\n+        // different owner.\n+    }\n+}"}, {"sha": "583b3b848f30d88a7e572cc713233555a265f594", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -17,7 +17,7 @@ pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n \n use dep_graph::{DepGraph, DepNode};\n \n-use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n+use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex, DefIndexAddressSpace};\n \n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID};\n@@ -36,6 +36,10 @@ pub mod blocks;\n mod collector;\n mod def_collector;\n pub mod definitions;\n+mod hir_id_validator;\n+\n+pub const ITEM_LIKE_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::Low;\n+pub const REGULAR_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::High;\n \n #[derive(Copy, Clone, Debug)]\n pub enum Node<'hir> {\n@@ -346,10 +350,6 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn num_local_def_ids(&self) -> usize {\n-        self.definitions.len()\n-    }\n-\n     pub fn definitions(&self) -> &Definitions {\n         &self.definitions\n     }\n@@ -964,13 +964,17 @@ pub fn map_crate<'hir>(forest: &'hir mut Forest,\n               entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n     }\n \n-    Map {\n+    let map = Map {\n         forest: forest,\n         dep_graph: forest.dep_graph.clone(),\n         map: map,\n         definitions: definitions,\n         inlined_bodies: RefCell::new(DefIdMap()),\n-    }\n+    };\n+\n+    hir_id_validator::check_crate(&map);\n+\n+    map\n }\n \n /// Identical to the `PpAnn` implementation for `hir::Crate`,"}, {"sha": "1c79a02d3da0e88d83f9b36511b09deb34bfc69d", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -30,7 +30,7 @@ pub use self::Visibility::{Public, Inherited};\n pub use self::PathParameters::*;\n \n use hir::def::Def;\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n use util::nodemap::{NodeMap, FxHashSet};\n \n use syntax_pos::{Span, ExpnId, DUMMY_SP};\n@@ -43,6 +43,8 @@ use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::TokenStream;\n use syntax::util::ThinVec;\n \n+use rustc_data_structures::indexed_vec;\n+\n use std::collections::BTreeMap;\n use std::fmt;\n \n@@ -73,6 +75,63 @@ pub mod pat_util;\n pub mod print;\n pub mod svh;\n \n+/// A HirId uniquely identifies a node in the HIR of then current crate. It is\n+/// composed of the `owner`, which is the DefIndex of the directly enclosing\n+/// hir::Item, hir::TraitItem, or hir::ImplItem (i.e. the closest \"item-like\"),\n+/// and the `local_id` which is unique within the given owner.\n+///\n+/// This two-level structure makes for more stable values: One can move an item\n+/// around within the source code, or add or remove stuff before it, without\n+/// the local_id part of the HirId changing, which is a very useful property\n+/// incremental compilation where we have to persist things through changes to\n+/// the code base.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug,\n+         RustcEncodable, RustcDecodable)]\n+pub struct HirId {\n+    pub owner: DefIndex,\n+    pub local_id: ItemLocalId,\n+}\n+\n+/// An `ItemLocalId` uniquely identifies something within a given \"item-like\",\n+/// that is within a hir::Item, hir::TraitItem, or hir::ImplItem. There is no\n+/// guarantee that the numerical value of a given `ItemLocalId` corresponds to\n+/// the node's position within the owning item in any way, but there is a\n+/// guarantee that the `LocalItemId`s within an owner occupy a dense range of\n+/// integers starting at zero, so a mapping that maps all or most nodes within\n+/// an \"item-like\" to something else can be implement by a `Vec` instead of a\n+/// tree or hash map.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug,\n+         RustcEncodable, RustcDecodable)]\n+pub struct ItemLocalId(pub u32);\n+\n+impl ItemLocalId {\n+    pub fn as_usize(&self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n+impl indexed_vec::Idx for ItemLocalId {\n+    fn new(idx: usize) -> Self {\n+        debug_assert!((idx as u32) as usize == idx);\n+        ItemLocalId(idx as u32)\n+    }\n+\n+    fn index(self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n+/// The `HirId` corresponding to CRATE_NODE_ID and CRATE_DEF_INDEX\n+pub const CRATE_HIR_ID: HirId = HirId {\n+    owner: CRATE_DEF_INDEX,\n+    local_id: ItemLocalId(0)\n+};\n+\n+pub const DUMMY_HIR_ID: HirId = HirId {\n+    owner: CRATE_DEF_INDEX,\n+    local_id: ItemLocalId(!0)\n+};\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,"}, {"sha": "a71251eedf5d037e82e9ed84cb04efd32a4dae13", "filename": "src/librustc/ich/caching_codemap_view.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::ty::TyCtxt;\n+use ty::TyCtxt;\n use std::rc::Rc;\n use syntax::codemap::CodeMap;\n use syntax_pos::{BytePos, FileMap};", "previous_filename": "src/librustc_incremental/calculate_svh/caching_codemap_view.rs"}, {"sha": "03051dc0034204a7dde4cc65c3882432c3070ef2", "filename": "src/librustc/ich/def_path_hash.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fich%2Fdef_path_hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fich%2Fdef_path_hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fdef_path_hash.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::hir::def_id::DefId;\n-use rustc::ty::TyCtxt;\n-use rustc::util::nodemap::DefIdMap;\n+use hir::def_id::DefId;\n+use ty::TyCtxt;\n+use util::nodemap::DefIdMap;\n \n pub struct DefPathHashes<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,", "previous_filename": "src/librustc_incremental/calculate_svh/def_path_hash.rs"}, {"sha": "d296d8293fb0674010bb00d12ec012fdfaca0588", "filename": "src/librustc/ich/fingerprint.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fich%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fich%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Ffingerprint.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "previous_filename": "src/librustc_incremental/ich/fingerprint.rs"}, {"sha": "209953f3c686b85b99c1f136d90a1bf6def1924c", "filename": "src/librustc/ich/mod.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use self::fingerprint::Fingerprint;\n+pub use self::def_path_hash::DefPathHashes;\n+pub use self::caching_codemap_view::CachingCodemapView;\n+\n+mod fingerprint;\n+mod def_path_hash;\n+mod caching_codemap_view;\n+\n+pub const ATTR_DIRTY: &'static str = \"rustc_dirty\";\n+pub const ATTR_CLEAN: &'static str = \"rustc_clean\";\n+pub const ATTR_DIRTY_METADATA: &'static str = \"rustc_metadata_dirty\";\n+pub const ATTR_CLEAN_METADATA: &'static str = \"rustc_metadata_clean\";\n+pub const ATTR_IF_THIS_CHANGED: &'static str = \"rustc_if_this_changed\";\n+pub const ATTR_THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";\n+\n+pub const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\n+    \"cfg\",\n+    ATTR_IF_THIS_CHANGED,\n+    ATTR_THEN_THIS_WOULD_NEED,\n+    ATTR_DIRTY,\n+    ATTR_CLEAN,\n+    ATTR_DIRTY_METADATA,\n+    ATTR_CLEAN_METADATA\n+];"}, {"sha": "c1c945d4e6063fc007afff67da7da9d7f5db0bf6", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -72,6 +72,7 @@ pub mod diagnostics;\n pub mod cfg;\n pub mod dep_graph;\n pub mod hir;\n+pub mod ich;\n pub mod infer;\n pub mod lint;\n "}, {"sha": "a0603c5795247c75fb98911daae1c1b3c7ddd284", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -82,6 +82,7 @@ pub enum OutputType {\n     Bitcode,\n     Assembly,\n     LlvmAssembly,\n+    Mir,\n     Metadata,\n     Object,\n     Exe,\n@@ -96,6 +97,7 @@ impl OutputType {\n             OutputType::Bitcode |\n             OutputType::Assembly |\n             OutputType::LlvmAssembly |\n+            OutputType::Mir |\n             OutputType::Object |\n             OutputType::Metadata => false,\n         }\n@@ -106,6 +108,7 @@ impl OutputType {\n             OutputType::Bitcode => \"llvm-bc\",\n             OutputType::Assembly => \"asm\",\n             OutputType::LlvmAssembly => \"llvm-ir\",\n+            OutputType::Mir => \"mir\",\n             OutputType::Object => \"obj\",\n             OutputType::Metadata => \"metadata\",\n             OutputType::Exe => \"link\",\n@@ -118,6 +121,7 @@ impl OutputType {\n             OutputType::Bitcode => \"bc\",\n             OutputType::Assembly => \"s\",\n             OutputType::LlvmAssembly => \"ll\",\n+            OutputType::Mir => \"mir\",\n             OutputType::Object => \"o\",\n             OutputType::Metadata => \"rmeta\",\n             OutputType::DepInfo => \"d\",\n@@ -172,6 +176,7 @@ impl OutputTypes {\n             OutputType::Bitcode |\n             OutputType::Assembly |\n             OutputType::LlvmAssembly |\n+            OutputType::Mir |\n             OutputType::Object |\n             OutputType::Exe => true,\n             OutputType::Metadata |\n@@ -1370,6 +1375,7 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n                 let output_type = match parts.next().unwrap() {\n                     \"asm\" => OutputType::Assembly,\n                     \"llvm-ir\" => OutputType::LlvmAssembly,\n+                    \"mir\" => OutputType::Mir,\n                     \"llvm-bc\" => OutputType::Bitcode,\n                     \"obj\" => OutputType::Object,\n                     \"metadata\" => OutputType::Metadata,"}, {"sha": "1c1e0d91cb4d6cd0deac1c46b955ef7a43feae9b", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -509,18 +509,21 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n     }\n \n     fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n+        self.hash_discriminant_u8(r);\n         match *r {\n-            ty::ReErased => {\n-                self.hash::<u32>(0);\n+            ty::ReErased |\n+            ty::ReStatic |\n+            ty::ReEmpty => {\n+                // No variant fields to hash for these ...\n             }\n             ty::ReLateBound(db, ty::BrAnon(i)) => {\n-                assert!(db.depth > 0);\n-                self.hash::<u32>(db.depth);\n+                self.hash(db.depth);\n                 self.hash(i);\n             }\n-            ty::ReStatic |\n-            ty::ReEmpty |\n-            ty::ReEarlyBound(..) |\n+            ty::ReEarlyBound(ty::EarlyBoundRegion { index, name }) => {\n+                self.hash(index);\n+                self.hash(name.as_str());\n+            }\n             ty::ReLateBound(..) |\n             ty::ReFree(..) |\n             ty::ReScope(..) |"}, {"sha": "62c430dda327fe1c48c4a9537c50daecbd87ecce", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -189,6 +189,13 @@ impl<I: Idx, T> IndexVec<I, T> {\n     }\n }\n \n+impl<I: Idx, T: Clone> IndexVec<I, T> {\n+    #[inline]\n+    pub fn resize(&mut self, new_len: usize, value: T) {\n+        self.raw.resize(new_len, value)\n+    }\n+}\n+\n impl<I: Idx, T> Index<I> for IndexVec<I, T> {\n     type Output = T;\n "}, {"sha": "5d600270626cb0ebc9c65ab9b32d58697233b2e4", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -10,6 +10,7 @@\n \n use rustc::hir::{self, map as hir_map};\n use rustc::hir::lowering::lower_crate;\n+use rustc::ich::Fingerprint;\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_mir as mir;\n use rustc::session::{Session, CompileResult, compile_result_from_err_count};\n@@ -25,7 +26,6 @@ use rustc::util::nodemap::NodeSet;\n use rustc::util::fs::rename_or_copy_remove;\n use rustc_borrowck as borrowck;\n use rustc_incremental::{self, IncrementalHashesMap};\n-use rustc_incremental::ich::Fingerprint;\n use rustc_resolve::{MakeGlobMap, Resolver};\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::{self, CStore};\n@@ -209,6 +209,13 @@ pub fn compile_input(sess: &Session,\n                 tcx.print_debug_stats();\n             }\n \n+            if tcx.sess.opts.output_types.contains_key(&OutputType::Mir) {\n+                if let Err(e) = mir::transform::dump_mir::emit_mir(tcx, &outputs) {\n+                    sess.err(&format!(\"could not emit MIR: {}\", e));\n+                    sess.abort_if_errors();\n+                }\n+            }\n+\n             Ok((outputs, trans))\n         })??\n     };"}, {"sha": "897ca0f29576181d18a5faf7005662ea61861582", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -52,13 +52,13 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::{Direction, INCOMING, OUTGOING, NodeIndex};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::ich::{ATTR_IF_THIS_CHANGED, ATTR_THEN_THIS_WOULD_NEED};\n use graphviz::IntoCow;\n use std::env;\n use std::fs::File;\n use std::io::Write;\n use syntax::ast;\n use syntax_pos::Span;\n-use {ATTR_IF_THIS_CHANGED, ATTR_THEN_THIS_WOULD_NEED};\n \n pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _ignore = tcx.dep_graph.in_ignore();"}, {"sha": "c9496a4deb8eb84293b3834cf67f20a3f33912f3", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -35,20 +35,16 @@ use rustc::hir;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::intravisit as visit;\n use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n+use rustc::ich::{Fingerprint, DefPathHashes, CachingCodemapView};\n use rustc::ty::TyCtxt;\n use rustc_data_structures::stable_hasher::StableHasher;\n-use ich::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc::util::common::record_time;\n use rustc::session::config::DebugInfoLevel::NoDebugInfo;\n \n-use self::def_path_hash::DefPathHashes;\n use self::svh_visitor::StrictVersionHashVisitor;\n-use self::caching_codemap_view::CachingCodemapView;\n \n-mod def_path_hash;\n mod svh_visitor;\n-mod caching_codemap_view;\n \n pub type IchHasher = StableHasher<Fingerprint>;\n "}, {"sha": "210803c3f329c9d63719227ab25c18f5d6d481d4", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -26,23 +26,12 @@ use rustc::hir::*;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self as visit, Visitor};\n+use rustc::ich::{DefPathHashes, CachingCodemapView, IGNORED_ATTRIBUTES};\n use rustc::ty::TyCtxt;\n use std::hash::{Hash, Hasher};\n \n-use super::def_path_hash::DefPathHashes;\n-use super::caching_codemap_view::CachingCodemapView;\n use super::IchHasher;\n \n-const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\n-    \"cfg\",\n-    ::ATTR_IF_THIS_CHANGED,\n-    ::ATTR_THEN_THIS_WOULD_NEED,\n-    ::ATTR_DIRTY,\n-    ::ATTR_CLEAN,\n-    ::ATTR_DIRTY_METADATA,\n-    ::ATTR_CLEAN_METADATA\n-];\n-\n pub struct StrictVersionHashVisitor<'a, 'hash: 'a, 'tcx: 'hash> {\n     pub tcx: TyCtxt<'hash, 'tcx, 'tcx>,\n     pub st: &'a mut IchHasher,"}, {"sha": "3b61cc1464a91e55829f071ac8315bf4ffb2785b", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -36,17 +36,9 @@ extern crate serialize as rustc_serialize;\n extern crate syntax;\n extern crate syntax_pos;\n \n-const ATTR_DIRTY: &'static str = \"rustc_dirty\";\n-const ATTR_CLEAN: &'static str = \"rustc_clean\";\n-const ATTR_DIRTY_METADATA: &'static str = \"rustc_metadata_dirty\";\n-const ATTR_CLEAN_METADATA: &'static str = \"rustc_metadata_clean\";\n-const ATTR_IF_THIS_CHANGED: &'static str = \"rustc_if_this_changed\";\n-const ATTR_THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";\n-\n mod assert_dep_graph;\n mod calculate_svh;\n mod persist;\n-pub mod ich;\n \n pub use assert_dep_graph::assert_dep_graph;\n pub use calculate_svh::compute_incremental_hashes_map;"}, {"sha": "d900907395656d9c140df0839fe0ee52bcab30b9", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -12,9 +12,9 @@\n \n use rustc::dep_graph::{DepNode, WorkProduct, WorkProductId};\n use rustc::hir::def_id::DefIndex;\n+use rustc::ich::Fingerprint;\n use std::sync::Arc;\n use rustc_data_structures::fx::FxHashMap;\n-use ich::Fingerprint;\n \n use super::directory::DefPathIndex;\n "}, {"sha": "d931f64d579e1a7f254baab3bddce755221dcc12", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -47,13 +47,12 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit;\n+use rustc::ich::{Fingerprint, ATTR_DIRTY, ATTR_CLEAN, ATTR_DIRTY_METADATA,\n+                 ATTR_CLEAN_METADATA};\n use syntax::ast::{self, Attribute, NestedMetaItem};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use syntax_pos::Span;\n use rustc::ty::TyCtxt;\n-use ich::Fingerprint;\n-\n-use {ATTR_DIRTY, ATTR_CLEAN, ATTR_DIRTY_METADATA, ATTR_CLEAN_METADATA};\n \n const LABEL: &'static str = \"label\";\n const CFG: &'static str = \"cfg\";"}, {"sha": "9d8ff57e03bcc4b39d9144653e8b77cfc2f0f2bc", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -11,14 +11,14 @@\n use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::{CrateNum, DefId};\n use rustc::hir::svh::Svh;\n+use rustc::ich::Fingerprint;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::flock;\n use rustc_serialize::Decodable;\n use rustc_serialize::opaque::Decoder;\n \n use IncrementalHashesMap;\n-use ich::Fingerprint;\n use super::data::*;\n use super::fs::*;\n use super::file_format;"}, {"sha": "ed2e2e72ee79f7381db081082f6d5a608b4ac8d9", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -13,6 +13,7 @@\n use rustc::dep_graph::{DepNode, WorkProductId};\n use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n+use rustc::ich::Fingerprint;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n@@ -22,7 +23,6 @@ use std::path::{Path};\n use std::sync::Arc;\n \n use IncrementalHashesMap;\n-use ich::Fingerprint;\n use super::data::*;\n use super::directory::*;\n use super::dirty_clean;"}, {"sha": "fe8cf72996e15d8b1359e20a4338c6746f81cc0e", "filename": "src/librustc_incremental/persist/preds/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -10,11 +10,11 @@\n \n use rustc::dep_graph::{DepGraphQuery, DepNode};\n use rustc::hir::def_id::DefId;\n+use rustc::ich::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph::{Graph, NodeIndex};\n \n use super::hash::*;\n-use ich::Fingerprint;\n \n mod compress;\n "}, {"sha": "2e5186493370b5d3fd1829f239fe4a3bf617da43", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -11,6 +11,7 @@\n use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n+use rustc::ich::Fingerprint;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n@@ -23,7 +24,6 @@ use std::fs::{self, File};\n use std::path::PathBuf;\n \n use IncrementalHashesMap;\n-use ich::Fingerprint;\n use super::data::*;\n use super::directory::*;\n use super::hash::*;"}, {"sha": "fcdb968dc06152ceca6c81d41140876336ab79f8", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -236,7 +236,8 @@ impl<'a> CrateLoader<'a> {\n             // path (this is a top-level dependency) as we don't want to\n             // implicitly load anything inside the dependency lookup path.\n             let prev_kind = source.dylib.as_ref().or(source.rlib.as_ref())\n-                                  .unwrap().1;\n+                                  .or(source.rmeta.as_ref())\n+                                  .expect(\"No sources for crate\").1;\n             if ret.is_none() && (prev_kind == kind || prev_kind == PathKind::All) {\n                 ret = Some(cnum);\n             }"}, {"sha": "6ccdf8092f210491c856774bb92ea632ccaf91bc", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -558,7 +558,6 @@ impl<'a, 'tcx> CrateMetadata {\n             EntryKind::Union(_, _) => ty::AdtKind::Union,\n             _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n         };\n-        let mut ctor_index = None;\n         let variants = if let ty::AdtKind::Enum = kind {\n             item.children\n                 .decode(self)\n@@ -570,8 +569,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 })\n                 .collect()\n         } else {\n-            let (variant, struct_ctor) = self.get_variant(&item, item_id, tcx);\n-            ctor_index = struct_ctor;\n+            let (variant, _struct_ctor) = self.get_variant(&item, item_id, tcx);\n             vec![variant]\n         };\n         let (kind, repr) = match item.kind {\n@@ -581,13 +579,7 @@ impl<'a, 'tcx> CrateMetadata {\n             _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n         };\n \n-        let adt = tcx.alloc_adt_def(did, kind, variants, repr);\n-        if let Some(ctor_index) = ctor_index {\n-            // Make adt definition available through constructor id as well.\n-            tcx.maps.adt_def.borrow_mut().insert(self.local_def_id(ctor_index), adt);\n-        }\n-\n-        adt\n+        tcx.alloc_adt_def(did, kind, variants, repr)\n     }\n \n     pub fn get_predicates(&self,"}, {"sha": "970a401177ba54e600e3b67aa5a7786717a0a4d3", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 50, "deletions": 17, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -10,7 +10,7 @@\n \n use schema::*;\n \n-use rustc::hir::def_id::{DefId, DefIndex};\n+use rustc::hir::def_id::{DefId, DefIndex, DefIndexAddressSpace};\n use std::io::{Cursor, Write};\n use std::slice;\n use std::u32;\n@@ -23,12 +23,15 @@ use std::u32;\n /// appropriate spot by calling `record_position`. We should never\n /// visit the same index twice.\n pub struct Index {\n-    positions: Vec<u32>,\n+    positions: [Vec<u32>; 2]\n }\n \n impl Index {\n-    pub fn new(max_index: usize) -> Index {\n-        Index { positions: vec![u32::MAX; max_index] }\n+    pub fn new((max_index_lo, max_index_hi): (usize, usize)) -> Index {\n+        Index {\n+            positions: [vec![u32::MAX; max_index_lo],\n+                        vec![u32::MAX; max_index_hi]],\n+        }\n     }\n \n     pub fn record(&mut self, def_id: DefId, entry: Lazy<Entry>) {\n@@ -37,24 +40,31 @@ impl Index {\n     }\n \n     pub fn record_index(&mut self, item: DefIndex, entry: Lazy<Entry>) {\n-        let item = item.as_usize();\n-\n         assert!(entry.position < (u32::MAX as usize));\n         let position = entry.position as u32;\n+        let space_index = item.address_space().index();\n+        let array_index = item.as_array_index();\n \n-        assert!(self.positions[item] == u32::MAX,\n+        assert!(self.positions[space_index][array_index] == u32::MAX,\n                 \"recorded position for item {:?} twice, first at {:?} and now at {:?}\",\n                 item,\n-                self.positions[item],\n+                self.positions[space_index][array_index],\n                 position);\n \n-        self.positions[item] = position.to_le();\n+        self.positions[space_index][array_index] = position.to_le();\n     }\n \n     pub fn write_index(&self, buf: &mut Cursor<Vec<u8>>) -> LazySeq<Index> {\n         let pos = buf.position();\n-        buf.write_all(words_to_bytes(&self.positions)).unwrap();\n-        LazySeq::with_position_and_length(pos as usize, self.positions.len())\n+\n+        // First we write the length of the lower range ...\n+        buf.write_all(words_to_bytes(&[self.positions[0].len() as u32])).unwrap();\n+        // ... then the values in the lower range ...\n+        buf.write_all(words_to_bytes(&self.positions[0][..])).unwrap();\n+        // ... then the values in the higher range.\n+        buf.write_all(words_to_bytes(&self.positions[1][..])).unwrap();\n+        LazySeq::with_position_and_length(pos as usize,\n+            self.positions[0].len() + self.positions[1].len() + 1)\n     }\n }\n \n@@ -70,7 +80,18 @@ impl<'tcx> LazySeq<Index> {\n                index,\n                words.len());\n \n-        let position = u32::from_le(words[index].get());\n+        let positions = match def_index.address_space() {\n+            DefIndexAddressSpace::Low => &words[1..],\n+            DefIndexAddressSpace::High => {\n+                // This is a DefIndex in the higher range, so find out where\n+                // that starts:\n+                let lo_count = u32::from_le(words[0].get()) as usize;\n+                &words[lo_count + 1 .. ]\n+            }\n+        };\n+\n+        let array_index = def_index.as_array_index();\n+        let position = u32::from_le(positions[array_index].get());\n         if position == u32::MAX {\n             debug!(\"Index::lookup: position=u32::MAX\");\n             None\n@@ -84,14 +105,26 @@ impl<'tcx> LazySeq<Index> {\n                                bytes: &'a [u8])\n                                -> impl Iterator<Item = (DefIndex, Lazy<Entry<'tcx>>)> + 'a {\n         let words = &bytes_to_words(&bytes[self.position..])[..self.len];\n-        words.iter().map(|word| word.get()).enumerate().filter_map(|(index, position)| {\n-            if position == u32::MAX {\n+        let lo_count = u32::from_le(words[0].get()) as usize;\n+        let lo = &words[1 .. lo_count + 1];\n+        let hi = &words[1 + lo_count ..];\n+\n+        lo.iter().map(|word| word.get()).enumerate().filter_map(|(index, pos)| {\n+            if pos == u32::MAX {\n+                None\n+            } else {\n+                let pos = u32::from_le(pos) as usize;\n+                Some((DefIndex::new(index), Lazy::with_position(pos)))\n+            }\n+        }).chain(hi.iter().map(|word| word.get()).enumerate().filter_map(|(index, pos)| {\n+            if pos == u32::MAX {\n                 None\n             } else {\n-                let position = u32::from_le(position) as usize;\n-                Some((DefIndex::new(index), Lazy::with_position(position)))\n+                let pos = u32::from_le(pos) as usize;\n+                Some((DefIndex::new(index + DefIndexAddressSpace::High.start()),\n+                                    Lazy::with_position(pos)))\n             }\n-        })\n+        }))\n     }\n }\n "}, {"sha": "a811f72bc956cbe1408c0ff27753d0583ce0f111", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -90,7 +90,7 @@ impl<'a, 'b, 'tcx> DerefMut for IndexBuilder<'a, 'b, 'tcx> {\n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     pub fn new(ecx: &'a mut EncodeContext<'b, 'tcx>) -> Self {\n         IndexBuilder {\n-            items: Index::new(ecx.tcx.hir.num_local_def_ids()),\n+            items: Index::new(ecx.tcx.hir.definitions().def_index_counts_lo_hi()),\n             ecx: ecx,\n         }\n     }"}, {"sha": "5b3113f962b2e07743a40bb4cb43062f7e4b2006", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -11,7 +11,10 @@\n //! This pass just dumps MIR at a specified point.\n \n use std::fmt;\n+use std::fs::File;\n+use std::io;\n \n+use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n use rustc::mir::transform::{Pass, MirPass, MirPassHook, MirSource};\n@@ -70,3 +73,14 @@ impl<'tcx> MirPassHook<'tcx> for DumpMir {\n }\n \n impl<'b> Pass for DumpMir {}\n+\n+pub fn emit_mir<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    outputs: &OutputFilenames)\n+    -> io::Result<()>\n+{\n+    let path = outputs.path(OutputType::Mir);\n+    let mut f = File::create(&path)?;\n+    mir_util::write_mir_pretty(tcx, tcx.maps.mir.borrow().keys().into_iter(), &mut f)?;\n+    Ok(())\n+}"}, {"sha": "0f869e7ed02ffef25565302aeec721879061ac8d", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -13,7 +13,7 @@\n //! care erasing regions all over the place.\n \n use rustc::ty::subst::Substs;\n-use rustc::ty::{Ty, TyCtxt};\n+use rustc::ty::{Ty, TyCtxt, ReErased, ClosureSubsts};\n use rustc::mir::*;\n use rustc::mir::visit::MutVisitor;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n@@ -39,6 +39,32 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n     fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>) {\n         *substs = self.tcx.erase_regions(&{*substs});\n     }\n+\n+    fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n+        match *rvalue {\n+            Rvalue::Ref(ref mut r, _, _) => {\n+                *r = self.tcx.mk_region(ReErased);\n+            }\n+            Rvalue::Use(..) |\n+            Rvalue::Repeat(..) |\n+            Rvalue::Len(..) |\n+            Rvalue::Cast(..) |\n+            Rvalue::BinaryOp(..) |\n+            Rvalue::CheckedBinaryOp(..) |\n+            Rvalue::UnaryOp(..) |\n+            Rvalue::Discriminant(..) |\n+            Rvalue::Box(..) |\n+            Rvalue::Aggregate(..) => {\n+                // These variants don't contain regions.\n+            }\n+        }\n+        self.super_rvalue(rvalue, location);\n+    }\n+\n+    fn visit_closure_substs(&mut self,\n+                            substs: &mut ClosureSubsts<'tcx>) {\n+        *substs = self.tcx.erase_regions(substs);\n+    }\n }\n \n pub struct EraseRegions;"}, {"sha": "ef2bf6e543420a59a962a5d59f15f428715adf5f", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -91,6 +91,9 @@ pub fn write_mir_pretty<'a, 'b, 'tcx, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                                          -> io::Result<()>\n     where I: Iterator<Item=DefId>, 'tcx: 'a\n {\n+    writeln!(w, \"// WARNING: This output format is intended for human consumers only\")?;\n+    writeln!(w, \"// and is subject to change without notice. Knock yourself out.\")?;\n+\n     let mut first = true;\n     for def_id in iter.filter(DefId::is_local) {\n         let mir = &tcx.item_mir(def_id);"}, {"sha": "377ff34cb7e0db7a745dfc4e802b95137a302586", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -741,6 +741,7 @@ pub fn run_passes(sess: &Session,\n                 modules_config.emit_obj = true;\n                 metadata_config.emit_obj = true;\n             },\n+            OutputType::Mir => {}\n             OutputType::DepInfo => {}\n         }\n     }\n@@ -880,6 +881,7 @@ pub fn run_passes(sess: &Session,\n                 user_wants_objects = true;\n                 copy_if_one_unit(OutputType::Object, true);\n             }\n+            OutputType::Mir |\n             OutputType::Metadata |\n             OutputType::Exe |\n             OutputType::DepInfo => {}"}, {"sha": "1ed42b842c6fafa3911ba8121a2a445259a3bdff", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -689,12 +689,6 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     let item = match tcx.hir.get(node_id) {\n         NodeItem(item) => item,\n-\n-        // Make adt definition available through constructor id as well.\n-        NodeStructCtor(_) => {\n-            return tcx.lookup_adt_def(tcx.hir.get_parent_did(node_id));\n-        }\n-\n         _ => bug!()\n     };\n "}, {"sha": "3dd4bdbd14ddb40e422d99686a6cb05ff67cc6cc", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -23,6 +23,7 @@ use abi::Abi;\n use ext::hygiene::SyntaxContext;\n use print::pprust;\n use ptr::P;\n+use rustc_data_structures::indexed_vec;\n use symbol::{Symbol, keywords};\n use tokenstream::{ThinTokenStream, TokenStream};\n \n@@ -275,6 +276,16 @@ impl serialize::UseSpecializedDecodable for NodeId {\n     }\n }\n \n+impl indexed_vec::Idx for NodeId {\n+    fn new(idx: usize) -> Self {\n+        NodeId::new(idx)\n+    }\n+\n+    fn index(self) -> usize {\n+        self.as_usize()\n+    }\n+}\n+\n /// Node id used to represent the root of the crate.\n pub const CRATE_NODE_ID: NodeId = NodeId(0);\n "}, {"sha": "f0e328a551d5f37003d53bf6f93a40617708ea83", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -178,17 +178,9 @@ impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n             block.stmts = block.stmts.move_flat_map(|mut stmt| {\n                 remaining_stmts -= 1;\n \n-                match stmt.node {\n-                    // Avoid wasting a node id on a trailing expression statement,\n-                    // which shares a HIR node with the expression itself.\n-                    ast::StmtKind::Expr(ref expr) if remaining_stmts == 0 => stmt.id = expr.id,\n-\n-                    _ if self.monotonic => {\n-                        assert_eq!(stmt.id, ast::DUMMY_NODE_ID);\n-                        stmt.id = self.cx.resolver.next_node_id();\n-                    }\n-\n-                    _ => {}\n+                if self.monotonic {\n+                    assert_eq!(stmt.id, ast::DUMMY_NODE_ID);\n+                    stmt.id = self.cx.resolver.next_node_id();\n                 }\n \n                 Some(stmt)"}, {"sha": "fd8d5ff9e7ea857b1f080d10c1fee5650010006f", "filename": "src/test/compile-fail/region-bounds-on-objects-and-type-parameters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -18,7 +18,7 @@ trait SomeTrait { }\n \n // Bounds on object types:\n \n-struct Foo<'a,'b,'c> { //~ ERROR parameter `'b` is never used\n+struct Foo<'a,'b,'c> { //~ ERROR parameter `'c` is never used\n     // All of these are ok, because we can derive exactly one bound:\n     a: Box<IsStatic>,\n     b: Box<Is<'static>>,"}, {"sha": "7d513a86a7fa580a15a60fd2d584b9e4103583eb", "filename": "src/test/run-make/issue-40535/Makefile", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Ftest%2Frun-make%2Fissue-40535%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Ftest%2Frun-make%2Fissue-40535%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-40535%2FMakefile?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -0,0 +1,11 @@\n+# The ICE occurred in the following situation:\n+# * `foo` declares `extern crate bar, baz`, depends only on `bar` (forgetting `baz` in `Cargo.toml`)\n+# * `bar` declares and depends on `extern crate baz`\n+# * All crates built in metadata-only mode (`cargo check`)\n+all:\n+\t# cc https://github.com/rust-lang/rust/issues/40623\n+\t$(RUSTC) baz.rs --emit=metadata --out-dir=$(TMPDIR)\n+\t$(RUSTC) bar.rs --emit=metadata --extern baz=$(TMPDIR)/libbaz.rmeta --out-dir=$(TMPDIR)\n+\t$(RUSTC) foo.rs --emit=metadata --extern bar=$(TMPDIR)/libbar.rmeta --out-dir=$(TMPDIR) 2>&1 | \\\n+\tgrep -vq \"unexpectedly panicked\"\n+\t# ^ Succeeds if it doesn't find the ICE message"}, {"sha": "4c22f181975b8e5c5412967f35c1d42ffb763547", "filename": "src/test/run-make/issue-40535/bar.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Ftest%2Frun-make%2Fissue-40535%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Ftest%2Frun-make%2Fissue-40535%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-40535%2Fbar.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::fingerprint::Fingerprint;\n+#![crate_type = \"lib\"]\n \n-mod fingerprint;\n+extern crate baz;", "previous_filename": "src/librustc_incremental/ich/mod.rs"}, {"sha": "737a918a0398d372e1b4dff8d76a1f7a327164cd", "filename": "src/test/run-make/issue-40535/baz.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Ftest%2Frun-make%2Fissue-40535%2Fbaz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Ftest%2Frun-make%2Fissue-40535%2Fbaz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-40535%2Fbaz.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]"}, {"sha": "53a8c8636b148fb11ee16fdc79b23d815698c956", "filename": "src/test/run-make/issue-40535/foo.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Ftest%2Frun-make%2Fissue-40535%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7753d370ee186219bf369cb0910a20198ea79e/src%2Ftest%2Frun-make%2Fissue-40535%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-40535%2Ffoo.rs?ref=7c7753d370ee186219bf369cb0910a20198ea79e", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+extern crate bar;\n+extern crate baz;"}]}