{"sha": "6f407d67b8ae387f763fa8e8dbc269b16a996ce3", "node_id": "C_kwDOAAsO6NoAKDZmNDA3ZDY3YjhhZTM4N2Y3NjNmYThlOGRiYzI2OWIxNmE5OTZjZTM", "commit": {"author": {"name": "Rune Tynan", "email": "runetynan@gmail.com", "date": "2023-02-14T03:30:53Z"}, "committer": {"name": "Rune Tynan", "email": "runetynan@gmail.com", "date": "2023-02-20T18:47:09Z"}, "message": "Allow non-`Box` allocations in preparation for aligned const allocations for miri. Credit to emarteca for the code.", "tree": {"sha": "c58f821df289bf41e4869465e51bb8765bca9e6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c58f821df289bf41e4869465e51bb8765bca9e6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f407d67b8ae387f763fa8e8dbc269b16a996ce3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEETdpCnQmiF6hBYUqdfsyTL4sscx4FAmPzwC4ACgkQfsyTL4ss\ncx7Xag//XxIbYBp1Tz1rwF0NBQXuXEBLfZy4fy91R7fOl81HzOEnkG9caswfo7FU\nApg9FGKit/oTLmD1jHs1CZqAwsNL/zwJnmAFNMyMxYSxbIrdrfCZJrlnzqivFtLK\ndUpKrUbe8X+vvAB9vpcrzWuXsSwdxSZ75ZloJKzli1lP3sZVtcvbjgrb4/atrbzl\n4dfvWmMXWMBDRNmmb1PAKD1mAbfXkKhdngMvOYNIX0HvBv3yZU+LA098NraMEoWA\njWiZfTB8fy0LK9iglR7a4UQ21GBGiOu79oOvNwXRkhq4c78VZ62xMjrMAitjM6Rk\nBZtP6/kGxnL1aZzLz1yUPQb6x5QmN5JgUo/JvWnfvy7DPcWQWcSIcAXaGT5e6nCT\n1JHZp9tJeKgw7O1wJ06JIu2ERgZ377kjRj1pZUY+/zd/Li7VVV55OvYJhSs7owPP\nlk2hYeF1oIfKZCOtsdNbb9S5paodficXPQwGF/4jK+dgsl3N/BqNIHDZ/dosC0He\nC62M3HDA0Zzf0L3wBgBTsSEvC9Wsqna92U39+yeOqV9L259r28IifwtpimTukYKe\n/IiJx7MQI9r/aTVH5bV3fPPxC9FlOGhZIeR6RiR3uTXujzuf1H63ULYQG2cqWpRJ\n3LM5SUVTwJBI5/74IVfLytigvQYee1PnBW0df2pjImMqyk5W05o=\n=x01W\n-----END PGP SIGNATURE-----", "payload": "tree c58f821df289bf41e4869465e51bb8765bca9e6f\nparent 267cd1d2c5abf5f0d825822a4179ba807b69ffb4\nauthor Rune Tynan <runetynan@gmail.com> 1676345453 -0500\ncommitter Rune Tynan <runetynan@gmail.com> 1676918829 -0500\n\nAllow non-`Box` allocations in preparation for aligned const allocations for miri. Credit to emarteca for the code.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f407d67b8ae387f763fa8e8dbc269b16a996ce3", "html_url": "https://github.com/rust-lang/rust/commit/6f407d67b8ae387f763fa8e8dbc269b16a996ce3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f407d67b8ae387f763fa8e8dbc269b16a996ce3/comments", "author": {"login": "CraftSpider", "id": 13342132, "node_id": "MDQ6VXNlcjEzMzQyMTMy", "avatar_url": "https://avatars.githubusercontent.com/u/13342132?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CraftSpider", "html_url": "https://github.com/CraftSpider", "followers_url": "https://api.github.com/users/CraftSpider/followers", "following_url": "https://api.github.com/users/CraftSpider/following{/other_user}", "gists_url": "https://api.github.com/users/CraftSpider/gists{/gist_id}", "starred_url": "https://api.github.com/users/CraftSpider/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CraftSpider/subscriptions", "organizations_url": "https://api.github.com/users/CraftSpider/orgs", "repos_url": "https://api.github.com/users/CraftSpider/repos", "events_url": "https://api.github.com/users/CraftSpider/events{/privacy}", "received_events_url": "https://api.github.com/users/CraftSpider/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CraftSpider", "id": 13342132, "node_id": "MDQ6VXNlcjEzMzQyMTMy", "avatar_url": "https://avatars.githubusercontent.com/u/13342132?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CraftSpider", "html_url": "https://github.com/CraftSpider", "followers_url": "https://api.github.com/users/CraftSpider/followers", "following_url": "https://api.github.com/users/CraftSpider/following{/other_user}", "gists_url": "https://api.github.com/users/CraftSpider/gists{/gist_id}", "starred_url": "https://api.github.com/users/CraftSpider/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CraftSpider/subscriptions", "organizations_url": "https://api.github.com/users/CraftSpider/orgs", "repos_url": "https://api.github.com/users/CraftSpider/repos", "events_url": "https://api.github.com/users/CraftSpider/events{/privacy}", "received_events_url": "https://api.github.com/users/CraftSpider/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "267cd1d2c5abf5f0d825822a4179ba807b69ffb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/267cd1d2c5abf5f0d825822a4179ba807b69ffb4", "html_url": "https://github.com/rust-lang/rust/commit/267cd1d2c5abf5f0d825822a4179ba807b69ffb4"}], "stats": {"total": 168, "additions": 120, "deletions": 48}, "files": [{"sha": "3a4df2da1ed51f323233e6c74168f2c207e1f000", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f407d67b8ae387f763fa8e8dbc269b16a996ce3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f407d67b8ae387f763fa8e8dbc269b16a996ce3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=6f407d67b8ae387f763fa8e8dbc269b16a996ce3", "patch": "@@ -16,7 +16,7 @@ use rustc_target::spec::abi::Abi as CallAbi;\n use crate::const_eval::CheckAlignment;\n \n use super::{\n-    AllocId, AllocRange, Allocation, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n+    AllocId, AllocRange, Allocation, AllocBytes, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n     MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar, StackPopUnwind,\n };\n \n@@ -105,10 +105,13 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Extra data stored in every allocation.\n     type AllocExtra: Debug + Clone + 'static;\n \n+    /// Type for the bytes of the allocation.\n+    type Bytes: AllocBytes + 'static;\n+\n     /// Memory's allocation map\n     type MemoryMap: AllocMap<\n             AllocId,\n-            (MemoryKind<Self::MemoryKind>, Allocation<Self::Provenance, Self::AllocExtra>),\n+            (MemoryKind<Self::MemoryKind>, Allocation<Self::Provenance, Self::AllocExtra, Self::Bytes>),\n         > + Default\n         + Clone;\n \n@@ -338,7 +341,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKind>>,\n-    ) -> InterpResult<'tcx, Cow<'b, Allocation<Self::Provenance, Self::AllocExtra>>>;\n+    ) -> InterpResult<'tcx, Cow<'b, Allocation<Self::Provenance, Self::AllocExtra, Self::Bytes>>>;\n \n     fn eval_inline_asm(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n@@ -459,6 +462,7 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n \n     type AllocExtra = ();\n     type FrameExtra = ();\n+    type Bytes = Box<[u8]>;\n \n     #[inline(always)]\n     fn use_addr_for_alignment_check(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {"}, {"sha": "a817211e745b7aad5fcb3039efeb45866f6ef349", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6f407d67b8ae387f763fa8e8dbc269b16a996ce3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f407d67b8ae387f763fa8e8dbc269b16a996ce3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=6f407d67b8ae387f763fa8e8dbc269b16a996ce3", "patch": "@@ -21,8 +21,9 @@ use rustc_target::abi::{Align, HasDataLayout, Size};\n use crate::const_eval::CheckAlignment;\n \n use super::{\n-    alloc_range, AllocId, AllocMap, AllocRange, Allocation, CheckInAllocMsg, GlobalAlloc, InterpCx,\n-    InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Provenance, Scalar,\n+    alloc_range, AllocBytes, AllocId, AllocMap, AllocRange, Allocation, CheckInAllocMsg,\n+    GlobalAlloc, InterpCx, InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Provenance,\n+    Scalar,\n };\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n@@ -114,16 +115,16 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n /// A reference to some allocation that was already bounds-checked for the given region\n /// and had the on-access machine hooks run.\n #[derive(Copy, Clone)]\n-pub struct AllocRef<'a, 'tcx, Prov: Provenance, Extra> {\n-    alloc: &'a Allocation<Prov, Extra>,\n+pub struct AllocRef<'a, 'tcx, Prov: Provenance, Extra, Bytes: AllocBytes = Box<[u8]>> {\n+    alloc: &'a Allocation<Prov, Extra, Bytes>,\n     range: AllocRange,\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n }\n /// A reference to some allocation that was already bounds-checked for the given region\n /// and had the on-access machine hooks run.\n-pub struct AllocRefMut<'a, 'tcx, Prov: Provenance, Extra> {\n-    alloc: &'a mut Allocation<Prov, Extra>,\n+pub struct AllocRefMut<'a, 'tcx, Prov: Provenance, Extra, Bytes: AllocBytes = Box<[u8]>> {\n+    alloc: &'a mut Allocation<Prov, Extra, Bytes>,\n     range: AllocRange,\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n@@ -483,7 +484,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         id: AllocId,\n         is_write: bool,\n-    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::Provenance, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::Provenance, M::AllocExtra, M::Bytes>>> {\n         let (alloc, def_id) = match self.tcx.try_get_global_alloc(id) {\n             Some(GlobalAlloc::Memory(mem)) => {\n                 // Memory of a constant or promoted or anonymous memory referenced by a static.\n@@ -526,14 +527,25 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         )\n     }\n \n+    /// Get the base address for the bytes in an `Allocation` specified by the\n+    /// `AllocID` passed in; error if no such allocation exists.\n+    ///\n+    /// It is up to the caller to take sufficient care when using this address:\n+    /// there could be provenance or uninit memory in there, and other memory\n+    /// accesses could invalidate the exposed pointer.\n+    pub fn alloc_base_addr(&self, id: AllocId) -> InterpResult<'tcx, *const ()> {\n+        let alloc = self.get_alloc_raw(id)?;\n+        Ok(alloc.base_addr())\n+    }\n+\n     /// Gives raw access to the `Allocation`, without bounds or alignment checks.\n     /// The caller is responsible for calling the access hooks!\n     ///\n     /// You almost certainly want to use `get_ptr_alloc`/`get_ptr_alloc_mut` instead.\n     fn get_alloc_raw(\n         &self,\n         id: AllocId,\n-    ) -> InterpResult<'tcx, &Allocation<M::Provenance, M::AllocExtra>> {\n+    ) -> InterpResult<'tcx, &Allocation<M::Provenance, M::AllocExtra, M::Bytes>> {\n         // The error type of the inner closure here is somewhat funny. We have two\n         // ways of \"erroring\": An actual error, or because we got a reference from\n         // `get_global_alloc` that we can actually use directly without inserting anything anywhere.\n@@ -569,7 +581,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ptr: Pointer<Option<M::Provenance>>,\n         size: Size,\n         align: Align,\n-    ) -> InterpResult<'tcx, Option<AllocRef<'a, 'tcx, M::Provenance, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Option<AllocRef<'a, 'tcx, M::Provenance, M::AllocExtra, M::Bytes>>> {\n         let ptr_and_alloc = self.check_and_deref_ptr(\n             ptr,\n             size,\n@@ -612,7 +624,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn get_alloc_raw_mut(\n         &mut self,\n         id: AllocId,\n-    ) -> InterpResult<'tcx, (&mut Allocation<M::Provenance, M::AllocExtra>, &mut M)> {\n+    ) -> InterpResult<'tcx, (&mut Allocation<M::Provenance, M::AllocExtra, M::Bytes>, &mut M)> {\n         // We have \"NLL problem case #3\" here, which cannot be worked around without loss of\n         // efficiency even for the common case where the key is in the map.\n         // <https://rust-lang.github.io/rfcs/2094-nll.html#problem-case-3-conditional-control-flow-across-functions>\n@@ -641,7 +653,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ptr: Pointer<Option<M::Provenance>>,\n         size: Size,\n         align: Align,\n-    ) -> InterpResult<'tcx, Option<AllocRefMut<'a, 'tcx, M::Provenance, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Option<AllocRefMut<'a, 'tcx, M::Provenance, M::AllocExtra, M::Bytes>>> {\n         let parts = self.get_ptr_access(ptr, size, align)?;\n         if let Some((alloc_id, offset, prov)) = parts {\n             let tcx = *self.tcx;\n@@ -840,11 +852,11 @@ pub struct DumpAllocs<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a, 'mir, 'tcx, M> {\n     fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         // Cannot be a closure because it is generic in `Prov`, `Extra`.\n-        fn write_allocation_track_relocs<'tcx, Prov: Provenance, Extra>(\n+        fn write_allocation_track_relocs<'tcx, Prov: Provenance, Extra, Bytes: AllocBytes>(\n             fmt: &mut std::fmt::Formatter<'_>,\n             tcx: TyCtxt<'tcx>,\n             allocs_to_print: &mut VecDeque<AllocId>,\n-            alloc: &Allocation<Prov, Extra>,\n+            alloc: &Allocation<Prov, Extra, Bytes>,\n         ) -> std::fmt::Result {\n             for alloc_id in alloc.provenance().provenances().filter_map(|prov| prov.get_alloc_id())\n             {\n@@ -912,7 +924,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n }\n \n /// Reading and writing.\n-impl<'tcx, 'a, Prov: Provenance, Extra> AllocRefMut<'a, 'tcx, Prov, Extra> {\n+impl<'tcx, 'a, Prov: Provenance, Extra, Bytes: AllocBytes> AllocRefMut<'a, 'tcx, Prov, Extra, Bytes> {\n     /// `range` is relative to this allocation reference, not the base of the allocation.\n     pub fn write_scalar(&mut self, range: AllocRange, val: Scalar<Prov>) -> InterpResult<'tcx> {\n         let range = self.range.subrange(range);\n@@ -937,7 +949,7 @@ impl<'tcx, 'a, Prov: Provenance, Extra> AllocRefMut<'a, 'tcx, Prov, Extra> {\n     }\n }\n \n-impl<'tcx, 'a, Prov: Provenance, Extra> AllocRef<'a, 'tcx, Prov, Extra> {\n+impl<'tcx, 'a, Prov: Provenance, Extra, Bytes: AllocBytes> AllocRef<'a, 'tcx, Prov, Extra, Bytes> {\n     /// `range` is relative to this allocation reference, not the base of the allocation.\n     pub fn read_scalar(\n         &self,"}, {"sha": "ad2d543854941dd3e857c66b5cf5bc93751507ff", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f407d67b8ae387f763fa8e8dbc269b16a996ce3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f407d67b8ae387f763fa8e8dbc269b16a996ce3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=6f407d67b8ae387f763fa8e8dbc269b16a996ce3", "patch": "@@ -340,7 +340,7 @@ where\n     pub(super) fn get_place_alloc(\n         &self,\n         place: &MPlaceTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, Option<AllocRef<'_, 'tcx, M::Provenance, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Option<AllocRef<'_, 'tcx, M::Provenance, M::AllocExtra, M::Bytes>>> {\n         assert!(place.layout.is_sized());\n         assert!(!place.meta.has_meta());\n         let size = place.layout.size;\n@@ -351,7 +351,7 @@ where\n     pub(super) fn get_place_alloc_mut(\n         &mut self,\n         place: &MPlaceTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, Option<AllocRefMut<'_, 'tcx, M::Provenance, M::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Option<AllocRefMut<'_, 'tcx, M::Provenance, M::AllocExtra, M::Bytes>>> {\n         assert!(place.layout.is_sized());\n         assert!(!place.meta.has_meta());\n         let size = place.layout.size;"}, {"sha": "2ddfdbbc25acf601f93147892a31d13427ff3a9d", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 72, "deletions": 16, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/6f407d67b8ae387f763fa8e8dbc269b16a996ce3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f407d67b8ae387f763fa8e8dbc269b16a996ce3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=6f407d67b8ae387f763fa8e8dbc269b16a996ce3", "patch": "@@ -8,7 +8,8 @@ mod tests;\n use std::borrow::Cow;\n use std::fmt;\n use std::hash;\n-use std::ops::Range;\n+use std::hash::Hash;\n+use std::ops::{Deref, DerefMut, Range};\n use std::ptr;\n \n use either::{Left, Right};\n@@ -29,6 +30,54 @@ use provenance_map::*;\n \n pub use init_mask::{InitChunk, InitChunkIter};\n \n+/// Functionality required for the bytes of an `Allocation`.\n+pub trait AllocBytes:\n+    Clone\n+    + fmt::Debug\n+    + Eq\n+    + PartialEq\n+    + Hash\n+    + Deref<Target = [u8]>\n+    + DerefMut<Target = [u8]>\n+{\n+    /// Adjust the bytes to the specified alignment -- by default, this is a no-op.\n+    fn adjust_to_align(self, _align: Align) -> Self;\n+\n+    /// Create an `AllocBytes` from a slice of `u8`.\n+    fn from_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, _align: Align) -> Self;\n+\n+    /// Create a zeroed `AllocBytes` of the specified size and alignment;\n+    /// call the callback error handler if there is an error in allocating the memory.\n+    fn zeroed<'tcx, F: Fn() -> InterpError<'tcx>>(\n+        size: Size,\n+        _align: Align,\n+        handle_alloc_fail: F,\n+    ) -> Result<Self, InterpError<'tcx>>;\n+}\n+\n+// Default `bytes` for `Allocation` is a `Box<[u8]>`.\n+impl AllocBytes for Box<[u8]> {\n+    fn adjust_to_align(self, _align: Align) -> Self {\n+        self\n+    }\n+\n+    fn from_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, _align: Align) -> Self {\n+        Box::<[u8]>::from(slice.into())\n+    }\n+\n+    fn zeroed<'tcx, F: Fn() -> InterpError<'tcx>>(\n+        size: Size,\n+        _align: Align,\n+        handle_alloc_fail: F,\n+    ) -> Result<Self, InterpError<'tcx>> {\n+        let bytes = Box::<[u8]>::try_new_zeroed_slice(size.bytes_usize())\n+            .map_err(|_| handle_alloc_fail())?;\n+        // SAFETY: the box was zero-allocated, which is a valid initial value for Box<[u8]>\n+        let bytes = unsafe { bytes.assume_init() };\n+        Ok(bytes)\n+    }\n+}\n+\n /// This type represents an Allocation in the Miri/CTFE core engine.\n ///\n /// Its public API is rather low-level, working directly with allocation offsets and a custom error\n@@ -38,10 +87,10 @@ pub use init_mask::{InitChunk, InitChunkIter};\n // hashed. (see the `Hash` impl below for more details), so the impl is not derived.\n #[derive(Clone, Eq, PartialEq, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n-pub struct Allocation<Prov: Provenance = AllocId, Extra = ()> {\n+pub struct Allocation<Prov: Provenance = AllocId, Extra = (), Bytes = Box<[u8]>> {\n     /// The actual bytes of the allocation.\n     /// Note that the bytes of a pointer represent the offset of the pointer.\n-    bytes: Box<[u8]>,\n+    bytes: Bytes,\n     /// Maps from byte addresses to extra provenance data for each pointer.\n     /// Only the first byte of a pointer is inserted into the map; i.e.,\n     /// every entry in this map applies to `pointer_size` consecutive bytes starting\n@@ -220,14 +269,14 @@ impl AllocRange {\n }\n \n // The constructors are all without extra; the extra gets added by a machine hook later.\n-impl<Prov: Provenance> Allocation<Prov> {\n+impl<Prov: Provenance, Bytes: AllocBytes> Allocation<Prov, (), Bytes> {\n     /// Creates an allocation initialized by the given bytes\n     pub fn from_bytes<'a>(\n         slice: impl Into<Cow<'a, [u8]>>,\n         align: Align,\n         mutability: Mutability,\n     ) -> Self {\n-        let bytes = Box::<[u8]>::from(slice.into());\n+        let bytes = Bytes::from_bytes(slice, align);\n         let size = Size::from_bytes(bytes.len());\n         Self {\n             bytes,\n@@ -248,7 +297,7 @@ impl<Prov: Provenance> Allocation<Prov> {\n     ///\n     /// If `panic_on_fail` is true, this will never return `Err`.\n     pub fn uninit<'tcx>(size: Size, align: Align, panic_on_fail: bool) -> InterpResult<'tcx, Self> {\n-        let bytes = Box::<[u8]>::try_new_zeroed_slice(size.bytes_usize()).map_err(|_| {\n+        let handle_alloc_fail = || -> InterpError<'tcx> {\n             // This results in an error that can happen non-deterministically, since the memory\n             // available to the compiler can change between runs. Normally queries are always\n             // deterministic. However, we can be non-deterministic here because all uses of const\n@@ -261,9 +310,10 @@ impl<Prov: Provenance> Allocation<Prov> {\n                 tcx.sess.delay_span_bug(DUMMY_SP, \"exhausted memory during interpretation\")\n             });\n             InterpError::ResourceExhaustion(ResourceExhaustionInfo::MemoryExhausted)\n-        })?;\n-        // SAFETY: the box was zero-allocated, which is a valid initial value for Box<[u8]>\n-        let bytes = unsafe { bytes.assume_init() };\n+        };\n+\n+        let bytes = Bytes::zeroed(size, align, handle_alloc_fail)?;\n+\n         Ok(Allocation {\n             bytes,\n             provenance: ProvenanceMap::new(),\n@@ -275,17 +325,19 @@ impl<Prov: Provenance> Allocation<Prov> {\n     }\n }\n \n-impl Allocation {\n+impl<Bytes: AllocBytes> Allocation<AllocId, (), Bytes> {\n     /// Adjust allocation from the ones in tcx to a custom Machine instance\n     /// with a different Provenance and Extra type.\n     pub fn adjust_from_tcx<Prov: Provenance, Extra, Err>(\n         self,\n         cx: &impl HasDataLayout,\n         extra: Extra,\n         mut adjust_ptr: impl FnMut(Pointer<AllocId>) -> Result<Pointer<Prov>, Err>,\n-    ) -> Result<Allocation<Prov, Extra>, Err> {\n-        // Compute new pointer provenance, which also adjusts the bytes.\n-        let mut bytes = self.bytes;\n+    ) -> Result<Allocation<Prov, Extra, Bytes>, Err> {\n+        // Compute new pointer provenance, which also adjusts the bytes, and realign the pointer if\n+        // necessary.\n+        let mut bytes = self.bytes.adjust_to_align(self.align);\n+\n         let mut new_provenance = Vec::with_capacity(self.provenance.ptrs().len());\n         let ptr_size = cx.data_layout().pointer_size.bytes_usize();\n         let endian = cx.data_layout().endian;\n@@ -311,7 +363,7 @@ impl Allocation {\n }\n \n /// Raw accessors. Provide access to otherwise private bytes.\n-impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n+impl<Prov: Provenance, Extra, Bytes: AllocBytes> Allocation<Prov, Extra, Bytes> {\n     pub fn len(&self) -> usize {\n         self.bytes.len()\n     }\n@@ -340,7 +392,11 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n }\n \n /// Byte accessors.\n-impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n+impl<Prov: Provenance, Extra, Bytes: AllocBytes> Allocation<Prov, Extra, Bytes> {\n+    pub fn base_addr(&self) -> *const u8 {\n+        self.bytes.as_ptr()\n+    }\n+\n     /// This is the entirely abstraction-violating way to just grab the raw bytes without\n     /// caring about provenance or initialization.\n     ///\n@@ -412,7 +468,7 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n }\n \n /// Reading and writing.\n-impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n+impl<Prov: Provenance, Extra, Bytes: AllocBytes> Allocation<Prov, Extra, Bytes> {\n     /// Sets the init bit for the given range.\n     fn mark_init(&mut self, range: AllocRange, is_init: bool) {\n         if range.size.bytes() == 0 {"}, {"sha": "4329bbf803076cb25d8538dd60633e1705ed4ad0", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f407d67b8ae387f763fa8e8dbc269b16a996ce3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f407d67b8ae387f763fa8e8dbc269b16a996ce3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=6f407d67b8ae387f763fa8e8dbc269b16a996ce3", "patch": "@@ -127,7 +127,7 @@ pub use self::error::{\n pub use self::value::{get_slice_bytes, ConstAlloc, ConstValue, Scalar};\n \n pub use self::allocation::{\n-    alloc_range, AllocError, AllocRange, AllocResult, Allocation, ConstAllocation, InitChunk,\n+    alloc_range, AllocBytes, AllocError, AllocRange, AllocResult, Allocation, ConstAllocation, InitChunk,\n     InitChunkIter,\n };\n "}, {"sha": "d8829e3e782c5c40b931714cfa30d717cc9f9f55", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6f407d67b8ae387f763fa8e8dbc269b16a996ce3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f407d67b8ae387f763fa8e8dbc269b16a996ce3/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=6f407d67b8ae387f763fa8e8dbc269b16a996ce3", "patch": "@@ -12,8 +12,8 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{\n-    alloc_range, read_target_uint, AllocId, Allocation, ConstAllocation, ConstValue, GlobalAlloc,\n-    Pointer, Provenance,\n+    alloc_range, read_target_uint, AllocBytes, AllocId, Allocation, ConstAllocation, ConstValue,\n+    GlobalAlloc, Pointer, Provenance,\n };\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n@@ -787,21 +787,21 @@ pub fn write_allocations<'tcx>(\n /// After the hex dump, an ascii dump follows, replacing all unprintable characters (control\n /// characters or characters whose value is larger than 127) with a `.`\n /// This also prints provenance adequately.\n-pub fn display_allocation<'a, 'tcx, Prov: Provenance, Extra>(\n+pub fn display_allocation<'a, 'tcx, Prov: Provenance, Extra, Bytes: AllocBytes>(\n     tcx: TyCtxt<'tcx>,\n-    alloc: &'a Allocation<Prov, Extra>,\n-) -> RenderAllocation<'a, 'tcx, Prov, Extra> {\n+    alloc: &'a Allocation<Prov, Extra, Bytes>,\n+) -> RenderAllocation<'a, 'tcx, Prov, Extra, Bytes> {\n     RenderAllocation { tcx, alloc }\n }\n \n #[doc(hidden)]\n-pub struct RenderAllocation<'a, 'tcx, Prov: Provenance, Extra> {\n+pub struct RenderAllocation<'a, 'tcx, Prov: Provenance, Extra, Bytes: AllocBytes> {\n     tcx: TyCtxt<'tcx>,\n-    alloc: &'a Allocation<Prov, Extra>,\n+    alloc: &'a Allocation<Prov, Extra, Bytes>,\n }\n \n-impl<'a, 'tcx, Prov: Provenance, Extra> std::fmt::Display\n-    for RenderAllocation<'a, 'tcx, Prov, Extra>\n+impl<'a, 'tcx, Prov: Provenance, Extra, Bytes: AllocBytes> std::fmt::Display\n+    for RenderAllocation<'a, 'tcx, Prov, Extra, Bytes>\n {\n     fn fmt(&self, w: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         let RenderAllocation { tcx, alloc } = *self;\n@@ -845,9 +845,9 @@ fn write_allocation_newline(\n /// The `prefix` argument allows callers to add an arbitrary prefix before each line (even if there\n /// is only one line). Note that your prefix should contain a trailing space as the lines are\n /// printed directly after it.\n-fn write_allocation_bytes<'tcx, Prov: Provenance, Extra>(\n+fn write_allocation_bytes<'tcx, Prov: Provenance, Extra, Bytes: AllocBytes>(\n     tcx: TyCtxt<'tcx>,\n-    alloc: &Allocation<Prov, Extra>,\n+    alloc: &Allocation<Prov, Extra, Bytes>,\n     w: &mut dyn std::fmt::Write,\n     prefix: &str,\n ) -> std::fmt::Result {"}]}