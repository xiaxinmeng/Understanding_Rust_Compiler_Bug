{"sha": "1333206eb32a78ef6ffe0defd4acd164e47146b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzMzMyMDZlYjMyYTc4ZWY2ZmZlMGRlZmQ0YWNkMTY0ZTQ3MTQ2Yjc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-10-24T14:13:39Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-10-24T14:15:42Z"}, "message": "ensure that statics are inhabited", "tree": {"sha": "1432bb73ab8de8e8f543c7f5ebb3b2de767f68bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1432bb73ab8de8e8f543c7f5ebb3b2de767f68bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1333206eb32a78ef6ffe0defd4acd164e47146b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1333206eb32a78ef6ffe0defd4acd164e47146b7", "html_url": "https://github.com/rust-lang/rust/commit/1333206eb32a78ef6ffe0defd4acd164e47146b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1333206eb32a78ef6ffe0defd4acd164e47146b7/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e8a54af60df63034e41359acfc923e5c5769a91", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e8a54af60df63034e41359acfc923e5c5769a91", "html_url": "https://github.com/rust-lang/rust/commit/2e8a54af60df63034e41359acfc923e5c5769a91"}], "stats": {"total": 120, "additions": 114, "deletions": 6}, "files": [{"sha": "d12eb0edd4d39371eda35bd7639e0ef9a5b186c2", "filename": "compiler/rustc_session/src/lint/builtin.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1333206eb32a78ef6ffe0defd4acd164e47146b7/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1333206eb32a78ef6ffe0defd4acd164e47146b7/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs?ref=1333206eb32a78ef6ffe0defd4acd164e47146b7", "patch": "@@ -2647,6 +2647,35 @@ declare_lint! {\n     };\n }\n \n+declare_lint! {\n+    /// The `uninhabited_static` lint detects uninhbaited statics.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// enum Void {}\n+    /// extern {\n+    ///     static EXTERN: Void;\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Statics with an uninhabited type can never be initialized, so they are impossible to define.\n+    /// However, this can be side-stepped with an `extern static`, leading to problems later in the\n+    /// compiler which assumes that there are no initialized uninhabited places (such as locals or\n+    /// statics). This was accientally allowed, but is being phased out.\n+    pub UNINHABITED_STATIC,\n+    Warn,\n+    \"uninhabited static\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #74840 <https://github.com/rust-lang/rust/issues/74840>\",\n+        edition: None,\n+    };\n+}\n+\n declare_tool_lint! {\n     pub rustc::INEFFECTIVE_UNSTABLE_TRAIT_IMPL,\n     Deny,\n@@ -2732,6 +2761,7 @@ declare_lint_pass! {\n         CENUM_IMPL_DROP_CAST,\n         CONST_EVALUATABLE_UNCHECKED,\n         INEFFECTIVE_UNSTABLE_TRAIT_IMPL,\n+        UNINHABITED_STATIC,\n     ]\n }\n "}, {"sha": "fb6746c85d3e4ea3f4fed849cdd7c67fbeaf7b45", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 45, "deletions": 6, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1333206eb32a78ef6ffe0defd4acd164e47146b7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1333206eb32a78ef6ffe0defd4acd164e47146b7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=1333206eb32a78ef6ffe0defd4acd164e47146b7", "patch": "@@ -14,8 +14,9 @@ use rustc_infer::infer::{RegionVariableOrigin, TyCtxtInferExt};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::util::{Discr, IntTypeExt, Representability};\n-use rustc_middle::ty::{self, RegionKind, ToPredicate, Ty, TyCtxt};\n+use rustc_middle::ty::{self, ParamEnv, RegionKind, ToPredicate, Ty, TyCtxt};\n use rustc_session::config::EntryFnType;\n+use rustc_session::lint::builtin::UNINHABITED_STATIC;\n use rustc_span::symbol::sym;\n use rustc_span::{self, MultiSpan, Span};\n use rustc_target::spec::abi::Abi;\n@@ -338,7 +339,7 @@ pub(super) fn check_struct(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n     check_packed(tcx, span, def);\n }\n \n-pub(super) fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n+fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n     let def_id = tcx.hir().local_def_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n@@ -349,7 +350,7 @@ pub(super) fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n }\n \n /// Check that the fields of the `union` do not need dropping.\n-pub(super) fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: LocalDefId) -> bool {\n+fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: LocalDefId) -> bool {\n     let item_type = tcx.type_of(item_def_id);\n     if let ty::Adt(def, substs) = item_type.kind() {\n         assert!(def.is_union());\n@@ -377,6 +378,36 @@ pub(super) fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: Local\n     true\n }\n \n+/// Check that a `static` is inhabited.\n+fn check_static_inhabited<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n+    // Make sure statics are inhabited.\n+    // Other parts of the compiler assume that there are no uninhabited places. In principle it\n+    // would be enugh to check this for `extern` statics, as statics with an initializer will\n+    // have UB during initialization if they are uninhabited, but there also seems to be no good\n+    // reason to allow any statics to be uninhabited.\n+    let ty = tcx.type_of(def_id);\n+    let layout = match tcx.layout_of(ParamEnv::reveal_all().and(ty)) {\n+        Ok(l) => l,\n+        Err(_) => {\n+            // Generic statics are rejected, but we still reach this case.\n+            tcx.sess.delay_span_bug(span, \"generic static must be rejected\");\n+            return;\n+        }\n+    };\n+    if layout.abi.is_uninhabited() {\n+        tcx.struct_span_lint_hir(\n+            UNINHABITED_STATIC,\n+            tcx.hir().local_def_id_to_hir_id(def_id),\n+            span,\n+            |lint| {\n+                lint.build(\"static of uninhabited type\")\n+                .note(\"uninhabited statics cannot be initialized, and any access would be an immediate error\")\n+                .emit();\n+            },\n+        );\n+    }\n+}\n+\n /// Checks that an opaque type does not contain cycles and does not use `Self` or `T::Foo`\n /// projections that would result in \"inheriting lifetimes\".\n pub(super) fn check_opaque<'tcx>(\n@@ -609,6 +640,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n             let def_id = tcx.hir().local_def_id(it.hir_id);\n             tcx.ensure().typeck(def_id);\n             maybe_check_static_with_link_section(tcx, def_id, it.span);\n+            check_static_inhabited(tcx, def_id, it.span);\n         }\n         hir::ItemKind::Const(..) => {\n             tcx.ensure().typeck(tcx.hir().local_def_id(it.hir_id));\n@@ -691,7 +723,8 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n                 }\n             } else {\n                 for item in m.items {\n-                    let generics = tcx.generics_of(tcx.hir().local_def_id(item.hir_id));\n+                    let def_id = tcx.hir().local_def_id(item.hir_id);\n+                    let generics = tcx.generics_of(def_id);\n                     let own_counts = generics.own_counts();\n                     if generics.params.len() - own_counts.lifetimes != 0 {\n                         let (kinds, kinds_pl, egs) = match (own_counts.types, own_counts.consts) {\n@@ -722,8 +755,14 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n                         .emit();\n                     }\n \n-                    if let hir::ForeignItemKind::Fn(ref fn_decl, _, _) = item.kind {\n-                        require_c_abi_if_c_variadic(tcx, fn_decl, m.abi, item.span);\n+                    match item.kind {\n+                        hir::ForeignItemKind::Fn(ref fn_decl, _, _) => {\n+                            require_c_abi_if_c_variadic(tcx, fn_decl, m.abi, item.span);\n+                        }\n+                        hir::ForeignItemKind::Static(..) => {\n+                            check_static_inhabited(tcx, def_id, item.span);\n+                        }\n+                        _ => {}\n                     }\n                 }\n             }"}, {"sha": "61189b0e0cd2a7a4b598fabe927b0b32b85966e6", "filename": "src/test/ui/statics/uninhabited-static.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1333206eb32a78ef6ffe0defd4acd164e47146b7/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1333206eb32a78ef6ffe0defd4acd164e47146b7/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.rs?ref=1333206eb32a78ef6ffe0defd4acd164e47146b7", "patch": "@@ -0,0 +1,12 @@\n+#![feature(never_type)]\n+#![deny(uninhabited_static)]\n+\n+enum Void {}\n+extern {\n+    static VOID: Void; //~ ERROR static of uninhabited type\n+    //~| WARN: previously accepted\n+    static NEVER: !; //~ ERROR static of uninhabited type\n+    //~| WARN: previously accepted\n+}\n+\n+fn main() {}"}, {"sha": "475578b3e7c7630df6acbb81e26284857040b9c5", "filename": "src/test/ui/statics/uninhabited-static.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1333206eb32a78ef6ffe0defd4acd164e47146b7/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1333206eb32a78ef6ffe0defd4acd164e47146b7/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.stderr?ref=1333206eb32a78ef6ffe0defd4acd164e47146b7", "patch": "@@ -0,0 +1,27 @@\n+error: static of uninhabited type\n+  --> $DIR/uninhabited-static.rs:6:5\n+   |\n+LL |     static VOID: Void;\n+   |     ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/uninhabited-static.rs:2:9\n+   |\n+LL | #![deny(uninhabited_static)]\n+   |         ^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #74840 <https://github.com/rust-lang/rust/issues/74840>\n+   = note: uninhabited statics cannot be initialized, and any access would be an immediate error\n+\n+error: static of uninhabited type\n+  --> $DIR/uninhabited-static.rs:8:5\n+   |\n+LL |     static NEVER: !;\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #74840 <https://github.com/rust-lang/rust/issues/74840>\n+   = note: uninhabited statics cannot be initialized, and any access would be an immediate error\n+\n+error: aborting due to 2 previous errors\n+"}]}