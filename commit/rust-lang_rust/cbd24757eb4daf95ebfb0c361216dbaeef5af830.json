{"sha": "cbd24757eb4daf95ebfb0c361216dbaeef5af830", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiZDI0NzU3ZWI0ZGFmOTVlYmZiMGMzNjEyMTZkYmFlZWY1YWY4MzA=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-27T06:36:56Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-29T07:52:58Z"}, "message": "Move `CrateConfig` from `Crate` to `ParseSess`.", "tree": {"sha": "79a2c34d91e49143e5c6c76cb8e9c1547fe22824", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79a2c34d91e49143e5c6c76cb8e9c1547fe22824"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbd24757eb4daf95ebfb0c361216dbaeef5af830", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbd24757eb4daf95ebfb0c361216dbaeef5af830", "html_url": "https://github.com/rust-lang/rust/commit/cbd24757eb4daf95ebfb0c361216dbaeef5af830", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbd24757eb4daf95ebfb0c361216dbaeef5af830/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17e9d9ae82149202908b5674966df86c0a1a5799", "url": "https://api.github.com/repos/rust-lang/rust/commits/17e9d9ae82149202908b5674966df86c0a1a5799", "html_url": "https://github.com/rust-lang/rust/commit/17e9d9ae82149202908b5674966df86c0a1a5799"}], "stats": {"total": 428, "additions": 130, "deletions": 298}, "files": [{"sha": "1d2c64d6d938aa815b6afc0fa6e03fd6e7ca4dd4", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -136,10 +136,8 @@ impl FromStr for TokenStream {\n     fn from_str(src: &str) -> Result<TokenStream, LexError> {\n         __internal::with_parse_sess(|sess| {\n             let src = src.to_string();\n-            let cfg = Vec::new();\n             let name = \"<proc-macro source code>\".to_string();\n-            let mut parser = parse::new_parser_from_source_str(sess, cfg, name,\n-                                                               src);\n+            let mut parser = parse::new_parser_from_source_str(sess, name, src);\n             let mut ret = TokenStream { inner: Vec::new() };\n             loop {\n                 match parser.parse_item() {"}, {"sha": "a489567fbb2a8986ce0b179bfd183496ed536846", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -124,7 +124,6 @@ impl<'a> LoweringContext<'a> {\n         hir::Crate {\n             module: self.lower_mod(&c.module),\n             attrs: self.lower_attrs(&c.attrs),\n-            config: c.config.clone().into(),\n             span: c.span,\n             exported_macros: c.exported_macros.iter().map(|m| self.lower_macro_def(m)).collect(),\n             items: items,"}, {"sha": "ed83e228a23c180aada02b5255dd7d121bc6ec53", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -413,7 +413,6 @@ pub type CrateConfig = HirVec<P<MetaItem>>;\n pub struct Crate {\n     pub module: Mod,\n     pub attrs: HirVec<Attribute>,\n-    pub config: CrateConfig,\n     pub span: Span,\n     pub exported_macros: HirVec<MacroDef>,\n "}, {"sha": "7b5413984a20504177a03783630aefb05e1f8ad4", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -1237,10 +1237,9 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n pub fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n     cfgspecs.into_iter().map(|s| {\n         let sess = parse::ParseSess::new();\n-        let mut parser = parse::new_parser_from_source_str(&sess,\n-                                                           Vec::new(),\n-                                                           \"cfgspec\".to_string(),\n-                                                           s.to_string());\n+        let mut parser =\n+            parse::new_parser_from_source_str(&sess, \"cfgspec\".to_string(), s.to_string());\n+\n         let meta_item = panictry!(parser.parse_meta_item());\n \n         if !parser.reader.is_eof() {"}, {"sha": "a629a2a7fa9a32bb898590ac6628881a10838e0b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -68,7 +68,6 @@ pub struct Resolutions {\n \n pub fn compile_input(sess: &Session,\n                      cstore: &CStore,\n-                     cfg: ast::CrateConfig,\n                      input: &Input,\n                      outdir: &Option<PathBuf>,\n                      output: &Option<PathBuf>,\n@@ -92,7 +91,7 @@ pub fn compile_input(sess: &Session,\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n     let (outputs, trans) = {\n-        let krate = match phase_1_parse_input(sess, cfg, input) {\n+        let krate = match phase_1_parse_input(sess, input) {\n             Ok(krate) => krate,\n             Err(mut parse_error) => {\n                 parse_error.emit();\n@@ -491,23 +490,17 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n     }\n }\n \n-pub fn phase_1_parse_input<'a>(sess: &'a Session,\n-                               cfg: ast::CrateConfig,\n-                               input: &Input)\n-                               -> PResult<'a, ast::Crate> {\n+pub fn phase_1_parse_input<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::Crate> {\n     let continue_after_error = sess.opts.debugging_opts.continue_parse_after_error;\n     sess.diagnostic().set_continue_after_error(continue_after_error);\n \n     let krate = time(sess.time_passes(), \"parsing\", || {\n         match *input {\n             Input::File(ref file) => {\n-                parse::parse_crate_from_file(file, cfg.clone(), &sess.parse_sess)\n+                parse::parse_crate_from_file(file, &sess.parse_sess)\n             }\n             Input::Str { ref input, ref name } => {\n-                parse::parse_crate_from_source_str(name.clone(),\n-                                                   input.clone(),\n-                                                   cfg.clone(),\n-                                                   &sess.parse_sess)\n+                parse::parse_crate_from_source_str(name.clone(), input.clone(), &sess.parse_sess)\n             }\n         }\n     })?;\n@@ -645,7 +638,7 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n     // its contents but the results of name resolution on those contents. Hopefully we'll push\n     // this back at some point.\n     let _ignore = sess.dep_graph.in_ignore();\n-    let mut crate_loader = CrateLoader::new(sess, &cstore, crate_name, krate.config.clone());\n+    let mut crate_loader = CrateLoader::new(sess, &cstore, crate_name);\n     crate_loader.preprocess(&krate);\n     let resolver_arenas = Resolver::arenas();\n     let mut resolver =\n@@ -686,7 +679,7 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n             should_test: sess.opts.test,\n             ..syntax::ext::expand::ExpansionConfig::default(crate_name.to_string())\n         };\n-        let mut ecx = ExtCtxt::new(&sess.parse_sess, krate.config.clone(), cfg, &mut resolver);\n+        let mut ecx = ExtCtxt::new(&sess.parse_sess, cfg, &mut resolver);\n         let err_count = ecx.parse_sess.span_diagnostic.err_count();\n \n         let krate = ecx.monotonic_expander().expand_crate(krate);"}, {"sha": "f4cae912898854a7d268ed2f7ae51f77f99deeac", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -205,24 +205,20 @@ pub fn run_compiler<'a>(args: &[String],\n \n     let loader = file_loader.unwrap_or(box RealFileLoader);\n     let codemap = Rc::new(CodeMap::with_file_loader(loader));\n-    let sess = session::build_session_with_codemap(sopts,\n-                                                   &dep_graph,\n-                                                   input_file_path,\n-                                                   descriptions,\n-                                                   cstore.clone(),\n-                                                   codemap,\n-                                                   emitter_dest);\n+    let mut sess = session::build_session_with_codemap(\n+        sopts, &dep_graph, input_file_path, descriptions, cstore.clone(), codemap, emitter_dest,\n+    );\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n+\n     let mut cfg = config::build_configuration(&sess, cfg);\n     target_features::add_configuration(&mut cfg, &sess);\n+    sess.parse_sess.config = cfg;\n \n-    do_or_return!(callbacks.late_callback(&matches, &sess, &cfg, &input, &odir, &ofile),\n-                  Some(sess));\n+    do_or_return!(callbacks.late_callback(&matches, &sess, &input, &odir, &ofile), Some(sess));\n \n     let plugins = sess.opts.debugging_opts.extra_plugins.clone();\n     let control = callbacks.build_controller(&sess, &matches);\n-    (driver::compile_input(&sess, &cstore, cfg, &input, &odir, &ofile,\n-                           Some(plugins), &control),\n+    (driver::compile_input(&sess, &cstore, &input, &odir, &ofile, Some(plugins), &control),\n      Some(sess))\n }\n \n@@ -310,7 +306,6 @@ pub trait CompilerCalls<'a> {\n     fn late_callback(&mut self,\n                      _: &getopts::Matches,\n                      _: &Session,\n-                     _: &ast::CrateConfig,\n                      _: &Input,\n                      _: &Option<PathBuf>,\n                      _: &Option<PathBuf>)\n@@ -439,19 +434,18 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                 }\n                 let dep_graph = DepGraph::new(sopts.build_dep_graph());\n                 let cstore = Rc::new(CStore::new(&dep_graph));\n-                let sess = build_session(sopts.clone(),\n+                let mut sess = build_session(sopts.clone(),\n                     &dep_graph,\n                     None,\n                     descriptions.clone(),\n                     cstore.clone());\n                 rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n                 let mut cfg = config::build_configuration(&sess, cfg.clone());\n                 target_features::add_configuration(&mut cfg, &sess);\n-                let should_stop = RustcDefaultCalls::print_crate_info(&sess,\n-                                                                      &cfg,\n-                                                                      None,\n-                                                                      odir,\n-                                                                      ofile);\n+                sess.parse_sess.config = cfg;\n+                let should_stop =\n+                    RustcDefaultCalls::print_crate_info(&sess, None, odir, ofile);\n+\n                 if should_stop == Compilation::Stop {\n                     return None;\n                 }\n@@ -467,12 +461,11 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n     fn late_callback(&mut self,\n                      matches: &getopts::Matches,\n                      sess: &Session,\n-                     cfg: &ast::CrateConfig,\n                      input: &Input,\n                      odir: &Option<PathBuf>,\n                      ofile: &Option<PathBuf>)\n                      -> Compilation {\n-        RustcDefaultCalls::print_crate_info(sess, cfg, Some(input), odir, ofile)\n+        RustcDefaultCalls::print_crate_info(sess, Some(input), odir, ofile)\n             .and_then(|| RustcDefaultCalls::list_metadata(sess, matches, input))\n     }\n \n@@ -593,7 +586,6 @@ impl RustcDefaultCalls {\n \n \n     fn print_crate_info(sess: &Session,\n-                        cfg: &ast::CrateConfig,\n                         input: Option<&Input>,\n                         odir: &Option<PathBuf>,\n                         ofile: &Option<PathBuf>)\n@@ -649,8 +641,8 @@ impl RustcDefaultCalls {\n                     let allow_unstable_cfg = UnstableFeatures::from_environment()\n                         .is_nightly_build();\n \n-                    for cfg in cfg {\n-                        if !allow_unstable_cfg && GatedCfg::gate(&*cfg).is_some() {\n+                    for cfg in &sess.parse_sess.config {\n+                        if !allow_unstable_cfg && GatedCfg::gate(cfg).is_some() {\n                             continue;\n                         }\n \n@@ -1036,13 +1028,10 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n fn parse_crate_attrs<'a>(sess: &'a Session, input: &Input) -> PResult<'a, Vec<ast::Attribute>> {\n     match *input {\n         Input::File(ref ifile) => {\n-            parse::parse_crate_attrs_from_file(ifile, Vec::new(), &sess.parse_sess)\n+            parse::parse_crate_attrs_from_file(ifile, &sess.parse_sess)\n         }\n         Input::Str { ref name, ref input } => {\n-            parse::parse_crate_attrs_from_source_str(name.clone(),\n-                                                     input.clone(),\n-                                                     Vec::new(),\n-                                                     &sess.parse_sess)\n+            parse::parse_crate_attrs_from_source_str(name.clone(), input.clone(), &sess.parse_sess)\n         }\n     }\n }"}, {"sha": "50903c89a58901bcc49e001ed6fdf30c310b6e57", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -106,12 +106,11 @@ fn test_env<F>(source_string: &str,\n     let sess = session::build_session_(options, &dep_graph, None, diagnostic_handler,\n                                        Rc::new(CodeMap::new()), cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-    let krate_config = Vec::new();\n     let input = config::Input::Str {\n         name: driver::anon_src(),\n         input: source_string.to_string(),\n     };\n-    let krate = driver::phase_1_parse_input(&sess, krate_config, &input).unwrap();\n+    let krate = driver::phase_1_parse_input(&sess, &input).unwrap();\n     let driver::ExpansionResult { defs, resolutions, mut hir_forest, .. } = {\n         driver::phase_2_configure_and_expand(\n             &sess, &cstore, krate, None, \"test\", None, MakeGlobMap::No, |_| Ok(()),"}, {"sha": "94478f6603a6ee8dcb8d4980490a1f1bd77a8f7e", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -264,7 +264,7 @@ impl<'a, 'tcx, 'm> DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n /// flag called `foo`.\n fn check_config(tcx: TyCtxt, attr: &ast::Attribute) -> bool {\n     debug!(\"check_config(attr={:?})\", attr);\n-    let config = &tcx.map.krate().config;\n+    let config = &tcx.sess.parse_sess.config;\n     debug!(\"check_config: config={:?}\", config);\n     for item in attr.meta_item_list().unwrap_or(&[]) {\n         if item.check_name(CFG) {"}, {"sha": "f4558a2871d1963b6813b2a55990b27586610509", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -52,7 +52,6 @@ pub struct CrateLoader<'a> {\n     next_crate_num: CrateNum,\n     foreign_item_map: FnvHashMap<String, Vec<ast::NodeId>>,\n     local_crate_name: String,\n-    local_crate_config: ast::CrateConfig,\n }\n \n fn dump_crates(cstore: &CStore) {\n@@ -144,18 +143,13 @@ enum LoadResult {\n }\n \n impl<'a> CrateLoader<'a> {\n-    pub fn new(sess: &'a Session,\n-               cstore: &'a CStore,\n-               local_crate_name: &str,\n-               local_crate_config: ast::CrateConfig)\n-               -> Self {\n+    pub fn new(sess: &'a Session, cstore: &'a CStore, local_crate_name: &str) -> Self {\n         CrateLoader {\n             sess: sess,\n             cstore: cstore,\n             next_crate_num: cstore.next_crate_num(),\n             foreign_item_map: FnvHashMap(),\n             local_crate_name: local_crate_name.to_owned(),\n-            local_crate_config: local_crate_config,\n         }\n     }\n \n@@ -541,7 +535,6 @@ impl<'a> CrateLoader<'a> {\n             // NB: Don't use parse::parse_tts_from_source_str because it parses with\n             // quote_depth > 0.\n             let mut p = parse::new_parser_from_source_str(&self.sess.parse_sess,\n-                                                          self.local_crate_config.clone(),\n                                                           source_name.clone(),\n                                                           def.body);\n             let lo = p.span.lo;"}, {"sha": "4438241999a3940e4f6c289d0032f0bb473569fc", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -47,7 +47,7 @@ pub fn load_plugins(sess: &Session,\n                     krate: &ast::Crate,\n                     crate_name: &str,\n                     addl_plugins: Option<Vec<String>>) -> Vec<PluginRegistrar> {\n-    let mut loader = PluginLoader::new(sess, cstore, crate_name, krate.config.clone());\n+    let mut loader = PluginLoader::new(sess, cstore, crate_name);\n \n     // do not report any error now. since crate attributes are\n     // not touched by expansion, every use of plugin without\n@@ -89,14 +89,10 @@ pub fn load_plugins(sess: &Session,\n }\n \n impl<'a> PluginLoader<'a> {\n-    fn new(sess: &'a Session,\n-           cstore: &'a CStore,\n-           crate_name: &str,\n-           crate_config: ast::CrateConfig)\n-            -> PluginLoader<'a> {\n+    fn new(sess: &'a Session, cstore: &'a CStore, crate_name: &str) -> Self {\n         PluginLoader {\n             sess: sess,\n-            reader: CrateLoader::new(sess, cstore, crate_name, crate_config),\n+            reader: CrateLoader::new(sess, cstore, crate_name),\n             plugins: vec![],\n         }\n     }"}, {"sha": "264ed4cd12fc1a419cbad0b13d6500559cfc992e", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -134,7 +134,7 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n     /// Scan for a `cfg=\"foo\"` attribute and check whether we have a\n     /// cfg flag called `foo`.\n     fn check_config(&self, attr: &ast::Attribute) -> bool {\n-        let config = &self.tcx.map.krate().config;\n+        let config = &self.tcx.sess.parse_sess.config;\n         let value = self.field(attr, CFG);\n         debug!(\"check_config(config={:?}, value={:?})\", config, value);\n         if config.iter().any(|c| c.check_name(&value[..])) {"}, {"sha": "d18e4c8d29c17295a6e77d65b46d25ab0e7d632c", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -163,14 +163,16 @@ pub fn run_core(search_paths: SearchPaths,\n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n     let cstore = Rc::new(CStore::new(&dep_graph));\n-    let sess = session::build_session_(sessopts, &dep_graph, cpath, diagnostic_handler,\n-                                       codemap, cstore.clone());\n+    let mut sess = session::build_session_(\n+        sessopts, &dep_graph, cpath, diagnostic_handler, codemap, cstore.clone()\n+    );\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs));\n     target_features::add_configuration(&mut cfg, &sess);\n+    sess.parse_sess.config = cfg;\n \n-    let krate = panictry!(driver::phase_1_parse_input(&sess, cfg, &input));\n+    let krate = panictry!(driver::phase_1_parse_input(&sess, &input));\n \n     let name = link::find_crate_name(Some(&sess), &krate.attrs, &input);\n "}, {"sha": "45c3d413500bf9e33a7ab871255916c8cacc0599", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -73,24 +73,20 @@ pub fn run(input: &str,\n     };\n \n     let codemap = Rc::new(CodeMap::new());\n-    let diagnostic_handler = errors::Handler::with_tty_emitter(ColorConfig::Auto,\n-                                                               true,\n-                                                               false,\n-                                                               Some(codemap.clone()));\n+    let handler =\n+        errors::Handler::with_tty_emitter(ColorConfig::Auto, true, false, Some(codemap.clone()));\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n     let cstore = Rc::new(CStore::new(&dep_graph));\n-    let sess = session::build_session_(sessopts,\n-                                       &dep_graph,\n-                                       Some(input_path.clone()),\n-                                       diagnostic_handler,\n-                                       codemap,\n-                                       cstore.clone());\n+    let mut sess = session::build_session_(\n+        sessopts, &dep_graph, Some(input_path.clone()), handler, codemap, cstore.clone(),\n+    );\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n+    sess.parse_sess.config =\n+        config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n \n-    let cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n-    let krate = panictry!(driver::phase_1_parse_input(&sess, cfg, &input));\n+    let krate = panictry!(driver::phase_1_parse_input(&sess, &input));\n     let driver::ExpansionResult { defs, mut hir_forest, .. } = {\n         phase_2_configure_and_expand(\n             &sess, &cstore, krate, None, \"rustdoc-test\", None, MakeGlobMap::No, |_| Ok(())\n@@ -236,28 +232,24 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n \n     let dep_graph = DepGraph::new(false);\n     let cstore = Rc::new(CStore::new(&dep_graph));\n-    let sess = session::build_session_(sessopts,\n-                                       &dep_graph,\n-                                       None,\n-                                       diagnostic_handler,\n-                                       codemap,\n-                                       cstore.clone());\n+    let mut sess = session::build_session_(\n+        sessopts, &dep_graph, None, diagnostic_handler, codemap, cstore.clone(),\n+    );\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let outdir = Mutex::new(TempDir::new(\"rustdoctest\").ok().expect(\"rustdoc needs a tempdir\"));\n     let libdir = sess.target_filesearch(PathKind::All).get_lib_path();\n     let mut control = driver::CompileController::basic();\n-    let cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n+    sess.parse_sess.config =\n+        config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n     let out = Some(outdir.lock().unwrap().path().to_path_buf());\n \n     if no_run {\n         control.after_analysis.stop = Compilation::Stop;\n     }\n \n     let res = panic::catch_unwind(AssertUnwindSafe(|| {\n-        driver::compile_input(&sess, &cstore, cfg.clone(),\n-                              &input, &out,\n-                              &None, None, &control)\n+        driver::compile_input(&sess, &cstore, &input, &out, &None, None, &control)\n     }));\n \n     match res {"}, {"sha": "8864694c932f38dc87a7543db23f21a3f3ab255b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -477,7 +477,6 @@ pub type CrateConfig = Vec<P<MetaItem>>;\n pub struct Crate {\n     pub module: Mod,\n     pub attrs: Vec<Attribute>,\n-    pub config: CrateConfig,\n     pub span: Span,\n     pub exported_macros: Vec<MacroDef>,\n }"}, {"sha": "0335f210347a2e05de4ece44211c92208f53e515", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -501,10 +501,7 @@ pub fn requests_inline(attrs: &[Attribute]) -> bool {\n }\n \n /// Tests if a cfg-pattern matches the cfg set\n-pub fn cfg_matches(cfgs: &[P<MetaItem>], cfg: &ast::MetaItem,\n-                   sess: &ParseSess,\n-                   features: Option<&Features>)\n-                   -> bool {\n+pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Features>) -> bool {\n     match cfg.node {\n         ast::MetaItemKind::List(ref pred, ref mis) => {\n             for mi in mis.iter() {\n@@ -518,18 +515,18 @@ pub fn cfg_matches(cfgs: &[P<MetaItem>], cfg: &ast::MetaItem,\n             // that they won't fail with the loop above.\n             match &pred[..] {\n                 \"any\" => mis.iter().any(|mi| {\n-                    cfg_matches(cfgs, mi.meta_item().unwrap(), sess, features)\n+                    cfg_matches(mi.meta_item().unwrap(), sess, features)\n                 }),\n                 \"all\" => mis.iter().all(|mi| {\n-                    cfg_matches(cfgs, mi.meta_item().unwrap(), sess, features)\n+                    cfg_matches(mi.meta_item().unwrap(), sess, features)\n                 }),\n                 \"not\" => {\n                     if mis.len() != 1 {\n                         span_err!(sess.span_diagnostic, cfg.span, E0536, \"expected 1 cfg-pattern\");\n                         return false;\n                     }\n \n-                    !cfg_matches(cfgs, mis[0].meta_item().unwrap(), sess, features)\n+                    !cfg_matches(mis[0].meta_item().unwrap(), sess, features)\n                 },\n                 p => {\n                     span_err!(sess.span_diagnostic, cfg.span, E0537, \"invalid predicate `{}`\", p);\n@@ -541,7 +538,7 @@ pub fn cfg_matches(cfgs: &[P<MetaItem>], cfg: &ast::MetaItem,\n             if let (Some(feats), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n                 gated_cfg.check_and_emit(sess, feats);\n             }\n-            contains(cfgs, cfg)\n+            contains(&sess.config, cfg)\n         }\n     }\n }"}, {"sha": "946257a16d5ac110a5a6218adc372653ae653611", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -20,7 +20,6 @@ use util::small_vector::SmallVector;\n \n /// A folder that strips out items that do not belong in the current configuration.\n pub struct StripUnconfigured<'a> {\n-    pub config: &'a ast::CrateConfig,\n     pub should_test: bool,\n     pub sess: &'a ParseSess,\n     pub features: Option<&'a Features>,\n@@ -32,7 +31,6 @@ pub fn features(mut krate: ast::Crate, sess: &ParseSess, should_test: bool)\n     let features;\n     {\n         let mut strip_unconfigured = StripUnconfigured {\n-            config: &krate.config.clone(),\n             should_test: should_test,\n             sess: sess,\n             features: None,\n@@ -107,7 +105,7 @@ impl<'a> StripUnconfigured<'a> {\n         use attr::cfg_matches;\n         match (cfg.meta_item(), mi.meta_item()) {\n             (Some(cfg), Some(mi)) =>\n-                if cfg_matches(self.config, &cfg, self.sess, self.features) {\n+                if cfg_matches(&cfg, self.sess, self.features) {\n                     self.process_cfg_attr(respan(mi.span, ast::Attribute_ {\n                         id: attr::mk_attr_id(),\n                         style: attr.node.style,\n@@ -148,7 +146,7 @@ impl<'a> StripUnconfigured<'a> {\n                 return true;\n             }\n \n-            attr::cfg_matches(self.config, mis[0].meta_item().unwrap(), self.sess, self.features)\n+            attr::cfg_matches(mis[0].meta_item().unwrap(), self.sess, self.features)\n         })\n     }\n "}, {"sha": "cc097ab0efadc05491b2c9290e1171d092af6b8d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -574,7 +574,6 @@ pub struct ExpansionData {\n /// -> expn_info of their expansion context stored into their span.\n pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a parse::ParseSess,\n-    pub cfg: ast::CrateConfig,\n     pub ecfg: expand::ExpansionConfig<'a>,\n     pub crate_root: Option<&'static str>,\n     pub resolver: &'a mut Resolver,\n@@ -583,13 +582,12 @@ pub struct ExtCtxt<'a> {\n }\n \n impl<'a> ExtCtxt<'a> {\n-    pub fn new(parse_sess: &'a parse::ParseSess, cfg: ast::CrateConfig,\n+    pub fn new(parse_sess: &'a parse::ParseSess,\n                ecfg: expand::ExpansionConfig<'a>,\n                resolver: &'a mut Resolver)\n                -> ExtCtxt<'a> {\n         ExtCtxt {\n             parse_sess: parse_sess,\n-            cfg: cfg,\n             ecfg: ecfg,\n             crate_root: None,\n             resolver: resolver,\n@@ -617,11 +615,11 @@ impl<'a> ExtCtxt<'a> {\n \n     pub fn new_parser_from_tts(&self, tts: &[tokenstream::TokenTree])\n         -> parser::Parser<'a> {\n-        parse::tts_to_parser(self.parse_sess, tts.to_vec(), self.cfg().clone())\n+        parse::tts_to_parser(self.parse_sess, tts.to_vec())\n     }\n     pub fn codemap(&self) -> &'a CodeMap { self.parse_sess.codemap() }\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n-    pub fn cfg(&self) -> &ast::CrateConfig { &self.cfg }\n+    pub fn cfg(&self) -> &ast::CrateConfig { &self.parse_sess.config }\n     pub fn call_site(&self) -> Span {\n         self.codemap().with_expn_info(self.backtrace(), |ei| match ei {\n             Some(expn_info) => expn_info.call_site,"}, {"sha": "e3b23e239f917103d05d2bdf0307946d6600e16f", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -293,11 +293,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     }\n \n     fn collect_invocations(&mut self, expansion: Expansion) -> (Expansion, Vec<Invocation>) {\n-        let crate_config = mem::replace(&mut self.cx.cfg, Vec::new());\n         let result = {\n             let mut collector = InvocationCollector {\n                 cfg: StripUnconfigured {\n-                    config: &crate_config,\n                     should_test: self.cx.ecfg.should_test,\n                     sess: self.cx.parse_sess,\n                     features: self.cx.ecfg.features,\n@@ -308,7 +306,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             };\n             (expansion.fold_with(&mut collector), collector.invocations)\n         };\n-        self.cx.cfg = crate_config;\n \n         if self.monotonic {\n             let err_count = self.cx.parse_sess.span_diagnostic.err_count();\n@@ -646,7 +643,7 @@ fn string_to_tts(text: String, parse_sess: &ParseSess) -> Vec<TokenTree> {\n                             .new_filemap(String::from(\"<macro expansion>\"), None, text);\n \n     let lexer = lexer::StringReader::new(&parse_sess.span_diagnostic, filemap);\n-    let mut parser = Parser::new(parse_sess, Vec::new(), Box::new(lexer));\n+    let mut parser = Parser::new(parse_sess, Box::new(lexer));\n     panictry!(parser.parse_all_token_trees())\n }\n "}, {"sha": "f3497c130bff43caf6ba9cd32f5ecc52433ccb55", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -331,31 +331,27 @@ pub mod rt {\n             panictry!(parse::parse_item_from_source_str(\n                 \"<quote expansion>\".to_string(),\n                 s,\n-                self.cfg().clone(),\n                 self.parse_sess())).expect(\"parse error\")\n         }\n \n         fn parse_stmt(&self, s: String) -> ast::Stmt {\n             panictry!(parse::parse_stmt_from_source_str(\n                 \"<quote expansion>\".to_string(),\n                 s,\n-                self.cfg().clone(),\n                 self.parse_sess())).expect(\"parse error\")\n         }\n \n         fn parse_expr(&self, s: String) -> P<ast::Expr> {\n             panictry!(parse::parse_expr_from_source_str(\n                 \"<quote expansion>\".to_string(),\n                 s,\n-                self.cfg().clone(),\n                 self.parse_sess()))\n         }\n \n         fn parse_tts(&self, s: String) -> Vec<TokenTree> {\n             panictry!(parse::parse_tts_from_source_str(\n                 \"<quote expansion>\".to_string(),\n                 s,\n-                self.cfg().clone(),\n                 self.parse_sess()))\n         }\n     }\n@@ -920,22 +916,14 @@ fn expand_parse_call(cx: &ExtCtxt,\n                      tts: &[TokenTree]) -> P<ast::Expr> {\n     let (cx_expr, tts_expr) = expand_tts(cx, sp, tts);\n \n-    let cfg_call = || cx.expr_method_call(\n-        sp, cx.expr_ident(sp, id_ext(\"ext_cx\")),\n-        id_ext(\"cfg\"), Vec::new());\n-\n-    let cfg_clone_call = || cx.expr_method_call(\n-        sp, cfg_call(),\n-        id_ext(\"clone\"), Vec::new());\n-\n     let parse_sess_call = || cx.expr_method_call(\n         sp, cx.expr_ident(sp, id_ext(\"ext_cx\")),\n         id_ext(\"parse_sess\"), Vec::new());\n \n     let new_parser_call =\n         cx.expr_call(sp,\n                      cx.expr_ident(sp, id_ext(\"new_parser_from_tts\")),\n-                     vec!(parse_sess_call(), cfg_clone_call(), tts_expr));\n+                     vec!(parse_sess_call(), tts_expr));\n \n     let path = vec![id_ext(\"syntax\"), id_ext(\"ext\"), id_ext(\"quote\"), id_ext(parse_method)];\n     let mut args = vec![cx.expr_mut_addr_of(sp, new_parser_call)];"}, {"sha": "ec48cae3f7652a6a4537c5431392d77561045cef", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -92,15 +92,8 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::T\n         None => return DummyResult::expr(sp),\n     };\n     // The file will be added to the code map by the parser\n-    let p =\n-        parse::new_sub_parser_from_file(cx.parse_sess(),\n-                                        cx.cfg().clone(),\n-                                        &res_rel_file(cx,\n-                                                      sp,\n-                                                      Path::new(&file)),\n-                                        true,\n-                                        None,\n-                                        sp);\n+    let path = res_rel_file(cx, sp, Path::new(&file));\n+    let p = parse::new_sub_parser_from_file(cx.parse_sess(), &path, true, None, sp);\n \n     struct ExpandResult<'a> {\n         p: parse::parser::Parser<'a>,"}, {"sha": "7e3fe3285695c2d6726b4df566d4c5841c61ce9a", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -78,7 +78,6 @@ pub use self::NamedMatch::*;\n pub use self::ParseResult::*;\n use self::TokenTreeOrTokenTreeVec::*;\n \n-use ast;\n use ast::Ident;\n use syntax_pos::{self, BytePos, mk_sp, Span};\n use codemap::Spanned;\n@@ -280,11 +279,7 @@ pub fn token_name_eq(t1 : &Token, t2 : &Token) -> bool {\n     }\n }\n \n-pub fn parse(sess: &ParseSess,\n-             cfg: &ast::CrateConfig,\n-             mut rdr: TtReader,\n-             ms: &[TokenTree])\n-             -> NamedParseResult {\n+pub fn parse(sess: &ParseSess, mut rdr: TtReader, ms: &[TokenTree]) -> NamedParseResult {\n     let mut cur_eis = SmallVector::one(initial_matcher_pos(ms.to_owned(),\n                                                            None,\n                                                            rdr.peek().sp.lo));\n@@ -482,7 +477,7 @@ pub fn parse(sess: &ParseSess,\n                 rdr.next_token();\n             } else /* bb_eis.len() == 1 */ {\n                 rdr.next_tok = {\n-                    let mut rust_parser = Parser::new(sess, cfg.clone(), Box::new(&mut rdr));\n+                    let mut rust_parser = Parser::new(sess, Box::new(&mut rdr));\n                     let mut ei = bb_eis.pop().unwrap();\n                     if let TokenTree::Token(span, MatchNt(_, ident)) = ei.top_elts.get_tt(ei.idx) {\n                         let match_cur = ei.match_cur;"}, {"sha": "431e757368c0361d59f0c2954d4979dbb63afe5c", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -115,7 +115,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n                 let trncbr =\n                     new_tt_reader(&cx.parse_sess.span_diagnostic, Some(named_matches), rhs);\n-                let mut p = Parser::new(cx.parse_sess(), cx.cfg().clone(), Box::new(trncbr));\n+                let mut p = Parser::new(cx.parse_sess(), Box::new(trncbr));\n                 p.directory = cx.current_expansion.module.directory.clone();\n                 p.restrictions = match cx.current_expansion.no_noninline_mod {\n                     true => Restrictions::NO_NONINLINE_MOD,\n@@ -220,7 +220,7 @@ pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n     let arg_reader = new_tt_reader(&sess.span_diagnostic, None, def.body.clone());\n \n-    let argument_map = match parse(sess, &Vec::new(), arg_reader, &argument_gram) {\n+    let argument_map = match parse(sess, arg_reader, &argument_gram) {\n         Success(m) => m,\n         Failure(sp, tok) => {\n             let s = parse_failure_msg(tok);"}, {"sha": "4bf6e55d6743bdbda6a2f45871b9c19cd3d3cdd8", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -972,10 +972,8 @@ pub fn noop_fold_mod<T: Folder>(Mod {inner, items}: Mod, folder: &mut T) -> Mod\n     }\n }\n \n-pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, mut exported_macros, span}: Crate,\n+pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, mut exported_macros, span}: Crate,\n                                   folder: &mut T) -> Crate {\n-    let config = folder.fold_meta_items(config);\n-\n     let mut items = folder.fold_item(P(ast::Item {\n         ident: keywords::Invalid.ident(),\n         attrs: attrs,\n@@ -1009,7 +1007,6 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, mut exported_mac\n     Crate {\n         module: module,\n         attrs: attrs,\n-        config: config,\n         exported_macros: exported_macros,\n         span: span,\n     }"}, {"sha": "7b67c23e10231464b1d537931155247ea15f147d", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 41, "deletions": 103, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -10,7 +10,7 @@\n \n //! The main parser interface\n \n-use ast;\n+use ast::{self, CrateConfig};\n use codemap::CodeMap;\n use syntax_pos::{self, Span, FileMap};\n use errors::{Handler, ColorConfig, DiagnosticBuilder};\n@@ -44,13 +44,14 @@ pub mod obsolete;\n pub struct ParseSess {\n     pub span_diagnostic: Handler, // better be the same as the one in the reader!\n     pub unstable_features: UnstableFeatures,\n+    pub config: CrateConfig,\n     /// Used to determine and report recursive mod inclusions\n     included_mod_stack: RefCell<Vec<PathBuf>>,\n     code_map: Rc<CodeMap>,\n }\n \n impl ParseSess {\n-    pub fn new() -> ParseSess {\n+    pub fn new() -> Self {\n         let cm = Rc::new(CodeMap::new());\n         let handler = Handler::with_tty_emitter(ColorConfig::Auto,\n                                                 true,\n@@ -63,6 +64,7 @@ impl ParseSess {\n         ParseSess {\n             span_diagnostic: handler,\n             unstable_features: UnstableFeatures::from_environment(),\n+            config: Vec::new(),\n             included_mod_stack: RefCell::new(vec![]),\n             code_map: code_map\n         }\n@@ -78,146 +80,90 @@ impl ParseSess {\n // uses a HOF to parse anything, and <source> includes file and\n // source_str.\n \n-pub fn parse_crate_from_file<'a>(input: &Path,\n-                                 cfg: ast::CrateConfig,\n-                                 sess: &'a ParseSess)\n-                                 -> PResult<'a, ast::Crate> {\n-    let mut parser = new_parser_from_file(sess, cfg, input);\n+pub fn parse_crate_from_file<'a>(input: &Path, sess: &'a ParseSess) -> PResult<'a, ast::Crate> {\n+    let mut parser = new_parser_from_file(sess, input);\n     parser.parse_crate_mod()\n }\n \n-pub fn parse_crate_attrs_from_file<'a>(input: &Path,\n-                                       cfg: ast::CrateConfig,\n-                                       sess: &'a ParseSess)\n+pub fn parse_crate_attrs_from_file<'a>(input: &Path, sess: &'a ParseSess)\n                                        -> PResult<'a, Vec<ast::Attribute>> {\n-    let mut parser = new_parser_from_file(sess, cfg, input);\n+    let mut parser = new_parser_from_file(sess, input);\n     parser.parse_inner_attributes()\n }\n \n-pub fn parse_crate_from_source_str<'a>(name: String,\n-                                       source: String,\n-                                       cfg: ast::CrateConfig,\n-                                       sess: &'a ParseSess)\n+pub fn parse_crate_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n                                        -> PResult<'a, ast::Crate> {\n-    let mut p = new_parser_from_source_str(sess,\n-                                           cfg,\n-                                           name,\n-                                           source);\n-    p.parse_crate_mod()\n+    new_parser_from_source_str(sess, name, source).parse_crate_mod()\n }\n \n-pub fn parse_crate_attrs_from_source_str<'a>(name: String,\n-                                             source: String,\n-                                             cfg: ast::CrateConfig,\n-                                             sess: &'a ParseSess)\n+pub fn parse_crate_attrs_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n                                              -> PResult<'a, Vec<ast::Attribute>> {\n-    let mut p = new_parser_from_source_str(sess,\n-                                           cfg,\n-                                           name,\n-                                           source);\n-    p.parse_inner_attributes()\n+    new_parser_from_source_str(sess, name, source).parse_inner_attributes()\n }\n \n-pub fn parse_expr_from_source_str<'a>(name: String,\n-                                      source: String,\n-                                      cfg: ast::CrateConfig,\n-                                      sess: &'a ParseSess)\n+pub fn parse_expr_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n                                       -> PResult<'a, P<ast::Expr>> {\n-    let mut p = new_parser_from_source_str(sess, cfg, name, source);\n-    p.parse_expr()\n+    new_parser_from_source_str(sess, name, source).parse_expr()\n }\n \n /// Parses an item.\n ///\n /// Returns `Ok(Some(item))` when successful, `Ok(None)` when no item was found, and`Err`\n /// when a syntax error occurred.\n-pub fn parse_item_from_source_str<'a>(name: String,\n-                                      source: String,\n-                                      cfg: ast::CrateConfig,\n-                                      sess: &'a ParseSess)\n+pub fn parse_item_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n                                       -> PResult<'a, Option<P<ast::Item>>> {\n-    let mut p = new_parser_from_source_str(sess, cfg, name, source);\n-    p.parse_item()\n+    new_parser_from_source_str(sess, name, source).parse_item()\n }\n \n-pub fn parse_meta_from_source_str<'a>(name: String,\n-                                      source: String,\n-                                      cfg: ast::CrateConfig,\n-                                      sess: &'a ParseSess)\n+pub fn parse_meta_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n                                       -> PResult<'a, P<ast::MetaItem>> {\n-    let mut p = new_parser_from_source_str(sess, cfg, name, source);\n-    p.parse_meta_item()\n+    new_parser_from_source_str(sess, name, source).parse_meta_item()\n }\n \n-pub fn parse_stmt_from_source_str<'a>(name: String,\n-                                      source: String,\n-                                      cfg: ast::CrateConfig,\n-                                      sess: &'a ParseSess)\n+pub fn parse_stmt_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n                                       -> PResult<'a, Option<ast::Stmt>> {\n-    let mut p = new_parser_from_source_str(\n-        sess,\n-        cfg,\n-        name,\n-        source\n-    );\n-    p.parse_stmt()\n+    new_parser_from_source_str(sess, name, source).parse_stmt()\n }\n \n // Warning: This parses with quote_depth > 0, which is not the default.\n-pub fn parse_tts_from_source_str<'a>(name: String,\n-                                     source: String,\n-                                     cfg: ast::CrateConfig,\n-                                     sess: &'a ParseSess)\n+pub fn parse_tts_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n                                      -> PResult<'a, Vec<tokenstream::TokenTree>> {\n-    let mut p = new_parser_from_source_str(\n-        sess,\n-        cfg,\n-        name,\n-        source\n-    );\n+    let mut p = new_parser_from_source_str(sess, name, source);\n     p.quote_depth += 1;\n     // right now this is re-creating the token trees from ... token trees.\n     p.parse_all_token_trees()\n }\n \n // Create a new parser from a source string\n-pub fn new_parser_from_source_str<'a>(sess: &'a ParseSess,\n-                                      cfg: ast::CrateConfig,\n-                                      name: String,\n-                                      source: String)\n+pub fn new_parser_from_source_str<'a>(sess: &'a ParseSess, name: String, source: String)\n                                       -> Parser<'a> {\n-    filemap_to_parser(sess, sess.codemap().new_filemap(name, None, source), cfg)\n+    filemap_to_parser(sess, sess.codemap().new_filemap(name, None, source))\n }\n \n /// Create a new parser, handling errors as appropriate\n /// if the file doesn't exist\n-pub fn new_parser_from_file<'a>(sess: &'a ParseSess,\n-                                cfg: ast::CrateConfig,\n-                                path: &Path) -> Parser<'a> {\n-    filemap_to_parser(sess, file_to_filemap(sess, path, None), cfg)\n+pub fn new_parser_from_file<'a>(sess: &'a ParseSess, path: &Path) -> Parser<'a> {\n+    filemap_to_parser(sess, file_to_filemap(sess, path, None))\n }\n \n /// Given a session, a crate config, a path, and a span, add\n /// the file at the given path to the codemap, and return a parser.\n /// On an error, use the given span as the source of the problem.\n pub fn new_sub_parser_from_file<'a>(sess: &'a ParseSess,\n-                                    cfg: ast::CrateConfig,\n                                     path: &Path,\n                                     owns_directory: bool,\n                                     module_name: Option<String>,\n                                     sp: Span) -> Parser<'a> {\n-    let mut p = filemap_to_parser(sess, file_to_filemap(sess, path, Some(sp)), cfg);\n+    let mut p = filemap_to_parser(sess, file_to_filemap(sess, path, Some(sp)));\n     p.owns_directory = owns_directory;\n     p.root_module_name = module_name;\n     p\n }\n \n /// Given a filemap and config, return a parser\n-pub fn filemap_to_parser<'a>(sess: &'a ParseSess,\n-                             filemap: Rc<FileMap>,\n-                             cfg: ast::CrateConfig) -> Parser<'a> {\n+pub fn filemap_to_parser<'a>(sess: &'a ParseSess, filemap: Rc<FileMap>, ) -> Parser<'a> {\n     let end_pos = filemap.end_pos;\n-    let mut parser = tts_to_parser(sess, filemap_to_tts(sess, filemap), cfg);\n+    let mut parser = tts_to_parser(sess, filemap_to_tts(sess, filemap));\n \n     if parser.token == token::Eof && parser.span == syntax_pos::DUMMY_SP {\n         parser.span = syntax_pos::mk_sp(end_pos, end_pos);\n@@ -228,18 +174,13 @@ pub fn filemap_to_parser<'a>(sess: &'a ParseSess,\n \n // must preserve old name for now, because quote! from the *existing*\n // compiler expands into it\n-pub fn new_parser_from_tts<'a>(sess: &'a ParseSess,\n-                               cfg: ast::CrateConfig,\n-                               tts: Vec<tokenstream::TokenTree>)\n+pub fn new_parser_from_tts<'a>(sess: &'a ParseSess, tts: Vec<tokenstream::TokenTree>)\n                                -> Parser<'a> {\n-    tts_to_parser(sess, tts, cfg)\n+    tts_to_parser(sess, tts)\n }\n \n-pub fn new_parser_from_ts<'a>(sess: &'a ParseSess,\n-                              cfg: ast::CrateConfig,\n-                              ts: tokenstream::TokenStream)\n-                              -> Parser<'a> {\n-    tts_to_parser(sess, ts.to_tts(), cfg)\n+pub fn new_parser_from_ts<'a>(sess: &'a ParseSess, ts: tokenstream::TokenStream) -> Parser<'a> {\n+    tts_to_parser(sess, ts.to_tts())\n }\n \n \n@@ -266,18 +207,15 @@ pub fn filemap_to_tts(sess: &ParseSess, filemap: Rc<FileMap>)\n     -> Vec<tokenstream::TokenTree> {\n     // it appears to me that the cfg doesn't matter here... indeed,\n     // parsing tt's probably shouldn't require a parser at all.\n-    let cfg = Vec::new();\n     let srdr = lexer::StringReader::new(&sess.span_diagnostic, filemap);\n-    let mut p1 = Parser::new(sess, cfg, Box::new(srdr));\n+    let mut p1 = Parser::new(sess, Box::new(srdr));\n     panictry!(p1.parse_all_token_trees())\n }\n \n-/// Given tts and cfg, produce a parser\n-pub fn tts_to_parser<'a>(sess: &'a ParseSess,\n-                         tts: Vec<tokenstream::TokenTree>,\n-                         cfg: ast::CrateConfig) -> Parser<'a> {\n+/// Given tts and the ParseSess, produce a parser\n+pub fn tts_to_parser<'a>(sess: &'a ParseSess, tts: Vec<tokenstream::TokenTree>) -> Parser<'a> {\n     let trdr = lexer::new_tt_reader(&sess.span_diagnostic, None, tts);\n-    let mut p = Parser::new(sess, cfg, Box::new(trdr));\n+    let mut p = Parser::new(sess, Box::new(trdr));\n     p.check_unknown_macro_variable();\n     p\n }\n@@ -1057,21 +995,21 @@ mod tests {\n \n         let name = \"<source>\".to_string();\n         let source = \"/// doc comment\\r\\nfn foo() {}\".to_string();\n-        let item = parse_item_from_source_str(name.clone(), source, Vec::new(), &sess)\n+        let item = parse_item_from_source_str(name.clone(), source, &sess)\n             .unwrap().unwrap();\n         let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n         assert_eq!(&doc[..], \"/// doc comment\");\n \n         let source = \"/// doc comment\\r\\n/// line 2\\r\\nfn foo() {}\".to_string();\n-        let item = parse_item_from_source_str(name.clone(), source, Vec::new(), &sess)\n+        let item = parse_item_from_source_str(name.clone(), source, &sess)\n             .unwrap().unwrap();\n         let docs = item.attrs.iter().filter(|a| &*a.name() == \"doc\")\n                     .map(|a| a.value_str().unwrap().to_string()).collect::<Vec<_>>();\n         let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n         assert_eq!(&docs[..], b);\n \n         let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n-        let item = parse_item_from_source_str(name, source, Vec::new(), &sess).unwrap().unwrap();\n+        let item = parse_item_from_source_str(name, source, &sess).unwrap().unwrap();\n         let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n         assert_eq!(&doc[..], \"/** doc comment\\n *  with CRLF */\");\n     }\n@@ -1080,7 +1018,7 @@ mod tests {\n     fn ttdelim_span() {\n         let sess = ParseSess::new();\n         let expr = parse::parse_expr_from_source_str(\"foo\".to_string(),\n-            \"foo!( fn main() { body } )\".to_string(), vec![], &sess).unwrap();\n+            \"foo!( fn main() { body } )\".to_string(), &sess).unwrap();\n \n         let tts = match expr.node {\n             ast::ExprKind::Mac(ref mac) => mac.node.tts.clone(),"}, {"sha": "a75937759a2a596470830d4acf8ad947305156f8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -15,7 +15,7 @@ use ast::Unsafety;\n use ast::{Mod, Arg, Arm, Attribute, BindingMode, TraitItemKind};\n use ast::Block;\n use ast::{BlockCheckMode, CaptureBy};\n-use ast::{Constness, Crate, CrateConfig};\n+use ast::{Constness, Crate};\n use ast::Defaultness;\n use ast::EnumDef;\n use ast::{Expr, ExprKind, RangeLimits};\n@@ -271,7 +271,6 @@ pub struct Parser<'a> {\n     pub span: Span,\n     /// the span of the previous token:\n     pub prev_span: Span,\n-    pub cfg: CrateConfig,\n     /// the previous token kind\n     prev_token_kind: PrevTokenKind,\n     lookahead_buffer: LookaheadBuffer,\n@@ -358,11 +357,7 @@ impl From<P<Expr>> for LhsExpr {\n }\n \n impl<'a> Parser<'a> {\n-    pub fn new(sess: &'a ParseSess,\n-               cfg: ast::CrateConfig,\n-               mut rdr: Box<Reader+'a>)\n-               -> Parser<'a>\n-    {\n+    pub fn new(sess: &'a ParseSess, mut rdr: Box<Reader+'a>) -> Self {\n         let tok0 = rdr.real_token();\n         let span = tok0.sp;\n         let mut directory = match span {\n@@ -374,7 +369,6 @@ impl<'a> Parser<'a> {\n         Parser {\n             reader: rdr,\n             sess: sess,\n-            cfg: cfg,\n             token: tok0.tok,\n             span: span,\n             prev_span: span,\n@@ -5328,7 +5322,6 @@ impl<'a> Parser<'a> {\n     fn parse_item_mod(&mut self, outer_attrs: &[Attribute]) -> PResult<'a, ItemInfo> {\n         let (in_cfg, outer_attrs) = {\n             let mut strip_unconfigured = ::config::StripUnconfigured {\n-                config: &self.cfg,\n                 sess: self.sess,\n                 should_test: false, // irrelevant\n                 features: None, // don't perform gated feature checking\n@@ -5496,12 +5489,7 @@ impl<'a> Parser<'a> {\n         included_mod_stack.push(path.clone());\n         drop(included_mod_stack);\n \n-        let mut p0 = new_sub_parser_from_file(self.sess,\n-                                              self.cfg.clone(),\n-                                              &path,\n-                                              owns_directory,\n-                                              Some(name),\n-                                              id_sp);\n+        let mut p0 = new_sub_parser_from_file(self.sess, &path, owns_directory, Some(name), id_sp);\n         let mod_inner_lo = p0.span.lo;\n         let mod_attrs = p0.parse_inner_attributes()?;\n         let m0 = p0.parse_mod_items(&token::Eof, mod_inner_lo)?;\n@@ -6195,7 +6183,6 @@ impl<'a> Parser<'a> {\n         Ok(ast::Crate {\n             attrs: self.parse_inner_attributes()?,\n             module: self.parse_mod_items(&token::Eof, lo)?,\n-            config: self.cfg.clone(),\n             span: mk_sp(lo, self.span.lo),\n             exported_macros: Vec::new(),\n         })"}, {"sha": "fdc1f45623d9c15b2ffb1a91d560de07d76f3da3", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -274,7 +274,7 @@ fn generate_test_harness(sess: &ParseSess,\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n         span_diagnostic: sd,\n-        ext_cx: ExtCtxt::new(sess, vec![], ExpansionConfig::default(\"test\".to_string()), resolver),\n+        ext_cx: ExtCtxt::new(sess, ExpansionConfig::default(\"test\".to_string()), resolver),\n         path: Vec::new(),\n         testfns: Vec::new(),\n         reexport_test_harness_main: reexport_test_harness_main,"}, {"sha": "9e644e59e86a736ee62caa68722165ccce1f23ff", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -220,7 +220,7 @@ impl TokenTree {\n                                                          None,\n                                                          tts.iter().cloned().collect(),\n                                                          true);\n-        macro_parser::parse(cx.parse_sess(), cx.cfg(), arg_rdr, mtch)\n+        macro_parser::parse(cx.parse_sess(), arg_rdr, mtch)\n     }\n \n     /// Check if this TokenTree is equal to the other, regardless of span information."}, {"sha": "76d3f2a063c1884bd0d49b980ecbafe47c2a4e28", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -25,10 +25,7 @@ pub fn string_to_tts(source_str: String) -> Vec<tokenstream::TokenTree> {\n \n /// Map string to parser (via tts)\n pub fn string_to_parser<'a>(ps: &'a ParseSess, source_str: String) -> Parser<'a> {\n-    new_parser_from_source_str(ps,\n-                               Vec::new(),\n-                               \"bogofile\".to_string(),\n-                               source_str)\n+    new_parser_from_source_str(ps, \"bogofile\".to_string(), source_str)\n }\n \n fn with_error_checking_parse<'a, T, F>(s: String, ps: &'a ParseSess, f: F) -> T where"}, {"sha": "24c515e502808f5799fe66c4f17a5ac0cb35acef", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -107,7 +107,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                 if p2.token != token::Eof {\n                     let mut extra_tts = panictry!(p2.parse_all_token_trees());\n                     extra_tts.extend(tts[first_colon..].iter().cloned());\n-                    p = parse::tts_to_parser(cx.parse_sess, extra_tts, cx.cfg().clone());\n+                    p = parse::tts_to_parser(cx.parse_sess, extra_tts);\n                 }\n \n                 asm = s;"}, {"sha": "98da49545f9272c3dac300ac81ca78d11843493a", "filename": "src/libsyntax_ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax_ext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax_ext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcfg.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -32,6 +32,6 @@ pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n         return DummyResult::expr(sp);\n     }\n \n-    let matches_cfg = attr::cfg_matches(&cx.cfg, &cfg, cx.parse_sess, cx.ecfg.features);\n+    let matches_cfg = attr::cfg_matches(&cfg, cx.parse_sess, cx.ecfg.features);\n     MacEager::expr(cx.expr_bool(sp, matches_cfg))\n }"}, {"sha": "f49a5f0e0706ed11084c9261be45ec2d45489082", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -47,7 +47,7 @@ pub fn modify(sess: &ParseSess,\n               handler: &errors::Handler,\n               features: &Features) -> ast::Crate {\n     let ecfg = ExpansionConfig::default(\"proc_macro\".to_string());\n-    let mut cx = ExtCtxt::new(sess, Vec::new(), ecfg, resolver);\n+    let mut cx = ExtCtxt::new(sess, ecfg, resolver);\n \n     let mut collect = CollectCustomDerives {\n         derives: Vec::new(),"}, {"sha": "60697cc8b6acecd985193530abedecd2d487c95c", "filename": "src/test/compile-fail-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -56,8 +56,7 @@ fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])\n fn expand_identity(cx: &mut ExtCtxt, _span: Span, tts: &[TokenTree])\n                    -> Box<MacResult+'static> {\n     // Parse an expression and emit it unchanged.\n-    let mut parser = parse::new_parser_from_tts(cx.parse_sess(),\n-        cx.cfg().clone(), tts.to_vec());\n+    let mut parser = parse::new_parser_from_tts(cx.parse_sess(), tts.to_vec());\n     let expr = parser.parse_expr().unwrap();\n     MacEager::expr(quote_expr!(&mut *cx, $expr))\n }"}, {"sha": "4a7033d44b87858e65e5479c8bb9a4b52825536a", "filename": "src/test/compile-fail-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -24,7 +24,7 @@ fn main() {\n     let ps = syntax::parse::ParseSess::new();\n     let mut resolver = syntax::ext::base::DummyResolver;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n-        &ps, vec![],\n+        &ps,\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n         &mut resolver);\n     cx.bt_push(syntax::codemap::ExpnInfo {"}, {"sha": "d2a16ac750704de8f3bf49cea7cc6aed7e6db5fb", "filename": "src/test/run-fail-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -27,7 +27,7 @@ fn main() {\n     let ps = syntax::parse::ParseSess::new();\n     let mut resolver = syntax::ext::base::DummyResolver;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n-        &ps, vec![],\n+        &ps,\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n         &mut resolver);\n     cx.bt_push(syntax::codemap::ExpnInfo {"}, {"sha": "ed127b017b6a92cdfe800aadd8a5e2e416942a28", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -67,12 +67,6 @@ fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n     let (sess, cstore) = basic_sess(sysroot);\n     let cfg = build_configuration(&sess, vec![]);\n     let control = CompileController::basic();\n-\n-    compile_input(&sess, &cstore,\n-            cfg,\n-            &Input::Str { name: anon_src(), input: code },\n-            &None,\n-            &Some(output),\n-            None,\n-            &control);\n+    let input = Input::Str { name: anon_src(), input: code };\n+    compile_input(&sess, &cstore, &input, &None, &Some(output), None, &control);\n }"}, {"sha": "a41b34f6a53d0a3e08e5c32a6077b80b00ec414a", "filename": "src/test/run-pass-fulldeps/ast_stmt_expr_attr.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -31,10 +31,7 @@ use std::fmt;\n // Copied out of syntax::util::parser_testing\n \n pub fn string_to_parser<'a>(ps: &'a ParseSess, source_str: String) -> Parser<'a> {\n-    new_parser_from_source_str(ps,\n-                               Vec::new(),\n-                               \"bogofile\".to_string(),\n-                               source_str)\n+    new_parser_from_source_str(ps, \"bogofile\".to_string(), source_str)\n }\n \n fn with_error_checking_parse<'a, T, F>(s: String, ps: &'a ParseSess, f: F) -> PResult<'a, T> where"}, {"sha": "15ec0ccae8fdd243cddb2c9f1f9116b246f1d5bd", "filename": "src/test/run-pass-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -60,7 +60,7 @@ fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> Box<MacResu\n // See Issue #15750\n fn expand_identity(cx: &mut ExtCtxt, _span: Span, tts: &[TokenTree]) -> Box<MacResult + 'static> {\n     // Parse an expression and emit it unchanged.\n-    let mut parser = parse::new_parser_from_tts(cx.parse_sess(), cx.cfg().clone(), tts.to_vec());\n+    let mut parser = parse::new_parser_from_tts(cx.parse_sess(), tts.to_vec());\n     let expr = parser.parse_expr().unwrap();\n     MacEager::expr(quote_expr!(&mut *cx, $expr))\n }"}, {"sha": "4a397621ceb53ebfc5bb31723a4eb8f9a5ee2077", "filename": "src/test/run-pass-fulldeps/compiler-calls.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -47,7 +47,6 @@ impl<'a> CompilerCalls<'a> for TestCalls {\n     fn late_callback(&mut self,\n                      _: &getopts::Matches,\n                      _: &Session,\n-                     _: &ast::CrateConfig,\n                      _: &Input,\n                      _: &Option<PathBuf>,\n                      _: &Option<PathBuf>)"}, {"sha": "7c0c24163fe617a7486fe21cee25ff1206d171b0", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbd24757eb4daf95ebfb0c361216dbaeef5af830/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=cbd24757eb4daf95ebfb0c361216dbaeef5af830", "patch": "@@ -23,7 +23,7 @@ fn main() {\n     let ps = syntax::parse::ParseSess::new();\n     let mut resolver = syntax::ext::base::DummyResolver;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n-        &ps, vec![],\n+        &ps,\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n         &mut resolver);\n     cx.bt_push(syntax::codemap::ExpnInfo {"}]}