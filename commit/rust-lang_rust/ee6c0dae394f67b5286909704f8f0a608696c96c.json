{"sha": "ee6c0dae394f67b5286909704f8f0a608696c96c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlNmMwZGFlMzk0ZjY3YjUyODY5MDk3MDRmOGYwYTYwODY5NmM5NmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-25T09:43:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-25T09:43:59Z"}, "message": "Auto merge of #72562 - RalfJung:rollup-2ngjgwi, r=RalfJung\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #71940 (Add `len` and `slice_from_raw_parts` to `NonNull<[T]>`)\n - #72525 (Miri casts: do not blindly rely on dest type)\n - #72537 (Fix InlineAsmOperand expresions being visited twice during liveness checking)\n - #72544 (librustc_middle: Rename upvars query to upvars_mentioned)\n - #72551 (First draft documenting Debug stability.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "54bba551a09e87274e5bc106a1da0551b8ab2154", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54bba551a09e87274e5bc106a1da0551b8ab2154"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee6c0dae394f67b5286909704f8f0a608696c96c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee6c0dae394f67b5286909704f8f0a608696c96c", "html_url": "https://github.com/rust-lang/rust/commit/ee6c0dae394f67b5286909704f8f0a608696c96c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee6c0dae394f67b5286909704f8f0a608696c96c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "997d953eeec0be62c59ea028c95cd7be49adf58f", "url": "https://api.github.com/repos/rust-lang/rust/commits/997d953eeec0be62c59ea028c95cd7be49adf58f", "html_url": "https://github.com/rust-lang/rust/commit/997d953eeec0be62c59ea028c95cd7be49adf58f"}, {"sha": "7c9fdb332bdca945f15627bd4e16f16dc5972b2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c9fdb332bdca945f15627bd4e16f16dc5972b2c", "html_url": "https://github.com/rust-lang/rust/commit/7c9fdb332bdca945f15627bd4e16f16dc5972b2c"}], "stats": {"total": 348, "additions": 212, "deletions": 136}, "files": [{"sha": "3d90fe1fa2f21623db1648de5c418b3df56f6ba6", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=ee6c0dae394f67b5286909704f8f0a608696c96c", "patch": "@@ -441,6 +441,13 @@ impl Display for Arguments<'_> {\n /// `enum`s, it will use the name of the variant and, if applicable, `(`, then the\n /// `Debug` values of the fields, then `)`.\n ///\n+/// # Stability\n+///\n+/// Derived `Debug` formats are not stable, and so may change with future Rust\n+/// versions. Additionally, `Debug` implementations of types provided by the\n+/// standard library (`libstd`, `libcore`, `liballoc`, etc.) are not stable, and\n+/// may also change with future Rust versions.\n+///\n /// # Examples\n ///\n /// Deriving an implementation:"}, {"sha": "ca13433caec8d518e187b97acad1b5d3479ae0b0", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=ee6c0dae394f67b5286909704f8f0a608696c96c", "patch": "@@ -87,6 +87,8 @@\n #![feature(const_generics)]\n #![feature(const_ptr_offset_from)]\n #![feature(const_result)]\n+#![feature(const_slice_from_raw_parts)]\n+#![feature(const_slice_ptr_len)]\n #![feature(const_type_name)]\n #![feature(custom_inner_attributes)]\n #![feature(decl_macro)]"}, {"sha": "870364a61dd47c9bfbe072c4bf383e52c3826be0", "filename": "src/libcore/ptr/non_null.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=ee6c0dae394f67b5286909704f8f0a608696c96c", "patch": "@@ -142,6 +142,65 @@ impl<T: ?Sized> NonNull<T> {\n     }\n }\n \n+impl<T> NonNull<[T]> {\n+    /// Creates a non-null raw slice from a thin pointer and a length.\n+    ///\n+    /// The `len` argument is the number of **elements**, not the number of bytes.\n+    ///\n+    /// This function is safe, but dereferencing the return value is unsafe.\n+    /// See the documentation of [`slice::from_raw_parts`] for slice safety requirements.\n+    ///\n+    /// [`slice::from_raw_parts`]: ../../std/slice/fn.from_raw_parts.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(nonnull_slice_from_raw_parts)]\n+    ///\n+    /// use std::ptr::NonNull;\n+    ///\n+    /// // create a slice pointer when starting out with a pointer to the first element\n+    /// let mut x = [5, 6, 7];\n+    /// let nonnull_pointer = NonNull::new(x.as_mut_ptr()).unwrap();\n+    /// let slice = NonNull::slice_from_raw_parts(nonnull_pointer, 3);\n+    /// assert_eq!(unsafe { slice.as_ref()[2] }, 7);\n+    /// ```\n+    ///\n+    /// (Note that this example artifically demonstrates a use of this method,\n+    /// but `let slice = NonNull::from(&x[..]);` would be a better way to write code like this.)\n+    #[unstable(feature = \"nonnull_slice_from_raw_parts\", issue = \"71941\")]\n+    #[rustc_const_unstable(feature = \"const_nonnull_slice_from_raw_parts\", issue = \"71941\")]\n+    #[inline]\n+    pub const fn slice_from_raw_parts(data: NonNull<T>, len: usize) -> Self {\n+        // SAFETY: `data` is a `NonNull` pointer which is necessarily non-null\n+        unsafe { Self::new_unchecked(super::slice_from_raw_parts_mut(data.as_ptr(), len)) }\n+    }\n+\n+    /// Returns the length of a non-null raw slice.\n+    ///\n+    /// The returned value is the number of **elements**, not the number of bytes.\n+    ///\n+    /// This function is safe, even when the non-null raw slice cannot be dereferenced to a slice\n+    /// because the pointer does not have a valid address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(slice_ptr_len, nonnull_slice_from_raw_parts)]\n+    ///\n+    /// use std::ptr::NonNull;\n+    ///\n+    /// let slice: NonNull<[i8]> = NonNull::slice_from_raw_parts(NonNull::dangling(), 3);\n+    /// assert_eq!(slice.len(), 3);\n+    /// ```\n+    #[unstable(feature = \"slice_ptr_len\", issue = \"71146\")]\n+    #[rustc_const_unstable(feature = \"const_slice_ptr_len\", issue = \"71146\")]\n+    #[inline]\n+    pub const fn len(self) -> usize {\n+        self.as_ptr().len()\n+    }\n+}\n+\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n impl<T: ?Sized> Clone for NonNull<T> {\n     #[inline]"}, {"sha": "9b9207312e8dddfd938eef398325276e48995f1d", "filename": "src/librustc_middle/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_middle%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_middle%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Farena.rs?ref=ee6c0dae394f67b5286909704f8f0a608696c96c", "patch": "@@ -61,7 +61,7 @@ macro_rules! arena_types {\n             [few] privacy_access_levels: rustc_middle::middle::privacy::AccessLevels,\n             [few] foreign_module: rustc_middle::middle::cstore::ForeignModule,\n             [few] foreign_modules: Vec<rustc_middle::middle::cstore::ForeignModule>,\n-            [] upvars: rustc_data_structures::fx::FxIndexMap<rustc_hir::HirId, rustc_hir::Upvar>,\n+            [] upvars_mentioned: rustc_data_structures::fx::FxIndexMap<rustc_hir::HirId, rustc_hir::Upvar>,\n             [] object_safety_violations: rustc_middle::traits::ObjectSafetyViolation,\n             [] codegen_unit: rustc_middle::mir::mono::CodegenUnit<$tcx>,\n             [] attribute: rustc_ast::ast::Attribute,"}, {"sha": "c279213e5bd0e9f009e8ee8e4b308f5fbaabc3b5", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=ee6c0dae394f67b5286909704f8f0a608696c96c", "patch": "@@ -2439,7 +2439,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             };\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n-                            if let Some(upvars) = tcx.upvars(def_id) {\n+                            if let Some(upvars) = tcx.upvars_mentioned(def_id) {\n                                 for (&var_id, place) in upvars.keys().zip(places) {\n                                     let var_name = tcx.hir().name(var_id);\n                                     struct_fmt.field(&var_name.as_str(), place);\n@@ -2458,7 +2458,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             let name = format!(\"[generator@{:?}]\", tcx.hir().span(hir_id));\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n-                            if let Some(upvars) = tcx.upvars(def_id) {\n+                            if let Some(upvars) = tcx.upvars_mentioned(def_id) {\n                                 for (&var_id, place) in upvars.keys().zip(places) {\n                                     let var_name = tcx.hir().name(var_id);\n                                     struct_fmt.field(&var_name.as_str(), place);"}, {"sha": "2445d484754d0fbfbb45c73cd0661a012423d72e", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=ee6c0dae394f67b5286909704f8f0a608696c96c", "patch": "@@ -1040,7 +1040,7 @@ rustc_queries! {\n             desc { \"generating a postorder list of CrateNums\" }\n         }\n \n-        query upvars(_: DefId) -> Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>> {\n+        query upvars_mentioned(_: DefId) -> Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>> {\n             eval_always\n         }\n         query maybe_unused_trait_import(def_id: LocalDefId) -> bool {"}, {"sha": "031ce6629bf4dfc1ef959cdf8be51aba28188354", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=ee6c0dae394f67b5286909704f8f0a608696c96c", "patch": "@@ -610,7 +610,7 @@ pub trait PrettyPrinter<'tcx>:\n                         let mut sep = \" \";\n                         for (&var_id, upvar_ty) in self\n                             .tcx()\n-                            .upvars(did)\n+                            .upvars_mentioned(did)\n                             .as_ref()\n                             .iter()\n                             .flat_map(|v| v.keys())\n@@ -659,7 +659,7 @@ pub trait PrettyPrinter<'tcx>:\n                         let mut sep = \" \";\n                         for (&var_id, upvar_ty) in self\n                             .tcx()\n-                            .upvars(did)\n+                            .upvars_mentioned(did)\n                             .as_ref()\n                             .iter()\n                             .flat_map(|v| v.keys())"}, {"sha": "ca8e54ea286491d2112bd266a71ab21a1917db80", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=ee6c0dae394f67b5286909704f8f0a608696c96c", "patch": "@@ -377,11 +377,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     self.describe_field_from_ty(&ty, field, variant_index)\n                 }\n                 ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n-                    // `tcx.upvars(def_id)` returns an `Option`, which is `None` in case\n+                    // `tcx.upvars_mentioned(def_id)` returns an `Option`, which is `None` in case\n                     // the closure comes from another crate. But in that case we wouldn't\n                     // be borrowck'ing it, so we can just unwrap:\n-                    let (&var_id, _) =\n-                        self.infcx.tcx.upvars(def_id).unwrap().get_index(field.index()).unwrap();\n+                    let (&var_id, _) = self\n+                        .infcx\n+                        .tcx\n+                        .upvars_mentioned(def_id)\n+                        .unwrap()\n+                        .get_index(field.index())\n+                        .unwrap();\n \n                     self.infcx.tcx.hir().name(var_id).to_string()\n                 }\n@@ -809,7 +814,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let expr = &self.infcx.tcx.hir().expect_expr(hir_id).kind;\n         debug!(\"closure_span: hir_id={:?} expr={:?}\", hir_id, expr);\n         if let hir::ExprKind::Closure(.., body_id, args_span, _) = expr {\n-            for (upvar, place) in self.infcx.tcx.upvars(def_id)?.values().zip(places) {\n+            for (upvar, place) in self.infcx.tcx.upvars_mentioned(def_id)?.values().zip(places) {\n                 match place {\n                     Operand::Copy(place) | Operand::Move(place)\n                         if target_place == place.as_ref() =>"}, {"sha": "0fd695586eb9876e562909e6e16689c5a669a4d1", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 98, "deletions": 92, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=ee6c0dae394f67b5286909704f8f0a608696c96c", "patch": "@@ -1,36 +1,47 @@\n use std::convert::TryFrom;\n \n-use super::{FnVal, ImmTy, Immediate, InterpCx, Machine, OpTy, PlaceTy};\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::{Float, FloatConvert};\n use rustc_ast::ast::FloatTy;\n+use rustc_attr as attr;\n use rustc_middle::mir::interpret::{InterpResult, PointerArithmetic, Scalar};\n use rustc_middle::mir::CastKind;\n use rustc_middle::ty::adjustment::PointerCast;\n-use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_middle::ty::layout::{IntegerExt, TyAndLayout};\n use rustc_middle::ty::{self, Ty, TypeAndMut, TypeFoldable};\n use rustc_span::symbol::sym;\n-use rustc_target::abi::{LayoutOf, Size, Variants};\n+use rustc_target::abi::{Integer, LayoutOf, Variants};\n+\n+use super::{truncate, FnVal, ImmTy, Immediate, InterpCx, Machine, OpTy, PlaceTy};\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn cast(\n         &mut self,\n         src: OpTy<'tcx, M::PointerTag>,\n-        kind: CastKind,\n+        cast_kind: CastKind,\n+        cast_ty: Ty<'tcx>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         use rustc_middle::mir::CastKind::*;\n-        match kind {\n+        // FIXME: In which cases should we trigger UB when the source is uninit?\n+        match cast_kind {\n             Pointer(PointerCast::Unsize) => {\n-                self.unsize_into(src, dest)?;\n+                let cast_ty = self.layout_of(cast_ty)?;\n+                self.unsize_into(src, cast_ty, dest)?;\n             }\n \n-            Misc | Pointer(PointerCast::MutToConstPointer | PointerCast::ArrayToPointer) => {\n+            Misc => {\n                 let src = self.read_immediate(src)?;\n-                let res = self.cast_immediate(src, dest.layout)?;\n+                let res = self.misc_cast(src, cast_ty)?;\n                 self.write_immediate(res, dest)?;\n             }\n \n+            Pointer(PointerCast::MutToConstPointer | PointerCast::ArrayToPointer) => {\n+                // These are NOPs, but can be wide pointers.\n+                let v = self.read_immediate(src)?;\n+                self.write_immediate(*v, dest)?;\n+            }\n+\n             Pointer(PointerCast::ReifyFnPointer) => {\n                 // The src operand does not matter, just its type\n                 match src.layout.ty.kind {\n@@ -61,12 +72,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Pointer(PointerCast::UnsafeFnPointer) => {\n                 let src = self.read_immediate(src)?;\n-                match dest.layout.ty.kind {\n+                match cast_ty.kind {\n                     ty::FnPtr(_) => {\n                         // No change to value\n                         self.write_immediate(*src, dest)?;\n                     }\n-                    _ => bug!(\"fn to unsafe fn cast on {:?}\", dest.layout.ty),\n+                    _ => bug!(\"fn to unsafe fn cast on {:?}\", cast_ty),\n                 }\n             }\n \n@@ -95,25 +106,21 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    fn cast_immediate(\n+    fn misc_cast(\n         &self,\n         src: ImmTy<'tcx, M::PointerTag>,\n-        dest_layout: TyAndLayout<'tcx>,\n+        cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::PointerTag>> {\n         use rustc_middle::ty::TyKind::*;\n-        trace!(\"Casting {:?}: {:?} to {:?}\", *src, src.layout.ty, dest_layout.ty);\n+        trace!(\"Casting {:?}: {:?} to {:?}\", *src, src.layout.ty, cast_ty);\n \n         match src.layout.ty.kind {\n             // Floating point\n             Float(FloatTy::F32) => {\n-                return Ok(self\n-                    .cast_from_float(src.to_scalar()?.to_f32()?, dest_layout.ty)?\n-                    .into());\n+                return Ok(self.cast_from_float(src.to_scalar()?.to_f32()?, cast_ty).into());\n             }\n             Float(FloatTy::F64) => {\n-                return Ok(self\n-                    .cast_from_float(src.to_scalar()?.to_f64()?, dest_layout.ty)?\n-                    .into());\n+                return Ok(self.cast_from_float(src.to_scalar()?.to_f64()?, cast_ty).into());\n             }\n             // The rest is integer/pointer-\"like\", including fn ptr casts and casts from enums that\n             // are represented as integers.\n@@ -128,121 +135,118 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ),\n         }\n \n+        // # First handle non-scalar source values.\n+\n         // Handle cast from a univariant (ZST) enum.\n         match src.layout.variants {\n             Variants::Single { index } => {\n                 if let Some(discr) = src.layout.ty.discriminant_for_variant(*self.tcx, index) {\n                     assert!(src.layout.is_zst());\n                     let discr_layout = self.layout_of(discr.ty)?;\n-                    return Ok(self\n-                        .cast_from_int_like(discr.val, discr_layout, dest_layout)?\n-                        .into());\n+                    return Ok(self.cast_from_scalar(discr.val, discr_layout, cast_ty).into());\n                 }\n             }\n             Variants::Multiple { .. } => {}\n         }\n \n-        // Handle casting the metadata away from a fat pointer.\n-        if src.layout.ty.is_unsafe_ptr()\n-            && dest_layout.ty.is_unsafe_ptr()\n-            && dest_layout.size != src.layout.size\n-        {\n-            assert_eq!(src.layout.size, 2 * self.memory.pointer_size());\n-            assert_eq!(dest_layout.size, self.memory.pointer_size());\n-            assert!(dest_layout.ty.is_unsafe_ptr());\n-            match *src {\n-                Immediate::ScalarPair(data, _) => return Ok(data.into()),\n-                Immediate::Scalar(..) => bug!(\n-                    \"{:?} input to a fat-to-thin cast ({:?} -> {:?})\",\n-                    *src,\n-                    src.layout.ty,\n-                    dest_layout.ty\n-                ),\n-            };\n-        }\n-\n         // Handle casting any ptr to raw ptr (might be a fat ptr).\n-        if src.layout.ty.is_any_ptr() && dest_layout.ty.is_unsafe_ptr() {\n-            // The only possible size-unequal case was handled above.\n-            assert_eq!(src.layout.size, dest_layout.size);\n-            return Ok(*src);\n+        if src.layout.ty.is_any_ptr() && cast_ty.is_unsafe_ptr() {\n+            let dest_layout = self.layout_of(cast_ty)?;\n+            if dest_layout.size == src.layout.size {\n+                // Thin or fat pointer that just hast the ptr kind of target type changed.\n+                return Ok(*src);\n+            } else {\n+                // Casting the metadata away from a fat ptr.\n+                assert_eq!(src.layout.size, 2 * self.memory.pointer_size());\n+                assert_eq!(dest_layout.size, self.memory.pointer_size());\n+                assert!(src.layout.ty.is_unsafe_ptr());\n+                return match *src {\n+                    Immediate::ScalarPair(data, _) => Ok(data.into()),\n+                    Immediate::Scalar(..) => bug!(\n+                        \"{:?} input to a fat-to-thin cast ({:?} -> {:?})\",\n+                        *src,\n+                        src.layout.ty,\n+                        cast_ty\n+                    ),\n+                };\n+            }\n         }\n \n+        // # The remaining source values are scalar.\n+\n         // For all remaining casts, we either\n         // (a) cast a raw ptr to usize, or\n         // (b) cast from an integer-like (including bool, char, enums).\n         // In both cases we want the bits.\n         let bits = self.force_bits(src.to_scalar()?, src.layout.size)?;\n-        Ok(self.cast_from_int_like(bits, src.layout, dest_layout)?.into())\n+        Ok(self.cast_from_scalar(bits, src.layout, cast_ty).into())\n     }\n \n-    fn cast_from_int_like(\n+    pub(super) fn cast_from_scalar(\n         &self,\n-        v: u128, // raw bits\n+        v: u128, // raw bits (there is no ScalarTy so we separate data+layout)\n         src_layout: TyAndLayout<'tcx>,\n-        dest_layout: TyAndLayout<'tcx>,\n-    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+        cast_ty: Ty<'tcx>,\n+    ) -> Scalar<M::PointerTag> {\n         // Let's make sure v is sign-extended *if* it has a signed type.\n-        let signed = src_layout.abi.is_signed();\n+        let signed = src_layout.abi.is_signed(); // Also asserts that abi is `Scalar`.\n         let v = if signed { self.sign_extend(v, src_layout) } else { v };\n-        trace!(\"cast_from_int: {}, {}, {}\", v, src_layout.ty, dest_layout.ty);\n+        trace!(\"cast_from_scalar: {}, {} -> {}\", v, src_layout.ty, cast_ty);\n         use rustc_middle::ty::TyKind::*;\n-        match dest_layout.ty.kind {\n+        match cast_ty.kind {\n             Int(_) | Uint(_) | RawPtr(_) => {\n-                let v = self.truncate(v, dest_layout);\n-                Ok(Scalar::from_uint(v, dest_layout.size))\n+                let size = match cast_ty.kind {\n+                    Int(t) => Integer::from_attr(self, attr::IntType::SignedInt(t)).size(),\n+                    Uint(t) => Integer::from_attr(self, attr::IntType::UnsignedInt(t)).size(),\n+                    RawPtr(_) => self.pointer_size(),\n+                    _ => bug!(),\n+                };\n+                let v = truncate(v, size);\n+                Scalar::from_uint(v, size)\n             }\n \n-            Float(FloatTy::F32) if signed => {\n-                Ok(Scalar::from_f32(Single::from_i128(v as i128).value))\n-            }\n-            Float(FloatTy::F64) if signed => {\n-                Ok(Scalar::from_f64(Double::from_i128(v as i128).value))\n-            }\n-            Float(FloatTy::F32) => Ok(Scalar::from_f32(Single::from_u128(v).value)),\n-            Float(FloatTy::F64) => Ok(Scalar::from_f64(Double::from_u128(v).value)),\n+            Float(FloatTy::F32) if signed => Scalar::from_f32(Single::from_i128(v as i128).value),\n+            Float(FloatTy::F64) if signed => Scalar::from_f64(Double::from_i128(v as i128).value),\n+            Float(FloatTy::F32) => Scalar::from_f32(Single::from_u128(v).value),\n+            Float(FloatTy::F64) => Scalar::from_f64(Double::from_u128(v).value),\n \n             Char => {\n                 // `u8` to `char` cast\n-                Ok(Scalar::from_u32(u8::try_from(v).unwrap().into()))\n+                Scalar::from_u32(u8::try_from(v).unwrap().into())\n             }\n \n             // Casts to bool are not permitted by rustc, no need to handle them here.\n-            _ => bug!(\"invalid int to {:?} cast\", dest_layout.ty),\n+            _ => bug!(\"invalid int to {:?} cast\", cast_ty),\n         }\n     }\n \n-    fn cast_from_float<F>(\n-        &self,\n-        f: F,\n-        dest_ty: Ty<'tcx>,\n-    ) -> InterpResult<'tcx, Scalar<M::PointerTag>>\n+    fn cast_from_float<F>(&self, f: F, dest_ty: Ty<'tcx>) -> Scalar<M::PointerTag>\n     where\n         F: Float + Into<Scalar<M::PointerTag>> + FloatConvert<Single> + FloatConvert<Double>,\n     {\n         use rustc_middle::ty::TyKind::*;\n         match dest_ty.kind {\n             // float -> uint\n             Uint(t) => {\n-                let width = t.bit_width().unwrap_or_else(|| self.pointer_size().bits());\n+                let size = Integer::from_attr(self, attr::IntType::UnsignedInt(t)).size();\n                 // `to_u128` is a saturating cast, which is what we need\n                 // (https://doc.rust-lang.org/nightly/nightly-rustc/rustc_apfloat/trait.Float.html#method.to_i128_r).\n-                let v = f.to_u128(usize::try_from(width).unwrap()).value;\n+                let v = f.to_u128(size.bits_usize()).value;\n                 // This should already fit the bit width\n-                Ok(Scalar::from_uint(v, Size::from_bits(width)))\n+                Scalar::from_uint(v, size)\n             }\n             // float -> int\n             Int(t) => {\n-                let width = t.bit_width().unwrap_or_else(|| self.pointer_size().bits());\n+                let size = Integer::from_attr(self, attr::IntType::SignedInt(t)).size();\n                 // `to_i128` is a saturating cast, which is what we need\n                 // (https://doc.rust-lang.org/nightly/nightly-rustc/rustc_apfloat/trait.Float.html#method.to_i128_r).\n-                let v = f.to_i128(usize::try_from(width).unwrap()).value;\n-                Ok(Scalar::from_int(v, Size::from_bits(width)))\n+                let v = f.to_i128(size.bits_usize()).value;\n+                Scalar::from_int(v, size)\n             }\n             // float -> f32\n-            Float(FloatTy::F32) => Ok(Scalar::from_f32(f.convert(&mut false).value)),\n+            Float(FloatTy::F32) => Scalar::from_f32(f.convert(&mut false).value),\n             // float -> f64\n-            Float(FloatTy::F64) => Ok(Scalar::from_f64(f.convert(&mut false).value)),\n+            Float(FloatTy::F64) => Scalar::from_f64(f.convert(&mut false).value),\n             // That's it.\n             _ => bug!(\"invalid float to {:?} cast\", dest_ty),\n         }\n@@ -254,11 +258,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         dest: PlaceTy<'tcx, M::PointerTag>,\n         // The pointee types\n         source_ty: Ty<'tcx>,\n-        dest_ty: Ty<'tcx>,\n+        cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx> {\n         // A<Struct> -> A<Trait> conversion\n         let (src_pointee_ty, dest_pointee_ty) =\n-            self.tcx.struct_lockstep_tails_erasing_lifetimes(source_ty, dest_ty, self.param_env);\n+            self.tcx.struct_lockstep_tails_erasing_lifetimes(source_ty, cast_ty, self.param_env);\n \n         match (&src_pointee_ty.kind, &dest_pointee_ty.kind) {\n             (&ty::Array(_, length), &ty::Slice(_)) => {\n@@ -286,48 +290,50 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_immediate(val, dest)\n             }\n \n-            _ => bug!(\"invalid unsizing {:?} -> {:?}\", src.layout.ty, dest.layout.ty),\n+            _ => bug!(\"invalid unsizing {:?} -> {:?}\", src.layout.ty, cast_ty),\n         }\n     }\n \n     fn unsize_into(\n         &mut self,\n         src: OpTy<'tcx, M::PointerTag>,\n+        cast_ty: TyAndLayout<'tcx>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        trace!(\"Unsizing {:?} into {:?}\", src, dest);\n-        match (&src.layout.ty.kind, &dest.layout.ty.kind) {\n-            (&ty::Ref(_, s, _), &ty::Ref(_, d, _) | &ty::RawPtr(TypeAndMut { ty: d, .. }))\n-            | (&ty::RawPtr(TypeAndMut { ty: s, .. }), &ty::RawPtr(TypeAndMut { ty: d, .. })) => {\n-                self.unsize_into_ptr(src, dest, s, d)\n+        trace!(\"Unsizing {:?} of type {} into {:?}\", *src, src.layout.ty, cast_ty.ty);\n+        match (&src.layout.ty.kind, &cast_ty.ty.kind) {\n+            (&ty::Ref(_, s, _), &ty::Ref(_, c, _) | &ty::RawPtr(TypeAndMut { ty: c, .. }))\n+            | (&ty::RawPtr(TypeAndMut { ty: s, .. }), &ty::RawPtr(TypeAndMut { ty: c, .. })) => {\n+                self.unsize_into_ptr(src, dest, s, c)\n             }\n             (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n                 assert_eq!(def_a, def_b);\n                 if def_a.is_box() || def_b.is_box() {\n                     if !def_a.is_box() || !def_b.is_box() {\n-                        bug!(\"invalid unsizing between {:?} -> {:?}\", src.layout, dest.layout);\n+                        bug!(\"invalid unsizing between {:?} -> {:?}\", src.layout.ty, cast_ty.ty);\n                     }\n                     return self.unsize_into_ptr(\n                         src,\n                         dest,\n                         src.layout.ty.boxed_ty(),\n-                        dest.layout.ty.boxed_ty(),\n+                        cast_ty.ty.boxed_ty(),\n                     );\n                 }\n \n                 // unsizing of generic struct with pointer fields\n                 // Example: `Arc<T>` -> `Arc<Trait>`\n                 // here we need to increase the size of every &T thin ptr field to a fat ptr\n                 for i in 0..src.layout.fields.count() {\n-                    let dst_field = self.place_field(dest, i)?;\n-                    if dst_field.layout.is_zst() {\n+                    let cast_ty_field = cast_ty.field(self, i)?;\n+                    if cast_ty_field.is_zst() {\n                         continue;\n                     }\n                     let src_field = self.operand_field(src, i)?;\n-                    if src_field.layout.ty == dst_field.layout.ty {\n+                    let dst_field = self.place_field(dest, i)?;\n+                    if src_field.layout.ty == cast_ty_field.ty {\n                         self.copy_op(src_field, dst_field)?;\n                     } else {\n-                        self.unsize_into(src_field, dst_field)?;\n+                        self.unsize_into(src_field, cast_ty_field, dst_field)?;\n                     }\n                 }\n                 Ok(())"}, {"sha": "fd9815975c19f613efa5beca7d398a5149840404", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=ee6c0dae394f67b5286909704f8f0a608696c96c", "patch": "@@ -253,9 +253,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_scalar(Scalar::from_machine_usize(layout.size.bytes(), self), dest)?;\n             }\n \n-            Cast(kind, ref operand, _) => {\n+            Cast(cast_kind, ref operand, cast_ty) => {\n                 let src = self.eval_operand(operand, None)?;\n-                self.cast(src, kind, dest)?;\n+                let cast_ty = self.subst_from_current_frame_and_normalize_erasing_regions(cast_ty);\n+                self.cast(src, cast_kind, cast_ty, dest)?;\n             }\n \n             Discriminant(place) => {"}, {"sha": "114bf5710402f7b79e03a3ffdecce53c30ba0694", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=ee6c0dae394f67b5286909704f8f0a608696c96c", "patch": "@@ -386,7 +386,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n             };\n             let upvars = cx\n                 .tcx\n-                .upvars(def_id)\n+                .upvars_mentioned(def_id)\n                 .iter()\n                 .flat_map(|upvars| upvars.iter())\n                 .zip(substs.upvar_tys())"}, {"sha": "ece78d02512817175db4b8f37ffcbc0ee6bf3d04", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=ee6c0dae394f67b5286909704f8f0a608696c96c", "patch": "@@ -463,7 +463,7 @@ fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr<'tcx>) {\n         hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n             debug!(\"expr {}: path that leads to {:?}\", expr.hir_id, path.res);\n             if let Res::Local(var_hir_id) = path.res {\n-                let upvars = ir.tcx.upvars(ir.body_owner);\n+                let upvars = ir.tcx.upvars_mentioned(ir.body_owner);\n                 if !upvars.map_or(false, |upvars| upvars.contains_key(&var_hir_id)) {\n                     ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n                 }\n@@ -481,8 +481,8 @@ fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr<'tcx>) {\n             // construction site.\n             let mut call_caps = Vec::new();\n             let closure_def_id = ir.tcx.hir().local_def_id(expr.hir_id);\n-            if let Some(upvars) = ir.tcx.upvars(closure_def_id) {\n-                let parent_upvars = ir.tcx.upvars(ir.body_owner);\n+            if let Some(upvars) = ir.tcx.upvars_mentioned(closure_def_id) {\n+                let parent_upvars = ir.tcx.upvars_mentioned(ir.body_owner);\n                 call_caps.extend(upvars.iter().filter_map(|(&var_id, upvar)| {\n                     let has_parent =\n                         parent_upvars.map_or(false, |upvars| upvars.contains_key(&var_id));\n@@ -1364,7 +1364,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     ) -> LiveNode {\n         match path.res {\n             Res::Local(hid) => {\n-                let upvars = self.ir.tcx.upvars(self.ir.body_owner);\n+                let upvars = self.ir.tcx.upvars_mentioned(self.ir.body_owner);\n                 if !upvars.map_or(false, |upvars| upvars.contains_key(&hid)) {\n                     self.access_var(hir_id, hid, succ, acc, path.span)\n                 } else {\n@@ -1460,26 +1460,20 @@ fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr<'tcx>) {\n         hir::ExprKind::InlineAsm(ref asm) => {\n             for op in asm.operands {\n                 match op {\n-                    hir::InlineAsmOperand::In { expr, .. }\n-                    | hir::InlineAsmOperand::Const { expr, .. }\n-                    | hir::InlineAsmOperand::Sym { expr, .. } => this.visit_expr(expr),\n                     hir::InlineAsmOperand::Out { expr, .. } => {\n                         if let Some(expr) = expr {\n                             this.check_place(expr);\n-                            this.visit_expr(expr);\n                         }\n                     }\n                     hir::InlineAsmOperand::InOut { expr, .. } => {\n                         this.check_place(expr);\n-                        this.visit_expr(expr);\n                     }\n-                    hir::InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n-                        this.visit_expr(in_expr);\n+                    hir::InlineAsmOperand::SplitInOut { out_expr, .. } => {\n                         if let Some(out_expr) = out_expr {\n                             this.check_place(out_expr);\n-                            this.visit_expr(out_expr);\n                         }\n                     }\n+                    _ => {}\n                 }\n             }\n         }\n@@ -1535,7 +1529,7 @@ impl<'tcx> Liveness<'_, 'tcx> {\n         match expr.kind {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n                 if let Res::Local(var_hid) = path.res {\n-                    let upvars = self.ir.tcx.upvars(self.ir.body_owner);\n+                    let upvars = self.ir.tcx.upvars_mentioned(self.ir.body_owner);\n                     if !upvars.map_or(false, |upvars| upvars.contains_key(&var_hid)) {\n                         // Assignment to an immutable variable or argument: only legal\n                         // if there is no later assignment. If this local is actually"}, {"sha": "99b4ef9d12fcd2a5872e0a4f764b2587996add7b", "filename": "src/librustc_passes/upvars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_passes%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_passes%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fupvars.rs?ref=ee6c0dae394f67b5286909704f8f0a608696c96c", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::ty::TyCtxt;\n use rustc_span::Span;\n \n pub fn provide(providers: &mut Providers<'_>) {\n-    providers.upvars = |tcx, def_id| {\n+    providers.upvars_mentioned = |tcx, def_id| {\n         if !tcx.is_closure(def_id) {\n             return None;\n         }\n@@ -89,7 +89,7 @@ impl Visitor<'tcx> for CaptureCollector<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         if let hir::ExprKind::Closure(..) = expr.kind {\n             let closure_def_id = self.tcx.hir().local_def_id(expr.hir_id);\n-            if let Some(upvars) = self.tcx.upvars(closure_def_id) {\n+            if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n                 // Every capture of a closure expression is a local in scope,\n                 // that is moved/copied/borrowed into the closure value, and\n                 // for this analysis they are like any other access to a local."}, {"sha": "31992f298080ead60326a5e846cfa4466f745865", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=ee6c0dae394f67b5286909704f8f0a608696c96c", "patch": "@@ -1380,7 +1380,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let mut interior_or_upvar_span = None;\n         let mut interior_extra_info = None;\n \n-        if let Some(upvars) = self.tcx.upvars(generator_did) {\n+        if let Some(upvars) = self.tcx.upvars_mentioned(generator_did) {\n             interior_or_upvar_span = upvars.iter().find_map(|(upvar_id, upvar)| {\n                 let upvar_ty = tables.node_type(*upvar_id);\n                 let upvar_ty = self.resolve_vars_if_possible(&upvar_ty);"}, {"sha": "af93f9bc8c0a79b74a237c592e20bf5a346281b0", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=ee6c0dae394f67b5286909704f8f0a608696c96c", "patch": "@@ -90,18 +90,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             base_substs.extend_to(self.tcx, expr_def_id.to_def_id(), |param, _| match param.kind {\n                 GenericParamDefKind::Lifetime => span_bug!(expr.span, \"closure has lifetime param\"),\n                 GenericParamDefKind::Type { .. } => if param.index as usize == tupled_upvars_idx {\n-                    self.tcx.mk_tup(self.tcx.upvars(expr_def_id).iter().flat_map(|upvars| {\n-                        upvars.iter().map(|(&var_hir_id, _)| {\n-                            // Create type variables (for now) to represent the transformed\n-                            // types of upvars. These will be unified during the upvar\n-                            // inference phase (`upvar.rs`).\n-                            self.infcx.next_ty_var(TypeVariableOrigin {\n-                                // FIXME(eddyb) distinguish upvar inference variables from the rest.\n-                                kind: TypeVariableOriginKind::ClosureSynthetic,\n-                                span: self.tcx.hir().span(var_hir_id),\n+                    self.tcx.mk_tup(self.tcx.upvars_mentioned(expr_def_id).iter().flat_map(\n+                        |upvars| {\n+                            upvars.iter().map(|(&var_hir_id, _)| {\n+                                // Create type variables (for now) to represent the transformed\n+                                // types of upvars. These will be unified during the upvar\n+                                // inference phase (`upvar.rs`).\n+                                self.infcx.next_ty_var(TypeVariableOrigin {\n+                                    // FIXME(eddyb) distinguish upvar inference variables from the rest.\n+                                    kind: TypeVariableOriginKind::ClosureSynthetic,\n+                                    span: self.tcx.hir().span(var_hir_id),\n+                                })\n                             })\n-                        })\n-                    }))\n+                        },\n+                    ))\n                 } else {\n                     // Create type variables (for now) to represent the various\n                     // pieces of information kept in `{Closure,Generic}Substs`."}, {"sha": "8707e4fe84a22807e06cf3095efd65dee3766ba1", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=ee6c0dae394f67b5286909704f8f0a608696c96c", "patch": "@@ -111,7 +111,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             None\n         };\n \n-        if let Some(upvars) = self.tcx.upvars(closure_def_id) {\n+        if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n             let mut upvar_list: FxIndexMap<hir::HirId, ty::UpvarId> =\n                 FxIndexMap::with_capacity_and_hasher(upvars.len(), Default::default());\n             for (&var_hir_id, _) in upvars.iter() {\n@@ -218,7 +218,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let tcx = self.tcx;\n         let closure_def_id = tcx.hir().local_def_id(closure_id);\n \n-        tcx.upvars(closure_def_id)\n+        tcx.upvars_mentioned(closure_def_id)\n             .iter()\n             .flat_map(|upvars| {\n                 upvars.iter().map(|(&var_hir_id, _)| {"}, {"sha": "53973eba22940fba94b2659ed77bf0b22c5f9b57", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=ee6c0dae394f67b5286909704f8f0a608696c96c", "patch": "@@ -539,7 +539,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n         let closure_def_id = self.tcx().hir().local_def_id(closure_expr.hir_id);\n-        if let Some(upvars) = self.tcx().upvars(closure_def_id) {\n+        if let Some(upvars) = self.tcx().upvars_mentioned(closure_def_id) {\n             for &var_id in upvars.keys() {\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath { hir_id: var_id },"}, {"sha": "93d01ccd66f1e1059876a9c1fdbca0c23cf41001", "filename": "src/librustc_typeck/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_typeck%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee6c0dae394f67b5286909704f8f0a608696c96c/src%2Flibrustc_typeck%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fmem_categorization.rs?ref=ee6c0dae394f67b5286909704f8f0a608696c96c", "patch": "@@ -159,7 +159,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             infcx,\n             param_env,\n             body_owner,\n-            upvars: infcx.tcx.upvars(body_owner),\n+            upvars: infcx.tcx.upvars_mentioned(body_owner),\n         }\n     }\n "}]}