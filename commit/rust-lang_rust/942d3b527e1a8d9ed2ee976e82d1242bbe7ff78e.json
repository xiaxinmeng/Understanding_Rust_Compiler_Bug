{"sha": "942d3b527e1a8d9ed2ee976e82d1242bbe7ff78e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0MmQzYjUyN2UxYThkOWVkMmVlOTc2ZTgyZDEyNDJiYmU3ZmY3OGU=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-06-10T03:46:29Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-29T22:41:55Z"}, "message": "std: test impl for using tcp_socket_buf and its reader/writer impls. fails.\n\nneeds work. probably the slice code and/or the way that the tcp_socket_buf\nis wrapped in a shared box", "tree": {"sha": "b59b227459ca4cda76a781a5f768d82531c5d361", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b59b227459ca4cda76a781a5f768d82531c5d361"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/942d3b527e1a8d9ed2ee976e82d1242bbe7ff78e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/942d3b527e1a8d9ed2ee976e82d1242bbe7ff78e", "html_url": "https://github.com/rust-lang/rust/commit/942d3b527e1a8d9ed2ee976e82d1242bbe7ff78e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/942d3b527e1a8d9ed2ee976e82d1242bbe7ff78e/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "099d0802336e513089446db954a9b0dd078b5434", "url": "https://api.github.com/repos/rust-lang/rust/commits/099d0802336e513089446db954a9b0dd078b5434", "html_url": "https://github.com/rust-lang/rust/commit/099d0802336e513089446db954a9b0dd078b5434"}], "stats": {"total": 96, "additions": 91, "deletions": 5}, "files": [{"sha": "06829312849dab72d1d9d33f77610e015cbe3ad2", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 91, "deletions": 5, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/942d3b527e1a8d9ed2ee976e82d1242bbe7ff78e/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942d3b527e1a8d9ed2ee976e82d1242bbe7ff78e/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=942d3b527e1a8d9ed2ee976e82d1242bbe7ff78e", "patch": "@@ -733,7 +733,7 @@ impl tcp_socket for tcp_socket {\n #[doc=\"\n Implementation of `io::reader` iface for a buffered `net::tcp::tcp_socket`\n \"]\n-impl tcp_socket_buf of io::reader for tcp_socket_buf {\n+impl tcp_socket_buf of io::reader for @tcp_socket_buf {\n     fn read_bytes(amt: uint) -> [u8] {\n         let has_amt_available =\n             vec::len((*self).buf) >= amt;\n@@ -748,7 +748,9 @@ impl tcp_socket_buf of io::reader for tcp_socket_buf {\n         else {\n             let read_result = read((*self).sock, 0u);\n             if read_result.is_failure() {\n-                // failure case.. no good answer, yet.\n+                let err_data = read_result.get_err();\n+                log(debug, #fmt(\"ERROR sock_buf as io::reader.read err %? %?\",\n+                                 err_data.err_name, err_data.err_msg));\n                 []\n             }\n             else {\n@@ -779,14 +781,19 @@ impl tcp_socket_buf of io::reader for tcp_socket_buf {\n #[doc=\"\n Implementation of `io::reader` iface for a buffered `net::tcp::tcp_socket`\n \"]\n-impl tcp_socket_buf of io::writer for tcp_socket_buf {\n+impl tcp_socket_buf of io::writer for @tcp_socket_buf {\n     fn write(data: [const u8]/&) unsafe {\n         let socket_data_ptr = ptr::addr_of(**((*self).sock));\n         let write_buf_vec = vec::unpack_const_slice(data) {|ptr, len|\n             [ uv::ll::buf_init(ptr as *u8, len) ]\n         };\n         let write_buf_vec_ptr = ptr::addr_of(write_buf_vec);\n-        write_common_impl(socket_data_ptr, write_buf_vec_ptr);\n+        let w_result = write_common_impl(socket_data_ptr, write_buf_vec_ptr);\n+        if w_result.is_failure() {\n+            let err_data = w_result.get_err();\n+            log(debug, #fmt(\"ERROR sock_buf as io::writer.writer err: %? %?\",\n+                             err_data.err_name, err_data.err_msg));\n+        }\n     }\n     fn seek(dist: int, seek: io::seek_style) {\n       log(debug, #fmt(\"tcp_socket_buf seek stub %? %?\", dist, seek));\n@@ -1204,7 +1211,7 @@ fn ipv4_ip_addr_to_sockaddr_in(input_ip: ip::ip_addr,\n     }\n }\n \n-#[cfg(test)]\n+//#[cfg(test)]\n mod test {\n     // FIXME don't run on fbsd or linux 32 bit (#2064)\n     #[cfg(target_os=\"win32\")]\n@@ -1232,6 +1239,10 @@ mod test {\n             fn test_gl_tcp_server_access_denied() unsafe {\n                 impl_gl_tcp_ipv4_server_access_denied();\n             }\n+            #[test]\n+            fn test_gl_tcp_ipv4_server_client_reader_writer() {\n+                impl_gl_tcp_ipv4_server_client_reader_writer();\n+            }\n \n         }\n         #[cfg(target_arch=\"x86\")]\n@@ -1259,6 +1270,11 @@ mod test {\n             fn test_gl_tcp_server_access_denied() unsafe {\n                 impl_gl_tcp_ipv4_server_access_denied();\n             }\n+            #[test]\n+            #[ignore(cfg(target_os = \"linux\"))]\n+            fn test_gl_tcp_ipv4_server_client_reader_writer() {\n+                impl_gl_tcp_ipv4_server_client_reader_writer();\n+            }\n         }\n     }\n     fn impl_gl_tcp_ipv4_server_and_client() {\n@@ -1400,6 +1416,73 @@ mod test {\n           }\n         }\n     }\n+    fn impl_gl_tcp_ipv4_server_client_reader_writer() {\n+        let iotask = uv::global_loop::get();\n+        let server_ip = \"127.0.0.1\";\n+        let server_port = 8891u;\n+        let expected_req = \"ping\";\n+        let expected_resp = \"pong\";\n+\n+        let server_result_po = comm::port::<str>();\n+        let server_result_ch = comm::chan(server_result_po);\n+\n+        let cont_po = comm::port::<()>();\n+        let cont_ch = comm::chan(cont_po);\n+        // server\n+        task::spawn_sched(task::manual_threads(1u)) {||\n+            let actual_req = comm::listen {|server_ch|\n+                run_tcp_test_server(\n+                    server_ip,\n+                    server_port,\n+                    expected_resp,\n+                    server_ch,\n+                    cont_ch,\n+                    iotask)\n+            };\n+            server_result_ch.send(actual_req);\n+        };\n+        comm::recv(cont_po);\n+        // client\n+        let server_addr = ip::v4::parse_addr(server_ip);\n+        let conn_result = connect(server_addr, server_port, iotask);\n+        if result::is_failure(conn_result) {\n+            assert false;\n+        }\n+        let sock_buf = @socket_buf(result::unwrap(conn_result));\n+        buf_write(sock_buf as io::writer, expected_req);\n+\n+        // so contrived!\n+        let actual_resp = str::as_bytes(expected_resp) {|resp_buf|\n+            buf_read(sock_buf as io::reader,\n+                     vec::len(resp_buf))\n+        };\n+        \n+        let actual_req = comm::recv(server_result_po);\n+        log(debug, #fmt(\"REQ: expected: '%s' actual: '%s'\",\n+                       expected_req, actual_req));\n+        log(debug, #fmt(\"RESP: expected: '%s' actual: '%s'\",\n+                       expected_resp, actual_resp));\n+        assert str::contains(actual_req, expected_req);\n+        assert str::contains(actual_resp, expected_resp);\n+    }\n+\n+    fn buf_write(+w: io::writer, val: str) {\n+        log(debug, #fmt(\"BUF_WRITE: val len %?\", str::len(val)));\n+        str::as_slice(val, 0u, str::len(val) -1u) {|val_slice|\n+            str::byte_slice(val_slice) {|b_slice|\n+                log(debug, #fmt(\"BUF_WRITE: b_slice len %?\",\n+                                vec::len(b_slice)));\n+                w.write(b_slice)\n+            }\n+        }\n+    }\n+\n+    fn buf_read(+r: io::reader, len: uint) -> str {\n+        let new_bytes = r.read_bytes(len);\n+        log(debug, #fmt(\"in buf_read.. new_bytes len: %?\",\n+                        vec::len(new_bytes)));\n+        str::from_bytes(new_bytes)\n+    }\n \n     fn run_tcp_test_server(server_ip: str, server_port: uint, resp: str,\n                           server_ch: comm::chan<str>,\n@@ -1441,6 +1524,9 @@ mod test {\n                         let received_req_bytes = read(sock, 0u);\n                         alt received_req_bytes {\n                           result::ok(data) {\n+                            log(debug, \"SERVER: got REQ str::from_bytes..\");\n+                            log(debug, #fmt(\"SERVER: REQ data len: %?\",\n+                                            vec::len(data)));\n                             server_ch.send(\n                                 str::from_bytes(data));\n                             log(debug, \"SERVER: before write\");"}]}