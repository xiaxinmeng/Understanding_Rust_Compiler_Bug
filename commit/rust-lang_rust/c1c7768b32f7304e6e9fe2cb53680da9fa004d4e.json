{"sha": "c1c7768b32f7304e6e9fe2cb53680da9fa004d4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxYzc3NjhiMzJmNzMwNGU2ZTlmZTJjYjUzNjgwZGE5ZmEwMDRkNGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-06T20:23:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-06T20:23:08Z"}, "message": "auto merge of #7562 : blake2-ppc/rust/deque, r=cmr\n\nFix an assertion in grow when using add_front.\r\n\r\nSpeeds up grow (and the functions that use it) by a lot. We retain the vector instead of creating it anew for each grow. \r\n\r\nThe struct field hi is removed since it is redundant, and all iterators are updated to use a representation closer to the Deque itself, it should make it work even if deque sizes are not powers of two.\r\n\r\nDeque::with_capacity is also implemented, but .reserve() is not yet done.", "tree": {"sha": "14dcee08b93730564549d55846774c35e5cc5e54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14dcee08b93730564549d55846774c35e5cc5e54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1c7768b32f7304e6e9fe2cb53680da9fa004d4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1c7768b32f7304e6e9fe2cb53680da9fa004d4e", "html_url": "https://github.com/rust-lang/rust/commit/c1c7768b32f7304e6e9fe2cb53680da9fa004d4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1c7768b32f7304e6e9fe2cb53680da9fa004d4e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e933b199c69e1b6c32ecb65bb8f06127cfb8312", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e933b199c69e1b6c32ecb65bb8f06127cfb8312", "html_url": "https://github.com/rust-lang/rust/commit/3e933b199c69e1b6c32ecb65bb8f06127cfb8312"}, {"sha": "10c7698d4b43aa9bd9b30df5e0769189d3a83110", "url": "https://api.github.com/repos/rust-lang/rust/commits/10c7698d4b43aa9bd9b30df5e0769189d3a83110", "html_url": "https://github.com/rust-lang/rust/commit/10c7698d4b43aa9bd9b30df5e0769189d3a83110"}], "stats": {"total": 384, "additions": 289, "deletions": 95}, "files": [{"sha": "36ebf295aabaa1f8d9f6364b0ad0372f012a7528", "filename": "src/libextra/deque.rs", "status": "modified", "additions": 288, "deletions": 94, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/c1c7768b32f7304e6e9fe2cb53680da9fa004d4e/src%2Flibextra%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c7768b32f7304e6e9fe2cb53680da9fa004d4e/src%2Flibextra%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdeque.rs?ref=c1c7768b32f7304e6e9fe2cb53680da9fa004d4e", "patch": "@@ -11,17 +11,17 @@\n //! A double-ended queue implemented as a circular buffer\n \n use std::uint;\n-use std::util::replace;\n use std::vec;\n-use std::cast::transmute;\n+use std::iterator::FromIterator;\n \n-static INITIAL_CAPACITY: uint = 32u; // 2^5\n+static INITIAL_CAPACITY: uint = 8u; // 2^3\n+static MINIMUM_CAPACITY: uint = 2u;\n \n #[allow(missing_doc)]\n+#[deriving(Clone)]\n pub struct Deque<T> {\n     priv nelts: uint,\n     priv lo: uint,\n-    priv hi: uint,\n     priv elts: ~[Option<T>]\n }\n \n@@ -39,26 +39,36 @@ impl<T> Mutable for Deque<T> {\n         for self.elts.mut_iter().advance |x| { *x = None }\n         self.nelts = 0;\n         self.lo = 0;\n-        self.hi = 0;\n     }\n }\n \n impl<T> Deque<T> {\n     /// Create an empty Deque\n     pub fn new() -> Deque<T> {\n-        Deque{nelts: 0, lo: 0, hi: 0,\n-              elts: vec::from_fn(INITIAL_CAPACITY, |_| None)}\n+        Deque::with_capacity(INITIAL_CAPACITY)\n+    }\n+\n+    /// Create an empty Deque with space for at least `n` elements.\n+    pub fn with_capacity(n: uint) -> Deque<T> {\n+        Deque{nelts: 0, lo: 0,\n+              elts: vec::from_fn(uint::max(MINIMUM_CAPACITY, n), |_| None)}\n     }\n \n     /// Return a reference to the first element in the deque\n     ///\n     /// Fails if the deque is empty\n-    pub fn peek_front<'a>(&'a self) -> &'a T { get(self.elts, self.lo) }\n+    pub fn peek_front<'a>(&'a self) -> &'a T { get(self.elts, self.raw_index(0)) }\n \n     /// Return a reference to the last element in the deque\n     ///\n     /// Fails if the deque is empty\n-    pub fn peek_back<'a>(&'a self) -> &'a T { get(self.elts, self.hi - 1u) }\n+    pub fn peek_back<'a>(&'a self) -> &'a T {\n+        if self.nelts > 0 {\n+            get(self.elts, self.raw_index(self.nelts - 1))\n+        } else {\n+            fail!(\"peek_back: empty deque\");\n+        }\n+    }\n \n     /// Retrieve an element in the deque by index\n     ///\n@@ -68,16 +78,6 @@ impl<T> Deque<T> {\n         get(self.elts, idx)\n     }\n \n-    /// Iterate over the elements in the deque\n-    pub fn each(&self, f: &fn(&T) -> bool) -> bool {\n-        self.eachi(|_i, e| f(e))\n-    }\n-\n-    /// Iterate over the elements in the deque by index\n-    pub fn eachi(&self, f: &fn(uint, &T) -> bool) -> bool {\n-        uint::range(0, self.nelts, |i| f(i, self.get(i as int)))\n-    }\n-\n     /// Remove and return the first element in the deque\n     ///\n     /// Fails if the deque is empty\n@@ -88,43 +88,39 @@ impl<T> Deque<T> {\n         result\n     }\n \n+    /// Return index in underlying vec for a given logical element index\n+    fn raw_index(&self, idx: uint) -> uint {\n+        raw_index(self.lo, self.elts.len(), idx)\n+    }\n+\n     /// Remove and return the last element in the deque\n     ///\n     /// Fails if the deque is empty\n     pub fn pop_back(&mut self) -> T {\n-        if self.hi == 0u {\n-            self.hi = self.elts.len() - 1u;\n-        } else { self.hi -= 1u; }\n-        let result = self.elts[self.hi].swap_unwrap();\n-        self.elts[self.hi] = None;\n-        self.nelts -= 1u;\n-        result\n+        self.nelts -= 1;\n+        let hi = self.raw_index(self.nelts);\n+        self.elts[hi].swap_unwrap()\n     }\n \n     /// Prepend an element to the deque\n     pub fn add_front(&mut self, t: T) {\n-        let oldlo = self.lo;\n+        if self.nelts == self.elts.len() {\n+            grow(self.nelts, &mut self.lo, &mut self.elts);\n+        }\n         if self.lo == 0u {\n             self.lo = self.elts.len() - 1u;\n         } else { self.lo -= 1u; }\n-        if self.lo == self.hi {\n-            self.elts = grow(self.nelts, oldlo, self.elts);\n-            self.lo = self.elts.len() - 1u;\n-            self.hi = self.nelts;\n-        }\n         self.elts[self.lo] = Some(t);\n         self.nelts += 1u;\n     }\n \n     /// Append an element to the deque\n     pub fn add_back(&mut self, t: T) {\n-        if self.lo == self.hi && self.nelts != 0u {\n-            self.elts = grow(self.nelts, self.lo, self.elts);\n-            self.lo = 0u;\n-            self.hi = self.nelts;\n+        if self.nelts == self.elts.len() {\n+            grow(self.nelts, &mut self.lo, &mut self.elts);\n         }\n-        self.elts[self.hi] = Some(t);\n-        self.hi = (self.hi + 1u) % self.elts.len();\n+        let hi = self.raw_index(self.nelts);\n+        self.elts[hi] = Some(t);\n         self.nelts += 1u;\n     }\n \n@@ -155,107 +151,155 @@ impl<T> Deque<T> {\n \n     /// Front-to-back iterator.\n     pub fn iter<'a>(&'a self) -> DequeIterator<'a, T> {\n-    DequeIterator { idx: self.lo, nelts: self.nelts, used: 0, vec: self.elts }\n+        DequeIterator{index: 0, nelts: self.nelts, elts: self.elts, lo: self.lo}\n     }\n \n     /// Front-to-back iterator which returns mutable values.\n     pub fn mut_iter<'a>(&'a mut self) -> DequeMutIterator<'a, T> {\n-    DequeMutIterator { idx: self.lo, nelts: self.nelts, used: 0, vec: self.elts }\n+        DequeMutIterator{index: 0, nelts: self.nelts, elts: self.elts, lo: self.lo}\n     }\n \n     /// Back-to-front iterator.\n     pub fn rev_iter<'a>(&'a self) -> DequeRevIterator<'a, T> {\n-    DequeRevIterator { idx: self.hi - 1u, nelts: self.nelts, used: 0, vec: self.elts }\n+        DequeRevIterator{index: self.nelts-1, nelts: self.nelts, elts: self.elts,\n+                         lo: self.lo}\n     }\n \n     /// Back-to-front iterator which returns mutable values.\n     pub fn mut_rev_iter<'a>(&'a mut self) -> DequeMutRevIterator<'a, T> {\n-    DequeMutRevIterator { idx: self.hi - 1u, nelts: self.nelts, used: 0, vec: self.elts }\n+        DequeMutRevIterator{index: self.nelts-1, nelts: self.nelts, elts: self.elts,\n+                            lo: self.lo}\n     }\n }\n \n macro_rules! iterator {\n-    (impl $name:ident -> $elem:ty, $step:expr) => {\n+    (impl $name:ident -> $elem:ty, $getter:ident, $step:expr) => {\n         impl<'self, T> Iterator<$elem> for $name<'self, T> {\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n-                if self.used >= self.nelts {\n+                if self.nelts == 0 {\n                     return None;\n                 }\n-                let ret = unsafe {\n-                    match self.vec[self.idx % self.vec.len()] {\n-                        Some(ref e) => Some(transmute(e)),\n-                        None => None\n-                    }\n-                };\n-                self.idx += $step;\n-                self.used += 1;\n-                ret\n+                let raw_index = raw_index(self.lo, self.elts.len(), self.index);\n+                self.index += $step;\n+                self.nelts -= 1;\n+                Some(self.elts[raw_index]. $getter ())\n             }\n         }\n     }\n }\n \n /// Deque iterator\n pub struct DequeIterator<'self, T> {\n-    priv idx: uint,\n+    priv lo: uint,\n     priv nelts: uint,\n-    priv used: uint,\n-    priv vec: &'self [Option<T>]\n+    priv index: uint,\n+    priv elts: &'self [Option<T>],\n }\n-iterator!{impl DequeIterator -> &'self T, 1}\n+iterator!{impl DequeIterator -> &'self T, get_ref, 1}\n \n /// Deque reverse iterator\n pub struct DequeRevIterator<'self, T> {\n-    priv idx: uint,\n+    priv lo: uint,\n     priv nelts: uint,\n-    priv used: uint,\n-    priv vec: &'self [Option<T>]\n+    priv index: uint,\n+    priv elts: &'self [Option<T>],\n }\n-iterator!{impl DequeRevIterator -> &'self T, -1}\n+iterator!{impl DequeRevIterator -> &'self T, get_ref, -1}\n \n /// Deque mutable iterator\n pub struct DequeMutIterator<'self, T> {\n-    priv idx: uint,\n+    priv lo: uint,\n     priv nelts: uint,\n-    priv used: uint,\n-    priv vec: &'self mut [Option<T>]\n-\n+    priv index: uint,\n+    priv elts: &'self mut [Option<T>],\n }\n-iterator!{impl DequeMutIterator -> &'self mut T, 1}\n+iterator!{impl DequeMutIterator -> &'self mut T, get_mut_ref, 1}\n \n /// Deque mutable reverse iterator\n pub struct DequeMutRevIterator<'self, T> {\n-    priv idx: uint,\n+    priv lo: uint,\n     priv nelts: uint,\n-    priv used: uint,\n-    priv vec: &'self mut [Option<T>]\n+    priv index: uint,\n+    priv elts: &'self mut [Option<T>],\n }\n-iterator!{impl DequeMutRevIterator -> &'self mut T, -1}\n+iterator!{impl DequeMutRevIterator -> &'self mut T, get_mut_ref, -1}\n \n /// Grow is only called on full elts, so nelts is also len(elts), unlike\n /// elsewhere.\n-fn grow<T>(nelts: uint, lo: uint, elts: &mut [Option<T>]) -> ~[Option<T>] {\n+fn grow<T>(nelts: uint, loptr: &mut uint, elts: &mut ~[Option<T>]) {\n     assert_eq!(nelts, elts.len());\n-    let mut rv = ~[];\n-\n-    do rv.grow_fn(nelts + 1) |i| {\n-        replace(&mut elts[(lo + i) % nelts], None)\n+    let lo = *loptr;\n+    let newlen = nelts * 2;\n+    elts.reserve(newlen);\n+\n+    /* fill with None */\n+    for uint::range(elts.len(), elts.capacity()) |_| {\n+        elts.push(None);\n+    }\n+\n+    /*\n+      Move the shortest half into the newly reserved area.\n+      lo ---->|\n+      nelts ----------->|\n+        [o o o|o o o o o]\n+      A [. . .|o o o o o o o o|. . . . .]\n+      B [o o o|. . . . . . . .|o o o o o]\n+     */\n+\n+    assert!(newlen - nelts/2 >= nelts);\n+    if lo <= (nelts - lo) { // A\n+        for uint::range(0, lo) |i| {\n+            elts.swap(i, nelts + i);\n+        }\n+    } else {                // B\n+        for uint::range(lo, nelts) |i| {\n+            elts.swap(i, newlen - nelts + i);\n+        }\n+        *loptr += newlen - nelts;\n     }\n-\n-    rv\n }\n \n fn get<'r, T>(elts: &'r [Option<T>], i: uint) -> &'r T {\n     match elts[i] { Some(ref t) => t, _ => fail!() }\n }\n \n+/// Return index in underlying vec for a given logical element index\n+fn raw_index(lo: uint, len: uint, index: uint) -> uint {\n+    if lo >= len - index {\n+        lo + index - len\n+    } else {\n+        lo + index\n+    }\n+}\n+\n+impl<A: Eq> Eq for Deque<A> {\n+    fn eq(&self, other: &Deque<A>) -> bool {\n+        self.nelts == other.nelts &&\n+            self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n+    }\n+    fn ne(&self, other: &Deque<A>) -> bool {\n+        !self.eq(other)\n+    }\n+}\n+\n+impl<A, T: Iterator<A>> FromIterator<A, T> for Deque<A> {\n+    fn from_iterator(iterator: &mut T) -> Deque<A> {\n+        let mut deq = Deque::new();\n+        for iterator.advance |elt| {\n+            deq.add_back(elt);\n+        }\n+        deq\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n     use std::cmp::Eq;\n     use std::kinds::Copy;\n-    use std::int;\n+    use std::{int, uint};\n+    use extra::test;\n \n     #[test]\n     fn test_simple() {\n@@ -369,6 +413,61 @@ mod tests {\n         assert_eq!(copy *deq.get(3), copy d);\n     }\n \n+    #[test]\n+    fn test_add_front_grow() {\n+        let mut deq = Deque::new();\n+        for int::range(0, 66) |i| {\n+            deq.add_front(i);\n+        }\n+        assert_eq!(deq.len(), 66);\n+\n+        for int::range(0, 66) |i| {\n+            assert_eq!(*deq.get(i), 65 - i);\n+        }\n+\n+        let mut deq = Deque::new();\n+        for int::range(0, 66) |i| {\n+            deq.add_back(i);\n+        }\n+\n+        for int::range(0, 66) |i| {\n+            assert_eq!(*deq.get(i), i);\n+        }\n+    }\n+\n+    #[bench]\n+    fn bench_new(b: &mut test::BenchHarness) {\n+        do b.iter {\n+            let _ = Deque::new::<u64>();\n+        }\n+    }\n+\n+    #[bench]\n+    fn bench_add_back(b: &mut test::BenchHarness) {\n+        let mut deq = Deque::new();\n+        do b.iter {\n+            deq.add_back(0);\n+        }\n+    }\n+\n+    #[bench]\n+    fn bench_add_front(b: &mut test::BenchHarness) {\n+        let mut deq = Deque::new();\n+        do b.iter {\n+            deq.add_front(0);\n+        }\n+    }\n+\n+    #[bench]\n+    fn bench_grow(b: &mut test::BenchHarness) {\n+        let mut deq = Deque::new();\n+        do b.iter {\n+            for 65.times {\n+                deq.add_front(1);\n+            }\n+        }\n+    }\n+\n     #[deriving(Eq)]\n     enum Taggy { One(int), Two(int, int), Three(int, int, int), }\n \n@@ -417,22 +516,13 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_eachi() {\n-        let mut deq = Deque::new();\n-        deq.add_back(1);\n-        deq.add_back(2);\n-        deq.add_back(3);\n-\n-        for deq.eachi |i, e| {\n-            assert_eq!(*e, i + 1);\n-        }\n-\n-        deq.pop_front();\n-\n-        for deq.eachi |i, e| {\n-            assert_eq!(*e, i + 2);\n-        }\n-\n+    fn test_with_capacity() {\n+        let mut d = Deque::with_capacity(0);\n+        d.add_back(1);\n+        assert_eq!(d.len(), 1);\n+        let mut d = Deque::with_capacity(50);\n+        d.add_back(1);\n+        assert_eq!(d.len(), 1);\n     }\n \n     #[test]\n@@ -462,6 +552,8 @@ mod tests {\n     #[test]\n     fn test_iter() {\n         let mut d = Deque::new();\n+        assert_eq!(d.iter().next(), None);\n+\n         for int::range(0,5) |i| {\n             d.add_back(i);\n         }\n@@ -476,6 +568,8 @@ mod tests {\n     #[test]\n     fn test_rev_iter() {\n         let mut d = Deque::new();\n+        assert_eq!(d.rev_iter().next(), None);\n+\n         for int::range(0,5) |i| {\n             d.add_back(i);\n         }\n@@ -486,4 +580,104 @@ mod tests {\n         }\n         assert_eq!(d.rev_iter().collect::<~[&int]>(), ~[&4,&3,&2,&1,&0,&6,&7,&8]);\n     }\n+\n+    #[test]\n+    fn test_mut_iter() {\n+        let mut d = Deque::new();\n+        assert!(d.mut_iter().next().is_none());\n+\n+        for uint::range(0,3) |i| {\n+            d.add_front(i);\n+        }\n+\n+        for d.mut_iter().enumerate().advance |(i, elt)| {\n+            assert_eq!(*elt, 2 - i);\n+            *elt = i;\n+        }\n+\n+        {\n+            let mut it = d.mut_iter();\n+            assert_eq!(*it.next().unwrap(), 0);\n+            assert_eq!(*it.next().unwrap(), 1);\n+            assert_eq!(*it.next().unwrap(), 2);\n+            assert!(it.next().is_none());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_mut_rev_iter() {\n+        let mut d = Deque::new();\n+        assert!(d.mut_rev_iter().next().is_none());\n+\n+        for uint::range(0,3) |i| {\n+            d.add_front(i);\n+        }\n+\n+        for d.mut_rev_iter().enumerate().advance |(i, elt)| {\n+            assert_eq!(*elt, i);\n+            *elt = i;\n+        }\n+\n+        {\n+            let mut it = d.mut_rev_iter();\n+            assert_eq!(*it.next().unwrap(), 0);\n+            assert_eq!(*it.next().unwrap(), 1);\n+            assert_eq!(*it.next().unwrap(), 2);\n+            assert!(it.next().is_none());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_from_iterator() {\n+        use std::iterator;\n+        let v = ~[1,2,3,4,5,6,7];\n+        let deq: Deque<int> = v.iter().transform(|&x| x).collect();\n+        let u: ~[int] = deq.iter().transform(|&x| x).collect();\n+        assert_eq!(u, v);\n+\n+        let mut seq = iterator::Counter::new(0u, 2).take_(256);\n+        let deq: Deque<uint> = seq.collect();\n+        for deq.iter().enumerate().advance |(i, &x)| {\n+            assert_eq!(2*i, x);\n+        }\n+        assert_eq!(deq.len(), 256);\n+    }\n+\n+    #[test]\n+    fn test_clone() {\n+        let mut d = Deque::new();\n+        d.add_front(17);\n+        d.add_front(42);\n+        d.add_back(137);\n+        d.add_back(137);\n+        assert_eq!(d.len(), 4u);\n+        let mut e = d.clone();\n+        assert_eq!(e.len(), 4u);\n+        while !d.is_empty() {\n+            assert_eq!(d.pop_back(), e.pop_back());\n+        }\n+        assert_eq!(d.len(), 0u);\n+        assert_eq!(e.len(), 0u);\n+    }\n+\n+    #[test]\n+    fn test_eq() {\n+        let mut d = Deque::new();\n+        assert_eq!(&d, &Deque::with_capacity(0));\n+        d.add_front(137);\n+        d.add_front(17);\n+        d.add_front(42);\n+        d.add_back(137);\n+        let mut e = Deque::with_capacity(0);\n+        e.add_back(42);\n+        e.add_back(17);\n+        e.add_back(137);\n+        e.add_back(137);\n+        assert_eq!(&e, &d);\n+        e.pop_back();\n+        e.add_back(0);\n+        assert!(e != d);\n+        e.clear();\n+        assert_eq!(e, Deque::new());\n+    }\n }"}, {"sha": "b1383948bf72b221fc1fe305a4b59eaddff84829", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1c7768b32f7304e6e9fe2cb53680da9fa004d4e/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c7768b32f7304e6e9fe2cb53680da9fa004d4e/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=c1c7768b32f7304e6e9fe2cb53680da9fa004d4e", "patch": "@@ -682,7 +682,7 @@ impl<\n > Encodable<S> for Deque<T> {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n-            for self.eachi |i, e| {\n+            for self.iter().enumerate().advance |(i, e)| {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n             }\n         }"}]}