{"sha": "ff6422d7a392acfc8af28994d65af2bbaecea4f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmNjQyMmQ3YTM5MmFjZmM4YWYyODk5NGQ2NWFmMmJiYWVjZWE0ZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-19T02:37:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-19T02:37:37Z"}, "message": "Auto merge of #54318 - nnethercote:use-HybridBitSet-in-SparseBitMatrix, r=pnkfelix\n\nUse `HybridBitSet` in `SparseBitMatrix`.\n\nThis fixes most of the remaining NLL memory regression.\n\nr? @pnkfelix, because you reviewed #54286.\ncc @nikomatsakis, because NLL\ncc @Mark-Simulacrum, because this removes `array_vec.rs`\ncc @lqd, because this massively improves `unic-ucd-name`, and probably other public crates", "tree": {"sha": "f8ca0e5126de7beb4f9780d60eebef130e61c03d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8ca0e5126de7beb4f9780d60eebef130e61c03d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff6422d7a392acfc8af28994d65af2bbaecea4f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff6422d7a392acfc8af28994d65af2bbaecea4f6", "html_url": "https://github.com/rust-lang/rust/commit/ff6422d7a392acfc8af28994d65af2bbaecea4f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff6422d7a392acfc8af28994d65af2bbaecea4f6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f376771cffad044b0c5a83d7055c3297aa65d42", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f376771cffad044b0c5a83d7055c3297aa65d42", "html_url": "https://github.com/rust-lang/rust/commit/8f376771cffad044b0c5a83d7055c3297aa65d42"}, {"sha": "154be2c98cf348de080ce951df3f73649e8bb1a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/154be2c98cf348de080ce951df3f73649e8bb1a6", "html_url": "https://github.com/rust-lang/rust/commit/154be2c98cf348de080ce951df3f73649e8bb1a6"}], "stats": {"total": 602, "additions": 222, "deletions": 380}, "files": [{"sha": "45fb56570618093f556f85134daa61a450e0da69", "filename": "src/librustc_data_structures/array_vec.rs", "status": "removed", "additions": 0, "deletions": 305, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/8f376771cffad044b0c5a83d7055c3297aa65d42/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f376771cffad044b0c5a83d7055c3297aa65d42/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=8f376771cffad044b0c5a83d7055c3297aa65d42", "patch": "@@ -1,305 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A stack-allocated vector, allowing storage of N elements on the stack.\n-\n-use std::marker::Unsize;\n-use std::iter::Extend;\n-use std::ptr::{self, drop_in_place, NonNull};\n-use std::ops::{Deref, DerefMut, Range};\n-use std::hash::{Hash, Hasher};\n-use std::slice;\n-use std::fmt;\n-use std::mem;\n-use std::mem::ManuallyDrop;\n-use std::ops::Bound::{Excluded, Included, Unbounded};\n-use std::ops::RangeBounds;\n-\n-pub unsafe trait Array {\n-    type Element;\n-    type PartialStorage: Unsize<[ManuallyDrop<Self::Element>]>;\n-    const LEN: usize;\n-}\n-\n-unsafe impl<T> Array for [T; 1] {\n-    type Element = T;\n-    type PartialStorage = [ManuallyDrop<T>; 1];\n-    const LEN: usize = 1;\n-}\n-\n-unsafe impl<T> Array for [T; 8] {\n-    type Element = T;\n-    type PartialStorage = [ManuallyDrop<T>; 8];\n-    const LEN: usize = 8;\n-}\n-\n-unsafe impl<T> Array for [T; 32] {\n-    type Element = T;\n-    type PartialStorage = [ManuallyDrop<T>; 32];\n-    const LEN: usize = 32;\n-}\n-\n-pub struct ArrayVec<A: Array> {\n-    count: usize,\n-    values: A::PartialStorage\n-}\n-\n-impl<A> Hash for ArrayVec<A>\n-    where A: Array,\n-          A::Element: Hash {\n-    fn hash<H>(&self, state: &mut H) where H: Hasher {\n-        (&self[..]).hash(state);\n-    }\n-}\n-\n-impl<A> Clone for ArrayVec<A>\n-    where A: Array,\n-          A::Element: Clone {\n-    fn clone(&self) -> Self {\n-        let mut v = ArrayVec::new();\n-        v.extend(self.iter().cloned());\n-        v\n-    }\n-}\n-\n-impl<A: Array> ArrayVec<A> {\n-    pub fn new() -> Self {\n-        ArrayVec {\n-            count: 0,\n-            values: unsafe { ::std::mem::uninitialized() },\n-        }\n-    }\n-\n-    pub fn len(&self) -> usize {\n-        self.count\n-    }\n-\n-    pub unsafe fn set_len(&mut self, len: usize) {\n-        self.count = len;\n-    }\n-\n-    /// Panics when the stack vector is full.\n-    pub fn push(&mut self, el: A::Element) {\n-        let arr = &mut self.values as &mut [ManuallyDrop<_>];\n-        arr[self.count] = ManuallyDrop::new(el);\n-        self.count += 1;\n-    }\n-\n-    pub fn pop(&mut self) -> Option<A::Element> {\n-        if self.count > 0 {\n-            let arr = &mut self.values as &mut [ManuallyDrop<_>];\n-            self.count -= 1;\n-            unsafe {\n-                let value = ptr::read(&*arr[self.count]);\n-                Some(value)\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn drain<R>(&mut self, range: R) -> Drain<A>\n-        where R: RangeBounds<usize>\n-    {\n-        // Memory safety\n-        //\n-        // When the Drain is first created, it shortens the length of\n-        // the source vector to make sure no uninitialized or moved-from elements\n-        // are accessible at all if the Drain's destructor never gets to run.\n-        //\n-        // Drain will ptr::read out the values to remove.\n-        // When finished, remaining tail of the vec is copied back to cover\n-        // the hole, and the vector length is restored to the new length.\n-        //\n-        let len = self.len();\n-        let start = match range.start_bound() {\n-            Included(&n) => n,\n-            Excluded(&n) => n + 1,\n-            Unbounded    => 0,\n-        };\n-        let end = match range.end_bound() {\n-            Included(&n) => n + 1,\n-            Excluded(&n) => n,\n-            Unbounded    => len,\n-        };\n-        assert!(start <= end);\n-        assert!(end <= len);\n-\n-        unsafe {\n-            // set self.vec length's to start, to be safe in case Drain is leaked\n-            self.set_len(start);\n-            // Use the borrow in the IterMut to indicate borrowing behavior of the\n-            // whole Drain iterator (like &mut T).\n-            let range_slice = {\n-                let arr = &mut self.values as &mut [ManuallyDrop<<A as Array>::Element>];\n-                slice::from_raw_parts_mut(arr.as_mut_ptr().add(start),\n-                                          end - start)\n-            };\n-            Drain {\n-                tail_start: end,\n-                tail_len: len - end,\n-                iter: range_slice.iter(),\n-                array_vec: NonNull::from(self),\n-            }\n-        }\n-    }\n-}\n-\n-impl<A> Default for ArrayVec<A>\n-    where A: Array {\n-    fn default() -> Self {\n-        ArrayVec::new()\n-    }\n-}\n-\n-impl<A> fmt::Debug for ArrayVec<A>\n-    where A: Array,\n-          A::Element: fmt::Debug {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self[..].fmt(f)\n-    }\n-}\n-\n-impl<A: Array> Deref for ArrayVec<A> {\n-    type Target = [A::Element];\n-    fn deref(&self) -> &Self::Target {\n-        unsafe {\n-            slice::from_raw_parts(&self.values as *const _ as *const A::Element, self.count)\n-        }\n-    }\n-}\n-\n-impl<A: Array> DerefMut for ArrayVec<A> {\n-    fn deref_mut(&mut self) -> &mut [A::Element] {\n-        unsafe {\n-            slice::from_raw_parts_mut(&mut self.values as *mut _ as *mut A::Element, self.count)\n-        }\n-    }\n-}\n-\n-impl<A: Array> Drop for ArrayVec<A> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            drop_in_place(&mut self[..])\n-        }\n-    }\n-}\n-\n-impl<A: Array> Extend<A::Element> for ArrayVec<A> {\n-    fn extend<I>(&mut self, iter: I) where I: IntoIterator<Item=A::Element> {\n-        for el in iter {\n-            self.push(el);\n-        }\n-    }\n-}\n-\n-pub struct Iter<A: Array> {\n-    indices: Range<usize>,\n-    store: A::PartialStorage,\n-}\n-\n-impl<A: Array> Drop for Iter<A> {\n-    fn drop(&mut self) {\n-        self.for_each(drop);\n-    }\n-}\n-\n-impl<A: Array> Iterator for Iter<A> {\n-    type Item = A::Element;\n-\n-    fn next(&mut self) -> Option<A::Element> {\n-        let arr = &self.store as &[ManuallyDrop<_>];\n-        unsafe {\n-            self.indices.next().map(|i| ptr::read(&*arr[i]))\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.indices.size_hint()\n-    }\n-}\n-\n-pub struct Drain<'a, A: Array>\n-        where A::Element: 'a\n-{\n-    tail_start: usize,\n-    tail_len: usize,\n-    iter: slice::Iter<'a, ManuallyDrop<A::Element>>,\n-    array_vec: NonNull<ArrayVec<A>>,\n-}\n-\n-impl<'a, A: Array> Iterator for Drain<'a, A> {\n-    type Item = A::Element;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A::Element> {\n-        self.iter.next().map(|elt| unsafe { ptr::read(&**elt) })\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-impl<'a, A: Array> Drop for Drain<'a, A> {\n-    fn drop(&mut self) {\n-        // exhaust self first\n-        self.for_each(drop);\n-\n-        if self.tail_len > 0 {\n-            unsafe {\n-                let source_array_vec: &mut ArrayVec<A> = self.array_vec.as_mut();\n-                // memmove back untouched tail, update to new length\n-                let start = source_array_vec.len();\n-                let tail = self.tail_start;\n-                {\n-                    let arr =\n-                        &mut source_array_vec.values as &mut [ManuallyDrop<<A as Array>::Element>];\n-                    let src = arr.as_ptr().add(tail);\n-                    let dst = arr.as_mut_ptr().add(start);\n-                    ptr::copy(src, dst, self.tail_len);\n-                };\n-                source_array_vec.set_len(start + self.tail_len);\n-            }\n-        }\n-    }\n-}\n-\n-impl<A: Array> IntoIterator for ArrayVec<A> {\n-    type Item = A::Element;\n-    type IntoIter = Iter<A>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        let store = unsafe {\n-            ptr::read(&self.values)\n-        };\n-        let indices = 0..self.count;\n-        mem::forget(self);\n-        Iter {\n-            indices,\n-            store,\n-        }\n-    }\n-}\n-\n-impl<'a, A: Array> IntoIterator for &'a ArrayVec<A> {\n-    type Item = &'a A::Element;\n-    type IntoIter = slice::Iter<'a, A::Element>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.iter()\n-    }\n-}\n-\n-impl<'a, A: Array> IntoIterator for &'a mut ArrayVec<A> {\n-    type Item = &'a mut A::Element;\n-    type IntoIter = slice::IterMut<'a, A::Element>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.iter_mut()\n-    }\n-}"}, {"sha": "9eb8d0afd46ecf9d7e00e06b5d259928d50eed93", "filename": "src/librustc_data_structures/bit_set.rs", "status": "modified", "additions": 210, "deletions": 62, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/ff6422d7a392acfc8af28994d65af2bbaecea4f6/src%2Flibrustc_data_structures%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff6422d7a392acfc8af28994d65af2bbaecea4f6/src%2Flibrustc_data_structures%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set.rs?ref=ff6422d7a392acfc8af28994d65af2bbaecea4f6", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use array_vec::ArrayVec;\n use indexed_vec::{Idx, IndexVec};\n use rustc_serialize;\n+use smallvec::SmallVec;\n use std::fmt;\n use std::iter;\n use std::marker::PhantomData;\n@@ -61,21 +61,21 @@ impl<T: Idx> BitSet<T> {\n     }\n \n     /// Sets all elements up to and including `size`.\n-    pub fn set_up_to(&mut self, bit: usize) {\n+    pub fn set_up_to(&mut self, elem: usize) {\n         for word in &mut self.words {\n             *word = !0;\n         }\n-        self.clear_above(bit);\n+        self.clear_above(elem);\n     }\n \n-    /// Clear all elements above `bit`.\n-    fn clear_above(&mut self, bit: usize) {\n-        let first_clear_block = bit / WORD_BITS;\n+    /// Clear all elements above `elem`.\n+    fn clear_above(&mut self, elem: usize) {\n+        let first_clear_block = elem / WORD_BITS;\n \n         if first_clear_block < self.words.len() {\n-            // Within `first_clear_block`, the `bit % WORD_BITS` LSBs should\n+            // Within `first_clear_block`, the `elem % WORD_BITS` LSBs should\n             // remain.\n-            let mask = (1 << (bit % WORD_BITS)) - 1;\n+            let mask = (1 << (elem % WORD_BITS)) - 1;\n             self.words[first_clear_block] &= mask;\n \n             // All the blocks above `first_clear_block` are fully cleared.\n@@ -96,10 +96,10 @@ impl<T: Idx> BitSet<T> {\n         self.words.iter().map(|e| e.count_ones() as usize).sum()\n     }\n \n-    /// True if `self` contains the bit `bit`.\n+    /// True if `self` contains `elem`.\n     #[inline]\n-    pub fn contains(&self, bit: T) -> bool {\n-        let (word_index, mask) = word_index_and_mask(bit);\n+    pub fn contains(&self, elem: T) -> bool {\n+        let (word_index, mask) = word_index_and_mask(elem);\n         (self.words[word_index] & mask) != 0\n     }\n \n@@ -118,10 +118,10 @@ impl<T: Idx> BitSet<T> {\n         self.words.iter().all(|a| *a == 0)\n     }\n \n-    /// Insert a bit. Returns true if the bit has changed.\n+    /// Insert `elem`. Returns true if the set has changed.\n     #[inline]\n-    pub fn insert(&mut self, bit: T) -> bool {\n-        let (word_index, mask) = word_index_and_mask(bit);\n+    pub fn insert(&mut self, elem: T) -> bool {\n+        let (word_index, mask) = word_index_and_mask(elem);\n         let word_ref = &mut self.words[word_index];\n         let word = *word_ref;\n         let new_word = word | mask;\n@@ -136,10 +136,10 @@ impl<T: Idx> BitSet<T> {\n         }\n     }\n \n-    /// Returns true if the bit has changed.\n+    /// Returns true if the set has changed.\n     #[inline]\n-    pub fn remove(&mut self, bit: T) -> bool {\n-        let (word_index, mask) = word_index_and_mask(bit);\n+    pub fn remove(&mut self, elem: T) -> bool {\n+        let (word_index, mask) = word_index_and_mask(elem);\n         let word_ref = &mut self.words[word_index];\n         let word = *word_ref;\n         let new_word = word & !mask;\n@@ -320,42 +320,52 @@ fn bitwise<Op>(out_vec: &mut [Word], in_vec: &[Word], op: Op) -> bool\n const SPARSE_MAX: usize = 8;\n \n /// A fixed-size bitset type with a sparse representation and a maximum of\n-/// SPARSE_MAX elements. The elements are stored as an unsorted vector with no\n-/// duplicates.\n+/// `SPARSE_MAX` elements. The elements are stored as a sorted `SmallVec` with\n+/// no duplicates; although `SmallVec` can spill its elements to the heap, that\n+/// never happens within this type because of the `SPARSE_MAX` limit.\n ///\n-/// This type is used by HybridBitSet; do not use directly.\n+/// This type is used by `HybridBitSet`; do not use directly.\n #[derive(Clone, Debug)]\n-pub struct SparseBitSet<T: Idx>(ArrayVec<[T; SPARSE_MAX]>);\n+pub struct SparseBitSet<T: Idx>(SmallVec<[T; SPARSE_MAX]>);\n \n impl<T: Idx> SparseBitSet<T> {\n     fn new_empty() -> Self {\n-        SparseBitSet(ArrayVec::new())\n+        SparseBitSet(SmallVec::new())\n     }\n \n     fn len(&self) -> usize {\n         self.0.len()\n     }\n \n+    fn is_empty(&self) -> bool {\n+        self.0.len() == 0\n+    }\n+\n     fn contains(&self, elem: T) -> bool {\n         self.0.contains(&elem)\n     }\n \n     fn insert(&mut self, elem: T) -> bool {\n-        // Ensure there are no duplicates.\n-        if self.0.contains(&elem) {\n-            false\n+        assert!(self.len() < SPARSE_MAX);\n+        if let Some(i) = self.0.iter().position(|&e| e >= elem) {\n+            if self.0[i] == elem {\n+                // `elem` is already in the set.\n+                false\n+            } else {\n+                // `elem` is smaller than one or more existing elements.\n+                self.0.insert(i, elem);\n+                true\n+            }\n         } else {\n+            // `elem` is larger than all existing elements.\n             self.0.push(elem);\n             true\n         }\n     }\n \n     fn remove(&mut self, elem: T) -> bool {\n         if let Some(i) = self.0.iter().position(|&e| e == elem) {\n-            // Swap the found element to the end, then pop it.\n-            let len = self.0.len();\n-            self.0.swap(i, len - 1);\n-            self.0.pop();\n+            self.0.remove(i);\n             true\n         } else {\n             false\n@@ -396,8 +406,8 @@ impl<T: Idx> SubtractFromBitSet<T> for SparseBitSet<T> {\n }\n \n /// A fixed-size bitset type with a hybrid representation: sparse when there\n-/// are up to a SPARSE_MAX elements in the set, but dense when there are more\n-/// than SPARSE_MAX.\n+/// are up to a `SPARSE_MAX` elements in the set, but dense when there are more\n+/// than `SPARSE_MAX`.\n ///\n /// This type is especially efficient for sets that typically have a small\n /// number of elements, but a large `domain_size`, and are cleared frequently.\n@@ -411,15 +421,28 @@ pub enum HybridBitSet<T: Idx> {\n }\n \n impl<T: Idx> HybridBitSet<T> {\n+    // FIXME: This function is used in conjunction with `mem::replace()` in\n+    // several pieces of awful code below. I can't work out how else to appease\n+    // the borrow checker.\n+    fn dummy() -> Self {\n+        // The cheapest HybridBitSet to construct, which is only used to get\n+        // around the borrow checker.\n+        HybridBitSet::Sparse(SparseBitSet::new_empty(), 0)\n+    }\n+\n     pub fn new_empty(domain_size: usize) -> Self {\n         HybridBitSet::Sparse(SparseBitSet::new_empty(), domain_size)\n     }\n \n-    pub fn clear(&mut self) {\n-        let domain_size = match *self {\n+    pub fn domain_size(&self) -> usize {\n+        match *self {\n             HybridBitSet::Sparse(_, size) => size,\n             HybridBitSet::Dense(_, size) => size,\n-        };\n+        }\n+    }\n+\n+    pub fn clear(&mut self) {\n+        let domain_size = self.domain_size();\n         *self = HybridBitSet::new_empty(domain_size);\n     }\n \n@@ -430,6 +453,22 @@ impl<T: Idx> HybridBitSet<T> {\n         }\n     }\n \n+    pub fn superset(&self, other: &HybridBitSet<T>) -> bool {\n+        match (self, other) {\n+            (HybridBitSet::Dense(self_dense, _), HybridBitSet::Dense(other_dense, _)) => {\n+                self_dense.superset(other_dense)\n+            }\n+            _ => other.iter().all(|elem| self.contains(elem)),\n+        }\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        match self {\n+            HybridBitSet::Sparse(sparse, _) => sparse.is_empty(),\n+            HybridBitSet::Dense(dense, _) => dense.is_empty(),\n+        }\n+    }\n+\n     pub fn insert(&mut self, elem: T) -> bool {\n         match self {\n             HybridBitSet::Sparse(sparse, _) if sparse.len() < SPARSE_MAX => {\n@@ -443,26 +482,33 @@ impl<T: Idx> HybridBitSet<T> {\n             }\n             HybridBitSet::Sparse(_, _) => {\n                 // The set is sparse and full. Convert to a dense set.\n-                //\n-                // FIXME: This code is awful, but I can't work out how else to\n-                //        appease the borrow checker.\n-                let dummy = HybridBitSet::Sparse(SparseBitSet::new_empty(), 0);\n-                match mem::replace(self, dummy) {\n+                match mem::replace(self, HybridBitSet::dummy()) {\n                     HybridBitSet::Sparse(sparse, domain_size) => {\n                         let mut dense = sparse.to_dense(domain_size);\n                         let changed = dense.insert(elem);\n                         assert!(changed);\n-                        mem::replace(self, HybridBitSet::Dense(dense, domain_size));\n+                        *self = HybridBitSet::Dense(dense, domain_size);\n                         changed\n                     }\n-                    _ => panic!(\"impossible\"),\n+                    _ => unreachable!()\n                 }\n             }\n \n             HybridBitSet::Dense(dense, _) => dense.insert(elem),\n         }\n     }\n \n+    pub fn insert_all(&mut self) {\n+        let domain_size = self.domain_size();\n+        match self {\n+            HybridBitSet::Sparse(_, _) => {\n+                let dense = BitSet::new_filled(domain_size);\n+                *self = HybridBitSet::Dense(dense, domain_size);\n+            }\n+            HybridBitSet::Dense(dense, _) => dense.insert_all(),\n+        }\n+    }\n+\n     pub fn remove(&mut self, elem: T) -> bool {\n         // Note: we currently don't bother going from Dense back to Sparse.\n         match self {\n@@ -471,6 +517,42 @@ impl<T: Idx> HybridBitSet<T> {\n         }\n     }\n \n+    pub fn union(&mut self, other: &HybridBitSet<T>) -> bool {\n+        match self {\n+            HybridBitSet::Sparse(_, _) => {\n+                match other {\n+                    HybridBitSet::Sparse(other_sparse, _) => {\n+                        // Both sets are sparse. Add the elements in\n+                        // `other_sparse` to `self_hybrid` one at a time. This\n+                        // may or may not cause `self_hybrid` to be densified.\n+                        let mut self_hybrid = mem::replace(self, HybridBitSet::dummy());\n+                        let mut changed = false;\n+                        for elem in other_sparse.iter() {\n+                            changed |= self_hybrid.insert(*elem);\n+                        }\n+                        *self = self_hybrid;\n+                        changed\n+                    }\n+                    HybridBitSet::Dense(other_dense, _) => {\n+                        // `self` is sparse and `other` is dense. Densify\n+                        // `self` and then do the bitwise union.\n+                        match mem::replace(self, HybridBitSet::dummy()) {\n+                            HybridBitSet::Sparse(self_sparse, self_domain_size) => {\n+                                let mut new_dense = self_sparse.to_dense(self_domain_size);\n+                                let changed = new_dense.union(other_dense);\n+                                *self = HybridBitSet::Dense(new_dense, self_domain_size);\n+                                changed\n+                            }\n+                            _ => unreachable!()\n+                        }\n+                    }\n+                }\n+            }\n+\n+            HybridBitSet::Dense(self_dense, _) => self_dense.union(other),\n+        }\n+    }\n+\n     /// Converts to a dense set, consuming itself in the process.\n     pub fn to_dense(self) -> BitSet<T> {\n         match self {\n@@ -479,7 +561,6 @@ impl<T: Idx> HybridBitSet<T> {\n         }\n     }\n \n-    /// Iteration order is unspecified.\n     pub fn iter(&self) -> HybridIter<T> {\n         match self {\n             HybridBitSet::Sparse(sparse, _) => HybridIter::Sparse(sparse.iter()),\n@@ -547,16 +628,16 @@ impl<T: Idx> GrowableBitSet<T> {\n         GrowableBitSet { bit_set: BitSet::new_empty(bits) }\n     }\n \n-    /// Returns true if the bit has changed.\n+    /// Returns true if the set has changed.\n     #[inline]\n-    pub fn insert(&mut self, bit: T) -> bool {\n-        self.grow(bit);\n-        self.bit_set.insert(bit)\n+    pub fn insert(&mut self, elem: T) -> bool {\n+        self.grow(elem);\n+        self.bit_set.insert(elem)\n     }\n \n     #[inline]\n-    pub fn contains(&self, bit: T) -> bool {\n-        let (word_index, mask) = word_index_and_mask(bit);\n+    pub fn contains(&self, elem: T) -> bool {\n+        let (word_index, mask) = word_index_and_mask(elem);\n         if let Some(word) = self.bit_set.words.get(word_index) {\n             (word & mask) != 0\n         } else {\n@@ -682,11 +763,10 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n /// sparse representation.\n ///\n /// Initially, every row has no explicit representation. If any bit within a\n-/// row is set, the entire row is instantiated as\n-/// `Some(<full-column-width-BitSet>)`. Furthermore, any previously\n-/// uninstantiated rows prior to it will be instantiated as `None`. Those prior\n-/// rows may themselves become fully instantiated later on if any of their bits\n-/// are set.\n+/// row is set, the entire row is instantiated as `Some(<HybridBitSet>)`.\n+/// Furthermore, any previously uninstantiated rows prior to it will be\n+/// instantiated as `None`. Those prior rows may themselves become fully\n+/// instantiated later on if any of their bits are set.\n ///\n /// `R` and `C` are index types used to identify rows and columns respectively;\n /// typically newtyped `usize` wrappers, but they can also just be `usize`.\n@@ -697,7 +777,7 @@ where\n     C: Idx,\n {\n     num_columns: usize,\n-    rows: IndexVec<R, Option<BitSet<C>>>,\n+    rows: IndexVec<R, Option<HybridBitSet<C>>>,\n }\n \n impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n@@ -709,14 +789,14 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         }\n     }\n \n-    fn ensure_row(&mut self, row: R) -> &mut BitSet<C> {\n+    fn ensure_row(&mut self, row: R) -> &mut HybridBitSet<C> {\n         // Instantiate any missing rows up to and including row `row` with an\n-        // empty BitSet.\n+        // empty HybridBitSet.\n         self.rows.ensure_contains_elem(row, || None);\n \n-        // Then replace row `row` with a full BitSet if necessary.\n+        // Then replace row `row` with a full HybridBitSet if necessary.\n         let num_columns = self.num_columns;\n-        self.rows[row].get_or_insert_with(|| BitSet::new_empty(num_columns))\n+        self.rows[row].get_or_insert_with(|| HybridBitSet::new_empty(num_columns))\n     }\n \n     /// Sets the cell at `(row, column)` to true. Put another way, insert\n@@ -755,8 +835,8 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         }\n     }\n \n-    /// Merge a row, `from`, into the `into` row.\n-    pub fn union_into_row(&mut self, into: R, from: &BitSet<C>) -> bool {\n+    /// Union a row, `from`, into the `into` row.\n+    pub fn union_into_row(&mut self, into: R, from: &HybridBitSet<C>) -> bool {\n         self.ensure_row(into).union(from)\n     }\n \n@@ -775,7 +855,7 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         self.row(row).into_iter().flat_map(|r| r.iter())\n     }\n \n-    pub fn row(&self, row: R) -> Option<&BitSet<C>> {\n+    pub fn row(&self, row: R) -> Option<&HybridBitSet<C>> {\n         if let Some(Some(row)) = self.rows.get(row) {\n             Some(row)\n         } else {\n@@ -866,7 +946,7 @@ fn bitset_iter_works_2() {\n }\n \n #[test]\n-fn union_two_vecs() {\n+fn union_two_sets() {\n     let mut set1: BitSet<usize> = BitSet::new_empty(65);\n     let mut set2: BitSet<usize> = BitSet::new_empty(65);\n     assert!(set1.insert(3));\n@@ -882,6 +962,74 @@ fn union_two_vecs() {\n     assert!(set1.contains(64));\n }\n \n+#[test]\n+fn hybrid_bitset() {\n+    let mut sparse038: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n+    assert!(sparse038.is_empty());\n+    assert!(sparse038.insert(0));\n+    assert!(sparse038.insert(1));\n+    assert!(sparse038.insert(8));\n+    assert!(sparse038.insert(3));\n+    assert!(!sparse038.insert(3));\n+    assert!(sparse038.remove(1));\n+    assert!(!sparse038.is_empty());\n+    assert_eq!(sparse038.iter().collect::<Vec<_>>(), [0, 3, 8]);\n+\n+    for i in 0..256 {\n+        if i == 0 || i == 3 || i == 8 {\n+            assert!(sparse038.contains(i));\n+        } else {\n+            assert!(!sparse038.contains(i));\n+        }\n+    }\n+\n+    let mut sparse01358 = sparse038.clone();\n+    assert!(sparse01358.insert(1));\n+    assert!(sparse01358.insert(5));\n+    assert_eq!(sparse01358.iter().collect::<Vec<_>>(), [0, 1, 3, 5, 8]);\n+\n+    let mut dense10 = HybridBitSet::new_empty(256);\n+    for i in 0..10 {\n+        assert!(dense10.insert(i));\n+    }\n+    assert!(!dense10.is_empty());\n+    assert_eq!(dense10.iter().collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n+\n+    let mut dense256 = HybridBitSet::new_empty(256);\n+    assert!(dense256.is_empty());\n+    dense256.insert_all();\n+    assert!(!dense256.is_empty());\n+    for i in 0..256 {\n+        assert!(dense256.contains(i));\n+    }\n+\n+    assert!(sparse038.superset(&sparse038));    // sparse + sparse (self)\n+    assert!(sparse01358.superset(&sparse038));  // sparse + sparse\n+    assert!(dense10.superset(&sparse038));      // dense + sparse\n+    assert!(dense10.superset(&dense10));        // dense + dense (self)\n+    assert!(dense256.superset(&dense10));       // dense + dense\n+\n+    let mut hybrid = sparse038;\n+    assert!(!sparse01358.union(&hybrid));       // no change\n+    assert!(hybrid.union(&sparse01358));\n+    assert!(hybrid.superset(&sparse01358) && sparse01358.superset(&hybrid));\n+    assert!(!dense10.union(&sparse01358));\n+    assert!(!dense256.union(&dense10));\n+    let mut dense = dense10;\n+    assert!(dense.union(&dense256));\n+    assert!(dense.superset(&dense256) && dense256.superset(&dense));\n+    assert!(hybrid.union(&dense256));\n+    assert!(hybrid.superset(&dense256) && dense256.superset(&hybrid));\n+\n+    assert_eq!(dense256.iter().count(), 256);\n+    let mut dense0 = dense256;\n+    for i in 0..256 {\n+        assert!(dense0.remove(i));\n+    }\n+    assert!(!dense0.remove(0));\n+    assert!(dense0.is_empty());\n+}\n+\n #[test]\n fn grow() {\n     let mut set: GrowableBitSet<usize> = GrowableBitSet::with_capacity(65);"}, {"sha": "70b960ac351c0031069b153b00cff8cedfb5402d", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff6422d7a392acfc8af28994d65af2bbaecea4f6/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff6422d7a392acfc8af28994d65af2bbaecea4f6/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=ff6422d7a392acfc8af28994d65af2bbaecea4f6", "patch": "@@ -60,7 +60,6 @@ extern crate rustc_cratesio_shim;\n pub use rustc_serialize::hex::ToHex;\n \n pub mod svh;\n-pub mod array_vec;\n pub mod base_n;\n pub mod bit_set;\n pub mod const_cstr;"}, {"sha": "8dc41a9b2d32d13df61fc6af0403527c6b51a8d9", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff6422d7a392acfc8af28994d65af2bbaecea4f6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff6422d7a392acfc8af28994d65af2bbaecea4f6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=ff6422d7a392acfc8af28994d65af2bbaecea4f6", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::ty::{self, RegionVid};\n-use rustc_data_structures::bit_set::{BitSet, SparseBitMatrix};\n+use rustc_data_structures::bit_set::{HybridBitSet, SparseBitMatrix};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt::Debug;\n@@ -184,7 +184,7 @@ impl<N: Idx> LivenessValues<N> {\n \n     /// Adds all the elements in the given bit array into the given\n     /// region. Returns true if any of them are newly added.\n-    crate fn add_elements(&mut self, row: N, locations: &BitSet<PointIndex>) -> bool {\n+    crate fn add_elements(&mut self, row: N, locations: &HybridBitSet<PointIndex>) -> bool {\n         debug!(\"LivenessValues::add_elements(row={:?}, locations={:?})\", row, locations);\n         self.points.union_into_row(row, locations)\n     }"}, {"sha": "47e6ce05cec1ff9cdc9485ba0d8d8796300b0ee7", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ff6422d7a392acfc8af28994d65af2bbaecea4f6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff6422d7a392acfc8af28994d65af2bbaecea4f6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=ff6422d7a392acfc8af28994d65af2bbaecea4f6", "patch": "@@ -22,7 +22,7 @@ use rustc::traits::query::dropck_outlives::DropckOutlivesResult;\n use rustc::traits::query::type_op::outlives::DropckOutlives;\n use rustc::traits::query::type_op::TypeOp;\n use rustc::ty::{Ty, TypeFoldable};\n-use rustc_data_structures::bit_set::BitSet;\n+use rustc_data_structures::bit_set::HybridBitSet;\n use rustc_data_structures::fx::FxHashMap;\n use std::rc::Rc;\n use util::liveness::LiveVariableMap;\n@@ -121,16 +121,16 @@ where\n     cx: LivenessContext<'me, 'typeck, 'flow, 'gcx, 'tcx>,\n \n     /// Set of points that define the current local.\n-    defs: BitSet<PointIndex>,\n+    defs: HybridBitSet<PointIndex>,\n \n     /// Points where the current variable is \"use live\" -- meaning\n     /// that there is a future \"full use\" that may use its value.\n-    use_live_at: BitSet<PointIndex>,\n+    use_live_at: HybridBitSet<PointIndex>,\n \n     /// Points where the current variable is \"drop live\" -- meaning\n     /// that there is no future \"full use\" that may use its value, but\n     /// there is a future drop.\n-    drop_live_at: BitSet<PointIndex>,\n+    drop_live_at: HybridBitSet<PointIndex>,\n \n     /// Locations where drops may occur.\n     drop_locations: Vec<Location>,\n@@ -144,9 +144,9 @@ impl LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx> {\n         let num_points = cx.elements.num_points();\n         LivenessResults {\n             cx,\n-            defs: BitSet::new_empty(num_points),\n-            use_live_at: BitSet::new_empty(num_points),\n-            drop_live_at: BitSet::new_empty(num_points),\n+            defs: HybridBitSet::new_empty(num_points),\n+            use_live_at: HybridBitSet::new_empty(num_points),\n+            drop_live_at: HybridBitSet::new_empty(num_points),\n             drop_locations: vec![],\n             stack: vec![],\n         }\n@@ -448,7 +448,7 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n     fn add_use_live_facts_for(\n         &mut self,\n         value: impl TypeFoldable<'tcx>,\n-        live_at: &BitSet<PointIndex>,\n+        live_at: &HybridBitSet<PointIndex>,\n     ) {\n         debug!(\"add_use_live_facts_for(value={:?})\", value);\n \n@@ -465,7 +465,7 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n         dropped_local: Local,\n         dropped_ty: Ty<'tcx>,\n         drop_locations: &[Location],\n-        live_at: &BitSet<PointIndex>,\n+        live_at: &HybridBitSet<PointIndex>,\n     ) {\n         debug!(\n             \"add_drop_live_constraint(\\\n@@ -508,7 +508,7 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n         elements: &RegionValueElements,\n         typeck: &mut TypeChecker<'_, '_, 'tcx>,\n         value: impl TypeFoldable<'tcx>,\n-        live_at: &BitSet<PointIndex>,\n+        live_at: &HybridBitSet<PointIndex>,\n     ) {\n         debug!(\"make_all_regions_live(value={:?})\", value);\n         debug!("}]}