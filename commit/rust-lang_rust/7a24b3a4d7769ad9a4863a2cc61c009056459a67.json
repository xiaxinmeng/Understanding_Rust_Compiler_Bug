{"sha": "7a24b3a4d7769ad9a4863a2cc61c009056459a67", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMjRiM2E0ZDc3NjlhZDlhNDg2M2EyY2M2MWMwMDkwNTY0NTlhNjc=", "commit": {"author": {"name": "Paul Collier", "email": "paul@paulcollier.ca", "date": "2015-01-17T23:55:21Z"}, "committer": {"name": "Paul Collier", "email": "paul@paulcollier.ca", "date": "2015-01-19T03:43:44Z"}, "message": "libsyntax: int => i32 in appropriate places", "tree": {"sha": "a3cfc7a21498a82b036e28417624a5a64c112c12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3cfc7a21498a82b036e28417624a5a64c112c12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a24b3a4d7769ad9a4863a2cc61c009056459a67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a24b3a4d7769ad9a4863a2cc61c009056459a67", "html_url": "https://github.com/rust-lang/rust/commit/7a24b3a4d7769ad9a4863a2cc61c009056459a67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a24b3a4d7769ad9a4863a2cc61c009056459a67/comments", "author": {"login": "pshc", "id": 6398, "node_id": "MDQ6VXNlcjYzOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6398?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pshc", "html_url": "https://github.com/pshc", "followers_url": "https://api.github.com/users/pshc/followers", "following_url": "https://api.github.com/users/pshc/following{/other_user}", "gists_url": "https://api.github.com/users/pshc/gists{/gist_id}", "starred_url": "https://api.github.com/users/pshc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pshc/subscriptions", "organizations_url": "https://api.github.com/users/pshc/orgs", "repos_url": "https://api.github.com/users/pshc/repos", "events_url": "https://api.github.com/users/pshc/events{/privacy}", "received_events_url": "https://api.github.com/users/pshc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pshc", "id": 6398, "node_id": "MDQ6VXNlcjYzOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6398?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pshc", "html_url": "https://github.com/pshc", "followers_url": "https://api.github.com/users/pshc/followers", "following_url": "https://api.github.com/users/pshc/following{/other_user}", "gists_url": "https://api.github.com/users/pshc/gists{/gist_id}", "starred_url": "https://api.github.com/users/pshc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pshc/subscriptions", "organizations_url": "https://api.github.com/users/pshc/orgs", "repos_url": "https://api.github.com/users/pshc/repos", "events_url": "https://api.github.com/users/pshc/events{/privacy}", "received_events_url": "https://api.github.com/users/pshc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5c83652b33a6e5049699ccc7e6bd6fffb42c2b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5c83652b33a6e5049699ccc7e6bd6fffb42c2b8", "html_url": "https://github.com/rust-lang/rust/commit/d5c83652b33a6e5049699ccc7e6bd6fffb42c2b8"}], "stats": {"total": 96, "additions": 48, "deletions": 48}, "files": [{"sha": "ca3c1d36fbaf961deb9253f8424ad574b4dddc1a", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7a24b3a4d7769ad9a4863a2cc61c009056459a67/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a24b3a4d7769ad9a4863a2cc61c009056459a67/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=7a24b3a4d7769ad9a4863a2cc61c009056459a67", "patch": "@@ -28,7 +28,7 @@\n //! arguments:\n //!\n //! - `Struct`, when `Self` is a struct (including tuple structs, e.g\n-//!   `struct T(int, char)`).\n+//!   `struct T(i32, char)`).\n //! - `EnumMatching`, when `Self` is an enum and all the arguments are the\n //!   same variant of the enum (e.g. `Some(1)`, `Some(3)` and `Some(4)`)\n //! - `EnumNonMatchingCollapsed` when `Self` is an enum and the arguments\n@@ -54,17 +54,17 @@\n //! following snippet\n //!\n //! ```rust\n-//! struct A { x : int }\n+//! struct A { x : i32 }\n //!\n-//! struct B(int);\n+//! struct B(i32);\n //!\n //! enum C {\n-//!     C0(int),\n-//!     C1 { x: int }\n+//!     C0(i32),\n+//!     C1 { x: i32 }\n //! }\n //! ```\n //!\n-//! The `int`s in `B` and `C0` don't have an identifier, so the\n+//! The `i32`s in `B` and `C0` don't have an identifier, so the\n //! `Option<ident>`s would be `None` for them.\n //!\n //! In the static cases, the structure is summarised, either into the just\n@@ -90,8 +90,8 @@\n //! trait PartialEq {\n //!     fn eq(&self, other: &Self);\n //! }\n-//! impl PartialEq for int {\n-//!     fn eq(&self, other: &int) -> bool {\n+//! impl PartialEq for i32 {\n+//!     fn eq(&self, other: &i32) -> bool {\n //!         *self == *other\n //!     }\n //! }\n@@ -117,7 +117,7 @@\n //!\n //! ```{.text}\n //! Struct(vec![FieldInfo {\n-//!           span: <span of `int`>,\n+//!           span: <span of `i32`>,\n //!           name: None,\n //!           self_: <expr for &a>\n //!           other: vec![<expr for &b>]\n@@ -132,7 +132,7 @@\n //! ```{.text}\n //! EnumMatching(0, <ast::Variant for C0>,\n //!              vec![FieldInfo {\n-//!                 span: <span of int>\n+//!                 span: <span of i32>\n //!                 name: None,\n //!                 self_: <expr for &a>,\n //!                 other: vec![<expr for &b>]\n@@ -179,7 +179,7 @@\n //! StaticStruct(<ast::StructDef of B>, Unnamed(vec![<span of x>]))\n //!\n //! StaticEnum(<ast::EnumDef of C>,\n-//!            vec![(<ident of C0>, <span of C0>, Unnamed(vec![<span of int>])),\n+//!            vec![(<ident of C0>, <span of C0>, Unnamed(vec![<span of i32>])),\n //!                 (<ident of C1>, <span of C1>, Named(vec![(<ident of x>, <span of x>)]))])\n //! ```\n \n@@ -719,7 +719,7 @@ impl<'a> MethodDef<'a> {\n \n     /// ```\n     /// #[derive(PartialEq)]\n-    /// struct A { x: int, y: int }\n+    /// struct A { x: i32, y: i32 }\n     ///\n     /// // equivalent to:\n     /// impl PartialEq for A {\n@@ -825,7 +825,7 @@ impl<'a> MethodDef<'a> {\n     /// #[derive(PartialEq)]\n     /// enum A {\n     ///     A1,\n-    ///     A2(int)\n+    ///     A2(i32)\n     /// }\n     ///\n     /// // is equivalent to"}, {"sha": "e7634716ed7ed364d393f1cd0cb952f6ca3dd1ca", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a24b3a4d7769ad9a4863a2cc61c009056459a67/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a24b3a4d7769ad9a4863a2cc61c009056459a67/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=7a24b3a4d7769ad9a4863a2cc61c009056459a67", "patch": "@@ -32,7 +32,7 @@ pub enum PtrTy<'a> {\n     Raw(ast::Mutability),\n }\n \n-/// A path, e.g. `::std::option::Option::<int>` (global). Has support\n+/// A path, e.g. `::std::option::Option::<i32>` (global). Has support\n /// for type parameters and a lifetime.\n #[derive(Clone)]\n pub struct Path<'a> {\n@@ -91,7 +91,7 @@ pub enum Ty<'a> {\n     /// &/Box/ Ty\n     Ptr(Box<Ty<'a>>, PtrTy<'a>),\n     /// mod::mod::Type<[lifetime], [Params...]>, including a plain type\n-    /// parameter, and things like `int`\n+    /// parameter, and things like `i32`\n     Literal(Path<'a>),\n     /// includes unit\n     Tuple(Vec<Ty<'a>> )"}, {"sha": "4f614c1a93717365f33ae03d9d5061a2b1cad601", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7a24b3a4d7769ad9a4863a2cc61c009056459a67/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a24b3a4d7769ad9a4863a2cc61c009056459a67/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7a24b3a4d7769ad9a4863a2cc61c009056459a67", "patch": "@@ -1507,7 +1507,7 @@ mod test {\n     #[should_fail]\n     #[test] fn macros_cant_escape_fns_test () {\n         let src = \"fn bogus() {macro_rules! z (() => (3+4));}\\\n-                   fn inty() -> int { z!() }\".to_string();\n+                   fn inty() -> i32 { z!() }\".to_string();\n         let sess = parse::new_parse_sess();\n         let crate_ast = parse::parse_crate_from_source_str(\n             \"<test>\".to_string(),\n@@ -1521,7 +1521,7 @@ mod test {\n     #[should_fail]\n     #[test] fn macros_cant_escape_mods_test () {\n         let src = \"mod foo {macro_rules! z (() => (3+4));}\\\n-                   fn inty() -> int { z!() }\".to_string();\n+                   fn inty() -> i32 { z!() }\".to_string();\n         let sess = parse::new_parse_sess();\n         let crate_ast = parse::parse_crate_from_source_str(\n             \"<test>\".to_string(),\n@@ -1533,7 +1533,7 @@ mod test {\n     // macro_use modules should allow macros to escape\n     #[test] fn macros_can_escape_flattened_mods_test () {\n         let src = \"#[macro_use] mod foo {macro_rules! z (() => (3+4));}\\\n-                   fn inty() -> int { z!() }\".to_string();\n+                   fn inty() -> i32 { z!() }\".to_string();\n         let sess = parse::new_parse_sess();\n         let crate_ast = parse::parse_crate_from_source_str(\n             \"<test>\".to_string(),\n@@ -1564,8 +1564,8 @@ mod test {\n     // should be able to use a bound identifier as a literal in a macro definition:\n     #[test] fn self_macro_parsing(){\n         expand_crate_str(\n-            \"macro_rules! foo ((zz) => (287u;));\n-            fn f(zz : int) {foo!(zz);}\".to_string()\n+            \"macro_rules! foo ((zz) => (287;));\n+            fn f(zz: i32) {foo!(zz);}\".to_string()\n             );\n     }\n \n@@ -1601,23 +1601,23 @@ mod test {\n     fn automatic_renaming () {\n         let tests: Vec<RenamingTest> =\n             vec!(// b & c should get new names throughout, in the expr too:\n-                (\"fn a() -> int { let b = 13; let c = b; b+c }\",\n+                (\"fn a() -> i32 { let b = 13; let c = b; b+c }\",\n                  vec!(vec!(0,1),vec!(2)), false),\n                 // both x's should be renamed (how is this causing a bug?)\n-                (\"fn main () {let x: int = 13;x;}\",\n+                (\"fn main () {let x: i32 = 13;x;}\",\n                  vec!(vec!(0)), false),\n                 // the use of b after the + should be renamed, the other one not:\n-                (\"macro_rules! f (($x:ident) => (b + $x)); fn a() -> int { let b = 13; f!(b)}\",\n+                (\"macro_rules! f (($x:ident) => (b + $x)); fn a() -> i32 { let b = 13; f!(b)}\",\n                  vec!(vec!(1)), false),\n                 // the b before the plus should not be renamed (requires marks)\n-                (\"macro_rules! f (($x:ident) => ({let b=9; ($x + b)})); fn a() -> int { f!(b)}\",\n+                (\"macro_rules! f (($x:ident) => ({let b=9; ($x + b)})); fn a() -> i32 { f!(b)}\",\n                  vec!(vec!(1)), false),\n                 // the marks going in and out of letty should cancel, allowing that $x to\n                 // capture the one following the semicolon.\n                 // this was an awesome test case, and caught a *lot* of bugs.\n                 (\"macro_rules! letty(($x:ident) => (let $x = 15;));\n                   macro_rules! user(($x:ident) => ({letty!($x); $x}));\n-                  fn main() -> int {user!(z)}\",\n+                  fn main() -> i32 {user!(z)}\",\n                  vec!(vec!(0)), false)\n                 );\n         for (idx,s) in tests.iter().enumerate() {\n@@ -1680,13 +1680,13 @@ mod test {\n     // can't write this test case until we have macro-generating macros.\n \n     // method arg hygiene\n-    // method expands to fn get_x(&self_0, x_1:int) {self_0 + self_2 + x_3 + x_1}\n+    // method expands to fn get_x(&self_0, x_1: i32) {self_0 + self_2 + x_3 + x_1}\n     #[test] fn method_arg_hygiene(){\n         run_renaming_test(\n             &(\"macro_rules! inject_x (()=>(x));\n               macro_rules! inject_self (()=>(self));\n               struct A;\n-              impl A{fn get_x(&self, x: int) {self + inject_self!() + inject_x!() + x;} }\",\n+              impl A{fn get_x(&self, x: i32) {self + inject_self!() + inject_x!() + x;} }\",\n               vec!(vec!(0),vec!(3)),\n               true),\n             0)\n@@ -1706,21 +1706,21 @@ mod test {\n     }\n \n     // item fn hygiene\n-    // expands to fn q(x_1:int){fn g(x_2:int){x_2 + x_1};}\n+    // expands to fn q(x_1: i32){fn g(x_2: i32){x_2 + x_1};}\n     #[test] fn issue_9383(){\n         run_renaming_test(\n-            &(\"macro_rules! bad_macro (($ex:expr) => (fn g(x:int){ x + $ex }));\n-              fn q(x:int) { bad_macro!(x); }\",\n+            &(\"macro_rules! bad_macro (($ex:expr) => (fn g(x: i32){ x + $ex }));\n+              fn q(x: i32) { bad_macro!(x); }\",\n               vec!(vec!(1),vec!(0)),true),\n             0)\n     }\n \n     // closure arg hygiene (ExprClosure)\n-    // expands to fn f(){(|x_1 : int| {(x_2 + x_1)})(3);}\n+    // expands to fn f(){(|x_1 : i32| {(x_2 + x_1)})(3);}\n     #[test] fn closure_arg_hygiene(){\n         run_renaming_test(\n             &(\"macro_rules! inject_x (()=>(x));\n-            fn f(){(|x : int| {(inject_x!() + x)})(3);}\",\n+            fn f(){(|x : i32| {(inject_x!() + x)})(3);}\",\n               vec!(vec!(1)),\n               true),\n             0)\n@@ -1729,7 +1729,7 @@ mod test {\n     // macro_rules in method position. Sadly, unimplemented.\n     #[test] fn macro_in_method_posn(){\n         expand_crate_str(\n-            \"macro_rules! my_method (() => (fn thirteen(&self) -> int {13}));\n+            \"macro_rules! my_method (() => (fn thirteen(&self) -> i32 {13}));\n             struct A;\n             impl A{ my_method!(); }\n             fn f(){A.thirteen;}\".to_string());\n@@ -1876,7 +1876,7 @@ foo_module!();\n     // it's the name of a 0-ary variant, and that 'i' appears twice in succession.\n     #[test]\n     fn crate_bindings_test(){\n-        let the_crate = string_to_crate(\"fn main (a : int) -> int {|b| {\n+        let the_crate = string_to_crate(\"fn main (a: i32) -> i32 {|b| {\n         match 34 {None => 3, Some(i) | i => j, Foo{k:z,l:y} => \\\"banana\\\"}} }\".to_string());\n         let idents = crate_bindings(&the_crate);\n         assert_eq!(idents, strs_to_idents(vec!(\"a\",\"b\",\"None\",\"i\",\"i\",\"z\",\"y\")));\n@@ -1885,10 +1885,10 @@ foo_module!();\n     // test the IdentRenamer directly\n     #[test]\n     fn ident_renamer_test () {\n-        let the_crate = string_to_crate(\"fn f(x : int){let x = x; x}\".to_string());\n+        let the_crate = string_to_crate(\"fn f(x: i32){let x = x; x}\".to_string());\n         let f_ident = token::str_to_ident(\"f\");\n         let x_ident = token::str_to_ident(\"x\");\n-        let int_ident = token::str_to_ident(\"int\");\n+        let int_ident = token::str_to_ident(\"i32\");\n         let renames = vec!((x_ident,Name(16)));\n         let mut renamer = IdentRenamer{renames: &renames};\n         let renamed_crate = renamer.fold_crate(the_crate);\n@@ -1900,10 +1900,10 @@ foo_module!();\n     // test the PatIdentRenamer; only PatIdents get renamed\n     #[test]\n     fn pat_ident_renamer_test () {\n-        let the_crate = string_to_crate(\"fn f(x : int){let x = x; x}\".to_string());\n+        let the_crate = string_to_crate(\"fn f(x: i32){let x = x; x}\".to_string());\n         let f_ident = token::str_to_ident(\"f\");\n         let x_ident = token::str_to_ident(\"x\");\n-        let int_ident = token::str_to_ident(\"int\");\n+        let int_ident = token::str_to_ident(\"i32\");\n         let renames = vec!((x_ident,Name(16)));\n         let mut renamer = PatIdentRenamer{renames: &renames};\n         let renamed_crate = renamer.fold_crate(the_crate);"}, {"sha": "58d114fb2a79e6f5e1fb3a23b5e135002aa6d082", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a24b3a4d7769ad9a4863a2cc61c009056459a67/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a24b3a4d7769ad9a4863a2cc61c009056459a67/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=7a24b3a4d7769ad9a4863a2cc61c009056459a67", "patch": "@@ -399,9 +399,9 @@ mod test {\n     }\n \n     #[test] fn test_block_doc_comment_3() {\n-        let comment = \"/**\\n let a: *int;\\n *a = 5;\\n*/\";\n+        let comment = \"/**\\n let a: *i32;\\n *a = 5;\\n*/\";\n         let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped, \" let a: *int;\\n *a = 5;\");\n+        assert_eq!(stripped, \" let a: *i32;\\n *a = 5;\");\n     }\n \n     #[test] fn test_block_doc_comment_4() {"}, {"sha": "33da7c160d94db8a078031f01e9e2c3e668e7929", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a24b3a4d7769ad9a4863a2cc61c009056459a67/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a24b3a4d7769ad9a4863a2cc61c009056459a67/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=7a24b3a4d7769ad9a4863a2cc61c009056459a67", "patch": "@@ -855,7 +855,7 @@ mod test {\n \n     #[test]\n     fn string_to_tts_1 () {\n-        let tts = string_to_tts(\"fn a (b : int) { b; }\".to_string());\n+        let tts = string_to_tts(\"fn a (b : i32) { b; }\".to_string());\n         assert_eq!(json::encode(&tts),\n         \"[\\\n     {\\\n@@ -919,7 +919,7 @@ mod test {\n                             {\\\n                                 \\\"variant\\\":\\\"Ident\\\",\\\n                                 \\\"fields\\\":[\\\n-                                    \\\"int\\\",\\\n+                                    \\\"i32\\\",\\\n                                     \\\"Plain\\\"\\\n                                 ]\\\n                             }\\\n@@ -1031,8 +1031,8 @@ mod test {\n \n     // check the contents of the tt manually:\n     #[test] fn parse_fundecl () {\n-        // this test depends on the intern order of \"fn\" and \"int\"\n-        assert!(string_to_item(\"fn a (b : int) { b; }\".to_string()) ==\n+        // this test depends on the intern order of \"fn\" and \"i32\"\n+        assert_eq!(string_to_item(\"fn a (b : i32) { b; }\".to_string()),\n                   Some(\n                       P(ast::Item{ident:str_to_ident(\"a\"),\n                             attrs:Vec::new(),\n@@ -1046,7 +1046,7 @@ mod test {\n                                         segments: vec!(\n                                             ast::PathSegment {\n                                                 identifier:\n-                                                    str_to_ident(\"int\"),\n+                                                    str_to_ident(\"i32\"),\n                                                 parameters: ast::PathParameters::none(),\n                                             }\n                                         ),"}, {"sha": "920cfeb3693523e7b63de8ec2d0ad6a75216e831", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a24b3a4d7769ad9a4863a2cc61c009056459a67/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a24b3a4d7769ad9a4863a2cc61c009056459a67/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7a24b3a4d7769ad9a4863a2cc61c009056459a67", "patch": "@@ -1499,7 +1499,7 @@ impl<'a> Parser<'a> {\n             self.expect(&token::OpenDelim(token::Bracket));\n             let t = self.parse_ty_sum();\n \n-            // Parse the `; e` in `[ int; e ]`\n+            // Parse the `; e` in `[ i32; e ]`\n             // where `e` is a const expression\n             let t = match self.maybe_parse_fixed_length_of_vec() {\n                 None => TyVec(t),\n@@ -4803,7 +4803,7 @@ impl<'a> Parser<'a> {\n          Some(attrs))\n     }\n \n-    /// Parse a::B<String,int>\n+    /// Parse a::B<String,i32>\n     fn parse_trait_ref(&mut self) -> TraitRef {\n         ast::TraitRef {\n             path: self.parse_path(LifetimeAndTypesWithoutColons),\n@@ -4822,7 +4822,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse for<'l> a::B<String,int>\n+    /// Parse for<'l> a::B<String,i32>\n     fn parse_poly_trait_ref(&mut self) -> PolyTraitRef {\n         let lifetime_defs = self.parse_late_bound_lifetime_defs();\n "}]}