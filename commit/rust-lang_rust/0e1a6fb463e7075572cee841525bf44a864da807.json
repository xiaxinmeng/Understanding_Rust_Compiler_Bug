{"sha": "0e1a6fb463e7075572cee841525bf44a864da807", "node_id": "C_kwDOAAsO6NoAKDBlMWE2ZmI0NjNlNzA3NTU3MmNlZTg0MTUyNWJmNDRhODY0ZGE4MDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-26T07:12:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-26T07:12:16Z"}, "message": "Auto merge of #98521 - JohnTitor:rollup-tl9sblx, r=JohnTitor\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #98371 (Fix printing `impl trait` under binders)\n - #98385 (Work around llvm 12's memory ordering restrictions.)\n - #98474 (x.py: Support systems with only `python3` not `python`)\n - #98488 (Bump RLS to latest master on rust-lang/rls)\n - #98491 (Fix backtrace UI test when panic=abort is used)\n - #98502 (Fix source sidebar hover in ayu theme)\n - #98509 (diagnostics: consider parameter count when suggesting smart pointers)\n - #98513 (Fix LLVM rebuild with download-ci-llvm.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "b515e950192f1afb4048d30cdee51fe9ca7d21a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b515e950192f1afb4048d30cdee51fe9ca7d21a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e1a6fb463e7075572cee841525bf44a864da807", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e1a6fb463e7075572cee841525bf44a864da807", "html_url": "https://github.com/rust-lang/rust/commit/0e1a6fb463e7075572cee841525bf44a864da807", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e1a6fb463e7075572cee841525bf44a864da807/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "639a655e11306116e8507d401a1262e87e1b23b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/639a655e11306116e8507d401a1262e87e1b23b7", "html_url": "https://github.com/rust-lang/rust/commit/639a655e11306116e8507d401a1262e87e1b23b7"}, {"sha": "fba8dfd75f9182a0793284c3d6766132c9965421", "url": "https://api.github.com/repos/rust-lang/rust/commits/fba8dfd75f9182a0793284c3d6766132c9965421", "html_url": "https://github.com/rust-lang/rust/commit/fba8dfd75f9182a0793284c3d6766132c9965421"}], "stats": {"total": 484, "additions": 355, "deletions": 129}, "files": [{"sha": "633eeb3d3bd8e8633cf67cd1cd002b70e3595f4f", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e1a6fb463e7075572cee841525bf44a864da807/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0e1a6fb463e7075572cee841525bf44a864da807/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0e1a6fb463e7075572cee841525bf44a864da807", "patch": "@@ -3054,7 +3054,6 @@ name = \"racer\"\n version = \"2.2.2\"\n dependencies = [\n  \"bitflags\",\n- \"clap 2.34.0\",\n  \"derive_more\",\n  \"env_logger 0.7.1\",\n  \"humantime 2.0.1\",\n@@ -3278,7 +3277,7 @@ dependencies = [\n  \"difference\",\n  \"env_logger 0.9.0\",\n  \"futures 0.3.19\",\n- \"heck 0.3.1\",\n+ \"heck 0.4.0\",\n  \"home\",\n  \"itertools\",\n  \"jsonrpc-core\","}, {"sha": "8c1e865762ccd30c6501d01d430de0b65a4e20a9", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0e1a6fb463e7075572cee841525bf44a864da807/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e1a6fb463e7075572cee841525bf44a864da807/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=0e1a6fb463e7075572cee841525bf44a864da807", "patch": "@@ -1064,11 +1064,25 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         dst: &'ll Value,\n         cmp: &'ll Value,\n         src: &'ll Value,\n-        order: rustc_codegen_ssa::common::AtomicOrdering,\n+        mut order: rustc_codegen_ssa::common::AtomicOrdering,\n         failure_order: rustc_codegen_ssa::common::AtomicOrdering,\n         weak: bool,\n     ) -> &'ll Value {\n         let weak = if weak { llvm::True } else { llvm::False };\n+        if llvm_util::get_version() < (13, 0, 0) {\n+            use rustc_codegen_ssa::common::AtomicOrdering::*;\n+            // Older llvm has the pre-C++17 restriction on\n+            // success and failure memory ordering,\n+            // requiring the former to be at least as strong as the latter.\n+            // So, for llvm 12, we upgrade the success ordering to a stronger\n+            // one if necessary.\n+            match (order, failure_order) {\n+                (Relaxed, Acquire) => order = Acquire,\n+                (Release, Acquire) => order = AcquireRelease,\n+                (_, SequentiallyConsistent) => order = SequentiallyConsistent,\n+                _ => {}\n+            }\n+        }\n         unsafe {\n             llvm::LLVMRustBuildAtomicCmpXchg(\n                 self.llbuilder,"}, {"sha": "c56909ba18b143559e34418c949147fda55d516f", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 120, "deletions": 113, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/0e1a6fb463e7075572cee841525bf44a864da807/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e1a6fb463e7075572cee841525bf44a864da807/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=0e1a6fb463e7075572cee841525bf44a864da807", "patch": "@@ -226,7 +226,7 @@ pub trait PrettyPrinter<'tcx>:\n         value.as_ref().skip_binder().print(self)\n     }\n \n-    fn wrap_binder<T, F: Fn(&T, Self) -> Result<Self, fmt::Error>>(\n+    fn wrap_binder<T, F: FnOnce(&T, Self) -> Result<Self, fmt::Error>>(\n         self,\n         value: &ty::Binder<'tcx, T>,\n         f: F,\n@@ -773,26 +773,26 @@ pub trait PrettyPrinter<'tcx>:\n         def_id: DefId,\n         substs: &'tcx ty::List<ty::GenericArg<'tcx>>,\n     ) -> Result<Self::Type, Self::Error> {\n-        define_scoped_cx!(self);\n+        let tcx = self.tcx();\n \n         // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n         // by looking up the projections associated with the def_id.\n-        let bounds = self.tcx().bound_explicit_item_bounds(def_id);\n+        let bounds = tcx.bound_explicit_item_bounds(def_id);\n \n         let mut traits = FxIndexMap::default();\n         let mut fn_traits = FxIndexMap::default();\n         let mut is_sized = false;\n \n         for predicate in bounds.transpose_iter().map(|e| e.map_bound(|(p, _)| *p)) {\n-            let predicate = predicate.subst(self.tcx(), substs);\n+            let predicate = predicate.subst(tcx, substs);\n             let bound_predicate = predicate.kind();\n \n             match bound_predicate.skip_binder() {\n                 ty::PredicateKind::Trait(pred) => {\n                     let trait_ref = bound_predicate.rebind(pred.trait_ref);\n \n                     // Don't print + Sized, but rather + ?Sized if absent.\n-                    if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n+                    if Some(trait_ref.def_id()) == tcx.lang_items().sized_trait() {\n                         is_sized = true;\n                         continue;\n                     }\n@@ -801,7 +801,7 @@ pub trait PrettyPrinter<'tcx>:\n                 }\n                 ty::PredicateKind::Projection(pred) => {\n                     let proj_ref = bound_predicate.rebind(pred);\n-                    let trait_ref = proj_ref.required_poly_trait_ref(self.tcx());\n+                    let trait_ref = proj_ref.required_poly_trait_ref(tcx);\n \n                     // Projection type entry -- the def-id for naming, and the ty.\n                     let proj_ty = (proj_ref.projection_def_id(), proj_ref.term());\n@@ -817,148 +817,155 @@ pub trait PrettyPrinter<'tcx>:\n             }\n         }\n \n+        write!(self, \"impl \")?;\n+\n         let mut first = true;\n         // Insert parenthesis around (Fn(A, B) -> C) if the opaque ty has more than one other trait\n         let paren_needed = fn_traits.len() > 1 || traits.len() > 0 || !is_sized;\n \n-        p!(\"impl\");\n-\n         for (fn_once_trait_ref, entry) in fn_traits {\n-            // Get the (single) generic ty (the args) of this FnOnce trait ref.\n-            let generics = self.tcx().generics_of(fn_once_trait_ref.def_id());\n-            let args =\n-                generics.own_substs_no_defaults(self.tcx(), fn_once_trait_ref.skip_binder().substs);\n-\n-            match (entry.return_ty, args[0].expect_ty()) {\n-                // We can only print `impl Fn() -> ()` if we have a tuple of args and we recorded\n-                // a return type.\n-                (Some(return_ty), arg_tys) if matches!(arg_tys.kind(), ty::Tuple(_)) => {\n-                    let name = if entry.fn_trait_ref.is_some() {\n-                        \"Fn\"\n-                    } else if entry.fn_mut_trait_ref.is_some() {\n-                        \"FnMut\"\n-                    } else {\n-                        \"FnOnce\"\n-                    };\n+            write!(self, \"{}\", if first { \"\" } else { \" + \" })?;\n+            write!(self, \"{}\", if paren_needed { \"(\" } else { \"\" })?;\n \n-                    p!(\n-                        write(\"{}\", if first { \" \" } else { \" + \" }),\n-                        write(\"{}{}(\", if paren_needed { \"(\" } else { \"\" }, name)\n-                    );\n+            self = self.wrap_binder(&fn_once_trait_ref, |trait_ref, mut cx| {\n+                define_scoped_cx!(cx);\n+                // Get the (single) generic ty (the args) of this FnOnce trait ref.\n+                let generics = tcx.generics_of(trait_ref.def_id);\n+                let args = generics.own_substs_no_defaults(tcx, trait_ref.substs);\n+\n+                match (entry.return_ty, args[0].expect_ty()) {\n+                    // We can only print `impl Fn() -> ()` if we have a tuple of args and we recorded\n+                    // a return type.\n+                    (Some(return_ty), arg_tys) if matches!(arg_tys.kind(), ty::Tuple(_)) => {\n+                        let name = if entry.fn_trait_ref.is_some() {\n+                            \"Fn\"\n+                        } else if entry.fn_mut_trait_ref.is_some() {\n+                            \"FnMut\"\n+                        } else {\n+                            \"FnOnce\"\n+                        };\n \n-                    for (idx, ty) in arg_tys.tuple_fields().iter().enumerate() {\n-                        if idx > 0 {\n-                            p!(\", \");\n+                        p!(write(\"{}(\", name));\n+\n+                        for (idx, ty) in arg_tys.tuple_fields().iter().enumerate() {\n+                            if idx > 0 {\n+                                p!(\", \");\n+                            }\n+                            p!(print(ty));\n                         }\n-                        p!(print(ty));\n-                    }\n \n-                    p!(\")\");\n-                    if let Term::Ty(ty) = return_ty.skip_binder() {\n-                        if !ty.is_unit() {\n-                            p!(\" -> \", print(return_ty));\n+                        p!(\")\");\n+                        if let Term::Ty(ty) = return_ty.skip_binder() {\n+                            if !ty.is_unit() {\n+                                p!(\" -> \", print(return_ty));\n+                            }\n                         }\n-                    }\n-                    p!(write(\"{}\", if paren_needed { \")\" } else { \"\" }));\n+                        p!(write(\"{}\", if paren_needed { \")\" } else { \"\" }));\n \n-                    first = false;\n-                }\n-                // If we got here, we can't print as a `impl Fn(A, B) -> C`. Just record the\n-                // trait_refs we collected in the OpaqueFnEntry as normal trait refs.\n-                _ => {\n-                    if entry.has_fn_once {\n-                        traits.entry(fn_once_trait_ref).or_default().extend(\n-                            // Group the return ty with its def id, if we had one.\n-                            entry\n-                                .return_ty\n-                                .map(|ty| (self.tcx().lang_items().fn_once_output().unwrap(), ty)),\n-                        );\n-                    }\n-                    if let Some(trait_ref) = entry.fn_mut_trait_ref {\n-                        traits.entry(trait_ref).or_default();\n+                        first = false;\n                     }\n-                    if let Some(trait_ref) = entry.fn_trait_ref {\n-                        traits.entry(trait_ref).or_default();\n+                    // If we got here, we can't print as a `impl Fn(A, B) -> C`. Just record the\n+                    // trait_refs we collected in the OpaqueFnEntry as normal trait refs.\n+                    _ => {\n+                        if entry.has_fn_once {\n+                            traits.entry(fn_once_trait_ref).or_default().extend(\n+                                // Group the return ty with its def id, if we had one.\n+                                entry\n+                                    .return_ty\n+                                    .map(|ty| (tcx.lang_items().fn_once_output().unwrap(), ty)),\n+                            );\n+                        }\n+                        if let Some(trait_ref) = entry.fn_mut_trait_ref {\n+                            traits.entry(trait_ref).or_default();\n+                        }\n+                        if let Some(trait_ref) = entry.fn_trait_ref {\n+                            traits.entry(trait_ref).or_default();\n+                        }\n                     }\n                 }\n-            }\n+\n+                Ok(cx)\n+            })?;\n         }\n \n         // Print the rest of the trait types (that aren't Fn* family of traits)\n         for (trait_ref, assoc_items) in traits {\n-            p!(\n-                write(\"{}\", if first { \" \" } else { \" + \" }),\n-                print(trait_ref.skip_binder().print_only_trait_name())\n-            );\n+            write!(self, \"{}\", if first { \"\" } else { \" + \" })?;\n+\n+            self = self.wrap_binder(&trait_ref, |trait_ref, mut cx| {\n+                define_scoped_cx!(cx);\n+                p!(print(trait_ref.print_only_trait_name()));\n \n-            let generics = self.tcx().generics_of(trait_ref.def_id());\n-            let args = generics.own_substs_no_defaults(self.tcx(), trait_ref.skip_binder().substs);\n+                let generics = tcx.generics_of(trait_ref.def_id);\n+                let args = generics.own_substs_no_defaults(tcx, trait_ref.substs);\n \n-            if !args.is_empty() || !assoc_items.is_empty() {\n-                let mut first = true;\n+                if !args.is_empty() || !assoc_items.is_empty() {\n+                    let mut first = true;\n \n-                for ty in args {\n-                    if first {\n-                        p!(\"<\");\n-                        first = false;\n-                    } else {\n-                        p!(\", \");\n+                    for ty in args {\n+                        if first {\n+                            p!(\"<\");\n+                            first = false;\n+                        } else {\n+                            p!(\", \");\n+                        }\n+                        p!(print(ty));\n                     }\n-                    p!(print(trait_ref.rebind(*ty)));\n-                }\n \n-                for (assoc_item_def_id, term) in assoc_items {\n-                    // Skip printing `<[generator@] as Generator<_>>::Return` from async blocks,\n-                    // unless we can find out what generator return type it comes from.\n-                    let term = if let Some(ty) = term.skip_binder().ty()\n-                        && let ty::Projection(ty::ProjectionTy { item_def_id, substs }) = ty.kind()\n-                        && Some(*item_def_id) == self.tcx().lang_items().generator_return()\n-                    {\n-                        if let ty::Generator(_, substs, _) = substs.type_at(0).kind() {\n-                            let return_ty = substs.as_generator().return_ty();\n-                            if !return_ty.is_ty_infer() {\n-                                return_ty.into()\n+                    for (assoc_item_def_id, term) in assoc_items {\n+                        // Skip printing `<[generator@] as Generator<_>>::Return` from async blocks,\n+                        // unless we can find out what generator return type it comes from.\n+                        let term = if let Some(ty) = term.skip_binder().ty()\n+                            && let ty::Projection(ty::ProjectionTy { item_def_id, substs }) = ty.kind()\n+                            && Some(*item_def_id) == tcx.lang_items().generator_return()\n+                        {\n+                            if let ty::Generator(_, substs, _) = substs.type_at(0).kind() {\n+                                let return_ty = substs.as_generator().return_ty();\n+                                if !return_ty.is_ty_infer() {\n+                                    return_ty.into()\n+                                } else {\n+                                    continue;\n+                                }\n                             } else {\n                                 continue;\n                             }\n                         } else {\n-                            continue;\n-                        }\n-                    } else {\n-                        term.skip_binder()\n-                    };\n+                            term.skip_binder()\n+                        };\n \n-                    if first {\n-                        p!(\"<\");\n-                        first = false;\n-                    } else {\n-                        p!(\", \");\n-                    }\n+                        if first {\n+                            p!(\"<\");\n+                            first = false;\n+                        } else {\n+                            p!(\", \");\n+                        }\n \n-                    p!(write(\"{} = \", self.tcx().associated_item(assoc_item_def_id).name));\n+                        p!(write(\"{} = \", tcx.associated_item(assoc_item_def_id).name));\n \n-                    match term {\n-                        Term::Ty(ty) => {\n-                            p!(print(ty))\n-                        }\n-                        Term::Const(c) => {\n-                            p!(print(c));\n-                        }\n-                    };\n-                }\n+                        match term {\n+                            Term::Ty(ty) => {\n+                                p!(print(ty))\n+                            }\n+                            Term::Const(c) => {\n+                                p!(print(c));\n+                            }\n+                        };\n+                    }\n \n-                if !first {\n-                    p!(\">\");\n+                    if !first {\n+                        p!(\">\");\n+                    }\n                 }\n-            }\n \n-            first = false;\n+                first = false;\n+                Ok(cx)\n+            })?;\n         }\n \n         if !is_sized {\n-            p!(write(\"{}?Sized\", if first { \" \" } else { \" + \" }));\n+            write!(self, \"{}?Sized\", if first { \"\" } else { \" + \" })?;\n         } else if first {\n-            p!(\" Sized\");\n+            write!(self, \"Sized\")?;\n         }\n \n         Ok(self)\n@@ -1869,7 +1876,7 @@ impl<'tcx> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx> {\n         self.pretty_in_binder(value)\n     }\n \n-    fn wrap_binder<T, C: Fn(&T, Self) -> Result<Self, Self::Error>>(\n+    fn wrap_binder<T, C: FnOnce(&T, Self) -> Result<Self, Self::Error>>(\n         self,\n         value: &ty::Binder<'tcx, T>,\n         f: C,\n@@ -2256,7 +2263,7 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n         Ok(inner)\n     }\n \n-    pub fn pretty_wrap_binder<T, C: Fn(&T, Self) -> Result<Self, fmt::Error>>(\n+    pub fn pretty_wrap_binder<T, C: FnOnce(&T, Self) -> Result<Self, fmt::Error>>(\n         self,\n         value: &ty::Binder<'tcx, T>,\n         f: C,"}, {"sha": "79a13ce2fcac969cd4b99c4d8511fd260b85ec88", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e1a6fb463e7075572cee841525bf44a864da807/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e1a6fb463e7075572cee841525bf44a864da807/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=0e1a6fb463e7075572cee841525bf44a864da807", "patch": "@@ -994,6 +994,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         span,\n                         rcvr_ty,\n                         item_name,\n+                        args.map(|args| args.len()),\n                         source,\n                         out_of_scope_traits,\n                         &unsatisfied_predicates,\n@@ -1732,6 +1733,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         rcvr_ty: Ty<'tcx>,\n         item_name: Ident,\n+        inputs_len: Option<usize>,\n         source: SelfSource<'tcx>,\n         valid_out_of_scope_traits: Vec<DefId>,\n         unsatisfied_predicates: &[(\n@@ -1808,7 +1810,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // Explicitly ignore the `Pin::as_ref()` method as `Pin` does not\n                         // implement the `AsRef` trait.\n                         let skip = skippable.contains(&did)\n-                            || ((\"Pin::new\" == *pre) && (sym::as_ref == item_name.name));\n+                            || ((\"Pin::new\" == *pre) && (sym::as_ref == item_name.name))\n+                            || inputs_len.map_or(false, |inputs_len| pick.item.kind == ty::AssocKind::Fn && self.tcx.fn_sig(pick.item.def_id).skip_binder().inputs().len() != inputs_len);\n                         // Make sure the method is defined for the *actual* receiver: we don't\n                         // want to treat `Box<Self>` as a receiver if it only works because of\n                         // an autoderef to `&self`"}, {"sha": "ea410849694ca9ab7b83b5f700707c45c99f23bc", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0e1a6fb463e7075572cee841525bf44a864da807/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e1a6fb463e7075572cee841525bf44a864da807/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=0e1a6fb463e7075572cee841525bf44a864da807", "patch": "@@ -150,6 +150,19 @@ pub(crate) fn maybe_download_ci_llvm(builder: &Builder<'_>) {\n         for binary in [\"llvm-config\", \"FileCheck\"] {\n             builder.fix_bin_or_dylib(&llvm_root.join(\"bin\").join(binary));\n         }\n+\n+        // Update the timestamp of llvm-config to force rustc_llvm to be\n+        // rebuilt. This is a hacky workaround for a deficiency in Cargo where\n+        // the rerun-if-changed directive doesn't handle changes very well.\n+        // https://github.com/rust-lang/cargo/issues/10791\n+        // Cargo only compares the timestamp of the file relative to the last\n+        // time `rustc_llvm` build script ran. However, the timestamps of the\n+        // files in the tarball are in the past, so it doesn't trigger a\n+        // rebuild.\n+        let now = filetime::FileTime::from_system_time(std::time::SystemTime::now());\n+        let llvm_config = llvm_root.join(\"bin/llvm-config\");\n+        t!(filetime::set_file_times(&llvm_config, now, now));\n+\n         let llvm_lib = llvm_root.join(\"lib\");\n         for entry in t!(fs::read_dir(&llvm_lib)) {\n             let lib = t!(entry).path();"}, {"sha": "5b37ecf19da9407de7043581816ea77a8290c2a8", "filename": "src/librustdoc/html/static/css/themes/ayu.css", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e1a6fb463e7075572cee841525bf44a864da807/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/0e1a6fb463e7075572cee841525bf44a864da807/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css?ref=0e1a6fb463e7075572cee841525bf44a864da807", "patch": "@@ -629,11 +629,11 @@ kbd {\n \tcolor: #fff;\n \tborder-bottom-color: #5c6773;\n }\n-div.files > a:hover, div.name:hover {\n+#source-sidebar div.files > a:hover, div.name:hover {\n \tbackground-color: #14191f;\n \tcolor: #ffb44c;\n }\n-div.files > .selected {\n+#source-sidebar div.files > .selected {\n \tbackground-color: #14191f;\n \tcolor: #ffb44c;\n }"}, {"sha": "ffb59f7762b6df65df324287333435425505e567", "filename": "src/librustdoc/html/static/css/themes/dark.css", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e1a6fb463e7075572cee841525bf44a864da807/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/0e1a6fb463e7075572cee841525bf44a864da807/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css?ref=0e1a6fb463e7075572cee841525bf44a864da807", "patch": "@@ -499,10 +499,10 @@ kbd {\n #source-sidebar > .title {\n \tborder-bottom-color: #ccc;\n }\n-div.files > a:hover, div.name:hover {\n+#source-sidebar div.files > a:hover, div.name:hover {\n \tbackground-color: #444;\n }\n-div.files > .selected {\n+#source-sidebar div.files > .selected {\n \tbackground-color: #333;\n }\n "}, {"sha": "ba798ee2a0eea2c85b0a47460ab8374623f44caa", "filename": "src/librustdoc/html/static/css/themes/light.css", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e1a6fb463e7075572cee841525bf44a864da807/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/0e1a6fb463e7075572cee841525bf44a864da807/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css?ref=0e1a6fb463e7075572cee841525bf44a864da807", "patch": "@@ -483,10 +483,10 @@ kbd {\n #source-sidebar > .title {\n \tborder-bottom-color: #ccc;\n }\n-div.files > a:hover, div.name:hover {\n+#source-sidebar div.files > a:hover, div.name:hover {\n \tbackground-color: #E0E0E0;\n }\n-div.files > .selected {\n+#source-sidebar div.files > .selected {\n \tbackground-color: #fff;\n }\n "}, {"sha": "8f53e8627ee1c8bb973c5c270a478c89c788571c", "filename": "src/test/rustdoc-gui/sidebar-source-code-display.goml", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/0e1a6fb463e7075572cee841525bf44a864da807/src%2Ftest%2Frustdoc-gui%2Fsidebar-source-code-display.goml", "raw_url": "https://github.com/rust-lang/rust/raw/0e1a6fb463e7075572cee841525bf44a864da807/src%2Ftest%2Frustdoc-gui%2Fsidebar-source-code-display.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsidebar-source-code-display.goml?ref=0e1a6fb463e7075572cee841525bf44a864da807", "patch": "@@ -17,3 +17,102 @@ assert-css: (\".sidebar > *:not(#sidebar-toggle)\", {\"visibility\": \"hidden\", \"opac\n click: \"#sidebar-toggle\"\n // Because of the transition CSS, we check by using `wait-for-css` instead of `assert-css`.\n wait-for-css: (\"#sidebar-toggle\", {\"visibility\": \"visible\", \"opacity\": 1})\n+\n+// Now we check the display of the sidebar items.\n+show-text: true\n+\n+// First we start with the light theme.\n+local-storage: {\"rustdoc-theme\": \"light\", \"rustdoc-use-system-theme\": \"false\"}\n+reload:\n+// Waiting for the sidebar to be displayed...\n+wait-for-css: (\"#sidebar-toggle\", {\"visibility\": \"visible\", \"opacity\": 1})\n+assert-css: (\n+    \"#source-sidebar .expand + .children a.selected\",\n+    {\"color\": \"rgb(0, 0, 0)\", \"background-color\": \"rgb(255, 255, 255)\"},\n+)\n+// Without hover.\n+assert-css: (\n+    \"#source-sidebar .expand + .children > .files a:not(.selected)\",\n+    {\"color\": \"rgb(0, 0, 0)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n+)\n+// With hover.\n+move-cursor-to: \"#source-sidebar .expand + .children > .files a:not(.selected)\"\n+assert-css: (\n+    \"#source-sidebar .expand + .children > .files a:not(.selected)\",\n+    {\"color\": \"rgb(0, 0, 0)\", \"background-color\": \"rgb(224, 224, 224)\"},\n+)\n+// Without hover.\n+assert-css: (\n+    \"#source-sidebar .expand + .children .folders .name\",\n+    {\"color\": \"rgb(0, 0, 0)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n+)\n+// With hover.\n+move-cursor-to: \"#source-sidebar .expand + .children .folders .name\"\n+assert-css: (\n+    \"#source-sidebar .expand + .children .folders .name\",\n+    {\"color\": \"rgb(0, 0, 0)\", \"background-color\": \"rgb(224, 224, 224)\"},\n+)\n+\n+// Now with the dark theme.\n+local-storage: {\"rustdoc-theme\": \"dark\", \"rustdoc-use-system-theme\": \"false\"}\n+reload:\n+// Waiting for the sidebar to be displayed...\n+wait-for-css: (\"#sidebar-toggle\", {\"visibility\": \"visible\", \"opacity\": 1})\n+assert-css: (\n+    \"#source-sidebar .expand + .children a.selected\",\n+    {\"color\": \"rgb(221, 221, 221)\", \"background-color\": \"rgb(51, 51, 51)\"},\n+)\n+// Without hover.\n+assert-css: (\n+    \"#source-sidebar .expand + .children > .files a:not(.selected)\",\n+    {\"color\": \"rgb(221, 221, 221)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n+)\n+// With hover.\n+move-cursor-to: \"#source-sidebar .expand + .children > .files a:not(.selected)\"\n+assert-css: (\n+    \"#source-sidebar .expand + .children > .files a:not(.selected)\",\n+    {\"color\": \"rgb(221, 221, 221)\", \"background-color\": \"rgb(68, 68, 68)\"},\n+)\n+// Without hover.\n+assert-css: (\n+    \"#source-sidebar .expand + .children .folders .name\",\n+    {\"color\": \"rgb(221, 221, 221)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n+)\n+// With hover.\n+move-cursor-to: \"#source-sidebar .expand + .children .folders .name\"\n+assert-css: (\n+    \"#source-sidebar .expand + .children .folders .name\",\n+    {\"color\": \"rgb(221, 221, 221)\", \"background-color\": \"rgb(68, 68, 68)\"},\n+)\n+\n+// And finally with the ayu theme.\n+local-storage: {\"rustdoc-theme\": \"ayu\", \"rustdoc-use-system-theme\": \"false\"}\n+reload:\n+// Waiting for the sidebar to be displayed...\n+wait-for-css: (\"#sidebar-toggle\", {\"visibility\": \"visible\", \"opacity\": 1})\n+assert-css: (\n+    \"#source-sidebar .expand + .children a.selected\",\n+    {\"color\": \"rgb(255, 180, 76)\", \"background-color\": \"rgb(20, 25, 31)\"},\n+)\n+// Without hover.\n+assert-css: (\n+    \"#source-sidebar .expand + .children > .files a:not(.selected)\",\n+    {\"color\": \"rgb(197, 197, 197)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n+)\n+// With hover.\n+move-cursor-to: \"#source-sidebar .expand + .children > .files a:not(.selected)\"\n+assert-css: (\n+    \"#source-sidebar .expand + .children > .files a:not(.selected)\",\n+    {\"color\": \"rgb(255, 180, 76)\", \"background-color\": \"rgb(20, 25, 31)\"},\n+)\n+// Without hover.\n+assert-css: (\n+    \"#source-sidebar .expand + .children .folders .name\",\n+    {\"color\": \"rgb(197, 197, 197)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n+)\n+// With hover.\n+move-cursor-to: \"#source-sidebar .expand + .children .folders .name\"\n+assert-css: (\n+    \"#source-sidebar .expand + .children .folders .name\",\n+    {\"color\": \"rgb(255, 180, 76)\", \"background-color\": \"rgb(20, 25, 31)\"},\n+)"}, {"sha": "e9b76b19dc4075d32d8100dd70b29dcef7b0b6ad", "filename": "src/test/ui/async-await/issue-70935-complex-spans.drop_tracking.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e1a6fb463e7075572cee841525bf44a864da807/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.drop_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e1a6fb463e7075572cee841525bf44a864da807/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.drop_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.drop_tracking.stderr?ref=0e1a6fb463e7075572cee841525bf44a864da807", "patch": "@@ -22,7 +22,7 @@ LL |   async fn baz<T>(_c: impl FnMut() -> T) where T: Future<Output=()> {\n LL | |\n LL | | }\n    | |_^\n-   = note: required because it captures the following types: `ResumeTy`, `impl Future<Output = ()>`, `()`\n+   = note: required because it captures the following types: `ResumeTy`, `impl for<'r, 's, 't0> Future<Output = ()>`, `()`\n note: required because it's used within this `async` block\n   --> $DIR/issue-70935-complex-spans.rs:23:16\n    |"}, {"sha": "e2ac43fffc9efdeb830c0c33c1047dec0b0b3c8f", "filename": "src/test/ui/backtrace.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e1a6fb463e7075572cee841525bf44a864da807/src%2Ftest%2Fui%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e1a6fb463e7075572cee841525bf44a864da807/src%2Ftest%2Fui%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbacktrace.rs?ref=0e1a6fb463e7075572cee841525bf44a864da807", "patch": "@@ -44,6 +44,7 @@ fn expected(fn_name: &str) -> String {\n     format!(\" backtrace::{}\", fn_name)\n }\n \n+#[cfg(not(panic = \"abort\"))]\n fn contains_verbose_expected(s: &str, fn_name: &str) -> bool {\n     // HACK(eddyb) work around the fact that verbosely demangled stack traces\n     // (from `RUST_BACKTRACE=full`, or, as is the case here, panic-in-panic)"}, {"sha": "273b5dcdb098545f91f83bf01d7db6a47598fe66", "filename": "src/test/ui/impl-trait/printing-binder.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0e1a6fb463e7075572cee841525bf44a864da807/src%2Ftest%2Fui%2Fimpl-trait%2Fprinting-binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e1a6fb463e7075572cee841525bf44a864da807/src%2Ftest%2Fui%2Fimpl-trait%2Fprinting-binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fprinting-binder.rs?ref=0e1a6fb463e7075572cee841525bf44a864da807", "patch": "@@ -0,0 +1,14 @@\n+trait Trait<'a> {}\n+impl<T> Trait<'_> for T {}\n+fn whatever() -> impl for<'a> Trait<'a> + for<'b> Trait<'b> {}\n+\n+fn whatever2() -> impl for<'c> Fn(&'c ()) {\n+    |_: &()| {}\n+}\n+\n+fn main() {\n+    let x: u32 = whatever();\n+    //~^ ERROR mismatched types\n+    let x2: u32 = whatever2();\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "5ffec8af1028915defdee18a6ab16434e8ea1bc9", "filename": "src/test/ui/impl-trait/printing-binder.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0e1a6fb463e7075572cee841525bf44a864da807/src%2Ftest%2Fui%2Fimpl-trait%2Fprinting-binder.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e1a6fb463e7075572cee841525bf44a864da807/src%2Ftest%2Fui%2Fimpl-trait%2Fprinting-binder.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fprinting-binder.stderr?ref=0e1a6fb463e7075572cee841525bf44a864da807", "patch": "@@ -0,0 +1,31 @@\n+error[E0308]: mismatched types\n+  --> $DIR/printing-binder.rs:10:18\n+   |\n+LL | fn whatever() -> impl for<'a> Trait<'a> + for<'b> Trait<'b> {}\n+   |                  ------------------------------------------ the found opaque type\n+...\n+LL |     let x: u32 = whatever();\n+   |            ---   ^^^^^^^^^^ expected `u32`, found opaque type\n+   |            |\n+   |            expected due to this\n+   |\n+   = note:     expected type `u32`\n+           found opaque type `impl for<'a> Trait<'a> + for<'b> Trait<'b>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/printing-binder.rs:12:19\n+   |\n+LL | fn whatever2() -> impl for<'c> Fn(&'c ()) {\n+   |                   ----------------------- the found opaque type\n+...\n+LL |     let x2: u32 = whatever2();\n+   |             ---   ^^^^^^^^^^^ expected `u32`, found opaque type\n+   |             |\n+   |             expected due to this\n+   |\n+   = note:     expected type `u32`\n+           found opaque type `impl for<'c> Fn(&'c ())`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "acb897571d64e38d809064cae77e1b670e19d7bd", "filename": "src/test/ui/suggestions/dont-suggest-pin-array-dot-set.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0e1a6fb463e7075572cee841525bf44a864da807/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-pin-array-dot-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e1a6fb463e7075572cee841525bf44a864da807/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-pin-array-dot-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-pin-array-dot-set.rs?ref=0e1a6fb463e7075572cee841525bf44a864da807", "patch": "@@ -0,0 +1,15 @@\n+// https://github.com/rust-lang/rust/issues/96834\n+//\n+// This test case verifies that rustc does not make an unhelpful suggestion:\n+//\n+//     help: consider wrapping the receiver expression with the appropriate type\n+//         |\n+//     14  |     Pin::new(&mut a).set(0, 3);\n+//         |     +++++++++++++  +\n+//\n+// We can tell that it isn't helpful, because `Pin::set` takes two parameters (including\n+// the receiver), but the function call on line 14 supplies three.\n+fn main() {\n+    let mut a = [0u8; 1];\n+    a.set(0, 3); //~ERROR\n+}"}, {"sha": "677aa031bf7d65dce3ca16bb54c20bf53879af7d", "filename": "src/test/ui/suggestions/dont-suggest-pin-array-dot-set.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0e1a6fb463e7075572cee841525bf44a864da807/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-pin-array-dot-set.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e1a6fb463e7075572cee841525bf44a864da807/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-pin-array-dot-set.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-pin-array-dot-set.stderr?ref=0e1a6fb463e7075572cee841525bf44a864da807", "patch": "@@ -0,0 +1,9 @@\n+error[E0599]: no method named `set` found for array `[u8; 1]` in the current scope\n+  --> $DIR/dont-suggest-pin-array-dot-set.rs:14:7\n+   |\n+LL |     a.set(0, 3);\n+   |       ^^^ help: there is an associated function with a similar name: `get`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "ece09b88c0365947af79c0ffdeea02bc6c1eec25", "filename": "src/tools/rls", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frls?ref=0e1a6fb463e7075572cee841525bf44a864da807", "patch": "@@ -1 +1 @@\n-Subproject commit 27f4044df03d15c7c38a483c3e4635cf4f51807d\n+Subproject commit ece09b88c0365947af79c0ffdeea02bc6c1eec25"}, {"sha": "0289056fdcb163889cd3d59b24e6e20afbbd2e30", "filename": "x.py", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0e1a6fb463e7075572cee841525bf44a864da807/x.py", "raw_url": "https://github.com/rust-lang/rust/raw/0e1a6fb463e7075572cee841525bf44a864da807/x.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/x.py?ref=0e1a6fb463e7075572cee841525bf44a864da807", "patch": "@@ -1,17 +1,38 @@\n-#!/usr/bin/env python\n+#!/usr/bin/env bash\n \n+# Modern Linux and macOS systems commonly only have a thing called `python3` and\n+# not `python`, while Windows commonly does not have `python3`, so we cannot\n+# directly use python in the shebang and have it consistently work. Instead we\n+# embed some bash to look for a python to run the rest of the script.\n+#\n+# On Windows, `py -3` sometimes works. We need to try it first because `python3`\n+# sometimes tries to launch the app store on Windows.\n+'''':\n+for PYTHON in \"py -3\" python3 python python2; do\n+    if command -v $PYTHON >/dev/null; then\n+        exec $PYTHON \"$0\" \"$@\"\n+        break\n+    fi\n+done\n+echo \"$0: error: did not find python installed\" >&2\n+exit 1\n+'''\n+\n+# The rest of this file is Python.\n+#\n # This file is only a \"symlink\" to bootstrap.py, all logic should go there.\n \n import os\n import sys\n \n # If this is python2, check if python3 is available and re-execute with that\n # interpreter.\n+#\n+# `./x.py` would not normally benefit from this because the bash above tries\n+# python3 before 2, but this matters if someone ran `python x.py` and their\n+# system's `python` is python2.\n if sys.version_info.major < 3:\n     try:\n-        # On Windows, `py -3` sometimes works.\n-        # Try this first, because 'python3' sometimes tries to launch the app\n-        # store on Windows\n         os.execvp(\"py\", [\"py\", \"-3\"] + sys.argv)\n     except OSError:\n         try:"}]}