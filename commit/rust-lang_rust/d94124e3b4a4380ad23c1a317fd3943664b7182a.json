{"sha": "d94124e3b4a4380ad23c1a317fd3943664b7182a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5NDEyNGUzYjRhNDM4MGFkMjNjMWEzMTdmZDM5NDM2NjRiNzE4MmE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-02-04T10:53:47Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-02-04T10:53:47Z"}, "message": "Somewhat more san directory structure", "tree": {"sha": "c11b5a548bac9dae6e77bead8f24db98dbea9dc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c11b5a548bac9dae6e77bead8f24db98dbea9dc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d94124e3b4a4380ad23c1a317fd3943664b7182a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d94124e3b4a4380ad23c1a317fd3943664b7182a", "html_url": "https://github.com/rust-lang/rust/commit/d94124e3b4a4380ad23c1a317fd3943664b7182a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d94124e3b4a4380ad23c1a317fd3943664b7182a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a40b715ce1cae4db1b4c3b4c383ee7517d4202c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a40b715ce1cae4db1b4c3b4c383ee7517d4202c4", "html_url": "https://github.com/rust-lang/rust/commit/a40b715ce1cae4db1b4c3b4c383ee7517d4202c4"}], "stats": {"total": 305, "additions": 153, "deletions": 152}, "files": [{"sha": "fd6bdc0863c78c4940e788e4cfd91e8e7e5fdb17", "filename": "src/parser/event.rs", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent.rs?ref=d94124e3b4a4380ad23c1a317fd3943664b7182a", "patch": "@@ -0,0 +1,140 @@\n+use {File, FileBuilder, Sink, SyntaxKind, Token};\n+use syntax_kinds::TOMBSTONE;\n+use super::is_insignificant;\n+\n+/// `Parser` produces a flat list of `Event`s.\n+/// They are converted to a tree-structure in\n+/// a separate pass, via `TreeBuilder`.\n+#[derive(Debug)]\n+pub(crate) enum Event {\n+    /// This event signifies the start of the node.\n+    /// It should be either abandoned (in which case the\n+    /// `kind` is `TOMBSTONE`, and the event is ignored),\n+    /// or completed via a `Finish` event.\n+    ///\n+    /// All tokens between a `Start` and a `Finish` would\n+    /// become the children of the respective node.\n+    ///\n+    /// For left-recursive syntactic constructs, the parser produces\n+    /// a child node before it sees a parent. `forward_parent`\n+    /// exists to allow to tweak parent-child relationships.\n+    ///\n+    /// Consider this path\n+    ///\n+    /// foo::bar\n+    ///\n+    /// The events for it would look like this:\n+    ///\n+    ///\n+    /// START(PATH) IDENT('foo') FINISH START(PATH) COLONCOLON IDENT('bar') FINISH\n+    ///       |                          /\\\n+    ///       |                          |\n+    ///       +------forward-parent------+\n+    ///\n+    /// And the tree would look like this\n+    ///\n+    ///    +--PATH---------+\n+    ///    |   |           |\n+    ///    |   |           |\n+    ///    |  '::'       'bar'\n+    ///    |\n+    ///   PATH\n+    ///    |\n+    ///   'foo'\n+    ///\n+    /// See also `CompleteMarker::precede`.\n+    Start {\n+        kind: SyntaxKind,\n+        forward_parent: Option<u32>,\n+    },\n+\n+    /// Complete the previous `Start` event\n+    Finish,\n+\n+    /// Produce a single leaf-element.\n+    /// `n_raw_tokens` is used to glue complex contextual tokens.\n+    /// For example, lexer tokenizes `>>` as `>`, `>`, and\n+    /// `n_raw_tokens = 2` is used to produced a single `>>`.\n+    Token {\n+        kind: SyntaxKind,\n+        n_raw_tokens: u8,\n+    },\n+\n+    Error {\n+        message: String,\n+    },\n+}\n+\n+pub(super) fn to_file(text: String, tokens: &[Token], events: Vec<Event>) -> File {\n+    let mut builder = FileBuilder::new(text);\n+    let mut idx = 0;\n+\n+    let mut holes = Vec::new();\n+    let mut forward_parents = Vec::new();\n+\n+    for (i, event) in events.iter().enumerate() {\n+        if holes.last() == Some(&i) {\n+            holes.pop();\n+            continue;\n+        }\n+\n+        match event {\n+            &Event::Start {\n+                kind: TOMBSTONE, ..\n+            } => (),\n+\n+            &Event::Start { .. } => {\n+                forward_parents.clear();\n+                let mut idx = i;\n+                loop {\n+                    let (kind, fwd) = match events[idx] {\n+                        Event::Start {\n+                            kind,\n+                            forward_parent,\n+                        } => (kind, forward_parent),\n+                        _ => unreachable!(),\n+                    };\n+                    forward_parents.push((idx, kind));\n+                    if let Some(fwd) = fwd {\n+                        idx += fwd as usize;\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                for &(idx, kind) in forward_parents.iter().into_iter().rev() {\n+                    builder.start_internal(kind);\n+                    holes.push(idx);\n+                }\n+                holes.pop();\n+            }\n+            &Event::Finish => {\n+                while idx < tokens.len() {\n+                    let token = tokens[idx];\n+                    if is_insignificant(token.kind) {\n+                        idx += 1;\n+                        builder.leaf(token.kind, token.len);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                builder.finish_internal()\n+            }\n+            &Event::Token {\n+                kind: _,\n+                mut n_raw_tokens,\n+            } => loop {\n+                let token = tokens[idx];\n+                if !is_insignificant(token.kind) {\n+                    n_raw_tokens -= 1;\n+                }\n+                idx += 1;\n+                builder.leaf(token.kind, token.len);\n+                if n_raw_tokens == 0 {\n+                    break;\n+                }\n+            },\n+            &Event::Error { ref message } => builder.error().message(message.clone()).emit(),\n+        }\n+    }\n+    builder.finish()\n+}"}, {"sha": "7823c476c200488cf38c1ff794b19a4edae7f8c2", "filename": "src/parser/event_parser/mod.rs", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/a40b715ce1cae4db1b4c3b4c383ee7517d4202c4/src%2Fparser%2Fevent_parser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40b715ce1cae4db1b4c3b4c383ee7517d4202c4/src%2Fparser%2Fevent_parser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fmod.rs?ref=a40b715ce1cae4db1b4c3b4c383ee7517d4202c4", "patch": "@@ -1,74 +0,0 @@\n-use {SyntaxKind, Token};\n-\n-#[macro_use]\n-mod parser;\n-mod grammar;\n-\n-/// `Parser` produces a flat list of `Event`s.\n-/// They are converted to a tree-structure in\n-/// a separate pass, via `TreeBuilder`.\n-#[derive(Debug)]\n-pub(crate) enum Event {\n-    /// This event signifies the start of the node.\n-    /// It should be either abandoned (in which case the\n-    /// `kind` is `TOMBSTONE`, and the event is ignored),\n-    /// or completed via a `Finish` event.\n-    ///\n-    /// All tokens between a `Start` and a `Finish` would\n-    /// become the children of the respective node.\n-    ///\n-    /// For left-recursive syntactic constructs, the parser produces\n-    /// a child node before it sees a parent. `forward_parent`\n-    /// exists to allow to tweak parent-child relationships.\n-    ///\n-    /// Consider this path\n-    ///\n-    /// foo::bar\n-    ///\n-    /// The events for it would look like this:\n-    ///\n-    ///\n-    /// START(PATH) IDENT('foo') FINISH START(PATH) COLONCOLON IDENT('bar') FINISH\n-    ///       |                          /\\\n-    ///       |                          |\n-    ///       +------forward-parent------+\n-    ///\n-    /// And the tree would look like this\n-    ///\n-    ///    +--PATH---------+\n-    ///    |   |           |\n-    ///    |   |           |\n-    ///    |  '::'       'bar'\n-    ///    |\n-    ///   PATH\n-    ///    |\n-    ///   'foo'\n-    ///\n-    /// See also `CompleteMarker::precede`.\n-    Start {\n-        kind: SyntaxKind,\n-        forward_parent: Option<u32>,\n-    },\n-\n-    /// Complete the previous `Start` event\n-    Finish,\n-\n-    /// Produce a single leaf-element.\n-    /// `n_raw_tokens` is used to glue complex contextual tokens.\n-    /// For example, lexer tokenizes `>>` as `>`, `>`, and\n-    /// `n_raw_tokens = 2` is used to produced a single `>>`.\n-    Token {\n-        kind: SyntaxKind,\n-        n_raw_tokens: u8,\n-    },\n-\n-    Error {\n-        message: String,\n-    },\n-}\n-\n-pub(crate) fn parse<'t>(text: &'t str, raw_tokens: &'t [Token]) -> Vec<Event> {\n-    let mut parser = parser::Parser::new(text, raw_tokens);\n-    grammar::file(&mut parser);\n-    parser.into_events()\n-}"}, {"sha": "8bf04afced1ce7df454bcf97dce6409c4d0a8559", "filename": "src/parser/grammar/attributes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fgrammar%2Fattributes.rs?ref=d94124e3b4a4380ad23c1a317fd3943664b7182a", "previous_filename": "src/parser/event_parser/grammar/attributes.rs"}, {"sha": "8caaf35538915da0a62536ac23658fa9638c7ca5", "filename": "src/parser/grammar/expressions.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fgrammar%2Fexpressions.rs?ref=d94124e3b4a4380ad23c1a317fd3943664b7182a", "previous_filename": "src/parser/event_parser/grammar/expressions.rs"}, {"sha": "c9881d681aa34f70757fddfabc974b540d9d9be1", "filename": "src/parser/grammar/items/consts.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Fitems%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Fitems%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fgrammar%2Fitems%2Fconsts.rs?ref=d94124e3b4a4380ad23c1a317fd3943664b7182a", "previous_filename": "src/parser/event_parser/grammar/items/consts.rs"}, {"sha": "3612802e17b9b4cc83e805b556b85a65f44673f6", "filename": "src/parser/grammar/items/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Fitems%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Fitems%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fgrammar%2Fitems%2Fmod.rs?ref=d94124e3b4a4380ad23c1a317fd3943664b7182a", "previous_filename": "src/parser/event_parser/grammar/items/mod.rs"}, {"sha": "69d95c698f0ff0dbc5398b72959b31af11dd3750", "filename": "src/parser/grammar/items/structs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Fitems%2Fstructs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Fitems%2Fstructs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fgrammar%2Fitems%2Fstructs.rs?ref=d94124e3b4a4380ad23c1a317fd3943664b7182a", "previous_filename": "src/parser/event_parser/grammar/items/structs.rs"}, {"sha": "3bef9639f0297715d6f50501aec3e2433baefac3", "filename": "src/parser/grammar/items/traits.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Fitems%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Fitems%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fgrammar%2Fitems%2Ftraits.rs?ref=d94124e3b4a4380ad23c1a317fd3943664b7182a", "previous_filename": "src/parser/event_parser/grammar/items/traits.rs"}, {"sha": "38e7b3f8a521e23b90699f1d4f5718a66384cc65", "filename": "src/parser/grammar/items/use_item.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Fitems%2Fuse_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Fitems%2Fuse_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fgrammar%2Fitems%2Fuse_item.rs?ref=d94124e3b4a4380ad23c1a317fd3943664b7182a", "previous_filename": "src/parser/event_parser/grammar/items/use_item.rs"}, {"sha": "afce308d0ce9e137ebc1a19184b4d68cc5e04c6e", "filename": "src/parser/grammar/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fgrammar%2Fmod.rs?ref=d94124e3b4a4380ad23c1a317fd3943664b7182a", "previous_filename": "src/parser/event_parser/grammar/mod.rs"}, {"sha": "6efac26103789507381095638c7f9e590446848b", "filename": "src/parser/grammar/paths.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fgrammar%2Fpaths.rs?ref=d94124e3b4a4380ad23c1a317fd3943664b7182a", "previous_filename": "src/parser/event_parser/grammar/paths.rs"}, {"sha": "12c9a53627e827f34bdd46eb80c5e09bbd383630", "filename": "src/parser/grammar/type_params.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Ftype_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Ftype_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fgrammar%2Ftype_params.rs?ref=d94124e3b4a4380ad23c1a317fd3943664b7182a", "previous_filename": "src/parser/event_parser/grammar/type_params.rs"}, {"sha": "1a3d44a0ab9ded0dd85a4639a8435360132196d2", "filename": "src/parser/grammar/types.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fgrammar%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fgrammar%2Ftypes.rs?ref=d94124e3b4a4380ad23c1a317fd3943664b7182a", "previous_filename": "src/parser/event_parser/grammar/types.rs"}, {"sha": "22ccb4921679678ddc9176619585a5af29793dc0", "filename": "src/parser/mod.rs", "status": "modified", "additions": 12, "deletions": 77, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fmod.rs?ref=d94124e3b4a4380ad23c1a317fd3943664b7182a", "patch": "@@ -1,88 +1,23 @@\n-use {File, FileBuilder, Sink, SyntaxKind, Token};\n+use {File, SyntaxKind, Token};\n \n use syntax_kinds::*;\n \n-mod event_parser;\n-use self::event_parser::Event;\n+#[macro_use]\n+mod parser;\n+mod event;\n+mod grammar;\n+use self::event::Event;\n \n /// Parse a sequence of tokens into the representative node tree\n pub fn parse(text: String, tokens: &[Token]) -> File {\n-    let events = event_parser::parse(&text, tokens);\n-    from_events_to_file(text, tokens, events)\n+    let events = parse_into_events(&text, tokens);\n+    event::to_file(text, tokens, events)\n }\n \n-fn from_events_to_file(text: String, tokens: &[Token], events: Vec<Event>) -> File {\n-    let mut builder = FileBuilder::new(text);\n-    let mut idx = 0;\n-\n-    let mut holes = Vec::new();\n-    let mut forward_parents = Vec::new();\n-\n-    for (i, event) in events.iter().enumerate() {\n-        if holes.last() == Some(&i) {\n-            holes.pop();\n-            continue;\n-        }\n-\n-        match event {\n-            &Event::Start {\n-                kind: TOMBSTONE, ..\n-            } => (),\n-\n-            &Event::Start { .. } => {\n-                forward_parents.clear();\n-                let mut idx = i;\n-                loop {\n-                    let (kind, fwd) = match events[idx] {\n-                        Event::Start {\n-                            kind,\n-                            forward_parent,\n-                        } => (kind, forward_parent),\n-                        _ => unreachable!(),\n-                    };\n-                    forward_parents.push((idx, kind));\n-                    if let Some(fwd) = fwd {\n-                        idx += fwd as usize;\n-                    } else {\n-                        break;\n-                    }\n-                }\n-                for &(idx, kind) in forward_parents.iter().into_iter().rev() {\n-                    builder.start_internal(kind);\n-                    holes.push(idx);\n-                }\n-                holes.pop();\n-            }\n-            &Event::Finish => {\n-                while idx < tokens.len() {\n-                    let token = tokens[idx];\n-                    if is_insignificant(token.kind) {\n-                        idx += 1;\n-                        builder.leaf(token.kind, token.len);\n-                    } else {\n-                        break;\n-                    }\n-                }\n-                builder.finish_internal()\n-            }\n-            &Event::Token {\n-                kind: _,\n-                mut n_raw_tokens,\n-            } => loop {\n-                let token = tokens[idx];\n-                if !is_insignificant(token.kind) {\n-                    n_raw_tokens -= 1;\n-                }\n-                idx += 1;\n-                builder.leaf(token.kind, token.len);\n-                if n_raw_tokens == 0 {\n-                    break;\n-                }\n-            },\n-            &Event::Error { ref message } => builder.error().message(message.clone()).emit(),\n-        }\n-    }\n-    builder.finish()\n+pub(crate) fn parse_into_events<'t>(text: &'t str, raw_tokens: &'t [Token]) -> Vec<Event> {\n+    let mut parser = parser::Parser::new(text, raw_tokens);\n+    grammar::file(&mut parser);\n+    parser.into_events()\n }\n \n fn is_insignificant(kind: SyntaxKind) -> bool {"}, {"sha": "3f4c8a07d0c13435890c1bb8659edeb30bf2e812", "filename": "src/parser/parser.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94124e3b4a4380ad23c1a317fd3943664b7182a/src%2Fparser%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fparser.rs?ref=d94124e3b4a4380ad23c1a317fd3943664b7182a", "patch": "@@ -1,6 +1,6 @@\n use {SyntaxKind, TextUnit, Token};\n use super::Event;\n-use super::super::is_insignificant;\n+use super::is_insignificant;\n use SyntaxKind::{EOF, TOMBSTONE};\n \n pub(crate) struct Marker {", "previous_filename": "src/parser/event_parser/parser.rs"}]}