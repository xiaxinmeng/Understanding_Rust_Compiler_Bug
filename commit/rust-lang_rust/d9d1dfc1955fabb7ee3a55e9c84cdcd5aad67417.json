{"sha": "d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5ZDFkZmMxOTU1ZmFiYjdlZTNhNTVlOWM4NGNkY2Q1YWFkNjc0MTc=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-09-15T16:50:17Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-10-02T14:55:41Z"}, "message": "std: Replace num::IntConvertible with {To,From}Primitive", "tree": {"sha": "44ee6031936df55eb8d34db48298b2a67b21cc3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44ee6031936df55eb8d34db48298b2a67b21cc3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417", "html_url": "https://github.com/rust-lang/rust/commit/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17548378a707fae752dc722e2fb767a65195e422", "url": "https://api.github.com/repos/rust-lang/rust/commits/17548378a707fae752dc722e2fb767a65195e422", "html_url": "https://github.com/rust-lang/rust/commit/17548378a707fae752dc722e2fb767a65195e422"}], "stats": {"total": 905, "additions": 582, "deletions": 323}, "files": [{"sha": "493bbfa14b968d0e1f482d21169622d3e900e953", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 212, "deletions": 211, "changes": 423, "blob_url": "https://github.com/rust-lang/rust/blob/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417", "patch": "@@ -22,7 +22,8 @@ A `BigInt` is a combination of `BigUint` and `Sign`.\n use std::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use std::int;\n use std::num;\n-use std::num::{IntConvertible, Zero, One, ToStrRadix, FromStrRadix, Orderable};\n+use std::num::{Zero, One, ToStrRadix, FromStrRadix, Orderable};\n+use std::num::{ToPrimitive, FromPrimitive};\n use std::rand::Rng;\n use std::str;\n use std::uint;\n@@ -500,15 +501,49 @@ impl Integer for BigUint {\n     fn is_odd(&self) -> bool { !self.is_even() }\n }\n \n-impl IntConvertible for BigUint {\n+impl ToPrimitive for BigUint {\n     #[inline]\n-    fn to_int(&self) -> int {\n-        self.to_int_opt().expect(\"BigUint conversion would overflow int\")\n+    fn to_int(&self) -> Option<int> {\n+        do self.to_uint().and_then |n| {\n+            // If top bit of uint is set, it's too large to convert to\n+            // int.\n+            if (n >> (2*BigDigit::bits - 1) != 0) {\n+                None\n+            } else {\n+                Some(n as int)\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn to_uint(&self) -> Option<uint> {\n+        match self.data.len() {\n+            0 => Some(0),\n+            1 => Some(self.data[0] as uint),\n+            2 => Some(BigDigit::to_uint(self.data[1], self.data[0])),\n+            _ => None\n+        }\n+    }\n+}\n+\n+impl FromPrimitive for BigUint {\n+    #[inline]\n+    fn from_int(n: int) -> Option<BigUint> {\n+        if (n < 0) {\n+            Some(Zero::zero())\n+        } else {\n+            FromPrimitive::from_uint(n as uint)\n+        }\n     }\n \n     #[inline]\n-    fn from_int(n: int) -> BigUint {\n-        if (n < 0) { Zero::zero() } else { BigUint::from_uint(n as uint) }\n+    fn from_uint(n: uint) -> Option<BigUint> {\n+        let n = match BigDigit::from_uint(n) {\n+            (0,  0)  => Zero::zero(),\n+            (0,  n0) => BigUint::new(~[n0]),\n+            (n1, n0) => BigUint::new(~[n0, n1])\n+        };\n+        Some(n)\n     }\n }\n \n@@ -522,16 +557,16 @@ impl ToStrRadix for BigUint {\n         return fill_concat(convert_base((*self).clone(), base), radix, max_len);\n \n         fn convert_base(n: BigUint, base: uint) -> ~[BigDigit] {\n-            let divider    = BigUint::from_uint(base);\n+            let divider    = FromPrimitive::from_uint(base).unwrap();\n             let mut result = ~[];\n             let mut m      = n;\n             while m > divider {\n                 let (d, m0) = m.div_mod_floor(&divider);\n-                result.push(m0.to_uint() as BigDigit);\n+                result.push(m0.to_uint().unwrap() as BigDigit);\n                 m = d;\n             }\n             if !m.is_zero() {\n-                result.push(m.to_uint() as BigDigit);\n+                result.push(m.to_uint().unwrap() as BigDigit);\n             }\n             return result;\n         }\n@@ -571,38 +606,39 @@ impl BigUint {\n         return BigUint { data: v };\n     }\n \n-    /// Creates and initializes a `BigUint`.\n-    #[inline]\n-    pub fn from_uint(n: uint) -> BigUint {\n-        match BigDigit::from_uint(n) {\n-            (0,  0)  => Zero::zero(),\n-            (0,  n0) => BigUint::new(~[n0]),\n-            (n1, n0) => BigUint::new(~[n0, n1])\n-        }\n-    }\n-\n     /// Creates and initializes a `BigUint`.\n     #[inline]\n     pub fn from_slice(slice: &[BigDigit]) -> BigUint {\n         return BigUint::new(slice.to_owned());\n     }\n \n     /// Creates and initializes a `BigUint`.\n-    pub fn parse_bytes(buf: &[u8], radix: uint)\n-        -> Option<BigUint> {\n+    pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<BigUint> {\n         let (base, unit_len) = get_radix_base(radix);\n-        let base_num: BigUint = BigUint::from_uint(base);\n+        let base_num = match FromPrimitive::from_uint(base) {\n+            Some(base_num) => base_num,\n+            None => { return None; }\n+        };\n \n         let mut end             = buf.len();\n         let mut n: BigUint      = Zero::zero();\n         let mut power: BigUint  = One::one();\n         loop {\n             let start = num::max(end, unit_len) - unit_len;\n             match uint::parse_bytes(buf.slice(start, end), radix) {\n-                // FIXME(#6102): Assignment operator for BigInt causes ICE\n-                // Some(d) => n += BigUint::from_uint(d) * power,\n-                Some(d) => n = n + BigUint::from_uint(d) * power,\n-                None    => return None\n+                Some(d) => {\n+                    let d: Option<BigUint> = FromPrimitive::from_uint(d);\n+                    match d {\n+                        Some(d) => {\n+                            // FIXME(#6102): Assignment operator for BigInt\n+                            // causes ICE:\n+                            // n += d * power;\n+                            n = n + d * power;\n+                        }\n+                        None => { return None; }\n+                    }\n+                }\n+                None => { return None; }\n             }\n             if end <= unit_len {\n                 return Some(n);\n@@ -614,39 +650,7 @@ impl BigUint {\n         }\n     }\n \n-\n-    /// Converts this `BigUint` into a `uint`, failing if the conversion\n-    /// would overflow.\n-    #[inline]\n-    pub fn to_uint(&self) -> uint {\n-        self.to_uint_opt().expect(\"BigUint conversion would overflow uint\")\n-    }\n-\n-    /// Converts this `BigUint` into a `uint`, unless it would overflow.\n-    #[inline]\n-    pub fn to_uint_opt(&self) -> Option<uint> {\n-        match self.data.len() {\n-            0 => Some(0),\n-            1 => Some(self.data[0] as uint),\n-            2 => Some(BigDigit::to_uint(self.data[1], self.data[0])),\n-            _ => None\n-        }\n-    }\n-\n-    /// Converts this `BigUint` into an `int`, unless it would overflow.\n-    pub fn to_int_opt(&self) -> Option<int> {\n-        self.to_uint_opt().and_then(|n| {\n-            // If top bit of uint is set, it's too large to convert to\n-            // int.\n-            if (n >> (2*BigDigit::bits - 1) != 0) {\n-                None\n-            } else {\n-                Some(n as int)\n-            }\n-        })\n-    }\n-\n-    /// Converts this `BigUint` into a `BigInt`.\n+    /// Converts this `BigUint` into a `BigInt.\n     #[inline]\n     pub fn to_bigint(&self) -> BigInt {\n         BigInt::from_biguint(Plus, self.clone())\n@@ -1077,23 +1081,62 @@ impl Integer for BigInt {\n     fn is_odd(&self) -> bool { self.data.is_odd() }\n }\n \n-impl IntConvertible for BigInt {\n+impl ToPrimitive for BigInt {\n+    #[inline]\n+    fn to_int(&self) -> Option<int> {\n+        match self.sign {\n+            Plus  => self.data.to_int(),\n+            Zero  => Some(0),\n+            Minus => {\n+                do self.data.to_uint().and_then |n| {\n+                    let m: uint = 1 << (2*BigDigit::bits-1);\n+                    if (n > m) {\n+                        None\n+                    } else if (n == m) {\n+                        Some(int::min_value)\n+                    } else {\n+                        Some(-(n as int))\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     #[inline]\n-    fn to_int(&self) -> int {\n-        self.to_int_opt().expect(\"BigInt conversion would overflow int\")\n+    fn to_uint(&self) -> Option<uint> {\n+        match self.sign {\n+            Plus => self.data.to_uint(),\n+            Zero => Some(0),\n+            Minus => None\n+        }\n     }\n+}\n \n+impl FromPrimitive for BigInt {\n     #[inline]\n-    fn from_int(n: int) -> BigInt {\n+    fn from_int(n: int) -> Option<BigInt> {\n         if n > 0 {\n-           return BigInt::from_biguint(Plus,  BigUint::from_uint(n as uint));\n+            do FromPrimitive::from_uint(n as uint).and_then |n| {\n+                Some(BigInt::from_biguint(Plus, n))\n+            }\n+        } else if n < 0 {\n+            do FromPrimitive::from_uint(uint::max_value - (n as uint) + 1).and_then |n| {\n+                Some(BigInt::from_biguint(Minus, n))\n+            }\n+        } else {\n+            Some(Zero::zero())\n         }\n-        if n < 0 {\n-            return BigInt::from_biguint(\n-                Minus, BigUint::from_uint(uint::max_value - (n as uint) + 1)\n-            );\n+    }\n+\n+    #[inline]\n+    fn from_uint(n: uint) -> Option<BigInt> {\n+        if n == 0 {\n+            Some(Zero::zero())\n+        } else {\n+            do FromPrimitive::from_uint(n).and_then |n| {\n+                Some(BigInt::from_biguint(Plus, n))\n+            }\n         }\n-        return Zero::zero();\n     }\n }\n \n@@ -1196,7 +1239,7 @@ impl<R: Rng> RandBigInt for R {\n                         ubound: &BigInt)\n                         -> BigInt {\n         assert!(*lbound < *ubound);\n-        let delta = (*ubound - *lbound).to_biguint();\n+        let delta = (*ubound - *lbound).to_biguint().unwrap();\n         return *lbound + self.gen_biguint_below(&delta).to_bigint();\n     }\n }\n@@ -1217,13 +1260,6 @@ impl BigInt {\n         return BigInt { sign: sign, data: data };\n     }\n \n-    /// Creates and initializes a `BigInt`.\n-    #[inline]\n-    pub fn from_uint(n: uint) -> BigInt {\n-        if n == 0 { return Zero::zero(); }\n-        return BigInt::from_biguint(Plus, BigUint::from_uint(n));\n-    }\n-\n     /// Creates and initializes a `BigInt`.\n     #[inline]\n     pub fn from_slice(sign: Sign, slice: &[BigDigit]) -> BigInt {\n@@ -1244,51 +1280,9 @@ impl BigInt {\n             .map_move(|bu| BigInt::from_biguint(sign, bu));\n     }\n \n-    /// Converts this `BigInt` into a `uint`, failing if the conversion\n-    /// would overflow.\n-    #[inline]\n-    pub fn to_uint(&self) -> uint {\n-        self.to_uint_opt().expect(\"BigInt conversion would overflow uint\")\n-    }\n-\n-    /// Converts this `BigInt` into a `uint`, unless it would overflow.\n-    #[inline]\n-    pub fn to_uint_opt(&self) -> Option<uint> {\n-        match self.sign {\n-            Plus => self.data.to_uint_opt(),\n-            Zero => Some(0),\n-            Minus => None\n-        }\n-    }\n-\n-    /// Converts this `BigInt` into an `int`, unless it would overflow.\n-    pub fn to_int_opt(&self) -> Option<int> {\n-        match self.sign {\n-            Plus  => self.data.to_int_opt(),\n-            Zero  => Some(0),\n-            Minus => self.data.to_uint_opt().and_then(|n| {\n-                let m: uint = 1 << (2*BigDigit::bits-1);\n-                if (n > m) {\n-                    None\n-                } else if (n == m) {\n-                    Some(int::min_value)\n-                } else {\n-                    Some(-(n as int))\n-                }\n-            })\n-        }\n-    }\n-\n-    /// Converts this `BigInt` into a `BigUint`, failing if BigInt is\n-    /// negative.\n-    #[inline]\n-    pub fn to_biguint(&self) -> BigUint {\n-        self.to_biguint_opt().expect(\"negative BigInt cannot convert to BigUint\")\n-    }\n-\n     /// Converts this `BigInt` into a `BigUint`, if it's not negative.\n     #[inline]\n-    pub fn to_biguint_opt(&self) -> Option<BigUint> {\n+    pub fn to_biguint(&self) -> Option<BigUint> {\n         match self.sign {\n             Plus => Some(self.data.clone()),\n             Zero => Some(Zero::zero()),\n@@ -1304,7 +1298,8 @@ mod biguint_tests {\n \n     use std::cmp::{Less, Equal, Greater};\n     use std::int;\n-    use std::num::{IntConvertible, Zero, One, FromStrRadix};\n+    use std::num::{Zero, One, FromStrRadix};\n+    use std::num::{ToPrimitive, FromPrimitive};\n     use std::rand::{task_rng};\n     use std::str;\n     use std::uint;\n@@ -1482,9 +1477,10 @@ mod biguint_tests {\n     #[test]\n     fn test_convert_int() {\n         fn check(v: ~[BigDigit], i: int) {\n-            let b = BigUint::new(v);\n-            assert!(b == IntConvertible::from_int(i));\n-            assert!(b.to_int() == i);\n+            let b1 = BigUint::new(v);\n+            let b2: BigUint = FromPrimitive::from_int(i).unwrap();\n+            assert!(b1 == b2);\n+            assert!(b1.to_int().unwrap() == i);\n         }\n \n         check(~[], 0);\n@@ -1493,17 +1489,18 @@ mod biguint_tests {\n         check(~[ 0,  1], ((uint::max_value >> BigDigit::bits) + 1) as int);\n         check(~[-1, -1 >> 1], int::max_value);\n \n-        assert_eq!(BigUint::new(~[0, -1]).to_int_opt(), None);\n-        assert_eq!(BigUint::new(~[0, 0, 1]).to_int_opt(), None);\n-        assert_eq!(BigUint::new(~[0, 0, -1]).to_int_opt(), None);\n+        assert_eq!(BigUint::new(~[0, -1]).to_int(), None);\n+        assert_eq!(BigUint::new(~[0, 0, 1]).to_int(), None);\n+        assert_eq!(BigUint::new(~[0, 0, -1]).to_int(), None);\n     }\n \n     #[test]\n     fn test_convert_uint() {\n         fn check(v: ~[BigDigit], u: uint) {\n-            let b = BigUint::new(v);\n-            assert!(b == BigUint::from_uint(u));\n-            assert!(b.to_uint() == u);\n+            let b1 = BigUint::new(v);\n+            let b2: BigUint = FromPrimitive::from_uint(u).unwrap();\n+            assert!(b1 == b2);\n+            assert!(b1.to_uint().unwrap() == u);\n         }\n \n         check(~[], 0);\n@@ -1513,15 +1510,15 @@ mod biguint_tests {\n         check(~[ 0, -1], uint::max_value << BigDigit::bits);\n         check(~[-1, -1], uint::max_value);\n \n-        assert_eq!(BigUint::new(~[0, 0, 1]).to_uint_opt(), None);\n-        assert_eq!(BigUint::new(~[0, 0, -1]).to_uint_opt(), None);\n+        assert_eq!(BigUint::new(~[0, 0, 1]).to_uint(), None);\n+        assert_eq!(BigUint::new(~[0, 0, -1]).to_uint(), None);\n     }\n \n     #[test]\n     fn test_convert_to_bigint() {\n         fn check(n: BigUint, ans: BigInt) {\n             assert_eq!(n.to_bigint(), ans);\n-            assert_eq!(n.to_bigint().to_biguint(), n);\n+            assert_eq!(n.to_bigint().to_biguint().unwrap(), n);\n         }\n         check(Zero::zero(), Zero::zero());\n         check(BigUint::new(~[1,2,3]),\n@@ -1660,9 +1657,9 @@ mod biguint_tests {\n     #[test]\n     fn test_gcd() {\n         fn check(a: uint, b: uint, c: uint) {\n-            let big_a = BigUint::from_uint(a);\n-            let big_b = BigUint::from_uint(b);\n-            let big_c = BigUint::from_uint(c);\n+            let big_a: BigUint = FromPrimitive::from_uint(a).unwrap();\n+            let big_b: BigUint = FromPrimitive::from_uint(b).unwrap();\n+            let big_c: BigUint = FromPrimitive::from_uint(c).unwrap();\n \n             assert_eq!(big_a.gcd(&big_b), big_c);\n         }\n@@ -1677,9 +1674,9 @@ mod biguint_tests {\n     #[test]\n     fn test_lcm() {\n         fn check(a: uint, b: uint, c: uint) {\n-            let big_a = BigUint::from_uint(a);\n-            let big_b = BigUint::from_uint(b);\n-            let big_c = BigUint::from_uint(c);\n+            let big_a: BigUint = FromPrimitive::from_uint(a).unwrap();\n+            let big_b: BigUint = FromPrimitive::from_uint(b).unwrap();\n+            let big_c: BigUint = FromPrimitive::from_uint(c).unwrap();\n \n             assert_eq!(big_a.lcm(&big_b), big_c);\n         }\n@@ -1694,20 +1691,18 @@ mod biguint_tests {\n \n     #[test]\n     fn test_is_even() {\n-        let one: Option<BigUint> = FromStr::from_str(\"1\");\n-        let two: Option<BigUint> = FromStr::from_str(\"2\");\n-        let thousand: Option<BigUint> = FromStr::from_str(\"1000\");\n-        let big: Option<BigUint> =\n-            FromStr::from_str(\"1000000000000000000000\");\n-        let bigger: Option<BigUint> =\n-            FromStr::from_str(\"1000000000000000000001\");\n-        assert!(one.unwrap().is_odd());\n-        assert!(two.unwrap().is_even());\n-        assert!(thousand.unwrap().is_even());\n-        assert!(big.unwrap().is_even());\n-        assert!(bigger.unwrap().is_odd());\n-        assert!((BigUint::from_uint(1) << 64).is_even());\n-        assert!(((BigUint::from_uint(1) << 64) + BigUint::from_uint(1)).is_odd());\n+        let one: BigUint = FromStr::from_str(\"1\").unwrap();\n+        let two: BigUint = FromStr::from_str(\"2\").unwrap();\n+        let thousand: BigUint = FromStr::from_str(\"1000\").unwrap();\n+        let big: BigUint = FromStr::from_str(\"1000000000000000000000\").unwrap();\n+        let bigger: BigUint = FromStr::from_str(\"1000000000000000000001\").unwrap();\n+        assert!(one.is_odd());\n+        assert!(two.is_even());\n+        assert!(thousand.is_even());\n+        assert!(big.is_even());\n+        assert!(bigger.is_odd());\n+        assert!((one << 64).is_even());\n+        assert!(((one << 64) + one).is_odd());\n     }\n \n     fn to_str_pairs() -> ~[ (BigUint, ~[(uint, ~str)]) ] {\n@@ -1805,8 +1800,8 @@ mod biguint_tests {\n             let mut f: BigUint = One::one();\n             for i in range(2, n + 1) {\n                 // FIXME(#6102): Assignment operator for BigInt causes ICE\n-                // f *= BigUint::from_uint(i);\n-                f = f * BigUint::from_uint(i);\n+                // f *= FromPrimitive::from_uint(i);\n+                f = f * FromPrimitive::from_uint(i).unwrap();\n             }\n             return f;\n         }\n@@ -1828,9 +1823,12 @@ mod biguint_tests {\n     #[test]\n     fn test_bits() {\n         assert_eq!(BigUint::new(~[0,0,0,0]).bits(), 0);\n-        assert_eq!(BigUint::from_uint(0).bits(), 0);\n-        assert_eq!(BigUint::from_uint(1).bits(), 1);\n-        assert_eq!(BigUint::from_uint(3).bits(), 2);\n+        let n: BigUint = FromPrimitive::from_uint(0).unwrap();\n+        assert_eq!(n.bits(), 0);\n+        let n: BigUint = FromPrimitive::from_uint(1).unwrap();\n+        assert_eq!(n.bits(), 1);\n+        let n: BigUint = FromPrimitive::from_uint(3).unwrap();\n+        assert_eq!(n.bits(), 2);\n         let n: BigUint = FromStrRadix::from_str_radix(\"4000000000\", 16).unwrap();\n         assert_eq!(n.bits(), 39);\n         let one: BigUint = One::one();\n@@ -1849,13 +1847,13 @@ mod biguint_tests {\n         let mut rng = task_rng();\n \n         do 10.times {\n-            assert_eq!(rng.gen_bigint_range(&BigInt::from_uint(236),\n-                                            &BigInt::from_uint(237)),\n-                       BigInt::from_uint(236));\n+            assert_eq!(rng.gen_bigint_range(&FromPrimitive::from_uint(236).unwrap(),\n+                                            &FromPrimitive::from_uint(237).unwrap()),\n+                       FromPrimitive::from_uint(236).unwrap());\n         }\n \n-        let l = BigUint::from_uint(403469000 + 2352);\n-        let u = BigUint::from_uint(403469000 + 3513);\n+        let l = FromPrimitive::from_uint(403469000 + 2352).unwrap();\n+        let u = FromPrimitive::from_uint(403469000 + 3513).unwrap();\n         do 1000.times {\n             let n: BigUint = rng.gen_biguint_below(&u);\n             assert!(n < u);\n@@ -1869,16 +1867,16 @@ mod biguint_tests {\n     #[test]\n     #[should_fail]\n     fn test_zero_rand_range() {\n-        task_rng().gen_biguint_range(&BigUint::from_uint(54),\n-                                     &BigUint::from_uint(54));\n+        task_rng().gen_biguint_range(&FromPrimitive::from_uint(54).unwrap(),\n+                                     &FromPrimitive::from_uint(54).unwrap());\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_negative_rand_range() {\n         let mut rng = task_rng();\n-        let l = BigUint::from_uint(2352);\n-        let u = BigUint::from_uint(3513);\n+        let l = FromPrimitive::from_uint(2352).unwrap();\n+        let u = FromPrimitive::from_uint(3513).unwrap();\n         // Switching u and l should fail:\n         let _n: BigUint = rng.gen_biguint_range(&u, &l);\n     }\n@@ -1890,15 +1888,16 @@ mod bigint_tests {\n \n     use std::cmp::{Less, Equal, Greater};\n     use std::int;\n-    use std::num::{IntConvertible, Zero, One, FromStrRadix};\n+    use std::num::{Zero, One, FromStrRadix};\n+    use std::num::{ToPrimitive, FromPrimitive};\n     use std::rand::{task_rng};\n     use std::uint;\n \n     #[test]\n     fn test_from_biguint() {\n         fn check(inp_s: Sign, inp_n: uint, ans_s: Sign, ans_n: uint) {\n-            let inp = BigInt::from_biguint(inp_s, BigUint::from_uint(inp_n));\n-            let ans = BigInt { sign: ans_s, data: BigUint::from_uint(ans_n)};\n+            let inp = BigInt::from_biguint(inp_s, FromPrimitive::from_uint(inp_n).unwrap());\n+            let ans = BigInt { sign: ans_s, data: FromPrimitive::from_uint(ans_n).unwrap()};\n             assert_eq!(inp, ans);\n         }\n         check(Plus, 1, Plus, 1);\n@@ -1952,61 +1951,62 @@ mod bigint_tests {\n \n     #[test]\n     fn test_convert_int() {\n-        fn check(b: BigInt, i: int) {\n-            assert!(b == IntConvertible::from_int(i));\n-            assert!(b.to_int() == i);\n+        fn check(b1: BigInt, i: int) {\n+            let b2: BigInt = FromPrimitive::from_int(i).unwrap();\n+            assert!(b1 == b2);\n+            assert!(b1.to_int().unwrap() == i);\n         }\n \n         check(Zero::zero(), 0);\n         check(One::one(), 1);\n         check(BigInt::from_biguint(\n-            Plus, BigUint::from_uint(int::max_value as uint)\n+            Plus, FromPrimitive::from_uint(int::max_value as uint).unwrap()\n         ), int::max_value);\n \n         assert_eq!(BigInt::from_biguint(\n-            Plus, BigUint::from_uint(int::max_value as uint + 1)\n-        ).to_int_opt(), None);\n+            Plus, FromPrimitive::from_uint(int::max_value as uint + 1).unwrap()\n+        ).to_int(), None);\n         assert_eq!(BigInt::from_biguint(\n             Plus, BigUint::new(~[1, 2, 3])\n-        ).to_int_opt(), None);\n+        ).to_int(), None);\n \n         check(BigInt::from_biguint(\n             Minus, BigUint::new(~[0, 1<<(BigDigit::bits-1)])\n         ), int::min_value);\n         assert_eq!(BigInt::from_biguint(\n             Minus, BigUint::new(~[1, 1<<(BigDigit::bits-1)])\n-        ).to_int_opt(), None);\n+        ).to_int(), None);\n         assert_eq!(BigInt::from_biguint(\n-            Minus, BigUint::new(~[1, 2, 3])).to_int_opt(), None);\n+            Minus, BigUint::new(~[1, 2, 3])).to_int(), None);\n     }\n \n     #[test]\n     fn test_convert_uint() {\n-        fn check(b: BigInt, u: uint) {\n-            assert!(b == BigInt::from_uint(u));\n-            assert!(b.to_uint() == u);\n+        fn check(b1: BigInt, u: uint) {\n+            let b2: BigInt = FromPrimitive::from_uint(u).unwrap();\n+            assert!(b1 == b2);\n+            assert!(b1.to_uint().unwrap() == u);\n         }\n \n         check(Zero::zero(), 0);\n         check(One::one(), 1);\n \n         check(\n-            BigInt::from_biguint(Plus, BigUint::from_uint(uint::max_value)),\n+            BigInt::from_biguint(Plus, FromPrimitive::from_uint(uint::max_value).unwrap()),\n             uint::max_value);\n         assert_eq!(BigInt::from_biguint(\n-            Plus, BigUint::new(~[1, 2, 3])).to_uint_opt(), None);\n+            Plus, BigUint::new(~[1, 2, 3])).to_uint(), None);\n \n-        assert_eq!(BigInt::from_biguint(\n-            Minus, BigUint::from_uint(uint::max_value)).to_uint_opt(), None);\n-        assert_eq!(BigInt::from_biguint(\n-            Minus, BigUint::new(~[1, 2, 3])).to_uint_opt(), None);\n+        let max_value: BigUint = FromPrimitive::from_uint(uint::max_value).unwrap();\n+        assert_eq!(BigInt::from_biguint(Minus, max_value).to_uint(), None);\n+        assert_eq!(BigInt::from_biguint(Minus, BigUint::new(~[1, 2, 3])).to_uint(), None);\n     }\n \n     #[test]\n     fn test_convert_to_biguint() {\n         fn check(n: BigInt, ans_1: BigUint) {\n-            assert_eq!(n.to_biguint(), ans_1);\n-            assert_eq!(n.to_biguint().to_bigint(), n);\n+            assert_eq!(n.to_biguint().unwrap(), ans_1);\n+            assert_eq!(n.to_biguint().unwrap().to_bigint(), n);\n         }\n         let zero: BigInt = Zero::zero();\n         let unsigned_zero: BigUint = Zero::zero();\n@@ -2017,7 +2017,7 @@ mod bigint_tests {\n         check(zero, unsigned_zero);\n         check(positive, BigUint::new(~[1,2,3]));\n \n-        assert_eq!(negative.to_biguint_opt(), None);\n+        assert_eq!(negative.to_biguint(), None);\n     }\n \n     static sum_triples: &'static [(&'static [BigDigit],\n@@ -2233,9 +2233,9 @@ mod bigint_tests {\n     #[test]\n     fn test_gcd() {\n         fn check(a: int, b: int, c: int) {\n-            let big_a: BigInt = IntConvertible::from_int(a);\n-            let big_b: BigInt = IntConvertible::from_int(b);\n-            let big_c: BigInt = IntConvertible::from_int(c);\n+            let big_a: BigInt = FromPrimitive::from_int(a).unwrap();\n+            let big_b: BigInt = FromPrimitive::from_int(b).unwrap();\n+            let big_c: BigInt = FromPrimitive::from_int(c).unwrap();\n \n             assert_eq!(big_a.gcd(&big_b), big_c);\n         }\n@@ -2253,9 +2253,9 @@ mod bigint_tests {\n     #[test]\n     fn test_lcm() {\n         fn check(a: int, b: int, c: int) {\n-            let big_a: BigInt = IntConvertible::from_int(a);\n-            let big_b: BigInt = IntConvertible::from_int(b);\n-            let big_c: BigInt = IntConvertible::from_int(c);\n+            let big_a: BigInt = FromPrimitive::from_int(a).unwrap();\n+            let big_b: BigInt = FromPrimitive::from_int(b).unwrap();\n+            let big_c: BigInt = FromPrimitive::from_int(c).unwrap();\n \n             assert_eq!(big_a.lcm(&big_b), big_c);\n         }\n@@ -2282,13 +2282,14 @@ mod bigint_tests {\n         let zero: BigInt = Zero::zero();\n         assert_eq!(one.abs_sub(&zero), one);\n         let one: BigInt = One::one();\n-        assert_eq!(one.abs_sub(&-one), IntConvertible::from_int(2));\n+        let two: BigInt = FromPrimitive::from_int(2).unwrap();\n+        assert_eq!(one.abs_sub(&-one), two);\n     }\n \n     #[test]\n     fn test_to_str_radix() {\n         fn check(n: int, ans: &str) {\n-            let n: BigInt = IntConvertible::from_int(n);\n+            let n: BigInt = FromPrimitive::from_int(n).unwrap();\n             assert!(ans == n.to_str_radix(10));\n         }\n         check(10, \"10\");\n@@ -2303,7 +2304,7 @@ mod bigint_tests {\n     fn test_from_str_radix() {\n         fn check(s: &str, ans: Option<int>) {\n             let ans = ans.map_move(|n| {\n-                let x: BigInt = IntConvertible::from_int(n);\n+                let x: BigInt = FromPrimitive::from_int(n).unwrap();\n                 x\n             });\n             assert_eq!(FromStrRadix::from_str_radix(s, 10), ans);\n@@ -2339,9 +2340,9 @@ mod bigint_tests {\n         let mut rng = task_rng();\n \n         do 10.times {\n-            assert_eq!(rng.gen_bigint_range(&BigInt::from_uint(236),\n-                                            &BigInt::from_uint(237)),\n-                       BigInt::from_uint(236));\n+            assert_eq!(rng.gen_bigint_range(&FromPrimitive::from_uint(236).unwrap(),\n+                                            &FromPrimitive::from_uint(237).unwrap()),\n+                       FromPrimitive::from_uint(236).unwrap());\n         }\n \n         fn check(l: BigInt, u: BigInt) {\n@@ -2352,8 +2353,8 @@ mod bigint_tests {\n                 assert!(n < u);\n             }\n         }\n-        let l = BigInt::from_uint(403469000 + 2352);\n-        let u = BigInt::from_uint(403469000 + 3513);\n+        let l: BigInt = FromPrimitive::from_uint(403469000 + 2352).unwrap();\n+        let u: BigInt = FromPrimitive::from_uint(403469000 + 3513).unwrap();\n         check( l.clone(),  u.clone());\n         check(-l.clone(),  u.clone());\n         check(-u.clone(), -l.clone());\n@@ -2362,16 +2363,16 @@ mod bigint_tests {\n     #[test]\n     #[should_fail]\n     fn test_zero_rand_range() {\n-        task_rng().gen_bigint_range(&IntConvertible::from_int(54),\n-                                    &IntConvertible::from_int(54));\n+        task_rng().gen_bigint_range(&FromPrimitive::from_int(54).unwrap(),\n+                                    &FromPrimitive::from_int(54).unwrap());\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_negative_rand_range() {\n         let mut rng = task_rng();\n-        let l = BigInt::from_uint(2352);\n-        let u = BigInt::from_uint(3513);\n+        let l = FromPrimitive::from_uint(2352).unwrap();\n+        let u = FromPrimitive::from_uint(3513).unwrap();\n         // Switching u and l should fail:\n         let _n: BigInt = rng.gen_bigint_range(&u, &l);\n     }\n@@ -2381,13 +2382,13 @@ mod bigint_tests {\n mod bench {\n     use super::*;\n     use std::{iter, util};\n-    use std::num::{Zero, One};\n+    use std::num::{FromPrimitive, Zero, One};\n     use extra::test::BenchHarness;\n \n     fn factorial(n: uint) -> BigUint {\n         let mut f: BigUint = One::one();\n         for i in iter::range_inclusive(1, n) {\n-            f = f * BigUint::from_uint(i);\n+            f = f * FromPrimitive::from_uint(i).unwrap();\n         }\n         f\n     }"}, {"sha": "a8dfdfbfd0018d8d118d014296ecbb6c890c29b8", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417", "patch": "@@ -306,7 +306,7 @@ impl<T: FromStrRadix + Clone + Integer + Ord>\n mod test {\n \n     use super::*;\n-    use std::num::{Zero,One,FromStrRadix,IntConvertible};\n+    use std::num::{Zero,One,FromStrRadix,FromPrimitive};\n     use std::from_str::FromStr;\n \n     pub static _0 : Rational = Ratio { numer: 0, denom: 1};\n@@ -318,8 +318,8 @@ mod test {\n \n     pub fn to_big(n: Rational) -> BigRational {\n         Ratio::new(\n-            IntConvertible::from_int(n.numer),\n-            IntConvertible::from_int(n.denom)\n+            FromPrimitive::from_int(n.numer).unwrap(),\n+            FromPrimitive::from_int(n.denom).unwrap()\n         )\n     }\n "}, {"sha": "52695100b3ee755baef9aaf4a422640fc78086da", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417", "patch": "@@ -107,7 +107,7 @@ use std::hashmap::HashMap;\n use std::libc::{c_uint, c_ulonglong, c_longlong};\n use std::ptr;\n use std::vec;\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, Pos};\n use syntax::{ast, codemap, ast_util, ast_map, opt_vec, visit};\n use syntax::parse::token;\n use syntax::parse::token::special_idents;"}, {"sha": "d5219ed0867483ab39d581755d727884e7236e9b", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417", "patch": "@@ -26,7 +26,7 @@ use middle::ty;\n use middle::typeck;\n use syntax::abi::AbiSet;\n use syntax::ast_map;\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, Pos};\n use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};"}, {"sha": "a8c85184664750190c153ebc7914511a16387752", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 341, "deletions": 83, "changes": 424, "blob_url": "https://github.com/rust-lang/rust/blob/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417", "patch": "@@ -32,11 +32,6 @@ pub trait Num: Eq + Zero + One\n              + Div<Self,Self>\n              + Rem<Self,Self> {}\n \n-pub trait IntConvertible {\n-    fn to_int(&self) -> int;\n-    fn from_int(n: int) -> Self;\n-}\n-\n pub trait Orderable: Ord {\n     // These should be methods on `Ord`, with overridable default implementations. We don't want\n     // to encumber all implementors of Ord by requiring them to implement these functions, but at\n@@ -353,6 +348,298 @@ pub trait Float: Real\n #[inline(always)] pub fn ln_1p<T: Float>(value: T) -> T { value.ln_1p() }\n #[inline(always)] pub fn mul_add<T: Float>(a: T, b: T, c: T) -> T { a.mul_add(b, c) }\n \n+/// A generic trait for converting a value to a number.\n+pub trait ToPrimitive {\n+    /// Converts the value of `self` to an `int`.\n+    fn to_int(&self) -> Option<int>;\n+\n+    /// Converts the value of `self` to an `i8`.\n+    #[inline]\n+    fn to_i8(&self) -> Option<i8> {\n+        // XXX: Check for range.\n+        self.to_int().and_then(|x| Some(x as i8))\n+    }\n+\n+    /// Converts the value of `self` to an `i16`.\n+    #[inline]\n+    fn to_i16(&self) -> Option<i16> {\n+        // XXX: Check for range.\n+        self.to_int().and_then(|x| Some(x as i16))\n+    }\n+\n+    /// Converts the value of `self` to an `i32`.\n+    #[inline]\n+    fn to_i32(&self) -> Option<i32> {\n+        // XXX: Check for range.\n+        self.to_int().and_then(|x| Some(x as i32))\n+    }\n+\n+    /// Converts the value of `self` to an `i64`.\n+    #[inline]\n+    fn to_i64(&self) -> Option<i64> {\n+        // XXX: Check for range.\n+        self.to_int().and_then(|x| Some(x as i64))\n+    }\n+\n+    /// Converts the value of `self` to an `uint`.\n+    fn to_uint(&self) -> Option<uint>;\n+\n+    /// Converts the value of `self` to an `u8`.\n+    #[inline]\n+    fn to_u8(&self) -> Option<u8> {\n+        // XXX: Check for range.\n+        self.to_uint().and_then(|x| Some(x as u8))\n+    }\n+\n+    /// Converts the value of `self` to an `u16`.\n+    #[inline]\n+    fn to_u16(&self) -> Option<u16> {\n+        // XXX: Check for range.\n+        self.to_uint().and_then(|x| Some(x as u16))\n+    }\n+\n+    /// Converts the value of `self` to an `u32`.\n+    #[inline]\n+    fn to_u32(&self) -> Option<u32> {\n+        // XXX: Check for range.\n+        self.to_uint().and_then(|x| Some(x as u32))\n+    }\n+\n+    /// Converts the value of `self` to an `u64`.\n+    #[inline]\n+    fn to_u64(&self) -> Option<u64> {\n+        // XXX: Check for range.\n+        self.to_uint().and_then(|x| Some(x as u64))\n+    }\n+\n+    /// Converts the value of `self` to an `f32`.\n+    #[inline]\n+    fn to_f32(&self) -> Option<f32> {\n+        // XXX: Check for range.\n+        self.to_float().and_then(|x| Some(x as f32))\n+    }\n+\n+    /// Converts the value of `self` to an `f64`.\n+    #[inline]\n+    fn to_f64(&self) -> Option<f64> {\n+        // XXX: Check for range.\n+        self.to_float().and_then(|x| Some(x as f64))\n+    }\n+}\n+\n+macro_rules! impl_to_primitive(\n+    ($T:ty) => (\n+        impl ToPrimitive for $T {\n+            #[inline] fn to_int(&self)   -> Option<int>   { Some(*self as int)   }\n+            #[inline] fn to_i8(&self)    -> Option<i8>    { Some(*self as i8)    }\n+            #[inline] fn to_i16(&self)   -> Option<i16>   { Some(*self as i16)   }\n+            #[inline] fn to_i32(&self)   -> Option<i32>   { Some(*self as i32)   }\n+            #[inline] fn to_i64(&self)   -> Option<i64>   { Some(*self as i64)   }\n+\n+            #[inline] fn to_uint(&self)  -> Option<uint>  { Some(*self as uint)  }\n+            #[inline] fn to_u8(&self)    -> Option<u8>    { Some(*self as u8)    }\n+            #[inline] fn to_u16(&self)   -> Option<u16>   { Some(*self as u16)   }\n+            #[inline] fn to_u32(&self)   -> Option<u32>   { Some(*self as u32)   }\n+            #[inline] fn to_u64(&self)   -> Option<u64>   { Some(*self as u64)   }\n+\n+            #[inline] fn to_float(&self) -> Option<float> { Some(*self as float) }\n+            #[inline] fn to_f32(&self)   -> Option<f32>   { Some(*self as f32)   }\n+            #[inline] fn to_f64(&self)   -> Option<f64>   { Some(*self as f64)   }\n+        }\n+    )\n+)\n+\n+impl_to_primitive!(u8)\n+impl_to_primitive!(u16)\n+impl_to_primitive!(u32)\n+impl_to_primitive!(u64)\n+impl_to_primitive!(uint)\n+impl_to_primitive!(i8)\n+impl_to_primitive!(i16)\n+impl_to_primitive!(i32)\n+impl_to_primitive!(i64)\n+impl_to_primitive!(int)\n+impl_to_primitive!(f32)\n+impl_to_primitive!(f64)\n+impl_to_primitive!(float)\n+\n+/// A generic trait for converting a number to a value.\n+pub trait FromPrimitive {\n+    /// Convert an `int` to return an optional value of this type. If the\n+    /// value cannot be represented by this value, the `None` is returned.\n+    fn from_int(n: int) -> Option<Self>;\n+\n+    /// Convert an `i8` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_i8(n: i8) -> Option<Self> {\n+        FromPrimitive::from_int(n as int)\n+    }\n+\n+    /// Convert an `i16` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_i16(n: i16) -> Option<Self> {\n+        FromPrimitive::from_int(n as int)\n+    }\n+\n+    /// Convert an `i32` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_i32(n: i32) -> Option<Self> {\n+        FromPrimitive::from_int(n as int)\n+    }\n+\n+    /// Convert an `i64` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_i64(n: i64) -> Option<Self> {\n+        FromPrimitive::from_int(n as int)\n+    }\n+\n+    /// Convert an `uint` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    fn from_uint(n: uint) -> Option<Self>;\n+\n+    /// Convert an `u8` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_u8(n: u8) -> Option<Self> {\n+        FromPrimitive::from_uint(n as uint)\n+    }\n+\n+    /// Convert an `u16` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_u16(n: u16) -> Option<Self> {\n+        FromPrimitive::from_uint(n as uint)\n+    }\n+\n+    /// Convert an `u32` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_u32(n: u32) -> Option<Self> {\n+        FromPrimitive::from_uint(n as uint)\n+    }\n+\n+    /// Convert an `u64` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_u64(n: u64) -> Option<Self> {\n+        FromPrimitive::from_uint(n as uint)\n+    }\n+\n+    /// Convert a `f32` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_f32(n: f32) -> Option<Self> {\n+        FromPrimitive::from_float(n as float)\n+    }\n+\n+    /// Convert a `f64` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_f64(n: f64) -> Option<Self> {\n+        FromPrimitive::from_float(n as float)\n+    }\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_int`.\n+pub fn from_int<A: FromPrimitive>(n: int) -> Option<A> {\n+    FromPrimitive::from_int(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_i8`.\n+pub fn from_i8<A: FromPrimitive>(n: i8) -> Option<A> {\n+    FromPrimitive::from_i8(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_i16`.\n+pub fn from_i16<A: FromPrimitive>(n: i16) -> Option<A> {\n+    FromPrimitive::from_i16(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_i32`.\n+pub fn from_i32<A: FromPrimitive>(n: i32) -> Option<A> {\n+    FromPrimitive::from_i32(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_i64`.\n+pub fn from_i64<A: FromPrimitive>(n: i64) -> Option<A> {\n+    FromPrimitive::from_i64(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_uint`.\n+pub fn from_uint<A: FromPrimitive>(n: uint) -> Option<A> {\n+    FromPrimitive::from_uint(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_u8`.\n+pub fn from_u8<A: FromPrimitive>(n: u8) -> Option<A> {\n+    FromPrimitive::from_u8(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_u16`.\n+pub fn from_u16<A: FromPrimitive>(n: u16) -> Option<A> {\n+    FromPrimitive::from_u16(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_u32`.\n+pub fn from_u32<A: FromPrimitive>(n: u32) -> Option<A> {\n+    FromPrimitive::from_u32(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_u64`.\n+pub fn from_u64<A: FromPrimitive>(n: u64) -> Option<A> {\n+    FromPrimitive::from_u64(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_f32`.\n+pub fn from_f32<A: FromPrimitive>(n: f32) -> Option<A> {\n+    FromPrimitive::from_f32(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_f64`.\n+pub fn from_f64<A: FromPrimitive>(n: f64) -> Option<A> {\n+    FromPrimitive::from_f64(n)\n+}\n+\n+macro_rules! impl_from_primitive(\n+    ($T:ty) => (\n+        impl FromPrimitive for $T {\n+            #[inline] fn from_int(n: int)     -> Option<$T> { Some(n as $T) }\n+            #[inline] fn from_i8(n: i8)       -> Option<$T> { Some(n as $T) }\n+            #[inline] fn from_i16(n: i16)     -> Option<$T> { Some(n as $T) }\n+            #[inline] fn from_i32(n: i32)     -> Option<$T> { Some(n as $T) }\n+            #[inline] fn from_i64(n: i64)     -> Option<$T> { Some(n as $T) }\n+\n+            #[inline] fn from_uint(n: uint)   -> Option<$T> { Some(n as $T) }\n+            #[inline] fn from_u8(n: u8)       -> Option<$T> { Some(n as $T) }\n+            #[inline] fn from_u16(n: u16)     -> Option<$T> { Some(n as $T) }\n+            #[inline] fn from_u32(n: u32)     -> Option<$T> { Some(n as $T) }\n+            #[inline] fn from_u64(n: u64)     -> Option<$T> { Some(n as $T) }\n+\n+            #[inline] fn from_float(n: float) -> Option<$T> { Some(n as $T) }\n+            #[inline] fn from_f32(n: f32)     -> Option<$T> { Some(n as $T) }\n+            #[inline] fn from_f64(n: f64)     -> Option<$T> { Some(n as $T) }\n+        }\n+    )\n+)\n+\n+impl_from_primitive!(u8)\n+impl_from_primitive!(u16)\n+impl_from_primitive!(u32)\n+impl_from_primitive!(u64)\n+impl_from_primitive!(uint)\n+impl_from_primitive!(i8)\n+impl_from_primitive!(i16)\n+impl_from_primitive!(i32)\n+impl_from_primitive!(i64)\n+impl_from_primitive!(int)\n+impl_from_primitive!(f32)\n+impl_from_primitive!(f64)\n+impl_from_primitive!(float)\n+\n /// Cast from one machine scalar to another\n ///\n /// # Example\n@@ -363,54 +650,24 @@ pub trait Float: Real\n /// ```\n ///\n #[inline]\n-pub fn cast<T:NumCast,U:NumCast>(n: T) -> U {\n+pub fn cast<T: NumCast,U: NumCast>(n: T) -> Option<U> {\n     NumCast::from(n)\n }\n \n /// An interface for casting between machine scalars\n-pub trait NumCast {\n-    fn from<T:NumCast>(n: T) -> Self;\n-\n-    fn to_u8(&self) -> u8;\n-    fn to_u16(&self) -> u16;\n-    fn to_u32(&self) -> u32;\n-    fn to_u64(&self) -> u64;\n-    fn to_uint(&self) -> uint;\n-\n-    fn to_i8(&self) -> i8;\n-    fn to_i16(&self) -> i16;\n-    fn to_i32(&self) -> i32;\n-    fn to_i64(&self) -> i64;\n-    fn to_int(&self) -> int;\n-\n-    fn to_f32(&self) -> f32;\n-    fn to_f64(&self) -> f64;\n+pub trait NumCast: ToPrimitive {\n+    fn from<T: ToPrimitive>(n: T) -> Option<Self>;\n }\n \n macro_rules! impl_num_cast(\n     ($T:ty, $conv:ident) => (\n         impl NumCast for $T {\n             #[inline]\n-            fn from<N:NumCast>(n: N) -> $T {\n+            fn from<N: ToPrimitive>(n: N) -> Option<$T> {\n                 // `$conv` could be generated using `concat_idents!`, but that\n                 // macro seems to be broken at the moment\n                 n.$conv()\n             }\n-\n-            #[inline] fn to_u8(&self)    -> u8    { *self as u8    }\n-            #[inline] fn to_u16(&self)   -> u16   { *self as u16   }\n-            #[inline] fn to_u32(&self)   -> u32   { *self as u32   }\n-            #[inline] fn to_u64(&self)   -> u64   { *self as u64   }\n-            #[inline] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-            #[inline] fn to_i8(&self)    -> i8    { *self as i8    }\n-            #[inline] fn to_i16(&self)   -> i16   { *self as i16   }\n-            #[inline] fn to_i32(&self)   -> i32   { *self as i32   }\n-            #[inline] fn to_i64(&self)   -> i64   { *self as i64   }\n-            #[inline] fn to_int(&self)   -> int   { *self as int   }\n-\n-            #[inline] fn to_f32(&self)   -> f32   { *self as f32   }\n-            #[inline] fn to_f64(&self)   -> f64   { *self as f64   }\n         }\n     )\n )\n@@ -461,7 +718,7 @@ pub fn pow_with_uint<T:NumCast+One+Zero+Div<T,T>+Mul<T,T>>(radix: uint, pow: uin\n     if radix == 0u { return _0; }\n     let mut my_pow     = pow;\n     let mut total      = _1;\n-    let mut multiplier = cast(radix);\n+    let mut multiplier = cast(radix).unwrap();\n     while (my_pow > 0u) {\n         if my_pow % 2u == 1u {\n             total = total * multiplier;\n@@ -543,11 +800,11 @@ pub trait CheckedDiv: Div<Self, Self> {\n /// Helper function for testing numeric operations\n #[cfg(test)]\n pub fn test_num<T:Num + NumCast>(ten: T, two: T) {\n-    assert_eq!(ten.add(&two),  cast(12));\n-    assert_eq!(ten.sub(&two),  cast(8));\n-    assert_eq!(ten.mul(&two),  cast(20));\n-    assert_eq!(ten.div(&two),  cast(5));\n-    assert_eq!(ten.rem(&two),  cast(0));\n+    assert_eq!(ten.add(&two),  cast(12).unwrap());\n+    assert_eq!(ten.sub(&two),  cast(8).unwrap());\n+    assert_eq!(ten.mul(&two),  cast(20).unwrap());\n+    assert_eq!(ten.div(&two),  cast(5).unwrap());\n+    assert_eq!(ten.rem(&two),  cast(0).unwrap());\n \n     assert_eq!(ten.add(&two),  ten + two);\n     assert_eq!(ten.sub(&two),  ten - two);\n@@ -566,44 +823,45 @@ mod tests {\n         ($_20:expr) => ({\n             let _20 = $_20;\n \n-            assert_eq!(20u,   _20.to_uint());\n-            assert_eq!(20u8,  _20.to_u8());\n-            assert_eq!(20u16, _20.to_u16());\n-            assert_eq!(20u32, _20.to_u32());\n-            assert_eq!(20u64, _20.to_u64());\n-            assert_eq!(20i,   _20.to_int());\n-            assert_eq!(20i8,  _20.to_i8());\n-            assert_eq!(20i16, _20.to_i16());\n-            assert_eq!(20i32, _20.to_i32());\n-            assert_eq!(20i64, _20.to_i64());\n-            assert_eq!(20f32, _20.to_f32());\n-            assert_eq!(20f64, _20.to_f64());\n-\n-            assert_eq!(_20, NumCast::from(20u));\n-            assert_eq!(_20, NumCast::from(20u8));\n-            assert_eq!(_20, NumCast::from(20u16));\n-            assert_eq!(_20, NumCast::from(20u32));\n-            assert_eq!(_20, NumCast::from(20u64));\n-            assert_eq!(_20, NumCast::from(20i));\n-            assert_eq!(_20, NumCast::from(20i8));\n-            assert_eq!(_20, NumCast::from(20i16));\n-            assert_eq!(_20, NumCast::from(20i32));\n-            assert_eq!(_20, NumCast::from(20i64));\n-            assert_eq!(_20, NumCast::from(20f32));\n-            assert_eq!(_20, NumCast::from(20f64));\n-\n-            assert_eq!(_20, cast(20u));\n-            assert_eq!(_20, cast(20u8));\n-            assert_eq!(_20, cast(20u16));\n-            assert_eq!(_20, cast(20u32));\n-            assert_eq!(_20, cast(20u64));\n-            assert_eq!(_20, cast(20i));\n-            assert_eq!(_20, cast(20i8));\n-            assert_eq!(_20, cast(20i16));\n-            assert_eq!(_20, cast(20i32));\n-            assert_eq!(_20, cast(20i64));\n-            assert_eq!(_20, cast(20f32));\n-            assert_eq!(_20, cast(20f64));\n+            assert_eq!(20u,   _20.to_uint().unwrap());\n+            assert_eq!(20u8,  _20.to_u8().unwrap());\n+            assert_eq!(20u16, _20.to_u16().unwrap());\n+            assert_eq!(20u32, _20.to_u32().unwrap());\n+            assert_eq!(20u64, _20.to_u64().unwrap());\n+            assert_eq!(20i,   _20.to_int().unwrap());\n+            assert_eq!(20i8,  _20.to_i8().unwrap());\n+            assert_eq!(20i16, _20.to_i16().unwrap());\n+            assert_eq!(20i32, _20.to_i32().unwrap());\n+            assert_eq!(20i64, _20.to_i64().unwrap());\n+            assert_eq!(20f,   _20.to_float().unwrap());\n+            assert_eq!(20f32, _20.to_f32().unwrap());\n+            assert_eq!(20f64, _20.to_f64().unwrap());\n+\n+            assert_eq!(_20, NumCast::from(20u).unwrap());\n+            assert_eq!(_20, NumCast::from(20u8).unwrap());\n+            assert_eq!(_20, NumCast::from(20u16).unwrap());\n+            assert_eq!(_20, NumCast::from(20u32).unwrap());\n+            assert_eq!(_20, NumCast::from(20u64).unwrap());\n+            assert_eq!(_20, NumCast::from(20i).unwrap());\n+            assert_eq!(_20, NumCast::from(20i8).unwrap());\n+            assert_eq!(_20, NumCast::from(20i16).unwrap());\n+            assert_eq!(_20, NumCast::from(20i32).unwrap());\n+            assert_eq!(_20, NumCast::from(20i64).unwrap());\n+            assert_eq!(_20, NumCast::from(20f32).unwrap());\n+            assert_eq!(_20, NumCast::from(20f64).unwrap());\n+\n+            assert_eq!(_20, cast(20u).unwrap());\n+            assert_eq!(_20, cast(20u8).unwrap());\n+            assert_eq!(_20, cast(20u16).unwrap());\n+            assert_eq!(_20, cast(20u32).unwrap());\n+            assert_eq!(_20, cast(20u64).unwrap());\n+            assert_eq!(_20, cast(20i).unwrap());\n+            assert_eq!(_20, cast(20i8).unwrap());\n+            assert_eq!(_20, cast(20i16).unwrap());\n+            assert_eq!(_20, cast(20i32).unwrap());\n+            assert_eq!(_20, cast(20i64).unwrap());\n+            assert_eq!(_20, cast(20f32).unwrap());\n+            assert_eq!(_20, cast(20f64).unwrap());\n         })\n     )\n "}, {"sha": "0f253a26ccf1eeae30e9e0a6998585b091910704", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417", "patch": "@@ -140,7 +140,7 @@ pub fn int_to_str_bytes_common<T:NumCast+Zero+Eq+Ord+Integer+\n     let _0: T = Zero::zero();\n \n     let neg = num < _0;\n-    let radix_gen: T = cast(radix);\n+    let radix_gen: T = cast(radix).unwrap();\n \n     let mut deccum = num;\n     // This is just for integral types, the largest of which is a u64. The\n@@ -163,7 +163,7 @@ pub fn int_to_str_bytes_common<T:NumCast+Zero+Eq+Ord+Integer+\n         } else {\n             current_digit_signed\n         };\n-        buf[cur] = match current_digit.to_u8() {\n+        buf[cur] = match current_digit.to_u8().unwrap() {\n             i @ 0..9 => '0' as u8 + i,\n             i        => 'a' as u8 + (i - 10),\n         };\n@@ -247,7 +247,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n \n     let neg = num < _0 || (negative_zero && _1 / num == Float::neg_infinity());\n     let mut buf: ~[u8] = ~[];\n-    let radix_gen: T   = cast(radix as int);\n+    let radix_gen: T   = cast(radix as int).unwrap();\n \n     // First emit the non-fractional part, looping at least once to make\n     // sure at least a `0` gets emitted.\n@@ -265,7 +265,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n         deccum = deccum / radix_gen;\n         deccum = deccum.trunc();\n \n-        buf.push(char::from_digit(current_digit.to_int() as uint, radix)\n+        buf.push(char::from_digit(current_digit.to_int().unwrap() as uint, radix)\n              .unwrap() as u8);\n \n         // No more digits to calculate for the non-fractional part -> break\n@@ -322,7 +322,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n             let current_digit = deccum.trunc().abs();\n \n             buf.push(char::from_digit(\n-                current_digit.to_int() as uint, radix).unwrap() as u8);\n+                current_digit.to_int().unwrap() as uint, radix).unwrap() as u8);\n \n             // Decrease the deccumulator one fractional digit at a time\n             deccum = deccum.fract();\n@@ -492,7 +492,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+\n \n     let _0: T = Zero::zero();\n     let _1: T = One::one();\n-    let radix_gen: T = cast(radix as int);\n+    let radix_gen: T = cast(radix as int).unwrap();\n \n     let len = buf.len();\n \n@@ -543,9 +543,9 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+\n \n                 // add/subtract current digit depending on sign\n                 if accum_positive {\n-                    accum = accum + cast(digit as int);\n+                    accum = accum + cast(digit as int).unwrap();\n                 } else {\n-                    accum = accum - cast(digit as int);\n+                    accum = accum - cast(digit as int).unwrap();\n                 }\n \n                 // Detect overflow by comparing to last value, except\n@@ -556,11 +556,11 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+\n \n                     // Detect overflow by reversing the shift-and-add proccess\n                     if accum_positive &&\n-                        (last_accum != ((accum - cast(digit as int))/radix_gen.clone())) {\n+                        (last_accum != ((accum - cast(digit as int).unwrap())/radix_gen.clone())) {\n                         return NumStrConv::inf();\n                     }\n                     if !accum_positive &&\n-                        (last_accum != ((accum + cast(digit as int))/radix_gen.clone())) {\n+                        (last_accum != ((accum + cast(digit as int).unwrap())/radix_gen.clone())) {\n                         return NumStrConv::neg_inf();\n                     }\n                 }\n@@ -596,7 +596,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+\n                     // Decrease power one order of magnitude\n                     power = power / radix_gen;\n \n-                    let digit_t: T = cast(digit);\n+                    let digit_t: T = cast(digit).unwrap();\n \n                     // add/subtract current digit depending on sign\n                     if accum_positive {\n@@ -654,9 +654,9 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+\n         match exp {\n             Some(exp_pow) => {\n                 multiplier = if exp_pow < 0 {\n-                    _1 / pow_with_uint::<T>(base, (-exp_pow.to_int()) as uint)\n+                    _1 / pow_with_uint::<T>(base, (-exp_pow.to_int().unwrap()) as uint)\n                 } else {\n-                    pow_with_uint::<T>(base, exp_pow.to_int() as uint)\n+                    pow_with_uint::<T>(base, exp_pow.to_int().unwrap() as uint)\n                 }\n             }\n             None => return None // invalid exponent -> invalid number"}, {"sha": "273a01c18113c4261e7d3905217e1fad508c266c", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417", "patch": "@@ -59,7 +59,7 @@ pub use num::{Orderable, Signed, Unsigned, Round};\n pub use num::{Algebraic, Trigonometric, Exponential, Hyperbolic};\n pub use num::{Integer, Fractional, Real, RealExt};\n pub use num::{Bitwise, BitCount, Bounded};\n-pub use num::{Primitive, Int, Float, ToStrRadix};\n+pub use num::{Primitive, Int, Float, ToStrRadix, ToPrimitive, FromPrimitive};\n pub use path::GenericPath;\n pub use path::Path;\n pub use path::PosixPath;"}, {"sha": "f143c936e3a2afaaf7f509208ba78c501f6d6605", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417", "patch": "@@ -314,12 +314,12 @@ pub trait Rng {\n     /// ```\n     fn gen_integer_range<T: Rand + Int>(&mut self, low: T, high: T) -> T {\n         assert!(low < high, \"RNG.gen_integer_range called with low >= high\");\n-        let range = (high - low).to_u64();\n+        let range = (high - low).to_u64().unwrap();\n         let accept_zone = u64::max_value - u64::max_value % range;\n         loop {\n             let rand = self.gen::<u64>();\n             if rand < accept_zone {\n-                return low + NumCast::from(rand % range);\n+                return low + NumCast::from(rand % range).unwrap();\n             }\n         }\n     }"}, {"sha": "1422f93e612af593b4952161779d660f86bcfa85", "filename": "src/test/run-pass/numeric-method-autoexport.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs?ref=d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417", "patch": "@@ -36,6 +36,6 @@ pub fn main() {\n \n // floats\n     // num\n-    assert_eq!(10f32.to_int(), 10);\n-    assert_eq!(10f64.to_int(), 10);\n+    assert_eq!(10f32.to_int().unwrap(), 10);\n+    assert_eq!(10f64.to_int().unwrap(), 10);\n }"}, {"sha": "8d3c258558e1830121679f1e0d3be9b0daac0b1f", "filename": "src/test/run-pass/trait-inheritance-num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs?ref=d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417", "patch": "@@ -19,7 +19,7 @@ pub trait NumExt: Num + NumCast + Eq + Ord {}\n \n pub trait FloatExt: NumExt + ApproxEq<Self> {}\n \n-fn greater_than_one<T:NumExt>(n: &T) -> bool { *n > NumCast::from(1) }\n-fn greater_than_one_float<T:FloatExt>(n: &T) -> bool { *n > NumCast::from(1) }\n+fn greater_than_one<T:NumExt>(n: &T) -> bool { *n > NumCast::from(1).unwrap() }\n+fn greater_than_one_float<T:FloatExt>(n: &T) -> bool { *n > NumCast::from(1).unwrap() }\n \n pub fn main() {}"}, {"sha": "46efac84907f2707471ec424741d3df97946de5e", "filename": "src/test/run-pass/trait-inheritance-num0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs?ref=d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417", "patch": "@@ -22,7 +22,7 @@ trait Num {\n pub trait NumExt: Num + NumCast { }\n \n fn greater_than_one<T:NumExt>(n: &T) -> bool {\n-    n.gt(&NumCast::from(1))\n+    n.gt(&NumCast::from(1).unwrap())\n }\n \n pub fn main() {}"}, {"sha": "28abae175cdfb6a97ecd749fd6463f0df222ba8c", "filename": "src/test/run-pass/trait-inheritance-num1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs?ref=d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417", "patch": "@@ -14,7 +14,7 @@ use std::num::NumCast;\n pub trait NumExt: Num + NumCast + Ord { }\n \n fn greater_than_one<T:NumExt>(n: &T) -> bool {\n-    *n > NumCast::from(1)\n+    *n > NumCast::from(1).unwrap()\n }\n \n pub fn main() {}"}, {"sha": "7909f01591228a4f99ae35f90acbdca95781293e", "filename": "src/test/run-pass/trait-inheritance-num3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs?ref=d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417", "patch": "@@ -16,7 +16,7 @@ pub trait NumExt: Eq + Ord + Num + NumCast {}\n impl NumExt for f32 {}\n \n fn num_eq_one<T:NumExt>(n: T) {\n-    println!(\"{}\", n == NumCast::from(1))\n+    println!(\"{}\", n == NumCast::from(1).unwrap())\n }\n \n pub fn main() {"}, {"sha": "0310dde2a6d3beb68074dbb1640b255688c6ae9a", "filename": "src/test/run-pass/trait-inheritance-num5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs?ref=d9d1dfc1955fabb7ee3a55e9c84cdcd5aad67417", "patch": "@@ -17,7 +17,7 @@ impl NumExt for f32 {}\n impl NumExt for int {}\n \n fn num_eq_one<T:NumExt>() -> T {\n-    NumCast::from(1)\n+    NumCast::from(1).unwrap()\n }\n \n pub fn main() {"}]}