{"sha": "8467e8d24a48027d3d328c6135c0a55cfc9a4cf9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0NjdlOGQyNGE0ODAyN2QzZDMyOGM2MTM1YzBhNTVjZmM5YTRjZjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-27T11:05:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-27T11:05:34Z"}, "message": "Auto merge of #36758 - michaelwoerister:incr-comp-file-headers, r=eddyb\n\nincr.comp.: Let the compiler ignore incompatible incr. comp. cache artifacts\n\nImplements #35720.\n\ncc @nikomatsakis", "tree": {"sha": "45c13ff66eedb448f72474d09d0f323ca006b129", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45c13ff66eedb448f72474d09d0f323ca006b129"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8467e8d24a48027d3d328c6135c0a55cfc9a4cf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8467e8d24a48027d3d328c6135c0a55cfc9a4cf9", "html_url": "https://github.com/rust-lang/rust/commit/8467e8d24a48027d3d328c6135c0a55cfc9a4cf9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8467e8d24a48027d3d328c6135c0a55cfc9a4cf9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec7679b460d49a89b5d23bb04426229f4add235b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec7679b460d49a89b5d23bb04426229f4add235b", "html_url": "https://github.com/rust-lang/rust/commit/ec7679b460d49a89b5d23bb04426229f4add235b"}, {"sha": "263ba920457c9f0ef20d7cb60578d91672eed20e", "url": "https://api.github.com/repos/rust-lang/rust/commits/263ba920457c9f0ef20d7cb60578d91672eed20e", "html_url": "https://github.com/rust-lang/rust/commit/263ba920457c9f0ef20d7cb60578d91672eed20e"}], "stats": {"total": 242, "additions": 202, "deletions": 40}, "files": [{"sha": "7c2b69e762b93130027bc4a68c01d3734a9dd4b4", "filename": "src/librustc_incremental/persist/file_format.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/8467e8d24a48027d3d328c6135c0a55cfc9a4cf9/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8467e8d24a48027d3d328c6135c0a55cfc9a4cf9/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs?ref=8467e8d24a48027d3d328c6135c0a55cfc9a4cf9", "patch": "@@ -0,0 +1,122 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module defines a generic file format that allows to check if a given\n+//! file generated by incremental compilation was generated by a compatible\n+//! compiler version. This file format is used for the on-disk version of the\n+//! dependency graph and the exported metadata hashes.\n+//!\n+//! In practice \"compatible compiler version\" means \"exactly the same compiler\n+//! version\", since the header encodes the git commit hash of the compiler.\n+//! Since we can always just ignore the incremental compilation cache and\n+//! compiler versions don't change frequently for the typical user, being\n+//! conservative here practically has no downside.\n+\n+use std::io::{self, Read};\n+use std::path::Path;\n+use std::fs::File;\n+use std::env;\n+\n+use rustc::session::config::nightly_options;\n+\n+/// The first few bytes of files generated by incremental compilation\n+const FILE_MAGIC: &'static [u8] = b\"RSIC\";\n+\n+/// Change this if the header format changes\n+const HEADER_FORMAT_VERSION: u16 = 0;\n+\n+/// A version string that hopefully is always different for compiler versions\n+/// with different encodings of incremental compilation artifacts. Contains\n+/// the git commit hash.\n+const RUSTC_VERSION: Option<&'static str> = option_env!(\"CFG_VERSION\");\n+\n+pub fn write_file_header<W: io::Write>(stream: &mut W) -> io::Result<()> {\n+    stream.write_all(FILE_MAGIC)?;\n+    stream.write_all(&[(HEADER_FORMAT_VERSION >> 0) as u8,\n+                       (HEADER_FORMAT_VERSION >> 8) as u8])?;\n+\n+    let rustc_version = rustc_version();\n+    assert_eq!(rustc_version.len(), (rustc_version.len() as u8) as usize);\n+    stream.write_all(&[rustc_version.len() as u8])?;\n+    stream.write_all(rustc_version.as_bytes())?;\n+\n+    Ok(())\n+}\n+\n+/// Reads the contents of a file with a file header as defined in this module.\n+///\n+/// - Returns `Ok(Some(data))` if the file existed and was generated by a\n+///   compatible compiler version. `data` is the entire contents of the file\n+///   *after* the header.\n+/// - Returns `Ok(None)` if the file did not exist or was generated by an\n+///   incompatible version of the compiler.\n+/// - Returns `Err(..)` if some kind of IO error occurred while reading the\n+///   file.\n+pub fn read_file(path: &Path) -> io::Result<Option<Vec<u8>>> {\n+    if !path.exists() {\n+        return Ok(None);\n+    }\n+\n+    let mut file = File::open(path)?;\n+\n+    // Check FILE_MAGIC\n+    {\n+        debug_assert!(FILE_MAGIC.len() == 4);\n+        let mut file_magic = [0u8; 4];\n+        file.read_exact(&mut file_magic)?;\n+        if file_magic != FILE_MAGIC {\n+            return Ok(None)\n+        }\n+    }\n+\n+    // Check HEADER_FORMAT_VERSION\n+    {\n+        debug_assert!(::std::mem::size_of_val(&HEADER_FORMAT_VERSION) == 2);\n+        let mut header_format_version = [0u8; 2];\n+        file.read_exact(&mut header_format_version)?;\n+        let header_format_version = (header_format_version[0] as u16) |\n+                                    ((header_format_version[1] as u16) << 8);\n+\n+        if header_format_version != HEADER_FORMAT_VERSION {\n+            return Ok(None)\n+        }\n+    }\n+\n+    // Check RUSTC_VERSION\n+    {\n+        let mut rustc_version_str_len = [0u8; 1];\n+        file.read_exact(&mut rustc_version_str_len)?;\n+        let rustc_version_str_len = rustc_version_str_len[0] as usize;\n+        let mut buffer = Vec::with_capacity(rustc_version_str_len);\n+        buffer.resize(rustc_version_str_len, 0);\n+        file.read_exact(&mut buffer[..])?;\n+\n+        if &buffer[..] != rustc_version().as_bytes() {\n+            return Ok(None);\n+        }\n+    }\n+\n+    let mut data = vec![];\n+    file.read_to_end(&mut data)?;\n+\n+    Ok(Some(data))\n+}\n+\n+fn rustc_version() -> String {\n+    if nightly_options::is_nightly_build() {\n+        if let Some(val) = env::var_os(\"RUSTC_FORCE_INCR_COMP_ARTIFACT_HEADER\") {\n+            return val.to_string_lossy().into_owned()\n+        }\n+    }\n+\n+    RUSTC_VERSION.expect(\"Cannot use rustc without explicit version for \\\n+                          incremental compilation\")\n+                 .to_string()\n+}"}, {"sha": "2d28afeaebf2d37aa5e7f43dfd8842d3099fda42", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8467e8d24a48027d3d328c6135c0a55cfc9a4cf9/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8467e8d24a48027d3d328c6135c0a55cfc9a4cf9/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=8467e8d24a48027d3d328c6135c0a55cfc9a4cf9", "patch": "@@ -345,6 +345,15 @@ pub fn finalize_session_directory(sess: &Session, svh: Svh) {\n     let _ = garbage_collect_session_directories(sess);\n }\n \n+pub fn delete_all_session_dir_contents(sess: &Session) -> io::Result<()> {\n+    let sess_dir_iterator = sess.incr_comp_session_dir().read_dir()?;\n+    for entry in sess_dir_iterator {\n+        let entry = entry?;\n+        safe_remove_file(&entry.path())?\n+    }\n+    Ok(())\n+}\n+\n fn copy_files(target_dir: &Path,\n               source_dir: &Path,\n               print_stats_on_success: bool)"}, {"sha": "ca173db15fcac37e303aff0beb9b16bb3a29bfd5", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8467e8d24a48027d3d328c6135c0a55cfc9a4cf9/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8467e8d24a48027d3d328c6135c0a55cfc9a4cf9/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=8467e8d24a48027d3d328c6135c0a55cfc9a4cf9", "patch": "@@ -16,12 +16,11 @@ use rustc_data_structures::fnv::FnvHashMap;\n use rustc_data_structures::flock;\n use rustc_serialize::Decodable;\n use rustc_serialize::opaque::Decoder;\n-use std::io::{ErrorKind, Read};\n-use std::fs::File;\n \n use IncrementalHashesMap;\n use super::data::*;\n use super::fs::*;\n+use super::file_format;\n \n pub struct HashContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -153,12 +152,9 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n \n             let hashes_file_path = metadata_hash_import_path(&session_dir);\n \n-            let mut data = vec![];\n-            match\n-                File::open(&hashes_file_path)\n-                     .and_then(|mut file| file.read_to_end(&mut data))\n+            match file_format::read_file(&hashes_file_path)\n             {\n-                Ok(_) => {\n+                Ok(Some(data)) => {\n                     match self.load_from_data(cnum, &data, svh) {\n                         Ok(()) => { }\n                         Err(err) => {\n@@ -167,18 +163,13 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n                         }\n                     }\n                 }\n+                Ok(None) => {\n+                    // If the file is not found, that's ok.\n+                }\n                 Err(err) => {\n-                    match err.kind() {\n-                        ErrorKind::NotFound => {\n-                            // If the file is not found, that's ok.\n-                        }\n-                        _ => {\n-                            self.tcx.sess.err(\n-                                &format!(\"could not load dep information from `{}`: {}\",\n-                                         hashes_file_path.display(), err));\n-                            return;\n-                        }\n-                    }\n+                    self.tcx.sess.err(\n+                        &format!(\"could not load dep information from `{}`: {}\",\n+                                 hashes_file_path.display(), err));\n                 }\n             }\n         }"}, {"sha": "db8d3125e510bf3f388e90f7c9054058485d5be2", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8467e8d24a48027d3d328c6135c0a55cfc9a4cf9/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8467e8d24a48027d3d328c6135c0a55cfc9a4cf9/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=8467e8d24a48027d3d328c6135c0a55cfc9a4cf9", "patch": "@@ -18,8 +18,7 @@ use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::{FnvHashSet, FnvHashMap};\n use rustc_serialize::Decodable as RustcDecodable;\n use rustc_serialize::opaque::Decoder;\n-use std::io::Read;\n-use std::fs::{self, File};\n+use std::fs;\n use std::path::{Path};\n \n use IncrementalHashesMap;\n@@ -28,6 +27,7 @@ use super::directory::*;\n use super::dirty_clean;\n use super::hash::*;\n use super::fs::*;\n+use super::file_format;\n \n pub type DirtyNodes = FnvHashSet<DepNode<DefPathIndex>>;\n \n@@ -94,25 +94,26 @@ fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn load_data(sess: &Session, path: &Path) -> Option<Vec<u8>> {\n-    if !path.exists() {\n-        return None;\n-    }\n-\n-    let mut data = vec![];\n-    match\n-        File::open(path)\n-        .and_then(|mut file| file.read_to_end(&mut data))\n-    {\n-        Ok(_) => {\n-            Some(data)\n+    match file_format::read_file(path) {\n+        Ok(Some(data)) => return Some(data),\n+        Ok(None) => {\n+            // The file either didn't exist or was produced by an incompatible\n+            // compiler version. Neither is an error.\n         }\n         Err(err) => {\n             sess.err(\n                 &format!(\"could not load dep-graph from `{}`: {}\",\n                          path.display(), err));\n-            None\n         }\n     }\n+\n+    if let Err(err) = delete_all_session_dir_contents(sess) {\n+        sess.err(&format!(\"could not clear incompatible incremental \\\n+                           compilation session directory `{}`: {}\",\n+                          path.display(), err));\n+    }\n+\n+    None\n }\n \n /// Decode the dep graph and load the edges/nodes that are still clean\n@@ -331,16 +332,22 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n \n     debug!(\"load_prev_metadata_hashes() - File: {}\", file_path.display());\n \n-    let mut data = vec![];\n-    if !File::open(&file_path)\n-             .and_then(|mut file| file.read_to_end(&mut data)).is_ok() {\n-        debug!(\"load_prev_metadata_hashes() - Couldn't read file containing \\\n-                hashes at `{}`\", file_path.display());\n-        return\n-    }\n+    let data = match file_format::read_file(&file_path) {\n+        Ok(Some(data)) => data,\n+        Ok(None) => {\n+            debug!(\"load_prev_metadata_hashes() - File produced by incompatible \\\n+                    compiler version: {}\", file_path.display());\n+            return\n+        }\n+        Err(err) => {\n+            debug!(\"load_prev_metadata_hashes() - Error reading file `{}`: {}\",\n+                   file_path.display(), err);\n+            return\n+        }\n+    };\n \n     debug!(\"load_prev_metadata_hashes() - Decoding hashes\");\n-    let mut decoder = Decoder::new(&mut data, 0);\n+    let mut decoder = Decoder::new(&data, 0);\n     let _ = Svh::decode(&mut decoder).unwrap();\n     let serialized_hashes = SerializedMetadataHashes::decode(&mut decoder).unwrap();\n \n@@ -358,3 +365,4 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n     debug!(\"load_prev_metadata_hashes() - successfully loaded {} hashes\",\n            serialized_hashes.index_map.len());\n }\n+"}, {"sha": "26fcde05868b9e4ca4bdf02119104661429050c6", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8467e8d24a48027d3d328c6135c0a55cfc9a4cf9/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8467e8d24a48027d3d328c6135c0a55cfc9a4cf9/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=8467e8d24a48027d3d328c6135c0a55cfc9a4cf9", "patch": "@@ -21,6 +21,7 @@ mod load;\n mod preds;\n mod save;\n mod work_product;\n+mod file_format;\n \n pub use self::fs::finalize_session_directory;\n pub use self::fs::in_incr_comp_dir;"}, {"sha": "e6fb1da1982c11a6de53f9709c194f07605184cc", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8467e8d24a48027d3d328c6135c0a55cfc9a4cf9/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8467e8d24a48027d3d328c6135c0a55cfc9a4cf9/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=8467e8d24a48027d3d328c6135c0a55cfc9a4cf9", "patch": "@@ -28,6 +28,7 @@ use super::hash::*;\n use super::preds::*;\n use super::fs::*;\n use super::dirty_clean;\n+use super::file_format;\n \n pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 incremental_hashes_map: &IncrementalHashesMap,\n@@ -102,6 +103,7 @@ fn save_in<F>(sess: &Session, path_buf: PathBuf, encode: F)\n \n     // generate the data in a memory buffer\n     let mut wr = Cursor::new(Vec::new());\n+    file_format::write_file_header(&mut wr).unwrap();\n     match encode(&mut Encoder::new(&mut wr)) {\n         Ok(()) => {}\n         Err(err) => {"}, {"sha": "274a3920be8d4ad54d02499fa713cb37690a0641", "filename": "src/test/incremental/cache_file_headers.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8467e8d24a48027d3d328c6135c0a55cfc9a4cf9/src%2Ftest%2Fincremental%2Fcache_file_headers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8467e8d24a48027d3d328c6135c0a55cfc9a4cf9/src%2Ftest%2Fincremental%2Fcache_file_headers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcache_file_headers.rs?ref=8467e8d24a48027d3d328c6135c0a55cfc9a4cf9", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test case makes sure that the compiler does not try to re-use anything\n+// from the incremental compilation cache if the cache was produced by a\n+// different compiler version. This is tested by artificially forcing the\n+// emission of a different compiler version in the header of rpass1 artifacts,\n+// and then making sure that the only object file of the test program gets\n+// re-translated although the program stays unchanged.\n+\n+// The `l33t haxx0r` Rust compiler is known to produce incr. comp. artifacts\n+// that are outrageously incompatible with just about anything, even itself:\n+//[rpass1] rustc-env:RUSTC_FORCE_INCR_COMP_ARTIFACT_HEADER=\"l33t haxx0r rustc 2.1 LTS\"\n+\n+// revisions:rpass1 rpass2\n+\n+#![feature(rustc_attrs)]\n+#![rustc_partition_translated(module=\"cache_file_headers\", cfg=\"rpass2\")]\n+\n+fn main() {\n+    // empty\n+}"}]}