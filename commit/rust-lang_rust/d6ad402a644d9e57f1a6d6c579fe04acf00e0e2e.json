{"sha": "d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2YWQ0MDJhNjQ0ZDllNTdmMWE2ZDZjNTc5ZmUwNGFjZjAwZTBlMmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-08T06:56:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-08T06:56:09Z"}, "message": "Auto merge of #43742 - epdtry:pprust-expr-fix, r=petrochenkov\n\npprust: fix parenthesization of exprs\n\nThe pretty printer in `syntax::print::pprust` currently relies on the presence of `ExprKind::Paren` hints in order to correctly parenthesize expressions in its output.  If `Paren` nodes are missing, it sometimes produces wrong output, such as printing `1 - (2 - 3)` as `1 - 2 - 3`.  This PR fixes `pprust` to correctly print expressions regardless of the presence or absence of `Paren` nodes.  This should make `pprust` easier to use with programmatically constructed ASTs.\n\nA few notes:\n\n * I added a function for assigning precedence values to exprs in `syntax::util::parser`, since there is already code there for assigning precedence values to binops.  Let me know if I should move this somewhere more `pprust`-specific.\n\n * I also moved the `contains_exterior_struct_lit` function from `rustc_lint::unused::UnusedParens` into `syntax::util::parser`, since it's needed for determining the correct parenthesization of `if`/`while` conditional expressions.\n\n * I couldn't find a good way to compare two exprs for equivalence while ignoring semantically-irrelevant details like spans.  So the test for the new behavior relies on a slight hack: it adds `Paren` nodes everywhere, so that the pretty-printed version exactly reflects the structure of the AST, and then compares the printed strings.  This works, but let me know if there's a better way.", "tree": {"sha": "36cb0612f6c81b1301d70a22841f8bb5355df1de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36cb0612f6c81b1301d70a22841f8bb5355df1de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e", "html_url": "https://github.com/rust-lang/rust/commit/d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1ef1882a0b1e37d51d1b864bc8222897977d692", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1ef1882a0b1e37d51d1b864bc8222897977d692", "html_url": "https://github.com/rust-lang/rust/commit/e1ef1882a0b1e37d51d1b864bc8222897977d692"}, {"sha": "3454d99cb6355ab60c95e72d96e04eb9c69a6138", "url": "https://api.github.com/repos/rust-lang/rust/commits/3454d99cb6355ab60c95e72d96e04eb9c69a6138", "html_url": "https://github.com/rust-lang/rust/commit/3454d99cb6355ab60c95e72d96e04eb9c69a6138"}], "stats": {"total": 751, "additions": 612, "deletions": 139}, "files": [{"sha": "a06ea0af2a9e65cce8da09ec2f5b808c0bb724df", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 179, "deletions": 38, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e", "patch": "@@ -20,6 +20,7 @@ use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n use syntax::print::pprust::PrintState;\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n+use syntax::util::parser::{self, AssocOp, Fixity};\n use syntax_pos::{self, BytePos};\n \n use hir;\n@@ -210,18 +211,6 @@ pub fn visibility_qualified(vis: &hir::Visibility, w: &str) -> String {\n     })\n }\n \n-fn needs_parentheses(expr: &hir::Expr) -> bool {\n-    match expr.node {\n-        hir::ExprAssign(..) |\n-        hir::ExprBinary(..) |\n-        hir::ExprClosure(..) |\n-        hir::ExprAssignOp(..) |\n-        hir::ExprCast(..) |\n-        hir::ExprType(..) => true,\n-        _ => false,\n-    }\n-}\n-\n impl<'a> State<'a> {\n     pub fn cbox(&mut self, u: usize) -> io::Result<()> {\n         self.boxes.push(pp::Breaks::Consistent);\n@@ -1047,7 +1036,7 @@ impl<'a> State<'a> {\n                         self.cbox(indent_unit - 1)?;\n                         self.ibox(0)?;\n                         self.s.word(\" else if \")?;\n-                        self.print_expr(&i)?;\n+                        self.print_expr_as_cond(&i)?;\n                         self.s.space()?;\n                         self.print_expr(&then)?;\n                         self.print_else(e.as_ref().map(|e| &**e))\n@@ -1075,7 +1064,7 @@ impl<'a> State<'a> {\n                     elseopt: Option<&hir::Expr>)\n                     -> io::Result<()> {\n         self.head(\"if\")?;\n-        self.print_expr(test)?;\n+        self.print_expr_as_cond(test)?;\n         self.s.space()?;\n         self.print_expr(blk)?;\n         self.print_else(elseopt)\n@@ -1091,7 +1080,7 @@ impl<'a> State<'a> {\n         self.print_pat(pat)?;\n         self.s.space()?;\n         self.word_space(\"=\")?;\n-        self.print_expr(expr)?;\n+        self.print_expr_as_cond(expr)?;\n         self.s.space()?;\n         self.print_block(blk)?;\n         self.print_else(elseopt)\n@@ -1104,8 +1093,31 @@ impl<'a> State<'a> {\n         self.pclose()\n     }\n \n-    pub fn print_expr_maybe_paren(&mut self, expr: &hir::Expr) -> io::Result<()> {\n-        let needs_par = needs_parentheses(expr);\n+    pub fn print_expr_maybe_paren(&mut self, expr: &hir::Expr, prec: i8) -> io::Result<()> {\n+        let needs_par = expr_precedence(expr) < prec;\n+        if needs_par {\n+            self.popen()?;\n+        }\n+        self.print_expr(expr)?;\n+        if needs_par {\n+            self.pclose()?;\n+        }\n+        Ok(())\n+    }\n+\n+    /// Print an expr using syntax that's acceptable in a condition position, such as the `cond` in\n+    /// `if cond { ... }`.\n+    pub fn print_expr_as_cond(&mut self, expr: &hir::Expr) -> io::Result<()> {\n+        let needs_par = match expr.node {\n+            // These cases need parens due to the parse error observed in #26461: `if return {}`\n+            // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n+            hir::ExprClosure(..) |\n+            hir::ExprRet(..) |\n+            hir::ExprBreak(..) => true,\n+\n+            _ => contains_exterior_struct_lit(expr),\n+        };\n+\n         if needs_par {\n             self.popen()?;\n         }\n@@ -1182,7 +1194,14 @@ impl<'a> State<'a> {\n     }\n \n     fn print_expr_call(&mut self, func: &hir::Expr, args: &[hir::Expr]) -> io::Result<()> {\n-        self.print_expr_maybe_paren(func)?;\n+        let prec =\n+            match func.node {\n+                hir::ExprField(..) |\n+                hir::ExprTupField(..) => parser::PREC_FORCE_PAREN,\n+                _ => parser::PREC_POSTFIX,\n+            };\n+\n+        self.print_expr_maybe_paren(func, prec)?;\n         self.print_call_post(args)\n     }\n \n@@ -1191,7 +1210,7 @@ impl<'a> State<'a> {\n                               args: &[hir::Expr])\n                               -> io::Result<()> {\n         let base_args = &args[1..];\n-        self.print_expr(&args[0])?;\n+        self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX)?;\n         self.s.word(\".\")?;\n         self.print_name(segment.name)?;\n         if !segment.parameters.lifetimes.is_empty() ||\n@@ -1207,15 +1226,25 @@ impl<'a> State<'a> {\n                          lhs: &hir::Expr,\n                          rhs: &hir::Expr)\n                          -> io::Result<()> {\n-        self.print_expr(lhs)?;\n+        let assoc_op = bin_op_to_assoc_op(op.node);\n+        let prec = assoc_op.precedence() as i8;\n+        let fixity = assoc_op.fixity();\n+\n+        let (left_prec, right_prec) = match fixity {\n+            Fixity::Left => (prec, prec + 1),\n+            Fixity::Right => (prec + 1, prec),\n+            Fixity::None => (prec + 1, prec + 1),\n+        };\n+\n+        self.print_expr_maybe_paren(lhs, left_prec)?;\n         self.s.space()?;\n         self.word_space(op.node.as_str())?;\n-        self.print_expr(rhs)\n+        self.print_expr_maybe_paren(rhs, right_prec)\n     }\n \n     fn print_expr_unary(&mut self, op: hir::UnOp, expr: &hir::Expr) -> io::Result<()> {\n         self.s.word(op.as_str())?;\n-        self.print_expr_maybe_paren(expr)\n+        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n \n     fn print_expr_addr_of(&mut self,\n@@ -1224,7 +1253,7 @@ impl<'a> State<'a> {\n                           -> io::Result<()> {\n         self.s.word(\"&\")?;\n         self.print_mutability(mutability)?;\n-        self.print_expr_maybe_paren(expr)\n+        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n \n     pub fn print_expr(&mut self, expr: &hir::Expr) -> io::Result<()> {\n@@ -1235,7 +1264,7 @@ impl<'a> State<'a> {\n         match expr.node {\n             hir::ExprBox(ref expr) => {\n                 self.word_space(\"box\")?;\n-                self.print_expr(expr)?;\n+                self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)?;\n             }\n             hir::ExprArray(ref exprs) => {\n                 self.print_expr_vec(exprs)?;\n@@ -1268,13 +1297,15 @@ impl<'a> State<'a> {\n                 self.print_literal(&lit)?;\n             }\n             hir::ExprCast(ref expr, ref ty) => {\n-                self.print_expr(&expr)?;\n+                let prec = AssocOp::As.precedence() as i8;\n+                self.print_expr_maybe_paren(&expr, prec)?;\n                 self.s.space()?;\n                 self.word_space(\"as\")?;\n                 self.print_type(&ty)?;\n             }\n             hir::ExprType(ref expr, ref ty) => {\n-                self.print_expr(&expr)?;\n+                let prec = AssocOp::Colon.precedence() as i8;\n+                self.print_expr_maybe_paren(&expr, prec)?;\n                 self.word_space(\":\")?;\n                 self.print_type(&ty)?;\n             }\n@@ -1287,7 +1318,7 @@ impl<'a> State<'a> {\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while\")?;\n-                self.print_expr(&test)?;\n+                self.print_expr_as_cond(&test)?;\n                 self.s.space()?;\n                 self.print_block(&blk)?;\n             }\n@@ -1304,7 +1335,7 @@ impl<'a> State<'a> {\n                 self.cbox(indent_unit)?;\n                 self.ibox(4)?;\n                 self.word_nbsp(\"match\")?;\n-                self.print_expr(&expr)?;\n+                self.print_expr_as_cond(&expr)?;\n                 self.s.space()?;\n                 self.bopen()?;\n                 for arm in arms {\n@@ -1335,30 +1366,32 @@ impl<'a> State<'a> {\n                 self.print_block(&blk)?;\n             }\n             hir::ExprAssign(ref lhs, ref rhs) => {\n-                self.print_expr(&lhs)?;\n+                let prec = AssocOp::Assign.precedence() as i8;\n+                self.print_expr_maybe_paren(&lhs, prec + 1)?;\n                 self.s.space()?;\n                 self.word_space(\"=\")?;\n-                self.print_expr(&rhs)?;\n+                self.print_expr_maybe_paren(&rhs, prec)?;\n             }\n             hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-                self.print_expr(&lhs)?;\n+                let prec = AssocOp::Assign.precedence() as i8;\n+                self.print_expr_maybe_paren(&lhs, prec + 1)?;\n                 self.s.space()?;\n                 self.s.word(op.node.as_str())?;\n                 self.word_space(\"=\")?;\n-                self.print_expr(&rhs)?;\n+                self.print_expr_maybe_paren(&rhs, prec)?;\n             }\n             hir::ExprField(ref expr, name) => {\n-                self.print_expr(&expr)?;\n+                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\".\")?;\n                 self.print_name(name.node)?;\n             }\n             hir::ExprTupField(ref expr, id) => {\n-                self.print_expr(&expr)?;\n+                self.print_expr_maybe_paren(&expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\".\")?;\n                 self.print_usize(id.node)?;\n             }\n             hir::ExprIndex(ref expr, ref index) => {\n-                self.print_expr(&expr)?;\n+                self.print_expr_maybe_paren(&expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\"[\")?;\n                 self.print_expr(&index)?;\n                 self.s.word(\"]\")?;\n@@ -1374,7 +1407,7 @@ impl<'a> State<'a> {\n                     self.s.space()?;\n                 }\n                 if let Some(ref expr) = *opt_expr {\n-                    self.print_expr(expr)?;\n+                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP)?;\n                     self.s.space()?;\n                 }\n             }\n@@ -1391,7 +1424,7 @@ impl<'a> State<'a> {\n                 match *result {\n                     Some(ref expr) => {\n                         self.s.word(\" \")?;\n-                        self.print_expr(&expr)?;\n+                        self.print_expr_maybe_paren(&expr, parser::PREC_JUMP)?;\n                     }\n                     _ => (),\n                 }\n@@ -1463,7 +1496,7 @@ impl<'a> State<'a> {\n             }\n             hir::ExprYield(ref expr) => {\n                 self.s.word(\"yield\")?;\n-                self.print_expr(&expr)?;\n+                self.print_expr_maybe_paren(&expr, parser::PREC_JUMP)?;\n             }\n         }\n         self.ann.post(self, NodeExpr(expr))?;\n@@ -2246,3 +2279,111 @@ fn stmt_ends_with_semi(stmt: &hir::Stmt_) -> bool {\n         }\n     }\n }\n+\n+\n+fn expr_precedence(expr: &hir::Expr) -> i8 {\n+    use syntax::util::parser::*;\n+\n+    match expr.node {\n+        hir::ExprClosure(..) => PREC_CLOSURE,\n+\n+        hir::ExprBreak(..) |\n+        hir::ExprAgain(..) |\n+        hir::ExprRet(..) |\n+        hir::ExprYield(..) => PREC_JUMP,\n+\n+        // Binop-like expr kinds, handled by `AssocOp`.\n+        hir::ExprBinary(op, _, _) => bin_op_to_assoc_op(op.node).precedence() as i8,\n+\n+        hir::ExprCast(..) => AssocOp::As.precedence() as i8,\n+        hir::ExprType(..) => AssocOp::Colon.precedence() as i8,\n+\n+        hir::ExprAssign(..) |\n+        hir::ExprAssignOp(..) => AssocOp::Assign.precedence() as i8,\n+\n+        // Unary, prefix\n+        hir::ExprBox(..) |\n+        hir::ExprAddrOf(..) |\n+        hir::ExprUnary(..) => PREC_PREFIX,\n+\n+        // Unary, postfix\n+        hir::ExprCall(..) |\n+        hir::ExprMethodCall(..) |\n+        hir::ExprField(..) |\n+        hir::ExprTupField(..) |\n+        hir::ExprIndex(..) |\n+        hir::ExprInlineAsm(..) => PREC_POSTFIX,\n+\n+        // Never need parens\n+        hir::ExprArray(..) |\n+        hir::ExprRepeat(..) |\n+        hir::ExprTup(..) |\n+        hir::ExprLit(..) |\n+        hir::ExprPath(..) |\n+        hir::ExprIf(..) |\n+        hir::ExprWhile(..) |\n+        hir::ExprLoop(..) |\n+        hir::ExprMatch(..) |\n+        hir::ExprBlock(..) |\n+        hir::ExprStruct(..) => PREC_PAREN,\n+    }\n+}\n+\n+fn bin_op_to_assoc_op(op: hir::BinOp_) -> AssocOp {\n+    use hir::BinOp_::*;\n+    match op {\n+        BiAdd => AssocOp::Add,\n+        BiSub => AssocOp::Subtract,\n+        BiMul => AssocOp::Multiply,\n+        BiDiv => AssocOp::Divide,\n+        BiRem => AssocOp::Modulus,\n+\n+        BiAnd => AssocOp::LAnd,\n+        BiOr => AssocOp::LOr,\n+\n+        BiBitXor => AssocOp::BitXor,\n+        BiBitAnd => AssocOp::BitAnd,\n+        BiBitOr => AssocOp::BitOr,\n+        BiShl => AssocOp::ShiftLeft,\n+        BiShr => AssocOp::ShiftRight,\n+\n+        BiEq => AssocOp::Equal,\n+        BiLt => AssocOp::Less,\n+        BiLe => AssocOp::LessEqual,\n+        BiNe => AssocOp::NotEqual,\n+        BiGe => AssocOp::GreaterEqual,\n+        BiGt => AssocOp::Greater,\n+    }\n+}\n+\n+/// Expressions that syntactically contain an \"exterior\" struct literal i.e. not surrounded by any\n+/// parens or other delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n+/// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n+fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n+    match value.node {\n+        hir::ExprStruct(..) => true,\n+\n+        hir::ExprAssign(ref lhs, ref rhs) |\n+        hir::ExprAssignOp(_, ref lhs, ref rhs) |\n+        hir::ExprBinary(_, ref lhs, ref rhs) => {\n+            // X { y: 1 } + X { y: 2 }\n+            contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n+        }\n+        hir::ExprUnary(_, ref x) |\n+        hir::ExprCast(ref x, _) |\n+        hir::ExprType(ref x, _) |\n+        hir::ExprField(ref x, _) |\n+        hir::ExprTupField(ref x, _) |\n+        hir::ExprIndex(ref x, _) => {\n+            // &X { y: 1 }, X { y: 1 }.y\n+            contains_exterior_struct_lit(&x)\n+        }\n+\n+        hir::ExprMethodCall(.., ref exprs) => {\n+            // X { y: 1 }.bar(...)\n+            contains_exterior_struct_lit(&exprs[0])\n+        }\n+\n+        _ => false,\n+    }\n+}"}, {"sha": "91646ce9f8b963ed58d4698d6ed319c5426f16f5", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 35, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e", "patch": "@@ -22,6 +22,7 @@ use syntax::attr;\n use syntax::feature_gate::{BUILTIN_ATTRIBUTES, AttributeType};\n use syntax::symbol::keywords;\n use syntax::ptr::P;\n+use syntax::util::parser;\n use syntax_pos::Span;\n \n use rustc_back::slice;\n@@ -313,47 +314,14 @@ impl UnusedParens {\n                                 msg: &str,\n                                 struct_lit_needs_parens: bool) {\n         if let ast::ExprKind::Paren(ref inner) = value.node {\n-            let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&inner);\n+            let necessary = struct_lit_needs_parens &&\n+                            parser::contains_exterior_struct_lit(&inner);\n             if !necessary {\n                 cx.span_lint(UNUSED_PARENS,\n                              value.span,\n                              &format!(\"unnecessary parentheses around {}\", msg))\n             }\n         }\n-\n-        /// Expressions that syntactically contain an \"exterior\" struct\n-        /// literal i.e. not surrounded by any parens or other\n-        /// delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo\n-        /// == X { y: 1 }` and `X { y: 1 } == foo` all do, but `(X {\n-        /// y: 1 }) == foo` does not.\n-        fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n-            match value.node {\n-                ast::ExprKind::Struct(..) => true,\n-\n-                ast::ExprKind::Assign(ref lhs, ref rhs) |\n-                ast::ExprKind::AssignOp(_, ref lhs, ref rhs) |\n-                ast::ExprKind::Binary(_, ref lhs, ref rhs) => {\n-                    // X { y: 1 } + X { y: 2 }\n-                    contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n-                }\n-                ast::ExprKind::Unary(_, ref x) |\n-                ast::ExprKind::Cast(ref x, _) |\n-                ast::ExprKind::Type(ref x, _) |\n-                ast::ExprKind::Field(ref x, _) |\n-                ast::ExprKind::TupField(ref x, _) |\n-                ast::ExprKind::Index(ref x, _) => {\n-                    // &X { y: 1 }, X { y: 1 }.y\n-                    contains_exterior_struct_lit(&x)\n-                }\n-\n-                ast::ExprKind::MethodCall(.., ref exprs) => {\n-                    // X { y: 1 }.bar(...)\n-                    contains_exterior_struct_lit(&exprs[0])\n-                }\n-\n-                _ => false,\n-            }\n-        }\n     }\n }\n "}, {"sha": "9903dc50f36fb4480aab744724df83cff444252f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 82, "deletions": 65, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e", "patch": "@@ -14,7 +14,7 @@ use abi::{self, Abi};\n use ast::{self, BlockCheckMode, PatKind, RangeEnd};\n use ast::{SelfKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::Attribute;\n-use util::parser::AssocOp;\n+use util::parser::{self, AssocOp, Fixity};\n use attr;\n use codemap::{self, CodeMap};\n use syntax_pos::{self, BytePos};\n@@ -421,16 +421,6 @@ pub fn visibility_qualified(vis: &ast::Visibility, s: &str) -> String {\n     format!(\"{}{}\", to_string(|s| s.print_visibility(vis)), s)\n }\n \n-fn needs_parentheses(expr: &ast::Expr) -> bool {\n-    match expr.node {\n-        ast::ExprKind::Assign(..) | ast::ExprKind::Binary(..) |\n-        ast::ExprKind::Closure(..) |\n-        ast::ExprKind::AssignOp(..) | ast::ExprKind::Cast(..) |\n-        ast::ExprKind::InPlace(..) | ast::ExprKind::Type(..) => true,\n-        _ => false,\n-    }\n-}\n-\n pub trait PrintState<'a> {\n     fn writer(&mut self) -> &mut pp::Printer<'a>;\n     fn boxes(&mut self) -> &mut Vec<pp::Breaks>;\n@@ -1736,7 +1726,7 @@ impl<'a> State<'a> {\n                         self.cbox(INDENT_UNIT - 1)?;\n                         self.ibox(0)?;\n                         self.s.word(\" else if \")?;\n-                        self.print_expr(i)?;\n+                        self.print_expr_as_cond(i)?;\n                         self.s.space()?;\n                         self.print_block(then)?;\n                         self.print_else(e.as_ref().map(|e| &**e))\n@@ -1749,7 +1739,7 @@ impl<'a> State<'a> {\n                         self.print_pat(pat)?;\n                         self.s.space()?;\n                         self.word_space(\"=\")?;\n-                        self.print_expr(expr)?;\n+                        self.print_expr_as_cond(expr)?;\n                         self.s.space()?;\n                         self.print_block(then)?;\n                         self.print_else(e.as_ref().map(|e| &**e))\n@@ -1774,7 +1764,7 @@ impl<'a> State<'a> {\n     pub fn print_if(&mut self, test: &ast::Expr, blk: &ast::Block,\n                     elseopt: Option<&ast::Expr>) -> io::Result<()> {\n         self.head(\"if\")?;\n-        self.print_expr(test)?;\n+        self.print_expr_as_cond(test)?;\n         self.s.space()?;\n         self.print_block(blk)?;\n         self.print_else(elseopt)\n@@ -1786,7 +1776,7 @@ impl<'a> State<'a> {\n         self.print_pat(pat)?;\n         self.s.space()?;\n         self.word_space(\"=\")?;\n-        self.print_expr(expr)?;\n+        self.print_expr_as_cond(expr)?;\n         self.s.space()?;\n         self.print_block(blk)?;\n         self.print_else(elseopt)\n@@ -1821,19 +1811,31 @@ impl<'a> State<'a> {\n         self.pclose()\n     }\n \n-    pub fn check_expr_bin_needs_paren(&mut self, sub_expr: &ast::Expr,\n-                                      binop: ast::BinOp) -> bool {\n-        match sub_expr.node {\n-            ast::ExprKind::Binary(ref sub_op, _, _) => {\n-                AssocOp::from_ast_binop(sub_op.node).precedence() <\n-                    AssocOp::from_ast_binop(binop.node).precedence()\n-            }\n-            _ => true\n+    pub fn print_expr_maybe_paren(&mut self, expr: &ast::Expr, prec: i8) -> io::Result<()> {\n+        let needs_par = parser::expr_precedence(expr) < prec;\n+        if needs_par {\n+            self.popen()?;\n         }\n+        self.print_expr(expr)?;\n+        if needs_par {\n+            self.pclose()?;\n+        }\n+        Ok(())\n     }\n \n-    pub fn print_expr_maybe_paren(&mut self, expr: &ast::Expr) -> io::Result<()> {\n-        let needs_par = needs_parentheses(expr);\n+    /// Print an expr using syntax that's acceptable in a condition position, such as the `cond` in\n+    /// `if cond { ... }`.\n+    pub fn print_expr_as_cond(&mut self, expr: &ast::Expr) -> io::Result<()> {\n+        let needs_par = match expr.node {\n+            // These cases need parens due to the parse error observed in #26461: `if return {}`\n+            // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n+            ast::ExprKind::Closure(..) |\n+            ast::ExprKind::Ret(..) |\n+            ast::ExprKind::Break(..) => true,\n+\n+            _ => parser::contains_exterior_struct_lit(expr),\n+        };\n+\n         if needs_par {\n             self.popen()?;\n         }\n@@ -1847,10 +1849,11 @@ impl<'a> State<'a> {\n     fn print_expr_in_place(&mut self,\n                            place: &ast::Expr,\n                            expr: &ast::Expr) -> io::Result<()> {\n-        self.print_expr_maybe_paren(place)?;\n+        let prec = AssocOp::Inplace.precedence() as i8;\n+        self.print_expr_maybe_paren(place, prec + 1)?;\n         self.s.space()?;\n         self.word_space(\"<-\")?;\n-        self.print_expr_maybe_paren(expr)\n+        self.print_expr_maybe_paren(expr, prec)\n     }\n \n     fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>],\n@@ -1931,15 +1934,22 @@ impl<'a> State<'a> {\n     fn print_expr_call(&mut self,\n                        func: &ast::Expr,\n                        args: &[P<ast::Expr>]) -> io::Result<()> {\n-        self.print_expr_maybe_paren(func)?;\n+        let prec =\n+            match func.node {\n+                ast::ExprKind::Field(..) |\n+                ast::ExprKind::TupField(..) => parser::PREC_FORCE_PAREN,\n+                _ => parser::PREC_POSTFIX,\n+            };\n+\n+        self.print_expr_maybe_paren(func, prec)?;\n         self.print_call_post(args)\n     }\n \n     fn print_expr_method_call(&mut self,\n                               segment: &ast::PathSegment,\n                               args: &[P<ast::Expr>]) -> io::Result<()> {\n         let base_args = &args[1..];\n-        self.print_expr(&args[0])?;\n+        self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX)?;\n         self.s.word(\".\")?;\n         self.print_ident(segment.identifier)?;\n         if let Some(ref parameters) = segment.parameters {\n@@ -1952,33 +1962,35 @@ impl<'a> State<'a> {\n                          op: ast::BinOp,\n                          lhs: &ast::Expr,\n                          rhs: &ast::Expr) -> io::Result<()> {\n-        if self.check_expr_bin_needs_paren(lhs, op) {\n-            self.print_expr_maybe_paren(lhs)?;\n-        } else {\n-            self.print_expr(lhs)?;\n-        }\n+        let assoc_op = AssocOp::from_ast_binop(op.node);\n+        let prec = assoc_op.precedence() as i8;\n+        let fixity = assoc_op.fixity();\n+\n+        let (left_prec, right_prec) = match fixity {\n+            Fixity::Left => (prec, prec + 1),\n+            Fixity::Right => (prec + 1, prec),\n+            Fixity::None => (prec + 1, prec + 1),\n+        };\n+\n+        self.print_expr_maybe_paren(lhs, left_prec)?;\n         self.s.space()?;\n         self.word_space(op.node.to_string())?;\n-        if self.check_expr_bin_needs_paren(rhs, op) {\n-            self.print_expr_maybe_paren(rhs)\n-        } else {\n-            self.print_expr(rhs)\n-        }\n+        self.print_expr_maybe_paren(rhs, right_prec)\n     }\n \n     fn print_expr_unary(&mut self,\n                         op: ast::UnOp,\n                         expr: &ast::Expr) -> io::Result<()> {\n         self.s.word(ast::UnOp::to_string(op))?;\n-        self.print_expr_maybe_paren(expr)\n+        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n \n     fn print_expr_addr_of(&mut self,\n                           mutability: ast::Mutability,\n                           expr: &ast::Expr) -> io::Result<()> {\n         self.s.word(\"&\")?;\n         self.print_mutability(mutability)?;\n-        self.print_expr_maybe_paren(expr)\n+        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n \n     pub fn print_expr(&mut self, expr: &ast::Expr) -> io::Result<()> {\n@@ -2002,7 +2014,7 @@ impl<'a> State<'a> {\n         match expr.node {\n             ast::ExprKind::Box(ref expr) => {\n                 self.word_space(\"box\")?;\n-                self.print_expr(expr)?;\n+                self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)?;\n             }\n             ast::ExprKind::InPlace(ref place, ref expr) => {\n                 self.print_expr_in_place(place, expr)?;\n@@ -2038,17 +2050,15 @@ impl<'a> State<'a> {\n                 self.print_literal(lit)?;\n             }\n             ast::ExprKind::Cast(ref expr, ref ty) => {\n-                if let ast::ExprKind::Cast(..) = expr.node {\n-                    self.print_expr(expr)?;\n-                } else {\n-                    self.print_expr_maybe_paren(expr)?;\n-                }\n+                let prec = AssocOp::As.precedence() as i8;\n+                self.print_expr_maybe_paren(expr, prec)?;\n                 self.s.space()?;\n                 self.word_space(\"as\")?;\n                 self.print_type(ty)?;\n             }\n             ast::ExprKind::Type(ref expr, ref ty) => {\n-                self.print_expr(expr)?;\n+                let prec = AssocOp::Colon.precedence() as i8;\n+                self.print_expr_maybe_paren(expr, prec)?;\n                 self.word_space(\":\")?;\n                 self.print_type(ty)?;\n             }\n@@ -2064,7 +2074,7 @@ impl<'a> State<'a> {\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while\")?;\n-                self.print_expr(test)?;\n+                self.print_expr_as_cond(test)?;\n                 self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n@@ -2077,7 +2087,7 @@ impl<'a> State<'a> {\n                 self.print_pat(pat)?;\n                 self.s.space()?;\n                 self.word_space(\"=\")?;\n-                self.print_expr(expr)?;\n+                self.print_expr_as_cond(expr)?;\n                 self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n@@ -2090,7 +2100,7 @@ impl<'a> State<'a> {\n                 self.print_pat(pat)?;\n                 self.s.space()?;\n                 self.word_space(\"in\")?;\n-                self.print_expr(iter)?;\n+                self.print_expr_as_cond(iter)?;\n                 self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n@@ -2107,7 +2117,7 @@ impl<'a> State<'a> {\n                 self.cbox(INDENT_UNIT)?;\n                 self.ibox(4)?;\n                 self.word_nbsp(\"match\")?;\n-                self.print_expr(expr)?;\n+                self.print_expr_as_cond(expr)?;\n                 self.s.space()?;\n                 self.bopen()?;\n                 self.print_inner_attributes_no_trailing_hardbreak(attrs)?;\n@@ -2137,45 +2147,52 @@ impl<'a> State<'a> {\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n             ast::ExprKind::Assign(ref lhs, ref rhs) => {\n-                self.print_expr(lhs)?;\n+                let prec = AssocOp::Assign.precedence() as i8;\n+                self.print_expr_maybe_paren(lhs, prec + 1)?;\n                 self.s.space()?;\n                 self.word_space(\"=\")?;\n-                self.print_expr(rhs)?;\n+                self.print_expr_maybe_paren(rhs, prec)?;\n             }\n             ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n-                self.print_expr(lhs)?;\n+                let prec = AssocOp::Assign.precedence() as i8;\n+                self.print_expr_maybe_paren(lhs, prec + 1)?;\n                 self.s.space()?;\n                 self.s.word(op.node.to_string())?;\n                 self.word_space(\"=\")?;\n-                self.print_expr(rhs)?;\n+                self.print_expr_maybe_paren(rhs, prec)?;\n             }\n             ast::ExprKind::Field(ref expr, id) => {\n-                self.print_expr(expr)?;\n+                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\".\")?;\n                 self.print_ident(id.node)?;\n             }\n             ast::ExprKind::TupField(ref expr, id) => {\n-                self.print_expr(expr)?;\n+                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\".\")?;\n                 self.print_usize(id.node)?;\n             }\n             ast::ExprKind::Index(ref expr, ref index) => {\n-                self.print_expr(expr)?;\n+                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\"[\")?;\n                 self.print_expr(index)?;\n                 self.s.word(\"]\")?;\n             }\n             ast::ExprKind::Range(ref start, ref end, limits) => {\n+                // Special case for `Range`.  `AssocOp` claims that `Range` has higher precedence\n+                // than `Assign`, but `x .. x = x` gives a parse error instead of `x .. (x = x)`.\n+                // Here we use a fake precedence value so that any child with lower precedence than\n+                // a \"normal\" binop gets parenthesized.  (`LOr` is the lowest-precedence binop.)\n+                let fake_prec = AssocOp::LOr.precedence() as i8;\n                 if let Some(ref e) = *start {\n-                    self.print_expr(e)?;\n+                    self.print_expr_maybe_paren(e, fake_prec)?;\n                 }\n                 if limits == ast::RangeLimits::HalfOpen {\n                     self.s.word(\"..\")?;\n                 } else {\n                     self.s.word(\"...\")?;\n                 }\n                 if let Some(ref e) = *end {\n-                    self.print_expr(e)?;\n+                    self.print_expr_maybe_paren(e, fake_prec)?;\n                 }\n             }\n             ast::ExprKind::Path(None, ref path) => {\n@@ -2192,7 +2209,7 @@ impl<'a> State<'a> {\n                     self.s.space()?;\n                 }\n                 if let Some(ref expr) = *opt_expr {\n-                    self.print_expr(expr)?;\n+                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP)?;\n                     self.s.space()?;\n                 }\n             }\n@@ -2208,7 +2225,7 @@ impl<'a> State<'a> {\n                 self.s.word(\"return\")?;\n                 if let Some(ref expr) = *result {\n                     self.s.word(\" \")?;\n-                    self.print_expr(expr)?;\n+                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP)?;\n                 }\n             }\n             ast::ExprKind::InlineAsm(ref a) => {\n@@ -2286,13 +2303,13 @@ impl<'a> State<'a> {\n                 match *e {\n                     Some(ref expr) => {\n                         self.s.space()?;\n-                        self.print_expr(&expr)?;\n+                        self.print_expr_maybe_paren(expr, parser::PREC_JUMP)?;\n                     }\n                     _ => ()\n                 }\n             }\n             ast::ExprKind::Try(ref e) => {\n-                self.print_expr(e)?;\n+                self.print_expr_maybe_paren(e, parser::PREC_POSTFIX)?;\n                 self.s.word(\"?\")?\n             }\n             ast::ExprKind::Catch(ref blk) => {"}, {"sha": "a4f06cb1b45da6fca561a7cba8cdde6f4ada1e9b", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 103, "deletions": 1, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n use parse::token::{Token, BinOpToken};\n use symbol::keywords;\n-use ast::BinOpKind;\n+use ast::{self, BinOpKind, ExprKind};\n \n /// Associative operator with precedence.\n ///\n@@ -215,3 +215,105 @@ impl AssocOp {\n         }\n     }\n }\n+\n+pub const PREC_RESET: i8 = -100;\n+pub const PREC_CLOSURE: i8 = -40;\n+pub const PREC_JUMP: i8 = -30;\n+pub const PREC_RANGE: i8 = -10;\n+// The range 2 ... 14 is reserved for AssocOp binary operator precedences.\n+pub const PREC_PREFIX: i8 = 50;\n+pub const PREC_POSTFIX: i8 = 60;\n+pub const PREC_PAREN: i8 = 99;\n+pub const PREC_FORCE_PAREN: i8 = 100;\n+\n+pub fn expr_precedence(expr: &ast::Expr) -> i8 {\n+    match expr.node {\n+        ExprKind::Closure(..) => PREC_CLOSURE,\n+\n+        ExprKind::Break(..) |\n+        ExprKind::Continue(..) |\n+        ExprKind::Ret(..) |\n+        ExprKind::Yield(..) => PREC_JUMP,\n+\n+        // `Range` claims to have higher precedence than `Assign`, but `x .. x = x` fails to parse,\n+        // instead of parsing as `(x .. x) = x`.  Giving `Range` a lower precedence ensures that\n+        // `pprust` will add parentheses in the right places to get the desired parse.\n+        ExprKind::Range(..) => PREC_RANGE,\n+\n+        // Binop-like expr kinds, handled by `AssocOp`.\n+        ExprKind::Binary(op, _, _) =>\n+            AssocOp::from_ast_binop(op.node).precedence() as i8,\n+\n+        ExprKind::InPlace(..) => AssocOp::Inplace.precedence() as i8,\n+        ExprKind::Cast(..) => AssocOp::As.precedence() as i8,\n+        ExprKind::Type(..) => AssocOp::Colon.precedence() as i8,\n+\n+        ExprKind::Assign(..) |\n+        ExprKind::AssignOp(..) => AssocOp::Assign.precedence() as i8,\n+\n+        // Unary, prefix\n+        ExprKind::Box(..) |\n+        ExprKind::AddrOf(..) |\n+        ExprKind::Unary(..) => PREC_PREFIX,\n+\n+        // Unary, postfix\n+        ExprKind::Call(..) |\n+        ExprKind::MethodCall(..) |\n+        ExprKind::Field(..) |\n+        ExprKind::TupField(..) |\n+        ExprKind::Index(..) |\n+        ExprKind::Try(..) |\n+        ExprKind::InlineAsm(..) |\n+        ExprKind::Mac(..) => PREC_POSTFIX,\n+\n+        // Never need parens\n+        ExprKind::Array(..) |\n+        ExprKind::Repeat(..) |\n+        ExprKind::Tup(..) |\n+        ExprKind::Lit(..) |\n+        ExprKind::Path(..) |\n+        ExprKind::Paren(..) |\n+        ExprKind::If(..) |\n+        ExprKind::IfLet(..) |\n+        ExprKind::While(..) |\n+        ExprKind::WhileLet(..) |\n+        ExprKind::ForLoop(..) |\n+        ExprKind::Loop(..) |\n+        ExprKind::Match(..) |\n+        ExprKind::Block(..) |\n+        ExprKind::Catch(..) |\n+        ExprKind::Struct(..) => PREC_PAREN,\n+    }\n+}\n+\n+/// Expressions that syntactically contain an \"exterior\" struct literal i.e. not surrounded by any\n+/// parens or other delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n+/// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n+pub fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n+    match value.node {\n+        ast::ExprKind::Struct(..) => true,\n+\n+        ast::ExprKind::Assign(ref lhs, ref rhs) |\n+        ast::ExprKind::AssignOp(_, ref lhs, ref rhs) |\n+        ast::ExprKind::Binary(_, ref lhs, ref rhs) => {\n+            // X { y: 1 } + X { y: 2 }\n+            contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n+        }\n+        ast::ExprKind::Unary(_, ref x) |\n+        ast::ExprKind::Cast(ref x, _) |\n+        ast::ExprKind::Type(ref x, _) |\n+        ast::ExprKind::Field(ref x, _) |\n+        ast::ExprKind::TupField(ref x, _) |\n+        ast::ExprKind::Index(ref x, _) => {\n+            // &X { y: 1 }, X { y: 1 }.y\n+            contains_exterior_struct_lit(&x)\n+        }\n+\n+        ast::ExprKind::MethodCall(.., ref exprs) => {\n+            // X { y: 1 }.bar(...)\n+            contains_exterior_struct_lit(&exprs[0])\n+        }\n+\n+        _ => false,\n+    }\n+}"}, {"sha": "456088b2c52858b12a79c0288eb3e1a786a78e19", "filename": "src/test/run-pass-fulldeps/pprust-expr-roundtrip.rs", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs?ref=d6ad402a644d9e57f1a6d6c579fe04acf00e0e2e", "patch": "@@ -0,0 +1,245 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-cross-compile\n+\n+\n+// The general idea of this test is to enumerate all \"interesting\" expressions and check that\n+// `parse(print(e)) == e` for all `e`.  Here's what's interesting, for the purposes of this test:\n+//\n+//  1. The test focuses on expression nesting, because interactions between different expression\n+//     types are harder to test manually than single expression types in isolation.\n+//\n+//  2. The test only considers expressions of at most two nontrivial nodes.  So it will check `x +\n+//     x` and `x + (x - x)` but not `(x * x) + (x - x)`.  The assumption here is that the correct\n+//     handling of an expression might depend on the expression's parent, but doesn't depend on its\n+//     siblings or any more distant ancestors.\n+//\n+// 3. The test only checks certain expression kinds.  The assumption is that similar expression\n+//    types, such as `if` and `while` or `+` and `-`,  will be handled identically in the printer\n+//    and parser.  So if all combinations of exprs involving `if` work correctly, then combinations\n+//    using `while`, `if let`, and so on will likely work as well.\n+\n+\n+#![feature(rustc_private)]\n+\n+extern crate syntax;\n+\n+use syntax::ast::*;\n+use syntax::codemap::{Spanned, DUMMY_SP};\n+use syntax::codemap::FilePathMapping;\n+use syntax::fold::{self, Folder};\n+use syntax::parse::{self, ParseSess};\n+use syntax::print::pprust;\n+use syntax::ptr::P;\n+use syntax::util::ThinVec;\n+\n+\n+fn parse_expr(ps: &ParseSess, src: &str) -> P<Expr> {\n+    let mut p = parse::new_parser_from_source_str(ps,\n+                                                  \"<expr>\".to_owned(),\n+                                                  src.to_owned());\n+    p.parse_expr().unwrap()\n+}\n+\n+\n+// Helper functions for building exprs\n+fn expr(kind: ExprKind) -> P<Expr> {\n+    P(Expr {\n+        id: DUMMY_NODE_ID,\n+        node: kind,\n+        span: DUMMY_SP,\n+        attrs: ThinVec::new(),\n+    })\n+}\n+\n+fn make_x() -> P<Expr> {\n+    let seg = PathSegment {\n+        identifier: Ident::from_str(\"x\"),\n+        span: DUMMY_SP,\n+        parameters: None,\n+    };\n+    let path = Path {\n+        span: DUMMY_SP,\n+        segments: vec![seg],\n+    };\n+    expr(ExprKind::Path(None, path))\n+}\n+\n+/// Iterate over exprs of depth up to `depth`.  The goal is to explore all \"interesting\"\n+/// combinations of expression nesting.  For example, we explore combinations using `if`, but not\n+/// `while` or `match`, since those should print and parse in much the same way as `if`.\n+fn iter_exprs(depth: usize, f: &mut FnMut(P<Expr>)) {\n+    if depth == 0 {\n+        f(make_x());\n+        return;\n+    }\n+\n+    let mut g = |e| f(expr(e));\n+\n+    for kind in 0 .. 17 {\n+        match kind {\n+            0 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Box(e))),\n+            1 => {\n+                // Note that for binary expressions, we explore each side separately.  The\n+                // parenthesization decisions for the LHS and RHS should be independent, and this\n+                // way produces `O(n)` results instead of `O(n^2)`.\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::InPlace(e, make_x())));\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::InPlace(make_x(), e)));\n+            },\n+            2 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Call(e, vec![]))),\n+            3 => {\n+                let seg = PathSegment {\n+                    identifier: Ident::from_str(\"x\"),\n+                    span: DUMMY_SP,\n+                    parameters: None,\n+                };\n+\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::MethodCall(\n+                            seg.clone(), vec![e, make_x()])));\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::MethodCall(\n+                            seg.clone(), vec![make_x(), e])));\n+            },\n+            4 => {\n+                let op = Spanned { span: DUMMY_SP, node: BinOpKind::Add };\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, e, make_x())));\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, make_x(), e)));\n+            },\n+            5 => {\n+                let op = Spanned { span: DUMMY_SP, node: BinOpKind::Mul };\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, e, make_x())));\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, make_x(), e)));\n+            },\n+            6 => {\n+                let op = Spanned { span: DUMMY_SP, node: BinOpKind::Shl };\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, e, make_x())));\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, make_x(), e)));\n+            },\n+            7 => {\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Unary(UnOp::Deref, e)));\n+            },\n+            8 => {\n+                let block = P(Block {\n+                    stmts: Vec::new(),\n+                    id: DUMMY_NODE_ID,\n+                    rules: BlockCheckMode::Default,\n+                    span: DUMMY_SP,\n+                });\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::If(e, block.clone(), None)));\n+            },\n+            9 => {\n+                let decl = P(FnDecl {\n+                    inputs: vec![],\n+                    output: FunctionRetTy::Default(DUMMY_SP),\n+                    variadic: false,\n+                });\n+                iter_exprs(depth - 1, &mut |e| g(\n+                        ExprKind::Closure(CaptureBy::Value, decl.clone(), e, DUMMY_SP)));\n+            },\n+            10 => {\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Assign(e, make_x())));\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Assign(make_x(), e)));\n+            },\n+            11 => {\n+                let ident = Spanned { span: DUMMY_SP, node: Ident::from_str(\"f\") };\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Field(e, ident)));\n+            },\n+            12 => {\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Range(\n+                            Some(e), Some(make_x()), RangeLimits::HalfOpen)));\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Range(\n+                            Some(make_x()), Some(e), RangeLimits::HalfOpen)));\n+            },\n+            13 => {\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::AddrOf(Mutability::Immutable, e)));\n+            },\n+            14 => {\n+                g(ExprKind::Ret(None));\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Ret(Some(e))));\n+            },\n+            15 => {\n+                let seg = PathSegment {\n+                    identifier: Ident::from_str(\"S\"),\n+                    span: DUMMY_SP,\n+                    parameters: None,\n+                };\n+                let path = Path {\n+                    span: DUMMY_SP,\n+                    segments: vec![seg],\n+                };\n+                g(ExprKind::Struct(path, vec![], Some(make_x())));\n+            },\n+            16 => {\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Try(e)));\n+            },\n+            _ => panic!(\"bad counter value in iter_exprs\"),\n+        }\n+    }\n+}\n+\n+\n+// Folders for manipulating the placement of `Paren` nodes.  See below for why this is needed.\n+\n+/// Folder that removes all `ExprKind::Paren` nodes.\n+struct RemoveParens;\n+\n+impl Folder for RemoveParens {\n+    fn fold_expr(&mut self, e: P<Expr>) -> P<Expr> {\n+        let e = match e.node {\n+            ExprKind::Paren(ref inner) => inner.clone(),\n+            _ => e.clone(),\n+        };\n+        e.map(|e| fold::noop_fold_expr(e, self))\n+    }\n+}\n+\n+\n+/// Folder that inserts `ExprKind::Paren` nodes around every `Expr`.\n+struct AddParens;\n+\n+impl Folder for AddParens {\n+    fn fold_expr(&mut self, e: P<Expr>) -> P<Expr> {\n+        let e = e.map(|e| fold::noop_fold_expr(e, self));\n+        P(Expr {\n+            id: DUMMY_NODE_ID,\n+            node: ExprKind::Paren(e),\n+            span: DUMMY_SP,\n+            attrs: ThinVec::new(),\n+        })\n+    }\n+}\n+\n+\n+fn main() {\n+    let ps = ParseSess::new(FilePathMapping::empty());\n+\n+    iter_exprs(2, &mut |e| {\n+        // If the pretty printer is correct, then `parse(print(e))` should be identical to `e`,\n+        // modulo placement of `Paren` nodes.\n+        let printed = pprust::expr_to_string(&e);\n+        println!(\"printed: {}\", printed);\n+\n+        let parsed = parse_expr(&ps, &printed);\n+\n+        // We want to know if `parsed` is structurally identical to `e`, ignoring trivial\n+        // differences like placement of `Paren`s or the exact ranges of node spans.\n+        // Unfortunately, there is no easy way to make this comparison.  Instead, we add `Paren`s\n+        // everywhere we can, then pretty-print.  This should give an unambiguous representation of\n+        // each `Expr`, and it bypasses nearly all of the parenthesization logic, so we aren't\n+        // relying on the correctness of the very thing we're testing.\n+        let e1 = AddParens.fold_expr(RemoveParens.fold_expr(e));\n+        let text1 = pprust::expr_to_string(&e1);\n+        let e2 = AddParens.fold_expr(RemoveParens.fold_expr(parsed));\n+        let text2 = pprust::expr_to_string(&e2);\n+        assert!(text1 == text2,\n+                \"exprs are not equal:\\n  e =      {:?}\\n  parsed = {:?}\",\n+                text1, text2);\n+    });\n+}"}]}