{"sha": "12e56ea56b0291c99f426521f028978598808d89", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyZTU2ZWE1NmIwMjkxYzk5ZjQyNjUyMWYwMjg5Nzg1OTg4MDhkODk=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-25T03:22:44Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-11T01:14:58Z"}, "message": "rustc: Wrap users of InferCtxt in an anonymous scope.", "tree": {"sha": "6b5d8a9601863137b26fc1bab9178010bc33888d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b5d8a9601863137b26fc1bab9178010bc33888d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12e56ea56b0291c99f426521f028978598808d89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12e56ea56b0291c99f426521f028978598808d89", "html_url": "https://github.com/rust-lang/rust/commit/12e56ea56b0291c99f426521f028978598808d89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12e56ea56b0291c99f426521f028978598808d89/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a704f6dc7f0ed6be1554867c2a95e4e322cc1bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a704f6dc7f0ed6be1554867c2a95e4e322cc1bc", "html_url": "https://github.com/rust-lang/rust/commit/8a704f6dc7f0ed6be1554867c2a95e4e322cc1bc"}], "stats": {"total": 1789, "additions": 876, "deletions": 913}, "files": [{"sha": "64277404203db5bfd58b6e5580f31179768423f1", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 38, "deletions": 27, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -385,12 +385,21 @@ impl fmt::Display for FixupError {\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               tables: &'a RefCell<ty::Tables<'tcx>>,\n-               param_env: Option<ty::ParameterEnvironment<'tcx>>,\n-               projection_mode: ProjectionMode)\n-               -> Self {\n-        InferCtxt {\n+    pub fn enter<F, R>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                       tables: Option<ty::Tables<'tcx>>,\n+                       param_env: Option<ty::ParameterEnvironment<'tcx>>,\n+                       projection_mode: ProjectionMode,\n+                       f: F) -> R\n+        where F: for<'b> FnOnce(InferCtxt<'b, 'tcx, 'tcx>) -> R\n+    {\n+        let new_tables;\n+        let tables = if let Some(tables) = tables {\n+            new_tables = RefCell::new(tables);\n+            &new_tables\n+        } else {\n+            &tcx.tables\n+        };\n+        f(InferCtxt {\n             tcx: tcx,\n             tables: tables,\n             type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n@@ -403,16 +412,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx, 'tcx> {\n             projection_mode: projection_mode,\n         tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: tcx.sess.err_count()\n-        }\n+        })\n     }\n \n-    pub fn normalizing(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                       tables: &'a RefCell<ty::Tables<'tcx>>,\n-                       projection_mode: ProjectionMode)\n-                       -> Self {\n-        let mut infcx = InferCtxt::new(tcx, tables, None, projection_mode);\n-        infcx.normalize = true;\n-        infcx\n+    pub fn enter_normalizing<F, R>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   projection_mode: ProjectionMode,\n+                                   f: F) -> R\n+        where F: for<'b> FnOnce(InferCtxt<'b, 'tcx, 'tcx>) -> R\n+    {\n+        InferCtxt::enter(tcx, None, None, projection_mode, |mut infcx| {\n+            infcx.normalize = true;\n+            f(infcx)\n+        })\n     }\n }\n \n@@ -453,23 +464,23 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             return value;\n         }\n \n-        let infcx = InferCtxt::new(self, &self.tables, None, ProjectionMode::Any);\n-        let mut selcx = traits::SelectionContext::new(&infcx);\n-        let cause = traits::ObligationCause::dummy();\n-        let traits::Normalized { value: result, obligations } =\n-            traits::normalize(&mut selcx, cause, &value);\n+        InferCtxt::enter(self, None, None, ProjectionMode::Any, |infcx| {\n+            let mut selcx = traits::SelectionContext::new(&infcx);\n+            let cause = traits::ObligationCause::dummy();\n+            let traits::Normalized { value: result, obligations } =\n+                traits::normalize(&mut selcx, cause, &value);\n \n-        debug!(\"normalize_associated_type: result={:?} obligations={:?}\",\n-            result,\n-            obligations);\n+            debug!(\"normalize_associated_type: result={:?} obligations={:?}\",\n+                   result, obligations);\n \n-        let mut fulfill_cx = traits::FulfillmentContext::new();\n+            let mut fulfill_cx = traits::FulfillmentContext::new();\n \n-        for obligation in obligations {\n-            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n-        }\n+            for obligation in obligations {\n+                fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+            }\n \n-        infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &result)\n+            infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &result)\n+        })\n     }\n }\n "}, {"sha": "e45d3331a0284d48325381674dbf61ded03cbd3b", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -36,13 +36,12 @@ struct ItemVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> ItemVisitor<'a, 'tcx> {\n     fn visit_const(&mut self, item_id: ast::NodeId, expr: &hir::Expr) {\n         let param_env = ty::ParameterEnvironment::for_item(self.tcx, item_id);\n-        let infcx = InferCtxt::new(self.tcx, &self.tcx.tables,\n-                                   Some(param_env),\n-                                   ProjectionMode::Any);\n-        let mut visitor = ExprVisitor {\n-            infcx: &infcx\n-        };\n-        visitor.visit_expr(expr);\n+        InferCtxt::enter(self.tcx, None, Some(param_env), ProjectionMode::Any, |infcx| {\n+            let mut visitor = ExprVisitor {\n+                infcx: &infcx\n+            };\n+            visitor.visit_expr(expr);\n+        });\n     }\n }\n \n@@ -115,12 +114,12 @@ impl<'a, 'tcx> ExprVisitor<'a, 'tcx, 'tcx> {\n impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n     // const, static and N in [T; N].\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n-        let infcx = InferCtxt::new(self.tcx, &self.tcx.tables,\n-                                   None, ProjectionMode::Any);\n-        let mut visitor = ExprVisitor {\n-            infcx: &infcx\n-        };\n-        visitor.visit_expr(expr);\n+        InferCtxt::enter(self.tcx, None, None, ProjectionMode::Any, |infcx| {\n+            let mut visitor = ExprVisitor {\n+                infcx: &infcx\n+            };\n+            visitor.visit_expr(expr);\n+        });\n     }\n \n     fn visit_trait_item(&mut self, item: &hir::TraitItem) {\n@@ -141,21 +140,16 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n                 b: &'v hir::Block, s: Span, id: ast::NodeId) {\n-        match fk {\n-            FnKind::ItemFn(..) | FnKind::Method(..) => {\n-                let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n-                let infcx = InferCtxt::new(self.tcx, &self.tcx.tables,\n-                                           Some(param_env),\n-                                           ProjectionMode::Any);\n-                let mut visitor = ExprVisitor {\n-                    infcx: &infcx\n-                };\n-                visitor.visit_fn(fk, fd, b, s, id);\n-            }\n-            FnKind::Closure(..) => {\n-                span_bug!(s, \"intrinsicck: closure outside of function\")\n-            }\n+        if let FnKind::Closure(..) = fk {\n+            span_bug!(s, \"intrinsicck: closure outside of function\")\n         }\n+        let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n+        InferCtxt::enter(self.tcx, None, Some(param_env), ProjectionMode::Any, |infcx| {\n+            let mut visitor = ExprVisitor {\n+                infcx: &infcx\n+            };\n+            visitor.visit_fn(fk, fd, b, s, id);\n+        });\n     }\n }\n "}, {"sha": "fd0ef992f427c0b2a800937daf2a6928f50d8f07", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -1488,18 +1488,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n                 let param_env = ParameterEnvironment::for_item(self.ir.tcx, id);\n                 let t_ret_subst = t_ret.subst(self.ir.tcx, &param_env.free_substs);\n-                let infcx = InferCtxt::new(self.ir.tcx,\n-                                           &self.ir.tcx.tables,\n-                                           Some(param_env),\n-                                           ProjectionMode::Any);\n-                let cause = traits::ObligationCause::dummy();\n-                let norm = traits::fully_normalize(&infcx,\n-                                                   cause,\n-                                                   &t_ret_subst);\n-\n-                if norm.unwrap().is_nil() {\n-                    // for nil return types, it is ok to not return a value expl.\n-                } else {\n+                let is_nil = InferCtxt::enter(self.ir.tcx, None, Some(param_env),\n+                                              ProjectionMode::Any, |infcx| {\n+                    let cause = traits::ObligationCause::dummy();\n+                    traits::fully_normalize(&infcx, cause, &t_ret_subst).unwrap().is_nil()\n+                });\n+\n+                // for nil return types, it is ok to not return a value expl.\n+                if !is_nil {\n                     let ends_with_stmt = match body.expr {\n                         None if !body.stmts.is_empty() =>\n                             match body.stmts.last().unwrap().node {"}, {"sha": "bdeb4a47686cc30e46b2e55fd5f0a1b9f60a402a", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -37,7 +37,7 @@ pub use self::object_safety::MethodViolationCode;\n pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n-pub use self::specialize::{Overlap, specialization_graph, specializes, translate_substs};\n+pub use self::specialize::{OverlapError, specialization_graph, specializes, translate_substs};\n pub use self::util::elaborate_predicates;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;\n@@ -422,42 +422,43 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n \n-    let infcx = InferCtxt::new(tcx, &tcx.tables, Some(elaborated_env),\n-                               ProjectionMode::AnyFinal);\n-    let predicates = match fully_normalize(&infcx,\n-                                           cause,\n-                                           &infcx.parameter_environment.caller_bounds) {\n-        Ok(predicates) => predicates,\n-        Err(errors) => {\n-            infcx.report_fulfillment_errors(&errors);\n-            return infcx.parameter_environment; // an unnormalized env is better than nothing\n-        }\n-    };\n-\n-    debug!(\"normalize_param_env_or_error: normalized predicates={:?}\",\n-           predicates);\n-\n-    let free_regions = FreeRegionMap::new();\n-    infcx.resolve_regions_and_report_errors(&free_regions, body_id);\n-    let predicates = match infcx.fully_resolve(&predicates) {\n-        Ok(predicates) => predicates,\n-        Err(fixup_err) => {\n-            // If we encounter a fixup error, it means that some type\n-            // variable wound up unconstrained. I actually don't know\n-            // if this can happen, and I certainly don't expect it to\n-            // happen often, but if it did happen it probably\n-            // represents a legitimate failure due to some kind of\n-            // unconstrained variable, and it seems better not to ICE,\n-            // all things considered.\n-            tcx.sess.span_err(span, &fixup_err.to_string());\n-            return infcx.parameter_environment; // an unnormalized env is better than nothing\n-        }\n-    };\n+    InferCtxt::enter(tcx, None, Some(elaborated_env), ProjectionMode::AnyFinal, |infcx| {\n+        let predicates = match fully_normalize(&infcx, cause,\n+                                               &infcx.parameter_environment.caller_bounds) {\n+            Ok(predicates) => predicates,\n+            Err(errors) => {\n+                infcx.report_fulfillment_errors(&errors);\n+                // An unnormalized env is better than nothing.\n+                return infcx.parameter_environment;\n+            }\n+        };\n+\n+        debug!(\"normalize_param_env_or_error: normalized predicates={:?}\",\n+            predicates);\n+\n+        let free_regions = FreeRegionMap::new();\n+        infcx.resolve_regions_and_report_errors(&free_regions, body_id);\n+        let predicates = match infcx.fully_resolve(&predicates) {\n+            Ok(predicates) => predicates,\n+            Err(fixup_err) => {\n+                // If we encounter a fixup error, it means that some type\n+                // variable wound up unconstrained. I actually don't know\n+                // if this can happen, and I certainly don't expect it to\n+                // happen often, but if it did happen it probably\n+                // represents a legitimate failure due to some kind of\n+                // unconstrained variable, and it seems better not to ICE,\n+                // all things considered.\n+                tcx.sess.span_err(span, &fixup_err.to_string());\n+                // An unnormalized env is better than nothing.\n+                return infcx.parameter_environment;\n+            }\n+        };\n \n-    debug!(\"normalize_param_env_or_error: resolved predicates={:?}\",\n-           predicates);\n+        debug!(\"normalize_param_env_or_error: resolved predicates={:?}\",\n+            predicates);\n \n-    infcx.parameter_environment.with_caller_bounds(predicates)\n+        infcx.parameter_environment.with_caller_bounds(predicates)\n+    })\n }\n \n pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx, 'tcx>,"}, {"sha": "775fa89f011f90ad07882ec5bd4cb68864f97fa7", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -31,10 +31,10 @@ use syntax::codemap::DUMMY_SP;\n pub mod specialization_graph;\n \n /// Information pertinent to an overlapping impl error.\n-pub struct Overlap<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    pub in_context: InferCtxt<'a, 'gcx, 'tcx>,\n+pub struct OverlapError {\n     pub with_impl: DefId,\n-    pub on_trait_ref: ty::TraitRef<'tcx>,\n+    pub trait_desc: String,\n+    pub self_desc: Option<String>\n }\n \n /// Given a subst for the requested impl, translate it to a subst\n@@ -135,8 +135,6 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return false;\n     }\n \n-    let mut infcx = InferCtxt::normalizing(tcx, &tcx.tables, ProjectionMode::Topmost);\n-\n     // create a parameter environment corresponding to a (skolemized) instantiation of impl1\n     let scheme = tcx.lookup_item_type(impl1_def_id);\n     let predicates = tcx.lookup_predicates(impl1_def_id);\n@@ -148,18 +146,21 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              .unwrap()\n                              .subst(tcx, &penv.free_substs);\n \n-    // Normalize the trait reference, adding any obligations that arise into the impl1 assumptions\n-    let Normalized { value: impl1_trait_ref, obligations: normalization_obligations } = {\n-        let selcx = &mut SelectionContext::new(&infcx);\n-        traits::normalize(selcx, ObligationCause::dummy(), &impl1_trait_ref)\n-    };\n-    penv.caller_bounds.extend(normalization_obligations.into_iter().map(|o| o.predicate));\n+    InferCtxt::enter_normalizing(tcx, ProjectionMode::Topmost, |mut infcx| {\n+        // Normalize the trait reference, adding any obligations\n+        // that arise into the impl1 assumptions.\n+        let Normalized { value: impl1_trait_ref, obligations: normalization_obligations } = {\n+            let selcx = &mut SelectionContext::new(&infcx);\n+            traits::normalize(selcx, ObligationCause::dummy(), &impl1_trait_ref)\n+        };\n+        penv.caller_bounds.extend(normalization_obligations.into_iter().map(|o| o.predicate));\n \n-    // Install the parameter environment, taking the predicates of impl1 as assumptions:\n-    infcx.parameter_environment = penv;\n+        // Install the parameter environment, taking the predicates of impl1 as assumptions:\n+        infcx.parameter_environment = penv;\n \n-    // Attempt to prove that impl2 applies, given all of the above.\n-    fulfill_implication(&infcx, impl1_trait_ref, impl2_def_id).is_ok()\n+        // Attempt to prove that impl2 applies, given all of the above.\n+        fulfill_implication(&infcx, impl1_trait_ref, impl2_def_id).is_ok()\n+    })\n }\n \n /// Attempt to fulfill all obligations of `target_impl` after unification with"}, {"sha": "10478b812de1772f10eb064fdbf149e72d87b205", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 51, "deletions": 37, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -11,7 +11,7 @@\n use std::cell;\n use std::rc::Rc;\n \n-use super::{Overlap, specializes};\n+use super::{OverlapError, specializes};\n \n use hir::def_id::DefId;\n use infer::InferCtxt;\n@@ -66,7 +66,7 @@ struct Children {\n }\n \n /// The result of attempting to insert an impl into a group of children.\n-enum InsertResult<'a, 'tcx: 'a> {\n+enum Inserted {\n     /// The impl was inserted as a new child in this group of children.\n     BecameNewSibling,\n \n@@ -75,10 +75,6 @@ enum InsertResult<'a, 'tcx: 'a> {\n \n     /// The impl is a specialization of an existing child.\n     ShouldRecurseOn(DefId),\n-\n-    /// The impl has an unresolvable overlap with an existing child (neither\n-    /// specializes the other).\n-    Overlapped(Overlap<'a, 'tcx, 'tcx>),\n }\n \n impl<'a, 'tcx> Children {\n@@ -107,49 +103,70 @@ impl<'a, 'tcx> Children {\n               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               impl_def_id: DefId,\n               simplified_self: Option<SimplifiedType>)\n-              -> InsertResult<'a, 'tcx>\n+              -> Result<Inserted, OverlapError>\n     {\n         for slot in match simplified_self {\n             Some(sty) => self.filtered_mut(sty),\n             None => self.iter_mut(),\n         } {\n             let possible_sibling = *slot;\n \n-            let infcx = InferCtxt::new(tcx, &tcx.tables, None, ProjectionMode::Topmost);\n-            let overlap = traits::overlapping_impls(&infcx, possible_sibling, impl_def_id);\n-\n-            if let Some(impl_header) = overlap {\n-                let le = specializes(tcx, impl_def_id, possible_sibling);\n-                let ge = specializes(tcx, possible_sibling, impl_def_id);\n+            let (le, ge) = InferCtxt::enter(tcx, None, None,\n+                                            ProjectionMode::Topmost, |infcx| {\n+                let overlap = traits::overlapping_impls(&infcx,\n+                                                        possible_sibling,\n+                                                        impl_def_id);\n+                if let Some(impl_header) = overlap {\n+                    let le = specializes(tcx, impl_def_id, possible_sibling);\n+                    let ge = specializes(tcx, possible_sibling, impl_def_id);\n+\n+                    if le == ge {\n+                        // overlap, but no specialization; error out\n+                        let trait_ref = impl_header.trait_ref.unwrap();\n+                        Err(OverlapError {\n+                            with_impl: possible_sibling,\n+                            trait_desc: trait_ref.to_string(),\n+                            self_desc: trait_ref.substs.self_ty().and_then(|ty| {\n+                                // only report the Self type if it has at least\n+                                // some outer concrete shell; otherwise, it's\n+                                // not adding much information.\n+                                if ty.has_concrete_skeleton() {\n+                                    Some(ty.to_string())\n+                                } else {\n+                                    None\n+                                }\n+                            })\n+                        })\n+                    } else {\n+                        Ok((le, ge))\n+                    }\n+                } else {\n+                    Ok((false, false))\n+                }\n+            })?;\n \n-                if le && !ge {\n-                    debug!(\"descending as child of TraitRef {:?}\",\n-                           tcx.impl_trait_ref(possible_sibling).unwrap());\n+            if le && !ge {\n+                debug!(\"descending as child of TraitRef {:?}\",\n+                       tcx.impl_trait_ref(possible_sibling).unwrap());\n \n-                    // the impl specializes possible_sibling\n-                    return InsertResult::ShouldRecurseOn(possible_sibling);\n-                } else if ge && !le {\n-                    debug!(\"placing as parent of TraitRef {:?}\",\n-                           tcx.impl_trait_ref(possible_sibling).unwrap());\n+                // the impl specializes possible_sibling\n+                return Ok(Inserted::ShouldRecurseOn(possible_sibling));\n+            } else if ge && !le {\n+                debug!(\"placing as parent of TraitRef {:?}\",\n+                       tcx.impl_trait_ref(possible_sibling).unwrap());\n \n                     // possible_sibling specializes the impl\n                     *slot = impl_def_id;\n-                    return InsertResult::Replaced(possible_sibling);\n-                } else {\n-                    // overlap, but no specialization; error out\n-                    return InsertResult::Overlapped(Overlap {\n-                        with_impl: possible_sibling,\n-                        on_trait_ref: impl_header.trait_ref.unwrap(),\n-                        in_context: infcx,\n-                    });\n-                }\n+                return Ok(Inserted::Replaced(possible_sibling));\n+            } else {\n+                // no overlap (error bailed already via ?)\n             }\n         }\n \n         // no overlap with any potential siblings, so add as a new sibling\n         debug!(\"placing as new sibling\");\n         self.insert_blindly(tcx, impl_def_id);\n-        InsertResult::BecameNewSibling\n+        Ok(Inserted::BecameNewSibling)\n     }\n \n     fn iter_mut(&'a mut self) -> Box<Iterator<Item = &'a mut DefId> + 'a> {\n@@ -178,7 +195,7 @@ impl<'a, 'tcx> Graph {\n     pub fn insert(&mut self,\n                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   impl_def_id: DefId)\n-                  -> Result<(), Overlap<'a, 'tcx, 'tcx>> {\n+                  -> Result<(), OverlapError> {\n         assert!(impl_def_id.is_local());\n \n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n@@ -207,10 +224,10 @@ impl<'a, 'tcx> Graph {\n \n         // Descend the specialization tree, where `parent` is the current parent node\n         loop {\n-            use self::InsertResult::*;\n+            use self::Inserted::*;\n \n             let insert_result = self.children.entry(parent).or_insert(Children::new())\n-                .insert(tcx, impl_def_id, simplified);\n+                .insert(tcx, impl_def_id, simplified)?;\n \n             match insert_result {\n                 BecameNewSibling => {\n@@ -226,9 +243,6 @@ impl<'a, 'tcx> Graph {\n                 ShouldRecurseOn(new_parent) => {\n                     parent = new_parent;\n                 }\n-                Overlapped(error) => {\n-                    return Err(error);\n-                }\n             }\n         }\n "}, {"sha": "1d8703b6666801118df09c02f842d45c80f07061", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -197,7 +197,7 @@ impl<'a, 'tcx> TraitDef<'tcx> {\n     pub fn add_impl_for_specialization(&self,\n                                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        impl_def_id: DefId)\n-                                       -> Result<(), traits::Overlap<'a, 'tcx, 'tcx>> {\n+                                       -> Result<(), traits::OverlapError> {\n         assert!(impl_def_id.is_local());\n \n         self.specialization_graph.borrow_mut()"}, {"sha": "0d6962bec770438c3a2f296bc21a70983dbe8333", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 25, "deletions": 32, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -134,34 +134,34 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n                                        self_type: Ty<'tcx>, span: Span)\n                                        -> Result<(),CopyImplementationError> {\n         // FIXME: (@jroesch) float this code up\n-        let infcx = InferCtxt::new(tcx, &tcx.tables, Some(self.clone()),\n-                                   ProjectionMode::Topmost);\n-\n-        let adt = match self_type.sty {\n-            ty::TyStruct(struct_def, substs) => {\n-                for field in struct_def.all_fields() {\n-                    let field_ty = field.ty(tcx, substs);\n-                    if infcx.type_moves_by_default(field_ty, span) {\n-                        return Err(CopyImplementationError::InfrigingField(\n-                            field.name))\n-                    }\n-                }\n-                struct_def\n-            }\n-            ty::TyEnum(enum_def, substs) => {\n-                for variant in &enum_def.variants {\n-                    for field in &variant.fields {\n+        let adt = InferCtxt::enter(tcx, None, Some(self.clone()),\n+                                   ProjectionMode::Topmost, |infcx| {\n+            match self_type.sty {\n+                ty::TyStruct(struct_def, substs) => {\n+                    for field in struct_def.all_fields() {\n                         let field_ty = field.ty(tcx, substs);\n                         if infcx.type_moves_by_default(field_ty, span) {\n-                            return Err(CopyImplementationError::InfrigingVariant(\n-                                variant.name))\n+                            return Err(CopyImplementationError::InfrigingField(\n+                                field.name))\n                         }\n                     }\n+                    Ok(struct_def)\n                 }\n-                enum_def\n+                ty::TyEnum(enum_def, substs) => {\n+                    for variant in &enum_def.variants {\n+                        for field in &variant.fields {\n+                            let field_ty = field.ty(tcx, substs);\n+                            if infcx.type_moves_by_default(field_ty, span) {\n+                                return Err(CopyImplementationError::InfrigingVariant(\n+                                    variant.name))\n+                            }\n+                        }\n+                    }\n+                    Ok(enum_def)\n+                }\n+                _ => Err(CopyImplementationError::NotAnAdt)\n             }\n-            _ => return Err(CopyImplementationError::NotAnAdt),\n-        };\n+        })?;\n \n         if adt.has_dtor() {\n             return Err(CopyImplementationError::HasDestructor)\n@@ -512,16 +512,9 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                    param_env: &ParameterEnvironment<'tcx>,\n                    bound: ty::BuiltinBound, span: Span) -> bool\n     {\n-        let infcx = InferCtxt::new(tcx, &tcx.tables, Some(param_env.clone()),\n-                                   ProjectionMode::Topmost);\n-\n-        let is_impld = traits::type_known_to_meet_builtin_bound(&infcx,\n-                                                                self, bound, span);\n-\n-        debug!(\"Ty::impls_bound({:?}, {:?}) = {:?}\",\n-               self, bound, is_impld);\n-\n-        is_impld\n+        InferCtxt::enter(tcx, None, Some(param_env.clone()), ProjectionMode::Topmost, |infcx| {\n+            traits::type_known_to_meet_builtin_bound(&infcx, self, bound, span)\n+        })\n     }\n \n     // FIXME (@jroesch): I made this public to use it, not sure if should be private"}, {"sha": "c5fe43666219c455ecb9a0fa003f8842c43e894e", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -203,21 +203,17 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     debug!(\"check_loans(body id={})\", body.id);\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n-    let infcx = InferCtxt::new(bccx.tcx, &bccx.tcx.tables, Some(param_env),\n-                               ProjectionMode::AnyFinal);\n-\n-    let mut clcx = CheckLoanCtxt {\n-        bccx: bccx,\n-        dfcx_loans: dfcx_loans,\n-        move_data: move_data,\n-        all_loans: all_loans,\n-        param_env: &infcx.parameter_environment\n-    };\n-\n-    {\n+    InferCtxt::enter(bccx.tcx, None, Some(param_env), ProjectionMode::AnyFinal, |infcx| {\n+        let mut clcx = CheckLoanCtxt {\n+            bccx: bccx,\n+            dfcx_loans: dfcx_loans,\n+            move_data: move_data,\n+            all_loans: all_loans,\n+            param_env: &infcx.parameter_environment\n+        };\n         let mut euv = euv::ExprUseVisitor::new(&mut clcx, &infcx);\n         euv.walk_fn(decl, body);\n-    }\n+    });\n }\n \n #[derive(PartialEq)]"}, {"sha": "b4d7ca6627e7d1acaa58ed3b682079b684c18b9f", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -56,12 +56,10 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     };\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n-    let infcx = InferCtxt::new(bccx.tcx, &bccx.tcx.tables, Some(param_env),\n-                               ProjectionMode::AnyFinal);\n-    {\n+    InferCtxt::enter(bccx.tcx, None, Some(param_env), ProjectionMode::AnyFinal, |infcx| {\n         let mut euv = euv::ExprUseVisitor::new(&mut glcx, &infcx);\n         euv.walk_fn(decl, body);\n-    }\n+    });\n \n     glcx.report_potential_errors();\n     let GatherLoanCtxt { all_loans, move_data, .. } = glcx;\n@@ -527,15 +525,17 @@ struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr) {\n         if let hir::ExprAddrOf(mutbl, ref base) = ex.node {\n-            let infcx = InferCtxt::new(self.bccx.tcx, &self.bccx.tcx.tables, None,\n-                                       ProjectionMode::AnyFinal);\n-            let mc = mc::MemCategorizationContext::new(&infcx);\n-            let base_cmt = mc.cat_expr(&base).unwrap();\n-            let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n-            // Check that we don't allow borrows of unsafe static items.\n-            if check_aliasability(self.bccx, ex.span,\n-                                  BorrowViolation(euv::AddrOf),\n-                                  base_cmt, borrow_kind).is_err() {\n+            let err = InferCtxt::enter(self.bccx.tcx, None, None,\n+                                       ProjectionMode::AnyFinal, |infcx| {\n+                let mc = mc::MemCategorizationContext::new(&infcx);\n+                let base_cmt = mc.cat_expr(&base).unwrap();\n+                let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n+                // Check that we don't allow borrows of unsafe static items.\n+                check_aliasability(self.bccx, ex.span,\n+                                   BorrowViolation(euv::AddrOf),\n+                                   base_cmt, borrow_kind).is_err()\n+            });\n+            if err {\n                 return; // reported an error, no sense in reporting more.\n             }\n         }"}, {"sha": "d7c1c877c8bfc5c448fb9e081d1006a916a962f0", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -1123,12 +1123,12 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                     PatKind::Ident(hir::BindByValue(_), _, ref sub) => {\n                         let pat_ty = tcx.node_id_to_type(p.id);\n                         //FIXME: (@jroesch) this code should be floated up as well\n-                        let infcx = InferCtxt::new(cx.tcx, &cx.tcx.tables,\n-                                                   Some(cx.param_env.clone()),\n-                                                   ProjectionMode::AnyFinal);\n-                        if infcx.type_moves_by_default(pat_ty, pat.span) {\n-                            check_move(p, sub.as_ref().map(|p| &**p));\n-                        }\n+                        InferCtxt::enter(cx.tcx, None, Some(cx.param_env.clone()),\n+                                         ProjectionMode::AnyFinal, |infcx| {\n+                            if infcx.type_moves_by_default(pat_ty, pat.span) {\n+                                check_move(p, sub.as_ref().map(|p| &**p));\n+                            }\n+                        });\n                     }\n                     PatKind::Ident(hir::BindByRef(_), _, _) => {\n                     }\n@@ -1150,16 +1150,14 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n /// assign.\n fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>,\n                                          guard: &hir::Expr) {\n-    let mut checker = MutationChecker {\n-        cx: cx,\n-    };\n-\n-    let infcx = InferCtxt::new(cx.tcx, &cx.tcx.tables,\n-                               Some(checker.cx.param_env.clone()),\n-                               ProjectionMode::AnyFinal);\n-\n-    let mut visitor = ExprUseVisitor::new(&mut checker, &infcx);\n-    visitor.walk_expr(guard);\n+    InferCtxt::enter(cx.tcx, None, Some(cx.param_env.clone()),\n+                     ProjectionMode::AnyFinal, |infcx| {\n+        let mut checker = MutationChecker {\n+            cx: cx,\n+        };\n+        let mut visitor = ExprUseVisitor::new(&mut checker, &infcx);\n+        visitor.walk_expr(guard);\n+    });\n }\n \n struct MutationChecker<'a, 'tcx: 'a> {"}, {"sha": "c06fd4756286d6baebdeeeb9f772951a1fe034c2", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -1014,48 +1014,47 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            trait_ref);\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n-    let infcx = InferCtxt::new(tcx, &tcx.tables, None, ProjectionMode::AnyFinal);\n-\n-    let mut selcx = traits::SelectionContext::new(&infcx);\n-    let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n-                                             trait_ref.to_poly_trait_predicate());\n-    let selection = match selcx.select(&obligation) {\n-        Ok(Some(vtable)) => vtable,\n-        // Still ambiguous, so give up and let the caller decide whether this\n-        // expression is really needed yet. Some associated constant values\n-        // can't be evaluated until monomorphization is done in trans.\n-        Ok(None) => {\n-            return None\n-        }\n-        Err(_) => {\n-            return None\n-        }\n-    };\n+    InferCtxt::enter(tcx, None, None, ProjectionMode::AnyFinal, |infcx| {\n+        let mut selcx = traits::SelectionContext::new(&infcx);\n+        let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n+                                                 trait_ref.to_poly_trait_predicate());\n+        let selection = match selcx.select(&obligation) {\n+            Ok(Some(vtable)) => vtable,\n+            // Still ambiguous, so give up and let the caller decide whether this\n+            // expression is really needed yet. Some associated constant values\n+            // can't be evaluated until monomorphization is done in trans.\n+            Ok(None) => {\n+                return None\n+            }\n+            Err(_) => {\n+                return None\n+            }\n+        };\n \n-    // NOTE: this code does not currently account for specialization, but when\n-    // it does so, it should hook into the ProjectionMode to determine when the\n-    // constant should resolve; this will also require plumbing through to this\n-    // function whether we are in \"trans mode\" to pick the right ProjectionMode\n-    // when constructing the inference context above.\n-    match selection {\n-        traits::VtableImpl(ref impl_data) => {\n-            match tcx.associated_consts(impl_data.impl_def_id)\n-                     .iter().find(|ic| ic.name == ti.name) {\n-                Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n-                None => match ti.node {\n-                    hir::ConstTraitItem(ref ty, Some(ref expr)) => {\n-                        Some((&*expr, tcx.ast_ty_to_prim_ty(ty)))\n+        // NOTE: this code does not currently account for specialization, but when\n+        // it does so, it should hook into the ProjectionMode to determine when the\n+        // constant should resolve; this will also require plumbing through to this\n+        // function whether we are in \"trans mode\" to pick the right ProjectionMode\n+        // when constructing the inference context above.\n+        match selection {\n+            traits::VtableImpl(ref impl_data) => {\n+                match tcx.associated_consts(impl_data.impl_def_id)\n+                        .iter().find(|ic| ic.name == ti.name) {\n+                    Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n+                    None => match ti.node {\n+                        hir::ConstTraitItem(ref ty, Some(ref expr)) => {\n+                            Some((&*expr, tcx.ast_ty_to_prim_ty(ty)))\n+                        },\n+                        _ => None,\n                     },\n-                    _ => None,\n-                },\n+                }\n+            }\n+            _ => {\n+            span_bug!(ti.span,\n+                      \"resolve_trait_associated_const: unexpected vtable type\")\n             }\n         }\n-        _ => {\n-            span_bug!(\n-                ti.span,\n-                \"resolve_trait_associated_const: unexpected vtable type\")\n-        }\n-    }\n+    })\n }\n \n fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstInt, ty: ty::Ty) -> CastResult {"}, {"sha": "6fc10d968d0d0f446ba0f537d70820507e904762", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -138,25 +138,25 @@ fn test_env<F>(source_string: &str,\n     let region_map = region::resolve_crate(&sess, &ast_map);\n     let index = stability::Index::new(&ast_map);\n     TyCtxt::create_and_enter(&sess,\n-                               &arenas,\n-                               resolutions.def_map,\n-                               named_region_map.unwrap(),\n-                               ast_map,\n-                               resolutions.freevars,\n-                               resolutions.maybe_unused_trait_imports,\n-                               region_map,\n-                               lang_items,\n-                               index,\n-                               \"test_crate\",\n-                               |tcx| {\n-                                   let infcx = InferCtxt::new(tcx, &tcx.tables, None,\n-                                                              ProjectionMode::AnyFinal);\n-                                   body(Env { infcx: &infcx });\n-                                   let free_regions = FreeRegionMap::new();\n-                                   infcx.resolve_regions_and_report_errors(&free_regions,\n-                                                                           ast::CRATE_NODE_ID);\n-                                   assert_eq!(tcx.sess.err_count(), expected_err_count);\n-                               });\n+                             &arenas,\n+                             resolutions.def_map,\n+                             named_region_map.unwrap(),\n+                             ast_map,\n+                             resolutions.freevars,\n+                             resolutions.maybe_unused_trait_imports,\n+                             region_map,\n+                             lang_items,\n+                             index,\n+                             \"test_crate\",\n+                             |tcx| {\n+        InferCtxt::enter(tcx, None, None, ProjectionMode::AnyFinal, |infcx| {\n+\n+            body(Env { infcx: &infcx });\n+            let free_regions = FreeRegionMap::new();\n+            infcx.resolve_regions_and_report_errors(&free_regions, ast::CRATE_NODE_ID);\n+            assert_eq!(tcx.sess.err_count(), expected_err_count);\n+        });\n+    });\n }\n \n impl<'a, 'tcx> Env<'a, 'tcx> {"}, {"sha": "3b8f8a18bc719089a90f2a2f3c488f56c5ee27cd", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -869,37 +869,37 @@ impl LateLintPass for UnconditionalRecursion {\n                     // checking, so it's always local\n                     let node_id = tcx.map.as_local_node_id(method.def_id).unwrap();\n \n-                    let param_env = ty::ParameterEnvironment::for_item(tcx, node_id);\n-                    let infcx = InferCtxt::new(tcx, &tcx.tables, Some(param_env),\n-                                               ProjectionMode::AnyFinal);\n-                    let mut selcx = traits::SelectionContext::new(&infcx);\n-                    match selcx.select(&obligation) {\n-                        // The method comes from a `T: Trait` bound.\n-                        // If `T` is `Self`, then this call is inside\n-                        // a default method definition.\n-                        Ok(Some(traits::VtableParam(_))) => {\n-                            let self_ty = callee_substs.self_ty();\n-                            let on_self = self_ty.map_or(false, |t| t.is_self());\n-                            // We can only be recurring in a default\n-                            // method if we're being called literally\n-                            // on the `Self` type.\n-                            on_self && callee_id == method.def_id\n-                        }\n+                    let param_env = Some(ty::ParameterEnvironment::for_item(tcx, node_id));\n+                    InferCtxt::enter(tcx, None, param_env, ProjectionMode::AnyFinal, |infcx| {\n+                        let mut selcx = traits::SelectionContext::new(&infcx);\n+                        match selcx.select(&obligation) {\n+                            // The method comes from a `T: Trait` bound.\n+                            // If `T` is `Self`, then this call is inside\n+                            // a default method definition.\n+                            Ok(Some(traits::VtableParam(_))) => {\n+                                let self_ty = callee_substs.self_ty();\n+                                let on_self = self_ty.map_or(false, |t| t.is_self());\n+                                // We can only be recurring in a default\n+                                // method if we're being called literally\n+                                // on the `Self` type.\n+                                on_self && callee_id == method.def_id\n+                            }\n \n-                        // The `impl` is known, so we check that with a\n-                        // special case:\n-                        Ok(Some(traits::VtableImpl(vtable_impl))) => {\n-                            let container = ty::ImplContainer(vtable_impl.impl_def_id);\n-                            // It matches if it comes from the same impl,\n-                            // and has the same method name.\n-                            container == method.container\n-                                && callee_item.name() == method.name\n-                        }\n+                            // The `impl` is known, so we check that with a\n+                            // special case:\n+                            Ok(Some(traits::VtableImpl(vtable_impl))) => {\n+                                let container = ty::ImplContainer(vtable_impl.impl_def_id);\n+                                // It matches if it comes from the same impl,\n+                                // and has the same method name.\n+                                container == method.container\n+                                    && callee_item.name() == method.name\n+                            }\n \n-                        // There's no way to know if this call is\n-                        // recursive, so we assume it's not.\n-                        _ => return false\n-                    }\n+                            // There's no way to know if this call is\n+                            // recursive, so we assume it's not.\n+                            _ => false\n+                        }\n+                    })\n                 }\n             }\n         }"}, {"sha": "3874224e05412aacc06661de6c21d2f24decfb84", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -75,13 +75,12 @@ impl<'a, 'tcx> BuildMir<'a, 'tcx> {\n         };\n \n         let param_env = ty::ParameterEnvironment::for_item(self.tcx, src.item_id());\n-\n-        let infcx = InferCtxt::new(self.tcx, &self.tcx.tables, Some(param_env),\n-                                   ProjectionMode::AnyFinal);\n-\n-        let (mir, scope_auxiliary) = f(Cx::new(&infcx, constness));\n-\n-        pretty::dump_mir(self.tcx, \"mir_map\", &0, src, &mir, Some(&scope_auxiliary));\n+        let mir = InferCtxt::enter(self.tcx, None, Some(param_env),\n+                                   ProjectionMode::AnyFinal, |infcx| {\n+            let (mir, scope_auxiliary) = f(Cx::new(&infcx, constness));\n+            pretty::dump_mir(self.tcx, \"mir_map\", &0, src, &mir, Some(&scope_auxiliary));\n+            mir\n+        });\n \n         assert!(self.map.map.insert(src.item_id(), mir).is_none())\n     }"}, {"sha": "eb7cc7559e6aa830fd124f0408fe074411512e3b", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -1019,18 +1019,18 @@ impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n             // Statics must be Sync.\n             if mode == Mode::Static {\n                 let ty = mir.return_ty.unwrap();\n-                let infcx = InferCtxt::new(tcx, &tcx.tables, None,\n-                                           ProjectionMode::AnyFinal);\n-                let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n-                let mut fulfillment_cx = traits::FulfillmentContext::new();\n-                fulfillment_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n-                if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n-                    infcx.report_fulfillment_errors(&err);\n-                }\n+                InferCtxt::enter(tcx, None, None, ProjectionMode::AnyFinal, |infcx| {\n+                    let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n+                    let mut fulfillment_cx = traits::FulfillmentContext::new();\n+                    fulfillment_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n+                    if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n+                        infcx.report_fulfillment_errors(&err);\n+                    }\n \n-                if let Err(errors) = fulfillment_cx.select_rfc1592_obligations(&infcx) {\n-                    infcx.report_fulfillment_errors_as_warnings(&errors, id);\n-                }\n+                    if let Err(errors) = fulfillment_cx.select_rfc1592_obligations(&infcx) {\n+                        infcx.report_fulfillment_errors_as_warnings(&errors, id);\n+                    }\n+                });\n             }\n         }\n     }"}, {"sha": "c7f2babfc2d38b49a723aa6b7faa244654e9891f", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -584,19 +584,19 @@ impl<'tcx> MirPass<'tcx> for TypeckMir {\n             return;\n         }\n         let param_env = ty::ParameterEnvironment::for_item(tcx, src.item_id());\n-        let infcx = InferCtxt::new(tcx, &tcx.tables, Some(param_env),\n-                                   ProjectionMode::AnyFinal);\n-        let mut checker = TypeChecker::new(&infcx);\n-        {\n-            let mut verifier = TypeVerifier::new(&mut checker, mir);\n-            verifier.visit_mir(mir);\n-            if verifier.errors_reported {\n-                // don't do further checks to avoid ICEs\n-                return;\n+        InferCtxt::enter(tcx, None, Some(param_env), ProjectionMode::AnyFinal, |infcx| {\n+            let mut checker = TypeChecker::new(&infcx);\n+            {\n+                let mut verifier = TypeVerifier::new(&mut checker, mir);\n+                verifier.visit_mir(mir);\n+                if verifier.errors_reported {\n+                    // don't do further checks to avoid ICEs\n+                    return;\n+                }\n             }\n-        }\n-        checker.typeck_mir(mir);\n-        checker.verify_obligations(mir);\n+            checker.typeck_mir(mir);\n+            checker.verify_obligations(mir);\n+        });\n     }\n }\n "}, {"sha": "f3e13fde04b00a9b0365869413ef440dd1cf6b93", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -88,17 +88,16 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     }\n \n     fn with_euv<'b, F, R>(&'b mut self, item_id: Option<ast::NodeId>, f: F) -> R where\n-        F: for<'c> FnOnce(&mut euv::ExprUseVisitor<'b, 'c, 'tcx, 'tcx>) -> R,\n+        F: for<'c> FnOnce(&mut euv::ExprUseVisitor<'c, 'c, 'tcx, 'tcx>) -> R,\n     {\n         let param_env = match item_id {\n             Some(item_id) => ty::ParameterEnvironment::for_item(self.tcx, item_id),\n             None => self.tcx.empty_parameter_environment()\n         };\n \n-        let infcx = InferCtxt::new(self.tcx, &self.tcx.tables, Some(param_env),\n-                                   ProjectionMode::AnyFinal);\n-\n-        f(&mut euv::ExprUseVisitor::new(self, &infcx))\n+        InferCtxt::enter(self.tcx, None, Some(param_env), ProjectionMode::AnyFinal, |infcx| {\n+            f(&mut euv::ExprUseVisitor::new(self, &infcx))\n+        })\n     }\n \n     fn global_expr(&mut self, mode: Mode, expr: &hir::Expr) -> ConstQualif {"}, {"sha": "441154b7bf08b88ef915114267eec2c91e1a81ce", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -39,16 +39,17 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n                 b: &'v hir::Block,\n                 s: Span,\n                 fn_id: ast::NodeId) {\n-        {\n-            // FIXME (@jroesch) change this to be an inference context\n-            let param_env = ParameterEnvironment::for_item(self.tcx, fn_id);\n-            let infcx = InferCtxt::new(self.tcx, &self.tcx.tables,\n-                                       Some(param_env.clone()),\n-                                       ProjectionMode::AnyFinal);\n-            let mut delegate = RvalueContextDelegate { tcx: self.tcx, param_env: &param_env };\n+        // FIXME (@jroesch) change this to be an inference context\n+        let param_env = ParameterEnvironment::for_item(self.tcx, fn_id);\n+        InferCtxt::enter(self.tcx, None, Some(param_env.clone()),\n+                         ProjectionMode::AnyFinal, |infcx| {\n+            let mut delegate = RvalueContextDelegate {\n+                tcx: self.tcx,\n+                param_env: &param_env\n+            };\n             let mut euv = euv::ExprUseVisitor::new(&mut delegate, &infcx);\n             euv.walk_fn(fd, b);\n-        }\n+        });\n         intravisit::walk_fn(self, fk, fd, b, s)\n     }\n }"}, {"sha": "4b656544bc440ba7bcaef67c8024cd70f57d6a61", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -1466,12 +1466,10 @@ fn is_discr_reassigned(bcx: Block, discr: &hir::Expr, body: &hir::Expr) -> bool\n         field: field,\n         reassigned: false\n     };\n-    {\n-        let infcx = InferCtxt::normalizing(bcx.tcx(), &bcx.tcx().tables,\n-                                           ProjectionMode::Any);\n+    InferCtxt::enter_normalizing(bcx.tcx(), ProjectionMode::Any, |infcx| {\n         let mut visitor = euv::ExprUseVisitor::new(&mut rc, &infcx);\n         visitor.walk_expr(body);\n-    }\n+    });\n     rc.reassigned\n }\n "}, {"sha": "25b76e1113c878f8e5a473c73952e034491df507", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -12,8 +12,6 @@ use arena::TypedArena;\n use back::symbol_names;\n use llvm::{ValueRef, get_param, get_params};\n use rustc::hir::def_id::DefId;\n-use rustc::infer::InferCtxt;\n-use rustc::traits::ProjectionMode;\n use abi::{Abi, FnType};\n use adt;\n use attributes;\n@@ -155,8 +153,7 @@ fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let symbol = symbol_names::exported_name(ccx, &instance);\n \n     // Compute the rust-call form of the closure call method.\n-    let infcx = InferCtxt::normalizing(tcx, &tcx.tables, ProjectionMode::Any);\n-    let sig = &infcx.closure_type(closure_id, &substs).sig;\n+    let sig = &ty::Tables::closure_type(&tcx.tables, tcx, closure_id, &substs).sig;\n     let sig = tcx.erase_late_bound_regions(sig);\n     let sig = tcx.normalize_associated_type(&sig);\n     let closure_type = tcx.mk_closure_from_closure_substs(closure_id, Box::new(substs));\n@@ -220,11 +217,11 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     // this function (`trans_closure`) is invoked at the point\n     // of the closure expression.\n \n-    let infcx = InferCtxt::normalizing(ccx.tcx(), &ccx.tcx().tables, ProjectionMode::Any);\n-    let function_type = infcx.closure_type(closure_def_id, closure_substs);\n-\n-    let sig = tcx.erase_late_bound_regions(&function_type.sig);\n-    let sig = ccx.tcx().normalize_associated_type(&sig);\n+    let sig = &ty::Tables::closure_type(&tcx.tables, tcx,\n+                                        closure_def_id,\n+                                        closure_substs).sig;\n+    let sig = tcx.erase_late_bound_regions(sig);\n+    let sig = tcx.normalize_associated_type(&sig);\n \n     let closure_type = tcx.mk_closure_from_closure_substs(closure_def_id,\n         Box::new(closure_substs.clone()));\n@@ -344,15 +341,15 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n            closure_def_id, substs, Value(llreffn));\n \n     let tcx = ccx.tcx();\n-    let infcx = InferCtxt::normalizing(ccx.tcx(), &ccx.tcx().tables, ProjectionMode::Any);\n \n     // Find a version of the closure type. Substitute static for the\n     // region since it doesn't really matter.\n     let closure_ty = tcx.mk_closure_from_closure_substs(closure_def_id, Box::new(substs.clone()));\n     let ref_closure_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic), closure_ty);\n \n     // Make a version with the type of by-ref closure.\n-    let ty::ClosureTy { unsafety, abi, mut sig } = infcx.closure_type(closure_def_id, &substs);\n+    let ty::ClosureTy { unsafety, abi, mut sig } =\n+        ty::Tables::closure_type(&tcx.tables, tcx, closure_def_id, &substs);\n     sig.0.inputs.insert(0, ref_closure_ty); // sig has no self type as of yet\n     let llref_fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {\n         unsafety: unsafety,\n@@ -369,7 +366,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     sig.0.inputs[0] = closure_ty;\n \n     let sig = tcx.erase_late_bound_regions(&sig);\n-    let sig = ccx.tcx().normalize_associated_type(&sig);\n+    let sig = tcx.normalize_associated_type(&sig);\n     let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n \n     let llonce_fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {"}, {"sha": "d312d07d973dbd0ab05eb9b3160583a9f42b5260", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 56, "deletions": 59, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -1066,53 +1066,49 @@ pub fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n         // Do the initial selection for the obligation. This yields the\n         // shallow result we are looking for -- that is, what specific impl.\n-        let infcx = InferCtxt::normalizing(tcx, &tcx.tables, ProjectionMode::Any);\n-        let mut selcx = SelectionContext::new(&infcx);\n+        let vtable = InferCtxt::enter_normalizing(tcx, ProjectionMode::Any, |infcx| {\n+            let mut selcx = SelectionContext::new(&infcx);\n \n-        let obligation_cause = traits::ObligationCause::misc(span,\n+            let obligation_cause = traits::ObligationCause::misc(span,\n                                                              ast::DUMMY_NODE_ID);\n-        let obligation = traits::Obligation::new(obligation_cause,\n-                                                 trait_ref.to_poly_trait_predicate());\n-\n-        let selection = match selcx.select(&obligation) {\n-            Ok(Some(selection)) => selection,\n-            Ok(None) => {\n-                // Ambiguity can happen when monomorphizing during trans\n-                // expands to some humongo type that never occurred\n-                // statically -- this humongo type can then overflow,\n-                // leading to an ambiguous result. So report this as an\n-                // overflow bug, since I believe this is the only case\n-                // where ambiguity can result.\n-                debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n-                        presuming due to overflow\",\n-                       trait_ref);\n-                tcx.sess.span_fatal(\n-                    span,\n-                    \"reached the recursion limit during monomorphization \\\n-                     (selection ambiguity)\");\n-            }\n-            Err(e) => {\n-                span_bug!(\n-                    span,\n-                    \"Encountered error `{:?}` selecting `{:?}` during trans\",\n-                    e,\n-                    trait_ref)\n-            }\n-        };\n-\n-        // Currently, we use a fulfillment context to completely resolve\n-        // all nested obligations. This is because they can inform the\n-        // inference of the impl's type parameters.\n-        let mut fulfill_cx = traits::FulfillmentContext::new();\n-        let vtable = selection.map(|predicate| {\n-            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-        });\n-        let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);\n-\n-        info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n-\n-        vtable\n-    })\n+            let obligation = traits::Obligation::new(obligation_cause,\n+                                                     trait_ref.to_poly_trait_predicate());\n+\n+            let selection = match selcx.select(&obligation) {\n+                Ok(Some(selection)) => selection,\n+                Ok(None) => {\n+                    // Ambiguity can happen when monomorphizing during trans\n+                    // expands to some humongo type that never occurred\n+                    // statically -- this humongo type can then overflow,\n+                    // leading to an ambiguous result. So report this as an\n+                    // overflow bug, since I believe this is the only case\n+                    // where ambiguity can result.\n+                    debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n+                            presuming due to overflow\",\n+                           trait_ref);\n+                    tcx.sess.span_fatal(span,\n+                        \"reached the recursion limit during monomorphization \\\n+                         (selection ambiguity)\");\n+                }\n+                Err(e) => {\n+                    span_bug!(span, \"Encountered error `{:?}` selecting `{:?}` during trans\",\n+                              e, trait_ref)\n+                }\n+            };\n+\n+            // Currently, we use a fulfillment context to completely resolve\n+            // all nested obligations. This is because they can inform the\n+            // inference of the impl's type parameters.\n+            let mut fulfill_cx = traits::FulfillmentContext::new();\n+            let vtable = selection.map(|predicate| {\n+                fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+            });\n+            let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);\n+\n+            info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n+            vtable\n+        })\n+    });\n }\n \n /// Normalizes the predicates and checks whether they hold.  If this\n@@ -1126,21 +1122,22 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"normalize_and_test_predicates(predicates={:?})\",\n            predicates);\n \n-    let infcx = InferCtxt::normalizing(tcx, &tcx.tables, ProjectionMode::Any);\n-    let mut selcx = SelectionContext::new(&infcx);\n-    let mut fulfill_cx = traits::FulfillmentContext::new();\n-    let cause = traits::ObligationCause::dummy();\n-    let traits::Normalized { value: predicates, obligations } =\n-        traits::normalize(&mut selcx, cause.clone(), &predicates);\n-    for obligation in obligations {\n-        fulfill_cx.register_predicate_obligation(&infcx, obligation);\n-    }\n-    for predicate in predicates {\n-        let obligation = traits::Obligation::new(cause.clone(), predicate);\n-        fulfill_cx.register_predicate_obligation(&infcx, obligation);\n-    }\n+    InferCtxt::enter_normalizing(tcx, ProjectionMode::Any, |infcx| {\n+        let mut selcx = SelectionContext::new(&infcx);\n+        let mut fulfill_cx = traits::FulfillmentContext::new();\n+        let cause = traits::ObligationCause::dummy();\n+        let traits::Normalized { value: predicates, obligations } =\n+            traits::normalize(&mut selcx, cause.clone(), &predicates);\n+        for obligation in obligations {\n+            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+        }\n+        for predicate in predicates {\n+            let obligation = traits::Obligation::new(cause.clone(), predicate);\n+            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+        }\n \n-    infcx.drain_fulfillment_cx(&mut fulfill_cx, &()).is_ok()\n+        infcx.drain_fulfillment_cx(&mut fulfill_cx, &()).is_ok()\n+    })\n }\n \n pub fn langcall(bcx: Block,"}, {"sha": "1c559749a8705e5d71ad0f94ed997bacafa5c814", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -314,13 +314,15 @@ pub fn get_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n     let trait_def = tcx.lookup_trait_def(trait_def_id);\n-    let infcx = InferCtxt::normalizing(tcx, &tcx.tables, ProjectionMode::Any);\n \n     match trait_def.ancestors(impl_def_id).fn_defs(tcx, name).next() {\n         Some(node_item) => {\n+            let substs = InferCtxt::enter_normalizing(tcx, ProjectionMode::Any, |infcx| {\n+                traits::translate_substs(&infcx, impl_def_id, substs, node_item.node)\n+            });\n             ImplMethod {\n                 method: node_item.item,\n-                substs: traits::translate_substs(&infcx, impl_def_id, substs, node_item.node),\n+                substs: substs,\n                 is_provided: node_item.node.is_from_trait(),\n             }\n         }"}, {"sha": "9db7503b3abda21bb28e5250068de7beed0e14ed", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -124,8 +124,10 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n     cx.llsizingtypes().borrow_mut().insert(t, llsizingty);\n \n     // FIXME(eddyb) Temporary sanity check for ty::layout.\n-    let infcx = InferCtxt::normalizing(cx.tcx(), &cx.tcx().tables, ProjectionMode::Any);\n-    match t.layout(&infcx) {\n+    let layout = InferCtxt::enter_normalizing(cx.tcx(), ProjectionMode::Any, |infcx| {\n+        t.layout(&infcx)\n+    });\n+    match layout {\n         Ok(layout) => {\n             if !type_is_sized(cx.tcx(), t) {\n                 if !layout.is_unsized() {"}, {"sha": "1a9db2e54498de7fda996aad0c5fef5eacf493c7", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 219, "deletions": 219, "changes": 438, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -44,8 +44,6 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n            impl_trait_ref);\n \n     let tcx = ccx.tcx;\n-    let mut infcx = InferCtxt::new(tcx, &tcx.tables, None, ProjectionMode::AnyFinal);\n-    let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n     let trait_to_impl_substs = &impl_trait_ref.substs;\n \n@@ -206,165 +204,169 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let impl_bounds =\n         impl_m.predicates.instantiate(tcx, impl_to_skol_substs);\n \n-    let (impl_bounds, _) =\n-        infcx.replace_late_bound_regions_with_fresh_var(\n-            impl_m_span,\n-            infer::HigherRankedType,\n-            &ty::Binder(impl_bounds));\n-    debug!(\"compare_impl_method: impl_bounds={:?}\",\n-           impl_bounds);\n-\n-    // Normalize the associated types in the trait_bounds.\n-    let trait_bounds = trait_m.predicates.instantiate(tcx, &trait_to_skol_substs);\n-\n-    // Obtain the predicate split predicate sets for each.\n-    let trait_pred = trait_bounds.predicates.split();\n-    let impl_pred = impl_bounds.predicates.split();\n-\n-    // This is the only tricky bit of the new way we check implementation methods\n-    // We need to build a set of predicates where only the FnSpace bounds\n-    // are from the trait and we assume all other bounds from the implementation\n-    // to be previously satisfied.\n-    //\n-    // We then register the obligations from the impl_m and check to see\n-    // if all constraints hold.\n-    let hybrid_preds = VecPerParamSpace::new(\n-        impl_pred.types,\n-        impl_pred.selfs,\n-        trait_pred.fns\n-    );\n-\n-    // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n-    // The key step here is to update the caller_bounds's predicates to be\n-    // the new hybrid bounds we computed.\n-    let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_body_id);\n-    let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.into_vec());\n-    let trait_param_env = traits::normalize_param_env_or_error(tcx,\n-                                                               trait_param_env,\n-                                                               normalize_cause.clone());\n-    // FIXME(@jroesch) this seems ugly, but is a temporary change\n-    infcx.parameter_environment = trait_param_env;\n-\n-    debug!(\"compare_impl_method: trait_bounds={:?}\",\n-        infcx.parameter_environment.caller_bounds);\n-\n-    let mut selcx = traits::SelectionContext::new(&infcx);\n-\n-    for predicate in impl_pred.fns {\n-        let traits::Normalized { value: predicate, .. } =\n-            traits::normalize(&mut selcx, normalize_cause.clone(), &predicate);\n-\n-        let cause = traits::ObligationCause {\n-            span: impl_m_span,\n-            body_id: impl_m_body_id,\n-            code: traits::ObligationCauseCode::CompareImplMethodObligation\n-        };\n-\n-        fulfillment_cx.register_predicate_obligation(\n-            &infcx,\n-            traits::Obligation::new(cause, predicate));\n-    }\n-\n-    // We now need to check that the signature of the impl method is\n-    // compatible with that of the trait method. We do this by\n-    // checking that `impl_fty <: trait_fty`.\n-    //\n-    // FIXME. Unfortunately, this doesn't quite work right now because\n-    // associated type normalization is not integrated into subtype\n-    // checks. For the comparison to be valid, we need to\n-    // normalize the associated types in the impl/trait methods\n-    // first. However, because function types bind regions, just\n-    // calling `normalize_associated_types_in` would have no effect on\n-    // any associated types appearing in the fn arguments or return\n-    // type.\n-\n-    // Compute skolemized form of impl and trait method tys.\n-    let impl_fty = tcx.mk_fn_ptr(impl_m.fty.clone());\n-    let impl_fty = impl_fty.subst(tcx, impl_to_skol_substs);\n-    let trait_fty = tcx.mk_fn_ptr(trait_m.fty.clone());\n-    let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n-\n-    let err = infcx.commit_if_ok(|snapshot| {\n-        let origin = TypeOrigin::MethodCompatCheck(impl_m_span);\n-\n-        let (impl_sig, _) =\n-            infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n-                                                            infer::HigherRankedType,\n-                                                            &impl_m.fty.sig);\n-        let impl_sig =\n-            impl_sig.subst(tcx, impl_to_skol_substs);\n-        let impl_sig =\n-            assoc::normalize_associated_types_in(&infcx,\n-                                                 &mut fulfillment_cx,\n-                                                 impl_m_span,\n-                                                 impl_m_body_id,\n-                                                 &impl_sig);\n-        let impl_fty = tcx.mk_fn_ptr(ty::BareFnTy {\n-            unsafety: impl_m.fty.unsafety,\n-            abi: impl_m.fty.abi,\n-            sig: ty::Binder(impl_sig)\n-        });\n-        debug!(\"compare_impl_method: impl_fty={:?}\",\n-               impl_fty);\n-\n-        let (trait_sig, skol_map) =\n-            infcx.skolemize_late_bound_regions(&trait_m.fty.sig, snapshot);\n-        let trait_sig =\n-            trait_sig.subst(tcx, &trait_to_skol_substs);\n-        let trait_sig =\n-            assoc::normalize_associated_types_in(&infcx,\n-                                                 &mut fulfillment_cx,\n-                                                 impl_m_span,\n-                                                 impl_m_body_id,\n-                                                 &trait_sig);\n-        let trait_fty = tcx.mk_fn_ptr(ty::BareFnTy {\n-            unsafety: trait_m.fty.unsafety,\n-            abi: trait_m.fty.abi,\n-            sig: ty::Binder(trait_sig)\n-        });\n+    InferCtxt::enter(tcx, None, None, ProjectionMode::AnyFinal, |mut infcx| {\n+        let mut fulfillment_cx = traits::FulfillmentContext::new();\n+        let (impl_bounds, _) =\n+            infcx.replace_late_bound_regions_with_fresh_var(\n+                impl_m_span,\n+                infer::HigherRankedType,\n+                &ty::Binder(impl_bounds));\n+        debug!(\"compare_impl_method: impl_bounds={:?}\",\n+               impl_bounds);\n+\n+        // Normalize the associated types in the trait_bounds.\n+        let trait_bounds = trait_m.predicates.instantiate(tcx, &trait_to_skol_substs);\n+\n+        // Obtain the predicate split predicate sets for each.\n+        let trait_pred = trait_bounds.predicates.split();\n+        let impl_pred = impl_bounds.predicates.split();\n+\n+        // This is the only tricky bit of the new way we check implementation methods\n+        // We need to build a set of predicates where only the FnSpace bounds\n+        // are from the trait and we assume all other bounds from the implementation\n+        // to be previously satisfied.\n+        //\n+        // We then register the obligations from the impl_m and check to see\n+        // if all constraints hold.\n+        let hybrid_preds = VecPerParamSpace::new(\n+            impl_pred.types,\n+            impl_pred.selfs,\n+            trait_pred.fns\n+        );\n+\n+        // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n+        // The key step here is to update the caller_bounds's predicates to be\n+        // the new hybrid bounds we computed.\n+        let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_body_id);\n+        let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.into_vec());\n+        let trait_param_env = traits::normalize_param_env_or_error(tcx,\n+                                                                   trait_param_env,\n+                                                                   normalize_cause.clone());\n+        // FIXME(@jroesch) this seems ugly, but is a temporary change\n+        infcx.parameter_environment = trait_param_env;\n+\n+        debug!(\"compare_impl_method: trait_bounds={:?}\",\n+            infcx.parameter_environment.caller_bounds);\n+\n+        let mut selcx = traits::SelectionContext::new(&infcx);\n+\n+        for predicate in impl_pred.fns {\n+            let traits::Normalized { value: predicate, .. } =\n+                traits::normalize(&mut selcx, normalize_cause.clone(), &predicate);\n+\n+            let cause = traits::ObligationCause {\n+                span: impl_m_span,\n+                body_id: impl_m_body_id,\n+                code: traits::ObligationCauseCode::CompareImplMethodObligation\n+            };\n+\n+            fulfillment_cx.register_predicate_obligation(\n+                &infcx,\n+                traits::Obligation::new(cause, predicate));\n+        }\n \n-        debug!(\"compare_impl_method: trait_fty={:?}\",\n-               trait_fty);\n+        // We now need to check that the signature of the impl method is\n+        // compatible with that of the trait method. We do this by\n+        // checking that `impl_fty <: trait_fty`.\n+        //\n+        // FIXME. Unfortunately, this doesn't quite work right now because\n+        // associated type normalization is not integrated into subtype\n+        // checks. For the comparison to be valid, we need to\n+        // normalize the associated types in the impl/trait methods\n+        // first. However, because function types bind regions, just\n+        // calling `normalize_associated_types_in` would have no effect on\n+        // any associated types appearing in the fn arguments or return\n+        // type.\n+\n+        // Compute skolemized form of impl and trait method tys.\n+        let impl_fty = tcx.mk_fn_ptr(impl_m.fty.clone());\n+        let impl_fty = impl_fty.subst(tcx, impl_to_skol_substs);\n+        let trait_fty = tcx.mk_fn_ptr(trait_m.fty.clone());\n+        let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n+\n+        let err = infcx.commit_if_ok(|snapshot| {\n+            let origin = TypeOrigin::MethodCompatCheck(impl_m_span);\n+\n+            let (impl_sig, _) =\n+                infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n+                                                                infer::HigherRankedType,\n+                                                                &impl_m.fty.sig);\n+            let impl_sig =\n+                impl_sig.subst(tcx, impl_to_skol_substs);\n+            let impl_sig =\n+                assoc::normalize_associated_types_in(&infcx,\n+                                                     &mut fulfillment_cx,\n+                                                     impl_m_span,\n+                                                     impl_m_body_id,\n+                                                     &impl_sig);\n+            let impl_fty = tcx.mk_fn_ptr(ty::BareFnTy {\n+                unsafety: impl_m.fty.unsafety,\n+                abi: impl_m.fty.abi,\n+                sig: ty::Binder(impl_sig)\n+            });\n+            debug!(\"compare_impl_method: impl_fty={:?}\",\n+                   impl_fty);\n+\n+            let (trait_sig, skol_map) =\n+                infcx.skolemize_late_bound_regions(&trait_m.fty.sig, snapshot);\n+            let trait_sig =\n+                trait_sig.subst(tcx, &trait_to_skol_substs);\n+            let trait_sig =\n+                assoc::normalize_associated_types_in(&infcx,\n+                                                     &mut fulfillment_cx,\n+                                                     impl_m_span,\n+                                                     impl_m_body_id,\n+                                                     &trait_sig);\n+            let trait_fty = tcx.mk_fn_ptr(ty::BareFnTy {\n+                unsafety: trait_m.fty.unsafety,\n+                abi: trait_m.fty.abi,\n+                sig: ty::Binder(trait_sig)\n+            });\n+\n+            debug!(\"compare_impl_method: trait_fty={:?}\",\n+                   trait_fty);\n \n-        infcx.sub_types(false, origin, impl_fty, trait_fty)?;\n+            infcx.sub_types(false, origin, impl_fty, trait_fty)?;\n \n-        infcx.leak_check(false, &skol_map, snapshot)\n-    });\n+            infcx.leak_check(false, &skol_map, snapshot)\n+        });\n \n-    match err {\n-        Ok(()) => { }\n-        Err(terr) => {\n-            debug!(\"checking trait method for compatibility: impl ty {:?}, trait ty {:?}\",\n-                   impl_fty,\n-                   trait_fty);\n-            span_err!(tcx.sess, impl_m_span, E0053,\n-                      \"method `{}` has an incompatible type for trait: {}\",\n-                      trait_m.name,\n-                      terr);\n-            return;\n+        match err {\n+            Ok(()) => { }\n+            Err(terr) => {\n+                debug!(\"checking trait method for compatibility: impl ty {:?}, trait ty {:?}\",\n+                       impl_fty,\n+                       trait_fty);\n+                span_err!(tcx.sess, impl_m_span, E0053,\n+                          \"method `{}` has an incompatible type for trait: {}\",\n+                          trait_m.name,\n+                          terr);\n+                return;\n+            }\n         }\n-    }\n-\n-    // Check that all obligations are satisfied by the implementation's\n-    // version.\n-    match fulfillment_cx.select_all_or_error(&infcx) {\n-        Err(ref errors) => { infcx.report_fulfillment_errors(errors) }\n-        Ok(_) => {}\n-    }\n \n-    // Finally, resolve all regions. This catches wily misuses of\n-    // lifetime parameters. We have to build up a plausible lifetime\n-    // environment based on what we find in the trait. We could also\n-    // include the obligations derived from the method argument types,\n-    // but I don't think it's necessary -- after all, those are still\n-    // in effect when type-checking the body, and all the\n-    // where-clauses in the header etc should be implied by the trait\n-    // anyway, so it shouldn't be needed there either. Anyway, we can\n-    // always add more relations later (it's backwards compat).\n-    let mut free_regions = FreeRegionMap::new();\n-    free_regions.relate_free_regions_from_predicates(&infcx.parameter_environment.caller_bounds);\n+        // Check that all obligations are satisfied by the implementation's\n+        // version.\n+        match fulfillment_cx.select_all_or_error(&infcx) {\n+            Err(ref errors) => { infcx.report_fulfillment_errors(errors) }\n+            Ok(_) => {}\n+        }\n \n-    infcx.resolve_regions_and_report_errors(&free_regions, impl_m_body_id);\n+        // Finally, resolve all regions. This catches wily misuses of\n+        // lifetime parameters. We have to build up a plausible lifetime\n+        // environment based on what we find in the trait. We could also\n+        // include the obligations derived from the method argument types,\n+        // but I don't think it's necessary -- after all, those are still\n+        // in effect when type-checking the body, and all the\n+        // where-clauses in the header etc should be implied by the trait\n+        // anyway, so it shouldn't be needed there either. Anyway, we can\n+        // always add more relations later (it's backwards compat).\n+        let mut free_regions = FreeRegionMap::new();\n+        free_regions.relate_free_regions_from_predicates(\n+            &infcx.parameter_environment.caller_bounds);\n+\n+        infcx.resolve_regions_and_report_errors(&free_regions, impl_m_body_id);\n+    });\n \n     fn check_region_bounds_on_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                     span: Span,\n@@ -419,70 +421,69 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n            impl_trait_ref);\n \n     let tcx = ccx.tcx;\n-    let infcx = InferCtxt::new(tcx, &tcx.tables, None, ProjectionMode::AnyFinal);\n-    let mut fulfillment_cx = traits::FulfillmentContext::new();\n-\n-    // The below is for the most part highly similar to the procedure\n-    // for methods above. It is simpler in many respects, especially\n-    // because we shouldn't really have to deal with lifetimes or\n-    // predicates. In fact some of this should probably be put into\n-    // shared functions because of DRY violations...\n-    let trait_to_impl_substs = &impl_trait_ref.substs;\n-\n-    // Create a parameter environment that represents the implementation's\n-    // method.\n-    let impl_c_node_id = tcx.map.as_local_node_id(impl_c.def_id).unwrap();\n-    let impl_param_env = ty::ParameterEnvironment::for_item(tcx, impl_c_node_id);\n-\n-    // Create mapping from impl to skolemized.\n-    let impl_to_skol_substs = &impl_param_env.free_substs;\n-\n-    // Create mapping from trait to skolemized.\n-    let trait_to_skol_substs =\n-        trait_to_impl_substs\n-        .subst(tcx, impl_to_skol_substs)\n-        .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n-                     impl_to_skol_substs.regions.get_slice(subst::FnSpace).to_vec());\n-    debug!(\"compare_const_impl: trait_to_skol_substs={:?}\",\n-           trait_to_skol_substs);\n-\n-    // Compute skolemized form of impl and trait const tys.\n-    let impl_ty = impl_c.ty.subst(tcx, impl_to_skol_substs);\n-    let trait_ty = trait_c.ty.subst(tcx, &trait_to_skol_substs);\n-\n-    let err = infcx.commit_if_ok(|_| {\n-        let origin = TypeOrigin::Misc(impl_c_span);\n-\n-        // There is no \"body\" here, so just pass dummy id.\n-        let impl_ty =\n-            assoc::normalize_associated_types_in(&infcx,\n-                                                 &mut fulfillment_cx,\n-                                                 impl_c_span,\n-                                                 0,\n-                                                 &impl_ty);\n-\n-        debug!(\"compare_const_impl: impl_ty={:?}\",\n-               impl_ty);\n-\n-        let trait_ty =\n-            assoc::normalize_associated_types_in(&infcx,\n-                                                 &mut fulfillment_cx,\n-                                                 impl_c_span,\n-                                                 0,\n-                                                 &trait_ty);\n-\n-        debug!(\"compare_const_impl: trait_ty={:?}\",\n-               trait_ty);\n-\n-        infcx.sub_types(false, origin, impl_ty, trait_ty)\n-    });\n+    InferCtxt::enter(tcx, None, None, ProjectionMode::AnyFinal, |infcx| {\n+        let mut fulfillment_cx = traits::FulfillmentContext::new();\n+\n+        // The below is for the most part highly similar to the procedure\n+        // for methods above. It is simpler in many respects, especially\n+        // because we shouldn't really have to deal with lifetimes or\n+        // predicates. In fact some of this should probably be put into\n+        // shared functions because of DRY violations...\n+        let trait_to_impl_substs = &impl_trait_ref.substs;\n+\n+        // Create a parameter environment that represents the implementation's\n+        // method.\n+        let impl_c_node_id = tcx.map.as_local_node_id(impl_c.def_id).unwrap();\n+        let impl_param_env = ty::ParameterEnvironment::for_item(tcx, impl_c_node_id);\n+\n+        // Create mapping from impl to skolemized.\n+        let impl_to_skol_substs = &impl_param_env.free_substs;\n+\n+        // Create mapping from trait to skolemized.\n+        let trait_to_skol_substs =\n+            trait_to_impl_substs\n+            .subst(tcx, impl_to_skol_substs)\n+            .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n+                         impl_to_skol_substs.regions.get_slice(subst::FnSpace).to_vec());\n+        debug!(\"compare_const_impl: trait_to_skol_substs={:?}\",\n+            trait_to_skol_substs);\n+\n+        // Compute skolemized form of impl and trait const tys.\n+        let impl_ty = impl_c.ty.subst(tcx, impl_to_skol_substs);\n+        let trait_ty = trait_c.ty.subst(tcx, &trait_to_skol_substs);\n+\n+        let err = infcx.commit_if_ok(|_| {\n+            let origin = TypeOrigin::Misc(impl_c_span);\n+\n+            // There is no \"body\" here, so just pass dummy id.\n+            let impl_ty =\n+                assoc::normalize_associated_types_in(&infcx,\n+                                                     &mut fulfillment_cx,\n+                                                     impl_c_span,\n+                                                     0,\n+                                                     &impl_ty);\n+\n+            debug!(\"compare_const_impl: impl_ty={:?}\",\n+                impl_ty);\n+\n+            let trait_ty =\n+                assoc::normalize_associated_types_in(&infcx,\n+                                                     &mut fulfillment_cx,\n+                                                     impl_c_span,\n+                                                     0,\n+                                                     &trait_ty);\n+\n+            debug!(\"compare_const_impl: trait_ty={:?}\",\n+                trait_ty);\n+\n+            infcx.sub_types(false, origin, impl_ty, trait_ty)\n+                 .map(|InferOk { obligations, .. }| {\n+                // FIXME(#32730) propagate obligations\n+                assert!(obligations.is_empty())\n+            })\n+        });\n \n-    match err {\n-        Ok(InferOk { obligations, .. }) => {\n-            // FIXME(#32730) propagate obligations\n-            assert!(obligations.is_empty())\n-        }\n-        Err(terr) => {\n+        if let Err(terr) = err {\n             debug!(\"checking associated const for compatibility: impl ty {:?}, trait ty {:?}\",\n                    impl_ty,\n                    trait_ty);\n@@ -491,7 +492,6 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                       trait: {}\",\n                       trait_c.name,\n                       terr);\n-            return;\n         }\n-    }\n+    });\n }"}, {"sha": "ed9925ea22b96cf4dcd076b2dd5da84c0ddd0ce0", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -84,43 +84,43 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     // check that the impl type can be made to match the trait type.\n \n     let impl_param_env = ty::ParameterEnvironment::for_item(tcx, self_type_node_id);\n-    let infcx = InferCtxt::new(tcx, &tcx.tables, Some(impl_param_env),\n-                               ProjectionMode::AnyFinal);\n-    let mut fulfillment_cx = traits::FulfillmentContext::new();\n+    InferCtxt::enter(tcx, None, Some(impl_param_env), ProjectionMode::AnyFinal, |infcx| {\n+        let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n-    let named_type = tcx.lookup_item_type(self_type_did).ty;\n-    let named_type = named_type.subst(tcx, &infcx.parameter_environment.free_substs);\n+        let named_type = tcx.lookup_item_type(self_type_did).ty;\n+        let named_type = named_type.subst(tcx, &infcx.parameter_environment.free_substs);\n \n-    let drop_impl_span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n-    let fresh_impl_substs =\n-        infcx.fresh_substs_for_generics(drop_impl_span, drop_impl_generics);\n-    let fresh_impl_self_ty = drop_impl_ty.subst(tcx, &fresh_impl_substs);\n-\n-    if let Err(_) = infcx.eq_types(true, infer::TypeOrigin::Misc(drop_impl_span),\n-                                   named_type, fresh_impl_self_ty) {\n-        let item_span = tcx.map.span(self_type_node_id);\n-        struct_span_err!(tcx.sess, drop_impl_span, E0366,\n-                         \"Implementations of Drop cannot be specialized\")\n-            .span_note(item_span,\n-                       \"Use same sequence of generic type and region \\\n-                        parameters that is on the struct/enum definition\")\n-            .emit();\n-        return Err(());\n-    }\n+        let drop_impl_span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n+        let fresh_impl_substs =\n+            infcx.fresh_substs_for_generics(drop_impl_span, drop_impl_generics);\n+        let fresh_impl_self_ty = drop_impl_ty.subst(tcx, &fresh_impl_substs);\n \n-    if let Err(ref errors) = fulfillment_cx.select_all_or_error(&infcx) {\n-        // this could be reached when we get lazy normalization\n-        infcx.report_fulfillment_errors(errors);\n-        return Err(());\n-    }\n+        if let Err(_) = infcx.eq_types(true, infer::TypeOrigin::Misc(drop_impl_span),\n+                                       named_type, fresh_impl_self_ty) {\n+            let item_span = tcx.map.span(self_type_node_id);\n+            struct_span_err!(tcx.sess, drop_impl_span, E0366,\n+                             \"Implementations of Drop cannot be specialized\")\n+                .span_note(item_span,\n+                           \"Use same sequence of generic type and region \\\n+                            parameters that is on the struct/enum definition\")\n+                .emit();\n+            return Err(());\n+        }\n+\n+        if let Err(ref errors) = fulfillment_cx.select_all_or_error(&infcx) {\n+            // this could be reached when we get lazy normalization\n+            infcx.report_fulfillment_errors(errors);\n+            return Err(());\n+        }\n \n     if let Err(ref errors) = fulfillment_cx.select_rfc1592_obligations(&infcx) {\n         infcx.report_fulfillment_errors_as_warnings(errors, drop_impl_node_id);\n     }\n \n-    let free_regions = FreeRegionMap::new();\n-    infcx.resolve_regions_and_report_errors(&free_regions, drop_impl_node_id);\n-    Ok(())\n+        let free_regions = FreeRegionMap::new();\n+        infcx.resolve_regions_and_report_errors(&free_regions, drop_impl_node_id);\n+        Ok(())\n+    })\n }\n \n /// Confirms that every predicate imposed by dtor_predicates is"}, {"sha": "e9af54882f443542b30f75bc14f1447324ea0cab", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 73, "deletions": 94, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -373,22 +373,25 @@ impl<'a, 'gcx, 'tcx> Deref for FnCtxt<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'tcx> Inherited<'a, 'tcx, 'tcx> {\n-    fn new(ccx: &'a CrateCtxt<'a, 'tcx>,\n-           tables: &'a RefCell<ty::Tables<'tcx>>,\n-           param_env: ty::ParameterEnvironment<'tcx>)\n-           -> Inherited<'a, 'tcx, 'tcx> {\n-\n-        Inherited {\n-            ccx: ccx,\n-            infcx: InferCtxt::new(ccx.tcx,\n-                                  tables,\n-                                  Some(param_env),\n-                                  ProjectionMode::AnyFinal),\n-            fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n-            locals: RefCell::new(NodeMap()),\n-            deferred_call_resolutions: RefCell::new(DefIdMap()),\n-            deferred_cast_checks: RefCell::new(Vec::new()),\n-        }\n+    fn enter<F, R>(ccx: &'a CrateCtxt<'a, 'tcx>,\n+                   param_env: ty::ParameterEnvironment<'tcx>,\n+                   f: F) -> R\n+        where F: for<'b> FnOnce(Inherited<'b, 'tcx, 'tcx>) -> R\n+    {\n+        InferCtxt::enter(ccx.tcx,\n+                         Some(ty::Tables::empty()),\n+                         Some(param_env),\n+                         ProjectionMode::AnyFinal,\n+                         |infcx| {\n+            f(Inherited {\n+                ccx: ccx,\n+                infcx: infcx,\n+                fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n+                locals: RefCell::new(NodeMap()),\n+                deferred_call_resolutions: RefCell::new(DefIdMap()),\n+                deferred_cast_checks: RefCell::new(Vec::new()),\n+            })\n+        })\n     }\n \n     fn normalize_associated_types_in<T>(&self,\n@@ -407,15 +410,6 @@ impl<'a, 'tcx> Inherited<'a, 'tcx, 'tcx> {\n \n }\n \n-fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n-                                     tables: &'a RefCell<ty::Tables<'tcx>>)\n-                                    -> Inherited<'a, 'tcx, 'tcx> {\n-    // It's kind of a kludge to manufacture a fake function context\n-    // and statement context, but we might as well do write the code only once\n-    let param_env = ccx.tcx.empty_parameter_environment();\n-    Inherited::new(ccx, &tables, param_env)\n-}\n-\n struct CheckItemTypesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n struct CheckItemBodiesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n \n@@ -492,36 +486,33 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            raw_fty: Ty<'tcx>,\n                            param_env: ty::ParameterEnvironment<'tcx>)\n {\n-    match raw_fty.sty {\n-        ty::TyFnDef(_, _, ref fn_ty) => {\n-            let tables = RefCell::new(ty::Tables::empty());\n-            let inh = Inherited::new(ccx, &tables, param_env);\n-\n-            // Compute the fty from point of view of inside fn.\n-            let fn_scope = ccx.tcx.region_maps.call_site_extent(fn_id, body.id);\n-            let fn_sig =\n-                fn_ty.sig.subst(ccx.tcx, &inh.parameter_environment.free_substs);\n-            let fn_sig =\n-                ccx.tcx.liberate_late_bound_regions(fn_scope, &fn_sig);\n-            let fn_sig =\n-                inh.normalize_associated_types_in(body.span,\n-                                                  body.id,\n-                                                  &fn_sig);\n-\n-            let fcx = check_fn(ccx, fn_ty.unsafety, fn_id, &fn_sig,\n-                               decl, fn_id, body, &inh);\n-\n-            fcx.select_all_obligations_and_apply_defaults();\n-            fcx.closure_analyze_fn(body);\n-            fcx.select_obligations_where_possible();\n-            fcx.check_casts();\n-            fcx.select_all_obligations_or_error(); // Casts can introduce new obligations.\n-\n-            fcx.regionck_fn(fn_id, fn_span, decl, body);\n-            fcx.resolve_type_vars_in_fn(decl, body);\n-        }\n+    let fn_ty = match raw_fty.sty {\n+        ty::TyFnDef(_, _, f) => f,\n         _ => span_bug!(body.span, \"check_bare_fn: function type expected\")\n-    }\n+    };\n+\n+    Inherited::enter(ccx, param_env, |inh| {\n+        // Compute the fty from point of view of inside fn.\n+        let fn_scope = ccx.tcx.region_maps.call_site_extent(fn_id, body.id);\n+        let fn_sig =\n+            fn_ty.sig.subst(ccx.tcx, &inh.parameter_environment.free_substs);\n+        let fn_sig =\n+            ccx.tcx.liberate_late_bound_regions(fn_scope, &fn_sig);\n+        let fn_sig =\n+            inh.normalize_associated_types_in(body.span, body.id, &fn_sig);\n+\n+        let fcx = check_fn(ccx, fn_ty.unsafety, fn_id, &fn_sig,\n+                           decl, fn_id, body, &inh);\n+\n+        fcx.select_all_obligations_and_apply_defaults();\n+        fcx.closure_analyze_fn(body);\n+        fcx.select_obligations_where_possible();\n+        fcx.check_casts();\n+        fcx.select_all_obligations_or_error(); // Casts can introduce new obligations.\n+\n+        fcx.regionck_fn(fn_id, fn_span, decl, body);\n+        fcx.resolve_type_vars_in_fn(decl, body);\n+    });\n }\n \n struct GatherLocalsVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n@@ -1135,22 +1126,22 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n fn check_const_in_type<'a,'tcx>(ccx: &'a CrateCtxt<'a,'tcx>,\n                                 expr: &'tcx hir::Expr,\n                                 expected_type: Ty<'tcx>) {\n-    let tables = RefCell::new(ty::Tables::empty());\n-    let inh = static_inherited_fields(ccx, &tables);\n-    let fcx = FnCtxt::new(&inh, ty::FnConverging(expected_type), expr.id);\n-    fcx.check_const_with_ty(expr.span, expr, expected_type);\n+    Inherited::enter(ccx, ccx.tcx.empty_parameter_environment(), |inh| {\n+        let fcx = FnCtxt::new(&inh, ty::FnConverging(expected_type), expr.id);\n+        fcx.check_const_with_ty(expr.span, expr, expected_type);\n+    });\n }\n \n fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                         sp: Span,\n                         e: &'tcx hir::Expr,\n                         id: ast::NodeId) {\n-    let tables = RefCell::new(ty::Tables::empty());\n-    let inh = static_inherited_fields(ccx, &tables);\n-    let rty = ccx.tcx.node_id_to_type(id);\n-    let fcx = FnCtxt::new(&inh, ty::FnConverging(rty), e.id);\n-    let declty = fcx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(id)).ty;\n-    fcx.check_const_with_ty(sp, e, declty);\n+    Inherited::enter(ccx, ccx.tcx.empty_parameter_environment(), |inh| {\n+        let rty = ccx.tcx.node_id_to_type(id);\n+        let fcx = FnCtxt::new(&inh, ty::FnConverging(rty), e.id);\n+        let declty = fcx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(id)).ty;\n+        fcx.check_const_with_ty(sp, e, declty);\n+    });\n }\n \n /// Checks whether a type can be represented in memory. In particular, it\n@@ -1206,21 +1197,21 @@ pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, id: ast::Node\n     }\n }\n \n+#[allow(trivial_numeric_casts)]\n pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                     sp: Span,\n                                     vs: &'tcx [hir::Variant],\n                                     id: ast::NodeId) {\n-    fn do_check<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                          vs: &'tcx [hir::Variant],\n-                          id: ast::NodeId,\n-                          hint: attr::ReprAttr) {\n-        #![allow(trivial_numeric_casts)]\n+    let def_id = ccx.tcx.map.local_def_id(id);\n+    let hint = *ccx.tcx.lookup_repr_hints(def_id).get(0).unwrap_or(&attr::ReprAny);\n \n-        let rty = ccx.tcx.node_id_to_type(id);\n-        let mut disr_vals: Vec<ty::Disr> = Vec::new();\n+    if hint != attr::ReprAny && vs.is_empty() {\n+        span_err!(ccx.tcx.sess, sp, E0084,\n+            \"unsupported representation for zero-variant enum\");\n+    }\n \n-        let tables = RefCell::new(ty::Tables::empty());\n-        let inh = static_inherited_fields(ccx, &tables);\n+    Inherited::enter(ccx, ccx.tcx.empty_parameter_environment(), |inh| {\n+        let rty = ccx.tcx.node_id_to_type(id);\n         let fcx = FnCtxt::new(&inh, ty::FnConverging(rty), id);\n \n         let repr_type_ty = ccx.tcx.enum_repr_type(Some(&hint)).to_ty(ccx.tcx);\n@@ -1233,34 +1224,22 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         let def_id = ccx.tcx.map.local_def_id(id);\n \n         let variants = &ccx.tcx.lookup_adt_def(def_id).variants;\n+        let mut disr_vals: Vec<ty::Disr> = Vec::new();\n         for (v, variant) in vs.iter().zip(variants.iter()) {\n             let current_disr_val = variant.disr_val;\n \n             // Check for duplicate discriminant values\n-            match disr_vals.iter().position(|&x| x == current_disr_val) {\n-                Some(i) => {\n-                    let mut err = struct_span_err!(ccx.tcx.sess, v.span, E0081,\n-                        \"discriminant value `{}` already exists\", disr_vals[i]);\n-                    let variant_i_node_id = ccx.tcx.map.as_local_node_id(variants[i].did).unwrap();\n-                    span_note!(&mut err, ccx.tcx.map.span(variant_i_node_id),\n-                        \"conflicting discriminant here\");\n-                    err.emit();\n-                }\n-                None => {}\n+            if let Some(i) = disr_vals.iter().position(|&x| x == current_disr_val) {\n+                let mut err = struct_span_err!(ccx.tcx.sess, v.span, E0081,\n+                    \"discriminant value `{}` already exists\", disr_vals[i]);\n+                let variant_i_node_id = ccx.tcx.map.as_local_node_id(variants[i].did).unwrap();\n+                span_note!(&mut err, ccx.tcx.map.span(variant_i_node_id),\n+                    \"conflicting discriminant here\");\n+                err.emit();\n             }\n             disr_vals.push(current_disr_val);\n         }\n-    }\n-\n-    let def_id = ccx.tcx.map.local_def_id(id);\n-    let hint = *ccx.tcx.lookup_repr_hints(def_id).get(0).unwrap_or(&attr::ReprAny);\n-\n-    if hint != attr::ReprAny && vs.is_empty() {\n-        span_err!(ccx.tcx.sess, sp, E0084,\n-            \"unsupported representation for zero-variant enum\");\n-    }\n-\n-    do_check(ccx, vs, id, hint);\n+    });\n \n     check_representable(ccx.tcx, sp, id, \"enum\");\n }"}, {"sha": "720881e768455f99c9fe611878ce66a268922e81", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -17,7 +17,6 @@ use rustc::ty::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n \n-use std::cell::RefCell;\n use std::collections::HashSet;\n use syntax::ast;\n use syntax::codemap::{Span};\n@@ -180,12 +179,12 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     {\n         let ccx = self.ccx;\n         let param_env = ty::ParameterEnvironment::for_item(ccx.tcx, id);\n-        let tables = RefCell::new(ty::Tables::empty());\n-        let inh = Inherited::new(ccx, &tables, param_env);\n-        let fcx = FnCtxt::new(&inh, ty::FnDiverging, id);\n-        let wf_tys = f(&fcx, self);\n-        fcx.select_all_obligations_or_error();\n-        fcx.regionck_item(id, span, &wf_tys);\n+        Inherited::enter(ccx, param_env, |inh| {\n+            let fcx = FnCtxt::new(&inh, ty::FnDiverging, id);\n+            let wf_tys = f(&fcx, self);\n+            fcx.select_all_obligations_or_error();\n+            fcx.regionck_item(id, span, &wf_tys);\n+        });\n     }\n \n     /// In a type definition, we check that to ensure that the types of the fields are well-formed."}, {"sha": "8c0e11780b21d106b88d352557969f7d2c020e21", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 104, "deletions": 106, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -376,111 +376,111 @@ fn get_base_type_def_id(&self, span: Span, ty: Ty<'tcx>) -> Option<DefId> {\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (free)\",\n                    source, target);\n \n-            let infcx = InferCtxt::new(tcx, &tcx.tables, Some(param_env), ProjectionMode::Topmost);\n-\n-            let origin = TypeOrigin::Misc(span);\n-            let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>, mt_b: ty::TypeAndMut<'tcx>,\n-                               mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n-                if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n-                    infcx.report_mismatched_types(origin, mk_ptr(mt_b.ty),\n-                                                  target, ty::error::TypeError::Mutability);\n-                }\n-                (mt_a.ty, mt_b.ty, unsize_trait, None)\n-            };\n-            let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n-                (&ty::TyBox(a), &ty::TyBox(b)) => (a, b, unsize_trait, None),\n-\n-                (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n-                    infcx.sub_regions(infer::RelateObjectBound(span), *r_b, *r_a);\n-                    check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n-                }\n-\n-                (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) |\n-                (&ty::TyRawPtr(mt_a), &ty::TyRawPtr(mt_b)) => {\n-                    check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n-                }\n+            InferCtxt::enter(tcx, None, Some(param_env), ProjectionMode::Topmost, |infcx| {\n+                let origin = TypeOrigin::Misc(span);\n+                let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>, mt_b: ty::TypeAndMut<'tcx>,\n+                                   mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n+                    if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n+                        infcx.report_mismatched_types(origin, mk_ptr(mt_b.ty),\n+                                                      target, ty::error::TypeError::Mutability);\n+                    }\n+                    (mt_a.ty, mt_b.ty, unsize_trait, None)\n+                };\n+                let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n+                    (&ty::TyBox(a), &ty::TyBox(b)) => (a, b, unsize_trait, None),\n+\n+                    (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n+                        infcx.sub_regions(infer::RelateObjectBound(span), *r_b, *r_a);\n+                        check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n+                    }\n \n-                (&ty::TyStruct(def_a, substs_a), &ty::TyStruct(def_b, substs_b)) => {\n-                    if def_a != def_b {\n-                        let source_path = tcx.item_path_str(def_a.did);\n-                        let target_path = tcx.item_path_str(def_b.did);\n-                        span_err!(tcx.sess, span, E0377,\n-                                  \"the trait `CoerceUnsized` may only be implemented \\\n-                                   for a coercion between structures with the same \\\n-                                   definition; expected {}, found {}\",\n-                                  source_path, target_path);\n-                        return;\n+                    (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) |\n+                    (&ty::TyRawPtr(mt_a), &ty::TyRawPtr(mt_b)) => {\n+                        check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n                     }\n \n-                    let fields = &def_a.struct_variant().fields;\n-                    let diff_fields = fields.iter().enumerate().filter_map(|(i, f)| {\n-                        let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n-\n-                        if f.unsubst_ty().is_phantom_data() {\n-                            // Ignore PhantomData fields\n-                            None\n-                        } else if infcx.sub_types(false, origin, b, a).is_ok() {\n-                            // Ignore fields that aren't significantly changed\n-                            None\n-                        } else {\n-                            // Collect up all fields that were significantly changed\n-                            // i.e. those that contain T in coerce_unsized T -> U\n-                            Some((i, a, b))\n+                    (&ty::TyStruct(def_a, substs_a), &ty::TyStruct(def_b, substs_b)) => {\n+                        if def_a != def_b {\n+                            let source_path = tcx.item_path_str(def_a.did);\n+                            let target_path = tcx.item_path_str(def_b.did);\n+                            span_err!(tcx.sess, span, E0377,\n+                                      \"the trait `CoerceUnsized` may only be implemented \\\n+                                       for a coercion between structures with the same \\\n+                                       definition; expected {}, found {}\",\n+                                      source_path, target_path);\n+                            return;\n                         }\n-                    }).collect::<Vec<_>>();\n \n-                    if diff_fields.is_empty() {\n-                        span_err!(tcx.sess, span, E0374,\n-                                  \"the trait `CoerceUnsized` may only be implemented \\\n-                                   for a coercion between structures with one field \\\n-                                   being coerced, none found\");\n-                        return;\n-                    } else if diff_fields.len() > 1 {\n-                        span_err!(tcx.sess, span, E0375,\n+                        let fields = &def_a.struct_variant().fields;\n+                        let diff_fields = fields.iter().enumerate().filter_map(|(i, f)| {\n+                            let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n+\n+                            if f.unsubst_ty().is_phantom_data() {\n+                                // Ignore PhantomData fields\n+                                None\n+                            } else if infcx.sub_types(false, origin, b, a).is_ok() {\n+                                // Ignore fields that aren't significantly changed\n+                                None\n+                            } else {\n+                                // Collect up all fields that were significantly changed\n+                                // i.e. those that contain T in coerce_unsized T -> U\n+                                Some((i, a, b))\n+                            }\n+                        }).collect::<Vec<_>>();\n+\n+                        if diff_fields.is_empty() {\n+                            span_err!(tcx.sess, span, E0374,\n+                                      \"the trait `CoerceUnsized` may only be implemented \\\n+                                       for a coercion between structures with one field \\\n+                                       being coerced, none found\");\n+                            return;\n+                        } else if diff_fields.len() > 1 {\n+                            span_err!(tcx.sess, span, E0375,\n+                                      \"the trait `CoerceUnsized` may only be implemented \\\n+                                       for a coercion between structures with one field \\\n+                                       being coerced, but {} fields need coercions: {}\",\n+                                       diff_fields.len(), diff_fields.iter().map(|&(i, a, b)| {\n+                                            format!(\"{} ({} to {})\", fields[i].name, a, b)\n+                                       }).collect::<Vec<_>>().join(\", \"));\n+                            return;\n+                        }\n+\n+                        let (i, a, b) = diff_fields[0];\n+                        let kind = ty::adjustment::CustomCoerceUnsized::Struct(i);\n+                        (a, b, coerce_unsized_trait, Some(kind))\n+                    }\n+\n+                    _ => {\n+                        span_err!(tcx.sess, span, E0376,\n                                   \"the trait `CoerceUnsized` may only be implemented \\\n-                                   for a coercion between structures with one field \\\n-                                   being coerced, but {} fields need coercions: {}\",\n-                                   diff_fields.len(), diff_fields.iter().map(|&(i, a, b)| {\n-                                        format!(\"{} ({} to {})\", fields[i].name, a, b)\n-                                   }).collect::<Vec<_>>().join(\", \"));\n+                                   for a coercion between structures\");\n                         return;\n                     }\n+                };\n \n-                    let (i, a, b) = diff_fields[0];\n-                    let kind = ty::adjustment::CustomCoerceUnsized::Struct(i);\n-                    (a, b, coerce_unsized_trait, Some(kind))\n-                }\n+                let mut fulfill_cx = traits::FulfillmentContext::new();\n \n-                _ => {\n-                    span_err!(tcx.sess, span, E0376,\n-                              \"the trait `CoerceUnsized` may only be implemented \\\n-                               for a coercion between structures\");\n-                    return;\n-                }\n-            };\n+                // Register an obligation for `A: Trait<B>`.\n+                let cause = traits::ObligationCause::misc(span, impl_node_id);\n+                let predicate = tcx.predicate_for_trait_def(cause, trait_def_id, 0,\n+                                                            source, vec![target]);\n+                fulfill_cx.register_predicate_obligation(&infcx, predicate);\n \n-            let mut fulfill_cx = traits::FulfillmentContext::new();\n-\n-            // Register an obligation for `A: Trait<B>`.\n-            let cause = traits::ObligationCause::misc(span, impl_node_id);\n-            let predicate = tcx.predicate_for_trait_def(cause, trait_def_id, 0,\n-                                                        source, vec![target]);\n-            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-\n-            // Check that all transitive obligations are satisfied.\n-            if let Err(errors) = fulfill_cx.select_all_or_error(&infcx) {\n-                infcx.report_fulfillment_errors(&errors);\n-            }\n+                // Check that all transitive obligations are satisfied.\n+                if let Err(errors) = fulfill_cx.select_all_or_error(&infcx) {\n+                    infcx.report_fulfillment_errors(&errors);\n+                }\n \n-            // Finally, resolve all regions.\n-            let mut free_regions = FreeRegionMap::new();\n-            free_regions.relate_free_regions_from_predicates(&infcx.parameter_environment\n-                                                                   .caller_bounds);\n-            infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n+                // Finally, resolve all regions.\n+                let mut free_regions = FreeRegionMap::new();\n+                free_regions.relate_free_regions_from_predicates(\n+                    &infcx.parameter_environment.caller_bounds);\n+                infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n \n-            if let Some(kind) = kind {\n-                tcx.custom_coerce_unsized_kinds.borrow_mut().insert(impl_did, kind);\n-            }\n+                if let Some(kind) = kind {\n+                    tcx.custom_coerce_unsized_kinds.borrow_mut().insert(impl_did, kind);\n+                }\n+            });\n         });\n     }\n }\n@@ -511,18 +511,16 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: Def\n     err.emit();\n }\n \n-pub fn check_coherence(crate_context: &CrateCtxt) {\n-    let _task = crate_context.tcx.dep_graph.in_task(DepNode::Coherence);\n-    let infcx = InferCtxt::new(crate_context.tcx,\n-                               &crate_context.tcx.tables,\n-                               None,\n-                               ProjectionMode::Topmost);\n-    CoherenceChecker {\n-        crate_context: crate_context,\n-        inference_context: infcx,\n-        inherent_impls: RefCell::new(FnvHashMap()),\n-    }.check();\n-    unsafety::check(crate_context.tcx);\n-    orphan::check(crate_context.tcx);\n-    overlap::check(crate_context.tcx);\n+pub fn check_coherence(ccx: &CrateCtxt) {\n+    let _task = ccx.tcx.dep_graph.in_task(DepNode::Coherence);\n+    InferCtxt::enter(ccx.tcx, None, None, ProjectionMode::Topmost, |infcx| {\n+        CoherenceChecker {\n+            crate_context: ccx,\n+            inference_context: infcx,\n+            inherent_impls: RefCell::new(FnvHashMap()),\n+        }.check();\n+    });\n+    unsafety::check(ccx.tcx);\n+    orphan::check(ccx.tcx);\n+    overlap::check(ccx.tcx);\n }"}, {"sha": "0f0a5b5241e71b274b15438ded91e77956014a5b", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -85,11 +85,11 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i+1)..] {\n-                let infcx = InferCtxt::new(self.tcx, &self.tcx.tables, None,\n-                                           ProjectionMode::Topmost);\n-                if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n-                    self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n-                }\n+                InferCtxt::enter(self.tcx, None, None, ProjectionMode::Topmost, |infcx| {\n+                    if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n+                        self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n+                    }\n+                });\n             }\n         }\n     }\n@@ -138,24 +138,12 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n \n                 // insertion failed due to overlap\n                 if let Err(overlap) = insert_result {\n-                    // only print the Self type if it has at least some outer\n-                    // concrete shell; otherwise, it's not adding much\n-                    // information.\n-                    let self_type = {\n-                        overlap.on_trait_ref.substs.self_ty().and_then(|ty| {\n-                            if ty.has_concrete_skeleton() {\n-                                Some(format!(\" for type `{}`\", ty))\n-                            } else {\n-                                None\n-                            }\n-                        }).unwrap_or(String::new())\n-                    };\n-\n                     let mut err = struct_span_err!(\n                         self.tcx.sess, self.tcx.span_of_impl(impl_def_id).unwrap(), E0119,\n                         \"conflicting implementations of trait `{}`{}:\",\n-                        overlap.on_trait_ref,\n-                        self_type);\n+                        overlap.trait_desc,\n+                        overlap.self_desc.map_or(String::new(),\n+                                                 |ty| format!(\" for type `{}`\", ty)));\n \n                     match self.tcx.span_of_impl(overlap.with_impl) {\n                         Ok(span) => {"}, {"sha": "32594a4e6188e1edf367c6991b7199b9cee217a6", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e56ea56b0291c99f426521f028978598808d89/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=12e56ea56b0291c99f426521f028978598808d89", "patch": "@@ -203,8 +203,9 @@ fn require_same_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let err = if let Some(infcx) = maybe_infcx {\n         infcx.eq_types(false, TypeOrigin::Misc(span), t1, t2).err()\n     } else {\n-        let infcx = InferCtxt::new(ccx.tcx, &ccx.tcx.tables, None, ProjectionMode::AnyFinal);\n-        infcx.eq_types(false, TypeOrigin::Misc(span), t1, t2).err()\n+        InferCtxt::enter(ccx.tcx, None, None, ProjectionMode::AnyFinal, |infcx| {\n+            infcx.eq_types(false, TypeOrigin::Misc(span), t1, t2).err()\n+        })\n     };\n \n     if let Some(ref terr) = err {"}]}