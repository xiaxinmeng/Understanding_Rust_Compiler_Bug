{"sha": "ec872dc8a3f008299ca1508105ee064d1f0f0367", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjODcyZGM4YTNmMDA4Mjk5Y2ExNTA4MTA1ZWUwNjRkMWYwZjAzNjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-07T21:45:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-07T21:45:39Z"}, "message": "Auto merge of #34141 - eddyb:trans-abi-memcpy, r=nikomatsakis\n\ntrans: always use a memcpy for ABI argument/return casts.\n\nWhen storing incoming arguments or values returned by call/invoke, always do a `memcpy` from a temporary of the cast type, if there is an ABI cast.\nWhile Clang has gotten smarter ([store](https://godbolt.org/g/EphFuK) vs [memcpy](https://godbolt.org/g/5dikH9)), a `memcpy` will always work.\nThis is what @dotdash has wanted to do all along, and it fixes #32049.", "tree": {"sha": "a143dd587358cf577ae7465ce4d67e9505c02694", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a143dd587358cf577ae7465ce4d67e9505c02694"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec872dc8a3f008299ca1508105ee064d1f0f0367", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec872dc8a3f008299ca1508105ee064d1f0f0367", "html_url": "https://github.com/rust-lang/rust/commit/ec872dc8a3f008299ca1508105ee064d1f0f0367", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec872dc8a3f008299ca1508105ee064d1f0f0367/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39a523ba134c86df449bccd903313fc5e7b6f6c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/39a523ba134c86df449bccd903313fc5e7b6f6c3", "html_url": "https://github.com/rust-lang/rust/commit/39a523ba134c86df449bccd903313fc5e7b6f6c3"}, {"sha": "e252865b744568649c3ecfcf8ac02bb6f73d7fc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e252865b744568649c3ecfcf8ac02bb6f73d7fc6", "html_url": "https://github.com/rust-lang/rust/commit/e252865b744568649c3ecfcf8ac02bb6f73d7fc6"}], "stats": {"total": 331, "additions": 137, "deletions": 194}, "files": [{"sha": "df3d2d149b99ce072fbbf3ba13a1755fafa67455", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 53, "deletions": 15, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ec872dc8a3f008299ca1508105ee064d1f0f0367/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec872dc8a3f008299ca1508105ee064d1f0f0367/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=ec872dc8a3f008299ca1508105ee064d1f0f0367", "patch": "@@ -10,8 +10,8 @@\n \n use llvm::{self, ValueRef};\n use base;\n-use builder::Builder;\n-use common::{type_is_fat_ptr, BlockAndBuilder};\n+use build::AllocaFcx;\n+use common::{type_is_fat_ptr, BlockAndBuilder, C_uint};\n use context::CrateContext;\n use cabi_x86;\n use cabi_x86_64;\n@@ -22,14 +22,15 @@ use cabi_powerpc;\n use cabi_powerpc64;\n use cabi_mips;\n use cabi_asmjs;\n-use machine::{llalign_of_min, llsize_of, llsize_of_real};\n+use machine::{llalign_of_min, llsize_of, llsize_of_real, llsize_of_store};\n use type_::Type;\n use type_of;\n \n use rustc::hir;\n use rustc::ty::{self, Ty};\n \n use libc::c_uint;\n+use std::cmp;\n \n pub use syntax::abi::Abi;\n pub use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n@@ -150,26 +151,63 @@ impl ArgType {\n     /// lvalue for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n     /// or results of call/invoke instructions into their destinations.\n-    pub fn store(&self, b: &Builder, mut val: ValueRef, dst: ValueRef) {\n+    pub fn store(&self, bcx: &BlockAndBuilder, mut val: ValueRef, dst: ValueRef) {\n         if self.is_ignore() {\n             return;\n         }\n+        let ccx = bcx.ccx();\n         if self.is_indirect() {\n-            let llsz = llsize_of(b.ccx, self.ty);\n-            let llalign = llalign_of_min(b.ccx, self.ty);\n-            base::call_memcpy(b, dst, val, llsz, llalign as u32);\n+            let llsz = llsize_of(ccx, self.ty);\n+            let llalign = llalign_of_min(ccx, self.ty);\n+            base::call_memcpy(bcx, dst, val, llsz, llalign as u32);\n         } else if let Some(ty) = self.cast {\n-            let cast_dst = b.pointercast(dst, ty.ptr_to());\n-            let store = b.store(val, cast_dst);\n-            let llalign = llalign_of_min(b.ccx, self.ty);\n-            unsafe {\n-                llvm::LLVMSetAlignment(store, llalign);\n+            // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n+            // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n+            let can_store_through_cast_ptr = false;\n+            if can_store_through_cast_ptr {\n+                let cast_dst = bcx.pointercast(dst, ty.ptr_to());\n+                let store = bcx.store(val, cast_dst);\n+                let llalign = llalign_of_min(ccx, self.ty);\n+                unsafe {\n+                    llvm::LLVMSetAlignment(store, llalign);\n+                }\n+            } else {\n+                // The actual return type is a struct, but the ABI\n+                // adaptation code has cast it into some scalar type.  The\n+                // code that follows is the only reliable way I have\n+                // found to do a transform like i64 -> {i32,i32}.\n+                // Basically we dump the data onto the stack then memcpy it.\n+                //\n+                // Other approaches I tried:\n+                // - Casting rust ret pointer to the foreign type and using Store\n+                //   is (a) unsafe if size of foreign type > size of rust type and\n+                //   (b) runs afoul of strict aliasing rules, yielding invalid\n+                //   assembly under -O (specifically, the store gets removed).\n+                // - Truncating foreign type to correct integral type and then\n+                //   bitcasting to the struct type yields invalid cast errors.\n+\n+                // We instead thus allocate some scratch space...\n+                let llscratch = AllocaFcx(bcx.fcx(), ty, \"abi_cast\");\n+                base::Lifetime::Start.call(bcx, llscratch);\n+\n+                // ...where we first store the value...\n+                bcx.store(val, llscratch);\n+\n+                // ...and then memcpy it to the intended destination.\n+                base::call_memcpy(bcx,\n+                                  bcx.pointercast(dst, Type::i8p(ccx)),\n+                                  bcx.pointercast(llscratch, Type::i8p(ccx)),\n+                                  C_uint(ccx, llsize_of_store(ccx, self.ty)),\n+                                  cmp::min(llalign_of_min(ccx, self.ty),\n+                                           llalign_of_min(ccx, ty)) as u32);\n+\n+                base::Lifetime::End.call(bcx, llscratch);\n             }\n         } else {\n-            if self.original_ty == Type::i1(b.ccx) {\n-                val = b.zext(val, Type::i8(b.ccx));\n+            if self.original_ty == Type::i1(ccx) {\n+                val = bcx.zext(val, Type::i8(ccx));\n             }\n-            b.store(val, dst);\n+            bcx.store(val, dst);\n         }\n     }\n "}, {"sha": "b7e8e618abbc49f77c3e072b2c3ea48ee96e6d46", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 42, "deletions": 52, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/ec872dc8a3f008299ca1508105ee064d1f0f0367/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec872dc8a3f008299ca1508105ee064d1f0f0367/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=ec872dc8a3f008299ca1508105ee064d1f0f0367", "patch": "@@ -1043,7 +1043,7 @@ pub fn with_cond<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>, val: ValueRef, f: F) ->\n     next_cx\n }\n \n-enum Lifetime { Start, End }\n+pub enum Lifetime { Start, End }\n \n // If LLVM lifetime intrinsic support is enabled (i.e. optimizations\n // on), and `ptr` is nonzero-sized, then extracts the size of `ptr`\n@@ -1080,24 +1080,25 @@ fn core_lifetime_emit<'blk, 'tcx, F>(ccx: &'blk CrateContext<'blk, 'tcx>,\n     emit(ccx, size, lifetime_intrinsic)\n }\n \n-pub fn call_lifetime_start(cx: Block, ptr: ValueRef) {\n-    core_lifetime_emit(cx.ccx(), ptr, Lifetime::Start, |ccx, size, lifetime_start| {\n-        let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n-        Call(cx,\n-             lifetime_start,\n-             &[C_u64(ccx, size), ptr],\n-             DebugLoc::None);\n-    })\n+impl Lifetime {\n+    pub fn call(self, b: &Builder, ptr: ValueRef) {\n+        core_lifetime_emit(b.ccx, ptr, self, |ccx, size, lifetime_intrinsic| {\n+            let ptr = b.pointercast(ptr, Type::i8p(ccx));\n+            b.call(lifetime_intrinsic, &[C_u64(ccx, size), ptr], None);\n+        });\n+    }\n }\n \n-pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n-    core_lifetime_emit(cx.ccx(), ptr, Lifetime::End, |ccx, size, lifetime_end| {\n-        let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n-        Call(cx,\n-             lifetime_end,\n-             &[C_u64(ccx, size), ptr],\n-             DebugLoc::None);\n-    })\n+pub fn call_lifetime_start(bcx: Block, ptr: ValueRef) {\n+    if !bcx.unreachable.get() {\n+        Lifetime::Start.call(&bcx.build(), ptr);\n+    }\n+}\n+\n+pub fn call_lifetime_end(bcx: Block, ptr: ValueRef) {\n+    if !bcx.unreachable.get() {\n+        Lifetime::End.call(&bcx.build(), ptr);\n+    }\n }\n \n // Generates code for resumption of unwind at the end of a landing pad.\n@@ -1664,29 +1665,21 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n                                       arg_ty,\n                                       datum::Lvalue::new(\"FunctionContext::bind_args\"))\n                 } else {\n-                    let lltmp = if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n-                        let lltemp = alloc_ty(bcx, arg_ty, \"\");\n-                        let b = &bcx.build();\n-                        // we pass fat pointers as two words, but we want to\n-                        // represent them internally as a pointer to two words,\n-                        // so make an alloca to store them in.\n-                        let meta = &self.fn_ty.args[idx];\n-                        idx += 1;\n-                        arg.store_fn_arg(b, &mut llarg_idx, expr::get_dataptr(bcx, lltemp));\n-                        meta.store_fn_arg(b, &mut llarg_idx, expr::get_meta(bcx, lltemp));\n-                        lltemp\n-                    } else  {\n-                        // otherwise, arg is passed by value, so store it into a temporary.\n-                        let llarg_ty = arg.cast.unwrap_or(arg.memory_ty(bcx.ccx()));\n-                        let lltemp = alloca(bcx, llarg_ty, \"\");\n+                    unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx, arg_ty, \"\",\n+                                                                   uninit_reason,\n+                                                                   arg_scope_id, |bcx, dst| {\n+                        debug!(\"FunctionContext::bind_args: {:?}: {:?}\", hir_arg, arg_ty);\n                         let b = &bcx.build();\n-                        arg.store_fn_arg(b, &mut llarg_idx, lltemp);\n-                        // And coerce the temporary into the type we expect.\n-                        b.pointercast(lltemp, arg.memory_ty(bcx.ccx()).ptr_to())\n-                    };\n-                    bcx.fcx.schedule_drop_mem(arg_scope_id, lltmp, arg_ty, None);\n-                    datum::Datum::new(lltmp, arg_ty,\n-                                      datum::Lvalue::new(\"bind_args\"))\n+                        if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n+                            let meta = &self.fn_ty.args[idx];\n+                            idx += 1;\n+                            arg.store_fn_arg(b, &mut llarg_idx, expr::get_dataptr(bcx, dst));\n+                            meta.store_fn_arg(b, &mut llarg_idx, expr::get_meta(bcx, dst));\n+                        } else {\n+                            arg.store_fn_arg(b, &mut llarg_idx, dst);\n+                        }\n+                        bcx\n+                    }))\n                 }\n             } else {\n                 // FIXME(pcwalton): Reduce the amount of code bloat this is responsible for.\n@@ -1721,19 +1714,16 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n             };\n \n             let pat = &hir_arg.pat;\n-            bcx = match simple_name(pat) {\n-                // The check for alloca is necessary because above for the immediate argument case\n-                // we had to cast. At this point arg_datum is not an alloca anymore and thus\n-                // breaks debuginfo if we allow this optimisation.\n-                Some(name)\n-                if unsafe { llvm::LLVMIsAAllocaInst(arg_datum.val) != ::std::ptr::null_mut() } => {\n-                    // Generate nicer LLVM for the common case of fn a pattern\n-                    // like `x: T`\n-                    set_value_name(arg_datum.val, &bcx.name(name));\n-                    self.lllocals.borrow_mut().insert(pat.id, arg_datum);\n-                    bcx\n-                },\n-                _ => _match::bind_irrefutable_pat(bcx, pat, arg_datum.match_input(), arg_scope_id)\n+            bcx = if let Some(name) = simple_name(pat) {\n+                // Generate nicer LLVM for the common case of fn a pattern\n+                // like `x: T`\n+                set_value_name(arg_datum.val, &bcx.name(name));\n+                self.lllocals.borrow_mut().insert(pat.id, arg_datum);\n+                bcx\n+            } else {\n+                // General path. Copy out the values that are used in the\n+                // pattern.\n+                _match::bind_irrefutable_pat(bcx, pat, arg_datum.match_input(), arg_scope_id)\n             };\n             debuginfo::create_argument_metadata(bcx, hir_arg);\n         }"}, {"sha": "7099246c6abde6f858955358ee313b67324a6d5b", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 10, "deletions": 46, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ec872dc8a3f008299ca1508105ee064d1f0f0367/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec872dc8a3f008299ca1508105ee064d1f0f0367/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=ec872dc8a3f008299ca1508105ee064d1f0f0367", "patch": "@@ -34,8 +34,7 @@ use build::*;\n use cleanup;\n use cleanup::CleanupMethods;\n use closure;\n-use common::{self, Block, Result, CrateContext, FunctionContext};\n-use common::{C_uint, C_undef};\n+use common::{self, Block, Result, CrateContext, FunctionContext, C_undef};\n use consts;\n use datum::*;\n use debuginfo::DebugLoc;\n@@ -44,7 +43,7 @@ use expr;\n use glue;\n use inline;\n use intrinsic;\n-use machine::{llalign_of_min, llsize_of_store};\n+use machine::llalign_of_min;\n use meth;\n use monomorphize::{self, Instance};\n use type_::Type;\n@@ -58,8 +57,6 @@ use syntax::codemap::DUMMY_SP;\n use syntax::errors;\n use syntax::ptr::P;\n \n-use std::cmp;\n-\n #[derive(Debug)]\n pub enum CalleeData {\n     /// Constructor for enum variant/tuple-like-struct.\n@@ -689,49 +686,16 @@ fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let (llret, mut bcx) = base::invoke(bcx, llfn, &llargs, debug_loc);\n     if !bcx.unreachable.get() {\n         fn_ty.apply_attrs_callsite(llret);\n-    }\n \n-    // If the function we just called does not use an outpointer,\n-    // store the result into the rust outpointer. Cast the outpointer\n-    // type to match because some ABIs will use a different type than\n-    // the Rust type. e.g., a {u32,u32} struct could be returned as\n-    // u64.\n-    if !fn_ty.ret.is_ignore() && !fn_ty.ret.is_indirect() {\n-        if let Some(llforeign_ret_ty) = fn_ty.ret.cast {\n-            let llrust_ret_ty = fn_ty.ret.original_ty;\n-            let llretslot = opt_llretslot.unwrap();\n-\n-            // The actual return type is a struct, but the ABI\n-            // adaptation code has cast it into some scalar type.  The\n-            // code that follows is the only reliable way I have\n-            // found to do a transform like i64 -> {i32,i32}.\n-            // Basically we dump the data onto the stack then memcpy it.\n-            //\n-            // Other approaches I tried:\n-            // - Casting rust ret pointer to the foreign type and using Store\n-            //   is (a) unsafe if size of foreign type > size of rust type and\n-            //   (b) runs afoul of strict aliasing rules, yielding invalid\n-            //   assembly under -O (specifically, the store gets removed).\n-            // - Truncating foreign type to correct integral type and then\n-            //   bitcasting to the struct type yields invalid cast errors.\n-            let llscratch = base::alloca(bcx, llforeign_ret_ty, \"__cast\");\n-            base::call_lifetime_start(bcx, llscratch);\n-            Store(bcx, llret, llscratch);\n-            let llscratch_i8 = PointerCast(bcx, llscratch, Type::i8(ccx).ptr_to());\n-            let llretptr_i8 = PointerCast(bcx, llretslot, Type::i8(ccx).ptr_to());\n-            let llrust_size = llsize_of_store(ccx, llrust_ret_ty);\n-            let llforeign_align = llalign_of_min(ccx, llforeign_ret_ty);\n-            let llrust_align = llalign_of_min(ccx, llrust_ret_ty);\n-            let llalign = cmp::min(llforeign_align, llrust_align);\n-            debug!(\"llrust_size={}\", llrust_size);\n-\n-            if !bcx.unreachable.get() {\n-                base::call_memcpy(&B(bcx), llretptr_i8, llscratch_i8,\n-                                  C_uint(ccx, llrust_size), llalign as u32);\n+        // If the function we just called does not use an outpointer,\n+        // store the result into the rust outpointer. Cast the outpointer\n+        // type to match because some ABIs will use a different type than\n+        // the Rust type. e.g., a {u32,u32} struct could be returned as\n+        // u64.\n+        if !fn_ty.ret.is_indirect() {\n+            if let Some(llretslot) = opt_llretslot {\n+                fn_ty.ret.store(&bcx.build(), llret, llretslot);\n             }\n-            base::call_lifetime_end(bcx, llscratch);\n-        } else if let Some(llretslot) = opt_llretslot {\n-            base::store_ty(bcx, llret, llretslot, output.unwrap());\n         }\n     }\n "}, {"sha": "b404475b5844bba6cb7867b42ad0b3f055edb918", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 14, "deletions": 66, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ec872dc8a3f008299ca1508105ee064d1f0f0367/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec872dc8a3f008299ca1508105ee064d1f0f0367/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=ec872dc8a3f008299ca1508105ee064d1f0f0367", "patch": "@@ -19,11 +19,11 @@ use base;\n use build;\n use callee::{Callee, CalleeData, Fn, Intrinsic, NamedTupleConstructor, Virtual};\n use common::{self, Block, BlockAndBuilder, LandingPad};\n-use common::{C_bool, C_str_slice, C_struct, C_u32, C_uint, C_undef};\n+use common::{C_bool, C_str_slice, C_struct, C_u32, C_undef};\n use consts;\n use debuginfo::DebugLoc;\n use Disr;\n-use machine::{llalign_of_min, llbitsize_of_real, llsize_of_store};\n+use machine::{llalign_of_min, llbitsize_of_real};\n use meth;\n use type_of;\n use glue;\n@@ -39,8 +39,6 @@ use super::lvalue::{LvalueRef, load_fat_ptr};\n use super::operand::OperandRef;\n use super::operand::OperandValue::*;\n \n-use std::cmp;\n-\n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n         let mut bcx = self.bcx(bb);\n@@ -852,77 +850,27 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     op: OperandRef<'tcx>) {\n         use self::ReturnDest::*;\n \n-        // Handle the simple cases that don't require casts, first.\n-        let llcast_ty = match dest {\n-            Nothing => return,\n-            Store(dst) => {\n-                if let Some(llcast_ty) = ret_ty.cast {\n-                    llcast_ty\n-                } else {\n-                    ret_ty.store(bcx, op.immediate(), dst);\n-                    return;\n-                }\n-            }\n+        match dest {\n+            Nothing => (),\n+            Store(dst) => ret_ty.store(bcx, op.immediate(), dst),\n             IndirectOperand(tmp, idx) => {\n                 let op = self.trans_load(bcx, tmp, op.ty);\n                 self.temps[idx as usize] = TempRef::Operand(Some(op));\n-                return;\n             }\n             DirectOperand(idx) => {\n-                if let Some(llcast_ty) = ret_ty.cast {\n-                    llcast_ty\n+                // If there is a cast, we have to store and reload.\n+                let op = if ret_ty.cast.is_some() {\n+                    let tmp = bcx.with_block(|bcx| {\n+                        base::alloc_ty(bcx, op.ty, \"tmp_ret\")\n+                    });\n+                    ret_ty.store(bcx, op.immediate(), tmp);\n+                    self.trans_load(bcx, tmp, op.ty)\n                 } else {\n-                    let op = op.unpack_if_pair(bcx);\n-                    self.temps[idx as usize] = TempRef::Operand(Some(op));\n-                    return;\n-                }\n-            }\n-        };\n-\n-        // The actual return type is a struct, but the ABI\n-        // adaptation code has cast it into some scalar type.  The\n-        // code that follows is the only reliable way I have\n-        // found to do a transform like i64 -> {i32,i32}.\n-        // Basically we dump the data onto the stack then memcpy it.\n-        //\n-        // Other approaches I tried:\n-        // - Casting rust ret pointer to the foreign type and using Store\n-        //   is (a) unsafe if size of foreign type > size of rust type and\n-        //   (b) runs afoul of strict aliasing rules, yielding invalid\n-        //   assembly under -O (specifically, the store gets removed).\n-        // - Truncating foreign type to correct integral type and then\n-        //   bitcasting to the struct type yields invalid cast errors.\n-\n-        // We instead thus allocate some scratch space...\n-        let llscratch = bcx.with_block(|bcx| {\n-            let alloca = base::alloca(bcx, llcast_ty, \"fn_ret_cast\");\n-            base::call_lifetime_start(bcx, alloca);\n-            alloca\n-        });\n-\n-        // ...where we first store the value...\n-        bcx.store(op.immediate(), llscratch);\n-\n-        let ccx = bcx.ccx();\n-        match dest {\n-            Store(dst) => {\n-                // ...and then memcpy it to the intended destination.\n-                base::call_memcpy(bcx,\n-                                  bcx.pointercast(dst, Type::i8p(ccx)),\n-                                  bcx.pointercast(llscratch, Type::i8p(ccx)),\n-                                  C_uint(ccx, llsize_of_store(ccx, ret_ty.original_ty)),\n-                                  cmp::min(llalign_of_min(ccx, ret_ty.original_ty),\n-                                           llalign_of_min(ccx, llcast_ty)) as u32);\n-            }\n-            DirectOperand(idx) => {\n-                let llptr = bcx.pointercast(llscratch, ret_ty.original_ty.ptr_to());\n-                let op = self.trans_load(bcx, llptr, op.ty);\n+                    op.unpack_if_pair(bcx)\n+                };\n                 self.temps[idx as usize] = TempRef::Operand(Some(op));\n             }\n-            Nothing | IndirectOperand(_, _) => bug!()\n         }\n-\n-        bcx.with_block(|bcx| base::call_lifetime_end(bcx, llscratch));\n     }\n }\n "}, {"sha": "0e700d61194341eee1ede6c96ef087ce479758c6", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ec872dc8a3f008299ca1508105ee064d1f0f0367/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec872dc8a3f008299ca1508105ee064d1f0f0367/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=ec872dc8a3f008299ca1508105ee064d1f0f0367", "patch": "@@ -348,28 +348,23 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n             llarg_idx += 1;\n             llarg\n         } else {\n+            let lltemp = bcx.with_block(|bcx| {\n+                base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index))\n+            });\n             if common::type_is_fat_ptr(tcx, arg_ty) {\n-                let lltemp = bcx.with_block(|bcx| {\n-                    base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index))\n-                });\n                 // we pass fat pointers as two words, but we want to\n                 // represent them internally as a pointer to two words,\n                 // so make an alloca to store them in.\n                 let meta = &fcx.fn_ty.args[idx];\n                 idx += 1;\n                 arg.store_fn_arg(bcx, &mut llarg_idx, get_dataptr(bcx, lltemp));\n                 meta.store_fn_arg(bcx, &mut llarg_idx, get_meta(bcx, lltemp));\n-                lltemp\n             } else  {\n-                // otherwise, arg is passed by value, so store it into a temporary.\n-                let llarg_ty = arg.cast.unwrap_or(arg.memory_ty(bcx.ccx()));\n-                let lltemp = bcx.with_block(|bcx| {\n-                    base::alloca(bcx, llarg_ty, &format!(\"arg{}\", arg_index))\n-                });\n+                // otherwise, arg is passed by value, so make a\n+                // temporary and store it there\n                 arg.store_fn_arg(bcx, &mut llarg_idx, lltemp);\n-                // And coerce the temporary into the type we expect.\n-                bcx.pointercast(lltemp, arg.memory_ty(bcx.ccx()).ptr_to())\n             }\n+            lltemp\n         };\n         bcx.with_block(|bcx| arg_scope.map(|scope| {\n             // Is this a regular argument?"}, {"sha": "89bb5d93c74fa1b7f29e553b4f65cb92d6a77878", "filename": "src/test/codegen/stores.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ec872dc8a3f008299ca1508105ee064d1f0f0367/src%2Ftest%2Fcodegen%2Fstores.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec872dc8a3f008299ca1508105ee064d1f0f0367/src%2Ftest%2Fcodegen%2Fstores.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fstores.rs?ref=ec872dc8a3f008299ca1508105ee064d1f0f0367", "patch": "@@ -26,8 +26,12 @@ pub struct Bytes {\n #[no_mangle]\n #[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn small_array_alignment(x: &mut [i8; 4], y: [i8; 4]) {\n-// CHECK: store i32 %{{.*}}, i32* %{{.*}}, align 1\n-// CHECK: [[VAR:%[0-9]+]] = bitcast i32* %{{.*}} to [4 x i8]*\n+// CHECK: %y = alloca [4 x i8]\n+// CHECK: [[TMP:%.+]] = alloca i32\n+// CHECK: store i32 %1, i32* [[TMP]]\n+// CHECK: [[Y8:%[0-9]+]] = bitcast [4 x i8]* %y to i8*\n+// CHECK: [[TMP8:%[0-9]+]] = bitcast i32* [[TMP]] to i8*\n+// CHECK: call void @llvm.memcpy.{{.*}}(i8* [[Y8]], i8* [[TMP8]], i{{[0-9]+}} 4, i32 1, i1 false)\n     *x = y;\n }\n \n@@ -37,7 +41,11 @@ pub fn small_array_alignment(x: &mut [i8; 4], y: [i8; 4]) {\n #[no_mangle]\n #[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn small_struct_alignment(x: &mut Bytes, y: Bytes) {\n-// CHECK: store i32 %{{.*}}, i32* %{{.*}}, align 1\n-// CHECK: [[VAR:%[0-9]+]] = bitcast i32* %{{.*}} to %Bytes*\n+// CHECK: %y = alloca %Bytes\n+// CHECK: [[TMP:%.+]] = alloca i32\n+// CHECK: store i32 %1, i32* [[TMP]]\n+// CHECK: [[Y8:%[0-9]+]] = bitcast %Bytes* %y to i8*\n+// CHECK: [[TMP8:%[0-9]+]] = bitcast i32* [[TMP]] to i8*\n+// CHECK: call void @llvm.memcpy.{{.*}}(i8* [[Y8]], i8* [[TMP8]], i{{[0-9]+}} 4, i32 1, i1 false)\n     *x = y;\n }"}]}