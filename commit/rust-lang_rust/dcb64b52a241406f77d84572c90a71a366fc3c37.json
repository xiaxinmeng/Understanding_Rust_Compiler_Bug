{"sha": "dcb64b52a241406f77d84572c90a71a366fc3c37", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjYjY0YjUyYTI0MTQwNmY3N2Q4NDU3MmM5MGE3MWEzNjZmYzNjMzc=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-11-10T20:05:11Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-11-13T20:47:02Z"}, "message": "represent fat ptr operands as 2 separate pointers\n\nthis does add some complexity, but to do otherwise would require unsized\nlvalues to have their own allocas, which would be ugly.", "tree": {"sha": "64e9de0190bfcb33034c95f2fa6ccc2e57d87b90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64e9de0190bfcb33034c95f2fa6ccc2e57d87b90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcb64b52a241406f77d84572c90a71a366fc3c37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcb64b52a241406f77d84572c90a71a366fc3c37", "html_url": "https://github.com/rust-lang/rust/commit/dcb64b52a241406f77d84572c90a71a366fc3c37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcb64b52a241406f77d84572c90a71a366fc3c37/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "602cf7ec3c69c5c9b7d04c7baf66b270f565a001", "url": "https://api.github.com/repos/rust-lang/rust/commits/602cf7ec3c69c5c9b7d04c7baf66b270f565a001", "html_url": "https://github.com/rust-lang/rust/commit/602cf7ec3c69c5c9b7d04c7baf66b270f565a001"}], "stats": {"total": 643, "additions": 431, "deletions": 212}, "files": [{"sha": "7f258cb845b44d5b51271e0d4d2dfa1ed37fecdb", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 66, "deletions": 33, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/dcb64b52a241406f77d84572c90a71a366fc3c37/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb64b52a241406f77d84572c90a71a366fc3c37/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=dcb64b52a241406f77d84572c90a71a366fc3c37", "patch": "@@ -312,6 +312,49 @@ pub fn bin_op_to_fcmp_predicate(ccx: &CrateContext, op: hir::BinOp_)\n     }\n }\n \n+pub fn compare_fat_ptrs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    lhs_addr: ValueRef,\n+                                    lhs_extra: ValueRef,\n+                                    rhs_addr: ValueRef,\n+                                    rhs_extra: ValueRef,\n+                                    _t: Ty<'tcx>,\n+                                    op: hir::BinOp_,\n+                                    debug_loc: DebugLoc)\n+                                    -> ValueRef {\n+    match op {\n+        hir::BiEq => {\n+            let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n+            let extra_eq = ICmp(bcx, llvm::IntEQ, lhs_extra, rhs_extra, debug_loc);\n+            And(bcx, addr_eq, extra_eq, debug_loc)\n+        }\n+        hir::BiNe => {\n+            let addr_eq = ICmp(bcx, llvm::IntNE, lhs_addr, rhs_addr, debug_loc);\n+            let extra_eq = ICmp(bcx, llvm::IntNE, lhs_extra, rhs_extra, debug_loc);\n+            Or(bcx, addr_eq, extra_eq, debug_loc)\n+        }\n+        hir::BiLe | hir::BiLt | hir::BiGe | hir::BiGt => {\n+            // a OP b ~ a.0 STRICT(OP) b.0 | (a.0 == b.0 && a.1 OP a.1)\n+            let (op, strict_op) = match op {\n+                hir::BiLt => (llvm::IntULT, llvm::IntULT),\n+                hir::BiLe => (llvm::IntULE, llvm::IntULT),\n+                hir::BiGt => (llvm::IntUGT, llvm::IntUGT),\n+                hir::BiGe => (llvm::IntUGE, llvm::IntUGT),\n+                _ => unreachable!()\n+            };\n+\n+            let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n+            let extra_op = ICmp(bcx, op, lhs_extra, rhs_extra, debug_loc);\n+            let addr_eq_extra_op = And(bcx, addr_eq, extra_op, debug_loc);\n+\n+            let addr_strict = ICmp(bcx, strict_op, lhs_addr, rhs_addr, debug_loc);\n+            Or(bcx, addr_strict, addr_eq_extra_op, debug_loc)\n+        }\n+        _ => {\n+            bcx.tcx().sess.bug(\"unexpected fat ptr binop\");\n+        }\n+    }\n+}\n+\n pub fn compare_scalar_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         lhs: ValueRef,\n                                         rhs: ValueRef,\n@@ -342,39 +385,10 @@ pub fn compare_scalar_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             let rhs_addr = Load(bcx, GEPi(bcx, rhs, &[0, abi::FAT_PTR_ADDR]));\n             let rhs_extra = Load(bcx, GEPi(bcx, rhs, &[0, abi::FAT_PTR_EXTRA]));\n-\n-            match op {\n-                hir::BiEq => {\n-                    let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n-                    let extra_eq = ICmp(bcx, llvm::IntEQ, lhs_extra, rhs_extra, debug_loc);\n-                    And(bcx, addr_eq, extra_eq, debug_loc)\n-                }\n-                hir::BiNe => {\n-                    let addr_eq = ICmp(bcx, llvm::IntNE, lhs_addr, rhs_addr, debug_loc);\n-                    let extra_eq = ICmp(bcx, llvm::IntNE, lhs_extra, rhs_extra, debug_loc);\n-                    Or(bcx, addr_eq, extra_eq, debug_loc)\n-                }\n-                hir::BiLe | hir::BiLt | hir::BiGe | hir::BiGt => {\n-                    // a OP b ~ a.0 STRICT(OP) b.0 | (a.0 == b.0 && a.1 OP a.1)\n-                    let (op, strict_op) = match op {\n-                        hir::BiLt => (llvm::IntULT, llvm::IntULT),\n-                        hir::BiLe => (llvm::IntULE, llvm::IntULT),\n-                        hir::BiGt => (llvm::IntUGT, llvm::IntUGT),\n-                        hir::BiGe => (llvm::IntUGE, llvm::IntUGT),\n-                        _ => unreachable!()\n-                    };\n-\n-                    let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n-                    let extra_op = ICmp(bcx, op, lhs_extra, rhs_extra, debug_loc);\n-                    let addr_eq_extra_op = And(bcx, addr_eq, extra_op, debug_loc);\n-\n-                    let addr_strict = ICmp(bcx, strict_op, lhs_addr, rhs_addr, debug_loc);\n-                    Or(bcx, addr_strict, addr_eq_extra_op, debug_loc)\n-                }\n-                _ => {\n-                    bcx.tcx().sess.bug(\"unexpected fat ptr binop\");\n-                }\n-            }\n+            compare_fat_ptrs(bcx,\n+                             lhs_addr, lhs_extra,\n+                             rhs_addr, rhs_extra,\n+                             t, op, debug_loc)\n         }\n         ty::TyInt(_) => {\n             ICmp(bcx, bin_op_to_icmp_predicate(bcx.ccx(), op, true), lhs, rhs, debug_loc)\n@@ -883,6 +897,25 @@ pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t\n     }\n }\n \n+pub fn store_fat_ptr<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                 data: ValueRef,\n+                                 extra: ValueRef,\n+                                 dst: ValueRef,\n+                                 _ty: Ty<'tcx>) {\n+    // FIXME: emit metadata\n+    Store(cx, data, expr::get_dataptr(cx, dst));\n+    Store(cx, extra, expr::get_meta(cx, dst));\n+}\n+\n+pub fn load_fat_ptr<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                src: ValueRef,\n+                                _ty: Ty<'tcx>) -> (ValueRef, ValueRef)\n+{\n+    // FIXME: emit metadata\n+    (Load(cx, expr::get_dataptr(cx, src)),\n+     Load(cx, expr::get_meta(cx, src)))\n+}\n+\n pub fn from_arg_ty(bcx: Block, val: ValueRef, ty: Ty) -> ValueRef {\n     if ty.is_bool() {\n         ZExt(bcx, val, Type::i8(bcx.ccx()))"}, {"sha": "fc76d1e787da5119802ce3ce37e763c0384ef066", "filename": "src/librustc_trans/trans/mir/analyze.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dcb64b52a241406f77d84572c90a71a366fc3c37/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb64b52a241406f77d84572c90a71a366fc3c37/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fanalyze.rs?ref=dcb64b52a241406f77d84572c90a71a366fc3c37", "patch": "@@ -27,16 +27,15 @@ pub fn lvalue_temps<'bcx,'tcx>(bcx: Block<'bcx,'tcx>,\n     for (index, temp_decl) in mir.temp_decls.iter().enumerate() {\n         let ty = bcx.monomorphize(&temp_decl.ty);\n         debug!(\"temp {:?} has type {:?}\", index, ty);\n-        if\n-            (ty.is_scalar() ||\n-             ty.is_unique() ||\n-             ty.is_region_ptr() ||\n-             ty.is_simd())\n-            && !common::type_is_fat_ptr(bcx.tcx(), ty)\n+        if ty.is_scalar() ||\n+            ty.is_unique() ||\n+            ty.is_region_ptr() ||\n+            ty.is_simd()\n         {\n             // These sorts of types are immediates that we can store\n             // in an ValueRef without an alloca.\n-            assert!(common::type_is_immediate(bcx.ccx(), ty));\n+            assert!(common::type_is_immediate(bcx.ccx(), ty) ||\n+                    common::type_is_fat_ptr(bcx.tcx(), ty));\n         } else {\n             // These sorts of types require an alloca. Note that\n             // type_is_immediate() may *still* be true, particularly"}, {"sha": "181a03790eeec1eb557856d3b58c1358cf458046", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcb64b52a241406f77d84572c90a71a366fc3c37/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb64b52a241406f77d84572c90a71a366fc3c37/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=dcb64b52a241406f77d84572c90a71a366fc3c37", "patch": "@@ -43,7 +43,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let cond = self.trans_operand(bcx, cond);\n                 let lltrue = self.llblock(true_bb);\n                 let llfalse = self.llblock(false_bb);\n-                build::CondBr(bcx, cond.llval, lltrue, llfalse, DebugLoc::None);\n+                build::CondBr(bcx, cond.immediate(), lltrue, llfalse, DebugLoc::None);\n             }\n \n             mir::Terminator::Switch { .. } => {\n@@ -55,7 +55,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let discr = build::Load(bcx, self.trans_lvalue(bcx, discr).llval);\n                 let switch = build::Switch(bcx, discr, self.llblock(*otherwise), values.len());\n                 for (value, target) in values.iter().zip(targets) {\n-                    let llval = self.trans_constval(bcx, value, switch_ty);\n+                    let llval = self.trans_constval(bcx, value, switch_ty).immediate();\n                     let llbb = self.llblock(*target);\n                     build::AddCase(switch, llval, llbb)\n                 }"}, {"sha": "923baf0dcfe112a86c959d357b104078483f9613", "filename": "src/librustc_trans/trans/mir/constant.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/dcb64b52a241406f77d84572c90a71a366fc3c37/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb64b52a241406f77d84572c90a71a366fc3c37/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs?ref=dcb64b52a241406f77d84572c90a71a366fc3c37", "patch": "@@ -8,35 +8,39 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::ValueRef;\n use middle::ty::Ty;\n use rustc::middle::const_eval::ConstVal;\n use rustc_mir::repr as mir;\n use trans::consts::{self, TrueConst};\n use trans::common::{self, Block};\n+use trans::common::{C_bool, C_bytes, C_floating_f64, C_integral, C_str_slice};\n use trans::type_of;\n \n+use super::operand::{OperandRef, OperandValue};\n use super::MirContext;\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_constval(&mut self,\n                           bcx: Block<'bcx, 'tcx>,\n                           cv: &ConstVal,\n                           ty: Ty<'tcx>)\n-                          -> ValueRef\n+                          -> OperandRef<'tcx>\n     {\n         let ccx = bcx.ccx();\n         let llty = type_of::type_of(ccx, ty);\n-        match *cv {\n-            ConstVal::Float(v) => common::C_floating_f64(v, llty),\n-            ConstVal::Bool(v) => common::C_bool(ccx, v),\n-            ConstVal::Int(v) => common::C_integral(llty, v as u64, true),\n-            ConstVal::Uint(v) => common::C_integral(llty, v, false),\n-            ConstVal::Str(ref v) => common::C_str_slice(ccx, v.clone()),\n-            ConstVal::ByteStr(ref v) => consts::addr_of(ccx,\n-                                                        common::C_bytes(ccx, v),\n-                                                        1,\n-                                                        \"byte_str\"),\n+        let val = match *cv {\n+            ConstVal::Float(v) => OperandValue::Imm(C_floating_f64(v, llty)),\n+            ConstVal::Bool(v) => OperandValue::Imm(C_bool(ccx, v)),\n+            ConstVal::Int(v) => OperandValue::Imm(C_integral(llty, v as u64, true)),\n+            ConstVal::Uint(v) => OperandValue::Imm(C_integral(llty, v, false)),\n+            ConstVal::Str(ref v) => OperandValue::Imm(C_str_slice(ccx, v.clone())),\n+            ConstVal::ByteStr(ref v) => {\n+                OperandValue::Imm(consts::addr_of(ccx,\n+                                                  C_bytes(ccx, v),\n+                                                  1,\n+                                                  \"byte_str\"))\n+            }\n+\n             ConstVal::Struct(id) | ConstVal::Tuple(id) => {\n                 let expr = bcx.tcx().map.expect_expr(id);\n                 let (llval, _) = match consts::const_expr(ccx,\n@@ -47,18 +51,26 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     Ok(v) => v,\n                     Err(_) => panic!(\"constant eval failure\"),\n                 };\n-                llval\n+                if common::type_is_immediate(bcx.ccx(), ty) {\n+                    OperandValue::Imm(llval)\n+                } else {\n+                    OperandValue::Ref(llval)\n+                }\n             }\n             ConstVal::Function(_) => {\n                 unimplemented!()\n             }\n+        };\n+        OperandRef {\n+            ty: ty,\n+            val: val\n         }\n     }\n \n     pub fn trans_constant(&mut self,\n                           bcx: Block<'bcx, 'tcx>,\n                           constant: &mir::Constant<'tcx>)\n-                          -> ValueRef\n+                          -> OperandRef<'tcx>\n     {\n         let constant_ty = bcx.monomorphize(&constant.ty);\n         match constant.literal {"}, {"sha": "d846307dc78927ac05f401bd5ac90544d60bbb98", "filename": "src/librustc_trans/trans/mir/lvalue.rs", "status": "modified", "additions": 39, "deletions": 23, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/dcb64b52a241406f77d84572c90a71a366fc3c37/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb64b52a241406f77d84572c90a71a366fc3c37/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs?ref=dcb64b52a241406f77d84572c90a71a366fc3c37", "patch": "@@ -18,7 +18,8 @@ use trans::build;\n use trans::common::{self, Block};\n use trans::debuginfo::DebugLoc;\n use trans::machine;\n-use trans::tvec;\n+\n+use std::ptr;\n \n use super::{MirContext, TempRef};\n \n@@ -27,13 +28,16 @@ pub struct LvalueRef<'tcx> {\n     /// Pointer to the contents of the lvalue\n     pub llval: ValueRef,\n \n+    /// This lvalue's extra data if it is unsized, or null\n+    pub llextra: ValueRef,\n+\n     /// Monomorphized type of this lvalue, including variant information\n     pub ty: LvalueTy<'tcx>,\n }\n \n impl<'tcx> LvalueRef<'tcx> {\n-    pub fn new(llval: ValueRef, lvalue_ty: LvalueTy<'tcx>) -> LvalueRef<'tcx> {\n-        LvalueRef { llval: llval, ty: lvalue_ty }\n+    pub fn new_sized(llval: ValueRef, lvalue_ty: LvalueTy<'tcx>) -> LvalueRef<'tcx> {\n+        LvalueRef { llval: llval, llextra: ptr::null_mut(), ty: lvalue_ty }\n     }\n \n     pub fn alloca<'bcx>(bcx: Block<'bcx, 'tcx>,\n@@ -42,11 +46,18 @@ impl<'tcx> LvalueRef<'tcx> {\n                         -> LvalueRef<'tcx>\n     {\n         let lltemp = base::alloc_ty(bcx, ty, name);\n-        LvalueRef::new(lltemp, LvalueTy::from_ty(ty))\n+        LvalueRef::new_sized(lltemp, LvalueTy::from_ty(ty))\n     }\n }\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+    pub fn lvalue_len(&mut self,\n+                      _bcx: Block<'bcx, 'tcx>,\n+                      _lvalue: LvalueRef<'tcx>)\n+                      -> ValueRef {\n+        unimplemented!()\n+    }\n+\n     pub fn trans_lvalue(&mut self,\n                         bcx: Block<'bcx, 'tcx>,\n                         lvalue: &mir::Lvalue<'tcx>)\n@@ -72,15 +83,20 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Lvalue::ReturnPointer => {\n                 let return_ty = bcx.monomorphize(&self.mir.return_ty);\n                 let llval = fcx.get_ret_slot(bcx, return_ty, \"return\");\n-                LvalueRef::new(llval, LvalueTy::from_ty(return_ty.unwrap()))\n+                LvalueRef::new_sized(llval, LvalueTy::from_ty(return_ty.unwrap()))\n             }\n             mir::Lvalue::Projection(ref projection) => {\n                 let tr_base = self.trans_lvalue(bcx, &projection.base);\n                 let projected_ty = tr_base.ty.projection_ty(tcx, &projection.elem);\n-                let llprojected = match projection.elem {\n+                let (llprojected, llextra) = match projection.elem {\n                     mir::ProjectionElem::Deref => {\n                         let base_ty = tr_base.ty.to_ty(tcx);\n-                        base::load_ty(bcx, tr_base.llval, base_ty)\n+                        if common::type_is_sized(tcx, projected_ty.to_ty(tcx)) {\n+                            (base::load_ty(bcx, tr_base.llval, base_ty),\n+                             ptr::null_mut())\n+                        } else {\n+                            base::load_fat_ptr(bcx, tr_base.llval, base_ty)\n+                        }\n                     }\n                     mir::ProjectionElem::Field(ref field) => {\n                         let base_ty = tr_base.ty.to_ty(tcx);\n@@ -90,44 +106,44 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             LvalueTy::Downcast { adt_def: _, substs: _, variant_index: v } => v,\n                         };\n                         let discr = discr as u64;\n-                        adt::trans_field_ptr(bcx, &base_repr, tr_base.llval, discr, field.index())\n+                        (adt::trans_field_ptr(bcx, &base_repr, tr_base.llval, discr, field.index()),\n+                         if common::type_is_sized(tcx, projected_ty.to_ty(tcx)) {\n+                             ptr::null_mut()\n+                         } else {\n+                             tr_base.llextra\n+                         })\n                     }\n                     mir::ProjectionElem::Index(ref index) => {\n-                        let base_ty = tr_base.ty.to_ty(tcx);\n                         let index = self.trans_operand(bcx, index);\n-                        let llindex = self.prepare_index(bcx, index.llval);\n-                        let (llbase, _) = tvec::get_base_and_len(bcx, tr_base.llval, base_ty);\n-                        build::InBoundsGEP(bcx, llbase, &[llindex])\n+                        let llindex = self.prepare_index(bcx, index.immediate());\n+                        (build::InBoundsGEP(bcx, tr_base.llval, &[llindex]),\n+                         ptr::null_mut())\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n-                        let base_ty = tr_base.ty.to_ty(tcx);\n                         let lloffset = common::C_u32(bcx.ccx(), offset);\n                         let llindex = self.prepare_index(bcx, lloffset);\n-                        let (llbase, _) = tvec::get_base_and_len(bcx,\n-                                                                 tr_base.llval,\n-                                                                 base_ty);\n-                        build::InBoundsGEP(bcx, llbase, &[llindex])\n+                        (build::InBoundsGEP(bcx, tr_base.llval, &[llindex]),\n+                         ptr::null_mut())\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n                         let lloffset = common::C_u32(bcx.ccx(), offset);\n-                        let base_ty = tr_base.ty.to_ty(tcx);\n-                        let (llbase, lllen) = tvec::get_base_and_len(bcx,\n-                                                                     tr_base.llval,\n-                                                                     base_ty);\n+                        let lllen = self.lvalue_len(bcx, tr_base);\n                         let llindex = build::Sub(bcx, lllen, lloffset, DebugLoc::None);\n                         let llindex = self.prepare_index(bcx, llindex);\n-                        build::InBoundsGEP(bcx, llbase, &[llindex])\n+                        (build::InBoundsGEP(bcx, tr_base.llval, &[llindex]),\n+                         ptr::null_mut())\n                     }\n                     mir::ProjectionElem::Downcast(..) => {\n-                        tr_base.llval\n+                        (tr_base.llval, tr_base.llextra)\n                     }\n                 };\n                 LvalueRef {\n                     llval: llprojected,\n+                    llextra: llextra,\n                     ty: projected_ty,\n                 }\n             }"}, {"sha": "c8eef7ff4487d8d4d5474e21edb3237d3049a3a6", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcb64b52a241406f77d84572c90a71a366fc3c37/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb64b52a241406f77d84572c90a71a366fc3c37/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=dcb64b52a241406f77d84572c90a71a366fc3c37", "patch": "@@ -180,7 +180,7 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: Block<'bcx, 'tcx>,\n                base::store_ty(bcx, llarg, lltemp, arg_ty);\n                lltemp\n            };\n-           LvalueRef::new(llval, LvalueTy::from_ty(arg_ty))\n+           LvalueRef::new_sized(llval, LvalueTy::from_ty(arg_ty))\n        })\n        .collect()\n }"}, {"sha": "7daf76a8d31ea41a8616c9b7899f62c2ca3c4e78", "filename": "src/librustc_trans/trans/mir/operand.rs", "status": "modified", "additions": 75, "deletions": 17, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/dcb64b52a241406f77d84572c90a71a366fc3c37/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb64b52a241406f77d84572c90a71a366fc3c37/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs?ref=dcb64b52a241406f77d84572c90a71a366fc3c37", "patch": "@@ -12,22 +12,64 @@ use llvm::ValueRef;\n use rustc::middle::ty::Ty;\n use rustc_mir::repr as mir;\n use trans::base;\n-use trans::build;\n-use trans::common::Block;\n+use trans::common::{self, Block};\n use trans::datum;\n \n use super::{MirContext, TempRef};\n \n+/// The Rust representation of an operand's value. This is uniquely\n+/// determined by the operand type, but is kept as an enum as a\n+/// safety check.\n+#[derive(Copy, Clone)]\n+pub enum OperandValue {\n+    /// A reference to the actual operand. The data is guaranteed\n+    /// to be valid for the operand's lifetime.\n+    Ref(ValueRef),\n+    /// A single LLVM value.\n+    Imm(ValueRef),\n+    /// A fat pointer. The first ValueRef is the data and the second\n+    /// is the extra.\n+    FatPtr(ValueRef, ValueRef)\n+}\n+\n #[derive(Copy, Clone)]\n pub struct OperandRef<'tcx> {\n     // This will be \"indirect\" if `appropriate_rvalue_mode` returns\n     // ByRef, and otherwise ByValue.\n-    pub llval: ValueRef,\n+    pub val: OperandValue,\n \n     // The type of value being returned.\n     pub ty: Ty<'tcx>\n }\n \n+impl<'tcx> OperandRef<'tcx> {\n+    pub fn immediate(self) -> ValueRef {\n+        match self.val {\n+            OperandValue::Imm(s) => s,\n+            _ => unreachable!()\n+        }\n+    }\n+\n+    pub fn repr<'bcx>(self, bcx: Block<'bcx, 'tcx>) -> String {\n+        match self.val {\n+            OperandValue::Ref(r) => {\n+                format!(\"OperandRef(Ref({}) @ {:?})\",\n+                        bcx.val_to_string(r), self.ty)\n+            }\n+            OperandValue::Imm(i) => {\n+                format!(\"OperandRef(Imm({}) @ {:?})\",\n+                        bcx.val_to_string(i), self.ty)\n+            }\n+            OperandValue::FatPtr(a, d) => {\n+                format!(\"OperandRef(FatPtr({}, {}) @ {:?})\",\n+                        bcx.val_to_string(a),\n+                        bcx.val_to_string(d),\n+                        self.ty)\n+            }\n+        }\n+    }\n+}\n+\n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_operand(&mut self,\n                          bcx: Block<'bcx, 'tcx>,\n@@ -62,23 +104,24 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 debug!(\"trans_operand: tr_lvalue={} @ {:?}\",\n                        bcx.val_to_string(tr_lvalue.llval),\n                        ty);\n-                let llval = match datum::appropriate_rvalue_mode(bcx.ccx(), ty) {\n-                    datum::ByValue => build::Load(bcx, tr_lvalue.llval),\n-                    datum::ByRef => tr_lvalue.llval,\n+                let val = match datum::appropriate_rvalue_mode(bcx.ccx(), ty) {\n+                    datum::ByValue => {\n+                        OperandValue::Imm(base::load_ty(bcx, tr_lvalue.llval, ty))\n+                    }\n+                    datum::ByRef if common::type_is_fat_ptr(bcx.tcx(), ty) => {\n+                        let (lldata, llextra) = base::load_fat_ptr(bcx, tr_lvalue.llval, ty);\n+                        OperandValue::FatPtr(lldata, llextra)\n+                    }\n+                    datum::ByRef => OperandValue::Ref(tr_lvalue.llval)\n                 };\n                 OperandRef {\n-                    llval: llval,\n+                    val: val,\n                     ty: ty\n                 }\n             }\n \n             mir::Operand::Constant(ref constant) => {\n-                let llval = self.trans_constant(bcx, constant);\n-                let ty = bcx.monomorphize(&constant.ty);\n-                OperandRef {\n-                    llval: llval,\n-                    ty: ty,\n-                }\n+                self.trans_constant(bcx, constant)\n             }\n         }\n     }\n@@ -92,10 +135,25 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                bcx.val_to_string(lldest),\n                operand);\n \n+        // FIXME: consider not copying constants through the\n+        // stack.\n+\n         let o = self.trans_operand(bcx, operand);\n-        match datum::appropriate_rvalue_mode(bcx.ccx(), o.ty) {\n-            datum::ByValue => base::store_ty(bcx, o.llval, lldest, o.ty),\n-            datum::ByRef => base::memcpy_ty(bcx, lldest, o.llval, o.ty),\n-        };\n+        self.store_operand(bcx, lldest, o);\n+    }\n+\n+    pub fn store_operand(&mut self,\n+                         bcx: Block<'bcx, 'tcx>,\n+                         lldest: ValueRef,\n+                         operand: OperandRef<'tcx>)\n+    {\n+        debug!(\"store_operand: operand={}\", operand.repr(bcx));\n+        match operand.val {\n+            OperandValue::Ref(r) => base::memcpy_ty(bcx, lldest, r, operand.ty),\n+            OperandValue::Imm(s) => base::store_ty(bcx, s, lldest, operand.ty),\n+            OperandValue::FatPtr(data, extra) => {\n+                base::store_fat_ptr(bcx, data, extra, lldest, operand.ty);\n+            }\n+        }\n     }\n }"}, {"sha": "f933252b51e49873c690b497753128ec6a47ae39", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 153, "deletions": 115, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/dcb64b52a241406f77d84572c90a71a366fc3c37/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb64b52a241406f77d84572c90a71a366fc3c37/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=dcb64b52a241406f77d84572c90a71a366fc3c37", "patch": "@@ -26,7 +26,7 @@ use trans::type_of;\n use trans::tvec;\n \n use super::MirContext;\n-use super::operand::OperandRef;\n+use super::operand::{OperandRef, OperandValue};\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n@@ -64,11 +64,11 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n             mir::Rvalue::Repeat(ref elem, ref count) => {\n                 let elem = self.trans_operand(bcx, elem);\n-                let size = self.trans_constant(bcx, count);\n+                let size = self.trans_constant(bcx, count).immediate();\n                 let base = expr::get_dataptr(bcx, lldest);\n-                tvec::iter_vec_raw(bcx, base, elem.ty, size, |b, vref, _| {\n-                    build::Store(b, elem.llval, vref);\n-                    b\n+                tvec::iter_vec_raw(bcx, base, elem.ty, size, |bcx, llslot, _| {\n+                    self.store_operand(bcx, llslot, elem);\n+                    bcx\n                 })\n             }\n \n@@ -106,7 +106,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             _ => {\n                 assert!(rvalue_creates_operand(rvalue));\n                 let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                base::store_ty(bcx, temp.llval, lldest, temp.ty);\n+                self.store_operand(bcx, lldest, temp);\n                 bcx\n             }\n         }\n@@ -136,145 +136,73 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Rvalue::Ref(_, _, ref lvalue) => {\n                 let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n \n+                let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n                 // Note: lvalues are indirect, so storing the `llval` into the\n                 // destination effectively creates a reference.\n-                (bcx, OperandRef {\n-                    llval: tr_lvalue.llval,\n-                    ty: tr_lvalue.ty.to_ty(bcx.tcx()),\n-                })\n+                if common::type_is_sized(bcx.tcx(), ty) {\n+                    (bcx, OperandRef {\n+                        val: OperandValue::Imm(tr_lvalue.llval),\n+                        ty: ty,\n+                    })\n+                } else {\n+                    (bcx, OperandRef {\n+                        val: OperandValue::FatPtr(tr_lvalue.llval,\n+                                                  tr_lvalue.llextra),\n+                        ty: ty,\n+                    })\n+                }\n             }\n \n             mir::Rvalue::Len(ref lvalue) => {\n                 let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n-                let (_, lllen) = tvec::get_base_and_len(bcx,\n-                                                        tr_lvalue.llval,\n-                                                        tr_lvalue.ty.to_ty(bcx.tcx()));\n                 (bcx, OperandRef {\n-                    llval: lllen,\n+                    val: OperandValue::Imm(self.lvalue_len(bcx, tr_lvalue)),\n                     ty: bcx.tcx().types.usize,\n                 })\n             }\n \n             mir::Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n                 let lhs = self.trans_operand(bcx, lhs);\n                 let rhs = self.trans_operand(bcx, rhs);\n-                let is_float = lhs.ty.is_fp();\n-                let is_signed = lhs.ty.is_signed();\n-                let binop_debug_loc = DebugLoc::None;\n-                let llval = match op {\n-                    mir::BinOp::Add => if is_float {\n-                        build::FAdd(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    } else {\n-                        build::Add(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    },\n-                    mir::BinOp::Sub => if is_float {\n-                        build::FSub(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    } else {\n-                        build::Sub(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    },\n-                    mir::BinOp::Mul => if is_float {\n-                        build::FMul(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    } else {\n-                        build::Mul(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    },\n-                    mir::BinOp::Div => if is_float {\n-                        build::FDiv(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    } else if is_signed {\n-                        build::SDiv(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    } else {\n-                        build::UDiv(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    },\n-                    mir::BinOp::Rem => if is_float {\n-                        // LLVM currently always lowers the `frem` instructions appropriate\n-                        // library calls typically found in libm. Notably f64 gets wired up\n-                        // to `fmod` and f32 gets wired up to `fmodf`. Inconveniently for\n-                        // us, 32-bit MSVC does not actually have a `fmodf` symbol, it's\n-                        // instead just an inline function in a header that goes up to a\n-                        // f64, uses `fmod`, and then comes back down to a f32.\n-                        //\n-                        // Although LLVM knows that `fmodf` doesn't exist on MSVC, it will\n-                        // still unconditionally lower frem instructions over 32-bit floats\n-                        // to a call to `fmodf`. To work around this we special case MSVC\n-                        // 32-bit float rem instructions and instead do the call out to\n-                        // `fmod` ourselves.\n-                        //\n-                        // Note that this is currently duplicated with src/libcore/ops.rs\n-                        // which does the same thing, and it would be nice to perhaps unify\n-                        // these two implementations one day! Also note that we call `fmod`\n-                        // for both 32 and 64-bit floats because if we emit any FRem\n-                        // instruction at all then LLVM is capable of optimizing it into a\n-                        // 32-bit FRem (which we're trying to avoid).\n-                        let tcx = bcx.tcx();\n-                        let use_fmod = tcx.sess.target.target.options.is_like_msvc &&\n-                            tcx.sess.target.target.arch == \"x86\";\n-                        if use_fmod {\n-                            let f64t = Type::f64(bcx.ccx());\n-                            let fty = Type::func(&[f64t, f64t], &f64t);\n-                            let llfn = declare::declare_cfn(bcx.ccx(), \"fmod\", fty,\n-                                                            tcx.types.f64);\n-                            if lhs.ty == tcx.types.f32 {\n-                                let lllhs = build::FPExt(bcx, lhs.llval, f64t);\n-                                let llrhs = build::FPExt(bcx, rhs.llval, f64t);\n-                                let llres = build::Call(bcx, llfn, &[lllhs, llrhs],\n-                                                        None, binop_debug_loc);\n-                                build::FPTrunc(bcx, llres, Type::f32(bcx.ccx()))\n-                            } else {\n-                                build::Call(bcx, llfn, &[lhs.llval, rhs.llval],\n-                                            None, binop_debug_loc)\n-                            }\n-                        } else {\n-                            build::FRem(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                let llresult = if common::type_is_fat_ptr(bcx.tcx(), lhs.ty) {\n+                    match (lhs.val, rhs.val) {\n+                        (OperandValue::FatPtr(lhs_addr, lhs_extra),\n+                         OperandValue::FatPtr(rhs_addr, rhs_extra)) => {\n+                            base::compare_fat_ptrs(bcx,\n+                                                   lhs_addr, lhs_extra,\n+                                                   rhs_addr, rhs_extra,\n+                                                   lhs.ty, cmp_to_hir_cmp(op),\n+                                                   DebugLoc::None)\n                         }\n-                    } else if is_signed {\n-                        build::SRem(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    } else {\n-                        build::URem(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n-                    },\n-                    mir::BinOp::BitOr => build::Or(bcx, lhs.llval, rhs.llval, binop_debug_loc),\n-                    mir::BinOp::BitAnd => build::And(bcx, lhs.llval, rhs.llval, binop_debug_loc),\n-                    mir::BinOp::BitXor => build::Xor(bcx, lhs.llval, rhs.llval, binop_debug_loc),\n-                    mir::BinOp::Shl => common::build_unchecked_lshift(bcx,\n-                                                                      lhs.llval,\n-                                                                      rhs.llval,\n-                                                                      binop_debug_loc),\n-                    mir::BinOp::Shr => common::build_unchecked_rshift(bcx,\n-                                                                      lhs.ty,\n-                                                                      lhs.llval,\n-                                                                      rhs.llval,\n-                                                                      binop_debug_loc),\n-                    mir::BinOp::Eq => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n-                                                                 hir::BiEq, binop_debug_loc),\n-                    mir::BinOp::Lt => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n-                                                                 hir::BiLt, binop_debug_loc),\n-                    mir::BinOp::Le => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n-                                                                 hir::BiLe, binop_debug_loc),\n-                    mir::BinOp::Ne => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n-                                                                 hir::BiNe, binop_debug_loc),\n-                    mir::BinOp::Ge => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n-                                                                 hir::BiGe, binop_debug_loc),\n-                    mir::BinOp::Gt => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n-                                                                 hir::BiGt, binop_debug_loc),\n+                        _ => unreachable!()\n+                    }\n+\n+                } else {\n+                    self.trans_scalar_binop(bcx, op,\n+                                            lhs.immediate(), rhs.immediate(),\n+                                            lhs.ty, DebugLoc::None)\n                 };\n                 (bcx, OperandRef {\n-                    llval: llval,\n+                    val: OperandValue::Imm(llresult),\n                     ty: type_of_binop(bcx.tcx(), op, lhs.ty, rhs.ty),\n                 })\n             }\n \n             mir::Rvalue::UnaryOp(op, ref operand) => {\n                 let operand = self.trans_operand(bcx, operand);\n+                let lloperand = operand.immediate();\n                 let is_float = operand.ty.is_fp();\n                 let debug_loc = DebugLoc::None;\n                 let llval = match op {\n-                    mir::UnOp::Not => build::Not(bcx, operand.llval, debug_loc),\n+                    mir::UnOp::Not => build::Not(bcx, lloperand, debug_loc),\n                     mir::UnOp::Neg => if is_float {\n-                        build::FNeg(bcx, operand.llval, debug_loc)\n+                        build::FNeg(bcx, lloperand, debug_loc)\n                     } else {\n-                        build::Neg(bcx, operand.llval, debug_loc)\n+                        build::Neg(bcx, lloperand, debug_loc)\n                     }\n                 };\n                 (bcx, OperandRef {\n-                    llval: llval,\n+                    val: OperandValue::Imm(llval),\n                     ty: operand.ty,\n                 })\n             }\n@@ -294,7 +222,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                                       llalign,\n                                                                       DebugLoc::None);\n                 (bcx, OperandRef {\n-                    llval: llval,\n+                    val: OperandValue::Imm(llval),\n                     ty: box_ty,\n                 })\n             }\n@@ -307,6 +235,104 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n         }\n     }\n+\n+    pub fn trans_scalar_binop(&mut self,\n+                              bcx: Block<'bcx, 'tcx>,\n+                              op: mir::BinOp,\n+                              lhs: ValueRef,\n+                              rhs: ValueRef,\n+                              input_ty: Ty<'tcx>,\n+                              debug_loc: DebugLoc) -> ValueRef {\n+        let is_float = input_ty.is_fp();\n+        let is_signed = input_ty.is_signed();\n+        match op {\n+            mir::BinOp::Add => if is_float {\n+                build::FAdd(bcx, lhs, rhs, debug_loc)\n+            } else {\n+                build::Add(bcx, lhs, rhs, debug_loc)\n+            },\n+            mir::BinOp::Sub => if is_float {\n+                build::FSub(bcx, lhs, rhs, debug_loc)\n+            } else {\n+                build::Sub(bcx, lhs, rhs, debug_loc)\n+            },\n+            mir::BinOp::Mul => if is_float {\n+                build::FMul(bcx, lhs, rhs, debug_loc)\n+            } else {\n+                build::Mul(bcx, lhs, rhs, debug_loc)\n+            },\n+            mir::BinOp::Div => if is_float {\n+                build::FDiv(bcx, lhs, rhs, debug_loc)\n+            } else if is_signed {\n+                build::SDiv(bcx, lhs, rhs, debug_loc)\n+            } else {\n+                build::UDiv(bcx, lhs, rhs, debug_loc)\n+            },\n+            mir::BinOp::Rem => if is_float {\n+                // LLVM currently always lowers the `frem` instructions appropriate\n+                // library calls typically found in libm. Notably f64 gets wired up\n+                // to `fmod` and f32 gets wired up to `fmodf`. Inconveniently for\n+                // us, 32-bit MSVC does not actually have a `fmodf` symbol, it's\n+                // instead just an inline function in a header that goes up to a\n+                // f64, uses `fmod`, and then comes back down to a f32.\n+                //\n+                // Although LLVM knows that `fmodf` doesn't exist on MSVC, it will\n+                // still unconditionally lower frem instructions over 32-bit floats\n+                // to a call to `fmodf`. To work around this we special case MSVC\n+                // 32-bit float rem instructions and instead do the call out to\n+                // `fmod` ourselves.\n+                //\n+                // Note that this is currently duplicated with src/libcore/ops.rs\n+                // which does the same thing, and it would be nice to perhaps unify\n+                // these two implementations one day! Also note that we call `fmod`\n+                // for both 32 and 64-bit floats because if we emit any FRem\n+                // instruction at all then LLVM is capable of optimizing it into a\n+                // 32-bit FRem (which we're trying to avoid).\n+                let tcx = bcx.tcx();\n+                let use_fmod = tcx.sess.target.target.options.is_like_msvc &&\n+                    tcx.sess.target.target.arch == \"x86\";\n+                if use_fmod {\n+                    let f64t = Type::f64(bcx.ccx());\n+                    let fty = Type::func(&[f64t, f64t], &f64t);\n+                    let llfn = declare::declare_cfn(bcx.ccx(), \"fmod\", fty,\n+                                                    tcx.types.f64);\n+                    if input_ty == tcx.types.f32 {\n+                        let lllhs = build::FPExt(bcx, lhs, f64t);\n+                        let llrhs = build::FPExt(bcx, rhs, f64t);\n+                        let llres = build::Call(bcx, llfn, &[lllhs, llrhs],\n+                                                None, debug_loc);\n+                        build::FPTrunc(bcx, llres, Type::f32(bcx.ccx()))\n+                    } else {\n+                        build::Call(bcx, llfn, &[lhs, rhs],\n+                                    None, debug_loc)\n+                    }\n+                } else {\n+                    build::FRem(bcx, lhs, rhs, debug_loc)\n+                }\n+            } else if is_signed {\n+                build::SRem(bcx, lhs, rhs, debug_loc)\n+            } else {\n+                build::URem(bcx, lhs, rhs, debug_loc)\n+            },\n+            mir::BinOp::BitOr => build::Or(bcx, lhs, rhs, debug_loc),\n+            mir::BinOp::BitAnd => build::And(bcx, lhs, rhs, debug_loc),\n+            mir::BinOp::BitXor => build::Xor(bcx, lhs, rhs, debug_loc),\n+            mir::BinOp::Shl => common::build_unchecked_lshift(bcx,\n+                                                              lhs,\n+                                                              rhs,\n+                                                              debug_loc),\n+            mir::BinOp::Shr => common::build_unchecked_rshift(bcx,\n+                                                              input_ty,\n+                                                              lhs,\n+                                                              rhs,\n+                                                              debug_loc),\n+            mir::BinOp::Eq | mir::BinOp::Lt | mir::BinOp::Gt |\n+            mir::BinOp::Ne | mir::BinOp::Le | mir::BinOp::Ge => {\n+                base::compare_scalar_types(bcx, lhs, rhs, input_ty,\n+                                           cmp_to_hir_cmp(op), debug_loc)\n+            }\n+        }\n+    }\n }\n \n pub fn rvalue_creates_operand<'tcx>(rvalue: &mir::Rvalue<'tcx>) -> bool {\n@@ -329,6 +355,18 @@ pub fn rvalue_creates_operand<'tcx>(rvalue: &mir::Rvalue<'tcx>) -> bool {\n     // (*) this is only true if the type is suitable\n }\n \n+fn cmp_to_hir_cmp(op: mir::BinOp) -> hir::BinOp_ {\n+    match op {\n+        mir::BinOp::Eq => hir::BiEq,\n+        mir::BinOp::Ne => hir::BiNe,\n+        mir::BinOp::Lt => hir::BiLt,\n+        mir::BinOp::Le => hir::BiLe,\n+        mir::BinOp::Gt => hir::BiGt,\n+        mir::BinOp::Ge => hir::BiGe,\n+        _ => unreachable!()\n+    }\n+}\n+\n /// FIXME(nikomatsakis): I don't think this function should go here\n fn type_of_binop<'tcx>(\n     tcx: &ty::ctxt<'tcx>,"}, {"sha": "1916e608a8c79bdc2139f5ddbe95c09dc4d9e76d", "filename": "src/test/run-pass/mir_fat_ptr.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/dcb64b52a241406f77d84572c90a71a366fc3c37/src%2Ftest%2Frun-pass%2Fmir_fat_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb64b52a241406f77d84572c90a71a366fc3c37/src%2Ftest%2Frun-pass%2Fmir_fat_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_fat_ptr.rs?ref=dcb64b52a241406f77d84572c90a71a366fc3c37", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// test that ordinary fat pointer operations work.\n+\n+#![feature(rustc_attrs)]\n+\n+struct Wrapper<T: ?Sized>(u32, T);\n+\n+struct FatPtrContainer<'a> {\n+    ptr: &'a [u8]\n+}\n+\n+#[rustc_mir]\n+fn fat_ptr_project(a: &Wrapper<[u8]>) -> &[u8] {\n+    &a.1\n+}\n+\n+#[rustc_mir]\n+fn fat_ptr_simple(a: &[u8]) -> &[u8] {\n+    a\n+}\n+\n+#[rustc_mir]\n+fn fat_ptr_via_local(a: &[u8]) -> &[u8] {\n+    let x = a;\n+    x\n+}\n+\n+#[rustc_mir]\n+fn fat_ptr_from_struct(s: FatPtrContainer) -> &[u8] {\n+    s.ptr\n+}\n+\n+#[rustc_mir]\n+fn fat_ptr_to_struct(a: &[u8]) -> FatPtrContainer {\n+    FatPtrContainer { ptr: a }\n+}\n+\n+#[rustc_mir]\n+fn fat_ptr_store_to<'a>(a: &'a [u8], b: &mut &'a [u8]) {\n+    *b = a;\n+}\n+\n+fn main() {\n+    let a = Wrapper(4, [7,6,5]);\n+\n+    let p = fat_ptr_project(&a);\n+    let p = fat_ptr_simple(p);\n+    let p = fat_ptr_via_local(p);\n+    let p = fat_ptr_from_struct(fat_ptr_to_struct(p));\n+\n+    let mut target : &[u8] = &[42];\n+    fat_ptr_store_to(p, &mut target);\n+    assert_eq!(target, &a.1);\n+}"}]}