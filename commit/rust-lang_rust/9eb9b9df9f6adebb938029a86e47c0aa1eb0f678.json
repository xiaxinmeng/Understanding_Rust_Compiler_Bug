{"sha": "9eb9b9df9f6adebb938029a86e47c0aa1eb0f678", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllYjliOWRmOWY2YWRlYmI5MzgwMjlhODZlNDdjMGFhMWViMGY2Nzg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-09T08:34:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-09T08:34:12Z"}, "message": "Merge #5276\n\n5276: Streamline r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "f9ca6a356d794239434a7ef1c9a8ba749834c5f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9ca6a356d794239434a7ef1c9a8ba749834c5f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9eb9b9df9f6adebb938029a86e47c0aa1eb0f678", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfBtaFCRBK7hj4Ov3rIwAAdHIIALK5cw7bECLF6dtIT+n39SyP\nXOWh71F2Ld2JjzqhVs8/JVDCS5OkMFNTt8iiRTSnklNU4T4aZ3zJI467kdfOogM8\nXGsOC+08kEqDHFHqpo+rRciKQOw73X8PU1AMWJFM3VhA4QqyNKFvojlIOJ3S2g0e\nHkRWn0ekm7dNfwzO+Xgu+p3v0o5/BpDnmfvhREEJbfCyOG5hBOebvo2BKE2/ED1r\nU+RoabQov1fN5MurLk5hSOvOEuwYppwnusIvYR92ZMIUAP6Ej/15LP5sL7Ew8vWH\ng4W1W7d3G1ZqK15ZrMUib7N2XMIRVp8YDCtyqGe4zj2Z8WOdJ/jduV7f9Vr+6vY=\n=HK2c\n-----END PGP SIGNATURE-----\n", "payload": "tree f9ca6a356d794239434a7ef1c9a8ba749834c5f6\nparent a61c8481571f8d8e6e08df9024d8dad5efc883de\nparent b9aab22d569c4ffe4d4f544a778bf07441ccf118\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1594283652 +0000\ncommitter GitHub <noreply@github.com> 1594283652 +0000\n\nMerge #5276\n\n5276: Streamline r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9eb9b9df9f6adebb938029a86e47c0aa1eb0f678", "html_url": "https://github.com/rust-lang/rust/commit/9eb9b9df9f6adebb938029a86e47c0aa1eb0f678", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9eb9b9df9f6adebb938029a86e47c0aa1eb0f678/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a61c8481571f8d8e6e08df9024d8dad5efc883de", "url": "https://api.github.com/repos/rust-lang/rust/commits/a61c8481571f8d8e6e08df9024d8dad5efc883de", "html_url": "https://github.com/rust-lang/rust/commit/a61c8481571f8d8e6e08df9024d8dad5efc883de"}, {"sha": "b9aab22d569c4ffe4d4f544a778bf07441ccf118", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9aab22d569c4ffe4d4f544a778bf07441ccf118", "html_url": "https://github.com/rust-lang/rust/commit/b9aab22d569c4ffe4d4f544a778bf07441ccf118"}], "stats": {"total": 277, "additions": 114, "deletions": 163}, "files": [{"sha": "7579a5027917aa686a2aa7ace354e18f4721bdba", "filename": "crates/expect/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9eb9b9df9f6adebb938029a86e47c0aa1eb0f678/crates%2Fexpect%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb9b9df9f6adebb938029a86e47c0aa1eb0f678/crates%2Fexpect%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fexpect%2Fsrc%2Flib.rs?ref=9eb9b9df9f6adebb938029a86e47c0aa1eb0f678", "patch": "@@ -275,7 +275,7 @@ fn format_patch(line_indent: usize, patch: &str) -> String {\n     }\n     let mut final_newline = false;\n     for line in lines_with_ends(patch) {\n-        if is_multiline {\n+        if is_multiline && !line.trim().is_empty() {\n             buf.push_str(indent);\n             buf.push_str(\"    \");\n         }"}, {"sha": "70d2a2dd13c0c8442179621531c2908a602a5d46", "filename": "crates/ra_ide/src/display.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9eb9b9df9f6adebb938029a86e47c0aa1eb0f678/crates%2Fra_ide%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb9b9df9f6adebb938029a86e47c0aa1eb0f678/crates%2Fra_ide%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay.rs?ref=9eb9b9df9f6adebb938029a86e47c0aa1eb0f678", "patch": "@@ -6,13 +6,10 @@ mod navigation_target;\n mod structure;\n mod short_label;\n \n-use std::fmt::Display;\n-\n use ra_syntax::{\n     ast::{self, AstNode, AttrsOwner, NameOwner, TypeParamsOwner},\n     SyntaxKind::{ATTR, COMMENT},\n };\n-use stdx::format_to;\n \n pub use function_signature::FunctionSignature;\n pub use navigation_target::NavigationTarget;\n@@ -69,29 +66,3 @@ pub(crate) fn macro_label(node: &ast::MacroCall) -> String {\n     let vis = if node.has_atom_attr(\"macro_export\") { \"#[macro_export]\\n\" } else { \"\" };\n     format!(\"{}macro_rules! {}\", vis, name)\n }\n-\n-pub(crate) fn rust_code_markup(code: &impl Display) -> String {\n-    rust_code_markup_with_doc(code, None, None)\n-}\n-\n-pub(crate) fn rust_code_markup_with_doc(\n-    code: &impl Display,\n-    doc: Option<&str>,\n-    mod_path: Option<&str>,\n-) -> String {\n-    let mut buf = String::new();\n-\n-    if let Some(mod_path) = mod_path {\n-        if !mod_path.is_empty() {\n-            format_to!(buf, \"```rust\\n{}\\n```\\n\\n\", mod_path);\n-        }\n-    }\n-    format_to!(buf, \"```rust\\n{}\\n```\", code);\n-\n-    if let Some(doc) = doc {\n-        format_to!(buf, \"\\n___\");\n-        format_to!(buf, \"\\n\\n{}\", doc);\n-    }\n-\n-    buf\n-}"}, {"sha": "a4c97e7f98630db6dfdd05a542e1a7a0e6f37672", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 105, "deletions": 125, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/9eb9b9df9f6adebb938029a86e47c0aa1eb0f678/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb9b9df9f6adebb938029a86e47c0aa1eb0f678/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=9eb9b9df9f6adebb938029a86e47c0aa1eb0f678", "patch": "@@ -1,5 +1,3 @@\n-use std::iter::once;\n-\n use hir::{\n     Adt, AsAssocItem, AssocItemContainer, Documentation, FieldSource, HasSource, HirDisplay,\n     Module, ModuleDef, ModuleSource, Semantics,\n@@ -11,16 +9,15 @@ use ra_ide_db::{\n     RootDatabase,\n };\n use ra_syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n+use stdx::format_to;\n+use test_utils::mark;\n \n use crate::{\n-    display::{\n-        macro_label, rust_code_markup, rust_code_markup_with_doc, ShortLabel, ToNav, TryToNav,\n-    },\n+    display::{macro_label, ShortLabel, ToNav, TryToNav},\n     markup::Markup,\n     runnables::runnable,\n     FileId, FilePosition, NavigationTarget, RangeInfo, Runnable,\n };\n-use test_utils::mark;\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct HoverConfig {\n@@ -73,20 +70,6 @@ pub struct HoverResult {\n     pub actions: Vec<HoverAction>,\n }\n \n-impl HoverResult {\n-    pub fn new() -> HoverResult {\n-        Self::default()\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        self.markup.is_empty()\n-    }\n-\n-    fn push_action(&mut self, action: HoverAction) {\n-        self.actions.push(action);\n-    }\n-}\n-\n // Feature: Hover\n //\n // Shows additional information, like type of an expression or documentation for definition when \"focusing\" code.\n@@ -97,38 +80,32 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n     let token = pick_best(file.token_at_offset(position.offset))?;\n     let token = sema.descend_into_macros(token);\n \n-    let mut res = HoverResult::new();\n+    let mut res = HoverResult::default();\n \n     let node = token.parent();\n     let definition = match_ast! {\n         match node {\n-            ast::NameRef(name_ref) => {\n-                classify_name_ref(&sema, &name_ref).map(|d| d.definition())\n-            },\n-            ast::Name(name) => {\n-                classify_name(&sema, &name).map(|d| d.definition())\n-            },\n+            ast::NameRef(name_ref) => classify_name_ref(&sema, &name_ref).map(|d| d.definition()),\n+            ast::Name(name) => classify_name(&sema, &name).map(|d| d.definition()),\n             _ => None,\n         }\n     };\n     if let Some(definition) = definition {\n-        let range = sema.original_range(&node).range;\n-        if let Some(text) = hover_text_from_name_kind(db, definition) {\n-            res.markup.push_section(&text);\n-        }\n-        if !res.is_empty() {\n+        if let Some(markup) = hover_for_definition(db, definition) {\n+            res.markup = markup;\n             if let Some(action) = show_implementations_action(db, definition) {\n-                res.push_action(action);\n+                res.actions.push(action);\n             }\n \n             if let Some(action) = runnable_action(&sema, definition, position.file_id) {\n-                res.push_action(action);\n+                res.actions.push(action);\n             }\n \n             if let Some(action) = goto_type_action(db, definition) {\n-                res.push_action(action);\n+                res.actions.push(action);\n             }\n \n+            let range = sema.original_range(&node).range;\n             return Some(RangeInfo::new(range, res));\n         }\n     }\n@@ -139,22 +116,16 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n \n     let ty = match_ast! {\n         match node {\n-            ast::MacroCall(_it) => {\n-                // If this node is a MACRO_CALL, it means that `descend_into_macros` failed to resolve.\n-                // (e.g expanding a builtin macro). So we give up here.\n-                return None;\n-            },\n-            ast::Expr(it) => {\n-                sema.type_of_expr(&it)\n-            },\n-            ast::Pat(it) => {\n-                sema.type_of_pat(&it)\n-            },\n-            _ => None,\n+            ast::Expr(it) => sema.type_of_expr(&it)?,\n+            ast::Pat(it) => sema.type_of_pat(&it)?,\n+            // If this node is a MACRO_CALL, it means that `descend_into_macros` failed to resolve.\n+            // (e.g expanding a builtin macro). So we give up here.\n+            ast::MacroCall(_it) => return None,\n+            _ => return None,\n         }\n-    }?;\n+    };\n \n-    res.markup.push_section(&rust_code_markup(&ty.display(db)));\n+    res.markup = Markup::fenced_block(&ty.display(db));\n     let range = sema.original_range(&node).range;\n     Some(RangeInfo::new(range, res))\n }\n@@ -235,7 +206,11 @@ fn goto_type_action(db: &RootDatabase, def: Definition) -> Option<HoverAction> {\n                 .into_iter()\n                 .filter_map(|it| {\n                     Some(HoverGotoTypeData {\n-                        mod_path: mod_path(db, &it)?,\n+                        mod_path: render_path(\n+                            db,\n+                            it.module(db)?,\n+                            it.name(db).map(|name| name.to_string()),\n+                        ),\n                         nav: it.try_to_nav(db)?,\n                     })\n                 })\n@@ -247,15 +222,28 @@ fn goto_type_action(db: &RootDatabase, def: Definition) -> Option<HoverAction> {\n     }\n }\n \n-fn hover_text(\n+fn hover_markup(\n     docs: Option<String>,\n     desc: Option<String>,\n     mod_path: Option<String>,\n-) -> Option<String> {\n-    if let Some(desc) = desc {\n-        Some(rust_code_markup_with_doc(&desc, docs.as_deref(), mod_path.as_deref()))\n-    } else {\n-        docs\n+) -> Option<Markup> {\n+    match desc {\n+        Some(desc) => {\n+            let mut buf = String::new();\n+\n+            if let Some(mod_path) = mod_path {\n+                if !mod_path.is_empty() {\n+                    format_to!(buf, \"```rust\\n{}\\n```\\n\\n\", mod_path);\n+                }\n+            }\n+            format_to!(buf, \"```rust\\n{}\\n```\", desc);\n+\n+            if let Some(doc) = docs {\n+                format_to!(buf, \"\\n___\\n\\n{}\", doc);\n+            }\n+            Some(buf.into())\n+        }\n+        None => docs.map(Markup::from),\n     }\n }\n \n@@ -277,43 +265,35 @@ fn definition_owner_name(db: &RootDatabase, def: &Definition) -> Option<String>\n     .map(|name| name.to_string())\n }\n \n-fn determine_mod_path(db: &RootDatabase, module: Module, name: Option<String>) -> String {\n-    once(db.crate_graph()[module.krate().into()].display_name.as_ref().map(ToString::to_string))\n-        .chain(\n-            module\n-                .path_to_root(db)\n-                .into_iter()\n-                .rev()\n-                .map(|it| it.name(db).map(|name| name.to_string())),\n-        )\n-        .chain(once(name))\n-        .flatten()\n-        .join(\"::\")\n-}\n-\n-// returns None only for ModuleDef::BuiltinType\n-fn mod_path(db: &RootDatabase, item: &ModuleDef) -> Option<String> {\n-    Some(determine_mod_path(db, item.module(db)?, item.name(db).map(|name| name.to_string())))\n+fn render_path(db: &RootDatabase, module: Module, item_name: Option<String>) -> String {\n+    let crate_name =\n+        db.crate_graph()[module.krate().into()].display_name.as_ref().map(ToString::to_string);\n+    let module_path = module\n+        .path_to_root(db)\n+        .into_iter()\n+        .rev()\n+        .flat_map(|it| it.name(db).map(|name| name.to_string()));\n+    crate_name.into_iter().chain(module_path).chain(item_name).join(\"::\")\n }\n \n fn definition_mod_path(db: &RootDatabase, def: &Definition) -> Option<String> {\n-    def.module(db).map(|module| determine_mod_path(db, module, definition_owner_name(db, def)))\n+    def.module(db).map(|module| render_path(db, module, definition_owner_name(db, def)))\n }\n \n-fn hover_text_from_name_kind(db: &RootDatabase, def: Definition) -> Option<String> {\n+fn hover_for_definition(db: &RootDatabase, def: Definition) -> Option<Markup> {\n     let mod_path = definition_mod_path(db, &def);\n     return match def {\n         Definition::Macro(it) => {\n             let src = it.source(db);\n             let docs = Documentation::from_ast(&src.value).map(Into::into);\n-            hover_text(docs, Some(macro_label(&src.value)), mod_path)\n+            hover_markup(docs, Some(macro_label(&src.value)), mod_path)\n         }\n         Definition::Field(it) => {\n             let src = it.source(db);\n             match src.value {\n                 FieldSource::Named(it) => {\n                     let docs = Documentation::from_ast(&it).map(Into::into);\n-                    hover_text(docs, it.short_label(), mod_path)\n+                    hover_markup(docs, it.short_label(), mod_path)\n                 }\n                 _ => None,\n             }\n@@ -322,7 +302,7 @@ fn hover_text_from_name_kind(db: &RootDatabase, def: Definition) -> Option<Strin\n             ModuleDef::Module(it) => match it.definition_source(db).value {\n                 ModuleSource::Module(it) => {\n                     let docs = Documentation::from_ast(&it).map(Into::into);\n-                    hover_text(docs, it.short_label(), mod_path)\n+                    hover_markup(docs, it.short_label(), mod_path)\n                 }\n                 _ => None,\n             },\n@@ -335,23 +315,23 @@ fn hover_text_from_name_kind(db: &RootDatabase, def: Definition) -> Option<Strin\n             ModuleDef::Static(it) => from_def_source(db, it, mod_path),\n             ModuleDef::Trait(it) => from_def_source(db, it, mod_path),\n             ModuleDef::TypeAlias(it) => from_def_source(db, it, mod_path),\n-            ModuleDef::BuiltinType(it) => Some(it.to_string()),\n+            ModuleDef::BuiltinType(it) => return Some(it.to_string().into()),\n         },\n-        Definition::Local(it) => Some(rust_code_markup(&it.ty(db).display(db))),\n+        Definition::Local(it) => return Some(Markup::fenced_block(&it.ty(db).display(db))),\n         Definition::TypeParam(_) | Definition::SelfType(_) => {\n             // FIXME: Hover for generic param\n             None\n         }\n     };\n \n-    fn from_def_source<A, D>(db: &RootDatabase, def: D, mod_path: Option<String>) -> Option<String>\n+    fn from_def_source<A, D>(db: &RootDatabase, def: D, mod_path: Option<String>) -> Option<Markup>\n     where\n         D: HasSource<Ast = A>,\n         A: ast::DocCommentsOwner + ast::NameOwner + ShortLabel + ast::AttrsOwner,\n     {\n         let src = def.source(db);\n         let docs = Documentation::from_ast(&src.value).map(Into::into);\n-        hover_text(docs, src.value.short_label(), mod_path)\n+        hover_markup(docs, src.value.short_label(), mod_path)\n     }\n }\n \n@@ -388,7 +368,7 @@ mod tests {\n         let content = analysis.db.file_text(position.file_id);\n         let hovered_element = &content[hover.range];\n \n-        let actual = format!(\"{}:\\n{}\\n\", hovered_element, hover.info.markup);\n+        let actual = format!(\"*{}*\\n{}\\n\", hovered_element, hover.info.markup);\n         expect.assert_eq(&actual)\n     }\n \n@@ -409,7 +389,7 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                foo():\n+                *foo()*\n                 ```rust\n                 u32\n                 ```\n@@ -441,7 +421,7 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                iter:\n+                *iter*\n                 ```rust\n                 Iter<Scan<OtherStruct<OtherStruct<i32>>, |&mut u32, &u32, &mut u32| -> Option<u32>, u32>>\n                 ```\n@@ -459,7 +439,7 @@ pub fn foo() -> u32 { 1 }\n fn main() { let foo_test = fo<|>o(); }\n \"#,\n             expect![[r#\"\n-                foo:\n+                *foo*\n                 ```rust\n                 pub fn foo() -> u32\n                 ```\n@@ -486,7 +466,7 @@ mod c;\n fn main() { let foo_test = fo<|>o(); }\n         \"#,\n             expect![[r#\"\n-                foo:\n+                *foo*\n                 ```rust\n                 {unknown}\n                 ```\n@@ -503,7 +483,7 @@ pub fn foo<'a, T: AsRef<str>>(b: &'a T) -> &'a str { }\n fn main() { let foo_test = fo<|>o(); }\n         \"#,\n             expect![[r#\"\n-                foo:\n+                *foo*\n                 ```rust\n                 pub fn foo<'a, T: AsRef<str>>(b: &'a T) -> &'a str\n                 ```\n@@ -520,7 +500,7 @@ pub fn foo<|>(a: u32, b: u32) -> u32 {}\n fn main() { }\n \"#,\n             expect![[r#\"\n-                foo:\n+                *foo*\n                 ```rust\n                 pub fn foo(a: u32, b: u32) -> u32\n                 ```\n@@ -540,7 +520,7 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                field_a:\n+                *field_a*\n                 ```rust\n                 Foo\n                 ```\n@@ -561,7 +541,7 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                field_a:\n+                *field_a*\n                 ```rust\n                 Foo\n                 ```\n@@ -578,7 +558,7 @@ fn main() {\n         check(\n             r#\"const foo<|>: u32 = 0;\"#,\n             expect![[r#\"\n-                foo:\n+                *foo*\n                 ```rust\n                 const foo: u32\n                 ```\n@@ -587,7 +567,7 @@ fn main() {\n         check(\n             r#\"static foo<|>: u32 = 0;\"#,\n             expect![[r#\"\n-                foo:\n+                *foo*\n                 ```rust\n                 static foo: u32\n                 ```\n@@ -605,7 +585,7 @@ fn main() {\n     let zz<|> = Test { t: 23u8, k: 33 };\n }\"#,\n             expect![[r#\"\n-                zz:\n+                *zz*\n                 ```rust\n                 Test<i32, u8>\n                 ```\n@@ -623,7 +603,7 @@ use Option::Some;\n fn main() { So<|>me(12); }\n \"#,\n             expect![[r#\"\n-                Some:\n+                *Some*\n                 ```rust\n                 Option\n                 ```\n@@ -642,7 +622,7 @@ use Option::Some;\n fn main() { let b<|>ar = Some(12); }\n \"#,\n             expect![[r#\"\n-                bar:\n+                *bar*\n                 ```rust\n                 Option<i32>\n                 ```\n@@ -660,7 +640,7 @@ enum Option<T> {\n }\n \"#,\n             expect![[r#\"\n-                None:\n+                *None*\n                 ```rust\n                 Option\n                 ```\n@@ -685,7 +665,7 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                Some:\n+                *Some*\n                 ```rust\n                 Option\n                 ```\n@@ -705,7 +685,7 @@ fn main() {\n         check(\n             r#\"fn func(foo: i32) { fo<|>o; }\"#,\n             expect![[r#\"\n-                foo:\n+                *foo*\n                 ```rust\n                 i32\n                 ```\n@@ -718,7 +698,7 @@ fn main() {\n         check(\n             r#\"fn func(fo<|>o: i32) {}\"#,\n             expect![[r#\"\n-                foo:\n+                *foo*\n                 ```rust\n                 i32\n                 ```\n@@ -731,7 +711,7 @@ fn main() {\n         check(\n             r#\"fn func(foo: i32) { if true { <|>foo; }; }\"#,\n             expect![[r#\"\n-                foo:\n+                *foo*\n                 ```rust\n                 i32\n                 ```\n@@ -744,7 +724,7 @@ fn main() {\n         check(\n             r#\"fn func(<|>foo: i32) {}\"#,\n             expect![[r#\"\n-                foo:\n+                *foo*\n                 ```rust\n                 i32\n                 ```\n@@ -765,7 +745,7 @@ impl Thing {\n fn main() { let foo_<|>test = Thing::new(); }\n             \"#,\n             expect![[r#\"\n-                foo_test:\n+                *foo_test*\n                 ```rust\n                 Thing\n                 ```\n@@ -788,7 +768,7 @@ mod wrapper {\n fn main() { let foo_test = wrapper::Thing::new<|>(); }\n \"#,\n             expect![[r#\"\n-                new:\n+                *new*\n                 ```rust\n                 wrapper::Thing\n                 ```\n@@ -818,7 +798,7 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                C:\n+                *C*\n                 ```rust\n                 const C: u32\n                 ```\n@@ -836,7 +816,7 @@ impl Thing {\n }\n \"#,\n             expect![[r#\"\n-                Self { x: 0 }:\n+                *Self { x: 0 }*\n                 ```rust\n                 Thing\n                 ```\n@@ -895,7 +875,7 @@ fn y() {\n }\n \"#,\n             expect![[r#\"\n-                x:\n+                *x*\n                 ```rust\n                 i32\n                 ```\n@@ -912,7 +892,7 @@ macro_rules! foo { () => {} }\n fn f() { fo<|>o!(); }\n \"#,\n             expect![[r#\"\n-                foo:\n+                *foo*\n                 ```rust\n                 macro_rules! foo\n                 ```\n@@ -925,7 +905,7 @@ fn f() { fo<|>o!(); }\n         check(\n             r#\"struct TS(String, i32<|>);\"#,\n             expect![[r#\"\n-                i32:\n+                *i32*\n                 i32\n             \"#]],\n         )\n@@ -942,7 +922,7 @@ id! {\n }\n \"#,\n             expect![[r#\"\n-                foo:\n+                *foo*\n                 ```rust\n                 fn foo()\n                 ```\n@@ -958,7 +938,7 @@ macro_rules! id { ($($tt:tt)*) => { $($tt)* } }\n fn foo(bar:u32) { let a = id!(ba<|>r); }\n \"#,\n             expect![[r#\"\n-                bar:\n+                *bar*\n                 ```rust\n                 u32\n                 ```\n@@ -975,7 +955,7 @@ macro_rules! id { ($($tt:tt)*) => { id_deep!($($tt)*) } }\n fn foo(bar:u32) { let a = id!(ba<|>r); }\n \"#,\n             expect![[r#\"\n-                bar:\n+                *bar*\n                 ```rust\n                 u32\n                 ```\n@@ -993,7 +973,7 @@ fn bar() -> u32 { 0 }\n fn foo() { let a = id!([0u32, bar(<|>)] ); }\n \"#,\n             expect![[r#\"\n-                bar():\n+                *bar()*\n                 ```rust\n                 u32\n                 ```\n@@ -1012,7 +992,7 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-                \"Tracks\":\n+                *\"Tracks\"*\n                 ```rust\n                 &str\n                 ```\n@@ -1033,7 +1013,7 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-                bar:\n+                *bar*\n                 ```rust\n                 fn bar() -> bool\n                 ```\n@@ -1065,7 +1045,7 @@ fn foo() { }\n fn bar() { fo<|>o(); }\n \",\n             expect![[r#\"\n-                foo:\n+                *foo*\n                 ```rust\n                 fn foo()\n                 ```\n@@ -1081,7 +1061,7 @@ fn bar() { fo<|>o(); }\n         check(\n             r#\"async fn foo<|>() {}\"#,\n             expect![[r#\"\n-                foo:\n+                *foo*\n                 ```rust\n                 async fn foo()\n                 ```\n@@ -1090,7 +1070,7 @@ fn bar() { fo<|>o(); }\n         check(\n             r#\"pub const unsafe fn foo<|>() {}\"#,\n             expect![[r#\"\n-                foo:\n+                *foo*\n                 ```rust\n                 pub const unsafe fn foo()\n                 ```\n@@ -1099,7 +1079,7 @@ fn bar() { fo<|>o(); }\n         check(\n             r#\"pub(crate) async unsafe extern \"C\" fn foo<|>() {}\"#,\n             expect![[r#\"\n-                foo:\n+                *foo*\n                 ```rust\n                 pub(crate) async unsafe extern \"C\" fn foo()\n                 ```\n@@ -1136,7 +1116,7 @@ mod my { pub struct Bar; }\n fn my() {}\n \"#,\n             expect![[r#\"\n-                my:\n+                *my*\n                 ```rust\n                 mod my\n                 ```\n@@ -1154,7 +1134,7 @@ struct Bar;\n fn foo() { let bar = Ba<|>r; }\n \"#,\n             expect![[r#\"\n-                Bar:\n+                *Bar*\n                 ```rust\n                 struct Bar\n                 ```\n@@ -1175,7 +1155,7 @@ struct Bar;\n fn foo() { let bar = Ba<|>r; }\n \"#,\n             expect![[r#\"\n-                Bar:\n+                *Bar*\n                 ```rust\n                 struct Bar\n                 ```\n@@ -1198,7 +1178,7 @@ struct Bar;\n fn foo() { let bar = Ba<|>r; }\n \"#,\n             expect![[r#\"\n-                Bar:\n+                *Bar*\n                 ```rust\n                 struct Bar\n                 ```\n@@ -1234,7 +1214,7 @@ bar!();\n fn foo() { let bar = Bar; bar.fo<|>o(); }\n \"#,\n             expect![[r#\"\n-                foo:\n+                *foo*\n                 ```rust\n                 Bar\n                 ```\n@@ -1270,7 +1250,7 @@ bar!();\n fn foo() { let bar = Bar; bar.fo<|>o(); }\n \"#,\n             expect![[r#\"\n-                foo:\n+                *foo*\n                 ```rust\n                 Bar\n                 ```"}, {"sha": "60c193c40aba27b81111fcab406a69584de34f6d", "filename": "crates/ra_ide/src/markup.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9eb9b9df9f6adebb938029a86e47c0aa1eb0f678/crates%2Fra_ide%2Fsrc%2Fmarkup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb9b9df9f6adebb938029a86e47c0aa1eb0f678/crates%2Fra_ide%2Fsrc%2Fmarkup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmarkup.rs?ref=9eb9b9df9f6adebb938029a86e47c0aa1eb0f678", "patch": "@@ -16,6 +16,12 @@ impl From<Markup> for String {\n     }\n }\n \n+impl From<String> for Markup {\n+    fn from(text: String) -> Self {\n+        Markup { text }\n+    }\n+}\n+\n impl fmt::Display for Markup {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(&self.text, f)\n@@ -26,13 +32,7 @@ impl Markup {\n     pub fn as_str(&self) -> &str {\n         self.text.as_str()\n     }\n-    pub fn is_empty(&self) -> bool {\n-        self.text.is_empty()\n-    }\n-    pub fn push_section(&mut self, section: &str) {\n-        if !self.text.is_empty() {\n-            self.text.push_str(\"\\n\\n___\\n\");\n-        }\n-        self.text.push_str(section);\n+    pub fn fenced_block(contents: &impl fmt::Display) -> Markup {\n+        format!(\"```rust\\n{}\\n```\", contents).into()\n     }\n }"}]}