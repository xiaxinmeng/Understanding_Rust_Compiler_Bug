{"sha": "87d859af24f49496e6aa2f65833e1cc2909ccf52", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3ZDg1OWFmMjRmNDk0OTZlNmFhMmY2NTgzM2UxY2MyOTA5Y2NmNTI=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-04-05T19:04:31Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-04-05T22:53:16Z"}, "message": "Don't lint for self-recursion when the function can diverge", "tree": {"sha": "5933caf5f6849f7b286c5b8ff883112136a6cd30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5933caf5f6849f7b286c5b8ff883112136a6cd30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87d859af24f49496e6aa2f65833e1cc2909ccf52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87d859af24f49496e6aa2f65833e1cc2909ccf52", "html_url": "https://github.com/rust-lang/rust/commit/87d859af24f49496e6aa2f65833e1cc2909ccf52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87d859af24f49496e6aa2f65833e1cc2909ccf52/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b543afca9b90ad6e4689b6d613ab51f9d3ba15e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b543afca9b90ad6e4689b6d613ab51f9d3ba15e7", "html_url": "https://github.com/rust-lang/rust/commit/b543afca9b90ad6e4689b6d613ab51f9d3ba15e7"}], "stats": {"total": 224, "additions": 132, "deletions": 92}, "files": [{"sha": "6e1a4ecf47a44e98ebb7f5cfb643aa041cf68653", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87d859af24f49496e6aa2f65833e1cc2909ccf52/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87d859af24f49496e6aa2f65833e1cc2909ccf52/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=87d859af24f49496e6aa2f65833e1cc2909ccf52", "patch": "@@ -178,11 +178,11 @@ fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n             build::construct_const(cx, body_id, return_ty, return_ty_span)\n         };\n \n-        lints::check(tcx, &body, def_id);\n-\n         let mut body = BodyAndCache::new(body);\n         body.ensure_predecessors();\n \n+        lints::check(tcx, &body.unwrap_read_only(), def_id);\n+\n         // The borrow checker will replace all the regions here with its own\n         // inference variables. There's no point having non-erased regions here.\n         // The exception is `body.user_type_annotations`, which is used unmodified"}, {"sha": "01dd575c51ed16d27b1005fc753c506e5d8e531d", "filename": "src/librustc_mir_build/lints.rs", "status": "modified", "additions": 112, "deletions": 90, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/87d859af24f49496e6aa2f65833e1cc2909ccf52/src%2Flibrustc_mir_build%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87d859af24f49496e6aa2f65833e1cc2909ccf52/src%2Flibrustc_mir_build%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Flints.rs?ref=87d859af24f49496e6aa2f65833e1cc2909ccf52", "patch": "@@ -1,13 +1,15 @@\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::FnKind;\n use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::IndexVec;\n use rustc_middle::hir::map::blocks::FnLikeNode;\n-use rustc_middle::mir::{self, Body, TerminatorKind};\n+use rustc_middle::mir::{BasicBlock, Body, ReadOnlyBodyAndCache, TerminatorKind, START_BLOCK};\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, AssocItem, AssocItemContainer, Instance, TyCtxt};\n use rustc_session::lint::builtin::UNCONDITIONAL_RECURSION;\n+use std::collections::VecDeque;\n \n-crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId) {\n+crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &ReadOnlyBodyAndCache<'_, 'tcx>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get(hir_id)) {\n@@ -18,121 +20,141 @@ crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId) {\n fn check_fn_for_unconditional_recursion<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     fn_kind: FnKind<'_>,\n-    body: &Body<'tcx>,\n+    body: &ReadOnlyBodyAndCache<'_, 'tcx>,\n     def_id: DefId,\n ) {\n     if let FnKind::Closure(_) = fn_kind {\n         // closures can't recur, so they don't matter.\n         return;\n     }\n \n-    //FIXME(#54444) rewrite this lint to use the dataflow framework\n-\n-    // Walk through this function (say `f`) looking to see if\n-    // every possible path references itself, i.e., the function is\n-    // called recursively unconditionally. This is done by trying\n-    // to find a path from the entry node to the exit node that\n-    // *doesn't* call `f` by traversing from the entry while\n-    // pretending that calls of `f` are sinks (i.e., ignoring any\n-    // exit edges from them).\n-    //\n-    // NB. this has an edge case with non-returning statements,\n-    // like `loop {}` or `panic!()`: control flow never reaches\n-    // the exit node through these, so one can have a function\n-    // that never actually calls itself but is still picked up by\n-    // this lint:\n-    //\n-    //     fn f(cond: bool) {\n-    //         if !cond { panic!() } // could come from `assert!(cond)`\n-    //         f(false)\n-    //     }\n-    //\n-    // In general, functions of that form may be able to call\n-    // itself a finite number of times and then diverge. The lint\n-    // considers this to be an error for two reasons, (a) it is\n-    // easier to implement, and (b) it seems rare to actually want\n-    // to have behaviour like the above, rather than\n-    // e.g., accidentally recursing after an assert.\n-\n-    let basic_blocks = body.basic_blocks();\n-    let mut reachable_without_self_call_queue = vec![mir::START_BLOCK];\n-    let mut reached_exit_without_self_call = false;\n-    let mut self_call_locations = vec![];\n-    let mut visited = BitSet::new_empty(basic_blocks.len());\n+    let self_calls = find_blocks_calling_self(tcx, &body, def_id);\n+    let mut results = IndexVec::from_elem_n(vec![], body.basic_blocks().len());\n+    let mut queue: VecDeque<_> = self_calls.iter().collect();\n \n-    let param_env = tcx.param_env(def_id);\n-    let trait_substs_count = match tcx.opt_associated_item(def_id) {\n-        Some(AssocItem { container: AssocItemContainer::TraitContainer(trait_def_id), .. }) => {\n-            tcx.generics_of(trait_def_id).count()\n-        }\n-        _ => 0,\n-    };\n-    let caller_substs = &InternalSubsts::identity_for_item(tcx, def_id)[..trait_substs_count];\n-\n-    while let Some(bb) = reachable_without_self_call_queue.pop() {\n-        if !visited.insert(bb) {\n-            //already done\n+    while let Some(bb) = queue.pop_front() {\n+        if !results[bb].is_empty() {\n+            // Already propagated.\n             continue;\n         }\n \n-        let block = &basic_blocks[bb];\n-\n-        if let Some(ref terminator) = block.terminator {\n-            match terminator.kind {\n-                TerminatorKind::Call { ref func, .. } => {\n-                    let func_ty = func.ty(body, tcx);\n-\n-                    if let ty::FnDef(fn_def_id, substs) = func_ty.kind {\n-                        let (call_fn_id, call_substs) = if let Some(instance) =\n-                            Instance::resolve(tcx, param_env, fn_def_id, substs)\n-                        {\n-                            (instance.def_id(), instance.substs)\n-                        } else {\n-                            (fn_def_id, substs)\n-                        };\n-\n-                        let is_self_call = call_fn_id == def_id\n-                            && &call_substs[..caller_substs.len()] == caller_substs;\n-\n-                        if is_self_call {\n-                            self_call_locations.push(terminator.source_info);\n-\n-                            //this is a self call so we shouldn't explore\n-                            //further down this path\n-                            continue;\n-                        }\n-                    }\n+        let locations = if self_calls.contains(bb) {\n+            // `bb` *is* a self-call.\n+            vec![bb]\n+        } else {\n+            // If *all* successors of `bb` lead to a self-call, emit notes at all of their\n+            // locations.\n+\n+            // Converging successors without unwind paths.\n+            let terminator = body[bb].terminator();\n+            let relevant_successors = match &terminator.kind {\n+                TerminatorKind::Call { destination: Some((_, dest)), .. } => {\n+                    Some(dest).into_iter().chain(&[])\n                 }\n-                TerminatorKind::Abort | TerminatorKind::Return => {\n-                    //found a path!\n-                    reached_exit_without_self_call = true;\n-                    break;\n+                TerminatorKind::Call { destination: None, .. } => None.into_iter().chain(&[]),\n+                TerminatorKind::SwitchInt { targets, .. } => None.into_iter().chain(targets),\n+                TerminatorKind::Goto { target }\n+                | TerminatorKind::Drop { target, .. }\n+                | TerminatorKind::DropAndReplace { target, .. }\n+                | TerminatorKind::Assert { target, .. } => Some(target).into_iter().chain(&[]),\n+                TerminatorKind::Yield { .. } | TerminatorKind::GeneratorDrop => {\n+                    None.into_iter().chain(&[])\n                 }\n-                _ => {}\n-            }\n+                TerminatorKind::FalseEdges { real_target, .. }\n+                | TerminatorKind::FalseUnwind { real_target, .. } => {\n+                    Some(real_target).into_iter().chain(&[])\n+                }\n+                TerminatorKind::Resume\n+                | TerminatorKind::Abort\n+                | TerminatorKind::Return\n+                | TerminatorKind::Unreachable => {\n+                    unreachable!(\"unexpected terminator {:?}\", terminator.kind)\n+                }\n+            };\n+\n+            let all_are_self_calls =\n+                relevant_successors.clone().all(|&succ| !results[succ].is_empty());\n \n-            for successor in terminator.successors() {\n-                reachable_without_self_call_queue.push(*successor);\n+            if all_are_self_calls {\n+                relevant_successors.flat_map(|&succ| results[succ].iter().copied()).collect()\n+            } else {\n+                vec![]\n             }\n+        };\n+\n+        if !locations.is_empty() {\n+            // This is a newly confirmed-to-always-reach-self-call block.\n+            results[bb] = locations;\n+\n+            // Propagate backwards through the CFG.\n+            debug!(\"propagate loc={:?} in {:?} -> {:?}\", results[bb], bb, body.predecessors()[bb]);\n+            queue.extend(body.predecessors()[bb].iter().copied());\n         }\n     }\n \n-    // Check the number of self calls because a function that\n-    // doesn't return (e.g., calls a `-> !` function or `loop { /*\n-    // no break */ }`) shouldn't be linted unless it actually\n-    // recurs.\n-    if !reached_exit_without_self_call && !self_call_locations.is_empty() {\n+    debug!(\"unconditional recursion results: {:?}\", results);\n+\n+    let self_call_locations = &mut results[START_BLOCK];\n+    self_call_locations.sort();\n+    self_call_locations.dedup();\n+\n+    if !self_call_locations.is_empty() {\n         let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let sp = tcx.sess.source_map().guess_head_span(tcx.hir().span(hir_id));\n         tcx.struct_span_lint_hir(UNCONDITIONAL_RECURSION, hir_id, sp, |lint| {\n             let mut db = lint.build(\"function cannot return without recursing\");\n             db.span_label(sp, \"cannot return without recursing\");\n             // offer some help to the programmer.\n-            for location in &self_call_locations {\n-                db.span_label(location.span, \"recursive call site\");\n+            for bb in self_call_locations {\n+                let span = body.basic_blocks()[*bb].terminator().source_info.span;\n+                db.span_label(span, \"recursive call site\");\n             }\n             db.help(\"a `loop` may express intention better if this is on purpose\");\n             db.emit();\n         });\n     }\n }\n+\n+/// Finds blocks with `Call` terminators that would end up calling back into the same method.\n+fn find_blocks_calling_self<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &Body<'tcx>,\n+    def_id: DefId,\n+) -> BitSet<BasicBlock> {\n+    let param_env = tcx.param_env(def_id);\n+    let trait_substs_count = match tcx.opt_associated_item(def_id) {\n+        Some(AssocItem { container: AssocItemContainer::TraitContainer(trait_def_id), .. }) => {\n+            tcx.generics_of(trait_def_id).count()\n+        }\n+        _ => 0,\n+    };\n+    let caller_substs = &InternalSubsts::identity_for_item(tcx, def_id)[..trait_substs_count];\n+\n+    let mut self_calls = BitSet::new_empty(body.basic_blocks().len());\n+\n+    for (bb, data) in body.basic_blocks().iter_enumerated() {\n+        if let TerminatorKind::Call { func, .. } = &data.terminator().kind {\n+            let func_ty = func.ty(body, tcx);\n+\n+            if let ty::FnDef(fn_def_id, substs) = func_ty.kind {\n+                let (call_fn_id, call_substs) =\n+                    if let Some(instance) = Instance::resolve(tcx, param_env, fn_def_id, substs) {\n+                        (instance.def_id(), instance.substs)\n+                    } else {\n+                        (fn_def_id, substs)\n+                    };\n+\n+                // FIXME(#57965): Make this work across function boundaries\n+\n+                let is_self_call =\n+                    call_fn_id == def_id && &call_substs[..caller_substs.len()] == caller_substs;\n+\n+                if is_self_call {\n+                    self_calls.insert(bb);\n+                }\n+            }\n+        }\n+    }\n+\n+    self_calls\n+}"}, {"sha": "d2a0329585b71b0d9302f8fafe51d78d5692d4b8", "filename": "src/test/ui/lint/lint-unconditional-recursion.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/87d859af24f49496e6aa2f65833e1cc2909ccf52/src%2Ftest%2Fui%2Flint%2Flint-unconditional-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87d859af24f49496e6aa2f65833e1cc2909ccf52/src%2Ftest%2Fui%2Flint%2Flint-unconditional-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unconditional-recursion.rs?ref=87d859af24f49496e6aa2f65833e1cc2909ccf52", "patch": "@@ -131,4 +131,22 @@ trait Bar {\n     }\n }\n \n+// Do not trigger on functions that may diverge instead of self-recursing (#54444)\n+\n+pub fn loops(x: bool) {\n+    if x {\n+        loops(x);\n+    } else {\n+        loop {}\n+    }\n+}\n+\n+pub fn panics(x: bool) {\n+    if x {\n+        panics(!x);\n+    } else {\n+        panic!(\"panics\");\n+    }\n+}\n+\n fn main() {}"}]}