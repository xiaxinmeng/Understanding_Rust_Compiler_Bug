{"sha": "88589f2ad891f115e44cab2f37993885c82c40d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NTg5ZjJhZDg5MWYxMTVlNDRjYWIyZjM3OTkzODg1YzgyYzQwZDg=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-03-21T13:02:18Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-03-21T13:21:08Z"}, "message": "Add matches module\n\n`matches` module contains `rewrite_match` and related stuffs.", "tree": {"sha": "65088532886e5e466e8286d37e4e51bcde2574af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65088532886e5e466e8286d37e4e51bcde2574af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88589f2ad891f115e44cab2f37993885c82c40d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88589f2ad891f115e44cab2f37993885c82c40d8", "html_url": "https://github.com/rust-lang/rust/commit/88589f2ad891f115e44cab2f37993885c82c40d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88589f2ad891f115e44cab2f37993885c82c40d8/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55162239007a1514dd9c5fe99c377c1929be1039", "url": "https://api.github.com/repos/rust-lang/rust/commits/55162239007a1514dd9c5fe99c377c1929be1039", "html_url": "https://github.com/rust-lang/rust/commit/55162239007a1514dd9c5fe99c377c1929be1039"}], "stats": {"total": 1117, "additions": 573, "deletions": 544}, "files": [{"sha": "e6cd6ee046f2a51933bd015f9bfdcad4eb690f1b", "filename": "src/expr.rs", "status": "modified", "additions": 7, "deletions": 544, "changes": 551, "blob_url": "https://github.com/rust-lang/rust/blob/88589f2ad891f115e44cab2f37993885c82c40d8/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88589f2ad891f115e44cab2f37993885c82c40d8/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=88589f2ad891f115e44cab2f37993885c82c40d8", "patch": "@@ -10,7 +10,6 @@\n \n use std::borrow::Cow;\n use std::cmp::min;\n-use std::iter::repeat;\n \n use config::lists::*;\n use syntax::{ast, ptr};\n@@ -25,17 +24,17 @@ use config::{Config, ControlBraceStyle, IndentStyle};\n use lists::{definitive_tactic, itemize_list, shape_for_tactic, struct_lit_formatting,\n             struct_lit_shape, struct_lit_tactic, write_list, ListFormatting, ListItem, Separator};\n use macros::{rewrite_macro, MacroArg, MacroPosition};\n+use matches::rewrite_match;\n use overflow;\n-use patterns::{can_be_overflowed_pat, TuplePatField};\n+use patterns::{can_be_overflowed_pat, is_short_pattern, TuplePatField};\n use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n use spanned::Spanned;\n use string::{rewrite_string, StringFormat};\n use types::{can_be_overflowed_type, rewrite_path, PathContext};\n-use utils::{colon_spaces, contains_skip, count_newlines, extra_offset, first_line_width,\n-            inner_attributes, last_line_extendable, last_line_width, mk_sp, outer_attributes,\n-            paren_overhead, ptr_vec_to_ref_vec, semicolon_for_stmt, trimmed_last_line_width,\n-            wrap_str};\n+use utils::{colon_spaces, contains_skip, count_newlines, first_line_width, inner_attributes,\n+            last_line_extendable, last_line_width, mk_sp, outer_attributes, paren_overhead,\n+            ptr_vec_to_ref_vec, semicolon_for_stmt, wrap_str};\n use vertical::rewrite_with_alignment;\n use visitor::FmtVisitor;\n \n@@ -566,19 +565,6 @@ fn array_tactic<T: Rewrite + Spanned + ToExpr>(\n     }\n }\n \n-fn nop_block_collapse(block_str: Option<String>, budget: usize) -> Option<String> {\n-    debug!(\"nop_block_collapse {:?} {}\", block_str, budget);\n-    block_str.map(|block_str| {\n-        if block_str.starts_with('{') && budget >= 2\n-            && (block_str[1..].find(|c: char| !c.is_whitespace()).unwrap() == block_str.len() - 2)\n-        {\n-            \"{}\".to_owned()\n-        } else {\n-            block_str.to_owned()\n-        }\n-    })\n-}\n-\n fn rewrite_empty_block(\n     context: &RewriteContext,\n     block: &ast::Block,\n@@ -1320,503 +1306,7 @@ pub fn is_unsafe_block(block: &ast::Block) -> bool {\n     }\n }\n \n-/// A simple wrapper type against `ast::Arm`. Used inside `write_list()`.\n-struct ArmWrapper<'a> {\n-    pub arm: &'a ast::Arm,\n-    /// True if the arm is the last one in match expression. Used to decide on whether we should add\n-    /// trailing comma to the match arm when `config.trailing_comma() == Never`.\n-    pub is_last: bool,\n-    /// Holds a byte position of `|` at the beginning of the arm pattern, if available.\n-    pub beginning_vert: Option<BytePos>,\n-}\n-\n-impl<'a> ArmWrapper<'a> {\n-    pub fn new(\n-        arm: &'a ast::Arm,\n-        is_last: bool,\n-        beginning_vert: Option<BytePos>,\n-    ) -> ArmWrapper<'a> {\n-        ArmWrapper {\n-            arm,\n-            is_last,\n-            beginning_vert,\n-        }\n-    }\n-}\n-\n-impl<'a> Spanned for ArmWrapper<'a> {\n-    fn span(&self) -> Span {\n-        if let Some(lo) = self.beginning_vert {\n-            mk_sp(lo, self.arm.span().hi())\n-        } else {\n-            self.arm.span()\n-        }\n-    }\n-}\n-\n-impl<'a> Rewrite for ArmWrapper<'a> {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        rewrite_match_arm(context, self.arm, shape, self.is_last, self.beginning_vert)\n-    }\n-}\n-\n-fn rewrite_match(\n-    context: &RewriteContext,\n-    cond: &ast::Expr,\n-    arms: &[ast::Arm],\n-    shape: Shape,\n-    span: Span,\n-    attrs: &[ast::Attribute],\n-) -> Option<String> {\n-    // Do not take the rhs overhead from the upper expressions into account\n-    // when rewriting match condition.\n-    let cond_shape = Shape {\n-        width: context.budget(shape.used_width()),\n-        ..shape\n-    };\n-    // 6 = `match `\n-    let cond_shape = match context.config.indent_style() {\n-        IndentStyle::Visual => cond_shape.shrink_left(6)?,\n-        IndentStyle::Block => cond_shape.offset_left(6)?,\n-    };\n-    let cond_str = cond.rewrite(context, cond_shape)?;\n-    let alt_block_sep = &shape.indent.to_string_with_newline(context.config);\n-    let block_sep = match context.config.control_brace_style() {\n-        ControlBraceStyle::AlwaysNextLine => alt_block_sep,\n-        _ if last_line_extendable(&cond_str) => \" \",\n-        // 2 = ` {`\n-        _ if cond_str.contains('\\n') || cond_str.len() + 2 > cond_shape.width => alt_block_sep,\n-        _ => \" \",\n-    };\n-\n-    let nested_indent_str = shape\n-        .indent\n-        .block_indent(context.config)\n-        .to_string(context.config);\n-    // Inner attributes.\n-    let inner_attrs = &inner_attributes(attrs);\n-    let inner_attrs_str = if inner_attrs.is_empty() {\n-        String::new()\n-    } else {\n-        inner_attrs\n-            .rewrite(context, shape)\n-            .map(|s| format!(\"{}{}\\n\", nested_indent_str, s))?\n-    };\n-\n-    let open_brace_pos = if inner_attrs.is_empty() {\n-        let hi = if arms.is_empty() {\n-            span.hi()\n-        } else {\n-            arms[0].span().lo()\n-        };\n-        context\n-            .snippet_provider\n-            .span_after(mk_sp(cond.span.hi(), hi), \"{\")\n-    } else {\n-        inner_attrs[inner_attrs.len() - 1].span().hi()\n-    };\n-\n-    if arms.is_empty() {\n-        let snippet = context.snippet(mk_sp(open_brace_pos, span.hi() - BytePos(1)));\n-        if snippet.trim().is_empty() {\n-            Some(format!(\"match {} {{}}\", cond_str))\n-        } else {\n-            // Empty match with comments or inner attributes? We are not going to bother, sorry ;)\n-            Some(context.snippet(span).to_owned())\n-        }\n-    } else {\n-        Some(format!(\n-            \"match {}{}{{\\n{}{}{}\\n{}}}\",\n-            cond_str,\n-            block_sep,\n-            inner_attrs_str,\n-            nested_indent_str,\n-            rewrite_match_arms(context, arms, shape, span, open_brace_pos)?,\n-            shape.indent.to_string(context.config),\n-        ))\n-    }\n-}\n-\n-fn arm_comma(config: &Config, body: &ast::Expr, is_last: bool) -> &'static str {\n-    if is_last && config.trailing_comma() == SeparatorTactic::Never {\n-        \"\"\n-    } else if config.match_block_trailing_comma() {\n-        \",\"\n-    } else if let ast::ExprKind::Block(ref block) = body.node {\n-        if let ast::BlockCheckMode::Default = block.rules {\n-            \"\"\n-        } else {\n-            \",\"\n-        }\n-    } else {\n-        \",\"\n-    }\n-}\n-\n-/// Collect a byte position of the beginning `|` for each arm, if available.\n-fn collect_beginning_verts(\n-    context: &RewriteContext,\n-    arms: &[ast::Arm],\n-    span: Span,\n-) -> Vec<Option<BytePos>> {\n-    let mut beginning_verts = Vec::with_capacity(arms.len());\n-    let mut lo = context.snippet_provider.span_after(span, \"{\");\n-    for arm in arms {\n-        let hi = arm.pats[0].span.lo();\n-        let missing_span = mk_sp(lo, hi);\n-        beginning_verts.push(context.snippet_provider.opt_span_before(missing_span, \"|\"));\n-        lo = arm.span().hi();\n-    }\n-    beginning_verts\n-}\n-\n-fn rewrite_match_arms(\n-    context: &RewriteContext,\n-    arms: &[ast::Arm],\n-    shape: Shape,\n-    span: Span,\n-    open_brace_pos: BytePos,\n-) -> Option<String> {\n-    let arm_shape = shape\n-        .block_indent(context.config.tab_spaces())\n-        .with_max_width(context.config);\n-\n-    let arm_len = arms.len();\n-    let is_last_iter = repeat(false)\n-        .take(arm_len.checked_sub(1).unwrap_or(0))\n-        .chain(repeat(true));\n-    let beginning_verts = collect_beginning_verts(context, arms, span);\n-    let items = itemize_list(\n-        context.snippet_provider,\n-        arms.iter()\n-            .zip(is_last_iter)\n-            .zip(beginning_verts.into_iter())\n-            .map(|((arm, is_last), beginning_vert)| ArmWrapper::new(arm, is_last, beginning_vert)),\n-        \"}\",\n-        \"|\",\n-        |arm| arm.span().lo(),\n-        |arm| arm.span().hi(),\n-        |arm| arm.rewrite(context, arm_shape),\n-        open_brace_pos,\n-        span.hi(),\n-        false,\n-    );\n-    let arms_vec: Vec<_> = items.collect();\n-    let fmt = ListFormatting {\n-        tactic: DefinitiveListTactic::Vertical,\n-        // We will add/remove commas inside `arm.rewrite()`, and hence no separator here.\n-        separator: \"\",\n-        trailing_separator: SeparatorTactic::Never,\n-        separator_place: SeparatorPlace::Back,\n-        shape: arm_shape,\n-        ends_with_newline: true,\n-        preserve_newline: true,\n-        config: context.config,\n-    };\n-\n-    write_list(&arms_vec, &fmt)\n-}\n-\n-fn rewrite_match_arm(\n-    context: &RewriteContext,\n-    arm: &ast::Arm,\n-    shape: Shape,\n-    is_last: bool,\n-    beginning_vert: Option<BytePos>,\n-) -> Option<String> {\n-    let (missing_span, attrs_str) = if !arm.attrs.is_empty() {\n-        if contains_skip(&arm.attrs) {\n-            let (_, body) = flatten_arm_body(context, &arm.body);\n-            // `arm.span()` does not include trailing comma, add it manually.\n-            return Some(format!(\n-                \"{}{}\",\n-                context.snippet(arm.span()),\n-                arm_comma(context.config, body, is_last),\n-            ));\n-        }\n-        let missing_span = mk_sp(\n-            arm.attrs[arm.attrs.len() - 1].span.hi(),\n-            arm.pats[0].span.lo(),\n-        );\n-        (missing_span, arm.attrs.rewrite(context, shape)?)\n-    } else {\n-        (mk_sp(arm.span().lo(), arm.span().lo()), String::new())\n-    };\n-    let pats_str = rewrite_match_pattern(\n-        context,\n-        &ptr_vec_to_ref_vec(&arm.pats),\n-        &arm.guard,\n-        beginning_vert.is_some(),\n-        shape,\n-    ).and_then(|pats_str| {\n-        combine_strs_with_missing_comments(\n-            context,\n-            &attrs_str,\n-            &pats_str,\n-            missing_span,\n-            shape,\n-            false,\n-        )\n-    })?;\n-    rewrite_match_body(\n-        context,\n-        &arm.body,\n-        &pats_str,\n-        shape,\n-        arm.guard.is_some(),\n-        is_last,\n-    )\n-}\n-\n-/// Returns true if the given pattern is short. A short pattern is defined by the following grammer:\n-///\n-/// [small, ntp]:\n-///     - single token\n-///     - `&[single-line, ntp]`\n-///\n-/// [small]:\n-///     - `[small, ntp]`\n-///     - unary tuple constructor `([small, ntp])`\n-///     - `&[small]`\n-fn is_short_pattern(pat: &ast::Pat, pat_str: &str) -> bool {\n-    // We also require that the pattern is reasonably 'small' with its literal width.\n-    pat_str.len() <= 20 && !pat_str.contains('\\n') && is_short_pattern_inner(pat)\n-}\n-\n-fn is_short_pattern_inner(pat: &ast::Pat) -> bool {\n-    match pat.node {\n-        ast::PatKind::Wild | ast::PatKind::Lit(_) => true,\n-        ast::PatKind::Ident(_, _, ref pat) => pat.is_none(),\n-        ast::PatKind::Struct(..)\n-        | ast::PatKind::Mac(..)\n-        | ast::PatKind::Slice(..)\n-        | ast::PatKind::Path(..)\n-        | ast::PatKind::Range(..) => false,\n-        ast::PatKind::Tuple(ref subpats, _) => subpats.len() <= 1,\n-        ast::PatKind::TupleStruct(ref path, ref subpats, _) => {\n-            path.segments.len() <= 1 && subpats.len() <= 1\n-        }\n-        ast::PatKind::Box(ref p) | ast::PatKind::Ref(ref p, _) | ast::PatKind::Paren(ref p) => {\n-            is_short_pattern_inner(&*p)\n-        }\n-    }\n-}\n-\n-fn rewrite_match_pattern(\n-    context: &RewriteContext,\n-    pats: &[&ast::Pat],\n-    guard: &Option<ptr::P<ast::Expr>>,\n-    has_beginning_vert: bool,\n-    shape: Shape,\n-) -> Option<String> {\n-    // Patterns\n-    // 5 = ` => {`\n-    // 2 = `| `\n-    let pat_shape = shape\n-        .sub_width(5)?\n-        .offset_left(if has_beginning_vert { 2 } else { 0 })?;\n-    let pats_str = rewrite_multiple_patterns(context, pats, pat_shape)?;\n-    let beginning_vert = if has_beginning_vert { \"| \" } else { \"\" };\n-\n-    // Guard\n-    let guard_str = rewrite_guard(context, guard, shape, trimmed_last_line_width(&pats_str))?;\n-\n-    Some(format!(\"{}{}{}\", beginning_vert, pats_str, guard_str))\n-}\n-\n-// (extend, body)\n-// @extend: true if the arm body can be put next to `=>`\n-// @body: flattened body, if the body is block with a single expression\n-fn flatten_arm_body<'a>(context: &'a RewriteContext, body: &'a ast::Expr) -> (bool, &'a ast::Expr) {\n-    match body.node {\n-        ast::ExprKind::Block(ref block)\n-            if !is_unsafe_block(block)\n-                && is_simple_block(block, Some(&body.attrs), context.codemap) =>\n-        {\n-            if let ast::StmtKind::Expr(ref expr) = block.stmts[0].node {\n-                (\n-                    !context.config.force_multiline_blocks() && can_extend_match_arm_body(expr),\n-                    &*expr,\n-                )\n-            } else {\n-                (false, &*body)\n-            }\n-        }\n-        _ => (\n-            !context.config.force_multiline_blocks() && body.can_be_overflowed(context, 1),\n-            &*body,\n-        ),\n-    }\n-}\n-\n-fn rewrite_match_body(\n-    context: &RewriteContext,\n-    body: &ptr::P<ast::Expr>,\n-    pats_str: &str,\n-    shape: Shape,\n-    has_guard: bool,\n-    is_last: bool,\n-) -> Option<String> {\n-    let (extend, body) = flatten_arm_body(context, body);\n-    let (is_block, is_empty_block) = if let ast::ExprKind::Block(ref block) = body.node {\n-        (\n-            true,\n-            is_empty_block(block, Some(&body.attrs), context.codemap),\n-        )\n-    } else {\n-        (false, false)\n-    };\n-\n-    let comma = arm_comma(context.config, body, is_last);\n-    let alt_block_sep = &shape.indent.to_string_with_newline(context.config);\n-\n-    let combine_orig_body = |body_str: &str| {\n-        let block_sep = match context.config.control_brace_style() {\n-            ControlBraceStyle::AlwaysNextLine if is_block => alt_block_sep,\n-            _ => \" \",\n-        };\n-\n-        Some(format!(\"{} =>{}{}{}\", pats_str, block_sep, body_str, comma))\n-    };\n-\n-    let forbid_same_line = has_guard && pats_str.contains('\\n') && !is_empty_block;\n-    let next_line_indent = if !is_block || is_empty_block {\n-        shape.indent.block_indent(context.config)\n-    } else {\n-        shape.indent\n-    };\n-    let combine_next_line_body = |body_str: &str| {\n-        if is_block {\n-            return Some(format!(\n-                \"{} =>{}{}\",\n-                pats_str,\n-                next_line_indent.to_string_with_newline(context.config),\n-                body_str\n-            ));\n-        }\n-\n-        let indent_str = shape.indent.to_string_with_newline(context.config);\n-        let nested_indent_str = next_line_indent.to_string_with_newline(context.config);\n-        let (body_prefix, body_suffix) = if context.config.match_arm_blocks() {\n-            let comma = if context.config.match_block_trailing_comma() {\n-                \",\"\n-            } else {\n-                \"\"\n-            };\n-            (\"{\", format!(\"{}}}{}\", indent_str, comma))\n-        } else {\n-            (\"\", String::from(\",\"))\n-        };\n-\n-        let block_sep = match context.config.control_brace_style() {\n-            ControlBraceStyle::AlwaysNextLine => format!(\"{}{}\", alt_block_sep, body_prefix),\n-            _ if body_prefix.is_empty() => \"\".to_owned(),\n-            _ if forbid_same_line => format!(\"{}{}\", alt_block_sep, body_prefix),\n-            _ => format!(\" {}\", body_prefix),\n-        } + &nested_indent_str;\n-\n-        Some(format!(\n-            \"{} =>{}{}{}\",\n-            pats_str, block_sep, body_str, body_suffix\n-        ))\n-    };\n-\n-    // Let's try and get the arm body on the same line as the condition.\n-    // 4 = ` => `.len()\n-    let orig_body_shape = shape\n-        .offset_left(extra_offset(pats_str, shape) + 4)\n-        .and_then(|shape| shape.sub_width(comma.len()));\n-    let orig_body = if let Some(body_shape) = orig_body_shape {\n-        let rewrite = nop_block_collapse(\n-            format_expr(body, ExprType::Statement, context, body_shape),\n-            body_shape.width,\n-        );\n-\n-        match rewrite {\n-            Some(ref body_str)\n-                if !forbid_same_line\n-                    && (is_block\n-                        || (!body_str.contains('\\n') && body_str.len() <= body_shape.width)) =>\n-            {\n-                return combine_orig_body(body_str);\n-            }\n-            _ => rewrite,\n-        }\n-    } else {\n-        None\n-    };\n-    let orig_budget = orig_body_shape.map_or(0, |shape| shape.width);\n-\n-    // Try putting body on the next line and see if it looks better.\n-    let next_line_body_shape = Shape::indented(next_line_indent, context.config);\n-    let next_line_body = nop_block_collapse(\n-        format_expr(body, ExprType::Statement, context, next_line_body_shape),\n-        next_line_body_shape.width,\n-    );\n-    match (orig_body, next_line_body) {\n-        (Some(ref orig_str), Some(ref next_line_str))\n-            if forbid_same_line\n-                || prefer_next_line(orig_str, next_line_str, RhsTactics::Default) =>\n-        {\n-            combine_next_line_body(next_line_str)\n-        }\n-        (Some(ref orig_str), _) if extend && first_line_width(orig_str) <= orig_budget => {\n-            combine_orig_body(orig_str)\n-        }\n-        (Some(ref orig_str), Some(ref next_line_str)) if orig_str.contains('\\n') => {\n-            combine_next_line_body(next_line_str)\n-        }\n-        (None, Some(ref next_line_str)) => combine_next_line_body(next_line_str),\n-        (None, None) => None,\n-        (Some(ref orig_str), _) => combine_orig_body(orig_str),\n-    }\n-}\n-\n-// The `if ...` guard on a match arm.\n-fn rewrite_guard(\n-    context: &RewriteContext,\n-    guard: &Option<ptr::P<ast::Expr>>,\n-    shape: Shape,\n-    // The amount of space used up on this line for the pattern in\n-    // the arm (excludes offset).\n-    pattern_width: usize,\n-) -> Option<String> {\n-    if let Some(ref guard) = *guard {\n-        // First try to fit the guard string on the same line as the pattern.\n-        // 4 = ` if `, 5 = ` => {`\n-        let cond_shape = shape\n-            .offset_left(pattern_width + 4)\n-            .and_then(|s| s.sub_width(5));\n-        if let Some(cond_shape) = cond_shape {\n-            if let Some(cond_str) = guard.rewrite(context, cond_shape) {\n-                if !cond_str.contains('\\n') || pattern_width <= context.config.tab_spaces() {\n-                    return Some(format!(\" if {}\", cond_str));\n-                }\n-            }\n-        }\n-\n-        // Not enough space to put the guard after the pattern, try a newline.\n-        // 3 = `if `, 5 = ` => {`\n-        let cond_shape = Shape::indented(shape.indent.block_indent(context.config), context.config)\n-            .offset_left(3)\n-            .and_then(|s| s.sub_width(5));\n-        if let Some(cond_shape) = cond_shape {\n-            if let Some(cond_str) = guard.rewrite(context, cond_shape) {\n-                return Some(format!(\n-                    \"{}if {}\",\n-                    cond_shape.indent.to_string_with_newline(context.config),\n-                    cond_str\n-                ));\n-            }\n-        }\n-\n-        None\n-    } else {\n-        Some(String::new())\n-    }\n-}\n-\n-fn rewrite_multiple_patterns(\n+pub fn rewrite_multiple_patterns(\n     context: &RewriteContext,\n     pats: &[&ast::Pat],\n     shape: Shape,\n@@ -1852,33 +1342,6 @@ fn rewrite_multiple_patterns(\n     write_list(&items, &fmt)\n }\n \n-fn can_extend_match_arm_body(body: &ast::Expr) -> bool {\n-    match body.node {\n-        // We do not allow `if` to stay on the same line, since we could easily mistake\n-        // `pat => if cond { ... }` and `pat if cond => { ... }`.\n-        ast::ExprKind::If(..) | ast::ExprKind::IfLet(..) => false,\n-        ast::ExprKind::ForLoop(..)\n-        | ast::ExprKind::Loop(..)\n-        | ast::ExprKind::While(..)\n-        | ast::ExprKind::WhileLet(..)\n-        | ast::ExprKind::Match(..)\n-        | ast::ExprKind::Block(..)\n-        | ast::ExprKind::Closure(..)\n-        | ast::ExprKind::Array(..)\n-        | ast::ExprKind::Call(..)\n-        | ast::ExprKind::MethodCall(..)\n-        | ast::ExprKind::Mac(..)\n-        | ast::ExprKind::Struct(..)\n-        | ast::ExprKind::Tup(..) => true,\n-        ast::ExprKind::AddrOf(_, ref expr)\n-        | ast::ExprKind::Box(ref expr)\n-        | ast::ExprKind::Try(ref expr)\n-        | ast::ExprKind::Unary(_, ref expr)\n-        | ast::ExprKind::Cast(ref expr, _) => can_extend_match_arm_body(expr),\n-        _ => false,\n-    }\n-}\n-\n pub fn rewrite_literal(context: &RewriteContext, l: &ast::Lit, shape: Shape) -> Option<String> {\n     match l.node {\n         ast::LitKind::Str(_, ast::StrStyle::Cooked) => rewrite_string_lit(context, l.span, shape),\n@@ -2663,7 +2126,7 @@ fn choose_rhs<R: Rewrite>(\n     }\n }\n \n-fn prefer_next_line(orig_rhs: &str, next_line_rhs: &str, rhs_tactics: RhsTactics) -> bool {\n+pub fn prefer_next_line(orig_rhs: &str, next_line_rhs: &str, rhs_tactics: RhsTactics) -> bool {\n     rhs_tactics == RhsTactics::ForceNextLine || !next_line_rhs.contains('\\n')\n         || count_newlines(orig_rhs) > count_newlines(next_line_rhs) + 1\n }"}, {"sha": "683a75cb32a4fea8e3608718e9c713b46a46ca4f", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88589f2ad891f115e44cab2f37993885c82c40d8/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88589f2ad891f115e44cab2f37993885c82c40d8/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=88589f2ad891f115e44cab2f37993885c82c40d8", "patch": "@@ -72,6 +72,7 @@ mod issues;\n mod items;\n mod lists;\n mod macros;\n+mod matches;\n mod missed_spans;\n pub mod modules;\n mod overflow;"}, {"sha": "b97fbd8741776fca55f87901e1eb4e8fb2f83f38", "filename": "src/matches.rs", "status": "added", "additions": 531, "deletions": 0, "changes": 531, "blob_url": "https://github.com/rust-lang/rust/blob/88589f2ad891f115e44cab2f37993885c82c40d8/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88589f2ad891f115e44cab2f37993885c82c40d8/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=88589f2ad891f115e44cab2f37993885c82c40d8", "patch": "@@ -0,0 +1,531 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Format match expression.\n+\n+use std::iter::repeat;\n+\n+use config::lists::*;\n+use syntax::{ast, ptr};\n+use syntax::codemap::{BytePos, Span};\n+\n+use codemap::SpanUtils;\n+use comment::combine_strs_with_missing_comments;\n+use config::{Config, ControlBraceStyle, IndentStyle};\n+use expr::{format_expr, is_empty_block, is_simple_block, is_unsafe_block, prefer_next_line,\n+           rewrite_multiple_patterns, ExprType, RhsTactics, ToExpr};\n+use lists::{itemize_list, write_list, ListFormatting};\n+use rewrite::{Rewrite, RewriteContext};\n+use shape::Shape;\n+use spanned::Spanned;\n+use utils::{contains_skip, extra_offset, first_line_width, inner_attributes, last_line_extendable,\n+            mk_sp, ptr_vec_to_ref_vec, trimmed_last_line_width};\n+\n+/// A simple wrapper type against `ast::Arm`. Used inside `write_list()`.\n+struct ArmWrapper<'a> {\n+    pub arm: &'a ast::Arm,\n+    /// True if the arm is the last one in match expression. Used to decide on whether we should add\n+    /// trailing comma to the match arm when `config.trailing_comma() == Never`.\n+    pub is_last: bool,\n+    /// Holds a byte position of `|` at the beginning of the arm pattern, if available.\n+    pub beginning_vert: Option<BytePos>,\n+}\n+\n+impl<'a> ArmWrapper<'a> {\n+    pub fn new(\n+        arm: &'a ast::Arm,\n+        is_last: bool,\n+        beginning_vert: Option<BytePos>,\n+    ) -> ArmWrapper<'a> {\n+        ArmWrapper {\n+            arm,\n+            is_last,\n+            beginning_vert,\n+        }\n+    }\n+}\n+\n+impl<'a> Spanned for ArmWrapper<'a> {\n+    fn span(&self) -> Span {\n+        if let Some(lo) = self.beginning_vert {\n+            mk_sp(lo, self.arm.span().hi())\n+        } else {\n+            self.arm.span()\n+        }\n+    }\n+}\n+\n+impl<'a> Rewrite for ArmWrapper<'a> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        rewrite_match_arm(context, self.arm, shape, self.is_last, self.beginning_vert)\n+    }\n+}\n+\n+pub fn rewrite_match(\n+    context: &RewriteContext,\n+    cond: &ast::Expr,\n+    arms: &[ast::Arm],\n+    shape: Shape,\n+    span: Span,\n+    attrs: &[ast::Attribute],\n+) -> Option<String> {\n+    // Do not take the rhs overhead from the upper expressions into account\n+    // when rewriting match condition.\n+    let cond_shape = Shape {\n+        width: context.budget(shape.used_width()),\n+        ..shape\n+    };\n+    // 6 = `match `\n+    let cond_shape = match context.config.indent_style() {\n+        IndentStyle::Visual => cond_shape.shrink_left(6)?,\n+        IndentStyle::Block => cond_shape.offset_left(6)?,\n+    };\n+    let cond_str = cond.rewrite(context, cond_shape)?;\n+    let alt_block_sep = &shape.indent.to_string_with_newline(context.config);\n+    let block_sep = match context.config.control_brace_style() {\n+        ControlBraceStyle::AlwaysNextLine => alt_block_sep,\n+        _ if last_line_extendable(&cond_str) => \" \",\n+        // 2 = ` {`\n+        _ if cond_str.contains('\\n') || cond_str.len() + 2 > cond_shape.width => alt_block_sep,\n+        _ => \" \",\n+    };\n+\n+    let nested_indent_str = shape\n+        .indent\n+        .block_indent(context.config)\n+        .to_string(context.config);\n+    // Inner attributes.\n+    let inner_attrs = &inner_attributes(attrs);\n+    let inner_attrs_str = if inner_attrs.is_empty() {\n+        String::new()\n+    } else {\n+        inner_attrs\n+            .rewrite(context, shape)\n+            .map(|s| format!(\"{}{}\\n\", nested_indent_str, s))?\n+    };\n+\n+    let open_brace_pos = if inner_attrs.is_empty() {\n+        let hi = if arms.is_empty() {\n+            span.hi()\n+        } else {\n+            arms[0].span().lo()\n+        };\n+        context\n+            .snippet_provider\n+            .span_after(mk_sp(cond.span.hi(), hi), \"{\")\n+    } else {\n+        inner_attrs[inner_attrs.len() - 1].span().hi()\n+    };\n+\n+    if arms.is_empty() {\n+        let snippet = context.snippet(mk_sp(open_brace_pos, span.hi() - BytePos(1)));\n+        if snippet.trim().is_empty() {\n+            Some(format!(\"match {} {{}}\", cond_str))\n+        } else {\n+            // Empty match with comments or inner attributes? We are not going to bother, sorry ;)\n+            Some(context.snippet(span).to_owned())\n+        }\n+    } else {\n+        Some(format!(\n+            \"match {}{}{{\\n{}{}{}\\n{}}}\",\n+            cond_str,\n+            block_sep,\n+            inner_attrs_str,\n+            nested_indent_str,\n+            rewrite_match_arms(context, arms, shape, span, open_brace_pos)?,\n+            shape.indent.to_string(context.config),\n+        ))\n+    }\n+}\n+\n+fn arm_comma(config: &Config, body: &ast::Expr, is_last: bool) -> &'static str {\n+    if is_last && config.trailing_comma() == SeparatorTactic::Never {\n+        \"\"\n+    } else if config.match_block_trailing_comma() {\n+        \",\"\n+    } else if let ast::ExprKind::Block(ref block) = body.node {\n+        if let ast::BlockCheckMode::Default = block.rules {\n+            \"\"\n+        } else {\n+            \",\"\n+        }\n+    } else {\n+        \",\"\n+    }\n+}\n+\n+/// Collect a byte position of the beginning `|` for each arm, if available.\n+fn collect_beginning_verts(\n+    context: &RewriteContext,\n+    arms: &[ast::Arm],\n+    span: Span,\n+) -> Vec<Option<BytePos>> {\n+    let mut beginning_verts = Vec::with_capacity(arms.len());\n+    let mut lo = context.snippet_provider.span_after(span, \"{\");\n+    for arm in arms {\n+        let hi = arm.pats[0].span.lo();\n+        let missing_span = mk_sp(lo, hi);\n+        beginning_verts.push(context.snippet_provider.opt_span_before(missing_span, \"|\"));\n+        lo = arm.span().hi();\n+    }\n+    beginning_verts\n+}\n+\n+fn rewrite_match_arms(\n+    context: &RewriteContext,\n+    arms: &[ast::Arm],\n+    shape: Shape,\n+    span: Span,\n+    open_brace_pos: BytePos,\n+) -> Option<String> {\n+    let arm_shape = shape\n+        .block_indent(context.config.tab_spaces())\n+        .with_max_width(context.config);\n+\n+    let arm_len = arms.len();\n+    let is_last_iter = repeat(false)\n+        .take(arm_len.checked_sub(1).unwrap_or(0))\n+        .chain(repeat(true));\n+    let beginning_verts = collect_beginning_verts(context, arms, span);\n+    let items = itemize_list(\n+        context.snippet_provider,\n+        arms.iter()\n+            .zip(is_last_iter)\n+            .zip(beginning_verts.into_iter())\n+            .map(|((arm, is_last), beginning_vert)| ArmWrapper::new(arm, is_last, beginning_vert)),\n+        \"}\",\n+        \"|\",\n+        |arm| arm.span().lo(),\n+        |arm| arm.span().hi(),\n+        |arm| arm.rewrite(context, arm_shape),\n+        open_brace_pos,\n+        span.hi(),\n+        false,\n+    );\n+    let arms_vec: Vec<_> = items.collect();\n+    let fmt = ListFormatting {\n+        tactic: DefinitiveListTactic::Vertical,\n+        // We will add/remove commas inside `arm.rewrite()`, and hence no separator here.\n+        separator: \"\",\n+        trailing_separator: SeparatorTactic::Never,\n+        separator_place: SeparatorPlace::Back,\n+        shape: arm_shape,\n+        ends_with_newline: true,\n+        preserve_newline: true,\n+        config: context.config,\n+    };\n+\n+    write_list(&arms_vec, &fmt)\n+}\n+\n+fn rewrite_match_arm(\n+    context: &RewriteContext,\n+    arm: &ast::Arm,\n+    shape: Shape,\n+    is_last: bool,\n+    beginning_vert: Option<BytePos>,\n+) -> Option<String> {\n+    let (missing_span, attrs_str) = if !arm.attrs.is_empty() {\n+        if contains_skip(&arm.attrs) {\n+            let (_, body) = flatten_arm_body(context, &arm.body);\n+            // `arm.span()` does not include trailing comma, add it manually.\n+            return Some(format!(\n+                \"{}{}\",\n+                context.snippet(arm.span()),\n+                arm_comma(context.config, body, is_last),\n+            ));\n+        }\n+        let missing_span = mk_sp(\n+            arm.attrs[arm.attrs.len() - 1].span.hi(),\n+            arm.pats[0].span.lo(),\n+        );\n+        (missing_span, arm.attrs.rewrite(context, shape)?)\n+    } else {\n+        (mk_sp(arm.span().lo(), arm.span().lo()), String::new())\n+    };\n+    let pats_str = rewrite_match_pattern(\n+        context,\n+        &ptr_vec_to_ref_vec(&arm.pats),\n+        &arm.guard,\n+        beginning_vert.is_some(),\n+        shape,\n+    ).and_then(|pats_str| {\n+        combine_strs_with_missing_comments(\n+            context,\n+            &attrs_str,\n+            &pats_str,\n+            missing_span,\n+            shape,\n+            false,\n+        )\n+    })?;\n+    rewrite_match_body(\n+        context,\n+        &arm.body,\n+        &pats_str,\n+        shape,\n+        arm.guard.is_some(),\n+        is_last,\n+    )\n+}\n+\n+fn rewrite_match_pattern(\n+    context: &RewriteContext,\n+    pats: &[&ast::Pat],\n+    guard: &Option<ptr::P<ast::Expr>>,\n+    has_beginning_vert: bool,\n+    shape: Shape,\n+) -> Option<String> {\n+    // Patterns\n+    // 5 = ` => {`\n+    // 2 = `| `\n+    let pat_shape = shape\n+        .sub_width(5)?\n+        .offset_left(if has_beginning_vert { 2 } else { 0 })?;\n+    let pats_str = rewrite_multiple_patterns(context, pats, pat_shape)?;\n+    let beginning_vert = if has_beginning_vert { \"| \" } else { \"\" };\n+\n+    // Guard\n+    let guard_str = rewrite_guard(context, guard, shape, trimmed_last_line_width(&pats_str))?;\n+\n+    Some(format!(\"{}{}{}\", beginning_vert, pats_str, guard_str))\n+}\n+\n+// (extend, body)\n+// @extend: true if the arm body can be put next to `=>`\n+// @body: flattened body, if the body is block with a single expression\n+fn flatten_arm_body<'a>(context: &'a RewriteContext, body: &'a ast::Expr) -> (bool, &'a ast::Expr) {\n+    match body.node {\n+        ast::ExprKind::Block(ref block)\n+            if !is_unsafe_block(block)\n+                && is_simple_block(block, Some(&body.attrs), context.codemap) =>\n+        {\n+            if let ast::StmtKind::Expr(ref expr) = block.stmts[0].node {\n+                (\n+                    !context.config.force_multiline_blocks() && can_extend_match_arm_body(expr),\n+                    &*expr,\n+                )\n+            } else {\n+                (false, &*body)\n+            }\n+        }\n+        _ => (\n+            !context.config.force_multiline_blocks() && body.can_be_overflowed(context, 1),\n+            &*body,\n+        ),\n+    }\n+}\n+\n+fn rewrite_match_body(\n+    context: &RewriteContext,\n+    body: &ptr::P<ast::Expr>,\n+    pats_str: &str,\n+    shape: Shape,\n+    has_guard: bool,\n+    is_last: bool,\n+) -> Option<String> {\n+    let (extend, body) = flatten_arm_body(context, body);\n+    let (is_block, is_empty_block) = if let ast::ExprKind::Block(ref block) = body.node {\n+        (\n+            true,\n+            is_empty_block(block, Some(&body.attrs), context.codemap),\n+        )\n+    } else {\n+        (false, false)\n+    };\n+\n+    let comma = arm_comma(context.config, body, is_last);\n+    let alt_block_sep = &shape.indent.to_string_with_newline(context.config);\n+\n+    let combine_orig_body = |body_str: &str| {\n+        let block_sep = match context.config.control_brace_style() {\n+            ControlBraceStyle::AlwaysNextLine if is_block => alt_block_sep,\n+            _ => \" \",\n+        };\n+\n+        Some(format!(\"{} =>{}{}{}\", pats_str, block_sep, body_str, comma))\n+    };\n+\n+    let forbid_same_line = has_guard && pats_str.contains('\\n') && !is_empty_block;\n+    let next_line_indent = if !is_block || is_empty_block {\n+        shape.indent.block_indent(context.config)\n+    } else {\n+        shape.indent\n+    };\n+    let combine_next_line_body = |body_str: &str| {\n+        if is_block {\n+            return Some(format!(\n+                \"{} =>{}{}\",\n+                pats_str,\n+                next_line_indent.to_string_with_newline(context.config),\n+                body_str\n+            ));\n+        }\n+\n+        let indent_str = shape.indent.to_string_with_newline(context.config);\n+        let nested_indent_str = next_line_indent.to_string_with_newline(context.config);\n+        let (body_prefix, body_suffix) = if context.config.match_arm_blocks() {\n+            let comma = if context.config.match_block_trailing_comma() {\n+                \",\"\n+            } else {\n+                \"\"\n+            };\n+            (\"{\", format!(\"{}}}{}\", indent_str, comma))\n+        } else {\n+            (\"\", String::from(\",\"))\n+        };\n+\n+        let block_sep = match context.config.control_brace_style() {\n+            ControlBraceStyle::AlwaysNextLine => format!(\"{}{}\", alt_block_sep, body_prefix),\n+            _ if body_prefix.is_empty() => \"\".to_owned(),\n+            _ if forbid_same_line => format!(\"{}{}\", alt_block_sep, body_prefix),\n+            _ => format!(\" {}\", body_prefix),\n+        } + &nested_indent_str;\n+\n+        Some(format!(\n+            \"{} =>{}{}{}\",\n+            pats_str, block_sep, body_str, body_suffix\n+        ))\n+    };\n+\n+    // Let's try and get the arm body on the same line as the condition.\n+    // 4 = ` => `.len()\n+    let orig_body_shape = shape\n+        .offset_left(extra_offset(pats_str, shape) + 4)\n+        .and_then(|shape| shape.sub_width(comma.len()));\n+    let orig_body = if let Some(body_shape) = orig_body_shape {\n+        let rewrite = nop_block_collapse(\n+            format_expr(body, ExprType::Statement, context, body_shape),\n+            body_shape.width,\n+        );\n+\n+        match rewrite {\n+            Some(ref body_str)\n+                if !forbid_same_line\n+                    && (is_block\n+                        || (!body_str.contains('\\n') && body_str.len() <= body_shape.width)) =>\n+            {\n+                return combine_orig_body(body_str);\n+            }\n+            _ => rewrite,\n+        }\n+    } else {\n+        None\n+    };\n+    let orig_budget = orig_body_shape.map_or(0, |shape| shape.width);\n+\n+    // Try putting body on the next line and see if it looks better.\n+    let next_line_body_shape = Shape::indented(next_line_indent, context.config);\n+    let next_line_body = nop_block_collapse(\n+        format_expr(body, ExprType::Statement, context, next_line_body_shape),\n+        next_line_body_shape.width,\n+    );\n+    match (orig_body, next_line_body) {\n+        (Some(ref orig_str), Some(ref next_line_str))\n+            if forbid_same_line\n+                || prefer_next_line(orig_str, next_line_str, RhsTactics::Default) =>\n+        {\n+            combine_next_line_body(next_line_str)\n+        }\n+        (Some(ref orig_str), _) if extend && first_line_width(orig_str) <= orig_budget => {\n+            combine_orig_body(orig_str)\n+        }\n+        (Some(ref orig_str), Some(ref next_line_str)) if orig_str.contains('\\n') => {\n+            combine_next_line_body(next_line_str)\n+        }\n+        (None, Some(ref next_line_str)) => combine_next_line_body(next_line_str),\n+        (None, None) => None,\n+        (Some(ref orig_str), _) => combine_orig_body(orig_str),\n+    }\n+}\n+\n+// The `if ...` guard on a match arm.\n+fn rewrite_guard(\n+    context: &RewriteContext,\n+    guard: &Option<ptr::P<ast::Expr>>,\n+    shape: Shape,\n+    // The amount of space used up on this line for the pattern in\n+    // the arm (excludes offset).\n+    pattern_width: usize,\n+) -> Option<String> {\n+    if let Some(ref guard) = *guard {\n+        // First try to fit the guard string on the same line as the pattern.\n+        // 4 = ` if `, 5 = ` => {`\n+        let cond_shape = shape\n+            .offset_left(pattern_width + 4)\n+            .and_then(|s| s.sub_width(5));\n+        if let Some(cond_shape) = cond_shape {\n+            if let Some(cond_str) = guard.rewrite(context, cond_shape) {\n+                if !cond_str.contains('\\n') || pattern_width <= context.config.tab_spaces() {\n+                    return Some(format!(\" if {}\", cond_str));\n+                }\n+            }\n+        }\n+\n+        // Not enough space to put the guard after the pattern, try a newline.\n+        // 3 = `if `, 5 = ` => {`\n+        let cond_shape = Shape::indented(shape.indent.block_indent(context.config), context.config)\n+            .offset_left(3)\n+            .and_then(|s| s.sub_width(5));\n+        if let Some(cond_shape) = cond_shape {\n+            if let Some(cond_str) = guard.rewrite(context, cond_shape) {\n+                return Some(format!(\n+                    \"{}if {}\",\n+                    cond_shape.indent.to_string_with_newline(context.config),\n+                    cond_str\n+                ));\n+            }\n+        }\n+\n+        None\n+    } else {\n+        Some(String::new())\n+    }\n+}\n+\n+fn nop_block_collapse(block_str: Option<String>, budget: usize) -> Option<String> {\n+    debug!(\"nop_block_collapse {:?} {}\", block_str, budget);\n+    block_str.map(|block_str| {\n+        if block_str.starts_with('{') && budget >= 2\n+            && (block_str[1..].find(|c: char| !c.is_whitespace()).unwrap() == block_str.len() - 2)\n+        {\n+            \"{}\".to_owned()\n+        } else {\n+            block_str.to_owned()\n+        }\n+    })\n+}\n+\n+fn can_extend_match_arm_body(body: &ast::Expr) -> bool {\n+    match body.node {\n+        // We do not allow `if` to stay on the same line, since we could easily mistake\n+        // `pat => if cond { ... }` and `pat if cond => { ... }`.\n+        ast::ExprKind::If(..) | ast::ExprKind::IfLet(..) => false,\n+        ast::ExprKind::ForLoop(..)\n+        | ast::ExprKind::Loop(..)\n+        | ast::ExprKind::While(..)\n+        | ast::ExprKind::WhileLet(..)\n+        | ast::ExprKind::Match(..)\n+        | ast::ExprKind::Block(..)\n+        | ast::ExprKind::Closure(..)\n+        | ast::ExprKind::Array(..)\n+        | ast::ExprKind::Call(..)\n+        | ast::ExprKind::MethodCall(..)\n+        | ast::ExprKind::Mac(..)\n+        | ast::ExprKind::Struct(..)\n+        | ast::ExprKind::Tup(..) => true,\n+        ast::ExprKind::AddrOf(_, ref expr)\n+        | ast::ExprKind::Box(ref expr)\n+        | ast::ExprKind::Try(ref expr)\n+        | ast::ExprKind::Unary(_, ref expr)\n+        | ast::ExprKind::Cast(ref expr, _) => can_extend_match_arm_body(expr),\n+        _ => false,\n+    }\n+}"}, {"sha": "cfff023bafc4bad922318290acfa43b4dc90349a", "filename": "src/patterns.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/88589f2ad891f115e44cab2f37993885c82c40d8/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88589f2ad891f115e44cab2f37993885c82c40d8/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=88589f2ad891f115e44cab2f37993885c82c40d8", "patch": "@@ -27,6 +27,40 @@ use spanned::Spanned;\n use types::{rewrite_path, PathContext};\n use utils::{format_mutability, mk_sp};\n \n+/// Returns true if the given pattern is short. A short pattern is defined by the following grammer:\n+///\n+/// [small, ntp]:\n+///     - single token\n+///     - `&[single-line, ntp]`\n+///\n+/// [small]:\n+///     - `[small, ntp]`\n+///     - unary tuple constructor `([small, ntp])`\n+///     - `&[small]`\n+pub fn is_short_pattern(pat: &ast::Pat, pat_str: &str) -> bool {\n+    // We also require that the pattern is reasonably 'small' with its literal width.\n+    pat_str.len() <= 20 && !pat_str.contains('\\n') && is_short_pattern_inner(pat)\n+}\n+\n+fn is_short_pattern_inner(pat: &ast::Pat) -> bool {\n+    match pat.node {\n+        ast::PatKind::Wild | ast::PatKind::Lit(_) => true,\n+        ast::PatKind::Ident(_, _, ref pat) => pat.is_none(),\n+        ast::PatKind::Struct(..)\n+        | ast::PatKind::Mac(..)\n+        | ast::PatKind::Slice(..)\n+        | ast::PatKind::Path(..)\n+        | ast::PatKind::Range(..) => false,\n+        ast::PatKind::Tuple(ref subpats, _) => subpats.len() <= 1,\n+        ast::PatKind::TupleStruct(ref path, ref subpats, _) => {\n+            path.segments.len() <= 1 && subpats.len() <= 1\n+        }\n+        ast::PatKind::Box(ref p) | ast::PatKind::Ref(ref p, _) | ast::PatKind::Paren(ref p) => {\n+            is_short_pattern_inner(&*p)\n+        }\n+    }\n+}\n+\n impl Rewrite for Pat {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         match self.node {"}]}