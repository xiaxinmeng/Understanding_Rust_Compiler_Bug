{"sha": "6421427b74f87ae463a623edd684c34b50790bb2", "node_id": "C_kwDOAAsO6NoAKDY0MjE0MjdiNzRmODdhZTQ2M2E2MjNlZGQ2ODRjMzRiNTA3OTBiYjI", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-08-18T18:19:40Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-08-18T18:19:40Z"}, "message": "Move Span lowering from debuginfo finalization to codegen\n\nThis removes the dependency on TyCtxt from the debuginfo finalization\ncode.", "tree": {"sha": "8db3c4ccec27e6d882d29a95c6f2243e3c127d1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8db3c4ccec27e6d882d29a95c6f2243e3c127d1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6421427b74f87ae463a623edd684c34b50790bb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6421427b74f87ae463a623edd684c34b50790bb2", "html_url": "https://github.com/rust-lang/rust/commit/6421427b74f87ae463a623edd684c34b50790bb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6421427b74f87ae463a623edd684c34b50790bb2/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0534a555ccb1a62c2f379bbd2e8cd323e6652e31", "url": "https://api.github.com/repos/rust-lang/rust/commits/0534a555ccb1a62c2f379bbd2e8cd323e6652e31", "html_url": "https://github.com/rust-lang/rust/commit/0534a555ccb1a62c2f379bbd2e8cd323e6652e31"}], "stats": {"total": 214, "additions": 100, "deletions": 114}, "files": [{"sha": "5f6d9f374fddfa3b23a1316cf65d01427f109476", "filename": "src/base.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6421427b74f87ae463a623edd684c34b50790bb2/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6421427b74f87ae463a623edd684c34b50790bb2/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=6421427b74f87ae463a623edd684c34b50790bb2", "patch": "@@ -7,8 +7,6 @@ use rustc_middle::ty::layout::FnAbiOf;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::SymbolName;\n \n-use indexmap::IndexSet;\n-\n use crate::constant::ConstantCx;\n use crate::debuginfo::FunctionDebugContext;\n use crate::prelude::*;\n@@ -20,8 +18,6 @@ struct CodegenedFunction<'tcx> {\n     func: Function,\n     clif_comments: CommentWriter,\n     func_debug_cx: Option<FunctionDebugContext>,\n-    function_span: Span,\n-    source_info_set: IndexSet<SourceInfo>,\n }\n \n pub(crate) fn codegen_and_compile_fn<'tcx>(\n@@ -37,7 +33,7 @@ pub(crate) fn codegen_and_compile_fn<'tcx>(\n     let cached_func = std::mem::replace(&mut cached_context.func, Function::new());\n     let codegened_func = codegen_fn(tcx, cx, cached_func, module, instance);\n \n-    compile_fn(tcx, cx, cached_context, module, codegened_func);\n+    compile_fn(cx, cached_context, module, codegened_func);\n }\n \n fn codegen_fn<'tcx>(\n@@ -110,7 +106,7 @@ fn codegen_fn<'tcx>(\n         caller_location: None, // set by `codegen_fn_prelude`\n \n         clif_comments,\n-        source_info_set: indexmap::IndexSet::new(),\n+        last_source_file: None,\n         next_ssa_var: 0,\n     };\n \n@@ -119,8 +115,6 @@ fn codegen_fn<'tcx>(\n     // Recover all necessary data from fx, before accessing func will prevent future access to it.\n     let clif_comments = fx.clif_comments;\n     let func_debug_cx = fx.func_debug_cx;\n-    let function_span = fx.mir.span;\n-    let source_info_set = fx.source_info_set;\n \n     fx.constants_cx.finalize(fx.tcx, &mut *fx.module);\n \n@@ -138,19 +132,10 @@ fn codegen_fn<'tcx>(\n     // Verify function\n     verify_func(tcx, &clif_comments, &func);\n \n-    CodegenedFunction {\n-        symbol_name,\n-        func_id,\n-        func,\n-        clif_comments,\n-        func_debug_cx,\n-        function_span,\n-        source_info_set,\n-    }\n+    CodegenedFunction { symbol_name, func_id, func, clif_comments, func_debug_cx }\n }\n \n fn compile_fn<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n     cx: &mut crate::CodegenCx,\n     cached_context: &mut Context,\n     module: &mut dyn Module,\n@@ -234,11 +219,8 @@ fn compile_fn<'tcx>(\n         if let Some(debug_context) = debug_context {\n             codegened_func.func_debug_cx.unwrap().finalize(\n                 debug_context,\n-                tcx,\n                 codegened_func.func_id,\n                 context,\n-                codegened_func.function_span,\n-                &codegened_func.source_info_set,\n             );\n         }\n         unwind_context.add_function(codegened_func.func_id, &context, isa);"}, {"sha": "4a80b79a9dc1b04c91e90d4f1eaacdddc55b020e", "filename": "src/common.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6421427b74f87ae463a623edd684c34b50790bb2/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6421427b74f87ae463a623edd684c34b50790bb2/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=6421427b74f87ae463a623edd684c34b50790bb2", "patch": "@@ -1,9 +1,13 @@\n use cranelift_codegen::isa::TargetFrontendConfig;\n+use gimli::write::FileId;\n+\n+use rustc_data_structures::sync::Lrc;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::layout::{\n     FnAbiError, FnAbiOfHelpers, FnAbiRequest, LayoutError, LayoutOfHelpers,\n };\n use rustc_middle::ty::SymbolName;\n+use rustc_span::SourceFile;\n use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Integer, Primitive};\n use rustc_target::spec::{HasTargetSpec, Target};\n@@ -254,7 +258,11 @@ pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n     pub(crate) caller_location: Option<CValue<'tcx>>,\n \n     pub(crate) clif_comments: crate::pretty_clif::CommentWriter,\n-    pub(crate) source_info_set: indexmap::IndexSet<SourceInfo>,\n+\n+    /// Last accessed source file and it's debuginfo file id.\n+    ///\n+    /// For optimization purposes only\n+    pub(crate) last_source_file: Option<(Lrc<SourceFile>, FileId)>,\n \n     /// This should only be accessed by `CPlace::new_var`.\n     pub(crate) next_ssa_var: u32,\n@@ -338,8 +346,31 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     }\n \n     pub(crate) fn set_debug_loc(&mut self, source_info: mir::SourceInfo) {\n-        let (index, _) = self.source_info_set.insert_full(source_info);\n-        self.bcx.set_srcloc(SourceLoc::new(index as u32));\n+        if let Some(debug_context) = &mut self.cx.debug_context {\n+            let (file, line, column) =\n+                DebugContext::get_span_loc(self.tcx, self.mir.span, source_info.span);\n+\n+            // add_source_file is very slow.\n+            // Optimize for the common case of the current file not being changed.\n+            let mut cached_file_id = None;\n+            if let Some((ref last_source_file, last_file_id)) = self.last_source_file {\n+                // If the allocations are not equal, the files may still be equal, but that\n+                // doesn't matter, as this is just an optimization.\n+                if rustc_data_structures::sync::Lrc::ptr_eq(last_source_file, &file) {\n+                    cached_file_id = Some(last_file_id);\n+                }\n+            }\n+\n+            let file_id = if let Some(file_id) = cached_file_id {\n+                file_id\n+            } else {\n+                debug_context.add_source_file(&file)\n+            };\n+\n+            let source_loc =\n+                self.func_debug_cx.as_mut().unwrap().add_dbg_loc(file_id, line, column);\n+            self.bcx.set_srcloc(source_loc);\n+        }\n     }\n \n     // Note: must be kept in sync with get_caller_location from cg_ssa"}, {"sha": "ff6a21eef0d12a2380e190949329c5b46871b9fd", "filename": "src/debuginfo/line_info.rs", "status": "modified", "additions": 45, "deletions": 74, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/6421427b74f87ae463a623edd684c34b50790bb2/src%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6421427b74f87ae463a623edd684c34b50790bb2/src%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fline_info.rs?ref=6421427b74f87ae463a623edd684c34b50790bb2", "patch": "@@ -48,30 +48,6 @@ fn osstr_as_utf8_bytes(path: &OsStr) -> &[u8] {\n     }\n }\n \n-fn get_span_loc(tcx: TyCtxt<'_>, function_span: Span, span: Span) -> (Lrc<SourceFile>, u64, u64) {\n-    // Based on https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src/librustc_codegen_ssa/mir/mod.rs#L116-L131\n-    // In order to have a good line stepping behavior in debugger, we overwrite debug\n-    // locations of macro expansions with that of the outermost expansion site\n-    // (unless the crate is being compiled with `-Z debug-macros`).\n-    let span = if !span.from_expansion() || tcx.sess.opts.unstable_opts.debug_macros {\n-        span\n-    } else {\n-        // Walk up the macro expansion chain until we reach a non-expanded span.\n-        // We also stop at the function body level because no line stepping can occur\n-        // at the level above that.\n-        rustc_span::hygiene::walk_chain(span, function_span.ctxt())\n-    };\n-\n-    match tcx.sess.source_map().lookup_line(span.lo()) {\n-        Ok(SourceFileAndLine { sf: file, line }) => {\n-            let line_pos = file.line_begin_pos(span.lo());\n-\n-            (file, u64::try_from(line).unwrap() + 1, u64::from((span.lo() - line_pos).to_u32()) + 1)\n-        }\n-        Err(file) => (file, 0, 0),\n-    }\n-}\n-\n const MD5_LEN: usize = 16;\n \n fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n@@ -85,6 +61,38 @@ fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n }\n \n impl DebugContext {\n+    pub(crate) fn get_span_loc(\n+        tcx: TyCtxt<'_>,\n+        function_span: Span,\n+        span: Span,\n+    ) -> (Lrc<SourceFile>, u64, u64) {\n+        // Based on https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src/librustc_codegen_ssa/mir/mod.rs#L116-L131\n+        // In order to have a good line stepping behavior in debugger, we overwrite debug\n+        // locations of macro expansions with that of the outermost expansion site\n+        // (unless the crate is being compiled with `-Z debug-macros`).\n+        let span = if !span.from_expansion() || tcx.sess.opts.unstable_opts.debug_macros {\n+            span\n+        } else {\n+            // Walk up the macro expansion chain until we reach a non-expanded span.\n+            // We also stop at the function body level because no line stepping can occur\n+            // at the level above that.\n+            rustc_span::hygiene::walk_chain(span, function_span.ctxt())\n+        };\n+\n+        match tcx.sess.source_map().lookup_line(span.lo()) {\n+            Ok(SourceFileAndLine { sf: file, line }) => {\n+                let line_pos = file.line_begin_pos(span.lo());\n+\n+                (\n+                    file,\n+                    u64::try_from(line).unwrap() + 1,\n+                    u64::from((span.lo() - line_pos).to_u32()) + 1,\n+                )\n+            }\n+            Err(file) => (file, 0, 0),\n+        }\n+    }\n+\n     pub(crate) fn add_source_file(&mut self, source_file: &SourceFile) -> FileId {\n         let line_program: &mut LineProgram = &mut self.dwarf.unit.line_program;\n         let line_strings: &mut LineStringTable = &mut self.dwarf.line_strings;\n@@ -124,63 +132,26 @@ impl DebugContext {\n }\n \n impl FunctionDebugContext {\n-    pub(super) fn set_function_span(\n-        &mut self,\n-        debug_context: &mut DebugContext,\n-        tcx: TyCtxt<'_>,\n-        span: Span,\n-    ) {\n-        let (file, line, column) = get_span_loc(tcx, span, span);\n-\n-        let file_id = debug_context.add_source_file(&file);\n-\n-        let entry = debug_context.dwarf.unit.get_mut(self.entry_id);\n-        entry.set(gimli::DW_AT_decl_file, AttributeValue::FileIndex(Some(file_id)));\n-        entry.set(gimli::DW_AT_decl_line, AttributeValue::Udata(line));\n-        entry.set(gimli::DW_AT_decl_column, AttributeValue::Udata(column));\n+    pub(crate) fn add_dbg_loc(&mut self, file_id: FileId, line: u64, column: u64) -> SourceLoc {\n+        let (index, _) = self.source_loc_set.insert_full((file_id, line, column));\n+        SourceLoc::new(u32::try_from(index).unwrap())\n     }\n \n     pub(super) fn create_debug_lines(\n         &mut self,\n         debug_context: &mut DebugContext,\n-        tcx: TyCtxt<'_>,\n         symbol: usize,\n         context: &Context,\n-        function_span: Span,\n-        source_info_set: &indexmap::IndexSet<SourceInfo>,\n     ) -> CodeOffset {\n-        let mut last_span = None;\n-        let mut last_file = None;\n-        let mut create_row_for_span = |debug_context: &mut DebugContext, span: Span| {\n-            if let Some(last_span) = last_span {\n-                if span == last_span {\n-                    debug_context.dwarf.unit.line_program.generate_row();\n-                    return;\n-                }\n-            }\n-            last_span = Some(span);\n-\n-            let (file, line, col) = get_span_loc(tcx, function_span, span);\n+        let create_row_for_span =\n+            |debug_context: &mut DebugContext, source_loc: (FileId, u64, u64)| {\n+                let (file_id, line, col) = source_loc;\n \n-            // line_program_add_file is very slow.\n-            // Optimize for the common case of the current file not being changed.\n-            let current_file_changed = if let Some(last_file) = &last_file {\n-                // If the allocations are not equal, then the files may still be equal, but that\n-                // is not a problem, as this is just an optimization.\n-                !rustc_data_structures::sync::Lrc::ptr_eq(last_file, &file)\n-            } else {\n-                true\n-            };\n-            if current_file_changed {\n-                let file_id = debug_context.add_source_file(&file);\n                 debug_context.dwarf.unit.line_program.row().file = file_id;\n-                last_file = Some(file);\n-            }\n-\n-            debug_context.dwarf.unit.line_program.row().line = line;\n-            debug_context.dwarf.unit.line_program.row().column = col;\n-            debug_context.dwarf.unit.line_program.generate_row();\n-        };\n+                debug_context.dwarf.unit.line_program.row().line = line;\n+                debug_context.dwarf.unit.line_program.row().column = col;\n+                debug_context.dwarf.unit.line_program.generate_row();\n+            };\n \n         debug_context\n             .dwarf\n@@ -194,10 +165,10 @@ impl FunctionDebugContext {\n         for &MachSrcLoc { start, end, loc } in mcr.buffer.get_srclocs_sorted() {\n             debug_context.dwarf.unit.line_program.row().address_offset = u64::from(start);\n             if !loc.is_default() {\n-                let source_info = *source_info_set.get_index(loc.bits() as usize).unwrap();\n-                create_row_for_span(debug_context, source_info.span);\n+                let source_loc = *self.source_loc_set.get_index(loc.bits() as usize).unwrap();\n+                create_row_for_span(debug_context, source_loc);\n             } else {\n-                create_row_for_span(debug_context, function_span);\n+                create_row_for_span(debug_context, self.function_source_loc);\n             }\n             func_end = end;\n         }"}, {"sha": "c55db2017ee68c31c53b0a59e12c82b6b72c6c7e", "filename": "src/debuginfo/mod.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6421427b74f87ae463a623edd684c34b50790bb2/src%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6421427b74f87ae463a623edd684c34b50790bb2/src%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fmod.rs?ref=6421427b74f87ae463a623edd684c34b50790bb2", "patch": "@@ -11,9 +11,11 @@ use cranelift_codegen::ir::Endianness;\n use cranelift_codegen::isa::TargetIsa;\n \n use gimli::write::{\n-    Address, AttributeValue, DwarfUnit, LineProgram, LineString, Range, RangeList, UnitEntryId,\n+    Address, AttributeValue, DwarfUnit, FileId, LineProgram, LineString, Range, RangeList,\n+    UnitEntryId,\n };\n use gimli::{Encoding, Format, LineEncoding, RunTimeEndian};\n+use indexmap::IndexSet;\n \n pub(crate) use emit::{DebugReloc, DebugRelocName};\n pub(crate) use unwind::UnwindContext;\n@@ -27,6 +29,8 @@ pub(crate) struct DebugContext {\n \n pub(crate) struct FunctionDebugContext {\n     entry_id: UnitEntryId,\n+    function_source_loc: (FileId, u64, u64),\n+    source_loc_set: indexmap::IndexSet<(FileId, u64, u64)>,\n }\n \n impl DebugContext {\n@@ -105,6 +109,10 @@ impl DebugContext {\n         name: &str,\n         function_span: Span,\n     ) -> FunctionDebugContext {\n+        let (file, line, column) = DebugContext::get_span_loc(tcx, function_span, function_span);\n+\n+        let file_id = self.add_source_file(&file);\n+\n         // FIXME: add to appropriate scope instead of root\n         let scope = self.dwarf.unit.root();\n \n@@ -115,34 +123,28 @@ impl DebugContext {\n         entry.set(gimli::DW_AT_name, AttributeValue::StringRef(name_id));\n         entry.set(gimli::DW_AT_linkage_name, AttributeValue::StringRef(name_id));\n \n-        let mut function_debug_context = FunctionDebugContext { entry_id };\n+        entry.set(gimli::DW_AT_decl_file, AttributeValue::FileIndex(Some(file_id)));\n+        entry.set(gimli::DW_AT_decl_line, AttributeValue::Udata(line));\n+        entry.set(gimli::DW_AT_decl_column, AttributeValue::Udata(column));\n \n-        function_debug_context.set_function_span(self, tcx, function_span);\n-\n-        function_debug_context\n+        FunctionDebugContext {\n+            entry_id,\n+            function_source_loc: (file_id, line, column),\n+            source_loc_set: IndexSet::new(),\n+        }\n     }\n }\n \n impl FunctionDebugContext {\n     pub(crate) fn finalize(\n         mut self,\n         debug_context: &mut DebugContext,\n-        tcx: TyCtxt<'_>,\n         func_id: FuncId,\n         context: &Context,\n-        function_span: Span,\n-        source_info_set: &indexmap::IndexSet<SourceInfo>,\n     ) {\n         let symbol = func_id.as_u32() as usize;\n \n-        let end = self.create_debug_lines(\n-            debug_context,\n-            tcx,\n-            symbol,\n-            context,\n-            function_span,\n-            source_info_set,\n-        );\n+        let end = self.create_debug_lines(debug_context, symbol, context);\n \n         debug_context.unit_range_list.0.push(Range::StartLength {\n             begin: Address::Symbol { symbol, addend: 0 },"}]}