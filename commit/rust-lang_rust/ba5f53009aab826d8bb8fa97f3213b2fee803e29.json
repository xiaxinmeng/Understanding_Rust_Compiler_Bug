{"sha": "ba5f53009aab826d8bb8fa97f3213b2fee803e29", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhNWY1MzAwOWFhYjgyNmQ4YmI4ZmE5N2YzMjEzYjJmZWU4MDNlMjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-15T18:22:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-15T18:22:02Z"}, "message": "auto merge of #13948 : huonw/rust/test-regex-filter, r=alexcrichton\n\nThis allows writing a regex to filter tests more precisely, rather than having to list long paths e.g.\r\n\r\n```\r\n$ ./stdtest-x86_64-unknown-linux-gnu 'vec.*clone'\r\n\r\nrunning 2 tests\r\ntest vec::tests::test_clone ... ok\r\ntest vec::tests::test_clone_from ... ok\r\n\r\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured\r\n```\r\n\r\nThe regex change is fully backwards compatible, since test names are Rust\r\nidentifiers + `:`, and hence not special regex characters.\r\n\r\n(See commits for details.)", "tree": {"sha": "b749932a3bac83abb73d22ee28a5ade72b77f117", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b749932a3bac83abb73d22ee28a5ade72b77f117"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba5f53009aab826d8bb8fa97f3213b2fee803e29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba5f53009aab826d8bb8fa97f3213b2fee803e29", "html_url": "https://github.com/rust-lang/rust/commit/ba5f53009aab826d8bb8fa97f3213b2fee803e29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba5f53009aab826d8bb8fa97f3213b2fee803e29/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf", "html_url": "https://github.com/rust-lang/rust/commit/fbd8f4a3a363877b244a88ba3b4fd5d4fd6288cf"}, {"sha": "18c13de5e6dfd4631f9ed05e0ab49305bf0384ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/18c13de5e6dfd4631f9ed05e0ab49305bf0384ac", "html_url": "https://github.com/rust-lang/rust/commit/18c13de5e6dfd4631f9ed05e0ab49305bf0384ac"}], "stats": {"total": 224, "additions": 138, "deletions": 86}, "files": [{"sha": "0b923cca7a2b950dff8ab40b683fd54c45246716", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba5f53009aab826d8bb8fa97f3213b2fee803e29/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ba5f53009aab826d8bb8fa97f3213b2fee803e29/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=ba5f53009aab826d8bb8fa97f3213b2fee803e29", "patch": "@@ -80,7 +80,7 @@ DEPS_collections := std rand\n DEPS_fourcc := syntax std\n DEPS_hexfloat := syntax std\n DEPS_num := std rand\n-DEPS_test := std collections getopts serialize term time\n+DEPS_test := std collections getopts serialize term time regex\n DEPS_time := std serialize\n DEPS_rand := std\n DEPS_url := std collections"}, {"sha": "b1f1e69c5a1874da7e6e877bfef2b31892c34d7a", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba5f53009aab826d8bb8fa97f3213b2fee803e29/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba5f53009aab826d8bb8fa97f3213b2fee803e29/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=ba5f53009aab826d8bb8fa97f3213b2fee803e29", "patch": "@@ -10,6 +10,7 @@\n \n use std::from_str::FromStr;\n use std::fmt;\n+use regex::Regex;\n \n #[deriving(Clone, Eq)]\n pub enum Mode {\n@@ -88,7 +89,7 @@ pub struct Config {\n     pub run_ignored: bool,\n \n     // Only run tests that match this filter\n-    pub filter: Option<~str>,\n+    pub filter: Option<Regex>,\n \n     // Write out a parseable log of tests that were run\n     pub logfile: Option<Path>,"}, {"sha": "3b57e3e98ca05707bf3d6fc7828a98567de35909", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ba5f53009aab826d8bb8fa97f3213b2fee803e29/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba5f53009aab826d8bb8fa97f3213b2fee803e29/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=ba5f53009aab826d8bb8fa97f3213b2fee803e29", "patch": "@@ -23,6 +23,8 @@ extern crate log;\n extern crate green;\n extern crate rustuv;\n \n+extern crate regex;\n+\n use std::os;\n use std::io;\n use std::io::fs;\n@@ -113,6 +115,19 @@ pub fn parse_config(args: Vec<~str> ) -> Config {\n         Path::new(m.opt_str(nm).unwrap())\n     }\n \n+    let filter = if !matches.free.is_empty() {\n+        let s = matches.free.get(0).as_slice();\n+        match regex::Regex::new(s) {\n+            Ok(re) => Some(re),\n+            Err(e) => {\n+                println!(\"failed to parse filter /{}/: {}\", s, e);\n+                fail!()\n+            }\n+        }\n+    } else {\n+        None\n+    };\n+\n     Config {\n         compile_lib_path: matches.opt_str(\"compile-lib-path\").unwrap(),\n         run_lib_path: matches.opt_str(\"run-lib-path\").unwrap(),\n@@ -125,12 +140,7 @@ pub fn parse_config(args: Vec<~str> ) -> Config {\n         stage_id: matches.opt_str(\"stage-id\").unwrap(),\n         mode: FromStr::from_str(matches.opt_str(\"mode\").unwrap()).expect(\"invalid mode\"),\n         run_ignored: matches.opt_present(\"ignored\"),\n-        filter:\n-            if !matches.free.is_empty() {\n-                 Some((*matches.free.get(0)).clone())\n-            } else {\n-                None\n-            },\n+        filter: filter,\n         logfile: matches.opt_str(\"logfile\").map(|s| Path::new(s)),\n         save_metrics: matches.opt_str(\"save-metrics\").map(|s| Path::new(s)),\n         ratchet_metrics:\n@@ -169,7 +179,7 @@ pub fn log_config(config: &Config) {\n     logv(c, format!(\"stage_id: {}\", config.stage_id));\n     logv(c, format!(\"mode: {}\", config.mode));\n     logv(c, format!(\"run_ignored: {}\", config.run_ignored));\n-    logv(c, format!(\"filter: {}\", opt_str(&config.filter)));\n+    logv(c, format!(\"filter: {}\", opt_str(&config.filter.as_ref().map(|re| re.to_str()))));\n     logv(c, format!(\"runtool: {}\", opt_str(&config.runtool)));\n     logv(c, format!(\"host-rustcflags: {}\", opt_str(&config.host_rustcflags)));\n     logv(c, format!(\"target-rustcflags: {}\", opt_str(&config.target_rustcflags)));\n@@ -238,7 +248,7 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n     test::TestOpts {\n         filter: match config.filter {\n             None => None,\n-            Some(ref filter) => Some(filter.to_strbuf()),\n+            Some(ref filter) => Some(filter.clone()),\n         },\n         run_ignored: config.run_ignored,\n         logfile: config.logfile.clone(),"}, {"sha": "057849f1bca736cae83af409610a135909cd0820", "filename": "src/doc/guide-testing.md", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ba5f53009aab826d8bb8fa97f3213b2fee803e29/src%2Fdoc%2Fguide-testing.md", "raw_url": "https://github.com/rust-lang/rust/raw/ba5f53009aab826d8bb8fa97f3213b2fee803e29/src%2Fdoc%2Fguide-testing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-testing.md?ref=ba5f53009aab826d8bb8fa97f3213b2fee803e29", "patch": "@@ -90,10 +90,15 @@ fn test_out_of_bounds_failure() {\n ~~~\n \n A test runner built with the `--test` flag supports a limited set of\n-arguments to control which tests are run: the first free argument\n-passed to a test runner specifies a filter used to narrow down the set\n-of tests being run; the `--ignored` flag tells the test runner to run\n-only tests with the `ignore` attribute.\n+arguments to control which tests are run:\n+\n+- the first free argument passed to a test runner is interpreted as a\n+  regular expression\n+  ([syntax reference](regex/index.html#syntax))\n+  and is used to narrow down the set of tests being run. Note: a plain\n+  string is a valid regular expression that matches itself.\n+- the `--ignored` flag tells the test runner to run only tests with the\n+  `ignore` attribute.\n \n ## Parallelism\n \n@@ -146,16 +151,31 @@ result: FAILED. 1 passed; 1 failed; 0 ignored\n \n ### Running a subset of tests\n \n+Using a plain string:\n+\n+~~~ {.notrust}\n+$ mytests mytest23\n+\n+running 1 tests\n+running driver::tests::mytest23 ... ok\n+\n+result: ok. 1 passed; 0 failed; 0 ignored\n+~~~\n+\n+Using some regular expression features:\n+\n ~~~ {.notrust}\n-$ mytests mytest1\n+$ mytests 'mytest[145]'\n \n-running 11 tests\n+running 13 tests\n running driver::tests::mytest1 ... ok\n+running driver::tests::mytest4 ... ok\n+running driver::tests::mytest5 ... ok\n running driver::tests::mytest10 ... ignored\n ... snip ...\n running driver::tests::mytest19 ... ok\n \n-result: ok. 11 passed; 0 failed; 1 ignored\n+result: ok. 13 passed; 0 failed; 1 ignored\n ~~~\n \n # Microbenchmarking"}, {"sha": "4a9c534945925f48f4ca591fd6962fe9111cad89", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ba5f53009aab826d8bb8fa97f3213b2fee803e29/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba5f53009aab826d8bb8fa97f3213b2fee803e29/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=ba5f53009aab826d8bb8fa97f3213b2fee803e29", "patch": "@@ -16,16 +16,16 @@ A simple wrapper over the platform's dynamic library facilities\n \n */\n \n+\n use c_str::ToCStr;\n-use iter::Iterator;\n use mem;\n use ops::*;\n use option::*;\n use os;\n use path::GenericPath;\n use path;\n use result::*;\n-use slice::{Vector,OwnedVector};\n+use slice::Vector;\n use str;\n use vec::Vec;\n \n@@ -85,10 +85,12 @@ impl DynamicLibrary {\n         } else {\n             (\"LD_LIBRARY_PATH\", ':' as u8)\n         };\n-        let newenv = os::getenv_as_bytes(envvar).unwrap_or(box []);\n-        let mut newenv = newenv.move_iter().collect::<Vec<_>>();\n-        newenv.push_all(&[sep]);\n-        newenv.push_all(path.as_vec());\n+        let mut newenv = Vec::from_slice(path.as_vec());\n+        newenv.push(sep);\n+        match os::getenv_as_bytes(envvar) {\n+            Some(bytes) => newenv.push_all(bytes),\n+            None => {}\n+        }\n         os::setenv(envvar, str::from_utf8(newenv.as_slice()).unwrap());\n     }\n "}, {"sha": "3273e53ed8a0bad0a14e26a5474e43f9cfc57593", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 82, "deletions": 63, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/ba5f53009aab826d8bb8fa97f3213b2fee803e29/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba5f53009aab826d8bb8fa97f3213b2fee803e29/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=ba5f53009aab826d8bb8fa97f3213b2fee803e29", "patch": "@@ -37,6 +37,7 @@\n \n extern crate collections;\n extern crate getopts;\n+extern crate regex;\n extern crate serialize;\n extern crate term;\n extern crate time;\n@@ -45,6 +46,7 @@ use collections::TreeMap;\n use stats::Stats;\n use time::precise_time_ns;\n use getopts::{OptGroup, optflag, optopt};\n+use regex::Regex;\n use serialize::{json, Decodable};\n use serialize::json::{Json, ToJson};\n use term::Terminal;\n@@ -53,6 +55,7 @@ use term::color::{Color, RED, YELLOW, GREEN, CYAN};\n use std::cmp;\n use std::f64;\n use std::fmt;\n+use std::fmt::Show;\n use std::from_str::FromStr;\n use std::io::stdio::StdWriter;\n use std::io::{File, ChanReader, ChanWriter};\n@@ -85,22 +88,27 @@ pub enum TestName {\n     StaticTestName(&'static str),\n     DynTestName(StrBuf)\n }\n-impl fmt::Show for TestName {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl TestName {\n+    fn as_slice<'a>(&'a self) -> &'a str {\n         match *self {\n-            StaticTestName(s) => f.buf.write_str(s),\n-            DynTestName(ref s) => f.buf.write_str(s.as_slice()),\n+            StaticTestName(s) => s,\n+            DynTestName(ref s) => s.as_slice()\n         }\n     }\n }\n+impl Show for TestName {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.as_slice().fmt(f)\n+    }\n+}\n \n #[deriving(Clone)]\n enum NamePadding { PadNone, PadOnLeft, PadOnRight }\n \n impl TestDesc {\n     fn padded_name(&self, column_count: uint, align: NamePadding) -> StrBuf {\n         use std::num::Saturating;\n-        let mut name = StrBuf::from_str(self.name.to_str());\n+        let mut name = StrBuf::from_str(self.name.as_slice());\n         let fill = column_count.saturating_sub(name.len());\n         let mut pad = StrBuf::from_owned_str(\" \".repeat(fill));\n         match align {\n@@ -257,7 +265,7 @@ pub fn test_main_static_x(args: &[~str], tests: &[TestDescAndFn]) {\n }\n \n pub struct TestOpts {\n-    pub filter: Option<StrBuf>,\n+    pub filter: Option<Regex>,\n     pub run_ignored: bool,\n     pub run_tests: bool,\n     pub run_benchmarks: bool,\n@@ -312,14 +320,12 @@ fn optgroups() -> Vec<getopts::OptGroup> {\n                                          task, allow printing directly\"))\n }\n \n-fn usage(binary: &str, helpstr: &str) {\n+fn usage(binary: &str) {\n     let message = format!(\"Usage: {} [OPTIONS] [FILTER]\", binary);\n-    println!(\"{}\", getopts::usage(message, optgroups().as_slice()));\n-    println!(\"\");\n-    if helpstr == \"help\" {\n-        println!(\"{}\", \"\\\n-The FILTER is matched against the name of all tests to run, and if any tests\n-have a substring match, only those tests are run.\n+    println!(r\"{usage}\n+\n+The FILTER regex is tested against the name of all tests to run, and\n+only those tests that match are run.\n \n By default, all tests are run in parallel. This can be altered with the\n RUST_TEST_TASKS environment variable when running tests (set it to 1).\n@@ -330,18 +336,18 @@ environment variable. Logging is not captured by default.\n \n Test Attributes:\n \n-    #[test]        - Indicates a function is a test to be run. This function\n+    \\#[test]        - Indicates a function is a test to be run. This function\n                      takes no arguments.\n-    #[bench]       - Indicates a function is a benchmark to be run. This\n+    \\#[bench]       - Indicates a function is a benchmark to be run. This\n                      function takes one argument (test::Bencher).\n-    #[should_fail] - This function (also labeled with #[test]) will only pass if\n+    \\#[should_fail] - This function (also labeled with \\#[test]) will only pass if\n                      the code causes a failure (an assertion failure or fail!)\n-    #[ignore]      - When applied to a function which is already attributed as a\n+    \\#[ignore]      - When applied to a function which is already attributed as a\n                      test, then the test runner will ignore these tests during\n                      normal test runs. Running with --ignored will run these\n-                     tests. This may also be written as #[ignore(cfg(...))] to\n-                     ignore the test on certain configurations.\");\n-    }\n+                     tests. This may also be written as \\#[ignore(cfg(...))] to\n+                     ignore the test on certain configurations.\",\n+             usage = getopts::usage(message, optgroups().as_slice()));\n }\n \n // Parses command line arguments into test options\n@@ -357,21 +363,17 @@ pub fn parse_opts(args: &[StrBuf]) -> Option<OptRes> {\n           Err(f) => return Some(Err(f.to_err_msg().to_strbuf()))\n         };\n \n-    if matches.opt_present(\"h\") {\n-        usage(args[0].as_slice(), \"h\");\n-        return None;\n-    }\n-    if matches.opt_present(\"help\") {\n-        usage(args[0].as_slice(), \"help\");\n-        return None;\n-    }\n+    if matches.opt_present(\"h\") { usage(args[0].as_slice()); return None; }\n \n-    let filter =\n-        if matches.free.len() > 0 {\n-            Some((*matches.free.get(0)).to_strbuf())\n-        } else {\n-            None\n-        };\n+    let filter = if matches.free.len() > 0 {\n+        let s = matches.free.get(0).as_slice();\n+        match Regex::new(s) {\n+            Ok(re) => Some(re),\n+            Err(e) => return Some(Err(format_strbuf!(\"could not parse /{}/: {}\", s, e)))\n+        }\n+    } else {\n+        None\n+    };\n \n     let run_ignored = matches.opt_present(\"ignored\");\n \n@@ -590,7 +592,7 @@ impl<T: Writer> ConsoleTestState<T> {\n                         TrIgnored => \"ignored\".to_strbuf(),\n                         TrMetrics(ref mm) => fmt_metrics(mm),\n                         TrBench(ref bs) => fmt_bench_samples(bs)\n-                    }, test.name.to_str());\n+                    }, test.name.as_slice());\n                 o.write(s.as_bytes())\n             }\n         }\n@@ -604,7 +606,7 @@ impl<T: Writer> ConsoleTestState<T> {\n             failures.push(f.name.to_str());\n             if stdout.len() > 0 {\n                 fail_out.push_str(format!(\"---- {} stdout ----\\n\\t\",\n-                                  f.name.to_str()));\n+                                  f.name.as_slice()));\n                 let output = str::from_utf8_lossy(stdout.as_slice());\n                 fail_out.push_str(output.as_slice().replace(\"\\n\", \"\\n\\t\"));\n                 fail_out.push_str(\"\\n\");\n@@ -618,7 +620,7 @@ impl<T: Writer> ConsoleTestState<T> {\n         try!(self.write_plain(\"\\nfailures:\\n\"));\n         failures.as_mut_slice().sort();\n         for name in failures.iter() {\n-            try!(self.write_plain(format!(\"    {}\\n\", name.to_str())));\n+            try!(self.write_plain(format!(\"    {}\\n\", name.as_slice())));\n         }\n         Ok(())\n     }\n@@ -753,7 +755,7 @@ pub fn run_tests_console(opts: &TestOpts,\n                     TrOk => st.passed += 1,\n                     TrIgnored => st.ignored += 1,\n                     TrMetrics(mm) => {\n-                        let tname = test.name.to_str();\n+                        let tname = test.name.as_slice();\n                         let MetricMap(mm) = mm;\n                         for (k,v) in mm.iter() {\n                             st.metrics\n@@ -764,7 +766,7 @@ pub fn run_tests_console(opts: &TestOpts,\n                         st.measured += 1\n                     }\n                     TrBench(bs) => {\n-                        st.metrics.insert_metric(test.name.to_str(),\n+                        st.metrics.insert_metric(test.name.as_slice(),\n                                                  bs.ns_iter_summ.median,\n                                                  bs.ns_iter_summ.max - bs.ns_iter_summ.min);\n                         st.measured += 1\n@@ -782,12 +784,12 @@ pub fn run_tests_console(opts: &TestOpts,\n     fn len_if_padded(t: &TestDescAndFn) -> uint {\n         match t.testfn.padding() {\n             PadNone => 0u,\n-            PadOnLeft | PadOnRight => t.desc.name.to_str().len(),\n+            PadOnLeft | PadOnRight => t.desc.name.as_slice().len(),\n         }\n     }\n     match tests.iter().max_by(|t|len_if_padded(*t)) {\n         Some(t) => {\n-            let n = t.desc.name.to_str();\n+            let n = t.desc.name.as_slice();\n             st.max_name_len = n.len();\n         },\n         None => {}\n@@ -939,26 +941,12 @@ pub fn filter_tests(\n     let mut filtered = tests;\n \n     // Remove tests that don't match the test filter\n-    filtered = if opts.filter.is_none() {\n-        filtered\n-    } else {\n-        let filter_str = match opts.filter {\n-          Some(ref f) => (*f).clone(),\n-          None => \"\".to_strbuf()\n-        };\n-\n-        fn filter_fn(test: TestDescAndFn, filter_str: &str) ->\n-            Option<TestDescAndFn> {\n-            if test.desc.name.to_str().contains(filter_str) {\n-                return Some(test);\n-            } else {\n-                return None;\n-            }\n+    filtered = match opts.filter {\n+        None => filtered,\n+        Some(ref re) => {\n+            filtered.move_iter()\n+                .filter(|test| re.is_match(test.desc.name.as_slice())).collect()\n         }\n-\n-        filtered.move_iter()\n-                .filter_map(|x| filter_fn(x, filter_str.as_slice()))\n-                .collect()\n     };\n \n     // Maybe pull out the ignored test and unignore them\n@@ -980,7 +968,7 @@ pub fn filter_tests(\n     };\n \n     // Sort the tests alphabetically\n-    filtered.sort_by(|t1, t2| t1.desc.name.to_str().cmp(&t2.desc.name.to_str()));\n+    filtered.sort_by(|t1, t2| t1.desc.name.as_slice().cmp(&t2.desc.name.as_slice()));\n \n     // Shard the remaining tests, if sharding requested.\n     match opts.test_shard {\n@@ -1445,12 +1433,12 @@ mod tests {\n \n     #[test]\n     fn first_free_arg_should_be_a_filter() {\n-        let args = vec!(\"progname\".to_strbuf(), \"filter\".to_strbuf());\n+        let args = vec!(\"progname\".to_strbuf(), \"some_regex_filter\".to_strbuf());\n         let opts = match parse_opts(args.as_slice()) {\n             Some(Ok(o)) => o,\n             _ => fail!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n         };\n-        assert!(\"filter\" == opts.filter.clone().unwrap().as_slice());\n+        assert!(opts.filter.expect(\"should've found filter\").is_match(\"some_regex_filter\"))\n     }\n \n     #[test]\n@@ -1549,6 +1537,37 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    pub fn filter_tests_regex() {\n+        let mut opts = TestOpts::new();\n+        opts.filter = Some(::regex::Regex::new(\"a.*b.+c\").unwrap());\n+\n+        let mut names = [\"yes::abXc\", \"yes::aXXXbXXXXc\",\n+                         \"no::XYZ\", \"no::abc\"];\n+        names.sort();\n+\n+        fn test_fn() {}\n+        let tests = names.iter().map(|name| {\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: DynTestName(name.to_strbuf()),\n+                    ignore: false,\n+                    should_fail: false\n+                },\n+                testfn: DynTestFn(test_fn)\n+            }\n+        }).collect();\n+        let filtered = filter_tests(&opts, tests);\n+\n+        let expected: Vec<&str> =\n+            names.iter().map(|&s| s).filter(|name| name.starts_with(\"yes\")).collect();\n+\n+        assert_eq!(filtered.len(), expected.len());\n+        for (test, expected_name) in filtered.iter().zip(expected.iter()) {\n+            assert_eq!(test.desc.name.as_slice(), *expected_name);\n+        }\n+    }\n+\n     #[test]\n     pub fn test_metricmap_compare() {\n         let mut m1 = MetricMap::new();"}]}