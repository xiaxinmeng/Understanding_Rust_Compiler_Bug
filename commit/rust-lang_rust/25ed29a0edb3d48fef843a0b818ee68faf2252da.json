{"sha": "25ed29a0edb3d48fef843a0b818ee68faf2252da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZWQyOWEwZWRiM2Q0OGZlZjg0M2EwYjgxOGVlNjhmYWYyMjUyZGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-06T09:31:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-06T09:31:02Z"}, "message": "auto merge of #9000 : brson/rust/dns, r=anasazi\n\nThis exposes a very simple function for resolving host names. There's a lot more that needs to be done, but this is probably enough for servo to get started connecting to real websites again.", "tree": {"sha": "cb046f4d81aed8b3f3677aa29e34a78b6a001baf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb046f4d81aed8b3f3677aa29e34a78b6a001baf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25ed29a0edb3d48fef843a0b818ee68faf2252da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25ed29a0edb3d48fef843a0b818ee68faf2252da", "html_url": "https://github.com/rust-lang/rust/commit/25ed29a0edb3d48fef843a0b818ee68faf2252da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25ed29a0edb3d48fef843a0b818ee68faf2252da/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b650da1673370b58d648fb99708e9dfcbbf79689", "url": "https://api.github.com/repos/rust-lang/rust/commits/b650da1673370b58d648fb99708e9dfcbbf79689", "html_url": "https://github.com/rust-lang/rust/commit/b650da1673370b58d648fb99708e9dfcbbf79689"}, {"sha": "807408b708a11c9a96b2dc4fedd611276273574f", "url": "https://api.github.com/repos/rust-lang/rust/commits/807408b708a11c9a96b2dc4fedd611276273574f", "html_url": "https://github.com/rust-lang/rust/commit/807408b708a11c9a96b2dc4fedd611276273574f"}], "stats": {"total": 403, "additions": 388, "deletions": 15}, "files": [{"sha": "5ceea8774536a96c89ca9d890c4f29c8c0d4f1fc", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=25ed29a0edb3d48fef843a0b818ee68faf2252da", "patch": "@@ -269,13 +269,7 @@ pub use self::extensions::WriterByteConversions;\n pub mod file;\n \n /// Synchronous, non-blocking network I/O.\n-pub mod net {\n-    pub mod tcp;\n-    pub mod udp;\n-    pub mod ip;\n-    #[cfg(unix)]\n-    pub mod unix;\n-}\n+pub mod net;\n \n /// Readers and Writers for memory buffers and strings.\n pub mod mem;"}, {"sha": "f44e879a63a2aa58a2b822267c70aeebb44e3415", "filename": "src/libstd/rt/io/net/mod.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Flibstd%2Frt%2Fio%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Flibstd%2Frt%2Fio%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fmod.rs?ref=25ed29a0edb3d48fef843a0b818ee68faf2252da", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use option::{Option, Some, None};\n+use result::{Ok, Err};\n+use rt::io::io_error;\n+use rt::io::net::ip::IpAddr;\n+use rt::rtio::{IoFactory, IoFactoryObject};\n+use rt::local::Local;\n+\n+pub mod tcp;\n+pub mod udp;\n+pub mod ip;\n+#[cfg(unix)]\n+pub mod unix;\n+\n+/// Simplistic name resolution\n+pub fn get_host_addresses(host: &str) -> Option<~[IpAddr]> {\n+    /*!\n+     * Get the IP addresses for a given host name.\n+     *\n+     * Raises io_error on failure.\n+     */\n+\n+    let ipaddrs = unsafe {\n+        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+        (*io).get_host_addresses(host)\n+    };\n+\n+    match ipaddrs {\n+        Ok(i) => Some(i),\n+        Err(ioerr) => {\n+            io_error::cond.raise(ioerr);\n+            None\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use option::Some;\n+    use rt::io::net::ip::Ipv4Addr;\n+    use super::*;\n+\n+    #[test]\n+    fn dns_smoke_test() {\n+        let ipaddrs = get_host_addresses(\"localhost\").unwrap();\n+        let mut found_local = false;\n+        let local_addr = &Ipv4Addr(127, 0, 0, 1);\n+        for addr in ipaddrs.iter() {\n+            found_local = found_local || addr == local_addr;\n+        }\n+        assert!(found_local);\n+    }\n+}"}, {"sha": "c9c402baaf0fa1d979149faffb9629c714e2db13", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=25ed29a0edb3d48fef843a0b818ee68faf2252da", "patch": "@@ -73,6 +73,7 @@ pub trait IoFactory {\n     fn fs_open<P: PathLike>(&mut self, path: &P, fm: FileMode, fa: FileAccess)\n         -> Result<~RtioFileStream, IoError>;\n     fn fs_unlink<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n+    fn get_host_addresses(&mut self, host: &str) -> Result<~[IpAddr], IoError>;\n }\n \n pub trait RtioTcpListener : RtioSocket {"}, {"sha": "00d1ab5aa9c697b7ca0d5fbc25fa51ac68bc457b", "filename": "src/libstd/rt/uv/addrinfo.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs?ref=25ed29a0edb3d48fef843a0b818ee68faf2252da", "patch": "@@ -0,0 +1,178 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cast::transmute;\n+use cell::Cell;\n+use c_str::ToCStr;\n+use libc::{c_int, c_void};\n+use option::{Option, Some, None};\n+use ptr::null;\n+use rt::uv::uvll;\n+use rt::uv::uvll::UV_GETADDRINFO;\n+use rt::uv::{Loop, UvError, NativeHandle};\n+use rt::uv::status_to_maybe_uv_error_with_loop;\n+use rt::uv::net::UvAddrInfo;\n+\n+type GetAddrInfoCallback = ~fn(GetAddrInfoRequest, &UvAddrInfo, Option<UvError>);\n+\n+pub struct GetAddrInfoRequest(*uvll::uv_getaddrinfo_t);\n+\n+pub struct RequestData {\n+    getaddrinfo_cb: Option<GetAddrInfoCallback>,\n+}\n+\n+impl GetAddrInfoRequest {\n+    pub fn new() -> GetAddrInfoRequest {\n+        let req = unsafe { uvll::malloc_req(UV_GETADDRINFO) };\n+        assert!(req.is_not_null());\n+        let mut req: GetAddrInfoRequest = NativeHandle::from_native_handle(req);\n+        req.install_req_data();\n+        return req;\n+    }\n+\n+    pub fn getaddrinfo(&mut self, loop_: &Loop, node: Option<&str>,\n+                       service: Option<&str>, hints: Option<UvAddrInfo>,\n+                       cb: GetAddrInfoCallback) {\n+\n+        assert!(node.is_some() || service.is_some());\n+\n+        let (c_node, c_node_ptr) = match node {\n+            Some(n) => {\n+                let c_node = n.to_c_str();\n+                let c_node_ptr = c_node.with_ref(|r| r);\n+                (Some(c_node), c_node_ptr)\n+            }\n+            None => (None, null())\n+        };\n+\n+        let (c_service, c_service_ptr) = match service {\n+            Some(s) => {\n+                let c_service = s.to_c_str();\n+                let c_service_ptr = c_service.with_ref(|r| r);\n+                (Some(c_service), c_service_ptr)\n+            }\n+            None => (None, null())\n+        };\n+\n+        let cb = Cell::new(cb);\n+        let wrapper_cb: GetAddrInfoCallback = |req, addrinfo, err| {\n+            // Capture some heap values that need to stay alive for the\n+            // getaddrinfo call\n+            let _ = &c_node;\n+            let _ = &c_service;\n+\n+            let cb = cb.take();\n+            cb(req, addrinfo, err)\n+        };\n+\n+        // XXX: Implement hints\n+        assert!(hints.is_none());\n+\n+        self.get_req_data().getaddrinfo_cb = Some(wrapper_cb);\n+\n+        unsafe {\n+            assert!(0 == uvll::getaddrinfo(loop_.native_handle(),\n+                                           self.native_handle(),\n+                                           getaddrinfo_cb,\n+                                           c_node_ptr,\n+                                           c_service_ptr,\n+                                           null()));\n+        }\n+\n+        extern \"C\" fn getaddrinfo_cb(req: *uvll::uv_getaddrinfo_t,\n+                                     status: c_int,\n+                                     res: *uvll::addrinfo) {\n+            let mut req: GetAddrInfoRequest = NativeHandle::from_native_handle(req);\n+            let loop_ = req.get_loop();\n+            let err = status_to_maybe_uv_error_with_loop(loop_.native_handle(), status);\n+            let addrinfo = UvAddrInfo(res);\n+            let data = req.get_req_data();\n+            (*data.getaddrinfo_cb.get_ref())(req, &addrinfo, err);\n+            unsafe {\n+                uvll::freeaddrinfo(res);\n+            }\n+        }\n+    }\n+\n+    fn get_loop(&self) -> Loop {\n+        unsafe {\n+            Loop {\n+                handle: uvll::get_loop_from_fs_req(self.native_handle())\n+            }\n+        }\n+    }\n+\n+    fn install_req_data(&mut self) {\n+        let req = self.native_handle() as *uvll::uv_getaddrinfo_t;\n+        let data = ~RequestData {\n+            getaddrinfo_cb: None\n+        };\n+        unsafe {\n+            let data = transmute::<~RequestData, *c_void>(data);\n+            uvll::set_data_for_req(req, data);\n+        }\n+    }\n+\n+    fn get_req_data<'r>(&'r mut self) -> &'r mut RequestData {\n+        unsafe {\n+            let data = uvll::get_data_for_req(self.native_handle());\n+            let data = transmute::<&*c_void, &mut ~RequestData>(&data);\n+            return &mut **data;\n+        }\n+    }\n+\n+    fn delete(self) {\n+        unsafe {\n+            let data = uvll::get_data_for_req(self.native_handle());\n+            let _data = transmute::<*c_void, ~RequestData>(data);\n+            uvll::set_data_for_req(self.native_handle(), null::<()>());\n+            uvll::free_req(self.native_handle());\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_getaddrinfo_t> for GetAddrInfoRequest {\n+    fn from_native_handle(handle: *uvll::uv_getaddrinfo_t) -> GetAddrInfoRequest {\n+        GetAddrInfoRequest(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_getaddrinfo_t {\n+        match self { &GetAddrInfoRequest(ptr) => ptr }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use option::{Some, None};\n+    use rt::uv::Loop;\n+    use rt::uv::net::accum_sockaddrs;\n+    use rt::io::net::ip::{SocketAddr, Ipv4Addr};\n+    use super::*;\n+\n+    #[test]\n+    fn getaddrinfo_test() {\n+        let mut loop_ = Loop::new();\n+        let mut req = GetAddrInfoRequest::new();\n+        do req.getaddrinfo(&loop_, Some(\"localhost\"), None, None) |_, addrinfo, _| {\n+            let sockaddrs = accum_sockaddrs(addrinfo);\n+            let mut found_local = false;\n+            let local_addr = &SocketAddr {\n+                ip: Ipv4Addr(127, 0, 0, 1),\n+                port: 0\n+            };\n+            for addr in sockaddrs.iter() {\n+                found_local = found_local || addr == local_addr;\n+            }\n+            assert!(found_local);\n+        }\n+        loop_.run();\n+        loop_.close();\n+        req.delete();\n+    }\n+}"}, {"sha": "0902d5e6d8c2085c08d59b27371bcd2494811ded", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=25ed29a0edb3d48fef843a0b818ee68faf2252da", "patch": "@@ -139,15 +139,17 @@ impl NativeHandle<*uvll::uv_fs_t> for FsRequest {\n         match self { &FsRequest(ptr) => ptr }\n     }\n }\n-    fn sync_cleanup(loop_: &Loop, result: int)\n-          -> Result<int, UvError> {\n-        match status_to_maybe_uv_error_with_loop(loop_.native_handle(), result as i32) {\n-            Some(err) => Err(err),\n-            None => Ok(result)\n-        }\n+\n+fn sync_cleanup(loop_: &Loop, result: int)\n+    -> Result<int, UvError> {\n+    match status_to_maybe_uv_error_with_loop(loop_.native_handle(), result as i32) {\n+        Some(err) => Err(err),\n+        None => Ok(result)\n     }\n+}\n \n pub struct FileDescriptor(c_int);\n+\n impl FileDescriptor {\n     fn new(fd: c_int) -> FileDescriptor {\n         FileDescriptor(fd)"}, {"sha": "b85b223468e86e617beb1b81f5099f18c459b8ff", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=25ed29a0edb3d48fef843a0b818ee68faf2252da", "patch": "@@ -70,6 +70,7 @@ pub mod net;\n pub mod idle;\n pub mod timer;\n pub mod async;\n+pub mod addrinfo;\n \n /// XXX: Loop(*handle) is buggy with destructors. Normal structs\n /// with dtors may not be destructured, but tuple structs can,\n@@ -132,7 +133,8 @@ pub type UdpReceiveCallback = ~fn(UdpWatcher, int, Buf, SocketAddr, uint, Option\n pub type UdpSendCallback = ~fn(UdpWatcher, Option<UvError>);\n \n \n-/// Callbacks used by StreamWatchers, set as custom data on the foreign handle\n+/// Callbacks used by StreamWatchers, set as custom data on the foreign handle.\n+/// XXX: Would be better not to have all watchers allocate room for all callback types.\n struct WatcherData {\n     read_cb: Option<ReadCallback>,\n     write_cb: Option<ConnectionCallback>,"}, {"sha": "9d4eb8f6302952135f0b7878637f1cc46a6c90bb", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=25ed29a0edb3d48fef843a0b818ee68faf2252da", "patch": "@@ -21,6 +21,8 @@ use vec;\n use str;\n use from_str::{FromStr};\n \n+pub struct UvAddrInfo(*uvll::addrinfo);\n+\n pub enum UvSocketAddr {\n     UvIpv4SocketAddr(*sockaddr_in),\n     UvIpv6SocketAddr(*sockaddr_in6),\n@@ -95,6 +97,28 @@ pub fn uv_socket_addr_to_socket_addr(addr: UvSocketAddr) -> SocketAddr {\n     uv_socket_addr_as_socket_addr(addr, util::id)\n }\n \n+// Traverse the addrinfo linked list, producing a vector of Rust socket addresses\n+pub fn accum_sockaddrs(addr: &UvAddrInfo) -> ~[SocketAddr] {\n+    unsafe {\n+        let &UvAddrInfo(addr) = addr;\n+        let mut addr = addr;\n+\n+        let mut addrs = ~[];\n+        loop {\n+            let uvaddr = sockaddr_to_UvSocketAddr((*addr).ai_addr);\n+            let rustaddr = uv_socket_addr_to_socket_addr(uvaddr);\n+            addrs.push(rustaddr);\n+            if (*addr).ai_next.is_not_null() {\n+                addr = (*addr).ai_next;\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        return addrs;\n+    }\n+}\n+\n #[cfg(test)]\n #[test]\n fn test_ip4_conversion() {"}, {"sha": "c22674995deca53326f25addd19a18bfab9054d5", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=25ed29a0edb3d48fef843a0b818ee68faf2252da", "patch": "@@ -29,7 +29,8 @@ use rt::tube::Tube;\n use rt::task::SchedHome;\n use rt::uv::*;\n use rt::uv::idle::IdleWatcher;\n-use rt::uv::net::{UvIpv4SocketAddr, UvIpv6SocketAddr};\n+use rt::uv::net::{UvIpv4SocketAddr, UvIpv6SocketAddr, accum_sockaddrs};\n+use rt::uv::addrinfo::GetAddrInfoRequest;\n use unstable::sync::Exclusive;\n use super::super::io::support::PathLike;\n use libc::{lseek, off_t, O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY,\n@@ -596,6 +597,37 @@ impl IoFactory for UvIoFactory {\n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n+\n+    fn get_host_addresses(&mut self, host: &str) -> Result<~[IpAddr], IoError> {\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<~[IpAddr], IoError>> = &result_cell;\n+        let host_ptr: *&str = &host;\n+        let addrinfo_req = GetAddrInfoRequest::new();\n+        let addrinfo_req_cell = Cell::new(addrinfo_req);\n+        do task::unkillable { // FIXME(#8674)\n+            let scheduler: ~Scheduler = Local::take();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                let mut addrinfo_req = addrinfo_req_cell.take();\n+                unsafe {\n+                    do addrinfo_req.getaddrinfo(self.uv_loop(),\n+                                                Some(*host_ptr),\n+                                                None, None) |_, addrinfo, err| {\n+                        let res = match err {\n+                            None => Ok(accum_sockaddrs(addrinfo).map(|addr| addr.ip.clone())),\n+                            Some(err) => Err(uv_error_to_io_error(err))\n+                        };\n+                        (*result_cell_ptr).put_back(res);\n+                        let scheduler: ~Scheduler = Local::take();\n+                        scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    }\n+                }\n+            }\n+        }\n+        addrinfo_req.delete();\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n }\n \n pub struct UvTcpListener {"}, {"sha": "08e9bc062ce4e8b75b2fbcd592d9d549f7b0b606", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=25ed29a0edb3d48fef843a0b818ee68faf2252da", "patch": "@@ -72,6 +72,7 @@ pub type uv_timer_t = c_void;\n pub type uv_stream_t = c_void;\n pub type uv_fs_t = c_void;\n pub type uv_udp_send_t = c_void;\n+pub type uv_getaddrinfo_t = c_void;\n \n #[cfg(stage0)]\n pub type uv_idle_cb = *u8;\n@@ -97,6 +98,8 @@ pub type uv_connection_cb = *u8;\n pub type uv_timer_cb = *u8;\n #[cfg(stage0)]\n pub type uv_write_cb = *u8;\n+#[cfg(stage0)]\n+pub type uv_getaddrinfo_cb = *u8;\n \n #[cfg(not(stage0))]\n pub type uv_idle_cb = extern \"C\" fn(handle: *uv_idle_t,\n@@ -137,12 +140,58 @@ pub type uv_timer_cb = extern \"C\" fn(handle: *uv_timer_t,\n #[cfg(not(stage0))]\n pub type uv_write_cb = extern \"C\" fn(handle: *uv_write_t,\n                                      status: c_int);\n+#[cfg(not(stage0))]\n+pub type uv_getaddrinfo_cb = extern \"C\" fn(req: *uv_getaddrinfo_t,\n+                                           status: c_int,\n+                                           res: *addrinfo);\n \n pub type sockaddr = c_void;\n pub type sockaddr_in = c_void;\n pub type sockaddr_in6 = c_void;\n pub type sockaddr_storage = c_void;\n \n+#[cfg(unix)]\n+pub type socklen_t = c_int;\n+\n+// XXX: This is a standard C type. Could probably be defined in libc\n+#[cfg(target_os = \"android\")]\n+#[cfg(target_os = \"linux\")]\n+pub struct addrinfo {\n+    ai_flags: c_int,\n+    ai_family: c_int,\n+    ai_socktype: c_int,\n+    ai_protocol: c_int,\n+    ai_addrlen: socklen_t,\n+    ai_addr: *sockaddr,\n+    ai_canonname: *char,\n+    ai_next: *addrinfo\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+pub struct addrinfo {\n+    ai_flags: c_int,\n+    ai_family: c_int,\n+    ai_socktype: c_int,\n+    ai_protocol: c_int,\n+    ai_addrlen: socklen_t,\n+    ai_canonname: *char,\n+    ai_addr: *sockaddr,\n+    ai_next: *addrinfo\n+}\n+\n+#[cfg(windows)]\n+pub struct addrinfo {\n+    ai_flags: c_int,\n+    ai_family: c_int,\n+    ai_socktype: c_int,\n+    ai_protocol: c_int,\n+    ai_addrlen: size_t,\n+    ai_canonname: *char,\n+    ai_addr: *sockaddr,\n+    ai_next: *addrinfo\n+}\n+\n #[deriving(Eq)]\n pub enum uv_handle_type {\n     UV_UNKNOWN_HANDLE,\n@@ -666,6 +715,11 @@ pub unsafe fn get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t {\n \n     rust_uv_get_loop_from_fs_req(req)\n }\n+pub unsafe fn get_loop_from_getaddrinfo_req(req: *uv_getaddrinfo_t) -> *uv_loop_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_get_loop_from_getaddrinfo_req(req)\n+}\n pub unsafe fn get_loop_for_uv_handle<T>(handle: *T) -> *c_void {\n     #[fixed_stack_segment]; #[inline(never)];\n \n@@ -721,6 +775,18 @@ pub unsafe fn get_len_from_buf(buf: uv_buf_t) -> size_t {\n \n     return rust_uv_get_len_from_buf(buf);\n }\n+pub unsafe fn getaddrinfo(loop_: *uv_loop_t, req: *uv_getaddrinfo_t,\n+               getaddrinfo_cb: uv_getaddrinfo_cb,\n+               node: *c_char, service: *c_char,\n+               hints: *addrinfo) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_getaddrinfo(loop_, req, getaddrinfo_cb, node, service, hints);\n+}\n+pub unsafe fn freeaddrinfo(ai: *addrinfo) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_uv_freeaddrinfo(ai);\n+}\n+\n pub unsafe fn get_last_err_info(uv_loop: *c_void) -> ~str {\n     let err = last_error(uv_loop);\n     let err_ptr = ptr::to_unsafe_ptr(&err);\n@@ -845,6 +911,7 @@ extern {\n     fn rust_uv_fs_req_cleanup(req: *uv_fs_t);\n     fn rust_uv_get_result_from_fs_req(req: *uv_fs_t) -> c_int;\n     fn rust_uv_get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t;\n+    fn rust_uv_get_loop_from_getaddrinfo_req(req: *uv_fs_t) -> *uv_loop_t;\n \n     fn rust_uv_get_stream_handle_from_connect_req(connect_req: *uv_connect_t) -> *uv_stream_t;\n     fn rust_uv_get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t;\n@@ -857,4 +924,9 @@ extern {\n     fn rust_uv_set_data_for_req(req: *c_void, data: *c_void);\n     fn rust_uv_get_base_from_buf(buf: uv_buf_t) -> *u8;\n     fn rust_uv_get_len_from_buf(buf: uv_buf_t) -> size_t;\n+    fn rust_uv_getaddrinfo(loop_: *uv_loop_t, req: *uv_getaddrinfo_t,\n+                           getaddrinfo_cb: uv_getaddrinfo_cb,\n+                           node: *c_char, service: *c_char,\n+                           hints: *addrinfo) -> c_int;\n+    fn rust_uv_freeaddrinfo(ai: *addrinfo);\n }"}, {"sha": "ac5ea4bb3b36b29d6426043777f5e23a636eec88", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=25ed29a0edb3d48fef843a0b818ee68faf2252da", "patch": "@@ -553,3 +553,8 @@ extern \"C\" uv_loop_t*\n rust_uv_get_loop_from_fs_req(uv_fs_t* req) {\n   return req->loop;\n }\n+\n+extern \"C\" uv_loop_t*\n+rust_uv_get_loop_from_getaddrinfo_req(uv_getaddrinfo_t* req) {\n+  return req->loop;\n+}"}, {"sha": "45109443f06142d8964782da4d8b3ad49570f2f2", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/25ed29a0edb3d48fef843a0b818ee68faf2252da/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=25ed29a0edb3d48fef843a0b818ee68faf2252da", "patch": "@@ -192,3 +192,4 @@ rust_take_change_dir_lock\n rust_drop_change_dir_lock\n rust_get_test_int\n rust_get_task\n+rust_uv_get_loop_from_getaddrinfo_req"}]}