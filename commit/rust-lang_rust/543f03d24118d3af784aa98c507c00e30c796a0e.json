{"sha": "543f03d24118d3af784aa98c507c00e30c796a0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0M2YwM2QyNDExOGQzYWY3ODRhYTk4YzUwN2MwMGUzMGM3OTZhMGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-09T14:29:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-09T14:29:42Z"}, "message": "Auto merge of #75134 - Aaron1011:feature/expn-data-parent-hash, r=petrochenkov\n\nHash parent ExpnData\n\ncc https://github.com/rust-lang/rust/pull/72121#discussion_r460528326", "tree": {"sha": "b333a9f3af9e77a2c20181615c5889828f79d8a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b333a9f3af9e77a2c20181615c5889828f79d8a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/543f03d24118d3af784aa98c507c00e30c796a0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/543f03d24118d3af784aa98c507c00e30c796a0e", "html_url": "https://github.com/rust-lang/rust/commit/543f03d24118d3af784aa98c507c00e30c796a0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/543f03d24118d3af784aa98c507c00e30c796a0e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bc801b05019cd3e0ef19e6c4c028d55baa645d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bc801b05019cd3e0ef19e6c4c028d55baa645d2", "html_url": "https://github.com/rust-lang/rust/commit/8bc801b05019cd3e0ef19e6c4c028d55baa645d2"}, {"sha": "1f63a6a572a0f9afc769a88229d80cc81ff04697", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f63a6a572a0f9afc769a88229d80cc81ff04697", "html_url": "https://github.com/rust-lang/rust/commit/1f63a6a572a0f9afc769a88229d80cc81ff04697"}], "stats": {"total": 72, "additions": 39, "deletions": 33}, "files": [{"sha": "4e21d566071ef609da18d9c34dcf87fb7a452b01", "filename": "src/librustc_span/hygiene.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/543f03d24118d3af784aa98c507c00e30c796a0e/src%2Flibrustc_span%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/543f03d24118d3af784aa98c507c00e30c796a0e/src%2Flibrustc_span%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fhygiene.rs?ref=543f03d24118d3af784aa98c507c00e30c796a0e", "patch": "@@ -80,8 +80,6 @@ pub enum Transparency {\n     Opaque,\n }\n \n-pub(crate) const NUM_TRANSPARENCIES: usize = 3;\n-\n impl ExpnId {\n     pub fn fresh(expn_data: Option<ExpnData>) -> Self {\n         HygieneData::with(|data| data.fresh_expn(expn_data))\n@@ -618,6 +616,11 @@ impl SyntaxContext {\n         HygieneData::with(|data| data.expn_data(data.outer_expn(self)).clone())\n     }\n \n+    #[inline]\n+    pub fn outer_mark(self) -> (ExpnId, Transparency) {\n+        HygieneData::with(|data| data.outer_mark(self))\n+    }\n+\n     #[inline]\n     pub fn outer_mark_with_data(self) -> (ExpnId, Transparency, ExpnData) {\n         HygieneData::with(|data| {\n@@ -667,7 +670,6 @@ pub struct ExpnData {\n     /// The kind of this expansion - macro or compiler desugaring.\n     pub kind: ExpnKind,\n     /// The expansion that produced this expansion.\n-    #[stable_hasher(ignore)]\n     pub parent: ExpnId,\n     /// The location of the actual macro invocation or syntax sugar , e.g.\n     /// `let x = foo!();` or `if let Some(y) = x {}`"}, {"sha": "697d88ad0639598ea392fa345260a1eac0749ce0", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/543f03d24118d3af784aa98c507c00e30c796a0e/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/543f03d24118d3af784aa98c507c00e30c796a0e/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=543f03d24118d3af784aa98c507c00e30c796a0e", "patch": "@@ -32,8 +32,8 @@ pub mod edition;\n use edition::Edition;\n pub mod hygiene;\n pub use hygiene::SyntaxContext;\n+use hygiene::Transparency;\n pub use hygiene::{DesugaringKind, ExpnData, ExpnId, ExpnKind, ForLoopLoc, MacroKind};\n-use hygiene::{Transparency, NUM_TRANSPARENCIES};\n pub mod def_id;\n use def_id::{CrateNum, DefId, LOCAL_CRATE};\n mod span_encoding;\n@@ -1823,47 +1823,51 @@ impl<CTX: HashStableContext> HashStable<CTX> for SyntaxContext {\n             TAG_NO_EXPANSION.hash_stable(ctx, hasher);\n         } else {\n             TAG_EXPANSION.hash_stable(ctx, hasher);\n+            let (expn_id, transparency) = self.outer_mark();\n+            expn_id.hash_stable(ctx, hasher);\n+            transparency.hash_stable(ctx, hasher);\n+        }\n+    }\n+}\n \n-            // Since the same expansion context is usually referenced many\n-            // times, we cache a stable hash of it and hash that instead of\n-            // recursing every time.\n-            thread_local! {\n-                static CACHE: RefCell<Vec<Option<[Option<u64>; NUM_TRANSPARENCIES]>>> = Default::default();\n-            }\n+impl<CTX: HashStableContext> HashStable<CTX> for ExpnId {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        // Since the same expansion context is usually referenced many\n+        // times, we cache a stable hash of it and hash that instead of\n+        // recursing every time.\n+        thread_local! {\n+            static CACHE: RefCell<Vec<Option<Fingerprint>>> = Default::default();\n+        }\n \n-            let sub_hash: u64 = CACHE.with(|cache| {\n-                let (expn_id, transparency, _) = self.outer_mark_with_data();\n-                let index = expn_id.as_u32() as usize;\n+        const TAG_ROOT: u8 = 0;\n+        const TAG_NOT_ROOT: u8 = 1;\n \n-                if let Some(sub_hash_cache) = cache.borrow().get(index).copied().flatten() {\n-                    if let Some(sub_hash) = sub_hash_cache[transparency as usize] {\n-                        return sub_hash;\n-                    }\n-                }\n+        if *self == ExpnId::root() {\n+            TAG_ROOT.hash_stable(ctx, hasher);\n+            return;\n+        }\n \n-                let new_len = index + 1;\n+        TAG_NOT_ROOT.hash_stable(ctx, hasher);\n+        let index = self.as_u32() as usize;\n \n-                let mut hasher = StableHasher::new();\n-                expn_id.expn_data().hash_stable(ctx, &mut hasher);\n-                transparency.hash_stable(ctx, &mut hasher);\n+        let res = CACHE.with(|cache| cache.borrow().get(index).copied().flatten());\n+\n+        if let Some(res) = res {\n+            res.hash_stable(ctx, hasher);\n+        } else {\n+            let new_len = index + 1;\n \n-                let sub_hash: Fingerprint = hasher.finish();\n-                let sub_hash = sub_hash.to_smaller_hash();\n+            let mut sub_hasher = StableHasher::new();\n+            self.expn_data().hash_stable(ctx, &mut sub_hasher);\n+            let sub_hash: Fingerprint = sub_hasher.finish();\n \n+            CACHE.with(|cache| {\n                 let mut cache = cache.borrow_mut();\n                 if cache.len() < new_len {\n                     cache.resize(new_len, None);\n                 }\n-                if let Some(mut sub_hash_cache) = cache[index] {\n-                    sub_hash_cache[transparency as usize] = Some(sub_hash);\n-                } else {\n-                    let mut sub_hash_cache = [None; NUM_TRANSPARENCIES];\n-                    sub_hash_cache[transparency as usize] = Some(sub_hash);\n-                    cache[index] = Some(sub_hash_cache);\n-                }\n-                sub_hash\n+                cache[index].replace(sub_hash).expect_none(\"Cache slot was filled\");\n             });\n-\n             sub_hash.hash_stable(ctx, hasher);\n         }\n     }"}]}