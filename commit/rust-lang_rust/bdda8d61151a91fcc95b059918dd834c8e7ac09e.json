{"sha": "bdda8d61151a91fcc95b059918dd834c8e7ac09e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkZGE4ZDYxMTUxYTkxZmNjOTViMDU5OTE4ZGQ4MzRjOGU3YWMwOWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-20T12:28:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-20T12:28:13Z"}, "message": "Auto merge of #46952 - SimonSapin:nonnull, r=alexcrichton\n\nRename std::ptr::Shared to NonNull and stabilize it\n\nThis implements the changes proposed at https://github.com/rust-lang/rust/issues/27730#issuecomment-352800629:\n\n> * Rename `Shared<T>` to `NonNull<T>` and stabilize it. (Being in the `ptr` module is enough to say that it\u2019s a pointer. I\u2019m not very attached to this specific name though.)\n> * Rename `Box<T>` methods ~~`from_unique`~~/`into_unique` to ~~`from_nonnull`~~/`into_nonnull` (or whatever names are deemed appropriate), replace `Unique<T>` with `NonNull<T>` in their signatures, and stabilize them.\n> *  Replace `Unique<T>` with `NonNull<T>` in the signatures of methods of the `Alloc` trait.\n> * Mark `Unique` \u201cpermanently-unstable\u201d by replacing remaining occurrences of `#[unstable(feature = \"unique\", issue = \"27730\")]` with:\n>\n>   ```rust\n>   #[unstable(feature = \"ptr_internals\", issue = \"0\", reason = \"\\\n>       use NonNull instead and consider PhantomData<T> (if you also use #[may_dangle]), \\\n>       Send, and/or Sync\")]\n>   ```\n>\n>   (Maybe the `reason` string is only useful on the struct definition.) Ideally it would be made private to some crate instead, but it needs to be used in both liballoc and libstd.\n> * (Leave `NonZero` and `Zeroable` unstable for now, and subject to future bikeshedding.)", "tree": {"sha": "392c16311de525e9573a63486a6e7d32469b6fb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/392c16311de525e9573a63486a6e7d32469b6fb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdda8d61151a91fcc95b059918dd834c8e7ac09e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdda8d61151a91fcc95b059918dd834c8e7ac09e", "html_url": "https://github.com/rust-lang/rust/commit/bdda8d61151a91fcc95b059918dd834c8e7ac09e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdda8d61151a91fcc95b059918dd834c8e7ac09e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "816d765716f25b0008049d89a0e41f0a48d03c78", "url": "https://api.github.com/repos/rust-lang/rust/commits/816d765716f25b0008049d89a0e41f0a48d03c78", "html_url": "https://github.com/rust-lang/rust/commit/816d765716f25b0008049d89a0e41f0a48d03c78"}, {"sha": "602a445b92b37ec6af4d3d7f331e1a0d1360b8d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/602a445b92b37ec6af4d3d7f331e1a0d1360b8d2", "html_url": "https://github.com/rust-lang/rust/commit/602a445b92b37ec6af4d3d7f331e1a0d1360b8d2"}], "stats": {"total": 379, "additions": 182, "deletions": 197}, "files": [{"sha": "fec3182d0b0a3cf8122e192b3270064a5b19be5b", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -1 +1 @@\n-Subproject commit 2f7b05fd5939aa49d52c4ab309b9a47776ba7bd8\n+Subproject commit fec3182d0b0a3cf8122e192b3270064a5b19be5b"}, {"sha": "55e8c0b430f52c76f6b63617d8b6a0b90bef91d3", "filename": "src/liballoc/allocator.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Fliballoc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Fliballoc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fallocator.rs?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -19,7 +19,7 @@ use core::cmp;\n use core::fmt;\n use core::mem;\n use core::usize;\n-use core::ptr::{self, Unique};\n+use core::ptr::{self, NonNull};\n \n /// Represents the combination of a starting address and\n /// a total capacity of the returned block.\n@@ -895,12 +895,12 @@ pub unsafe trait Alloc {\n     /// Clients wishing to abort computation in response to an\n     /// allocation error are encouraged to call the allocator's `oom`\n     /// method, rather than directly invoking `panic!` or similar.\n-    fn alloc_one<T>(&mut self) -> Result<Unique<T>, AllocErr>\n+    fn alloc_one<T>(&mut self) -> Result<NonNull<T>, AllocErr>\n         where Self: Sized\n     {\n         let k = Layout::new::<T>();\n         if k.size() > 0 {\n-            unsafe { self.alloc(k).map(|p| Unique::new_unchecked(p as *mut T)) }\n+            unsafe { self.alloc(k).map(|p| NonNull::new_unchecked(p as *mut T)) }\n         } else {\n             Err(AllocErr::invalid_input(\"zero-sized type invalid for alloc_one\"))\n         }\n@@ -923,7 +923,7 @@ pub unsafe trait Alloc {\n     /// * `ptr` must denote a block of memory currently allocated via this allocator\n     ///\n     /// * the layout of `T` must *fit* that block of memory.\n-    unsafe fn dealloc_one<T>(&mut self, ptr: Unique<T>)\n+    unsafe fn dealloc_one<T>(&mut self, ptr: NonNull<T>)\n         where Self: Sized\n     {\n         let raw_ptr = ptr.as_ptr() as *mut u8;\n@@ -963,15 +963,15 @@ pub unsafe trait Alloc {\n     /// Clients wishing to abort computation in response to an\n     /// allocation error are encouraged to call the allocator's `oom`\n     /// method, rather than directly invoking `panic!` or similar.\n-    fn alloc_array<T>(&mut self, n: usize) -> Result<Unique<T>, AllocErr>\n+    fn alloc_array<T>(&mut self, n: usize) -> Result<NonNull<T>, AllocErr>\n         where Self: Sized\n     {\n         match Layout::array::<T>(n) {\n             Some(ref layout) if layout.size() > 0 => {\n                 unsafe {\n                     self.alloc(layout.clone())\n                         .map(|p| {\n-                            Unique::new_unchecked(p as *mut T)\n+                            NonNull::new_unchecked(p as *mut T)\n                         })\n                 }\n             }\n@@ -1012,15 +1012,15 @@ pub unsafe trait Alloc {\n     /// reallocation error are encouraged to call the allocator's `oom`\n     /// method, rather than directly invoking `panic!` or similar.\n     unsafe fn realloc_array<T>(&mut self,\n-                               ptr: Unique<T>,\n+                               ptr: NonNull<T>,\n                                n_old: usize,\n-                               n_new: usize) -> Result<Unique<T>, AllocErr>\n+                               n_new: usize) -> Result<NonNull<T>, AllocErr>\n         where Self: Sized\n     {\n         match (Layout::array::<T>(n_old), Layout::array::<T>(n_new), ptr.as_ptr()) {\n             (Some(ref k_old), Some(ref k_new), ptr) if k_old.size() > 0 && k_new.size() > 0 => {\n                 self.realloc(ptr as *mut u8, k_old.clone(), k_new.clone())\n-                    .map(|p|Unique::new_unchecked(p as *mut T))\n+                    .map(|p| NonNull::new_unchecked(p as *mut T))\n             }\n             _ => {\n                 Err(AllocErr::invalid_input(\"invalid layout for realloc_array\"))\n@@ -1048,7 +1048,7 @@ pub unsafe trait Alloc {\n     /// constraints.\n     ///\n     /// Always returns `Err` on arithmetic overflow.\n-    unsafe fn dealloc_array<T>(&mut self, ptr: Unique<T>, n: usize) -> Result<(), AllocErr>\n+    unsafe fn dealloc_array<T>(&mut self, ptr: NonNull<T>, n: usize) -> Result<(), AllocErr>\n         where Self: Sized\n     {\n         let raw_ptr = ptr.as_ptr() as *mut u8;"}, {"sha": "6a77bf64baee5f9ffe5d9670ad5eab3405abade5", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -25,7 +25,7 @@ use core::intrinsics::abort;\n use core::mem::{self, align_of_val, size_of_val, uninitialized};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n-use core::ptr::{self, Shared};\n+use core::ptr::{self, NonNull};\n use core::marker::{Unsize, PhantomData};\n use core::hash::{Hash, Hasher};\n use core::{isize, usize};\n@@ -197,7 +197,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// [rc_examples]: ../../std/rc/index.html#examples\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Arc<T: ?Sized> {\n-    ptr: Shared<ArcInner<T>>,\n+    ptr: NonNull<ArcInner<T>>,\n     phantom: PhantomData<T>,\n }\n \n@@ -234,7 +234,7 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n /// [`None`]: ../../std/option/enum.Option.html#variant.None\n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n-    ptr: Shared<ArcInner<T>>,\n+    ptr: NonNull<ArcInner<T>>,\n }\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n@@ -286,7 +286,7 @@ impl<T> Arc<T> {\n             weak: atomic::AtomicUsize::new(1),\n             data,\n         };\n-        Arc { ptr: Shared::from(Box::into_unique(x)), phantom: PhantomData }\n+        Arc { ptr: Box::into_raw_non_null(x), phantom: PhantomData }\n     }\n \n     /// Returns the contained value, if the `Arc` has exactly one strong reference.\n@@ -397,7 +397,7 @@ impl<T: ?Sized> Arc<T> {\n         let arc_ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n \n         Arc {\n-            ptr: Shared::new_unchecked(arc_ptr),\n+            ptr: NonNull::new_unchecked(arc_ptr),\n             phantom: PhantomData,\n         }\n     }\n@@ -582,7 +582,7 @@ impl<T: ?Sized> Arc<T> {\n             // Free the allocation without dropping its contents\n             box_free(bptr);\n \n-            Arc { ptr: Shared::new_unchecked(ptr), phantom: PhantomData }\n+            Arc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n         }\n     }\n }\n@@ -609,7 +609,7 @@ impl<T> Arc<[T]> {\n             &mut (*ptr).data as *mut [T] as *mut T,\n             v.len());\n \n-        Arc { ptr: Shared::new_unchecked(ptr), phantom: PhantomData }\n+        Arc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n     }\n }\n \n@@ -669,7 +669,7 @@ impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n             // All clear. Forget the guard so it doesn't free the new ArcInner.\n             mem::forget(guard);\n \n-            Arc { ptr: Shared::new_unchecked(ptr), phantom: PhantomData }\n+            Arc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n         }\n     }\n }\n@@ -991,11 +991,11 @@ impl<T> Weak<T> {\n     pub fn new() -> Weak<T> {\n         unsafe {\n             Weak {\n-                ptr: Shared::from(Box::into_unique(box ArcInner {\n+                ptr: Box::into_raw_non_null(box ArcInner {\n                     strong: atomic::AtomicUsize::new(0),\n                     weak: atomic::AtomicUsize::new(1),\n                     data: uninitialized(),\n-                })),\n+                }),\n             }\n         }\n     }"}, {"sha": "bfe23ddeca32828ed5097d8d7cd54249ed834cb0", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 18, "deletions": 47, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -68,7 +68,7 @@ use core::marker::{self, Unsize};\n use core::mem;\n use core::ops::{CoerceUnsized, Deref, DerefMut, Generator, GeneratorState};\n use core::ops::{BoxPlace, Boxed, InPlace, Place, Placer};\n-use core::ptr::{self, Unique};\n+use core::ptr::{self, NonNull, Unique};\n use core::convert::From;\n use str::from_boxed_utf8_unchecked;\n \n@@ -269,38 +269,7 @@ impl<T: ?Sized> Box<T> {\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n-        Box::from_unique(Unique::new_unchecked(raw))\n-    }\n-\n-    /// Constructs a `Box` from a `Unique<T>` pointer.\n-    ///\n-    /// After calling this function, the memory is owned by a `Box` and `T` can\n-    /// then be destroyed and released upon drop.\n-    ///\n-    /// # Safety\n-    ///\n-    /// A `Unique<T>` can be safely created via [`Unique::new`] and thus doesn't\n-    /// necessarily own the data pointed to nor is the data guaranteed to live\n-    /// as long as the pointer.\n-    ///\n-    /// [`Unique::new`]: ../../core/ptr/struct.Unique.html#method.new\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(unique)]\n-    ///\n-    /// fn main() {\n-    ///     let x = Box::new(5);\n-    ///     let ptr = Box::into_unique(x);\n-    ///     let x = unsafe { Box::from_unique(ptr) };\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"unique\", reason = \"needs an RFC to flesh out design\",\n-               issue = \"27730\")]\n-    #[inline]\n-    pub unsafe fn from_unique(u: Unique<T>) -> Self {\n-        Box(u)\n+        Box(Unique::new_unchecked(raw))\n     }\n \n     /// Consumes the `Box`, returning the wrapped raw pointer.\n@@ -326,40 +295,42 @@ impl<T: ?Sized> Box<T> {\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub fn into_raw(b: Box<T>) -> *mut T {\n-        Box::into_unique(b).as_ptr()\n+        Box::into_raw_non_null(b).as_ptr()\n     }\n \n-    /// Consumes the `Box`, returning the wrapped pointer as `Unique<T>`.\n+    /// Consumes the `Box`, returning the wrapped pointer as `NonNull<T>`.\n     ///\n     /// After calling this function, the caller is responsible for the\n     /// memory previously managed by the `Box`. In particular, the\n     /// caller should properly destroy `T` and release the memory. The\n-    /// proper way to do so is to either convert the `Unique<T>` pointer:\n-    ///\n-    /// - Into a `Box` with the [`Box::from_unique`] function.\n-    ///\n-    /// - Into a raw pointer and back into a `Box` with the [`Box::from_raw`]\n-    ///   function.\n+    /// proper way to do so is to convert the `NonNull<T>` pointer\n+    /// into a raw pointer and back into a `Box` with the [`Box::from_raw`]\n+    /// function.\n     ///\n     /// Note: this is an associated function, which means that you have\n-    /// to call it as `Box::into_unique(b)` instead of `b.into_unique()`. This\n+    /// to call it as `Box::into_raw_non_null(b)`\n+    /// instead of `b.into_raw_non_null()`. This\n     /// is so that there is no conflict with a method on the inner type.\n     ///\n-    /// [`Box::from_unique`]: struct.Box.html#method.from_unique\n     /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(unique)]\n+    /// #![feature(box_into_raw_non_null)]\n     ///\n     /// fn main() {\n     ///     let x = Box::new(5);\n-    ///     let ptr = Box::into_unique(x);\n+    ///     let ptr = Box::into_raw_non_null(x);\n     /// }\n     /// ```\n-    #[unstable(feature = \"unique\", reason = \"needs an RFC to flesh out design\",\n-               issue = \"27730\")]\n+    #[unstable(feature = \"box_into_raw_non_null\", issue = \"47336\")]\n+    #[inline]\n+    pub fn into_raw_non_null(b: Box<T>) -> NonNull<T> {\n+        Box::into_unique(b).into()\n+    }\n+\n+    #[unstable(feature = \"ptr_internals\", issue = \"0\", reason = \"use into_raw_non_null instead\")]\n     #[inline]\n     pub fn into_unique(b: Box<T>) -> Unique<T> {\n         let unique = b.0;"}, {"sha": "37af9ea529532f7b045baa3cd00cc16e1eb554f4", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -232,7 +232,7 @@ unsafe impl Alloc for Heap {\n ///\n /// This preserves the non-null invariant for types like `Box<T>`. The address\n /// may overlap with non-zero-size memory allocations.\n-#[rustc_deprecated(since = \"1.19\", reason = \"Use Unique/Shared::empty() instead\")]\n+#[rustc_deprecated(since = \"1.19\", reason = \"Use Unique/NonNull::empty() instead\")]\n #[unstable(feature = \"heap_api\", issue = \"27700\")]\n pub const EMPTY: *mut () = 1 as *mut ();\n "}, {"sha": "5139e54b5604a30d5e97fd92d4b32b4eb45ed3d3", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -84,6 +84,7 @@\n #![cfg_attr(test, feature(rand, test))]\n #![feature(allow_internal_unstable)]\n #![feature(ascii_ctype)]\n+#![feature(box_into_raw_non_null)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(cfg_target_has_atomic)]\n@@ -109,8 +110,8 @@\n #![feature(pattern)]\n #![feature(placement_in_syntax)]\n #![feature(placement_new_protocol)]\n+#![feature(ptr_internals)]\n #![feature(rustc_attrs)]\n-#![feature(shared)]\n #![feature(slice_get_slice)]\n #![feature(slice_patterns)]\n #![feature(slice_rsplit)]\n@@ -120,7 +121,6 @@\n #![feature(trusted_len)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n-#![feature(unique)]\n #![feature(unsize)]\n #![feature(allocator_internals)]\n #![feature(on_unimplemented)]"}, {"sha": "3cc810a055f3efc3eeee5b7e60752847964f75e9", "filename": "src/liballoc/linked_list.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Fliballoc%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Fliballoc%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flinked_list.rs?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -29,7 +29,7 @@ use core::iter::{FromIterator, FusedIterator};\n use core::marker::PhantomData;\n use core::mem;\n use core::ops::{BoxPlace, InPlace, Place, Placer};\n-use core::ptr::{self, Shared};\n+use core::ptr::{self, NonNull};\n \n use boxed::{Box, IntermediateBox};\n use super::SpecExtend;\n@@ -44,15 +44,15 @@ use super::SpecExtend;\n /// more memory efficient and make better use of CPU cache.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LinkedList<T> {\n-    head: Option<Shared<Node<T>>>,\n-    tail: Option<Shared<Node<T>>>,\n+    head: Option<NonNull<Node<T>>>,\n+    tail: Option<NonNull<Node<T>>>,\n     len: usize,\n     marker: PhantomData<Box<Node<T>>>,\n }\n \n struct Node<T> {\n-    next: Option<Shared<Node<T>>>,\n-    prev: Option<Shared<Node<T>>>,\n+    next: Option<NonNull<Node<T>>>,\n+    prev: Option<NonNull<Node<T>>>,\n     element: T,\n }\n \n@@ -65,8 +65,8 @@ struct Node<T> {\n /// [`LinkedList`]: struct.LinkedList.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n-    head: Option<Shared<Node<T>>>,\n-    tail: Option<Shared<Node<T>>>,\n+    head: Option<NonNull<Node<T>>>,\n+    tail: Option<NonNull<Node<T>>>,\n     len: usize,\n     marker: PhantomData<&'a Node<T>>,\n }\n@@ -98,8 +98,8 @@ impl<'a, T> Clone for Iter<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n     list: &'a mut LinkedList<T>,\n-    head: Option<Shared<Node<T>>>,\n-    tail: Option<Shared<Node<T>>>,\n+    head: Option<NonNull<Node<T>>>,\n+    tail: Option<NonNull<Node<T>>>,\n     len: usize,\n }\n \n@@ -157,7 +157,7 @@ impl<T> LinkedList<T> {\n         unsafe {\n             node.next = self.head;\n             node.prev = None;\n-            let node = Some(Shared::from(Box::into_unique(node)));\n+            let node = Some(Box::into_raw_non_null(node));\n \n             match self.head {\n                 None => self.tail = node,\n@@ -192,7 +192,7 @@ impl<T> LinkedList<T> {\n         unsafe {\n             node.next = None;\n             node.prev = self.tail;\n-            let node = Some(Shared::from(Box::into_unique(node)));\n+            let node = Some(Box::into_raw_non_null(node));\n \n             match self.tail {\n                 None => self.head = node,\n@@ -225,7 +225,7 @@ impl<T> LinkedList<T> {\n     ///\n     /// Warning: this will not check that the provided node belongs to the current list.\n     #[inline]\n-    unsafe fn unlink_node(&mut self, mut node: Shared<Node<T>>) {\n+    unsafe fn unlink_node(&mut self, mut node: NonNull<Node<T>>) {\n         let node = node.as_mut();\n \n         match node.prev {\n@@ -986,11 +986,11 @@ impl<'a, T> IterMut<'a, T> {\n                     Some(prev) => prev,\n                 };\n \n-                let node = Some(Shared::from(Box::into_unique(box Node {\n+                let node = Some(Box::into_raw_non_null(box Node {\n                     next: Some(head),\n                     prev: Some(prev),\n                     element,\n-                })));\n+                }));\n \n                 prev.as_mut().next = node;\n                 head.as_mut().prev = node;\n@@ -1038,7 +1038,7 @@ pub struct DrainFilter<'a, T: 'a, F: 'a>\n     where F: FnMut(&mut T) -> bool,\n {\n     list: &'a mut LinkedList<T>,\n-    it: Option<Shared<Node<T>>>,\n+    it: Option<NonNull<Node<T>>>,\n     pred: F,\n     idx: usize,\n     old_len: usize,"}, {"sha": "621e190696137c7fe7d792733ab0f7978acaa23f", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -322,7 +322,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     // would cause overflow\n                     let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n                     match self.a.alloc_array::<T>(new_cap) {\n-                        Ok(ptr) => (new_cap, ptr),\n+                        Ok(ptr) => (new_cap, ptr.into()),\n                         Err(e) => self.a.oom(e),\n                     }\n                 }"}, {"sha": "1fa5d34cb5787147091617c92c1499a0e1506cf5", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -256,7 +256,7 @@ use core::marker::{Unsize, PhantomData};\n use core::mem::{self, align_of_val, forget, size_of_val, uninitialized};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n-use core::ptr::{self, Shared};\n+use core::ptr::{self, NonNull};\n use core::convert::From;\n \n use heap::{Heap, Alloc, Layout, box_free};\n@@ -282,7 +282,7 @@ struct RcBox<T: ?Sized> {\n /// [get_mut]: #method.get_mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T: ?Sized> {\n-    ptr: Shared<RcBox<T>>,\n+    ptr: NonNull<RcBox<T>>,\n     phantom: PhantomData<T>,\n }\n \n@@ -311,11 +311,11 @@ impl<T> Rc<T> {\n             // pointers, which ensures that the weak destructor never frees\n             // the allocation while the strong destructor is running, even\n             // if the weak pointer is stored inside the strong one.\n-            ptr: Shared::from(Box::into_unique(box RcBox {\n+            ptr: Box::into_raw_non_null(box RcBox {\n                 strong: Cell::new(1),\n                 weak: Cell::new(1),\n                 value,\n-            })),\n+            }),\n             phantom: PhantomData,\n         }\n     }\n@@ -428,7 +428,7 @@ impl<T: ?Sized> Rc<T> {\n         let rc_ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n \n         Rc {\n-            ptr: Shared::new_unchecked(rc_ptr),\n+            ptr: NonNull::new_unchecked(rc_ptr),\n             phantom: PhantomData,\n         }\n     }\n@@ -649,7 +649,7 @@ impl Rc<Any> {\n                 let raw: *const RcBox<Any> = self.ptr.as_ptr();\n                 forget(self);\n                 Ok(Rc {\n-                    ptr: Shared::new_unchecked(raw as *const RcBox<T> as *mut _),\n+                    ptr: NonNull::new_unchecked(raw as *const RcBox<T> as *mut _),\n                     phantom: PhantomData,\n                 })\n             }\n@@ -695,7 +695,7 @@ impl<T: ?Sized> Rc<T> {\n             // Free the allocation without dropping its contents\n             box_free(bptr);\n \n-            Rc { ptr: Shared::new_unchecked(ptr), phantom: PhantomData }\n+            Rc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n         }\n     }\n }\n@@ -722,7 +722,7 @@ impl<T> Rc<[T]> {\n             &mut (*ptr).value as *mut [T] as *mut T,\n             v.len());\n \n-        Rc { ptr: Shared::new_unchecked(ptr), phantom: PhantomData }\n+        Rc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n     }\n }\n \n@@ -781,7 +781,7 @@ impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n             // All clear. Forget the guard so it doesn't free the new RcBox.\n             forget(guard);\n \n-            Rc { ptr: Shared::new_unchecked(ptr), phantom: PhantomData }\n+            Rc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n         }\n     }\n }\n@@ -1160,7 +1160,7 @@ impl<T> From<Vec<T>> for Rc<[T]> {\n /// [`None`]: ../../std/option/enum.Option.html#variant.None\n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n-    ptr: Shared<RcBox<T>>,\n+    ptr: NonNull<RcBox<T>>,\n }\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n@@ -1190,11 +1190,11 @@ impl<T> Weak<T> {\n     pub fn new() -> Weak<T> {\n         unsafe {\n             Weak {\n-                ptr: Shared::from(Box::into_unique(box RcBox {\n+                ptr: Box::into_raw_non_null(box RcBox {\n                     strong: Cell::new(0),\n                     weak: Cell::new(1),\n                     value: uninitialized(),\n-                })),\n+                }),\n             }\n         }\n     }"}, {"sha": "b14b9d747654817343bbad6d36806f4514e76653", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -78,7 +78,7 @@ use core::num::Float;\n use core::ops::{InPlace, Index, IndexMut, Place, Placer};\n use core::ops;\n use core::ptr;\n-use core::ptr::Shared;\n+use core::ptr::NonNull;\n use core::slice;\n \n use borrow::ToOwned;\n@@ -1124,7 +1124,7 @@ impl<T> Vec<T> {\n                 tail_start: end,\n                 tail_len: len - end,\n                 iter: range_slice.iter(),\n-                vec: Shared::from(self),\n+                vec: NonNull::from(self),\n             }\n         }\n     }\n@@ -1745,7 +1745,7 @@ impl<T> IntoIterator for Vec<T> {\n             let cap = self.buf.cap();\n             mem::forget(self);\n             IntoIter {\n-                buf: Shared::new_unchecked(begin),\n+                buf: NonNull::new_unchecked(begin),\n                 phantom: PhantomData,\n                 cap,\n                 ptr: begin,\n@@ -2267,7 +2267,7 @@ impl<'a, T> FromIterator<T> for Cow<'a, [T]> where T: Clone {\n /// [`IntoIterator`]: ../../std/iter/trait.IntoIterator.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n-    buf: Shared<T>,\n+    buf: NonNull<T>,\n     phantom: PhantomData<T>,\n     cap: usize,\n     ptr: *const T,\n@@ -2442,7 +2442,7 @@ pub struct Drain<'a, T: 'a> {\n     tail_len: usize,\n     /// Current remaining range to remove\n     iter: slice::Iter<'a, T>,\n-    vec: Shared<Vec<T>>,\n+    vec: NonNull<Vec<T>>,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]"}, {"sha": "8f05a69c5f3ec58f694c764151498706b8ae0271", "filename": "src/liballoc/vec_deque.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Fliballoc%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Fliballoc%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec_deque.rs?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -23,7 +23,7 @@ use core::iter::{repeat, FromIterator, FusedIterator};\n use core::mem;\n use core::ops::{Index, IndexMut, Place, Placer, InPlace};\n use core::ptr;\n-use core::ptr::Shared;\n+use core::ptr::NonNull;\n use core::slice;\n \n use core::hash::{Hash, Hasher};\n@@ -895,7 +895,7 @@ impl<T> VecDeque<T> {\n         self.head = drain_tail;\n \n         Drain {\n-            deque: Shared::from(&mut *self),\n+            deque: NonNull::from(&mut *self),\n             after_tail: drain_head,\n             after_head: head,\n             iter: Iter {\n@@ -2154,7 +2154,7 @@ pub struct Drain<'a, T: 'a> {\n     after_tail: usize,\n     after_head: usize,\n     iter: Iter<'a, T>,\n-    deque: Shared<VecDeque<T>>,\n+    deque: NonNull<VecDeque<T>>,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]"}, {"sha": "fab5832d905df8262bfbaa85971ef913e8711844", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 88, "deletions": 68, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -2321,7 +2321,7 @@ impl<T: ?Sized> PartialOrd for *mut T {\n /// its owning Unique.\n ///\n /// If you're uncertain of whether it's correct to use `Unique` for your purposes,\n-/// consider using `Shared`, which has weaker semantics.\n+/// consider using `NonNull`, which has weaker semantics.\n ///\n /// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n /// is never dereferenced. This is so that enums may use this forbidden value\n@@ -2330,9 +2330,9 @@ impl<T: ?Sized> PartialOrd for *mut T {\n ///\n /// Unlike `*mut T`, `Unique<T>` is covariant over `T`. This should always be correct\n /// for any type which upholds Unique's aliasing requirements.\n-#[allow(missing_debug_implementations)]\n-#[unstable(feature = \"unique\", reason = \"needs an RFC to flesh out design\",\n-           issue = \"27730\")]\n+#[unstable(feature = \"ptr_internals\", issue = \"0\",\n+           reason = \"use NonNull instead and consider PhantomData<T> \\\n+                     (if you also use #[may_dangle]), Send, and/or Sync\")]\n pub struct Unique<T: ?Sized> {\n     pointer: NonZero<*const T>,\n     // NOTE: this marker has no consequences for variance, but is necessary\n@@ -2343,26 +2343,34 @@ pub struct Unique<T: ?Sized> {\n     _marker: PhantomData<T>,\n }\n \n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized> fmt::Debug for Unique<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Pointer::fmt(&self.as_ptr(), f)\n+    }\n+}\n+\n /// `Unique` pointers are `Send` if `T` is `Send` because the data they\n /// reference is unaliased. Note that this aliasing invariant is\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n-#[unstable(feature = \"unique\", issue = \"27730\")]\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n unsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n \n /// `Unique` pointers are `Sync` if `T` is `Sync` because the data they\n /// reference is unaliased. Note that this aliasing invariant is\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n-#[unstable(feature = \"unique\", issue = \"27730\")]\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n \n-#[unstable(feature = \"unique\", issue = \"27730\")]\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<T: Sized> Unique<T> {\n     /// Creates a new `Unique` that is dangling, but well-aligned.\n     ///\n     /// This is useful for initializing types which lazily allocate, like\n     /// `Vec::new` does.\n+    // FIXME: rename to dangling() to match NonNull?\n     pub fn empty() -> Self {\n         unsafe {\n             let ptr = mem::align_of::<T>() as *mut T;\n@@ -2371,14 +2379,13 @@ impl<T: Sized> Unique<T> {\n     }\n }\n \n-#[unstable(feature = \"unique\", issue = \"27730\")]\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<T: ?Sized> Unique<T> {\n     /// Creates a new `Unique`.\n     ///\n     /// # Safety\n     ///\n     /// `ptr` must be non-null.\n-    #[unstable(feature = \"unique\", issue = \"27730\")]\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n         Unique { pointer: NonZero::new_unchecked(ptr), _marker: PhantomData }\n     }\n@@ -2397,7 +2404,7 @@ impl<T: ?Sized> Unique<T> {\n     ///\n     /// The resulting lifetime is bound to self so this behaves \"as if\"\n     /// it were actually an instance of T that is getting borrowed. If a longer\n-    /// (unbound) lifetime is needed, use `&*my_ptr.ptr()`.\n+    /// (unbound) lifetime is needed, use `&*my_ptr.as_ptr()`.\n     pub unsafe fn as_ref(&self) -> &T {\n         &*self.as_ptr()\n     }\n@@ -2406,112 +2413,130 @@ impl<T: ?Sized> Unique<T> {\n     ///\n     /// The resulting lifetime is bound to self so this behaves \"as if\"\n     /// it were actually an instance of T that is getting borrowed. If a longer\n-    /// (unbound) lifetime is needed, use `&mut *my_ptr.ptr()`.\n+    /// (unbound) lifetime is needed, use `&mut *my_ptr.as_ptr()`.\n     pub unsafe fn as_mut(&mut self) -> &mut T {\n         &mut *self.as_ptr()\n     }\n }\n \n-#[unstable(feature = \"unique\", issue = \"27730\")]\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<T: ?Sized> Clone for Unique<T> {\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n-#[unstable(feature = \"unique\", issue = \"27730\")]\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<T: ?Sized> Copy for Unique<T> { }\n \n-#[unstable(feature = \"unique\", issue = \"27730\")]\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> { }\n \n-#[unstable(feature = \"unique\", issue = \"27730\")]\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<T: ?Sized> fmt::Pointer for Unique<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Pointer::fmt(&self.as_ptr(), f)\n     }\n }\n \n-#[unstable(feature = \"unique\", issue = \"27730\")]\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<'a, T: ?Sized> From<&'a mut T> for Unique<T> {\n     fn from(reference: &'a mut T) -> Self {\n         Unique { pointer: NonZero::from(reference), _marker: PhantomData }\n     }\n }\n \n-#[unstable(feature = \"unique\", issue = \"27730\")]\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<'a, T: ?Sized> From<&'a T> for Unique<T> {\n     fn from(reference: &'a T) -> Self {\n         Unique { pointer: NonZero::from(reference), _marker: PhantomData }\n     }\n }\n \n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<'a, T: ?Sized> From<NonNull<T>> for Unique<T> {\n+    fn from(p: NonNull<T>) -> Self {\n+        Unique { pointer: p.pointer, _marker: PhantomData }\n+    }\n+}\n+\n+/// Previous name of `NonNull`.\n+#[rustc_deprecated(since = \"1.24\", reason = \"renamed to `NonNull`\")]\n+#[unstable(feature = \"shared\", issue = \"27730\")]\n+pub type Shared<T> = NonNull<T>;\n+\n /// `*mut T` but non-zero and covariant.\n ///\n /// This is often the correct thing to use when building data structures using\n /// raw pointers, but is ultimately more dangerous to use because of its additional\n-/// properties. If you're not sure if you should use `Shared<T>`, just use `*mut T`!\n+/// properties. If you're not sure if you should use `NonNull<T>`, just use `*mut T`!\n ///\n /// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n /// is never dereferenced. This is so that enums may use this forbidden value\n-/// as a discriminant -- `Option<Shared<T>>` has the same size as `Shared<T>`.\n+/// as a discriminant -- `Option<NonNull<T>>` has the same size as `NonNull<T>`.\n /// However the pointer may still dangle if it isn't dereferenced.\n ///\n-/// Unlike `*mut T`, `Shared<T>` is covariant over `T`. If this is incorrect\n+/// Unlike `*mut T`, `NonNull<T>` is covariant over `T`. If this is incorrect\n /// for your use case, you should include some PhantomData in your type to\n /// provide invariance, such as `PhantomData<Cell<T>>` or `PhantomData<&'a mut T>`.\n /// Usually this won't be necessary; covariance is correct for most safe abstractions,\n /// such as Box, Rc, Arc, Vec, and LinkedList. This is the case because they\n /// provide a public API that follows the normal shared XOR mutable rules of Rust.\n-#[allow(missing_debug_implementations)]\n-#[unstable(feature = \"shared\", reason = \"needs an RFC to flesh out design\",\n-           issue = \"27730\")]\n-pub struct Shared<T: ?Sized> {\n+#[stable(feature = \"nonnull\", since = \"1.24.0\")]\n+pub struct NonNull<T: ?Sized> {\n     pointer: NonZero<*const T>,\n }\n \n-/// `Shared` pointers are not `Send` because the data they reference may be aliased.\n+#[stable(feature = \"nonnull\", since = \"1.24.0\")]\n+impl<T: ?Sized> fmt::Debug for NonNull<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Pointer::fmt(&self.as_ptr(), f)\n+    }\n+}\n+\n+/// `NonNull` pointers are not `Send` because the data they reference may be aliased.\n // NB: This impl is unnecessary, but should provide better error messages.\n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T: ?Sized> !Send for Shared<T> { }\n+#[stable(feature = \"nonnull\", since = \"1.24.0\")]\n+impl<T: ?Sized> !Send for NonNull<T> { }\n \n-/// `Shared` pointers are not `Sync` because the data they reference may be aliased.\n+/// `NonNull` pointers are not `Sync` because the data they reference may be aliased.\n // NB: This impl is unnecessary, but should provide better error messages.\n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T: ?Sized> !Sync for Shared<T> { }\n+#[stable(feature = \"nonnull\", since = \"1.24.0\")]\n+impl<T: ?Sized> !Sync for NonNull<T> { }\n \n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T: Sized> Shared<T> {\n-    /// Creates a new `Shared` that is dangling, but well-aligned.\n+impl<T: Sized> NonNull<T> {\n+    /// Creates a new `NonNull` that is dangling, but well-aligned.\n     ///\n     /// This is useful for initializing types which lazily allocate, like\n     /// `Vec::new` does.\n-    pub fn empty() -> Self {\n+    #[stable(feature = \"nonnull\", since = \"1.24.0\")]\n+    pub fn dangling() -> Self {\n         unsafe {\n             let ptr = mem::align_of::<T>() as *mut T;\n-            Shared::new_unchecked(ptr)\n+            NonNull::new_unchecked(ptr)\n         }\n     }\n }\n \n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T: ?Sized> Shared<T> {\n-    /// Creates a new `Shared`.\n+impl<T: ?Sized> NonNull<T> {\n+    /// Creates a new `NonNull`.\n     ///\n     /// # Safety\n     ///\n     /// `ptr` must be non-null.\n-    #[unstable(feature = \"shared\", issue = \"27730\")]\n+    #[stable(feature = \"nonnull\", since = \"1.24.0\")]\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n-        Shared { pointer: NonZero::new_unchecked(ptr) }\n+        NonNull { pointer: NonZero::new_unchecked(ptr) }\n     }\n \n-    /// Creates a new `Shared` if `ptr` is non-null.\n+    /// Creates a new `NonNull` if `ptr` is non-null.\n+    #[stable(feature = \"nonnull\", since = \"1.24.0\")]\n     pub fn new(ptr: *mut T) -> Option<Self> {\n-        NonZero::new(ptr as *const T).map(|nz| Shared { pointer: nz })\n+        NonZero::new(ptr as *const T).map(|nz| NonNull { pointer: nz })\n     }\n \n     /// Acquires the underlying `*mut` pointer.\n+    #[stable(feature = \"nonnull\", since = \"1.24.0\")]\n     pub fn as_ptr(self) -> *mut T {\n         self.pointer.get() as *mut T\n     }\n@@ -2520,7 +2545,8 @@ impl<T: ?Sized> Shared<T> {\n     ///\n     /// The resulting lifetime is bound to self so this behaves \"as if\"\n     /// it were actually an instance of T that is getting borrowed. If a longer\n-    /// (unbound) lifetime is needed, use `&*my_ptr.ptr()`.\n+    /// (unbound) lifetime is needed, use `&*my_ptr.as_ptr()`.\n+    #[stable(feature = \"nonnull\", since = \"1.24.0\")]\n     pub unsafe fn as_ref(&self) -> &T {\n         &*self.as_ptr()\n     }\n@@ -2529,56 +2555,50 @@ impl<T: ?Sized> Shared<T> {\n     ///\n     /// The resulting lifetime is bound to self so this behaves \"as if\"\n     /// it were actually an instance of T that is getting borrowed. If a longer\n-    /// (unbound) lifetime is needed, use `&mut *my_ptr.ptr_mut()`.\n+    /// (unbound) lifetime is needed, use `&mut *my_ptr.as_ptr()`.\n+    #[stable(feature = \"nonnull\", since = \"1.24.0\")]\n     pub unsafe fn as_mut(&mut self) -> &mut T {\n         &mut *self.as_ptr()\n     }\n-\n-    /// Acquires the underlying pointer as a `*mut` pointer.\n-    #[rustc_deprecated(since = \"1.19\", reason = \"renamed to `as_ptr` for ergonomics/consistency\")]\n-    #[unstable(feature = \"shared\", issue = \"27730\")]\n-    pub unsafe fn as_mut_ptr(&self) -> *mut T {\n-        self.as_ptr()\n-    }\n }\n \n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T: ?Sized> Clone for Shared<T> {\n+#[stable(feature = \"nonnull\", since = \"1.24.0\")]\n+impl<T: ?Sized> Clone for NonNull<T> {\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T: ?Sized> Copy for Shared<T> { }\n+#[stable(feature = \"nonnull\", since = \"1.24.0\")]\n+impl<T: ?Sized> Copy for NonNull<T> { }\n \n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T: ?Sized, U: ?Sized> CoerceUnsized<Shared<U>> for Shared<T> where T: Unsize<U> { }\n+#[stable(feature = \"nonnull\", since = \"1.24.0\")]\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n \n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T: ?Sized> fmt::Pointer for Shared<T> {\n+#[stable(feature = \"nonnull\", since = \"1.24.0\")]\n+impl<T: ?Sized> fmt::Pointer for NonNull<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Pointer::fmt(&self.as_ptr(), f)\n     }\n }\n \n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T: ?Sized> From<Unique<T>> for Shared<T> {\n+#[stable(feature = \"nonnull\", since = \"1.24.0\")]\n+impl<T: ?Sized> From<Unique<T>> for NonNull<T> {\n     fn from(unique: Unique<T>) -> Self {\n-        Shared { pointer: unique.pointer }\n+        NonNull { pointer: unique.pointer }\n     }\n }\n \n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<'a, T: ?Sized> From<&'a mut T> for Shared<T> {\n+#[stable(feature = \"nonnull\", since = \"1.24.0\")]\n+impl<'a, T: ?Sized> From<&'a mut T> for NonNull<T> {\n     fn from(reference: &'a mut T) -> Self {\n-        Shared { pointer: NonZero::from(reference) }\n+        NonNull { pointer: NonZero::from(reference) }\n     }\n }\n \n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<'a, T: ?Sized> From<&'a T> for Shared<T> {\n+#[stable(feature = \"nonnull\", since = \"1.24.0\")]\n+impl<'a, T: ?Sized> From<&'a T> for NonNull<T> {\n     fn from(reference: &'a T) -> Self {\n-        Shared { pointer: NonZero::from(reference) }\n+        NonNull { pointer: NonZero::from(reference) }\n     }\n }"}, {"sha": "1c32452f84635e6b6554b510b8a49199f7aac6d7", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -41,7 +41,6 @@\n #![feature(trusted_len)]\n #![feature(try_from)]\n #![feature(try_trait)]\n-#![feature(unique)]\n #![feature(exact_chunks)]\n \n extern crate core;"}, {"sha": "00f87336f3c80c863f2b3bdff684d429e9b50411", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -249,9 +249,9 @@ fn test_set_memory() {\n }\n \n #[test]\n-fn test_unsized_unique() {\n+fn test_unsized_nonnull() {\n     let xs: &[i32] = &[1, 2, 3];\n-    let ptr = unsafe { Unique::new_unchecked(xs as *const [i32] as *mut [i32]) };\n+    let ptr = unsafe { NonNull::new_unchecked(xs as *const [i32] as *mut [i32]) };\n     let ys = unsafe { ptr.as_ref() };\n     let zs: &[i32] = &[1, 2, 3];\n     assert!(ys == zs);"}, {"sha": "511c407d45a7fef0ad7d7cb0f5d937041b93826e", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -12,7 +12,7 @@\n \n use std::marker::Unsize;\n use std::iter::Extend;\n-use std::ptr::{self, drop_in_place, Shared};\n+use std::ptr::{self, drop_in_place, NonNull};\n use std::ops::{Deref, DerefMut, Range};\n use std::hash::{Hash, Hasher};\n use std::slice;\n@@ -146,7 +146,7 @@ impl<A: Array> ArrayVec<A> {\n                 tail_start: end,\n                 tail_len: len - end,\n                 iter: range_slice.iter(),\n-                array_vec: Shared::from(self),\n+                array_vec: NonNull::from(self),\n             }\n         }\n     }\n@@ -232,7 +232,7 @@ pub struct Drain<'a, A: Array>\n     tail_start: usize,\n     tail_len: usize,\n     iter: slice::Iter<'a, ManuallyDrop<A::Element>>,\n-    array_vec: Shared<ArrayVec<A>>,\n+    array_vec: NonNull<ArrayVec<A>>,\n }\n \n impl<'a, A: Array> Iterator for Drain<'a, A> {"}, {"sha": "a35ef2f7ce7baefec130cbd7a9823d3897010390", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -21,7 +21,6 @@\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![deny(warnings)]\n \n-#![feature(shared)]\n #![feature(collections_range)]\n #![feature(nonzero)]\n #![feature(unboxed_closures)]"}, {"sha": "73bd5747c105a98fd66d470264ab421c33cef817", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -16,7 +16,7 @@ use marker;\n use mem::{align_of, size_of, needs_drop};\n use mem;\n use ops::{Deref, DerefMut};\n-use ptr::{self, Unique, Shared};\n+use ptr::{self, Unique, NonNull};\n \n use self::BucketState::*;\n \n@@ -873,7 +873,7 @@ impl<K, V> RawTable<K, V> {\n                 elems_left,\n                 marker: marker::PhantomData,\n             },\n-            table: Shared::from(self),\n+            table: NonNull::from(self),\n             marker: marker::PhantomData,\n         }\n     }\n@@ -1020,7 +1020,7 @@ impl<K, V> IntoIter<K, V> {\n \n /// Iterator over the entries in a table, clearing the table.\n pub struct Drain<'a, K: 'a, V: 'a> {\n-    table: Shared<RawTable<K, V>>,\n+    table: NonNull<RawTable<K, V>>,\n     iter: RawBuckets<'static, K, V>,\n     marker: marker::PhantomData<&'a RawTable<K, V>>,\n }"}, {"sha": "91cc6d25cce01016601c16b1fc0c1a31f024747a", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -293,11 +293,11 @@\n #![feature(placement_in_syntax)]\n #![feature(placement_new_protocol)]\n #![feature(prelude_import)]\n+#![feature(ptr_internals)]\n #![feature(rand)]\n #![feature(raw)]\n #![feature(repr_align)]\n #![feature(rustc_attrs)]\n-#![feature(shared)]\n #![feature(sip_hash_13)]\n #![feature(slice_bytes)]\n #![feature(slice_concat_ext)]\n@@ -315,7 +315,6 @@\n #![feature(try_from)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n-#![feature(unique)]\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]\n #![feature(vec_push_all)]"}, {"sha": "560876006d3f348999cb6568a1381306d7bbc39c", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -17,7 +17,7 @@ use cell::UnsafeCell;\n use fmt;\n use ops::{Deref, DerefMut};\n use panicking;\n-use ptr::{Unique, Shared};\n+use ptr::{Unique, NonNull};\n use rc::Rc;\n use sync::{Arc, Mutex, RwLock, atomic};\n use thread::Result;\n@@ -196,10 +196,10 @@ impl<'a, T: RefUnwindSafe + ?Sized> UnwindSafe for &'a T {}\n impl<T: RefUnwindSafe + ?Sized> UnwindSafe for *const T {}\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n impl<T: RefUnwindSafe + ?Sized> UnwindSafe for *mut T {}\n-#[unstable(feature = \"unique\", issue = \"27730\")]\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<T: UnwindSafe + ?Sized> UnwindSafe for Unique<T> {}\n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T: RefUnwindSafe + ?Sized> UnwindSafe for Shared<T> {}\n+#[stable(feature = \"nonnull\", since = \"1.24.0\")]\n+impl<T: RefUnwindSafe + ?Sized> UnwindSafe for NonNull<T> {}\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n impl<T: ?Sized> UnwindSafe for Mutex<T> {}\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]"}, {"sha": "eaa5bc90805768e7643c8725eb6bd291b87bd78b", "filename": "src/test/run-pass/allocator-alloc-one.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Ftest%2Frun-pass%2Fallocator-alloc-one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Ftest%2Frun-pass%2Fallocator-alloc-one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator-alloc-one.rs?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(allocator_api, unique)]\n+#![feature(allocator_api, nonnull)]\n \n use std::heap::{Heap, Alloc};\n "}, {"sha": "7af732f561deb5d68cbdb6fb7d3eb2e5b4b1ef9e", "filename": "src/test/run-pass/issue-23433.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Ftest%2Frun-pass%2Fissue-23433.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Ftest%2Frun-pass%2Fissue-23433.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23433.rs?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -10,13 +10,11 @@\n \n // Don't fail if we encounter a NonZero<*T> where T is an unsized type\n \n-#![feature(unique)]\n-\n-use std::ptr::Unique;\n+use std::ptr::NonNull;\n \n fn main() {\n     let mut a = [0u8; 5];\n-    let b: Option<Unique<[u8]>> = Some(Unique::from(&mut a));\n+    let b: Option<NonNull<[u8]>> = Some(NonNull::from(&mut a));\n     match b {\n         Some(_) => println!(\"Got `Some`\"),\n         None => panic!(\"Unexpected `None`\"),"}, {"sha": "0296788f7a0f5402f94de16eb0ba06a7ced0fec7", "filename": "src/test/rustdoc-js/from_u.js", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Ftest%2Frustdoc-js%2Ffrom_u.js", "raw_url": "https://github.com/rust-lang/rust/raw/bdda8d61151a91fcc95b059918dd834c8e7ac09e/src%2Ftest%2Frustdoc-js%2Ffrom_u.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Ffrom_u.js?ref=bdda8d61151a91fcc95b059918dd834c8e7ac09e", "patch": "@@ -15,7 +15,6 @@ const EXPECTED = {\n         { 'path': 'std::char', 'name': 'from_u32' },\n         { 'path': 'std::str', 'name': 'from_utf8' },\n         { 'path': 'std::string::String', 'name': 'from_utf8' },\n-        { 'path': 'std::boxed::Box', 'name': 'from_unique' },\n         { 'path': 'std::i32', 'name': 'from_unsigned' },\n         { 'path': 'std::i128', 'name': 'from_unsigned' },\n     ],"}]}