{"sha": "dd1687ef416f9a5856872c7ed40c4a1a3d8788ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkMTY4N2VmNDE2ZjlhNTg1Njg3MmM3ZWQ0MGM0YTFhM2Q4Nzg4ZWE=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-01-11T16:58:50Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-14T22:40:03Z"}, "message": "Always check upper bounds when choosing member regions\n\nAlso correctly calculate what the upper bounds are.", "tree": {"sha": "6fd9b873020116b9a4937a620e1b6711f0d87a00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fd9b873020116b9a4937a620e1b6711f0d87a00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd1687ef416f9a5856872c7ed40c4a1a3d8788ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd1687ef416f9a5856872c7ed40c4a1a3d8788ea", "html_url": "https://github.com/rust-lang/rust/commit/dd1687ef416f9a5856872c7ed40c4a1a3d8788ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd1687ef416f9a5856872c7ed40c4a1a3d8788ea/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bd16f3c81af80718403e2e202fd0d59e8f94c60", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bd16f3c81af80718403e2e202fd0d59e8f94c60", "html_url": "https://github.com/rust-lang/rust/commit/2bd16f3c81af80718403e2e202fd0d59e8f94c60"}], "stats": {"total": 121, "additions": 81, "deletions": 40}, "files": [{"sha": "192e4700b91f66da05ff47b3a6558764529748cc", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 13, "deletions": 40, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/dd1687ef416f9a5856872c7ed40c4a1a3d8788ea/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd1687ef416f9a5856872c7ed40c4a1a3d8788ea/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=dd1687ef416f9a5856872c7ed40c4a1a3d8788ea", "patch": "@@ -12,8 +12,6 @@ use rustc::ty::{self, subst::SubstsRef, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc_data_structures::binary_search_util;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::scc::Sccs;\n-use rustc_data_structures::graph::vec_graph::VecGraph;\n-use rustc_data_structures::graph::WithSuccessors;\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n@@ -26,6 +24,7 @@ use crate::borrow_check::{\n     diagnostics::{RegionErrorKind, RegionErrors},\n     member_constraints::{MemberConstraintSet, NllMemberConstraintIndex},\n     nll::{PoloniusOutput, ToRegionVid},\n+    region_infer::reverse_sccs::ReverseSccGraph,\n     region_infer::values::{\n         LivenessValues, PlaceholderIndices, RegionElement, RegionValueElements, RegionValues,\n         ToElementIndex,\n@@ -37,6 +36,7 @@ use crate::borrow_check::{\n mod dump_mir;\n mod graphviz;\n mod opaque_types;\n+mod reverse_sccs;\n \n pub mod values;\n \n@@ -66,9 +66,10 @@ pub struct RegionInferenceContext<'tcx> {\n     /// compute the values of each region.\n     constraint_sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n \n-    /// Reverse of the SCC constraint graph -- i.e., an edge `A -> B`\n-    /// exists if `B: A`. Computed lazilly.\n-    rev_constraint_graph: Option<Rc<VecGraph<ConstraintSccIndex>>>,\n+    /// Reverse of the SCC constraint graph --  i.e., an edge `A -> B` exists if\n+    /// `B: A`. This is used to compute the universal regions that are required\n+    /// to outlive a given SCC. Computed lazily.\n+    rev_scc_graph: Option<Rc<ReverseSccGraph>>,\n \n     /// The \"R0 member of [R1..Rn]\" constraints, indexed by SCC.\n     member_constraints: Rc<MemberConstraintSet<'tcx, ConstraintSccIndex>>,\n@@ -288,7 +289,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             constraints,\n             constraint_graph,\n             constraint_sccs,\n-            rev_constraint_graph: None,\n+            rev_scc_graph: None,\n             member_constraints,\n             member_constraints_applied: Vec::new(),\n             closure_bounds_mapping,\n@@ -680,15 +681,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // free region that must outlive the member region `R0` (`UB:\n         // R0`). Therefore, we need only keep an option `O` if `UB: O`\n         // for all UB.\n-        if choice_regions.len() > 1 {\n-            let universal_region_relations = self.universal_region_relations.clone();\n-            let rev_constraint_graph = self.rev_constraint_graph();\n-            for ub in self.upper_bounds(scc, &rev_constraint_graph) {\n-                debug!(\"apply_member_constraint: ub={:?}\", ub);\n-                choice_regions.retain(|&o_r| universal_region_relations.outlives(ub, o_r));\n-            }\n-            debug!(\"apply_member_constraint: after ub, choice_regions={:?}\", choice_regions);\n+        let rev_scc_graph = self.reverse_scc_graph();\n+        let universal_region_relations = &self.universal_region_relations;\n+        for ub in rev_scc_graph.upper_bounds(scc) {\n+            debug!(\"apply_member_constraint: ub={:?}\", ub);\n+            choice_regions.retain(|&o_r| universal_region_relations.outlives(ub, o_r));\n         }\n+        debug!(\"apply_member_constraint: after ub, choice_regions={:?}\", choice_regions);\n \n         // If we ruled everything out, we're done.\n         if choice_regions.is_empty() {\n@@ -744,32 +743,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    /// Compute and return the reverse SCC-based constraint graph (lazilly).\n-    fn upper_bounds(\n-        &'a mut self,\n-        scc0: ConstraintSccIndex,\n-        rev_constraint_graph: &'a VecGraph<ConstraintSccIndex>,\n-    ) -> impl Iterator<Item = RegionVid> + 'a {\n-        let scc_values = &self.scc_values;\n-        let mut duplicates = FxHashSet::default();\n-        rev_constraint_graph\n-            .depth_first_search(scc0)\n-            .skip(1)\n-            .flat_map(move |scc1| scc_values.universal_regions_outlived_by(scc1))\n-            .filter(move |&r| duplicates.insert(r))\n-    }\n-\n-    /// Compute and return the reverse SCC-based constraint graph (lazilly).\n-    fn rev_constraint_graph(&mut self) -> Rc<VecGraph<ConstraintSccIndex>> {\n-        if let Some(g) = &self.rev_constraint_graph {\n-            return g.clone();\n-        }\n-\n-        let rev_graph = Rc::new(self.constraint_sccs.reverse());\n-        self.rev_constraint_graph = Some(rev_graph.clone());\n-        rev_graph\n-    }\n-\n     /// Returns `true` if all the elements in the value of `scc_b` are nameable\n     /// in `scc_a`. Used during constraint propagation, and only once\n     /// the value of `scc_b` has been computed."}, {"sha": "4b8357bda0280f66ea76399ca02880f21d512181", "filename": "src/librustc_mir/borrow_check/region_infer/reverse_sccs.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/dd1687ef416f9a5856872c7ed40c4a1a3d8788ea/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Freverse_sccs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd1687ef416f9a5856872c7ed40c4a1a3d8788ea/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Freverse_sccs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Freverse_sccs.rs?ref=dd1687ef416f9a5856872c7ed40c4a1a3d8788ea", "patch": "@@ -0,0 +1,68 @@\n+use crate::borrow_check::constraints::ConstraintSccIndex;\n+use crate::borrow_check::RegionInferenceContext;\n+use itertools::Itertools;\n+use rustc::ty::RegionVid;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::graph::vec_graph::VecGraph;\n+use rustc_data_structures::graph::WithSuccessors;\n+use std::ops::Range;\n+use std::rc::Rc;\n+\n+crate struct ReverseSccGraph {\n+    graph: VecGraph<ConstraintSccIndex>,\n+    /// For each SCC, the range of `universal_regions` that use that SCC as\n+    /// their value.\n+    scc_regions: FxHashMap<ConstraintSccIndex, Range<usize>>,\n+    /// All of the universal regions, in grouped so that `scc_regions` can\n+    /// index into here.\n+    universal_regions: Vec<RegionVid>,\n+}\n+\n+impl ReverseSccGraph {\n+    /// Find all universal regions that are required to outlive the given SCC.\n+    pub(super) fn upper_bounds<'a>(\n+        &'a self,\n+        scc0: ConstraintSccIndex,\n+    ) -> impl Iterator<Item = RegionVid> + 'a {\n+        let mut duplicates = FxHashSet::default();\n+        self.graph\n+            .depth_first_search(scc0)\n+            .flat_map(move |scc1| {\n+                self.scc_regions\n+                    .get(&scc1)\n+                    .map_or(&[][..], |range| &self.universal_regions[range.clone()])\n+            })\n+            .copied()\n+            .filter(move |r| duplicates.insert(*r))\n+    }\n+}\n+\n+impl RegionInferenceContext<'_> {\n+    /// Compute and return the reverse SCC-based constraint graph (lazily).\n+    pub(super) fn reverse_scc_graph(&mut self) -> Rc<ReverseSccGraph> {\n+        if let Some(g) = &self.rev_scc_graph {\n+            return g.clone();\n+        }\n+\n+        let graph = self.constraint_sccs.reverse();\n+        let mut paired_scc_regions = self\n+            .universal_regions\n+            .universal_regions()\n+            .map(|region| (self.constraint_sccs.scc(region), region))\n+            .collect_vec();\n+        paired_scc_regions.sort();\n+        let universal_regions = paired_scc_regions.iter().map(|&(_, region)| region).collect();\n+\n+        let mut scc_regions = FxHashMap::default();\n+        let mut start = 0;\n+        for (scc, group) in &paired_scc_regions.into_iter().group_by(|(scc, _)| *scc) {\n+            let group_size = group.into_iter().count();\n+            scc_regions.insert(scc, start..start + group_size);\n+            start += group_size;\n+        }\n+\n+        let rev_graph = Rc::new(ReverseSccGraph { graph, scc_regions, universal_regions });\n+        self.rev_scc_graph = Some(rev_graph.clone());\n+        rev_graph\n+    }\n+}"}]}