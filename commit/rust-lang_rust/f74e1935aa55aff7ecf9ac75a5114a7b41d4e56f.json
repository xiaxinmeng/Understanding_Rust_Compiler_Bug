{"sha": "f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3NGUxOTM1YWE1NWFmZjdlY2Y5YWM3NWE1MTE0YTdiNDFkNGU1NmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-16T07:04:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-16T07:04:13Z"}, "message": "auto merge of #7123 : huonw/rust/more-str, r=thestinger\n\nMoves all the remaining functions that could reasonably be methods to be methods, except for some FFI ones (which I believe @erickt is working on, possibly) and `each_split_within`, since I'm not really sure the details of it (I believe @kimundi wrote the current implementation, so maybe he could convert it to an external iterator method on `StrSlice`, e.g. `word_wrap_iter(&self) -> WordWrapIterator<'self>`, where `WordWrapIterator` impls `Iterator<&'self str>`. It probably won't be too hard, since it's already a state machine.)\r\n\r\nThis also cleans up the comparison impls for the string types, except I'm not sure how the lang items `eq_str` and `eq_str_uniq` need to be handled, so they (`eq_slice` and `eq`) remain stand-alone functions.", "tree": {"sha": "95cfabfbe2e63d3f42d0d8966d6b4af31ffb6c39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95cfabfbe2e63d3f42d0d8966d6b4af31ffb6c39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "html_url": "https://github.com/rust-lang/rust/commit/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba", "html_url": "https://github.com/rust-lang/rust/commit/8482d29d9b27a00e2d84bbf3bc0a3d14c61e34ba"}, {"sha": "bbcff95ac51f5533866d307a85eedb062a1a05da", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbcff95ac51f5533866d307a85eedb062a1a05da", "html_url": "https://github.com/rust-lang/rust/commit/bbcff95ac51f5533866d307a85eedb062a1a05da"}], "stats": {"total": 772, "additions": 342, "deletions": 430}, "files": [{"sha": "e0ceb79a37dfc31de5520d57dc465d387a40b83e", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -24,7 +24,6 @@ use util::logv;\n \n use core::io;\n use core::os;\n-use core::str;\n use core::uint;\n use core::vec;\n "}, {"sha": "5bf4dd517a5b2be655d12b7842cd1f64d40c1b03", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -229,8 +229,6 @@ impl<'self> FromBase64 for &'self str {\n \n #[cfg(test)]\n mod tests {\n-    use core::str;\n-\n     #[test]\n     fn test_to_base64() {\n         assert_eq!(\"\".to_base64(), ~\"\");"}, {"sha": "fed73256c002c18164e7eff2d24d373edffaf28b", "filename": "src/libextra/rope.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frope.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -1271,7 +1271,6 @@ mod tests {\n \n     use rope::*;\n \n-    use core::str;\n     use core::uint;\n     use core::vec;\n "}, {"sha": "7c4b3f4ce39f7345ddaa9ed49912cc20d14854c9", "filename": "src/libextra/sha1.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsha1.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -24,7 +24,6 @@\n \n use core::prelude::*;\n \n-use core::str;\n use core::uint;\n use core::vec;\n \n@@ -279,8 +278,6 @@ pub fn sha1() -> @Sha1 {\n mod tests {\n     use sha1;\n \n-    use core::vec;\n-\n     #[test]\n     fn test() {\n         struct Test {"}, {"sha": "972bccde18a2554aced05c8aeecd9625e3b2ae53", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -294,11 +294,6 @@ mod tests {\n \n     use super::SmallIntMap;\n \n-    use core::local_data;\n-    use core::rand;\n-    use core::uint;\n-    use core::vec;\n-\n     #[test]\n     fn test_find_mut() {\n         let mut m = SmallIntMap::new();"}, {"sha": "b88fd374da25414d1fa04a83340f2c930aeb23a1", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -751,7 +751,6 @@ fn shift_vec<T:Copy>(dest: &mut [T],\n mod test_qsort3 {\n     use sort::*;\n \n-    use core::vec;\n \n     fn check_sort(v1: &mut [int], v2: &mut [int]) {\n         let len = v1.len();\n@@ -861,8 +860,6 @@ mod tests {\n \n     use sort::*;\n \n-    use core::vec;\n-\n     fn check_sort(v1: &[int], v2: &[int]) {\n         let len = v1.len();\n         pub fn le(a: &int, b: &int) -> bool { *a <= *b }"}, {"sha": "3a1de5de01d60558041742ea575c2467d7029104", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -12,7 +12,6 @@\n \n use core::prelude::*;\n \n-use core::vec;\n use core::f64;\n use core::cmp;\n use core::num;"}, {"sha": "93759bea35f7e4b9fce60642337dfa62f706ee58", "filename": "src/libextra/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstd.rc?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -37,6 +37,7 @@ not required in or otherwise suitable for the core library.\n \n extern mod core(name = \"std\", vers = \"0.7-pre\");\n \n+#[cfg(stage0)]\n use core::{str, unstable};\n use core::str::{StrSlice, OwnedStr};\n "}, {"sha": "39dcee5eff315a04cb412451078f8174e18ac3d6", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -36,7 +36,6 @@ mod tests {\n     use tempfile::mkdtemp;\n \n     use core::os;\n-    use core::str;\n \n     #[test]\n     fn test_mkdtemp() {"}, {"sha": "66649c62fcaf34759bffe0d079130827c49d1980", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -313,7 +313,6 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use p = core::path::Path;\n \n     #[test]\n     fn test_veclens() {"}, {"sha": "72837cb4ae1f789d4e0f9759e8a4eea712b5263c", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -26,7 +26,6 @@ use core::either;\n use core::io;\n use core::option;\n use core::result;\n-use core::str;\n use core::task;\n use core::to_str::ToStr;\n use core::uint;\n@@ -542,7 +541,7 @@ pub fn filter_tests(\n \n     // Sort the tests alphabetically\n     fn lteq(t1: &TestDescAndFn, t2: &TestDescAndFn) -> bool {\n-        str::le(t1.desc.name.to_str(), t2.desc.name.to_str())\n+        t1.desc.name.to_str() < t2.desc.name.to_str()\n     }\n     sort::quick_sort(filtered, lteq);\n "}, {"sha": "e37ce7c71ef79c97b47fb6a523ddef4916e559ef", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -710,7 +710,6 @@ mod test_treemap {\n \n     use core::rand::RngUtil;\n     use core::rand;\n-    use core::str;\n     use core::vec;\n \n     #[test]"}, {"sha": "33f578d335b0e540d34b2171b715e53fc9afab5e", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -199,9 +199,6 @@ pub fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n mod test {\n     use core::prelude::*;\n \n-    use core::os;\n-    use core::str;\n-\n     // FIXME(#2119): the outer attribute should be #[cfg(unix, test)], then\n     // these redundant #[cfg(test)] blocks can be removed\n     #[cfg(test)]"}, {"sha": "925b1f506d75d31e675fd692615052ed426baac7", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -15,7 +15,6 @@ use cstore = metadata::cstore;\n use driver::session::Session;\n use e = metadata::encoder;\n use metadata::decoder;\n-use metadata::encoder;\n use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter};\n use metadata::tyencode;"}, {"sha": "3e656b3e5940509cb7ff8be7b785101bef842afd", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -4845,7 +4845,7 @@ impl Resolver {\n         let mut smallest = 0;\n         for maybes.eachi |i, &other| {\n \n-            values[i] = str::levdistance(name, other);\n+            values[i] = name.lev_distance(other);\n \n             if values[i] <= values[smallest] {\n                 smallest = i;"}, {"sha": "5481ed9a7fdfd46158efaeb677806da0c6006481", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -47,7 +47,6 @@\n use core::container::Map;\n use core::libc::c_ulonglong;\n use core::option::{Option, Some, None};\n-use core::str;\n use core::vec;\n \n use lib::llvm::{ValueRef, TypeRef, True, IntEQ, IntNE};"}, {"sha": "ffc54bbed3551fc9f0bee4974f3017ba043fe125", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -71,7 +71,6 @@ use core::libc::c_uint;\n use core::str;\n use core::uint;\n use core::vec;\n-use core::local_data;\n use extra::time;\n use syntax::ast::ident;\n use syntax::ast_map::{path, path_elt_to_str, path_name};\n@@ -3120,4 +3119,3 @@ pub fn trans_crate(sess: session::Session,\n \n     return (llcx, llmod, link_meta);\n }\n-"}, {"sha": "3775aafb56969539cddb3e9e19cb545393decb07", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -32,8 +32,6 @@ use syntax::ast;\n use syntax::ast_map;\n use syntax;\n \n-#[cfg(test)] use core::vec;\n-\n pub struct Ctxt {\n     ast: @ast::crate,\n     ast_map: ast_map::map"}, {"sha": "dbaa5e8532cb3b91a9bbe5896a1e5cf0a96e238f", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -24,7 +24,6 @@ use fold::Fold;\n use fold;\n use pass::Pass;\n \n-use core::str;\n use core::util;\n \n pub fn mk_pass() -> Pass {\n@@ -129,25 +128,21 @@ fn first_sentence_(s: &str) -> ~str {\n         }\n     });\n     match idx {\n-        Some(idx) if idx > 2u => {\n-            str::to_owned(s.slice(0, idx - 1))\n-        }\n+        Some(idx) if idx > 2u => s.slice(0, idx - 1).to_owned(),\n         _ => {\n             if s.ends_with(\".\") {\n-                str::to_owned(s)\n+                s.to_owned()\n             } else {\n-                str::to_owned(s)\n+                s.to_owned()\n             }\n         }\n     }\n }\n \n pub fn paragraphs(s: &str) -> ~[~str] {\n-    let mut lines = ~[];\n-    for str::each_line_any(s) |line| { lines.push(line.to_owned()); }\n     let mut whitespace_lines = 0;\n     let mut accum = ~\"\";\n-    let paras = do lines.iter().fold(~[]) |paras, line| {\n+    let paras = do s.any_line_iter().fold(~[]) |paras, line| {\n         let mut res = paras;\n \n         if line.is_whitespace() {\n@@ -163,9 +158,9 @@ pub fn paragraphs(s: &str) -> ~[~str] {\n             whitespace_lines = 0;\n \n             accum = if accum.is_empty() {\n-                copy *line\n+                line.to_owned()\n             } else {\n-                accum + \"\\n\" + *line\n+                fmt!(\"%s\\n%s\", accum, line)\n             }\n         }\n "}, {"sha": "f8c49f544bc2efb25e327680bb632ba7f210b183", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -285,8 +285,6 @@ mod test {\n     use extract::{extract, from_srv};\n     use parse;\n \n-    use core::vec;\n-\n     fn mk_doc(source: @str) -> doc::Doc {\n         let ast = parse::from_str(source);\n         extract(ast, ~\"\")"}, {"sha": "075b64a674cbbaffbdef0a8ef9151616952a87fd", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -466,10 +466,7 @@ fn write_variant(ctxt: &Ctxt, doc: doc::VariantDoc) {\n }\n \n fn list_item_indent(item: &str) -> ~str {\n-    let mut indented = ~[];\n-    for str::each_line_any(item) |line| {\n-        indented.push(line);\n-    }\n+    let indented = item.any_line_iter().collect::<~[&str]>();\n \n     // separate markdown elements within `*` lists must be indented by four\n     // spaces, or they will escape the list context. indenting everything\n@@ -539,8 +536,6 @@ mod test {\n     use tystr_pass;\n     use unindent_pass;\n \n-    use core::str;\n-\n     fn render(source: ~str) -> ~str {\n         let (srv, doc) = create_doc_srv(source);\n         let markdown = write_markdown_str_srv(srv, doc);"}, {"sha": "584e6ccc887301a3e2176cfbd0817ed170182965", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -157,7 +157,6 @@ mod test {\n     use doc;\n     use extract;\n     use page_pass::run;\n-    use core::vec;\n \n     fn mk_doc_(\n         output_style: config::OutputStyle,"}, {"sha": "484eb8c7980dc06bbff5b052edafa0295f523e80", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -77,8 +77,6 @@ mod test {\n \n     #[test]\n     fn should_prune_hidden_items() {\n-        use core::vec;\n-\n         let doc = mk_doc(~\"#[doc(hidden)] mod a { }\");\n         assert!(doc.cratemod().mods().is_empty())\n     }"}, {"sha": "741da3e265eebb91e1c998317fb36d285cfba291", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -162,7 +162,6 @@ mod test {\n     use extract;\n     use tystr_pass;\n     use prune_private_pass::run;\n-    use core::vec;\n \n     fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {"}, {"sha": "ba433bf479d2cebe5b5d0dde6c5dcffc838b65f6", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -19,7 +19,7 @@ use fold::Fold;\n use fold;\n use pass::Pass;\n \n-use core::str;\n+use core::iterator::IteratorUtil;\n \n pub fn mk_pass() -> Pass {\n     Pass {\n@@ -104,39 +104,37 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n     if desc.is_none() {\n         return (None, ~[]);\n     }\n-    let mut lines = ~[];\n-    for str::each_line_any(*desc.get_ref()) |line| { lines.push(line.to_owned()); }\n \n     let mut new_desc = None::<~str>;\n     let mut current_section = None;\n     let mut sections = ~[];\n \n-    for lines.each |line| {\n-        match parse_header(copy *line) {\n+    for desc.get_ref().any_line_iter().advance |line| {\n+        match parse_header(line) {\n           Some(header) => {\n             if current_section.is_some() {\n-                sections += [copy *current_section.get_ref()];\n+                sections.push(copy *current_section.get_ref());\n             }\n             current_section = Some(doc::Section {\n-                header: header,\n+                header: header.to_owned(),\n                 body: ~\"\"\n             });\n           }\n           None => {\n             match copy current_section {\n               Some(section) => {\n                 current_section = Some(doc::Section {\n-                    body: section.body + \"\\n\" + *line,\n+                    body: fmt!(\"%s\\n%s\", section.body, line),\n                     .. section\n                 });\n               }\n               None => {\n                 new_desc = match copy new_desc {\n                   Some(desc) => {\n-                    Some(desc + \"\\n\" + *line)\n+                    Some(fmt!(\"%s\\n%s\", desc, line))\n                   }\n                   None => {\n-                    Some(copy *line)\n+                    Some(line.to_owned())\n                   }\n                 };\n               }\n@@ -146,15 +144,15 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n     }\n \n     if current_section.is_some() {\n-        sections += [current_section.get()];\n+        sections.push(current_section.unwrap());\n     }\n \n     (new_desc, sections)\n }\n \n-fn parse_header(line: ~str) -> Option<~str> {\n+fn parse_header<'a>(line: &'a str) -> Option<&'a str> {\n     if line.starts_with(\"# \") {\n-        Some(line.slice(2u, line.len()).to_owned())\n+        Some(line.slice_from(2))\n     } else {\n         None\n     }\n@@ -172,9 +170,6 @@ mod test {\n     use extract;\n     use sectionalize_pass::run;\n \n-    use core::str;\n-    use core::vec;\n-\n     fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");"}, {"sha": "6db582a60e98baac7f9da61db15717b563918cd9", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -149,8 +149,6 @@ mod test {\n     use sectionalize_pass;\n     use text_pass::mk_pass;\n \n-    use core::str;\n-\n     fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n             let doc = extract::from_srv(srv.clone(), ~\"\");"}, {"sha": "2bcf04c0262e0b4f6a0f49a7c9599f8f7f22bbbc", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -21,7 +21,6 @@ middle of a line, and each of the following lines is indented.\n \n use core::prelude::*;\n \n-use core::str;\n use core::uint;\n use pass::Pass;\n use text_pass;\n@@ -31,8 +30,7 @@ pub fn mk_pass() -> Pass {\n }\n \n fn unindent(s: &str) -> ~str {\n-    let mut lines = ~[];\n-    for str::each_line_any(s) |line| { lines.push(line.to_owned()); }\n+    let lines = s.any_line_iter().collect::<~[&str]>();\n     let mut saw_first_line = false;\n     let mut saw_second_line = false;\n     let min_indent = do lines.iter().fold(uint::max_value)\n@@ -76,19 +74,20 @@ fn unindent(s: &str) -> ~str {\n         }\n     };\n \n-    if !lines.is_empty() {\n-        let unindented = ~[lines.head().trim().to_owned()]\n-            + do lines.tail().map |line| {\n-            if line.is_whitespace() {\n-                copy *line\n-            } else {\n-                assert!(line.len() >= min_indent);\n-                line.slice(min_indent, line.len()).to_owned()\n-            }\n-        };\n-        unindented.connect(\"\\n\")\n-    } else {\n-        s.to_str()\n+    match lines {\n+        [head, .. tail] => {\n+            let mut unindented = ~[ head.trim() ];\n+            unindented.push_all(do tail.map |&line| {\n+                if line.is_whitespace() {\n+                    line\n+                } else {\n+                    assert!(line.len() >= min_indent);\n+                    line.slice_from(min_indent)\n+                }\n+            });\n+            unindented.connect(\"\\n\")\n+        }\n+        [] => s.to_owned()\n     }\n }\n "}, {"sha": "0af6ed724e1dafeb66edfb3b3ec24244ecfb42a2", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -370,7 +370,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n                     if arg.ends_with(\".rs\") || arg.ends_with(\".rc\") {\n                     (arg.slice_to(arg.len() - 3).to_owned(), copy *arg)\n                 } else {\n-                    (copy *arg, arg + \".rs\")\n+                    (copy *arg, *arg + \".rs\")\n                 };\n                 match compile_crate(filename, copy repl.binary) {\n                     Some(_) => loaded_crates.push(crate),"}, {"sha": "e48dc723c47a4a69a8f516aea0772f7a8ec5f54e", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -144,7 +144,7 @@ pub mod win32 {\n     }\n \n     pub fn as_utf16_p<T>(s: &str, f: &fn(*u16) -> T) -> T {\n-        let mut t = str::to_utf16(s);\n+        let mut t = s.to_utf16();\n         // Null terminate before passing on.\n         t += [0u16];\n         vec::as_imm_buf(t, |buf, _len| f(buf))"}, {"sha": "9c4e8f083584c542adcaa501d18dbb3f1bfc7f6e", "filename": "src/libstd/path.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -515,7 +515,7 @@ impl GenericPath for PosixPath {\n     fn with_filestem(&self, s: &str) -> PosixPath {\n         match self.filetype() {\n             None => self.with_filename(s),\n-            Some(ref t) => self.with_filename(str::to_owned(s) + *t),\n+            Some(ref t) => self.with_filename(s.to_owned() + *t),\n         }\n     }\n \n@@ -657,7 +657,7 @@ impl GenericPath for WindowsPath {\n             (None, None) => {\n                 host = None;\n                 device = None;\n-                rest = str::to_owned(s);\n+                rest = s.to_owned();\n             }\n         }\n \n@@ -729,7 +729,7 @@ impl GenericPath for WindowsPath {\n     fn with_filestem(&self, s: &str) -> WindowsPath {\n         match self.filetype() {\n             None => self.with_filename(s),\n-            Some(ref t) => self.with_filename(str::to_owned(s) + *t),\n+            Some(ref t) => self.with_filename(s.to_owned() + *t),\n         }\n     }\n \n@@ -947,7 +947,6 @@ pub mod windows {\n mod tests {\n     use option::{None, Some};\n     use path::{PosixPath, WindowsPath, windows};\n-    use str;\n \n     #[test]\n     fn test_double_slash_collapsing() {\n@@ -984,7 +983,7 @@ mod tests {\n     fn test_posix_paths() {\n         fn t(wp: &PosixPath, s: &str) {\n             let ss = wp.to_str();\n-            let sss = str::to_owned(s);\n+            let sss = s.to_owned();\n             if (ss != sss) {\n                 debug!(\"got %s\", ss);\n                 debug!(\"expected %s\", sss);\n@@ -1042,7 +1041,7 @@ mod tests {\n     fn test_normalize() {\n         fn t(wp: &PosixPath, s: &str) {\n             let ss = wp.to_str();\n-            let sss = str::to_owned(s);\n+            let sss = s.to_owned();\n             if (ss != sss) {\n                 debug!(\"got %s\", ss);\n                 debug!(\"expected %s\", sss);\n@@ -1105,7 +1104,7 @@ mod tests {\n     fn test_windows_paths() {\n         fn t(wp: &WindowsPath, s: &str) {\n             let ss = wp.to_str();\n-            let sss = str::to_owned(s);\n+            let sss = s.to_owned();\n             if (ss != sss) {\n                 debug!(\"got %s\", ss);\n                 debug!(\"expected %s\", sss);"}, {"sha": "21f747317f4a5f1e5ce9a823b5dd24aed31d8a11", "filename": "src/libstd/str.rs", "status": "modified", "additions": 291, "deletions": 322, "changes": 613, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -23,10 +23,9 @@ use cast;\n use char;\n use char::Char;\n use clone::Clone;\n-use cmp::{TotalOrd, Ordering, Less, Equal, Greater};\n use container::Container;\n use iter::Times;\n-use iterator::{Iterator, IteratorUtil, FilterIterator, AdditiveIterator};\n+use iterator::{Iterator, IteratorUtil, FilterIterator, AdditiveIterator, MapIterator};\n use libc;\n use option::{None, Option, Some};\n use old_iter::{BaseIter, EqIter};\n@@ -37,8 +36,6 @@ use uint;\n use vec;\n use vec::{OwnedVector, OwnedCopyableVector, ImmutableVector};\n \n-#[cfg(not(test))] use cmp::{Eq, Ord, Equiv, TotalEq};\n-\n /*\n Section: Conditions\n */\n@@ -291,6 +288,10 @@ pub type WordIterator<'self> =\n     FilterIterator<'self, &'self str,\n              StrCharSplitIterator<'self, extern \"Rust\" fn(char) -> bool>>;\n \n+/// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n+pub type AnyLineIterator<'self> =\n+    MapIterator<'self, &'self str, &'self str, StrCharSplitIterator<'self, char>>;\n+\n impl<'self, Sep: CharEq> Iterator<&'self str> for StrCharSplitIterator<'self, Sep> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self str> {\n@@ -400,56 +401,6 @@ impl<'self> Iterator<&'self str> for StrStrSplitIterator<'self> {\n     }\n }\n \n-/// Levenshtein Distance between two strings\n-pub fn levdistance(s: &str, t: &str) -> uint {\n-\n-    let slen = s.len();\n-    let tlen = t.len();\n-\n-    if slen == 0 { return tlen; }\n-    if tlen == 0 { return slen; }\n-\n-    let mut dcol = vec::from_fn(tlen + 1, |x| x);\n-\n-    for s.iter().enumerate().advance |(i, sc)| {\n-\n-        let mut current = i;\n-        dcol[0] = current + 1;\n-\n-        for t.iter().enumerate().advance |(j, tc)| {\n-\n-            let next = dcol[j + 1];\n-\n-            if sc == tc {\n-                dcol[j + 1] = current;\n-            } else {\n-                dcol[j + 1] = ::cmp::min(current, next);\n-                dcol[j + 1] = ::cmp::min(dcol[j + 1], dcol[j]) + 1;\n-            }\n-\n-            current = next;\n-        }\n-    }\n-\n-    return dcol[tlen];\n-}\n-\n-/**\n- * Splits a string into substrings separated by LF ('\\n')\n- * and/or CR LF (\"\\r\\n\")\n- */\n-pub fn each_line_any<'a>(s: &'a str, it: &fn(&'a str) -> bool) -> bool {\n-    for s.line_iter().advance |s| {\n-        let l = s.len();\n-        if l > 0u && s[l - 1u] == '\\r' as u8 {\n-            if !it( unsafe { raw::slice_bytes(s, 0, l - 1) } ) { return false; }\n-        } else {\n-            if !it( s ) { return false; }\n-        }\n-    }\n-    return true;\n-}\n-\n /** Splits a string into substrings with possibly internal whitespace,\n  *  each of them at most `lim` bytes long. The substrings have leading and trailing\n  *  whitespace removed, and are only cut at whitespace boundaries.\n@@ -576,196 +527,6 @@ pub fn eq(a: &~str, b: &~str) -> bool {\n     eq_slice(*a, *b)\n }\n \n-#[inline]\n-fn cmp(a: &str, b: &str) -> Ordering {\n-    let low = uint::min(a.len(), b.len());\n-\n-    for uint::range(0, low) |idx| {\n-        match a[idx].cmp(&b[idx]) {\n-          Greater => return Greater,\n-          Less => return Less,\n-          Equal => ()\n-        }\n-    }\n-\n-    a.len().cmp(&b.len())\n-}\n-\n-#[cfg(not(test))]\n-impl<'self> TotalOrd for &'self str {\n-    #[inline]\n-    fn cmp(&self, other: & &'self str) -> Ordering { cmp(*self, *other) }\n-}\n-\n-#[cfg(not(test))]\n-impl TotalOrd for ~str {\n-    #[inline]\n-    fn cmp(&self, other: &~str) -> Ordering { cmp(*self, *other) }\n-}\n-\n-#[cfg(not(test))]\n-impl TotalOrd for @str {\n-    #[inline]\n-    fn cmp(&self, other: &@str) -> Ordering { cmp(*self, *other) }\n-}\n-\n-/// Bytewise slice less than\n-#[inline]\n-fn lt(a: &str, b: &str) -> bool {\n-    let (a_len, b_len) = (a.len(), b.len());\n-    let end = uint::min(a_len, b_len);\n-\n-    let mut i = 0;\n-    while i < end {\n-        let (c_a, c_b) = (a[i], b[i]);\n-        if c_a < c_b { return true; }\n-        if c_a > c_b { return false; }\n-        i += 1;\n-    }\n-\n-    return a_len < b_len;\n-}\n-\n-/// Bytewise less than or equal\n-#[inline]\n-pub fn le(a: &str, b: &str) -> bool {\n-    !lt(b, a)\n-}\n-\n-/// Bytewise greater than or equal\n-#[inline]\n-fn ge(a: &str, b: &str) -> bool {\n-    !lt(a, b)\n-}\n-\n-/// Bytewise greater than\n-#[inline]\n-fn gt(a: &str, b: &str) -> bool {\n-    !le(a, b)\n-}\n-\n-#[cfg(not(test))]\n-impl<'self> Eq for &'self str {\n-    #[inline(always)]\n-    fn eq(&self, other: & &'self str) -> bool {\n-        eq_slice((*self), (*other))\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: & &'self str) -> bool { !(*self).eq(other) }\n-}\n-\n-#[cfg(not(test))]\n-impl Eq for ~str {\n-    #[inline(always)]\n-    fn eq(&self, other: &~str) -> bool {\n-        eq_slice((*self), (*other))\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: &~str) -> bool { !(*self).eq(other) }\n-}\n-\n-#[cfg(not(test))]\n-impl Eq for @str {\n-    #[inline(always)]\n-    fn eq(&self, other: &@str) -> bool {\n-        eq_slice((*self), (*other))\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: &@str) -> bool { !(*self).eq(other) }\n-}\n-\n-#[cfg(not(test))]\n-impl<'self> TotalEq for &'self str {\n-    #[inline(always)]\n-    fn equals(&self, other: & &'self str) -> bool {\n-        eq_slice((*self), (*other))\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl TotalEq for ~str {\n-    #[inline(always)]\n-    fn equals(&self, other: &~str) -> bool {\n-        eq_slice((*self), (*other))\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl TotalEq for @str {\n-    #[inline(always)]\n-    fn equals(&self, other: &@str) -> bool {\n-        eq_slice((*self), (*other))\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl Ord for ~str {\n-    #[inline(always)]\n-    fn lt(&self, other: &~str) -> bool { lt((*self), (*other)) }\n-    #[inline(always)]\n-    fn le(&self, other: &~str) -> bool { le((*self), (*other)) }\n-    #[inline(always)]\n-    fn ge(&self, other: &~str) -> bool { ge((*self), (*other)) }\n-    #[inline(always)]\n-    fn gt(&self, other: &~str) -> bool { gt((*self), (*other)) }\n-}\n-\n-#[cfg(not(test))]\n-impl<'self> Ord for &'self str {\n-    #[inline(always)]\n-    fn lt(&self, other: & &'self str) -> bool { lt((*self), (*other)) }\n-    #[inline(always)]\n-    fn le(&self, other: & &'self str) -> bool { le((*self), (*other)) }\n-    #[inline(always)]\n-    fn ge(&self, other: & &'self str) -> bool { ge((*self), (*other)) }\n-    #[inline(always)]\n-    fn gt(&self, other: & &'self str) -> bool { gt((*self), (*other)) }\n-}\n-\n-#[cfg(not(test))]\n-impl Ord for @str {\n-    #[inline(always)]\n-    fn lt(&self, other: &@str) -> bool { lt((*self), (*other)) }\n-    #[inline(always)]\n-    fn le(&self, other: &@str) -> bool { le((*self), (*other)) }\n-    #[inline(always)]\n-    fn ge(&self, other: &@str) -> bool { ge((*self), (*other)) }\n-    #[inline(always)]\n-    fn gt(&self, other: &@str) -> bool { gt((*self), (*other)) }\n-}\n-\n-#[cfg(not(test))]\n-impl<'self, S: Str> Equiv<S> for &'self str {\n-    #[inline(always)]\n-    fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n-}\n-#[cfg(not(test))]\n-impl<'self, S: Str> Equiv<S> for @str {\n-    #[inline(always)]\n-    fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n-}\n-\n-#[cfg(not(test))]\n-impl<'self, S: Str> Equiv<S> for ~str {\n-    #[inline(always)]\n-    fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n-}\n-\n-\n-/*\n-Section: Iterating through strings\n-*/\n-\n-/// Apply a function to each character\n-pub fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n-    let mut result = ~\"\";\n-    result.reserve(ss.len());\n-    for ss.iter().advance |cc| {\n-        result.push_char(ff(cc));\n-    }\n-    result\n-}\n-\n /*\n Section: Searching\n */\n@@ -820,30 +581,6 @@ pub fn is_utf16(v: &[u16]) -> bool {\n     return true;\n }\n \n-/// Converts to a vector of `u16` encoded as UTF-16\n-pub fn to_utf16(s: &str) -> ~[u16] {\n-    let mut u = ~[];\n-    for s.iter().advance |ch| {\n-        // Arithmetic with u32 literals is easier on the eyes than chars.\n-        let mut ch = ch as u32;\n-\n-        if (ch & 0xFFFF_u32) == ch {\n-            // The BMP falls through (assuming non-surrogate, as it\n-            // should)\n-            assert!(ch <= 0xD7FF_u32 || ch >= 0xE000_u32);\n-            u.push(ch as u16)\n-        } else {\n-            // Supplementary planes break into surrogates.\n-            assert!(ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32);\n-            ch -= 0x1_0000_u32;\n-            let w1 = 0xD800_u16 | ((ch >> 10) as u16);\n-            let w2 = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n-            u.push_all([w1, w2])\n-        }\n-    }\n-    u\n-}\n-\n /// Iterates over the utf-16 characters in the specified slice, yielding each\n /// decoded unicode character to the function provided.\n ///\n@@ -989,40 +726,6 @@ pub fn as_buf<T>(s: &str, f: &fn(*u8, uint) -> T) -> T {\n     }\n }\n \n-/**\n- * Returns the byte offset of an inner slice relative to an enclosing outer slice\n- *\n- * # Example\n- *\n- * ~~~ {.rust}\n- * let string = \"a\\nb\\nc\";\n- * let mut lines = ~[];\n- * for string.line_iter().advance |line| { lines.push(line) }\n- *\n- * assert!(subslice_offset(string, lines[0]) == 0); // &\"a\"\n- * assert!(subslice_offset(string, lines[1]) == 2); // &\"b\"\n- * assert!(subslice_offset(string, lines[2]) == 4); // &\"c\"\n- * ~~~\n- */\n-#[inline(always)]\n-pub fn subslice_offset(outer: &str, inner: &str) -> uint {\n-    do as_buf(outer) |a, a_len| {\n-        do as_buf(inner) |b, b_len| {\n-            let a_start: uint;\n-            let a_end: uint;\n-            let b_start: uint;\n-            let b_end: uint;\n-            unsafe {\n-                a_start = cast::transmute(a); a_end = a_len + cast::transmute(a);\n-                b_start = cast::transmute(b); b_end = b_len + cast::transmute(b);\n-            }\n-            assert!(a_start <= b_start);\n-            assert!(b_end <= a_end);\n-            b_start - a_start\n-        }\n-    }\n-}\n-\n /// Unsafe operations\n pub mod raw {\n     use cast;\n@@ -1207,12 +910,138 @@ pub mod raw {\n #[cfg(not(test))]\n pub mod traits {\n     use ops::Add;\n-    impl<'self> Add<&'self str,~str> for ~str {\n+    use cmp::{TotalOrd, Ordering, Less, Equal, Greater, Eq, Ord, Equiv, TotalEq};\n+    use super::{Str, eq_slice};\n+\n+    impl<'self> Add<&'self str,~str> for &'self str {\n         #[inline(always)]\n         fn add(&self, rhs: & &'self str) -> ~str {\n-            self.append((*rhs))\n+            let mut ret = self.to_owned();\n+            ret.push_str(*rhs);\n+            ret\n         }\n     }\n+\n+    impl<'self> TotalOrd for &'self str {\n+        #[inline]\n+        fn cmp(&self, other: & &'self str) -> Ordering {\n+            for self.bytes_iter().zip(other.bytes_iter()).advance |(s_b, o_b)| {\n+                match s_b.cmp(&o_b) {\n+                    Greater => return Greater,\n+                    Less => return Less,\n+                    Equal => ()\n+                }\n+            }\n+\n+            self.len().cmp(&other.len())\n+        }\n+    }\n+\n+    impl TotalOrd for ~str {\n+        #[inline]\n+        fn cmp(&self, other: &~str) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n+    }\n+\n+    impl TotalOrd for @str {\n+        #[inline]\n+        fn cmp(&self, other: &@str) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n+    }\n+\n+    impl<'self> Eq for &'self str {\n+        #[inline(always)]\n+        fn eq(&self, other: & &'self str) -> bool {\n+            eq_slice((*self), (*other))\n+        }\n+        #[inline(always)]\n+        fn ne(&self, other: & &'self str) -> bool { !(*self).eq(other) }\n+    }\n+\n+    impl Eq for ~str {\n+        #[inline(always)]\n+        fn eq(&self, other: &~str) -> bool {\n+            eq_slice((*self), (*other))\n+        }\n+        #[inline(always)]\n+        fn ne(&self, other: &~str) -> bool { !(*self).eq(other) }\n+    }\n+\n+    impl Eq for @str {\n+        #[inline(always)]\n+        fn eq(&self, other: &@str) -> bool {\n+            eq_slice((*self), (*other))\n+        }\n+        #[inline(always)]\n+        fn ne(&self, other: &@str) -> bool { !(*self).eq(other) }\n+    }\n+\n+    impl<'self> TotalEq for &'self str {\n+        #[inline(always)]\n+        fn equals(&self, other: & &'self str) -> bool {\n+            eq_slice((*self), (*other))\n+        }\n+    }\n+\n+    impl TotalEq for ~str {\n+        #[inline(always)]\n+        fn equals(&self, other: &~str) -> bool {\n+            eq_slice((*self), (*other))\n+        }\n+    }\n+\n+    impl TotalEq for @str {\n+        #[inline(always)]\n+        fn equals(&self, other: &@str) -> bool {\n+            eq_slice((*self), (*other))\n+        }\n+    }\n+\n+    impl<'self> Ord for &'self str {\n+        #[inline(always)]\n+        fn lt(&self, other: & &'self str) -> bool { self.cmp(other) == Less }\n+        #[inline(always)]\n+        fn le(&self, other: & &'self str) -> bool { self.cmp(other) != Greater }\n+        #[inline(always)]\n+        fn ge(&self, other: & &'self str) -> bool { self.cmp(other) != Less }\n+        #[inline(always)]\n+        fn gt(&self, other: & &'self str) -> bool { self.cmp(other) == Greater }\n+    }\n+\n+    impl Ord for ~str {\n+        #[inline(always)]\n+        fn lt(&self, other: &~str) -> bool { self.cmp(other) == Less }\n+        #[inline(always)]\n+        fn le(&self, other: &~str) -> bool { self.cmp(other) != Greater }\n+        #[inline(always)]\n+        fn ge(&self, other: &~str) -> bool { self.cmp(other) != Less }\n+        #[inline(always)]\n+        fn gt(&self, other: &~str) -> bool { self.cmp(other) == Greater }\n+    }\n+\n+    impl Ord for @str {\n+        #[inline(always)]\n+        fn lt(&self, other: &@str) -> bool { self.cmp(other) == Less }\n+        #[inline(always)]\n+        fn le(&self, other: &@str) -> bool { self.cmp(other) != Greater }\n+        #[inline(always)]\n+        fn ge(&self, other: &@str) -> bool { self.cmp(other) != Less }\n+        #[inline(always)]\n+        fn gt(&self, other: &@str) -> bool { self.cmp(other) == Greater }\n+    }\n+\n+    impl<'self, S: Str> Equiv<S> for &'self str {\n+        #[inline(always)]\n+        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n+    }\n+\n+    impl<'self, S: Str> Equiv<S> for @str {\n+        #[inline(always)]\n+        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n+    }\n+\n+    impl<'self, S: Str> Equiv<S> for ~str {\n+        #[inline(always)]\n+        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n+    }\n }\n \n #[cfg(test)]\n@@ -1256,6 +1085,7 @@ pub trait StrSlice<'self> {\n     fn matches_index_iter(&self, sep: &'self str) -> StrMatchesIndexIterator<'self>;\n     fn split_str_iter(&self, &'self str) -> StrStrSplitIterator<'self>;\n     fn line_iter(&self) -> StrCharSplitIterator<'self, char>;\n+    fn any_line_iter(&self) -> AnyLineIterator<'self>;\n     fn word_iter(&self) -> WordIterator<'self>;\n     fn ends_with(&self, needle: &str) -> bool;\n     fn is_empty(&self) -> bool;\n@@ -1282,6 +1112,7 @@ pub trait StrSlice<'self> {\n     fn replace(&self, from: &str, to: &str) -> ~str;\n     fn to_owned(&self) -> ~str;\n     fn to_managed(&self) -> @str;\n+    fn to_utf16(&self) -> ~[u16];\n     fn is_char_boundary(&self, index: uint) -> bool;\n     fn char_range_at(&self, start: uint) -> CharRange;\n     fn char_at(&self, i: uint) -> char;\n@@ -1296,6 +1127,12 @@ pub trait StrSlice<'self> {\n     fn repeat(&self, nn: uint) -> ~str;\n \n     fn slice_shift_char(&self) -> (char, &'self str);\n+\n+    fn map_chars(&self, ff: &fn(char) -> char) -> ~str;\n+\n+    fn lev_distance(&self, t: &str) -> uint;\n+\n+    fn subslice_offset(&self, inner: &str) -> uint;\n }\n \n /// Extension methods for strings\n@@ -1437,6 +1274,17 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn line_iter(&self) -> StrCharSplitIterator<'self, char> {\n         self.split_options_iter('\\n', self.len(), false)\n     }\n+\n+    /// An iterator over the lines of a string, separated by either\n+    /// `\\n` or (`\\r\\n`).\n+    fn any_line_iter(&self) -> AnyLineIterator<'self> {\n+        do self.line_iter().transform |line| {\n+            let l = line.len();\n+            if l > 0 && line[l - 1] == '\\r' as u8 { line.slice(0, l - 1) }\n+            else { line }\n+        }\n+    }\n+\n     /// An iterator over the words of a string (subsequences separated\n     /// by any sequence of whitespace).\n     #[inline]\n@@ -1586,7 +1434,7 @@ impl<'self> StrSlice<'self> for &'self str {\n      *\n      * # Example\n      *\n-     * ~~~\n+     * ~~~ {.rust}\n      * assert_eq!(\"11foo1bar11\".trim_chars(&'1'), \"foo1bar\")\n      * assert_eq!(\"12foo1bar12\".trim_chars(& &['1', '2']), \"foo1bar\")\n      * assert_eq!(\"123foo1bar123\".trim_chars(&|c: char| c.is_digit()), \"foo1bar\")\n@@ -1605,7 +1453,7 @@ impl<'self> StrSlice<'self> for &'self str {\n      *\n      * # Example\n      *\n-     * ~~~\n+     * ~~~ {.rust}\n      * assert_eq!(\"11foo1bar11\".trim_left_chars(&'1'), \"foo1bar11\")\n      * assert_eq!(\"12foo1bar12\".trim_left_chars(& &['1', '2']), \"foo1bar12\")\n      * assert_eq!(\"123foo1bar123\".trim_left_chars(&|c: char| c.is_digit()), \"foo1bar123\")\n@@ -1627,7 +1475,7 @@ impl<'self> StrSlice<'self> for &'self str {\n      *\n      * # Example\n      *\n-     * ~~~\n+     * ~~~ {.rust}\n      * assert_eq!(\"11foo1bar11\".trim_right_chars(&'1'), \"11foo1bar\")\n      * assert_eq!(\"12foo1bar12\".trim_right_chars(& &['1', '2']), \"12foo1bar\")\n      * assert_eq!(\"123foo1bar123\".trim_right_chars(&|c: char| c.is_digit()), \"123foo1bar\")\n@@ -1679,6 +1527,30 @@ impl<'self> StrSlice<'self> for &'self str {\n         unsafe { ::cast::transmute(v) }\n     }\n \n+    /// Converts to a vector of `u16` encoded as UTF-16.\n+    fn to_utf16(&self) -> ~[u16] {\n+        let mut u = ~[];\n+        for self.iter().advance |ch| {\n+            // Arithmetic with u32 literals is easier on the eyes than chars.\n+            let mut ch = ch as u32;\n+\n+            if (ch & 0xFFFF_u32) == ch {\n+                // The BMP falls through (assuming non-surrogate, as it\n+                // should)\n+                assert!(ch <= 0xD7FF_u32 || ch >= 0xE000_u32);\n+                u.push(ch as u16)\n+            } else {\n+                // Supplementary planes break into surrogates.\n+                assert!(ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32);\n+                ch -= 0x1_0000_u32;\n+                let w1 = 0xD800_u16 | ((ch >> 10) as u16);\n+                let w2 = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n+                u.push_all([w1, w2])\n+            }\n+        }\n+        u\n+    }\n+\n     /**\n      * Returns false if the index points into the middle of a multi-byte\n      * character sequence.\n@@ -1921,6 +1793,85 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n \n+    /// Apply a function to each character.\n+    fn map_chars(&self, ff: &fn(char) -> char) -> ~str {\n+        let mut result = with_capacity(self.len());\n+        for self.iter().advance |cc| {\n+            result.push_char(ff(cc));\n+        }\n+        result\n+    }\n+\n+    /// Levenshtein Distance between two strings.\n+    fn lev_distance(&self, t: &str) -> uint {\n+        let slen = self.len();\n+        let tlen = t.len();\n+\n+        if slen == 0 { return tlen; }\n+        if tlen == 0 { return slen; }\n+\n+        let mut dcol = vec::from_fn(tlen + 1, |x| x);\n+\n+        for self.iter().enumerate().advance |(i, sc)| {\n+\n+            let mut current = i;\n+            dcol[0] = current + 1;\n+\n+            for t.iter().enumerate().advance |(j, tc)| {\n+\n+                let next = dcol[j + 1];\n+\n+                if sc == tc {\n+                    dcol[j + 1] = current;\n+                } else {\n+                    dcol[j + 1] = ::cmp::min(current, next);\n+                    dcol[j + 1] = ::cmp::min(dcol[j + 1], dcol[j]) + 1;\n+                }\n+\n+                current = next;\n+            }\n+        }\n+\n+        return dcol[tlen];\n+    }\n+\n+\n+    /**\n+     * Returns the byte offset of an inner slice relative to an enclosing outer slice.\n+     *\n+     * Fails if `inner` is not a direct slice contained within self.\n+     *\n+     * # Example\n+     *\n+     * ~~~ {.rust}\n+     * let string = \"a\\nb\\nc\";\n+     * let mut lines = ~[];\n+     * for string.line_iter().advance |line| { lines.push(line) }\n+     *\n+     * assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n+     * assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n+     * assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n+     * ~~~\n+     */\n+    #[inline(always)]\n+    fn subslice_offset(&self, inner: &str) -> uint {\n+        do as_buf(*self) |a, a_len| {\n+            do as_buf(inner) |b, b_len| {\n+                let a_start: uint;\n+                let a_end: uint;\n+                let b_start: uint;\n+                let b_end: uint;\n+                unsafe {\n+                    a_start = cast::transmute(a); a_end = a_len + cast::transmute(a);\n+                    b_start = cast::transmute(b); b_end = b_len + cast::transmute(b);\n+                }\n+                assert!(a_start <= b_start);\n+                assert!(b_end <= a_end);\n+                b_start - a_start\n+            }\n+        }\n+    }\n+\n }\n \n #[allow(missing_doc)]\n@@ -2280,10 +2231,10 @@ mod tests {\n \n     #[test]\n     fn test_le() {\n-        assert!((le(&\"\", &\"\")));\n-        assert!((le(&\"\", &\"foo\")));\n-        assert!((le(&\"foo\", &\"foo\")));\n-        assert!((!eq(&~\"foo\", &~\"bar\")));\n+        assert!(\"\" <= \"\");\n+        assert!(\"\" <= \"foo\");\n+        assert!(\"foo\" <= \"foo\");\n+        assert!(\"foo\" != ~\"bar\");\n     }\n \n     #[test]\n@@ -3003,23 +2954,23 @@ mod tests {\n         let a = \"kernelsprite\";\n         let b = a.slice(7, a.len());\n         let c = a.slice(0, a.len() - 6);\n-        assert_eq!(subslice_offset(a, b), 7);\n-        assert_eq!(subslice_offset(a, c), 0);\n+        assert_eq!(a.subslice_offset(b), 7);\n+        assert_eq!(a.subslice_offset(c), 0);\n \n         let string = \"a\\nb\\nc\";\n         let mut lines = ~[];\n         for string.line_iter().advance |line| { lines.push(line) }\n-        assert_eq!(subslice_offset(string, lines[0]), 0);\n-        assert_eq!(subslice_offset(string, lines[1]), 2);\n-        assert_eq!(subslice_offset(string, lines[2]), 4);\n+        assert_eq!(string.subslice_offset(lines[0]), 0);\n+        assert_eq!(string.subslice_offset(lines[1]), 2);\n+        assert_eq!(string.subslice_offset(lines[2]), 4);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_subslice_offset_2() {\n         let a = \"alchemiter\";\n         let b = \"cruxtruder\";\n-        subslice_offset(a, b);\n+        a.subslice_offset(b);\n     }\n \n     #[test]\n@@ -3069,8 +3020,8 @@ mod tests {\n \n     #[test]\n     fn test_map() {\n-        assert_eq!(~\"\", map(\"\", |c| unsafe {libc::toupper(c as c_char)} as char));\n-        assert_eq!(~\"YMCA\", map(\"ymca\", |c| unsafe {libc::toupper(c as c_char)} as char));\n+        assert_eq!(~\"\", \"\".map_chars(|c| unsafe {libc::toupper(c as c_char)} as char));\n+        assert_eq!(~\"YMCA\", \"ymca\".map_chars(|c| unsafe {libc::toupper(c as c_char)} as char));\n     }\n \n     #[test]\n@@ -3114,10 +3065,10 @@ mod tests {\n \n         for pairs.each |p| {\n             let (s, u) = copy *p;\n-            assert!(to_utf16(s) == u);\n+            assert!(s.to_utf16() == u);\n             assert!(from_utf16(u) == s);\n-            assert!(from_utf16(to_utf16(s)) == s);\n-            assert!(to_utf16(from_utf16(u)) == u);\n+            assert!(from_utf16(s.to_utf16()) == s);\n+            assert!(from_utf16(u).to_utf16() == u);\n         }\n     }\n \n@@ -3188,6 +3139,24 @@ mod tests {\n         assert_eq!(\"abc\".char_range_at_reverse(0).next, 0);\n     }\n \n+    #[test]\n+    fn test_add() {\n+        macro_rules! t (\n+            ($s1:expr, $s2:expr, $e:expr) => {\n+                assert_eq!($s1 + $s2, $e);\n+                assert_eq!($s1.to_owned() + $s2, $e);\n+                assert_eq!($s1.to_managed() + $s2, $e);\n+            }\n+        );\n+\n+        t!(\"foo\",  \"bar\", ~\"foobar\");\n+        t!(\"foo\", @\"bar\", ~\"foobar\");\n+        t!(\"foo\", ~\"bar\", ~\"foobar\");\n+        t!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\",  \"\u534eVi\u1ec7t Nam\", ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        t!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\", @\"\u534eVi\u1ec7t Nam\", ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        t!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"\u534eVi\u1ec7t Nam\", ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+    }\n+\n     #[test]\n     fn test_iterator() {\n         use iterator::*;"}, {"sha": "44e480dc7df2d1e3877f643216566b3169b695d2", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -39,8 +39,6 @@ pub mod rt {\n     use parse;\n     use print::pprust;\n \n-    use core::str;\n-\n     pub use ast::*;\n     pub use parse::token::*;\n     pub use parse::new_parser_from_tts;"}, {"sha": "c1bf979cd319bda56ee393db234d1abd87dd645c", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -969,7 +969,7 @@ mod test {\n     // change every identifier to \"zz\"\n     pub fn to_zz() -> @fn(ast::ident)->ast::ident {\n         let zz_id = token::str_to_ident(\"zz\");\n-        |id| {zz_id}\n+        |_id| {zz_id}\n     }\n \n     // maybe add to expand.rs..."}, {"sha": "40352f890f4faf6dff9ae4073e488e4758bf0a20", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=f74e1935aa55aff7ecf9ac75a5114a7b41d4e56f", "patch": "@@ -89,12 +89,11 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         }\n \n         return do lines.map |line| {\n-            let mut chars = ~[];\n-            for line.iter().advance |c| { chars.push(c) }\n+            let chars = line.iter().collect::<~[char]>();\n             if i > chars.len() {\n                 ~\"\"\n             } else {\n-                str::from_chars(chars.slice(i, chars.len()).to_owned())\n+                str::from_chars(chars.slice(i, chars.len()))\n             }\n         };\n     }\n@@ -103,14 +102,13 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         // FIXME #5475:\n         // return comment.slice(3u, comment.len()).trim().to_owned();\n         let r = comment.slice(3u, comment.len()); return r.trim().to_owned();\n-\n     }\n \n     if comment.starts_with(\"/*\") {\n-        let mut lines = ~[];\n-        for str::each_line_any(comment.slice(3u, comment.len() - 2u)) |line| {\n-            lines.push(line.to_owned())\n-        }\n+        let lines = comment.slice(3u, comment.len() - 2u)\n+            .any_line_iter()\n+            .transform(|s| s.to_owned())\n+            .collect::<~[~str]>();\n         let lines = vertical_trim(lines);\n         let lines = block_trim(lines, ~\"\\t \", None);\n         let lines = block_trim(lines, ~\"*\", Some(1u));"}]}