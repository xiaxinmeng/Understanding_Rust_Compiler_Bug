{"sha": "0bbac1275177176c6bb1a8640b5ef34dbb5c5074", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiYmFjMTI3NTE3NzE3NmM2YmIxYTg2NDBiNWVmMzRkYmI1YzUwNzQ=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "vastrauskas@gmail.com", "date": "2020-05-18T14:28:19Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "vastrauskas@gmail.com", "date": "2020-05-24T22:02:54Z"}, "message": "Change how the time is handled.", "tree": {"sha": "0a5d7c59f82aaf2b6da19c6ee383979ddb0e632c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a5d7c59f82aaf2b6da19c6ee383979ddb0e632c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bbac1275177176c6bb1a8640b5ef34dbb5c5074", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bbac1275177176c6bb1a8640b5ef34dbb5c5074", "html_url": "https://github.com/rust-lang/rust/commit/0bbac1275177176c6bb1a8640b5ef34dbb5c5074", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bbac1275177176c6bb1a8640b5ef34dbb5c5074/comments", "author": {"login": "vakaras", "id": 75347, "node_id": "MDQ6VXNlcjc1MzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/75347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vakaras", "html_url": "https://github.com/vakaras", "followers_url": "https://api.github.com/users/vakaras/followers", "following_url": "https://api.github.com/users/vakaras/following{/other_user}", "gists_url": "https://api.github.com/users/vakaras/gists{/gist_id}", "starred_url": "https://api.github.com/users/vakaras/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vakaras/subscriptions", "organizations_url": "https://api.github.com/users/vakaras/orgs", "repos_url": "https://api.github.com/users/vakaras/repos", "events_url": "https://api.github.com/users/vakaras/events{/privacy}", "received_events_url": "https://api.github.com/users/vakaras/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vakaras", "id": 75347, "node_id": "MDQ6VXNlcjc1MzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/75347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vakaras", "html_url": "https://github.com/vakaras", "followers_url": "https://api.github.com/users/vakaras/followers", "following_url": "https://api.github.com/users/vakaras/following{/other_user}", "gists_url": "https://api.github.com/users/vakaras/gists{/gist_id}", "starred_url": "https://api.github.com/users/vakaras/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vakaras/subscriptions", "organizations_url": "https://api.github.com/users/vakaras/orgs", "repos_url": "https://api.github.com/users/vakaras/repos", "events_url": "https://api.github.com/users/vakaras/events{/privacy}", "received_events_url": "https://api.github.com/users/vakaras/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86eb262e8a2d270cc8195185b217710f815761b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/86eb262e8a2d270cc8195185b217710f815761b3", "html_url": "https://github.com/rust-lang/rust/commit/86eb262e8a2d270cc8195185b217710f815761b3"}], "stats": {"total": 70, "additions": 36, "deletions": 34}, "files": [{"sha": "51aa7ae31047a5d5142e6c73411c78e79d1f1c18", "filename": "src/machine.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0bbac1275177176c6bb1a8640b5ef34dbb5c5074/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbac1275177176c6bb1a8640b5ef34dbb5c5074/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=0bbac1275177176c6bb1a8640b5ef34dbb5c5074", "patch": "@@ -5,7 +5,7 @@ use std::borrow::Cow;\n use std::cell::RefCell;\n use std::num::NonZeroU64;\n use std::rc::Rc;\n-use std::time::{Instant, SystemTime};\n+use std::time::Instant;\n use std::fmt;\n \n use log::trace;\n@@ -251,11 +251,6 @@ pub struct Evaluator<'mir, 'tcx> {\n     /// The \"time anchor\" for this machine's monotone clock (for `Instant` simulation).\n     pub(crate) time_anchor: Instant,\n \n-    /// The approximate system time when \"time anchor\" was created. This is used\n-    /// for converting system time to monotone time so that we can simplify the\n-    /// thread scheduler to deal only with a single representation of time.\n-    pub(crate) time_anchor_timestamp: SystemTime,\n-\n     /// The set of threads.\n     pub(crate) threads: ThreadManager<'mir, 'tcx>,\n \n@@ -286,7 +281,6 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             dir_handler: Default::default(),\n             panic_payload: None,\n             time_anchor: Instant::now(),\n-            time_anchor_timestamp: SystemTime::now(),\n             layouts,\n             threads: ThreadManager::default(),\n         }"}, {"sha": "5432c76dfe7192b5e878b685cfd08ab83d589bae", "filename": "src/shims/sync.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0bbac1275177176c6bb1a8640b5ef34dbb5c5074/src%2Fshims%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbac1275177176c6bb1a8640b5ef34dbb5c5074/src%2Fshims%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fsync.rs?ref=0bbac1275177176c6bb1a8640b5ef34dbb5c5074", "patch": "@@ -1,10 +1,11 @@\n-use std::time::{Duration, SystemTime};\n use std::convert::TryInto;\n+use std::time::{Duration, SystemTime};\n \n use rustc_middle::ty::{layout::TyAndLayout, TyKind, TypeAndMut};\n use rustc_target::abi::{LayoutOf, Size};\n \n use crate::stacked_borrows::Tag;\n+use crate::thread::Time;\n \n use crate::*;\n \n@@ -734,12 +735,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         };\n \n         let timeout_time = if clock_id == this.eval_libc_i32(\"CLOCK_REALTIME\")? {\n-            let time_anchor_since_epoch =\n-                this.machine.time_anchor_timestamp.duration_since(SystemTime::UNIX_EPOCH).unwrap();\n-            let duration_since_time_anchor = duration.checked_sub(time_anchor_since_epoch).unwrap();\n-            this.machine.time_anchor.checked_add(duration_since_time_anchor).unwrap()\n+            Time::RealTime(SystemTime::UNIX_EPOCH.checked_add(duration).unwrap())\n         } else if clock_id == this.eval_libc_i32(\"CLOCK_MONOTONIC\")? {\n-            this.machine.time_anchor.checked_add(duration).unwrap()\n+            Time::Monotonic(this.machine.time_anchor.checked_add(duration).unwrap())\n         } else {\n             throw_ub_format!(\"Unsupported clock id.\");\n         };"}, {"sha": "e05d111cb28395906006f279cd63641b1256d33f", "filename": "src/sync.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0bbac1275177176c6bb1a8640b5ef34dbb5c5074/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbac1275177176c6bb1a8640b5ef34dbb5c5074/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=0bbac1275177176c6bb1a8640b5ef34dbb5c5074", "patch": "@@ -1,7 +1,6 @@\n use std::collections::{hash_map::Entry, HashMap, VecDeque};\n use std::convert::TryFrom;\n use std::num::NonZeroU32;\n-use std::time::Instant;\n \n use rustc_index::vec::{Idx, IndexVec};\n \n@@ -76,8 +75,6 @@ struct CondvarWaiter {\n     thread: ThreadId,\n     /// The mutex on which the thread is waiting.\n     mutex: MutexId,\n-    /// The moment in time when the waiter should time out.\n-    timeout: Option<Instant>,\n }\n \n /// The conditional variable state.\n@@ -280,7 +277,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         let waiters = &mut this.machine.threads.sync.condvars[id].waiters;\n         assert!(waiters.iter().all(|waiter| waiter.thread != thread), \"thread is already waiting\");\n-        waiters.push_back(CondvarWaiter { thread, mutex, timeout: None });\n+        waiters.push_back(CondvarWaiter { thread, mutex });\n     }\n \n     /// Wake up some thread (if there is any) sleeping on the conditional"}, {"sha": "69b31b541ae5e2e24ec0a3bfd94b67d85e675314", "filename": "src/thread.rs", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0bbac1275177176c6bb1a8640b5ef34dbb5c5074/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbac1275177176c6bb1a8640b5ef34dbb5c5074/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=0bbac1275177176c6bb1a8640b5ef34dbb5c5074", "patch": "@@ -4,7 +4,7 @@ use std::cell::RefCell;\n use std::collections::hash_map::Entry;\n use std::convert::TryFrom;\n use std::num::TryFromIntError;\n-use std::time::Instant;\n+use std::time::{Duration, Instant, SystemTime};\n \n use log::trace;\n \n@@ -159,13 +159,30 @@ impl<'mir, 'tcx> Default for Thread<'mir, 'tcx> {\n     }\n }\n \n+#[derive(Debug)]\n+pub enum Time {\n+    Monotonic(Instant),\n+    RealTime(SystemTime),\n+}\n+\n+impl Time {\n+    /// How long do we have to wait from now until the specified time?\n+    fn get_wait_time(&self) -> Duration {\n+        match self {\n+            Time::Monotonic(instant) => instant.saturating_duration_since(Instant::now()),\n+            Time::RealTime(time) =>\n+                time.duration_since(SystemTime::now()).unwrap_or(Duration::new(0, 0)),\n+        }\n+    }\n+}\n+\n /// Callbacks are used to implement timeouts. For example, waiting on a\n /// conditional variable with a timeout creates a callback that is called after\n /// the specified time and unblocks the thread. If another thread signals on the\n /// conditional variable, the signal handler deletes the callback.\n struct TimeoutCallbackInfo<'mir, 'tcx> {\n     /// The callback should be called no earlier than this time.\n-    call_time: Instant,\n+    call_time: Time,\n     /// The called function.\n     callback: TimeoutCallback<'mir, 'tcx>,\n }\n@@ -362,11 +379,11 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     fn register_timeout_callback(\n         &mut self,\n         thread: ThreadId,\n-        call_time: Instant,\n+        call_time: Time,\n         callback: TimeoutCallback<'mir, 'tcx>,\n     ) {\n         self.timeout_callbacks\n-            .insert(thread, TimeoutCallbackInfo { call_time: call_time, callback: callback })\n+            .insert(thread, TimeoutCallbackInfo { call_time, callback })\n             .unwrap_none();\n     }\n \n@@ -376,13 +393,12 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Get a callback that is ready to be called.\n-    fn get_callback(&mut self) -> Option<(ThreadId, TimeoutCallback<'mir, 'tcx>)> {\n-        let current_time = Instant::now();\n+    fn get_ready_callback(&mut self) -> Option<(ThreadId, TimeoutCallback<'mir, 'tcx>)> {\n         // We use a for loop here to make the scheduler more deterministic.\n         for thread in self.threads.indices() {\n             match self.timeout_callbacks.entry(thread) {\n                 Entry::Occupied(entry) =>\n-                    if current_time >= entry.get().call_time {\n+                    if entry.get().call_time.get_wait_time() == Duration::new(0, 0) {\n                         return Some((thread, entry.remove().callback));\n                     },\n                 Entry::Vacant(_) => {}\n@@ -445,18 +461,14 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         }\n         // We have not found a thread to execute.\n         if self.threads.iter().all(|thread| thread.state == ThreadState::Terminated) {\n-            unreachable!();\n-        } else if let Some(next_call_time) =\n-            self.timeout_callbacks.values().min_by_key(|info| info.call_time)\n+            unreachable!(\"all threads terminated without the main thread terminating?!\");\n+        } else if let Some(sleep_time) =\n+            self.timeout_callbacks.values().map(|info| info.call_time.get_wait_time()).min()\n         {\n             // All threads are currently blocked, but we have unexecuted\n             // timeout_callbacks, which may unblock some of the threads. Hence,\n             // sleep until the first callback.\n-            if let Some(sleep_time) =\n-                next_call_time.call_time.checked_duration_since(Instant::now())\n-            {\n-                std::thread::sleep(sleep_time);\n-            }\n+            std::thread::sleep(sleep_time);\n             Ok(SchedulingAction::ExecuteTimeoutCallback)\n         } else {\n             throw_machine_stop!(TerminationInfo::Deadlock);\n@@ -650,7 +662,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn register_timeout_callback(\n         &mut self,\n         thread: ThreadId,\n-        call_time: Instant,\n+        call_time: Time,\n         callback: TimeoutCallback<'mir, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n@@ -669,7 +681,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[inline]\n     fn run_timeout_callback(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let (thread, callback) = this.machine.threads.get_callback().expect(\"no callback found\");\n+        let (thread, callback) =\n+            this.machine.threads.get_ready_callback().expect(\"no callback found\");\n         let old_thread = this.set_active_thread(thread)?;\n         callback(this)?;\n         this.set_active_thread(old_thread)?;"}]}