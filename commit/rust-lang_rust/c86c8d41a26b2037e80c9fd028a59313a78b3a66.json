{"sha": "c86c8d41a26b2037e80c9fd028a59313a78b3a66", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NmM4ZDQxYTI2YjIwMzdlODBjOWZkMDI4YTU5MzEzYTc4YjNhNjY=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-05T00:10:27Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-13T09:40:28Z"}, "message": "Perform node id assignment and `macros_at_scope` construction during\nthe `InvocationCollector` and `PlaceholderExpander` folds.", "tree": {"sha": "c3b7a4b63c6c276b1eff2d12eea73aa5af69e6a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3b7a4b63c6c276b1eff2d12eea73aa5af69e6a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c86c8d41a26b2037e80c9fd028a59313a78b3a66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c86c8d41a26b2037e80c9fd028a59313a78b3a66", "html_url": "https://github.com/rust-lang/rust/commit/c86c8d41a26b2037e80c9fd028a59313a78b3a66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c86c8d41a26b2037e80c9fd028a59313a78b3a66/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72a636975fc5d0bb4af45af7bdd97987cc722a6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/72a636975fc5d0bb4af45af7bdd97987cc722a6a", "html_url": "https://github.com/rust-lang/rust/commit/72a636975fc5d0bb4af45af7bdd97987cc722a6a"}], "stats": {"total": 187, "additions": 83, "deletions": 104}, "files": [{"sha": "007222b2edf6d2db032f2202d845bd0c84d1f058", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c86c8d41a26b2037e80c9fd028a59313a78b3a66/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86c8d41a26b2037e80c9fd028a59313a78b3a66/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c86c8d41a26b2037e80c9fd028a59313a78b3a66", "patch": "@@ -707,8 +707,6 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n                                                   &sess.features.borrow())\n     });\n \n-    let krate = time(sess.time_passes(), \"assigning node ids\", || resolver.assign_node_ids(krate));\n-\n     if sess.opts.debugging_opts.input_stats {\n         println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n     }"}, {"sha": "a9e3c6ffe9ed887d028208dab5d64fa7e49d70e3", "filename": "src/librustc_resolve/assign_ids.rs", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibrustc_resolve%2Fassign_ids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibrustc_resolve%2Fassign_ids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fassign_ids.rs?ref=72a636975fc5d0bb4af45af7bdd97987cc722a6a", "patch": "@@ -1,92 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use Resolver;\n-use rustc::session::Session;\n-use rustc::util::nodemap::FnvHashMap;\n-use syntax::ast;\n-use syntax::ext::hygiene::Mark;\n-use syntax::fold::{self, Folder};\n-use syntax::ptr::P;\n-use syntax::util::move_map::MoveMap;\n-use syntax::util::small_vector::SmallVector;\n-\n-use std::mem;\n-\n-impl<'a> Resolver<'a> {\n-    pub fn assign_node_ids(&mut self, krate: ast::Crate) -> ast::Crate {\n-        NodeIdAssigner {\n-            sess: self.session,\n-            macros_at_scope: &mut self.macros_at_scope,\n-        }.fold_crate(krate)\n-    }\n-}\n-\n-struct NodeIdAssigner<'a> {\n-    sess: &'a Session,\n-    macros_at_scope: &'a mut FnvHashMap<ast::NodeId, Vec<Mark>>,\n-}\n-\n-impl<'a> Folder for NodeIdAssigner<'a> {\n-    fn new_id(&mut self, old_id: ast::NodeId) -> ast::NodeId {\n-        assert_eq!(old_id, ast::DUMMY_NODE_ID);\n-        self.sess.next_node_id()\n-    }\n-\n-    fn fold_block(&mut self, block: P<ast::Block>) -> P<ast::Block> {\n-        block.map(|mut block| {\n-            block.id = self.new_id(block.id);\n-\n-            let stmt = block.stmts.pop();\n-            let mut macros = Vec::new();\n-            block.stmts = block.stmts.move_flat_map(|stmt| {\n-                if let ast::StmtKind::Item(ref item) = stmt.node {\n-                    if let ast::ItemKind::Mac(..) = item.node {\n-                        macros.push(item.ident.ctxt.data().outer_mark);\n-                        return None;\n-                    }\n-                }\n-\n-                let stmt = self.fold_stmt(stmt).pop().unwrap();\n-                if !macros.is_empty() {\n-                    self.macros_at_scope.insert(stmt.id, mem::replace(&mut macros, Vec::new()));\n-                }\n-                Some(stmt)\n-            });\n-\n-            stmt.and_then(|mut stmt| {\n-                // Avoid wasting a node id on a trailing expression statement,\n-                // which shares a HIR node with the expression itself.\n-                if let ast::StmtKind::Expr(expr) = stmt.node {\n-                    let expr = self.fold_expr(expr);\n-                    stmt.id = expr.id;\n-                    stmt.node = ast::StmtKind::Expr(expr);\n-                    Some(stmt)\n-                } else {\n-                    self.fold_stmt(stmt).pop()\n-                }\n-            }).map(|stmt| {\n-                if !macros.is_empty() {\n-                    self.macros_at_scope.insert(stmt.id, mem::replace(&mut macros, Vec::new()));\n-                }\n-                block.stmts.push(stmt);\n-            });\n-\n-            block\n-        })\n-    }\n-\n-    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n-        match item.node {\n-            ast::ItemKind::Mac(..) => SmallVector::zero(),\n-            _ => fold::noop_fold_item(item, self),\n-        }\n-    }\n-}"}, {"sha": "ad0507c9fb7e18b9bed2008540596f602e94d488", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c86c8d41a26b2037e80c9fd028a59313a78b3a66/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86c8d41a26b2037e80c9fd028a59313a78b3a66/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c86c8d41a26b2037e80c9fd028a59313a78b3a66", "patch": "@@ -84,7 +84,6 @@ mod macros;\n mod check_unused;\n mod build_reduced_graph;\n mod resolve_imports;\n-mod assign_ids;\n \n enum SuggestionType {\n     Macro(String),"}, {"sha": "67ee4c307d3c33a493182ad1577a907264e2fcd0", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c86c8d41a26b2037e80c9fd028a59313a78b3a66/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86c8d41a26b2037e80c9fd028a59313a78b3a66/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=c86c8d41a26b2037e80c9fd028a59313a78b3a66", "patch": "@@ -41,6 +41,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n         self.macro_loader.load_crate(extern_crate, allows_macros)\n     }\n \n+    fn next_node_id(&mut self) -> ast::NodeId {\n+        self.session.next_node_id()\n+    }\n+\n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion) {\n         expansion.visit_with(&mut ExpansionVisitor {\n             current_module: self.expansion_data[mark.as_u32() as usize].module.clone(),"}, {"sha": "1e8f8ef9ddd6c13fa2aaee331629f42c459e28a6", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c86c8d41a26b2037e80c9fd028a59313a78b3a66/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86c8d41a26b2037e80c9fd028a59313a78b3a66/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c86c8d41a26b2037e80c9fd028a59313a78b3a66", "patch": "@@ -464,6 +464,7 @@ pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n \n pub trait Resolver {\n     fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro>;\n+    fn next_node_id(&mut self) -> ast::NodeId;\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion);\n     fn add_macro(&mut self, scope: Mark, ident: ast::Ident, ext: Rc<SyntaxExtension>);\n@@ -479,10 +480,12 @@ pub enum LoadedMacro {\n }\n \n pub struct DummyResolver;\n+\n impl Resolver for DummyResolver {\n     fn load_crate(&mut self, _extern_crate: &ast::Item, _allows_macros: bool) -> Vec<LoadedMacro> {\n         Vec::new()\n     }\n+    fn next_node_id(&mut self) -> ast::NodeId { ast::DUMMY_NODE_ID }\n \n     fn visit_expansion(&mut self, _invoc: Mark, _expansion: &Expansion) {}\n     fn add_macro(&mut self, _scope: Mark, _ident: ast::Ident, _ext: Rc<SyntaxExtension>) {}"}, {"sha": "eef38ea28e0f48aa4b4914d6a9286b76215ccc81", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c86c8d41a26b2037e80c9fd028a59313a78b3a66/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86c8d41a26b2037e80c9fd028a59313a78b3a66/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c86c8d41a26b2037e80c9fd028a59313a78b3a66", "patch": "@@ -195,6 +195,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         krate.module.items = self.expand(items).make_items().into();\n         krate.exported_macros = mem::replace(&mut self.cx.exported_macros, Vec::new());\n \n+        for def in &mut krate.exported_macros {\n+            def.id = self.cx.resolver.next_node_id()\n+        }\n+\n         if self.cx.parse_sess.span_diagnostic.err_count() > err_count {\n             self.cx.parse_sess.span_diagnostic.abort_if_errors();\n         }\n@@ -234,7 +238,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         self.cx.current_expansion = orig_expansion_data;\n \n-        let mut placeholder_expander = PlaceholderExpander::new();\n+        let mut placeholder_expander = PlaceholderExpander::new(self.cx);\n         while let Some(expansions) = expansions.pop() {\n             for (mark, expansion) in expansions.into_iter().rev() {\n                 let expansion = expansion.fold_with(&mut placeholder_expander);\n@@ -530,9 +534,14 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n             None => return SmallVector::zero(),\n         };\n \n-        let (mac, style, attrs) = match stmt.node {\n-            StmtKind::Mac(mac) => mac.unwrap(),\n-            _ => return noop_fold_stmt(stmt, self),\n+        let (mac, style, attrs) = if let StmtKind::Mac(mac) = stmt.node {\n+            mac.unwrap()\n+        } else {\n+            // The placeholder expander gives ids to statements, so we avoid folding the id here.\n+            let ast::Stmt { id, node, span } = stmt;\n+            return noop_fold_stmt_kind(node, self).into_iter().map(|node| {\n+                ast::Stmt { id: id, node: node, span: span }\n+            }).collect()\n         };\n \n         let mut placeholder =\n@@ -624,7 +633,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                         }\n                     }\n                 }\n-                SmallVector::one(item)\n+                noop_fold_item(item, self)\n             },\n             _ => noop_fold_item(item, self),\n         }\n@@ -687,6 +696,11 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n         noop_fold_item_kind(self.cfg.configure_item_kind(item), self)\n     }\n+\n+    fn new_id(&mut self, id: ast::NodeId) -> ast::NodeId {\n+        assert_eq!(id, ast::DUMMY_NODE_ID);\n+        self.cx.resolver.next_node_id()\n+    }\n }\n \n pub struct ExpansionConfig<'feat> {"}, {"sha": "7635705daa05299e1fb062193f9fe473d5c0f701", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 57, "deletions": 4, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c86c8d41a26b2037e80c9fd028a59313a78b3a66/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86c8d41a26b2037e80c9fd028a59313a78b3a66/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=c86c8d41a26b2037e80c9fd028a59313a78b3a66", "patch": "@@ -10,13 +10,16 @@\n \n use ast;\n use codemap::{DUMMY_SP, dummy_spanned};\n+use ext::base::ExtCtxt;\n use ext::expand::{Expansion, ExpansionKind};\n use fold::*;\n use parse::token::keywords;\n use ptr::P;\n+use util::move_map::MoveMap;\n use util::small_vector::SmallVector;\n \n use std::collections::HashMap;\n+use std::mem;\n \n pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion {\n     fn mac_placeholder() -> ast::Mac {\n@@ -69,13 +72,15 @@ pub fn macro_scope_placeholder() -> Expansion {\n     placeholder(ExpansionKind::Items, ast::DUMMY_NODE_ID)\n }\n \n-pub struct PlaceholderExpander {\n+pub struct PlaceholderExpander<'a, 'b: 'a> {\n     expansions: HashMap<ast::NodeId, Expansion>,\n+    cx: &'a mut ExtCtxt<'b>,\n }\n \n-impl PlaceholderExpander {\n-    pub fn new() -> Self {\n+impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n+    pub fn new(cx: &'a mut ExtCtxt<'b>) -> Self {\n         PlaceholderExpander {\n+            cx: cx,\n             expansions: HashMap::new(),\n         }\n     }\n@@ -89,7 +94,7 @@ impl PlaceholderExpander {\n     }\n }\n \n-impl Folder for PlaceholderExpander {\n+impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n         match item.node {\n             // Scope placeholder\n@@ -155,6 +160,54 @@ impl Folder for PlaceholderExpander {\n             _ => noop_fold_ty(ty, self),\n         }\n     }\n+\n+    fn fold_block(&mut self, block: P<ast::Block>) -> P<ast::Block> {\n+        noop_fold_block(block, self).map(|mut block| {\n+            let mut macros = Vec::new();\n+            let mut remaining_stmts = block.stmts.len();\n+\n+            block.stmts = block.stmts.move_flat_map(|mut stmt| {\n+                remaining_stmts -= 1;\n+\n+                // Scope placeholder\n+                if let ast::StmtKind::Item(ref item) = stmt.node {\n+                    if let ast::ItemKind::Mac(..) = item.node {\n+                        macros.push(item.ident.ctxt.data().outer_mark);\n+                        return None;\n+                    }\n+                }\n+\n+                match stmt.node {\n+                    // Avoid wasting a node id on a trailing expression statement,\n+                    // which shares a HIR node with the expression itself.\n+                    ast::StmtKind::Expr(ref expr) if remaining_stmts == 0 => stmt.id = expr.id,\n+\n+                    _ => {\n+                        assert_eq!(stmt.id, ast::DUMMY_NODE_ID);\n+                        stmt.id = self.cx.resolver.next_node_id();\n+                    }\n+                }\n+\n+                if !macros.is_empty() {\n+                    let macros = mem::replace(&mut macros, Vec::new());\n+                    self.cx.resolver.add_expansions_at_stmt(stmt.id, macros);\n+                }\n+\n+                Some(stmt)\n+            });\n+\n+            block\n+        })\n+    }\n+\n+    fn fold_mod(&mut self, module: ast::Mod) -> ast::Mod {\n+        let mut module = noop_fold_mod(module, self);\n+        module.items = module.items.move_flat_map(|item| match item.node {\n+            ast::ItemKind::Mac(_) => None, // remove scope placeholders from modules\n+            _ => Some(item),\n+        });\n+        module\n+    }\n }\n \n pub fn reconstructed_macro_rules(def: &ast::MacroDef, path: &ast::Path) -> Expansion {"}]}