{"sha": "c1d48a85082cfe3683ad9eda5223d3259d4fa718", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxZDQ4YTg1MDgyY2ZlMzY4M2FkOWVkYTUyMjNkMzI1OWQ0ZmE3MTg=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-12T21:59:18Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-12T22:59:37Z"}, "message": "cleanup: `&foo[0..a]` -> `&foo[..a]`", "tree": {"sha": "ac65328b877bd7a2127dbd4d0edaf7b637f0878e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac65328b877bd7a2127dbd4d0edaf7b637f0878e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1d48a85082cfe3683ad9eda5223d3259d4fa718", "comment_count": 8, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1d48a85082cfe3683ad9eda5223d3259d4fa718", "html_url": "https://github.com/rust-lang/rust/commit/c1d48a85082cfe3683ad9eda5223d3259d4fa718", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1d48a85082cfe3683ad9eda5223d3259d4fa718/comments", "author": null, "committer": null, "parents": [{"sha": "3a44a19af29585c02e81e22ea7665f829ae0590a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a44a19af29585c02e81e22ea7665f829ae0590a", "html_url": "https://github.com/rust-lang/rust/commit/3a44a19af29585c02e81e22ea7665f829ae0590a"}], "stats": {"total": 209, "additions": 104, "deletions": 105}, "files": [{"sha": "4812ecc2c0b754b7a3a83b58dd1f43446271b495", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -1631,7 +1631,7 @@ mod tests {\n     #[test]\n     fn test_slice_from() {\n         let vec: &[int] = &[1, 2, 3, 4];\n-        assert_eq!(&vec[0..], vec);\n+        assert_eq!(&vec[], vec);\n         let b: &[int] = &[3, 4];\n         assert_eq!(&vec[2..], b);\n         let b: &[int] = &[];\n@@ -1641,11 +1641,11 @@ mod tests {\n     #[test]\n     fn test_slice_to() {\n         let vec: &[int] = &[1, 2, 3, 4];\n-        assert_eq!(&vec[0..4], vec);\n+        assert_eq!(&vec[..4], vec);\n         let b: &[int] = &[1, 2];\n-        assert_eq!(&vec[0..2], b);\n+        assert_eq!(&vec[..2], b);\n         let b: &[int] = &[];\n-        assert_eq!(&vec[0..0], b);\n+        assert_eq!(&vec[..0], b);\n     }\n \n \n@@ -2538,15 +2538,15 @@ mod tests {\n             let (left, right) = values.split_at_mut(2);\n             {\n                 let left: &[_] = left;\n-                assert!(left[0..left.len()] == [1, 2][]);\n+                assert!(left[..left.len()] == [1, 2][]);\n             }\n             for p in left.iter_mut() {\n                 *p += 1;\n             }\n \n             {\n                 let right: &[_] = right;\n-                assert!(right[0..right.len()] == [3, 4, 5][]);\n+                assert!(right[..right.len()] == [3, 4, 5][]);\n             }\n             for p in right.iter_mut() {\n                 *p += 2;"}, {"sha": "96c73981e36961f36b27c41539c30f8fe4fcdfa4", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -807,7 +807,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// out of bounds.\n     ///\n     /// See also `slice`, `slice_from` and `slice_chars`.\n-    #[unstable = \"use slice notation [0..a] instead\"]\n+    #[unstable = \"use slice notation [..a] instead\"]\n     fn slice_to(&self, end: uint) -> &str {\n         core_str::StrExt::slice_to(&self[], end)\n     }"}, {"sha": "c845d86ca0fe78dc043a8131b3da0d13b1bbfa09", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -168,7 +168,7 @@ impl String {\n \n         if i > 0 {\n             unsafe {\n-                res.as_mut_vec().push_all(&v[0..i])\n+                res.as_mut_vec().push_all(&v[..i])\n             };\n         }\n "}, {"sha": "f1b9ebe6d905d13e6271094fe4bd61126aaff854", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -332,5 +332,5 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n         }\n     }\n \n-    f(unsafe { str::from_utf8_unchecked(&buf[0..end]) })\n+    f(unsafe { str::from_utf8_unchecked(&buf[..end]) })\n }"}, {"sha": "20ac3e28c973ecb65f439556f9a491462fdb14c6", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -449,7 +449,7 @@ impl<'a> Formatter<'a> {\n             for c in sign.into_iter() {\n                 let mut b = [0; 4];\n                 let n = c.encode_utf8(&mut b).unwrap_or(0);\n-                let b = unsafe { str::from_utf8_unchecked(&b[0..n]) };\n+                let b = unsafe { str::from_utf8_unchecked(&b[..n]) };\n                 try!(f.buf.write_str(b));\n             }\n             if prefixed { f.buf.write_str(prefix) }\n@@ -692,7 +692,7 @@ impl String for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         let mut utf8 = [0u8; 4];\n         let amt = self.encode_utf8(&mut utf8).unwrap_or(0);\n-        let s: &str = unsafe { mem::transmute(&utf8[0..amt]) };\n+        let s: &str = unsafe { mem::transmute(&utf8[..amt]) };\n         String::fmt(s, f)\n     }\n }"}, {"sha": "22da168911daad66f84a6bc6a731408cfbae17c0", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -159,7 +159,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn split_at(&self, mid: uint) -> (&[T], &[T]) {\n-        (&self[0..mid], &self[mid..])\n+        (&self[..mid], &self[mid..])\n     }\n \n     #[inline]\n@@ -240,7 +240,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn init(&self) -> &[T] {\n-        &self[0..(self.len() - 1)]\n+        &self[..(self.len() - 1)]\n     }\n \n     #[inline]\n@@ -443,7 +443,7 @@ impl<T> SliceExt for [T] {\n     #[inline]\n     fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq {\n         let n = needle.len();\n-        self.len() >= n && needle == &self[0..n]\n+        self.len() >= n && needle == &self[..n]\n     }\n \n     #[inline]\n@@ -972,7 +972,7 @@ impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n         match self.v.iter().position(|x| (self.pred)(x)) {\n             None => self.finish(),\n             Some(idx) => {\n-                let ret = Some(&self.v[0..idx]);\n+                let ret = Some(&self.v[..idx]);\n                 self.v = &self.v[(idx + 1)..];\n                 ret\n             }\n@@ -999,7 +999,7 @@ impl<'a, T, P> DoubleEndedIterator for Split<'a, T, P> where P: FnMut(&T) -> boo\n             None => self.finish(),\n             Some(idx) => {\n                 let ret = Some(&self.v[(idx + 1)..]);\n-                self.v = &self.v[0..idx];\n+                self.v = &self.v[..idx];\n                 ret\n             }\n         }\n@@ -1195,7 +1195,7 @@ impl<'a, T> Iterator for Windows<'a, T> {\n         if self.size > self.v.len() {\n             None\n         } else {\n-            let ret = Some(&self.v[0..self.size]);\n+            let ret = Some(&self.v[..self.size]);\n             self.v = &self.v[1..];\n             ret\n         }"}, {"sha": "d9cf6dc086d9972099544924198cdf313333f096", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -701,10 +701,10 @@ impl TwoWaySearcher {\n         //\n         // What's going on is we have some critical factorization (u, v) of the\n         // needle, and we want to determine whether u is a suffix of\n-        // &v[0..period]. If it is, we use \"Algorithm CP1\". Otherwise we use\n+        // &v[..period]. If it is, we use \"Algorithm CP1\". Otherwise we use\n         // \"Algorithm CP2\", which is optimized for when the period of the needle\n         // is large.\n-        if &needle[0..crit_pos] == &needle[period.. period + crit_pos] {\n+        if &needle[..crit_pos] == &needle[period.. period + crit_pos] {\n             TwoWaySearcher {\n                 crit_pos: crit_pos,\n                 period: period,\n@@ -1412,7 +1412,7 @@ impl StrExt for str {\n     #[inline]\n     fn starts_with(&self, needle: &str) -> bool {\n         let n = needle.len();\n-        self.len() >= n && needle.as_bytes() == &self.as_bytes()[0..n]\n+        self.len() >= n && needle.as_bytes() == &self.as_bytes()[..n]\n     }\n \n     #[inline]"}, {"sha": "2e29b1c41c418f1fb098735d3df6ee353e942d3a", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -167,7 +167,7 @@ fn test_encode_utf8() {\n     fn check(input: char, expect: &[u8]) {\n         let mut buf = [0u8; 4];\n         let n = input.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n-        assert_eq!(&buf[0..n], expect);\n+        assert_eq!(&buf[..n], expect);\n     }\n \n     check('x', &[0x78]);\n@@ -181,7 +181,7 @@ fn test_encode_utf16() {\n     fn check(input: char, expect: &[u16]) {\n         let mut buf = [0u16; 2];\n         let n = input.encode_utf16(buf.as_mut_slice()).unwrap_or(0);\n-        assert_eq!(&buf[0..n], expect);\n+        assert_eq!(&buf[..n], expect);\n     }\n \n     check('x', &[0x0078]);"}, {"sha": "26819bf92098631a86ba05c2940d201fe1a6e996", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -288,39 +288,39 @@ fn test_iterator_len() {\n     let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     assert_eq!(v[..4].iter().count(), 4);\n     assert_eq!(v[..10].iter().count(), 10);\n-    assert_eq!(v[0..0].iter().count(), 0);\n+    assert_eq!(v[..0].iter().count(), 0);\n }\n \n #[test]\n fn test_iterator_sum() {\n     let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     assert_eq!(v[..4].iter().map(|&x| x).sum(), 6);\n     assert_eq!(v.iter().map(|&x| x).sum(), 55);\n-    assert_eq!(v[0..0].iter().map(|&x| x).sum(), 0);\n+    assert_eq!(v[..0].iter().map(|&x| x).sum(), 0);\n }\n \n #[test]\n fn test_iterator_product() {\n     let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().map(|&x| x).product(), 0);\n+    assert_eq!(v[..4].iter().map(|&x| x).product(), 0);\n     assert_eq!(v[1..5].iter().map(|&x| x).product(), 24);\n-    assert_eq!(v[0..0].iter().map(|&x| x).product(), 1);\n+    assert_eq!(v[..0].iter().map(|&x| x).product(), 1);\n }\n \n #[test]\n fn test_iterator_max() {\n     let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().map(|&x| x).max(), Some(3));\n+    assert_eq!(v[..4].iter().map(|&x| x).max(), Some(3));\n     assert_eq!(v.iter().map(|&x| x).max(), Some(10));\n-    assert_eq!(v[0..0].iter().map(|&x| x).max(), None);\n+    assert_eq!(v[..0].iter().map(|&x| x).max(), None);\n }\n \n #[test]\n fn test_iterator_min() {\n     let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().map(|&x| x).min(), Some(0));\n+    assert_eq!(v[..4].iter().map(|&x| x).min(), Some(0));\n     assert_eq!(v.iter().map(|&x| x).min(), Some(0));\n-    assert_eq!(v[0..0].iter().map(|&x| x).min(), None);\n+    assert_eq!(v[..0].iter().map(|&x| x).min(), None);\n }\n \n #[test]\n@@ -373,7 +373,7 @@ fn test_all() {\n     assert!(v.iter().all(|&x| x < 10));\n     assert!(!v.iter().all(|&x| x % 2 == 0));\n     assert!(!v.iter().all(|&x| x > 100));\n-    assert!(v[0..0].iter().all(|_| panic!()));\n+    assert!(v[..0].iter().all(|_| panic!()));\n }\n \n #[test]\n@@ -382,7 +382,7 @@ fn test_any() {\n     assert!(v.iter().any(|&x| x < 10));\n     assert!(v.iter().any(|&x| x % 2 == 0));\n     assert!(!v.iter().any(|&x| x > 100));\n-    assert!(!v[0..0].iter().any(|_| panic!()));\n+    assert!(!v[..0].iter().any(|_| panic!()));\n }\n \n #[test]"}, {"sha": "85944ccc5517c1c855152e0e10c12c0c2eb641b6", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -286,7 +286,7 @@ impl<'a> Parser<'a> {\n             flags: 0,\n             precision: CountImplied,\n             width: CountImplied,\n-            ty: &self.input[0..0],\n+            ty: &self.input[..0],\n         };\n         if !self.consume(':') { return spec }\n \n@@ -395,7 +395,7 @@ impl<'a> Parser<'a> {\n                 self.cur.next();\n                 pos\n             }\n-            Some(..) | None => { return &self.input[0..0]; }\n+            Some(..) | None => { return &self.input[..0]; }\n         };\n         let mut end;\n         loop {"}, {"sha": "8430ee81c321462a6ee025850b8ce739a0b8bcff", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -270,8 +270,7 @@ pub trait Rng : Sized {\n     /// let choices = [1i, 2, 4, 8, 16, 32];\n     /// let mut rng = thread_rng();\n     /// println!(\"{:?}\", rng.choose(&choices));\n-    /// # // uncomment when slicing syntax is stable\n-    /// //assert_eq!(rng.choose(&choices[0..0]), None);\n+    /// assert_eq!(rng.choose(&choices[..0]), None);\n     /// ```\n     fn choose<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {\n         if values.is_empty() {"}, {"sha": "f39860c8695c96c8c629513fe4138b19f219e656", "filename": "src/librbml/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -95,7 +95,7 @@ impl Writer for SeekableMemWriter {\n             // there (left), and what will be appended on the end (right)\n             let cap = self.buf.len() - self.pos;\n             let (left, right) = if cap <= buf.len() {\n-                (&buf[0..cap], &buf[cap..])\n+                (&buf[..cap], &buf[cap..])\n             } else {\n                 let result: (_, &[_]) = (buf, &[]);\n                 result"}, {"sha": "a1a90395b3b783306c08c7a9f488348694a53a58", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -926,7 +926,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n     };\n     head.map(|mut head| {\n-        head.push_all(&r[0..col]);\n+        head.push_all(&r[..col]);\n         head.push_all(&r[(col + 1)..]);\n         head\n     })"}, {"sha": "1a1ad899d4e82bd281b1f53fe8801ce007ff9399", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -542,7 +542,7 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n         0\n     };\n \n-    for t in tps[0..(tps.len() - num_defaults)].iter() {\n+    for t in tps[..(tps.len() - num_defaults)].iter() {\n         strs.push(ty_to_string(cx, *t))\n     }\n "}, {"sha": "e376ac50dcdf5ebd1055e6892a1409d1d257bdaf", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -140,7 +140,7 @@ impl FixedBuffer for FixedBuffer64 {\n             if input.len() >= buffer_remaining {\n                     copy_memory(\n                         self.buffer.slice_mut(self.buffer_idx, size),\n-                        &input[0..buffer_remaining]);\n+                        &input[..buffer_remaining]);\n                 self.buffer_idx = 0;\n                 func(&self.buffer);\n                 i += buffer_remaining;\n@@ -188,7 +188,7 @@ impl FixedBuffer for FixedBuffer64 {\n     fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n         assert!(self.buffer_idx == 64);\n         self.buffer_idx = 0;\n-        return &self.buffer[0..64];\n+        return &self.buffer[..64];\n     }\n \n     fn position(&self) -> uint { self.buffer_idx }"}, {"sha": "ae55f8fb3aa610ee08fbb45149bf7c5852df7c38", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -2081,7 +2081,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                             // idx +- 1 to account for the\n                                             // colons on either side\n                                             &mpath[(idx + 1)..],\n-                                            &mpath[0..(idx - 1)]);\n+                                            &mpath[..(idx - 1)]);\n                         return Failed(Some((span, msg)));\n                     },\n                     None => {"}, {"sha": "d7148bdaa1fe8a56a0629b26443fa78b77bab30c", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -186,7 +186,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n fn is_versioned_bytecode_format(bc: &[u8]) -> bool {\n     let magic_id_byte_count = link::RLIB_BYTECODE_OBJECT_MAGIC.len();\n     return bc.len() > magic_id_byte_count &&\n-           &bc[0..magic_id_byte_count] == link::RLIB_BYTECODE_OBJECT_MAGIC;\n+           &bc[..magic_id_byte_count] == link::RLIB_BYTECODE_OBJECT_MAGIC;\n }\n \n fn extract_bytecode_format_version(bc: &[u8]) -> u32 {"}, {"sha": "815a6fe846da6c6b5cc027f4d8da33a5156d0cba", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -186,7 +186,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         if len <= 2 {\n             return;\n         }\n-        let sub_paths = &sub_paths[0..(len-2)];\n+        let sub_paths = &sub_paths[..(len-2)];\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,"}, {"sha": "11f8fbbaf11bfb50168268a38fc3c3f4c98d7b92", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -166,7 +166,7 @@ impl<'a> FmtStrs<'a> {\n         let values = values.iter().map(|s| {\n             // Never take more than 1020 chars\n             if s.len() > 1020 {\n-                &s[0..1020]\n+                &s[..1020]\n             } else {\n                 &s[]\n             }"}, {"sha": "f182045efd23b4bf0ea8a1c1f332298960f7111c", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -471,7 +471,7 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Collect all of the matches that can match against anything.\n     enter_match(bcx, dm, m, col, val, |pats| {\n         if pat_is_binding_or_wild(dm, &*pats[col]) {\n-            let mut r = pats[0..col].to_vec();\n+            let mut r = pats[..col].to_vec();\n             r.push_all(&pats[(col + 1)..]);\n             Some(r)\n         } else {"}, {"sha": "75194e3d21fcb57ac29602db0ed39d9e803159b3", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -552,7 +552,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             for (small_vec_e, &ix) in small_vec.iter_mut().zip(ixs.iter()) {\n                 *small_vec_e = C_i32(self.ccx, ix as i32);\n             }\n-            self.inbounds_gep(base, &small_vec[0..ixs.len()])\n+            self.inbounds_gep(base, &small_vec[..ixs.len()])\n         } else {\n             let v = ixs.iter().map(|i| C_i32(self.ccx, *i as i32)).collect::<Vec<ValueRef>>();\n             self.count_insn(\"gepi\");"}, {"sha": "f2fb0863b5aa0686789b685f72e2ea1323ad3b2e", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -962,7 +962,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let variable_access = IndirectVariable {\n         alloca: env_pointer,\n-        address_operations: &address_operations[0..address_op_count]\n+        address_operations: &address_operations[..address_op_count]\n     };\n \n     declare_local(bcx,"}, {"sha": "bfa354480284ba81daf17217ff911367e085dcbd", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -332,7 +332,7 @@ fn path<F, G>(w: &mut fmt::Formatter,\n         match rel_root {\n             Some(root) => {\n                 let mut root = String::from_str(root.as_slice());\n-                for seg in path.segments[0..amt].iter() {\n+                for seg in path.segments[..amt].iter() {\n                     if \"super\" == seg.name ||\n                             \"self\" == seg.name {\n                         try!(write!(w, \"{}::\", seg.name));\n@@ -347,7 +347,7 @@ fn path<F, G>(w: &mut fmt::Formatter,\n                 }\n             }\n             None => {\n-                for seg in path.segments[0..amt].iter() {\n+                for seg in path.segments[..amt].iter() {\n                     try!(write!(w, \"{}::\", seg.name));\n                 }\n             }"}, {"sha": "41499b5ae0efed34bafe3b29191c5db904c957f0", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -401,7 +401,7 @@ fn escape_str(wr: &mut fmt::Writer, v: &str) -> fmt::Result {\n fn escape_char(writer: &mut fmt::Writer, v: char) -> fmt::Result {\n     let mut buf = [0; 4];\n     let n = v.encode_utf8(&mut buf).unwrap();\n-    let buf = unsafe { str::from_utf8_unchecked(&buf[0..n]) };\n+    let buf = unsafe { str::from_utf8_unchecked(&buf[..n]) };\n     escape_str(writer, buf)\n }\n \n@@ -414,7 +414,7 @@ fn spaces(wr: &mut fmt::Writer, mut n: uint) -> fmt::Result {\n     }\n \n     if n > 0 {\n-        wr.write_str(&BUF[0..n])\n+        wr.write_str(&BUF[..n])\n     } else {\n         Ok(())\n     }"}, {"sha": "60e2641ed8c37f0dab7ff0cd575a34506161fd06", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -122,7 +122,7 @@ impl<R: Reader> Reader for BufferedReader<R> {\n         let nread = {\n             let available = try!(self.fill_buf());\n             let nread = cmp::min(available.len(), buf.len());\n-            slice::bytes::copy_memory(buf, &available[0..nread]);\n+            slice::bytes::copy_memory(buf, &available[..nread]);\n             nread\n         };\n         self.pos += nread;\n@@ -183,7 +183,7 @@ impl<W: Writer> BufferedWriter<W> {\n \n     fn flush_buf(&mut self) -> IoResult<()> {\n         if self.pos != 0 {\n-            let ret = self.inner.as_mut().unwrap().write(&self.buf[0..self.pos]);\n+            let ret = self.inner.as_mut().unwrap().write(&self.buf[..self.pos]);\n             self.pos = 0;\n             ret\n         } else {\n@@ -282,7 +282,7 @@ impl<W: Writer> Writer for LineBufferedWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         match buf.iter().rposition(|&b| b == b'\\n') {\n             Some(i) => {\n-                try!(self.inner.write(&buf[0..(i + 1)]));\n+                try!(self.inner.write(&buf[..(i + 1)]));\n                 try!(self.inner.flush());\n                 try!(self.inner.write(&buf[(i + 1)..]));\n                 Ok(())"}, {"sha": "4b0014c68f7a84289cd17be9d6ff93a986b031e3", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -90,7 +90,7 @@ impl Reader for ChanReader {\n                 Some(src) => {\n                     let dst = buf.slice_from_mut(num_read);\n                     let count = cmp::min(src.len(), dst.len());\n-                    bytes::copy_memory(dst, &src[0..count]);\n+                    bytes::copy_memory(dst, &src[..count]);\n                     count\n                 },\n                 None => 0,"}, {"sha": "64406d88253a775305fb03749efe875c3c4d0bb9", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -889,7 +889,7 @@ mod test {\n             let mut read_buf = [0; 1028];\n             let read_str = match check!(read_stream.read(&mut read_buf)) {\n                 -1|0 => panic!(\"shouldn't happen\"),\n-                n => str::from_utf8(&read_buf[0..n]).unwrap().to_string()\n+                n => str::from_utf8(&read_buf[..n]).unwrap().to_string()\n             };\n             assert_eq!(read_str.as_slice(), message);\n         }"}, {"sha": "ee05a9e55964eb527421eca7707422f55d73b18e", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -204,7 +204,7 @@ impl<'a> Reader for &'a [u8] {\n \n         let write_len = min(buf.len(), self.len());\n         {\n-            let input = &self[0..write_len];\n+            let input = &self[..write_len];\n             let output = buf.slice_to_mut(write_len);\n             slice::bytes::copy_memory(output, input);\n         }\n@@ -286,7 +286,7 @@ impl<'a> Writer for BufWriter<'a> {\n \n             Ok(())\n         } else {\n-            slice::bytes::copy_memory(dst, &src[0..dst_len]);\n+            slice::bytes::copy_memory(dst, &src[..dst_len]);\n \n             self.pos += dst_len;\n \n@@ -498,7 +498,7 @@ mod test {\n         assert_eq!(buf, b);\n         assert_eq!(reader.read(&mut buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(&buf[0..3], b);\n+        assert_eq!(&buf[..3], b);\n         assert!(reader.read(&mut buf).is_err());\n         let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n@@ -524,7 +524,7 @@ mod test {\n         assert_eq!(buf.as_slice(), b);\n         assert_eq!(reader.read(&mut buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(&buf[0..3], b);\n+        assert_eq!(&buf[..3], b);\n         assert!(reader.read(&mut buf).is_err());\n         let mut reader = &mut in_buf.as_slice();\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n@@ -551,7 +551,7 @@ mod test {\n         assert_eq!(buf, b);\n         assert_eq!(reader.read(&mut buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(&buf[0..3], b);\n+        assert_eq!(&buf[..3], b);\n         assert!(reader.read(&mut buf).is_err());\n         let mut reader = BufReader::new(in_buf.as_slice());\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));"}, {"sha": "bab4dafd090bdfc40ec6f90f5c2072744d16835d", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -1069,7 +1069,7 @@ pub trait Writer {\n     fn write_char(&mut self, c: char) -> IoResult<()> {\n         let mut buf = [0u8; 4];\n         let n = c.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n-        self.write(&buf[0..n])\n+        self.write(&buf[..n])\n     }\n \n     /// Write the result of passing n through `int::to_str_bytes`.\n@@ -1454,7 +1454,7 @@ pub trait Buffer: Reader {\n                 };\n                 match available.iter().position(|&b| b == byte) {\n                     Some(i) => {\n-                        res.push_all(&available[0..(i + 1)]);\n+                        res.push_all(&available[..(i + 1)]);\n                         used = i + 1;\n                         break\n                     }\n@@ -1493,7 +1493,7 @@ pub trait Buffer: Reader {\n                 }\n             }\n         }\n-        match str::from_utf8(&buf[0..width]).ok() {\n+        match str::from_utf8(&buf[..width]).ok() {\n             Some(s) => Ok(s.char_at(0)),\n             None => Err(standard_error(InvalidInput))\n         }"}, {"sha": "adc122ff44741114d1337442addff67b03560714", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -313,7 +313,7 @@ impl<'a> Parser<'a> {\n \n         let mut tail = [0u16; 8];\n         let (tail_size, _) = read_groups(self, &mut tail, 8 - head_size);\n-        Some(ipv6_addr_from_head_tail(&head[0..head_size], &tail[0..tail_size]))\n+        Some(ipv6_addr_from_head_tail(&head[..head_size], &tail[..tail_size]))\n     }\n \n     fn read_ipv6_addr(&mut self) -> Option<IpAddr> {"}, {"sha": "adfd88644ccec6e4ec35c57efdd17c836e7b2e9c", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -60,7 +60,7 @@ impl<R: Reader> Reader for LimitReader<R> {\n impl<R: Buffer> Buffer for LimitReader<R> {\n     fn fill_buf<'a>(&'a mut self) -> io::IoResult<&'a [u8]> {\n         let amt = try!(self.inner.fill_buf());\n-        let buf = &amt[0..cmp::min(amt.len(), self.limit)];\n+        let buf = &amt[..cmp::min(amt.len(), self.limit)];\n         if buf.len() == 0 {\n             Err(io::standard_error(io::EndOfFile))\n         } else {\n@@ -223,7 +223,7 @@ impl<R: Reader, W: Writer> TeeReader<R, W> {\n impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {\n     fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n         self.reader.read(buf).and_then(|len| {\n-            self.writer.write(&mut buf[0..len]).map(|()| len)\n+            self.writer.write(&mut buf[..len]).map(|()| len)\n         })\n     }\n }\n@@ -237,7 +237,7 @@ pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> {\n             Err(ref e) if e.kind == io::EndOfFile => return Ok(()),\n             Err(e) => return Err(e),\n         };\n-        try!(w.write(&buf[0..len]));\n+        try!(w.write(&buf[..len]));\n     }\n }\n "}, {"sha": "541f1e7714070584dd0bf49046af9d6a9dba55a0", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -352,7 +352,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => name,\n                     Some(1) if name == b\"..\" => name,\n-                    Some(pos) => &name[0..pos]\n+                    Some(pos) => &name[..pos]\n                 }\n             })\n         }\n@@ -475,7 +475,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             let extlen = extension.container_as_bytes().len();\n             match (name.rposition_elem(&dot), extlen) {\n                 (None, 0) | (Some(0), 0) => None,\n-                (Some(idx), 0) => Some(name[0..idx].to_vec()),\n+                (Some(idx), 0) => Some(name[..idx].to_vec()),\n                 (idx, extlen) => {\n                     let idx = match idx {\n                         None | Some(0) => name.len(),\n@@ -484,7 +484,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n \n                     let mut v;\n                     v = Vec::with_capacity(idx + extlen + 1);\n-                    v.push_all(&name[0..idx]);\n+                    v.push_all(&name[..idx]);\n                     v.push(dot);\n                     v.push_all(extension.container_as_bytes());\n                     Some(v)"}, {"sha": "aab64639ab5903865a180c74dc2715d88e71e10d", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -136,7 +136,7 @@ impl GenericPathUnsafe for Path {\n             }\n             Some(idx) => {\n                 let mut v = Vec::with_capacity(idx + 1 + filename.len());\n-                v.push_all(&self.repr[0..(idx+1)]);\n+                v.push_all(&self.repr[..(idx+1)]);\n                 v.push_all(filename);\n                 // FIXME: this is slow\n                 self.repr = Path::normalize(v.as_slice());\n@@ -177,9 +177,9 @@ impl GenericPath for Path {\n         match self.sepidx {\n             None if b\"..\" == self.repr => self.repr.as_slice(),\n             None => dot_static,\n-            Some(0) => &self.repr[0..1],\n+            Some(0) => &self.repr[..1],\n             Some(idx) if &self.repr[(idx+1)..] == b\"..\" => self.repr.as_slice(),\n-            Some(idx) => &self.repr[0..idx]\n+            Some(idx) => &self.repr[..idx]\n         }\n     }\n "}, {"sha": "3cff1c67be3684ed07c810d4ec69f17ff9eabaa9", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -180,20 +180,20 @@ impl GenericPathUnsafe for Path {\n             }\n             Some((_,idxa,end)) if &self.repr[idxa..end] == \"..\" => {\n                 let mut s = String::with_capacity(end + 1 + filename.len());\n-                s.push_str(&self.repr[0..end]);\n+                s.push_str(&self.repr[..end]);\n                 s.push(SEP);\n                 s.push_str(filename);\n                 self.update_normalized(&s[]);\n             }\n             Some((idxb,idxa,_)) if self.prefix == Some(DiskPrefix) && idxa == self.prefix_len() => {\n                 let mut s = String::with_capacity(idxb + filename.len());\n-                s.push_str(&self.repr[0..idxb]);\n+                s.push_str(&self.repr[..idxb]);\n                 s.push_str(filename);\n                 self.update_normalized(&s[]);\n             }\n             Some((idxb,_,_)) => {\n                 let mut s = String::with_capacity(idxb + 1 + filename.len());\n-                s.push_str(&self.repr[0..idxb]);\n+                s.push_str(&self.repr[..idxb]);\n                 s.push(SEP);\n                 s.push_str(filename);\n                 self.update_normalized(&s[]);\n@@ -350,13 +350,13 @@ impl GenericPath for Path {\n             Some((idxb,_,end)) if &self.repr[idxb..end] == \"\\\\\" => {\n                 &self.repr[]\n             }\n-            Some((0,idxa,_)) => &self.repr[0..idxa],\n+            Some((0,idxa,_)) => &self.repr[..idxa],\n             Some((idxb,idxa,_)) => {\n                 match self.prefix {\n                     Some(DiskPrefix) | Some(VerbatimDiskPrefix) if idxb == self.prefix_len() => {\n-                        &self.repr[0..idxa]\n+                        &self.repr[..idxa]\n                     }\n-                    _ => &self.repr[0..idxb]\n+                    _ => &self.repr[..idxb]\n                 }\n             }\n         })\n@@ -428,15 +428,15 @@ impl GenericPath for Path {\n         if self.prefix.is_some() {\n             Some(Path::new(match self.prefix {\n                 Some(DiskPrefix) if self.is_absolute() => {\n-                    &self.repr[0..(self.prefix_len()+1)]\n+                    &self.repr[..(self.prefix_len()+1)]\n                 }\n                 Some(VerbatimDiskPrefix) => {\n-                    &self.repr[0..(self.prefix_len()+1)]\n+                    &self.repr[..(self.prefix_len()+1)]\n                 }\n-                _ => &self.repr[0..self.prefix_len()]\n+                _ => &self.repr[..self.prefix_len()]\n             }))\n         } else if is_vol_relative(self) {\n-            Some(Path::new(&self.repr[0..1]))\n+            Some(Path::new(&self.repr[..1]))\n         } else {\n             None\n         }\n@@ -683,7 +683,7 @@ impl Path {\n             }\n             (None, None) => true,\n             (a, b) if a == b => {\n-                &s_repr[0..self.prefix_len()] == &o_repr[0..other.prefix_len()]\n+                &s_repr[..self.prefix_len()] == &o_repr[..other.prefix_len()]\n             }\n             _ => false\n         }\n@@ -737,7 +737,7 @@ impl Path {\n                         match prefix.unwrap() {\n                             DiskPrefix => {\n                                 let len = prefix_len(prefix) + is_abs as uint;\n-                                let mut s = String::from_str(&s[0..len]);\n+                                let mut s = String::from_str(&s[..len]);\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n                                     v[0] = (*v)[0].to_ascii_uppercase();\n@@ -752,7 +752,7 @@ impl Path {\n                             }\n                             VerbatimDiskPrefix => {\n                                 let len = prefix_len(prefix) + is_abs as uint;\n-                                let mut s = String::from_str(&s[0..len]);\n+                                let mut s = String::from_str(&s[..len]);\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n                                     v[4] = (*v)[4].to_ascii_uppercase();\n@@ -762,14 +762,14 @@ impl Path {\n                             _ => {\n                                 let plen = prefix_len(prefix);\n                                 if s.len() > plen {\n-                                    Some(String::from_str(&s[0..plen]))\n+                                    Some(String::from_str(&s[..plen]))\n                                 } else { None }\n                             }\n                         }\n                     } else if is_abs && comps.is_empty() {\n                         Some(repeat(SEP).take(1).collect())\n                     } else {\n-                        let prefix_ = &s[0..prefix_len(prefix)];\n+                        let prefix_ = &s[..prefix_len(prefix)];\n                         let n = prefix_.len() +\n                                 if is_abs { comps.len() } else { comps.len() - 1} +\n                                 comps.iter().map(|v| v.len()).sum();\n@@ -780,7 +780,7 @@ impl Path {\n                                 s.push(':');\n                             }\n                             Some(VerbatimDiskPrefix) => {\n-                                s.push_str(&prefix_[0..4]);\n+                                s.push_str(&prefix_[..4]);\n                                 s.push(prefix_.as_bytes()[4].to_ascii_uppercase() as char);\n                                 s.push_str(&prefix_[5..]);\n                             }\n@@ -813,7 +813,7 @@ impl Path {\n \n     fn update_sepidx(&mut self) {\n         let s = if self.has_nonsemantic_trailing_slash() {\n-                    &self.repr[0..(self.repr.len()-1)]\n+                    &self.repr[..(self.repr.len()-1)]\n                 } else { &self.repr[] };\n         let sep_test: fn(char) -> bool = if !prefix_is_verbatim(self.prefix) {\n             is_sep"}, {"sha": "79a70b50bcfeeaaaa1a92859de44b6b9670b815e", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -544,7 +544,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n     // MAX_CALLBACKS, so we're sure to clamp it as necessary.\n     let callbacks = {\n         let amt = CALLBACK_CNT.load(Ordering::SeqCst);\n-        &CALLBACKS[0..cmp::min(amt, MAX_CALLBACKS)]\n+        &CALLBACKS[..cmp::min(amt, MAX_CALLBACKS)]\n     };\n     for cb in callbacks.iter() {\n         match cb.load(Ordering::SeqCst) {"}, {"sha": "aebf1b1179ea4f607592627973469d6a8adbcf5e", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -131,7 +131,7 @@ pub fn abort(args: fmt::Arguments) -> ! {\n     impl<'a> fmt::Writer for BufWriter<'a> {\n         fn write_str(&mut self, bytes: &str) -> fmt::Result {\n             let left = self.buf.slice_from_mut(self.pos);\n-            let to_write = &bytes.as_bytes()[0..cmp::min(bytes.len(), left.len())];\n+            let to_write = &bytes.as_bytes()[..cmp::min(bytes.len(), left.len())];\n             slice::bytes::copy_memory(left, to_write);\n             self.pos += to_write.len();\n             Ok(())\n@@ -142,7 +142,7 @@ pub fn abort(args: fmt::Arguments) -> ! {\n     let mut msg = [0u8; 512];\n     let mut w = BufWriter { buf: &mut msg, pos: 0 };\n     let _ = write!(&mut w, \"{}\", args);\n-    let msg = str::from_utf8(&w.buf[0..w.pos]).unwrap_or(\"aborted\");\n+    let msg = str::from_utf8(&w.buf[..w.pos]).unwrap_or(\"aborted\");\n     let msg = if msg.is_empty() {\"aborted\"} else {msg};\n \n     // Give some context to the message"}, {"sha": "4540068133bd796a7e734df0cbddef4c0ac03264", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -36,7 +36,7 @@ const BUF_BYTES : uint = 2048u;\n pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     match v.iter().position(|c| *c == 0) {\n         // don't include the 0\n-        Some(i) => &v[0..i],\n+        Some(i) => &v[..i],\n         None => v\n     }\n }"}, {"sha": "d4fc5f2dd1a23eb5fd234fef0418f1677c4da70f", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -513,7 +513,7 @@ impl<'ast> Map<'ast> {\n         NodesMatchingSuffix {\n             map: self,\n             item_name: parts.last().unwrap(),\n-            in_which: &parts[0..(parts.len() - 1)],\n+            in_which: &parts[..(parts.len() - 1)],\n             idx: 0,\n         }\n     }"}, {"sha": "bf26687deededc5f370d1b2050e3d6470f5c66c0", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -313,7 +313,7 @@ impl FileMap {\n             let begin = begin.to_uint();\n             let slice = &self.src[begin..];\n             match slice.find('\\n') {\n-                Some(e) => &slice[0..e],\n+                Some(e) => &slice[..e],\n                 None => slice\n             }.to_string()\n         })"}, {"sha": "dfef52872608fcc03a82adffd30ef5e0837d746e", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -277,7 +277,7 @@ fn print_maybe_styled(w: &mut EmitterWriter,\n             // to be miscolored. We assume this is rare enough that we don't\n             // have to worry about it.\n             if msg.ends_with(\"\\n\") {\n-                try!(t.write_str(&msg[0..(msg.len()-1)]));\n+                try!(t.write_str(&msg[..(msg.len()-1)]));\n                 try!(t.reset());\n                 try!(t.write_str(\"\\n\"));\n             } else {"}, {"sha": "9e5618579e40a5c520bec78e5974cf6bc9c3f129", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -128,7 +128,7 @@ impl<'a, W: Writer> RepeatFasta<'a, W> {\n         copy_memory(buf.as_mut_slice(), alu);\n         let buf_len = buf.len();\n         copy_memory(buf.slice_mut(alu_len, buf_len),\n-                    &alu[0..LINE_LEN]);\n+                    &alu[..LINE_LEN]);\n \n         let mut pos = 0;\n         let mut bytes;\n@@ -204,7 +204,7 @@ impl<'a, W: Writer> RandomFasta<'a, W> {\n         for i in range(0u, chars_left) {\n             buf[i] = self.nextc();\n         }\n-        self.out.write(&buf[0..chars_left])\n+        self.out.write(&buf[..chars_left])\n     }\n }\n "}, {"sha": "a071224999be094bcfc0d598fce7b86eebd1c2de", "filename": "src/test/run-pass/issue-17503.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Ftest%2Frun-pass%2Fissue-17503.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Ftest%2Frun-pass%2Fissue-17503.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17503.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -13,7 +13,7 @@ fn main() {\n     let ss: &&[int] = &s;\n     let sss: &&&[int] = &ss;\n \n-    println!(\"{:?}\", &s[0..3]);\n+    println!(\"{:?}\", &s[..3]);\n     println!(\"{:?}\", &ss[3..]);\n     println!(\"{:?}\", &sss[2..4]);\n }"}, {"sha": "f845db9c421634bf0bbab252f85bc3312f488587", "filename": "src/test/run-pass/issue-8898.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8898.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -16,7 +16,7 @@ pub fn main() {\n     let abc = [1i, 2, 3];\n     let tf = [true, false];\n     let x  = [(), ()];\n-    let slice = &x[0..1];\n+    let slice = &x[..1];\n \n     assert_repr_eq(&abc[], \"[1i, 2i, 3i]\".to_string());\n     assert_repr_eq(&tf[], \"[true, false]\".to_string());"}, {"sha": "43e517404cb09b3adc9414f17584d9da7cfae8b2", "filename": "src/test/run-pass/slice-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Ftest%2Frun-pass%2Fslice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d48a85082cfe3683ad9eda5223d3259d4fa718/src%2Ftest%2Frun-pass%2Fslice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-2.rs?ref=c1d48a85082cfe3683ad9eda5223d3259d4fa718", "patch": "@@ -17,7 +17,7 @@ fn main() {\n     let cmp: &[int] = &[3, 4, 5];\n     assert!(&x[2..] == cmp);\n     let cmp: &[int] = &[1, 2, 3];\n-    assert!(&x[0..3] == cmp);\n+    assert!(&x[..3] == cmp);\n     let cmp: &[int] = &[2, 3, 4];\n     assert!(&x[1..4] == cmp);\n \n@@ -27,7 +27,7 @@ fn main() {\n     let cmp: &[int] = &[3, 4, 5];\n     assert!(&x[2..] == cmp);\n     let cmp: &[int] = &[1, 2, 3];\n-    assert!(&x[0..3] == cmp);\n+    assert!(&x[..3] == cmp);\n     let cmp: &[int] = &[2, 3, 4];\n     assert!(&x[1..4] == cmp);\n "}]}