{"sha": "d38fddd89908cae6767ad599388421f99f71840b", "node_id": "C_kwDOAAsO6NoAKGQzOGZkZGQ4OTkwOGNhZTY3NjdhZDU5OTM4ODQyMWY5OWY3MTg0MGI", "commit": {"author": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-10-24T19:06:17Z"}, "committer": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-10-24T19:13:43Z"}, "message": "Refactor `camel_case` util functions for new `StrIndex`", "tree": {"sha": "bead9c906f07e7d23a31abe0b78876de1a07ea75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bead9c906f07e7d23a31abe0b78876de1a07ea75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d38fddd89908cae6767ad599388421f99f71840b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d38fddd89908cae6767ad599388421f99f71840b", "html_url": "https://github.com/rust-lang/rust/commit/d38fddd89908cae6767ad599388421f99f71840b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d38fddd89908cae6767ad599388421f99f71840b/comments", "author": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b91d986ea38ad121d760ab8c1320dd2fc5580f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b91d986ea38ad121d760ab8c1320dd2fc5580f2", "html_url": "https://github.com/rust-lang/rust/commit/1b91d986ea38ad121d760ab8c1320dd2fc5580f2"}], "stats": {"total": 162, "additions": 103, "deletions": 59}, "files": [{"sha": "19f1781d0b046196025347d878069ccb07de7629", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d38fddd89908cae6767ad599388421f99f71840b/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38fddd89908cae6767ad599388421f99f71840b/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=d38fddd89908cae6767ad599388421f99f71840b", "patch": "@@ -1,8 +1,8 @@\n //! lint on enum variants that are prefixed or suffixed by the same characters\n \n-use clippy_utils::str_utils;\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::source::is_present_in_source;\n+use clippy_utils::str_utils;\n use rustc_hir::{EnumDef, Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -171,23 +171,23 @@ fn check_variant(\n         }\n     }\n     let first = &def.variants[0].ident.name.as_str();\n-    let mut pre = &first[..str_utils::until(&*first)];\n-    let mut post = &first[str_utils::from(&*first)..];\n+    let mut pre = &first[..str_utils::camel_case_until(&*first).byte_index];\n+    let mut post = &first[str_utils::camel_case_start(&*first).byte_index..];\n     for var in def.variants {\n         let name = var.ident.name.as_str();\n \n         let pre_match = partial_match(pre, &name);\n         pre = &pre[..pre_match];\n-        let pre_camel = str_utils::until(pre);\n+        let pre_camel = str_utils::camel_case_until(pre).byte_index;\n         pre = &pre[..pre_camel];\n         while let Some((next, last)) = name[pre.len()..].chars().zip(pre.chars().rev()).next() {\n             if next.is_numeric() {\n                 return;\n             }\n             if next.is_lowercase() {\n                 let last = pre.len() - last.len_utf8();\n-                let last_camel = str_utils::until(&pre[..last]);\n-                pre = &pre[..last_camel];\n+                let last_camel = str_utils::camel_case_until(&pre[..last]);\n+                pre = &pre[..last_camel.byte_index];\n             } else {\n                 break;\n             }\n@@ -196,8 +196,8 @@ fn check_variant(\n         let post_match = partial_rmatch(post, &name);\n         let post_end = post.len() - post_match;\n         post = &post[post_end..];\n-        let post_camel = str_utils::from(post);\n-        post = &post[post_camel..];\n+        let post_camel = str_utils::camel_case_start(post);\n+        post = &post[post_camel.byte_index..];\n     }\n     let (what, value) = match (pre.is_empty(), post.is_empty()) {\n         (true, true) => return,"}, {"sha": "0637ae3e97b6b81df96af5cfb8134bc8a966105c", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d38fddd89908cae6767ad599388421f99f71840b/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38fddd89908cae6767ad599388421f99f71840b/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=d38fddd89908cae6767ad599388421f99f71840b", "patch": "@@ -37,7 +37,6 @@ pub mod sym_helper;\n #[allow(clippy::module_name_repetitions)]\n pub mod ast_utils;\n pub mod attrs;\n-pub mod str_utils;\n pub mod comparisons;\n pub mod consts;\n pub mod diagnostics;\n@@ -50,6 +49,7 @@ pub mod paths;\n pub mod ptr;\n pub mod qualify_min_const_fn;\n pub mod source;\n+pub mod str_utils;\n pub mod sugg;\n pub mod ty;\n pub mod usage;"}, {"sha": "f3de1250d5d80eceedd7e7a5b861b4c822e356f4", "filename": "clippy_utils/src/str_utils.rs", "status": "modified", "additions": 94, "deletions": 50, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/d38fddd89908cae6767ad599388421f99f71840b/clippy_utils%2Fsrc%2Fstr_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38fddd89908cae6767ad599388421f99f71840b/clippy_utils%2Fsrc%2Fstr_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fstr_utils.rs?ref=d38fddd89908cae6767ad599388421f99f71840b", "patch": "@@ -1,117 +1,161 @@\n+/// Dealing with sting indices can be hard, this struct ensures that both the\n+/// character and byte index are provided for correct indexing.\n+#[derive(Debug, Default, PartialEq, Eq)]\n+pub struct StrIndex {\n+    pub char_index: usize,\n+    pub byte_index: usize,\n+}\n+\n+impl StrIndex {\n+    pub fn new(char_index: usize, byte_index: usize) -> Self {\n+        Self { char_index, byte_index }\n+    }\n+}\n+\n /// Returns the index of the character after the first camel-case component of `s`.\n+///\n+/// ```\n+/// assert_eq!(camel_case_until(\"AbcDef\"), StrIndex::new(6, 6));\n+/// assert_eq!(camel_case_until(\"ABCD\"), StrIndex::new(0, 0));\n+/// assert_eq!(camel_case_until(\"AbcDD\"), StrIndex::new(3, 3));\n+/// assert_eq!(camel_case_until(\"Abc\\u{f6}\\u{f6}DD\"), StrIndex::new(5, 7));\n+/// ```\n #[must_use]\n-pub fn until(s: &str) -> usize {\n-    let mut iter = s.char_indices();\n-    if let Some((_, first)) = iter.next() {\n+pub fn camel_case_until(s: &str) -> StrIndex {\n+    let mut iter = s.char_indices().enumerate();\n+    if let Some((_char_index, (_, first))) = iter.next() {\n         if !first.is_uppercase() {\n-            return 0;\n+            return StrIndex::new(0, 0);\n         }\n     } else {\n-        return 0;\n+        return StrIndex::new(0, 0);\n     }\n     let mut up = true;\n-    let mut last_i = 0;\n-    for (i, c) in iter {\n+    let mut last_index = StrIndex::new(0, 0);\n+    for (char_index, (byte_index, c)) in iter {\n         if up {\n             if c.is_lowercase() {\n                 up = false;\n             } else {\n-                return last_i;\n+                return last_index;\n             }\n         } else if c.is_uppercase() {\n             up = true;\n-            last_i = i;\n+            last_index.byte_index = byte_index;\n+            last_index.char_index = char_index;\n         } else if !c.is_lowercase() {\n-            return i;\n+            return StrIndex::new(char_index, byte_index);\n         }\n     }\n-    if up { last_i } else { s.len() }\n+\n+    if up {\n+        last_index\n+    } else {\n+        StrIndex::new(s.chars().count(), s.len())\n+    }\n }\n \n /// Returns index of the last camel-case component of `s`.\n+///\n+/// ```\n+/// assert_eq!(camel_case_start(\"AbcDef\"), StrIndex::new(0, 0));\n+/// assert_eq!(camel_case_start(\"abcDef\"), StrIndex::new(3, 3));\n+/// assert_eq!(camel_case_start(\"ABCD\"), StrIndex::new(4, 4));\n+/// assert_eq!(camel_case_start(\"abcd\"), StrIndex::new(4, 4));\n+/// assert_eq!(camel_case_start(\"\\u{f6}\\u{f6}cd\"), StrIndex::new(4, 6));\n+/// ```\n #[must_use]\n-pub fn from(s: &str) -> usize {\n-    let mut iter = s.char_indices().rev();\n-    if let Some((_, first)) = iter.next() {\n+pub fn camel_case_start(s: &str) -> StrIndex {\n+    let char_count = s.chars().count();\n+    let range = 0..char_count;\n+    let mut iter = range.rev().zip(s.char_indices().rev());\n+    if let Some((char_index, (_, first))) = iter.next() {\n         if !first.is_lowercase() {\n-            return s.len();\n+            return StrIndex::new(char_index, s.len());\n         }\n     } else {\n-        return s.len();\n+        return StrIndex::new(char_count, s.len());\n     }\n     let mut down = true;\n-    let mut last_i = s.len();\n-    for (i, c) in iter {\n+    let mut last_index = StrIndex::new(char_count, s.len());\n+    for (char_index, (byte_index, c)) in iter {\n         if down {\n             if c.is_uppercase() {\n                 down = false;\n-                last_i = i;\n+                last_index.byte_index = byte_index;\n+                last_index.char_index = char_index;\n             } else if !c.is_lowercase() {\n-                return last_i;\n+                return last_index;\n             }\n         } else if c.is_lowercase() {\n             down = true;\n         } else if c.is_uppercase() {\n-            last_i = i;\n+            last_index.byte_index = byte_index;\n+            last_index.char_index = char_index;\n         } else {\n-            return last_i;\n+            return last_index;\n         }\n     }\n-    last_i\n+    last_index\n }\n \n #[cfg(test)]\n mod test {\n-    use super::{from, until};\n+    use super::*;\n \n     #[test]\n-    fn from_full() {\n-        assert_eq!(from(\"AbcDef\"), 0);\n-        assert_eq!(from(\"Abc\"), 0);\n-        assert_eq!(from(\"ABcd\"), 0);\n-        assert_eq!(from(\"ABcdEf\"), 0);\n-        assert_eq!(from(\"AabABcd\"), 0);\n+    fn camel_case_start_full() {\n+        assert_eq!(camel_case_start(\"AbcDef\"), StrIndex::new(0, 0));\n+        assert_eq!(camel_case_start(\"Abc\"), StrIndex::new(0, 0));\n+        assert_eq!(camel_case_start(\"ABcd\"), StrIndex::new(0, 0));\n+        assert_eq!(camel_case_start(\"ABcdEf\"), StrIndex::new(0, 0));\n+        assert_eq!(camel_case_start(\"AabABcd\"), StrIndex::new(0, 0));\n     }\n \n     #[test]\n-    fn from_partial() {\n-        assert_eq!(from(\"abcDef\"), 3);\n-        assert_eq!(from(\"aDbc\"), 1);\n-        assert_eq!(from(\"aabABcd\"), 3);\n+    fn camel_case_start_partial() {\n+        assert_eq!(camel_case_start(\"abcDef\"), StrIndex::new(3, 3));\n+        assert_eq!(camel_case_start(\"aDbc\"), StrIndex::new(1, 1));\n+        assert_eq!(camel_case_start(\"aabABcd\"), StrIndex::new(3, 3));\n+        assert_eq!(camel_case_start(\"\\u{f6}\\u{f6}AabABcd\"), StrIndex::new(2, 4));\n     }\n \n     #[test]\n-    fn from_not() {\n-        assert_eq!(from(\"AbcDef_\"), 7);\n-        assert_eq!(from(\"AbcDD\"), 5);\n+    fn camel_case_start_not() {\n+        assert_eq!(camel_case_start(\"AbcDef_\"), StrIndex::new(7, 7));\n+        assert_eq!(camel_case_start(\"AbcDD\"), StrIndex::new(5, 5));\n+        assert_eq!(camel_case_start(\"all_small\"), StrIndex::new(9, 9));\n+        assert_eq!(camel_case_start(\"\\u{f6}_all_small\"), StrIndex::new(11, 12));\n     }\n \n     #[test]\n-    fn from_caps() {\n-        assert_eq!(from(\"ABCD\"), 4);\n+    fn camel_case_start_caps() {\n+        assert_eq!(camel_case_start(\"ABCD\"), StrIndex::new(4, 4));\n     }\n \n     #[test]\n-    fn until_full() {\n-        assert_eq!(until(\"AbcDef\"), 6);\n-        assert_eq!(until(\"Abc\"), 3);\n+    fn camel_case_until_full() {\n+        assert_eq!(camel_case_until(\"AbcDef\"), StrIndex::new(6, 6));\n+        assert_eq!(camel_case_until(\"Abc\"), StrIndex::new(3, 3));\n+        assert_eq!(camel_case_until(\"Abc\\u{f6}\\u{f6}\\u{f6}\"), StrIndex::new(6, 9));\n     }\n \n     #[test]\n-    fn until_not() {\n-        assert_eq!(until(\"abcDef\"), 0);\n-        assert_eq!(until(\"aDbc\"), 0);\n+    fn camel_case_until_not() {\n+        assert_eq!(camel_case_until(\"abcDef\"), StrIndex::new(0, 0));\n+        assert_eq!(camel_case_until(\"aDbc\"), StrIndex::new(0, 0));\n     }\n \n     #[test]\n-    fn until_partial() {\n-        assert_eq!(until(\"AbcDef_\"), 6);\n-        assert_eq!(until(\"CallTypeC\"), 8);\n-        assert_eq!(until(\"AbcDD\"), 3);\n+    fn camel_case_until_partial() {\n+        assert_eq!(camel_case_until(\"AbcDef_\"), StrIndex::new(6, 6));\n+        assert_eq!(camel_case_until(\"CallTypeC\"), StrIndex::new(8, 8));\n+        assert_eq!(camel_case_until(\"AbcDD\"), StrIndex::new(3, 3));\n+        assert_eq!(camel_case_until(\"Abc\\u{f6}\\u{f6}DD\"), StrIndex::new(5, 7));\n     }\n \n     #[test]\n     fn until_caps() {\n-        assert_eq!(until(\"ABCD\"), 0);\n+        assert_eq!(camel_case_until(\"ABCD\"), StrIndex::new(0, 0));\n     }\n }"}]}