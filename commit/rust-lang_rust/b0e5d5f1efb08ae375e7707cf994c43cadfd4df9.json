{"sha": "b0e5d5f1efb08ae375e7707cf994c43cadfd4df9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwZTVkNWYxZWZiMDhhZTM3NWU3NzA3Y2Y5OTRjNDNjYWRmZDRkZjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-19T14:34:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-19T14:34:39Z"}, "message": "Auto merge of #1804 - RalfJung:ptrless-allocs, r=RalfJung\n\nupdate for Memory API changes\n\nThe Miri side of https://github.com/rust-lang/rust/pull/85376.", "tree": {"sha": "9893c816523a06021b4f524bedb8f949c320adc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9893c816523a06021b4f524bedb8f949c320adc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9", "html_url": "https://github.com/rust-lang/rust/commit/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cda0b07121b8792fec23030f44515c5b4f351b8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cda0b07121b8792fec23030f44515c5b4f351b8d", "html_url": "https://github.com/rust-lang/rust/commit/cda0b07121b8792fec23030f44515c5b4f351b8d"}, {"sha": "aba96b82b4a9600ea8d01934c799f0539def356b", "url": "https://api.github.com/repos/rust-lang/rust/commits/aba96b82b4a9600ea8d01934c799f0539def356b", "html_url": "https://github.com/rust-lang/rust/commit/aba96b82b4a9600ea8d01934c799f0539def356b"}], "stats": {"total": 214, "additions": 117, "deletions": 97}, "files": [{"sha": "143d077e3c201ff5ace1257f12f1c66436ba9860", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=b0e5d5f1efb08ae375e7707cf994c43cadfd4df9", "patch": "@@ -1 +1 @@\n-3e99439f4dacc8ba0d2ca48d221694362d587927\n+3e827cc21e0734edd26170e8d1481f0d66a1426b"}, {"sha": "bcc2e17654319d3cffa65e36631d179cb12d0cc3", "filename": "src/data_race.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=b0e5d5f1efb08ae375e7707cf994c43cadfd4df9", "patch": "@@ -720,7 +720,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         if let Some(data_race) = &mut this.memory.extra.data_race {\n             if data_race.multi_threaded.get() {\n                 let alloc_meta =\n-                    this.memory.get_raw_mut(ptr.alloc_id)?.extra.data_race.as_mut().unwrap();\n+                    this.memory.get_alloc_extra_mut(ptr.alloc_id)?.data_race.as_mut().unwrap();\n                 alloc_meta.reset_clocks(ptr.offset, size);\n             }\n         }\n@@ -1024,7 +1024,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n                 let place_ptr = place.ptr.assert_ptr();\n                 let size = place.layout.size;\n                 let alloc_meta =\n-                    &this.memory.get_raw(place_ptr.alloc_id)?.extra.data_race.as_ref().unwrap();\n+                    &this.memory.get_alloc_extra(place_ptr.alloc_id)?.data_race.as_ref().unwrap();\n                 log::trace!(\n                     \"Atomic op({}) with ordering {:?} on memory({:?}, offset={}, size={})\",\n                     description,"}, {"sha": "ae50b50860227f3a326c4ae68f59a71cc1c0f75f", "filename": "src/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=b0e5d5f1efb08ae375e7707cf994c43cadfd4df9", "patch": "@@ -136,13 +136,13 @@ pub fn report_error<'tcx, 'mir>(\n \n     // Extra output to help debug specific issues.\n     match e.kind() {\n-        UndefinedBehavior(UndefinedBehaviorInfo::InvalidUninitBytes(Some(access))) => {\n+        UndefinedBehavior(UndefinedBehaviorInfo::InvalidUninitBytes(Some((alloc_id, access)))) => {\n             eprintln!(\n                 \"Uninitialized read occurred at offsets 0x{:x}..0x{:x} into this allocation:\",\n-                access.uninit_ptr.offset.bytes(),\n-                access.uninit_ptr.offset.bytes() + access.uninit_size.bytes(),\n+                access.uninit_offset.bytes(),\n+                access.uninit_offset.bytes() + access.uninit_size.bytes(),\n             );\n-            eprintln!(\"{:?}\", ecx.memory.dump_alloc(access.uninit_ptr.alloc_id));\n+            eprintln!(\"{:?}\", ecx.memory.dump_alloc(*alloc_id));\n         }\n         _ => {}\n     }"}, {"sha": "45a5a8d4170bf691c4517a82f725eb3da1c28edc", "filename": "src/helpers.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=b0e5d5f1efb08ae375e7707cf994c43cadfd4df9", "patch": "@@ -8,7 +8,7 @@ use log::trace;\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_middle::mir;\n use rustc_middle::ty::{self, layout::TyAndLayout, List, TyCtxt};\n-use rustc_target::abi::{FieldsShape, LayoutOf, Size, Variants};\n+use rustc_target::abi::{Align, FieldsShape, LayoutOf, Size, Variants};\n use rustc_target::spec::abi::Abi;\n \n use rand::RngCore;\n@@ -577,10 +577,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let ptr = this.force_ptr(sptr)?; // We need to read at least 1 byte, so we can eagerly get a ptr.\n \n         // Step 1: determine the length.\n-        let alloc = this.memory.get_raw(ptr.alloc_id)?;\n         let mut len = Size::ZERO;\n         loop {\n-            let byte = alloc.read_scalar(this, ptr.offset(len, this)?, size1)?.to_u8()?;\n+            // FIXME: We are re-getting the allocation each time around the loop.\n+            // Would be nice if we could somehow \"extend\" an existing AllocRange.\n+            let alloc = this.memory.get(ptr.offset(len, this)?.into(), size1, Align::ONE)?.unwrap(); // not a ZST, so we will get a result\n+            let byte = alloc.read_scalar(alloc_range(Size::ZERO, size1))?.to_u8()?;\n             if byte == 0 {\n                 break;\n             } else {\n@@ -595,12 +597,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn read_wide_str(&self, sptr: Scalar<Tag>) -> InterpResult<'tcx, Vec<u16>> {\n         let this = self.eval_context_ref();\n         let size2 = Size::from_bytes(2);\n+        let align2 = Align::from_bytes(2).unwrap();\n \n         let mut ptr = this.force_ptr(sptr)?; // We need to read at least 1 wchar, so we can eagerly get a ptr.\n         let mut wchars = Vec::new();\n-        let alloc = this.memory.get_raw(ptr.alloc_id)?;\n         loop {\n-            let wchar = alloc.read_scalar(this, ptr, size2)?.to_u16()?;\n+            // FIXME: We are re-getting the allocation each time around the loop.\n+            // Would be nice if we could somehow \"extend\" an existing AllocRange.\n+            let alloc = this.memory.get(ptr.into(), size2, align2)?.unwrap(); // not a ZST, so we will get a result\n+            let wchar = alloc.read_scalar(alloc_range(Size::ZERO, size2))?.to_u16()?;\n             if wchar == 0 {\n                 break;\n             } else {"}, {"sha": "7ed8147753d275fa108359fbf4ce73c5ce631d21", "filename": "src/machine.rs", "status": "modified", "additions": 48, "deletions": 56, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=b0e5d5f1efb08ae375e7707cf994c43cadfd4df9", "patch": "@@ -506,15 +506,57 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     }\n \n     #[inline(always)]\n-    fn before_deallocation(\n-        memory_extra: &mut Self::MemoryExtra,\n-        id: AllocId,\n+    fn memory_read(\n+        _memory_extra: &Self::MemoryExtra,\n+        alloc: &Allocation<Tag, AllocExtra>,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n     ) -> InterpResult<'tcx> {\n-        if Some(id) == memory_extra.tracked_alloc_id {\n-            register_diagnostic(NonHaltingDiagnostic::FreedAlloc(id));\n+        if let Some(data_race) = &alloc.extra.data_race {\n+            data_race.read(ptr, size)?;\n         }\n+        if let Some(stacked_borrows) = &alloc.extra.stacked_borrows {\n+            stacked_borrows.memory_read(ptr, size)\n+        } else {\n+            Ok(())\n+        }\n+    }\n \n-        Ok(())\n+    #[inline(always)]\n+    fn memory_written(\n+        _memory_extra: &mut Self::MemoryExtra,\n+        alloc: &mut Allocation<Tag, AllocExtra>,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> InterpResult<'tcx> {\n+        if let Some(data_race) = &mut alloc.extra.data_race {\n+            data_race.write(ptr, size)?;\n+        }\n+        if let Some(stacked_borrows) = &mut alloc.extra.stacked_borrows {\n+            stacked_borrows.memory_written(ptr, size)\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn memory_deallocated(\n+        memory_extra: &mut Self::MemoryExtra,\n+        alloc: &mut Allocation<Tag, AllocExtra>,\n+        ptr: Pointer<Tag>,\n+    ) -> InterpResult<'tcx> {\n+        let size = alloc.size();\n+        if Some(ptr.alloc_id) == memory_extra.tracked_alloc_id {\n+            register_diagnostic(NonHaltingDiagnostic::FreedAlloc(ptr.alloc_id));\n+        }\n+        if let Some(data_race) = &mut alloc.extra.data_race {\n+            data_race.deallocate(ptr, size)?;\n+        }\n+        if let Some(stacked_borrows) = &mut alloc.extra.stacked_borrows {\n+            stacked_borrows.memory_deallocated(ptr, size)\n+        } else {\n+            Ok(())\n+        }\n     }\n \n     fn after_static_mem_initialized(\n@@ -601,53 +643,3 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         intptrcast::GlobalState::ptr_to_int(ptr, memory)\n     }\n }\n-\n-impl AllocationExtra<Tag> for AllocExtra {\n-    #[inline(always)]\n-    fn memory_read<'tcx>(\n-        alloc: &Allocation<Tag, AllocExtra>,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx> {\n-        if let Some(data_race) = &alloc.extra.data_race {\n-            data_race.read(ptr, size)?;\n-        }\n-        if let Some(stacked_borrows) = &alloc.extra.stacked_borrows {\n-            stacked_borrows.memory_read(ptr, size)\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    #[inline(always)]\n-    fn memory_written<'tcx>(\n-        alloc: &mut Allocation<Tag, AllocExtra>,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx> {\n-        if let Some(data_race) = &mut alloc.extra.data_race {\n-            data_race.write(ptr, size)?;\n-        }\n-        if let Some(stacked_borrows) = &mut alloc.extra.stacked_borrows {\n-            stacked_borrows.memory_written(ptr, size)\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    #[inline(always)]\n-    fn memory_deallocated<'tcx>(\n-        alloc: &mut Allocation<Tag, AllocExtra>,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx> {\n-        if let Some(data_race) = &mut alloc.extra.data_race {\n-            data_race.deallocate(ptr, size)?;\n-        }\n-        if let Some(stacked_borrows) = &mut alloc.extra.stacked_borrows {\n-            stacked_borrows.memory_deallocated(ptr, size)\n-        } else {\n-            Ok(())\n-        }\n-    }\n-}"}, {"sha": "f2979a3c69d8020aec7ae6f9fe43e4b684e62242", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=b0e5d5f1efb08ae375e7707cf994c43cadfd4df9", "patch": "@@ -574,7 +574,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n         // be 8-aligned).\n         let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-        this.memory.check_ptr_access(place.ptr, place.layout.size, align)?;\n+        this.memory.check_ptr_access_align(\n+            place.ptr,\n+            place.layout.size,\n+            align,\n+            CheckInAllocMsg::MemoryAccessTest,\n+        )?;\n+        // Perform regular access.\n         this.write_scalar(val, dest)?;\n         Ok(())\n     }\n@@ -594,7 +600,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n         // be 8-aligned).\n         let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-        this.memory.check_ptr_access(place.ptr, place.layout.size, align)?;\n+        this.memory.check_ptr_access_align(\n+            place.ptr,\n+            place.layout.size,\n+            align,\n+            CheckInAllocMsg::MemoryAccessTest,\n+        )?;\n \n         // Perform atomic store\n         this.write_scalar_atomic(val, &place, atomic)?;\n@@ -644,7 +655,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n         // be 8-aligned).\n         let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-        this.memory.check_ptr_access(place.ptr, place.layout.size, align)?;\n+        this.memory.check_ptr_access_align(\n+            place.ptr,\n+            place.layout.size,\n+            align,\n+            CheckInAllocMsg::MemoryAccessTest,\n+        )?;\n \n         match atomic_op {\n             AtomicOp::Min => {\n@@ -681,7 +697,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n         // be 8-aligned).\n         let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-        this.memory.check_ptr_access(place.ptr, place.layout.size, align)?;\n+        this.memory.check_ptr_access_align(\n+            place.ptr,\n+            place.layout.size,\n+            align,\n+            CheckInAllocMsg::MemoryAccessTest,\n+        )?;\n \n         let old = this.atomic_exchange_scalar(&place, new, atomic)?;\n         this.write_scalar(old, dest)?; // old value is returned\n@@ -707,7 +728,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n         // be 8-aligned).\n         let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-        this.memory.check_ptr_access(place.ptr, place.layout.size, align)?;\n+        this.memory.check_ptr_access_align(\n+            place.ptr,\n+            place.layout.size,\n+            align,\n+            CheckInAllocMsg::MemoryAccessTest,\n+        )?;\n \n         let old = this.atomic_compare_exchange_scalar(\n             &place,"}, {"sha": "8a3f5677706ec04b922baa91f7fe44f7995c62e1", "filename": "src/shims/os_str.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/src%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/src%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fos_str.rs?ref=b0e5d5f1efb08ae375e7707cf994c43cadfd4df9", "patch": "@@ -9,7 +9,7 @@ use std::os::unix::ffi::{OsStrExt, OsStringExt};\n #[cfg(windows)]\n use std::os::windows::ffi::{OsStrExt, OsStringExt};\n \n-use rustc_target::abi::{LayoutOf, Size};\n+use rustc_target::abi::{Align, LayoutOf, Size};\n \n use crate::*;\n \n@@ -144,17 +144,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Store the UTF-16 string.\n         let size2 = Size::from_bytes(2);\n         let this = self.eval_context_mut();\n-        let tcx = &*this.tcx;\n-        let ptr = this.force_ptr(sptr)?; // we need to write at least the 0 terminator\n-        let alloc = this.memory.get_raw_mut(ptr.alloc_id)?;\n+        let mut alloc = this\n+            .memory\n+            .get_mut(sptr, size2 * string_length, Align::from_bytes(2).unwrap())?\n+            .unwrap(); // not a ZST, so we will get a result\n         for (offset, wchar) in u16_vec.into_iter().chain(iter::once(0x0000)).enumerate() {\n             let offset = u64::try_from(offset).unwrap();\n-            alloc.write_scalar(\n-                tcx,\n-                ptr.offset(size2 * offset, tcx)?,\n-                Scalar::from_u16(wchar).into(),\n-                size2,\n-            )?;\n+            alloc\n+                .write_scalar(alloc_range(size2 * offset, size2), Scalar::from_u16(wchar).into())?;\n         }\n         Ok((true, string_length - 1))\n     }"}, {"sha": "06594e5ca1d6a0007471c166d2c1e84119221900", "filename": "src/shims/posix/fs.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/src%2Fshims%2Fposix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/src%2Fshims%2Fposix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Ffs.rs?ref=b0e5d5f1efb08ae375e7707cf994c43cadfd4df9", "patch": "@@ -677,10 +677,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         trace!(\"Reading from FD {}, size {}\", fd, count);\n \n         // Check that the *entire* buffer is actually valid memory.\n-        this.memory.check_ptr_access(\n+        this.memory.check_ptr_access_align(\n             buf,\n             Size::from_bytes(count),\n-            Align::from_bytes(1).unwrap(),\n+            Align::ONE,\n+            CheckInAllocMsg::MemoryAccessTest,\n         )?;\n \n         // We cap the number of read bytes to the largest value that we are able to fit in both the\n@@ -722,10 +723,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Isolation check is done via `FileDescriptor` trait.\n \n         // Check that the *entire* buffer is actually valid memory.\n-        this.memory.check_ptr_access(\n+        this.memory.check_ptr_access_align(\n             buf,\n             Size::from_bytes(count),\n-            Align::from_bytes(1).unwrap(),\n+            Align::ONE,\n+            CheckInAllocMsg::MemoryAccessTest,\n         )?;\n \n         // We cap the number of written bytes to the largest value that we are able to fit in both the"}, {"sha": "fda70d815de2136403b12aacb2401d636cb0ca79", "filename": "src/shims/posix/linux/sync.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fsync.rs?ref=b0e5d5f1efb08ae375e7707cf994c43cadfd4df9", "patch": "@@ -82,10 +82,11 @@ pub fn futex<'tcx>(\n             // Check the pointer for alignment and validity.\n             // The API requires `addr` to be a 4-byte aligned pointer, and will\n             // use the 4 bytes at the given address as an (atomic) i32.\n-            this.memory.check_ptr_access(\n+            this.memory.check_ptr_access_align(\n                 addr.to_scalar()?,\n                 Size::from_bytes(4),\n                 Align::from_bytes(4).unwrap(),\n+                CheckInAllocMsg::MemoryAccessTest,\n             )?;\n             // Read an `i32` through the pointer, regardless of any wrapper types.\n             // It's not uncommon for `addr` to be passed as another type than `*mut i32`, such as `*const AtomicI32`."}, {"sha": "1139e21e0f13a944d6dda5ca6a5f11d725b0a99f", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=b0e5d5f1efb08ae375e7707cf994c43cadfd4df9", "patch": "@@ -561,7 +561,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         );\n \n         // Get the allocation. It might not be mutable, so we cannot use `get_mut`.\n-        let extra = &this.memory.get_raw(ptr.alloc_id)?.extra;\n+        let extra = this.memory.get_alloc_extra(ptr.alloc_id)?;\n         let stacked_borrows =\n             extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n         // Update the stacks."}, {"sha": "093c9024f202debfd362270048dc8741cd6d741b", "filename": "tests/compile-fail/data_race/alloc_read_race.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/tests%2Fcompile-fail%2Fdata_race%2Falloc_read_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/tests%2Fcompile-fail%2Fdata_race%2Falloc_read_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Falloc_read_race.rs?ref=b0e5d5f1efb08ae375e7707cf994c43cadfd4df9", "patch": "@@ -1,4 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n+#![feature(new_uninit)]\n \n use std::thread::spawn;\n use std::ptr::null_mut;\n@@ -29,7 +30,7 @@ pub fn main() {\n             // Uses relaxed semantics to not generate\n             // a release sequence.\n             let pointer = &*ptr.0;\n-            pointer.store(Box::into_raw(Box::new(MaybeUninit::uninit())), Ordering::Relaxed);\n+            pointer.store(Box::into_raw(Box::new_uninit()), Ordering::Relaxed);\n         });\n \n         let j2 = spawn(move || {"}, {"sha": "becebe6a122a97fdf40cc3b695b6222439bc8ddd", "filename": "tests/compile-fail/data_race/alloc_write_race.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/tests%2Fcompile-fail%2Fdata_race%2Falloc_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e5d5f1efb08ae375e7707cf994c43cadfd4df9/tests%2Fcompile-fail%2Fdata_race%2Falloc_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Falloc_write_race.rs?ref=b0e5d5f1efb08ae375e7707cf994c43cadfd4df9", "patch": "@@ -1,4 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n+#![feature(new_uninit)]\n \n use std::thread::spawn;\n use std::ptr::null_mut;\n@@ -10,11 +11,6 @@ struct EvilSend<T>(pub T);\n unsafe impl<T> Send for EvilSend<T> {}\n unsafe impl<T> Sync for EvilSend<T> {}\n \n-extern \"C\" {\n-    fn malloc(size: usize) -> *mut u8;\n-    fn free(ptr: *mut u8);\n-}\n-\n pub fn main() {\n     // Shared atomic pointer\n     let pointer = AtomicPtr::new(null_mut::<usize>());\n@@ -33,7 +29,7 @@ pub fn main() {\n             // Uses relaxed semantics to not generate\n             // a release sequence.\n             let pointer = &*ptr.0;\n-            pointer.store(malloc(std::mem::size_of::<usize>()) as *mut usize, Ordering::Relaxed);\n+            pointer.store(Box::into_raw(Box::<usize>::new_uninit()) as *mut usize, Ordering::Relaxed);\n         });\n \n         let j2 = spawn(move || {\n@@ -45,6 +41,6 @@ pub fn main() {\n         j2.join().unwrap();\n \n         // Clean up memory, will never be executed\n-        free(pointer.load(Ordering::Relaxed) as *mut _);\n+        drop(Box::from_raw(pointer.load(Ordering::Relaxed)));\n     }\n }"}]}