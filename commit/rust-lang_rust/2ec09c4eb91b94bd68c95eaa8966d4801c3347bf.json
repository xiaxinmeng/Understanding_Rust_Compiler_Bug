{"sha": "2ec09c4eb91b94bd68c95eaa8966d4801c3347bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlYzA5YzRlYjkxYjk0YmQ2OGM5NWVhYTg5NjZkNDgwMWMzMzQ3YmY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-13T02:24:56Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-13T02:24:56Z"}, "message": "Objectify the codemap", "tree": {"sha": "74966da5517e5ea005bda5429ff9462f20f4abf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74966da5517e5ea005bda5429ff9462f20f4abf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf", "html_url": "https://github.com/rust-lang/rust/commit/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15a5d2ccbf2de7ac0bb4894a6885791fa1f23521", "url": "https://api.github.com/repos/rust-lang/rust/commits/15a5d2ccbf2de7ac0bb4894a6885791fa1f23521", "html_url": "https://github.com/rust-lang/rust/commit/15a5d2ccbf2de7ac0bb4894a6885791fa1f23521"}], "stats": {"total": 388, "additions": 195, "deletions": 193}, "files": [{"sha": "4879ae30699a18536c6fc0d7e355c92d0f34a2db", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=2ec09c4eb91b94bd68c95eaa8966d4801c3347bf", "patch": "@@ -354,7 +354,7 @@ fn pretty_print_input(sess: Session, cfg: ast::crate_cfg, input: input,\n       ppm_expanded | ppm_normal => pprust::no_ann()\n     };\n     let is_expanded = upto != cu_parse;\n-    let src = codemap::get_filemap(sess.codemap, source_name(input)).src;\n+    let src = sess.codemap.get_filemap(source_name(input)).src;\n     do io::with_str_reader(*src) |rdr| {\n         pprust::print_crate(sess.codemap, sess.parse_sess.interner,\n                             sess.span_diagnostic, crate,\n@@ -574,7 +574,7 @@ fn build_session_options(binary: ~str,\n \n fn build_session(sopts: @session::options,\n                  demitter: diagnostic::emitter) -> Session {\n-    let codemap = @codemap::new_codemap();\n+    let codemap = @codemap::CodeMap::new();\n     let diagnostic_handler =\n         diagnostic::mk_handler(Some(demitter));\n     let span_diagnostic_handler ="}, {"sha": "5aed12dba959412429909efa9019f95313b8a7ae", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=2ec09c4eb91b94bd68c95eaa8966d4801c3347bf", "patch": "@@ -557,7 +557,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n     let add_to_index = |copy ebml_w| add_to_index_(item, ebml_w, index);\n \n     debug!(\"encoding info for item at %s\",\n-           syntax::codemap::span_to_str(item.span, ecx.tcx.sess.codemap));\n+           ecx.tcx.sess.codemap.span_to_str(item.span));\n \n     match item.node {\n       item_const(_, _) => {"}, {"sha": "ed9549cedd7e63ef3b549838165c435625e5a75b", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=2ec09c4eb91b94bd68c95eaa8966d4801c3347bf", "patch": "@@ -97,7 +97,7 @@ use std::map::HashMap;\n use syntax::{visit, ast_util};\n use syntax::print::pprust::{expr_to_str, block_to_str};\n use visit::vt;\n-use syntax::codemap::{span, span_to_str};\n+use syntax::codemap::span;\n use syntax::ast::*;\n use io::WriterUtil;\n use capture::{cap_move, cap_drop, cap_copy, cap_ref};\n@@ -170,9 +170,9 @@ impl LiveNodeKind : cmp::Eq {\n fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n     let cm = cx.sess.codemap;\n     match lnk {\n-        FreeVarNode(s) => fmt!(\"Free var node [%s]\", span_to_str(s, cm)),\n-        ExprNode(s)    => fmt!(\"Expr node [%s]\", span_to_str(s, cm)),\n-        VarDefNode(s)  => fmt!(\"Var def node [%s]\", span_to_str(s, cm)),\n+        FreeVarNode(s) => fmt!(\"Free var node [%s]\", cm.span_to_str(s)),\n+        ExprNode(s)    => fmt!(\"Expr node [%s]\", cm.span_to_str(s)),\n+        VarDefNode(s)  => fmt!(\"Var def node [%s]\", cm.span_to_str(s)),\n         ExitNode       => ~\"Exit node\"\n     }\n }"}, {"sha": "4941885cafb5465b70af0be6448b2e3cf562d996", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=2ec09c4eb91b94bd68c95eaa8966d4801c3347bf", "patch": "@@ -919,7 +919,7 @@ fn trans_trace(bcx: block, sp_opt: Option<span>, trace_str: ~str) {\n     let {V_filename, V_line} = match sp_opt {\n       Some(sp) => {\n         let sess = bcx.sess();\n-        let loc = codemap::lookup_char_pos(sess.parse_sess.cm, sp.lo);\n+        let loc = sess.parse_sess.cm.lookup_char_pos(sp.lo);\n         {V_filename: C_cstr(bcx.ccx(), loc.file.name),\n          V_line: loc.line as int}\n       }"}, {"sha": "f980990517495ff27aa707c029b2976fa6100f10", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=2ec09c4eb91b94bd68c95eaa8966d4801c3347bf", "patch": "@@ -645,7 +645,7 @@ fn _UndefReturn(cx: block, Fn: ValueRef) -> ValueRef {\n fn add_span_comment(bcx: block, sp: span, text: ~str) {\n     let ccx = bcx.ccx();\n     if !ccx.sess.no_asm_comments() {\n-        let s = text + ~\" (\" + codemap::span_to_str(sp, ccx.sess.codemap)\n+        let s = text + ~\" (\" + ccx.sess.codemap.span_to_str(sp)\n             + ~\")\";\n         log(debug, s);\n         add_comment(bcx, s);"}, {"sha": "0c09b02bb07b108da688bff7ae929d6a62c38bec", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=2ec09c4eb91b94bd68c95eaa8966d4801c3347bf", "patch": "@@ -339,7 +339,7 @@ fn trans_fail_value(bcx: block, sp_opt: Option<span>, V_fail_str: ValueRef)\n     let {V_filename, V_line} = match sp_opt {\n       Some(sp) => {\n         let sess = bcx.sess();\n-        let loc = codemap::lookup_char_pos(sess.parse_sess.cm, sp.lo);\n+        let loc = sess.parse_sess.cm.lookup_char_pos(sp.lo);\n         {V_filename: C_cstr(bcx.ccx(), loc.file.name),\n          V_line: loc.line as int}\n       }\n@@ -361,7 +361,7 @@ fn trans_fail_bounds_check(bcx: block, sp: span,\n     let _icx = bcx.insn_ctxt(\"trans_fail_bounds_check\");\n     let ccx = bcx.ccx();\n \n-    let loc = codemap::lookup_char_pos(bcx.sess().parse_sess.cm, sp.lo);\n+    let loc = bcx.sess().parse_sess.cm.lookup_char_pos(sp.lo);\n     let line = C_int(ccx, loc.line as int);\n     let filename_cstr = C_cstr(bcx.ccx(), loc.file.name);\n     let filename = PointerCast(bcx, filename_cstr, T_ptr(T_i8()));"}, {"sha": "2575141f7c45ba27cf96d92de99c2f56e2bf290d", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=2ec09c4eb91b94bd68c95eaa8966d4801c3347bf", "patch": "@@ -230,7 +230,7 @@ fn create_file(cx: @crate_ctxt, full_path: ~str) -> @metadata<file_md> {\n }\n \n fn line_from_span(cm: @codemap::CodeMap, sp: span) -> uint {\n-    codemap::lookup_char_pos(cm, sp.lo).line\n+    cm.lookup_char_pos(sp.lo).line\n }\n \n fn create_block(cx: block) -> @metadata<block_md> {\n@@ -244,9 +244,9 @@ fn create_block(cx: block) -> @metadata<block_md> {\n     }\n     let sp = cx.node_info.get().span;\n \n-    let start = codemap::lookup_char_pos(cx.sess().codemap, sp.lo);\n+    let start = cx.sess().codemap.lookup_char_pos(sp.lo);\n     let fname = start.file.name;\n-    let end = codemap::lookup_char_pos(cx.sess().codemap, sp.hi);\n+    let end = cx.sess().codemap.lookup_char_pos(sp.hi);\n     let tg = LexicalBlockTag;\n     /*alt cached_metadata::<@metadata<block_md>>(\n         cache, tg,\n@@ -597,7 +597,7 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::Ty)\n }\n \n fn filename_from_span(cx: @crate_ctxt, sp: codemap::span) -> ~str {\n-    codemap::lookup_char_pos(cx.sess.codemap, sp.lo).file.name\n+    cx.sess.codemap.lookup_char_pos(sp.lo).file.name\n }\n \n fn create_var(type_tag: int, context: ValueRef, name: ~str, file: ValueRef,\n@@ -629,8 +629,7 @@ fn create_local_var(bcx: block, local: @ast::local)\n       // FIXME this should be handled (#2533)\n       _ => fail ~\"no single variable name for local\"\n     };\n-    let loc = codemap::lookup_char_pos(cx.sess.codemap,\n-                                       local.span.lo);\n+    let loc = cx.sess.codemap.lookup_char_pos(local.span.lo);\n     let ty = node_id_type(bcx, local.node.id);\n     let tymd = create_ty(cx, ty, local.node.ty);\n     let filemd = create_file(cx, loc.file.name);\n@@ -674,8 +673,7 @@ fn create_arg(bcx: block, arg: ast::arg, sp: span)\n       option::None => ()\n     }\n \n-    let loc = codemap::lookup_char_pos(cx.sess.codemap,\n-                                       sp.lo);\n+    let loc = cx.sess.codemap.lookup_char_pos(sp.lo);\n     let ty = node_id_type(bcx, arg.id);\n     let tymd = create_ty(cx, ty, arg.ty);\n     let filemd = create_file(cx, loc.file.name);\n@@ -714,7 +712,7 @@ fn update_source_pos(cx: block, s: span) {\n     }\n     let cm = cx.sess().codemap;\n     let blockmd = create_block(cx);\n-    let loc = codemap::lookup_char_pos(cm, s.lo);\n+    let loc = cm.lookup_char_pos(s.lo);\n     let scopedata = ~[lli32(loc.line as int),\n                      lli32(loc.col as int),\n                      blockmd.node,\n@@ -731,7 +729,7 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     log(debug, fcx.id);\n \n     let sp = fcx.span.get();\n-    log(debug, codemap::span_to_str(sp, cx.sess.codemap));\n+    log(debug, cx.sess.codemap.span_to_str(sp));\n \n     let (ident, ret_ty, id) = match cx.tcx.items.get(fcx.id) {\n       ast_map::node_item(item, _) => {\n@@ -773,8 +771,7 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n       option::None => ()\n     }\n \n-    let loc = codemap::lookup_char_pos(cx.sess.codemap,\n-                                       sp.lo);\n+    let loc = cx.sess.codemap.lookup_char_pos(sp.lo);\n     let file_node = create_file(cx, loc.file.name).node;\n     let ty_node = if cx.sess.opts.extra_debuginfo {\n         match ret_ty.node {"}, {"sha": "652d99779d3120672ca5c38da45383ae075784e8", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=2ec09c4eb91b94bd68c95eaa8966d4801c3347bf", "patch": "@@ -507,7 +507,7 @@ impl RegionVarBindings {\n             self.undo_log.push(AddVar(vid));\n         }\n         debug!(\"created new region variable %? with span %?\",\n-               vid, codemap::span_to_str(span, self.tcx.sess.codemap));\n+               vid, self.tcx.sess.codemap.span_to_str(span));\n         return vid;\n     }\n "}, {"sha": "7ef71c0cc2fc60591a3ecc560f838e15de66b427", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=2ec09c4eb91b94bd68c95eaa8966d4801c3347bf", "patch": "@@ -105,7 +105,7 @@ fn explain_region_and_span(cx: ctxt, region: ty::Region)\n     fn explain_span(cx: ctxt, heading: ~str, span: span)\n         -> (~str, Option<span>)\n     {\n-        let lo = codemap::lookup_char_pos_adj(cx.sess.codemap, span.lo);\n+        let lo = cx.sess.codemap.lookup_char_pos_adj(span.lo);\n         (fmt!(\"the %s at %u:%u\", heading, lo.line, lo.col), Some(span))\n     }\n }\n@@ -131,29 +131,29 @@ fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n     match cx.items.find(node_id) {\n       Some(ast_map::node_block(blk)) => {\n         fmt!(\"<block at %s>\",\n-             codemap::span_to_str(blk.span, cx.sess.codemap))\n+             cx.sess.codemap.span_to_str(blk.span))\n       }\n       Some(ast_map::node_expr(expr)) => {\n         match expr.node {\n           ast::expr_call(*) => {\n             fmt!(\"<call at %s>\",\n-                 codemap::span_to_str(expr.span, cx.sess.codemap))\n+                 cx.sess.codemap.span_to_str(expr.span))\n           }\n           ast::expr_match(*) => {\n             fmt!(\"<alt at %s>\",\n-                 codemap::span_to_str(expr.span, cx.sess.codemap))\n+                 cx.sess.codemap.span_to_str(expr.span))\n           }\n           ast::expr_assign_op(*) |\n           ast::expr_field(*) |\n           ast::expr_unary(*) |\n           ast::expr_binary(*) |\n           ast::expr_index(*) => {\n             fmt!(\"<method at %s>\",\n-                 codemap::span_to_str(expr.span, cx.sess.codemap))\n+                 cx.sess.codemap.span_to_str(expr.span))\n           }\n           _ => {\n             fmt!(\"<expression at %s>\",\n-                 codemap::span_to_str(expr.span, cx.sess.codemap))\n+                 cx.sess.codemap.span_to_str(expr.span))\n           }\n         }\n       }"}, {"sha": "cb97d38b208542d908672b0065b56356a3dd209a", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=2ec09c4eb91b94bd68c95eaa8966d4801c3347bf", "patch": "@@ -120,7 +120,7 @@ fn build_ctxt(sess: Session,\n \n fn build_session() -> Session {\n     let sopts: @options = basic_options();\n-    let codemap = @codemap::new_codemap();\n+    let codemap = @codemap::CodeMap::new();\n     let error_handlers = build_error_handlers(codemap);\n     let {emitter, span_handler} = error_handlers;\n "}, {"sha": "f204cf89e1b573ba3f71db6ad222104a6a863a0d", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 144, "deletions": 139, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=2ec09c4eb91b94bd68c95eaa8966d4801c3347bf", "patch": "@@ -58,6 +58,11 @@ impl file_pos : cmp::Eq {\n     pure fn ne(other: &file_pos) -> bool { !self.eq(other) }\n }\n \n+pub struct file_lines {\n+    file: @filemap,\n+    lines: ~[uint]\n+}\n+\n pub enum file_substr {\n     pub fss_none,\n     pub fss_internal(span),\n@@ -90,173 +95,173 @@ pub impl filemap {\n         return filemap::new_w_substr(filename, fss_none, src,\n                                      start_pos_ch, start_pos_byte);\n     }\n-}\n \n-pub struct CodeMap {\n-    files: DVec<@filemap>\n-}\n+    fn next_line(@self, chpos: uint, byte_pos: uint) {\n+        self.lines.push(file_pos {ch: chpos, byte: byte_pos + self.start_pos.byte});\n+    }\n \n-pub fn new_codemap() -> CodeMap {\n-    CodeMap {\n-        files: DVec()\n+    pub fn get_line(@self, line: int) -> ~str unsafe {\n+        let begin: uint = self.lines[line].byte - self.start_pos.byte;\n+        let end = match str::find_char_from(*self.src, '\\n', begin) {\n+            Some(e) => e,\n+            None => str::len(*self.src)\n+        };\n+        str::slice(*self.src, begin, end)\n     }\n-}\n \n-pub fn mk_substr_filename(cm: @CodeMap, sp: span) -> ~str\n-{\n-    let pos = lookup_char_pos(cm, sp.lo);\n-    return fmt!(\"<%s:%u:%u>\", pos.file.name, pos.line, pos.col);\n }\n \n-pub fn next_line(file: @filemap, chpos: uint, byte_pos: uint) {\n-    file.lines.push(file_pos {ch: chpos, byte: byte_pos + file.start_pos.byte});\n+pub struct CodeMap {\n+    files: DVec<@filemap>\n }\n \n-fn lookup_line(map: @CodeMap, pos: uint, lookup: lookup_fn)\n-    -> {fm: @filemap, line: uint}\n-{\n-    let len = map.files.len();\n-    let mut a = 0u;\n-    let mut b = len;\n-    while b - a > 1u {\n-        let m = (a + b) / 2u;\n-        if lookup(map.files[m].start_pos) > pos { b = m; } else { a = m; }\n-    }\n-    if (a >= len) {\n-        fail fmt!(\"position %u does not resolve to a source location\", pos)\n+pub impl CodeMap {\n+    static pub fn new() -> CodeMap {\n+        CodeMap {\n+            files: DVec()\n+        }\n     }\n-    let f = map.files[a];\n-    a = 0u;\n-    b = vec::len(f.lines);\n-    while b - a > 1u {\n-        let m = (a + b) / 2u;\n-        if lookup(f.lines[m]) > pos { b = m; } else { a = m; }\n+\n+    pub fn mk_substr_filename(@self, sp: span) -> ~str {\n+        let pos = self.lookup_char_pos(sp.lo);\n+        return fmt!(\"<%s:%u:%u>\", pos.file.name, pos.line, pos.col);\n     }\n-    return {fm: f, line: a};\n-}\n \n-fn lookup_pos(map: @CodeMap, pos: uint, lookup: lookup_fn) -> loc {\n-    let {fm: f, line: a} = lookup_line(map, pos, lookup);\n-    return loc {file: f, line: a + 1u, col: pos - lookup(f.lines[a])};\n-}\n+    pub fn lookup_char_pos(@self, pos: uint) -> loc {\n+        pure fn lookup(pos: file_pos) -> uint { return pos.ch; }\n+        return self.lookup_pos(pos, lookup);\n+    }\n \n-pub fn lookup_char_pos(map: @CodeMap, pos: uint) -> loc {\n-    pure fn lookup(pos: file_pos) -> uint { return pos.ch; }\n-    return lookup_pos(map, pos, lookup);\n-}\n+    pub fn lookup_byte_pos(@self, pos: uint) -> loc {\n+        pure fn lookup(pos: file_pos) -> uint { return pos.byte; }\n+        return self.lookup_pos(pos, lookup);\n+    }\n \n-fn lookup_byte_pos(map: @CodeMap, pos: uint) -> loc {\n-    pure fn lookup(pos: file_pos) -> uint { return pos.byte; }\n-    return lookup_pos(map, pos, lookup);\n-}\n+    pub fn lookup_char_pos_adj(@self, pos: uint)\n+        -> {filename: ~str, line: uint, col: uint, file: Option<@filemap>}\n+    {\n+        let loc = self.lookup_char_pos(pos);\n+        match (loc.file.substr) {\n+            fss_none => {\n+                {filename: /* FIXME (#2543) */ copy loc.file.name,\n+                 line: loc.line,\n+                 col: loc.col,\n+                 file: Some(loc.file)}\n+            }\n+            fss_internal(sp) => {\n+                self.lookup_char_pos_adj(sp.lo + (pos - loc.file.start_pos.ch))\n+            }\n+            fss_external(eloc) => {\n+                {filename: /* FIXME (#2543) */ copy eloc.filename,\n+                 line: eloc.line + loc.line - 1u,\n+                 col: if loc.line == 1u {eloc.col + loc.col} else {loc.col},\n+                 file: None}\n+            }\n+        }\n+    }\n \n-pub fn lookup_char_pos_adj(map: @CodeMap, pos: uint)\n-    -> {filename: ~str, line: uint, col: uint, file: Option<@filemap>}\n-{\n-    let loc = lookup_char_pos(map, pos);\n-    match (loc.file.substr) {\n-      fss_none => {\n-        {filename: /* FIXME (#2543) */ copy loc.file.name,\n-         line: loc.line,\n-         col: loc.col,\n-         file: Some(loc.file)}\n-      }\n-      fss_internal(sp) => {\n-        lookup_char_pos_adj(map, sp.lo + (pos - loc.file.start_pos.ch))\n-      }\n-      fss_external(eloc) => {\n-        {filename: /* FIXME (#2543) */ copy eloc.filename,\n-         line: eloc.line + loc.line - 1u,\n-         col: if loc.line == 1u {eloc.col + loc.col} else {loc.col},\n-         file: None}\n-      }\n+    pub fn adjust_span(@self, sp: span) -> span {\n+        pure fn lookup(pos: file_pos) -> uint { return pos.ch; }\n+        let line = self.lookup_line(sp.lo, lookup);\n+        match (line.fm.substr) {\n+            fss_none => sp,\n+            fss_internal(s) => {\n+                self.adjust_span(span {lo: s.lo + (sp.lo - line.fm.start_pos.ch),\n+                                       hi: s.lo + (sp.hi - line.fm.start_pos.ch),\n+                                       expn_info: sp.expn_info})}\n+            fss_external(_) => sp\n+        }\n     }\n-}\n \n-pub fn adjust_span(map: @CodeMap, sp: span) -> span {\n-    pure fn lookup(pos: file_pos) -> uint { return pos.ch; }\n-    let line = lookup_line(map, sp.lo, lookup);\n-    match (line.fm.substr) {\n-      fss_none => sp,\n-      fss_internal(s) => {\n-        adjust_span(map, span {lo: s.lo + (sp.lo - line.fm.start_pos.ch),\n-                               hi: s.lo + (sp.hi - line.fm.start_pos.ch),\n-                               expn_info: sp.expn_info})}\n-      fss_external(_) => sp\n+    pub fn span_to_str(@self, sp: span) -> ~str {\n+        let lo = self.lookup_char_pos_adj(sp.lo);\n+        let hi = self.lookup_char_pos_adj(sp.hi);\n+        return fmt!(\"%s:%u:%u: %u:%u\", lo.filename,\n+                    lo.line, lo.col, hi.line, hi.col)\n     }\n-}\n \n-fn span_to_str_no_adj(sp: span, cm: @CodeMap) -> ~str {\n-    let lo = lookup_char_pos(cm, sp.lo);\n-    let hi = lookup_char_pos(cm, sp.hi);\n-    return fmt!(\"%s:%u:%u: %u:%u\", lo.file.name,\n-             lo.line, lo.col, hi.line, hi.col)\n-}\n+    pub fn span_to_filename(@self, sp: span) -> filename {\n+        let lo = self.lookup_char_pos(sp.lo);\n+        return /* FIXME (#2543) */ copy lo.file.name;\n+    }\n \n-pub fn span_to_str(sp: span, cm: @CodeMap) -> ~str {\n-    let lo = lookup_char_pos_adj(cm, sp.lo);\n-    let hi = lookup_char_pos_adj(cm, sp.hi);\n-    return fmt!(\"%s:%u:%u: %u:%u\", lo.filename,\n-             lo.line, lo.col, hi.line, hi.col)\n-}\n+    pub fn span_to_lines(@self, sp: span) -> @file_lines {\n+        let lo = self.lookup_char_pos(sp.lo);\n+        let hi = self.lookup_char_pos(sp.hi);\n+        let mut lines = ~[];\n+        for uint::range(lo.line - 1u, hi.line as uint) |i| {\n+            lines.push(i);\n+        };\n+        return @file_lines {file: lo.file, lines: lines};\n+    }\n \n-pub struct file_lines {\n-    file: @filemap,\n-    lines: ~[uint]\n-}\n+    fn lookup_byte_offset(@self, chpos: uint)\n+        -> {fm: @filemap, pos: uint} {\n+        pure fn lookup(pos: file_pos) -> uint { return pos.ch; }\n+        let {fm, line} = self.lookup_line(chpos, lookup);\n+        let line_offset = fm.lines[line].byte - fm.start_pos.byte;\n+        let col = chpos - fm.lines[line].ch;\n+        let col_offset = str::count_bytes(*fm.src, line_offset, col);\n+        {fm: fm, pos: line_offset + col_offset}\n+    }\n \n-pub fn span_to_filename(sp: span, cm: @codemap::CodeMap) -> filename {\n-    let lo = lookup_char_pos(cm, sp.lo);\n-    return /* FIXME (#2543) */ copy lo.file.name;\n-}\n+    pub fn span_to_snippet(@self, sp: span) -> ~str {\n+        let begin = self.lookup_byte_offset(sp.lo);\n+        let end = self.lookup_byte_offset(sp.hi);\n+        assert begin.fm.start_pos == end.fm.start_pos;\n+        return str::slice(*begin.fm.src, begin.pos, end.pos);\n+    }\n \n-pub fn span_to_lines(sp: span, cm: @codemap::CodeMap) -> @file_lines {\n-    let lo = lookup_char_pos(cm, sp.lo);\n-    let hi = lookup_char_pos(cm, sp.hi);\n-    let mut lines = ~[];\n-    for uint::range(lo.line - 1u, hi.line as uint) |i| {\n-        lines.push(i);\n-    };\n-    return @file_lines {file: lo.file, lines: lines};\n-}\n+    pub fn get_snippet(@self, fidx: uint, lo: uint, hi: uint) -> ~str\n+    {\n+        let fm = self.files[fidx];\n+        return str::slice(*fm.src, lo, hi)\n+    }\n \n-pub fn get_line(fm: @filemap, line: int) -> ~str unsafe {\n-    let begin: uint = fm.lines[line].byte - fm.start_pos.byte;\n-    let end = match str::find_char_from(*fm.src, '\\n', begin) {\n-      Some(e) => e,\n-      None => str::len(*fm.src)\n-    };\n-    str::slice(*fm.src, begin, end)\n-}\n+    pub fn get_filemap(@self, filename: ~str) -> @filemap {\n+        for self.files.each |fm| { if fm.name == filename { return *fm; } }\n+        //XXjdm the following triggers a mismatched type bug\n+        //      (or expected function, found _|_)\n+        fail; // (\"asking for \" + filename + \" which we don't know about\");\n+    }\n \n-fn lookup_byte_offset(cm: @codemap::CodeMap, chpos: uint)\n-    -> {fm: @filemap, pos: uint} {\n-    pure fn lookup(pos: file_pos) -> uint { return pos.ch; }\n-    let {fm, line} = lookup_line(cm, chpos, lookup);\n-    let line_offset = fm.lines[line].byte - fm.start_pos.byte;\n-    let col = chpos - fm.lines[line].ch;\n-    let col_offset = str::count_bytes(*fm.src, line_offset, col);\n-    {fm: fm, pos: line_offset + col_offset}\n }\n \n-pub fn span_to_snippet(sp: span, cm: @codemap::CodeMap) -> ~str {\n-    let begin = lookup_byte_offset(cm, sp.lo);\n-    let end = lookup_byte_offset(cm, sp.hi);\n-    assert begin.fm.start_pos == end.fm.start_pos;\n-    return str::slice(*begin.fm.src, begin.pos, end.pos);\n-}\n+priv impl CodeMap {\n+    fn lookup_line(@self, pos: uint, lookup: lookup_fn)\n+        -> {fm: @filemap, line: uint}\n+    {\n+        let len = self.files.len();\n+        let mut a = 0u;\n+        let mut b = len;\n+        while b - a > 1u {\n+            let m = (a + b) / 2u;\n+            if lookup(self.files[m].start_pos) > pos { b = m; } else { a = m; }\n+        }\n+        if (a >= len) {\n+            fail fmt!(\"position %u does not resolve to a source location\", pos)\n+        }\n+        let f = self.files[a];\n+        a = 0u;\n+        b = vec::len(f.lines);\n+        while b - a > 1u {\n+            let m = (a + b) / 2u;\n+            if lookup(f.lines[m]) > pos { b = m; } else { a = m; }\n+        }\n+        return {fm: f, line: a};\n+    }\n \n-pub fn get_snippet(cm: @codemap::CodeMap, fidx: uint, lo: uint, hi: uint) -> ~str\n-{\n-    let fm = cm.files[fidx];\n-    return str::slice(*fm.src, lo, hi)\n-}\n+    fn lookup_pos(@self, pos: uint, lookup: lookup_fn) -> loc {\n+        let {fm: f, line: a} = self.lookup_line(pos, lookup);\n+        return loc {file: f, line: a + 1u, col: pos - lookup(f.lines[a])};\n+    }\n \n-pub fn get_filemap(cm: @CodeMap, filename: ~str) -> @filemap {\n-    for cm.files.each |fm| { if fm.name == filename { return *fm; } }\n-    //XXjdm the following triggers a mismatched type bug\n-    //      (or expected function, found _|_)\n-    fail; // (\"asking for \" + filename + \" which we don't know about\");\n+    fn span_to_str_no_adj(@self, sp: span) -> ~str {\n+        let lo = self.lookup_char_pos(sp.lo);\n+        let hi = self.lookup_char_pos(sp.hi);\n+        return fmt!(\"%s:%u:%u: %u:%u\", lo.file.name,\n+                    lo.line, lo.col, hi.line, hi.col)\n+    }\n }\n \n //"}, {"sha": "66c59683813a8c4c00e7eb2acde3a389d08fcaaf", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=2ec09c4eb91b94bd68c95eaa8966d4801c3347bf", "patch": "@@ -192,9 +192,9 @@ fn print_diagnostic(topic: ~str, lvl: level, msg: &str) {\n fn emit(cmsp: Option<(@codemap::CodeMap, span)>, msg: &str, lvl: level) {\n     match cmsp {\n       Some((cm, sp)) => {\n-        let sp = codemap::adjust_span(cm,sp);\n-        let ss = codemap::span_to_str(sp, cm);\n-        let lines = codemap::span_to_lines(sp, cm);\n+        let sp = cm.adjust_span(sp);\n+        let ss = cm.span_to_str(sp);\n+        let lines = cm.span_to_lines(sp);\n         print_diagnostic(ss, lvl, msg);\n         highlight_lines(cm, sp, lines);\n         print_macro_backtrace(cm, sp);\n@@ -221,7 +221,7 @@ fn highlight_lines(cm: @codemap::CodeMap, sp: span,\n     // Print the offending lines\n     for display_lines.each |line| {\n         io::stderr().write_str(fmt!(\"%s:%u \", fm.name, *line + 1u));\n-        let s = codemap::get_line(fm, *line as int) + ~\"\\n\";\n+        let s = fm.get_line(*line as int) + ~\"\\n\";\n         io::stderr().write_str(s);\n     }\n     if elided {\n@@ -237,7 +237,7 @@ fn highlight_lines(cm: @codemap::CodeMap, sp: span,\n \n     // If there's one line at fault we can easily point to the problem\n     if vec::len(lines.lines) == 1u {\n-        let lo = codemap::lookup_char_pos(cm, sp.lo);\n+        let lo = cm.lookup_char_pos(sp.lo);\n         let mut digits = 0u;\n         let mut num = (lines.lines[0] + 1u) / 10u;\n \n@@ -250,7 +250,7 @@ fn highlight_lines(cm: @codemap::CodeMap, sp: span,\n         while left > 0u { str::push_char(&mut s, ' '); left -= 1u; }\n \n         s += ~\"^\";\n-        let hi = codemap::lookup_char_pos(cm, sp.hi);\n+        let hi = cm.lookup_char_pos(sp.hi);\n         if hi.col != lo.col {\n             // the ^ already takes up one space\n             let mut width = hi.col - lo.col - 1u;\n@@ -263,10 +263,10 @@ fn highlight_lines(cm: @codemap::CodeMap, sp: span,\n fn print_macro_backtrace(cm: @codemap::CodeMap, sp: span) {\n     do option::iter(&sp.expn_info) |ei| {\n         let ss = option::map_default(&ei.callie.span, @~\"\",\n-                                     |span| @codemap::span_to_str(*span, cm));\n+                                     |span| @cm.span_to_str(*span));\n         print_diagnostic(*ss, note,\n                          fmt!(\"in expansion of %s!\", ei.callie.name));\n-        let ss = codemap::span_to_str(ei.call_site, cm);\n+        let ss = cm.span_to_str(ei.call_site);\n         print_diagnostic(ss, note, ~\"expansion site\");\n         print_macro_backtrace(cm, ei.call_site);\n     }"}, {"sha": "6ae083779cd1b174de15f2bed20d2a54b264b6fa", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=2ec09c4eb91b94bd68c95eaa8966d4801c3347bf", "patch": "@@ -204,13 +204,13 @@ fn finish<T: qq_helper>\n     -> @ast::expr\n {\n     let cm = ecx.codemap();\n-    let str = @codemap::span_to_snippet(body.span, cm);\n+    let str = @cm.span_to_snippet(body.span);\n     debug!(\"qquote--str==%?\", str);\n-    let fname = codemap::mk_substr_filename(cm, body.span);\n+    let fname = cm.mk_substr_filename(body.span);\n     let node = parse_from_source_str\n         (f, fname, codemap::fss_internal(body.span), str,\n          ecx.cfg(), ecx.parse_sess());\n-    let loc = codemap::lookup_char_pos(cm, body.span.lo);\n+    let loc = cm.lookup_char_pos(body.span.lo);\n \n     let sp = node.span();\n     let qcx = gather_anti_quotes(sp.lo, node);"}, {"sha": "8c5048b4c6f7ae4c322121f90df5adb99e7c9475", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=2ec09c4eb91b94bd68c95eaa8966d4801c3347bf", "patch": "@@ -16,15 +16,15 @@ export expand_include_bin;\n fn expand_line(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                _body: ast::mac_body) -> @ast::expr {\n     get_mac_args(cx, sp, arg, 0u, option::Some(0u), ~\"line\");\n-    let loc = codemap::lookup_char_pos(cx.codemap(), sp.lo);\n+    let loc = cx.codemap().lookup_char_pos(sp.lo);\n     return mk_uint(cx, sp, loc.line);\n }\n \n /* col!(): expands to the current column number */\n fn expand_col(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n               _body: ast::mac_body) -> @ast::expr {\n     get_mac_args(cx, sp, arg, 0u, option::Some(0u), ~\"col\");\n-    let loc = codemap::lookup_char_pos(cx.codemap(), sp.lo);\n+    let loc = cx.codemap().lookup_char_pos(sp.lo);\n     return mk_uint(cx, sp, loc.col);\n }\n \n@@ -35,7 +35,7 @@ fn expand_file(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                _body: ast::mac_body) -> @ast::expr {\n     get_mac_args(cx, sp, arg, 0u, option::Some(0u), ~\"file\");\n     let loc { file: @filemap { name: filename, _ }, _ } =\n-        codemap::lookup_char_pos(cx.codemap(), sp.lo);\n+        cx.codemap().lookup_char_pos(sp.lo);\n     return mk_uniq_str(cx, sp, filename);\n }\n \n@@ -103,7 +103,7 @@ fn expand_include_bin(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n fn res_rel_file(cx: ext_ctxt, sp: codemap::span, arg: &Path) -> Path {\n     // NB: relative paths are resolved relative to the compilation unit\n     if !arg.is_absolute {\n-        let cu = Path(codemap::span_to_filename(sp, cx.codemap()));\n+        let cu = Path(cx.codemap().span_to_filename(sp));\n         cu.dir_path().push_many(arg.components)\n     } else {\n         copy *arg"}, {"sha": "3f15a5b6e88649f0b0154223b391ef7cdcfb4ee7", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=2ec09c4eb91b94bd68c95eaa8966d4801c3347bf", "patch": "@@ -20,7 +20,7 @@ use util::interner;\n use diagnostic::{span_handler, mk_span_handler, mk_handler, emitter};\n use lexer::{reader, string_reader};\n use parse::token::{ident_interner, mk_ident_interner};\n-use codemap::filemap;\n+use codemap::{CodeMap, filemap};\n \n type parse_sess = @{\n     cm: @codemap::CodeMap,\n@@ -33,7 +33,7 @@ type parse_sess = @{\n };\n \n fn new_parse_sess(demitter: Option<emitter>) -> parse_sess {\n-    let cm = @codemap::new_codemap();\n+    let cm = @CodeMap::new();\n     return @{cm: cm,\n              mut next_id: 1,\n              span_diagnostic: mk_span_handler(mk_handler(demitter), cm),"}, {"sha": "1c984ad57b1f926dde88d6181aee9083357b738e", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=2ec09c4eb91b94bd68c95eaa8966d4801c3347bf", "patch": "@@ -1,5 +1,5 @@\n use diagnostic::span_handler;\n-use codemap::span;\n+use codemap::{span, CodeMap};\n use ext::tt::transcribe::{tt_reader,  new_tt_reader, dup_tt_reader,\n                              tt_next_token};\n \n@@ -135,7 +135,7 @@ fn bump(rdr: string_reader) {\n         rdr.col += 1u;\n         rdr.chpos += 1u;\n         if rdr.curr == '\\n' {\n-            codemap::next_line(rdr.filemap, rdr.chpos, rdr.pos);\n+            rdr.filemap.next_line(rdr.chpos, rdr.pos);\n             rdr.col = 0u;\n         }\n         let next = str::char_range_at(*rdr.src, rdr.pos);\n@@ -232,9 +232,9 @@ fn consume_any_line_comment(rdr: string_reader)\n         }\n     } else if rdr.curr == '#' {\n         if nextch(rdr) == '!' {\n-            let cmap = @codemap::new_codemap();\n+            let cmap = @CodeMap::new();\n             (*cmap).files.push(rdr.filemap);\n-            let loc = codemap::lookup_char_pos_adj(cmap, rdr.chpos);\n+            let loc = cmap.lookup_char_pos_adj(rdr.chpos);\n             if loc.line == 1u && loc.col == 0u {\n                 while rdr.curr != '\\n' && !is_eof(rdr) { bump(rdr); }\n                 return consume_whitespace_and_comments(rdr);"}, {"sha": "8fa7543b2d1334e042cde80350cc896cac8822b0", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ec09c4eb91b94bd68c95eaa8966d4801c3347bf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=2ec09c4eb91b94bd68c95eaa8966d4801c3347bf", "patch": "@@ -1904,8 +1904,8 @@ fn maybe_print_trailing_comment(s: ps, span: codemap::span,\n     match next_comment(s) {\n       Some(cmnt) => {\n         if cmnt.style != comments::trailing { return; }\n-        let span_line = codemap::lookup_char_pos(cm, span.hi);\n-        let comment_line = codemap::lookup_char_pos(cm, cmnt.pos);\n+        let span_line = cm.lookup_char_pos(span.hi);\n+        let comment_line = cm.lookup_char_pos(cmnt.pos);\n         let mut next = cmnt.pos + 1u;\n         match next_pos { None => (), Some(p) => next = p }\n         if span.hi < cmnt.pos && cmnt.pos < next &&"}]}