{"sha": "ff41359e6535ca7dc1261f282b1601136fedee21", "node_id": "C_kwDOAAsO6NoAKGZmNDEzNTllNjUzNWNhN2RjMTI2MWYyODJiMTYwMTEzNmZlZGVlMjE", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-12-09T17:08:56Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-12-14T20:32:42Z"}, "message": "address review", "tree": {"sha": "4195ccf6503da1121ad55714ae600ecc879aa878", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4195ccf6503da1121ad55714ae600ecc879aa878"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff41359e6535ca7dc1261f282b1601136fedee21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff41359e6535ca7dc1261f282b1601136fedee21", "html_url": "https://github.com/rust-lang/rust/commit/ff41359e6535ca7dc1261f282b1601136fedee21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff41359e6535ca7dc1261f282b1601136fedee21/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc93a28e98e6bdcb73441ec699f43aa01d10e4e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc93a28e98e6bdcb73441ec699f43aa01d10e4e6", "html_url": "https://github.com/rust-lang/rust/commit/dc93a28e98e6bdcb73441ec699f43aa01d10e4e6"}], "stats": {"total": 151, "additions": 60, "deletions": 91}, "files": [{"sha": "b7a5f9c8757bab671be6f4d61a65227d73f6745e", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ff41359e6535ca7dc1261f282b1601136fedee21/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff41359e6535ca7dc1261f282b1601136fedee21/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=ff41359e6535ca7dc1261f282b1601136fedee21", "patch": "@@ -875,6 +875,13 @@ pub struct Place<'tcx> {\n     pub projection: &'tcx List<PlaceElem<'tcx>>,\n }\n \n+/// The different kinds of projections that can be used in the projection of a `Place`.\n+///\n+/// `T1` is the generic type for a field projection. For an actual projection on a `Place`\n+/// this parameter will always be `Ty`, but the field type can be unavailable when\n+/// building (by using `PlaceBuilder`) places that correspond to upvars.\n+/// `T2` is the generic type for an `OpaqueCast` (is generic since it's abstracted over\n+/// in dataflow analysis, see `AbstractElem`).\n #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n #[derive(TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n pub enum ProjectionElem<V, T1, T2> {\n@@ -942,7 +949,7 @@ pub enum ProjectionElem<V, T1, T2> {\n /// and the index is a local.\n pub type PlaceElem<'tcx> = ProjectionElem<Local, Ty<'tcx>, Ty<'tcx>>;\n \n-/// Alias for projections that appear in `PlaceBuilder::UpVar`, for which\n+/// Alias for projections that appear in `PlaceBuilder::Upvar`, for which\n /// we cannot provide any field types.\n pub type UpvarProjectionElem<'tcx> = ProjectionElem<Local, (), Ty<'tcx>>;\n "}, {"sha": "8a35478dd8b3412c648cc7ba8eceebab25cb8eaf", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 48, "deletions": 85, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/ff41359e6535ca7dc1261f282b1601136fedee21/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff41359e6535ca7dc1261f282b1601136fedee21/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=ff41359e6535ca7dc1261f282b1601136fedee21", "patch": "@@ -33,7 +33,7 @@ pub(in crate::build) enum PlaceBuilder<'tcx> {\n     /// Denotes the start of a `Place`.\n     ///\n     /// We use `PlaceElem` since this has all `Field` types available.\n-    Local(Local, Vec<PlaceElem<'tcx>>),\n+    Local { local: Local, projection: Vec<PlaceElem<'tcx>> },\n \n     /// When building place for an expression within a closure, the place might start off a\n     /// captured path. When `capture_disjoint_fields` is enabled, we might not know the capture\n@@ -67,11 +67,11 @@ pub(in crate::build) enum PlaceBuilder<'tcx> {\n     ///\n     /// Note: in contrast to `PlaceBuilder::Local` we have not yet determined all `Field` types\n     /// and will only do so once converting to `PlaceBuilder::Local`.\n-    UpVar(UpVar, Vec<UpvarProjectionElem<'tcx>>),\n+    Upvar { upvar: Upvar, projection: Vec<UpvarProjectionElem<'tcx>> },\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n-pub(crate) struct UpVar {\n+pub(crate) struct Upvar {\n     var_hir_id: LocalVarId,\n     closure_def_id: LocalDefId,\n }\n@@ -222,36 +222,7 @@ fn to_upvars_resolved_place_builder<'tcx>(\n         upvar_projection,\n     );\n \n-    debug_assert!({\n-        let builder = upvar_resolved_place_builder.clone();\n-        let mut valid_conversion = true;\n-        match builder {\n-            PlaceBuilder::Local(_, projections) => {\n-                for proj in projections.iter() {\n-                    match proj {\n-                        ProjectionElem::Field(_, field_ty) => {\n-                            if matches!(field_ty.kind(), ty::Infer(..)) {\n-                                debug!(\n-                                    \"field ty should have been converted for projection {:?} in PlaceBuilder {:?}\",\n-                                    proj,\n-                                    upvar_resolved_place_builder.clone()\n-                                );\n-\n-                                valid_conversion = false;\n-                                break;\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n-            PlaceBuilder::UpVar(..) => {\n-                unreachable!()\n-            }\n-        }\n-\n-        valid_conversion\n-    });\n+    assert!(matches!(upvar_resolved_place_builder, PlaceBuilder::Local { .. }));\n \n     Some(upvar_resolved_place_builder)\n }\n@@ -269,9 +240,9 @@ fn strip_prefix<'a, 'tcx>(\n ) -> impl Iterator<Item = UpvarProjectionElem<'tcx>> + 'a {\n     let mut iter = projections\n         .iter()\n+        .copied()\n         // Filter out opaque casts, they are unnecessary in the prefix.\n-        .filter(|elem| !matches!(elem, ProjectionElem::OpaqueCast(..)))\n-        .map(|elem| *elem);\n+        .filter(|elem| !matches!(elem, ProjectionElem::OpaqueCast(..)));\n     for projection in prefix_projections {\n         debug!(?projection, ?projection.ty);\n \n@@ -305,8 +276,8 @@ impl<'tcx> PlaceBuilder<'tcx> {\n     pub(in crate::build) fn try_to_place(&self, cx: &Builder<'_, 'tcx>) -> Option<Place<'tcx>> {\n         let resolved = self.resolve_upvar(cx);\n         let builder = resolved.as_ref().unwrap_or(self);\n-        let PlaceBuilder::Local(local, projection) = builder else { return None };\n-        let projection = cx.tcx.intern_place_elems(&projection);\n+        let PlaceBuilder::Local{local, ref projection} = builder else { return None };\n+        let projection = cx.tcx.intern_place_elems(projection);\n         Some(Place { local: *local, projection })\n     }\n \n@@ -324,40 +295,31 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         &self,\n         cx: &Builder<'_, 'tcx>,\n     ) -> Option<PlaceBuilder<'tcx>> {\n-        let PlaceBuilder::UpVar( UpVar {var_hir_id, closure_def_id }, projection) = self else {\n+        let PlaceBuilder::Upvar{ upvar: Upvar {var_hir_id, closure_def_id }, projection} = self else {\n             return None;\n         };\n \n         to_upvars_resolved_place_builder(cx, *var_hir_id, *closure_def_id, &projection)\n     }\n \n-    pub(crate) fn get_local_projection(&self) -> &[PlaceElem<'tcx>] {\n-        match self {\n-            Self::Local(_, projection) => projection,\n-            Self::UpVar(..) => {\n-                bug!(\"get_local_projection_mut can only be called on PlaceBuilder::Local\")\n-            }\n-        }\n-    }\n-\n     #[instrument(skip(cx), level = \"debug\")]\n     pub(crate) fn field(self, cx: &Builder<'_, 'tcx>, f: Field) -> Self {\n-        let field_ty = match self.clone() {\n-            PlaceBuilder::Local(local, projection) => {\n-                let base_place = PlaceBuilder::Local(local, projection);\n+        match self.clone() {\n+            PlaceBuilder::Local { local, projection } => {\n+                let base_place = PlaceBuilder::Local { local, projection };\n                 let PlaceTy { ty, variant_index } =\n                     base_place.to_place(cx).ty(&cx.local_decls, cx.tcx);\n                 let base_ty = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n \n-                PlaceBuilder::compute_field_ty(cx, f, base_ty, variant_index)\n+                let field_ty = PlaceBuilder::compute_field_ty(cx, f, base_ty, variant_index);\n+\n+                self.project(ProjectionElem::Field(f, field_ty))\n             }\n-            PlaceBuilder::UpVar(..) => {\n-                let dummy_ty = cx.tcx.mk_ty_infer(ty::FreshTy(0));\n-                dummy_ty\n+            PlaceBuilder::Upvar { upvar, mut projection } => {\n+                projection.push(ProjectionElem::Field(f, ()));\n+                PlaceBuilder::Upvar { upvar, projection }\n             }\n-        };\n-\n-        self.project(ProjectionElem::Field(f, field_ty))\n+        }\n     }\n \n     pub(crate) fn deref(self) -> Self {\n@@ -375,13 +337,13 @@ impl<'tcx> PlaceBuilder<'tcx> {\n     #[instrument(level = \"debug\")]\n     pub(crate) fn project(self, elem: PlaceElem<'tcx>) -> Self {\n         let result = match self {\n-            PlaceBuilder::Local(local, mut proj) => {\n-                proj.push(elem);\n-                PlaceBuilder::Local(local, proj)\n+            PlaceBuilder::Local { local, mut projection } => {\n+                projection.push(elem);\n+                PlaceBuilder::Local { local, projection }\n             }\n-            PlaceBuilder::UpVar(upvar, mut proj) => {\n-                proj.push(elem.into());\n-                PlaceBuilder::UpVar(upvar, proj)\n+            PlaceBuilder::Upvar { upvar, mut projection } => {\n+                projection.push(elem.into());\n+                PlaceBuilder::Upvar { upvar, projection }\n             }\n         };\n \n@@ -392,14 +354,14 @@ impl<'tcx> PlaceBuilder<'tcx> {\n     /// Same as `.clone().project(..)` but more efficient\n     pub(crate) fn clone_project(&self, elem: PlaceElem<'tcx>) -> Self {\n         match self {\n-            PlaceBuilder::Local(local, proj) => PlaceBuilder::Local(\n-                *local,\n-                Vec::from_iter(proj.iter().copied().chain([elem.into()])),\n-            ),\n-            PlaceBuilder::UpVar(upvar, proj) => PlaceBuilder::UpVar(\n-                *upvar,\n-                Vec::from_iter(proj.iter().copied().chain([elem.into()])),\n-            ),\n+            PlaceBuilder::Local { local, projection } => PlaceBuilder::Local {\n+                local: *local,\n+                projection: Vec::from_iter(projection.iter().copied().chain([elem.into()])),\n+            },\n+            PlaceBuilder::Upvar { upvar, projection } => PlaceBuilder::Upvar {\n+                upvar: *upvar,\n+                projection: Vec::from_iter(projection.iter().copied().chain([elem.into()])),\n+            },\n         }\n     }\n \n@@ -463,7 +425,11 @@ impl<'tcx> PlaceBuilder<'tcx> {\n                     f_ty\n                 } else {\n                     let Some(f_ty) = substs.as_generator().prefix_tys().nth(field.index()) else {\n-                        bug!(\"expected to take index {:?} in {:?}\", field.index(), substs.as_generator().prefix_tys().collect::<Vec<_>>());\n+                        bug!(\n+                            \"expected to take index {:?} in {:?}\",\n+                            field.index(),\n+                            substs.as_generator().prefix_tys().collect::<Vec<_>>()\n+                        );\n                     };\n \n                     f_ty\n@@ -475,7 +441,7 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         cx.tcx.normalize_erasing_regions(cx.param_env, field_ty)\n     }\n \n-    /// Creates a `PlaceBuilder::Local` from a `PlaceBuilder::UpVar` whose upvars\n+    /// Creates a `PlaceBuilder::Local` from a `PlaceBuilder::Upvar` whose upvars\n     /// are resolved. This function takes two kinds of projections: `local_projection`\n     /// contains the projections of the captured upvar and `upvar_projection` the\n     /// projections that are applied to the captured upvar. The main purpose of this\n@@ -516,19 +482,19 @@ impl<'tcx> PlaceBuilder<'tcx> {\n             }\n         }\n \n-        PlaceBuilder::Local(local, local_projection)\n+        PlaceBuilder::Local { local, projection: local_projection }\n     }\n }\n \n impl<'tcx> From<Local> for PlaceBuilder<'tcx> {\n     fn from(local: Local) -> Self {\n-        Self::Local(local, Vec::new())\n+        Self::Local { local, projection: Vec::new() }\n     }\n }\n \n impl<'tcx> From<Place<'tcx>> for PlaceBuilder<'tcx> {\n     fn from(p: Place<'tcx>) -> Self {\n-        Self::Local(p.local, p.projection.to_vec())\n+        Self::Local { local: p.local, projection: p.projection.to_vec() }\n     }\n }\n \n@@ -564,13 +530,7 @@ fn project_ty<'tcx>(\n             (ty, None)\n         }\n         ProjectionElem::Downcast(_, variant_idx) => (ty, Some(variant_idx)),\n-        ProjectionElem::Field(_, ty) => {\n-            if matches!(ty.kind(), ty::Infer(..)) {\n-                bug!(\"Field ty should have been resolved\");\n-            }\n-\n-            (ty, None)\n-        }\n+        ProjectionElem::Field(_, ty) => (ty, None),\n         ProjectionElem::OpaqueCast(..) => bug!(\"didn't expect OpaqueCast\"),\n     }\n }\n@@ -836,15 +796,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /// Lower a captured upvar. Note we might not know the actual capture index,\n-    /// so we create a place starting from `UpVar`, which will be resolved\n+    /// so we create a place starting from `Upvar`, which will be resolved\n     /// once all projections that allow us to identify a capture have been applied.\n     fn lower_captured_upvar(\n         &mut self,\n         block: BasicBlock,\n         closure_def_id: LocalDefId,\n         var_hir_id: LocalVarId,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n-        block.and(PlaceBuilder::UpVar(UpVar { var_hir_id, closure_def_id }, vec![]))\n+        block.and(PlaceBuilder::Upvar {\n+            upvar: Upvar { var_hir_id, closure_def_id },\n+            projection: vec![],\n+        })\n     }\n \n     /// Lower an index expression"}, {"sha": "b3fd054a00a5c02ab4ff08a8a00d382ce2805286", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff41359e6535ca7dc1261f282b1601136fedee21/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff41359e6535ca7dc1261f282b1601136fedee21/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=ff41359e6535ca7dc1261f282b1601136fedee21", "patch": "@@ -654,11 +654,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // We are capturing a path that starts off a local variable in the parent.\n             // The mutability of the current capture is same as the mutability\n             // of the local declaration in the parent.\n-            PlaceBuilder::Local(local, _) => this.local_decls[local].mutability,\n+            PlaceBuilder::Local { local, .. } => this.local_decls[local].mutability,\n             // Parent is a closure and we are capturing a path that is captured\n             // by the parent itself. The mutability of the current capture\n             // is same as that of the capture in the parent closure.\n-            PlaceBuilder::UpVar(..) => {\n+            PlaceBuilder::Upvar { .. } => {\n                 let enclosing_upvars_resolved = arg_place_builder.to_place(this);\n \n                 match enclosing_upvars_resolved.as_ref() {"}, {"sha": "e48c6b2457be3a38de468b05d1cf356db8fb8408", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff41359e6535ca7dc1261f282b1601136fedee21/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff41359e6535ca7dc1261f282b1601136fedee21/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=ff41359e6535ca7dc1261f282b1601136fedee21", "patch": "@@ -108,9 +108,8 @@ impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n         // Only add the OpaqueCast projection if the given place is an opaque type and the\n         // expected type from the pattern is not.\n         let may_need_cast = match place {\n-            PlaceBuilder::Local(local, _) => {\n-                let ty =\n-                    Place::ty_from(local, place.get_local_projection(), &cx.local_decls, cx.tcx).ty;\n+            PlaceBuilder::Local { local, ref projection } => {\n+                let ty = Place::ty_from(local, projection, &cx.local_decls, cx.tcx).ty;\n                 ty != pattern.ty && ty.has_opaque_types()\n             }\n             _ => true,"}]}