{"sha": "6b549f9f147b18eaeb3a4c185e45ccd8ae310b09", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiNTQ5ZjlmMTQ3YjE4ZWFlYjNhNGMxODVlNDVjY2Q4YWUzMTBiMDk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-17T15:40:06Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-17T19:02:36Z"}, "message": "repair LUB/GLB of free/scope regions, and enable test", "tree": {"sha": "c9fc9bb0d9a166bb8f61675a019a80c728a97114", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9fc9bb0d9a166bb8f61675a019a80c728a97114"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b549f9f147b18eaeb3a4c185e45ccd8ae310b09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b549f9f147b18eaeb3a4c185e45ccd8ae310b09", "html_url": "https://github.com/rust-lang/rust/commit/6b549f9f147b18eaeb3a4c185e45ccd8ae310b09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b549f9f147b18eaeb3a4c185e45ccd8ae310b09/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58f8cb343d384b52ade37235aec40f1f0fec1df4", "url": "https://api.github.com/repos/rust-lang/rust/commits/58f8cb343d384b52ade37235aec40f1f0fec1df4", "html_url": "https://github.com/rust-lang/rust/commit/58f8cb343d384b52ade37235aec40f1f0fec1df4"}], "stats": {"total": 115, "additions": 74, "deletions": 41}, "files": [{"sha": "24130a560488aedeb249b378309dbfe07faa2727", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 68, "deletions": 33, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/6b549f9f147b18eaeb3a4c185e45ccd8ae310b09/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b549f9f147b18eaeb3a4c185e45ccd8ae310b09/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=6b549f9f147b18eaeb3a4c185e45ccd8ae310b09", "patch": "@@ -1373,23 +1373,28 @@ impl of combine for lub {\n                 ok(ty::re_static) // nothing lives longer than static\n               }\n \n-              (ty::re_var(a_id), ty::re_var(b_id)) {\n-                lattice_vars(self, self.infcx().rb,\n-                           a, a_id, b_id,\n-                           {|x, y| self.regions(x, y) })\n-              }\n-\n-              (ty::re_var(v_id), r) | (r, ty::re_var(v_id)) {\n-                lattice_var_t(self, self.infcx().rb,\n-                              v_id, r,\n-                              {|x, y| self.regions(x, y) })\n+              (ty::re_var(_), _) | (_, ty::re_var(_)) {\n+                lattice_rvars(self, a, b)\n               }\n \n-              (f @ ty::re_free(f_id, f_br), ty::re_scope(s_id)) |\n-              (ty::re_scope(s_id), f @ ty::re_free(f_id, f_br)) {\n-                // for LUB, the scope is within the function and the free\n-                // region is always a parameter to the method.\n-                ok(f) // NDM--not so for nested functions\n+              (f @ ty::re_free(f_id, _), ty::re_scope(s_id)) |\n+              (ty::re_scope(s_id), f @ ty::re_free(f_id, _)) {\n+                // For LUB, generally the scope is within the fn and\n+                // the free region is a parameter to the fn.  In that case,\n+                // the free region will always live as long as the fn,\n+                // which is longer than the scope.\n+                //\n+                // However, with nested fns, it can happen that the\n+                // scope surrounds the fn itself.  In that case, we do\n+                // not know which will live longer---it depends on the\n+                // value provided for the free region in any given\n+                // call.  And so we must just back off to re_static as\n+                // the LUB.\n+                let rm = self.infcx().tcx.region_map;\n+                alt region::nearest_common_ancestor(rm, f_id, s_id) {\n+                  some(r_id) if r_id == f_id { ok(f) }\n+                  _ { ok(ty::re_static) }\n+                }\n               }\n \n               (ty::re_scope(a_id), ty::re_scope(b_id)) {\n@@ -1399,7 +1404,7 @@ impl of combine for lub {\n                 let rm = self.infcx().tcx.region_map;\n                 alt region::nearest_common_ancestor(rm, a_id, b_id) {\n                   some(r_id) { ok(ty::re_scope(r_id)) }\n-                  _ { err(ty::terr_regions_differ(b, a)) }\n+                  _ { ok(ty::re_static) }\n                 }\n               }\n \n@@ -1414,7 +1419,7 @@ impl of combine for lub {\n                 if a == b {\n                     ok(a)\n                 } else {\n-                    err(ty::terr_regions_differ(b, a))\n+                    ok(ty::re_static)\n                 }\n               }\n             }\n@@ -1551,24 +1556,26 @@ impl of combine for glb {\n                 ok(r)\n               }\n \n-              (ty::re_var(a_id), ty::re_var(b_id)) {\n-                lattice_vars(self, self.infcx().rb,\n-                             a, a_id, b_id,\n-                             {|x, y| self.regions(x, y) })\n-              }\n-\n-              (ty::re_var(v_id), r) | (r, ty::re_var(v_id)) {\n-                lattice_var_t(self, self.infcx().rb,\n-                              v_id, r,\n-                              {|x, y| self.regions(x, y) })\n+              (ty::re_var(_), _) | (_, ty::re_var(_)) {\n+                lattice_rvars(self, a, b)\n               }\n \n-              (f @ ty::re_free(f_id, f_br), ty::re_scope(s_id)) |\n-              (ty::re_scope(s_id), f @ ty::re_free(f_id, f_br)) {\n-                // for GLB, the scope is within the function and the free\n-                // region is always a parameter to the method.  So the GLB\n-                // must be the scope.\n-                ok(b) // NDM--not so for nested functions\n+              (ty::re_free(f_id, _), s @ ty::re_scope(s_id)) |\n+              (s @ ty::re_scope(s_id), ty::re_free(f_id, _)) {\n+                // For GLB, generally the scope is within the fn and\n+                // the free region is a parameter to the fn.  In that case,\n+                // the scope is always shorter than the free region.\n+                //\n+                // However, with nested fns, it can happen that the\n+                // scope surrounds the fn itself.  In that case, we do\n+                // not know which will live longer---it depends on the\n+                // value provided for the free region in any given\n+                // call.  And so we cannot give a GLB.\n+                let rm = self.infcx().tcx.region_map;\n+                alt region::nearest_common_ancestor(rm, f_id, s_id) {\n+                  some(r_id) if r_id == f_id { ok(s) }\n+                  _ { err(ty::terr_regions_differ(b, a)) }\n+                }\n               }\n \n               (ty::re_scope(a_id), ty::re_scope(b_id)) {\n@@ -1704,6 +1711,34 @@ fn lattice_tys<L:lattice_ops combine>(\n     }\n }\n \n+// Pull out some common code from LUB/GLB for handling region vars:\n+fn lattice_rvars<L:lattice_ops combine>(\n+    self: L, a: ty::region, b: ty::region) -> cres<ty::region> {\n+\n+    alt (a, b) {\n+      (ty::re_var(a_id), ty::re_var(b_id)) {\n+        lattice_vars(self, self.infcx().rb,\n+                     a, a_id, b_id,\n+                     {|x, y| self.regions(x, y) })\n+      }\n+\n+      (ty::re_var(v_id), r) | (r, ty::re_var(v_id)) {\n+        lattice_var_t(self, self.infcx().rb,\n+                      v_id, r,\n+                      {|x, y| self.regions(x, y) })\n+      }\n+\n+      _ {\n+        self.infcx().tcx.sess.bug(\n+            #fmt[\"%s: lattice_rvars invoked with a=%s and b=%s, \\\n+                  neither of which are region variables\",\n+                 self.tag(),\n+                 a.to_str(self.infcx()),\n+                 b.to_str(self.infcx())]);\n+      }\n+    }\n+}\n+\n fn lattice_vars<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n     self: L, vb: vals_and_bindings<V, T>,\n     a_t: T, a_vid: V, b_vid: V,"}, {"sha": "3c7421b2fd2d397d373c9907a51885232de1a9ff", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b549f9f147b18eaeb3a4c185e45ccd8ae310b09/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b549f9f147b18eaeb3a4c185e45ccd8ae310b09/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=6b549f9f147b18eaeb3a4c185e45ccd8ae310b09", "patch": "@@ -2078,8 +2078,8 @@ fn type_err_to_str(cx: ctxt, err: type_err) -> str {\n                 ty_constr_to_str(a_constr);\n       }\n       terr_regions_differ(subregion, superregion) {\n-        ret #fmt(\"references with lifetime %s do not outlive references with \\\n-                  lifetime %s\",\n+        ret #fmt(\"references with lifetime %s do not necessarily \\\n+                  outlive references with lifetime %s\",\n                  region_to_str(cx, subregion),\n                  region_to_str(cx, superregion));\n       }"}, {"sha": "3f0a871a34226420a2bef829d5bd2e97f441f3f5", "filename": "src/test/compile-fail/regions-nested-fns.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b549f9f147b18eaeb3a4c185e45ccd8ae310b09/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b549f9f147b18eaeb3a4c185e45ccd8ae310b09/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs?ref=6b549f9f147b18eaeb3a4c185e45ccd8ae310b09", "patch": "@@ -1,5 +1,3 @@\n-// xfail-test\n-\n fn ignore<T>(t: T) {}\n \n fn nested(x: &x.int) {\n@@ -9,13 +7,13 @@ fn nested(x: &x.int) {\n     ignore(fn&(z: &z.int) {\n         ay = x;\n         ay = &y;\n-        ay = z; //! ERROR foo\n+        ay = z; //! ERROR references with lifetime\n     });\n \n     ignore(fn&(z: &z.int) -> &z.int {\n-        if false { ret x; }  //! ERROR bar\n-        if false { ret &y; } //! ERROR bar\n-        if false { ret ay; } //! ERROR bar\n+        if false { ret x; }  //! ERROR references with lifetime\n+        if false { ret &y; } //! ERROR references with lifetime\n+        if false { ret ay; } //! ERROR references with lifetime\n         ret z;\n     });\n }"}]}