{"sha": "8efc383047460f20c6061d2e075f202dcfa92a79", "node_id": "C_kwDOAAsO6NoAKDhlZmMzODMwNDc0NjBmMjBjNjA2MWQyZTA3NWYyMDJkY2ZhOTJhNzk", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-08-26T17:13:17Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-09-27T11:31:51Z"}, "message": "Move FormatArgs structure to its own module.", "tree": {"sha": "d563192dcd93d9bac28390d7677901a60f3f6bf8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d563192dcd93d9bac28390d7677901a60f3f6bf8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8efc383047460f20c6061d2e075f202dcfa92a79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8efc383047460f20c6061d2e075f202dcfa92a79", "html_url": "https://github.com/rust-lang/rust/commit/8efc383047460f20c6061d2e075f202dcfa92a79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8efc383047460f20c6061d2e075f202dcfa92a79/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ffcb655184e9e069af76d8d648e59eb9ff2cf6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ffcb655184e9e069af76d8d648e59eb9ff2cf6c", "html_url": "https://github.com/rust-lang/rust/commit/3ffcb655184e9e069af76d8d648e59eb9ff2cf6c"}], "stats": {"total": 335, "additions": 172, "deletions": 163}, "files": [{"sha": "42a413210c764b32eb60bffaf954aecf6e498b1f", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 13, "deletions": 163, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/8efc383047460f20c6061d2e075f202dcfa92a79/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8efc383047460f20c6061d2e075f202dcfa92a79/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=8efc383047460f20c6061d2e075f202dcfa92a79", "patch": "@@ -1,7 +1,7 @@\n-use rustc_ast as ast;\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n+use rustc_ast::Expr;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, Applicability, MultiSpan, PResult};\n use rustc_expand::base::{self, *};\n@@ -12,6 +12,9 @@ use rustc_span::{BytePos, InnerSpan, Span};\n use rustc_lint_defs::builtin::NAMED_ARGUMENTS_USED_POSITIONALLY;\n use rustc_lint_defs::{BufferedEarlyLint, BuiltinLintDiagnostics, LintId};\n \n+mod ast;\n+use ast::*;\n+\n mod expand;\n use expand::expand_parsed_format_args;\n \n@@ -23,160 +26,7 @@ use expand::expand_parsed_format_args;\n //  3. Finally, `expand_parsed_format_args` will turn that `FormatArgs` structure\n //     into the expression that the macro expands to.\n \n-// Definitions:\n-//\n-// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n-// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n-//                     FormatArgs\n-//\n-// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n-//                                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n-//                                      argument\n-//\n-// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n-//              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n-//                     template\n-//\n-// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n-//               \u2514\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2518\n-//                      pieces\n-//\n-// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n-//               \u2514\u2500\u2500\u2500\u2500\u2518           \u2514\u2518\n-//                   literal pieces\n-//\n-// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n-//                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n-//                     placeholder\n-//\n-// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n-//                      \u2514\u2500\u2518  \u2514\u2500\u2518\n-//                      positions (could be names, numbers, empty, or `*`)\n-\n-/// (Parsed) format args.\n-///\n-/// Basically the \"AST\" for a complete `format_args!()`.\n-///\n-/// E.g., `format_args!(\"hello {name}\");`.\n-#[derive(Clone, Debug)]\n-pub struct FormatArgs {\n-    pub span: Span,\n-    pub template: Vec<FormatArgsPiece>,\n-    pub arguments: Vec<(P<ast::Expr>, FormatArgKind)>,\n-}\n-\n-#[derive(Clone, Debug)]\n-pub enum FormatArgsPiece {\n-    Literal(Symbol),\n-    Placeholder(FormatPlaceholder),\n-}\n-\n-#[derive(Clone, Debug)]\n-pub enum FormatArgKind {\n-    /// `format_args(\u2026, arg)`\n-    Normal,\n-    /// `format_args(\u2026, arg = 1)`\n-    Named(Ident),\n-    /// `format_args(\"\u2026 {arg} \u2026\")`\n-    Captured(Ident),\n-}\n-\n-impl FormatArgKind {\n-    pub fn ident(&self) -> Option<Ident> {\n-        match self {\n-            &Self::Normal => None,\n-            &Self::Named(id) => Some(id),\n-            &Self::Captured(id) => Some(id),\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub struct FormatPlaceholder {\n-    /// Index into [`FormatArgs::arguments`].\n-    pub argument: FormatArgPosition,\n-    /// The span inside the format string for the full `{\u2026}` placeholder.\n-    pub span: Option<Span>,\n-    /// `{}`, `{:?}`, or `{:x}`, etc.\n-    pub format_trait: FormatTrait,\n-    /// `{}` or `{:.5}` or `{:-^20}`, etc.\n-    pub format_options: FormatOptions,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub struct FormatArgPosition {\n-    /// Which argument this position refers to (Ok),\n-    /// or would've referred to if it existed (Err).\n-    pub index: Result<usize, usize>,\n-    /// What kind of position this is. See [`FormatArgsPositionKind`].\n-    pub kind: FormatArgPositionKind,\n-    /// The span of the name or number.\n-    pub span: Option<Span>,\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum FormatArgPositionKind {\n-    /// `{}` or `{.*}`\n-    Implicit,\n-    /// `{1}` or `{:1$}` or `{:.1$}`\n-    Number,\n-    /// `{a}` or `{:a$}` or `{:.a$}`\n-    Named,\n-}\n-\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum FormatTrait {\n-    /// `{}`\n-    Display,\n-    /// `{:?}`\n-    Debug,\n-    /// `{:e}`\n-    LowerExp,\n-    /// `{:E}`\n-    UpperExp,\n-    /// `{:o}`\n-    Octal,\n-    /// `{:p}`\n-    Pointer,\n-    /// `{:b}`\n-    Binary,\n-    /// `{:x}`\n-    LowerHex,\n-    /// `{:X}`\n-    UpperHex,\n-}\n-\n-#[derive(Clone, Debug, Default, PartialEq, Eq)]\n-pub struct FormatOptions {\n-    /// The width. E.g. `{:5}` or `{:width$}`.\n-    pub width: Option<FormatCount>,\n-    /// The precision. E.g. `{:.5}` or `{:.precision$}`.\n-    pub precision: Option<FormatCount>,\n-    /// The alignment. E.g. `{:>}` or `{:<}` or `{:^}`.\n-    pub alignment: Option<FormatAlignment>,\n-    /// The fill character. E.g. the `.` in `{:.>10}`.\n-    pub fill: Option<char>,\n-    /// The `+`, `-`, `0`, `#`, `x?` and `X?` flags.\n-    pub flags: u32,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub enum FormatAlignment {\n-    /// `{:<}`\n-    Left,\n-    /// `{:>}`\n-    Right,\n-    /// `{:^}`\n-    Center,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub enum FormatCount {\n-    /// `{:0}` or `{:.0}`\n-    Literal(usize),\n-    /// `{:.*}`, `{:.0$}`, or `{:a$}`, etc.\n-    Argument(FormatArgPosition),\n-}\n+// See format/ast.rs forthe FormatArgs structure.\n \n // Only used in parse_args and report_invalid_references,\n // to indicate how a referred argument was used.\n@@ -201,8 +51,8 @@ fn parse_args<'a>(\n     ecx: &mut ExtCtxt<'a>,\n     sp: Span,\n     tts: TokenStream,\n-) -> PResult<'a, (P<ast::Expr>, Vec<(P<ast::Expr>, FormatArgKind)>)> {\n-    let mut args = Vec::<(P<ast::Expr>, FormatArgKind)>::new();\n+) -> PResult<'a, (P<Expr>, Vec<(P<Expr>, FormatArgKind)>)> {\n+    let mut args = Vec::<(P<Expr>, FormatArgKind)>::new();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n \n@@ -305,8 +155,8 @@ fn parse_args<'a>(\n \n pub fn make_format_args(\n     ecx: &mut ExtCtxt<'_>,\n-    efmt: P<ast::Expr>,\n-    mut args: Vec<(P<ast::Expr>, FormatArgKind)>,\n+    efmt: P<Expr>,\n+    mut args: Vec<(P<Expr>, FormatArgKind)>,\n     append_newline: bool,\n ) -> Result<FormatArgs, ()> {\n     let start_of_named_args =\n@@ -341,8 +191,8 @@ pub fn make_format_args(\n     };\n \n     let str_style = match fmt_style {\n-        ast::StrStyle::Cooked => None,\n-        ast::StrStyle::Raw(raw) => Some(raw as usize),\n+        rustc_ast::StrStyle::Cooked => None,\n+        rustc_ast::StrStyle::Raw(raw) => Some(raw as usize),\n     };\n \n     let fmt_str = fmt_str.as_str(); // for the suggestions below\n@@ -669,7 +519,7 @@ pub fn make_format_args(\n             ecx.buffered_early_lint.push(BufferedEarlyLint {\n                 span: arg_name.span.into(),\n                 msg: format!(\"named argument `{}` is not used by name\", arg_name.name).into(),\n-                node_id: ast::CRATE_NODE_ID,\n+                node_id: rustc_ast::CRATE_NODE_ID,\n                 lint_id: LintId::of(&NAMED_ARGUMENTS_USED_POSITIONALLY),\n                 diagnostic: BuiltinLintDiagnostics::NamedArgumentUsedPositionally {\n                     position_sp_to_replace,\n@@ -850,7 +700,7 @@ fn report_invalid_references(\n     template: &[FormatArgsPiece],\n     fmt_span: Span,\n     num_explicit_args: usize,\n-    args: &[(P<ast::Expr>, FormatArgKind)],\n+    args: &[(P<Expr>, FormatArgKind)],\n     parser: parse::Parser<'_>,\n ) {\n     let num_args_desc = match num_explicit_args {"}, {"sha": "d6f72497acff8fba4c4f0d425cca21bdf79ffc94", "filename": "compiler/rustc_builtin_macros/src/format/ast.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/8efc383047460f20c6061d2e075f202dcfa92a79/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8efc383047460f20c6061d2e075f202dcfa92a79/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fast.rs?ref=8efc383047460f20c6061d2e075f202dcfa92a79", "patch": "@@ -0,0 +1,159 @@\n+use rustc_ast::ptr::P;\n+use rustc_ast::Expr;\n+use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::Span;\n+\n+// Definitions:\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+//                     FormatArgs\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//                                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+//                                      argument\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+//                     template\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//               \u2514\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2518\n+//                      pieces\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//               \u2514\u2500\u2500\u2500\u2500\u2518           \u2514\u2518\n+//                   literal pieces\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+//                     placeholder\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//                      \u2514\u2500\u2518  \u2514\u2500\u2518\n+//                      positions (could be names, numbers, empty, or `*`)\n+\n+/// (Parsed) format args.\n+///\n+/// Basically the \"AST\" for a complete `format_args!()`.\n+///\n+/// E.g., `format_args!(\"hello {name}\");`.\n+#[derive(Clone, Debug)]\n+pub struct FormatArgs {\n+    pub span: Span,\n+    pub template: Vec<FormatArgsPiece>,\n+    pub arguments: Vec<(P<Expr>, FormatArgKind)>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum FormatArgsPiece {\n+    Literal(Symbol),\n+    Placeholder(FormatPlaceholder),\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum FormatArgKind {\n+    /// `format_args(\u2026, arg)`\n+    Normal,\n+    /// `format_args(\u2026, arg = 1)`\n+    Named(Ident),\n+    /// `format_args(\"\u2026 {arg} \u2026\")`\n+    Captured(Ident),\n+}\n+\n+impl FormatArgKind {\n+    pub fn ident(&self) -> Option<Ident> {\n+        match self {\n+            &Self::Normal => None,\n+            &Self::Named(id) => Some(id),\n+            &Self::Captured(id) => Some(id),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct FormatPlaceholder {\n+    /// Index into [`FormatArgs::arguments`].\n+    pub argument: FormatArgPosition,\n+    /// The span inside the format string for the full `{\u2026}` placeholder.\n+    pub span: Option<Span>,\n+    /// `{}`, `{:?}`, or `{:x}`, etc.\n+    pub format_trait: FormatTrait,\n+    /// `{}` or `{:.5}` or `{:-^20}`, etc.\n+    pub format_options: FormatOptions,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct FormatArgPosition {\n+    /// Which argument this position refers to (Ok),\n+    /// or would've referred to if it existed (Err).\n+    pub index: Result<usize, usize>,\n+    /// What kind of position this is. See [`FormatArgsPositionKind`].\n+    pub kind: FormatArgPositionKind,\n+    /// The span of the name or number.\n+    pub span: Option<Span>,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum FormatArgPositionKind {\n+    /// `{}` or `{.*}`\n+    Implicit,\n+    /// `{1}` or `{:1$}` or `{:.1$}`\n+    Number,\n+    /// `{a}` or `{:a$}` or `{:.a$}`\n+    Named,\n+}\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum FormatTrait {\n+    /// `{}`\n+    Display,\n+    /// `{:?}`\n+    Debug,\n+    /// `{:e}`\n+    LowerExp,\n+    /// `{:E}`\n+    UpperExp,\n+    /// `{:o}`\n+    Octal,\n+    /// `{:p}`\n+    Pointer,\n+    /// `{:b}`\n+    Binary,\n+    /// `{:x}`\n+    LowerHex,\n+    /// `{:X}`\n+    UpperHex,\n+}\n+\n+#[derive(Clone, Debug, Default, PartialEq, Eq)]\n+pub struct FormatOptions {\n+    /// The width. E.g. `{:5}` or `{:width$}`.\n+    pub width: Option<FormatCount>,\n+    /// The precision. E.g. `{:.5}` or `{:.precision$}`.\n+    pub precision: Option<FormatCount>,\n+    /// The alignment. E.g. `{:>}` or `{:<}` or `{:^}`.\n+    pub alignment: Option<FormatAlignment>,\n+    /// The fill character. E.g. the `.` in `{:.>10}`.\n+    pub fill: Option<char>,\n+    /// The `+`, `-`, `0`, `#`, `x?` and `X?` flags.\n+    pub flags: u32,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum FormatAlignment {\n+    /// `{:<}`\n+    Left,\n+    /// `{:>}`\n+    Right,\n+    /// `{:^}`\n+    Center,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum FormatCount {\n+    /// `{:0}` or `{:.0}`\n+    Literal(usize),\n+    /// `{:.*}`, `{:.0$}`, or `{:a$}`, etc.\n+    Argument(FormatArgPosition),\n+}"}]}