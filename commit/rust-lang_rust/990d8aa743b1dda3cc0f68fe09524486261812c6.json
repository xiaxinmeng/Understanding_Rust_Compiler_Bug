{"sha": "990d8aa743b1dda3cc0f68fe09524486261812c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5MGQ4YWE3NDNiMWRkYTNjYzBmNjhmZTA5NTI0NDg2MjYxODEyYzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-25T13:59:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-25T13:59:48Z"}, "message": "Auto merge of #50967 - oli-obk:miri_api_refactor, r=eddyb\n\nMiri api refactor\n\nr? @eddyb\n\ncc @Zoxc\n\nbased on https://github.com/rust-lang/rust/pull/50916", "tree": {"sha": "76b57fd8f2eed340185b4714f0b2e98368519396", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76b57fd8f2eed340185b4714f0b2e98368519396"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/990d8aa743b1dda3cc0f68fe09524486261812c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/990d8aa743b1dda3cc0f68fe09524486261812c6", "html_url": "https://github.com/rust-lang/rust/commit/990d8aa743b1dda3cc0f68fe09524486261812c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/990d8aa743b1dda3cc0f68fe09524486261812c6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9823cb99c5779c0910a0d0a232966b37dfda73fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/9823cb99c5779c0910a0d0a232966b37dfda73fd", "html_url": "https://github.com/rust-lang/rust/commit/9823cb99c5779c0910a0d0a232966b37dfda73fd"}, {"sha": "5f599bb490ad7b44d6130213e635c3912f1978d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f599bb490ad7b44d6130213e635c3912f1978d5", "html_url": "https://github.com/rust-lang/rust/commit/5f599bb490ad7b44d6130213e635c3912f1978d5"}], "stats": {"total": 2056, "additions": 1068, "deletions": 988}, "files": [{"sha": "43c9fc0b8fd3676ea22fc0dc975681c0d0d3b0c4", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -394,10 +394,10 @@ for ::mir::interpret::ConstValue<'gcx> {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n-            ByVal(val) => {\n+            Scalar(val) => {\n                 val.hash_stable(hcx, hasher);\n             }\n-            ByValPair(a, b) => {\n+            ScalarPair(a, b) => {\n                 a.hash_stable(hcx, hasher);\n                 b.hash_stable(hcx, hasher);\n             }\n@@ -410,12 +410,12 @@ for ::mir::interpret::ConstValue<'gcx> {\n }\n \n impl_stable_hash_for!(enum mir::interpret::Value {\n-    ByVal(v),\n-    ByValPair(a, b),\n+    Scalar(v),\n+    ScalarPair(a, b),\n     ByRef(ptr, align)\n });\n \n-impl_stable_hash_for!(struct mir::interpret::MemoryPointer {\n+impl_stable_hash_for!(struct mir::interpret::Pointer {\n     alloc_id,\n     offset\n });\n@@ -473,13 +473,24 @@ impl_stable_hash_for!(enum ::syntax::ast::Mutability {\n     Mutable\n });\n \n-impl_stable_hash_for!(struct mir::interpret::Pointer{primval});\n \n-impl_stable_hash_for!(enum mir::interpret::PrimVal {\n-    Bytes(b),\n-    Ptr(p),\n-    Undef\n-});\n+impl<'a> HashStable<StableHashingContext<'a>>\n+for ::mir::interpret::Scalar {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use mir::interpret::Scalar::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            Bits { bits, defined } => {\n+                bits.hash_stable(hcx, hasher);\n+                defined.hash_stable(hcx, hasher);\n+            },\n+            Ptr(ptr) => ptr.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n \n impl_stable_hash_for!(struct ty::Const<'tcx> {\n     ty,"}, {"sha": "d138c6a85a0dd5fabcdef44c4e2163c64a031f22", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -68,6 +68,7 @@\n #![feature(trusted_len)]\n #![feature(catch_expr)]\n #![feature(test)]\n+#![feature(in_band_lifetimes)]\n \n #![recursion_limit=\"512\"]\n "}, {"sha": "45819afca3f5c0dc9d840ec94caa04e8590a0550", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -5,7 +5,7 @@ use ty::{FnSig, Ty, layout};\n use ty::layout::{Size, Align};\n \n use super::{\n-    MemoryPointer, Lock, AccessKind\n+    Pointer, Lock, AccessKind\n };\n \n use backtrace::Backtrace;\n@@ -38,15 +38,15 @@ pub enum EvalErrorKind<'tcx, O> {\n     MachineError(String),\n     FunctionPointerTyMismatch(FnSig<'tcx>, FnSig<'tcx>),\n     NoMirFor(String),\n-    UnterminatedCString(MemoryPointer),\n+    UnterminatedCString(Pointer),\n     DanglingPointerDeref,\n     DoubleFree,\n     InvalidMemoryAccess,\n     InvalidFunctionPointer,\n     InvalidBool,\n     InvalidDiscriminant,\n     PointerOutOfBounds {\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         access: bool,\n         allocation_size: Size,\n     },\n@@ -76,26 +76,26 @@ pub enum EvalErrorKind<'tcx, O> {\n         has: Align,\n     },\n     MemoryLockViolation {\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         frame: usize,\n         access: AccessKind,\n         lock: Lock,\n     },\n     MemoryAcquireConflict {\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         kind: AccessKind,\n         lock: Lock,\n     },\n     InvalidMemoryLockRelease {\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         frame: usize,\n         lock: Lock,\n     },\n     DeallocatedLockedMemory {\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         lock: Lock,\n     },\n     ValidationFailure(String),"}, {"sha": "b41652469aeed319537a33d85cf712db0d99ba4d", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -10,7 +10,7 @@ mod value;\n \n pub use self::error::{EvalError, EvalResult, EvalErrorKind, AssertMessage};\n \n-pub use self::value::{PrimVal, PrimValKind, Value, Pointer, ConstValue};\n+pub use self::value::{Scalar, Value, ConstValue};\n \n use std::fmt;\n use mir;\n@@ -110,42 +110,49 @@ impl<T: layout::HasDataLayout> PointerArithmetic for T {}\n \n \n #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n-pub struct MemoryPointer {\n+pub struct Pointer {\n     pub alloc_id: AllocId,\n     pub offset: Size,\n }\n \n-impl<'tcx> MemoryPointer {\n+/// Produces a `Pointer` which points to the beginning of the Allocation\n+impl From<AllocId> for Pointer {\n+    fn from(alloc_id: AllocId) -> Self {\n+        Pointer::new(alloc_id, Size::ZERO)\n+    }\n+}\n+\n+impl<'tcx> Pointer {\n     pub fn new(alloc_id: AllocId, offset: Size) -> Self {\n-        MemoryPointer { alloc_id, offset }\n+        Pointer { alloc_id, offset }\n     }\n \n     pub(crate) fn wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> Self {\n-        MemoryPointer::new(\n+        Pointer::new(\n             self.alloc_id,\n             Size::from_bytes(cx.data_layout().wrapping_signed_offset(self.offset.bytes(), i)),\n         )\n     }\n \n     pub fn overflowing_signed_offset<C: HasDataLayout>(self, i: i128, cx: C) -> (Self, bool) {\n         let (res, over) = cx.data_layout().overflowing_signed_offset(self.offset.bytes(), i);\n-        (MemoryPointer::new(self.alloc_id, Size::from_bytes(res)), over)\n+        (Pointer::new(self.alloc_id, Size::from_bytes(res)), over)\n     }\n \n     pub(crate) fn signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n-        Ok(MemoryPointer::new(\n+        Ok(Pointer::new(\n             self.alloc_id,\n             Size::from_bytes(cx.data_layout().signed_offset(self.offset.bytes(), i)?),\n         ))\n     }\n \n     pub fn overflowing_offset<C: HasDataLayout>(self, i: Size, cx: C) -> (Self, bool) {\n         let (res, over) = cx.data_layout().overflowing_offset(self.offset.bytes(), i.bytes());\n-        (MemoryPointer::new(self.alloc_id, Size::from_bytes(res)), over)\n+        (Pointer::new(self.alloc_id, Size::from_bytes(res)), over)\n     }\n \n     pub fn offset<C: HasDataLayout>(self, i: Size, cx: C) -> EvalResult<'tcx, Self> {\n-        Ok(MemoryPointer::new(\n+        Ok(Pointer::new(\n             self.alloc_id,\n             Size::from_bytes(cx.data_layout().offset(self.offset.bytes(), i.bytes())?),\n         ))\n@@ -355,7 +362,7 @@ pub struct Allocation {\n \n impl Allocation {\n     pub fn from_bytes(slice: &[u8], align: Align) -> Self {\n-        let mut undef_mask = UndefMask::new(Size::from_bytes(0));\n+        let mut undef_mask = UndefMask::new(Size::ZERO);\n         undef_mask.grow(Size::from_bytes(slice.len() as u64), true);\n         Self {\n             bytes: slice.to_owned(),\n@@ -467,7 +474,7 @@ impl UndefMask {\n     pub fn new(size: Size) -> Self {\n         let mut m = UndefMask {\n             blocks: vec![],\n-            len: Size::from_bytes(0),\n+            len: Size::ZERO,\n         };\n         m.grow(size, false);\n         m"}, {"sha": "9e3d4e60603ec8f6173dd8b8e9a6e3db7ff26b29", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 120, "deletions": 232, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -3,16 +3,16 @@\n use ty::layout::{Align, HasDataLayout, Size};\n use ty;\n \n-use super::{EvalResult, MemoryPointer, PointerArithmetic, Allocation};\n+use super::{EvalResult, Pointer, PointerArithmetic, Allocation};\n \n-/// Represents a constant value in Rust. ByVal and ByValPair are optimizations which\n+/// Represents a constant value in Rust. ByVal and ScalarPair are optimizations which\n /// matches Value's optimizations for easy conversions between these two types\n #[derive(Clone, Copy, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n pub enum ConstValue<'tcx> {\n-    /// Used only for types with layout::abi::Scalar ABI and ZSTs which use PrimVal::Undef\n-    ByVal(PrimVal),\n+    /// Used only for types with layout::abi::Scalar ABI and ZSTs which use Scalar::undef()\n+    Scalar(Scalar),\n     /// Used only for types with layout::abi::ScalarPair\n-    ByValPair(PrimVal, PrimVal),\n+    ScalarPair(Scalar, Scalar),\n     /// Used only for the remaining cases. An allocation + offset into the allocation\n     ByRef(&'tcx Allocation, Size),\n }\n@@ -22,48 +22,42 @@ impl<'tcx> ConstValue<'tcx> {\n     pub fn from_byval_value(val: Value) -> Self {\n         match val {\n             Value::ByRef(..) => bug!(),\n-            Value::ByValPair(a, b) => ConstValue::ByValPair(a, b),\n-            Value::ByVal(val) => ConstValue::ByVal(val),\n+            Value::ScalarPair(a, b) => ConstValue::ScalarPair(a, b),\n+            Value::Scalar(val) => ConstValue::Scalar(val),\n         }\n     }\n \n     #[inline]\n     pub fn to_byval_value(&self) -> Option<Value> {\n         match *self {\n             ConstValue::ByRef(..) => None,\n-            ConstValue::ByValPair(a, b) => Some(Value::ByValPair(a, b)),\n-            ConstValue::ByVal(val) => Some(Value::ByVal(val)),\n+            ConstValue::ScalarPair(a, b) => Some(Value::ScalarPair(a, b)),\n+            ConstValue::Scalar(val) => Some(Value::Scalar(val)),\n         }\n     }\n \n     #[inline]\n-    pub fn from_primval(val: PrimVal) -> Self {\n-        ConstValue::ByVal(val)\n+    pub fn from_scalar(val: Scalar) -> Self {\n+        ConstValue::Scalar(val)\n     }\n \n     #[inline]\n-    pub fn to_primval(&self) -> Option<PrimVal> {\n+    pub fn to_scalar(&self) -> Option<Scalar> {\n         match *self {\n             ConstValue::ByRef(..) => None,\n-            ConstValue::ByValPair(..) => None,\n-            ConstValue::ByVal(val) => Some(val),\n+            ConstValue::ScalarPair(..) => None,\n+            ConstValue::Scalar(val) => Some(val),\n         }\n     }\n \n     #[inline]\n-    pub fn to_bits(&self) -> Option<u128> {\n-        match self.to_primval() {\n-            Some(PrimVal::Bytes(val)) => Some(val),\n-            _ => None,\n-        }\n+    pub fn to_bits(&self, size: Size) -> Option<u128> {\n+        self.to_scalar()?.to_bits(size).ok()\n     }\n \n     #[inline]\n-    pub fn to_ptr(&self) -> Option<MemoryPointer> {\n-        match self.to_primval() {\n-            Some(PrimVal::Ptr(ptr)) => Some(ptr),\n-            _ => None,\n-        }\n+    pub fn to_ptr(&self) -> Option<Pointer> {\n+        self.to_scalar()?.to_ptr().ok()\n     }\n }\n \n@@ -74,13 +68,13 @@ impl<'tcx> ConstValue<'tcx> {\n /// whether the pointer is supposed to be aligned or not (also see Place).\n ///\n /// For optimization of a few very common cases, there is also a representation for a pair of\n-/// primitive values (`ByValPair`). It allows Miri to avoid making allocations for checked binary\n+/// primitive values (`ScalarPair`). It allows Miri to avoid making allocations for checked binary\n /// operations and fat pointers. This idea was taken from rustc's codegen.\n #[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n pub enum Value {\n-    ByRef(Pointer, Align),\n-    ByVal(PrimVal),\n-    ByValPair(PrimVal, PrimVal),\n+    ByRef(Scalar, Align),\n+    Scalar(Scalar),\n+    ScalarPair(Scalar, Scalar),\n }\n \n impl<'tcx> ty::TypeFoldable<'tcx> for Value {\n@@ -92,277 +86,171 @@ impl<'tcx> ty::TypeFoldable<'tcx> for Value {\n     }\n }\n \n-/// A wrapper type around `PrimVal` that cannot be turned back into a `PrimVal` accidentally.\n-/// This type clears up a few APIs where having a `PrimVal` argument for something that is\n-/// potentially an integer pointer or a pointer to an allocation was unclear.\n-///\n-/// I (@oli-obk) believe it is less easy to mix up generic primvals and primvals that are just\n-/// the representation of pointers. Also all the sites that convert between primvals and pointers\n-/// are explicit now (and rare!)\n-#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n-pub struct Pointer {\n-    pub primval: PrimVal,\n-}\n-\n-impl<'tcx> Pointer {\n-    pub fn null() -> Self {\n-        PrimVal::Bytes(0).into()\n-    }\n-    pub fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n-        self.primval.to_ptr()\n-    }\n-    pub fn into_inner_primval(self) -> PrimVal {\n-        self.primval\n+impl<'tcx> Scalar {\n+    pub fn ptr_null<C: HasDataLayout>(cx: C) -> Self {\n+        Scalar::Bits {\n+            bits: 0,\n+            defined: cx.data_layout().pointer_size.bits() as u8,\n+        }\n     }\n \n-    pub fn signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn ptr_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n-        match self.primval {\n-            PrimVal::Bytes(b) => {\n-                assert_eq!(b as u64 as u128, b);\n-                Ok(Pointer::from(\n-                    PrimVal::Bytes(layout.signed_offset(b as u64, i)? as u128),\n-                ))\n+        match self {\n+            Scalar::Bits { bits, defined } => {\n+                let pointer_size = layout.pointer_size.bits() as u8;\n+                if defined < pointer_size {\n+                    err!(ReadUndefBytes)\n+                } else {\n+                    Ok(Scalar::Bits {\n+                        bits: layout.signed_offset(bits as u64, i)? as u128,\n+                        defined: pointer_size,\n+                    })\n+            }\n             }\n-            PrimVal::Ptr(ptr) => ptr.signed_offset(i, layout).map(Pointer::from),\n-            PrimVal::Undef => err!(ReadUndefBytes),\n+            Scalar::Ptr(ptr) => ptr.signed_offset(i, layout).map(Scalar::Ptr),\n         }\n     }\n \n-    pub fn offset<C: HasDataLayout>(self, i: Size, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn ptr_offset<C: HasDataLayout>(self, i: Size, cx: C) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n-        match self.primval {\n-            PrimVal::Bytes(b) => {\n-                assert_eq!(b as u64 as u128, b);\n-                Ok(Pointer::from(\n-                    PrimVal::Bytes(layout.offset(b as u64, i.bytes())? as u128),\n-                ))\n+        match self {\n+            Scalar::Bits { bits, defined } => {\n+                let pointer_size = layout.pointer_size.bits() as u8;\n+                if defined < pointer_size {\n+                    err!(ReadUndefBytes)\n+                } else {\n+                    Ok(Scalar::Bits {\n+                        bits: layout.offset(bits as u64, i.bytes())? as u128,\n+                        defined: pointer_size,\n+                    })\n             }\n-            PrimVal::Ptr(ptr) => ptr.offset(i, layout).map(Pointer::from),\n-            PrimVal::Undef => err!(ReadUndefBytes),\n+            }\n+            Scalar::Ptr(ptr) => ptr.offset(i, layout).map(Scalar::Ptr),\n         }\n     }\n \n-    pub fn wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn ptr_wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n-        match self.primval {\n-            PrimVal::Bytes(b) => {\n-                assert_eq!(b as u64 as u128, b);\n-                Ok(Pointer::from(PrimVal::Bytes(\n-                    layout.wrapping_signed_offset(b as u64, i) as u128,\n-                )))\n+        match self {\n+            Scalar::Bits { bits, defined } => {\n+                let pointer_size = layout.pointer_size.bits() as u8;\n+                if defined < pointer_size {\n+                    err!(ReadUndefBytes)\n+                } else {\n+                    Ok(Scalar::Bits {\n+                        bits: layout.wrapping_signed_offset(bits as u64, i) as u128,\n+                        defined: pointer_size,\n+                    })\n             }\n-            PrimVal::Ptr(ptr) => Ok(Pointer::from(ptr.wrapping_signed_offset(i, layout))),\n-            PrimVal::Undef => err!(ReadUndefBytes),\n+            }\n+            Scalar::Ptr(ptr) => Ok(Scalar::Ptr(ptr.wrapping_signed_offset(i, layout))),\n         }\n     }\n \n-    pub fn is_null(self) -> EvalResult<'tcx, bool> {\n-        match self.primval {\n-            PrimVal::Bytes(b) => Ok(b == 0),\n-            PrimVal::Ptr(_) => Ok(false),\n-            PrimVal::Undef => err!(ReadUndefBytes),\n+    pub fn is_null_ptr<C: HasDataLayout>(self, cx: C) -> EvalResult<'tcx, bool> {\n+        match self {\n+            Scalar::Bits {\n+                bits, defined,\n+            } => if defined < cx.data_layout().pointer_size.bits() as u8 {\n+                err!(ReadUndefBytes)\n+            } else {\n+                Ok(bits == 0)\n+            },\n+            Scalar::Ptr(_) => Ok(false),\n         }\n     }\n \n-    pub fn to_value_with_len(self, len: u64) -> Value {\n-        Value::ByValPair(self.primval, PrimVal::from_u128(len as u128))\n+    pub fn to_value_with_len<C: HasDataLayout>(self, len: u64, cx: C) -> Value {\n+        Value::ScalarPair(self, Scalar::Bits {\n+            bits: len as u128,\n+            defined: cx.data_layout().pointer_size.bits() as u8,\n+        })\n     }\n \n-    pub fn to_value_with_vtable(self, vtable: MemoryPointer) -> Value {\n-        Value::ByValPair(self.primval, PrimVal::Ptr(vtable))\n+    pub fn to_value_with_vtable(self, vtable: Pointer) -> Value {\n+        Value::ScalarPair(self, Scalar::Ptr(vtable))\n     }\n \n     pub fn to_value(self) -> Value {\n-        Value::ByVal(self.primval)\n-    }\n-}\n-\n-impl ::std::convert::From<PrimVal> for Pointer {\n-    fn from(primval: PrimVal) -> Self {\n-        Pointer { primval }\n+        Value::Scalar(self)\n     }\n }\n \n-impl ::std::convert::From<MemoryPointer> for Pointer {\n-    fn from(ptr: MemoryPointer) -> Self {\n-        PrimVal::Ptr(ptr).into()\n+impl From<Pointer> for Scalar {\n+    fn from(ptr: Pointer) -> Self {\n+        Scalar::Ptr(ptr)\n     }\n }\n \n-/// A `PrimVal` represents an immediate, primitive value existing outside of a\n+/// A `Scalar` represents an immediate, primitive value existing outside of a\n /// `memory::Allocation`. It is in many ways like a small chunk of a `Allocation`, up to 8 bytes in\n-/// size. Like a range of bytes in an `Allocation`, a `PrimVal` can either represent the raw bytes\n-/// of a simple value, a pointer into another `Allocation`, or be undefined.\n+/// size. Like a range of bytes in an `Allocation`, a `Scalar` can either represent the raw bytes\n+/// of a simple value or a pointer into another `Allocation`\n #[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n-pub enum PrimVal {\n+pub enum Scalar {\n     /// The raw bytes of a simple value.\n-    Bytes(u128),\n+    Bits {\n+        /// The first `defined` number of bits are valid\n+        defined: u8,\n+        bits: u128,\n+    },\n \n     /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n-    /// relocations, but a `PrimVal` is only large enough to contain one, so we just represent the\n-    /// relocation and its associated offset together as a `MemoryPointer` here.\n-    Ptr(MemoryPointer),\n-\n-    /// An undefined `PrimVal`, for representing values that aren't safe to examine, but are safe\n-    /// to copy around, just like undefined bytes in an `Allocation`.\n-    Undef,\n-}\n-\n-#[derive(Clone, Copy, Debug, PartialEq)]\n-pub enum PrimValKind {\n-    I8, I16, I32, I64, I128,\n-    U8, U16, U32, U64, U128,\n-    F32, F64,\n-    Ptr, FnPtr,\n-    Bool,\n-    Char,\n+    /// relocations, but a `Scalar` is only large enough to contain one, so we just represent the\n+    /// relocation and its associated offset together as a `Pointer` here.\n+    Ptr(Pointer),\n }\n \n-impl<'tcx> PrimVal {\n-    pub fn from_u128(n: u128) -> Self {\n-        PrimVal::Bytes(n)\n-    }\n-\n-    pub fn from_i128(n: i128) -> Self {\n-        PrimVal::Bytes(n as u128)\n+impl<'tcx> Scalar {\n+    pub fn undef() -> Self {\n+        Scalar::Bits { bits: 0, defined: 0 }\n     }\n \n     pub fn from_bool(b: bool) -> Self {\n-        PrimVal::Bytes(b as u128)\n+        // FIXME: can we make defined `1`?\n+        Scalar::Bits { bits: b as u128, defined: 8 }\n     }\n \n     pub fn from_char(c: char) -> Self {\n-        PrimVal::Bytes(c as u128)\n+        Scalar::Bits { bits: c as u128, defined: 32 }\n     }\n \n-    pub fn to_bytes(self) -> EvalResult<'tcx, u128> {\n+    pub fn to_bits(self, size: Size) -> EvalResult<'tcx, u128> {\n         match self {\n-            PrimVal::Bytes(b) => Ok(b),\n-            PrimVal::Ptr(_) => err!(ReadPointerAsBytes),\n-            PrimVal::Undef => err!(ReadUndefBytes),\n+            Scalar::Bits { .. } if size.bits() == 0 => bug!(\"to_bits cannot be used with zsts\"),\n+            Scalar::Bits { bits, defined } if size.bits() <= defined as u64 => Ok(bits),\n+            Scalar::Bits { .. } => err!(ReadUndefBytes),\n+            Scalar::Ptr(_) => err!(ReadPointerAsBytes),\n         }\n     }\n \n-    pub fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n+    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n         match self {\n-            PrimVal::Bytes(_) => err!(ReadBytesAsPointer),\n-            PrimVal::Ptr(p) => Ok(p),\n-            PrimVal::Undef => err!(ReadUndefBytes),\n+            Scalar::Bits {..} => err!(ReadBytesAsPointer),\n+            Scalar::Ptr(p) => Ok(p),\n         }\n     }\n \n-    pub fn is_bytes(self) -> bool {\n+    pub fn is_bits(self) -> bool {\n         match self {\n-            PrimVal::Bytes(_) => true,\n+            Scalar::Bits { .. } => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_ptr(self) -> bool {\n         match self {\n-            PrimVal::Ptr(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_undef(self) -> bool {\n-        match self {\n-            PrimVal::Undef => true,\n+            Scalar::Ptr(_) => true,\n             _ => false,\n         }\n     }\n \n-    pub fn to_u128(self) -> EvalResult<'tcx, u128> {\n-        self.to_bytes()\n-    }\n-\n-    pub fn to_u64(self) -> EvalResult<'tcx, u64> {\n-        self.to_bytes().map(|b| {\n-            assert_eq!(b as u64 as u128, b);\n-            b as u64\n-        })\n-    }\n-\n-    pub fn to_i32(self) -> EvalResult<'tcx, i32> {\n-        self.to_bytes().map(|b| {\n-            assert_eq!(b as i32 as u128, b);\n-            b as i32\n-        })\n-    }\n-\n-    pub fn to_i128(self) -> EvalResult<'tcx, i128> {\n-        self.to_bytes().map(|b| b as i128)\n-    }\n-\n-    pub fn to_i64(self) -> EvalResult<'tcx, i64> {\n-        self.to_bytes().map(|b| {\n-            assert_eq!(b as i64 as u128, b);\n-            b as i64\n-        })\n-    }\n-\n     pub fn to_bool(self) -> EvalResult<'tcx, bool> {\n-        match self.to_bytes()? {\n-            0 => Ok(false),\n-            1 => Ok(true),\n-            _ => err!(InvalidBool),\n-        }\n-    }\n-}\n-\n-impl PrimValKind {\n-    pub fn is_int(self) -> bool {\n-        use self::PrimValKind::*;\n-        match self {\n-            I8 | I16 | I32 | I64 | I128 | U8 | U16 | U32 | U64 | U128 => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_signed_int(self) -> bool {\n-        use self::PrimValKind::*;\n-        match self {\n-            I8 | I16 | I32 | I64 | I128 => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_float(self) -> bool {\n-        use self::PrimValKind::*;\n-        match self {\n-            F32 | F64 => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn from_uint_size(size: Size) -> Self {\n-        match size.bytes() {\n-            1 => PrimValKind::U8,\n-            2 => PrimValKind::U16,\n-            4 => PrimValKind::U32,\n-            8 => PrimValKind::U64,\n-            16 => PrimValKind::U128,\n-            _ => bug!(\"can't make uint with size {}\", size.bytes()),\n-        }\n-    }\n-\n-    pub fn from_int_size(size: Size) -> Self {\n-        match size.bytes() {\n-            1 => PrimValKind::I8,\n-            2 => PrimValKind::I16,\n-            4 => PrimValKind::I32,\n-            8 => PrimValKind::I64,\n-            16 => PrimValKind::I128,\n-            _ => bug!(\"can't make int with size {}\", size.bytes()),\n-        }\n-    }\n-\n-    pub fn is_ptr(self) -> bool {\n-        use self::PrimValKind::*;\n         match self {\n-            Ptr | FnPtr => true,\n-            _ => false,\n+            Scalar::Bits { bits: 0, defined: 8 } => Ok(false),\n+            Scalar::Bits { bits: 1, defined: 8 } => Ok(true),\n+            _ => err!(InvalidBool),\n         }\n     }\n }"}, {"sha": "e44b1dc886b5b345c264f8618b6331997c608bed", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -24,7 +24,7 @@ use rustc_serialize as serialize;\n use hir::def::CtorKind;\n use hir::def_id::DefId;\n use mir::visit::MirVisitable;\n-use mir::interpret::{Value, PrimVal, EvalErrorKind};\n+use mir::interpret::{Value, Scalar, EvalErrorKind};\n use ty::subst::{Subst, Substs};\n use ty::{self, AdtDef, CanonicalTy, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n@@ -1149,11 +1149,16 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Return | Resume | Abort | Unreachable | GeneratorDrop => vec![],\n             Goto { .. } => vec![\"\".into()],\n             SwitchInt { ref values, switch_ty, .. } => {\n+                let size = ty::tls::with(|tcx| {\n+                    let param_env = ty::ParamEnv::empty();\n+                    let switch_ty = tcx.lift_to_global(&switch_ty).unwrap();\n+                    tcx.layout_of(param_env.and(switch_ty)).unwrap().size\n+                });\n                 values.iter()\n                       .map(|&u| {\n                           let mut s = String::new();\n                           print_miri_value(\n-                              Value::ByVal(PrimVal::Bytes(u)),\n+                              Value::Scalar(Scalar::Bits { bits: u, defined: size.bits() as u8 }),\n                               switch_ty,\n                               &mut s,\n                           ).unwrap();\n@@ -1893,19 +1898,26 @@ pub fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ty::Const) -> fmt::Resul\n pub fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Result {\n     use ty::TypeVariants::*;\n     match (value, &ty.sty) {\n-        (Value::ByVal(PrimVal::Bytes(0)), &TyBool) => write!(f, \"false\"),\n-        (Value::ByVal(PrimVal::Bytes(1)), &TyBool) => write!(f, \"true\"),\n-        (Value::ByVal(PrimVal::Bytes(bits)), &TyFloat(ast::FloatTy::F32)) =>\n+        (Value::Scalar(Scalar::Bits { bits: 0, .. }), &TyBool) => write!(f, \"false\"),\n+        (Value::Scalar(Scalar::Bits { bits: 1, .. }), &TyBool) => write!(f, \"true\"),\n+        (Value::Scalar(Scalar::Bits { bits, .. }), &TyFloat(ast::FloatTy::F32)) =>\n             write!(f, \"{}f32\", Single::from_bits(bits)),\n-        (Value::ByVal(PrimVal::Bytes(bits)), &TyFloat(ast::FloatTy::F64)) =>\n+        (Value::Scalar(Scalar::Bits { bits, .. }), &TyFloat(ast::FloatTy::F64)) =>\n             write!(f, \"{}f64\", Double::from_bits(bits)),\n-        (Value::ByVal(PrimVal::Bytes(n)), &TyUint(ui)) => write!(f, \"{:?}{}\", n, ui),\n-        (Value::ByVal(PrimVal::Bytes(n)), &TyInt(i)) => write!(f, \"{:?}{}\", n as i128, i),\n-        (Value::ByVal(PrimVal::Bytes(n)), &TyChar) =>\n-            write!(f, \"{:?}\", ::std::char::from_u32(n as u32).unwrap()),\n-        (Value::ByVal(PrimVal::Undef), &TyFnDef(did, _)) =>\n+        (Value::Scalar(Scalar::Bits { bits, .. }), &TyUint(ui)) => write!(f, \"{:?}{}\", bits, ui),\n+        (Value::Scalar(Scalar::Bits { bits, .. }), &TyInt(i)) => {\n+            let bit_width = ty::tls::with(|tcx| {\n+                 let ty = tcx.lift_to_global(&ty).unwrap();\n+                 tcx.layout_of(ty::ParamEnv::empty().and(ty)).unwrap().size.bits()\n+            });\n+            let shift = 128 - bit_width;\n+            write!(f, \"{:?}{}\", ((bits as i128) << shift) >> shift, i)\n+        },\n+        (Value::Scalar(Scalar::Bits { bits, .. }), &TyChar) =>\n+            write!(f, \"{:?}\", ::std::char::from_u32(bits as u32).unwrap()),\n+        (_, &TyFnDef(did, _)) =>\n             write!(f, \"{}\", item_path_str(did)),\n-        (Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len)),\n+        (Value::ScalarPair(Scalar::Ptr(ptr), Scalar::Bits { bits: len, .. }),\n          &TyRef(_, &ty::TyS { sty: TyStr, .. }, _)) => {\n             ty::tls::with(|tcx| {\n                 match tcx.alloc_map.lock().get(ptr.alloc_id) {"}, {"sha": "6169b3bc33fcd0be6b75a2a3da6d20541d1372b6", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -11,7 +11,7 @@\n use session::{self, DataTypeKind};\n use ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions};\n \n-use syntax::ast::{self, FloatTy, IntTy, UintTy};\n+use syntax::ast::{self, IntTy, UintTy};\n use syntax::attr;\n use syntax_pos::DUMMY_SP;\n \n@@ -130,8 +130,8 @@ impl PrimitiveExt for Primitive {\n     fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             Int(i, signed) => i.to_ty(tcx, signed),\n-            F32 => tcx.types.f32,\n-            F64 => tcx.types.f64,\n+            Float(FloatTy::F32) => tcx.types.f32,\n+            Float(FloatTy::F64) => tcx.types.f64,\n             Pointer => tcx.mk_mut_ptr(tcx.mk_nil()),\n         }\n     }\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             LayoutDetails {\n                 variants: Variants::Single { index: 0 },\n                 fields: FieldPlacement::Arbitrary {\n-                    offsets: vec![Size::from_bytes(0), b_offset],\n+                    offsets: vec![Size::ZERO, b_offset],\n                     memory_index: vec![0, 1]\n                 },\n                 abi: Abi::ScalarPair(a, b),\n@@ -267,7 +267,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             };\n \n             let mut sized = true;\n-            let mut offsets = vec![Size::from_bytes(0); fields.len()];\n+            let mut offsets = vec![Size::ZERO; fields.len()];\n             let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n \n             let mut optimize = !repr.inhibit_struct_field_reordering_opt();\n@@ -307,7 +307,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             // field 5 with offset 0 puts 0 in offsets[5].\n             // At the bottom of this function, we use inverse_memory_index to produce memory_index.\n \n-            let mut offset = Size::from_bytes(0);\n+            let mut offset = Size::ZERO;\n \n             if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n                 if packed {\n@@ -488,8 +488,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             ty::TyUint(ity) => {\n                 scalar(Int(Integer::from_attr(dl, attr::UnsignedInt(ity)), false))\n             }\n-            ty::TyFloat(FloatTy::F32) => scalar(F32),\n-            ty::TyFloat(FloatTy::F64) => scalar(F64),\n+            ty::TyFloat(fty) => scalar(Float(fty)),\n             ty::TyFnPtr(_) => {\n                 let mut ptr = scalar_unit(Pointer);\n                 ptr.valid_range = 1..=*ptr.valid_range.end();\n@@ -503,7 +502,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     fields: FieldPlacement::Union(0),\n                     abi: Abi::Uninhabited,\n                     align: dl.i8_align,\n-                    size: Size::from_bytes(0)\n+                    size: Size::ZERO\n                 })\n             }\n \n@@ -575,7 +574,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     },\n                     abi: Abi::Aggregate { sized: false },\n                     align: element.align,\n-                    size: Size::from_bytes(0)\n+                    size: Size::ZERO\n                 })\n             }\n             ty::TyStr => {\n@@ -587,7 +586,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     },\n                     abi: Abi::Aggregate { sized: false },\n                     align: dl.i8_align,\n-                    size: Size::from_bytes(0)\n+                    size: Size::ZERO\n                 })\n             }\n \n@@ -696,7 +695,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                             Align::from_bytes(repr_align, repr_align).unwrap());\n                     }\n \n-                    let mut size = Size::from_bytes(0);\n+                    let mut size = Size::ZERO;\n                     for field in &variants[0] {\n                         assert!(!field.is_unsized());\n \n@@ -908,7 +907,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 let (min_ity, signed) = Integer::repr_discr(tcx, ty, &def.repr, min, max);\n \n                 let mut align = dl.aggregate_align;\n-                let mut size = Size::from_bytes(0);\n+                let mut size = Size::ZERO;\n \n                 // We're interested in the smallest alignment, so start large.\n                 let mut start_align = Align::from_bytes(256, 256).unwrap();\n@@ -1078,7 +1077,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                             }\n                             _ => bug!()\n                         };\n-                        if pair_offsets[0] == Size::from_bytes(0) &&\n+                        if pair_offsets[0] == Size::ZERO &&\n                             pair_offsets[1] == *offset &&\n                             align == pair.align &&\n                             size == pair.size {\n@@ -1099,7 +1098,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                         variants: layout_variants,\n                     },\n                     fields: FieldPlacement::Arbitrary {\n-                        offsets: vec![Size::from_bytes(0)],\n+                        offsets: vec![Size::ZERO],\n                         memory_index: vec![0]\n                     },\n                     abi,\n@@ -1182,7 +1181,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n         let build_variant_info = |n: Option<ast::Name>,\n                                   flds: &[ast::Name],\n                                   layout: TyLayout<'tcx>| {\n-            let mut min_size = Size::from_bytes(0);\n+            let mut min_size = Size::ZERO;\n             let field_info: Vec<_> = flds.iter().enumerate().map(|(i, &name)| {\n                 match layout.field(self, i) {\n                     Err(err) => {\n@@ -1514,28 +1513,28 @@ impl<'a, 'tcx> LayoutOf for LayoutCx<'tcx, ty::maps::TyCtxtAt<'a, 'tcx, 'tcx>> {\n }\n \n // Helper (inherent) `layout_of` methods to avoid pushing `LayoutCx` to users.\n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl TyCtxt<'a, 'tcx, '_> {\n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n     #[inline]\n     pub fn layout_of(self, param_env_and_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n                      -> Result<TyLayout<'tcx>, LayoutError<'tcx>> {\n         let cx = LayoutCx {\n-            tcx: self,\n+            tcx: self.global_tcx(),\n             param_env: param_env_and_ty.param_env\n         };\n         cx.layout_of(param_env_and_ty.value)\n     }\n }\n \n-impl<'a, 'tcx> ty::maps::TyCtxtAt<'a, 'tcx, 'tcx> {\n+impl ty::maps::TyCtxtAt<'a, 'tcx, '_> {\n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n     #[inline]\n     pub fn layout_of(self, param_env_and_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n                      -> Result<TyLayout<'tcx>, LayoutError<'tcx>> {\n         let cx = LayoutCx {\n-            tcx: self,\n+            tcx: self.global_tcx().at(self.span),\n             param_env: param_env_and_ty.param_env\n         };\n         cx.layout_of(param_env_and_ty.value)\n@@ -1567,7 +1566,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                     fields: FieldPlacement::Union(fields),\n                     abi: Abi::Uninhabited,\n                     align: tcx.data_layout.i8_align,\n-                    size: Size::from_bytes(0)\n+                    size: Size::ZERO\n                 })\n             }\n \n@@ -1746,19 +1745,19 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n         match layout.abi {\n             Abi::Scalar(ref scalar) => {\n-                return Ok(scalar_niche(scalar, Size::from_bytes(0)));\n+                return Ok(scalar_niche(scalar, Size::ZERO));\n             }\n             Abi::ScalarPair(ref a, ref b) => {\n                 // HACK(nox): We iter on `b` and then `a` because `max_by_key`\n                 // returns the last maximum.\n                 let niche = iter::once((b, a.value.size(self).abi_align(b.value.align(self))))\n-                    .chain(iter::once((a, Size::from_bytes(0))))\n+                    .chain(iter::once((a, Size::ZERO)))\n                     .filter_map(|(scalar, offset)| scalar_niche(scalar, offset))\n                     .max_by_key(|niche| niche.available);\n                 return Ok(niche);\n             }\n             Abi::Vector { ref element, .. } => {\n-                return Ok(scalar_niche(element, Size::from_bytes(0)));\n+                return Ok(scalar_niche(element, Size::ZERO));\n             }\n             _ => {}\n         }\n@@ -1908,8 +1907,7 @@ impl_stable_hash_for!(enum ::ty::layout::Integer {\n \n impl_stable_hash_for!(enum ::ty::layout::Primitive {\n     Int(integer, signed),\n-    F32,\n-    F64,\n+    Float(fty),\n     Pointer\n });\n "}, {"sha": "5ee6329e860e56545e80db88819b95844c02d64a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -1982,7 +1982,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         match tcx.const_eval(param_env.and(cid)) {\n             Ok(val) => {\n                 // FIXME: Find the right type and use it instead of `val.ty` here\n-                if let Some(b) = val.assert_bits(val.ty) {\n+                if let Some(b) = val.assert_bits(tcx.global_tcx(), param_env.and(val.ty)) {\n                     trace!(\"discriminants: {} ({:?})\", b, repr_type);\n                     Some(Discr {\n                         val: b,"}, {"sha": "3347d47a4e81ec3d320fe9bdfb4d11413aaf85f6", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 48, "deletions": 25, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -17,9 +17,9 @@ use middle::region;\n use rustc_data_structures::indexed_vec::Idx;\n use ty::subst::{Substs, Subst, Kind, UnpackedKind};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n-use ty::{Slice, TyS};\n+use ty::{Slice, TyS, ParamEnvAnd, ParamEnv};\n use util::captures::Captures;\n-use mir::interpret::{PrimVal, MemoryPointer, Value, ConstValue};\n+use mir::interpret::{Scalar, Pointer, Value, ConstValue};\n \n use std::iter;\n use std::cmp::Ordering;\n@@ -1809,51 +1809,64 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn from_primval(\n+    pub fn from_scalar(\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        val: PrimVal,\n+        val: Scalar,\n         ty: Ty<'tcx>,\n     ) -> &'tcx Self {\n-        Self::from_const_value(tcx, ConstValue::from_primval(val), ty)\n+        Self::from_const_value(tcx, ConstValue::from_scalar(val), ty)\n     }\n \n     #[inline]\n     pub fn from_bits(\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        val: u128,\n-        ty: Ty<'tcx>,\n+        bits: u128,\n+        ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n     ) -> &'tcx Self {\n-        Self::from_primval(tcx, PrimVal::Bytes(val), ty)\n+        let ty = tcx.lift_to_global(&ty).unwrap();\n+        let size = tcx.layout_of(ty).unwrap_or_else(|e| {\n+            panic!(\"could not compute layout for {:?}: {:?}\", ty, e)\n+        }).size;\n+        let shift = 128 - size.bits();\n+        let truncated = (bits << shift) >> shift;\n+        assert_eq!(truncated, bits, \"from_bits called with untruncated value\");\n+        Self::from_scalar(tcx, Scalar::Bits { bits, defined: size.bits() as u8 }, ty.value)\n     }\n \n     #[inline]\n     pub fn zero_sized(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n-        Self::from_primval(tcx, PrimVal::Undef, ty)\n+        Self::from_scalar(tcx, Scalar::undef(), ty)\n     }\n \n     #[inline]\n     pub fn from_bool(tcx: TyCtxt<'_, '_, 'tcx>, v: bool) -> &'tcx Self {\n-        Self::from_bits(tcx, v as u128, tcx.types.bool)\n+        Self::from_bits(tcx, v as u128, ParamEnv::empty().and(tcx.types.bool))\n     }\n \n     #[inline]\n     pub fn from_usize(tcx: TyCtxt<'_, '_, 'tcx>, n: u64) -> &'tcx Self {\n-        Self::from_bits(tcx, n as u128, tcx.types.usize)\n+        Self::from_bits(tcx, n as u128, ParamEnv::empty().and(tcx.types.usize))\n     }\n \n     #[inline]\n-    pub fn to_bits(&self, ty: Ty<'_>) -> Option<u128> {\n-        if self.ty != ty {\n+    pub fn to_bits(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n+    ) -> Option<u128> {\n+        if self.ty != ty.value {\n             return None;\n         }\n+        let ty = tcx.lift_to_global(&ty).unwrap();\n+        let size = tcx.layout_of(ty).ok()?.size;\n         match self.val {\n-            ConstVal::Value(val) => val.to_bits(),\n+            ConstVal::Value(val) => val.to_bits(size),\n             _ => None,\n         }\n     }\n \n     #[inline]\n-    pub fn to_ptr(&self) -> Option<MemoryPointer> {\n+    pub fn to_ptr(&self) -> Option<Pointer> {\n         match self.val {\n             ConstVal::Value(val) => val.to_ptr(),\n             _ => None,\n@@ -1869,25 +1882,31 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn to_primval(&self) -> Option<PrimVal> {\n+    pub fn to_scalar(&self) -> Option<Scalar> {\n         match self.val {\n-            ConstVal::Value(val) => val.to_primval(),\n+            ConstVal::Value(val) => val.to_scalar(),\n             _ => None,\n         }\n     }\n \n     #[inline]\n-    pub fn assert_bits(&self, ty: Ty<'_>) -> Option<u128> {\n-        assert_eq!(self.ty, ty);\n+    pub fn assert_bits(\n+        &self,\n+        tcx: TyCtxt<'_, '_, '_>,\n+        ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n+    ) -> Option<u128> {\n+        assert_eq!(self.ty, ty.value);\n+        let ty = tcx.lift_to_global(&ty).unwrap();\n+        let size = tcx.layout_of(ty).ok()?.size;\n         match self.val {\n-            ConstVal::Value(val) => val.to_bits(),\n+            ConstVal::Value(val) => val.to_bits(size),\n             _ => None,\n         }\n     }\n \n     #[inline]\n     pub fn assert_bool(&self, tcx: TyCtxt<'_, '_, '_>) -> Option<bool> {\n-        self.assert_bits(tcx.types.bool).and_then(|v| match v {\n+        self.assert_bits(tcx, ParamEnv::empty().and(tcx.types.bool)).and_then(|v| match v {\n             0 => Some(false),\n             1 => Some(true),\n             _ => None,\n@@ -1896,14 +1915,18 @@ impl<'tcx> Const<'tcx> {\n \n     #[inline]\n     pub fn assert_usize(&self, tcx: TyCtxt<'_, '_, '_>) -> Option<u64> {\n-        self.assert_bits(tcx.types.usize).map(|v| v as u64)\n+        self.assert_bits(tcx, ParamEnv::empty().and(tcx.types.usize)).map(|v| v as u64)\n     }\n \n     #[inline]\n-    pub fn unwrap_bits(&self, ty: Ty<'_>) -> u128 {\n-        match self.assert_bits(ty) {\n+    pub fn unwrap_bits(\n+        &self,\n+        tcx: TyCtxt<'_, '_, '_>,\n+        ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n+    ) -> u128 {\n+        match self.assert_bits(tcx, ty) {\n             Some(val) => val,\n-            None => bug!(\"expected bits of {}, got {:#?}\", ty, self),\n+            None => bug!(\"expected bits of {}, got {:#?}\", ty.value, self),\n         }\n     }\n "}, {"sha": "9b7443f97ef1ffcda9b5d5477603575b65dfedad", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -68,14 +68,14 @@ impl<'tcx> Discr<'tcx> {\n         };\n \n         let bit_size = int.size().bits();\n-        let amt = 128 - bit_size;\n+        let shift = 128 - bit_size;\n         if signed {\n             let sext = |u| {\n                 let i = u as i128;\n-                (i << amt) >> amt\n+                (i << shift) >> shift\n             };\n             let min = sext(1_u128 << (bit_size - 1));\n-            let max = i128::max_value() >> amt;\n+            let max = i128::max_value() >> shift;\n             let val = sext(self.val);\n             assert!(n < (i128::max_value() as u128));\n             let n = n as i128;\n@@ -87,13 +87,13 @@ impl<'tcx> Discr<'tcx> {\n             };\n             // zero the upper bits\n             let val = val as u128;\n-            let val = (val << amt) >> amt;\n+            let val = (val << shift) >> shift;\n             (Self {\n                 val: val as u128,\n                 ty: self.ty,\n             }, oflo)\n         } else {\n-            let max = u128::max_value() >> amt;\n+            let max = u128::max_value() >> shift;\n             let val = self.val;\n             let oflo = val > max - n;\n             let val = if oflo {"}, {"sha": "6b5baa402b4ab88642e0821004e65e2a6bd2efbe", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -454,7 +454,7 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n                     adjust_for_rust_scalar(&mut a_attrs,\n                                            a,\n                                            arg.layout,\n-                                           Size::from_bytes(0),\n+                                           Size::ZERO,\n                                            false);\n                     adjust_for_rust_scalar(&mut b_attrs,\n                                            b,\n@@ -471,7 +471,7 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n                     adjust_for_rust_scalar(attrs,\n                                            scalar,\n                                            arg.layout,\n-                                           Size::from_bytes(0),\n+                                           Size::ZERO,\n                                            is_return);\n                 }\n             }"}, {"sha": "99f08540c716c660e3308ec4a79893c6d419b5b7", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -325,7 +325,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         MemberDescription {\n             name: \"data_ptr\".to_string(),\n             type_metadata: data_ptr_metadata,\n-            offset: Size::from_bytes(0),\n+            offset: Size::ZERO,\n             size: pointer_size,\n             align: pointer_align,\n             flags: DIFlags::FlagZero,\n@@ -1074,7 +1074,7 @@ impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n             MemberDescription {\n                 name: f.name.to_string(),\n                 type_metadata: type_metadata(cx, field.ty, self.span),\n-                offset: Size::from_bytes(0),\n+                offset: Size::ZERO,\n                 size,\n                 align,\n                 flags: DIFlags::FlagZero,\n@@ -1158,7 +1158,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     MemberDescription {\n                         name: \"\".to_string(),\n                         type_metadata: variant_type_metadata,\n-                        offset: Size::from_bytes(0),\n+                        offset: Size::ZERO,\n                         size: self.layout.size,\n                         align: self.layout.align,\n                         flags: DIFlags::FlagZero\n@@ -1187,7 +1187,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     MemberDescription {\n                         name: \"\".to_string(),\n                         type_metadata: variant_type_metadata,\n-                        offset: Size::from_bytes(0),\n+                        offset: Size::ZERO,\n                         size: variant.size,\n                         align: variant.align,\n                         flags: DIFlags::FlagZero\n@@ -1248,7 +1248,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     MemberDescription {\n                         name,\n                         type_metadata: variant_type_metadata,\n-                        offset: Size::from_bytes(0),\n+                        offset: Size::ZERO,\n                         size: variant.size,\n                         align: variant.align,\n                         flags: DIFlags::FlagZero\n@@ -1747,7 +1747,7 @@ pub fn create_vtable_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             name.as_ptr(),\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n-            Size::from_bytes(0).bits(),\n+            Size::ZERO.bits(),\n             cx.tcx.data_layout.pointer_align.abi_bits() as u32,\n             DIFlags::FlagArtificial,\n             ptr::null_mut(),"}, {"sha": "ef0bc3ed3306a9c561904fe6c1a24123b400b42c", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -14,9 +14,9 @@ use rustc_mir::interpret::{read_target_uint, const_val_field};\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::mir::interpret::{GlobalId, MemoryPointer, PrimVal, Allocation, ConstValue, AllocType};\n+use rustc::mir::interpret::{GlobalId, Pointer, Scalar, Allocation, ConstValue, AllocType};\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Scalar, Size};\n+use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Size};\n use builder::Builder;\n use common::{CodegenCx};\n use common::{C_bytes, C_struct, C_uint_big, C_undef, C_usize};\n@@ -28,22 +28,24 @@ use syntax::ast::Mutability;\n use super::super::callee;\n use super::FunctionCx;\n \n-pub fn primval_to_llvm(cx: &CodegenCx,\n-                       cv: PrimVal,\n-                       scalar: &Scalar,\n+pub fn scalar_to_llvm(cx: &CodegenCx,\n+                       cv: Scalar,\n+                       layout: &layout::Scalar,\n                        llty: Type) -> ValueRef {\n-    let bits = if scalar.is_bool() { 1 } else { scalar.value.size(cx).bits() };\n+    let bitsize = if layout.is_bool() { 1 } else { layout.value.size(cx).bits() };\n     match cv {\n-        PrimVal::Undef => C_undef(Type::ix(cx, bits)),\n-        PrimVal::Bytes(b) => {\n-            let llval = C_uint_big(Type::ix(cx, bits), b);\n-            if scalar.value == layout::Pointer {\n+        Scalar::Bits { defined, .. } if (defined as u64) < bitsize || defined == 0 => {\n+            C_undef(Type::ix(cx, bitsize))\n+        },\n+        Scalar::Bits { bits, .. } => {\n+            let llval = C_uint_big(Type::ix(cx, bitsize), bits);\n+            if layout.value == layout::Pointer {\n                 unsafe { llvm::LLVMConstIntToPtr(llval, llty.to_ref()) }\n             } else {\n                 consts::bitcast(llval, llty)\n             }\n         },\n-        PrimVal::Ptr(ptr) => {\n+        Scalar::Ptr(ptr) => {\n             let alloc_type = cx.tcx.alloc_map.lock().get(ptr.alloc_id);\n             let base_addr = match alloc_type {\n                 Some(AllocType::Memory(alloc)) => {\n@@ -68,7 +70,7 @@ pub fn primval_to_llvm(cx: &CodegenCx,\n                 &C_usize(cx, ptr.offset.bytes()),\n                 1,\n             ) };\n-            if scalar.value != layout::Pointer {\n+            if layout.value != layout::Pointer {\n                 unsafe { llvm::LLVMConstPtrToInt(llval, llty.to_ref()) }\n             } else {\n                 consts::bitcast(llval, llty)\n@@ -94,10 +96,10 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx, alloc: &Allocation) -> ValueRef {\n             layout.endian,\n             &alloc.bytes[offset..(offset + pointer_size)],\n         ).expect(\"const_alloc_to_llvm: could not read relocation pointer\") as u64;\n-        llvals.push(primval_to_llvm(\n+        llvals.push(scalar_to_llvm(\n             cx,\n-            PrimVal::Ptr(MemoryPointer { alloc_id, offset: Size::from_bytes(ptr_offset) }),\n-            &Scalar {\n+            Pointer { alloc_id, offset: Size::from_bytes(ptr_offset) }.into(),\n+            &layout::Scalar {\n                 value: layout::Primitive::Pointer,\n                 valid_range: 0..=!0\n             },\n@@ -197,13 +199,13 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                         c,\n                         constant.ty,\n                     )?;\n-                    if let Some(prim) = field.to_primval() {\n+                    if let Some(prim) = field.to_scalar() {\n                         let layout = bx.cx.layout_of(field_ty);\n                         let scalar = match layout.abi {\n                             layout::Abi::Scalar(ref x) => x,\n                             _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n                         };\n-                        Ok(primval_to_llvm(\n+                        Ok(scalar_to_llvm(\n                             bx.cx, prim, scalar,\n                             layout.immediate_llvm_type(bx.cx),\n                         ))"}, {"sha": "98383e882c4e8eeeb01ef9326e46a669825e85e4", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -28,7 +28,7 @@ use std::fmt;\n use std::ptr;\n \n use super::{FunctionCx, LocalRef};\n-use super::constant::{primval_to_llvm, const_alloc_to_llvm};\n+use super::constant::{scalar_to_llvm, const_alloc_to_llvm};\n use super::place::PlaceRef;\n \n /// The representation of a Rust value. The enum variant is in fact\n@@ -105,31 +105,31 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         }\n \n         let val = match val {\n-            ConstValue::ByVal(x) => {\n+            ConstValue::Scalar(x) => {\n                 let scalar = match layout.abi {\n                     layout::Abi::Scalar(ref x) => x,\n                     _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n                 };\n-                let llval = primval_to_llvm(\n+                let llval = scalar_to_llvm(\n                     bx.cx,\n                     x,\n                     scalar,\n                     layout.immediate_llvm_type(bx.cx),\n                 );\n                 OperandValue::Immediate(llval)\n             },\n-            ConstValue::ByValPair(a, b) => {\n+            ConstValue::ScalarPair(a, b) => {\n                 let (a_scalar, b_scalar) = match layout.abi {\n                     layout::Abi::ScalarPair(ref a, ref b) => (a, b),\n-                    _ => bug!(\"from_const: invalid ByValPair layout: {:#?}\", layout)\n+                    _ => bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout)\n                 };\n-                let a_llval = primval_to_llvm(\n+                let a_llval = scalar_to_llvm(\n                     bx.cx,\n                     a,\n                     a_scalar,\n                     layout.scalar_pair_element_llvm_type(bx.cx, 0),\n                 );\n-                let b_llval = primval_to_llvm(\n+                let b_llval = scalar_to_llvm(\n                     bx.cx,\n                     b,\n                     b_scalar,"}, {"sha": "88b75ff9c09439cbfa68c1241024ae1c06db99b2", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -15,6 +15,7 @@ use rustc::hir;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n use rustc_target::spec::PanicStrategy;\n+use rustc_target::abi::FloatTy;\n use mono_item::DefPathBasedNames;\n use type_::Type;\n \n@@ -40,7 +41,7 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             if use_x86_mmx {\n                 return Type::x86_mmx(cx)\n             } else {\n-                let element = layout.scalar_llvm_type_at(cx, element, Size::from_bytes(0));\n+                let element = layout.scalar_llvm_type_at(cx, element, Size::ZERO);\n                 return Type::vector(&element, count);\n             }\n         }\n@@ -120,7 +121,7 @@ fn struct_llfields<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     let field_count = layout.fields.count();\n \n     let mut packed = false;\n-    let mut offset = Size::from_bytes(0);\n+    let mut offset = Size::ZERO;\n     let mut prev_align = layout.align;\n     let mut result: Vec<Type> = Vec::with_capacity(1 + field_count * 2);\n     for i in layout.fields.index_by_increasing_offset() {\n@@ -265,7 +266,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                     );\n                     FnType::new(cx, sig, &[]).llvm_type(cx).ptr_to()\n                 }\n-                _ => self.scalar_llvm_type_at(cx, scalar, Size::from_bytes(0))\n+                _ => self.scalar_llvm_type_at(cx, scalar, Size::ZERO)\n             };\n             cx.scalar_lltypes.borrow_mut().insert(self.ty, llty);\n             return llty;\n@@ -324,8 +325,8 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                                scalar: &layout::Scalar, offset: Size) -> Type {\n         match scalar.value {\n             layout::Int(i, _) => Type::from_integer(cx, i),\n-            layout::F32 => Type::f32(cx),\n-            layout::F64 => Type::f64(cx),\n+            layout::Float(FloatTy::F32) => Type::f32(cx),\n+            layout::Float(FloatTy::F64) => Type::f64(cx),\n             layout::Pointer => {\n                 // If we know the alignment, pick something better than i8.\n                 let pointee = if let Some(pointee) = self.pointee_info_at(cx, offset) {\n@@ -372,7 +373,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         }\n \n         let offset = if index == 0 {\n-            Size::from_bytes(0)\n+            Size::ZERO\n         } else {\n             a.value.size(cx).abi_align(b.value.align(cx))\n         };"}, {"sha": "d660b40e9cb128bdc3c2f8eadaa063e75df11e69", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -202,7 +202,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                 value: ty::Const::from_bits(\n                                     this.hir.tcx(),\n                                     0,\n-                                    this.hir.tcx().types.u32),\n+                                    ty::ParamEnv::empty().and(this.hir.tcx().types.u32)),\n                             },\n                         }));\n                         box AggregateKind::Generator(closure_id, substs, movability)\n@@ -374,10 +374,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     // Helper to get a `-1` value of the appropriate type\n     fn neg_1_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n-        let bits = self.hir.integer_bit_width(ty);\n+        let param_ty = ty::ParamEnv::empty().and(self.hir.tcx().lift_to_global(&ty).unwrap());\n+        let bits = self.hir.tcx().layout_of(param_ty).unwrap().size.bits();\n         let n = (!0u128) >> (128 - bits);\n         let literal = Literal::Value {\n-            value: ty::Const::from_bits(self.hir.tcx(), n, ty)\n+            value: ty::Const::from_bits(self.hir.tcx(), n, param_ty)\n         };\n \n         self.literal_operand(span, ty, literal)\n@@ -386,10 +387,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     // Helper to get the minimum value of the appropriate type\n     fn minval_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         assert!(ty.is_signed());\n-        let bits = self.hir.integer_bit_width(ty);\n+        let param_ty = ty::ParamEnv::empty().and(self.hir.tcx().lift_to_global(&ty).unwrap());\n+        let bits = self.hir.tcx().layout_of(param_ty).unwrap().size.bits();\n         let n = 1 << (bits - 1);\n         let literal = Literal::Value {\n-            value: ty::Const::from_bits(self.hir.tcx(), n, ty)\n+            value: ty::Const::from_bits(self.hir.tcx(), n, param_ty)\n         };\n \n         self.literal_operand(span, ty, literal)"}, {"sha": "aa5727ee5c7ea67d1cce0032568ac73bfd17e17f", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -122,9 +122,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         match *match_pair.pattern.kind {\n             PatternKind::Constant { value } => {\n+                let switch_ty = ty::ParamEnv::empty().and(switch_ty);\n                 indices.entry(value)\n                        .or_insert_with(|| {\n-                           options.push(value.unwrap_bits(switch_ty));\n+                           options.push(value.unwrap_bits(self.hir.tcx(), switch_ty));\n                            options.len() - 1\n                        });\n                 true"}, {"sha": "5907a0cff8e6aa1bce7a252020cb37b0e4085791", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -52,17 +52,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     // Returns a zero literal operand for the appropriate type, works for\n     // bool, char and integers.\n     pub fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n-        match ty.sty {\n-            ty::TyBool |\n-            ty::TyChar |\n-            ty::TyUint(_) |\n-            ty::TyInt(_) => {}\n-            _ => {\n-                span_bug!(span, \"Invalid type for zero_literal: `{:?}`\", ty)\n-            }\n-        }\n         let literal = Literal::Value {\n-            value: ty::Const::from_bits(self.hir.tcx(), 0, ty)\n+            value: ty::Const::from_bits(self.hir.tcx(), 0, ty::ParamEnv::empty().and(ty))\n         };\n \n         self.literal_operand(span, ty, literal)"}, {"sha": "f6f98f0732e3ae525a96f8b313c75cc00c8d8bf9", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -614,7 +614,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 let idx = adt_def.variant_index_with_id(variant_id);\n                                 let (d, o) = adt_def.discriminant_def_for_variant(idx);\n                                 use rustc::ty::util::IntTypeExt;\n-                                let ty = adt_def.repr.discr_type().to_ty(cx.tcx());\n+                                let ty = adt_def.repr.discr_type();\n+                                let ty = ty.to_ty(cx.tcx());\n                                 Some((d, o, ty))\n                             }\n                             _ => None,\n@@ -634,7 +635,11 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             },\n                         },\n                     }.to_ref();\n-                    let offset = mk_const(ty::Const::from_bits(cx.tcx, offset as u128, ty));\n+                    let offset = mk_const(ty::Const::from_bits(\n+                        cx.tcx,\n+                        offset as u128,\n+                        cx.param_env.and(ty),\n+                    ));\n                     match did {\n                         Some(did) => {\n                             // in case we are offsetting from a computed discriminant"}, {"sha": "8ff1738394e1b12e03737440e47024096f3a8b50", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 29, "deletions": 34, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -21,9 +21,8 @@ use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::middle::region;\n use rustc::infer::InferCtxt;\n-use rustc::ty::layout::{IntegerExt, Size};\n use rustc::ty::subst::Subst;\n-use rustc::ty::{self, Ty, TyCtxt, layout};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{Kind, Substs};\n use syntax::ast::{self, LitKind};\n use syntax::attr;\n@@ -139,18 +138,6 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn integer_bit_width(\n-        &self,\n-        ty: Ty,\n-    ) -> u64 {\n-        let ty = match ty.sty {\n-            ty::TyInt(ity) => attr::IntType::SignedInt(ity),\n-            ty::TyUint(uty) => attr::IntType::UnsignedInt(uty),\n-            _ => bug!(\"{} is not an integer\", ty),\n-        };\n-        layout::Integer::from_attr(self.tcx, ty).size().bits()\n-    }\n-\n     // FIXME: Combine with rustc_mir::hair::pattern::lit_to_const\n     pub fn const_eval_literal(\n         &mut self,\n@@ -168,39 +155,41 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             })\n         };\n \n-        let clamp = |n| {\n-            let size = self.integer_bit_width(ty);\n-            trace!(\"clamp {} with size {} and amt {}\", n, size, 128 - size);\n-            let amt = 128 - size;\n-            let result = (n << amt) >> amt;\n-            trace!(\"clamp result: {}\", result);\n-            result\n+        let trunc = |n| {\n+            let param_ty = self.param_env.and(self.tcx.lift_to_global(&ty).unwrap());\n+            let bit_width = self.tcx.layout_of(param_ty).unwrap().size.bits();\n+            trace!(\"trunc {} with size {} and shift {}\", n, bit_width, 128 - bit_width);\n+            let shift = 128 - bit_width;\n+            let result = (n << shift) >> shift;\n+            trace!(\"trunc result: {}\", result);\n+            ConstValue::Scalar(Scalar::Bits {\n+                bits: result,\n+                defined: bit_width as u8,\n+            })\n         };\n \n         use rustc::mir::interpret::*;\n         let lit = match *lit {\n             LitKind::Str(ref s, _) => {\n                 let s = s.as_str();\n                 let id = self.tcx.allocate_bytes(s.as_bytes());\n-                let ptr = MemoryPointer::new(id, Size::from_bytes(0));\n-                ConstValue::ByValPair(\n-                    PrimVal::Ptr(ptr),\n-                    PrimVal::from_u128(s.len() as u128),\n-                )\n+                let value = Scalar::Ptr(id.into()).to_value_with_len(s.len() as u64, self.tcx);\n+                ConstValue::from_byval_value(value)\n             },\n             LitKind::ByteStr(ref data) => {\n                 let id = self.tcx.allocate_bytes(data);\n-                let ptr = MemoryPointer::new(id, Size::from_bytes(0));\n-                ConstValue::ByVal(PrimVal::Ptr(ptr))\n+                ConstValue::Scalar(Scalar::Ptr(id.into()))\n             },\n-            LitKind::Byte(n) => ConstValue::ByVal(PrimVal::Bytes(n as u128)),\n+            LitKind::Byte(n) => ConstValue::Scalar(Scalar::Bits {\n+                bits: n as u128,\n+                defined: 8,\n+            }),\n             LitKind::Int(n, _) if neg => {\n                 let n = n as i128;\n                 let n = n.overflowing_neg().0;\n-                let n = clamp(n as u128);\n-                ConstValue::ByVal(PrimVal::Bytes(n))\n+                trunc(n as u128)\n             },\n-            LitKind::Int(n, _) => ConstValue::ByVal(PrimVal::Bytes(clamp(n))),\n+            LitKind::Int(n, _) => trunc(n),\n             LitKind::Float(n, fty) => {\n                 parse_float(n, fty)\n             }\n@@ -211,8 +200,14 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                 };\n                 parse_float(n, fty)\n             }\n-            LitKind::Bool(b) => ConstValue::ByVal(PrimVal::Bytes(b as u128)),\n-            LitKind::Char(c) => ConstValue::ByVal(PrimVal::Bytes(c as u128)),\n+            LitKind::Bool(b) => ConstValue::Scalar(Scalar::Bits {\n+                bits: b as u128,\n+                defined: 8,\n+            }),\n+            LitKind::Char(c) => ConstValue::Scalar(Scalar::Bits {\n+                bits: c as u128,\n+                defined: 32,\n+            }),\n         };\n         Literal::Value {\n             value: ty::Const::from_const_value(self.tcx, lit, ty)"}, {"sha": "a7b2e205d006df27c72eabc76e9fa03944abea89", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -198,7 +198,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n                                     value: ty::Const::from_bits(\n                                         tcx,\n                                         *b as u128,\n-                                        tcx.types.u8)\n+                                        ty::ParamEnv::empty().and(tcx.types.u8))\n                                 }\n                             })\n                         }).collect()\n@@ -958,7 +958,7 @@ fn slice_pat_covered_by_constructor<'tcx>(\n     {\n         match pat.kind {\n             box PatternKind::Constant { value } => {\n-                let b = value.unwrap_bits(pat.ty);\n+                let b = value.unwrap_bits(tcx, ty::ParamEnv::empty().and(pat.ty));\n                 assert_eq!(b as u8 as u128, b);\n                 if b as u8 != *ch {\n                     return Ok(false);\n@@ -979,9 +979,9 @@ fn constructor_covered_by_range<'a, 'tcx>(\n     ty: Ty<'tcx>,\n ) -> Result<bool, ErrorReported> {\n     trace!(\"constructor_covered_by_range {:#?}, {:#?}, {:#?}, {}\", ctor, from, to, ty);\n-    let cmp_from = |c_from| compare_const_vals(tcx, c_from, from, ty)\n+    let cmp_from = |c_from| compare_const_vals(tcx, c_from, from, ty::ParamEnv::empty().and(ty))\n         .map(|res| res != Ordering::Less);\n-    let cmp_to = |c_to| compare_const_vals(tcx, c_to, to, ty);\n+    let cmp_to = |c_to| compare_const_vals(tcx, c_to, to, ty::ParamEnv::empty().and(ty));\n     macro_rules! some_or_ok {\n         ($e:expr) => {\n             match $e {"}, {"sha": "32cad88edb0379a358bfb927e575678e2a6e01dc", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 65, "deletions": 46, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -20,9 +20,8 @@ use interpret::{const_val_field, const_variant_index, self};\n \n use rustc::middle::const_val::ConstVal;\n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n-use rustc::mir::interpret::{PrimVal, GlobalId, ConstValue, Value};\n+use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, Value};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n-use rustc::ty::layout::Size;\n use rustc::ty::subst::{Substs, Kind};\n use rustc::hir::{self, PatKind, RangeEnd};\n use rustc::hir::def::{Def, CtorKind};\n@@ -360,8 +359,14 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     (PatternKind::Constant { value: lo },\n                      PatternKind::Constant { value: hi }) => {\n                         use std::cmp::Ordering;\n-                        match (end, compare_const_vals(self.tcx, lo, hi, ty).unwrap()) {\n-                            (RangeEnd::Excluded, Ordering::Less) =>\n+                        let cmp = compare_const_vals(\n+                            self.tcx,\n+                            lo,\n+                            hi,\n+                            self.param_env.and(ty),\n+                        );\n+                        match (end, cmp) {\n+                            (RangeEnd::Excluded, Some(Ordering::Less)) =>\n                                 PatternKind::Range { lo, hi, end },\n                             (RangeEnd::Excluded, _) => {\n                                 span_err!(\n@@ -372,7 +377,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                 );\n                                 PatternKind::Wild\n                             },\n-                            (RangeEnd::Included, Ordering::Greater) => {\n+                            (RangeEnd::Included, None) |\n+                            (RangeEnd::Included, Some(Ordering::Greater)) => {\n                                 let mut err = struct_span_err!(\n                                     self.tcx.sess,\n                                     lo_expr.span,\n@@ -393,7 +399,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                 err.emit();\n                                 PatternKind::Wild\n                             },\n-                            (RangeEnd::Included, _) => PatternKind::Range { lo, hi, end },\n+                            (RangeEnd::Included, Some(_)) => PatternKind::Range { lo, hi, end },\n                         }\n                     }\n                     _ => PatternKind::Wild\n@@ -1037,7 +1043,7 @@ pub fn compare_const_vals<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     a: &'tcx ty::Const<'tcx>,\n     b: &'tcx ty::Const<'tcx>,\n-    ty: Ty<'tcx>,\n+    ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n ) -> Option<Ordering> {\n     trace!(\"compare_const_vals: {:?}, {:?}\", a, b);\n \n@@ -1052,15 +1058,15 @@ pub fn compare_const_vals<'a, 'tcx>(\n     let fallback = || from_bool(a == b);\n \n     // Use the fallback if any type differs\n-    if a.ty != b.ty || a.ty != ty {\n+    if a.ty != b.ty || a.ty != ty.value {\n         return fallback();\n     }\n \n     // FIXME: This should use assert_bits(ty) instead of use_bits\n     // but triggers possibly bugs due to mismatching of arrays and slices\n-    if let (Some(a), Some(b)) = (a.to_bits(ty), b.to_bits(ty)) {\n+    if let (Some(a), Some(b)) = (a.to_bits(tcx, ty), b.to_bits(tcx, ty)) {\n         use ::rustc_apfloat::Float;\n-        return match ty.sty {\n+        return match ty.value.sty {\n             ty::TyFloat(ast::FloatTy::F32) => {\n                 let l = ::rustc_apfloat::ieee::Single::from_bits(a);\n                 let r = ::rustc_apfloat::ieee::Single::from_bits(b);\n@@ -1072,33 +1078,37 @@ pub fn compare_const_vals<'a, 'tcx>(\n                 l.partial_cmp(&r)\n             },\n             ty::TyInt(_) => {\n-                let a = interpret::sign_extend(tcx, a, ty).expect(\"layout error for TyInt\");\n-                let b = interpret::sign_extend(tcx, b, ty).expect(\"layout error for TyInt\");\n+                let a = interpret::sign_extend(tcx, a, ty.value).expect(\"layout error for TyInt\");\n+                let b = interpret::sign_extend(tcx, b, ty.value).expect(\"layout error for TyInt\");\n                 Some((a as i128).cmp(&(b as i128)))\n             },\n             _ => Some(a.cmp(&b)),\n         }\n     }\n \n-    if let ty::TyRef(_, rty, _) = ty.sty {\n+    if let ty::TyRef(_, rty, _) = ty.value.sty {\n         if let ty::TyStr = rty.sty {\n             match (a.to_byval_value(), b.to_byval_value()) {\n                 (\n-                    Some(Value::ByValPair(\n-                        PrimVal::Ptr(ptr_a),\n-                        PrimVal::Bytes(size_a))\n-                    ),\n-                    Some(Value::ByValPair(\n-                        PrimVal::Ptr(ptr_b),\n-                        PrimVal::Bytes(size_b))\n-                    )\n-                ) if size_a == size_b => {\n-                    if ptr_a.offset == Size::from_bytes(0) && ptr_b.offset == Size::from_bytes(0) {\n-                        let map = tcx.alloc_map.lock();\n-                        let alloc_a = map.unwrap_memory(ptr_a.alloc_id);\n-                        let alloc_b = map.unwrap_memory(ptr_b.alloc_id);\n-                        if alloc_a.bytes.len() as u64 == size_a as u64 {\n-                            return from_bool(alloc_a == alloc_b);\n+                    Some(Value::ScalarPair(\n+                        Scalar::Ptr(ptr_a),\n+                        len_a,\n+                    )),\n+                    Some(Value::ScalarPair(\n+                        Scalar::Ptr(ptr_b),\n+                        len_b,\n+                    ))\n+                ) if ptr_a.offset.bytes() == 0 && ptr_b.offset.bytes() == 0 => {\n+                    if let Ok(len_a) = len_a.to_bits(tcx.data_layout.pointer_size) {\n+                        if let Ok(len_b) = len_b.to_bits(tcx.data_layout.pointer_size) {\n+                            if len_a == len_b {\n+                                let map = tcx.alloc_map.lock();\n+                                let alloc_a = map.unwrap_memory(ptr_a.alloc_id);\n+                                let alloc_b = map.unwrap_memory(ptr_b.alloc_id);\n+                                if alloc_a.bytes.len() as u128 == len_a {\n+                                    return from_bool(alloc_a == alloc_b);\n+                                }\n+                            }\n                         }\n                     }\n                 }\n@@ -1123,33 +1133,32 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n         LitKind::Str(ref s, _) => {\n             let s = s.as_str();\n             let id = tcx.allocate_bytes(s.as_bytes());\n-            let ptr = MemoryPointer::new(id, Size::from_bytes(0));\n-            ConstValue::ByValPair(\n-                PrimVal::Ptr(ptr),\n-                PrimVal::from_u128(s.len() as u128),\n-            )\n+            let value = Scalar::Ptr(id.into()).to_value_with_len(s.len() as u64, tcx);\n+            ConstValue::from_byval_value(value)\n         },\n         LitKind::ByteStr(ref data) => {\n             let id = tcx.allocate_bytes(data);\n-            let ptr = MemoryPointer::new(id, Size::from_bytes(0));\n-            ConstValue::ByVal(PrimVal::Ptr(ptr))\n+            ConstValue::Scalar(Scalar::Ptr(id.into()))\n         },\n-        LitKind::Byte(n) => ConstValue::ByVal(PrimVal::Bytes(n as u128)),\n+        LitKind::Byte(n) => ConstValue::Scalar(Scalar::Bits {\n+            bits: n as u128,\n+            defined: 8,\n+        }),\n         LitKind::Int(n, _) => {\n             enum Int {\n                 Signed(IntTy),\n                 Unsigned(UintTy),\n             }\n-            let ty = match ty.sty {\n+            let ity = match ty.sty {\n                 ty::TyInt(IntTy::Isize) => Int::Signed(tcx.sess.target.isize_ty),\n                 ty::TyInt(other) => Int::Signed(other),\n                 ty::TyUint(UintTy::Usize) => Int::Unsigned(tcx.sess.target.usize_ty),\n                 ty::TyUint(other) => Int::Unsigned(other),\n                 _ => bug!(),\n             };\n             // This converts from LitKind::Int (which is sign extended) to\n-            // PrimVal::Bytes (which is zero extended)\n-            let n = match ty {\n+            // Scalar::Bytes (which is zero extended)\n+            let n = match ity {\n                 // FIXME(oli-obk): are these casts correct?\n                 Int::Signed(IntTy::I8) if neg =>\n                     (n as i8).overflowing_neg().0 as u8 as u128,\n@@ -1168,7 +1177,11 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n                 Int::Signed(IntTy::I128)| Int::Unsigned(UintTy::U128) => n,\n                 _ => bug!(),\n             };\n-            ConstValue::ByVal(PrimVal::Bytes(n))\n+            let defined = tcx.layout_of(ty::ParamEnv::empty().and(ty)).unwrap().size.bits() as u8;\n+            ConstValue::Scalar(Scalar::Bits {\n+                bits: n,\n+                defined,\n+            })\n         },\n         LitKind::Float(n, fty) => {\n             parse_float(n, fty, neg)?\n@@ -1180,8 +1193,14 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n             };\n             parse_float(n, fty, neg)?\n         }\n-        LitKind::Bool(b) => ConstValue::ByVal(PrimVal::Bytes(b as u128)),\n-        LitKind::Char(c) => ConstValue::ByVal(PrimVal::Bytes(c as u128)),\n+        LitKind::Bool(b) => ConstValue::Scalar(Scalar::Bits {\n+            bits: b as u128,\n+            defined: 8,\n+        }),\n+        LitKind::Char(c) => ConstValue::Scalar(Scalar::Bits {\n+            bits: c as u128,\n+            defined: 32,\n+        }),\n     };\n     Ok(ty::Const::from_const_value(tcx, lit, ty))\n }\n@@ -1194,7 +1213,7 @@ pub fn parse_float<'tcx>(\n     let num = num.as_str();\n     use rustc_apfloat::ieee::{Single, Double};\n     use rustc_apfloat::Float;\n-    let bits = match fty {\n+    let (bits, defined) = match fty {\n         ast::FloatTy::F32 => {\n             num.parse::<f32>().map_err(|_| ())?;\n             let mut f = num.parse::<Single>().unwrap_or_else(|e| {\n@@ -1203,7 +1222,7 @@ pub fn parse_float<'tcx>(\n             if neg {\n                 f = -f;\n             }\n-            f.to_bits()\n+            (f.to_bits(), 32)\n         }\n         ast::FloatTy::F64 => {\n             num.parse::<f64>().map_err(|_| ())?;\n@@ -1213,9 +1232,9 @@ pub fn parse_float<'tcx>(\n             if neg {\n                 f = -f;\n             }\n-            f.to_bits()\n+            (f.to_bits(), 64)\n         }\n     };\n \n-    Ok(ConstValue::ByVal(PrimVal::Bytes(bits)))\n+    Ok(ConstValue::Scalar(Scalar::Bits { bits, defined }))\n }"}, {"sha": "e69e7a522ab73e62bfdc7d5014db72f3cb7392a5", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 73, "deletions": 29, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -4,26 +4,27 @@ use syntax::ast::{FloatTy, IntTy, UintTy};\n \n use rustc_apfloat::ieee::{Single, Double};\n use super::{EvalContext, Machine};\n-use rustc::mir::interpret::{PrimVal, EvalResult, MemoryPointer, PointerArithmetic};\n+use rustc::mir::interpret::{Scalar, EvalResult, Pointer, PointerArithmetic};\n use rustc_apfloat::Float;\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    pub(super) fn cast_primval(\n+    pub(super) fn cast_scalar(\n         &self,\n-        val: PrimVal,\n+        val: Scalar,\n         src_ty: Ty<'tcx>,\n         dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, PrimVal> {\n+    ) -> EvalResult<'tcx, Scalar> {\n         use rustc::ty::TypeVariants::*;\n         trace!(\"Casting {:?}: {:?} to {:?}\", val, src_ty, dest_ty);\n \n         match val {\n-            PrimVal::Undef => Ok(PrimVal::Undef),\n-            PrimVal::Ptr(ptr) => self.cast_from_ptr(ptr, dest_ty),\n-            PrimVal::Bytes(b) => {\n+            Scalar::Bits { defined: 0, .. } => Ok(val),\n+            Scalar::Ptr(ptr) => self.cast_from_ptr(ptr, dest_ty),\n+            Scalar::Bits { bits, .. } => {\n+                // TODO(oli-obk): check defined bits here\n                 match src_ty.sty {\n-                    TyFloat(fty) => self.cast_from_float(b, fty, dest_ty),\n-                    _ => self.cast_from_int(b, src_ty, dest_ty),\n+                    TyFloat(fty) => self.cast_from_float(bits, fty, dest_ty),\n+                    _ => self.cast_from_int(bits, src_ty, dest_ty),\n                 }\n             }\n         }\n@@ -34,7 +35,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         v: u128,\n         src_ty: Ty<'tcx>,\n         dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, PrimVal> {\n+    ) -> EvalResult<'tcx, Scalar> {\n         let signed = self.layout_of(src_ty)?.abi.is_signed();\n         let v = if signed {\n             self.sign_extend(v, src_ty)?\n@@ -46,68 +47,111 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         match dest_ty.sty {\n             TyInt(_) | TyUint(_) => {\n                 let v = self.truncate(v, dest_ty)?;\n-                Ok(PrimVal::Bytes(v))\n+                Ok(Scalar::Bits {\n+                    bits: v,\n+                    defined: self.layout_of(dest_ty).unwrap().size.bits() as u8,\n+                })\n             }\n \n-            TyFloat(FloatTy::F32) if signed => Ok(PrimVal::Bytes(Single::from_i128(v as i128).value.to_bits())),\n-            TyFloat(FloatTy::F64) if signed => Ok(PrimVal::Bytes(Double::from_i128(v as i128).value.to_bits())),\n-            TyFloat(FloatTy::F32) => Ok(PrimVal::Bytes(Single::from_u128(v).value.to_bits())),\n-            TyFloat(FloatTy::F64) => Ok(PrimVal::Bytes(Double::from_u128(v).value.to_bits())),\n+            TyFloat(FloatTy::F32) if signed => Ok(Scalar::Bits {\n+                bits: Single::from_i128(v as i128).value.to_bits(),\n+                defined: 32,\n+            }),\n+            TyFloat(FloatTy::F64) if signed => Ok(Scalar::Bits {\n+                bits: Double::from_i128(v as i128).value.to_bits(),\n+                defined: 64,\n+            }),\n+            TyFloat(FloatTy::F32) => Ok(Scalar::Bits {\n+                bits: Single::from_u128(v).value.to_bits(),\n+                defined: 32,\n+            }),\n+            TyFloat(FloatTy::F64) => Ok(Scalar::Bits {\n+                bits: Double::from_u128(v).value.to_bits(),\n+                defined: 64,\n+            }),\n \n-            TyChar if v as u8 as u128 == v => Ok(PrimVal::Bytes(v)),\n+            TyChar if v as u8 as u128 == v => Ok(Scalar::Bits { bits: v, defined: 32 }),\n             TyChar => err!(InvalidChar(v)),\n \n             // No alignment check needed for raw pointers.  But we have to truncate to target ptr size.\n             TyRawPtr(_) => {\n-                Ok(PrimVal::Bytes(self.memory.truncate_to_ptr(v).0 as u128))\n+                Ok(Scalar::Bits {\n+                    bits: self.memory.truncate_to_ptr(v).0 as u128,\n+                    defined: self.memory.pointer_size().bits() as u8,\n+                })\n             },\n \n             // Casts to bool are not permitted by rustc, no need to handle them here.\n             _ => err!(Unimplemented(format!(\"int to {:?} cast\", dest_ty))),\n         }\n     }\n \n-    fn cast_from_float(&self, bits: u128, fty: FloatTy, dest_ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+    fn cast_from_float(&self, bits: u128, fty: FloatTy, dest_ty: Ty<'tcx>) -> EvalResult<'tcx, Scalar> {\n         use rustc::ty::TypeVariants::*;\n         use rustc_apfloat::FloatConvert;\n         match dest_ty.sty {\n             // float -> uint\n             TyUint(t) => {\n-                let width = t.bit_width().unwrap_or(self.memory.pointer_size().bytes() as usize * 8);\n+                let width = t.bit_width().unwrap_or(self.memory.pointer_size().bits() as usize);\n                 match fty {\n-                    FloatTy::F32 => Ok(PrimVal::Bytes(Single::from_bits(bits).to_u128(width).value)),\n-                    FloatTy::F64 => Ok(PrimVal::Bytes(Double::from_bits(bits).to_u128(width).value)),\n+                    FloatTy::F32 => Ok(Scalar::Bits {\n+                        bits: Single::from_bits(bits).to_u128(width).value,\n+                        defined: width as u8,\n+                    }),\n+                    FloatTy::F64 => Ok(Scalar::Bits {\n+                        bits: Double::from_bits(bits).to_u128(width).value,\n+                        defined: width as u8,\n+                    }),\n                 }\n             },\n             // float -> int\n             TyInt(t) => {\n-                let width = t.bit_width().unwrap_or(self.memory.pointer_size().bytes() as usize * 8);\n+                let width = t.bit_width().unwrap_or(self.memory.pointer_size().bits() as usize);\n                 match fty {\n-                    FloatTy::F32 => Ok(PrimVal::from_i128(Single::from_bits(bits).to_i128(width).value)),\n-                    FloatTy::F64 => Ok(PrimVal::from_i128(Double::from_bits(bits).to_i128(width).value)),\n+                    FloatTy::F32 => Ok(Scalar::Bits {\n+                        bits: Single::from_bits(bits).to_i128(width).value as u128,\n+                        defined: width as u8,\n+                    }),\n+                    FloatTy::F64 => Ok(Scalar::Bits {\n+                        bits: Double::from_bits(bits).to_i128(width).value as u128,\n+                        defined: width as u8,\n+                    }),\n                 }\n             },\n             // f64 -> f32\n             TyFloat(FloatTy::F32) if fty == FloatTy::F64 => {\n-                Ok(PrimVal::Bytes(Single::to_bits(Double::from_bits(bits).convert(&mut false).value)))\n+                Ok(Scalar::Bits {\n+                    bits: Single::to_bits(Double::from_bits(bits).convert(&mut false).value),\n+                    defined: 32,\n+                })\n             },\n             // f32 -> f64\n             TyFloat(FloatTy::F64) if fty == FloatTy::F32 => {\n-                Ok(PrimVal::Bytes(Double::to_bits(Single::from_bits(bits).convert(&mut false).value)))\n+                Ok(Scalar::Bits {\n+                    bits: Double::to_bits(Single::from_bits(bits).convert(&mut false).value),\n+                    defined: 64,\n+                })\n             },\n             // identity cast\n-            TyFloat(_) => Ok(PrimVal::Bytes(bits)),\n+            TyFloat(FloatTy:: F64) => Ok(Scalar::Bits {\n+                bits,\n+                defined: 64,\n+            }),\n+            TyFloat(FloatTy:: F32) => Ok(Scalar::Bits {\n+                bits,\n+                defined: 32,\n+            }),\n             _ => err!(Unimplemented(format!(\"float to {:?} cast\", dest_ty))),\n         }\n     }\n \n-    fn cast_from_ptr(&self, ptr: MemoryPointer, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+    fn cast_from_ptr(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Scalar> {\n         use rustc::ty::TypeVariants::*;\n         match ty.sty {\n             // Casting to a reference or fn pointer is not permitted by rustc, no need to support it here.\n             TyRawPtr(_) |\n             TyInt(IntTy::Isize) |\n-            TyUint(UintTy::Usize) => Ok(PrimVal::Ptr(ptr)),\n+            TyUint(UintTy::Usize) => Ok(ptr.into()),\n             TyInt(_) | TyUint(_) => err!(ReadPointerAsBytes),\n             _ => err!(Unimplemented(format!(\"ptr to {:?} cast\", ty))),\n         }"}, {"sha": "b1f290d7b614fc6b41d133cac840c46d6e276272", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -12,7 +12,7 @@ use syntax::codemap::DUMMY_SP;\n \n use rustc::mir::interpret::{\n     EvalResult, EvalError, EvalErrorKind, GlobalId,\n-    Value, Pointer, PrimVal, AllocId, Allocation, ConstValue,\n+    Value, Scalar, AllocId, Allocation, ConstValue,\n };\n use super::{Place, EvalContext, StackPopCleanup, ValTy, PlaceExtra, Memory, MemoryKind};\n \n@@ -65,7 +65,7 @@ pub fn eval_promoted<'a, 'mir, 'tcx>(\n     cid: GlobalId<'tcx>,\n     mir: &'mir mir::Mir<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> Option<(Value, Pointer, Ty<'tcx>)> {\n+) -> Option<(Value, Scalar, Ty<'tcx>)> {\n     ecx.with_fresh_body(|ecx| {\n         let res = eval_body_using_ecx(ecx, cid, Some(mir), param_env);\n         match res {\n@@ -82,7 +82,7 @@ pub fn eval_body<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cid: GlobalId<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> Option<(Value, Pointer, Ty<'tcx>)> {\n+) -> Option<(Value, Scalar, Ty<'tcx>)> {\n     let (res, ecx) = eval_body_and_ecx(tcx, cid, None, param_env);\n     match res {\n         Ok(val) => Some(val),\n@@ -100,18 +100,18 @@ pub fn value_to_const_value<'tcx>(\n ) -> &'tcx ty::Const<'tcx> {\n     let layout = ecx.tcx.layout_of(ty::ParamEnv::reveal_all().and(ty)).unwrap();\n     match (val, &layout.abi) {\n-        (Value::ByVal(PrimVal::Undef), _) if layout.is_zst() => {},\n+        (Value::Scalar(Scalar::Bits { defined: 0, ..}), _) if layout.is_zst() => {},\n         (Value::ByRef(..), _) |\n-        (Value::ByVal(_), &layout::Abi::Scalar(_)) |\n-        (Value::ByValPair(..), &layout::Abi::ScalarPair(..)) => {},\n+        (Value::Scalar(_), &layout::Abi::Scalar(_)) |\n+        (Value::ScalarPair(..), &layout::Abi::ScalarPair(..)) => {},\n         _ => bug!(\"bad value/layout combo: {:#?}, {:#?}\", val, layout),\n     }\n     let val = (|| {\n         match val {\n-            Value::ByVal(val) => Ok(ConstValue::ByVal(val)),\n-            Value::ByValPair(a, b) => Ok(ConstValue::ByValPair(a, b)),\n+            Value::Scalar(val) => Ok(ConstValue::Scalar(val)),\n+            Value::ScalarPair(a, b) => Ok(ConstValue::ScalarPair(a, b)),\n             Value::ByRef(ptr, align) => {\n-                let ptr = ptr.primval.to_ptr().unwrap();\n+                let ptr = ptr.to_ptr().unwrap();\n                 let alloc = ecx.memory.get(ptr.alloc_id)?;\n                 assert!(alloc.align.abi() >= align.abi());\n                 assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= layout.size.bytes());\n@@ -136,7 +136,7 @@ fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     cid: GlobalId<'tcx>,\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> (EvalResult<'tcx, (Value, Pointer, Ty<'tcx>)>, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>) {\n+) -> (EvalResult<'tcx, (Value, Scalar, Ty<'tcx>)>, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>) {\n     debug!(\"eval_body_and_ecx: {:?}, {:?}\", cid, param_env);\n     // we start out with the best span we have\n     // and try improving it down the road when more information is available\n@@ -152,7 +152,7 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     cid: GlobalId<'tcx>,\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, (Value, Pointer, Ty<'tcx>)> {\n+) -> EvalResult<'tcx, (Value, Scalar, Ty<'tcx>)> {\n     debug!(\"eval_body: {:?}, {:?}\", cid, param_env);\n     let tcx = ecx.tcx.tcx;\n     let mut mir = match mir {\n@@ -319,20 +319,31 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n             \"min_align_of\" => {\n                 let elem_ty = substs.type_at(0);\n                 let elem_align = ecx.layout_of(elem_ty)?.align.abi();\n-                let align_val = PrimVal::from_u128(elem_align as u128);\n-                ecx.write_primval(dest, align_val, dest_layout.ty)?;\n+                let align_val = Scalar::Bits {\n+                    bits: elem_align as u128,\n+                    defined: dest_layout.size.bits() as u8,\n+                };\n+                ecx.write_scalar(dest, align_val, dest_layout.ty)?;\n             }\n \n             \"size_of\" => {\n                 let ty = substs.type_at(0);\n                 let size = ecx.layout_of(ty)?.size.bytes() as u128;\n-                ecx.write_primval(dest, PrimVal::from_u128(size), dest_layout.ty)?;\n+                let size_val = Scalar::Bits {\n+                    bits: size,\n+                    defined: dest_layout.size.bits() as u8,\n+                };\n+                ecx.write_scalar(dest, size_val, dest_layout.ty)?;\n             }\n \n             \"type_id\" => {\n                 let ty = substs.type_at(0);\n                 let type_id = ecx.tcx.type_id_hash(ty) as u128;\n-                ecx.write_primval(dest, PrimVal::from_u128(type_id), dest_layout.ty)?;\n+                let id_val = Scalar::Bits {\n+                    bits: type_id,\n+                    defined: dest_layout.size.bits() as u8,\n+                };\n+                ecx.write_scalar(dest, id_val, dest_layout.ty)?;\n             }\n \n             name => return Err(ConstEvalError::NeedsRfc(format!(\"calling intrinsic `{}`\", name)).into()),\n@@ -349,12 +360,12 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n     fn try_ptr_op<'a>(\n         _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n-        left: PrimVal,\n+        left: Scalar,\n         _left_ty: Ty<'tcx>,\n-        right: PrimVal,\n+        right: Scalar,\n         _right_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>> {\n-        if left.is_bytes() && right.is_bytes() {\n+    ) -> EvalResult<'tcx, Option<(Scalar, bool)>> {\n+        if left.is_bits() && right.is_bits() {\n             Ok(None)\n         } else {\n             Err(\n@@ -419,7 +430,7 @@ pub fn const_val_field<'a, 'tcx>(\n         let layout = ecx.layout_of(ty)?;\n         let (ptr, align) = match value {\n             Value::ByRef(ptr, align) => (ptr, align),\n-            Value::ByValPair(..) | Value::ByVal(_) => {\n+            Value::ScalarPair(..) | Value::Scalar(_) => {\n                 let ptr = ecx.alloc_ptr(ty)?.into();\n                 ecx.write_value_to_ptr(value, ptr, layout.align, ty)?;\n                 (ptr, layout.align)\n@@ -436,9 +447,9 @@ pub fn const_val_field<'a, 'tcx>(\n         new_value = ecx.try_read_by_ref(new_value, layout.ty)?;\n         use rustc_data_structures::indexed_vec::Idx;\n         match (value, new_value) {\n-            (Value::ByVal(_), Value::ByRef(..)) |\n-            (Value::ByValPair(..), Value::ByRef(..)) |\n-            (Value::ByVal(_), Value::ByValPair(..)) => bug!(\n+            (Value::Scalar(_), Value::ByRef(..)) |\n+            (Value::ScalarPair(..), Value::ByRef(..)) |\n+            (Value::Scalar(_), Value::ScalarPair(..)) => bug!(\n                 \"field {} of {:?} yielded {:?}\",\n                 field.index(),\n                 value,\n@@ -469,16 +480,15 @@ pub fn const_variant_index<'a, 'tcx>(\n     let mut ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n     let value = ecx.const_value_to_value(val, ty)?;\n     let (ptr, align) = match value {\n-        Value::ByValPair(..) | Value::ByVal(_) => {\n+        Value::ScalarPair(..) | Value::Scalar(_) => {\n             let layout = ecx.layout_of(ty)?;\n-            let ptr = ecx.memory.allocate(layout.size, layout.align, Some(MemoryKind::Stack))?;\n-            let ptr: Pointer = ptr.into();\n+            let ptr = ecx.memory.allocate(layout.size, layout.align, Some(MemoryKind::Stack))?.into();\n             ecx.write_value_to_ptr(value, ptr, layout.align, ty)?;\n             (ptr, layout.align)\n         },\n         Value::ByRef(ptr, align) => (ptr, align),\n     };\n-    let place = Place::from_primval_ptr(ptr, align);\n+    let place = Place::from_scalar_ptr(ptr, align);\n     ecx.read_discriminant_as_variant_index(place, ty)\n }\n "}, {"sha": "9f6e376d3062afa417efc1088a607619133f2ee0", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 134, "deletions": 181, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -14,8 +14,8 @@ use rustc::middle::const_val::FrameInfo;\n use syntax::codemap::{self, Span};\n use syntax::ast::Mutability;\n use rustc::mir::interpret::{\n-    GlobalId, Value, Pointer, PrimVal, PrimValKind,\n-    EvalError, EvalResult, EvalErrorKind, MemoryPointer, ConstValue,\n+    GlobalId, Value, Scalar,\n+    EvalError, EvalResult, EvalErrorKind, Pointer, ConstValue,\n };\n use std::mem;\n \n@@ -74,9 +74,9 @@ pub struct Frame<'mir, 'tcx: 'mir> {\n     /// The list of locals for this stack frame, stored in order as\n     /// `[return_ptr, arguments..., variables..., temporaries...]`. The locals are stored as `Option<Value>`s.\n     /// `None` represents a local that is currently dead, while a live local\n-    /// can either directly contain `PrimVal` or refer to some part of an `Allocation`.\n+    /// can either directly contain `Scalar` or refer to some part of an `Allocation`.\n     ///\n-    /// Before being initialized, arguments are `Value::ByVal(PrimVal::Undef)` and other locals are `None`.\n+    /// Before being initialized, arguments are `Value::Scalar(Scalar::undef())` and other locals are `None`.\n     pub locals: IndexVec<mir::Local, Option<Value>>,\n \n     ////////////////////////////////////////////////////////////////////////////////\n@@ -203,7 +203,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         r\n     }\n \n-    pub fn alloc_ptr(&mut self, ty: Ty<'tcx>) -> EvalResult<'tcx, MemoryPointer> {\n+    pub fn alloc_ptr(&mut self, ty: Ty<'tcx>) -> EvalResult<'tcx, Pointer> {\n         let layout = self.layout_of(ty)?;\n         assert!(!layout.is_unsized(), \"cannot alloc memory for unsized type\");\n \n@@ -230,10 +230,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n     pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n         let ptr = self.memory.allocate_bytes(s.as_bytes());\n-        Ok(Value::ByValPair(\n-            PrimVal::Ptr(ptr),\n-            PrimVal::from_u128(s.len() as u128),\n-        ))\n+        Ok(Scalar::Ptr(ptr).to_value_with_len(s.len() as u64, self.tcx.tcx))\n     }\n \n     pub fn const_value_to_value(\n@@ -245,10 +242,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             ConstValue::ByRef(alloc, offset) => {\n                 // FIXME: Allocate new AllocId for all constants inside\n                 let id = self.memory.allocate_value(alloc.clone(), Some(MemoryKind::Stack))?;\n-                Ok(Value::ByRef(MemoryPointer::new(id, offset).into(), alloc.align))\n+                Ok(Value::ByRef(Pointer::new(id, offset).into(), alloc.align))\n             },\n-            ConstValue::ByValPair(a, b) => Ok(Value::ByValPair(a, b)),\n-            ConstValue::ByVal(val) => Ok(Value::ByVal(val)),\n+            ConstValue::ScalarPair(a, b) => Ok(Value::ScalarPair(a, b)),\n+            ConstValue::Scalar(val) => Ok(Value::Scalar(val)),\n         }\n     }\n \n@@ -408,7 +405,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         ::log_settings::settings().indentation += 1;\n \n         let locals = if mir.local_decls.len() > 1 {\n-            let mut locals = IndexVec::from_elem(Some(Value::ByVal(PrimVal::Undef)), &mir.local_decls);\n+            let mut locals = IndexVec::from_elem(Some(Value::Scalar(Scalar::undef())), &mir.local_decls);\n             match self.tcx.describe_def(instance.def_id()) {\n                 // statics and constants don't have `Storage*` statements, no need to look for them\n                 Some(Def::Static(..)) | Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {},\n@@ -543,9 +540,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             }\n \n             UnaryOp(un_op, ref operand) => {\n-                let val = self.eval_operand_to_primval(operand)?;\n+                let val = self.eval_operand_to_scalar(operand)?;\n                 let val = self.unary_op(un_op, val, dest_ty)?;\n-                self.write_primval(\n+                self.write_scalar(\n                     dest,\n                     val,\n                     dest_ty,\n@@ -596,7 +593,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n                 // FIXME: speed up repeat filling\n                 for i in 0..length {\n-                    let elem_dest = dest.offset(elem_size * i as u64, &self)?;\n+                    let elem_dest = dest.ptr_offset(elem_size * i as u64, &self)?;\n                     self.write_value_to_ptr(value, elem_dest, dest_align, elem_ty)?;\n                 }\n             }\n@@ -606,9 +603,13 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let src = self.eval_place(place)?;\n                 let ty = self.place_ty(place);\n                 let (_, len) = src.elem_ty_and_len(ty, self.tcx.tcx);\n-                self.write_primval(\n+                let defined = self.memory.pointer_size().bits() as u8;\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::from_u128(len as u128),\n+                    Scalar::Bits {\n+                        bits: len as u128,\n+                        defined,\n+                    },\n                     dest_ty,\n                 )?;\n             }\n@@ -621,7 +622,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n                 let val = match extra {\n                     PlaceExtra::None => ptr.to_value(),\n-                    PlaceExtra::Length(len) => ptr.to_value_with_len(len),\n+                    PlaceExtra::Length(len) => ptr.to_value_with_len(len, self.tcx.tcx),\n                     PlaceExtra::Vtable(vtable) => ptr.to_value_with_vtable(vtable),\n                     PlaceExtra::DowncastVariant(..) => {\n                         bug!(\"attempted to take a reference to an enum downcast place\")\n@@ -644,9 +645,13 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let layout = self.layout_of(ty)?;\n                 assert!(!layout.is_unsized(),\n                         \"SizeOf nullary MIR operator called for unsized type\");\n-                self.write_primval(\n+                let defined = self.memory.pointer_size().bits() as u8;\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::from_u128(layout.size.bytes() as u128),\n+                    Scalar::Bits {\n+                        bits: layout.size.bytes() as u128,\n+                        defined,\n+                    },\n                     dest_ty,\n                 )?;\n             }\n@@ -668,19 +673,19 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                             match (src.value, self.type_is_fat_ptr(dest_ty)) {\n                                 (Value::ByRef { .. }, _) |\n                                 // pointers to extern types\n-                                (Value::ByVal(_),_) |\n+                                (Value::Scalar(_),_) |\n                                 // slices and trait objects to other slices/trait objects\n-                                (Value::ByValPair(..), true) => {\n+                                (Value::ScalarPair(..), true) => {\n                                     let valty = ValTy {\n                                         value: src.value,\n                                         ty: dest_ty,\n                                     };\n                                     self.write_value(valty, dest)?;\n                                 }\n                                 // slices and trait objects to thin pointers (dropping the metadata)\n-                                (Value::ByValPair(data, _), false) => {\n+                                (Value::ScalarPair(data, _), false) => {\n                                     let valty = ValTy {\n-                                        value: Value::ByVal(data),\n+                                        value: Value::Scalar(data),\n                                         ty: dest_ty,\n                                     };\n                                     self.write_value(valty, dest)?;\n@@ -694,20 +699,28 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                                         let discr_val = def\n                                             .discriminant_for_variant(*self.tcx, index)\n                                             .val;\n-                                        return self.write_primval(\n+                                        let defined = self\n+                                            .layout_of(dest_ty)\n+                                            .unwrap()\n+                                            .size\n+                                            .bits() as u8;\n+                                        return self.write_scalar(\n                                             dest,\n-                                            PrimVal::Bytes(discr_val),\n+                                            Scalar::Bits {\n+                                                bits: discr_val,\n+                                                defined,\n+                                            },\n                                             dest_ty);\n                                     }\n                                 }\n                                 layout::Variants::Tagged { .. } |\n                                 layout::Variants::NicheFilling { .. } => {},\n                             }\n \n-                            let src_val = self.value_to_primval(src)?;\n-                            let dest_val = self.cast_primval(src_val, src.ty, dest_ty)?;\n+                            let src_val = self.value_to_scalar(src)?;\n+                            let dest_val = self.cast_scalar(src_val, src.ty, dest_ty)?;\n                             let valty = ValTy {\n-                                value: Value::ByVal(dest_val),\n+                                value: Value::Scalar(dest_val),\n                                 ty: dest_ty,\n                             };\n                             self.write_value(valty, dest)?;\n@@ -729,7 +742,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                                 ).ok_or_else(|| EvalErrorKind::TypeckError.into());\n                                 let fn_ptr = self.memory.create_fn_alloc(instance?);\n                                 let valty = ValTy {\n-                                    value: Value::ByVal(PrimVal::Ptr(fn_ptr)),\n+                                    value: Value::Scalar(fn_ptr.into()),\n                                     ty: dest_ty,\n                                 };\n                                 self.write_value(valty, dest)?;\n@@ -765,7 +778,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                                 );\n                                 let fn_ptr = self.memory.create_fn_alloc(instance);\n                                 let valty = ValTy {\n-                                    value: Value::ByVal(PrimVal::Ptr(fn_ptr)),\n+                                    value: Value::Scalar(fn_ptr.into()),\n                                     ty: dest_ty,\n                                 };\n                                 self.write_value(valty, dest)?;\n@@ -780,7 +793,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let ty = self.place_ty(place);\n                 let place = self.eval_place(place)?;\n                 let discr_val = self.read_discriminant_value(place, ty)?;\n-                self.write_primval(dest, PrimVal::Bytes(discr_val), dest_ty)?;\n+                let defined = self.layout_of(ty).unwrap().size.bits() as u8;\n+                self.write_scalar(dest, Scalar::Bits {\n+                    bits: discr_val,\n+                    defined,\n+                }, dest_ty)?;\n             }\n         }\n \n@@ -798,12 +815,12 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         }\n     }\n \n-    pub(super) fn eval_operand_to_primval(\n+    pub(super) fn eval_operand_to_scalar(\n         &mut self,\n         op: &mir::Operand<'tcx>,\n-    ) -> EvalResult<'tcx, PrimVal> {\n+    ) -> EvalResult<'tcx, Scalar> {\n         let valty = self.eval_operand(op)?;\n-        self.value_to_primval(valty)\n+        self.value_to_scalar(valty)\n     }\n \n     pub(crate) fn operands_to_args(\n@@ -901,7 +918,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n         let (discr_place, discr) = self.place_field(place, mir::Field::new(0), layout)?;\n         trace!(\"discr place: {:?}, {:?}\", discr_place, discr);\n-        let raw_discr = self.value_to_primval(ValTy {\n+        let raw_discr = self.value_to_scalar(ValTy {\n             value: self.read_place(discr_place)?,\n             ty: discr.ty\n         })?;\n@@ -910,22 +927,22 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             // FIXME: should we catch invalid discriminants here?\n             layout::Variants::Tagged { .. } => {\n                 if discr.ty.is_signed() {\n-                    let i = raw_discr.to_bytes()? as i128;\n+                    let i = raw_discr.to_bits(discr.size)? as i128;\n                     // going from layout tag type to typeck discriminant type\n                     // requires first sign extending with the layout discriminant\n-                    let amt = 128 - discr.size.bits();\n-                    let sexted = (i << amt) >> amt;\n+                    let shift = 128 - discr.size.bits();\n+                    let sexted = (i << shift) >> shift;\n                     // and then zeroing with the typeck discriminant type\n                     let discr_ty = ty\n                         .ty_adt_def().expect(\"tagged layout corresponds to adt\")\n                         .repr\n                         .discr_type();\n                     let discr_ty = layout::Integer::from_attr(self.tcx.tcx, discr_ty);\n-                    let amt = 128 - discr_ty.size().bits();\n+                    let shift = 128 - discr_ty.size().bits();\n                     let truncatee = sexted as u128;\n-                    (truncatee << amt) >> amt\n+                    (truncatee << shift) >> shift\n                 } else {\n-                    raw_discr.to_bytes()?\n+                    raw_discr.to_bits(discr.size)?\n                 }\n             },\n             layout::Variants::NicheFilling {\n@@ -937,12 +954,15 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let variants_start = *niche_variants.start() as u128;\n                 let variants_end = *niche_variants.end() as u128;\n                 match raw_discr {\n-                    PrimVal::Ptr(_) => {\n+                    Scalar::Ptr(_) => {\n                         assert!(niche_start == 0);\n                         assert!(variants_start == variants_end);\n                         dataful_variant as u128\n                     },\n-                    PrimVal::Bytes(raw_discr) => {\n+                    Scalar::Bits { bits: raw_discr, defined } => {\n+                        if defined < discr.size.bits() as u8 {\n+                            return err!(ReadUndefBytes);\n+                        }\n                         let discr = raw_discr.wrapping_sub(niche_start)\n                             .wrapping_add(variants_start);\n                         if variants_start <= discr && discr <= variants_end {\n@@ -951,7 +971,6 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                             dataful_variant as u128\n                         }\n                     },\n-                    PrimVal::Undef => return err!(ReadUndefBytes),\n                 }\n             }\n         };\n@@ -986,11 +1005,14 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 // their computation, but the in-memory tag is the smallest possible\n                 // representation\n                 let size = tag.value.size(self.tcx.tcx).bits();\n-                let amt = 128 - size;\n-                let discr_val = (discr_val << amt) >> amt;\n+                let shift = 128 - size;\n+                let discr_val = (discr_val << shift) >> shift;\n \n                 let (discr_dest, tag) = self.place_field(dest, mir::Field::new(0), layout)?;\n-                self.write_primval(discr_dest, PrimVal::Bytes(discr_val), tag.ty)?;\n+                self.write_scalar(discr_dest, Scalar::Bits {\n+                    bits: discr_val,\n+                    defined: size as u8,\n+                }, tag.ty)?;\n             }\n             layout::Variants::NicheFilling {\n                 dataful_variant,\n@@ -1003,7 +1025,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                         self.place_field(dest, mir::Field::new(0), layout)?;\n                     let niche_value = ((variant_index - niche_variants.start()) as u128)\n                         .wrapping_add(niche_start);\n-                    self.write_primval(niche_dest, PrimVal::Bytes(niche_value), niche.ty)?;\n+                    self.write_scalar(niche_dest, Scalar::Bits {\n+                        bits: niche_value,\n+                        defined: niche.size.bits() as u8,\n+                    }, niche.ty)?;\n                 }\n             }\n         }\n@@ -1019,8 +1044,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 .lock()\n                 .intern_static(gid.instance.def_id());\n             let layout = self.layout_of(ty)?;\n-            let ptr = MemoryPointer::new(alloc_id, Size::from_bytes(0));\n-            return Ok(Value::ByRef(ptr.into(), layout.align))\n+            return Ok(Value::ByRef(Scalar::Ptr(alloc_id.into()), layout.align))\n         }\n         let cv = self.const_eval(gid)?;\n         self.const_to_value(&cv.val, ty)\n@@ -1087,39 +1111,39 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         }\n     }\n \n-    pub fn value_to_primval(\n+    pub fn value_to_scalar(\n         &self,\n         ValTy { value, ty } : ValTy<'tcx>,\n-    ) -> EvalResult<'tcx, PrimVal> {\n+    ) -> EvalResult<'tcx, Scalar> {\n         match self.follow_by_ref_value(value, ty)? {\n             Value::ByRef { .. } => bug!(\"follow_by_ref_value can't result in `ByRef`\"),\n \n-            Value::ByVal(primval) => {\n+            Value::Scalar(scalar) => {\n                 // TODO: Do we really want insta-UB here?\n-                self.ensure_valid_value(primval, ty)?;\n-                Ok(primval)\n+                self.ensure_valid_value(scalar, ty)?;\n+                Ok(scalar)\n             }\n \n-            Value::ByValPair(..) => bug!(\"value_to_primval can't work with fat pointers\"),\n+            Value::ScalarPair(..) => bug!(\"value_to_scalar can't work with fat pointers\"),\n         }\n     }\n \n-    pub fn write_ptr(&mut self, dest: Place, val: Pointer, dest_ty: Ty<'tcx>) -> EvalResult<'tcx> {\n+    pub fn write_ptr(&mut self, dest: Place, val: Scalar, dest_ty: Ty<'tcx>) -> EvalResult<'tcx> {\n         let valty = ValTy {\n             value: val.to_value(),\n             ty: dest_ty,\n         };\n         self.write_value(valty, dest)\n     }\n \n-    pub fn write_primval(\n+    pub fn write_scalar(\n         &mut self,\n         dest: Place,\n-        val: PrimVal,\n+        val: Scalar,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         let valty = ValTy {\n-            value: Value::ByVal(val),\n+            value: Value::Scalar(val),\n             ty: dest_ty,\n         };\n         self.write_value(valty, dest)\n@@ -1132,7 +1156,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     ) -> EvalResult<'tcx> {\n         //trace!(\"Writing {:?} to {:?} at type {:?}\", src_val, dest, dest_ty);\n         // Note that it is really important that the type here is the right one, and matches the type things are read at.\n-        // In case `src_val` is a `ByValPair`, we don't do any magic here to handle padding properly, which is only\n+        // In case `src_val` is a `ScalarPair`, we don't do any magic here to handle padding properly, which is only\n         // correct if we never look at this data with the wrong type.\n \n         match dest {\n@@ -1201,7 +1225,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     pub fn write_value_to_ptr(\n         &mut self,\n         value: Value,\n-        dest: Pointer,\n+        dest: Scalar,\n         dest_align: Align,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n@@ -1211,115 +1235,49 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             Value::ByRef(ptr, align) => {\n                 self.memory.copy(ptr, align.min(layout.align), dest, dest_align.min(layout.align), layout.size, false)\n             }\n-            Value::ByVal(primval) => {\n+            Value::Scalar(scalar) => {\n                 let signed = match layout.abi {\n                     layout::Abi::Scalar(ref scal) => match scal.value {\n                         layout::Primitive::Int(_, signed) => signed,\n                         _ => false,\n                     },\n-                    _ if primval.is_undef() => false,\n-                    _ => bug!(\"write_value_to_ptr: invalid ByVal layout: {:#?}\", layout)\n+                    _ => match scalar {\n+                        Scalar::Bits { defined: 0, .. } => false,\n+                        _ => bug!(\"write_value_to_ptr: invalid ByVal layout: {:#?}\", layout),\n+                    }\n                 };\n-                self.memory.write_primval(dest, dest_align, primval, layout.size, signed)\n+                self.memory.write_scalar(dest, dest_align, scalar, layout.size, signed)\n             }\n-            Value::ByValPair(a_val, b_val) => {\n+            Value::ScalarPair(a_val, b_val) => {\n                 trace!(\"write_value_to_ptr valpair: {:#?}\", layout);\n                 let (a, b) = match layout.abi {\n                     layout::Abi::ScalarPair(ref a, ref b) => (&a.value, &b.value),\n-                    _ => bug!(\"write_value_to_ptr: invalid ByValPair layout: {:#?}\", layout)\n+                    _ => bug!(\"write_value_to_ptr: invalid ScalarPair layout: {:#?}\", layout)\n                 };\n                 let (a_size, b_size) = (a.size(&self), b.size(&self));\n                 let a_ptr = dest;\n                 let b_offset = a_size.abi_align(b.align(&self));\n-                let b_ptr = dest.offset(b_offset, &self)?.into();\n+                let b_ptr = dest.ptr_offset(b_offset, &self)?.into();\n                 // TODO: What about signedess?\n-                self.memory.write_primval(a_ptr, dest_align, a_val, a_size, false)?;\n-                self.memory.write_primval(b_ptr, dest_align, b_val, b_size, false)\n+                self.memory.write_scalar(a_ptr, dest_align, a_val, a_size, false)?;\n+                self.memory.write_scalar(b_ptr, dest_align, b_val, b_size, false)\n             }\n         }\n     }\n \n-    pub fn ty_to_primval_kind(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimValKind> {\n-        use syntax::ast::FloatTy;\n-\n-        let kind = match ty.sty {\n-            ty::TyBool => PrimValKind::Bool,\n-            ty::TyChar => PrimValKind::Char,\n-\n-            ty::TyInt(int_ty) => {\n-                use syntax::ast::IntTy::*;\n-                let size = match int_ty {\n-                    I8 => Size::from_bytes(1),\n-                    I16 => Size::from_bytes(2),\n-                    I32 => Size::from_bytes(4),\n-                    I64 => Size::from_bytes(8),\n-                    I128 => Size::from_bytes(16),\n-                    Isize => self.memory.pointer_size(),\n-                };\n-                PrimValKind::from_int_size(size)\n-            }\n-\n-            ty::TyUint(uint_ty) => {\n-                use syntax::ast::UintTy::*;\n-                let size = match uint_ty {\n-                    U8 => Size::from_bytes(1),\n-                    U16 => Size::from_bytes(2),\n-                    U32 => Size::from_bytes(4),\n-                    U64 => Size::from_bytes(8),\n-                    U128 => Size::from_bytes(16),\n-                    Usize => self.memory.pointer_size(),\n-                };\n-                PrimValKind::from_uint_size(size)\n-            }\n-\n-            ty::TyFloat(FloatTy::F32) => PrimValKind::F32,\n-            ty::TyFloat(FloatTy::F64) => PrimValKind::F64,\n-\n-            ty::TyFnPtr(_) => PrimValKind::FnPtr,\n-\n-            ty::TyRef(_, ty, _) |\n-            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) if self.type_is_sized(ty) => {\n-                PrimValKind::Ptr\n-            }\n-\n-            ty::TyAdt(def, _) if def.is_box() => PrimValKind::Ptr,\n-\n-            ty::TyAdt(..) => {\n-                match self.layout_of(ty)?.abi {\n-                    layout::Abi::Scalar(ref scalar) => {\n-                        use rustc::ty::layout::Primitive::*;\n-                        match scalar.value {\n-                            Int(i, false) => PrimValKind::from_uint_size(i.size()),\n-                            Int(i, true) => PrimValKind::from_int_size(i.size()),\n-                            F32 => PrimValKind::F32,\n-                            F64 => PrimValKind::F64,\n-                            Pointer => PrimValKind::Ptr,\n-                        }\n-                    }\n-\n-                    _ => return err!(TypeNotPrimitive(ty)),\n-                }\n-            }\n-\n-            _ => return err!(TypeNotPrimitive(ty)),\n-        };\n-\n-        Ok(kind)\n-    }\n-\n-    fn ensure_valid_value(&self, val: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n+    fn ensure_valid_value(&self, val: Scalar, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n         match ty.sty {\n-            ty::TyBool if val.to_bytes()? > 1 => err!(InvalidBool),\n+            ty::TyBool => val.to_bool().map(|_| ()),\n \n-            ty::TyChar if ::std::char::from_u32(val.to_bytes()? as u32).is_none() => {\n-                err!(InvalidChar(val.to_bytes()? as u32 as u128))\n+            ty::TyChar if ::std::char::from_u32(val.to_bits(Size::from_bytes(4))? as u32).is_none() => {\n+                err!(InvalidChar(val.to_bits(Size::from_bytes(4))? as u32 as u128))\n             }\n \n             _ => Ok(()),\n         }\n     }\n \n-    pub fn read_value(&self, ptr: Pointer, align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub fn read_value(&self, ptr: Scalar, align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         if let Some(val) = self.try_read_value(ptr, align, ty)? {\n             Ok(val)\n         } else {\n@@ -1329,12 +1287,12 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n     pub(crate) fn read_ptr(\n         &self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         ptr_align: Align,\n         pointee_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Value> {\n         let ptr_size = self.memory.pointer_size();\n-        let p: Pointer = self.memory.read_ptr_sized(ptr, ptr_align)?.into();\n+        let p: Scalar = self.memory.read_ptr_sized(ptr, ptr_align)?.into();\n         if self.type_is_sized(pointee_ty) {\n             Ok(p.to_value())\n         } else {\n@@ -1348,31 +1306,26 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     let len = self\n                         .memory\n                         .read_ptr_sized(extra, ptr_align)?\n-                        .to_bytes()?;\n-                    Ok(p.to_value_with_len(len as u64))\n+                        .to_bits(ptr_size)?;\n+                    Ok(p.to_value_with_len(len as u64, self.tcx.tcx))\n                 },\n-                _ => bug!(\"unsized primval ptr read from {:?}\", pointee_ty),\n+                _ => bug!(\"unsized scalar ptr read from {:?}\", pointee_ty),\n             }\n         }\n     }\n \n     pub fn validate_ptr_target(\n         &self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         ptr_align: Align,\n         ty: Ty<'tcx>\n     ) -> EvalResult<'tcx> {\n         match ty.sty {\n             ty::TyBool => {\n-                let val = self.memory.read_primval(ptr, ptr_align, Size::from_bytes(1))?;\n-                match val {\n-                    PrimVal::Bytes(0) | PrimVal::Bytes(1) => (),\n-                    // TODO: This seems a little overeager, should reading at bool type already be insta-UB?\n-                    _ => return err!(InvalidBool),\n-                }\n+                self.memory.read_scalar(ptr, ptr_align, Size::from_bytes(1))?.to_bool()?;\n             }\n             ty::TyChar => {\n-                let c = self.memory.read_primval(ptr, ptr_align, Size::from_bytes(4))?.to_bytes()? as u32;\n+                let c = self.memory.read_scalar(ptr, ptr_align, Size::from_bytes(4))?.to_bits(Size::from_bytes(4))? as u32;\n                 match ::std::char::from_u32(c) {\n                     Some(..) => (),\n                     None => return err!(InvalidChar(c as u128)),\n@@ -1395,7 +1348,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n                 if let layout::Abi::Scalar(ref scalar) = self.layout_of(ty)?.abi {\n                     let size = scalar.value.size(self);\n-                    self.memory.read_primval(ptr, ptr_align, size)?;\n+                    self.memory.read_scalar(ptr, ptr_align, size)?;\n                 }\n             }\n \n@@ -1405,7 +1358,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     }\n \n     pub fn try_read_by_ref(&self, mut val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n-        // Convert to ByVal or ByValPair if possible\n+        // Convert to ByVal or ScalarPair if possible\n         if let Value::ByRef(ptr, align) = val {\n             if let Some(read_val) = self.try_read_value(ptr, align, ty)? {\n                 val = read_val;\n@@ -1414,12 +1367,12 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         Ok(val)\n     }\n \n-    pub fn try_read_value(&self, ptr: Pointer, ptr_align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n+    pub fn try_read_value(&self, ptr: Scalar, ptr_align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n         let layout = self.layout_of(ty)?;\n         self.memory.check_align(ptr, ptr_align)?;\n \n         if layout.size.bytes() == 0 {\n-            return Ok(Some(Value::ByVal(PrimVal::Undef)));\n+            return Ok(Some(Value::Scalar(Scalar::undef())));\n         }\n \n         let ptr = ptr.to_ptr()?;\n@@ -1429,18 +1382,18 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n         match layout.abi {\n             layout::Abi::Scalar(..) => {\n-                let primval = self.memory.read_primval(ptr, ptr_align, layout.size)?;\n-                Ok(Some(Value::ByVal(primval)))\n+                let scalar = self.memory.read_scalar(ptr, ptr_align, layout.size)?;\n+                Ok(Some(Value::Scalar(scalar)))\n             }\n             layout::Abi::ScalarPair(ref a, ref b) => {\n                 let (a, b) = (&a.value, &b.value);\n                 let (a_size, b_size) = (a.size(self), b.size(self));\n                 let a_ptr = ptr;\n                 let b_offset = a_size.abi_align(b.align(self));\n                 let b_ptr = ptr.offset(b_offset, self)?.into();\n-                let a_val = self.memory.read_primval(a_ptr, ptr_align, a_size)?;\n-                let b_val = self.memory.read_primval(b_ptr, ptr_align, b_size)?;\n-                Ok(Some(Value::ByValPair(a_val, b_val)))\n+                let a_val = self.memory.read_scalar(a_ptr, ptr_align, a_size)?;\n+                let b_val = self.memory.read_scalar(b_ptr, ptr_align, b_size)?;\n+                Ok(Some(Value::ScalarPair(a_val, b_val)))\n             }\n             _ => Ok(None),\n         }\n@@ -1483,7 +1436,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let ptr = self.into_ptr(src)?;\n                 // u64 cast is from usize to u64, which is always good\n                 let valty = ValTy {\n-                    value: ptr.to_value_with_len(length.unwrap_usize(self.tcx.tcx)),\n+                    value: ptr.to_value_with_len(length.unwrap_usize(self.tcx.tcx), self.tcx.tcx),\n                     ty: dest_ty,\n                 };\n                 self.write_value(valty, dest)\n@@ -1558,12 +1511,12 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     }\n                     let (src_f_value, src_field) = match src {\n                         Value::ByRef(ptr, align) => {\n-                            let src_place = Place::from_primval_ptr(ptr, align);\n+                            let src_place = Place::from_scalar_ptr(ptr, align);\n                             let (src_f_place, src_field) =\n                                 self.place_field(src_place, mir::Field::new(i), src_layout)?;\n                             (self.read_place(src_f_place)?, src_field)\n                         }\n-                        Value::ByVal(_) | Value::ByValPair(..) => {\n+                        Value::Scalar(_) | Value::ScalarPair(..) => {\n                             let src_field = src_layout.field(&self, i)?;\n                             assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n                             assert_eq!(src_field.size, src_layout.size);\n@@ -1614,26 +1567,26 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                         }\n                     }\n                     Ok(Value::ByRef(ptr, align)) => {\n-                        match ptr.into_inner_primval() {\n-                            PrimVal::Ptr(ptr) => {\n+                        match ptr {\n+                            Scalar::Ptr(ptr) => {\n                                 write!(msg, \" by align({}) ref:\", align.abi()).unwrap();\n                                 allocs.push(ptr.alloc_id);\n                             }\n                             ptr => write!(msg, \" integral by ref: {:?}\", ptr).unwrap(),\n                         }\n                     }\n-                    Ok(Value::ByVal(val)) => {\n+                    Ok(Value::Scalar(val)) => {\n                         write!(msg, \" {:?}\", val).unwrap();\n-                        if let PrimVal::Ptr(ptr) = val {\n+                        if let Scalar::Ptr(ptr) = val {\n                             allocs.push(ptr.alloc_id);\n                         }\n                     }\n-                    Ok(Value::ByValPair(val1, val2)) => {\n+                    Ok(Value::ScalarPair(val1, val2)) => {\n                         write!(msg, \" ({:?}, {:?})\", val1, val2).unwrap();\n-                        if let PrimVal::Ptr(ptr) = val1 {\n+                        if let Scalar::Ptr(ptr) = val1 {\n                             allocs.push(ptr.alloc_id);\n                         }\n-                        if let PrimVal::Ptr(ptr) = val2 {\n+                        if let Scalar::Ptr(ptr) = val2 {\n                             allocs.push(ptr.alloc_id);\n                         }\n                     }\n@@ -1643,8 +1596,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 self.memory.dump_allocs(allocs);\n             }\n             Place::Ptr { ptr, align, .. } => {\n-                match ptr.into_inner_primval() {\n-                    PrimVal::Ptr(ptr) => {\n+                match ptr {\n+                    Scalar::Ptr(ptr) => {\n                         trace!(\"by align({}) ref:\", align.abi());\n                         self.memory.dump_alloc(ptr.alloc_id);\n                     }\n@@ -1797,7 +1750,7 @@ impl<'mir, 'tcx> Frame<'mir, 'tcx> {\n         trace!(\"{:?} is now live\", local);\n \n         // StorageLive *always* kills the value that's currently stored\n-        mem::replace(&mut self.locals[local], Some(Value::ByVal(PrimVal::Undef)))\n+        mem::replace(&mut self.locals[local], Some(Value::Scalar(Scalar::undef())))\n     }\n \n     /// Returns the old value of the local"}, {"sha": "4d04900320fe900553bfd28b67feb7ebb868effe", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -2,7 +2,7 @@\n //! This separation exists to ensure that no fancy miri features like\n //! interpreting common C functions leak into CTFE.\n \n-use rustc::mir::interpret::{AllocId, EvalResult, PrimVal, MemoryPointer, AccessKind, GlobalId};\n+use rustc::mir::interpret::{AllocId, EvalResult, Scalar, Pointer, AccessKind, GlobalId};\n use super::{EvalContext, Place, ValTy, Memory};\n \n use rustc::mir;\n@@ -54,11 +54,11 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn try_ptr_op<'a>(\n         ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n-        left: PrimVal,\n+        left: Scalar,\n         left_ty: Ty<'tcx>,\n-        right: PrimVal,\n+        right: Scalar,\n         right_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>>;\n+    ) -> EvalResult<'tcx, Option<(Scalar, bool)>>;\n \n     /// Called when trying to mark machine defined `MemoryKinds` as static\n     fn mark_static_initialized<'a>(\n@@ -92,7 +92,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n \n     fn check_locks<'a>(\n         _mem: &Memory<'a, 'mir, 'tcx, Self>,\n-        _ptr: MemoryPointer,\n+        _ptr: Pointer,\n         _size: Size,\n         _access: AccessKind,\n     ) -> EvalResult<'tcx> {"}, {"sha": "912fc64d3429c8e6d8c39b470c98228bcde83f3d", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 73, "deletions": 74, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -10,8 +10,8 @@ use syntax::ast::Mutability;\n use rustc::middle::const_val::{ConstVal, ErrKind};\n \n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n-use rustc::mir::interpret::{MemoryPointer, AllocId, Allocation, AccessKind, Value, Pointer,\n-                            EvalResult, PrimVal, EvalErrorKind, GlobalId, AllocType};\n+use rustc::mir::interpret::{Pointer, AllocId, Allocation, AccessKind, Value,\n+                            EvalResult, Scalar, EvalErrorKind, GlobalId, AllocType};\n pub use rustc::mir::interpret::{write_target_uint, write_target_int, read_target_uint};\n \n use super::{EvalContext, Machine};\n@@ -71,14 +71,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         self.alloc_map.iter().map(|(&id, alloc)| (id, alloc))\n     }\n \n-    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> MemoryPointer {\n-        let id = self.tcx.alloc_map.lock().create_fn_alloc(instance);\n-        MemoryPointer::new(id, Size::from_bytes(0))\n+    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> Pointer {\n+        self.tcx.alloc_map.lock().create_fn_alloc(instance).into()\n     }\n \n-    pub fn allocate_bytes(&mut self, bytes: &[u8]) -> MemoryPointer {\n-        let id = self.tcx.allocate_bytes(bytes);\n-        MemoryPointer::new(id, Size::from_bytes(0))\n+    pub fn allocate_bytes(&mut self, bytes: &[u8]) -> Pointer {\n+        self.tcx.allocate_bytes(bytes).into()\n     }\n \n     /// kind is `None` for statics\n@@ -108,20 +106,19 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         size: Size,\n         align: Align,\n         kind: Option<MemoryKind<M::MemoryKinds>>,\n-    ) -> EvalResult<'tcx, MemoryPointer> {\n-        let id = self.allocate_value(Allocation::undef(size, align), kind)?;\n-        Ok(MemoryPointer::new(id, Size::from_bytes(0)))\n+    ) -> EvalResult<'tcx, Pointer> {\n+        self.allocate_value(Allocation::undef(size, align), kind).map(Pointer::from)\n     }\n \n     pub fn reallocate(\n         &mut self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         old_size: Size,\n         old_align: Align,\n         new_size: Size,\n         new_align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n-    ) -> EvalResult<'tcx, MemoryPointer> {\n+    ) -> EvalResult<'tcx, Pointer> {\n         if ptr.offset.bytes() != 0 {\n             return err!(ReallocateNonBasePtr);\n         }\n@@ -151,7 +148,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(new_ptr)\n     }\n \n-    pub fn deallocate_local(&mut self, ptr: MemoryPointer) -> EvalResult<'tcx> {\n+    pub fn deallocate_local(&mut self, ptr: Pointer) -> EvalResult<'tcx> {\n         match self.alloc_kind.get(&ptr.alloc_id).cloned() {\n             Some(MemoryKind::Stack) => self.deallocate(ptr, None, MemoryKind::Stack),\n             // Happens if the memory was interned into immutable memory\n@@ -162,7 +159,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn deallocate(\n         &mut self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         size_and_align: Option<(Size, Align)>,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx> {\n@@ -228,22 +225,25 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     }\n \n     /// Check that the pointer is aligned AND non-NULL.\n-    pub fn check_align(&self, ptr: Pointer, required_align: Align) -> EvalResult<'tcx> {\n+    pub fn check_align(&self, ptr: Scalar, required_align: Align) -> EvalResult<'tcx> {\n         // Check non-NULL/Undef, extract offset\n-        let (offset, alloc_align) = match ptr.into_inner_primval() {\n-            PrimVal::Ptr(ptr) => {\n+        let (offset, alloc_align) = match ptr {\n+            Scalar::Ptr(ptr) => {\n                 let alloc = self.get(ptr.alloc_id)?;\n                 (ptr.offset.bytes(), alloc.align)\n             }\n-            PrimVal::Bytes(bytes) => {\n-                let v = ((bytes as u128) % (1 << self.pointer_size().bytes())) as u64;\n+            Scalar::Bits { bits, defined } => {\n+                if (defined as u64) < self.pointer_size().bits() {\n+                    return err!(ReadUndefBytes);\n+                }\n+                // FIXME: what on earth does this line do? docs or fix needed!\n+                let v = ((bits as u128) % (1 << self.pointer_size().bytes())) as u64;\n                 if v == 0 {\n                     return err!(InvalidNullPointerUsage);\n                 }\n                 // the base address if the \"integer allocation\" is 0 and hence always aligned\n                 (v, required_align)\n             }\n-            PrimVal::Undef => return err!(ReadUndefBytes),\n         };\n         // Check alignment\n         if alloc_align.abi() < required_align.abi() {\n@@ -263,7 +263,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn check_bounds(&self, ptr: MemoryPointer, access: bool) -> EvalResult<'tcx> {\n+    pub fn check_bounds(&self, ptr: Pointer, access: bool) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         let allocation_size = alloc.bytes.len() as u64;\n         if ptr.offset.bytes() > allocation_size {\n@@ -351,7 +351,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn get_fn(&self, ptr: MemoryPointer) -> EvalResult<'tcx, Instance<'tcx>> {\n+    pub fn get_fn(&self, ptr: Pointer) -> EvalResult<'tcx, Instance<'tcx>> {\n         if ptr.offset.bytes() != 0 {\n             return err!(InvalidFunctionPointer);\n         }\n@@ -448,7 +448,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             if !relocations.is_empty() {\n                 msg.clear();\n                 write!(msg, \"{:1$}\", \"\", prefix_len).unwrap(); // Print spaces.\n-                let mut pos = Size::from_bytes(0);\n+                let mut pos = Size::ZERO;\n                 let relocation_width = (self.pointer_size().bytes() - 1) * 3;\n                 for (i, target_id) in relocations {\n                     // this `as usize` is fine, since we can't print more chars than `usize::MAX`\n@@ -479,7 +479,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     fn get_bytes_unchecked(\n         &self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         size: Size,\n         align: Align,\n     ) -> EvalResult<'tcx, &[u8]> {\n@@ -499,7 +499,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     fn get_bytes_unchecked_mut(\n         &mut self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         size: Size,\n         align: Align,\n     ) -> EvalResult<'tcx, &mut [u8]> {\n@@ -517,7 +517,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(&mut alloc.bytes[offset..offset + size.bytes() as usize])\n     }\n \n-    fn get_bytes(&self, ptr: MemoryPointer, size: Size, align: Align) -> EvalResult<'tcx, &[u8]> {\n+    fn get_bytes(&self, ptr: Pointer, size: Size, align: Align) -> EvalResult<'tcx, &[u8]> {\n         assert_ne!(size.bytes(), 0);\n         if self.relocations(ptr, size)?.len() != 0 {\n             return err!(ReadPointerAsBytes);\n@@ -528,7 +528,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     fn get_bytes_mut(\n         &mut self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         size: Size,\n         align: Align,\n     ) -> EvalResult<'tcx, &mut [u8]> {\n@@ -594,9 +594,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn copy(\n         &mut self,\n-        src: Pointer,\n+        src: Scalar,\n         src_align: Align,\n-        dest: Pointer,\n+        dest: Scalar,\n         dest_align: Align,\n         size: Size,\n         nonoverlapping: bool,\n@@ -653,7 +653,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn read_c_str(&self, ptr: MemoryPointer) -> EvalResult<'tcx, &[u8]> {\n+    pub fn read_c_str(&self, ptr: Pointer) -> EvalResult<'tcx, &[u8]> {\n         let alloc = self.get(ptr.alloc_id)?;\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         let offset = ptr.offset.bytes() as usize;\n@@ -671,7 +671,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn read_bytes(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx, &[u8]> {\n+    pub fn read_bytes(&self, ptr: Scalar, size: Size) -> EvalResult<'tcx, &[u8]> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n         let align = Align::from_bytes(1, 1).unwrap();\n         self.check_align(ptr, align)?;\n@@ -681,7 +681,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         self.get_bytes(ptr.to_ptr()?, size, align)\n     }\n \n-    pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<'tcx> {\n+    pub fn write_bytes(&mut self, ptr: Scalar, src: &[u8]) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n         let align = Align::from_bytes(1, 1).unwrap();\n         self.check_align(ptr, align)?;\n@@ -693,7 +693,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: Size) -> EvalResult<'tcx> {\n+    pub fn write_repeat(&mut self, ptr: Scalar, val: u8, count: Size) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n         let align = Align::from_bytes(1, 1).unwrap();\n         self.check_align(ptr, align)?;\n@@ -707,17 +707,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn read_primval(&self, ptr: MemoryPointer, ptr_align: Align, size: Size) -> EvalResult<'tcx, PrimVal> {\n+    pub fn read_scalar(&self, ptr: Pointer, ptr_align: Align, size: Size) -> EvalResult<'tcx, Scalar> {\n         self.check_relocation_edges(ptr, size)?; // Make sure we don't read part of a pointer as a pointer\n         let endianness = self.endianness();\n         let bytes = self.get_bytes_unchecked(ptr, size, ptr_align.min(self.int_align(size)))?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n         if self.check_defined(ptr, size).is_err() {\n-            return Ok(PrimVal::Undef.into());\n+            return Ok(Scalar::undef().into());\n         }\n         // Now we do the actual reading\n-        let bytes = read_target_uint(endianness, bytes).unwrap();\n+        let bits = read_target_uint(endianness, bytes).unwrap();\n         // See if we got a pointer\n         if size != self.pointer_size() {\n             if self.relocations(ptr, size)?.len() != 0 {\n@@ -726,30 +726,33 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         } else {\n             let alloc = self.get(ptr.alloc_id)?;\n             match alloc.relocations.get(&ptr.offset) {\n-                Some(&alloc_id) => return Ok(PrimVal::Ptr(MemoryPointer::new(alloc_id, Size::from_bytes(bytes as u64)))),\n+                Some(&alloc_id) => return Ok(Pointer::new(alloc_id, Size::from_bytes(bits as u64)).into()),\n                 None => {},\n             }\n         }\n-        // We don't. Just return the bytes.\n-        Ok(PrimVal::Bytes(bytes))\n+        // We don't. Just return the bits.\n+        Ok(Scalar::Bits {\n+            bits,\n+            defined: size.bits() as u8,\n+        })\n     }\n \n-    pub fn read_ptr_sized(&self, ptr: MemoryPointer, ptr_align: Align) -> EvalResult<'tcx, PrimVal> {\n-        self.read_primval(ptr, ptr_align, self.pointer_size())\n+    pub fn read_ptr_sized(&self, ptr: Pointer, ptr_align: Align) -> EvalResult<'tcx, Scalar> {\n+        self.read_scalar(ptr, ptr_align, self.pointer_size())\n     }\n \n-    pub fn write_primval(&mut self, ptr: Pointer, ptr_align: Align, val: PrimVal, size: Size, signed: bool) -> EvalResult<'tcx> {\n+    pub fn write_scalar(&mut self, ptr: Scalar, ptr_align: Align, val: Scalar, size: Size, signed: bool) -> EvalResult<'tcx> {\n         let endianness = self.endianness();\n \n         let bytes = match val {\n-            PrimVal::Ptr(val) => {\n+            Scalar::Ptr(val) => {\n                 assert_eq!(size, self.pointer_size());\n                 val.offset.bytes() as u128\n             }\n \n-            PrimVal::Bytes(bytes) => bytes,\n+            Scalar::Bits { bits, defined } if defined as u64 >= size.bits() && size.bits() != 0 => bits,\n \n-            PrimVal::Undef => {\n+            Scalar::Bits { .. } => {\n                 self.check_align(ptr.into(), ptr_align)?;\n                 self.mark_definedness(ptr, size, false)?;\n                 return Ok(());\n@@ -770,7 +773,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n         // See if we have to also write a relocation\n         match val {\n-            PrimVal::Ptr(val) => {\n+            Scalar::Ptr(val) => {\n                 self.get_mut(ptr.alloc_id)?.relocations.insert(\n                     ptr.offset,\n                     val.alloc_id,\n@@ -782,9 +785,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn write_ptr_sized_unsigned(&mut self, ptr: MemoryPointer, ptr_align: Align, val: PrimVal) -> EvalResult<'tcx> {\n+    pub fn write_ptr_sized_unsigned(&mut self, ptr: Pointer, ptr_align: Align, val: Scalar) -> EvalResult<'tcx> {\n         let ptr_size = self.pointer_size();\n-        self.write_primval(ptr.into(), ptr_align, val, ptr_size, false)\n+        self.write_scalar(ptr.into(), ptr_align, val, ptr_size, false)\n     }\n \n     fn int_align(&self, size: Size) -> Align {\n@@ -806,15 +809,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     fn relocations(\n         &self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         size: Size,\n     ) -> EvalResult<'tcx, &[(Size, AllocId)]> {\n         let start = ptr.offset.bytes().saturating_sub(self.pointer_size().bytes() - 1);\n         let end = ptr.offset + size;\n         Ok(self.get(ptr.alloc_id)?.relocations.range(Size::from_bytes(start)..end))\n     }\n \n-    fn clear_relocations(&mut self, ptr: MemoryPointer, size: Size) -> EvalResult<'tcx> {\n+    fn clear_relocations(&mut self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n         // Find the start and end of the given range and its outermost relocations.\n         let (first, last) = {\n             // Find all relocations overlapping the given range.\n@@ -846,9 +849,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    fn check_relocation_edges(&self, ptr: MemoryPointer, size: Size) -> EvalResult<'tcx> {\n-        let overlapping_start = self.relocations(ptr, Size::from_bytes(0))?.len();\n-        let overlapping_end = self.relocations(ptr.offset(size, self)?, Size::from_bytes(0))?.len();\n+    fn check_relocation_edges(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n+        let overlapping_start = self.relocations(ptr, Size::ZERO)?.len();\n+        let overlapping_end = self.relocations(ptr.offset(size, self)?, Size::ZERO)?.len();\n         if overlapping_start + overlapping_end != 0 {\n             return err!(ReadPointerAsBytes);\n         }\n@@ -861,8 +864,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     // FIXME(solson): This is a very naive, slow version.\n     fn copy_undef_mask(\n         &mut self,\n-        src: MemoryPointer,\n-        dest: MemoryPointer,\n+        src: Pointer,\n+        dest: Pointer,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n@@ -882,7 +885,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    fn check_defined(&self, ptr: MemoryPointer, size: Size) -> EvalResult<'tcx> {\n+    fn check_defined(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         if !alloc.undef_mask.is_range_defined(\n             ptr.offset,\n@@ -896,7 +899,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn mark_definedness(\n         &mut self,\n-        ptr: Pointer,\n+        ptr: Scalar,\n         size: Size,\n         new_state: bool,\n     ) -> EvalResult<'tcx> {\n@@ -927,59 +930,55 @@ pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     fn into_ptr(\n         &self,\n         value: Value,\n-    ) -> EvalResult<'tcx, Pointer> {\n+    ) -> EvalResult<'tcx, Scalar> {\n         Ok(match value {\n             Value::ByRef(ptr, align) => {\n                 self.memory().read_ptr_sized(ptr.to_ptr()?, align)?\n             }\n-            Value::ByVal(ptr) |\n-            Value::ByValPair(ptr, _) => ptr,\n+            Value::Scalar(ptr) |\n+            Value::ScalarPair(ptr, _) => ptr,\n         }.into())\n     }\n \n     fn into_ptr_vtable_pair(\n         &self,\n         value: Value,\n-    ) -> EvalResult<'tcx, (Pointer, MemoryPointer)> {\n+    ) -> EvalResult<'tcx, (Scalar, Pointer)> {\n         match value {\n             Value::ByRef(ref_ptr, align) => {\n                 let mem = self.memory();\n                 let ptr = mem.read_ptr_sized(ref_ptr.to_ptr()?, align)?.into();\n                 let vtable = mem.read_ptr_sized(\n-                    ref_ptr.offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n+                    ref_ptr.ptr_offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n                     align\n                 )?.to_ptr()?;\n                 Ok((ptr, vtable))\n             }\n \n-            Value::ByValPair(ptr, vtable) => Ok((ptr.into(), vtable.to_ptr()?)),\n-\n-            Value::ByVal(PrimVal::Undef) => err!(ReadUndefBytes),\n+            Value::ScalarPair(ptr, vtable) => Ok((ptr.into(), vtable.to_ptr()?)),\n             _ => bug!(\"expected ptr and vtable, got {:?}\", value),\n         }\n     }\n \n     fn into_slice(\n         &self,\n         value: Value,\n-    ) -> EvalResult<'tcx, (Pointer, u64)> {\n+    ) -> EvalResult<'tcx, (Scalar, u64)> {\n         match value {\n             Value::ByRef(ref_ptr, align) => {\n                 let mem = self.memory();\n                 let ptr = mem.read_ptr_sized(ref_ptr.to_ptr()?, align)?.into();\n                 let len = mem.read_ptr_sized(\n-                    ref_ptr.offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n+                    ref_ptr.ptr_offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n                     align\n-                )?.to_bytes()? as u64;\n+                )?.to_bits(mem.pointer_size())? as u64;\n                 Ok((ptr, len))\n             }\n-            Value::ByValPair(ptr, val) => {\n-                let len = val.to_u128()?;\n-                assert_eq!(len as u64 as u128, len);\n+            Value::ScalarPair(ptr, val) => {\n+                let len = val.to_bits(self.memory().pointer_size())?;\n                 Ok((ptr.into(), len as u64))\n             }\n-            Value::ByVal(PrimVal::Undef) => err!(ReadUndefBytes),\n-            Value::ByVal(_) => bug!(\"expected ptr and length, got {:?}\", value),\n+            Value::Scalar(_) => bug!(\"expected ptr and length, got {:?}\", value),\n         }\n     }\n }"}, {"sha": "b5b4ac6df6b5e00caef78f555e1f8ec56d294556", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -43,17 +43,17 @@ pub fn sign_extend<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, value: u128, ty: Ty<'t\n     let size = layout.size.bits();\n     assert!(layout.abi.is_signed());\n     // sign extend\n-    let amt = 128 - size;\n+    let shift = 128 - size;\n     // shift the unsigned value to the left\n     // and back to the right as signed (essentially fills with FF on the left)\n-    Ok((((value << amt) as i128) >> amt) as u128)\n+    Ok((((value << shift) as i128) >> shift) as u128)\n }\n \n pub fn truncate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, value: u128, ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n     let param_env = ParamEnv::empty();\n     let layout = tcx.layout_of(param_env.and(ty)).map_err(|layout| EvalErrorKind::Layout(layout))?;\n     let size = layout.size.bits();\n-    let amt = 128 - size;\n+    let shift = 128 - size;\n     // truncate (shift left to drop out leftover values, shift right to fill with zeroes)\n-    Ok((value << amt) >> amt)\n+    Ok((value << shift) >> shift)\n }"}, {"sha": "8a2a78daa357052ec896c71bf4b81a629b15c604", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 75, "deletions": 49, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -1,23 +1,23 @@\n use rustc::mir;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, Ty, layout};\n use syntax::ast::FloatTy;\n use rustc::ty::layout::LayoutOf;\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n \n use super::{EvalContext, Place, Machine, ValTy};\n \n-use rustc::mir::interpret::{EvalResult, PrimVal, Value};\n+use rustc::mir::interpret::{EvalResult, Scalar, Value};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn binop_with_overflow(\n         &mut self,\n         op: mir::BinOp,\n         left: ValTy<'tcx>,\n         right: ValTy<'tcx>,\n-    ) -> EvalResult<'tcx, (PrimVal, bool)> {\n-        let left_val = self.value_to_primval(left)?;\n-        let right_val = self.value_to_primval(right)?;\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+        let left_val = self.value_to_scalar(left)?;\n+        let right_val = self.value_to_scalar(right)?;\n         self.binary_op(op, left_val, left.ty, right_val, right.ty)\n     }\n \n@@ -32,7 +32,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         let (val, overflowed) = self.binop_with_overflow(op, left, right)?;\n-        let val = Value::ByValPair(val, PrimVal::from_bool(overflowed));\n+        let val = Value::ScalarPair(val, Scalar::from_bool(overflowed));\n         let valty = ValTy {\n             value: val,\n             ty: dest_ty,\n@@ -51,7 +51,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, bool> {\n         let (val, overflowed) = self.binop_with_overflow(op, left, right)?;\n-        self.write_primval(dest, val, dest_ty)?;\n+        self.write_scalar(dest, val, dest_ty)?;\n         Ok(overflowed)\n     }\n }\n@@ -61,15 +61,24 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn binary_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: PrimVal,\n+        left: Scalar,\n         left_ty: Ty<'tcx>,\n-        right: PrimVal,\n+        right: Scalar,\n         right_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, (PrimVal, bool)> {\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n         use rustc::mir::BinOp::*;\n \n-        let left_kind = self.ty_to_primval_kind(left_ty)?;\n-        let right_kind = self.ty_to_primval_kind(right_ty)?;\n+        let left_layout = self.layout_of(left_ty)?;\n+        let right_layout = self.layout_of(right_ty)?;\n+\n+        let left_kind = match left_layout.abi {\n+            layout::Abi::Scalar(ref scalar) => scalar.value,\n+            _ => return err!(TypeNotPrimitive(left_ty)),\n+        };\n+        let right_kind = match right_layout.abi {\n+            layout::Abi::Scalar(ref scalar) => scalar.value,\n+            _ => return err!(TypeNotPrimitive(right_ty)),\n+        };\n         trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n \n         // I: Handle operations that support pointers\n@@ -80,10 +89,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         }\n \n         // II: From now on, everything must be bytes, no pointers\n-        let l = left.to_bytes()?;\n-        let r = right.to_bytes()?;\n-\n-        let left_layout = self.layout_of(left_ty)?;\n+        let l = left.to_bits(left_layout.size)?;\n+        let r = right.to_bits(right_layout.size)?;\n \n         // These ops can have an RHS with a different numeric type.\n         if right_kind.is_int() && (bin_op == Shl || bin_op == Shr) {\n@@ -110,7 +117,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 }\n             };\n             let truncated = self.truncate(result, left_ty)?;\n-            return Ok((PrimVal::Bytes(truncated), oflo));\n+            return Ok((Scalar::Bits {\n+                bits: truncated,\n+                defined: size as u8,\n+            }, oflo));\n         }\n \n         if left_kind != right_kind {\n@@ -136,7 +146,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             if let Some(op) = op {\n                 let l = self.sign_extend(l, left_ty)? as i128;\n                 let r = self.sign_extend(r, right_ty)? as i128;\n-                return Ok((PrimVal::from_bool(op(&l, &r)), false));\n+                return Ok((Scalar::from_bool(op(&l, &r)), false));\n             }\n             let op: Option<fn(i128, i128) -> (i128, bool)> = match bin_op {\n                 Div if r == 0 => return err!(DivisionByZero),\n@@ -156,7 +166,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     Rem | Div => {\n                         // int_min / -1\n                         if r == -1 && l == (1 << (size - 1)) {\n-                            return Ok((PrimVal::Bytes(l), true));\n+                            return Ok((Scalar::Bits { bits: l, defined: size as u8 }, true));\n                         }\n                     },\n                     _ => {},\n@@ -170,51 +180,60 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 }\n                 let result = result as u128;\n                 let truncated = self.truncate(result, left_ty)?;\n-                return Ok((PrimVal::Bytes(truncated), oflo));\n+                return Ok((Scalar::Bits {\n+                    bits: truncated,\n+                    defined: size as u8,\n+                }, oflo));\n             }\n         }\n \n         if let ty::TyFloat(fty) = left_ty.sty {\n             macro_rules! float_math {\n-                ($ty:path) => {{\n+                ($ty:path, $bitsize:expr) => {{\n                     let l = <$ty>::from_bits(l);\n                     let r = <$ty>::from_bits(r);\n+                    let bitify = |res: ::rustc_apfloat::StatusAnd<$ty>| Scalar::Bits {\n+                        bits: res.value.to_bits(),\n+                        defined: $bitsize,\n+                    };\n                     let val = match bin_op {\n-                        Eq => PrimVal::from_bool(l == r),\n-                        Ne => PrimVal::from_bool(l != r),\n-                        Lt => PrimVal::from_bool(l < r),\n-                        Le => PrimVal::from_bool(l <= r),\n-                        Gt => PrimVal::from_bool(l > r),\n-                        Ge => PrimVal::from_bool(l >= r),\n-                        Add => PrimVal::Bytes((l + r).value.to_bits()),\n-                        Sub => PrimVal::Bytes((l - r).value.to_bits()),\n-                        Mul => PrimVal::Bytes((l * r).value.to_bits()),\n-                        Div => PrimVal::Bytes((l / r).value.to_bits()),\n-                        Rem => PrimVal::Bytes((l % r).value.to_bits()),\n+                        Eq => Scalar::from_bool(l == r),\n+                        Ne => Scalar::from_bool(l != r),\n+                        Lt => Scalar::from_bool(l < r),\n+                        Le => Scalar::from_bool(l <= r),\n+                        Gt => Scalar::from_bool(l > r),\n+                        Ge => Scalar::from_bool(l >= r),\n+                        Add => bitify(l + r),\n+                        Sub => bitify(l - r),\n+                        Mul => bitify(l * r),\n+                        Div => bitify(l / r),\n+                        Rem => bitify(l % r),\n                         _ => bug!(\"invalid float op: `{:?}`\", bin_op),\n                     };\n                     return Ok((val, false));\n                 }};\n             }\n             match fty {\n-                FloatTy::F32 => float_math!(Single),\n-                FloatTy::F64 => float_math!(Double),\n+                FloatTy::F32 => float_math!(Single, 32),\n+                FloatTy::F64 => float_math!(Double, 64),\n             }\n         }\n \n+        let bit_width = self.layout_of(left_ty).unwrap().size.bits() as u8;\n+\n         // only ints left\n         let val = match bin_op {\n-            Eq => PrimVal::from_bool(l == r),\n-            Ne => PrimVal::from_bool(l != r),\n+            Eq => Scalar::from_bool(l == r),\n+            Ne => Scalar::from_bool(l != r),\n \n-            Lt => PrimVal::from_bool(l < r),\n-            Le => PrimVal::from_bool(l <= r),\n-            Gt => PrimVal::from_bool(l > r),\n-            Ge => PrimVal::from_bool(l >= r),\n+            Lt => Scalar::from_bool(l < r),\n+            Le => Scalar::from_bool(l <= r),\n+            Gt => Scalar::from_bool(l > r),\n+            Ge => Scalar::from_bool(l >= r),\n \n-            BitOr => PrimVal::Bytes(l | r),\n-            BitAnd => PrimVal::Bytes(l & r),\n-            BitXor => PrimVal::Bytes(l ^ r),\n+            BitOr => Scalar::Bits { bits: l | r, defined: bit_width },\n+            BitAnd => Scalar::Bits { bits: l & r, defined: bit_width },\n+            BitXor => Scalar::Bits { bits: l ^ r, defined: bit_width },\n \n             Add | Sub | Mul | Rem | Div => {\n                 let op: fn(u128, u128) -> (u128, bool) = match bin_op {\n@@ -229,7 +248,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 };\n                 let (result, oflo) = op(l, r);\n                 let truncated = self.truncate(result, left_ty)?;\n-                return Ok((PrimVal::Bytes(truncated), oflo || truncated != result));\n+                return Ok((Scalar::Bits {\n+                    bits: truncated,\n+                    defined: bit_width,\n+                }, oflo || truncated != result));\n             }\n \n             _ => {\n@@ -251,15 +273,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn unary_op(\n         &self,\n         un_op: mir::UnOp,\n-        val: PrimVal,\n+        val: Scalar,\n         ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, PrimVal> {\n+    ) -> EvalResult<'tcx, Scalar> {\n         use rustc::mir::UnOp::*;\n         use rustc_apfloat::ieee::{Single, Double};\n         use rustc_apfloat::Float;\n \n-        let bytes = val.to_bytes()?;\n-        let size = self.layout_of(ty)?.size.bits();\n+        let size = self.layout_of(ty)?.size;\n+        let bytes = val.to_bits(size)?;\n+        let size = size.bits();\n \n         let result_bytes = match (un_op, &ty.sty) {\n \n@@ -274,6 +297,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             (Neg, _) => (-(bytes as i128)) as u128,\n         };\n \n-        Ok(PrimVal::Bytes(self.truncate(result_bytes, ty)?))\n+        Ok(Scalar::Bits {\n+            bits: self.truncate(result_bytes, ty)?,\n+            defined: size as u8,\n+        })\n     }\n }"}, {"sha": "c1bcffe7e9aa5812b2956a61a9b7360f24a1a29f", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -1,9 +1,9 @@\n use rustc::mir;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{self, Align, LayoutOf, TyLayout, Size};\n+use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n use rustc_data_structures::indexed_vec::Idx;\n \n-use rustc::mir::interpret::{GlobalId, Value, PrimVal, EvalResult, Pointer, MemoryPointer};\n+use rustc::mir::interpret::{GlobalId, Value, Scalar, EvalResult, Pointer};\n use super::{EvalContext, Machine, ValTy};\n use interpret::memory::HasMemory;\n \n@@ -14,7 +14,7 @@ pub enum Place {\n         /// A place may have an invalid (integral or undef) pointer,\n         /// since it might be turned back into a reference\n         /// before ever being dereferenced.\n-        ptr: Pointer,\n+        ptr: Scalar,\n         align: Align,\n         extra: PlaceExtra,\n     },\n@@ -28,42 +28,42 @@ pub enum Place {\n pub enum PlaceExtra {\n     None,\n     Length(u64),\n-    Vtable(MemoryPointer),\n+    Vtable(Pointer),\n     DowncastVariant(usize),\n }\n \n impl<'tcx> Place {\n     /// Produces a Place that will error if attempted to be read from\n     pub fn undef() -> Self {\n-        Self::from_primval_ptr(PrimVal::Undef.into(), Align::from_bytes(1, 1).unwrap())\n+        Self::from_scalar_ptr(Scalar::undef().into(), Align::from_bytes(1, 1).unwrap())\n     }\n \n-    pub fn from_primval_ptr(ptr: Pointer, align: Align) -> Self {\n+    pub fn from_scalar_ptr(ptr: Scalar, align: Align) -> Self {\n         Place::Ptr {\n             ptr,\n             align,\n             extra: PlaceExtra::None,\n         }\n     }\n \n-    pub fn from_ptr(ptr: MemoryPointer, align: Align) -> Self {\n-        Self::from_primval_ptr(ptr.into(), align)\n+    pub fn from_ptr(ptr: Pointer, align: Align) -> Self {\n+        Self::from_scalar_ptr(ptr.into(), align)\n     }\n \n-    pub fn to_ptr_align_extra(self) -> (Pointer, Align, PlaceExtra) {\n+    pub fn to_ptr_align_extra(self) -> (Scalar, Align, PlaceExtra) {\n         match self {\n             Place::Ptr { ptr, align, extra } => (ptr, align, extra),\n             _ => bug!(\"to_ptr_and_extra: expected Place::Ptr, got {:?}\", self),\n \n         }\n     }\n \n-    pub fn to_ptr_align(self) -> (Pointer, Align) {\n+    pub fn to_ptr_align(self) -> (Scalar, Align) {\n         let (ptr, align, _extra) = self.to_ptr_align_extra();\n         (ptr, align)\n     }\n \n-    pub fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n+    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n         // At this point, we forget about the alignment information -- the place has been turned into a reference,\n         // and no matter where it came from, it now must be aligned.\n         self.to_ptr_align().0.to_ptr()\n@@ -128,17 +128,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let field_index = field.index();\n         let field = base_layout.field(self, field_index)?;\n         if field.size.bytes() == 0 {\n-            return Ok(Some((Value::ByVal(PrimVal::Undef), field.ty)))\n+            return Ok(Some((Value::Scalar(Scalar::undef()), field.ty)))\n         }\n         let offset = base_layout.fields.offset(field_index);\n         match base {\n             // the field covers the entire type\n-            Value::ByValPair(..) |\n-            Value::ByVal(_) if offset.bytes() == 0 && field.size == base_layout.size => Ok(Some((base, field.ty))),\n+            Value::ScalarPair(..) |\n+            Value::Scalar(_) if offset.bytes() == 0 && field.size == base_layout.size => Ok(Some((base, field.ty))),\n             // split fat pointers, 2 element tuples, ...\n-            Value::ByValPair(a, b) if base_layout.fields.count() == 2 => {\n+            Value::ScalarPair(a, b) if base_layout.fields.count() == 2 => {\n                 let val = [a, b][field_index];\n-                Ok(Some((Value::ByVal(val), field.ty)))\n+                Ok(Some((Value::Scalar(val), field.ty)))\n             },\n             // FIXME(oli-obk): figure out whether we should be calling `try_read_value` here\n             _ => Ok(None),\n@@ -173,7 +173,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         place: &mir::Place<'tcx>,\n     ) -> EvalResult<'tcx, Value> {\n         // Shortcut for things like accessing a fat pointer's field,\n-        // which would otherwise (in the `eval_place` path) require moving a `ByValPair` to memory\n+        // which would otherwise (in the `eval_place` path) require moving a `ScalarPair` to memory\n         // and returning an `Place::Ptr` to it\n         if let Some(val) = self.try_read_place(place)? {\n             return Ok(val);\n@@ -210,7 +210,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 };\n                 let alloc = Machine::init_static(self, cid)?;\n                 Place::Ptr {\n-                    ptr: MemoryPointer::new(alloc, Size::from_bytes(0)).into(),\n+                    ptr: Scalar::Ptr(alloc.into()),\n                     align: layout.align,\n                     extra: PlaceExtra::None,\n                 }\n@@ -250,8 +250,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Place::Local { frame, local } => {\n                 match (&self.stack[frame].get_local(local)?, &base_layout.abi) {\n                     // in case the field covers the entire type, just return the value\n-                    (&Value::ByVal(_), &layout::Abi::Scalar(_)) |\n-                    (&Value::ByValPair(..), &layout::Abi::ScalarPair(..))\n+                    (&Value::Scalar(_), &layout::Abi::Scalar(_)) |\n+                    (&Value::ScalarPair(..), &layout::Abi::ScalarPair(..))\n                         if offset.bytes() == 0 && field.size == base_layout.size =>\n                     {\n                         return Ok((base, field));\n@@ -272,7 +272,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             _ => offset,\n         };\n \n-        let ptr = base_ptr.offset(offset, &self)?;\n+        let ptr = base_ptr.ptr_offset(offset, &self)?;\n         let align = base_align.min(base_layout.align).min(field.align);\n         let extra = if !field.is_unsized() {\n             PlaceExtra::None\n@@ -310,7 +310,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     extra: PlaceExtra::Length(len),\n                 }\n             }\n-            _ => Place::from_primval_ptr(self.into_ptr(val)?, layout.align),\n+            _ => Place::from_scalar_ptr(self.into_ptr(val)?, layout.align),\n         })\n     }\n \n@@ -332,7 +332,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             n,\n             len\n         );\n-        let ptr = base_ptr.offset(elem_size * n, &*self)?;\n+        let ptr = base_ptr.ptr_offset(elem_size * n, &*self)?;\n         Ok(Place::Ptr {\n             ptr,\n             align,\n@@ -387,8 +387,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Index(local) => {\n                 let value = self.frame().get_local(local)?;\n                 let ty = self.tcx.types.usize;\n-                let n = self.value_to_primval(ValTy { value, ty })?.to_u64()?;\n-                self.place_index(base, base_ty, n)\n+                let n = self\n+                    .value_to_scalar(ValTy { value, ty })?\n+                    .to_bits(self.tcx.data_layout.pointer_size)?;\n+                self.place_index(base, base_ty, n as u64)\n             }\n \n             ConstantIndex {\n@@ -410,7 +412,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     u64::from(offset)\n                 };\n \n-                let ptr = base_ptr.offset(elem_size * index, &self)?;\n+                let ptr = base_ptr.ptr_offset(elem_size * index, &self)?;\n                 Ok(Place::Ptr { ptr, align, extra: PlaceExtra::None })\n             }\n \n@@ -422,7 +424,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty, self.tcx.tcx);\n                 let elem_size = self.layout_of(elem_ty)?.size;\n                 assert!(u64::from(from) <= n - u64::from(to));\n-                let ptr = base_ptr.offset(elem_size * u64::from(from), &self)?;\n+                let ptr = base_ptr.ptr_offset(elem_size * u64::from(from), &self)?;\n                 // sublicing arrays produces arrays\n                 let extra = if self.type_is_sized(base_ty) {\n                     PlaceExtra::None"}, {"sha": "c0fafa7f83e22886d51217a0a6c1402debe58d1b", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -2,7 +2,7 @@ use rustc::mir::BasicBlock;\n use rustc::ty::{self, Ty};\n use syntax::codemap::Span;\n \n-use rustc::mir::interpret::{EvalResult, PrimVal, Value};\n+use rustc::mir::interpret::{EvalResult, Scalar, Value};\n use interpret::{Machine, ValTy, EvalContext, Place, PlaceExtra};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -28,7 +28,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 ptr,\n                 align: _,\n                 extra: PlaceExtra::Length(len),\n-            } => ptr.to_value_with_len(len),\n+            } => ptr.to_value_with_len(len, self.tcx.tcx),\n             Place::Ptr {\n                 ptr,\n                 align: _,\n@@ -52,7 +52,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let instance = match ty.sty {\n             ty::TyDynamic(..) => {\n                 let vtable = match arg {\n-                    Value::ByValPair(_, PrimVal::Ptr(vtable)) => vtable,\n+                    Value::ScalarPair(_, Scalar::Ptr(vtable)) => vtable,\n                     _ => bug!(\"expected fat ptr, got {:?}\", arg),\n                 };\n                 match self.read_drop_type_from_vtable(vtable)? {"}, {"sha": "cc250fb68c902a14013c35cefd9e0a639797b604", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::layout::LayoutOf;\n use syntax::codemap::Span;\n use rustc_target::spec::abi::Abi;\n \n-use rustc::mir::interpret::{EvalResult, PrimVal, Value};\n+use rustc::mir::interpret::{EvalResult, Scalar, Value};\n use super::{EvalContext, Place, Machine, ValTy};\n \n use rustc_data_structures::indexed_vec::Idx;\n@@ -38,13 +38,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 ..\n             } => {\n                 let discr_val = self.eval_operand(discr)?;\n-                let discr_prim = self.value_to_primval(discr_val)?;\n+                let discr_prim = self.value_to_scalar(discr_val)?;\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n                 let mut target_block = targets[targets.len() - 1];\n \n                 for (index, &const_int) in values.iter().enumerate() {\n-                    if discr_prim.to_bytes()? == const_int {\n+                    if discr_prim.to_bits(self.layout_of(discr_val.ty).unwrap().size)? == const_int {\n                         target_block = targets[index];\n                         break;\n                     }\n@@ -67,7 +67,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let func = self.eval_operand(func)?;\n                 let (fn_def, sig) = match func.ty.sty {\n                     ty::TyFnPtr(sig) => {\n-                        let fn_ptr = self.value_to_primval(func)?.to_ptr()?;\n+                        let fn_ptr = self.value_to_scalar(func)?.to_ptr()?;\n                         let instance = self.memory.get_fn(fn_ptr)?;\n                         let instance_ty = instance.ty(*self.tcx);\n                         match instance_ty.sty {\n@@ -144,19 +144,19 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 target,\n                 ..\n             } => {\n-                let cond_val = self.eval_operand_to_primval(cond)?.to_bool()?;\n+                let cond_val = self.eval_operand_to_scalar(cond)?.to_bool()?;\n                 if expected == cond_val {\n                     self.goto_block(target);\n                 } else {\n                     use rustc::mir::interpret::EvalErrorKind::*;\n                     return match *msg {\n                         BoundsCheck { ref len, ref index } => {\n-                            let len = self.eval_operand_to_primval(len)\n+                            let len = self.eval_operand_to_scalar(len)\n                                 .expect(\"can't eval len\")\n-                                .to_u64()?;\n-                            let index = self.eval_operand_to_primval(index)\n+                                .to_bits(self.memory().pointer_size())? as u64;\n+                            let index = self.eval_operand_to_scalar(index)\n                                 .expect(\"can't eval index\")\n-                                .to_u64()?;\n+                                .to_bits(self.memory().pointer_size())? as u64;\n                             err!(BoundsCheck { len, index })\n                         }\n                         Overflow(op) => Err(Overflow(op).into()),\n@@ -342,7 +342,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                                         for (i, arg_local) in arg_locals.enumerate() {\n                                             let field = layout.field(&self, i)?;\n                                             let offset = layout.fields.offset(i);\n-                                            let arg = Value::ByRef(ptr.offset(offset, &self)?,\n+                                            let arg = Value::ByRef(ptr.ptr_offset(offset, &self)?,\n                                                                    align.min(field.align));\n                                             let dest =\n                                                 self.eval_place(&mir::Place::Local(arg_local))?;\n@@ -359,7 +359,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                                             self.write_value(valty, dest)?;\n                                         }\n                                     }\n-                                    Value::ByVal(PrimVal::Undef) => {}\n+                                    Value::Scalar(Scalar::Bits { defined: 0, .. }) => {}\n                                     other => {\n                                         trace!(\"{:#?}, {:#?}\", other, layout);\n                                         let mut layout = layout;"}, {"sha": "373a0b0d0bfedb75ffa80057d1ccbead6d870257", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -2,7 +2,7 @@ use rustc::ty::{self, Ty};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n use syntax::ast::Mutability;\n \n-use rustc::mir::interpret::{PrimVal, Value, MemoryPointer, EvalResult};\n+use rustc::mir::interpret::{Scalar, Value, Pointer, EvalResult};\n use super::{EvalContext, Machine};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -16,7 +16,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         &mut self,\n         ty: Ty<'tcx>,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n-    ) -> EvalResult<'tcx, MemoryPointer> {\n+    ) -> EvalResult<'tcx, Pointer> {\n         debug!(\"get_vtable(trait_ref={:?})\", trait_ref);\n \n         let layout = self.layout_of(trait_ref.self_ty())?;\n@@ -35,19 +35,25 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n         let drop = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);\n         let drop = self.memory.create_fn_alloc(drop);\n-        self.memory.write_ptr_sized_unsigned(vtable, ptr_align, PrimVal::Ptr(drop))?;\n+        self.memory.write_ptr_sized_unsigned(vtable, ptr_align, drop.into())?;\n \n         let size_ptr = vtable.offset(ptr_size, &self)?;\n-        self.memory.write_ptr_sized_unsigned(size_ptr, ptr_align, PrimVal::Bytes(size as u128))?;\n+        self.memory.write_ptr_sized_unsigned(size_ptr, ptr_align, Scalar::Bits {\n+            bits: size as u128,\n+            defined: ptr_size.bits() as u8,\n+        })?;\n         let align_ptr = vtable.offset(ptr_size * 2, &self)?;\n-        self.memory.write_ptr_sized_unsigned(align_ptr, ptr_align, PrimVal::Bytes(align as u128))?;\n+        self.memory.write_ptr_sized_unsigned(align_ptr, ptr_align, Scalar::Bits {\n+            bits: align as u128,\n+            defined: ptr_size.bits() as u8,\n+        })?;\n \n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 let instance = self.resolve(def_id, substs)?;\n                 let fn_ptr = self.memory.create_fn_alloc(instance);\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), &self)?;\n-                self.memory.write_ptr_sized_unsigned(method_ptr, ptr_align, PrimVal::Ptr(fn_ptr))?;\n+                self.memory.write_ptr_sized_unsigned(method_ptr, ptr_align, fn_ptr.into())?;\n             }\n         }\n \n@@ -61,29 +67,30 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n     pub fn read_drop_type_from_vtable(\n         &self,\n-        vtable: MemoryPointer,\n+        vtable: Pointer,\n     ) -> EvalResult<'tcx, Option<ty::Instance<'tcx>>> {\n         // we don't care about the pointee type, we just want a pointer\n         let pointer_align = self.tcx.data_layout.pointer_align;\n+        let pointer_size = self.tcx.data_layout.pointer_size.bits() as u8;\n         match self.read_ptr(vtable, pointer_align, self.tcx.mk_nil_ptr())? {\n             // some values don't need to call a drop impl, so the value is null\n-            Value::ByVal(PrimVal::Bytes(0)) => Ok(None),\n-            Value::ByVal(PrimVal::Ptr(drop_fn)) => self.memory.get_fn(drop_fn).map(Some),\n+            Value::Scalar(Scalar::Bits { bits: 0, defined} ) if defined == pointer_size => Ok(None),\n+            Value::Scalar(Scalar::Ptr(drop_fn)) => self.memory.get_fn(drop_fn).map(Some),\n             _ => err!(ReadBytesAsPointer),\n         }\n     }\n \n     pub fn read_size_and_align_from_vtable(\n         &self,\n-        vtable: MemoryPointer,\n+        vtable: Pointer,\n     ) -> EvalResult<'tcx, (Size, Align)> {\n         let pointer_size = self.memory.pointer_size();\n         let pointer_align = self.tcx.data_layout.pointer_align;\n-        let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?, pointer_align)?.to_bytes()? as u64;\n+        let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?, pointer_align)?.to_bits(pointer_size)? as u64;\n         let align = self.memory.read_ptr_sized(\n             vtable.offset(pointer_size * 2, self)?,\n             pointer_align\n-        )?.to_bytes()? as u64;\n+        )?.to_bits(pointer_size)? as u64;\n         Ok((Size::from_bytes(size), Align::from_bytes(align, align).unwrap()))\n     }\n }"}, {"sha": "a8a50e14c68225788edd9876d45513015c9ee4f4", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -203,7 +203,7 @@ use rustc::session::config;\n use rustc::mir::{self, Location, Promoted};\n use rustc::mir::visit::Visitor as MirVisitor;\n use rustc::mir::mono::MonoItem;\n-use rustc::mir::interpret::{PrimVal, GlobalId, AllocType};\n+use rustc::mir::interpret::{Scalar, GlobalId, AllocType};\n \n use monomorphize::{self, Instance};\n use rustc::util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n@@ -1245,13 +1245,13 @@ fn collect_const<'a, 'tcx>(\n     };\n     match val {\n         ConstVal::Unevaluated(..) => bug!(\"const eval yielded unevaluated const\"),\n-        ConstVal::Value(ConstValue::ByValPair(PrimVal::Ptr(a), PrimVal::Ptr(b))) => {\n+        ConstVal::Value(ConstValue::ScalarPair(Scalar::Ptr(a), Scalar::Ptr(b))) => {\n             collect_miri(tcx, a.alloc_id, output);\n             collect_miri(tcx, b.alloc_id, output);\n         }\n-        ConstVal::Value(ConstValue::ByValPair(_, PrimVal::Ptr(ptr))) |\n-        ConstVal::Value(ConstValue::ByValPair(PrimVal::Ptr(ptr), _)) |\n-        ConstVal::Value(ConstValue::ByVal(PrimVal::Ptr(ptr))) =>\n+        ConstVal::Value(ConstValue::ScalarPair(_, Scalar::Ptr(ptr))) |\n+        ConstVal::Value(ConstValue::ScalarPair(Scalar::Ptr(ptr), _)) |\n+        ConstVal::Value(ConstValue::Scalar(Scalar::Ptr(ptr))) =>\n             collect_miri(tcx, ptr.alloc_id, output),\n         ConstVal::Value(ConstValue::ByRef(alloc, _offset)) => {\n             for &id in alloc.relocations.values() {"}, {"sha": "fa740876091ac099163070ae1722d67d14c7d0ee", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -19,7 +19,7 @@ use rustc::mir::{TerminatorKind, ClearCrossCrate, SourceInfo, BinOp, ProjectionE\n use rustc::mir::visit::{Visitor, PlaceContext};\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{TyCtxt, self, Instance};\n-use rustc::mir::interpret::{Value, PrimVal, GlobalId, EvalResult};\n+use rustc::mir::interpret::{Value, Scalar, GlobalId, EvalResult};\n use interpret::EvalContext;\n use interpret::CompileTimeEvaluator;\n use interpret::{eval_promoted, mk_borrowck_eval_cx, ValTy};\n@@ -215,7 +215,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     trace!(\"field proj on {:?}\", proj.base);\n                     let (base, ty, span) = self.eval_place(&proj.base)?;\n                     match base {\n-                        Value::ByValPair(a, b) => {\n+                        Value::ScalarPair(a, b) => {\n                             trace!(\"by val pair: {:?}, {:?}\", a, b);\n                             let base_layout = self.tcx.layout_of(self.param_env.and(ty)).ok()?;\n                             trace!(\"layout computed\");\n@@ -228,7 +228,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                             };\n                             let field = base_layout.field(cx, field_index).ok()?;\n                             trace!(\"projection resulted in: {:?}\", val);\n-                            Some((Value::ByVal(val), field.ty, span))\n+                            Some((Value::Scalar(val), field.ty, span))\n                         },\n                         _ => None,\n                     }\n@@ -283,7 +283,10 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n             Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n                 let param_env = self.tcx.param_env(self.source.def_id);\n                 type_size_of(self.tcx, param_env, ty).map(|n| (\n-                    Value::ByVal(PrimVal::Bytes(n as u128)),\n+                    Value::Scalar(Scalar::Bits {\n+                        bits: n as u128,\n+                        defined: self.tcx.data_layout.pointer_size.bits() as u8,\n+                    }),\n                     self.tcx.types.usize,\n                     span,\n                 ))\n@@ -302,10 +305,10 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n \n                 let val = self.eval_operand(arg)?;\n                 let prim = self.use_ecx(span, |this| {\n-                    this.ecx.value_to_primval(ValTy { value: val.0, ty: val.1 })\n+                    this.ecx.value_to_scalar(ValTy { value: val.0, ty: val.1 })\n                 })?;\n                 let val = self.use_ecx(span, |this| this.ecx.unary_op(op, prim, val.1))?;\n-                Some((Value::ByVal(val), place_ty, span))\n+                Some((Value::Scalar(val), place_ty, span))\n             }\n             Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n             Rvalue::BinaryOp(op, ref left, ref right) => {\n@@ -323,13 +326,18 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 }\n \n                 let r = self.use_ecx(span, |this| {\n-                    this.ecx.value_to_primval(ValTy { value: right.0, ty: right.1 })\n+                    this.ecx.value_to_scalar(ValTy { value: right.0, ty: right.1 })\n                 })?;\n                 if op == BinOp::Shr || op == BinOp::Shl {\n-                    let param_env = self.tcx.param_env(self.source.def_id);\n                     let left_ty = left.ty(self.mir, self.tcx);\n-                    let bits = self.tcx.layout_of(param_env.and(left_ty)).unwrap().size.bits();\n-                    if r.to_bytes().ok().map_or(false, |b| b >= bits as u128) {\n+                    let left_bits = self\n+                        .tcx\n+                        .layout_of(self.param_env.and(left_ty))\n+                        .unwrap()\n+                        .size\n+                        .bits();\n+                    let right_size = self.tcx.layout_of(self.param_env.and(right.1)).unwrap().size;\n+                    if r.to_bits(right_size).ok().map_or(false, |b| b >= left_bits as u128) {\n                         let scope_info = match self.mir.visibility_scope_info {\n                             ClearCrossCrate::Set(ref data) => data,\n                             ClearCrossCrate::Clear => return None,\n@@ -350,16 +358,16 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 }\n                 let left = self.eval_operand(left)?;\n                 let l = self.use_ecx(span, |this| {\n-                    this.ecx.value_to_primval(ValTy { value: left.0, ty: left.1 })\n+                    this.ecx.value_to_scalar(ValTy { value: left.0, ty: left.1 })\n                 })?;\n                 trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n                 let (val, overflow) = self.use_ecx(span, |this| {\n                     this.ecx.binary_op(op, l, left.1, r, right.1)\n                 })?;\n                 let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n-                    Value::ByValPair(\n+                    Value::ScalarPair(\n                         val,\n-                        PrimVal::from_bool(overflow),\n+                        Scalar::from_bool(overflow),\n                     )\n                 } else {\n                     if overflow {\n@@ -371,7 +379,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                         });\n                         return None;\n                     }\n-                    Value::ByVal(val)\n+                    Value::Scalar(val)\n                 };\n                 Some((val, place_ty, span))\n             },\n@@ -485,7 +493,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n         if let TerminatorKind::Assert { expected, msg, cond, .. } = kind {\n             if let Some(value) = self.eval_operand(cond) {\n                 trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                if Value::ByVal(PrimVal::from_bool(*expected)) != value.0 {\n+                if Value::Scalar(Scalar::from_bool(*expected)) != value.0 {\n                     // poison all places this operand references so that further code\n                     // doesn't use the invalid value\n                     match cond {\n@@ -520,14 +528,14 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                         BoundsCheck { ref len, ref index } => {\n                             let len = self.eval_operand(len).expect(\"len must be const\");\n                             let len = match len.0 {\n-                                Value::ByVal(PrimVal::Bytes(n)) => n,\n+                                Value::Scalar(Scalar::Bits { bits, ..}) => bits,\n                                 _ => bug!(\"const len not primitive: {:?}\", len),\n                             };\n                             let index = self\n                                 .eval_operand(index)\n                                 .expect(\"index must be const\");\n                             let index = match index.0 {\n-                                Value::ByVal(PrimVal::Bytes(n)) => n,\n+                                Value::Scalar(Scalar::Bits { bits, .. }) => bits,\n                                 _ => bug!(\"const index not primitive: {:?}\", index),\n                             };\n                             format!("}, {"sha": "74b6d721882fa42e15b1b9fed1b26340a49e6862", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -181,7 +181,7 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n                 value: ty::Const::from_bits(\n                     self.tcx,\n                     state_disc.into(),\n-                    self.tcx.types.u32),\n+                    ty::ParamEnv::empty().and(self.tcx.types.u32)),\n             },\n         });\n         Statement {"}, {"sha": "2dbba897fa8a27bd742585540aa2b89a3806eeb8", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -10,7 +10,7 @@\n \n //! A pass that simplifies branches when their condition is known.\n \n-use rustc::ty::TyCtxt;\n+use rustc::ty::{TyCtxt, ParamEnv};\n use rustc::mir::*;\n use transform::{MirPass, MirSource};\n \n@@ -39,7 +39,8 @@ impl MirPass for SimplifyBranches {\n                 TerminatorKind::SwitchInt { discr: Operand::Constant(box Constant {\n                     literal: Literal::Value { ref value }, ..\n                 }), switch_ty, ref values, ref targets, .. } => {\n-                    if let Some(constint) = value.assert_bits(switch_ty) {\n+                    let switch_ty = ParamEnv::empty().and(switch_ty);\n+                    if let Some(constint) = value.assert_bits(tcx, switch_ty) {\n                         let (otherwise, targets) = targets.split_last().unwrap();\n                         let mut ret = TerminatorKind::Goto { target: *otherwise };\n                         for (&v, t) in values.iter().zip(targets.iter()) {"}, {"sha": "1e8af52e3e8192c3f45054442b71182774e77371", "filename": "src/librustc_target/abi/call/mips.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -47,7 +47,7 @@ fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<Ty>, offset: &mut Size)\n pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<Ty>)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n-    let mut offset = Size::from_bytes(0);\n+    let mut offset = Size::ZERO;\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(cx, &mut fty.ret, &mut offset);\n     }"}, {"sha": "3734e563d585e5fb65b5e943bf1380b0585ebb92", "filename": "src/librustc_target/abi/call/mips64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -33,8 +33,8 @@ fn float_reg<'a, Ty, C>(cx: C, ret: &ArgType<'a, Ty>, i: usize) -> Option<Reg>\n {\n     match ret.layout.field(cx, i).abi {\n         abi::Abi::Scalar(ref scalar) => match scalar.value {\n-            abi::F32 => Some(Reg::f32()),\n-            abi::F64 => Some(Reg::f64()),\n+            abi::Float(abi::FloatTy::F32) => Some(Reg::f32()),\n+            abi::Float(abi::FloatTy::F64) => Some(Reg::f64()),\n             _ => None\n         },\n         _ => None\n@@ -109,15 +109,15 @@ fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<'a, Ty>)\n         abi::FieldPlacement::Arbitrary { .. } => {\n             // Structures are split up into a series of 64-bit integer chunks, but any aligned\n             // doubles not part of another aggregate are passed as floats.\n-            let mut last_offset = Size::from_bytes(0);\n+            let mut last_offset = Size::ZERO;\n \n             for i in 0..arg.layout.fields.count() {\n                 let field = arg.layout.field(cx, i);\n                 let offset = arg.layout.fields.offset(i);\n \n                 // We only care about aligned doubles\n                 if let abi::Abi::Scalar(ref scalar) = field.abi {\n-                    if let abi::F64 = scalar.value {\n+                    if let abi::Float(abi::FloatTy::F64) = scalar.value {\n                         if offset.is_abi_aligned(dl.f64_align) {\n                             // Insert enough integers to cover [last_offset, offset)\n                             assert!(last_offset.is_abi_aligned(dl.f64_align));"}, {"sha": "fcae9ea22bba1cde930429a3eeb15b8df4fd25b2", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -83,7 +83,7 @@ impl ArgAttributes {\n     pub fn new() -> Self {\n         ArgAttributes {\n             regular: ArgAttribute::default(),\n-            pointee_size: Size::from_bytes(0),\n+            pointee_size: Size::ZERO,\n             pointee_align: None,\n         }\n     }\n@@ -206,7 +206,7 @@ impl From<Uniform> for CastTarget {\n     fn from(uniform: Uniform) -> CastTarget {\n         CastTarget {\n             prefix: [None; 8],\n-            prefix_chunk: Size::from_bytes(0),\n+            prefix_chunk: Size::ZERO,\n             rest: uniform\n         }\n     }\n@@ -256,8 +256,7 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n                 let kind = match scalar.value {\n                     abi::Int(..) |\n                     abi::Pointer => RegKind::Integer,\n-                    abi::F32 |\n-                    abi::F64 => RegKind::Float\n+                    abi::Float(_) => RegKind::Float,\n                 };\n                 Some(Reg {\n                     kind,\n@@ -274,7 +273,7 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n \n             Abi::ScalarPair(..) |\n             Abi::Aggregate { .. } => {\n-                let mut total = Size::from_bytes(0);\n+                let mut total = Size::ZERO;\n                 let mut result = None;\n \n                 let is_union = match self.fields {"}, {"sha": "3be3034143a3473ef798d53222129cfbf4f29a7b", "filename": "src/librustc_target/abi/call/powerpc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -47,7 +47,7 @@ fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<Ty>, offset: &mut Size)\n pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<Ty>)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n-    let mut offset = Size::from_bytes(0);\n+    let mut offset = Size::ZERO;\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(cx, &mut fty.ret, &mut offset);\n     }"}, {"sha": "37be6ea41c63a091c1744d9d3486918308c77e3f", "filename": "src/librustc_target/abi/call/s390x.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_target%2Fabi%2Fcall%2Fs390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_target%2Fabi%2Fcall%2Fs390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fs390x.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -29,12 +29,7 @@ fn is_single_fp_element<'a, Ty, C>(cx: C, layout: TyLayout<'a, Ty>) -> bool\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n     match layout.abi {\n-        abi::Abi::Scalar(ref scalar) => {\n-            match scalar.value {\n-                abi::F32 | abi::F64 => true,\n-                _ => false\n-            }\n-        }\n+        abi::Abi::Scalar(ref scalar) => scalar.value.is_float(),\n         abi::Abi::Aggregate { .. } => {\n             if layout.fields.count() == 1 && layout.fields.offset(0).bytes() == 0 {\n                 is_single_fp_element(cx, layout.field(cx, 0))"}, {"sha": "1e8af52e3e8192c3f45054442b71182774e77371", "filename": "src/librustc_target/abi/call/sparc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fsparc.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -47,7 +47,7 @@ fn classify_arg_ty<'a, Ty, C>(cx: C, arg: &mut ArgType<Ty>, offset: &mut Size)\n pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<Ty>)\n     where Ty: TyLayoutMethods<'a, C>, C: LayoutOf<Ty = Ty> + HasDataLayout\n {\n-    let mut offset = Size::from_bytes(0);\n+    let mut offset = Size::ZERO;\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(cx, &mut fty.ret, &mut offset);\n     }"}, {"sha": "0c0040de9df9fc4ccfd2ef38be6ca70953a1f58b", "filename": "src/librustc_target/abi/call/x86.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -23,12 +23,7 @@ fn is_single_fp_element<'a, Ty, C>(cx: C, layout: TyLayout<'a, Ty>) -> bool\n           C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n {\n     match layout.abi {\n-        abi::Abi::Scalar(ref scalar) => {\n-            match scalar.value {\n-                abi::F32 | abi::F64 => true,\n-                _ => false\n-            }\n-        }\n+        abi::Abi::Scalar(ref scalar) => scalar.value.is_float(),\n         abi::Abi::Aggregate { .. } => {\n             if layout.fields.count() == 1 && layout.fields.offset(0).bytes() == 0 {\n                 is_single_fp_element(cx, layout.field(cx, 0))"}, {"sha": "a443255b9700f1bf5b425661565bf6f3a8d82944", "filename": "src/librustc_target/abi/call/x86_64.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86_64.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -55,8 +55,7 @@ fn classify_arg<'a, Ty, C>(cx: C, arg: &ArgType<'a, Ty>)\n                 match scalar.value {\n                     abi::Int(..) |\n                     abi::Pointer => Class::Int,\n-                    abi::F32 |\n-                    abi::F64 => Class::Sse\n+                    abi::Float(_) => Class::Sse\n                 }\n             }\n \n@@ -101,7 +100,7 @@ fn classify_arg<'a, Ty, C>(cx: C, arg: &ArgType<'a, Ty>)\n     }\n \n     let mut cls = [None; MAX_EIGHTBYTES];\n-    classify(cx, arg.layout, &mut cls, Size::from_bytes(0))?;\n+    classify(cx, arg.layout, &mut cls, Size::ZERO)?;\n     if n > 2 {\n         if cls[0] != Some(Class::Sse) {\n             return Err(Memory);\n@@ -175,7 +174,7 @@ fn cast_target(cls: &[Option<Class>], size: Size) -> CastTarget {\n             target = CastTarget::pair(lo, hi);\n         }\n     }\n-    assert_eq!(reg_component(cls, &mut i, Size::from_bytes(0)), None);\n+    assert_eq!(reg_component(cls, &mut i, Size::ZERO), None);\n     target\n }\n "}, {"sha": "7ff04df6233995322e64931624333243d9c7c7dd", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 59, "deletions": 8, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -13,7 +13,7 @@ pub use self::Primitive::*;\n \n use spec::Target;\n \n-use std::cmp;\n+use std::{cmp, fmt};\n use std::ops::{Add, Deref, Sub, Mul, AddAssign, Range, RangeInclusive};\n \n pub mod call;\n@@ -227,6 +227,8 @@ pub struct Size {\n }\n \n impl Size {\n+    pub const ZERO: Size = Self::from_bytes(0);\n+\n     pub fn from_bits(bits: u64) -> Size {\n         // Avoid potential overflow from `bits + 7`.\n         Size::from_bytes(bits / 8 + ((bits % 8) + 7) / 8)\n@@ -486,6 +488,42 @@ impl Integer {\n     }\n }\n \n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy,\n+         PartialOrd, Ord)]\n+pub enum FloatTy {\n+    F32,\n+    F64,\n+}\n+\n+impl fmt::Debug for FloatTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Display for FloatTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.ty_to_string())\n+    }\n+}\n+\n+impl FloatTy {\n+    pub fn ty_to_string(&self) -> &'static str {\n+        match *self {\n+            FloatTy::F32 => \"f32\",\n+            FloatTy::F64 => \"f64\",\n+        }\n+    }\n+\n+    pub fn bit_width(&self) -> usize {\n+        match *self {\n+            FloatTy::F32 => 32,\n+            FloatTy::F64 => 64,\n+        }\n+    }\n+}\n+\n /// Fundamental unit of memory access and layout.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Primitive {\n@@ -497,8 +535,7 @@ pub enum Primitive {\n     /// a negative integer passed by zero-extension will appear positive in\n     /// the callee, and most operations on it will produce the wrong values.\n     Int(Integer, bool),\n-    F32,\n-    F64,\n+    Float(FloatTy),\n     Pointer\n }\n \n@@ -508,8 +545,8 @@ impl<'a, 'tcx> Primitive {\n \n         match self {\n             Int(i, _) => i.size(),\n-            F32 => Size::from_bits(32),\n-            F64 => Size::from_bits(64),\n+            Float(FloatTy::F32) => Size::from_bits(32),\n+            Float(FloatTy::F64) => Size::from_bits(64),\n             Pointer => dl.pointer_size\n         }\n     }\n@@ -519,11 +556,25 @@ impl<'a, 'tcx> Primitive {\n \n         match self {\n             Int(i, _) => i.align(dl),\n-            F32 => dl.f32_align,\n-            F64 => dl.f64_align,\n+            Float(FloatTy::F32) => dl.f32_align,\n+            Float(FloatTy::F64) => dl.f64_align,\n             Pointer => dl.pointer_align\n         }\n     }\n+\n+    pub fn is_float(self) -> bool {\n+        match self {\n+            Float(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_int(self) -> bool {\n+        match self {\n+            Int(..) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n /// Information about one scalar component of a Rust type.\n@@ -614,7 +665,7 @@ impl FieldPlacement {\n \n     pub fn offset(&self, i: usize) -> Size {\n         match *self {\n-            FieldPlacement::Union(_) => Size::from_bytes(0),\n+            FieldPlacement::Union(_) => Size::ZERO,\n             FieldPlacement::Array { stride, count } => {\n                 let i = i as u64;\n                 assert!(i < count);"}, {"sha": "c9843de547fb21975b029c1f2ed88695a31e94a5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -33,6 +33,8 @@ use std::fmt;\n use rustc_data_structures::sync::Lrc;\n use std::u32;\n \n+pub use rustc_target::abi::FloatTy;\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Label {\n     pub ident: Ident,\n@@ -1519,41 +1521,6 @@ impl fmt::Display for UintTy {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy,\n-         PartialOrd, Ord)]\n-pub enum FloatTy {\n-    F32,\n-    F64,\n-}\n-\n-impl fmt::Debug for FloatTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n-    }\n-}\n-\n-impl fmt::Display for FloatTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.ty_to_string())\n-    }\n-}\n-\n-impl FloatTy {\n-    pub fn ty_to_string(&self) -> &'static str {\n-        match *self {\n-            FloatTy::F32 => \"f32\",\n-            FloatTy::F64 => \"f64\",\n-        }\n-    }\n-\n-    pub fn bit_width(&self) -> usize {\n-        match *self {\n-            FloatTy::F32 => 32,\n-            FloatTy::F64 => 64,\n-        }\n-    }\n-}\n-\n // Bind a type to an associated type: `A=Foo`.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TypeBinding {"}, {"sha": "77d5222cb9c74275c1505a1adcefcf9cce6b1545", "filename": "src/test/ui/const-eval/ref_to_float_transmute.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Ftest%2Fui%2Fconst-eval%2Fref_to_float_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Ftest%2Fui%2Fconst-eval%2Fref_to_float_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fref_to_float_transmute.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//compile-pass\n+\n+fn main() {}\n+\n+static FOO: u32 = 42;\n+\n+union Foo {\n+    f: Float,\n+    r: &'static u32,\n+}\n+\n+#[cfg(target_pointer_width=\"64\")]\n+type Float = f64;\n+\n+#[cfg(target_pointer_width=\"32\")]\n+type Float = f32;\n+\n+static BAR: Float = unsafe { Foo { r: &FOO }.f };"}, {"sha": "4c5fc6c3797623983bda6f58c13ad1d1211c088b", "filename": "src/test/ui/const-eval/ref_to_int_match.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Ftest%2Fui%2Fconst-eval%2Fref_to_int_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Ftest%2Fui%2Fconst-eval%2Fref_to_int_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fref_to_int_match.rs?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let n: Int = 40;\n+    match n {\n+        0...10 => {},\n+        10...BAR => {}, //~ ERROR lower range bound must be less than or equal to upper\n+        _ => {},\n+    }\n+}\n+\n+union Foo {\n+    f: Int,\n+    r: &'static u32,\n+}\n+\n+#[cfg(target_pointer_width=\"64\")]\n+type Int = u64;\n+\n+#[cfg(target_pointer_width=\"32\")]\n+type Int = u32;\n+\n+const BAR: Int = unsafe { Foo { r: &42 }.f };"}, {"sha": "eef7b6df252fe5f21d48ce32fb7a362d41cc37b2", "filename": "src/test/ui/const-eval/ref_to_int_match.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Ftest%2Fui%2Fconst-eval%2Fref_to_int_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/990d8aa743b1dda3cc0f68fe09524486261812c6/src%2Ftest%2Fui%2Fconst-eval%2Fref_to_int_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fref_to_int_match.stderr?ref=990d8aa743b1dda3cc0f68fe09524486261812c6", "patch": "@@ -0,0 +1,9 @@\n+error[E0030]: lower range bound must be less than or equal to upper\n+  --> $DIR/ref_to_int_match.rs:15:9\n+   |\n+LL |         10...BAR => {}, //~ ERROR lower range bound must be less than or equal to upper\n+   |         ^^ lower bound larger than upper bound\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0030`."}]}