{"sha": "dd9896b0f8752c71c82c5d538ec0b115ffb5cf4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkOTg5NmIwZjg3NTJjNzFjODJjNWQ1MzhlYzBiMTE1ZmZiNWNmNGU=", "commit": {"author": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-02-18T03:30:24Z"}, "committer": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-04-05T15:03:22Z"}, "message": "Implement mutex and rwlock functions", "tree": {"sha": "a9e9ef8644cc05384f7b0b3e2ff59cc19ada18c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9e9ef8644cc05384f7b0b3e2ff59cc19ada18c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd9896b0f8752c71c82c5d538ec0b115ffb5cf4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd9896b0f8752c71c82c5d538ec0b115ffb5cf4e", "html_url": "https://github.com/rust-lang/rust/commit/dd9896b0f8752c71c82c5d538ec0b115ffb5cf4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd9896b0f8752c71c82c5d538ec0b115ffb5cf4e/comments", "author": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "committer": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2683dad34f6f51761661840de8164dd001bb782", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2683dad34f6f51761661840de8164dd001bb782", "html_url": "https://github.com/rust-lang/rust/commit/c2683dad34f6f51761661840de8164dd001bb782"}], "stats": {"total": 626, "additions": 567, "deletions": 59}, "files": [{"sha": "2f381b4a34546f7868ed5dd82cff3175820814a3", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd9896b0f8752c71c82c5d538ec0b115ffb5cf4e/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9896b0f8752c71c82c5d538ec0b115ffb5cf4e/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=dd9896b0f8752c71c82c5d538ec0b115ffb5cf4e", "patch": "@@ -39,6 +39,7 @@ pub use crate::shims::fs::{DirHandler, EvalContextExt as FileEvalContextExt, Fil\n pub use crate::shims::intrinsics::EvalContextExt as IntrinsicsEvalContextExt;\n pub use crate::shims::os_str::EvalContextExt as OsStrEvalContextExt;\n pub use crate::shims::panic::{CatchUnwindData, EvalContextExt as PanicEvalContextExt};\n+pub use crate::shims::sync::{EvalContextExt as SyncEvalContextExt};\n pub use crate::shims::time::EvalContextExt as TimeEvalContextExt;\n pub use crate::shims::tls::{EvalContextExt as TlsEvalContextExt, TlsData};\n pub use crate::shims::EvalContextExt as ShimsEvalContextExt;"}, {"sha": "2b9e94ba11db4ba321eb4856cebb63ef719fb7cb", "filename": "src/shims/foreign_items/posix.rs", "status": "modified", "additions": 73, "deletions": 18, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/dd9896b0f8752c71c82c5d538ec0b115ffb5cf4e/src%2Fshims%2Fforeign_items%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9896b0f8752c71c82c5d538ec0b115ffb5cf4e/src%2Fshims%2Fforeign_items%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix.rs?ref=dd9896b0f8752c71c82c5d538ec0b115ffb5cf4e", "patch": "@@ -255,28 +255,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n \n-            // Incomplete shims that we \"stub out\" just to get pre-main initialziation code to work.\n+            // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library.\n             | \"pthread_attr_init\"\n             | \"pthread_attr_destroy\"\n             | \"pthread_self\"\n-            | \"pthread_attr_setstacksize\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n-                this.write_null(dest)?;\n-            }\n-            | \"pthread_mutexattr_init\"\n-            | \"pthread_mutexattr_settype\"\n-            | \"pthread_mutex_init\"\n-            | \"pthread_mutexattr_destroy\"\n-            | \"pthread_mutex_lock\"\n-            | \"pthread_mutex_trylock\"\n-            | \"pthread_mutex_unlock\"\n-            | \"pthread_mutex_destroy\"\n-            | \"pthread_rwlock_rdlock\"\n-            | \"pthread_rwlock_tryrdlock\"\n-            | \"pthread_rwlock_unlock\"\n-            | \"pthread_rwlock_wrlock\"\n-            | \"pthread_rwlock_trywrlock\"\n-            | \"pthread_rwlock_destroy\"\n+            | \"pthread_attr_setstacksize\"\n             | \"pthread_condattr_init\"\n             | \"pthread_condattr_setclock\"\n             | \"pthread_cond_init\"\n@@ -285,6 +269,77 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             => {\n                 this.write_null(dest)?;\n             }\n+\n+            \"pthread_mutexattr_init\" => {\n+                let result = this.pthread_mutexattr_init(args[0])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n+            \"pthread_mutexattr_settype\" => {\n+                let result = this.pthread_mutexattr_settype(args[0], args[1])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n+            \"pthread_mutexattr_destroy\" => {\n+                let result = this.pthread_mutexattr_destroy(args[0])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n+            \"pthread_mutex_init\" => {\n+                let result = this.pthread_mutex_init(args[0], args[1])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n+            \"pthread_mutex_lock\" => {\n+                let result = this.pthread_mutex_lock(args[0])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n+            \"pthread_mutex_trylock\" => {\n+                let result = this.pthread_mutex_trylock(args[0])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n+            \"pthread_mutex_unlock\" => {\n+                let result = this.pthread_mutex_unlock(args[0])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n+            \"pthread_mutex_destroy\" => {\n+                let result = this.pthread_mutex_destroy(args[0])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n+            \"pthread_rwlock_rdlock\" => {\n+                let result = this.pthread_rwlock_rdlock(args[0])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n+            \"pthread_rwlock_tryrdlock\" => {\n+                let result = this.pthread_rwlock_tryrdlock(args[0])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n+            \"pthread_rwlock_wrlock\" => {\n+                let result = this.pthread_rwlock_wrlock(args[0])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n+            \"pthread_rwlock_trywrlock\" => {\n+                let result = this.pthread_rwlock_trywrlock(args[0])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n+            \"pthread_rwlock_unlock\" => {\n+                let result = this.pthread_rwlock_unlock(args[0])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n+            \"pthread_rwlock_destroy\" => {\n+                let result = this.pthread_rwlock_destroy(args[0])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n             | \"signal\"\n             | \"sigaction\"\n             | \"sigaltstack\""}, {"sha": "764e404141e4d0dbb4f8173a98580268349cf6e1", "filename": "src/shims/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd9896b0f8752c71c82c5d538ec0b115ffb5cf4e/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9896b0f8752c71c82c5d538ec0b115ffb5cf4e/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=dd9896b0f8752c71c82c5d538ec0b115ffb5cf4e", "patch": "@@ -5,6 +5,7 @@ pub mod fs;\n pub mod intrinsics;\n pub mod os_str;\n pub mod panic;\n+pub mod sync;\n pub mod time;\n pub mod tls;\n "}, {"sha": "c9329586627dd07a0543e1aa6846e55537f7e06f", "filename": "src/shims/sync.rs", "status": "added", "additions": 436, "deletions": 0, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/dd9896b0f8752c71c82c5d538ec0b115ffb5cf4e/src%2Fshims%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9896b0f8752c71c82c5d538ec0b115ffb5cf4e/src%2Fshims%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fsync.rs?ref=dd9896b0f8752c71c82c5d538ec0b115ffb5cf4e", "patch": "@@ -0,0 +1,436 @@\n+use rustc_middle::ty::{TyKind, TypeAndMut};\n+use rustc_target::abi::{LayoutOf, Size};\n+\n+use crate::stacked_borrows::Tag;\n+use crate::*;\n+\n+impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    // pthread_mutexattr_t is either 4 or 8 bytes, depending on the platform\n+    // memory layout: store an i32 in the first four bytes equal to the\n+    // corresponding libc mutex kind constant (i.e. PTHREAD_MUTEX_NORMAL)\n+\n+    fn pthread_mutexattr_init(&mut self, attr_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        check_ptr_target_min_size(this, attr_op, 4)?;\n+\n+        let attr = this.read_scalar(attr_op)?.not_undef()?;\n+        if this.is_null(attr)? {\n+            return this.eval_libc_i32(\"EINVAL\");\n+        }\n+\n+        let attr_place = this.deref_operand(attr_op)?;\n+        let i32_layout = this.layout_of(this.tcx.types.i32)?;\n+        let kind_place = attr_place.offset(Size::ZERO, MemPlaceMeta::None, i32_layout, this)?;\n+        let default_kind = this.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?;\n+        this.write_scalar(default_kind, kind_place.into())?;\n+\n+        Ok(0)\n+    }\n+\n+    fn pthread_mutexattr_settype(\n+        &mut self,\n+        attr_op: OpTy<'tcx, Tag>,\n+        kind_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        check_ptr_target_min_size(this, attr_op, 4)?;\n+\n+        let attr = this.read_scalar(attr_op)?.not_undef()?;\n+        if this.is_null(attr)? {\n+            return this.eval_libc_i32(\"EINVAL\");\n+        }\n+\n+        let kind = this.read_scalar(kind_op)?.not_undef()?;\n+        if kind == this.eval_libc(\"PTHREAD_MUTEX_NORMAL\")? ||\n+                kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")? ||\n+                kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")? {\n+            let attr_place = this.deref_operand(attr_op)?;\n+            let i32_layout = this.layout_of(this.tcx.types.i32)?;\n+            let kind_place = attr_place.offset(Size::ZERO, MemPlaceMeta::None, i32_layout, this)?;\n+            this.write_scalar(kind, kind_place.into())?;\n+        } else {\n+            let einval = this.eval_libc_i32(\"EINVAL\")?;\n+            return Ok(einval);\n+        }\n+\n+        Ok(0)\n+    }\n+\n+    fn pthread_mutexattr_destroy(&mut self, attr_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        check_ptr_target_min_size(this, attr_op, 4)?;\n+\n+        let attr = this.read_scalar(attr_op)?.not_undef()?;\n+        if this.is_null(attr)? {\n+            return this.eval_libc_i32(\"EINVAL\");\n+        }\n+\n+        let attr_place = this.deref_operand(attr_op)?;\n+        let i32_layout = this.layout_of(this.tcx.types.i32)?;\n+        let kind_place = attr_place.offset(Size::ZERO, MemPlaceMeta::None, i32_layout, this)?;\n+        this.write_scalar(ScalarMaybeUndef::Undef, kind_place.into())?;\n+\n+        Ok(0)\n+    }\n+\n+    // pthread_mutex_t is between 24 and 48 bytes, depending on the platform\n+    // memory layout:\n+    // bytes 0-3: count of how many times this mutex has been locked, as a u32\n+    // bytes 12-15: mutex kind, as an i32\n+    // (the kind should be at this offset for compatibility with the static\n+    // initializer macro)\n+\n+    fn pthread_mutex_init(\n+        &mut self,\n+        mutex_op: OpTy<'tcx, Tag>,\n+        attr_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        check_ptr_target_min_size(this, mutex_op, 16)?;\n+        check_ptr_target_min_size(this, attr_op, 4)?;\n+\n+        let mutex = this.read_scalar(mutex_op)?.not_undef()?;\n+        if this.is_null(mutex)? {\n+            return this.eval_libc_i32(\"EINVAL\");\n+        }\n+        let mutex_place = this.deref_operand(mutex_op)?;\n+\n+        let i32_layout = this.layout_of(this.tcx.types.i32)?;\n+\n+        let attr = this.read_scalar(attr_op)?.not_undef()?;\n+        let kind = if this.is_null(attr)? {\n+            this.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?\n+        } else {\n+            let attr_place = this.deref_operand(attr_op)?;\n+            let attr_kind_place = attr_place.offset(Size::ZERO, MemPlaceMeta::None, i32_layout, this)?;\n+            this.read_scalar(attr_kind_place.into())?.not_undef()?\n+        };\n+\n+        let u32_layout = this.layout_of(this.tcx.types.u32)?;\n+        let locked_count_place = mutex_place.offset(Size::ZERO, MemPlaceMeta::None, u32_layout, this)?;\n+        this.write_scalar(Scalar::from_u32(0), locked_count_place.into())?;\n+\n+        let mutex_kind_place = mutex_place.offset(Size::from_bytes(12), MemPlaceMeta::None, i32_layout, &*this.tcx)?;\n+        this.write_scalar(kind, mutex_kind_place.into())?;\n+\n+        Ok(0)\n+    }\n+\n+    fn pthread_mutex_lock(&mut self, mutex_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        check_ptr_target_min_size(this, mutex_op, 16)?;\n+\n+        let mutex = this.read_scalar(mutex_op)?.not_undef()?;\n+        if this.is_null(mutex)? {\n+            return this.eval_libc_i32(\"EINVAL\");\n+        }\n+        let mutex_place = this.deref_operand(mutex_op)?;\n+\n+        let i32_layout = this.layout_of(this.tcx.types.i32)?;\n+        let kind_place = mutex_place.offset(Size::from_bytes(12), MemPlaceMeta::None, i32_layout, this)?;\n+        let kind = this.read_scalar(kind_place.into())?.not_undef()?;\n+\n+        let u32_layout = this.layout_of(this.tcx.types.u32)?;\n+        let locked_count_place = mutex_place.offset(Size::ZERO, MemPlaceMeta::None, u32_layout, this)?;\n+        let locked_count = this.read_scalar(locked_count_place.into())?.to_u32()?;\n+\n+        if kind == this.eval_libc(\"PTHREAD_MUTEX_NORMAL\")? {\n+            if locked_count == 0 {\n+                this.write_scalar(Scalar::from_u32(1), locked_count_place.into())?;\n+                Ok(0)\n+            } else {\n+                throw_unsup_format!(\"Deadlock due to locking a PTHREAD_MUTEX_NORMAL mutex twice\");\n+            }\n+        } else if kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")? {\n+            if locked_count == 0 {\n+                this.write_scalar(Scalar::from_u32(1), locked_count_place.into())?;\n+                Ok(0)\n+            } else {\n+                this.eval_libc_i32(\"EDEADLK\")\n+            }\n+        } else if kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")? {\n+            this.write_scalar(Scalar::from_u32(locked_count + 1), locked_count_place.into())?;\n+            Ok(0)\n+        } else {\n+            this.eval_libc_i32(\"EINVAL\")\n+        }\n+    }\n+\n+    fn pthread_mutex_trylock(&mut self, mutex_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        check_ptr_target_min_size(this, mutex_op, 16)?;\n+\n+        let mutex = this.read_scalar(mutex_op)?.not_undef()?;\n+        if this.is_null(mutex)? {\n+            return this.eval_libc_i32(\"EINVAL\");\n+        }\n+        let mutex_place = this.deref_operand(mutex_op)?;\n+\n+        let i32_layout = this.layout_of(this.tcx.types.i32)?;\n+        let kind_place = mutex_place.offset(Size::from_bytes(12), MemPlaceMeta::None, i32_layout, this)?;\n+        let kind = this.read_scalar(kind_place.into())?.not_undef()?;\n+\n+        let u32_layout = this.layout_of(this.tcx.types.u32)?;\n+        let locked_count_place = mutex_place.offset(Size::ZERO, MemPlaceMeta::None, u32_layout, this)?;\n+        let locked_count = this.read_scalar(locked_count_place.into())?.to_u32()?;\n+\n+        if kind == this.eval_libc(\"PTHREAD_MUTEX_NORMAL\")? ||\n+                kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")? {\n+            if locked_count == 0 {\n+                this.write_scalar(Scalar::from_u32(1), locked_count_place.into())?;\n+                Ok(0)\n+            } else {\n+                this.eval_libc_i32(\"EBUSY\")\n+            }\n+        } else if kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")? {\n+            this.write_scalar(Scalar::from_u32(locked_count + 1), locked_count_place.into())?;\n+            Ok(0)\n+        } else {\n+            this.eval_libc_i32(\"EINVAL\")\n+        }\n+    }\n+\n+    fn pthread_mutex_unlock(&mut self, mutex_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        check_ptr_target_min_size(this, mutex_op, 16)?;\n+\n+        let mutex = this.read_scalar(mutex_op)?.not_undef()?;\n+        if this.is_null(mutex)? {\n+            return this.eval_libc_i32(\"EINVAL\");\n+        }\n+        let mutex_place = this.deref_operand(mutex_op)?;\n+\n+        let i32_layout = this.layout_of(this.tcx.types.i32)?;\n+        let kind_place = mutex_place.offset(Size::from_bytes(12), MemPlaceMeta::None, i32_layout, this)?;\n+        let kind = this.read_scalar(kind_place.into())?.not_undef()?;\n+\n+        let u32_layout = this.layout_of(this.tcx.types.u32)?;\n+        let locked_count_place = mutex_place.offset(Size::ZERO, MemPlaceMeta::None, u32_layout, this)?;\n+        let locked_count = this.read_scalar(locked_count_place.into())?.to_u32()?;\n+\n+        if kind == this.eval_libc(\"PTHREAD_MUTEX_NORMAL\")? {\n+            if locked_count == 1 {\n+                this.write_scalar(Scalar::from_u32(0), locked_count_place.into())?;\n+                Ok(0)\n+            } else {\n+                throw_ub_format!(\"Attempted to unlock a PTHREAD_MUTEX_NORMAL mutex that was not locked\");\n+            }\n+        } else if kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")? {\n+            if locked_count == 1 {\n+                this.write_scalar(Scalar::from_u32(0), locked_count_place.into())?;\n+                Ok(0)\n+            } else {\n+                this.eval_libc_i32(\"EPERM\")\n+            }\n+        } else if kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")? {\n+            if locked_count > 0 {\n+                this.write_scalar(Scalar::from_u32(locked_count - 1), locked_count_place.into())?;\n+                Ok(0)\n+            } else {\n+                this.eval_libc_i32(\"EPERM\")\n+            }\n+        } else {\n+            this.eval_libc_i32(\"EINVAL\")\n+        }\n+    }\n+\n+    fn pthread_mutex_destroy(&mut self, mutex_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        check_ptr_target_min_size(this, mutex_op, 16)?;\n+\n+        let mutex = this.read_scalar(mutex_op)?.not_undef()?;\n+        if this.is_null(mutex)? {\n+            return this.eval_libc_i32(\"EINVAL\");\n+        }\n+        let mutex_place = this.deref_operand(mutex_op)?;\n+\n+        let u32_layout = this.layout_of(this.tcx.types.u32)?;\n+        let locked_count_place = mutex_place.offset(Size::ZERO, MemPlaceMeta::None, u32_layout, this)?;\n+        if this.read_scalar(locked_count_place.into())?.to_u32()? != 0 {\n+            return this.eval_libc_i32(\"EBUSY\");\n+        }\n+\n+        let i32_layout = this.layout_of(this.tcx.types.i32)?;\n+        let kind_place = mutex_place.offset(Size::from_bytes(12), MemPlaceMeta::None, i32_layout, this)?;\n+        this.write_scalar(ScalarMaybeUndef::Undef, kind_place.into())?;\n+        this.write_scalar(ScalarMaybeUndef::Undef, locked_count_place.into())?;\n+\n+        Ok(0)\n+    }\n+\n+    // pthread_rwlock_t is between 32 and 56 bytes, depending on the platform\n+    // memory layout:\n+    // bytes 0-3: reader count, as a u32\n+    // bytes 4-7: writer count, as a u32\n+\n+    fn pthread_rwlock_rdlock(&mut self, rwlock_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        check_ptr_target_min_size(this, rwlock_op, 8)?;\n+\n+        let rwlock = this.read_scalar(rwlock_op)?.not_undef()?;\n+        if this.is_null(rwlock)? {\n+            return this.eval_libc_i32(\"EINVAL\");\n+        }\n+        let rwlock_place = this.deref_operand(rwlock_op)?;\n+\n+        let u32_layout = this.layout_of(this.tcx.types.u32)?;\n+        let readers_place = rwlock_place.offset(Size::ZERO, MemPlaceMeta::None, u32_layout, this)?;\n+        let writers_place = rwlock_place.offset(Size::from_bytes(4), MemPlaceMeta::None, u32_layout, this)?;\n+        let readers = this.read_scalar(readers_place.into())?.to_u32()?;\n+        let writers = this.read_scalar(writers_place.into())?.to_u32()?;\n+        if writers != 0 {\n+            throw_unsup_format!(\"Deadlock due to read-locking a pthreads read-write lock while it is already write-locked\");\n+        } else {\n+            this.write_scalar(Scalar::from_u32(readers + 1), readers_place.into())?;\n+            Ok(0)\n+        }\n+    }\n+\n+    fn pthread_rwlock_tryrdlock(&mut self, rwlock_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        check_ptr_target_min_size(this, rwlock_op, 8)?;\n+\n+        let rwlock = this.read_scalar(rwlock_op)?.not_undef()?;\n+        if this.is_null(rwlock)? {\n+            return this.eval_libc_i32(\"EINVAL\");\n+        }\n+        let rwlock_place = this.deref_operand(rwlock_op)?;\n+\n+        let u32_layout = this.layout_of(this.tcx.types.u32)?;\n+        let readers_place = rwlock_place.offset(Size::ZERO, MemPlaceMeta::None, u32_layout, this)?;\n+        let writers_place = rwlock_place.offset(Size::from_bytes(4), MemPlaceMeta::None, u32_layout, this)?;\n+        let readers = this.read_scalar(readers_place.into())?.to_u32()?;\n+        let writers = this.read_scalar(writers_place.into())?.to_u32()?;\n+        if writers != 0 {\n+            this.eval_libc_i32(\"EBUSY\")\n+        } else {\n+            this.write_scalar(Scalar::from_u32(readers + 1), readers_place.into())?;\n+            Ok(0)\n+        }\n+    }\n+\n+    fn pthread_rwlock_wrlock(&mut self, rwlock_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        check_ptr_target_min_size(this, rwlock_op, 8)?;\n+\n+        let rwlock = this.read_scalar(rwlock_op)?.not_undef()?;\n+        if this.is_null(rwlock)? {\n+            return this.eval_libc_i32(\"EINVAL\");\n+        }\n+        let rwlock_place = this.deref_operand(rwlock_op)?;\n+\n+        let u32_layout = this.layout_of(this.tcx.types.u32)?;\n+        let readers_place = rwlock_place.offset(Size::ZERO, MemPlaceMeta::None, u32_layout, this)?;\n+        let writers_place = rwlock_place.offset(Size::from_bytes(4), MemPlaceMeta::None, u32_layout, this)?;\n+        let readers = this.read_scalar(readers_place.into())?.to_u32()?;\n+        let writers = this.read_scalar(writers_place.into())?.to_u32()?;\n+        if readers != 0 {\n+            throw_unsup_format!(\"Deadlock due to write-locking a pthreads read-write lock while it is already read-locked\");\n+        } else if writers != 0 {\n+            throw_unsup_format!(\"Deadlock due to write-locking a pthreads read-write lock while it is already write-locked\");\n+        } else {\n+            this.write_scalar(Scalar::from_u32(1), writers_place.into())?;\n+            Ok(0)\n+        }\n+    }\n+\n+    fn pthread_rwlock_trywrlock(&mut self, rwlock_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        check_ptr_target_min_size(this, rwlock_op, 8)?;\n+\n+        let rwlock = this.read_scalar(rwlock_op)?.not_undef()?;\n+        if this.is_null(rwlock)? {\n+            return this.eval_libc_i32(\"EINVAL\");\n+        }\n+        let rwlock_place = this.deref_operand(rwlock_op)?;\n+\n+        let u32_layout = this.layout_of(this.tcx.types.u32)?;\n+        let readers_place = rwlock_place.offset(Size::ZERO, MemPlaceMeta::None, u32_layout, this)?;\n+        let writers_place = rwlock_place.offset(Size::from_bytes(4), MemPlaceMeta::None, u32_layout, this)?;\n+        let readers = this.read_scalar(readers_place.into())?.to_u32()?;\n+        let writers = this.read_scalar(writers_place.into())?.to_u32()?;\n+        if readers != 0 || writers != 0 {\n+            this.eval_libc_i32(\"EBUSY\")\n+        } else {\n+            this.write_scalar(Scalar::from_u32(1), writers_place.into())?;\n+            Ok(0)\n+        }\n+    }\n+\n+    fn pthread_rwlock_unlock(&mut self, rwlock_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        check_ptr_target_min_size(this, rwlock_op, 8)?;\n+\n+        let rwlock = this.read_scalar(rwlock_op)?.not_undef()?;\n+        if this.is_null(rwlock)? {\n+            return this.eval_libc_i32(\"EINVAL\");\n+        }\n+        let rwlock_place = this.deref_operand(rwlock_op)?;\n+\n+        let u32_layout = this.layout_of(this.tcx.types.u32)?;\n+        let readers_place = rwlock_place.offset(Size::ZERO, MemPlaceMeta::None, u32_layout, this)?;\n+        let writers_place = rwlock_place.offset(Size::from_bytes(4), MemPlaceMeta::None, u32_layout, this)?;\n+        let readers = this.read_scalar(readers_place.into())?.to_u32()?;\n+        let writers = this.read_scalar(writers_place.into())?.to_u32()?;\n+        if readers != 0 {\n+            this.write_scalar(Scalar::from_u32(readers - 1), readers_place.into())?;\n+            Ok(0)\n+        } else if writers != 0 {\n+            this.write_scalar(Scalar::from_u32(0), writers_place.into())?;\n+            Ok(0)\n+        } else {\n+            this.eval_libc_i32(\"EPERM\")\n+        }\n+    }\n+\n+    fn pthread_rwlock_destroy(&mut self, rwlock_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        check_ptr_target_min_size(this, rwlock_op, 8)?;\n+\n+        let rwlock = this.read_scalar(rwlock_op)?.not_undef()?;\n+        if this.is_null(rwlock)? {\n+            return this.eval_libc_i32(\"EINVAL\");\n+        }\n+        let rwlock_place = this.deref_operand(rwlock_op)?;\n+\n+        let u32_layout = this.layout_of(this.tcx.types.u32)?;\n+        let readers_place = rwlock_place.offset(Size::ZERO, MemPlaceMeta::None, u32_layout, this)?;\n+        if this.read_scalar(readers_place.into())?.to_u32()? != 0 {\n+            return this.eval_libc_i32(\"EBUSY\");\n+        }\n+        let writers_place = rwlock_place.offset(Size::from_bytes(4), MemPlaceMeta::None, u32_layout, this)?;\n+        if this.read_scalar(writers_place.into())?.to_u32()? != 0 {\n+            return this.eval_libc_i32(\"EBUSY\");\n+        }\n+\n+        this.write_scalar(ScalarMaybeUndef::Undef, readers_place.into())?;\n+        this.write_scalar(ScalarMaybeUndef::Undef, writers_place.into())?;\n+\n+        Ok(0)\n+    }\n+}\n+\n+fn check_ptr_target_min_size<'mir, 'tcx: 'mir>(ecx: &MiriEvalContext<'mir, 'tcx>, operand: OpTy<'tcx, Tag>, min_size: u64) -> InterpResult<'tcx, ()> {\n+    let target_ty = match operand.layout.ty.kind {\n+        TyKind::RawPtr(TypeAndMut{ ty, mutbl: _ }) => ty,\n+        _ => panic!(\"Argument to pthread function was not a raw pointer\"),\n+    };\n+    let target_layout = ecx.layout_of(target_ty)?;\n+    assert!(target_layout.size.bytes() >= min_size);\n+    Ok(())\n+}"}, {"sha": "d6ce939c6c36ce471c8d4218631a03f520861288", "filename": "tests/run-pass/sync.rs", "status": "modified", "additions": 56, "deletions": 41, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/dd9896b0f8752c71c82c5d538ec0b115ffb5cf4e/tests%2Frun-pass%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9896b0f8752c71c82c5d538ec0b115ffb5cf4e/tests%2Frun-pass%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fsync.rs?ref=dd9896b0f8752c71c82c5d538ec0b115ffb5cf4e", "patch": "@@ -1,4 +1,3 @@\n-// Just instantiate some data structures to make sure we got all their foreign items covered.\n // Requires full MIR on Windows.\n \n #![feature(rustc_private)]\n@@ -8,61 +7,77 @@ use std::sync::{Mutex, RwLock, TryLockError};\n extern crate libc;\n \n fn main() {\n+    test_mutex();\n+    #[cfg(not(target_os = \"windows\"))] // TODO: implement RwLock on Windows\n+    {\n+        test_rwlock_stdlib();\n+        test_rwlock_libc_init();\n+        test_rwlock_libc_static_initializer();\n+    }\n+}\n+\n+fn test_mutex() {\n     let m = Mutex::new(0);\n     {\n         let _guard = m.lock();\n         assert!(m.try_lock().unwrap_err().would_block());\n     }\n     drop(m.try_lock().unwrap());\n     drop(m);\n+}\n \n-    #[cfg(not(target_os = \"windows\"))] // TODO: implement RwLock on Windows\n+#[cfg(not(target_os = \"windows\"))]\n+fn test_rwlock_stdlib() {\n+    let rw = RwLock::new(0);\n     {\n-        let rw = RwLock::new(0);\n-        {\n-            let _read_guard = rw.read().unwrap();\n-            drop(rw.read().unwrap());\n-            drop(rw.try_read().unwrap());\n-            assert!(rw.try_write().unwrap_err().would_block());\n-        }\n+        let _read_guard = rw.read().unwrap();\n+        drop(rw.read().unwrap());\n+        drop(rw.try_read().unwrap());\n+        assert!(rw.try_write().unwrap_err().would_block());\n+    }\n \n-        {\n-            let _write_guard = rw.write().unwrap();\n-            assert!(rw.try_read().unwrap_err().would_block());\n-            assert!(rw.try_write().unwrap_err().would_block());\n-        }\n+    {\n+        let _write_guard = rw.write().unwrap();\n+        assert!(rw.try_read().unwrap_err().would_block());\n+        assert!(rw.try_write().unwrap_err().would_block());\n+    }\n+}\n \n-        // need to go a layer deeper and test the behavior of libc functions, because\n-        // std::sys::unix::rwlock::RWLock keeps track of write_locked and num_readers\n+// need to go a layer deeper and test the behavior of libc functions, because\n+// std::sys::unix::rwlock::RWLock keeps track of write_locked and num_readers\n \n-        unsafe {\n-            let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n-            assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, std::ptr::null_mut()), 0);\n-            assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n-            assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), libc::EBUSY);\n-            assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n-            assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), 0);\n-            assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n-            assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n-        }\n+#[cfg(not(target_os = \"windows\"))]\n+fn test_rwlock_libc_init() {\n+    unsafe {\n+        let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, std::ptr::null_mut()), 0);\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), libc::EBUSY);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n+    }\n+}\n \n-        let rw = std::cell::UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER);\n-        unsafe {\n-            assert_eq!(libc::pthread_rwlock_rdlock(rw.get()), 0);\n-            assert_eq!(libc::pthread_rwlock_rdlock(rw.get()), 0);\n-            assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n-            assert_eq!(libc::pthread_rwlock_tryrdlock(rw.get()), 0);\n-            assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n-            assert_eq!(libc::pthread_rwlock_trywrlock(rw.get()), libc::EBUSY);\n-            assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n+#[cfg(not(target_os = \"windows\"))]\n+fn test_rwlock_libc_static_initializer() {\n+    let rw = std::cell::UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER);\n+    unsafe {\n+        assert_eq!(libc::pthread_rwlock_rdlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_rdlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_tryrdlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_trywrlock(rw.get()), libc::EBUSY);\n+        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n \n-            assert_eq!(libc::pthread_rwlock_wrlock(rw.get()), 0);\n-            assert_eq!(libc::pthread_rwlock_tryrdlock(rw.get()), libc::EBUSY);\n-            assert_eq!(libc::pthread_rwlock_trywrlock(rw.get()), libc::EBUSY);\n-            assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_wrlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_tryrdlock(rw.get()), libc::EBUSY);\n+        assert_eq!(libc::pthread_rwlock_trywrlock(rw.get()), libc::EBUSY);\n+        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n \n-            assert_eq!(libc::pthread_rwlock_destroy(rw.get()), 0);\n-        }\n+        assert_eq!(libc::pthread_rwlock_destroy(rw.get()), 0);\n     }\n }\n "}]}