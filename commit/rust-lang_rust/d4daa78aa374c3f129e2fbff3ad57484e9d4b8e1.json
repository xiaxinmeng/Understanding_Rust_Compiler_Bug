{"sha": "d4daa78aa374c3f129e2fbff3ad57484e9d4b8e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ZGFhNzhhYTM3NGMzZjEyOWUyZmJmZjNhZDU3NDg0ZTlkNGI4ZTE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-15T03:12:51Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-16T03:55:25Z"}, "message": "Update docs for crate file changes", "tree": {"sha": "669e1e0b75ceee8042ddb04b3c3fbc1f6bdefb0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/669e1e0b75ceee8042ddb04b3c3fbc1f6bdefb0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4daa78aa374c3f129e2fbff3ad57484e9d4b8e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4daa78aa374c3f129e2fbff3ad57484e9d4b8e1", "html_url": "https://github.com/rust-lang/rust/commit/d4daa78aa374c3f129e2fbff3ad57484e9d4b8e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4daa78aa374c3f129e2fbff3ad57484e9d4b8e1/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebd9ad4d0446ac76bdbb0ada21e943ad0cbeef60", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebd9ad4d0446ac76bdbb0ada21e943ad0cbeef60", "html_url": "https://github.com/rust-lang/rust/commit/ebd9ad4d0446ac76bdbb0ada21e943ad0cbeef60"}], "stats": {"total": 178, "additions": 79, "deletions": 99}, "files": [{"sha": "7e554e68b37e816f9711b86d38b82ed928d30d40", "filename": "doc/rust.md", "status": "modified", "additions": 50, "deletions": 70, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/d4daa78aa374c3f129e2fbff3ad57484e9d4b8e1/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/d4daa78aa374c3f129e2fbff3ad57484e9d4b8e1/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=d4daa78aa374c3f129e2fbff3ad57484e9d4b8e1", "patch": "@@ -570,53 +570,29 @@ Semantic rules called \"dynamic semantics\" govern the behavior of programs at run\n A program that fails to compile due to violation of a compile-time rule has no defined dynamic semantics; the compiler should halt with an error report, and produce no executable artifact.\n \n The compilation model centres on artifacts called _crates_.\n-Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or a library.\n+Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or a library.^[A crate is somewhat\n+analogous to an *assembly* in the ECMA-335 CLI model, a *library* in the\n+SML/NJ Compilation Manager, a *unit* in the Owens and Flatt module system,\n+or a *configuration* in Mesa.]\n \n A _crate_ is a unit of compilation and linking, as well as versioning, distribution and runtime loading.\n A crate contains a _tree_ of nested [module](#modules) scopes.\n The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical [module path](#paths) denoting its location within the crate's module tree.\n \n-Crates are provided to the Rust compiler through two kinds of file:\n-\n-  - _crate files_, that end in `.rc` and each define a `crate`.\n-  - _source files_, that end in `.rs` and each define a `module`.\n-\n-> **Note:** The functionality of crate files will be merged into source files in future versions of Rust.\n-> The separate processing of crate files, both their grammar and file extension, will be removed.\n-\n-The Rust compiler is always invoked with a single crate file as input, and always produces a single output crate.\n-\n-When the Rust compiler is invoked with a crate file, it reads the _explicit_\n-definition of the crate it's compiling from that file, and populates the\n-crate with modules derived from all the source files referenced by the\n-crate, reading and processing all the referenced modules at once.\n-\n-When the Rust compiler is invoked with a source file, it creates an _implicit_ crate and treats the source file as if it is the sole module populating this explicit crate.\n-The module name is derived from the source file name, with the `.rs` extension removed.\n-\n-## Crate files\n+The Rust compiler is always invoked with a single source file as input, and always produces a single output crate.\n+The processing of that source file may result in other source files being loaded as modules.\n+Source files typically have the extension `.rs` but, by convention,\n+source files that represent crates have the extension `.rc`, called *crate files*.\n \n-~~~~~~~~ {.ebnf .gram}\n-crate : attribute [ ';' | attribute* directive ]\n-      | directive ;\n-directive : view_item | dir_directive | source_directive ;\n-~~~~~~~~\n-\n-A crate file contains a crate definition, for which the production above\n-defines the grammar. It is a declarative grammar that guides the compiler in\n-assembling a crate from component source files.^[A crate is somewhat\n-analogous to an *assembly* in the ECMA-335 CLI model, a *library* in the\n-SML/NJ Compilation Manager, a *unit* in the Owens and Flatt module system,\n-or a *configuration* in Mesa.] A crate file describes:\n-\n-* [Attributes](#attributes) about the crate, such as author, name, version,\n-  and copyright. These are used for linking, versioning and distributing\n-  crates.\n-* The source-file and directory modules that make up the crate.\n-* Any `use` or `extern mod` [view items](#view-items) that apply to\n-  the anonymous module at the top-level of the crate's module tree.\n+A Rust source file describes a module, the name and\n+location of which -- in the module tree of the current crate -- are defined\n+from outside the source file: either by an explicit `mod_item` in\n+a referencing source file, or by the name of the crate ittself.\n \n-An example of a crate file:\n+Each source file contains a sequence of zero or more `item` definitions,\n+and may optionally begin with any number of `attributes` that apply to the containing module.\n+Atributes on the anonymous crate module define important metadata that influences\n+the behavior of the compiler.\n \n ~~~~~~~~{.xfail-test}\n // Linkage attributes\n@@ -629,40 +605,17 @@ An example of a crate file:\n    license = \"BSD\" ];\n    author = \"Jane Doe\" ];\n \n-// Import a module.\n-extern mod std (ver = \"1.0\");\n+// Specify the output type\n+#[ crate_type = \"lib\" ];\n \n-// Define some modules.\n-#[path = \"foo.rs\"]\n-mod foo;\n-mod bar {\n-    #[path =  \"quux.rs\"]\n-    mod quux;\n-}\n+// Turn on a warning\n+#[ warn(non_camel_case_types) ];\n ~~~~~~~~\n \n-### Dir directives\n-\n-A `dir_directive` forms a module in the module tree making up the crate, as\n-well as implicitly relating that module to a directory in the filesystem\n-containing source files and/or further subdirectories. The filesystem\n-directory associated with a `dir_directive` module can either be explicit,\n-or if omitted, is implicitly the same name as the module.\n-\n-A `source_directive` references a source file, either explicitly or implicitly, by combining the module name with the file extension `.rs`.\n-The module contained in that source file is bound to the module path formed by the `dir_directive` modules containing the `source_directive`.\n-\n-## Source files\n-\n-A source file contains a `module`: that is, a sequence of zero or more\n-`item` definitions. Each source file is an implicit module, the name and\n-location of which -- in the module tree of the current crate -- is defined\n-from outside the source file: either by an explicit `source_directive` in\n-a referencing crate file, or by the filename of the source file itself.\n-\n-A source file that contains a `main` function can be compiled to an executable.\n+A crate that contains a `main` function can be compiled to an executable.\n If a `main` function is present, its return type must be [`unit`](#primitive-types) and it must take no arguments.\n \n+\n # Items and attributes\n \n Crates contain [items](#items),\n@@ -719,7 +672,7 @@ That is, Rust has no notion of type abstraction: there are no first-class \"foral\n ### Modules\n \n ~~~~~~~~ {.ebnf .gram}\n-mod_item : \"mod\" ident '{' mod '}' ;\n+mod_item : \"mod\" ident ( ';' | '{' mod '}' );\n mod : [ view_item | item ] * ;\n ~~~~~~~~\n \n@@ -757,6 +710,33 @@ Declaring a named type that has the same name as a module in scope is forbidden:\n that is, a type definition, trait, struct, enumeration, or type parameter\n can't shadow the name of a module in scope, or vice versa.\n \n+A module without a body is loaded from an external file, by default with the same\n+name as the module, plus the `.rs` extension.\n+When a nested submodule is loaded from an external file,\n+it is loaded from a subdirectory path that mirrors the module hierarchy.\n+\n+~~~ {.xfail-test}\n+// Load the `vec` module from `vec.rs`\n+mod vec;\n+\n+mod task {\n+    // Load the `local_data` module from `task/local_data.rs`\n+    mod local_data;\n+}\n+~~~\n+\n+The directories and files used for loading external file modules can be influenced\n+with the `path` attribute.\n+\n+~~~ {.xfail-test}\n+#[path = \"task_files\"]\n+mod task {\n+    // Load the `local_data` module from `task_files/tls.rs`\n+    #[path = \"tls.rs\"]\n+    mod local_data;\n+}\n+~~~\n+\n #### View items\n \n ~~~~~~~~ {.ebnf .gram}"}, {"sha": "f2414de9e94d7368a007b2c793e330a2b66313de", "filename": "doc/tutorial.md", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d4daa78aa374c3f129e2fbff3ad57484e9d4b8e1/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/d4daa78aa374c3f129e2fbff3ad57484e9d4b8e1/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=d4daa78aa374c3f129e2fbff3ad57484e9d4b8e1", "patch": "@@ -2252,22 +2252,46 @@ The unit of independent compilation in Rust is the crate: rustc\n compiles a single crate at a time, from which it produces either a\n library or executable.\n \n-When compiling a single `.rs` file, the file acts as the whole crate.\n+When compiling a single `.rs` source file, the file acts as the whole crate.\n You can compile it with the `--lib` compiler switch to create a shared\n library, or without, provided that your file contains a `fn main`\n somewhere, to create an executable.\n \n-Larger crates typically span multiple files and are compiled from\n-a crate (.rc) file. Crate files contain their own syntax for loading\n-modules from .rs files and typically include metadata about the crate.\n+Larger crates typically span multiple files and are, by convention,\n+compiled from a source file with the `.rc` extension, called a *crate file*.\n+The crate file extension distinguishes source files that represent\n+crates from those that do not, but otherwise source files and crate files are identical.\n+\n+A typical crate file declares attributes associated with the crate that\n+may affect how the compiler processes the source.\n+Crate attributes specify metadata used for locating and linking crates,\n+the type of crate (library or executable),\n+and control warning and error behavior,\n+among other things.\n+Crate files additionally declare the external crates they depend on\n+as well as any modules loaded from other files.\n \n ~~~~ { .xfail-test }\n+// Crate linkage metadata\n #[link(name = \"farm\", vers = \"2.5\", author = \"mjh\")];\n+\n+// Make a library (\"bin\" is the default)\n #[crate_type = \"lib\"];\n \n+// Turn on a warning\n+#[warn(non_camel_case_types)]\n+\n+// Link to the standard library\n+extern mod std;\n+\n+// Load some modules from other files\n mod cow;\n mod chicken;\n mod horse;\n+\n+fn main() {\n+    ...\n+}\n ~~~~\n \n Compiling this file will cause `rustc` to look for files named\n@@ -2282,7 +2306,7 @@ module, which other crates can use to load the right module. More\n about that later.\n \n To have a nested directory structure for your source files, you can\n-nest mods in your `.rc` file:\n+nest mods:\n \n ~~~~ {.ignore}\n mod poultry {\n@@ -2296,30 +2320,6 @@ The compiler will now look for `poultry/chicken.rs` and\n and `poultry::turkey`. You can also provide a `poultry.rs` to add\n content to the `poultry` module itself.\n \n-When compiling .rc files, if rustc finds a .rs file with the same\n-name, then that .rs file provides the top-level content of the crate.\n-\n-~~~ {.xfail-test}\n-// foo.rc\n-#[link(name = \"foo\", vers=\"1.0\")];\n-\n-mod bar;\n-~~~\n-\n-~~~ {.xfail-test}\n-// foo.rs\n-fn main() { bar::baz(); }\n-~~~\n-\n-> ***Note***: The way rustc looks for .rs files to pair with .rc\n-> files is a major source of confusion and will change. It's likely\n-> that the crate and source file grammars will merge.\n-\n-> ***Note***: The way that directory modules are handled will also\n-> change. The code for directory modules currently lives in a .rs\n-> file with the same name as the directory, _next to_ the directory.\n-> A new scheme will make that file live _inside_ the directory.\n-\n ## Using other crates\n \n The `extern mod` directive lets you use a crate (once it's been"}]}