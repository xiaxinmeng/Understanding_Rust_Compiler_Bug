{"sha": "a811f608349ee5044ffcdcd2c8190b913d0668e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MTFmNjA4MzQ5ZWU1MDQ0ZmZjZGNkMmM4MTkwYjkxM2QwNjY4ZTQ=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-20T04:16:58Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:04:45Z"}, "message": "Simplify get_landing_pad by inlining UnwindKind.", "tree": {"sha": "cebfe30e1aa2ef70c729d9d22aa8e9da1cd45b38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cebfe30e1aa2ef70c729d9d22aa8e9da1cd45b38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a811f608349ee5044ffcdcd2c8190b913d0668e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a811f608349ee5044ffcdcd2c8190b913d0668e4", "html_url": "https://github.com/rust-lang/rust/commit/a811f608349ee5044ffcdcd2c8190b913d0668e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a811f608349ee5044ffcdcd2c8190b913d0668e4/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "654131cb5376514eb355f40837790afca7fa3e7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/654131cb5376514eb355f40837790afca7fa3e7d", "html_url": "https://github.com/rust-lang/rust/commit/654131cb5376514eb355f40837790afca7fa3e7d"}], "stats": {"total": 94, "additions": 22, "deletions": 72}, "files": [{"sha": "84a731c9d7df7e57888a49d6967db3883630d13a", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 22, "deletions": 72, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/a811f608349ee5044ffcdcd2c8190b913d0668e4/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a811f608349ee5044ffcdcd2c8190b913d0668e4/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=a811f608349ee5044ffcdcd2c8190b913d0668e4", "patch": "@@ -19,8 +19,7 @@\n //! completing evaluation successfully without panic).\n \n use llvm::{BasicBlockRef, ValueRef};\n-use base::{self, Lifetime};\n-use common;\n+use base;\n use common::{BlockAndBuilder, FunctionContext, Funclet};\n use glue;\n use type_::Type;\n@@ -55,90 +54,41 @@ impl<'tcx> DropValue<'tcx> {\n     /// This should only be called once per function, as it creates an alloca for the landingpad.\n     fn get_landing_pad<'a>(&self, fcx: &FunctionContext<'a, 'tcx>) -> BasicBlockRef {\n         debug!(\"get_landing_pad\");\n+        let bcx = fcx.build_new_block(\"cleanup_unwind\");\n+        let llpersonality = bcx.ccx.eh_personality();\n+        bcx.set_personality_fn(llpersonality);\n \n-        let mut pad_bcx = fcx.build_new_block(\"unwind_custom_\");\n-\n-        let llpersonality = pad_bcx.ccx.eh_personality();\n-\n-        let resume_bcx = fcx.build_new_block(\"resume\");\n-        let val = if base::wants_msvc_seh(fcx.ccx.sess()) {\n-            // A cleanup pad requires a personality function to be specified, so\n-            // we do that here explicitly (happens implicitly below through\n-            // creation of the landingpad instruction). We then create a\n-            // cleanuppad instruction which has no filters to run cleanup on all\n-            // exceptions.\n-            pad_bcx.set_personality_fn(llpersonality);\n-            let llretval = pad_bcx.cleanup_pad(None, &[]);\n-            resume_bcx.cleanup_ret(resume_bcx.cleanup_pad(None, &[]), None);\n-            UnwindKind::CleanupPad(llretval)\n+        if base::wants_msvc_seh(fcx.ccx.sess()) {\n+            // Insert cleanup instructions into the cleanup block\n+            let funclet = Some(Funclet::new(bcx.cleanup_pad(None, &[])));\n+            self.trans(funclet.as_ref(), &bcx);\n+\n+            bcx.cleanup_ret(bcx.cleanup_pad(None, &[]), None);\n         } else {\n             // The landing pad return type (the type being propagated). Not sure\n             // what this represents but it's determined by the personality\n             // function and this is what the EH proposal example uses.\n             let llretty = Type::struct_(fcx.ccx, &[Type::i8p(fcx.ccx), Type::i32(fcx.ccx)], false);\n \n             // The only landing pad clause will be 'cleanup'\n-            let llretval = pad_bcx.landing_pad(llretty, llpersonality, 1, pad_bcx.fcx().llfn);\n+            let llretval = bcx.landing_pad(llretty, llpersonality, 1, bcx.fcx().llfn);\n \n             // The landing pad block is a cleanup\n-            pad_bcx.set_cleanup(llretval);\n-\n-            let addr = pad_bcx.fcx().alloca(common::val_ty(llretval), \"\");\n-            Lifetime::Start.call(&pad_bcx, addr);\n-            pad_bcx.store(llretval, addr);\n-            let lp = resume_bcx.load(addr);\n-            Lifetime::End.call(&resume_bcx, addr);\n-            if !resume_bcx.sess().target.target.options.custom_unwind_resume {\n-                resume_bcx.resume(lp);\n-            } else {\n-                let exc_ptr = resume_bcx.extract_value(lp, 0);\n-                resume_bcx.call(fcx.eh_unwind_resume().reify(fcx.ccx), &[exc_ptr], None);\n-                resume_bcx.unreachable();\n-            }\n-            UnwindKind::LandingPad\n-        };\n+            bcx.set_cleanup(llretval);\n \n-        let mut cleanup = fcx.build_new_block(\"clean_custom_\");\n+            // Insert cleanup instructions into the cleanup block\n+            self.trans(None, &bcx);\n \n-        // Insert cleanup instructions into the cleanup block\n-        let funclet = match val {\n-            UnwindKind::CleanupPad(_) => Some(Funclet::new(cleanup.cleanup_pad(None, &[]))),\n-            UnwindKind::LandingPad => None,\n-        };\n-        self.trans(funclet.as_ref(), &cleanup);\n-\n-        // Insert instruction into cleanup block to branch to the exit\n-        val.branch(&mut cleanup, resume_bcx.llbb());\n-\n-        // Branch into the cleanup block\n-        val.branch(&mut pad_bcx, cleanup.llbb());\n-\n-        pad_bcx.llbb()\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-enum UnwindKind {\n-    LandingPad,\n-    CleanupPad(ValueRef),\n-}\n-\n-impl UnwindKind {\n-    /// Generates a branch going from `bcx` to `to_llbb` where `self` is\n-    /// the exit label attached to the start of `bcx`.\n-    ///\n-    /// Transitions from an exit label to other exit labels depend on the type\n-    /// of label. For example with MSVC exceptions unwind exit labels will use\n-    /// the `cleanupret` instruction instead of the `br` instruction.\n-    fn branch(&self, bcx: &BlockAndBuilder, to_llbb: BasicBlockRef) {\n-        match *self {\n-            UnwindKind::CleanupPad(pad) => {\n-                bcx.cleanup_ret(pad, Some(to_llbb));\n-            }\n-            UnwindKind::LandingPad => {\n-                bcx.br(to_llbb);\n+            if !bcx.sess().target.target.options.custom_unwind_resume {\n+                bcx.resume(llretval);\n+            } else {\n+                let exc_ptr = bcx.extract_value(llretval, 0);\n+                bcx.call(fcx.eh_unwind_resume().reify(fcx.ccx), &[exc_ptr], None);\n+                bcx.unreachable();\n             }\n         }\n+\n+        bcx.llbb()\n     }\n }\n "}]}