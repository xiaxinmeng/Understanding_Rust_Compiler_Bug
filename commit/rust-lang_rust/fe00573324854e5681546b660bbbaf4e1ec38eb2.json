{"sha": "fe00573324854e5681546b660bbbaf4e1ec38eb2", "node_id": "C_kwDOAAsO6NoAKGZlMDA1NzMzMjQ4NTRlNTY4MTU0NmI2NjBiYmJhZjRlMWVjMzhlYjI", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-17T20:02:49Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-20T21:12:04Z"}, "message": "make use of symbolic vtables in interpreter", "tree": {"sha": "226774fcd3c885bc7cdafde8a5aa0425c762b651", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/226774fcd3c885bc7cdafde8a5aa0425c762b651"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe00573324854e5681546b660bbbaf4e1ec38eb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe00573324854e5681546b660bbbaf4e1ec38eb2", "html_url": "https://github.com/rust-lang/rust/commit/fe00573324854e5681546b660bbbaf4e1ec38eb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe00573324854e5681546b660bbbaf4e1ec38eb2/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a10d8e458118b3feac96fe5e56c25e70cee99b88", "url": "https://api.github.com/repos/rust-lang/rust/commits/a10d8e458118b3feac96fe5e56c25e70cee99b88", "html_url": "https://github.com/rust-lang/rust/commit/a10d8e458118b3feac96fe5e56c25e70cee99b88"}], "stats": {"total": 660, "additions": 283, "deletions": 377}, "files": [{"sha": "473ba848a58300112f540faffdedf2bc8fcc8f48", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -299,29 +299,35 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n                 let val = self.read_immediate(src)?;\n+                let (old_data, old_vptr) = val.to_scalar_pair()?;\n+                let old_vptr = self.scalar_to_ptr(old_vptr)?;\n                 if data_a.principal_def_id() == data_b.principal_def_id() {\n                     return self.write_immediate(*val, dest);\n                 }\n                 // trait upcasting coercion\n-                let vptr_entry_idx = self.tcx.vtable_trait_upcasting_coercion_new_vptr_slot((\n+                let Some(vptr_entry_idx) = self.tcx.vtable_trait_upcasting_coercion_new_vptr_slot((\n                     src_pointee_ty,\n                     dest_pointee_ty,\n-                ));\n-\n-                if let Some(entry_idx) = vptr_entry_idx {\n-                    let entry_idx = u64::try_from(entry_idx).unwrap();\n-                    let (old_data, old_vptr) = val.to_scalar_pair()?;\n-                    let old_vptr = self.scalar_to_ptr(old_vptr)?;\n-                    let new_vptr = self\n-                        .read_new_vtable_after_trait_upcasting_from_vtable(old_vptr, entry_idx)?;\n-                    self.write_immediate(Immediate::new_dyn_trait(old_data, new_vptr, self), dest)\n-                } else {\n-                    self.write_immediate(*val, dest)\n-                }\n+                )) else {\n+                    return self.write_immediate(*val, dest);\n+                };\n+\n+                let (ty, _) = self.get_ptr_vtable(old_vptr)?;\n+                let Some(ty::VtblEntry::TraitVPtr(new_trait)) = self.get_vtable_entries(old_vptr)?.get(vptr_entry_idx) else {\n+                    throw_ub_format!(\n+                        \"upcasting to index {vptr_entry_idx} of vtable {old_vptr} but \\\n+                        that vtable is too small or does not have an upcast-vtable at that index\"\n+                    )\n+                };\n+                let new_trait = new_trait.map_bound(|trait_ref| {\n+                    ty::ExistentialTraitRef::erase_self_ty(*self.tcx, trait_ref)\n+                });\n+                let new_vptr = self.get_vtable_ptr(ty, Some(new_trait))?;\n+                self.write_immediate(Immediate::new_dyn_trait(old_data, new_vptr, self), dest)\n             }\n             (_, &ty::Dynamic(ref data, _)) => {\n                 // Initial cast from sized to dyn trait\n-                let vtable = self.get_vtable(src_pointee_ty, data.principal())?;\n+                let vtable = self.get_vtable_ptr(src_pointee_ty, data.principal())?;\n                 let ptr = self.read_immediate(src)?.to_scalar()?;\n                 let val = Immediate::new_dyn_trait(ptr, vtable, &*self.tcx);\n                 self.write_immediate(val, dest)"}, {"sha": "fdf243c4108d31bb4afa0329428a27444bff8e37", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -631,7 +631,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ty::Dynamic(..) => {\n                 let vtable = self.scalar_to_ptr(metadata.unwrap_meta())?;\n                 // Read size and align from vtable (already checks size).\n-                Ok(Some(self.read_size_and_align_from_vtable(vtable)?))\n+                Ok(Some(self.get_vtable_size_and_align(vtable)?))\n             }\n \n             ty::Slice(_) | ty::Str => {"}, {"sha": "5e49e6a4f084514749e59bac370f314e171e942a", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -16,7 +16,7 @@ use std::ptr;\n use rustc_ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_middle::mir::display_allocation;\n-use rustc_middle::ty::{Instance, ParamEnv, TyCtxt};\n+use rustc_middle::ty::{self, Instance, ParamEnv, Ty, TyCtxt};\n use rustc_target::abi::{Align, HasDataLayout, Size};\n \n use super::{\n@@ -500,6 +500,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // contains a reference to memory that was created during its evaluation (i.e., not\n                 // to another static), those inner references only exist in \"resolved\" form.\n                 if self.tcx.is_foreign_item(def_id) {\n+                    // This is unreachable in Miri, but can happen in CTFE where we actually *do* support\n+                    // referencing arbitrary (declared) extern statics.\n                     throw_unsup!(ReadExternStatic(def_id));\n                 }\n \n@@ -670,11 +672,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Can't do this in the match argument, we may get cycle errors since the lock would\n         // be held throughout the match.\n         match self.tcx.try_get_global_alloc(id) {\n-            Some(GlobalAlloc::Static(did)) => {\n-                assert!(!self.tcx.is_thread_local_static(did));\n+            Some(GlobalAlloc::Static(def_id)) => {\n+                assert!(self.tcx.is_static(def_id));\n+                assert!(!self.tcx.is_thread_local_static(def_id));\n                 // Use size and align of the type.\n-                let ty = self.tcx.type_of(did);\n+                let ty = self.tcx.type_of(def_id);\n                 let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n+                assert!(!layout.is_unsized());\n                 (layout.size, layout.align.abi, AllocKind::LiveData)\n             }\n             Some(GlobalAlloc::Memory(alloc)) => {\n@@ -685,8 +689,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             Some(GlobalAlloc::Function(_)) => bug!(\"We already checked function pointers above\"),\n             Some(GlobalAlloc::Vtable(..)) => {\n-                // No data to be accessed here.\n-                return (Size::ZERO, Align::ONE, AllocKind::Vtable);\n+                // No data to be accessed here. But vtables are pointer-aligned.\n+                return (Size::ZERO, self.tcx.data_layout.pointer_align.abi, AllocKind::Vtable);\n             }\n             // The rest must be dead.\n             None => {\n@@ -726,7 +730,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         ptr: Pointer<Option<M::Provenance>>,\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n-        trace!(\"get_fn({:?})\", ptr);\n+        trace!(\"get_ptr_fn({:?})\", ptr);\n         let (alloc_id, offset, _prov) = self.ptr_get_alloc_id(ptr)?;\n         if offset.bytes() != 0 {\n             throw_ub!(InvalidFunctionPointer(Pointer::new(alloc_id, offset)))\n@@ -735,6 +739,21 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .ok_or_else(|| err_ub!(InvalidFunctionPointer(Pointer::new(alloc_id, offset))).into())\n     }\n \n+    pub fn get_ptr_vtable(\n+        &self,\n+        ptr: Pointer<Option<M::Provenance>>,\n+    ) -> InterpResult<'tcx, (Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>)> {\n+        trace!(\"get_ptr_vtable({:?})\", ptr);\n+        let (alloc_id, offset, _tag) = self.ptr_get_alloc_id(ptr)?;\n+        if offset.bytes() != 0 {\n+            throw_ub!(InvalidVtablePointer(Pointer::new(alloc_id, offset)))\n+        }\n+        match self.tcx.try_get_global_alloc(alloc_id) {\n+            Some(GlobalAlloc::Vtable(ty, trait_ref)) => Ok((ty, trait_ref)),\n+            _ => throw_ub!(InvalidVtablePointer(Pointer::new(alloc_id, offset))),\n+        }\n+    }\n+\n     pub fn alloc_mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {\n         self.get_alloc_raw_mut(id)?.0.mutability = Mutability::Not;\n         Ok(())"}, {"sha": "c7d8a744f7c09878c158e254a9a25d777ee25582", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -885,28 +885,19 @@ where\n     }\n \n     /// Turn a place with a `dyn Trait` type into a place with the actual dynamic type.\n-    /// Also return some more information so drop doesn't have to run the same code twice.\n     pub(super) fn unpack_dyn_trait(\n         &self,\n         mplace: &MPlaceTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, (ty::Instance<'tcx>, MPlaceTy<'tcx, M::Provenance>)> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n         let vtable = self.scalar_to_ptr(mplace.vtable())?; // also sanity checks the type\n-        let (instance, ty) = self.read_drop_type_from_vtable(vtable)?;\n+        let (ty, _) = self.get_ptr_vtable(vtable)?;\n         let layout = self.layout_of(ty)?;\n \n-        // More sanity checks\n-        if cfg!(debug_assertions) {\n-            let (size, align) = self.read_size_and_align_from_vtable(vtable)?;\n-            assert_eq!(size, layout.size);\n-            // only ABI alignment is preserved\n-            assert_eq!(align, layout.align.abi);\n-        }\n-\n         let mplace = MPlaceTy {\n             mplace: MemPlace { meta: MemPlaceMeta::None, ..**mplace },\n             layout,\n             align: layout.align.abi,\n         };\n-        Ok((instance, mplace))\n+        Ok(mplace)\n     }\n }"}, {"sha": "2ae0e1a6f5ac78aa5d76f351868db028995512b8", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -1,5 +1,4 @@\n use std::borrow::Cow;\n-use std::convert::TryFrom;\n \n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf};\n use rustc_middle::ty::Instance;\n@@ -563,7 +562,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     ty::Dynamic(..)\n                 ));\n                 let vtable = self.scalar_to_ptr(receiver_place.meta.unwrap_meta())?;\n-                let fn_val = self.get_vtable_slot(vtable, u64::try_from(idx).unwrap())?;\n+                let Some(ty::VtblEntry::Method(fn_inst)) = self.get_vtable_entries(vtable)?.get(idx).copied() else {\n+                    throw_ub_format!(\n+                        \"calling index {idx} of vtable {vtable} but \\\n+                        that vtable is too small or does not have a method at that index\"\n+                    )\n+                };\n \n                 // `*mut receiver_place.layout.ty` is almost the layout that we\n                 // want for args[0]: We have to project to field 0 because we want\n@@ -579,7 +583,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 trace!(\"Patched receiver operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n                 self.eval_fn_call(\n-                    fn_val,\n+                    FnVal::Instance(fn_inst),\n                     (caller_abi, caller_fn_abi),\n                     &args,\n                     with_caller_location,\n@@ -606,8 +610,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let (instance, place) = match place.layout.ty.kind() {\n             ty::Dynamic(..) => {\n-                // Dropping a trait object.\n-                self.unpack_dyn_trait(&place)?\n+                // Dropping a trait object. Need to find actual drop fn.\n+                let place = self.unpack_dyn_trait(&place)?;\n+                let instance = ty::Instance::resolve_drop_in_place(*self.tcx, place.layout.ty);\n+                (instance, place)\n             }\n             _ => (instance, place),\n         };"}, {"sha": "bddca2a20edecd55fd218190f372162f14bfe4cf", "filename": "compiler/rustc_const_eval/src/interpret/traits.rs", "status": "modified", "additions": 24, "deletions": 109, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -1,14 +1,10 @@\n-use std::convert::TryFrom;\n-\n-use rustc_middle::mir::interpret::{alloc_range, InterpResult, Pointer, PointerArithmetic};\n-use rustc_middle::ty::{\n-    self, Ty, TyCtxt, COMMON_VTABLE_ENTRIES_ALIGN, COMMON_VTABLE_ENTRIES_DROPINPLACE,\n-    COMMON_VTABLE_ENTRIES_SIZE,\n-};\n+use rustc_middle::mir::interpret::{InterpResult, Pointer};\n+use rustc_middle::ty::layout::LayoutOf;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_target::abi::{Align, Size};\n \n use super::util::ensure_monomorphic_enough;\n-use super::{FnVal, InterpCx, Machine};\n+use super::{InterpCx, Machine};\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n@@ -17,8 +13,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// The `trait_ref` encodes the erased self type. Hence, if we are\n     /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n     /// `trait_ref` would map `T: Trait`.\n-    pub fn get_vtable(\n-        &mut self,\n+    pub fn get_vtable_ptr(\n+        &self,\n         ty: Ty<'tcx>,\n         poly_trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n     ) -> InterpResult<'tcx, Pointer<Option<M::Provenance>>> {\n@@ -30,114 +26,33 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ensure_monomorphic_enough(*self.tcx, ty)?;\n         ensure_monomorphic_enough(*self.tcx, poly_trait_ref)?;\n \n-        let vtable_allocation = self.tcx.vtable_allocation((ty, poly_trait_ref));\n-\n-        let vtable_ptr = self.global_base_pointer(Pointer::from(vtable_allocation))?;\n-\n+        let vtable_symbolic_allocation = self.tcx.create_vtable_alloc(ty, poly_trait_ref);\n+        let vtable_ptr = self.global_base_pointer(Pointer::from(vtable_symbolic_allocation))?;\n         Ok(vtable_ptr.into())\n     }\n \n-    /// Resolves the function at the specified slot in the provided\n-    /// vtable. Currently an index of '3' (`TyCtxt::COMMON_VTABLE_ENTRIES.len()`)\n-    /// corresponds to the first method declared in the trait of the provided vtable.\n-    pub fn get_vtable_slot(\n+    /// Returns a high-level representation of the entires of the given vtable.\n+    pub fn get_vtable_entries(\n         &self,\n         vtable: Pointer<Option<M::Provenance>>,\n-        idx: u64,\n-    ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n-        let ptr_size = self.pointer_size();\n-        let vtable_slot = vtable.offset(ptr_size * idx, self)?;\n-        let vtable_slot = self\n-            .get_ptr_alloc(vtable_slot, ptr_size, self.tcx.data_layout.pointer_align.abi)?\n-            .expect(\"cannot be a ZST\");\n-        let fn_ptr = self.scalar_to_ptr(vtable_slot.read_pointer(Size::ZERO)?.check_init()?)?;\n-        self.get_ptr_fn(fn_ptr)\n+    ) -> InterpResult<'tcx, &'tcx [ty::VtblEntry<'tcx>]> {\n+        let (ty, poly_trait_ref) = self.get_ptr_vtable(vtable)?;\n+        Ok(if let Some(poly_trait_ref) = poly_trait_ref {\n+            let trait_ref = poly_trait_ref.with_self_ty(*self.tcx, ty);\n+            let trait_ref = self.tcx.erase_regions(trait_ref);\n+            self.tcx.vtable_entries(trait_ref)\n+        } else {\n+            TyCtxt::COMMON_VTABLE_ENTRIES\n+        })\n     }\n \n-    /// Returns the drop fn instance as well as the actual dynamic type.\n-    pub fn read_drop_type_from_vtable(\n-        &self,\n-        vtable: Pointer<Option<M::Provenance>>,\n-    ) -> InterpResult<'tcx, (ty::Instance<'tcx>, Ty<'tcx>)> {\n-        let pointer_size = self.pointer_size();\n-        // We don't care about the pointee type; we just want a pointer.\n-        let vtable = self\n-            .get_ptr_alloc(\n-                vtable,\n-                pointer_size * u64::try_from(TyCtxt::COMMON_VTABLE_ENTRIES.len()).unwrap(),\n-                self.tcx.data_layout.pointer_align.abi,\n-            )?\n-            .expect(\"cannot be a ZST\");\n-        let drop_fn = vtable\n-            .read_pointer(pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_DROPINPLACE).unwrap())?\n-            .check_init()?;\n-        // We *need* an instance here, no other kind of function value, to be able\n-        // to determine the type.\n-        let drop_instance = self.get_ptr_fn(self.scalar_to_ptr(drop_fn)?)?.as_instance()?;\n-        trace!(\"Found drop fn: {:?}\", drop_instance);\n-        let fn_sig = drop_instance.ty(*self.tcx, self.param_env).fn_sig(*self.tcx);\n-        let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, fn_sig);\n-        // The drop function takes `*mut T` where `T` is the type being dropped, so get that.\n-        let args = fn_sig.inputs();\n-        if args.len() != 1 {\n-            throw_ub!(InvalidVtableDropFn(fn_sig));\n-        }\n-        let ty =\n-            args[0].builtin_deref(true).ok_or_else(|| err_ub!(InvalidVtableDropFn(fn_sig)))?.ty;\n-        Ok((drop_instance, ty))\n-    }\n-\n-    pub fn read_size_and_align_from_vtable(\n+    pub fn get_vtable_size_and_align(\n         &self,\n         vtable: Pointer<Option<M::Provenance>>,\n     ) -> InterpResult<'tcx, (Size, Align)> {\n-        let pointer_size = self.pointer_size();\n-        // We check for `size = 3 * ptr_size`, which covers the drop fn (unused here),\n-        // the size, and the align (which we read below).\n-        let vtable = self\n-            .get_ptr_alloc(\n-                vtable,\n-                pointer_size * u64::try_from(TyCtxt::COMMON_VTABLE_ENTRIES.len()).unwrap(),\n-                self.tcx.data_layout.pointer_align.abi,\n-            )?\n-            .expect(\"cannot be a ZST\");\n-        let size = vtable\n-            .read_integer(alloc_range(\n-                pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_SIZE).unwrap(),\n-                pointer_size,\n-            ))?\n-            .check_init()?;\n-        let size = size.to_machine_usize(self)?;\n-        let size = Size::from_bytes(size);\n-        let align = vtable\n-            .read_integer(alloc_range(\n-                pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_ALIGN).unwrap(),\n-                pointer_size,\n-            ))?\n-            .check_init()?;\n-        let align = align.to_machine_usize(self)?;\n-        let align = Align::from_bytes(align).map_err(|e| err_ub!(InvalidVtableAlignment(e)))?;\n-\n-        if size > self.max_size_of_val() {\n-            throw_ub!(InvalidVtableSize);\n-        }\n-        Ok((size, align))\n-    }\n-\n-    pub fn read_new_vtable_after_trait_upcasting_from_vtable(\n-        &self,\n-        vtable: Pointer<Option<M::Provenance>>,\n-        idx: u64,\n-    ) -> InterpResult<'tcx, Pointer<Option<M::Provenance>>> {\n-        let pointer_size = self.pointer_size();\n-\n-        let vtable_slot = vtable.offset(pointer_size * idx, self)?;\n-        let new_vtable = self\n-            .get_ptr_alloc(vtable_slot, pointer_size, self.tcx.data_layout.pointer_align.abi)?\n-            .expect(\"cannot be a ZST\");\n-\n-        let new_vtable = self.scalar_to_ptr(new_vtable.read_pointer(Size::ZERO)?.check_init()?)?;\n-\n-        Ok(new_vtable)\n+        let (ty, _trait_ref) = self.get_ptr_vtable(vtable)?;\n+        let layout = self.layout_of(ty)?;\n+        assert!(!layout.is_unsized(), \"there are no vtables for unsized types\");\n+        Ok((layout.size, layout.align.abi))\n     }\n }"}, {"sha": "190eb732f9ad32e6c32c550eda3eea3a7b0777e8", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 7, "deletions": 44, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -313,50 +313,15 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         match tail.kind() {\n             ty::Dynamic(..) => {\n                 let vtable = self.ecx.scalar_to_ptr(meta.unwrap_meta())?;\n-                // Direct call to `check_ptr_access_align` checks alignment even on CTFE machines.\n-                try_validation!(\n-                    self.ecx.check_ptr_access_align(\n-                        vtable,\n-                        3 * self.ecx.tcx.data_layout.pointer_size, // drop, size, align\n-                        self.ecx.tcx.data_layout.pointer_align.abi,\n-                        CheckInAllocMsg::InboundsTest, // will anyway be replaced by validity message\n-                    ),\n-                    self.path,\n-                    err_ub!(DanglingIntPointer(..)) |\n-                    err_ub!(PointerUseAfterFree(..)) =>\n-                        { \"dangling vtable pointer in wide pointer\" },\n-                    err_ub!(AlignmentCheckFailed { .. }) =>\n-                        { \"unaligned vtable pointer in wide pointer\" },\n-                    err_ub!(PointerOutOfBounds { .. }) =>\n-                        { \"too small vtable\" },\n-                );\n-                try_validation!(\n-                    self.ecx.read_drop_type_from_vtable(vtable),\n+                // Make sure it is a genuine vtable pointer.\n+                let (_ty, _trait) = try_validation!(\n+                    self.ecx.get_ptr_vtable(vtable),\n                     self.path,\n                     err_ub!(DanglingIntPointer(..)) |\n-                    err_ub!(InvalidFunctionPointer(..)) =>\n-                        { \"invalid drop function pointer in vtable (not pointing to a function)\" },\n-                    err_ub!(InvalidVtableDropFn(..)) =>\n-                        { \"invalid drop function pointer in vtable (function has incompatible signature)\" },\n-                    // Stacked Borrows errors can happen here, see https://github.com/rust-lang/miri/issues/2123.\n-                    // (We assume there are no other MachineStop errors possible here.)\n-                    InterpError::MachineStop(_) =>\n-                        { \"vtable pointer does not have permission to read drop function pointer\" },\n-                );\n-                try_validation!(\n-                    self.ecx.read_size_and_align_from_vtable(vtable),\n-                    self.path,\n-                    err_ub!(InvalidVtableSize) =>\n-                        { \"invalid vtable: size is bigger than largest supported object\" },\n-                    err_ub!(InvalidVtableAlignment(msg)) =>\n-                        { \"invalid vtable: alignment {}\", msg },\n-                    err_unsup!(ReadPointerAsBytes) => { \"invalid size or align in vtable\" },\n-                    // Stacked Borrows errors can happen here, see https://github.com/rust-lang/miri/issues/2123.\n-                    // (We assume there are no other MachineStop errors possible here.)\n-                    InterpError::MachineStop(_) =>\n-                        { \"vtable pointer does not have permission to read size and alignment\" },\n+                    err_ub!(InvalidVtablePointer(..)) =>\n+                        { \"{vtable}\" } expected { \"a vtable pointer\" },\n                 );\n-                // FIXME: More checks for the vtable.\n+                // FIXME: check if the type/trait match what ty::Dynamic says?\n             }\n             ty::Slice(..) | ty::Str => {\n                 let _len = try_validation!(\n@@ -607,11 +572,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     let _fn = try_validation!(\n                         self.ecx.get_ptr_fn(ptr),\n                         self.path,\n-                        err_ub!(DanglingIntPointer(0, _)) =>\n-                            { \"a null function pointer\" },\n                         err_ub!(DanglingIntPointer(..)) |\n                         err_ub!(InvalidFunctionPointer(..)) =>\n-                            { \"{:x}\", value } expected { \"a function pointer\" },\n+                            { \"{ptr}\" } expected { \"a function pointer\" },\n                     );\n                     // FIXME: Check if the signature matches\n                 } else {"}, {"sha": "aee1f93b1a39cc65e2eef83fde163d0650ac3827", "filename": "compiler/rustc_const_eval/src/interpret/visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -425,7 +425,7 @@ macro_rules! make_value_visitor {\n                         // unsized values are never immediate, so we can assert_mem_place\n                         let op = v.to_op_for_read(self.ecx())?;\n                         let dest = op.assert_mem_place();\n-                        let inner_mplace = self.ecx().unpack_dyn_trait(&dest)?.1;\n+                        let inner_mplace = self.ecx().unpack_dyn_trait(&dest)?;\n                         trace!(\"walk_value: dyn object layout: {:#?}\", inner_mplace.layout);\n                         // recurse with the inner type\n                         return self.visit_field(&v, 0, &$value_trait::from_op(&inner_mplace.into()));"}, {"sha": "81d9db98478f928d91e27dcd1cec51786fde139a", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -1,7 +1,7 @@\n use super::{AllocId, AllocRange, ConstAlloc, Pointer, Scalar};\n \n use crate::mir::interpret::ConstValue;\n-use crate::ty::{layout, query::TyCtxtAt, tls, FnSig, Ty, ValTree};\n+use crate::ty::{layout, query::TyCtxtAt, tls, Ty, ValTree};\n \n use rustc_data_structures::sync::Lock;\n use rustc_errors::{pluralize, struct_span_err, DiagnosticBuilder, ErrorGuaranteed};\n@@ -219,7 +219,7 @@ pub struct ScalarSizeMismatch {\n }\n \n /// Error information for when the program caused Undefined Behavior.\n-pub enum UndefinedBehaviorInfo<'tcx> {\n+pub enum UndefinedBehaviorInfo {\n     /// Free-form case. Only for errors that are never caught!\n     Ub(String),\n     /// Unreachable code was executed.\n@@ -241,12 +241,6 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     PointerArithOverflow,\n     /// Invalid metadata in a wide pointer (using `str` to avoid allocations).\n     InvalidMeta(&'static str),\n-    /// Invalid drop function in vtable.\n-    InvalidVtableDropFn(FnSig<'tcx>),\n-    /// Invalid size in a vtable: too large.\n-    InvalidVtableSize,\n-    /// Invalid alignment in a vtable: too large, or not a power of 2.\n-    InvalidVtableAlignment(String),\n     /// Reading a C string that does not end within its allocation.\n     UnterminatedCString(Pointer),\n     /// Dereferencing a dangling pointer after it got freed.\n@@ -290,6 +284,8 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     InvalidTag(Scalar),\n     /// Using a pointer-not-to-a-function as function pointer.\n     InvalidFunctionPointer(Pointer),\n+    /// Using a pointer-not-to-a-vtable as vtable pointer.\n+    InvalidVtablePointer(Pointer),\n     /// Using a string that is not valid UTF-8,\n     InvalidStr(std::str::Utf8Error),\n     /// Using uninitialized data where it is not allowed.\n@@ -302,7 +298,7 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     UninhabitedEnumVariantWritten,\n }\n \n-impl fmt::Display for UndefinedBehaviorInfo<'_> {\n+impl fmt::Display for UndefinedBehaviorInfo {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use UndefinedBehaviorInfo::*;\n         match self {\n@@ -317,14 +313,6 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n             RemainderOverflow => write!(f, \"overflow in signed remainder (dividing MIN by -1)\"),\n             PointerArithOverflow => write!(f, \"overflowing in-bounds pointer arithmetic\"),\n             InvalidMeta(msg) => write!(f, \"invalid metadata in wide pointer: {msg}\"),\n-            InvalidVtableDropFn(sig) => write!(\n-                f,\n-                \"invalid drop function signature: got {sig}, expected exactly one argument which must be a pointer type\",\n-            ),\n-            InvalidVtableSize => {\n-                write!(f, \"invalid vtable: size is bigger than largest supported object\")\n-            }\n-            InvalidVtableAlignment(msg) => write!(f, \"invalid vtable: alignment {msg}\"),\n             UnterminatedCString(p) => write!(\n                 f,\n                 \"reading a null-terminated string starting at {p:?} with no null found before end of allocation\",\n@@ -378,6 +366,9 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n             InvalidFunctionPointer(p) => {\n                 write!(f, \"using {p:?} as function pointer but it does not point to a function\")\n             }\n+            InvalidVtablePointer(p) => {\n+                write!(f, \"using {p:?} as vtable pointer but it does not point to a vtable\")\n+            }\n             InvalidStr(err) => write!(f, \"this string is not valid UTF-8: {err}\"),\n             InvalidUninitBytes(Some((alloc, info))) => write!(\n                 f,\n@@ -497,7 +488,7 @@ impl dyn MachineStopType {\n \n pub enum InterpError<'tcx> {\n     /// The program caused undefined behavior.\n-    UndefinedBehavior(UndefinedBehaviorInfo<'tcx>),\n+    UndefinedBehavior(UndefinedBehaviorInfo),\n     /// The program did something the interpreter does not support (some of these *might* be UB\n     /// but the interpreter is not sure).\n     Unsupported(UnsupportedOpInfo),"}, {"sha": "90a454c75a1cecf2823060c5db65492f05c71b80", "filename": "src/test/ui/consts/const-eval/const_transmute.rs", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a10d8e458118b3feac96fe5e56c25e70cee99b88/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10d8e458118b3feac96fe5e56c25e70cee99b88/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_transmute.rs?ref=a10d8e458118b3feac96fe5e56c25e70cee99b88", "patch": "@@ -1,54 +0,0 @@\n-// run-pass\n-\n-#![allow(dead_code)]\n-\n-#[repr(C)]\n-union Transmute<T: Copy, U: Copy> {\n-    t: T,\n-    u: U,\n-}\n-\n-trait Bar {\n-    fn bar(&self) -> u32;\n-}\n-\n-struct Foo {\n-    foo: u32,\n-    bar: bool,\n-}\n-\n-impl Bar for Foo {\n-    fn bar(&self) -> u32 {\n-        self.foo\n-    }\n-}\n-\n-impl Drop for Foo {\n-    fn drop(&mut self) {\n-        assert!(!self.bar);\n-        self.bar = true;\n-        println!(\"dropping Foo\");\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-struct Fat<'a>(&'a Foo, &'static VTable);\n-\n-struct VTable {\n-    drop: Option<for<'a> fn(&'a mut Foo)>,\n-    size: usize,\n-    align: usize,\n-    bar: for<'a> fn(&'a Foo) -> u32,\n-}\n-\n-const FOO: &dyn Bar = &Foo { foo: 128, bar: false };\n-const G: Fat = unsafe { Transmute { t: FOO }.u };\n-const F: Option<for<'a> fn(&'a mut Foo)> = G.1.drop;\n-const H: for<'a> fn(&'a Foo) -> u32 = G.1.bar;\n-\n-fn main() {\n-    let mut foo = Foo { foo: 99, bar: false };\n-    (F.unwrap())(&mut foo);\n-    std::mem::forget(foo); // already ran the drop impl\n-    assert_eq!(H(&Foo { foo: 42, bar: false }), 42);\n-}"}, {"sha": "965256de21a0f4159ef66dd00635e42630d74fea", "filename": "src/test/ui/consts/const-eval/ub-incorrect-vtable.32bit.stderr", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-incorrect-vtable.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-incorrect-vtable.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-incorrect-vtable.32bit.stderr?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -2,36 +2,58 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-incorrect-vtable.rs:19:14\n    |\n LL |     unsafe { std::mem::transmute((&92u8, &[0usize, 1usize, 1000usize])) };\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid vtable: alignment `1000` is not a power of 2\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-incorrect-vtable.rs:24:14\n    |\n LL |     unsafe { std::mem::transmute((&92u8, &[1usize, usize::MAX, 1usize])) };\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid vtable: size is bigger than largest supported object\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-incorrect-vtable.rs:34:1\n+  --> $DIR/ub-incorrect-vtable.rs:33:1\n    |\n LL | const INVALID_VTABLE_ALIGNMENT_UB: W<&dyn Trait> =\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid vtable: alignment `1000` is not a power of 2\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                \u257e\u2500allocN\u2500\u257c \u257e\u2500allocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-incorrect-vtable.rs:39:1\n+  --> $DIR/ub-incorrect-vtable.rs:38:1\n    |\n LL | const INVALID_VTABLE_SIZE_UB: W<&dyn Trait> =\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid vtable: size is bigger than largest supported object\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                \u257e\u2500allocN\u2500\u257c \u257e\u2500allocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n-error: aborting due to 4 previous errors\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-incorrect-vtable.rs:44:1\n+   |\n+LL | const INVALID_VTABLE_UB: W<&dyn Trait> =\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257e\u2500allocN\u2500\u257c \u257e\u2500allocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-incorrect-vtable.rs:91:1\n+   |\n+LL | const G: Wide = unsafe { Transmute { t: FOO }.u };\n+   | ^^^^^^^^^^^^^ constructing invalid value at .1: encountered a dangling reference (going beyond the bounds of its allocation)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257e\u2500allocN\u2500\u257c \u257e\u2500allocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+           }\n+\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "bd542a7a5f2933351c4c45ee9f6dca7550402ff9", "filename": "src/test/ui/consts/const-eval/ub-incorrect-vtable.64bit.stderr", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-incorrect-vtable.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-incorrect-vtable.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-incorrect-vtable.64bit.stderr?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -2,36 +2,58 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-incorrect-vtable.rs:19:14\n    |\n LL |     unsafe { std::mem::transmute((&92u8, &[0usize, 1usize, 1000usize])) };\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid vtable: alignment `1000` is not a power of 2\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-incorrect-vtable.rs:24:14\n    |\n LL |     unsafe { std::mem::transmute((&92u8, &[1usize, usize::MAX, 1usize])) };\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid vtable: size is bigger than largest supported object\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-incorrect-vtable.rs:34:1\n+  --> $DIR/ub-incorrect-vtable.rs:33:1\n    |\n LL | const INVALID_VTABLE_ALIGNMENT_UB: W<&dyn Trait> =\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid vtable: alignment `1000` is not a power of 2\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-incorrect-vtable.rs:39:1\n+  --> $DIR/ub-incorrect-vtable.rs:38:1\n    |\n LL | const INVALID_VTABLE_SIZE_UB: W<&dyn Trait> =\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid vtable: size is bigger than largest supported object\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n-error: aborting due to 4 previous errors\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-incorrect-vtable.rs:44:1\n+   |\n+LL | const INVALID_VTABLE_UB: W<&dyn Trait> =\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-incorrect-vtable.rs:91:1\n+   |\n+LL | const G: Wide = unsafe { Transmute { t: FOO }.u };\n+   | ^^^^^^^^^^^^^ constructing invalid value at .1: encountered a dangling reference (going beyond the bounds of its allocation)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+           }\n+\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "4bb30b75bc8eb657fb6b0f21e093dbda598ed750", "filename": "src/test/ui/consts/const-eval/ub-incorrect-vtable.rs", "status": "modified", "additions": 57, "deletions": 5, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-incorrect-vtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-incorrect-vtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-incorrect-vtable.rs?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -18,27 +18,79 @@ trait Trait {}\n const INVALID_VTABLE_ALIGNMENT: &dyn Trait =\n     unsafe { std::mem::transmute((&92u8, &[0usize, 1usize, 1000usize])) };\n //~^ ERROR evaluation of constant value failed\n-//~| invalid vtable: alignment `1000` is not a power of 2\n+//~| does not point to a vtable\n \n const INVALID_VTABLE_SIZE: &dyn Trait =\n     unsafe { std::mem::transmute((&92u8, &[1usize, usize::MAX, 1usize])) };\n //~^ ERROR evaluation of constant value failed\n-//~| invalid vtable: size is bigger than largest supported object\n+//~| does not point to a vtable\n \n #[repr(transparent)]\n struct W<T>(T);\n \n-// The drop fn is checked before size/align are, so get ourselves a \"sufficiently valid\" drop fn\n fn drop_me(_: *mut usize) {}\n \n const INVALID_VTABLE_ALIGNMENT_UB: W<&dyn Trait> =\n     unsafe { std::mem::transmute((&92u8, &(drop_me as fn(*mut usize), 1usize, 1000usize))) };\n //~^^ ERROR it is undefined behavior to use this value\n-//~| invalid vtable: alignment `1000` is not a power of 2\n+//~| expected a vtable pointer\n \n const INVALID_VTABLE_SIZE_UB: W<&dyn Trait> =\n     unsafe { std::mem::transmute((&92u8, &(drop_me as fn(*mut usize), usize::MAX, 1usize))) };\n //~^^ ERROR it is undefined behavior to use this value\n-//~| invalid vtable: size is bigger than largest supported object\n+//~| expected a vtable pointer\n+\n+// Even if the vtable has a fn ptr and a reasonable size+align, it still does not work.\n+const INVALID_VTABLE_UB: W<&dyn Trait> =\n+    unsafe { std::mem::transmute((&92u8, &(drop_me as fn(*mut usize), 1usize, 1usize))) };\n+//~^^ ERROR it is undefined behavior to use this value\n+//~| expected a vtable pointer\n+\n+// Trying to access the data in a vtable does not work, either.\n+\n+#[derive(Copy, Clone)]\n+struct Wide<'a>(&'a Foo, &'static VTable);\n+\n+struct VTable {\n+    drop: Option<for<'a> fn(&'a mut Foo)>,\n+    size: usize,\n+    align: usize,\n+    bar: for<'a> fn(&'a Foo) -> u32,\n+}\n+\n+trait Bar {\n+    fn bar(&self) -> u32;\n+}\n+\n+struct Foo {\n+    foo: u32,\n+    bar: bool,\n+}\n+\n+impl Bar for Foo {\n+    fn bar(&self) -> u32 {\n+        self.foo\n+    }\n+}\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        assert!(!self.bar);\n+        self.bar = true;\n+        println!(\"dropping Foo\");\n+    }\n+}\n+\n+#[repr(C)]\n+union Transmute<T: Copy, U: Copy> {\n+    t: T,\n+    u: U,\n+}\n+\n+const FOO: &dyn Bar = &Foo { foo: 128, bar: false };\n+const G: Wide = unsafe { Transmute { t: FOO }.u };\n+//~^ ERROR it is undefined behavior to use this value\n+//~| encountered a dangling reference\n+// (it is dangling because vtables do not contain memory that can be dereferenced)\n \n fn main() {}"}, {"sha": "ae114233c0f72a5fb4c7f5a19760dc4270edc07b", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.32bit.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -125,7 +125,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:56:1\n    |\n LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null function pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n@@ -147,7 +147,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:60:1\n    |\n LL | const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0x0000000d, but expected a function pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0xd[noalloc], but expected a function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n@@ -158,7 +158,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:62:1\n    |\n LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered pointer to alloc41, but expected a function pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered alloc41, but expected a function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {"}, {"sha": "1b93a869c0dd90d64e8cf8d14960789395e3565e", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.64bit.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -125,7 +125,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:56:1\n    |\n LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a null function pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n@@ -147,7 +147,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:60:1\n    |\n LL | const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0x000000000000000d, but expected a function pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0xd[noalloc], but expected a function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n@@ -158,7 +158,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:62:1\n    |\n LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered pointer to alloc41, but expected a function pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered alloc41, but expected a function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {"}, {"sha": "f7898e55ee2c53b894dbc44b164499b0ce6a8ffc", "filename": "src/test/ui/consts/const-eval/ub-upvars.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.32bit.stderr?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -6,7 +6,7 @@ LL | const BAD_UPVAR: &dyn FnOnce() = &{\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500alloc3\u2500\u2500\u257c \u257e\u2500alloc6\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc3\u2500\u2500\u257c \u257e\u2500alloc4\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n error: aborting due to previous error"}, {"sha": "60432380e134701aa483008725815e35a1302148", "filename": "src/test/ui/consts/const-eval/ub-upvars.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.64bit.stderr?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -6,7 +6,7 @@ LL | const BAD_UPVAR: &dyn FnOnce() = &{\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc6\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error: aborting due to previous error"}, {"sha": "ee27651dca03f78f591517290c9642b15f5bf441", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.32bit.stderr", "status": "modified", "additions": 23, "deletions": 38, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -209,7 +209,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:117:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered too small vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n@@ -220,7 +220,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:120:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered too small vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n@@ -231,59 +231,44 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:123:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered dangling vtable pointer in wide pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered 0x4[noalloc], but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                \u257eallocN\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:125:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-wide-ptr.rs:125:57\n    |\n LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered unaligned vtable pointer in wide pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eallocN\u2500\u257c \u257eallocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n-           }\n+   |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:127:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-wide-ptr.rs:128:57\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid drop function pointer in vtable (not pointing to a function)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eallocN\u2500\u257c \u257eallocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n-           }\n+   |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:129:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-wide-ptr.rs:131:56\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid drop function pointer in vtable (not pointing to a function)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257eallocN\u2500\u257c \u257eallocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n-           }\n+   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:131:1\n+  --> $DIR/ub-wide-ptr.rs:134:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid drop function pointer in vtable (not pointing to a function)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                \u257eallocN\u2500\u257c \u257eallocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:135:1\n+  --> $DIR/ub-wide-ptr.rs:138:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n@@ -294,38 +279,38 @@ LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_,\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:139:1\n+  --> $DIR/ub-wide-ptr.rs:142:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered dangling vtable pointer in wide pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                \u257eallocN\u2500\u257c 00 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:141:1\n+  --> $DIR/ub-wide-ptr.rs:144:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered too small vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                \u257eallocN\u2500\u257c \u257eallocN\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:147:5\n+  --> $DIR/ub-wide-ptr.rs:150:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: null pointer is a dangling pointer (it has no provenance)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer use: null pointer is a dangling pointer (it has no provenance)\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:151:5\n+  --> $DIR/ub-wide-ptr.rs:154:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: allocN has size N, so pointer to 12 bytes starting at offset N is out-of-bounds\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error: aborting due to 32 previous errors\n "}, {"sha": "84c323e87b6c88f9128d115caa7885a227d647be", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.64bit.stderr", "status": "modified", "additions": 23, "deletions": 38, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -209,7 +209,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:117:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered too small vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n@@ -220,7 +220,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:120:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered too small vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n@@ -231,59 +231,44 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:123:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered dangling vtable pointer in wide pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered 0x4[noalloc], but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:125:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-wide-ptr.rs:125:57\n    |\n LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered unaligned vtable pointer in wide pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n+   |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:127:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-wide-ptr.rs:128:57\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid drop function pointer in vtable (not pointing to a function)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n+   |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:129:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-wide-ptr.rs:131:56\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid drop function pointer in vtable (not pointing to a function)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-           }\n+   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:131:1\n+  --> $DIR/ub-wide-ptr.rs:134:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered invalid drop function pointer in vtable (not pointing to a function)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:135:1\n+  --> $DIR/ub-wide-ptr.rs:138:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n@@ -294,38 +279,38 @@ LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_,\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:139:1\n+  --> $DIR/ub-wide-ptr.rs:142:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered dangling vtable pointer in wide pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 00 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:141:1\n+  --> $DIR/ub-wide-ptr.rs:144:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered too small vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered allocN, but expected a vtable pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:147:5\n+  --> $DIR/ub-wide-ptr.rs:150:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: null pointer is a dangling pointer (it has no provenance)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer use: null pointer is a dangling pointer (it has no provenance)\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:151:5\n+  --> $DIR/ub-wide-ptr.rs:154:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: allocN has size N, so pointer to 24 bytes starting at offset N is out-of-bounds\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error: aborting due to 32 previous errors\n "}, {"sha": "9e3d349cd7eb040b064067d53544c5fb0cf1df27", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -123,11 +123,14 @@ const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8\n const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n //~^ ERROR it is undefined behavior to use this value\n const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR evaluation of constant value failed\n+//~| does not point to a vtable\n const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR evaluation of constant value failed\n+//~| does not point to a vtable\n const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR evaluation of constant value failed\n+//~| does not point to a vtable\n const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n //~^ ERROR it is undefined behavior to use this value\n "}, {"sha": "b8798a9755fe2b1b0055568a83e52f838857d37e", "filename": "src/test/ui/consts/issue-79690.64bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fissue-79690.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fissue-79690.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-79690.64bit.stderr?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -2,11 +2,11 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/issue-79690.rs:30:1\n    |\n LL | const G: Fat = unsafe { Transmute { t: FOO }.u };\n-   | ^^^^^^^^^^^^ constructing invalid value at .1.<deref>.size.foo: encountered (potentially part of) a pointer, but expected plain (non-pointer) bytes\n+   | ^^^^^^^^^^^^ constructing invalid value at .1: encountered a dangling reference (going beyond the bounds of its allocation)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc6\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error: aborting due to previous error"}, {"sha": "7ea35f70d108eb35b8eee6f3909987557b8f721b", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_err.32bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.32bit.stderr?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -17,7 +17,7 @@ LL | const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500alloc7\u2500\u2500\u257c \u257e\u2500alloc9\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc7\u2500\u2500\u257c \u257e\u2500alloc8\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -28,7 +28,7 @@ LL | const BLUNT: &mut i32 = &mut 42;\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc11\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc10\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n warning: skipping const checks"}, {"sha": "5ad39893089090c4f4b1f1d6c5226fa1bd00db51", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_err.64bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe00573324854e5681546b660bbbaf4e1ec38eb2/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.64bit.stderr?ref=fe00573324854e5681546b660bbbaf4e1ec38eb2", "patch": "@@ -17,7 +17,7 @@ LL | const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc7\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc7\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -28,7 +28,7 @@ LL | const BLUNT: &mut i32 = &mut 42;\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc11\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc10\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n warning: skipping const checks"}]}