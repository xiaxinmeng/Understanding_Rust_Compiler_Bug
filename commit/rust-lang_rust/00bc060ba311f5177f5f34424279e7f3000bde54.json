{"sha": "00bc060ba311f5177f5f34424279e7f3000bde54", "node_id": "C_kwDOAAsO6NoAKDAwYmMwNjBiYTMxMWY1MTc3ZjVmMzQ0MjQyNzllN2YzMDAwYmRlNTQ", "commit": {"author": {"name": "Amos Wenger", "email": "amoswenger@gmail.com", "date": "2022-07-20T16:36:10Z"}, "committer": {"name": "Amos Wenger", "email": "amoswenger@gmail.com", "date": "2022-07-20T17:18:39Z"}, "message": "Fix imports, delete removed interfaces", "tree": {"sha": "e00b9f72aa65443eac2d7caac7d60a887a08cc98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e00b9f72aa65443eac2d7caac7d60a887a08cc98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00bc060ba311f5177f5f34424279e7f3000bde54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00bc060ba311f5177f5f34424279e7f3000bde54", "html_url": "https://github.com/rust-lang/rust/commit/00bc060ba311f5177f5f34424279e7f3000bde54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00bc060ba311f5177f5f34424279e7f3000bde54/comments", "author": {"login": "fasterthanlime", "id": 7998310, "node_id": "MDQ6VXNlcjc5OTgzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/7998310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fasterthanlime", "html_url": "https://github.com/fasterthanlime", "followers_url": "https://api.github.com/users/fasterthanlime/followers", "following_url": "https://api.github.com/users/fasterthanlime/following{/other_user}", "gists_url": "https://api.github.com/users/fasterthanlime/gists{/gist_id}", "starred_url": "https://api.github.com/users/fasterthanlime/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fasterthanlime/subscriptions", "organizations_url": "https://api.github.com/users/fasterthanlime/orgs", "repos_url": "https://api.github.com/users/fasterthanlime/repos", "events_url": "https://api.github.com/users/fasterthanlime/events{/privacy}", "received_events_url": "https://api.github.com/users/fasterthanlime/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fasterthanlime", "id": 7998310, "node_id": "MDQ6VXNlcjc5OTgzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/7998310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fasterthanlime", "html_url": "https://github.com/fasterthanlime", "followers_url": "https://api.github.com/users/fasterthanlime/followers", "following_url": "https://api.github.com/users/fasterthanlime/following{/other_user}", "gists_url": "https://api.github.com/users/fasterthanlime/gists{/gist_id}", "starred_url": "https://api.github.com/users/fasterthanlime/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fasterthanlime/subscriptions", "organizations_url": "https://api.github.com/users/fasterthanlime/orgs", "repos_url": "https://api.github.com/users/fasterthanlime/repos", "events_url": "https://api.github.com/users/fasterthanlime/events{/privacy}", "received_events_url": "https://api.github.com/users/fasterthanlime/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e009cdc8d9f155e2a5e99202a433b426f0ac2ee4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e009cdc8d9f155e2a5e99202a433b426f0ac2ee4", "html_url": "https://github.com/rust-lang/rust/commit/e009cdc8d9f155e2a5e99202a433b426f0ac2ee4"}], "stats": {"total": 256, "additions": 66, "deletions": 190}, "files": [{"sha": "9265cd6b6b79ec4a4fefc479bbcc593e0b41e7b5", "filename": "crates/proc-macro-srv/src/abis/abi_sysroot/ra_server.rs", "status": "modified", "additions": 32, "deletions": 190, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/00bc060ba311f5177f5f34424279e7f3000bde54/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00bc060ba311f5177f5f34424279e7f3000bde54/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server.rs?ref=00bc060ba311f5177f5f34424279e7f3000bde54", "patch": "@@ -8,16 +8,18 @@\n //!\n //! FIXME: No span and source file information is implemented yet\n \n-use super::proc_macro::bridge::{self, server};\n+use super::proc_macro::{\n+    self,\n+    bridge::{self, server},\n+};\n \n mod token_stream;\n pub use token_stream::*;\n \n-use std::ascii;\n-use std::collections::HashMap;\n-use std::hash::Hash;\n+mod symbol;\n+pub use symbol::*;\n+\n use std::iter::FromIterator;\n-use std::ops::Bound;\n \n type Group = tt::Subtree;\n type TokenTree = tt::TokenTree;\n@@ -51,42 +53,6 @@ impl Diagnostic {\n     }\n }\n \n-// Rustc Server Ident has to be `Copyable`\n-// We use a stub here for bypassing\n-#[derive(Hash, Eq, PartialEq, Copy, Clone)]\n-pub struct IdentId(u32);\n-\n-#[derive(Clone, Hash, Eq, PartialEq)]\n-struct IdentData(tt::Ident);\n-\n-#[derive(Default)]\n-struct IdentInterner {\n-    idents: HashMap<IdentData, u32>,\n-    ident_data: Vec<IdentData>,\n-}\n-\n-impl IdentInterner {\n-    fn intern(&mut self, data: &IdentData) -> u32 {\n-        if let Some(index) = self.idents.get(data) {\n-            return *index;\n-        }\n-\n-        let index = self.idents.len() as u32;\n-        self.ident_data.push(data.clone());\n-        self.idents.insert(data.clone(), index);\n-        index\n-    }\n-\n-    fn get(&self, index: u32) -> &IdentData {\n-        &self.ident_data[index as usize]\n-    }\n-\n-    #[allow(unused)]\n-    fn get_mut(&mut self, index: u32) -> &mut IdentData {\n-        self.ident_data.get_mut(index as usize).expect(\"Should be consistent\")\n-    }\n-}\n-\n pub struct FreeFunctions;\n \n #[derive(Default)]\n@@ -141,12 +107,13 @@ impl server::TokenStream for RustAnalyzer {\n                 Self::TokenStream::from_iter(vec![tree])\n             }\n \n-            bridge::TokenTree::Ident(IdentId(index)) => {\n-                let IdentData(ident) = self.ident_interner.get(index).clone();\n-                let ident: tt::Ident = ident;\n-                let leaf = tt::Leaf::from(ident);\n-                let tree = TokenTree::from(leaf);\n-                Self::TokenStream::from_iter(vec![tree])\n+            bridge::TokenTree::Ident(symbol) => {\n+                todo!(\"implement\");\n+                // let IdentData(ident) = self.ident_interner.get(index).clone();\n+                // let ident: tt::Ident = ident;\n+                // let leaf = tt::Leaf::from(ident);\n+                // let tree = TokenTree::from(leaf);\n+                // Self::TokenStream::from_iter(vec![tree])\n             }\n \n             bridge::TokenTree::Literal(literal) => {\n@@ -210,7 +177,8 @@ impl server::TokenStream for RustAnalyzer {\n             .into_iter()\n             .map(|tree| match tree {\n                 tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n-                    bridge::TokenTree::Ident(IdentId(self.ident_interner.intern(&IdentData(ident))))\n+                    todo!(\"implement\");\n+                    // bridge::TokenTree::Ident(Symbol(self.ident_interner.intern(&IdentData(ident))))\n                 }\n                 tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) => bridge::TokenTree::Literal(lit),\n                 tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) => {\n@@ -236,162 +204,36 @@ impl server::TokenStream for RustAnalyzer {\n     }\n }\n \n-fn delim_to_internal(d: bridge::Delimiter) -> Option<tt::Delimiter> {\n+fn delim_to_internal(d: proc_macro::Delimiter) -> Option<tt::Delimiter> {\n     let kind = match d {\n-        bridge::Delimiter::Parenthesis => tt::DelimiterKind::Parenthesis,\n-        bridge::Delimiter::Brace => tt::DelimiterKind::Brace,\n-        bridge::Delimiter::Bracket => tt::DelimiterKind::Bracket,\n-        bridge::Delimiter::None => return None,\n+        proc_macro::Delimiter::Parenthesis => tt::DelimiterKind::Parenthesis,\n+        proc_macro::Delimiter::Brace => tt::DelimiterKind::Brace,\n+        proc_macro::Delimiter::Bracket => tt::DelimiterKind::Bracket,\n+        proc_macro::Delimiter::None => return None,\n     };\n     Some(tt::Delimiter { id: tt::TokenId::unspecified(), kind })\n }\n \n-fn delim_to_external(d: Option<tt::Delimiter>) -> bridge::Delimiter {\n+fn delim_to_external(d: Option<tt::Delimiter>) -> proc_macro::Delimiter {\n     match d.map(|it| it.kind) {\n-        Some(tt::DelimiterKind::Parenthesis) => bridge::Delimiter::Parenthesis,\n-        Some(tt::DelimiterKind::Brace) => bridge::Delimiter::Brace,\n-        Some(tt::DelimiterKind::Bracket) => bridge::Delimiter::Bracket,\n-        None => bridge::Delimiter::None,\n+        Some(tt::DelimiterKind::Parenthesis) => proc_macro::Delimiter::Parenthesis,\n+        Some(tt::DelimiterKind::Brace) => proc_macro::Delimiter::Brace,\n+        Some(tt::DelimiterKind::Bracket) => proc_macro::Delimiter::Bracket,\n+        None => proc_macro::Delimiter::None,\n     }\n }\n \n-fn spacing_to_internal(spacing: bridge::Spacing) -> Spacing {\n+fn spacing_to_internal(spacing: proc_macro::Spacing) -> Spacing {\n     match spacing {\n-        bridge::Spacing::Alone => Spacing::Alone,\n-        bridge::Spacing::Joint => Spacing::Joint,\n+        proc_macro::Spacing::Alone => Spacing::Alone,\n+        proc_macro::Spacing::Joint => Spacing::Joint,\n     }\n }\n \n-fn spacing_to_external(spacing: Spacing) -> bridge::Spacing {\n+fn spacing_to_external(spacing: Spacing) -> proc_macro::Spacing {\n     match spacing {\n-        Spacing::Alone => bridge::Spacing::Alone,\n-        Spacing::Joint => bridge::Spacing::Joint,\n-    }\n-}\n-\n-impl server::Ident for RustAnalyzer {\n-    fn new(&mut self, string: &str, span: Self::Span, _is_raw: bool) -> Self::Ident {\n-        IdentId(self.ident_interner.intern(&IdentData(tt::Ident { text: string.into(), id: span })))\n-    }\n-\n-    fn span(&mut self, ident: Self::Ident) -> Self::Span {\n-        self.ident_interner.get(ident.0).0.id\n-    }\n-    fn with_span(&mut self, ident: Self::Ident, span: Self::Span) -> Self::Ident {\n-        let data = self.ident_interner.get(ident.0);\n-        let new = IdentData(tt::Ident { id: span, ..data.0.clone() });\n-        IdentId(self.ident_interner.intern(&new))\n-    }\n-}\n-\n-impl server::Literal for RustAnalyzer {\n-    fn debug_kind(&mut self, _literal: &Self::Literal) -> String {\n-        // r-a: debug_kind and suffix are unsupported; corresponding client code has been changed to not call these.\n-        // They must still be present to be ABI-compatible and work with upstream proc_macro.\n-        \"\".to_owned()\n-    }\n-    fn from_str(&mut self, s: &str) -> Result<Self::Literal, ()> {\n-        Ok(Literal { text: s.into(), id: tt::TokenId::unspecified() })\n-    }\n-    fn symbol(&mut self, literal: &Self::Literal) -> String {\n-        literal.text.to_string()\n-    }\n-    fn suffix(&mut self, _literal: &Self::Literal) -> Option<String> {\n-        None\n-    }\n-\n-    fn to_string(&mut self, literal: &Self::Literal) -> String {\n-        literal.to_string()\n-    }\n-\n-    fn integer(&mut self, n: &str) -> Self::Literal {\n-        let n = match n.parse::<i128>() {\n-            Ok(n) => n.to_string(),\n-            Err(_) => n.parse::<u128>().unwrap().to_string(),\n-        };\n-        Literal { text: n.into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn typed_integer(&mut self, n: &str, kind: &str) -> Self::Literal {\n-        macro_rules! def_suffixed_integer {\n-            ($kind:ident, $($ty:ty),*) => {\n-                match $kind {\n-                    $(\n-                        stringify!($ty) => {\n-                            let n: $ty = n.parse().unwrap();\n-                            format!(concat!(\"{}\", stringify!($ty)), n)\n-                        }\n-                    )*\n-                    _ => unimplemented!(\"unknown args for typed_integer: n {}, kind {}\", n, $kind),\n-                }\n-            }\n-        }\n-\n-        let text = def_suffixed_integer! {kind, u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize};\n-\n-        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn float(&mut self, n: &str) -> Self::Literal {\n-        let n: f64 = n.parse().unwrap();\n-        let mut text = f64::to_string(&n);\n-        if !text.contains('.') {\n-            text += \".0\"\n-        }\n-        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn f32(&mut self, n: &str) -> Self::Literal {\n-        let n: f32 = n.parse().unwrap();\n-        let text = format!(\"{}f32\", n);\n-        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn f64(&mut self, n: &str) -> Self::Literal {\n-        let n: f64 = n.parse().unwrap();\n-        let text = format!(\"{}f64\", n);\n-        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn string(&mut self, string: &str) -> Self::Literal {\n-        let mut escaped = String::new();\n-        for ch in string.chars() {\n-            escaped.extend(ch.escape_debug());\n-        }\n-        Literal { text: format!(\"\\\"{}\\\"\", escaped).into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn character(&mut self, ch: char) -> Self::Literal {\n-        Literal { text: format!(\"'{}'\", ch).into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn byte_string(&mut self, bytes: &[u8]) -> Self::Literal {\n-        let string = bytes\n-            .iter()\n-            .cloned()\n-            .flat_map(ascii::escape_default)\n-            .map(Into::<char>::into)\n-            .collect::<String>();\n-\n-        Literal { text: format!(\"b\\\"{}\\\"\", string).into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn span(&mut self, literal: &Self::Literal) -> Self::Span {\n-        literal.id\n-    }\n-\n-    fn set_span(&mut self, literal: &mut Self::Literal, span: Self::Span) {\n-        literal.id = span;\n-    }\n-\n-    fn subspan(\n-        &mut self,\n-        _literal: &Self::Literal,\n-        _start: Bound<usize>,\n-        _end: Bound<usize>,\n-    ) -> Option<Self::Span> {\n-        // FIXME handle span\n-        None\n+        Spacing::Alone => proc_macro::Spacing::Alone,\n+        Spacing::Joint => proc_macro::Spacing::Joint,\n     }\n }\n "}, {"sha": "b97e2aecf331509c7d6c11d322a402c502072f4f", "filename": "crates/proc-macro-srv/src/abis/abi_sysroot/ra_server/symbol.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/00bc060ba311f5177f5f34424279e7f3000bde54/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00bc060ba311f5177f5f34424279e7f3000bde54/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server%2Fsymbol.rs?ref=00bc060ba311f5177f5f34424279e7f3000bde54", "patch": "@@ -0,0 +1,34 @@\n+use std::collections::HashMap;\n+use tt::SmolStr;\n+\n+// Identifier for an interned symbol.\n+#[derive(Hash, Eq, PartialEq, Copy, Clone)]\n+pub struct Symbol(u32);\n+\n+#[derive(Default)]\n+struct IdentInterner {\n+    idents: HashMap<SmolStr, u32>,\n+    ident_data: Vec<SmolStr>,\n+}\n+\n+impl IdentInterner {\n+    fn intern(&mut self, data: &str) -> Symbol {\n+        if let Some(index) = self.idents.get(data) {\n+            return *index;\n+        }\n+\n+        let index = self.idents.len() as u32;\n+        self.ident_data.push(data.clone());\n+        self.idents.insert(data.clone(), index);\n+        index\n+    }\n+\n+    fn get(&self, index: u32) -> &SmolStr {\n+        &self.ident_data[index as usize]\n+    }\n+\n+    #[allow(unused)]\n+    fn get_mut(&mut self, index: u32) -> &mut SmolStr {\n+        self.ident_data.get_mut(index as usize).expect(\"Should be consistent\")\n+    }\n+}"}]}