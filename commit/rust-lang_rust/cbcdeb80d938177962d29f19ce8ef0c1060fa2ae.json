{"sha": "cbcdeb80d938177962d29f19ce8ef0c1060fa2ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiY2RlYjgwZDkzODE3Nzk2MmQyOWYxOWNlOGVmMGMxMDYwZmEyYWU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-11-16T04:07:06Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-11-16T23:27:08Z"}, "message": "remove wrappers from intrinsics", "tree": {"sha": "aa48c535d14eaf1b973fe3bf146a0c945279ba2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa48c535d14eaf1b973fe3bf146a0c945279ba2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbcdeb80d938177962d29f19ce8ef0c1060fa2ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbcdeb80d938177962d29f19ce8ef0c1060fa2ae", "html_url": "https://github.com/rust-lang/rust/commit/cbcdeb80d938177962d29f19ce8ef0c1060fa2ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbcdeb80d938177962d29f19ce8ef0c1060fa2ae/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23bb158acbb8af412371455c7493c8546c7afafd", "url": "https://api.github.com/repos/rust-lang/rust/commits/23bb158acbb8af412371455c7493c8546c7afafd", "html_url": "https://github.com/rust-lang/rust/commit/23bb158acbb8af412371455c7493c8546c7afafd"}], "stats": {"total": 636, "additions": 335, "deletions": 301}, "files": [{"sha": "5069e75815d9724eef2e74c53576d6a57e51aed8", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 9, "deletions": 141, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/cbcdeb80d938177962d29f19ce8ef0c1060fa2ae/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcdeb80d938177962d29f19ce8ef0c1060fa2ae/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=cbcdeb80d938177962d29f19ce8ef0c1060fa2ae", "patch": "@@ -5723,21 +5723,20 @@ fn raw_native_fn_type(ccx: @crate_ctxt, sp: span, args: [ty::arg],\n     ret T_fn(type_of_explicit_args(ccx, sp, args), type_of(ccx, sp, ret_ty));\n }\n \n-fn register_native_fn(ccx: @crate_ctxt, sp: span, path: [str], name: str,\n-                           id: ast::node_id) {\n+fn register_native_fn(ccx: @crate_ctxt, sp: span, _path: [str], name: str,\n+                      id: ast::node_id) {\n     let fn_type = node_id_type(ccx, id); // NB: has no type params\n     let abi = ty::ty_fn_abi(ccx.tcx, fn_type);\n \n-    // FIXME: There's probably a lot of unused code here now that\n-    // there's only one possible combination of these three options\n-    let pass_task;\n-    let uses_retptr;\n-    let cast_to_i32;\n     alt abi {\n       ast::native_abi_rust_intrinsic. {\n-        pass_task = true;\n-        uses_retptr = true;\n-        cast_to_i32 = false;\n+        let num_ty_param = native_fn_ty_param_count(ccx, id);\n+        let fn_type = native_fn_wrapper_type(ccx, sp, num_ty_param, fn_type);\n+        let ri_name = \"rust_intrinsic_2_\" + name;\n+        let llnativefn = get_extern_fn(ccx.externs, ccx.llmod, ri_name,\n+                                       lib::llvm::LLVMCCallConv, fn_type);\n+        ccx.item_ids.insert(id, llnativefn);\n+        ccx.item_symbols.insert(id, ri_name);\n       }\n \n       ast::native_abi_cdecl. | ast::native_abi_stdcall. {\n@@ -5747,140 +5746,9 @@ fn register_native_fn(ccx: @crate_ctxt, sp: span, path: [str], name: str,\n             ccx.llmod, shim_name, tys.shim_fn_ty);\n         ccx.item_ids.insert(id, llshimfn);\n         ccx.item_symbols.insert(id, shim_name);\n-        ret;\n       }\n     }\n \n-    let path = path;\n-    let num_ty_param = native_fn_ty_param_count(ccx, id);\n-    // Declare the wrapper.\n-\n-    let t = node_id_type(ccx, id);\n-    let wrapper_type = native_fn_wrapper_type(ccx, sp, num_ty_param, t);\n-    let ps: str = mangle_exported_name(ccx, path, node_id_type(ccx, id));\n-    let wrapper_fn = decl_cdecl_fn(ccx.llmod, ps, wrapper_type);\n-    ccx.item_ids.insert(id, wrapper_fn);\n-    ccx.item_symbols.insert(id, ps);\n-\n-    // Build the wrapper.\n-    let fcx = new_fn_ctxt(new_local_ctxt(ccx), sp, wrapper_fn);\n-    let bcx = new_top_block_ctxt(fcx);\n-    let lltop = bcx.llbb;\n-\n-    // Declare the function itself.\n-    // FIXME: If the returned type is not nil, then we assume it's 32 bits\n-    // wide. This is obviously wildly unsafe. We should have a better FFI\n-    // that allows types of different sizes to be returned.\n-\n-    let rty = ty::ty_fn_ret(ccx.tcx, fn_type);\n-    let rty_is_nil = ty::type_is_nil(ccx.tcx, rty);\n-\n-    let call_args: [ValueRef] = [];\n-    if pass_task { call_args += [C_null(T_ptr(ccx.task_type))]; }\n-    if uses_retptr { call_args += [bcx.fcx.llretptr]; }\n-\n-    let arg_n = 2u;\n-    uint::range(0u, num_ty_param) {|_i|\n-        let llarg = llvm::LLVMGetParam(fcx.llfn, arg_n);\n-        fcx.lltydescs += [llarg];\n-        assert (llarg as int != 0);\n-        if cast_to_i32 {\n-            call_args += [vp2i(bcx, llarg)];\n-        } else { call_args += [llarg]; }\n-        arg_n += 1u;\n-    };\n-    fn convert_arg_to_i32(cx: @block_ctxt, v: ValueRef, t: ty::t,\n-                          mode: ty::mode) -> ValueRef {\n-        if mode == ast::by_ref || mode == ast::by_val {\n-            let ccx = bcx_ccx(cx);\n-            if ty::type_is_integral(bcx_tcx(cx), t) {\n-                // FIXME: would be nice to have a postcondition that says\n-                // if a type is integral, then it has static size (#586)\n-                let lldsttype = ccx.int_type;\n-                let sp = cx.sp;\n-                check (type_has_static_size(ccx, t));\n-                let llsrctype = type_of(ccx, sp, t);\n-                if llvm::LLVMGetIntTypeWidth(lldsttype) >\n-                       llvm::LLVMGetIntTypeWidth(llsrctype) {\n-                    ret ZExtOrBitCast(cx, v, ccx.int_type);\n-                }\n-                ret TruncOrBitCast(cx, v, ccx.int_type);\n-            }\n-            if ty::type_is_fp(bcx_tcx(cx), t) {\n-                ret FPToSI(cx, v, ccx.int_type);\n-            }\n-        }\n-        ret vp2i(cx, v);\n-    }\n-\n-    fn trans_simple_native_abi(bcx: @block_ctxt, name: str,\n-                               &call_args: [ValueRef], fn_type: ty::t,\n-                               uses_retptr: bool, cc: uint) ->\n-       {val: ValueRef, rptr: ValueRef} {\n-        let call_arg_tys: [TypeRef] = [];\n-        for arg: ValueRef in call_args { call_arg_tys += [val_ty(arg)]; }\n-        let ccx = bcx_ccx(bcx);\n-\n-        let llnativefnty =\n-            if uses_retptr {\n-                T_fn(call_arg_tys, T_void())\n-            } else {\n-                let fn_ret_ty = ty::ty_fn_ret(bcx_tcx(bcx), fn_type);\n-                // FIXME: Could follow from a constraint on fn_type...\n-                check (type_has_static_size(ccx, fn_ret_ty));\n-                let sp = bcx.sp;\n-                T_fn(call_arg_tys, type_of(ccx, sp, fn_ret_ty))\n-            };\n-\n-        let llnativefn =\n-            get_extern_fn(ccx.externs, ccx.llmod, name, cc, llnativefnty);\n-        let r =\n-            if cc == lib::llvm::LLVMCCallConv {\n-                Call(bcx, llnativefn, call_args)\n-            } else { CallWithConv(bcx, llnativefn, call_args, cc) };\n-        let rptr = bcx.fcx.llretptr;\n-        ret {val: r, rptr: rptr};\n-    }\n-\n-    let args = ty::ty_fn_args(ccx.tcx, fn_type);\n-    // Build up the list of arguments.\n-\n-    let i = arg_n;\n-    for arg: ty::arg in args {\n-        let llarg = llvm::LLVMGetParam(fcx.llfn, i);\n-        assert (llarg as int != 0);\n-        if cast_to_i32 {\n-            let llarg_i32 = convert_arg_to_i32(bcx, llarg, arg.ty, arg.mode);\n-            call_args += [llarg_i32];\n-        } else { call_args += [llarg]; }\n-        i += 1u;\n-    }\n-    let r;\n-    let rptr;\n-    alt abi {\n-      ast::native_abi_rust_intrinsic. {\n-        let external_name = \"rust_intrinsic_\" + name;\n-        let result =\n-            trans_simple_native_abi(bcx, external_name, call_args, fn_type,\n-                                    uses_retptr, lib::llvm::LLVMCCallConv);\n-        r = result.val;\n-        rptr = result.rptr;\n-      }\n-      _ {\n-        r =\n-            trans_native_call(new_raw_block_ctxt(bcx.fcx, bcx.llbb),\n-                              ccx.externs, ccx.llmod, name, call_args);\n-        rptr = BitCast(bcx, fcx.llretptr, T_ptr(ccx.int_type));\n-      }\n-    }\n-    // We don't store the return value if it's nil, to avoid stomping on a nil\n-    // pointer. This is the only concession made to non-i32 return values. See\n-    // the FIXME above.\n-\n-    if !rty_is_nil && !uses_retptr { Store(bcx, r, rptr); }\n-\n-    build_return(bcx);\n-    finish_fn(fcx, lltop);\n }\n \n fn item_path(item: @ast::item) -> [str] { ret [item.ident]; }"}, {"sha": "dd08fd852163946c5ccabfa7c3d004bd72649fff", "filename": "src/rt/intrinsics/intrinsics.cpp", "status": "modified", "additions": 86, "deletions": 12, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/cbcdeb80d938177962d29f19ce8ef0c1060fa2ae/src%2Frt%2Fintrinsics%2Fintrinsics.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/cbcdeb80d938177962d29f19ce8ef0c1060fa2ae/src%2Frt%2Fintrinsics%2Fintrinsics.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.cpp?ref=cbcdeb80d938177962d29f19ce8ef0c1060fa2ae", "patch": "@@ -16,22 +16,30 @@ extern \"C\" CDECL void\n rust_task_sleep(size_t time_in_us);\n \n extern \"C\" void\n-rust_intrinsic_vec_len(rust_task *task, size_t *retptr, type_desc *ty,\n-                       rust_vec **vp)\n+rust_intrinsic_2_vec_len(size_t *retptr,\n+                         void *env,\n+                         type_desc *ty,\n+                         rust_vec **vp)\n {\n     *retptr = (*vp)->fill / ty->size;\n }\n \n extern \"C\" void\n-rust_intrinsic_ptr_offset(rust_task *task, void **retptr, type_desc *ty,\n-                          void *ptr, uintptr_t count)\n+rust_intrinsic_2_ptr_offset(void **retptr,\n+                          void *env,\n+                          type_desc *ty,\n+                          void *ptr,\n+                          uintptr_t count)\n {\n     *retptr = &((uint8_t *)ptr)[ty->size * count];\n }\n \n extern \"C\" void\n-rust_intrinsic_cast(rust_task *task, void *retptr, type_desc *t1,\n-                    type_desc *t2, void *src)\n+rust_intrinsic_2_cast(void *retptr,\n+                    void *env,\n+                    type_desc *t1,\n+                    type_desc *t2,\n+                    void *src)\n {\n     if (t1->size != t2->size) {\n         upcall_fail(\"attempt to cast values of differing sizes\",\n@@ -43,25 +51,91 @@ rust_intrinsic_cast(rust_task *task, void *retptr, type_desc *t1,\n }\n \n extern \"C\" void\n-rust_intrinsic_addr_of(rust_task *task, void **retptr, type_desc *ty,\n+rust_intrinsic_2_addr_of(void **retptr,\n+                       void *env,\n+                       type_desc *ty,\n                        void *valptr) {\n     *retptr = valptr;\n }\n \n extern \"C\" void\n-rust_intrinsic_recv(rust_task *task, void **retptr, type_desc *ty,\n+rust_intrinsic_2_recv(void **retptr,\n+                    void *env,\n+                    type_desc *ty,\n                     rust_port *port) {\n     port_recv((uintptr_t*)retptr, port);\n }\n \n extern \"C\" void\n-rust_intrinsic_get_type_desc(rust_task *task, void **retptr,\n+rust_intrinsic_2_get_type_desc(void **retptr,\n+                             void *env,\n                              type_desc* ty) {\n     *(type_desc**)retptr = ty;\n }\n \n extern \"C\" void\n-rust_intrinsic_task_sleep(rust_task *_task, void **retptr,\n-\t\t\t  size_t time_in_us) {\n-  rust_task_sleep(time_in_us);\n+rust_intrinsic_2_task_sleep(void **retptr,\n+                          void *env,\n+                          size_t time_in_us) {\n+    rust_task_sleep(time_in_us);\n+}\n+\n+extern \"C\" void\n+rust_intrinsic_vec_len(void *task,\n+                       size_t *retptr,\n+                       type_desc *ty,\n+                       rust_vec **vp)\n+{\n+    rust_intrinsic_2_vec_len(retptr, NULL, ty, vp);\n+}\n+\n+extern \"C\" void\n+rust_intrinsic_ptr_offset(void *task,\n+                          void **retptr,\n+                          type_desc *ty,\n+                          void *ptr,\n+                          uintptr_t count)\n+{\n+    rust_intrinsic_2_ptr_offset(retptr, NULL, ty, ptr, count);\n+}\n+\n+extern \"C\" void\n+rust_intrinsic_cast(void *task,\n+                    void *retptr,\n+                    type_desc *t1,\n+                    type_desc *t2,\n+                    void *src)\n+{\n+    rust_intrinsic_2_cast(retptr, NULL, t1, t2, src);\n+}\n+\n+extern \"C\" void\n+rust_intrinsic_addr_of(void *task,\n+                       void **retptr,\n+                       type_desc *ty,\n+                       void *valptr) {\n+    rust_intrinsic_2_addr_of(retptr, NULL, ty, valptr);\n+}\n+\n+extern \"C\" void\n+rust_intrinsic_recv(void *task,\n+                    void **retptr,\n+                    type_desc *ty,\n+                    rust_port *port) {\n+    rust_intrinsic_2_recv(retptr, NULL, ty, port);\n }\n+\n+extern \"C\" void\n+rust_intrinsic_get_type_desc(void *task,\n+                             void **retptr,\n+                             type_desc* ty) {\n+    rust_intrinsic_2_get_type_desc(retptr, NULL, ty);\n+}\n+\n+extern \"C\" void\n+rust_intrinsic_task_sleep(void *task,\n+                          void **retptr,\n+                          size_t time_in_us) {\n+    rust_task_sleep(time_in_us);\n+}\n+"}, {"sha": "a45c6b1ff6b8f18ad0aa06c8d974c3e8accb64a3", "filename": "src/rt/intrinsics/intrinsics.i386.ll.in", "status": "modified", "additions": 120, "deletions": 74, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/cbcdeb80d938177962d29f19ce8ef0c1060fa2ae/src%2Frt%2Fintrinsics%2Fintrinsics.i386.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/cbcdeb80d938177962d29f19ce8ef0c1060fa2ae/src%2Frt%2Fintrinsics%2Fintrinsics.i386.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.i386.ll.in?ref=cbcdeb80d938177962d29f19ce8ef0c1060fa2ae", "patch": "@@ -1,99 +1,88 @@\n ; ModuleID = 'src/rt/intrinsics/intrinsics.cpp'\n-; target datalayout = \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:32:32-n8:16:32-S128\"\n+; target datalayout = \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:128:128-n8:16:32\"\n target triple = \"@CFG_TARGET_TRIPLE@\"\n \n-%struct.rust_task = type { %struct.rust_task_user, i32, %class.context, %struct.stk_seg*, i32, %struct.rust_scheduler*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i32, %class.timer, i32*, %class.array_list.1, i32, i32, %class.memory_region, %\"class.rust_task::wakeup_callback\"*, i8, i8, i8, %class.lock_and_signal, %class.hash_map.4, %class.rust_obstack, %\"class.std::map\", i32, %\"class.debug::task_debug_info\" }\n-%struct.rust_task_user = type { i32, i32, %struct.chan_handle, i32 }\n-%struct.chan_handle = type { i32, i32 }\n+%0 = type { i32, %\"struct.memory_region::alloc_header\"**, i32 }\n+%1 = type { i32, %struct.rust_scheduler**, i32 }\n+%2 = type { %\"struct.hash_map<long, rust_task *>::map_entry\"* }\n+%class.array_list = type { i32, %struct.rust_task**, i32 }\n+%class.circular_buffer = type { %class.rust_kernel*, i32, i32, i32, i32, i8* }\n %class.context = type { %struct.registers_t, %class.context* }\n-%struct.registers_t = type { i32, i32, i32, i32, i32, i32, i32, i32, i16, i16, i16, i16, i16, i16, i32, i32 }\n-%struct.stk_seg = type { %struct.stk_seg*, i32, i32, i32, [0 x i8] }\n-%struct.rust_scheduler = type { %class.rust_thread, i32, i32, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, i32, i32, %class.lock_and_signal, i32, %union.pthread_attr_t, %struct.rust_env*, %class.context }\n-%class.rust_thread = type { i32 (...)**, i8, i32 }\n+%\"class.debug::task_debug_info\" = type { %\"class.std::map\" }\n+%class.hash_map = type { %\"struct.hash_map<long, rust_port *>::map_entry\"* }\n+%class.indexed_list = type { i32 (...)**, %class.array_list }\n+%class.lock_and_signal = type { i32 (...)**, %struct._opaque_pthread_cond_t, %struct._opaque_pthread_mutex_t, %struct._opaque_pthread_t*, i8, i8 }\n+%class.memory_region = type { i32 (...)**, %class.rust_srv*, %class.memory_region*, i32, %0, i8, i8, %class.lock_and_signal }\n+%class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_scheduler*, i32 }\n+%class.rust_kernel = type { i32 (...)**, %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, %1, %struct.randctx, i32, %2, i32, i32, i32, %struct.rust_env* }\n %class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_scheduler*, i8 }\n+%class.rust_obstack = type { %struct.rust_obstack_chunk*, %struct.rust_task* }\n+%class.rust_port = type { i32, i32, %class.rust_kernel*, %struct.rust_task*, i32, %class.circular_buffer, %class.lock_and_signal }\n %class.rust_srv = type { i32 (...)**, %struct.rust_env*, %class.memory_region }\n-%struct.rust_env = type { i32, i32, i8*, i8, i8, i8* }\n-%class.memory_region = type { i32 (...)**, %class.rust_srv*, %class.memory_region*, i32, %class.array_list, i8, i8, %class.lock_and_signal }\n-%class.array_list = type { i32, %\"struct.memory_region::alloc_header\"**, i32 }\n-%\"struct.memory_region::alloc_header\" = type { i32, i32, i8*, i32, [0 x i8] }\n-%class.lock_and_signal = type { i32 (...)**, %union.pthread_cond_t, %union.pthread_mutex_t, i32, i8, i8 }\n-%union.pthread_cond_t = type { %struct.anon, [4 x i8] }\n-%struct.anon = type { i32, i32, i64, i64, i64, i8*, i32, i32 }\n-%union.pthread_mutex_t = type { %\"struct.<anonymous union>::__pthread_mutex_s\" }\n-%\"struct.<anonymous union>::__pthread_mutex_s\" = type { i32, i32, i32, i32, i32, %union.anon }\n-%union.anon = type { i32 }\n+%\"class.rust_task::wakeup_callback\" = type { i32 (...)** }\n %class.rust_task_list = type { %class.indexed_list, %struct.rust_scheduler*, i8* }\n-%class.indexed_list = type { i32 (...)**, %class.array_list.1 }\n-%class.array_list.1 = type { i32, %struct.rust_task**, i32 }\n-%class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_scheduler*, i32 }\n-%struct.type_desc = type { %struct.type_desc**, i32, i32, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i8*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i32, void (i8*, i8*, %struct.type_desc**, i8*, i8*, i8)*, i8*, %struct.rust_shape_tables*, i32, i32, %struct.UT_hash_handle, i32, [0 x %struct.type_desc*] }\n-%struct.rust_shape_tables = type { i8*, i8* }\n+%class.rust_thread = type { i32 (...)**, i8, %struct._opaque_pthread_t* }\n+%\"class.std::_Rb_tree\" = type { %\"struct.std::_Rb_tree<void *, std::pair<void *const, const type_desc *>, std::_Select1st<std::pair<void *const, const type_desc *> >, std::less<void *>, std::allocator<std::pair<void *const, const type_desc *> > >::_Rb_tree_impl\" }\n+%\"class.std::map\" = type { %\"class.std::_Rb_tree\" }\n+%class.timer = type { i32 (...)**, i64, i64 }\n+%struct.UT_hash_bucket = type { %struct.UT_hash_handle*, i32, i32 }\n %struct.UT_hash_handle = type { %struct.UT_hash_table*, i8*, i8*, %struct.UT_hash_handle*, %struct.UT_hash_handle*, i8*, i32, i32 }\n %struct.UT_hash_table = type { %struct.UT_hash_bucket*, i32, i32, i32, %struct.UT_hash_handle*, i32, i32, i32, i32, i32 }\n-%struct.UT_hash_bucket = type { %struct.UT_hash_handle*, i32, i32 }\n+%struct.__darwin_pthread_handler_rec = type { void (i8*)*, i8*, %struct.__darwin_pthread_handler_rec* }\n+%struct._opaque_pthread_attr_t = type { i32, [36 x i8] }\n+%struct._opaque_pthread_cond_t = type { i32, [24 x i8] }\n+%struct._opaque_pthread_mutex_t = type { i32, [40 x i8] }\n+%struct._opaque_pthread_t = type { i32, %struct.__darwin_pthread_handler_rec*, [596 x i8] }\n+%struct.chan_handle = type { i32, i32 }\n+%\"struct.hash_map<long, rust_port *>::map_entry\" = type opaque\n+%\"struct.hash_map<long, rust_task *>::map_entry\" = type opaque\n+%\"struct.memory_region::alloc_header\" = type { i8 }\n %struct.randctx = type { i32, [256 x i32], [256 x i32], i32, i32, i32 }\n-%class.rust_kernel = type { i32 (...)**, %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, %class.array_list.3, %struct.randctx, i32, %class.hash_map, i32, i32, i32, %struct.rust_env* }\n-%class.array_list.3 = type { i32, %struct.rust_scheduler**, i32 }\n-%class.hash_map = type { %\"struct.hash_map<int, rust_task *>::map_entry\"* }\n-%\"struct.hash_map<int, rust_task *>::map_entry\" = type opaque\n-%union.pthread_attr_t = type { i32, [32 x i8] }\n-%struct.rust_cond = type { i8 }\n-%class.timer = type { i32 (...)**, i64, i64 }\n-%\"class.rust_task::wakeup_callback\" = type { i32 (...)** }\n-%class.hash_map.4 = type { %\"struct.hash_map<int, rust_port *>::map_entry\"* }\n-%\"struct.hash_map<int, rust_port *>::map_entry\" = type opaque\n-%class.rust_obstack = type { %struct.rust_obstack_chunk*, %struct.rust_task* }\n+%struct.registers_t = type { i32, i32, i32, i32, i32, i32, i32, i32, i16, i16, i16, i16, i16, i16, i32, i32 }\n+%struct.rust_env = type { i32, i32, i8*, i8, i8, i8* }\n %struct.rust_obstack_chunk = type { %struct.rust_obstack_chunk*, i32, i32, i32, [0 x i8] }\n-%\"class.std::map\" = type { %\"class.std::_Rb_tree\" }\n-%\"class.std::_Rb_tree\" = type { %\"struct.std::_Rb_tree<void *, std::pair<void *const, const type_desc *>, std::_Select1st<std::pair<void *const, const type_desc *> >, std::less<void *>, std::allocator<std::pair<void *const, const type_desc *> > >::_Rb_tree_impl\" }\n-%\"struct.std::_Rb_tree<void *, std::pair<void *const, const type_desc *>, std::_Select1st<std::pair<void *const, const type_desc *> >, std::less<void *>, std::allocator<std::pair<void *const, const type_desc *> > >::_Rb_tree_impl\" = type { %\"struct.std::less\", %\"struct.std::_Rb_tree_node_base\", i32 }\n-%\"struct.std::less\" = type { i8 }\n-%\"struct.std::_Rb_tree_node_base\" = type { i32, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"* }\n-%\"class.debug::task_debug_info\" = type { %\"class.std::map.5\" }\n-%\"class.std::map.5\" = type { %\"class.std::_Rb_tree.6\" }\n-%\"class.std::_Rb_tree.6\" = type { %\"struct.std::_Rb_tree<void *, std::pair<void *const, std::basic_string<char> >, std::_Select1st<std::pair<void *const, std::basic_string<char> > >, std::less<void *>, std::allocator<std::pair<void *const, std::basic_string<char> > > >::_Rb_tree_impl\" }\n-%\"struct.std::_Rb_tree<void *, std::pair<void *const, std::basic_string<char> >, std::_Select1st<std::pair<void *const, std::basic_string<char> > >, std::less<void *>, std::allocator<std::pair<void *const, std::basic_string<char> > > >::_Rb_tree_impl\" = type { %\"struct.std::less\", %\"struct.std::_Rb_tree_node_base\", i32 }\n+%struct.rust_scheduler = type { %class.rust_thread, i32, i32, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, i32, i32, %class.lock_and_signal, i32, %struct._opaque_pthread_attr_t, %struct.rust_env*, %class.context }\n+%struct.rust_shape_tables = type { i8*, i8* }\n+%struct.rust_task = type { %struct.rust_task_user, i32, %class.context, %struct.rust_obstack_chunk*, i32, %struct.rust_scheduler*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %\"struct.memory_region::alloc_header\"*, i8*, %struct.rust_task*, i32, i32, %class.timer, i32*, %class.array_list, i32, i32, %class.memory_region, %\"class.rust_task::wakeup_callback\"*, i8, i8, i8, %class.lock_and_signal, %class.hash_map, %class.rust_obstack, %\"class.std::map\", i32, %\"class.debug::task_debug_info\" }\n+%struct.rust_task_user = type { i32, i32, %struct.chan_handle, i32 }\n %struct.rust_vec = type { i32, i32, [0 x i8] }\n-%class.rust_port = type { i32, i32, %class.rust_kernel*, %struct.rust_task*, %class.rust_chan*, i32, %class.ptr_vec, %class.ptr_vec.13, %class.lock_and_signal }\n-%class.rust_chan = type { i32, %class.rust_kernel*, %struct.rust_task*, %class.rust_port*, i32, %class.circular_buffer }\n-%class.circular_buffer = type { %class.rust_kernel*, i32, i32, i32, i32, i8* }\n-%class.ptr_vec = type { %struct.rust_task*, i32, i32, %struct.rust_token** }\n-%struct.rust_token = type opaque\n-%class.ptr_vec.13 = type { %struct.rust_task*, i32, i32, %class.rust_chan** }\n+%\"struct.std::_Rb_tree<void *, std::pair<void *const, const type_desc *>, std::_Select1st<std::pair<void *const, const type_desc *> >, std::less<void *>, std::allocator<std::pair<void *const, const type_desc *> > >::_Rb_tree_impl\" = type { %\"struct.memory_region::alloc_header\", %\"struct.std::_Rb_tree_node_base\", i32 }\n+%\"struct.std::_Rb_tree_node_base\" = type { i32, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"* }\n+%struct.type_desc = type { %struct.type_desc**, i32, i32, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i8*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i32, void (i8*, i8*, %struct.type_desc**, i8*, i8*, i8)*, i8*, %struct.rust_shape_tables*, i32, i32, %struct.UT_hash_handle, i32, [0 x %struct.type_desc*] }\n \n-@.str = private unnamed_addr constant [42 x i8] c\"attempt to cast values of differing sizes\\00\", align 1\n-@.str1 = private unnamed_addr constant [33 x i8] c\"src/rt/intrinsics/intrinsics.cpp\\00\", align 1\n+@.str = private unnamed_addr constant [42 x i8] c\"attempt to cast values of differing sizes\\00\"\n+@.str1 = private unnamed_addr constant [33 x i8] c\"src/rt/intrinsics/intrinsics.cpp\\00\"\n \n-define void @rust_intrinsic_vec_len(%struct.rust_task* nocapture %task, i32* nocapture %retptr, %struct.type_desc* nocapture %ty, %struct.rust_vec** nocapture %vp) nounwind {\n-  %1 = load %struct.rust_vec** %vp, align 4, !tbaa !0\n+define void @rust_intrinsic_2_vec_len(i32* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %struct.rust_vec** nocapture %vp) nounwind {\n+  %1 = load %struct.rust_vec** %vp, align 4\n   %2 = getelementptr inbounds %struct.rust_vec* %1, i32 0, i32 0\n-  %3 = load i32* %2, align 4, !tbaa !3\n+  %3 = load i32* %2, align 4\n   %4 = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n-  %5 = load i32* %4, align 4, !tbaa !3\n+  %5 = load i32* %4, align 4\n   %6 = udiv i32 %3, %5\n-  store i32 %6, i32* %retptr, align 4, !tbaa !3\n+  store i32 %6, i32* %retptr, align 4\n   ret void\n }\n \n-define void @rust_intrinsic_ptr_offset(%struct.rust_task* nocapture %task, i8** nocapture %retptr, %struct.type_desc* nocapture %ty, i8* %ptr, i32 %count) nounwind {\n+define void @rust_intrinsic_2_ptr_offset(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* %ptr, i32 %count) nounwind {\n   %1 = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n-  %2 = load i32* %1, align 4, !tbaa !3\n+  %2 = load i32* %1, align 4\n   %3 = mul i32 %2, %count\n   %4 = getelementptr inbounds i8* %ptr, i32 %3\n-  store i8* %4, i8** %retptr, align 4, !tbaa !0\n+  store i8* %4, i8** %retptr, align 4\n   ret void\n }\n \n-define void @rust_intrinsic_cast(%struct.rust_task* nocapture %task, i8* nocapture %retptr, %struct.type_desc* nocapture %t1, %struct.type_desc* nocapture %t2, i8* nocapture %src) {\n+define void @rust_intrinsic_2_cast(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %t1, %struct.type_desc* nocapture %t2, i8* nocapture %src) {\n   %1 = getelementptr inbounds %struct.type_desc* %t1, i32 0, i32 1\n-  %2 = load i32* %1, align 4, !tbaa !3\n+  %2 = load i32* %1, align 4\n   %3 = getelementptr inbounds %struct.type_desc* %t2, i32 0, i32 1\n-  %4 = load i32* %3, align 4, !tbaa !3\n+  %4 = load i32* %3, align 4\n   %5 = icmp eq i32 %2, %4\n   br i1 %5, label %7, label %6\n \n ; <label>:6                                       ; preds = %0\n-  tail call void @upcall_fail(i8* getelementptr inbounds ([42 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8]* @.str1, i32 0, i32 0), i32 38)\n+  tail call void @upcall_fail(i8* getelementptr inbounds ([42 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8]* @.str1, i32 0, i32 0), i32 46)\n   br label %8\n \n ; <label>:7                                       ; preds = %0\n@@ -108,33 +97,90 @@ declare void @upcall_fail(i8*, i8*, i32)\n \n declare void @llvm.memmove.p0i8.p0i8.i32(i8* nocapture, i8* nocapture, i32, i32, i1) nounwind\n \n-define void @rust_intrinsic_addr_of(%struct.rust_task* nocapture %task, i8** nocapture %retptr, %struct.type_desc* nocapture %ty, i8* %valptr) nounwind {\n-  store i8* %valptr, i8** %retptr, align 4, !tbaa !0\n+define void @rust_intrinsic_2_addr_of(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* %valptr) nounwind {\n+  store i8* %valptr, i8** %retptr, align 4\n   ret void\n }\n \n-define void @rust_intrinsic_recv(%struct.rust_task* nocapture %task, i8** %retptr, %struct.type_desc* nocapture %ty, %class.rust_port* %port) {\n+define void @rust_intrinsic_2_recv(i8** %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %class.rust_port* %port) {\n   %1 = bitcast i8** %retptr to i32*\n   tail call void @port_recv(i32* %1, %class.rust_port* %port)\n   ret void\n }\n \n declare void @port_recv(i32*, %class.rust_port*)\n \n-define void @rust_intrinsic_get_type_desc(%struct.rust_task* nocapture %task, i8** nocapture %retptr, %struct.type_desc* %ty) nounwind {\n+define void @rust_intrinsic_2_get_type_desc(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* %ty) nounwind {\n   %ty.c = bitcast %struct.type_desc* %ty to i8*\n-  store i8* %ty.c, i8** %retptr, align 4, !tbaa !0\n+  store i8* %ty.c, i8** %retptr, align 4\n   ret void\n }\n \n-define void @rust_intrinsic_task_sleep(%struct.rust_task* nocapture %_task, i8** nocapture %retptr, i32 %time_in_us) {\n+define void @rust_intrinsic_2_task_sleep(i8** nocapture %retptr, i8* nocapture %env, i32 %time_in_us) {\n   tail call void @rust_task_sleep(i32 %time_in_us)\n   ret void\n }\n \n declare void @rust_task_sleep(i32)\n \n-!0 = metadata !{metadata !\"any pointer\", metadata !1}\n-!1 = metadata !{metadata !\"omnipotent char\", metadata !2}\n-!2 = metadata !{metadata !\"Simple C/C++ TBAA\", null}\n-!3 = metadata !{metadata !\"int\", metadata !1}\n+define void @rust_intrinsic_vec_len(i8* nocapture %task, i32* nocapture %retptr, %struct.type_desc* nocapture %ty, %struct.rust_vec** nocapture %vp) nounwind {\n+  %1 = load %struct.rust_vec** %vp, align 4\n+  %2 = getelementptr inbounds %struct.rust_vec* %1, i32 0, i32 0\n+  %3 = load i32* %2, align 4\n+  %4 = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n+  %5 = load i32* %4, align 4\n+  %6 = udiv i32 %3, %5\n+  store i32 %6, i32* %retptr, align 4\n+  ret void\n+}\n+\n+define void @rust_intrinsic_ptr_offset(i8* nocapture %task, i8** nocapture %retptr, %struct.type_desc* nocapture %ty, i8* %ptr, i32 %count) nounwind {\n+  %1 = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n+  %2 = load i32* %1, align 4\n+  %3 = mul i32 %2, %count\n+  %4 = getelementptr inbounds i8* %ptr, i32 %3\n+  store i8* %4, i8** %retptr, align 4\n+  ret void\n+}\n+\n+define void @rust_intrinsic_cast(i8* nocapture %task, i8* nocapture %retptr, %struct.type_desc* nocapture %t1, %struct.type_desc* nocapture %t2, i8* nocapture %src) {\n+  %1 = getelementptr inbounds %struct.type_desc* %t1, i32 0, i32 1\n+  %2 = load i32* %1, align 4\n+  %3 = getelementptr inbounds %struct.type_desc* %t2, i32 0, i32 1\n+  %4 = load i32* %3, align 4\n+  %5 = icmp eq i32 %2, %4\n+  br i1 %5, label %7, label %6\n+\n+; <label>:6                                       ; preds = %0\n+  tail call void @upcall_fail(i8* getelementptr inbounds ([42 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8]* @.str1, i32 0, i32 0), i32 46)\n+  br label %rust_intrinsic_2_cast.exit\n+\n+; <label>:7                                       ; preds = %0\n+  tail call void @llvm.memmove.p0i8.p0i8.i32(i8* %retptr, i8* %src, i32 %2, i32 1, i1 false)\n+  br label %rust_intrinsic_2_cast.exit\n+\n+rust_intrinsic_2_cast.exit:                       ; preds = %6, %7\n+  ret void\n+}\n+\n+define void @rust_intrinsic_addr_of(i8* nocapture %task, i8** nocapture %retptr, %struct.type_desc* nocapture %ty, i8* %valptr) nounwind {\n+  store i8* %valptr, i8** %retptr, align 4\n+  ret void\n+}\n+\n+define void @rust_intrinsic_recv(i8* nocapture %task, i8** %retptr, %struct.type_desc* nocapture %ty, %class.rust_port* %port) {\n+  %1 = bitcast i8** %retptr to i32*\n+  tail call void @port_recv(i32* %1, %class.rust_port* %port)\n+  ret void\n+}\n+\n+define void @rust_intrinsic_get_type_desc(i8* nocapture %task, i8** nocapture %retptr, %struct.type_desc* %ty) nounwind {\n+  %ty.c.i = bitcast %struct.type_desc* %ty to i8*\n+  store i8* %ty.c.i, i8** %retptr, align 4\n+  ret void\n+}\n+\n+define void @rust_intrinsic_task_sleep(i8* nocapture %task, i8** nocapture %retptr, i32 %time_in_us) {\n+  tail call void @rust_task_sleep(i32 %time_in_us)\n+  ret void\n+}"}, {"sha": "0fa33aa2b2bb62249bf975043ba89989fc43fd8c", "filename": "src/rt/intrinsics/intrinsics.x86_64.ll.in", "status": "modified", "additions": 120, "deletions": 74, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/cbcdeb80d938177962d29f19ce8ef0c1060fa2ae/src%2Frt%2Fintrinsics%2Fintrinsics.x86_64.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/cbcdeb80d938177962d29f19ce8ef0c1060fa2ae/src%2Frt%2Fintrinsics%2Fintrinsics.x86_64.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.x86_64.ll.in?ref=cbcdeb80d938177962d29f19ce8ef0c1060fa2ae", "patch": "@@ -1,99 +1,88 @@\n ; ModuleID = 'src/rt/intrinsics/intrinsics.cpp'\n-; target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\n+; target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64\"\n target triple = \"@CFG_TARGET_TRIPLE@\"\n \n-%struct.rust_task = type { %struct.rust_task_user, i64, %class.context, %struct.stk_seg*, i64, %struct.rust_scheduler*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i64, %class.timer, i64*, %class.array_list.1, i32, i32, %class.memory_region, %\"class.rust_task::wakeup_callback\"*, i8, i8, i8, %class.lock_and_signal, %class.hash_map.4, %class.rust_obstack, %\"class.std::map\", i32, %\"class.debug::task_debug_info\" }\n-%struct.rust_task_user = type { i64, i32, %struct.chan_handle, i64 }\n-%struct.chan_handle = type { i64, i64 }\n+%0 = type { i64, %\"struct.memory_region::alloc_header\"**, i64 }\n+%1 = type { i64, %struct.rust_scheduler**, i64 }\n+%2 = type { %\"struct.hash_map<long, rust_task *>::map_entry\"* }\n+%class.array_list = type { i64, %struct.rust_task**, i64 }\n+%class.circular_buffer = type { %class.rust_kernel*, i64, i64, i64, i64, i8* }\n %class.context = type { %struct.registers_t, %class.context* }\n-%struct.registers_t = type { [7 x i64], [6 x i64], i64 }\n-%struct.stk_seg = type { %struct.stk_seg*, i64, i32, [0 x i8] }\n-%struct.rust_scheduler = type { %class.rust_thread, i64, i64, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, i32, i32, %class.lock_and_signal, i64, %union.pthread_attr_t, %struct.rust_env*, %class.context }\n-%class.rust_thread = type { i32 (...)**, i8, i64 }\n+%\"class.debug::task_debug_info\" = type { %\"class.std::map\" }\n+%class.hash_map = type { %\"struct.hash_map<long, rust_port *>::map_entry\"* }\n+%class.indexed_list = type { i32 (...)**, %class.array_list }\n+%class.lock_and_signal = type { i32 (...)**, %struct._opaque_pthread_cond_t, %struct._opaque_pthread_attr_t, %struct._opaque_pthread_t*, i8, i8 }\n+%class.memory_region = type { i32 (...)**, %class.rust_srv*, %class.memory_region*, i32, %0, i8, i8, %class.lock_and_signal }\n+%class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_scheduler*, i64 }\n+%class.rust_kernel = type { i32 (...)**, %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, %1, %struct.randctx, i64, %2, i64, i32, i32, %struct.rust_env* }\n %class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_scheduler*, i8 }\n+%class.rust_obstack = type { %struct.rust_obstack_chunk*, %struct.rust_task* }\n+%class.rust_port = type { i64, i64, %class.rust_kernel*, %struct.rust_task*, i64, %class.circular_buffer, %class.lock_and_signal }\n %class.rust_srv = type { i32 (...)**, %struct.rust_env*, %class.memory_region }\n-%struct.rust_env = type { i64, i64, i8*, i8, i8, i8* }\n-%class.memory_region = type { i32 (...)**, %class.rust_srv*, %class.memory_region*, i32, %class.array_list, i8, i8, %class.lock_and_signal }\n-%class.array_list = type { i64, %\"struct.memory_region::alloc_header\"**, i64 }\n-%\"struct.memory_region::alloc_header\" = type { i32, i32, i8*, i32, [0 x i8] }\n-%class.lock_and_signal = type { i32 (...)**, %union.pthread_cond_t, %union.pthread_mutex_t, i64, i8, i8 }\n-%union.pthread_cond_t = type { %struct.anon }\n-%struct.anon = type { i32, i32, i64, i64, i64, i8*, i32, i32 }\n-%union.pthread_mutex_t = type { %\"struct.<anonymous union>::__pthread_mutex_s\" }\n-%\"struct.<anonymous union>::__pthread_mutex_s\" = type { i32, i32, i32, i32, i32, i32, %struct.__pthread_internal_list }\n-%struct.__pthread_internal_list = type { %struct.__pthread_internal_list*, %struct.__pthread_internal_list* }\n+%\"class.rust_task::wakeup_callback\" = type { i32 (...)** }\n %class.rust_task_list = type { %class.indexed_list, %struct.rust_scheduler*, i8* }\n-%class.indexed_list = type { i32 (...)**, %class.array_list.1 }\n-%class.array_list.1 = type { i64, %struct.rust_task**, i64 }\n-%class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_scheduler*, i64 }\n-%struct.type_desc = type { %struct.type_desc**, i64, i64, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i8*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i64, void (i8*, i8*, %struct.type_desc**, i8*, i8*, i8)*, i8*, %struct.rust_shape_tables*, i64, i64, %struct.UT_hash_handle, i64, [0 x %struct.type_desc*] }\n-%struct.rust_shape_tables = type { i8*, i8* }\n+%class.rust_thread = type { i32 (...)**, i8, %struct._opaque_pthread_t* }\n+%\"class.std::_Rb_tree\" = type { %\"struct.std::_Rb_tree<void *, std::pair<void *const, const type_desc *>, std::_Select1st<std::pair<void *const, const type_desc *> >, std::less<void *>, std::allocator<std::pair<void *const, const type_desc *> > >::_Rb_tree_impl\" }\n+%\"class.std::map\" = type { %\"class.std::_Rb_tree\" }\n+%class.timer = type { i32 (...)**, i64, i64 }\n+%struct.UT_hash_bucket = type { %struct.UT_hash_handle*, i32, i32 }\n %struct.UT_hash_handle = type { %struct.UT_hash_table*, i8*, i8*, %struct.UT_hash_handle*, %struct.UT_hash_handle*, i8*, i32, i32 }\n %struct.UT_hash_table = type { %struct.UT_hash_bucket*, i32, i32, i32, %struct.UT_hash_handle*, i64, i32, i32, i32, i32 }\n-%struct.UT_hash_bucket = type { %struct.UT_hash_handle*, i32, i32 }\n-%struct.randctx = type { i64, [256 x i64], [256 x i64], i64, i64, i64 }\n-%class.rust_kernel = type { i32 (...)**, %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, %class.array_list.3, %struct.randctx, i64, %class.hash_map, i64, i32, i32, %struct.rust_env* }\n-%class.array_list.3 = type { i64, %struct.rust_scheduler**, i64 }\n-%class.hash_map = type { %\"struct.hash_map<long, rust_task *>::map_entry\"* }\n-%\"struct.hash_map<long, rust_task *>::map_entry\" = type opaque\n-%union.pthread_attr_t = type { i64, [48 x i8] }\n-%struct.rust_cond = type { i8 }\n-%class.timer = type { i32 (...)**, i64, i64 }\n-%\"class.rust_task::wakeup_callback\" = type { i32 (...)** }\n-%class.hash_map.4 = type { %\"struct.hash_map<long, rust_port *>::map_entry\"* }\n+%struct.__darwin_pthread_handler_rec = type { void (i8*)*, i8*, %struct.__darwin_pthread_handler_rec* }\n+%struct._opaque_pthread_attr_t = type { i64, [56 x i8] }\n+%struct._opaque_pthread_cond_t = type { i64, [40 x i8] }\n+%struct._opaque_pthread_t = type { i64, %struct.__darwin_pthread_handler_rec*, [1168 x i8] }\n+%struct.chan_handle = type { i64, i64 }\n %\"struct.hash_map<long, rust_port *>::map_entry\" = type opaque\n-%class.rust_obstack = type { %struct.rust_obstack_chunk*, %struct.rust_task* }\n+%\"struct.hash_map<long, rust_task *>::map_entry\" = type opaque\n+%\"struct.memory_region::alloc_header\" = type { i8 }\n+%struct.randctx = type { i64, [256 x i64], [256 x i64], i64, i64, i64 }\n+%struct.registers_t = type { [22 x i64] }\n+%struct.rust_env = type { i64, i64, i8*, i8, i8, i8* }\n %struct.rust_obstack_chunk = type { %struct.rust_obstack_chunk*, i64, i64, i64, [0 x i8] }\n-%\"class.std::map\" = type { %\"class.std::_Rb_tree\" }\n-%\"class.std::_Rb_tree\" = type { %\"struct.std::_Rb_tree<void *, std::pair<void *const, const type_desc *>, std::_Select1st<std::pair<void *const, const type_desc *> >, std::less<void *>, std::allocator<std::pair<void *const, const type_desc *> > >::_Rb_tree_impl\" }\n-%\"struct.std::_Rb_tree<void *, std::pair<void *const, const type_desc *>, std::_Select1st<std::pair<void *const, const type_desc *> >, std::less<void *>, std::allocator<std::pair<void *const, const type_desc *> > >::_Rb_tree_impl\" = type { %\"struct.std::less\", %\"struct.std::_Rb_tree_node_base\", i64 }\n-%\"struct.std::less\" = type { i8 }\n-%\"struct.std::_Rb_tree_node_base\" = type { i32, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"* }\n-%\"class.debug::task_debug_info\" = type { %\"class.std::map.5\" }\n-%\"class.std::map.5\" = type { %\"class.std::_Rb_tree.6\" }\n-%\"class.std::_Rb_tree.6\" = type { %\"struct.std::_Rb_tree<void *, std::pair<void *const, std::basic_string<char> >, std::_Select1st<std::pair<void *const, std::basic_string<char> > >, std::less<void *>, std::allocator<std::pair<void *const, std::basic_string<char> > > >::_Rb_tree_impl\" }\n-%\"struct.std::_Rb_tree<void *, std::pair<void *const, std::basic_string<char> >, std::_Select1st<std::pair<void *const, std::basic_string<char> > >, std::less<void *>, std::allocator<std::pair<void *const, std::basic_string<char> > > >::_Rb_tree_impl\" = type { %\"struct.std::less\", %\"struct.std::_Rb_tree_node_base\", i64 }\n+%struct.rust_scheduler = type { %class.rust_thread, i64, i64, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, i32, i32, %class.lock_and_signal, i64, %struct._opaque_pthread_attr_t, %struct.rust_env*, %class.context }\n+%struct.rust_shape_tables = type { i8*, i8* }\n+%struct.rust_task = type { %struct.rust_task_user, i64, %class.context, %struct.stk_seg*, i64, %struct.rust_scheduler*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %\"struct.memory_region::alloc_header\"*, i8*, %struct.rust_task*, i32, i64, %class.timer, i64*, %class.array_list, i32, i32, %class.memory_region, %\"class.rust_task::wakeup_callback\"*, i8, i8, i8, %class.lock_and_signal, %class.hash_map, %class.rust_obstack, %\"class.std::map\", i32, %\"class.debug::task_debug_info\" }\n+%struct.rust_task_user = type { i64, i64, %struct.chan_handle, i64 }\n %struct.rust_vec = type { i64, i64, [0 x i8] }\n-%class.rust_port = type { i64, i64, %class.rust_kernel*, %struct.rust_task*, %class.rust_chan*, i64, %class.ptr_vec, %class.ptr_vec.13, %class.lock_and_signal }\n-%class.rust_chan = type { i64, %class.rust_kernel*, %struct.rust_task*, %class.rust_port*, i64, %class.circular_buffer }\n-%class.circular_buffer = type { %class.rust_kernel*, i64, i64, i64, i64, i8* }\n-%class.ptr_vec = type { %struct.rust_task*, i64, i64, %struct.rust_token** }\n-%struct.rust_token = type opaque\n-%class.ptr_vec.13 = type { %struct.rust_task*, i64, i64, %class.rust_chan** }\n+%\"struct.std::_Rb_tree<void *, std::pair<void *const, const type_desc *>, std::_Select1st<std::pair<void *const, const type_desc *> >, std::less<void *>, std::allocator<std::pair<void *const, const type_desc *> > >::_Rb_tree_impl\" = type { %\"struct.memory_region::alloc_header\", %\"struct.std::_Rb_tree_node_base\", i64 }\n+%\"struct.std::_Rb_tree_node_base\" = type { i32, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"* }\n+%struct.stk_seg = type { %struct.stk_seg*, i64, i32, [0 x i8] }\n+%struct.type_desc = type { %struct.type_desc**, i64, i64, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i8*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i64, void (i8*, i8*, %struct.type_desc**, i8*, i8*, i8)*, i8*, %struct.rust_shape_tables*, i64, i64, %struct.UT_hash_handle, i64, [0 x %struct.type_desc*] }\n \n-@.str = private unnamed_addr constant [42 x i8] c\"attempt to cast values of differing sizes\\00\", align 1\n-@.str1 = private unnamed_addr constant [33 x i8] c\"src/rt/intrinsics/intrinsics.cpp\\00\", align 1\n+@.str = private unnamed_addr constant [42 x i8] c\"attempt to cast values of differing sizes\\00\"\n+@.str1 = private unnamed_addr constant [33 x i8] c\"src/rt/intrinsics/intrinsics.cpp\\00\"\n \n-define void @rust_intrinsic_vec_len(%struct.rust_task* nocapture %task, i64* nocapture %retptr, %struct.type_desc* nocapture %ty, %struct.rust_vec** nocapture %vp) nounwind uwtable {\n-  %1 = load %struct.rust_vec** %vp, align 8, !tbaa !0\n+define void @rust_intrinsic_2_vec_len(i64* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %struct.rust_vec** nocapture %vp) nounwind {\n+  %1 = load %struct.rust_vec** %vp, align 8\n   %2 = getelementptr inbounds %struct.rust_vec* %1, i64 0, i32 0\n-  %3 = load i64* %2, align 8, !tbaa !3\n+  %3 = load i64* %2, align 8\n   %4 = getelementptr inbounds %struct.type_desc* %ty, i64 0, i32 1\n-  %5 = load i64* %4, align 8, !tbaa !3\n+  %5 = load i64* %4, align 8\n   %6 = udiv i64 %3, %5\n-  store i64 %6, i64* %retptr, align 8, !tbaa !3\n+  store i64 %6, i64* %retptr, align 8\n   ret void\n }\n \n-define void @rust_intrinsic_ptr_offset(%struct.rust_task* nocapture %task, i8** nocapture %retptr, %struct.type_desc* nocapture %ty, i8* %ptr, i64 %count) nounwind uwtable {\n+define void @rust_intrinsic_2_ptr_offset(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* %ptr, i64 %count) nounwind {\n   %1 = getelementptr inbounds %struct.type_desc* %ty, i64 0, i32 1\n-  %2 = load i64* %1, align 8, !tbaa !3\n+  %2 = load i64* %1, align 8\n   %3 = mul i64 %2, %count\n   %4 = getelementptr inbounds i8* %ptr, i64 %3\n-  store i8* %4, i8** %retptr, align 8, !tbaa !0\n+  store i8* %4, i8** %retptr, align 8\n   ret void\n }\n \n-define void @rust_intrinsic_cast(%struct.rust_task* nocapture %task, i8* nocapture %retptr, %struct.type_desc* nocapture %t1, %struct.type_desc* nocapture %t2, i8* nocapture %src) uwtable {\n+define void @rust_intrinsic_2_cast(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %t1, %struct.type_desc* nocapture %t2, i8* nocapture %src) {\n   %1 = getelementptr inbounds %struct.type_desc* %t1, i64 0, i32 1\n-  %2 = load i64* %1, align 8, !tbaa !3\n+  %2 = load i64* %1, align 8\n   %3 = getelementptr inbounds %struct.type_desc* %t2, i64 0, i32 1\n-  %4 = load i64* %3, align 8, !tbaa !3\n+  %4 = load i64* %3, align 8\n   %5 = icmp eq i64 %2, %4\n   br i1 %5, label %7, label %6\n \n ; <label>:6                                       ; preds = %0\n-  tail call void @upcall_fail(i8* getelementptr inbounds ([42 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([33 x i8]* @.str1, i64 0, i64 0), i64 38)\n+  tail call void @upcall_fail(i8* getelementptr inbounds ([42 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([33 x i8]* @.str1, i64 0, i64 0), i64 46)\n   br label %8\n \n ; <label>:7                                       ; preds = %0\n@@ -108,33 +97,90 @@ declare void @upcall_fail(i8*, i8*, i64)\n \n declare void @llvm.memmove.p0i8.p0i8.i64(i8* nocapture, i8* nocapture, i64, i32, i1) nounwind\n \n-define void @rust_intrinsic_addr_of(%struct.rust_task* nocapture %task, i8** nocapture %retptr, %struct.type_desc* nocapture %ty, i8* %valptr) nounwind uwtable {\n-  store i8* %valptr, i8** %retptr, align 8, !tbaa !0\n+define void @rust_intrinsic_2_addr_of(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* %valptr) nounwind {\n+  store i8* %valptr, i8** %retptr, align 8\n   ret void\n }\n \n-define void @rust_intrinsic_recv(%struct.rust_task* nocapture %task, i8** %retptr, %struct.type_desc* nocapture %ty, %class.rust_port* %port) uwtable {\n+define void @rust_intrinsic_2_recv(i8** %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %class.rust_port* %port) {\n   %1 = bitcast i8** %retptr to i64*\n   tail call void @port_recv(i64* %1, %class.rust_port* %port)\n   ret void\n }\n \n declare void @port_recv(i64*, %class.rust_port*)\n \n-define void @rust_intrinsic_get_type_desc(%struct.rust_task* nocapture %task, i8** nocapture %retptr, %struct.type_desc* %ty) nounwind uwtable {\n+define void @rust_intrinsic_2_get_type_desc(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* %ty) nounwind {\n   %ty.c = bitcast %struct.type_desc* %ty to i8*\n-  store i8* %ty.c, i8** %retptr, align 8, !tbaa !0\n+  store i8* %ty.c, i8** %retptr, align 8\n   ret void\n }\n \n-define void @rust_intrinsic_task_sleep(%struct.rust_task* nocapture %_task, i8** nocapture %retptr, i64 %time_in_us) uwtable {\n+define void @rust_intrinsic_2_task_sleep(i8** nocapture %retptr, i8* nocapture %env, i64 %time_in_us) {\n   tail call void @rust_task_sleep(i64 %time_in_us)\n   ret void\n }\n \n declare void @rust_task_sleep(i64)\n \n-!0 = metadata !{metadata !\"any pointer\", metadata !1}\n-!1 = metadata !{metadata !\"omnipotent char\", metadata !2}\n-!2 = metadata !{metadata !\"Simple C/C++ TBAA\", null}\n-!3 = metadata !{metadata !\"long\", metadata !1}\n+define void @rust_intrinsic_vec_len(i8* nocapture %task, i64* nocapture %retptr, %struct.type_desc* nocapture %ty, %struct.rust_vec** nocapture %vp) nounwind {\n+  %1 = load %struct.rust_vec** %vp, align 8\n+  %2 = getelementptr inbounds %struct.rust_vec* %1, i64 0, i32 0\n+  %3 = load i64* %2, align 8\n+  %4 = getelementptr inbounds %struct.type_desc* %ty, i64 0, i32 1\n+  %5 = load i64* %4, align 8\n+  %6 = udiv i64 %3, %5\n+  store i64 %6, i64* %retptr, align 8\n+  ret void\n+}\n+\n+define void @rust_intrinsic_ptr_offset(i8* nocapture %task, i8** nocapture %retptr, %struct.type_desc* nocapture %ty, i8* %ptr, i64 %count) nounwind {\n+  %1 = getelementptr inbounds %struct.type_desc* %ty, i64 0, i32 1\n+  %2 = load i64* %1, align 8\n+  %3 = mul i64 %2, %count\n+  %4 = getelementptr inbounds i8* %ptr, i64 %3\n+  store i8* %4, i8** %retptr, align 8\n+  ret void\n+}\n+\n+define void @rust_intrinsic_cast(i8* nocapture %task, i8* nocapture %retptr, %struct.type_desc* nocapture %t1, %struct.type_desc* nocapture %t2, i8* nocapture %src) {\n+  %1 = getelementptr inbounds %struct.type_desc* %t1, i64 0, i32 1\n+  %2 = load i64* %1, align 8\n+  %3 = getelementptr inbounds %struct.type_desc* %t2, i64 0, i32 1\n+  %4 = load i64* %3, align 8\n+  %5 = icmp eq i64 %2, %4\n+  br i1 %5, label %7, label %6\n+\n+; <label>:6                                       ; preds = %0\n+  tail call void @upcall_fail(i8* getelementptr inbounds ([42 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([33 x i8]* @.str1, i64 0, i64 0), i64 46)\n+  br label %rust_intrinsic_2_cast.exit\n+\n+; <label>:7                                       ; preds = %0\n+  tail call void @llvm.memmove.p0i8.p0i8.i64(i8* %retptr, i8* %src, i64 %2, i32 1, i1 false)\n+  br label %rust_intrinsic_2_cast.exit\n+\n+rust_intrinsic_2_cast.exit:                       ; preds = %6, %7\n+  ret void\n+}\n+\n+define void @rust_intrinsic_addr_of(i8* nocapture %task, i8** nocapture %retptr, %struct.type_desc* nocapture %ty, i8* %valptr) nounwind {\n+  store i8* %valptr, i8** %retptr, align 8\n+  ret void\n+}\n+\n+define void @rust_intrinsic_recv(i8* nocapture %task, i8** %retptr, %struct.type_desc* nocapture %ty, %class.rust_port* %port) {\n+  %1 = bitcast i8** %retptr to i64*\n+  tail call void @port_recv(i64* %1, %class.rust_port* %port)\n+  ret void\n+}\n+\n+define void @rust_intrinsic_get_type_desc(i8* nocapture %task, i8** nocapture %retptr, %struct.type_desc* %ty) nounwind {\n+  %ty.c.i = bitcast %struct.type_desc* %ty to i8*\n+  store i8* %ty.c.i, i8** %retptr, align 8\n+  ret void\n+}\n+\n+define void @rust_intrinsic_task_sleep(i8* nocapture %task, i8** nocapture %retptr, i64 %time_in_us) {\n+  tail call void @rust_task_sleep(i64 %time_in_us)\n+  ret void\n+}"}]}