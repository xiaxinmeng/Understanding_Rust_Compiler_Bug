{"sha": "763e72110a913c7aab396a0f687e2ebd3c9e572a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2M2U3MjExMGE5MTNjN2FhYjM5NmEwZjY4N2UyZWJkM2M5ZTU3MmE=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2018-08-09T23:35:25Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2018-08-09T23:35:25Z"}, "message": "rustc_codegen_llvm: Restore the closure env alloca hack for LLVM 5.\n\nThis hack was removed in #50949, but without it I found that building\n`std` with full debuginfo would print many LLVM `DW_OP_LLVM_fragment`\nerrors, then die `LLVM ERROR: Failed to strip malformed debug info`.\n\nIt doesn't seem to be a problem for LLVM 6, so we can re-enable the hack\njust for older LLVM.\n\nThis reverts commit da579ef75e4a8ca11fb98b24a0a3ea0c7ccffeeb.\nFixes #53204.\nr? @eddyb", "tree": {"sha": "be36e53ca677d070717833a4badaac20c3632765", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be36e53ca677d070717833a4badaac20c3632765"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/763e72110a913c7aab396a0f687e2ebd3c9e572a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/763e72110a913c7aab396a0f687e2ebd3c9e572a", "html_url": "https://github.com/rust-lang/rust/commit/763e72110a913c7aab396a0f687e2ebd3c9e572a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/763e72110a913c7aab396a0f687e2ebd3c9e572a/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b73535f1e9c46a698527fab51b1cc9fad3f53412", "url": "https://api.github.com/repos/rust-lang/rust/commits/b73535f1e9c46a698527fab51b1cc9fad3f53412", "html_url": "https://github.com/rust-lang/rust/commit/b73535f1e9c46a698527fab51b1cc9fad3f53412"}], "stats": {"total": 26, "additions": 24, "deletions": 2}, "files": [{"sha": "8bb049be30549a237b68b2703767e3d3a61af013", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/763e72110a913c7aab396a0f687e2ebd3c9e572a/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763e72110a913c7aab396a0f687e2ebd3c9e572a/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=763e72110a913c7aab396a0f687e2ebd3c9e572a", "patch": "@@ -574,6 +574,25 @@ fn arg_local_refs(\n             };\n             let upvar_tys = upvar_substs.upvar_tys(def_id, tcx);\n \n+            // Store the pointer to closure data in an alloca for debuginfo\n+            // because that's what the llvm.dbg.declare intrinsic expects.\n+\n+            // FIXME(eddyb) this shouldn't be necessary but SROA seems to\n+            // mishandle DW_OP_plus not preceded by DW_OP_deref, i.e. it\n+            // doesn't actually strip the offset when splitting the closure\n+            // environment into its components so it ends up out of bounds.\n+            // (cuviper) It seems to be fine without the alloca on LLVM 6 and later.\n+            let env_alloca = !env_ref && unsafe { llvm::LLVMRustVersionMajor() < 6 };\n+            let env_ptr = if env_alloca {\n+                let scratch = PlaceRef::alloca(bx,\n+                    bx.cx.layout_of(tcx.mk_mut_ptr(arg.layout.ty)),\n+                    \"__debuginfo_env_ptr\");\n+                bx.store(place.llval, scratch.llval, scratch.align);\n+                scratch.llval\n+            } else {\n+                place.llval\n+            };\n+\n             for (i, (decl, ty)) in mir.upvar_decls.iter().zip(upvar_tys).enumerate() {\n                 let byte_offset_of_var_in_env = closure_layout.fields.offset(i).bytes();\n \n@@ -585,7 +604,10 @@ fn arg_local_refs(\n                 };\n \n                 // The environment and the capture can each be indirect.\n-                let mut ops = if env_ref { &ops[..] } else { &ops[1..] };\n+\n+                // FIXME(eddyb) see above why we sometimes have to keep\n+                // a pointer in an alloca for debuginfo atm.\n+                let mut ops = if env_ref || env_alloca { &ops[..] } else { &ops[1..] };\n \n                 let ty = if let (true, &ty::TyRef(_, ty, _)) = (decl.by_ref, &ty.sty) {\n                     ty\n@@ -595,7 +617,7 @@ fn arg_local_refs(\n                 };\n \n                 let variable_access = VariableAccess::IndirectVariable {\n-                    alloca: place.llval,\n+                    alloca: env_ptr,\n                     address_operations: &ops\n                 };\n                 declare_local("}]}