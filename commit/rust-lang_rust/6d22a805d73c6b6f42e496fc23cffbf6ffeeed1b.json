{"sha": "6d22a805d73c6b6f42e496fc23cffbf6ffeeed1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkMjJhODA1ZDczYzZiNmY0MmU0OTZmYzIzY2ZmYmY2ZmZlZWVkMWI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-08-29T20:25:31Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-08-29T20:26:51Z"}, "message": "Replace core::path with contents of core::path2. Back to one path module.", "tree": {"sha": "e689224c339c233683520f3effb00e0773d1e93a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e689224c339c233683520f3effb00e0773d1e93a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d22a805d73c6b6f42e496fc23cffbf6ffeeed1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d22a805d73c6b6f42e496fc23cffbf6ffeeed1b", "html_url": "https://github.com/rust-lang/rust/commit/6d22a805d73c6b6f42e496fc23cffbf6ffeeed1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d22a805d73c6b6f42e496fc23cffbf6ffeeed1b/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb8ecd79849160d8cff2eff8b070efd7f9a3b9a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb8ecd79849160d8cff2eff8b070efd7f9a3b9a7", "html_url": "https://github.com/rust-lang/rust/commit/cb8ecd79849160d8cff2eff8b070efd7f9a3b9a7"}], "stats": {"total": 1465, "additions": 480, "deletions": 985}, "files": [{"sha": "c87e62089731adf69c3e158fc3ade3da0458bb0d", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6d22a805d73c6b6f42e496fc23cffbf6ffeeed1b/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6d22a805d73c6b6f42e496fc23cffbf6ffeeed1b/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=6d22a805d73c6b6f42e496fc23cffbf6ffeeed1b", "patch": "@@ -54,7 +54,7 @@ export send_map;\n export hash;\n export cmp;\n export num;\n-export path, path2;\n+export path;\n export managed;\n export flate;\n \n@@ -254,7 +254,6 @@ mod libc;\n mod os;\n #[warn(non_camel_case_types)]\n mod path;\n-mod path2;\n #[warn(non_camel_case_types)]\n mod rand;\n #[warn(non_camel_case_types)]"}, {"sha": "e7e5931fe94e913deb207fb5731554d1bc32f6d6", "filename": "src/libcore/core.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d22a805d73c6b6f42e496fc23cffbf6ffeeed1b/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d22a805d73c6b6f42e496fc23cffbf6ffeeed1b/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=6d22a805d73c6b6f42e496fc23cffbf6ffeeed1b", "patch": "@@ -10,10 +10,10 @@ import option = option::Option;\n \n import result::{Result, Ok, Err};\n \n-import Path = path2::Path;\n-import GenericPath = path2::GenericPath;\n-import WindowsPath = path2::WindowsPath;\n-import PosixPath = path2::PosixPath;\n+import Path = path::Path;\n+import GenericPath = path::GenericPath;\n+import WindowsPath = path::WindowsPath;\n+import PosixPath = path::PosixPath;\n \n import tuple::{TupleOps, ExtendedTupleOps};\n import str::{StrSlice, UniqueStr};"}, {"sha": "d7a3ffdf9417741ad4c80d1d628d01f90faec6ae", "filename": "src/libcore/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d22a805d73c6b6f42e496fc23cffbf6ffeeed1b/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d22a805d73c6b6f42e496fc23cffbf6ffeeed1b/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=6d22a805d73c6b6f42e496fc23cffbf6ffeeed1b", "patch": "@@ -914,7 +914,7 @@ mod tests {\n \n     #[test]\n     fn test() {\n-        assert (!path::path_is_absolute(~\"test-path\"));\n+        assert (!Path(\"test-path\").is_absolute);\n \n         log(debug, ~\"Current working directory: \" + getcwd().to_str());\n "}, {"sha": "235dd686a1db656dc0b76943bdc219ae6ddabe24", "filename": "src/libcore/path.rs", "status": "modified", "additions": 474, "deletions": 401, "changes": 875, "blob_url": "https://github.com/rust-lang/rust/blob/6d22a805d73c6b6f42e496fc23cffbf6ffeeed1b/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d22a805d73c6b6f42e496fc23cffbf6ffeeed1b/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=6d22a805d73c6b6f42e496fc23cffbf6ffeeed1b", "patch": "@@ -1,504 +1,577 @@\n-//! Path data type and helper functions\n-\n-export Path;\n-export consts;\n-export path_is_absolute;\n-export path_sep;\n-export dirname;\n-export basename;\n-export connect;\n-export connect_many;\n-export split;\n-export splitext;\n-export normalize;\n-\n-// FIXME: This type should probably be constrained (#2624)\n-/// A path or fragment of a filesystem path\n-type Path = ~str;\n-\n-#[cfg(unix)]\n-mod consts {\n-    /**\n-     * The primary path separator character for the platform\n-     *\n-     * On all platforms it is '/'\n-     */\n-    const path_sep: char = '/';\n-    /**\n-     * The secondary path separator character for the platform\n-     *\n-     * On Unixes it is '/'. On Windows it is '\\'.\n-     */\n-    const alt_path_sep: char = '/';\n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n+struct WindowsPath {\n+    host: Option<~str>;\n+    device: Option<~str>;\n+    is_absolute: bool;\n+    components: ~[~str];\n }\n \n-#[cfg(windows)]\n-mod consts {\n-    const path_sep: char = '/';\n-    const alt_path_sep: char = '\\\\';\n+struct PosixPath {\n+    is_absolute: bool;\n+    components: ~[~str];\n }\n \n-/**\n- * Indicates whether a path is absolute.\n- *\n- * A path is considered absolute if it begins at the filesystem root (\"/\") or,\n- * on Windows, begins with a drive letter.\n- */\n-#[cfg(unix)]\n-fn path_is_absolute(p: Path) -> bool {\n-    str::char_at(p, 0u) == '/'\n-}\n+trait GenericPath {\n \n-#[cfg(windows)]\n-fn path_is_absolute(p: ~str) -> bool {\n-    return str::char_at(p, 0u) == '/' ||\n-        str::char_at(p, 1u) == ':'\n-        && (str::char_at(p, 2u) == consts::path_sep\n-            || str::char_at(p, 2u) == consts::alt_path_sep);\n-}\n+    static pure fn from_str((&str)) -> self;\n \n-/// Get the default path separator for the host platform\n-fn path_sep() -> ~str { return str::from_char(consts::path_sep); }\n+    pure fn dirname() -> ~str;\n+    pure fn filename() -> Option<~str>;\n+    pure fn filestem() -> Option<~str>;\n+    pure fn filetype() -> Option<~str>;\n \n-fn split_dirname_basename (pp: Path) -> {dirname: ~str, basename: ~str} {\n-    match str::rfind(pp, |ch|\n-        ch == consts::path_sep || ch == consts::alt_path_sep\n-    ) {\n-      Some(i) => {\n-        dirname: str::slice(pp, 0u, i),\n-        basename: str::slice(pp, i + 1u, str::len(pp))\n-      },\n-      None => {dirname: ~\".\", basename: pp}\n-    }\n+    pure fn with_dirname((&str)) -> self;\n+    pure fn with_filename((&str)) -> self;\n+    pure fn with_filestem((&str)) -> self;\n+    pure fn with_filetype((&str)) -> self;\n+\n+    pure fn push((&str)) -> self;\n+    pure fn push_rel((&self)) -> self;\n+    pure fn push_many((&[~str])) -> self;\n+    pure fn pop() -> self;\n }\n \n-/**\n- * Get the directory portion of a path\n- *\n- * Returns all of the path up to, but excluding, the final path separator.\n- * The dirname of \"/usr/share\" will be \"/usr\", but the dirname of\n- * \"/usr/share/\" is \"/usr/share\".\n- *\n- * If the path is not prefixed with a directory, then \".\" is returned.\n- */\n-fn dirname(pp: Path) -> Path {\n-    return split_dirname_basename(pp).dirname;\n+#[cfg(windows)]\n+type Path = WindowsPath;\n+\n+#[cfg(windows)]\n+pure fn Path(s: &str) -> Path {\n+    from_str::<WindowsPath>(s)\n }\n \n-/**\n- * Get the file name portion of a path\n- *\n- * Returns the portion of the path after the final path separator.\n- * The basename of \"/usr/share\" will be \"share\". If there are no\n- * path separators in the path then the returned path is identical to\n- * the provided path. If an empty path is provided or the path ends\n- * with a path separator then an empty path is returned.\n- */\n-fn basename(pp: Path) -> Path {\n-    return split_dirname_basename(pp).basename;\n+#[cfg(unix)]\n+type Path = PosixPath;\n+\n+#[cfg(unix)]\n+pure fn Path(s: &str) -> Path {\n+    from_str::<PosixPath>(s)\n }\n \n-/**\n- * Connects to path segments\n- *\n- * Given paths `pre` and `post, removes any trailing path separator on `pre`\n- * and any leading path separator on `post`, and returns the concatenation of\n- * the two with a single path separator between them.\n- */\n-fn connect(pre: Path, post: Path) -> Path {\n-    let mut pre_ = pre;\n-    let mut post_ = post;\n-    let sep = consts::path_sep as u8;\n-    let pre_len  = str::len(pre);\n-    let post_len = str::len(post);\n-    unsafe {\n-        if pre_len > 1u && pre[pre_len-1u] == sep {\n-            str::unsafe::pop_byte(pre_);\n-        }\n-        if post_len > 1u && post[0] == sep {\n-            str::unsafe::shift_byte(post_);\n+impl PosixPath : ToStr {\n+    fn to_str() -> ~str {\n+        let mut s = ~\"\";\n+        if self.is_absolute {\n+            s += \"/\";\n         }\n+        s + str::connect(self.components, \"/\")\n     }\n-    return pre_ + path_sep() + post_;\n }\n \n-/**\n- * Connects a vector of path segments into a single path.\n- *\n- * Inserts path separators as needed.\n- */\n-fn connect_many(paths: ~[Path]) -> Path {\n-    return if vec::len(paths) == 1u {\n-        paths[0]\n-    } else {\n-        let rest = vec::slice(paths, 1u, vec::len(paths));\n-        connect(paths[0], connect_many(rest))\n-    }\n-}\n+// FIXME (#3227): when default methods in traits are working, de-duplicate\n+// PosixPath and WindowsPath, most of their methods are common.\n+impl PosixPath : GenericPath {\n \n-/**\n- * Split a path into its individual components\n- *\n- * Splits a given path by path separators and returns a vector containing\n- * each piece of the path. On Windows, if the path is absolute then\n- * the first element of the returned vector will be the drive letter\n- * followed by a colon.\n- */\n-fn split(p: Path) -> ~[Path] {\n-    str::split_nonempty(p, |c| {\n-        c == consts::path_sep || c == consts::alt_path_sep\n-    })\n-}\n+    static pure fn from_str(s: &str) -> PosixPath {\n+        let mut components = str::split_nonempty(s, |c| c == '/');\n+        let is_absolute = (s.len() != 0 && s[0] == '/' as u8);\n+        return PosixPath { is_absolute: is_absolute,\n+                           components: normalize(components) }\n+    }\n \n-/**\n- * Split a path into the part before the extension and the extension\n- *\n- * Split a path into a pair of strings with the first element being the\n- * filename without the extension and the second being either empty or the\n- * file extension including the period. Leading periods in the basename are\n- * ignored.  If the path includes directory components then they are included\n- * in the filename part of the result pair.\n- */\n-fn splitext(p: Path) -> (~str, ~str) {\n-    if str::is_empty(p) { (~\"\", ~\"\") }\n-    else {\n-        let parts = str::split_char(p, '.');\n-        if vec::len(parts) > 1u {\n-            let base = str::connect(vec::init(parts), ~\".\");\n-            // We just checked that parts is non-empty, so this is safe\n-            let ext = ~\".\" + vec::last(parts);\n-\n-            fn is_dotfile(base: ~str) -> bool {\n-                str::is_empty(base)\n-                    || str::ends_with(\n-                        base, str::from_char(consts::path_sep))\n-                    || str::ends_with(\n-                        base, str::from_char(consts::alt_path_sep))\n+    pure fn dirname() -> ~str {\n+        unchecked {\n+            let s = self.dir_path().to_str();\n+            if s.len() == 0 {\n+                ~\".\"\n+            } else {\n+                s\n             }\n+        }\n+    }\n \n-            fn ext_contains_sep(ext: ~str) -> bool {\n-                vec::len(split(ext)) > 1u\n-            }\n+    pure fn filename() -> Option<~str> {\n+        match self.components.len() {\n+          0 => None,\n+          n => Some(copy self.components[n - 1])\n+        }\n+    }\n \n-            fn no_basename(ext: ~str) -> bool {\n-                str::ends_with(\n-                    ext, str::from_char(consts::path_sep))\n-                    || str::ends_with(\n-                        ext, str::from_char(consts::alt_path_sep))\n+    pure fn filestem() -> Option<~str> {\n+        match self.filename() {\n+          None => None,\n+          Some(ref f) => {\n+            match str::rfind_char(*f, '.') {\n+              Some(p) => Some(f.slice(0, p)),\n+              None => Some(copy *f)\n             }\n+          }\n+        }\n+    }\n \n-            if is_dotfile(base)\n-                || ext_contains_sep(ext)\n-                || no_basename(ext) {\n-                (p, ~\"\")\n-            } else {\n-                (base, ext)\n+    pure fn filetype() -> Option<~str> {\n+        match self.filename() {\n+          None => None,\n+          Some(ref f) => {\n+            match str::rfind_char(*f, '.') {\n+              Some(p) if p+1 < f.len() => Some(f.slice(p+1, f.len())),\n+              _ => None\n             }\n-        } else {\n-            (p, ~\"\")\n+          }\n         }\n     }\n-}\n \n-/**\n- * Collapses redundant path separators.\n- *\n- * Does not follow symbolic links.\n- *\n- * # Examples\n- *\n- * * '/a/../b' becomes '/b'\n- * * 'a/./b/' becomes 'a/b/'\n- * * 'a/b/../../../' becomes '..'\n- * * '/a/b/c/../d/./../../e/' becomes '/a/e/'\n- */\n-fn normalize(p: Path) -> Path {\n-    let s = split(p);\n-    let s = strip_dots(s);\n-    let s = rollup_doubledots(s);\n-\n-    let s = if vec::is_not_empty(s) {\n-        connect_many(s)\n-    } else {\n-        ~\"\"\n-    };\n-    let s = reabsolute(p, s);\n-    let s = reterminate(p, s);\n-\n-    let s = if str::len(s) == 0u {\n-        ~\".\"\n-    } else {\n-        s\n-    };\n-\n-    return s;\n-\n-    fn strip_dots(s: ~[Path]) -> ~[Path] {\n-        vec::filter_map(s, |elem|\n-            if elem == ~\".\" {\n-                option::None\n-            } else {\n-                option::Some(elem)\n-            })\n+    pure fn with_dirname(d: &str) -> PosixPath {\n+        let dpath = from_str::<PosixPath>(d);\n+        match self.filename() {\n+          Some(ref f) => dpath.push(*f),\n+          None => dpath\n+        }\n     }\n \n-    fn rollup_doubledots(s: ~[Path]) -> ~[Path] {\n-        if vec::is_empty(s) {\n-            return ~[];\n+    pure fn with_filename(f: &str) -> PosixPath {\n+        unchecked {\n+            assert ! str::any(f, |c| windows::is_sep(c as u8));\n+            self.dir_path().push(f)\n         }\n+    }\n \n-        let mut t = ~[];\n-        let mut i = vec::len(s);\n-        let mut skip = 0;\n-        while i != 0u {\n-            i -= 1u;\n-            if s[i] == ~\"..\" {\n-                skip += 1;\n-            } else {\n-                if skip == 0 {\n-                    vec::push(t, s[i]);\n-                } else {\n-                    skip -= 1;\n-                }\n-            }\n+    pure fn with_filestem(s: &str) -> PosixPath {\n+        match self.filetype() {\n+          None => self.with_filename(s),\n+          Some(ref t) =>\n+          self.with_filename(str::from_slice(s) + \".\" + *t)\n         }\n-        let mut t = vec::reversed(t);\n-        while skip > 0 {\n-            vec::push(t, ~\"..\");\n-            skip -= 1;\n-        }\n-        return t;\n     }\n \n-    #[cfg(unix)]\n-    fn reabsolute(orig: Path, n: Path) -> Path {\n-        if path_is_absolute(orig) {\n-            path_sep() + n\n+    pure fn with_filetype(t: &str) -> PosixPath {\n+        if t.len() == 0 {\n+            match self.filestem() {\n+              None => copy self,\n+              Some(s) => self.with_filename(s)\n+            }\n         } else {\n-            n\n+            let t = ~\".\" + str::from_slice(t);\n+            match self.filestem() {\n+              None => self.with_filename(t),\n+              Some(ref s) =>\n+              self.with_filename(*s + t)\n+            }\n         }\n     }\n \n-    #[cfg(windows)]\n-    fn reabsolute(orig: Path, newp: Path) -> Path {\n-       if path_is_absolute(orig) && orig[0] == consts::path_sep as u8 {\n-           str::from_char(consts::path_sep) + newp\n-       } else {\n-           newp\n-       }\n-    }\n-\n-    fn reterminate(orig: Path, newp: Path) -> Path {\n-        let last = orig[str::len(orig) - 1u];\n-        if last == consts::path_sep as u8\n-            || last == consts::path_sep as u8 {\n-            return newp + path_sep();\n+    pure fn dir_path() -> PosixPath {\n+        if self.components.len() != 0 {\n+            self.pop()\n         } else {\n-            return newp;\n+            copy self\n         }\n     }\n-}\n \n-#[cfg(test)]\n-mod tests {\n-    #[test]\n-    fn test_connect() {\n-        let slash = path_sep();\n-        log(error, connect(~\"a\", ~\"b\"));\n-        assert (connect(~\"a\", ~\"b\") == ~\"a\" + slash + ~\"b\");\n-        assert (connect(~\"a\" + slash, ~\"b\") == ~\"a\" + slash + ~\"b\");\n+    pure fn file_path() -> PosixPath {\n+        let cs = match self.filename() {\n+          None => ~[],\n+          Some(ref f) => ~[copy *f]\n+        };\n+        return PosixPath { is_absolute: false,\n+                           components: cs }\n     }\n \n-    fn ps() -> ~str {\n-        path_sep()\n+    pure fn push_rel(other: &PosixPath) -> PosixPath {\n+        assert !other.is_absolute;\n+        self.push_many(other.components)\n     }\n \n-    fn aps() -> ~str {\n-        ~\"/\"\n+    pure fn push_many(cs: &[~str]) -> PosixPath {\n+        return PosixPath { components: normalize(self.components + cs),\n+                           ..self }\n     }\n \n-    #[test]\n-    fn split1() {\n-        let actual = split(~\"a\" + ps() + ~\"b\");\n-        let expected = ~[~\"a\", ~\"b\"];\n-        assert actual == expected;\n+    pure fn push(s: &str) -> PosixPath {\n+        let mut cs = self.components;\n+        unchecked { vec::push(cs, move str::from_slice(s)); }\n+        cs = normalize(cs);\n+        return PosixPath { components: move cs,\n+                           ..self }\n     }\n \n-    #[test]\n-    fn split2() {\n-        let actual = split(~\"a\" + aps() + ~\"b\");\n-        let expected = ~[~\"a\", ~\"b\"];\n-        assert actual == expected;\n+    pure fn pop() -> PosixPath {\n+        let mut cs = copy self.components;\n+        if cs.len() != 0 {\n+            unchecked { vec::pop(cs); }\n+        }\n+        return PosixPath { components: move cs, ..self }\n     }\n+}\n \n-    #[test]\n-    fn split3() {\n-        let actual = split(ps() + ~\"a\" + ps() + ~\"b\");\n-        let expected = ~[~\"a\", ~\"b\"];\n-        assert actual == expected;\n+\n+impl WindowsPath : ToStr {\n+    fn to_str() -> ~str {\n+        let mut s = ~\"\";\n+        match self.host {\n+          Some(h) => { s += \"\\\\\\\\\"; s += h; }\n+          None => { }\n+        }\n+        match self.device {\n+          Some(d) => { s += d; s += \":\"; }\n+          None => { }\n+        }\n+        if self.is_absolute {\n+            s += \"\\\\\";\n+        }\n+        s + str::connect(self.components, \"\\\\\")\n     }\n+}\n \n-    #[test]\n-    fn split4() {\n-        let actual = split(~\"a\" + ps() + ~\"b\" + aps() + ~\"c\");\n-        let expected = ~[~\"a\", ~\"b\", ~\"c\"];\n-        assert actual == expected;\n+\n+impl WindowsPath : GenericPath {\n+\n+    static pure fn from_str(s: &str) -> WindowsPath {\n+        let host;\n+        let device;\n+        let rest;\n+\n+        match windows::extract_drive_prefix(s) {\n+          Some((ref d, ref r)) => {\n+            host = None;\n+            device = Some(copy *d);\n+            rest = copy *r;\n+          }\n+          None => {\n+            match windows::extract_unc_prefix(s) {\n+              Some((ref h, ref r)) => {\n+                host = Some(copy *h);\n+                device = None;\n+                rest = copy *r;\n+              }\n+              None => {\n+                host = None;\n+                device = None;\n+                rest = str::from_slice(s);\n+              }\n+            }\n+          }\n+        }\n+\n+        let mut components =\n+            str::split_nonempty(rest, |c| windows::is_sep(c as u8));\n+        let is_absolute = (rest.len() != 0 && windows::is_sep(rest[0]));\n+        return WindowsPath { host: host,\n+                             device: device,\n+                             is_absolute: is_absolute,\n+                             components: normalize(components) }\n     }\n \n-    #[test]\n-    fn normalize1() {\n-        let actual = normalize(~\"a/b/..\");\n-        let expected = ~\"a\";\n-        assert actual == expected;\n+    pure fn dirname() -> ~str {\n+        unchecked {\n+            let s = self.dir_path().to_str();\n+            if s.len() == 0 {\n+                ~\".\"\n+            } else {\n+                s\n+            }\n+        }\n     }\n \n-    #[test]\n-    fn normalize2() {\n-        let actual = normalize(~\"/a/b/..\");\n-        let expected = ~\"/a\";\n-        assert actual == expected;\n+    pure fn filename() -> Option<~str> {\n+        match self.components.len() {\n+          0 => None,\n+          n => Some(copy self.components[n - 1])\n+        }\n     }\n \n-    #[test]\n-    fn normalize3() {\n-        let actual = normalize(~\"a/../b\");\n-        let expected = ~\"b\";\n-        assert actual == expected;\n+    pure fn filestem() -> Option<~str> {\n+        match self.filename() {\n+          None => None,\n+          Some(ref f) => {\n+            match str::rfind_char(*f, '.') {\n+              Some(p) => Some(f.slice(0, p)),\n+              None => Some(copy *f)\n+            }\n+          }\n+        }\n     }\n \n-    #[test]\n-    fn normalize4() {\n-        let actual = normalize(~\"/a/../b\");\n-        let expected = ~\"/b\";\n-        assert actual == expected;\n+    pure fn filetype() -> Option<~str> {\n+        match self.filename() {\n+          None => None,\n+          Some(ref f) => {\n+            match str::rfind_char(*f, '.') {\n+              Some(p) if p+1 < f.len() => Some(f.slice(p+1, f.len())),\n+              _ => None\n+            }\n+          }\n+        }\n     }\n \n-    #[test]\n-    fn normalize5() {\n-        let actual = normalize(~\"a/.\");\n-        let expected = ~\"a\";\n-        assert actual == expected;\n+    pure fn with_dirname(d: &str) -> WindowsPath {\n+        let dpath = from_str::<WindowsPath>(d);\n+        match self.filename() {\n+          Some(ref f) => dpath.push(*f),\n+          None => dpath\n+        }\n     }\n \n-    #[test]\n-    fn normalize6() {\n-        let actual = normalize(~\"a/./b/\");\n-        let expected = ~\"a/b/\";\n-        assert actual == expected;\n+    pure fn with_filename(f: &str) -> WindowsPath {\n+        assert ! str::any(f, |c| windows::is_sep(c as u8));\n+        self.dir_path().push(f)\n     }\n \n-    #[test]\n-    fn normalize7() {\n-        let actual = normalize(~\"a/..\");\n-        let expected = ~\".\";\n-        assert actual == expected;\n+    pure fn with_filestem(s: &str) -> WindowsPath {\n+        match self.filetype() {\n+          None => self.with_filename(s),\n+          Some(ref t) =>\n+          self.with_filename(str::from_slice(s) + \".\" + *t)\n+        }\n     }\n \n-    #[test]\n-    fn normalize8() {\n-        let actual = normalize(~\"../../..\");\n-        let expected = ~\"../../..\";\n-        assert actual == expected;\n+    pure fn with_filetype(t: &str) -> WindowsPath {\n+        if t.len() == 0 {\n+            match self.filestem() {\n+              None => copy self,\n+              Some(s) => self.with_filename(s)\n+            }\n+        } else {\n+            let t = ~\".\" + str::from_slice(t);\n+            match self.filestem() {\n+              None => self.with_filename(t),\n+              Some(ref s) =>\n+              self.with_filename(*s + t)\n+            }\n+        }\n     }\n \n-    #[test]\n-    fn normalize9() {\n-        let actual = normalize(~\"a/b/../../..\");\n-        let expected = ~\"..\";\n-        assert actual == expected;\n+    pure fn dir_path() -> WindowsPath {\n+        if self.components.len() != 0 {\n+            self.pop()\n+        } else {\n+            copy self\n+        }\n     }\n \n-    #[test]\n-    fn normalize10() {\n-        let actual = normalize(~\"/a/b/c/../d/./../../e/\");\n-        let expected = ~\"/a/e/\";\n-        log(error, actual);\n-        assert actual == expected;\n+    pure fn file_path() -> WindowsPath {\n+        let cs = match self.filename() {\n+          None => ~[],\n+          Some(ref f) => ~[copy *f]\n+        };\n+        return WindowsPath { host: None,\n+                             device: None,\n+                             is_absolute: false,\n+                             components: cs }\n     }\n \n-    #[test]\n-    fn normalize11() {\n-        let actual = normalize(~\"/a/..\");\n-        let expected = ~\"/\";\n-        assert actual == expected;\n+    pure fn push_rel(other: &WindowsPath) -> WindowsPath {\n+        assert !other.is_absolute;\n+        self.push_many(other.components)\n     }\n \n-    #[test]\n-    #[cfg(windows)]\n-    fn normalize12() {\n-        let actual = normalize(~\"C:/whatever\");\n-        let expected = ~\"C:/whatever\";\n-        log(error, actual);\n-        assert actual == expected;\n+    pure fn push_many(cs: &[~str]) -> WindowsPath {\n+        return WindowsPath { components: normalize(self.components + cs),\n+                            ..self }\n     }\n \n-    #[test]\n-    #[cfg(windows)]\n-    fn path_is_absolute_win32() {\n-        assert path_is_absolute(~\"C:/whatever\");\n+    pure fn push(s: &str) -> WindowsPath {\n+        let mut cs = self.components;\n+        unchecked { vec::push(cs, move str::from_slice(s)); }\n+        cs = normalize(cs);\n+        return WindowsPath { components: move cs,\n+                             ..self }\n     }\n \n-    #[test]\n-    fn splitext_empty() {\n-        let (base, ext) = splitext(~\"\");\n-        assert base == ~\"\";\n-        assert ext == ~\"\";\n+    pure fn pop() -> WindowsPath {\n+        let mut cs = copy self.components;\n+        if cs.len() != 0 {\n+            unchecked { vec::pop(cs); }\n+        }\n+        return WindowsPath { components: move cs, ..self }\n     }\n+}\n \n-    #[test]\n-    fn splitext_ext() {\n-        let (base, ext) = splitext(~\"grum.exe\");\n-        assert base == ~\"grum\";\n-        assert ext == ~\".exe\";\n+\n+pure fn normalize(components: &[~str]) -> ~[~str] {\n+    let mut cs = ~[];\n+    unchecked {\n+        for components.each |c| {\n+            unchecked {\n+                if c == ~\".\" && components.len() > 1 { again; }\n+                if c == ~\"..\" && cs.len() != 0 {\n+                    vec::pop(cs);\n+                    again;\n+                }\n+                vec::push(cs, copy c);\n+            }\n+        }\n     }\n+    cs\n+}\n+\n+mod posix {\n \n     #[test]\n-    fn splitext_noext() {\n-        let (base, ext) = splitext(~\"grum\");\n-        assert base == ~\"grum\";\n-        assert ext == ~\"\";\n+    fn test_posix_paths() {\n+        fn mk(s: &str) -> PosixPath { from_str::<PosixPath>(s) }\n+        fn t(wp: &PosixPath, s: &str) {\n+            let ss = wp.to_str();\n+            let sss = str::from_slice(s);\n+            if (ss != sss) {\n+                debug!(\"got %s\", ss);\n+                debug!(\"expected %s\", sss);\n+                assert ss == sss;\n+            }\n+        }\n+\n+        t(&(mk(\"hi\")), \"hi\");\n+        t(&(mk(\"/lib\")), \"/lib\");\n+        t(&(mk(\"hi/there\")), \"hi/there\");\n+        t(&(mk(\"hi/there.txt\")), \"hi/there.txt\");\n+\n+        t(&(mk(\"hi/there.txt\")), \"hi/there.txt\");\n+        t(&(mk(\"hi/there.txt\")\n+           .with_filetype(\"\")), \"hi/there\");\n+\n+        t(&(mk(\"/a/b/c/there.txt\")\n+            .with_dirname(\"hi\")), \"hi/there.txt\");\n+\n+        t(&(mk(\"hi/there.txt\")\n+            .with_dirname(\".\")), \"there.txt\");\n+\n+        t(&(mk(\"a/b/../c/././/../foo.txt/\")),\n+          \"a/foo.txt\");\n+\n+        t(&(mk(\"a/b/c\")\n+            .push(\"..\")), \"a/b\");\n+\n+        t(&(mk(\"there.txt\")\n+            .with_filetype(\"o\")), \"there.o\");\n+\n+        t(&(mk(\"hi/there.txt\")\n+            .with_filetype(\"o\")), \"hi/there.o\");\n+\n+        t(&(mk(\"hi/there.txt\")\n+            .with_filetype(\"o\")\n+            .with_dirname(\"/usr/lib\")),\n+          \"/usr/lib/there.o\");\n+\n+        t(&(mk(\"hi/there.txt\")\n+            .with_filetype(\"o\")\n+            .with_dirname(\"/usr/lib/\")),\n+          \"/usr/lib/there.o\");\n+\n+        t(&(mk(\"hi/there.txt\")\n+            .with_filetype(\"o\")\n+            .with_dirname(\"/usr//lib//\")),\n+            \"/usr/lib/there.o\");\n+\n+        t(&(mk(\"/usr/bin/rust\")\n+            .push_many([~\"lib\", ~\"thingy.so\"])\n+            .with_filestem(\"librustc\")),\n+          \"/usr/bin/rust/lib/librustc.so\");\n+\n     }\n \n-    #[test]\n-    fn splitext_dotfile() {\n-        let (base, ext) = splitext(~\".grum\");\n-        assert base == ~\".grum\";\n-        assert ext == ~\"\";\n+}\n+\n+// Various windows helpers, and tests for the impl.\n+mod windows {\n+\n+    #[inline(always)]\n+    pure fn is_sep(u: u8) -> bool {\n+        u == '/' as u8 || u == '\\\\' as u8\n     }\n \n-    #[test]\n-    fn splitext_path_ext() {\n-        let (base, ext) = splitext(~\"oh/grum.exe\");\n-        assert base == ~\"oh/grum\";\n-        assert ext == ~\".exe\";\n+    pure fn extract_unc_prefix(s: &str) -> Option<(~str,~str)> {\n+        if (s.len() > 1 &&\n+            s[0] == '\\\\' as u8 &&\n+            s[1] == '\\\\' as u8) {\n+            let mut i = 2;\n+            while i < s.len() {\n+                if s[i] == '\\\\' as u8 {\n+                    let pre = s.slice(2, i);\n+                    let rest = s.slice(i, s.len());\n+                    return Some((pre, rest));\n+                }\n+                i += 1;\n+            }\n+        }\n+        None\n+    }\n+\n+    pure fn extract_drive_prefix(s: &str) -> Option<(~str,~str)> {\n+        unchecked {\n+            if (s.len() > 1 &&\n+                libc::isalpha(s[0] as libc::c_int) != 0 &&\n+                s[1] == ':' as u8) {\n+                let rest = if s.len() == 2 {\n+                    ~\"\"\n+                } else {\n+                    s.slice(2, s.len())\n+                };\n+                return Some((s.slice(0,1), rest));\n+            }\n+            None\n+        }\n     }\n \n     #[test]\n-    fn splitext_path_noext() {\n-        let (base, ext) = splitext(~\"oh/grum\");\n-        assert base == ~\"oh/grum\";\n-        assert ext == ~\"\";\n+    fn test_extract_unc_prefixes() {\n+        assert extract_unc_prefix(\"\\\\\\\\\").is_none();\n+        assert extract_unc_prefix(\"\\\\\\\\hi\").is_none();\n+        assert extract_unc_prefix(\"\\\\\\\\hi\\\\\") == Some((~\"hi\", ~\"\\\\\"));\n+        assert extract_unc_prefix(\"\\\\\\\\hi\\\\there\") ==\n+            Some((~\"hi\", ~\"\\\\there\"));\n+        assert extract_unc_prefix(\"\\\\\\\\hi\\\\there\\\\friends.txt\") ==\n+            Some((~\"hi\", ~\"\\\\there\\\\friends.txt\"));\n     }\n \n     #[test]\n-    fn splitext_dot_in_path() {\n-        let (base, ext) = splitext(~\"oh.my/grum\");\n-        assert base == ~\"oh.my/grum\";\n-        assert ext == ~\"\";\n+    fn test_extract_drive_prefixes() {\n+        assert extract_drive_prefix(\"c\").is_none();\n+        assert extract_drive_prefix(\"c:\") == Some((~\"c\", ~\"\"));\n+        assert extract_drive_prefix(\"d:\") == Some((~\"d\", ~\"\"));\n+        assert extract_drive_prefix(\"z:\") == Some((~\"z\", ~\"\"));\n+        assert extract_drive_prefix(\"c:\\\\hi\") == Some((~\"c\", ~\"\\\\hi\"));\n+        assert extract_drive_prefix(\"d:hi\") == Some((~\"d\", ~\"hi\"));\n+        assert extract_drive_prefix(\"c:hi\\\\there.txt\") ==\n+            Some((~\"c\", ~\"hi\\\\there.txt\"));\n+        assert extract_drive_prefix(\"c:\\\\hi\\\\there.txt\") ==\n+            Some((~\"c\", ~\"\\\\hi\\\\there.txt\"));\n     }\n \n     #[test]\n-    fn splitext_nobasename() {\n-        let (base, ext) = splitext(~\"oh.my/\");\n-        assert base == ~\"oh.my/\";\n-        assert ext == ~\"\";\n+    fn test_windows_paths() {\n+        fn mk(s: &str) -> WindowsPath { from_str::<WindowsPath>(s) }\n+        fn t(wp: &WindowsPath, s: &str) {\n+            let ss = wp.to_str();\n+            let sss = str::from_slice(s);\n+            if (ss != sss) {\n+                debug!(\"got %s\", ss);\n+                debug!(\"expected %s\", sss);\n+                assert ss == sss;\n+            }\n+        }\n+\n+        t(&(mk(\"hi\")), \"hi\");\n+        t(&(mk(\"hi/there\")), \"hi\\\\there\");\n+        t(&(mk(\"hi/there.txt\")), \"hi\\\\there.txt\");\n+\n+        t(&(mk(\"there.txt\")\n+            .with_filetype(\"o\")), \"there.o\");\n+\n+        t(&(mk(\"hi/there.txt\")\n+            .with_filetype(\"o\")), \"hi\\\\there.o\");\n+\n+        t(&(mk(\"hi/there.txt\")\n+            .with_filetype(\"o\")\n+            .with_dirname(\"c:\\\\program files A\")),\n+          \"c:\\\\program files A\\\\there.o\");\n+\n+        t(&(mk(\"hi/there.txt\")\n+            .with_filetype(\"o\")\n+            .with_dirname(\"c:\\\\program files B\\\\\")),\n+          \"c:\\\\program files B\\\\there.o\");\n+\n+        t(&(mk(\"hi/there.txt\")\n+            .with_filetype(\"o\")\n+            .with_dirname(\"c:\\\\program files C\\\\/\")),\n+            \"c:\\\\program files C\\\\there.o\");\n+\n+        t(&(mk(\"c:\\\\program files (x86)\\\\rust\")\n+            .push_many([~\"lib\", ~\"thingy.dll\"])\n+            .with_filename(\"librustc.dll\")),\n+          \"c:\\\\program files (x86)\\\\rust\\\\lib\\\\librustc.dll\");\n+\n     }\n-}\n \n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n+}"}, {"sha": "235dd686a1db656dc0b76943bdc219ae6ddabe24", "filename": "src/libcore/path2.rs", "status": "removed", "additions": 0, "deletions": 577, "changes": 577, "blob_url": "https://github.com/rust-lang/rust/blob/cb8ecd79849160d8cff2eff8b070efd7f9a3b9a7/src%2Flibcore%2Fpath2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb8ecd79849160d8cff2eff8b070efd7f9a3b9a7/src%2Flibcore%2Fpath2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath2.rs?ref=cb8ecd79849160d8cff2eff8b070efd7f9a3b9a7", "patch": "@@ -1,577 +0,0 @@\n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n-struct WindowsPath {\n-    host: Option<~str>;\n-    device: Option<~str>;\n-    is_absolute: bool;\n-    components: ~[~str];\n-}\n-\n-struct PosixPath {\n-    is_absolute: bool;\n-    components: ~[~str];\n-}\n-\n-trait GenericPath {\n-\n-    static pure fn from_str((&str)) -> self;\n-\n-    pure fn dirname() -> ~str;\n-    pure fn filename() -> Option<~str>;\n-    pure fn filestem() -> Option<~str>;\n-    pure fn filetype() -> Option<~str>;\n-\n-    pure fn with_dirname((&str)) -> self;\n-    pure fn with_filename((&str)) -> self;\n-    pure fn with_filestem((&str)) -> self;\n-    pure fn with_filetype((&str)) -> self;\n-\n-    pure fn push((&str)) -> self;\n-    pure fn push_rel((&self)) -> self;\n-    pure fn push_many((&[~str])) -> self;\n-    pure fn pop() -> self;\n-}\n-\n-#[cfg(windows)]\n-type Path = WindowsPath;\n-\n-#[cfg(windows)]\n-pure fn Path(s: &str) -> Path {\n-    from_str::<WindowsPath>(s)\n-}\n-\n-#[cfg(unix)]\n-type Path = PosixPath;\n-\n-#[cfg(unix)]\n-pure fn Path(s: &str) -> Path {\n-    from_str::<PosixPath>(s)\n-}\n-\n-impl PosixPath : ToStr {\n-    fn to_str() -> ~str {\n-        let mut s = ~\"\";\n-        if self.is_absolute {\n-            s += \"/\";\n-        }\n-        s + str::connect(self.components, \"/\")\n-    }\n-}\n-\n-// FIXME (#3227): when default methods in traits are working, de-duplicate\n-// PosixPath and WindowsPath, most of their methods are common.\n-impl PosixPath : GenericPath {\n-\n-    static pure fn from_str(s: &str) -> PosixPath {\n-        let mut components = str::split_nonempty(s, |c| c == '/');\n-        let is_absolute = (s.len() != 0 && s[0] == '/' as u8);\n-        return PosixPath { is_absolute: is_absolute,\n-                           components: normalize(components) }\n-    }\n-\n-    pure fn dirname() -> ~str {\n-        unchecked {\n-            let s = self.dir_path().to_str();\n-            if s.len() == 0 {\n-                ~\".\"\n-            } else {\n-                s\n-            }\n-        }\n-    }\n-\n-    pure fn filename() -> Option<~str> {\n-        match self.components.len() {\n-          0 => None,\n-          n => Some(copy self.components[n - 1])\n-        }\n-    }\n-\n-    pure fn filestem() -> Option<~str> {\n-        match self.filename() {\n-          None => None,\n-          Some(ref f) => {\n-            match str::rfind_char(*f, '.') {\n-              Some(p) => Some(f.slice(0, p)),\n-              None => Some(copy *f)\n-            }\n-          }\n-        }\n-    }\n-\n-    pure fn filetype() -> Option<~str> {\n-        match self.filename() {\n-          None => None,\n-          Some(ref f) => {\n-            match str::rfind_char(*f, '.') {\n-              Some(p) if p+1 < f.len() => Some(f.slice(p+1, f.len())),\n-              _ => None\n-            }\n-          }\n-        }\n-    }\n-\n-    pure fn with_dirname(d: &str) -> PosixPath {\n-        let dpath = from_str::<PosixPath>(d);\n-        match self.filename() {\n-          Some(ref f) => dpath.push(*f),\n-          None => dpath\n-        }\n-    }\n-\n-    pure fn with_filename(f: &str) -> PosixPath {\n-        unchecked {\n-            assert ! str::any(f, |c| windows::is_sep(c as u8));\n-            self.dir_path().push(f)\n-        }\n-    }\n-\n-    pure fn with_filestem(s: &str) -> PosixPath {\n-        match self.filetype() {\n-          None => self.with_filename(s),\n-          Some(ref t) =>\n-          self.with_filename(str::from_slice(s) + \".\" + *t)\n-        }\n-    }\n-\n-    pure fn with_filetype(t: &str) -> PosixPath {\n-        if t.len() == 0 {\n-            match self.filestem() {\n-              None => copy self,\n-              Some(s) => self.with_filename(s)\n-            }\n-        } else {\n-            let t = ~\".\" + str::from_slice(t);\n-            match self.filestem() {\n-              None => self.with_filename(t),\n-              Some(ref s) =>\n-              self.with_filename(*s + t)\n-            }\n-        }\n-    }\n-\n-    pure fn dir_path() -> PosixPath {\n-        if self.components.len() != 0 {\n-            self.pop()\n-        } else {\n-            copy self\n-        }\n-    }\n-\n-    pure fn file_path() -> PosixPath {\n-        let cs = match self.filename() {\n-          None => ~[],\n-          Some(ref f) => ~[copy *f]\n-        };\n-        return PosixPath { is_absolute: false,\n-                           components: cs }\n-    }\n-\n-    pure fn push_rel(other: &PosixPath) -> PosixPath {\n-        assert !other.is_absolute;\n-        self.push_many(other.components)\n-    }\n-\n-    pure fn push_many(cs: &[~str]) -> PosixPath {\n-        return PosixPath { components: normalize(self.components + cs),\n-                           ..self }\n-    }\n-\n-    pure fn push(s: &str) -> PosixPath {\n-        let mut cs = self.components;\n-        unchecked { vec::push(cs, move str::from_slice(s)); }\n-        cs = normalize(cs);\n-        return PosixPath { components: move cs,\n-                           ..self }\n-    }\n-\n-    pure fn pop() -> PosixPath {\n-        let mut cs = copy self.components;\n-        if cs.len() != 0 {\n-            unchecked { vec::pop(cs); }\n-        }\n-        return PosixPath { components: move cs, ..self }\n-    }\n-}\n-\n-\n-impl WindowsPath : ToStr {\n-    fn to_str() -> ~str {\n-        let mut s = ~\"\";\n-        match self.host {\n-          Some(h) => { s += \"\\\\\\\\\"; s += h; }\n-          None => { }\n-        }\n-        match self.device {\n-          Some(d) => { s += d; s += \":\"; }\n-          None => { }\n-        }\n-        if self.is_absolute {\n-            s += \"\\\\\";\n-        }\n-        s + str::connect(self.components, \"\\\\\")\n-    }\n-}\n-\n-\n-impl WindowsPath : GenericPath {\n-\n-    static pure fn from_str(s: &str) -> WindowsPath {\n-        let host;\n-        let device;\n-        let rest;\n-\n-        match windows::extract_drive_prefix(s) {\n-          Some((ref d, ref r)) => {\n-            host = None;\n-            device = Some(copy *d);\n-            rest = copy *r;\n-          }\n-          None => {\n-            match windows::extract_unc_prefix(s) {\n-              Some((ref h, ref r)) => {\n-                host = Some(copy *h);\n-                device = None;\n-                rest = copy *r;\n-              }\n-              None => {\n-                host = None;\n-                device = None;\n-                rest = str::from_slice(s);\n-              }\n-            }\n-          }\n-        }\n-\n-        let mut components =\n-            str::split_nonempty(rest, |c| windows::is_sep(c as u8));\n-        let is_absolute = (rest.len() != 0 && windows::is_sep(rest[0]));\n-        return WindowsPath { host: host,\n-                             device: device,\n-                             is_absolute: is_absolute,\n-                             components: normalize(components) }\n-    }\n-\n-    pure fn dirname() -> ~str {\n-        unchecked {\n-            let s = self.dir_path().to_str();\n-            if s.len() == 0 {\n-                ~\".\"\n-            } else {\n-                s\n-            }\n-        }\n-    }\n-\n-    pure fn filename() -> Option<~str> {\n-        match self.components.len() {\n-          0 => None,\n-          n => Some(copy self.components[n - 1])\n-        }\n-    }\n-\n-    pure fn filestem() -> Option<~str> {\n-        match self.filename() {\n-          None => None,\n-          Some(ref f) => {\n-            match str::rfind_char(*f, '.') {\n-              Some(p) => Some(f.slice(0, p)),\n-              None => Some(copy *f)\n-            }\n-          }\n-        }\n-    }\n-\n-    pure fn filetype() -> Option<~str> {\n-        match self.filename() {\n-          None => None,\n-          Some(ref f) => {\n-            match str::rfind_char(*f, '.') {\n-              Some(p) if p+1 < f.len() => Some(f.slice(p+1, f.len())),\n-              _ => None\n-            }\n-          }\n-        }\n-    }\n-\n-    pure fn with_dirname(d: &str) -> WindowsPath {\n-        let dpath = from_str::<WindowsPath>(d);\n-        match self.filename() {\n-          Some(ref f) => dpath.push(*f),\n-          None => dpath\n-        }\n-    }\n-\n-    pure fn with_filename(f: &str) -> WindowsPath {\n-        assert ! str::any(f, |c| windows::is_sep(c as u8));\n-        self.dir_path().push(f)\n-    }\n-\n-    pure fn with_filestem(s: &str) -> WindowsPath {\n-        match self.filetype() {\n-          None => self.with_filename(s),\n-          Some(ref t) =>\n-          self.with_filename(str::from_slice(s) + \".\" + *t)\n-        }\n-    }\n-\n-    pure fn with_filetype(t: &str) -> WindowsPath {\n-        if t.len() == 0 {\n-            match self.filestem() {\n-              None => copy self,\n-              Some(s) => self.with_filename(s)\n-            }\n-        } else {\n-            let t = ~\".\" + str::from_slice(t);\n-            match self.filestem() {\n-              None => self.with_filename(t),\n-              Some(ref s) =>\n-              self.with_filename(*s + t)\n-            }\n-        }\n-    }\n-\n-    pure fn dir_path() -> WindowsPath {\n-        if self.components.len() != 0 {\n-            self.pop()\n-        } else {\n-            copy self\n-        }\n-    }\n-\n-    pure fn file_path() -> WindowsPath {\n-        let cs = match self.filename() {\n-          None => ~[],\n-          Some(ref f) => ~[copy *f]\n-        };\n-        return WindowsPath { host: None,\n-                             device: None,\n-                             is_absolute: false,\n-                             components: cs }\n-    }\n-\n-    pure fn push_rel(other: &WindowsPath) -> WindowsPath {\n-        assert !other.is_absolute;\n-        self.push_many(other.components)\n-    }\n-\n-    pure fn push_many(cs: &[~str]) -> WindowsPath {\n-        return WindowsPath { components: normalize(self.components + cs),\n-                            ..self }\n-    }\n-\n-    pure fn push(s: &str) -> WindowsPath {\n-        let mut cs = self.components;\n-        unchecked { vec::push(cs, move str::from_slice(s)); }\n-        cs = normalize(cs);\n-        return WindowsPath { components: move cs,\n-                             ..self }\n-    }\n-\n-    pure fn pop() -> WindowsPath {\n-        let mut cs = copy self.components;\n-        if cs.len() != 0 {\n-            unchecked { vec::pop(cs); }\n-        }\n-        return WindowsPath { components: move cs, ..self }\n-    }\n-}\n-\n-\n-pure fn normalize(components: &[~str]) -> ~[~str] {\n-    let mut cs = ~[];\n-    unchecked {\n-        for components.each |c| {\n-            unchecked {\n-                if c == ~\".\" && components.len() > 1 { again; }\n-                if c == ~\"..\" && cs.len() != 0 {\n-                    vec::pop(cs);\n-                    again;\n-                }\n-                vec::push(cs, copy c);\n-            }\n-        }\n-    }\n-    cs\n-}\n-\n-mod posix {\n-\n-    #[test]\n-    fn test_posix_paths() {\n-        fn mk(s: &str) -> PosixPath { from_str::<PosixPath>(s) }\n-        fn t(wp: &PosixPath, s: &str) {\n-            let ss = wp.to_str();\n-            let sss = str::from_slice(s);\n-            if (ss != sss) {\n-                debug!(\"got %s\", ss);\n-                debug!(\"expected %s\", sss);\n-                assert ss == sss;\n-            }\n-        }\n-\n-        t(&(mk(\"hi\")), \"hi\");\n-        t(&(mk(\"/lib\")), \"/lib\");\n-        t(&(mk(\"hi/there\")), \"hi/there\");\n-        t(&(mk(\"hi/there.txt\")), \"hi/there.txt\");\n-\n-        t(&(mk(\"hi/there.txt\")), \"hi/there.txt\");\n-        t(&(mk(\"hi/there.txt\")\n-           .with_filetype(\"\")), \"hi/there\");\n-\n-        t(&(mk(\"/a/b/c/there.txt\")\n-            .with_dirname(\"hi\")), \"hi/there.txt\");\n-\n-        t(&(mk(\"hi/there.txt\")\n-            .with_dirname(\".\")), \"there.txt\");\n-\n-        t(&(mk(\"a/b/../c/././/../foo.txt/\")),\n-          \"a/foo.txt\");\n-\n-        t(&(mk(\"a/b/c\")\n-            .push(\"..\")), \"a/b\");\n-\n-        t(&(mk(\"there.txt\")\n-            .with_filetype(\"o\")), \"there.o\");\n-\n-        t(&(mk(\"hi/there.txt\")\n-            .with_filetype(\"o\")), \"hi/there.o\");\n-\n-        t(&(mk(\"hi/there.txt\")\n-            .with_filetype(\"o\")\n-            .with_dirname(\"/usr/lib\")),\n-          \"/usr/lib/there.o\");\n-\n-        t(&(mk(\"hi/there.txt\")\n-            .with_filetype(\"o\")\n-            .with_dirname(\"/usr/lib/\")),\n-          \"/usr/lib/there.o\");\n-\n-        t(&(mk(\"hi/there.txt\")\n-            .with_filetype(\"o\")\n-            .with_dirname(\"/usr//lib//\")),\n-            \"/usr/lib/there.o\");\n-\n-        t(&(mk(\"/usr/bin/rust\")\n-            .push_many([~\"lib\", ~\"thingy.so\"])\n-            .with_filestem(\"librustc\")),\n-          \"/usr/bin/rust/lib/librustc.so\");\n-\n-    }\n-\n-}\n-\n-// Various windows helpers, and tests for the impl.\n-mod windows {\n-\n-    #[inline(always)]\n-    pure fn is_sep(u: u8) -> bool {\n-        u == '/' as u8 || u == '\\\\' as u8\n-    }\n-\n-    pure fn extract_unc_prefix(s: &str) -> Option<(~str,~str)> {\n-        if (s.len() > 1 &&\n-            s[0] == '\\\\' as u8 &&\n-            s[1] == '\\\\' as u8) {\n-            let mut i = 2;\n-            while i < s.len() {\n-                if s[i] == '\\\\' as u8 {\n-                    let pre = s.slice(2, i);\n-                    let rest = s.slice(i, s.len());\n-                    return Some((pre, rest));\n-                }\n-                i += 1;\n-            }\n-        }\n-        None\n-    }\n-\n-    pure fn extract_drive_prefix(s: &str) -> Option<(~str,~str)> {\n-        unchecked {\n-            if (s.len() > 1 &&\n-                libc::isalpha(s[0] as libc::c_int) != 0 &&\n-                s[1] == ':' as u8) {\n-                let rest = if s.len() == 2 {\n-                    ~\"\"\n-                } else {\n-                    s.slice(2, s.len())\n-                };\n-                return Some((s.slice(0,1), rest));\n-            }\n-            None\n-        }\n-    }\n-\n-    #[test]\n-    fn test_extract_unc_prefixes() {\n-        assert extract_unc_prefix(\"\\\\\\\\\").is_none();\n-        assert extract_unc_prefix(\"\\\\\\\\hi\").is_none();\n-        assert extract_unc_prefix(\"\\\\\\\\hi\\\\\") == Some((~\"hi\", ~\"\\\\\"));\n-        assert extract_unc_prefix(\"\\\\\\\\hi\\\\there\") ==\n-            Some((~\"hi\", ~\"\\\\there\"));\n-        assert extract_unc_prefix(\"\\\\\\\\hi\\\\there\\\\friends.txt\") ==\n-            Some((~\"hi\", ~\"\\\\there\\\\friends.txt\"));\n-    }\n-\n-    #[test]\n-    fn test_extract_drive_prefixes() {\n-        assert extract_drive_prefix(\"c\").is_none();\n-        assert extract_drive_prefix(\"c:\") == Some((~\"c\", ~\"\"));\n-        assert extract_drive_prefix(\"d:\") == Some((~\"d\", ~\"\"));\n-        assert extract_drive_prefix(\"z:\") == Some((~\"z\", ~\"\"));\n-        assert extract_drive_prefix(\"c:\\\\hi\") == Some((~\"c\", ~\"\\\\hi\"));\n-        assert extract_drive_prefix(\"d:hi\") == Some((~\"d\", ~\"hi\"));\n-        assert extract_drive_prefix(\"c:hi\\\\there.txt\") ==\n-            Some((~\"c\", ~\"hi\\\\there.txt\"));\n-        assert extract_drive_prefix(\"c:\\\\hi\\\\there.txt\") ==\n-            Some((~\"c\", ~\"\\\\hi\\\\there.txt\"));\n-    }\n-\n-    #[test]\n-    fn test_windows_paths() {\n-        fn mk(s: &str) -> WindowsPath { from_str::<WindowsPath>(s) }\n-        fn t(wp: &WindowsPath, s: &str) {\n-            let ss = wp.to_str();\n-            let sss = str::from_slice(s);\n-            if (ss != sss) {\n-                debug!(\"got %s\", ss);\n-                debug!(\"expected %s\", sss);\n-                assert ss == sss;\n-            }\n-        }\n-\n-        t(&(mk(\"hi\")), \"hi\");\n-        t(&(mk(\"hi/there\")), \"hi\\\\there\");\n-        t(&(mk(\"hi/there.txt\")), \"hi\\\\there.txt\");\n-\n-        t(&(mk(\"there.txt\")\n-            .with_filetype(\"o\")), \"there.o\");\n-\n-        t(&(mk(\"hi/there.txt\")\n-            .with_filetype(\"o\")), \"hi\\\\there.o\");\n-\n-        t(&(mk(\"hi/there.txt\")\n-            .with_filetype(\"o\")\n-            .with_dirname(\"c:\\\\program files A\")),\n-          \"c:\\\\program files A\\\\there.o\");\n-\n-        t(&(mk(\"hi/there.txt\")\n-            .with_filetype(\"o\")\n-            .with_dirname(\"c:\\\\program files B\\\\\")),\n-          \"c:\\\\program files B\\\\there.o\");\n-\n-        t(&(mk(\"hi/there.txt\")\n-            .with_filetype(\"o\")\n-            .with_dirname(\"c:\\\\program files C\\\\/\")),\n-            \"c:\\\\program files C\\\\there.o\");\n-\n-        t(&(mk(\"c:\\\\program files (x86)\\\\rust\")\n-            .push_many([~\"lib\", ~\"thingy.dll\"])\n-            .with_filename(\"librustc.dll\")),\n-          \"c:\\\\program files (x86)\\\\rust\\\\lib\\\\librustc.dll\");\n-\n-    }\n-\n-}"}]}