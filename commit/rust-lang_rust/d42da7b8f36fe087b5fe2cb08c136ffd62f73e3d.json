{"sha": "d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0MmRhN2I4ZjM2ZmUwODdiNWZlMmNiMDhjMTM2ZmZkNjJmNzNlM2Q=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-05T21:50:13Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-05T21:50:13Z"}, "message": "Rewrite TypeId computation to not miss anything and work cross-crate.", "tree": {"sha": "880a26cbd05d0375625c751a33b3f298541e2298", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/880a26cbd05d0375625c751a33b3f298541e2298"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d", "html_url": "https://github.com/rust-lang/rust/commit/d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "html_url": "https://github.com/rust-lang/rust/commit/b30eff7ba72a78e31acd61a2b6931919a0ad62e8"}], "stats": {"total": 439, "additions": 248, "deletions": 191}, "files": [{"sha": "d9ffe36ea47fbe3610cb927d346cdf4d7a3008d0", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 146, "deletions": 143, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d", "patch": "@@ -10,21 +10,22 @@\n \n //! misc. type-system utilities too small to deserve their own file\n \n-use hir::svh::Svh;\n use hir::def_id::DefId;\n use ty::subst;\n use infer::InferCtxt;\n use hir::pat_util;\n use traits::{self, ProjectionMode};\n use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n use ty::{Disr, ParameterEnvironment};\n+use ty::fold::TypeVisitor;\n use ty::layout::{Layout, LayoutError};\n use ty::TypeVariants::*;\n \n use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n \n use std::cmp;\n use std::hash::{Hash, SipHasher, Hasher};\n+use std::intrinsics;\n use syntax::ast::{self, Name};\n use syntax::attr::{self, SignedInt, UnsignedInt};\n use syntax_pos::Span;\n@@ -350,148 +351,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Creates a hash of the type `Ty` which will be the same no matter what crate\n     /// context it's calculated within. This is used by the `type_id` intrinsic.\n-    pub fn hash_crate_independent(self, ty: Ty<'tcx>, svh: &Svh) -> u64 {\n-        let mut state = SipHasher::new();\n-        helper(self, ty, svh, &mut state);\n-        return state.finish();\n-\n-        fn helper<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                  ty: Ty<'tcx>, svh: &Svh,\n-                                  state: &mut SipHasher) {\n-            macro_rules! byte { ($b:expr) => { ($b as u8).hash(state) } }\n-            macro_rules! hash { ($e:expr) => { $e.hash(state) }  }\n-\n-            let region = |state: &mut SipHasher, r: ty::Region| {\n-                match r {\n-                    ty::ReStatic | ty::ReErased => {}\n-                    ty::ReLateBound(db, ty::BrAnon(i)) => {\n-                        db.hash(state);\n-                        i.hash(state);\n-                    }\n-                    ty::ReEmpty |\n-                    ty::ReEarlyBound(..) |\n-                    ty::ReLateBound(..) |\n-                    ty::ReFree(..) |\n-                    ty::ReScope(..) |\n-                    ty::ReVar(..) |\n-                    ty::ReSkolemized(..) => {\n-                        bug!(\"unexpected region found when hashing a type\")\n-                    }\n-                }\n-            };\n-            let did = |state: &mut SipHasher, did: DefId| {\n-                let h = if did.is_local() {\n-                    svh.clone()\n-                } else {\n-                    tcx.sess.cstore.crate_hash(did.krate)\n-                };\n-                h.hash(state);\n-                did.index.hash(state);\n-            };\n-            let mt = |state: &mut SipHasher, mt: TypeAndMut| {\n-                mt.mutbl.hash(state);\n-            };\n-            let fn_sig = |state: &mut SipHasher, sig: &ty::Binder<ty::FnSig<'tcx>>| {\n-                let sig = tcx.anonymize_late_bound_regions(sig).0;\n-                for a in &sig.inputs { helper(tcx, *a, svh, state); }\n-                if let ty::FnConverging(output) = sig.output {\n-                    helper(tcx, output, svh, state);\n-                }\n-            };\n-            ty.maybe_walk(|ty| {\n-                match ty.sty {\n-                    TyBool => byte!(2),\n-                    TyChar => byte!(3),\n-                    TyInt(i) => {\n-                        byte!(4);\n-                        hash!(i);\n-                    }\n-                    TyUint(u) => {\n-                        byte!(5);\n-                        hash!(u);\n-                    }\n-                    TyFloat(f) => {\n-                        byte!(6);\n-                        hash!(f);\n-                    }\n-                    TyStr => {\n-                        byte!(7);\n-                    }\n-                    TyEnum(d, _) => {\n-                        byte!(8);\n-                        did(state, d.did);\n-                    }\n-                    TyBox(_) => {\n-                        byte!(9);\n-                    }\n-                    TyArray(_, n) => {\n-                        byte!(10);\n-                        n.hash(state);\n-                    }\n-                    TySlice(_) => {\n-                        byte!(11);\n-                    }\n-                    TyRawPtr(m) => {\n-                        byte!(12);\n-                        mt(state, m);\n-                    }\n-                    TyRef(r, m) => {\n-                        byte!(13);\n-                        region(state, *r);\n-                        mt(state, m);\n-                    }\n-                    TyFnDef(def_id, _, _) => {\n-                        byte!(14);\n-                        hash!(def_id);\n-                    }\n-                    TyFnPtr(ref b) => {\n-                        byte!(15);\n-                        hash!(b.unsafety);\n-                        hash!(b.abi);\n-                        fn_sig(state, &b.sig);\n-                        return false;\n-                    }\n-                    TyTrait(ref data) => {\n-                        byte!(17);\n-                        did(state, data.principal_def_id());\n-                        hash!(data.bounds);\n-\n-                        let principal = tcx.anonymize_late_bound_regions(&data.principal).0;\n-                        for subty in &principal.substs.types {\n-                            helper(tcx, subty, svh, state);\n-                        }\n-\n-                        return false;\n-                    }\n-                    TyStruct(d, _) => {\n-                        byte!(18);\n-                        did(state, d.did);\n-                    }\n-                    TyTuple(ref inner) => {\n-                        byte!(19);\n-                        hash!(inner.len());\n-                    }\n-                    TyParam(p) => {\n-                        byte!(20);\n-                        hash!(p.space);\n-                        hash!(p.idx);\n-                        hash!(p.name.as_str());\n-                    }\n-                    TyInfer(_) => bug!(),\n-                    TyError => byte!(21),\n-                    TyClosure(d, _) => {\n-                        byte!(22);\n-                        did(state, d);\n-                    }\n-                    TyProjection(ref data) => {\n-                        byte!(23);\n-                        did(state, data.trait_ref.def_id);\n-                        hash!(data.item_name.as_str());\n-                    }\n-                }\n-                true\n-            });\n-        }\n+    pub fn type_id_hash(self, ty: Ty<'tcx>) -> u64 {\n+        let mut hasher = TypeIdHasher {\n+            tcx: self,\n+            state: SipHasher::new()\n+        };\n+        hasher.visit_ty(ty);\n+        hasher.state.finish()\n     }\n \n     /// Returns true if this ADT is a dtorck type.\n@@ -525,6 +391,143 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n+struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    state: SipHasher\n+}\n+\n+impl<'a, 'gcx, 'tcx> TypeIdHasher<'a, 'gcx, 'tcx> {\n+    fn hash<T: Hash>(&mut self, x: T) {\n+        x.hash(&mut self.state);\n+    }\n+\n+    fn hash_discriminant_u8<T>(&mut self, x: &T) {\n+        let v = unsafe {\n+            intrinsics::discriminant_value(x)\n+        };\n+        let b = v as u8;\n+        assert_eq!(v, b as u64);\n+        self.hash(b)\n+    }\n+\n+    fn def_id(&mut self, did: DefId) {\n+        // Hash the crate identification information.\n+        let name = self.tcx.crate_name(did.krate);\n+        let disambiguator = self.tcx.crate_disambiguator(did.krate);\n+        self.hash((name, disambiguator));\n+\n+        // Hash the item path within that crate.\n+        // FIXME(#35379) This should use a deterministic\n+        // DefPath hashing mechanism, not the DefIndex.\n+        self.hash(did.index);\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx> {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+        // Distinguish between the Ty variants uniformly.\n+        self.hash_discriminant_u8(&ty.sty);\n+\n+        match ty.sty {\n+            TyInt(i) => self.hash(i),\n+            TyUint(u) => self.hash(u),\n+            TyFloat(f) => self.hash(f),\n+            TyStruct(d, _) |\n+            TyEnum(d, _) => self.def_id(d.did),\n+            TyArray(_, n) => self.hash(n),\n+            TyRawPtr(m) |\n+            TyRef(_, m) => self.hash(m.mutbl),\n+            TyClosure(def_id, _) |\n+            TyFnDef(def_id, _, _) => self.def_id(def_id),\n+            TyFnPtr(f) => {\n+                self.hash(f.unsafety);\n+                self.hash(f.abi);\n+                self.hash(f.sig.variadic());\n+            }\n+            TyTrait(ref data) => {\n+                // Trait objects have a list of projection bounds\n+                // that are not guaranteed to be sorted in an order\n+                // that gets preserved across crates, so we need\n+                // to sort them again by the name, in string form.\n+\n+                // Hash the whole principal trait ref.\n+                self.def_id(data.principal_def_id());\n+                data.principal.visit_with(self);\n+\n+                // Hash region and builtin bounds.\n+                data.bounds.region_bound.visit_with(self);\n+                self.hash(data.bounds.builtin_bounds);\n+\n+                // Only projection bounds are left, sort and hash them.\n+                let mut projection_bounds: Vec<_> = data.bounds.projection_bounds\n+                                                        .iter()\n+                                                        .map(|b| (b.item_name().as_str(), b))\n+                                                        .collect();\n+                projection_bounds.sort_by_key(|&(ref name, _)| name.clone());\n+                for (name, bound) in projection_bounds {\n+                    self.def_id(bound.0.projection_ty.trait_ref.def_id);\n+                    self.hash(name);\n+                    bound.visit_with(self);\n+                }\n+\n+                // Bypass super_visit_with, we've visited everything.\n+                return false;\n+            }\n+            TyTuple(tys) => {\n+                self.hash(tys.len());\n+            }\n+            TyParam(p) => {\n+                self.hash(p.space);\n+                self.hash(p.idx);\n+                self.hash(p.name.as_str());\n+            }\n+            TyProjection(ref data) => {\n+                self.def_id(data.trait_ref.def_id);\n+                self.hash(data.item_name.as_str());\n+            }\n+            TyBool |\n+            TyChar |\n+            TyStr |\n+            TyBox(_) |\n+            TySlice(_) |\n+            TyError => {}\n+            TyInfer(_) => bug!()\n+        }\n+\n+        ty.super_visit_with(self)\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region) -> bool {\n+        match r {\n+            ty::ReStatic | ty::ReErased => {\n+                self.hash::<u32>(0);\n+            }\n+            ty::ReLateBound(db, ty::BrAnon(i)) => {\n+                assert!(db.depth > 0);\n+                self.hash::<u32>(db.depth);\n+                self.hash(i);\n+            }\n+            ty::ReEmpty |\n+            ty::ReEarlyBound(..) |\n+            ty::ReLateBound(..) |\n+            ty::ReFree(..) |\n+            ty::ReScope(..) |\n+            ty::ReVar(..) |\n+            ty::ReSkolemized(..) => {\n+                bug!(\"unexpected region found when hashing a type\")\n+            }\n+        }\n+        false\n+    }\n+\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, x: &ty::Binder<T>) -> bool {\n+        // Anonymize late-bound regions so that, for example:\n+        // `for<'a, b> fn(&'a &'b T)` and `for<'a, b> fn(&'b &'a T)`\n+        // result in the same TypeId (the two types are equivalent).\n+        self.tcx.anonymize_late_bound_regions(x).super_visit_with(self)\n+    }\n+}\n+\n impl<'a, 'tcx> ty::TyS<'tcx> {\n     fn impls_bound(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                    param_env: &ParameterEnvironment<'tcx>,"}, {"sha": "4980fad0cc37e676f3605bbcfdd667166e1681a7", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d", "patch": "@@ -406,9 +406,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             C_str_slice(ccx, ty_name)\n         }\n         (_, \"type_id\") => {\n-            let hash = ccx.tcx().hash_crate_independent(*substs.types.get(FnSpace, 0),\n-                                                        &ccx.link_meta().crate_hash);\n-            C_u64(ccx, hash)\n+            C_u64(ccx, ccx.tcx().type_id_hash(*substs.types.get(FnSpace, 0)))\n         }\n         (_, \"init_dropped\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);"}, {"sha": "42c0da6286bdca27f95692cd6b85c074ac6cc569", "filename": "src/test/run-pass/auxiliary/typeid-intrinsic-aux1.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d/src%2Ftest%2Frun-pass%2Fauxiliary%2Ftypeid-intrinsic-aux1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d/src%2Ftest%2Frun-pass%2Fauxiliary%2Ftypeid-intrinsic-aux1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Ftypeid-intrinsic-aux1.rs?ref=d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d", "patch": "@@ -21,14 +21,16 @@ pub struct E(Result<&'static str, isize>);\n pub type F = Option<isize>;\n pub type G = usize;\n pub type H = &'static str;\n+pub type I = Box<Fn()>;\n \n-pub unsafe fn id_A() -> TypeId { TypeId::of::<A>() }\n-pub unsafe fn id_B() -> TypeId { TypeId::of::<B>() }\n-pub unsafe fn id_C() -> TypeId { TypeId::of::<C>() }\n-pub unsafe fn id_D() -> TypeId { TypeId::of::<D>() }\n-pub unsafe fn id_E() -> TypeId { TypeId::of::<E>() }\n-pub unsafe fn id_F() -> TypeId { TypeId::of::<F>() }\n-pub unsafe fn id_G() -> TypeId { TypeId::of::<G>() }\n-pub unsafe fn id_H() -> TypeId { TypeId::of::<H>() }\n+pub fn id_A() -> TypeId { TypeId::of::<A>() }\n+pub fn id_B() -> TypeId { TypeId::of::<B>() }\n+pub fn id_C() -> TypeId { TypeId::of::<C>() }\n+pub fn id_D() -> TypeId { TypeId::of::<D>() }\n+pub fn id_E() -> TypeId { TypeId::of::<E>() }\n+pub fn id_F() -> TypeId { TypeId::of::<F>() }\n+pub fn id_G() -> TypeId { TypeId::of::<G>() }\n+pub fn id_H() -> TypeId { TypeId::of::<H>() }\n+pub fn id_I() -> TypeId { TypeId::of::<I>() }\n \n-pub unsafe fn foo<T: Any>() -> TypeId { TypeId::of::<T>() }\n+pub fn foo<T: Any>() -> TypeId { TypeId::of::<T>() }"}, {"sha": "42c0da6286bdca27f95692cd6b85c074ac6cc569", "filename": "src/test/run-pass/auxiliary/typeid-intrinsic-aux2.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d/src%2Ftest%2Frun-pass%2Fauxiliary%2Ftypeid-intrinsic-aux2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d/src%2Ftest%2Frun-pass%2Fauxiliary%2Ftypeid-intrinsic-aux2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Ftypeid-intrinsic-aux2.rs?ref=d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d", "patch": "@@ -21,14 +21,16 @@ pub struct E(Result<&'static str, isize>);\n pub type F = Option<isize>;\n pub type G = usize;\n pub type H = &'static str;\n+pub type I = Box<Fn()>;\n \n-pub unsafe fn id_A() -> TypeId { TypeId::of::<A>() }\n-pub unsafe fn id_B() -> TypeId { TypeId::of::<B>() }\n-pub unsafe fn id_C() -> TypeId { TypeId::of::<C>() }\n-pub unsafe fn id_D() -> TypeId { TypeId::of::<D>() }\n-pub unsafe fn id_E() -> TypeId { TypeId::of::<E>() }\n-pub unsafe fn id_F() -> TypeId { TypeId::of::<F>() }\n-pub unsafe fn id_G() -> TypeId { TypeId::of::<G>() }\n-pub unsafe fn id_H() -> TypeId { TypeId::of::<H>() }\n+pub fn id_A() -> TypeId { TypeId::of::<A>() }\n+pub fn id_B() -> TypeId { TypeId::of::<B>() }\n+pub fn id_C() -> TypeId { TypeId::of::<C>() }\n+pub fn id_D() -> TypeId { TypeId::of::<D>() }\n+pub fn id_E() -> TypeId { TypeId::of::<E>() }\n+pub fn id_F() -> TypeId { TypeId::of::<F>() }\n+pub fn id_G() -> TypeId { TypeId::of::<G>() }\n+pub fn id_H() -> TypeId { TypeId::of::<H>() }\n+pub fn id_I() -> TypeId { TypeId::of::<I>() }\n \n-pub unsafe fn foo<T:Any>() -> TypeId { TypeId::of::<T>() }\n+pub fn foo<T: Any>() -> TypeId { TypeId::of::<T>() }"}, {"sha": "aead8bc264d7ea43319651eecf6818206facea34", "filename": "src/test/run-pass/type-id-higher-rank-2.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d/src%2Ftest%2Frun-pass%2Ftype-id-higher-rank-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d/src%2Ftest%2Frun-pass%2Ftype-id-higher-rank-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-id-higher-rank-2.rs?ref=d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can't ignore lifetimes by going through Any.\n+\n+use std::any::Any;\n+\n+struct Foo<'a>(&'a str);\n+\n+fn good(s: &String) -> Foo { Foo(s) }\n+\n+fn bad1(s: String) -> Option<&'static str> {\n+    let a: Box<Any> = Box::new(good as fn(&String) -> Foo);\n+    a.downcast_ref::<fn(&String) -> Foo<'static>>().map(|f| f(&s).0)\n+}\n+\n+trait AsStr<'a, 'b> {\n+    fn get(&'a self) -> &'b str;\n+}\n+\n+impl<'a> AsStr<'a, 'a> for String {\n+   fn get(&'a self) -> &'a str { self }\n+}\n+\n+fn bad2(s: String) -> Option<&'static str> {\n+    let a: Box<Any> = Box::new(Box::new(s) as Box<for<'a> AsStr<'a, 'a>>);\n+    a.downcast_ref::<Box<for<'a> AsStr<'a, 'static>>>().map(|x| x.get())\n+}\n+\n+fn main() {\n+    assert_eq!(bad1(String::from(\"foo\")), None);\n+    assert_eq!(bad2(String::from(\"bar\")), None);\n+}"}, {"sha": "827b05c0801e1eb39b5650defc365315f411b3d3", "filename": "src/test/run-pass/type-id-higher-rank.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d/src%2Ftest%2Frun-pass%2Ftype-id-higher-rank.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d/src%2Ftest%2Frun-pass%2Ftype-id-higher-rank.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-id-higher-rank.rs?ref=d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d", "patch": "@@ -16,6 +16,9 @@\n \n use std::any::{Any, TypeId};\n \n+struct Struct<'a>(&'a ());\n+trait Trait<'a> {}\n+\n fn main() {\n     // Bare fns\n     {\n@@ -34,6 +37,14 @@ fn main() {\n         let e = TypeId::of::<for<'a> fn(fn(&'a isize) -> &'a isize)>();\n         let f = TypeId::of::<fn(for<'a> fn(&'a isize) -> &'a isize)>();\n         assert!(e != f);\n+\n+        // Make sure lifetime parameters of items are not ignored.\n+        let g = TypeId::of::<for<'a> fn(&'a Trait<'a>) -> Struct<'a>>();\n+        let h = TypeId::of::<for<'a> fn(&'a Trait<'a>) -> Struct<'static>>();\n+        let i = TypeId::of::<for<'a, 'b> fn(&'a Trait<'b>) -> Struct<'b>>();\n+        assert!(g != h);\n+        assert!(g != i);\n+        assert!(h != i);\n     }\n     // Boxed unboxed closures\n     {"}, {"sha": "e99a5f69af40f23c984301370f54297b6034de1f", "filename": "src/test/run-pass/typeid-intrinsic.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs?ref=d42da7b8f36fe087b5fe2cb08c136ffd62f73e3d", "patch": "@@ -23,36 +23,37 @@ struct A;\n struct Test;\n \n pub fn main() {\n-    unsafe {\n-        assert_eq!(TypeId::of::<other1::A>(), other1::id_A());\n-        assert_eq!(TypeId::of::<other1::B>(), other1::id_B());\n-        assert_eq!(TypeId::of::<other1::C>(), other1::id_C());\n-        assert_eq!(TypeId::of::<other1::D>(), other1::id_D());\n-        assert_eq!(TypeId::of::<other1::E>(), other1::id_E());\n-        assert_eq!(TypeId::of::<other1::F>(), other1::id_F());\n-        assert_eq!(TypeId::of::<other1::G>(), other1::id_G());\n-        assert_eq!(TypeId::of::<other1::H>(), other1::id_H());\n+    assert_eq!(TypeId::of::<other1::A>(), other1::id_A());\n+    assert_eq!(TypeId::of::<other1::B>(), other1::id_B());\n+    assert_eq!(TypeId::of::<other1::C>(), other1::id_C());\n+    assert_eq!(TypeId::of::<other1::D>(), other1::id_D());\n+    assert_eq!(TypeId::of::<other1::E>(), other1::id_E());\n+    assert_eq!(TypeId::of::<other1::F>(), other1::id_F());\n+    assert_eq!(TypeId::of::<other1::G>(), other1::id_G());\n+    assert_eq!(TypeId::of::<other1::H>(), other1::id_H());\n+    assert_eq!(TypeId::of::<other1::I>(), other1::id_I());\n \n-        assert_eq!(TypeId::of::<other2::A>(), other2::id_A());\n-        assert_eq!(TypeId::of::<other2::B>(), other2::id_B());\n-        assert_eq!(TypeId::of::<other2::C>(), other2::id_C());\n-        assert_eq!(TypeId::of::<other2::D>(), other2::id_D());\n-        assert_eq!(TypeId::of::<other2::E>(), other2::id_E());\n-        assert_eq!(TypeId::of::<other2::F>(), other2::id_F());\n-        assert_eq!(TypeId::of::<other2::G>(), other2::id_G());\n-        assert_eq!(TypeId::of::<other2::H>(), other2::id_H());\n+    assert_eq!(TypeId::of::<other2::A>(), other2::id_A());\n+    assert_eq!(TypeId::of::<other2::B>(), other2::id_B());\n+    assert_eq!(TypeId::of::<other2::C>(), other2::id_C());\n+    assert_eq!(TypeId::of::<other2::D>(), other2::id_D());\n+    assert_eq!(TypeId::of::<other2::E>(), other2::id_E());\n+    assert_eq!(TypeId::of::<other2::F>(), other2::id_F());\n+    assert_eq!(TypeId::of::<other2::G>(), other2::id_G());\n+    assert_eq!(TypeId::of::<other2::H>(), other2::id_H());\n+    assert_eq!(TypeId::of::<other1::I>(), other2::id_I());\n \n-        assert_eq!(other1::id_F(), other2::id_F());\n-        assert_eq!(other1::id_G(), other2::id_G());\n-        assert_eq!(other1::id_H(), other2::id_H());\n+    assert_eq!(other1::id_F(), other2::id_F());\n+    assert_eq!(other1::id_G(), other2::id_G());\n+    assert_eq!(other1::id_H(), other2::id_H());\n+    assert_eq!(other1::id_I(), other2::id_I());\n \n-        assert_eq!(TypeId::of::<isize>(), other2::foo::<isize>());\n-        assert_eq!(TypeId::of::<isize>(), other1::foo::<isize>());\n-        assert_eq!(other2::foo::<isize>(), other1::foo::<isize>());\n-        assert_eq!(TypeId::of::<A>(), other2::foo::<A>());\n-        assert_eq!(TypeId::of::<A>(), other1::foo::<A>());\n-        assert_eq!(other2::foo::<A>(), other1::foo::<A>());\n-    }\n+    assert_eq!(TypeId::of::<isize>(), other2::foo::<isize>());\n+    assert_eq!(TypeId::of::<isize>(), other1::foo::<isize>());\n+    assert_eq!(other2::foo::<isize>(), other1::foo::<isize>());\n+    assert_eq!(TypeId::of::<A>(), other2::foo::<A>());\n+    assert_eq!(TypeId::of::<A>(), other1::foo::<A>());\n+    assert_eq!(other2::foo::<A>(), other1::foo::<A>());\n \n     // sanity test of TypeId\n     let (a, b, c) = (TypeId::of::<usize>(), TypeId::of::<&'static str>(),"}]}