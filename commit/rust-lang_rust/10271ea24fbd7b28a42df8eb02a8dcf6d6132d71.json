{"sha": "10271ea24fbd7b28a42df8eb02a8dcf6d6132d71", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwMjcxZWEyNGZiZDdiMjhhNDJkZjhlYjAyYThkY2Y2ZDYxMzJkNzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-19T12:17:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-19T12:17:24Z"}, "message": "Auto merge of #38466 - sanxiyn:rollup, r=sanxiyn\n\nRollup of 9 pull requests\n\n- Successful merges: #38334, #38397, #38413, #38421, #38422, #38433, #38438, #38445, #38459\n- Failed merges:", "tree": {"sha": "4e6317a08c4c8cf2b0cbef21dd235222ccce77c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e6317a08c4c8cf2b0cbef21dd235222ccce77c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71", "html_url": "https://github.com/rust-lang/rust/commit/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e70415bd716cdbfaa7d7e849cb1d3b09254a7dcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e70415bd716cdbfaa7d7e849cb1d3b09254a7dcb", "html_url": "https://github.com/rust-lang/rust/commit/e70415bd716cdbfaa7d7e849cb1d3b09254a7dcb"}, {"sha": "05be48b18b896c16b36cf3f68c14c87b79081f94", "url": "https://api.github.com/repos/rust-lang/rust/commits/05be48b18b896c16b36cf3f68c14c87b79081f94", "html_url": "https://github.com/rust-lang/rust/commit/05be48b18b896c16b36cf3f68c14c87b79081f94"}], "stats": {"total": 811, "additions": 448, "deletions": 363}, "files": [{"sha": "c5684e69994ea86618740f82ff9ba62c4cae663b", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=10271ea24fbd7b28a42df8eb02a8dcf6d6132d71", "patch": "@@ -30,7 +30,7 @@ extern crate bootstrap;\n use std::env;\n use std::ffi::OsString;\n use std::path::PathBuf;\n-use std::process::Command;\n+use std::process::{Command, ExitStatus};\n \n fn main() {\n     let args = env::args_os().skip(1).collect::<Vec<_>>();\n@@ -180,8 +180,19 @@ fn main() {\n     }\n \n     // Actually run the compiler!\n-    std::process::exit(match cmd.status() {\n-        Ok(s) => s.code().unwrap_or(1),\n+    std::process::exit(match exec_cmd(&mut cmd) {\n+        Ok(s) => s.code().unwrap_or(0xfe),\n         Err(e) => panic!(\"\\n\\nfailed to run {:?}: {}\\n\\n\", cmd, e),\n     })\n }\n+\n+#[cfg(unix)]\n+fn exec_cmd(cmd: &mut Command) -> ::std::io::Result<ExitStatus> {\n+    use std::os::unix::process::CommandExt;\n+    Err(cmd.exec())\n+}\n+\n+#[cfg(not(unix))]\n+fn exec_cmd(cmd: &mut Command) -> ::std::io::Result<ExitStatus> {\n+    cmd.status()\n+}"}, {"sha": "18b465d85a12f74413e01ed908fedfcfeb8c8acf", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=10271ea24fbd7b28a42df8eb02a8dcf6d6132d71", "patch": "@@ -255,10 +255,44 @@ pub trait BuildHasher {\n     fn build_hasher(&self) -> Self::Hasher;\n }\n \n-/// A structure which implements `BuildHasher` for all `Hasher` types which also\n-/// implement `Default`.\n+/// The `BuildHasherDefault` structure is used in scenarios where one has a\n+/// type that implements [`Hasher`] and [`Default`], but needs that type to\n+/// implement [`BuildHasher`].\n ///\n-/// This struct is 0-sized and does not need construction.\n+/// This structure is zero-sized and does not need construction.\n+///\n+/// # Examples\n+///\n+/// Using `BuildHasherDefault` to specify a custom [`BuildHasher`] for\n+/// [`HashMap`]:\n+///\n+/// ```\n+/// use std::collections::HashMap;\n+/// use std::hash::{BuildHasherDefault, Hasher};\n+///\n+/// #[derive(Default)]\n+/// struct MyHasher;\n+///\n+/// impl Hasher for MyHasher {\n+///     fn write(&mut self, bytes: &[u8]) {\n+///         // Your hashing algorithm goes here!\n+///        unimplemented!()\n+///     }\n+///\n+///     fn finish(&self) -> u64 {\n+///         // Your hashing algorithm goes here!\n+///         unimplemented!()\n+///     }\n+/// }\n+///\n+/// type MyBuildHasher = BuildHasherDefault<MyHasher>;\n+///\n+/// let hash_map = HashMap::<u32, u32, MyBuildHasher>::default();\n+/// ```\n+///\n+/// [`BuildHasher`]: trait.BuildHasher.html\n+/// [`Default`]: ../default/trait.Default.html\n+/// [`Hasher`]: trait.Hasher.html\n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n pub struct BuildHasherDefault<H>(marker::PhantomData<H>);\n "}, {"sha": "54eead94986cc9b441854d5ccd207bdaa6d27d9a", "filename": "src/librustc_back/target/aarch64_linux_android.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs?ref=10271ea24fbd7b28a42df8eb02a8dcf6d6132d71", "patch": "@@ -10,6 +10,9 @@\n \n use target::{Target, TargetOptions, TargetResult};\n \n+// See https://developer.android.com/ndk/guides/abis.html#arm64-v8a\n+// for target ABI requirements.\n+\n pub fn target() -> TargetResult {\n     let mut base = super::android_base::opts();\n     base.max_atomic_width = Some(128);"}, {"sha": "36f409b7948c27ace4ef2e8b6698bff9036ac2f9", "filename": "src/librustc_back/target/armv7_linux_androideabi.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Flibrustc_back%2Ftarget%2Farmv7_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Flibrustc_back%2Ftarget%2Farmv7_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7_linux_androideabi.rs?ref=10271ea24fbd7b28a42df8eb02a8dcf6d6132d71", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,9 +10,12 @@\n \n use target::{Target, TargetOptions, TargetResult};\n \n+// See https://developer.android.com/ndk/guides/abis.html#v7a\n+// for target ABI requirements.\n+\n pub fn target() -> TargetResult {\n     let mut base = super::android_base::opts();\n-    base.features = \"+v7,+thumb2,+vfp3,+d16\".to_string();\n+    base.features = \"+v7,+thumb2,+vfp3,+d16,-neon\".to_string();\n     base.max_atomic_width = Some(64);\n \n     Ok(Target {"}, {"sha": "f8a8f5a3500befb6a1d7a789e7fb2ff078d07421", "filename": "src/librustc_back/target/i686_linux_android.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Flibrustc_back%2Ftarget%2Fi686_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Flibrustc_back%2Ftarget%2Fi686_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_linux_android.rs?ref=10271ea24fbd7b28a42df8eb02a8dcf6d6132d71", "patch": "@@ -10,6 +10,9 @@\n \n use target::{Target, TargetResult};\n \n+// See https://developer.android.com/ndk/guides/abis.html#x86\n+// for target ABI requirements.\n+\n pub fn target() -> TargetResult {\n     let mut base = super::android_base::opts();\n "}, {"sha": "2dcb8c2f1529c3c2c497c220ddab13dac0a6fe35", "filename": "src/libstd/process.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=10271ea24fbd7b28a42df8eb02a8dcf6d6132d71", "patch": "@@ -828,13 +828,30 @@ impl Child {\n /// this function at a known point where there are no more destructors left\n /// to run.\n ///\n+/// ## Platform-specific behavior\n+///\n+/// **Unix**: On Unix-like platforms, it is unlikely that all 32 bits of `exit`\n+/// will be visible to a parent process inspecting the exit code. On most\n+/// Unix-like platforms, only the eight least-significant bits are considered.\n+///\n /// # Examples\n ///\n /// ```\n /// use std::process;\n ///\n /// process::exit(0);\n /// ```\n+///\n+/// Due to [platform-specific behavior], the exit code for this example will be\n+/// `0` on Linux, but `256` on Windows:\n+///\n+/// ```no_run\n+/// use std::process;\n+///\n+/// process::exit(0x0f00);\n+/// ```\n+///\n+/// [platform-specific behavior]: #platform-specific-behavior\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn exit(code: i32) -> ! {\n     ::sys_common::cleanup();"}, {"sha": "8bcf008649f222cdc70b16a11302d8445064faa7", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 85, "deletions": 107, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=10271ea24fbd7b28a42df8eb02a8dcf6d6132d71", "patch": "@@ -348,7 +348,7 @@ impl<T> !Sync for Sender<T> { }\n /// owned by one thread, but it can be cloned to send to other threads.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SyncSender<T> {\n-    inner: Arc<UnsafeCell<sync::Packet<T>>>,\n+    inner: Arc<sync::Packet<T>>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -426,10 +426,10 @@ pub enum TrySendError<T> {\n }\n \n enum Flavor<T> {\n-    Oneshot(Arc<UnsafeCell<oneshot::Packet<T>>>),\n-    Stream(Arc<UnsafeCell<stream::Packet<T>>>),\n-    Shared(Arc<UnsafeCell<shared::Packet<T>>>),\n-    Sync(Arc<UnsafeCell<sync::Packet<T>>>),\n+    Oneshot(Arc<oneshot::Packet<T>>),\n+    Stream(Arc<stream::Packet<T>>),\n+    Shared(Arc<shared::Packet<T>>),\n+    Sync(Arc<sync::Packet<T>>),\n }\n \n #[doc(hidden)]\n@@ -487,7 +487,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n-    let a = Arc::new(UnsafeCell::new(oneshot::Packet::new()));\n+    let a = Arc::new(oneshot::Packet::new());\n     (Sender::new(Flavor::Oneshot(a.clone())), Receiver::new(Flavor::Oneshot(a)))\n }\n \n@@ -532,7 +532,7 @@ pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn sync_channel<T>(bound: usize) -> (SyncSender<T>, Receiver<T>) {\n-    let a = Arc::new(UnsafeCell::new(sync::Packet::new(bound)));\n+    let a = Arc::new(sync::Packet::new(bound));\n     (SyncSender::new(a.clone()), Receiver::new(Flavor::Sync(a)))\n }\n \n@@ -578,38 +578,30 @@ impl<T> Sender<T> {\n     pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n         let (new_inner, ret) = match *unsafe { self.inner() } {\n             Flavor::Oneshot(ref p) => {\n-                unsafe {\n-                    let p = p.get();\n-                    if !(*p).sent() {\n-                        return (*p).send(t).map_err(SendError);\n-                    } else {\n-                        let a =\n-                            Arc::new(UnsafeCell::new(stream::Packet::new()));\n-                        let rx = Receiver::new(Flavor::Stream(a.clone()));\n-                        match (*p).upgrade(rx) {\n-                            oneshot::UpSuccess => {\n-                                let ret = (*a.get()).send(t);\n-                                (a, ret)\n-                            }\n-                            oneshot::UpDisconnected => (a, Err(t)),\n-                            oneshot::UpWoke(token) => {\n-                                // This send cannot panic because the thread is\n-                                // asleep (we're looking at it), so the receiver\n-                                // can't go away.\n-                                (*a.get()).send(t).ok().unwrap();\n-                                token.signal();\n-                                (a, Ok(()))\n-                            }\n+                if !p.sent() {\n+                    return p.send(t).map_err(SendError);\n+                } else {\n+                    let a = Arc::new(stream::Packet::new());\n+                    let rx = Receiver::new(Flavor::Stream(a.clone()));\n+                    match p.upgrade(rx) {\n+                        oneshot::UpSuccess => {\n+                            let ret = a.send(t);\n+                            (a, ret)\n+                        }\n+                        oneshot::UpDisconnected => (a, Err(t)),\n+                        oneshot::UpWoke(token) => {\n+                            // This send cannot panic because the thread is\n+                            // asleep (we're looking at it), so the receiver\n+                            // can't go away.\n+                            a.send(t).ok().unwrap();\n+                            token.signal();\n+                            (a, Ok(()))\n                         }\n                     }\n                 }\n             }\n-            Flavor::Stream(ref p) => return unsafe {\n-                (*p.get()).send(t).map_err(SendError)\n-            },\n-            Flavor::Shared(ref p) => return unsafe {\n-                (*p.get()).send(t).map_err(SendError)\n-            },\n+            Flavor::Stream(ref p) => return p.send(t).map_err(SendError),\n+            Flavor::Shared(ref p) => return p.send(t).map_err(SendError),\n             Flavor::Sync(..) => unreachable!(),\n         };\n \n@@ -624,41 +616,43 @@ impl<T> Sender<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Sender<T> {\n     fn clone(&self) -> Sender<T> {\n-        let (packet, sleeper, guard) = match *unsafe { self.inner() } {\n+        let packet = match *unsafe { self.inner() } {\n             Flavor::Oneshot(ref p) => {\n-                let a = Arc::new(UnsafeCell::new(shared::Packet::new()));\n-                unsafe {\n-                    let guard = (*a.get()).postinit_lock();\n+                let a = Arc::new(shared::Packet::new());\n+                {\n+                    let guard = a.postinit_lock();\n                     let rx = Receiver::new(Flavor::Shared(a.clone()));\n-                    match (*p.get()).upgrade(rx) {\n+                    let sleeper = match p.upgrade(rx) {\n                         oneshot::UpSuccess |\n-                        oneshot::UpDisconnected => (a, None, guard),\n-                        oneshot::UpWoke(task) => (a, Some(task), guard)\n-                    }\n+                        oneshot::UpDisconnected => None,\n+                        oneshot::UpWoke(task) => Some(task),\n+                    };\n+                    a.inherit_blocker(sleeper, guard);\n                 }\n+                a\n             }\n             Flavor::Stream(ref p) => {\n-                let a = Arc::new(UnsafeCell::new(shared::Packet::new()));\n-                unsafe {\n-                    let guard = (*a.get()).postinit_lock();\n+                let a = Arc::new(shared::Packet::new());\n+                {\n+                    let guard = a.postinit_lock();\n                     let rx = Receiver::new(Flavor::Shared(a.clone()));\n-                    match (*p.get()).upgrade(rx) {\n+                    let sleeper = match p.upgrade(rx) {\n                         stream::UpSuccess |\n-                        stream::UpDisconnected => (a, None, guard),\n-                        stream::UpWoke(task) => (a, Some(task), guard),\n-                    }\n+                        stream::UpDisconnected => None,\n+                        stream::UpWoke(task) => Some(task),\n+                    };\n+                    a.inherit_blocker(sleeper, guard);\n                 }\n+                a\n             }\n             Flavor::Shared(ref p) => {\n-                unsafe { (*p.get()).clone_chan(); }\n+                p.clone_chan();\n                 return Sender::new(Flavor::Shared(p.clone()));\n             }\n             Flavor::Sync(..) => unreachable!(),\n         };\n \n         unsafe {\n-            (*packet.get()).inherit_blocker(sleeper, guard);\n-\n             let tmp = Sender::new(Flavor::Shared(packet.clone()));\n             mem::swap(self.inner_mut(), tmp.inner_mut());\n         }\n@@ -669,10 +663,10 @@ impl<T> Clone for Sender<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Sender<T> {\n     fn drop(&mut self) {\n-        match *unsafe { self.inner_mut() } {\n-            Flavor::Oneshot(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n-            Flavor::Stream(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n-            Flavor::Shared(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n+        match *unsafe { self.inner() } {\n+            Flavor::Oneshot(ref p) => p.drop_chan(),\n+            Flavor::Stream(ref p) => p.drop_chan(),\n+            Flavor::Shared(ref p) => p.drop_chan(),\n             Flavor::Sync(..) => unreachable!(),\n         }\n     }\n@@ -690,7 +684,7 @@ impl<T> fmt::Debug for Sender<T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n impl<T> SyncSender<T> {\n-    fn new(inner: Arc<UnsafeCell<sync::Packet<T>>>) -> SyncSender<T> {\n+    fn new(inner: Arc<sync::Packet<T>>) -> SyncSender<T> {\n         SyncSender { inner: inner }\n     }\n \n@@ -710,7 +704,7 @@ impl<T> SyncSender<T> {\n     /// information.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n-        unsafe { (*self.inner.get()).send(t).map_err(SendError) }\n+        self.inner.send(t).map_err(SendError)\n     }\n \n     /// Attempts to send a value on this channel without blocking.\n@@ -724,22 +718,22 @@ impl<T> SyncSender<T> {\n     /// receiver has received the data or not if this function is successful.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> {\n-        unsafe { (*self.inner.get()).try_send(t) }\n+        self.inner.try_send(t)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for SyncSender<T> {\n     fn clone(&self) -> SyncSender<T> {\n-        unsafe { (*self.inner.get()).clone_chan(); }\n+        self.inner.clone_chan();\n         SyncSender::new(self.inner.clone())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for SyncSender<T> {\n     fn drop(&mut self) {\n-        unsafe { (*self.inner.get()).drop_chan(); }\n+        self.inner.drop_chan();\n     }\n }\n \n@@ -772,7 +766,7 @@ impl<T> Receiver<T> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n                 Flavor::Oneshot(ref p) => {\n-                    match unsafe { (*p.get()).try_recv() } {\n+                    match p.try_recv() {\n                         Ok(t) => return Ok(t),\n                         Err(oneshot::Empty) => return Err(TryRecvError::Empty),\n                         Err(oneshot::Disconnected) => {\n@@ -782,7 +776,7 @@ impl<T> Receiver<T> {\n                     }\n                 }\n                 Flavor::Stream(ref p) => {\n-                    match unsafe { (*p.get()).try_recv() } {\n+                    match p.try_recv() {\n                         Ok(t) => return Ok(t),\n                         Err(stream::Empty) => return Err(TryRecvError::Empty),\n                         Err(stream::Disconnected) => {\n@@ -792,7 +786,7 @@ impl<T> Receiver<T> {\n                     }\n                 }\n                 Flavor::Shared(ref p) => {\n-                    match unsafe { (*p.get()).try_recv() } {\n+                    match p.try_recv() {\n                         Ok(t) => return Ok(t),\n                         Err(shared::Empty) => return Err(TryRecvError::Empty),\n                         Err(shared::Disconnected) => {\n@@ -801,7 +795,7 @@ impl<T> Receiver<T> {\n                     }\n                 }\n                 Flavor::Sync(ref p) => {\n-                    match unsafe { (*p.get()).try_recv() } {\n+                    match p.try_recv() {\n                         Ok(t) => return Ok(t),\n                         Err(sync::Empty) => return Err(TryRecvError::Empty),\n                         Err(sync::Disconnected) => {\n@@ -875,31 +869,29 @@ impl<T> Receiver<T> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n                 Flavor::Oneshot(ref p) => {\n-                    match unsafe { (*p.get()).recv(None) } {\n+                    match p.recv(None) {\n                         Ok(t) => return Ok(t),\n                         Err(oneshot::Disconnected) => return Err(RecvError),\n                         Err(oneshot::Upgraded(rx)) => rx,\n                         Err(oneshot::Empty) => unreachable!(),\n                     }\n                 }\n                 Flavor::Stream(ref p) => {\n-                    match unsafe { (*p.get()).recv(None) } {\n+                    match p.recv(None) {\n                         Ok(t) => return Ok(t),\n                         Err(stream::Disconnected) => return Err(RecvError),\n                         Err(stream::Upgraded(rx)) => rx,\n                         Err(stream::Empty) => unreachable!(),\n                     }\n                 }\n                 Flavor::Shared(ref p) => {\n-                    match unsafe { (*p.get()).recv(None) } {\n+                    match p.recv(None) {\n                         Ok(t) => return Ok(t),\n                         Err(shared::Disconnected) => return Err(RecvError),\n                         Err(shared::Empty) => unreachable!(),\n                     }\n                 }\n-                Flavor::Sync(ref p) => return unsafe {\n-                    (*p.get()).recv(None).map_err(|_| RecvError)\n-                }\n+                Flavor::Sync(ref p) => return p.recv(None).map_err(|_| RecvError),\n             };\n             unsafe {\n                 mem::swap(self.inner_mut(), new_port.inner_mut());\n@@ -952,30 +944,30 @@ impl<T> Receiver<T> {\n         loop {\n             let port_or_empty = match *unsafe { self.inner() } {\n                 Flavor::Oneshot(ref p) => {\n-                    match unsafe { (*p.get()).recv(Some(deadline)) } {\n+                    match p.recv(Some(deadline)) {\n                         Ok(t) => return Ok(t),\n                         Err(oneshot::Disconnected) => return Err(Disconnected),\n                         Err(oneshot::Upgraded(rx)) => Some(rx),\n                         Err(oneshot::Empty) => None,\n                     }\n                 }\n                 Flavor::Stream(ref p) => {\n-                    match unsafe { (*p.get()).recv(Some(deadline)) } {\n+                    match p.recv(Some(deadline)) {\n                         Ok(t) => return Ok(t),\n                         Err(stream::Disconnected) => return Err(Disconnected),\n                         Err(stream::Upgraded(rx)) => Some(rx),\n                         Err(stream::Empty) => None,\n                     }\n                 }\n                 Flavor::Shared(ref p) => {\n-                    match unsafe { (*p.get()).recv(Some(deadline)) } {\n+                    match p.recv(Some(deadline)) {\n                         Ok(t) => return Ok(t),\n                         Err(shared::Disconnected) => return Err(Disconnected),\n                         Err(shared::Empty) => None,\n                     }\n                 }\n                 Flavor::Sync(ref p) => {\n-                    match unsafe { (*p.get()).recv(Some(deadline)) } {\n+                    match p.recv(Some(deadline)) {\n                         Ok(t) => return Ok(t),\n                         Err(sync::Disconnected) => return Err(Disconnected),\n                         Err(sync::Empty) => None,\n@@ -1020,23 +1012,19 @@ impl<T> select::Packet for Receiver<T> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n                 Flavor::Oneshot(ref p) => {\n-                    match unsafe { (*p.get()).can_recv() } {\n+                    match p.can_recv() {\n                         Ok(ret) => return ret,\n                         Err(upgrade) => upgrade,\n                     }\n                 }\n                 Flavor::Stream(ref p) => {\n-                    match unsafe { (*p.get()).can_recv() } {\n+                    match p.can_recv() {\n                         Ok(ret) => return ret,\n                         Err(upgrade) => upgrade,\n                     }\n                 }\n-                Flavor::Shared(ref p) => {\n-                    return unsafe { (*p.get()).can_recv() };\n-                }\n-                Flavor::Sync(ref p) => {\n-                    return unsafe { (*p.get()).can_recv() };\n-                }\n+                Flavor::Shared(ref p) => return p.can_recv(),\n+                Flavor::Sync(ref p) => return p.can_recv(),\n             };\n             unsafe {\n                 mem::swap(self.inner_mut(),\n@@ -1049,25 +1037,21 @@ impl<T> select::Packet for Receiver<T> {\n         loop {\n             let (t, new_port) = match *unsafe { self.inner() } {\n                 Flavor::Oneshot(ref p) => {\n-                    match unsafe { (*p.get()).start_selection(token) } {\n+                    match p.start_selection(token) {\n                         oneshot::SelSuccess => return Installed,\n                         oneshot::SelCanceled => return Abort,\n                         oneshot::SelUpgraded(t, rx) => (t, rx),\n                     }\n                 }\n                 Flavor::Stream(ref p) => {\n-                    match unsafe { (*p.get()).start_selection(token) } {\n+                    match p.start_selection(token) {\n                         stream::SelSuccess => return Installed,\n                         stream::SelCanceled => return Abort,\n                         stream::SelUpgraded(t, rx) => (t, rx),\n                     }\n                 }\n-                Flavor::Shared(ref p) => {\n-                    return unsafe { (*p.get()).start_selection(token) };\n-                }\n-                Flavor::Sync(ref p) => {\n-                    return unsafe { (*p.get()).start_selection(token) };\n-                }\n+                Flavor::Shared(ref p) => return p.start_selection(token),\n+                Flavor::Sync(ref p) => return p.start_selection(token),\n             };\n             token = t;\n             unsafe {\n@@ -1080,16 +1064,10 @@ impl<T> select::Packet for Receiver<T> {\n         let mut was_upgrade = false;\n         loop {\n             let result = match *unsafe { self.inner() } {\n-                Flavor::Oneshot(ref p) => unsafe { (*p.get()).abort_selection() },\n-                Flavor::Stream(ref p) => unsafe {\n-                    (*p.get()).abort_selection(was_upgrade)\n-                },\n-                Flavor::Shared(ref p) => return unsafe {\n-                    (*p.get()).abort_selection(was_upgrade)\n-                },\n-                Flavor::Sync(ref p) => return unsafe {\n-                    (*p.get()).abort_selection()\n-                },\n+                Flavor::Oneshot(ref p) => p.abort_selection(),\n+                Flavor::Stream(ref p) => p.abort_selection(was_upgrade),\n+                Flavor::Shared(ref p) => return p.abort_selection(was_upgrade),\n+                Flavor::Sync(ref p) => return p.abort_selection(),\n             };\n             let new_port = match result { Ok(b) => return b, Err(p) => p };\n             was_upgrade = true;\n@@ -1142,11 +1120,11 @@ impl <T> IntoIterator for Receiver<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Receiver<T> {\n     fn drop(&mut self) {\n-        match *unsafe { self.inner_mut() } {\n-            Flavor::Oneshot(ref mut p) => unsafe { (*p.get()).drop_port(); },\n-            Flavor::Stream(ref mut p) => unsafe { (*p.get()).drop_port(); },\n-            Flavor::Shared(ref mut p) => unsafe { (*p.get()).drop_port(); },\n-            Flavor::Sync(ref mut p) => unsafe { (*p.get()).drop_port(); },\n+        match *unsafe { self.inner() } {\n+            Flavor::Oneshot(ref p) => p.drop_port(),\n+            Flavor::Stream(ref p) => p.drop_port(),\n+            Flavor::Shared(ref p) => p.drop_port(),\n+            Flavor::Sync(ref p) => p.drop_port(),\n         }\n     }\n }"}, {"sha": "b8e50c9297b647c852eed8d5d4ed5e803c575047", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "modified", "additions": 153, "deletions": 140, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=10271ea24fbd7b28a42df8eb02a8dcf6d6132d71", "patch": "@@ -39,7 +39,8 @@ use self::MyUpgrade::*;\n \n use sync::mpsc::Receiver;\n use sync::mpsc::blocking::{self, SignalToken};\n-use core::mem;\n+use cell::UnsafeCell;\n+use ptr;\n use sync::atomic::{AtomicUsize, Ordering};\n use time::Instant;\n \n@@ -57,10 +58,10 @@ pub struct Packet<T> {\n     // Internal state of the chan/port pair (stores the blocked thread as well)\n     state: AtomicUsize,\n     // One-shot data slot location\n-    data: Option<T>,\n+    data: UnsafeCell<Option<T>>,\n     // when used for the second time, a oneshot channel must be upgraded, and\n     // this contains the slot for the upgrade\n-    upgrade: MyUpgrade<T>,\n+    upgrade: UnsafeCell<MyUpgrade<T>>,\n }\n \n pub enum Failure<T> {\n@@ -90,56 +91,60 @@ enum MyUpgrade<T> {\n impl<T> Packet<T> {\n     pub fn new() -> Packet<T> {\n         Packet {\n-            data: None,\n-            upgrade: NothingSent,\n+            data: UnsafeCell::new(None),\n+            upgrade: UnsafeCell::new(NothingSent),\n             state: AtomicUsize::new(EMPTY),\n         }\n     }\n \n-    pub fn send(&mut self, t: T) -> Result<(), T> {\n-        // Sanity check\n-        match self.upgrade {\n-            NothingSent => {}\n-            _ => panic!(\"sending on a oneshot that's already sent on \"),\n-        }\n-        assert!(self.data.is_none());\n-        self.data = Some(t);\n-        self.upgrade = SendUsed;\n-\n-        match self.state.swap(DATA, Ordering::SeqCst) {\n-            // Sent the data, no one was waiting\n-            EMPTY => Ok(()),\n-\n-            // Couldn't send the data, the port hung up first. Return the data\n-            // back up the stack.\n-            DISCONNECTED => {\n-                self.state.swap(DISCONNECTED, Ordering::SeqCst);\n-                self.upgrade = NothingSent;\n-                Err(self.data.take().unwrap())\n+    pub fn send(&self, t: T) -> Result<(), T> {\n+        unsafe {\n+            // Sanity check\n+            match *self.upgrade.get() {\n+                NothingSent => {}\n+                _ => panic!(\"sending on a oneshot that's already sent on \"),\n             }\n+            assert!((*self.data.get()).is_none());\n+            ptr::write(self.data.get(), Some(t));\n+            ptr::write(self.upgrade.get(), SendUsed);\n+\n+            match self.state.swap(DATA, Ordering::SeqCst) {\n+                // Sent the data, no one was waiting\n+                EMPTY => Ok(()),\n+\n+                // Couldn't send the data, the port hung up first. Return the data\n+                // back up the stack.\n+                DISCONNECTED => {\n+                    self.state.swap(DISCONNECTED, Ordering::SeqCst);\n+                    ptr::write(self.upgrade.get(), NothingSent);\n+                    Err((&mut *self.data.get()).take().unwrap())\n+                }\n \n-            // Not possible, these are one-use channels\n-            DATA => unreachable!(),\n+                // Not possible, these are one-use channels\n+                DATA => unreachable!(),\n \n-            // There is a thread waiting on the other end. We leave the 'DATA'\n-            // state inside so it'll pick it up on the other end.\n-            ptr => unsafe {\n-                SignalToken::cast_from_usize(ptr).signal();\n-                Ok(())\n+                // There is a thread waiting on the other end. We leave the 'DATA'\n+                // state inside so it'll pick it up on the other end.\n+                ptr => {\n+                    SignalToken::cast_from_usize(ptr).signal();\n+                    Ok(())\n+                }\n             }\n         }\n     }\n \n     // Just tests whether this channel has been sent on or not, this is only\n     // safe to use from the sender.\n     pub fn sent(&self) -> bool {\n-        match self.upgrade {\n-            NothingSent => false,\n-            _ => true,\n+        unsafe {\n+            match *self.upgrade.get() {\n+                NothingSent => false,\n+                _ => true,\n+            }\n         }\n     }\n \n-    pub fn recv(&mut self, deadline: Option<Instant>) -> Result<T, Failure<T>> {\n+    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure<T>> {\n         // Attempt to not block the thread (it's a little expensive). If it looks\n         // like we're not empty, then immediately go through to `try_recv`.\n         if self.state.load(Ordering::SeqCst) == EMPTY {\n@@ -167,73 +172,77 @@ impl<T> Packet<T> {\n         self.try_recv()\n     }\n \n-    pub fn try_recv(&mut self) -> Result<T, Failure<T>> {\n-        match self.state.load(Ordering::SeqCst) {\n-            EMPTY => Err(Empty),\n-\n-            // We saw some data on the channel, but the channel can be used\n-            // again to send us an upgrade. As a result, we need to re-insert\n-            // into the channel that there's no data available (otherwise we'll\n-            // just see DATA next time). This is done as a cmpxchg because if\n-            // the state changes under our feet we'd rather just see that state\n-            // change.\n-            DATA => {\n-                self.state.compare_and_swap(DATA, EMPTY, Ordering::SeqCst);\n-                match self.data.take() {\n-                    Some(data) => Ok(data),\n-                    None => unreachable!(),\n+    pub fn try_recv(&self) -> Result<T, Failure<T>> {\n+        unsafe {\n+            match self.state.load(Ordering::SeqCst) {\n+                EMPTY => Err(Empty),\n+\n+                // We saw some data on the channel, but the channel can be used\n+                // again to send us an upgrade. As a result, we need to re-insert\n+                // into the channel that there's no data available (otherwise we'll\n+                // just see DATA next time). This is done as a cmpxchg because if\n+                // the state changes under our feet we'd rather just see that state\n+                // change.\n+                DATA => {\n+                    self.state.compare_and_swap(DATA, EMPTY, Ordering::SeqCst);\n+                    match (&mut *self.data.get()).take() {\n+                        Some(data) => Ok(data),\n+                        None => unreachable!(),\n+                    }\n                 }\n-            }\n \n-            // There's no guarantee that we receive before an upgrade happens,\n-            // and an upgrade flags the channel as disconnected, so when we see\n-            // this we first need to check if there's data available and *then*\n-            // we go through and process the upgrade.\n-            DISCONNECTED => {\n-                match self.data.take() {\n-                    Some(data) => Ok(data),\n-                    None => {\n-                        match mem::replace(&mut self.upgrade, SendUsed) {\n-                            SendUsed | NothingSent => Err(Disconnected),\n-                            GoUp(upgrade) => Err(Upgraded(upgrade))\n+                // There's no guarantee that we receive before an upgrade happens,\n+                // and an upgrade flags the channel as disconnected, so when we see\n+                // this we first need to check if there's data available and *then*\n+                // we go through and process the upgrade.\n+                DISCONNECTED => {\n+                    match (&mut *self.data.get()).take() {\n+                        Some(data) => Ok(data),\n+                        None => {\n+                            match ptr::replace(self.upgrade.get(), SendUsed) {\n+                                SendUsed | NothingSent => Err(Disconnected),\n+                                GoUp(upgrade) => Err(Upgraded(upgrade))\n+                            }\n                         }\n                     }\n                 }\n-            }\n \n-            // We are the sole receiver; there cannot be a blocking\n-            // receiver already.\n-            _ => unreachable!()\n+                // We are the sole receiver; there cannot be a blocking\n+                // receiver already.\n+                _ => unreachable!()\n+            }\n         }\n     }\n \n     // Returns whether the upgrade was completed. If the upgrade wasn't\n     // completed, then the port couldn't get sent to the other half (it will\n     // never receive it).\n-    pub fn upgrade(&mut self, up: Receiver<T>) -> UpgradeResult {\n-        let prev = match self.upgrade {\n-            NothingSent => NothingSent,\n-            SendUsed => SendUsed,\n-            _ => panic!(\"upgrading again\"),\n-        };\n-        self.upgrade = GoUp(up);\n-\n-        match self.state.swap(DISCONNECTED, Ordering::SeqCst) {\n-            // If the channel is empty or has data on it, then we're good to go.\n-            // Senders will check the data before the upgrade (in case we\n-            // plastered over the DATA state).\n-            DATA | EMPTY => UpSuccess,\n-\n-            // If the other end is already disconnected, then we failed the\n-            // upgrade. Be sure to trash the port we were given.\n-            DISCONNECTED => { self.upgrade = prev; UpDisconnected }\n-\n-            // If someone's waiting, we gotta wake them up\n-            ptr => UpWoke(unsafe { SignalToken::cast_from_usize(ptr) })\n+    pub fn upgrade(&self, up: Receiver<T>) -> UpgradeResult {\n+        unsafe {\n+            let prev = match *self.upgrade.get() {\n+                NothingSent => NothingSent,\n+                SendUsed => SendUsed,\n+                _ => panic!(\"upgrading again\"),\n+            };\n+            ptr::write(self.upgrade.get(), GoUp(up));\n+\n+            match self.state.swap(DISCONNECTED, Ordering::SeqCst) {\n+                // If the channel is empty or has data on it, then we're good to go.\n+                // Senders will check the data before the upgrade (in case we\n+                // plastered over the DATA state).\n+                DATA | EMPTY => UpSuccess,\n+\n+                // If the other end is already disconnected, then we failed the\n+                // upgrade. Be sure to trash the port we were given.\n+                DISCONNECTED => { ptr::replace(self.upgrade.get(), prev); UpDisconnected }\n+\n+                // If someone's waiting, we gotta wake them up\n+                ptr => UpWoke(SignalToken::cast_from_usize(ptr))\n+            }\n         }\n     }\n \n-    pub fn drop_chan(&mut self) {\n+    pub fn drop_chan(&self) {\n         match self.state.swap(DISCONNECTED, Ordering::SeqCst) {\n             DATA | DISCONNECTED | EMPTY => {}\n \n@@ -244,7 +253,7 @@ impl<T> Packet<T> {\n         }\n     }\n \n-    pub fn drop_port(&mut self) {\n+    pub fn drop_port(&self) {\n         match self.state.swap(DISCONNECTED, Ordering::SeqCst) {\n             // An empty channel has nothing to do, and a remotely disconnected\n             // channel also has nothing to do b/c we're about to run the drop\n@@ -254,7 +263,7 @@ impl<T> Packet<T> {\n             // There's data on the channel, so make sure we destroy it promptly.\n             // This is why not using an arc is a little difficult (need the box\n             // to stay valid while we take the data).\n-            DATA => { self.data.take().unwrap(); }\n+            DATA => unsafe { (&mut *self.data.get()).take().unwrap(); },\n \n             // We're the only ones that can block on this port\n             _ => unreachable!()\n@@ -267,70 +276,74 @@ impl<T> Packet<T> {\n \n     // If Ok, the value is whether this port has data, if Err, then the upgraded\n     // port needs to be checked instead of this one.\n-    pub fn can_recv(&mut self) -> Result<bool, Receiver<T>> {\n-        match self.state.load(Ordering::SeqCst) {\n-            EMPTY => Ok(false), // Welp, we tried\n-            DATA => Ok(true),   // we have some un-acquired data\n-            DISCONNECTED if self.data.is_some() => Ok(true), // we have data\n-            DISCONNECTED => {\n-                match mem::replace(&mut self.upgrade, SendUsed) {\n-                    // The other end sent us an upgrade, so we need to\n-                    // propagate upwards whether the upgrade can receive\n-                    // data\n-                    GoUp(upgrade) => Err(upgrade),\n-\n-                    // If the other end disconnected without sending an\n-                    // upgrade, then we have data to receive (the channel is\n-                    // disconnected).\n-                    up => { self.upgrade = up; Ok(true) }\n+    pub fn can_recv(&self) -> Result<bool, Receiver<T>> {\n+        unsafe {\n+            match self.state.load(Ordering::SeqCst) {\n+                EMPTY => Ok(false), // Welp, we tried\n+                DATA => Ok(true),   // we have some un-acquired data\n+                DISCONNECTED if (*self.data.get()).is_some() => Ok(true), // we have data\n+                DISCONNECTED => {\n+                    match ptr::replace(self.upgrade.get(), SendUsed) {\n+                        // The other end sent us an upgrade, so we need to\n+                        // propagate upwards whether the upgrade can receive\n+                        // data\n+                        GoUp(upgrade) => Err(upgrade),\n+\n+                        // If the other end disconnected without sending an\n+                        // upgrade, then we have data to receive (the channel is\n+                        // disconnected).\n+                        up => { ptr::write(self.upgrade.get(), up); Ok(true) }\n+                    }\n                 }\n+                _ => unreachable!(), // we're the \"one blocker\"\n             }\n-            _ => unreachable!(), // we're the \"one blocker\"\n         }\n     }\n \n     // Attempts to start selection on this port. This can either succeed, fail\n     // because there is data, or fail because there is an upgrade pending.\n-    pub fn start_selection(&mut self, token: SignalToken) -> SelectionResult<T> {\n-        let ptr = unsafe { token.cast_to_usize() };\n-        match self.state.compare_and_swap(EMPTY, ptr, Ordering::SeqCst) {\n-            EMPTY => SelSuccess,\n-            DATA => {\n-                drop(unsafe { SignalToken::cast_from_usize(ptr) });\n-                SelCanceled\n-            }\n-            DISCONNECTED if self.data.is_some() => {\n-                drop(unsafe { SignalToken::cast_from_usize(ptr) });\n-                SelCanceled\n-            }\n-            DISCONNECTED => {\n-                match mem::replace(&mut self.upgrade, SendUsed) {\n-                    // The other end sent us an upgrade, so we need to\n-                    // propagate upwards whether the upgrade can receive\n-                    // data\n-                    GoUp(upgrade) => {\n-                        SelUpgraded(unsafe { SignalToken::cast_from_usize(ptr) }, upgrade)\n-                    }\n+    pub fn start_selection(&self, token: SignalToken) -> SelectionResult<T> {\n+        unsafe {\n+            let ptr = token.cast_to_usize();\n+            match self.state.compare_and_swap(EMPTY, ptr, Ordering::SeqCst) {\n+                EMPTY => SelSuccess,\n+                DATA => {\n+                    drop(SignalToken::cast_from_usize(ptr));\n+                    SelCanceled\n+                }\n+                DISCONNECTED if (*self.data.get()).is_some() => {\n+                    drop(SignalToken::cast_from_usize(ptr));\n+                    SelCanceled\n+                }\n+                DISCONNECTED => {\n+                    match ptr::replace(self.upgrade.get(), SendUsed) {\n+                        // The other end sent us an upgrade, so we need to\n+                        // propagate upwards whether the upgrade can receive\n+                        // data\n+                        GoUp(upgrade) => {\n+                            SelUpgraded(SignalToken::cast_from_usize(ptr), upgrade)\n+                        }\n \n-                    // If the other end disconnected without sending an\n-                    // upgrade, then we have data to receive (the channel is\n-                    // disconnected).\n-                    up => {\n-                        self.upgrade = up;\n-                        drop(unsafe { SignalToken::cast_from_usize(ptr) });\n-                        SelCanceled\n+                        // If the other end disconnected without sending an\n+                        // upgrade, then we have data to receive (the channel is\n+                        // disconnected).\n+                        up => {\n+                            ptr::write(self.upgrade.get(), up);\n+                            drop(SignalToken::cast_from_usize(ptr));\n+                            SelCanceled\n+                        }\n                     }\n                 }\n+                _ => unreachable!(), // we're the \"one blocker\"\n             }\n-            _ => unreachable!(), // we're the \"one blocker\"\n         }\n     }\n \n     // Remove a previous selecting thread from this port. This ensures that the\n     // blocked thread will no longer be visible to any other threads.\n     //\n     // The return value indicates whether there's data on this port.\n-    pub fn abort_selection(&mut self) -> Result<bool, Receiver<T>> {\n+    pub fn abort_selection(&self) -> Result<bool, Receiver<T>> {\n         let state = match self.state.load(Ordering::SeqCst) {\n             // Each of these states means that no further activity will happen\n             // with regard to abortion selection\n@@ -356,16 +369,16 @@ impl<T> Packet<T> {\n             //\n             // We then need to check to see if there was an upgrade requested,\n             // and if so, the upgraded port needs to have its selection aborted.\n-            DISCONNECTED => {\n-                if self.data.is_some() {\n+            DISCONNECTED => unsafe {\n+                if (*self.data.get()).is_some() {\n                     Ok(true)\n                 } else {\n-                    match mem::replace(&mut self.upgrade, SendUsed) {\n+                    match ptr::replace(self.upgrade.get(), SendUsed) {\n                         GoUp(port) => Err(port),\n                         _ => Ok(true),\n                     }\n                 }\n-            }\n+            },\n \n             // We woke ourselves up from select.\n             ptr => unsafe {"}, {"sha": "f9e0290416432001d464d51e71d9a1d30cfc524b", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 56, "deletions": 50, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=10271ea24fbd7b28a42df8eb02a8dcf6d6132d71", "patch": "@@ -24,6 +24,8 @@ use core::cmp;\n use core::intrinsics::abort;\n use core::isize;\n \n+use cell::UnsafeCell;\n+use ptr;\n use sync::atomic::{AtomicUsize, AtomicIsize, AtomicBool, Ordering};\n use sync::mpsc::blocking::{self, SignalToken};\n use sync::mpsc::mpsc_queue as mpsc;\n@@ -44,7 +46,7 @@ const MAX_STEALS: isize = 1 << 20;\n pub struct Packet<T> {\n     queue: mpsc::Queue<T>,\n     cnt: AtomicIsize, // How many items are on this channel\n-    steals: isize, // How many times has a port received without blocking?\n+    steals: UnsafeCell<isize>, // How many times has a port received without blocking?\n     to_wake: AtomicUsize, // SignalToken for wake up\n \n     // The number of channels which are currently using this packet.\n@@ -72,7 +74,7 @@ impl<T> Packet<T> {\n         Packet {\n             queue: mpsc::Queue::new(),\n             cnt: AtomicIsize::new(0),\n-            steals: 0,\n+            steals: UnsafeCell::new(0),\n             to_wake: AtomicUsize::new(0),\n             channels: AtomicUsize::new(2),\n             port_dropped: AtomicBool::new(false),\n@@ -95,7 +97,7 @@ impl<T> Packet<T> {\n     // threads in select().\n     //\n     // This can only be called at channel-creation time\n-    pub fn inherit_blocker(&mut self,\n+    pub fn inherit_blocker(&self,\n                            token: Option<SignalToken>,\n                            guard: MutexGuard<()>) {\n         token.map(|token| {\n@@ -122,7 +124,7 @@ impl<T> Packet<T> {\n             // To offset this bad increment, we initially set the steal count to\n             // -1. You'll find some special code in abort_selection() as well to\n             // ensure that this -1 steal count doesn't escape too far.\n-            self.steals = -1;\n+            unsafe { *self.steals.get() = -1; }\n         });\n \n         // When the shared packet is constructed, we grabbed this lock. The\n@@ -133,7 +135,7 @@ impl<T> Packet<T> {\n         drop(guard);\n     }\n \n-    pub fn send(&mut self, t: T) -> Result<(), T> {\n+    pub fn send(&self, t: T) -> Result<(), T> {\n         // See Port::drop for what's going on\n         if self.port_dropped.load(Ordering::SeqCst) { return Err(t) }\n \n@@ -218,7 +220,7 @@ impl<T> Packet<T> {\n         Ok(())\n     }\n \n-    pub fn recv(&mut self, deadline: Option<Instant>) -> Result<T, Failure> {\n+    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure> {\n         // This code is essentially the exact same as that found in the stream\n         // case (see stream.rs)\n         match self.try_recv() {\n@@ -239,37 +241,38 @@ impl<T> Packet<T> {\n         }\n \n         match self.try_recv() {\n-            data @ Ok(..) => { self.steals -= 1; data }\n+            data @ Ok(..) => unsafe { *self.steals.get() -= 1; data },\n             data => data,\n         }\n     }\n \n     // Essentially the exact same thing as the stream decrement function.\n     // Returns true if blocking should proceed.\n-    fn decrement(&mut self, token: SignalToken) -> StartResult {\n-        assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n-        let ptr = unsafe { token.cast_to_usize() };\n-        self.to_wake.store(ptr, Ordering::SeqCst);\n-\n-        let steals = self.steals;\n-        self.steals = 0;\n-\n-        match self.cnt.fetch_sub(1 + steals, Ordering::SeqCst) {\n-            DISCONNECTED => { self.cnt.store(DISCONNECTED, Ordering::SeqCst); }\n-            // If we factor in our steals and notice that the channel has no\n-            // data, we successfully sleep\n-            n => {\n-                assert!(n >= 0);\n-                if n - steals <= 0 { return Installed }\n+    fn decrement(&self, token: SignalToken) -> StartResult {\n+        unsafe {\n+            assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n+            let ptr = token.cast_to_usize();\n+            self.to_wake.store(ptr, Ordering::SeqCst);\n+\n+            let steals = ptr::replace(self.steals.get(), 0);\n+\n+            match self.cnt.fetch_sub(1 + steals, Ordering::SeqCst) {\n+                DISCONNECTED => { self.cnt.store(DISCONNECTED, Ordering::SeqCst); }\n+                // If we factor in our steals and notice that the channel has no\n+                // data, we successfully sleep\n+                n => {\n+                    assert!(n >= 0);\n+                    if n - steals <= 0 { return Installed }\n+                }\n             }\n-        }\n \n-        self.to_wake.store(0, Ordering::SeqCst);\n-        drop(unsafe { SignalToken::cast_from_usize(ptr) });\n-        Abort\n+            self.to_wake.store(0, Ordering::SeqCst);\n+            drop(SignalToken::cast_from_usize(ptr));\n+            Abort\n+        }\n     }\n \n-    pub fn try_recv(&mut self) -> Result<T, Failure> {\n+    pub fn try_recv(&self) -> Result<T, Failure> {\n         let ret = match self.queue.pop() {\n             mpsc::Data(t) => Some(t),\n             mpsc::Empty => None,\n@@ -303,23 +306,23 @@ impl<T> Packet<T> {\n         match ret {\n             // See the discussion in the stream implementation for why we\n             // might decrement steals.\n-            Some(data) => {\n-                if self.steals > MAX_STEALS {\n+            Some(data) => unsafe {\n+                if *self.steals.get() > MAX_STEALS {\n                     match self.cnt.swap(0, Ordering::SeqCst) {\n                         DISCONNECTED => {\n                             self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n                         }\n                         n => {\n-                            let m = cmp::min(n, self.steals);\n-                            self.steals -= m;\n+                            let m = cmp::min(n, *self.steals.get());\n+                            *self.steals.get() -= m;\n                             self.bump(n - m);\n                         }\n                     }\n-                    assert!(self.steals >= 0);\n+                    assert!(*self.steals.get() >= 0);\n                 }\n-                self.steals += 1;\n+                *self.steals.get() += 1;\n                 Ok(data)\n-            }\n+            },\n \n             // See the discussion in the stream implementation for why we try\n             // again.\n@@ -341,7 +344,7 @@ impl<T> Packet<T> {\n \n     // Prepares this shared packet for a channel clone, essentially just bumping\n     // a refcount.\n-    pub fn clone_chan(&mut self) {\n+    pub fn clone_chan(&self) {\n         let old_count = self.channels.fetch_add(1, Ordering::SeqCst);\n \n         // See comments on Arc::clone() on why we do this (for `mem::forget`).\n@@ -355,7 +358,7 @@ impl<T> Packet<T> {\n     // Decrement the reference count on a channel. This is called whenever a\n     // Chan is dropped and may end up waking up a receiver. It's the receiver's\n     // responsibility on the other end to figure out that we've disconnected.\n-    pub fn drop_chan(&mut self) {\n+    pub fn drop_chan(&self) {\n         match self.channels.fetch_sub(1, Ordering::SeqCst) {\n             1 => {}\n             n if n > 1 => return,\n@@ -371,9 +374,9 @@ impl<T> Packet<T> {\n \n     // See the long discussion inside of stream.rs for why the queue is drained,\n     // and why it is done in this fashion.\n-    pub fn drop_port(&mut self) {\n+    pub fn drop_port(&self) {\n         self.port_dropped.store(true, Ordering::SeqCst);\n-        let mut steals = self.steals;\n+        let mut steals = unsafe { *self.steals.get() };\n         while {\n             let cnt = self.cnt.compare_and_swap(steals, DISCONNECTED, Ordering::SeqCst);\n             cnt != DISCONNECTED && cnt != steals\n@@ -390,7 +393,7 @@ impl<T> Packet<T> {\n     }\n \n     // Consumes ownership of the 'to_wake' field.\n-    fn take_to_wake(&mut self) -> SignalToken {\n+    fn take_to_wake(&self) -> SignalToken {\n         let ptr = self.to_wake.load(Ordering::SeqCst);\n         self.to_wake.store(0, Ordering::SeqCst);\n         assert!(ptr != 0);\n@@ -406,13 +409,13 @@ impl<T> Packet<T> {\n     //\n     // This is different than the stream version because there's no need to peek\n     // at the queue, we can just look at the local count.\n-    pub fn can_recv(&mut self) -> bool {\n+    pub fn can_recv(&self) -> bool {\n         let cnt = self.cnt.load(Ordering::SeqCst);\n-        cnt == DISCONNECTED || cnt - self.steals > 0\n+        cnt == DISCONNECTED || cnt - unsafe { *self.steals.get() } > 0\n     }\n \n     // increment the count on the channel (used for selection)\n-    fn bump(&mut self, amt: isize) -> isize {\n+    fn bump(&self, amt: isize) -> isize {\n         match self.cnt.fetch_add(amt, Ordering::SeqCst) {\n             DISCONNECTED => {\n                 self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n@@ -427,7 +430,7 @@ impl<T> Packet<T> {\n     //\n     // The code here is the same as in stream.rs, except that it doesn't need to\n     // peek at the channel to see if an upgrade is pending.\n-    pub fn start_selection(&mut self, token: SignalToken) -> StartResult {\n+    pub fn start_selection(&self, token: SignalToken) -> StartResult {\n         match self.decrement(token) {\n             Installed => Installed,\n             Abort => {\n@@ -443,7 +446,7 @@ impl<T> Packet<T> {\n     //\n     // This is similar to the stream implementation (hence fewer comments), but\n     // uses a different value for the \"steals\" variable.\n-    pub fn abort_selection(&mut self, _was_upgrade: bool) -> bool {\n+    pub fn abort_selection(&self, _was_upgrade: bool) -> bool {\n         // Before we do anything else, we bounce on this lock. The reason for\n         // doing this is to ensure that any upgrade-in-progress is gone and\n         // done with. Without this bounce, we can race with inherit_blocker\n@@ -477,12 +480,15 @@ impl<T> Packet<T> {\n                     thread::yield_now();\n                 }\n             }\n-            // if the number of steals is -1, it was the pre-emptive -1 steal\n-            // count from when we inherited a blocker. This is fine because\n-            // we're just going to overwrite it with a real value.\n-            assert!(self.steals == 0 || self.steals == -1);\n-            self.steals = steals;\n-            prev >= 0\n+            unsafe {\n+                // if the number of steals is -1, it was the pre-emptive -1 steal\n+                // count from when we inherited a blocker. This is fine because\n+                // we're just going to overwrite it with a real value.\n+                let old = self.steals.get();\n+                assert!(*old == 0 || *old == -1);\n+                *old = steals;\n+                prev >= 0\n+            }\n         }\n     }\n }"}, {"sha": "47cd8977fda23ced729085ce1339ca7c25b0ea6e", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=10271ea24fbd7b28a42df8eb02a8dcf6d6132d71", "patch": "@@ -22,8 +22,10 @@ pub use self::UpgradeResult::*;\n pub use self::SelectionResult::*;\n use self::Message::*;\n \n+use cell::UnsafeCell;\n use core::cmp;\n use core::isize;\n+use ptr;\n use thread;\n use time::Instant;\n \n@@ -42,7 +44,7 @@ pub struct Packet<T> {\n     queue: spsc::Queue<Message<T>>, // internal queue for all message\n \n     cnt: AtomicIsize, // How many items are on this channel\n-    steals: isize, // How many times has a port received without blocking?\n+    steals: UnsafeCell<isize>, // How many times has a port received without blocking?\n     to_wake: AtomicUsize, // SignalToken for the blocked thread to wake up\n \n     port_dropped: AtomicBool, // flag if the channel has been destroyed.\n@@ -79,14 +81,14 @@ impl<T> Packet<T> {\n             queue: unsafe { spsc::Queue::new(128) },\n \n             cnt: AtomicIsize::new(0),\n-            steals: 0,\n+            steals: UnsafeCell::new(0),\n             to_wake: AtomicUsize::new(0),\n \n             port_dropped: AtomicBool::new(false),\n         }\n     }\n \n-    pub fn send(&mut self, t: T) -> Result<(), T> {\n+    pub fn send(&self, t: T) -> Result<(), T> {\n         // If the other port has deterministically gone away, then definitely\n         // must return the data back up the stack. Otherwise, the data is\n         // considered as being sent.\n@@ -99,15 +101,15 @@ impl<T> Packet<T> {\n         Ok(())\n     }\n \n-    pub fn upgrade(&mut self, up: Receiver<T>) -> UpgradeResult {\n+    pub fn upgrade(&self, up: Receiver<T>) -> UpgradeResult {\n         // If the port has gone away, then there's no need to proceed any\n         // further.\n         if self.port_dropped.load(Ordering::SeqCst) { return UpDisconnected }\n \n         self.do_send(GoUp(up))\n     }\n \n-    fn do_send(&mut self, t: Message<T>) -> UpgradeResult {\n+    fn do_send(&self, t: Message<T>) -> UpgradeResult {\n         self.queue.push(t);\n         match self.cnt.fetch_add(1, Ordering::SeqCst) {\n             // As described in the mod's doc comment, -1 == wakeup\n@@ -141,7 +143,7 @@ impl<T> Packet<T> {\n     }\n \n     // Consumes ownership of the 'to_wake' field.\n-    fn take_to_wake(&mut self) -> SignalToken {\n+    fn take_to_wake(&self) -> SignalToken {\n         let ptr = self.to_wake.load(Ordering::SeqCst);\n         self.to_wake.store(0, Ordering::SeqCst);\n         assert!(ptr != 0);\n@@ -151,13 +153,12 @@ impl<T> Packet<T> {\n     // Decrements the count on the channel for a sleeper, returning the sleeper\n     // back if it shouldn't sleep. Note that this is the location where we take\n     // steals into account.\n-    fn decrement(&mut self, token: SignalToken) -> Result<(), SignalToken> {\n+    fn decrement(&self, token: SignalToken) -> Result<(), SignalToken> {\n         assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n         let ptr = unsafe { token.cast_to_usize() };\n         self.to_wake.store(ptr, Ordering::SeqCst);\n \n-        let steals = self.steals;\n-        self.steals = 0;\n+        let steals = unsafe { ptr::replace(self.steals.get(), 0) };\n \n         match self.cnt.fetch_sub(1 + steals, Ordering::SeqCst) {\n             DISCONNECTED => { self.cnt.store(DISCONNECTED, Ordering::SeqCst); }\n@@ -173,7 +174,7 @@ impl<T> Packet<T> {\n         Err(unsafe { SignalToken::cast_from_usize(ptr) })\n     }\n \n-    pub fn recv(&mut self, deadline: Option<Instant>) -> Result<T, Failure<T>> {\n+    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure<T>> {\n         // Optimistic preflight check (scheduling is expensive).\n         match self.try_recv() {\n             Err(Empty) => {}\n@@ -199,16 +200,16 @@ impl<T> Packet<T> {\n             // a steal, so offset the decrement here (we already have our\n             // \"steal\" factored into the channel count above).\n             data @ Ok(..) |\n-            data @ Err(Upgraded(..)) => {\n-                self.steals -= 1;\n+            data @ Err(Upgraded(..)) => unsafe {\n+                *self.steals.get() -= 1;\n                 data\n-            }\n+            },\n \n             data => data,\n         }\n     }\n \n-    pub fn try_recv(&mut self) -> Result<T, Failure<T>> {\n+    pub fn try_recv(&self) -> Result<T, Failure<T>> {\n         match self.queue.pop() {\n             // If we stole some data, record to that effect (this will be\n             // factored into cnt later on).\n@@ -221,26 +222,26 @@ impl<T> Packet<T> {\n             // a pretty slow operation, of swapping 0 into cnt, taking steals\n             // down as much as possible (without going negative), and then\n             // adding back in whatever we couldn't factor into steals.\n-            Some(data) => {\n-                if self.steals > MAX_STEALS {\n+            Some(data) => unsafe {\n+                if *self.steals.get() > MAX_STEALS {\n                     match self.cnt.swap(0, Ordering::SeqCst) {\n                         DISCONNECTED => {\n                             self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n                         }\n                         n => {\n-                            let m = cmp::min(n, self.steals);\n-                            self.steals -= m;\n+                            let m = cmp::min(n, *self.steals.get());\n+                            *self.steals.get() -= m;\n                             self.bump(n - m);\n                         }\n                     }\n-                    assert!(self.steals >= 0);\n+                    assert!(*self.steals.get() >= 0);\n                 }\n-                self.steals += 1;\n+                *self.steals.get() += 1;\n                 match data {\n                     Data(t) => Ok(t),\n                     GoUp(up) => Err(Upgraded(up)),\n                 }\n-            }\n+            },\n \n             None => {\n                 match self.cnt.load(Ordering::SeqCst) {\n@@ -269,7 +270,7 @@ impl<T> Packet<T> {\n         }\n     }\n \n-    pub fn drop_chan(&mut self) {\n+    pub fn drop_chan(&self) {\n         // Dropping a channel is pretty simple, we just flag it as disconnected\n         // and then wakeup a blocker if there is one.\n         match self.cnt.swap(DISCONNECTED, Ordering::SeqCst) {\n@@ -279,7 +280,7 @@ impl<T> Packet<T> {\n         }\n     }\n \n-    pub fn drop_port(&mut self) {\n+    pub fn drop_port(&self) {\n         // Dropping a port seems like a fairly trivial thing. In theory all we\n         // need to do is flag that we're disconnected and then everything else\n         // can take over (we don't have anyone to wake up).\n@@ -309,7 +310,7 @@ impl<T> Packet<T> {\n         // continue to fail while active senders send data while we're dropping\n         // data, but eventually we're guaranteed to break out of this loop\n         // (because there is a bounded number of senders).\n-        let mut steals = self.steals;\n+        let mut steals = unsafe { *self.steals.get() };\n         while {\n             let cnt = self.cnt.compare_and_swap(\n                             steals, DISCONNECTED, Ordering::SeqCst);\n@@ -332,7 +333,7 @@ impl<T> Packet<T> {\n     // Tests to see whether this port can receive without blocking. If Ok is\n     // returned, then that's the answer. If Err is returned, then the returned\n     // port needs to be queried instead (an upgrade happened)\n-    pub fn can_recv(&mut self) -> Result<bool, Receiver<T>> {\n+    pub fn can_recv(&self) -> Result<bool, Receiver<T>> {\n         // We peek at the queue to see if there's anything on it, and we use\n         // this return value to determine if we should pop from the queue and\n         // upgrade this channel immediately. If it looks like we've got an\n@@ -351,7 +352,7 @@ impl<T> Packet<T> {\n     }\n \n     // increment the count on the channel (used for selection)\n-    fn bump(&mut self, amt: isize) -> isize {\n+    fn bump(&self, amt: isize) -> isize {\n         match self.cnt.fetch_add(amt, Ordering::SeqCst) {\n             DISCONNECTED => {\n                 self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n@@ -363,7 +364,7 @@ impl<T> Packet<T> {\n \n     // Attempts to start selecting on this port. Like a oneshot, this can fail\n     // immediately because of an upgrade.\n-    pub fn start_selection(&mut self, token: SignalToken) -> SelectionResult<T> {\n+    pub fn start_selection(&self, token: SignalToken) -> SelectionResult<T> {\n         match self.decrement(token) {\n             Ok(()) => SelSuccess,\n             Err(token) => {\n@@ -387,7 +388,7 @@ impl<T> Packet<T> {\n     }\n \n     // Removes a previous thread from being blocked in this port\n-    pub fn abort_selection(&mut self,\n+    pub fn abort_selection(&self,\n                            was_upgrade: bool) -> Result<bool, Receiver<T>> {\n         // If we're aborting selection after upgrading from a oneshot, then\n         // we're guarantee that no one is waiting. The only way that we could\n@@ -403,7 +404,7 @@ impl<T> Packet<T> {\n         // this end. This is fine because we know it's a small bounded windows\n         // of time until the data is actually sent.\n         if was_upgrade {\n-            assert_eq!(self.steals, 0);\n+            assert_eq!(unsafe { *self.steals.get() }, 0);\n             assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n             return Ok(true)\n         }\n@@ -444,8 +445,10 @@ impl<T> Packet<T> {\n                     thread::yield_now();\n                 }\n             }\n-            assert_eq!(self.steals, 0);\n-            self.steals = steals;\n+            unsafe {\n+                assert_eq!(*self.steals.get(), 0);\n+                *self.steals.get() = steals;\n+            }\n \n             // if we were previously positive, then there's surely data to\n             // receive"}, {"sha": "55adc3dabf40fa7e54763730ecf938012663f8ad", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=10271ea24fbd7b28a42df8eb02a8dcf6d6132d71", "patch": "@@ -17,13 +17,11 @@\n //! provide some built-in support for low-level synchronization.\n //!\n //! Communication between threads can be done through\n-//! [channels](../../std/sync/mpsc/index.html), Rust's message-passing\n-//! types, along with [other forms of thread\n+//! [channels], Rust's message-passing types, along with [other forms of thread\n //! synchronization](../../std/sync/index.html) and shared-memory data\n //! structures. In particular, types that are guaranteed to be\n //! threadsafe are easily shared between threads using the\n-//! atomically-reference-counted container,\n-//! [`Arc`](../../std/sync/struct.Arc.html).\n+//! atomically-reference-counted container, [`Arc`].\n //!\n //! Fatal logic errors in Rust cause *thread panic*, during which\n //! a thread will unwind the stack, running destructors and freeing\n@@ -40,7 +38,7 @@\n //!\n //! ## Spawning a thread\n //!\n-//! A new thread can be spawned using the `thread::spawn` function:\n+//! A new thread can be spawned using the [`thread::spawn`][`spawn`] function:\n //!\n //! ```rust\n //! use std::thread;\n@@ -55,7 +53,7 @@\n //! it), unless this parent is the main thread.\n //!\n //! The parent thread can also wait on the completion of the child\n-//! thread; a call to `spawn` produces a `JoinHandle`, which provides\n+//! thread; a call to [`spawn`] produces a [`JoinHandle`], which provides\n //! a `join` method for waiting:\n //!\n //! ```rust\n@@ -68,13 +66,13 @@\n //! let res = child.join();\n //! ```\n //!\n-//! The `join` method returns a `Result` containing `Ok` of the final\n-//! value produced by the child thread, or `Err` of the value given to\n-//! a call to `panic!` if the child panicked.\n+//! The [`join`] method returns a [`Result`] containing [`Ok`] of the final\n+//! value produced by the child thread, or [`Err`] of the value given to\n+//! a call to [`panic!`] if the child panicked.\n //!\n //! ## Configuring threads\n //!\n-//! A new thread can be configured before it is spawned via the `Builder` type,\n+//! A new thread can be configured before it is spawned via the [`Builder`] type,\n //! which currently allows you to set the name and stack size for the child thread:\n //!\n //! ```rust\n@@ -88,43 +86,43 @@\n //!\n //! ## The `Thread` type\n //!\n-//! Threads are represented via the `Thread` type, which you can get in one of\n+//! Threads are represented via the [`Thread`] type, which you can get in one of\n //! two ways:\n //!\n-//! * By spawning a new thread, e.g. using the `thread::spawn` function, and\n-//!   calling `thread()` on the `JoinHandle`.\n-//! * By requesting the current thread, using the `thread::current` function.\n+//! * By spawning a new thread, e.g. using the [`thread::spawn`][`spawn`]\n+//!   function, and calling [`thread()`] on the [`JoinHandle`].\n+//! * By requesting the current thread, using the [`thread::current()`] function.\n //!\n-//! The `thread::current()` function is available even for threads not spawned\n+//! The [`thread::current()`] function is available even for threads not spawned\n //! by the APIs of this module.\n //!\n //! ## Blocking support: park and unpark\n //!\n //! Every thread is equipped with some basic low-level blocking support, via the\n-//! `thread::park()` function and `thread::Thread::unpark()` method. `park()`\n-//! blocks the current thread, which can then be resumed from another thread by\n-//! calling the `unpark()` method on the blocked thread's handle.\n+//! [`thread::park()`][`park()`] function and [`thread::Thread::unpark()`][`unpark()`]\n+//! method. [`park()`] blocks the current thread, which can then be resumed from\n+//! another thread by calling the [`unpark()`] method on the blocked thread's handle.\n //!\n-//! Conceptually, each `Thread` handle has an associated token, which is\n+//! Conceptually, each [`Thread`] handle has an associated token, which is\n //! initially not present:\n //!\n-//! * The `thread::park()` function blocks the current thread unless or until\n+//! * The [`thread::park()`][`park()`] function blocks the current thread unless or until\n //!   the token is available for its thread handle, at which point it atomically\n //!   consumes the token. It may also return *spuriously*, without consuming the\n-//!   token. `thread::park_timeout()` does the same, but allows specifying a\n+//!   token. [`thread::park_timeout()`] does the same, but allows specifying a\n //!   maximum time to block the thread for.\n //!\n-//! * The `unpark()` method on a `Thread` atomically makes the token available\n+//! * The [`unpark()`] method on a [`Thread`] atomically makes the token available\n //!   if it wasn't already.\n //!\n-//! In other words, each `Thread` acts a bit like a semaphore with initial count\n+//! In other words, each [`Thread`] acts a bit like a semaphore with initial count\n //! 0, except that the semaphore is *saturating* (the count cannot go above 1),\n //! and can return spuriously.\n //!\n //! The API is typically used by acquiring a handle to the current thread,\n //! placing that handle in a shared data structure so that other threads can\n //! find it, and then `park`ing. When some desired condition is met, another\n-//! thread calls `unpark` on the handle.\n+//! thread calls [`unpark()`] on the handle.\n //!\n //! The motivation for this design is twofold:\n //!\n@@ -149,6 +147,22 @@\n //! will want to make use of some form of **interior mutability** through the\n //! [`Cell`] or [`RefCell`] types.\n //!\n+//! [channels]: ../../std/sync/mpsc/index.html\n+//! [`Arc`]: ../../std/sync/struct.Arc.html\n+//! [`spawn`]: ../../std/thread/fn.spawn.html\n+//! [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n+//! [`thread()`]: ../../std/thread/struct.JoinHandle.html#method.thread\n+//! [`join`]: ../../std/thread/struct.JoinHandle.html#method.join\n+//! [`Result`]: ../../std/result/enum.Result.html\n+//! [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n+//! [`Err`]: ../../std/result/enum.Result.html#variant.Err\n+//! [`panic!`]: ../../std/macro.panic.html\n+//! [`Builder`]: ../../std/thread/struct.Builder.html\n+//! [`thread::current()`]: ../../std/thread/fn.spawn.html\n+//! [`Thread`]: ../../std/thread/struct.Thread.html\n+//! [`park()`]: ../../std/thread/fn.park.html\n+//! [`unpark()`]: ../../std/thread/struct.Thread.html#method.unpark\n+//! [`thread::park_timeout()`]: ../../std/thread/fn.park_timeout.html\n //! [`Cell`]: ../cell/struct.Cell.html\n //! [`RefCell`]: ../cell/struct.RefCell.html\n //! [`thread_local!`]: ../macro.thread_local.html"}, {"sha": "4fbd70835dd2bc73ad9749505ee3a98d77f12241", "filename": "src/stage0.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Fstage0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Fstage0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstage0.txt?ref=10271ea24fbd7b28a42df8eb02a8dcf6d6132d71", "patch": "@@ -2,7 +2,7 @@\n # compiler itself. For the rustbuild build system, this also describes the\n # relevant Cargo revision that we're using.\n #\n-# Currently Rust always bootstrap from the previous stable release, and in our\n+# Currently Rust always bootstraps from the previous stable release, and in our\n # train model this means that the master branch bootstraps from beta, beta\n # bootstraps from current stable, and stable bootstraps from the previous stable\n # release.\n@@ -12,5 +12,5 @@\n # tarball for a stable release you'll likely see `1.x.0-$date` where `1.x.0` was\n # released on `$date`\n \n-rustc: beta-2016-11-16\n+rustc: beta-2016-12-16\n cargo: nightly-2016-11-16"}, {"sha": "ac5dff0980c08ee437c1db1553e862a22b59f4f9", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10271ea24fbd7b28a42df8eb02a8dcf6d6132d71/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=10271ea24fbd7b28a42df8eb02a8dcf6d6132d71", "patch": "@@ -67,7 +67,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n         }\n \n         contents.truncate(0);\n-        t!(t!(File::open(file)).read_to_string(&mut contents));\n+        t!(t!(File::open(&file), &file).read_to_string(&mut contents));\n \n         for (i, line) in contents.lines().enumerate() {\n             let mut err = |msg: &str| {"}]}