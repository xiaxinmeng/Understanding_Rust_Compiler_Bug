{"sha": "a58bfced3cdb8e4eccbee9c5f9494ab1929d3720", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1OGJmY2VkM2NkYjhlNGVjY2JlZTljNWY5NDk0YWIxOTI5ZDM3MjA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-26T04:04:04Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T22:54:44Z"}, "message": "Convert back::link to istrs. Issue #855", "tree": {"sha": "f8a15d86f317b51c676d34c78b35f7dd9d630241", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8a15d86f317b51c676d34c78b35f7dd9d630241"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a58bfced3cdb8e4eccbee9c5f9494ab1929d3720", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a58bfced3cdb8e4eccbee9c5f9494ab1929d3720", "html_url": "https://github.com/rust-lang/rust/commit/a58bfced3cdb8e4eccbee9c5f9494ab1929d3720", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a58bfced3cdb8e4eccbee9c5f9494ab1929d3720/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c9c5c9054c2680a68c47f0bd9d80625b0906507", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c9c5c9054c2680a68c47f0bd9d80625b0906507", "html_url": "https://github.com/rust-lang/rust/commit/9c9c5c9054c2680a68c47f0bd9d80625b0906507"}], "stats": {"total": 277, "additions": 162, "deletions": 115}, "files": [{"sha": "6a56ca94f94d753d452a7d44ea3952024d68dd94", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 71, "deletions": 55, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/a58bfced3cdb8e4eccbee9c5f9494ab1929d3720/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a58bfced3cdb8e4eccbee9c5f9494ab1929d3720/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=a58bfced3cdb8e4eccbee9c5f9494ab1929d3720", "patch": "@@ -32,11 +32,14 @@ tag output_type {\n     output_type_exe;\n }\n \n-fn llvm_err(sess: session::session, msg: str) {\n+fn llvm_err(sess: session::session, msg: &istr) {\n     let buf = llvm::LLVMRustGetLastError();\n     if buf as uint == 0u {\n-        sess.fatal(msg);\n-    } else { sess.fatal(msg + \": \" + str::str_from_cstr(buf)); }\n+        sess.fatal(istr::to_estr(msg));\n+    } else {\n+        sess.fatal(\n+            istr::to_estr(msg) + \": \" + str::str_from_cstr(buf));\n+    }\n }\n \n fn link_intrinsics(sess: session::session, llmod: ModuleRef) {\n@@ -46,19 +49,20 @@ fn link_intrinsics(sess: session::session, llmod: ModuleRef) {\n     let membuf =\n         llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(str::buf(path));\n     if membuf as uint == 0u {\n-        llvm_err(sess, \"installation problem: couldn't open \" + path);\n+        llvm_err(sess, ~\"installation problem: couldn't open \"\n+                 + istr::from_estr(path));\n         fail;\n     }\n     let llintrinsicsmod = llvm::LLVMRustParseBitcode(membuf);\n     llvm::LLVMDisposeMemoryBuffer(membuf);\n     if llintrinsicsmod as uint == 0u {\n-        llvm_err(sess, \"installation problem: couldn't parse intrinsics.bc\");\n+        llvm_err(sess, ~\"installation problem: couldn't parse intrinsics.bc\");\n         fail;\n     }\n     let linkres = llvm::LLVMLinkModules(llmod, llintrinsicsmod);\n     llvm::LLVMDisposeModule(llintrinsicsmod);\n     if linkres == False {\n-        llvm_err(sess, \"couldn't link the module with the intrinsics\");\n+        llvm_err(sess, ~\"couldn't link the module with the intrinsics\");\n         fail;\n     }\n }\n@@ -74,15 +78,15 @@ mod write {\n \n     // Decides what to call an intermediate file, given the name of the output\n     // and the extension to use.\n-    fn mk_intermediate_name(output_path: str, extension: str) -> str {\n-        let dot_pos = str::index(output_path, '.' as u8);\n+    fn mk_intermediate_name(output_path: &istr, extension: &istr) -> istr {\n+        let dot_pos = istr::index(output_path, '.' as u8);\n         let stem;\n         if dot_pos < 0 {\n             stem = output_path;\n-        } else { stem = str::substr(output_path, 0u, dot_pos as uint); }\n-        ret stem + \".\" + extension;\n+        } else { stem = istr::substr(output_path, 0u, dot_pos as uint); }\n+        ret stem + ~\".\" + extension;\n     }\n-    fn run_passes(sess: session::session, llmod: ModuleRef, output: str) {\n+    fn run_passes(sess: session::session, llmod: ModuleRef, output: &istr) {\n         let opts = sess.get_opts();\n         if opts.time_llvm_passes { llvm::LLVMRustEnableTimePasses(); }\n         link_intrinsics(sess, llmod);\n@@ -99,12 +103,14 @@ mod write {\n             alt opts.output_type {\n               output_type_bitcode. {\n                 if opts.optimize != 0u {\n-                    let filename = mk_intermediate_name(output, \"no-opt.bc\");\n+                    let filename = mk_intermediate_name(output, ~\"no-opt.bc\");\n+                    let filename = istr::to_estr(filename);\n                     llvm::LLVMWriteBitcodeToFile(llmod, str::buf(filename));\n                 }\n               }\n               _ {\n-                let filename = mk_intermediate_name(output, \"bc\");\n+                let filename = mk_intermediate_name(output, ~\"bc\");\n+                let filename = istr::to_estr(filename);\n                 llvm::LLVMWriteBitcodeToFile(llmod, str::buf(filename));\n               }\n             }\n@@ -176,14 +182,16 @@ mod write {\n             if opts.save_temps {\n                 // Always output the bitcode file with --save-temps\n \n-                let filename = mk_intermediate_name(output, \"opt.bc\");\n+                let filename = mk_intermediate_name(output, ~\"opt.bc\");\n+                let filename = istr::to_estr(filename);\n                 llvm::LLVMRunPassManager(pm.llpm, llmod);\n                 llvm::LLVMWriteBitcodeToFile(llmod, str::buf(filename));\n                 pm = mk_pass_manager();\n                 // Save the assembly file if -S is used\n \n                 if opts.output_type == output_type_assembly {\n                     let triple = x86::get_target_triple();\n+                    let output = istr::to_estr(output);\n                     llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n                                                   str::buf(triple),\n                                                   str::buf(output),\n@@ -197,6 +205,7 @@ mod write {\n                 if opts.output_type == output_type_object ||\n                        opts.output_type == output_type_exe {\n                     let triple = x86::get_target_triple();\n+                    let output = istr::to_estr(output);\n                     llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n                                                   str::buf(triple),\n                                                   str::buf(output),\n@@ -208,6 +217,7 @@ mod write {\n                 // type corresponding to the '-c' or '-S' flag used\n \n                 let triple = x86::get_target_triple();\n+                let output = istr::to_estr(output);\n                 llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n                                               str::buf(triple),\n                                               str::buf(output), FileType,\n@@ -223,6 +233,7 @@ mod write {\n         // flag, then output it here\n \n         llvm::LLVMRunPassManager(pm.llpm, llmod);\n+        let output = istr::to_estr(output);\n         llvm::LLVMWriteBitcodeToFile(llmod, str::buf(output));\n         llvm::LLVMDisposeModule(llmod);\n         if opts.time_llvm_passes { llvm::LLVMRustPrintPassTimings(); }\n@@ -281,32 +292,32 @@ mod write {\n  *\n  */\n \n-type link_meta = {name: str, vers: str, extras_hash: str};\n+type link_meta = {name: istr, vers: istr, extras_hash: istr};\n \n-fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n+fn build_link_meta(sess: &session::session, c: &ast::crate, output: &istr,\n                    sha: sha1) -> link_meta {\n \n     type provided_metas =\n-        {name: option::t<str>,\n-         vers: option::t<str>,\n+        {name: option::t<istr>,\n+         vers: option::t<istr>,\n          cmh_items: [@ast::meta_item]};\n \n     fn provided_link_metas(sess: &session::session, c: &ast::crate) ->\n        provided_metas {\n-        let name: option::t<str> = none;\n-        let vers: option::t<str> = none;\n+        let name: option::t<istr> = none;\n+        let vers: option::t<istr> = none;\n         let cmh_items: [@ast::meta_item] = [];\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess, linkage_metas);\n         for meta: @ast::meta_item in linkage_metas {\n             if attr::get_meta_item_name(meta) == ~\"name\" {\n                 alt attr::get_meta_item_value_str(meta) {\n-                  some(v) { name = some(v); }\n+                  some(v) { name = some(istr::from_estr(v)); }\n                   none. { cmh_items += [meta]; }\n                 }\n             } else if attr::get_meta_item_name(meta) == ~\"vers\" {\n                 alt attr::get_meta_item_value_str(meta) {\n-                  some(v) { vers = some(v); }\n+                  some(v) { vers = some(istr::from_estr(v)); }\n                   none. { cmh_items += [meta]; }\n                 }\n             } else { cmh_items += [meta]; }\n@@ -316,7 +327,7 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n \n     // This calculates CMH as defined above\n     fn crate_meta_extras_hash(sha: sha1, _crate: &ast::crate,\n-                              metas: &provided_metas) -> str {\n+                              metas: &provided_metas) -> istr {\n         fn len_and_str(s: &istr) -> istr {\n             ret istr::from_estr(#fmt[\"%u_%s\",\n                                      istr::byte_len(s),\n@@ -349,39 +360,39 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n         ret truncated_sha1_result(sha);\n     }\n \n-    fn warn_missing(sess: &session::session, name: str, default: str) {\n+    fn warn_missing(sess: &session::session, name: &istr, default: &istr) {\n         if !sess.get_opts().library { ret; }\n         sess.warn(#fmt[\"missing crate link meta '%s', using '%s' as default\",\n-                       name, default]);\n+                       istr::to_estr(name), istr::to_estr(default)]);\n     }\n \n     fn crate_meta_name(sess: &session::session, _crate: &ast::crate,\n-                       output: &str, metas: &provided_metas) -> str {\n+                       output: &istr, metas: &provided_metas) -> istr {\n         ret alt metas.name {\n               some(v) { v }\n               none. {\n                 let name =\n                     {\n                         let os = istr::split(\n-                            fs::basename(istr::from_estr(output)),\n+                            fs::basename(output),\n                             '.' as u8);\n                         assert (vec::len(os) >= 2u);\n                         vec::pop(os);\n-                        istr::to_estr(istr::connect(os, ~\".\"))\n+                        istr::connect(os, ~\".\")\n                     };\n-                warn_missing(sess, \"name\", name);\n+                warn_missing(sess, ~\"name\", name);\n                 name\n               }\n             };\n     }\n \n     fn crate_meta_vers(sess: &session::session, _crate: &ast::crate,\n-                       metas: &provided_metas) -> str {\n+                       metas: &provided_metas) -> istr {\n         ret alt metas.vers {\n               some(v) { v }\n               none. {\n-                let vers = \"0.0\";\n-                warn_missing(sess, \"vers\", vers);\n+                let vers = ~\"0.0\";\n+                warn_missing(sess, ~\"vers\", vers);\n                 vers\n               }\n             };\n@@ -395,32 +406,32 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n     ret {name: name, vers: vers, extras_hash: extras_hash};\n }\n \n-fn truncated_sha1_result(sha: sha1) -> str {\n-    ret istr::to_estr(istr::substr(sha.result_str(), 0u, 16u));\n+fn truncated_sha1_result(sha: sha1) -> istr {\n+    ret istr::substr(sha.result_str(), 0u, 16u);\n }\n \n \n // This calculates STH for a symbol, as defined above\n fn symbol_hash(tcx: ty::ctxt, sha: sha1, t: ty::t, link_meta: &link_meta) ->\n-   str {\n+   istr {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n \n     sha.reset();\n-    sha.input_str(istr::from_estr(link_meta.name));\n+    sha.input_str(link_meta.name);\n     sha.input_str(~\"-\");\n     // FIXME: This wants to be link_meta.meta_hash\n-    sha.input_str(istr::from_estr(link_meta.name));\n+    sha.input_str(link_meta.name);\n     sha.input_str(~\"-\");\n     sha.input_str(encoder::encoded_ty(tcx, t));\n     let hash = truncated_sha1_result(sha);\n     // Prefix with _ so that it never blends into adjacent digits\n \n-    ret \"_\" + hash;\n+    ret ~\"_\" + hash;\n }\n \n-fn get_symbol_hash(ccx: &@crate_ctxt, t: ty::t) -> str {\n-    let hash = \"\";\n+fn get_symbol_hash(ccx: &@crate_ctxt, t: ty::t) -> istr {\n+    let hash = ~\"\";\n     alt ccx.type_sha1s.find(t) {\n       some(h) { hash = h; }\n       none. {\n@@ -431,47 +442,52 @@ fn get_symbol_hash(ccx: &@crate_ctxt, t: ty::t) -> str {\n     ret hash;\n }\n \n-fn mangle(ss: &[str]) -> str {\n+fn mangle(ss: &[istr]) -> istr {\n     // Follow C++ namespace-mangling style\n \n-    let n = \"_ZN\"; // Begin name-sequence.\n+    let n = ~\"_ZN\"; // Begin name-sequence.\n \n-    for s: str in ss { n += #fmt[\"%u%s\", str::byte_len(s), s]; }\n-    n += \"E\"; // End name-sequence.\n+    for s: istr in ss {\n+        n += istr::from_estr(#fmt[\"%u%s\",\n+                                  istr::byte_len(s),\n+                                  istr::to_estr(s)]);\n+    }\n+    n += ~\"E\"; // End name-sequence.\n \n     ret n;\n }\n \n-fn exported_name(path: &[str], hash: &str, _vers: &str) -> str {\n+fn exported_name(path: &[istr], hash: &istr, _vers: &istr) -> istr {\n     // FIXME: versioning isn't working yet\n \n     ret mangle(path + [hash]); //  + \"@\" + vers;\n \n }\n \n-fn mangle_exported_name(ccx: &@crate_ctxt, path: &[str], t: ty::t) -> str {\n+fn mangle_exported_name(ccx: &@crate_ctxt, path: &[istr], t: ty::t) -> istr {\n     let hash = get_symbol_hash(ccx, t);\n     ret exported_name(path, hash, ccx.link_meta.vers);\n }\n \n-fn mangle_internal_name_by_type_only(ccx: &@crate_ctxt, t: ty::t, name: &str)\n-   -> str {\n+fn mangle_internal_name_by_type_only(ccx: &@crate_ctxt, t: ty::t, name: &istr)\n+   -> istr {\n     let s = util::ppaux::ty_to_short_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n-    ret mangle([name, istr::to_estr(s), hash]);\n+    ret mangle([name, s, hash]);\n }\n \n-fn mangle_internal_name_by_path_and_seq(ccx: &@crate_ctxt, path: &[str],\n-                                        flav: &str) -> str {\n-    ret mangle(path + [ccx.names.next(flav)]);\n+fn mangle_internal_name_by_path_and_seq(ccx: &@crate_ctxt, path: &[istr],\n+                                        flav: &istr) -> istr {\n+    ret mangle(path +\n+               istr::from_estrs([ccx.names.next(istr::to_estr(flav))]));\n }\n \n-fn mangle_internal_name_by_path(_ccx: &@crate_ctxt, path: &[str]) -> str {\n+fn mangle_internal_name_by_path(_ccx: &@crate_ctxt, path: &[istr]) -> istr {\n     ret mangle(path);\n }\n \n-fn mangle_internal_name_by_seq(ccx: &@crate_ctxt, flav: &str) -> str {\n-    ret ccx.names.next(flav);\n+fn mangle_internal_name_by_seq(ccx: &@crate_ctxt, flav: &istr) -> istr {\n+    ret istr::from_estr(ccx.names.next(istr::to_estr(flav)));\n }\n //\n // Local Variables:"}, {"sha": "be7e06d0460b26c7c8bb455377e100f1c9732de3", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a58bfced3cdb8e4eccbee9c5f9494ab1929d3720/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a58bfced3cdb8e4eccbee9c5f9494ab1929d3720/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=a58bfced3cdb8e4eccbee9c5f9494ab1929d3720", "patch": "@@ -169,7 +169,7 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n                      bind trans::trans_crate(sess, crate, ty_cx, output,\n                                              ast_map, mut_map));\n     time(time_passes, \"LLVM passes\",\n-         bind link::write::run_passes(sess, llmod, output));\n+         bind link::write::run_passes(sess, llmod, istr::from_estr(output)));\n }\n \n fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg, input: str,"}, {"sha": "537e40761af133cb4e5d9f36c05c1b08c264ca84", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a58bfced3cdb8e4eccbee9c5f9494ab1929d3720/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a58bfced3cdb8e4eccbee9c5f9494ab1929d3720/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=a58bfced3cdb8e4eccbee9c5f9494ab1929d3720", "patch": "@@ -504,13 +504,15 @@ fn synthesize_crate_attrs(ecx: &@encode_ctxt, crate: &@crate) -> [attribute] {\n     fn synthesize_link_attr(ecx: &@encode_ctxt, items: &[@meta_item]) ->\n        attribute {\n \n-        assert (ecx.ccx.link_meta.name != \"\");\n-        assert (ecx.ccx.link_meta.vers != \"\");\n+        assert (ecx.ccx.link_meta.name != ~\"\");\n+        assert (ecx.ccx.link_meta.vers != ~\"\");\n \n         let name_item =\n-            attr::mk_name_value_item_str(~\"name\", ecx.ccx.link_meta.name);\n+            attr::mk_name_value_item_str(\n+                ~\"name\", istr::to_estr(ecx.ccx.link_meta.name));\n         let vers_item =\n-            attr::mk_name_value_item_str(~\"vers\", ecx.ccx.link_meta.vers);\n+            attr::mk_name_value_item_str(\n+                ~\"vers\", istr::to_estr(ecx.ccx.link_meta.vers));\n \n         let other_items =\n             {"}, {"sha": "65c829d2bd7d0191b81c3d04f221b01abc887bbf", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 63, "deletions": 42, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/a58bfced3cdb8e4eccbee9c5f9494ab1929d3720/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a58bfced3cdb8e4eccbee9c5f9494ab1929d3720/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=a58bfced3cdb8e4eccbee9c5f9494ab1929d3720", "patch": "@@ -287,23 +287,23 @@ fn type_of_or_i8(bcx: &@block_ctxt, typ: ty::t) -> TypeRef {\n \n // Name sanitation. LLVM will happily accept identifiers with weird names, but\n // gas doesn't!\n-fn sanitize(s: &str) -> str {\n-    let result = \"\";\n+fn sanitize(s: &istr) -> istr {\n+    let result = ~\"\";\n     for c: u8 in s {\n         if c == '@' as u8 {\n-            result += \"boxed_\";\n+            result += ~\"boxed_\";\n         } else {\n             if c == ',' as u8 {\n-                result += \"_\";\n+                result += ~\"_\";\n             } else {\n                 if c == '{' as u8 || c == '(' as u8 {\n-                    result += \"_of_\";\n+                    result += ~\"_of_\";\n                 } else {\n                     if c != 10u8 && c != '}' as u8 && c != ')' as u8 &&\n                            c != ' ' as u8 && c != '\\t' as u8 && c != ';' as u8\n                        {\n                         let v = [c];\n-                        result += str::unsafe_from_bytes(v);\n+                        result += istr::unsafe_from_bytes(v);\n                     }\n                 }\n             }\n@@ -1137,9 +1137,10 @@ fn declare_tydesc(cx: &@local_ctxt, sp: &span, t: ty::t, ty_params: &[uint])\n     }\n     let name;\n     if cx.ccx.sess.get_opts().debuginfo {\n-        name = mangle_internal_name_by_type_only(cx.ccx, t, \"tydesc\");\n+        name = mangle_internal_name_by_type_only(cx.ccx, t, ~\"tydesc\");\n         name = sanitize(name);\n-    } else { name = mangle_internal_name_by_seq(cx.ccx, \"tydesc\"); }\n+    } else { name = mangle_internal_name_by_seq(cx.ccx, ~\"tydesc\"); }\n+    let name = istr::to_estr(name);\n     let gvar =\n         llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type, str::buf(name));\n     let info =\n@@ -1164,12 +1165,13 @@ tag glue_helper {\n \n fn declare_generic_glue(cx: &@local_ctxt, t: ty::t, llfnty: TypeRef,\n                         name: &str) -> ValueRef {\n+    let name = istr::from_estr(name);\n     let fn_nm;\n     if cx.ccx.sess.get_opts().debuginfo {\n-        fn_nm = mangle_internal_name_by_type_only(cx.ccx, t, \"glue_\" + name);\n+        fn_nm = mangle_internal_name_by_type_only(cx.ccx, t, ~\"glue_\" + name);\n         fn_nm = sanitize(fn_nm);\n-    } else { fn_nm = mangle_internal_name_by_seq(cx.ccx, \"glue_\" + name); }\n-    let llfn = decl_cdecl_fn(cx.ccx.llmod, fn_nm, llfnty);\n+    } else { fn_nm = mangle_internal_name_by_seq(cx.ccx, ~\"glue_\" + name); }\n+    let llfn = decl_cdecl_fn(cx.ccx.llmod, istr::to_estr(fn_nm), llfnty);\n     set_glue_inlining(cx, llfn, t);\n     ret llfn;\n }\n@@ -3155,8 +3157,10 @@ fn trans_for_each(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n     let llenv = build_closure(cx, upvars, false);\n \n     // Step 2: Declare foreach body function.\n-    let s: str =\n-        mangle_internal_name_by_path_and_seq(lcx.ccx, lcx.path, \"foreach\");\n+    let s: istr =\n+        mangle_internal_name_by_path_and_seq(lcx.ccx,\n+                                             istr::from_estrs(lcx.path),\n+                                             ~\"foreach\");\n \n     // The 'env' arg entering the body function is a fake env member (as in\n     // the env-part of the normal rust calling convention) that actually\n@@ -3167,7 +3171,8 @@ fn trans_for_each(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n         type_of_fn_from_ty(lcx.ccx, cx.sp,\n                            ty::mk_iter_body_fn(lcx.ccx.tcx, decl_ty), 0u);\n     let lliterbody: ValueRef =\n-        decl_internal_fastcall_fn(lcx.ccx.llmod, s, iter_body_llty);\n+        decl_internal_fastcall_fn(lcx.ccx.llmod,\n+                                  istr::to_estr(s), iter_body_llty);\n     let fcx = new_fn_ctxt_w_id(lcx, cx.sp, lliterbody, body.node.id);\n     fcx.iterbodyty = cx.fcx.iterbodyty;\n \n@@ -3699,12 +3704,15 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: ty::t,\n     // construct and return that thunk.\n \n     // Give the thunk a name, type, and value.\n-    let s: str =\n-        mangle_internal_name_by_path_and_seq(cx.ccx, cx.path, \"thunk\");\n+    let s: istr =\n+        mangle_internal_name_by_path_and_seq(cx.ccx,\n+                                             istr::from_estrs(cx.path),\n+                                             ~\"thunk\");\n     let llthunk_ty: TypeRef =\n         get_pair_fn_ty(type_of(cx.ccx, sp, incoming_fty));\n     let llthunk: ValueRef =\n-        decl_internal_fastcall_fn(cx.ccx.llmod, s, llthunk_ty);\n+        decl_internal_fastcall_fn(cx.ccx.llmod,\n+                                  istr::to_estr(s), llthunk_ty);\n \n     // Create a new function context and block context for the thunk, and hold\n     // onto a pointer to the first block in the function for later use.\n@@ -4298,8 +4306,10 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n         let llfnty: TypeRef =\n             type_of_fn_from_ty(ccx, e.span, node_id_type(ccx, e.id), 0u);\n         let sub_cx = extend_path(cx.fcx.lcx, ccx.names.next(\"anon\"));\n-        let s = mangle_internal_name_by_path(ccx, sub_cx.path);\n-        let llfn = decl_internal_fastcall_fn(ccx.llmod, s, llfnty);\n+        let s = mangle_internal_name_by_path(ccx,\n+                                             istr::from_estrs(sub_cx.path));\n+        let llfn = decl_internal_fastcall_fn(ccx.llmod,\n+                                             istr::to_estr(s), llfnty);\n \n         let fn_res =\n             trans_closure(some(cx), some(llfnty), sub_cx, e.span, f, llfn,\n@@ -4308,7 +4318,8 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n             alt fn_res {\n               some(fn_pair) { fn_pair }\n               none. {\n-                {fn_pair: create_fn_pair(ccx, s, llfnty, llfn, false),\n+                {fn_pair: create_fn_pair(ccx, istr::to_estr(s),\n+                                         llfnty, llfn, false),\n                  bcx: cx}\n               }\n             };\n@@ -4532,9 +4543,11 @@ fn trans_log(lvl: int, cx: &@block_ctxt, e: &@ast::expr) -> result {\n         global = lcx.ccx.module_data.get(istr::from_estr(modname));\n     } else {\n         let s =\n-            link::mangle_internal_name_by_path_and_seq(lcx.ccx,\n-                                                       lcx.module_path,\n-                                                       \"loglevel\");\n+            link::mangle_internal_name_by_path_and_seq(\n+                lcx.ccx,\n+                istr::from_estrs(lcx.module_path),\n+                ~\"loglevel\");\n+        let s = istr::to_estr(s);\n         global = llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(), str::buf(s));\n         llvm::LLVMSetGlobalConstant(global, False);\n         llvm::LLVMSetInitializer(global, C_null(T_int()));\n@@ -5130,7 +5143,7 @@ fn trans_block(cx: &@block_ctxt, b: &ast::blk, output: &out_method) ->\n fn new_local_ctxt(ccx: &@crate_ctxt) -> @local_ctxt {\n     let pth: [str] = [];\n     ret @{path: pth,\n-          module_path: [ccx.link_meta.name],\n+          module_path: [istr::to_estr(ccx.link_meta.name)],\n           obj_typarams: [],\n           obj_fields: [],\n           ccx: ccx};\n@@ -5702,6 +5715,7 @@ fn decl_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str], flav: str,\n fn decl_fn_and_pair_full(ccx: &@crate_ctxt, sp: &span, path: &[str],\n                          _flav: str, ty_params: &[ast::ty_param],\n                          node_id: ast::node_id, node_type: ty::t) {\n+    let path = istr::from_estrs(path);\n     let llfty =\n         type_of_fn_from_ty(ccx, sp, node_type, std::vec::len(ty_params));\n     alt ty::struct(ccx.tcx, node_type) {\n@@ -5712,14 +5726,14 @@ fn decl_fn_and_pair_full(ccx: &@crate_ctxt, sp: &span, path: &[str],\n       }\n       _ { ccx.sess.bug(\"decl_fn_and_pair(): fn item doesn't have fn type!\"); }\n     }\n-    let s: str = mangle_internal_name_by_path(ccx, path);\n-    let llfn: ValueRef = decl_internal_fastcall_fn(ccx.llmod, s, llfty);\n+    let s: istr = mangle_internal_name_by_path(ccx, path);\n+    let llfn: ValueRef = decl_internal_fastcall_fn(ccx.llmod,\n+                                                   istr::to_estr(s), llfty);\n     // Declare the global constant pair that points to it.\n \n-    let ps: str = mangle_exported_name(ccx, path, node_type);\n-    register_fn_pair(ccx, ps, llfty, llfn, node_id);\n+    let ps: istr = mangle_exported_name(ccx, path, node_type);\n+    register_fn_pair(ccx, istr::to_estr(ps), llfty, llfn, node_id);\n \n-    let path = istr::from_estrs(path);\n     let is_main: bool = is_main_name(path) && !ccx.sess.get_opts().library;\n     if is_main { create_main_wrapper(ccx, sp, llfn, node_type); }\n }\n@@ -5851,18 +5865,20 @@ fn native_fn_wrapper_type(cx: &@crate_ctxt, sp: &span, ty_param_count: uint,\n \n fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n                            name: str, id: ast::node_id) {\n+    let path = istr::from_estrs(path);\n     let num_ty_param = native_fn_ty_param_count(ccx, id);\n     // Declare the wrapper.\n \n     let t = node_id_type(ccx, id);\n     let wrapper_type = native_fn_wrapper_type(ccx, sp, num_ty_param, t);\n-    let s: str = mangle_internal_name_by_path(ccx, path);\n+    let s: istr = mangle_internal_name_by_path(ccx, path);\n     let wrapper_fn: ValueRef =\n-        decl_internal_fastcall_fn(ccx.llmod, s, wrapper_type);\n+        decl_internal_fastcall_fn(ccx.llmod,\n+                                  istr::to_estr(s), wrapper_type);\n     // Declare the global constant pair that points to it.\n \n-    let ps: str = mangle_exported_name(ccx, path, node_id_type(ccx, id));\n-    register_fn_pair(ccx, ps, wrapper_type, wrapper_fn, id);\n+    let ps: istr = mangle_exported_name(ccx, path, node_id_type(ccx, id));\n+    register_fn_pair(ccx, istr::to_estr(ps), wrapper_type, wrapper_fn, id);\n     // Build the wrapper.\n \n     let fcx = new_fn_ctxt(new_local_ctxt(ccx), sp, wrapper_fn);\n@@ -6054,8 +6070,9 @@ fn collect_item_1(ccx: @crate_ctxt, i: &@ast::item, pt: &[str],\n       ast::item_const(_, _) {\n         let typ = node_id_type(ccx, i.id);\n         let s =\n-            mangle_exported_name(ccx, pt + [istr::to_estr(i.ident)],\n+            mangle_exported_name(ccx, istr::from_estrs(pt) + [i.ident],\n                                  node_id_type(ccx, i.id));\n+        let s = istr::to_estr(s);\n         let g =\n             llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, i.span, typ),\n                                 str::buf(s));\n@@ -6143,9 +6160,12 @@ fn trans_constant(ccx: @crate_ctxt, it: &@ast::item, pt: &[str],\n         let n_variants = std::vec::len::<ast::variant>(variants);\n         while i < n_variants {\n             let variant = variants[i];\n-            let p = new_pt + istr::to_estrs([it.ident,\n-                                             variant.node.name, ~\"discrim\"]);\n-            let s = mangle_exported_name(ccx, p, ty::mk_int(ccx.tcx));\n+            let p = istr::from_estrs(new_pt) + [it.ident,\n+                                                variant.node.name,\n+                                                ~\"discrim\"];\n+            let s = mangle_exported_name(ccx, p,\n+                                         ty::mk_int(ccx.tcx));\n+            let s = istr::to_estr(s);\n             let discrim_gvar =\n                 llvm::LLVMAddGlobal(ccx.llmod, T_int(), str::buf(s));\n             if n_variants != 1u {\n@@ -6263,7 +6283,7 @@ fn make_common_glue(sess: &session::session, output: &str) {\n     let modl_asm = x86::get_module_asm(); //HACK (buf lifetime issue)\n     llvm::LLVMSetModuleInlineAsm(llmod, str::buf(modl_asm));\n     make_glues(llmod, taskptr_type);\n-    link::write::run_passes(sess, llmod, output);\n+    link::write::run_passes(sess, llmod, istr::from_estr(output));\n }\n \n fn create_module_map(ccx: &@crate_ctxt) -> ValueRef {\n@@ -6301,8 +6321,8 @@ fn create_crate_map(ccx: &@crate_ctxt) -> ValueRef {\n     let mapname;\n     if ccx.sess.get_opts().library {\n         mapname = ccx.link_meta.name;\n-    } else { mapname = \"toplevel\"; }\n-    let sym_name = \"_rust_crate_map_\" + mapname;\n+    } else { mapname = ~\"toplevel\"; }\n+    let sym_name = istr::to_estr(~\"_rust_crate_map_\" + mapname);\n     let arrtype = T_array(T_int(), std::vec::len::<ValueRef>(subcrates));\n     let maptype = T_struct([T_int(), arrtype]);\n     let map = llvm::LLVMAddGlobal(ccx.llmod, maptype, str::buf(sym_name));\n@@ -6367,7 +6387,7 @@ fn trans_crate(sess: &session::session, crate: &@ast::crate, tcx: &ty::ctxt,\n     let tag_sizes = map::mk_hashmap::<ty::t, uint>(hasher, eqer);\n     let tydescs = map::mk_hashmap::<ty::t, @tydesc_info>(hasher, eqer);\n     let lltypes = map::mk_hashmap::<ty::t, TypeRef>(hasher, eqer);\n-    let sha1s = map::mk_hashmap::<ty::t, str>(hasher, eqer);\n+    let sha1s = map::mk_hashmap::<ty::t, istr>(hasher, eqer);\n     let short_names = map::mk_hashmap::<ty::t, str>(hasher, eqer);\n     let sha = std::sha1::mk_sha1();\n     let ccx =\n@@ -6381,7 +6401,8 @@ fn trans_crate(sess: &session::session, crate: &@ast::crate, tcx: &ty::ctxt,\n           ast_map: amap,\n           item_symbols: new_int_hash::<str>(),\n           mutable main_fn: none::<ValueRef>,\n-          link_meta: link::build_link_meta(sess, *crate, output, sha),\n+          link_meta: link::build_link_meta(sess, *crate,\n+                                           istr::from_estr(output), sha),\n           tag_sizes: tag_sizes,\n           discrims: new_int_hash::<ValueRef>(),\n           discrim_symbols: new_int_hash::<str>(),"}, {"sha": "b4c243d9842c9cfca92a1fd973430e456618af13", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a58bfced3cdb8e4eccbee9c5f9494ab1929d3720/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a58bfced3cdb8e4eccbee9c5f9494ab1929d3720/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=a58bfced3cdb8e4eccbee9c5f9494ab1929d3720", "patch": "@@ -146,7 +146,7 @@ type crate_ctxt =\n      glues: @glue_fns,\n      names: namegen,\n      sha: std::sha1::sha1,\n-     type_sha1s: hashmap<ty::t, str>,\n+     type_sha1s: hashmap<ty::t, istr>,\n      type_short_names: hashmap<ty::t, str>,\n      tcx: ty::ctxt,\n      mut_map: alias::mut_map,"}, {"sha": "085c955c2c399fc2c2d15c87fa3a7552d391b71d", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a58bfced3cdb8e4eccbee9c5f9494ab1929d3720/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a58bfced3cdb8e4eccbee9c5f9494ab1929d3720/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=a58bfced3cdb8e4eccbee9c5f9494ab1929d3720", "patch": "@@ -569,7 +569,9 @@ fn create_backwarding_vtbl(cx: @local_ctxt, sp: &span, inner_obj_ty: ty::t,\n fn finish_vtbl(cx: @local_ctxt, llmethods: [ValueRef], name: str) ->\n    ValueRef {\n     let vtbl = C_struct(llmethods);\n-    let vtbl_name = mangle_internal_name_by_path(cx.ccx, cx.path + [name]);\n+    let vtbl_name = mangle_internal_name_by_path(\n+        cx.ccx, istr::from_estrs(cx.path + [name]));\n+    let vtbl_name = istr::to_estr(vtbl_name);\n     let gvar =\n         llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl), str::buf(vtbl_name));\n     llvm::LLVMSetInitializer(gvar, vtbl);\n@@ -603,16 +605,18 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n         + [\"method\", istr::to_estr(m.ident)] with *cx};\n \n     // Make up a name for the backwarding function.\n-    let fn_name: str = \"backwarding_fn\";\n-    let s: str =\n-        mangle_internal_name_by_path_and_seq(mcx.ccx, mcx.path, fn_name);\n+    let fn_name: istr = ~\"backwarding_fn\";\n+    let s: istr =\n+        mangle_internal_name_by_path_and_seq(\n+            mcx.ccx, istr::from_estrs(mcx.path), fn_name);\n \n     // Get the backwarding function's type and declare it.\n     let llbackwarding_fn_ty: TypeRef =\n         type_of_fn_full(cx.ccx, sp, m.proto, true, m.inputs, m.output,\n                         std::vec::len::<ast::ty_param>(ty_params));\n     let llbackwarding_fn: ValueRef =\n-        decl_internal_fastcall_fn(cx.ccx.llmod, s, llbackwarding_fn_ty);\n+        decl_internal_fastcall_fn(\n+            cx.ccx.llmod, istr::to_estr(s), llbackwarding_fn_ty);\n \n     // Create a new function context and block context for the backwarding\n     // function, holding onto a pointer to the first block.\n@@ -732,16 +736,18 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n         + [\"method\", istr::to_estr(m.ident)] with *cx};\n \n     // Make up a name for the forwarding function.\n-    let fn_name: str = \"forwarding_fn\";\n-    let s: str =\n-        mangle_internal_name_by_path_and_seq(mcx.ccx, mcx.path, fn_name);\n+    let fn_name: istr = ~\"forwarding_fn\";\n+    let s: istr =\n+        mangle_internal_name_by_path_and_seq(\n+            mcx.ccx, istr::from_estrs(mcx.path), fn_name);\n \n     // Get the forwarding function's type and declare it.\n     let llforwarding_fn_ty: TypeRef =\n         type_of_fn_full(cx.ccx, sp, m.proto, true, m.inputs, m.output,\n                         std::vec::len::<ast::ty_param>(ty_params));\n     let llforwarding_fn: ValueRef =\n-        decl_internal_fastcall_fn(cx.ccx.llmod, s, llforwarding_fn_ty);\n+        decl_internal_fastcall_fn(\n+            cx.ccx.llmod, istr::to_estr(s), llforwarding_fn_ty);\n \n     // Create a new function context and block context for the forwarding\n     // function, holding onto a pointer to the first block.\n@@ -921,14 +927,16 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n     }\n     let mcx: @local_ctxt =\n         @{path: cx.path + [\"method\", istr::to_estr(m.node.ident)] with *cx};\n-    let s: str = mangle_internal_name_by_path(mcx.ccx, mcx.path);\n-    let llfn: ValueRef = decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n+    let s: istr = mangle_internal_name_by_path(mcx.ccx,\n+                                               istr::from_estrs(mcx.path));\n+    let llfn: ValueRef = decl_internal_fastcall_fn(\n+        cx.ccx.llmod, istr::to_estr(s), llfnty);\n \n     // Every method on an object gets its node_id inserted into the crate-wide\n     // item_ids map, together with the ValueRef that points to where that\n     // method's definition will be in the executable.\n     cx.ccx.item_ids.insert(m.node.id, llfn);\n-    cx.ccx.item_symbols.insert(m.node.id, s);\n+    cx.ccx.item_symbols.insert(m.node.id, istr::to_estr(s));\n     trans_fn(mcx, m.span, m.node.meth, llfn, some(self_ty), ty_params,\n              m.node.id);\n "}]}