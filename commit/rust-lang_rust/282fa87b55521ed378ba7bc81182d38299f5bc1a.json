{"sha": "282fa87b55521ed378ba7bc81182d38299f5bc1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4MmZhODdiNTU1MjFlZDM3OGJhN2JjODExODJkMzgyOTlmNWJjMWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-12T07:20:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-12T07:20:31Z"}, "message": "Auto merge of #39680 - canndrew:uninhabited_from-infinite-loop, r=arielb1\n\nAdd recursion limit to inhabitedness check\n\nFixes #39489.\nAdd test aswell.", "tree": {"sha": "a047bbd9a3e446fdff69280e384b976821b79730", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a047bbd9a3e446fdff69280e384b976821b79730"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/282fa87b55521ed378ba7bc81182d38299f5bc1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/282fa87b55521ed378ba7bc81182d38299f5bc1a", "html_url": "https://github.com/rust-lang/rust/commit/282fa87b55521ed378ba7bc81182d38299f5bc1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/282fa87b55521ed378ba7bc81182d38299f5bc1a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "410d807e46b2538ab3ab2ebefcc68b44442d025a", "url": "https://api.github.com/repos/rust-lang/rust/commits/410d807e46b2538ab3ab2ebefcc68b44442d025a", "html_url": "https://github.com/rust-lang/rust/commit/410d807e46b2538ab3ab2ebefcc68b44442d025a"}, {"sha": "347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04", "url": "https://api.github.com/repos/rust-lang/rust/commits/347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04", "html_url": "https://github.com/rust-lang/rust/commit/347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04"}], "stats": {"total": 90, "additions": 68, "deletions": 22}, "files": [{"sha": "24ca476e5ff7994a36311f123cec3cace45b164a", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/282fa87b55521ed378ba7bc81182d38299f5bc1a/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/282fa87b55521ed378ba7bc81182d38299f5bc1a/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=282fa87b55521ed378ba7bc81182d38299f5bc1a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use util::nodemap::FxHashSet;\n+use util::nodemap::{FxHashMap, FxHashSet};\n use ty::context::TyCtxt;\n use ty::{AdtDef, VariantDef, FieldDef, TyS};\n use ty::{DefId, Substs};\n@@ -66,27 +66,21 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     /// Calculate the forest of DefIds from which this adt is visibly uninhabited.\n     pub fn uninhabited_from(\n                 &self,\n-                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n                 tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 substs: &'tcx Substs<'tcx>) -> DefIdForest\n     {\n-        if !visited.insert((self.did, substs)) {\n-            return DefIdForest::empty();\n-        }\n-\n-        let ret = DefIdForest::intersection(tcx, self.variants.iter().map(|v| {\n+        DefIdForest::intersection(tcx, self.variants.iter().map(|v| {\n             v.uninhabited_from(visited, tcx, substs, self.adt_kind())\n-        }));\n-        visited.remove(&(self.did, substs));\n-        ret\n+        }))\n     }\n }\n \n impl<'a, 'gcx, 'tcx> VariantDef {\n     /// Calculate the forest of DefIds from which this variant is visibly uninhabited.\n     pub fn uninhabited_from(\n                 &self,\n-                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n                 tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 substs: &'tcx Substs<'tcx>,\n                 adt_kind: AdtKind) -> DefIdForest\n@@ -115,12 +109,14 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n     /// Calculate the forest of DefIds from which this field is visibly uninhabited.\n     pub fn uninhabited_from(\n                 &self,\n-                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n                 tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 substs: &'tcx Substs<'tcx>,\n                 is_enum: bool) -> DefIdForest\n     {\n-        let mut data_uninhabitedness = move || self.ty(tcx, substs).uninhabited_from(visited, tcx);\n+        let mut data_uninhabitedness = move || {\n+            self.ty(tcx, substs).uninhabited_from(visited, tcx)\n+        };\n         // FIXME(canndrew): Currently enum fields are (incorrectly) stored with\n         // Visibility::Invisible so we need to override self.vis if we're\n         // dealing with an enum.\n@@ -144,7 +140,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// Calculate the forest of DefIds from which this type is visibly uninhabited.\n     pub fn uninhabited_from(\n                 &self,\n-                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n                 tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n     {\n         match tcx.lift_to_global(&self) {\n@@ -169,12 +165,37 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     fn uninhabited_from_inner(\n                 &self,\n-                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n                 tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n     {\n         match self.sty {\n             TyAdt(def, substs) => {\n-                def.uninhabited_from(visited, tcx, substs)\n+                {\n+                    let mut substs_set = visited.entry(def.did).or_insert(FxHashSet::default());\n+                    if !substs_set.insert(substs) {\n+                        // We are already calculating the inhabitedness of this type.\n+                        // The type must contain a reference to itself. Break the\n+                        // infinite loop.\n+                        return DefIdForest::empty();\n+                    }\n+                    if substs_set.len() >= tcx.sess.recursion_limit.get() / 4 {\n+                        // We have gone very deep, reinstantiating this ADT inside\n+                        // itself with different type arguments. We are probably\n+                        // hitting an infinite loop. For example, it's possible to write:\n+                        //                a type Foo<T>\n+                        //      which contains a Foo<(T, T)>\n+                        //      which contains a Foo<((T, T), (T, T))>\n+                        //      which contains a Foo<(((T, T), (T, T)), ((T, T), (T, T)))>\n+                        //      etc.\n+                        let error = format!(\"reached recursion limit while checking\n+                                             inhabitedness of `{}`\", self);\n+                        tcx.sess.fatal(&error);\n+                    }\n+                }\n+                let ret = def.uninhabited_from(visited, tcx, substs);\n+                let mut substs_set = visited.get_mut(&def.did).unwrap();\n+                substs_set.remove(substs);\n+                ret\n             },\n \n             TyNever => DefIdForest::full(tcx),"}, {"sha": "862bc15c0526001775f1088c92cb540be4ed225a", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/282fa87b55521ed378ba7bc81182d38299f5bc1a/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/282fa87b55521ed378ba7bc81182d38299f5bc1a/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=282fa87b55521ed378ba7bc81182d38299f5bc1a", "patch": "@@ -24,7 +24,7 @@ use std::cmp::Ordering;\n use syntax::abi;\n use syntax::ast::{self, Name};\n use syntax::symbol::{keywords, InternedString};\n-use util::nodemap::FxHashSet;\n+use util::nodemap::FxHashMap;\n \n use serialize;\n \n@@ -1018,7 +1018,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// This code should only compile in modules where the uninhabitedness of Foo is\n     /// visible.\n     pub fn is_uninhabited_from(&self, module: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n-        let mut visited = FxHashSet::default();\n+        let mut visited = FxHashMap::default();\n         let forest = self.uninhabited_from(&mut visited, tcx);\n \n         // To check whether this type is uninhabited at all (not just from the"}, {"sha": "78c4027aa4319297a1ab45100580d6e863b70c57", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/282fa87b55521ed378ba7bc81182d38299f5bc1a/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/282fa87b55521ed378ba7bc81182d38299f5bc1a/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=282fa87b55521ed378ba7bc81182d38299f5bc1a", "patch": "@@ -17,7 +17,7 @@ use eval::{compare_const_vals};\n \n use rustc_const_math::ConstInt;\n \n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n use pattern::{FieldPattern, Pattern, PatternKind};\n@@ -404,7 +404,7 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         }\n         ty::TyAdt(def, substs) if def.is_enum() && def.variants.len() != 1 => {\n             def.variants.iter().filter_map(|v| {\n-                let mut visited = FxHashSet::default();\n+                let mut visited = FxHashMap::default();\n                 let forest = v.uninhabited_from(&mut visited,\n                                                 cx.tcx, substs,\n                                                 AdtKind::Enum);"}, {"sha": "efddee2c933f40baf3bb7d80c1d19f4293232ebc", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/282fa87b55521ed378ba7bc81182d38299f5bc1a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/282fa87b55521ed378ba7bc81182d38299f5bc1a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=282fa87b55521ed378ba7bc81182d38299f5bc1a", "patch": "@@ -26,7 +26,7 @@ use build::{BlockAnd, BlockAndExtension, Builder};\n use build::matches::{Binding, MatchPair, Candidate};\n use hair::*;\n use rustc::mir::*;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxHashMap;\n \n use std::mem;\n \n@@ -102,7 +102,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 if self.hir.tcx().sess.features.borrow().never_type {\n                     let irrefutable = adt_def.variants.iter().enumerate().all(|(i, v)| {\n                         i == variant_index || {\n-                            let mut visited = FxHashSet::default();\n+                            let mut visited = FxHashMap::default();\n                             let node_set = v.uninhabited_from(&mut visited,\n                                                               self.hir.tcx(),\n                                                               substs,"}, {"sha": "91b85d7510a24bfc74405d5aa74df1bc2ede6398", "filename": "src/test/compile-fail/inhabitedness-infinite-loop.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/282fa87b55521ed378ba7bc81182d38299f5bc1a/src%2Ftest%2Fcompile-fail%2Finhabitedness-infinite-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/282fa87b55521ed378ba7bc81182d38299f5bc1a/src%2Ftest%2Fcompile-fail%2Finhabitedness-infinite-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finhabitedness-infinite-loop.rs?ref=282fa87b55521ed378ba7bc81182d38299f5bc1a", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:reached recursion limit\n+\n+#![feature(never_type)]\n+\n+struct Foo<'a, T: 'a> {\n+    ph: std::marker::PhantomData<T>,\n+    foo: &'a Foo<'a, (T, T)>,\n+}\n+\n+fn wub(f: Foo<!>) {\n+    match f {}\n+}\n+\n+fn main() {}\n+"}]}