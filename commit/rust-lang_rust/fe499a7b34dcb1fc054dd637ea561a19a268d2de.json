{"sha": "fe499a7b34dcb1fc054dd637ea561a19a268d2de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlNDk5YTdiMzRkY2IxZmMwNTRkZDYzN2VhNTYxYTE5YTI2OGQyZGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-19T00:24:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-19T00:24:39Z"}, "message": "Auto merge of #62684 - petrochenkov:scopevisit, r=davidtwco\n\nresolve: Improve candidate search for unresolved macro suggestions\n\nUse same scope visiting machinery for both collecting suggestion candidates and actually resolving the names.\n\nThe PR is better read in per-commit fashion with whitespace changes ignored (the first commit in particular moves some code around).\n\nThis should be the last pre-requisite for https://github.com/rust-lang/rust/pull/62086.\nr? @davidtwco", "tree": {"sha": "b4dbe1763cb8a971531e046b3a708e78dc2f6c26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4dbe1763cb8a971531e046b3a708e78dc2f6c26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe499a7b34dcb1fc054dd637ea561a19a268d2de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe499a7b34dcb1fc054dd637ea561a19a268d2de", "html_url": "https://github.com/rust-lang/rust/commit/fe499a7b34dcb1fc054dd637ea561a19a268d2de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe499a7b34dcb1fc054dd637ea561a19a268d2de/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3369981deff35f1c8d9a29e99358593959bd06e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3369981deff35f1c8d9a29e99358593959bd06e", "html_url": "https://github.com/rust-lang/rust/commit/a3369981deff35f1c8d9a29e99358593959bd06e"}, {"sha": "1b4fbfca4181c6779b75a4a1dc6c8fd538d6edcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b4fbfca4181c6779b75a4a1dc6c8fd538d6edcc", "html_url": "https://github.com/rust-lang/rust/commit/1b4fbfca4181c6779b75a4a1dc6c8fd538d6edcc"}], "stats": {"total": 2441, "additions": 1170, "deletions": 1271}, "files": [{"sha": "db568dbf9fb942b5cbba827e2dfeb05dd139e445", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -398,4 +398,12 @@ impl<Id> Res<Id> {\n             Res::Err => Res::Err,\n         }\n     }\n+\n+    pub fn macro_kind(self) -> Option<MacroKind> {\n+        match self {\n+            Res::Def(DefKind::Macro(kind), _) => Some(kind),\n+            Res::NonMacroAttr(..) => Some(MacroKind::Attr),\n+            _ => None,\n+        }\n+    }\n }"}, {"sha": "4554980071272d481ed81786517959aa5f80319b", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -3,11 +3,11 @@\n //! Here we build the \"reduced graph\": the graph of the module tree without\n //! any imports resolved.\n \n-use crate::macros::{InvocationData, ParentScope, LegacyScope};\n+use crate::macros::{InvocationData, LegacyScope};\n use crate::resolve_imports::ImportDirective;\n use crate::resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n use crate::{Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, Segment, ToNameBinding};\n-use crate::{ModuleOrUniformRoot, PerNS, Resolver, ResolverArenas, ExternPreludeEntry};\n+use crate::{ModuleOrUniformRoot, ParentScope, PerNS, Resolver, ResolverArenas, ExternPreludeEntry};\n use crate::Namespace::{self, TypeNS, ValueNS, MacroNS};\n use crate::{resolve_error, resolve_struct_error, ResolutionError, Determinacy};\n "}, {"sha": "90a4107f773e181fe55b0ee7fd471cceff3c67dc", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 648, "deletions": 25, "changes": 673, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -2,21 +2,84 @@ use std::cmp::Reverse;\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use log::debug;\n-use rustc::hir::def::{self, DefKind, CtorKind, Namespace::*};\n+use rustc::hir::def::{self, DefKind, CtorKind, NonMacroAttrKind};\n+use rustc::hir::def::Namespace::{self, *};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::PrimTy;\n use rustc::session::{Session, config::nightly_options};\n-use syntax::ast::{self, Expr, ExprKind, Ident};\n+use rustc::ty::{self, DefIdTree};\n+use rustc::util::nodemap::FxHashSet;\n+use syntax::ast::{self, Expr, ExprKind, Ident, NodeId, Path, Ty, TyKind};\n use syntax::ext::base::MacroKind;\n+use syntax::feature_gate::BUILTIN_ATTRIBUTES;\n use syntax::symbol::{Symbol, kw};\n+use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{BytePos, Span};\n \n+use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n+use crate::{is_self_type, is_self_value, path_names_to_string, KNOWN_TOOLS};\n+use crate::{CrateLint, LegacyScope, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{PathResult, PathSource, ParentScope, Resolver, RibKind, Scope, ScopeSet, Segment};\n+\n type Res = def::Res<ast::NodeId>;\n \n-use crate::macros::ParentScope;\n-use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n-use crate::{import_candidate_to_enum_paths, is_self_type, is_self_value, path_names_to_string};\n-use crate::{AssocSuggestion, CrateLint, ImportSuggestion, ModuleOrUniformRoot, PathResult,\n-            PathSource, Resolver, Segment, Suggestion};\n+/// A vector of spans and replacements, a message and applicability.\n+crate type Suggestion = (Vec<(Span, String)>, String, Applicability);\n+\n+/// A field or associated item from self type suggested in case of resolution failure.\n+enum AssocSuggestion {\n+    Field,\n+    MethodWithSelf,\n+    AssocItem,\n+}\n+\n+struct TypoSuggestion {\n+    candidate: Symbol,\n+\n+    /// The kind of the binding (\"crate\", \"module\", etc.)\n+    kind: &'static str,\n+\n+    /// An appropriate article to refer to the binding (\"a\", \"an\", etc.)\n+    article: &'static str,\n+}\n+\n+impl TypoSuggestion {\n+    fn from_res(candidate: Symbol, res: Res) -> TypoSuggestion {\n+        TypoSuggestion { candidate, kind: res.descr(), article: res.article() }\n+    }\n+}\n+\n+/// A free importable items suggested in case of resolution failure.\n+crate struct ImportSuggestion {\n+    did: Option<DefId>,\n+    pub path: Path,\n+}\n+\n+fn add_typo_suggestion(\n+    err: &mut DiagnosticBuilder<'_>, suggestion: Option<TypoSuggestion>, span: Span\n+) -> bool {\n+    if let Some(suggestion) = suggestion {\n+        let msg = format!(\"{} {} with a similar name exists\", suggestion.article, suggestion.kind);\n+        err.span_suggestion(\n+            span, &msg, suggestion.candidate.to_string(), Applicability::MaybeIncorrect\n+        );\n+        return true;\n+    }\n+    false\n+}\n+\n+fn add_module_candidates(\n+    module: Module<'_>, names: &mut Vec<TypoSuggestion>, filter_fn: &impl Fn(Res) -> bool\n+) {\n+    for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n+        if let Some(binding) = resolution.borrow().binding {\n+            let res = binding.res();\n+            if filter_fn(res) {\n+                names.push(TypoSuggestion::from_res(ident.name, res));\n+            }\n+        }\n+    }\n+}\n \n impl<'a> Resolver<'a> {\n     /// Handles error reporting for `smart_resolve_path_fragment` function.\n@@ -204,24 +267,10 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let mut levenshtein_worked = false;\n-\n         // Try Levenshtein algorithm.\n-        let suggestion = self.lookup_typo_candidate(path, ns, is_expected, span);\n-        if let Some(suggestion) = suggestion {\n-            let msg = format!(\n-                \"{} {} with a similar name exists\",\n-                suggestion.article, suggestion.kind\n-            );\n-            err.span_suggestion(\n-                ident_span,\n-                &msg,\n-                suggestion.candidate.to_string(),\n-                Applicability::MaybeIncorrect,\n-            );\n-\n-            levenshtein_worked = true;\n-        }\n+        let levenshtein_worked = add_typo_suggestion(\n+            &mut err, self.lookup_typo_candidate(path, ns, is_expected, span), ident_span\n+        );\n \n         // Try context-dependent help if relaxed lookup didn't work.\n         if let Some(res) = res {\n@@ -365,7 +414,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         match (res, source) {\n-            (Res::Def(DefKind::Macro(..), _), _) => {\n+            (Res::Def(DefKind::Macro(MacroKind::Bang), _), _) => {\n                 err.span_suggestion(\n                     span,\n                     \"use `!` to invoke the macro\",\n@@ -439,6 +488,513 @@ impl<'a> Resolver<'a> {\n         }\n         true\n     }\n+\n+    fn lookup_assoc_candidate<FilterFn>(&mut self,\n+                                        ident: Ident,\n+                                        ns: Namespace,\n+                                        filter_fn: FilterFn)\n+                                        -> Option<AssocSuggestion>\n+        where FilterFn: Fn(Res) -> bool\n+    {\n+        fn extract_node_id(t: &Ty) -> Option<NodeId> {\n+            match t.node {\n+                TyKind::Path(None, _) => Some(t.id),\n+                TyKind::Rptr(_, ref mut_ty) => extract_node_id(&mut_ty.ty),\n+                // This doesn't handle the remaining `Ty` variants as they are not\n+                // that commonly the self_type, it might be interesting to provide\n+                // support for those in future.\n+                _ => None,\n+            }\n+        }\n+\n+        // Fields are generally expected in the same contexts as locals.\n+        if filter_fn(Res::Local(ast::DUMMY_NODE_ID)) {\n+            if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n+                // Look for a field with the same name in the current self_type.\n+                if let Some(resolution) = self.partial_res_map.get(&node_id) {\n+                    match resolution.base_res() {\n+                        Res::Def(DefKind::Struct, did) | Res::Def(DefKind::Union, did)\n+                                if resolution.unresolved_segments() == 0 => {\n+                            if let Some(field_names) = self.field_names.get(&did) {\n+                                if field_names.iter().any(|&field_name| ident.name == field_name) {\n+                                    return Some(AssocSuggestion::Field);\n+                                }\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+        }\n+\n+        for assoc_type_ident in &self.current_trait_assoc_types {\n+            if *assoc_type_ident == ident {\n+                return Some(AssocSuggestion::AssocItem);\n+            }\n+        }\n+\n+        // Look for associated items in the current trait.\n+        if let Some((module, _)) = self.current_trait_ref {\n+            if let Ok(binding) = self.resolve_ident_in_module(\n+                    ModuleOrUniformRoot::Module(module),\n+                    ident,\n+                    ns,\n+                    None,\n+                    false,\n+                    module.span,\n+                ) {\n+                let res = binding.res();\n+                if filter_fn(res) {\n+                    return Some(if self.has_self.contains(&res.def_id()) {\n+                        AssocSuggestion::MethodWithSelf\n+                    } else {\n+                        AssocSuggestion::AssocItem\n+                    });\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    /// Lookup typo candidate in scope for a macro or import.\n+    fn early_lookup_typo_candidate(\n+        &mut self,\n+        scope_set: ScopeSet,\n+        parent_scope: &ParentScope<'a>,\n+        ident: Ident,\n+        filter_fn: &impl Fn(Res) -> bool,\n+    ) -> Option<TypoSuggestion> {\n+        let mut suggestions = Vec::new();\n+        self.visit_scopes(scope_set, parent_scope, ident, |this, scope, _| {\n+            match scope {\n+                Scope::DeriveHelpers => {\n+                    let res = Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n+                    if filter_fn(res) {\n+                        for derive in &parent_scope.derives {\n+                            let parent_scope = ParentScope { derives: Vec::new(), ..*parent_scope };\n+                            if let Ok((Some(ext), _)) = this.resolve_macro_path(\n+                                derive, Some(MacroKind::Derive), &parent_scope, false, false\n+                            ) {\n+                                suggestions.extend(ext.helper_attrs.iter().map(|name| {\n+                                    TypoSuggestion::from_res(*name, res)\n+                                }));\n+                            }\n+                        }\n+                    }\n+                }\n+                Scope::MacroRules(legacy_scope) => {\n+                    if let LegacyScope::Binding(legacy_binding) = legacy_scope {\n+                        let res = legacy_binding.binding.res();\n+                        if filter_fn(res) {\n+                            suggestions.push(\n+                                TypoSuggestion::from_res(legacy_binding.ident.name, res)\n+                            )\n+                        }\n+                    }\n+                }\n+                Scope::CrateRoot => {\n+                    let root_ident = Ident::new(kw::PathRoot, ident.span);\n+                    let root_module = this.resolve_crate_root(root_ident);\n+                    add_module_candidates(root_module, &mut suggestions, filter_fn);\n+                }\n+                Scope::Module(module) => {\n+                    add_module_candidates(module, &mut suggestions, filter_fn);\n+                }\n+                Scope::MacroUsePrelude => {\n+                    suggestions.extend(this.macro_use_prelude.iter().filter_map(|(name, binding)| {\n+                        let res = binding.res();\n+                        if filter_fn(res) {\n+                            Some(TypoSuggestion::from_res(*name, res))\n+                        } else {\n+                            None\n+                        }\n+                    }));\n+                }\n+                Scope::BuiltinMacros => {\n+                    suggestions.extend(this.builtin_macros.iter().filter_map(|(name, binding)| {\n+                        let res = binding.res();\n+                        if filter_fn(res) {\n+                            Some(TypoSuggestion::from_res(*name, res))\n+                        } else {\n+                            None\n+                        }\n+                    }));\n+                }\n+                Scope::BuiltinAttrs => {\n+                    let res = Res::NonMacroAttr(NonMacroAttrKind::Builtin);\n+                    if filter_fn(res) {\n+                        suggestions.extend(BUILTIN_ATTRIBUTES.iter().map(|(name, ..)| {\n+                            TypoSuggestion::from_res(*name, res)\n+                        }));\n+                    }\n+                }\n+                Scope::LegacyPluginHelpers => {\n+                    let res = Res::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper);\n+                    if filter_fn(res) {\n+                        let plugin_attributes = this.session.plugin_attributes.borrow();\n+                        suggestions.extend(plugin_attributes.iter().map(|(name, _)| {\n+                            TypoSuggestion::from_res(*name, res)\n+                        }));\n+                    }\n+                }\n+                Scope::ExternPrelude => {\n+                    suggestions.extend(this.extern_prelude.iter().filter_map(|(ident, _)| {\n+                        let res = Res::Def(DefKind::Mod, DefId::local(CRATE_DEF_INDEX));\n+                        if filter_fn(res) {\n+                            Some(TypoSuggestion::from_res(ident.name, res))\n+                        } else {\n+                            None\n+                        }\n+                    }));\n+                }\n+                Scope::ToolPrelude => {\n+                    let res = Res::NonMacroAttr(NonMacroAttrKind::Tool);\n+                    suggestions.extend(KNOWN_TOOLS.iter().map(|name| {\n+                        TypoSuggestion::from_res(*name, res)\n+                    }));\n+                }\n+                Scope::StdLibPrelude => {\n+                    if let Some(prelude) = this.prelude {\n+                        add_module_candidates(prelude, &mut suggestions, filter_fn);\n+                    }\n+                }\n+                Scope::BuiltinTypes => {\n+                    let primitive_types = &this.primitive_type_table.primitive_types;\n+                    suggestions.extend(\n+                        primitive_types.iter().flat_map(|(name, prim_ty)| {\n+                            let res = Res::PrimTy(*prim_ty);\n+                            if filter_fn(res) {\n+                                Some(TypoSuggestion::from_res(*name, res))\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                    )\n+                }\n+            }\n+\n+            None::<()>\n+        });\n+\n+        // Make sure error reporting is deterministic.\n+        suggestions.sort_by_cached_key(|suggestion| suggestion.candidate.as_str());\n+\n+        match find_best_match_for_name(\n+            suggestions.iter().map(|suggestion| &suggestion.candidate),\n+            &ident.as_str(),\n+            None,\n+        ) {\n+            Some(found) if found != ident.name => suggestions\n+                .into_iter()\n+                .find(|suggestion| suggestion.candidate == found),\n+            _ => None,\n+        }\n+    }\n+\n+    fn lookup_typo_candidate(\n+        &mut self,\n+        path: &[Segment],\n+        ns: Namespace,\n+        filter_fn: &impl Fn(Res) -> bool,\n+        span: Span,\n+    ) -> Option<TypoSuggestion> {\n+        let mut names = Vec::new();\n+        if path.len() == 1 {\n+            // Search in lexical scope.\n+            // Walk backwards up the ribs in scope and collect candidates.\n+            for rib in self.ribs[ns].iter().rev() {\n+                // Locals and type parameters\n+                for (ident, &res) in &rib.bindings {\n+                    if filter_fn(res) {\n+                        names.push(TypoSuggestion::from_res(ident.name, res));\n+                    }\n+                }\n+                // Items in scope\n+                if let RibKind::ModuleRibKind(module) = rib.kind {\n+                    // Items from this module\n+                    add_module_candidates(module, &mut names, &filter_fn);\n+\n+                    if let ModuleKind::Block(..) = module.kind {\n+                        // We can see through blocks\n+                    } else {\n+                        // Items from the prelude\n+                        if !module.no_implicit_prelude {\n+                            names.extend(self.extern_prelude.clone().iter().flat_map(|(ident, _)| {\n+                                self.crate_loader\n+                                    .maybe_process_path_extern(ident.name, ident.span)\n+                                    .and_then(|crate_id| {\n+                                        let crate_mod = Res::Def(\n+                                            DefKind::Mod,\n+                                            DefId {\n+                                                krate: crate_id,\n+                                                index: CRATE_DEF_INDEX,\n+                                            },\n+                                        );\n+\n+                                        if filter_fn(crate_mod) {\n+                                            Some(TypoSuggestion {\n+                                                candidate: ident.name,\n+                                                article: \"a\",\n+                                                kind: \"crate\",\n+                                            })\n+                                        } else {\n+                                            None\n+                                        }\n+                                    })\n+                            }));\n+\n+                            if let Some(prelude) = self.prelude {\n+                                add_module_candidates(prelude, &mut names, &filter_fn);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+            // Add primitive types to the mix\n+            if filter_fn(Res::PrimTy(PrimTy::Bool)) {\n+                names.extend(\n+                    self.primitive_type_table.primitive_types.iter().map(|(name, prim_ty)| {\n+                        TypoSuggestion::from_res(*name, Res::PrimTy(*prim_ty))\n+                    })\n+                )\n+            }\n+        } else {\n+            // Search in module.\n+            let mod_path = &path[..path.len() - 1];\n+            if let PathResult::Module(module) = self.resolve_path_without_parent_scope(\n+                mod_path, Some(TypeNS), false, span, CrateLint::No\n+            ) {\n+                if let ModuleOrUniformRoot::Module(module) = module {\n+                    add_module_candidates(module, &mut names, &filter_fn);\n+                }\n+            }\n+        }\n+\n+        let name = path[path.len() - 1].ident.name;\n+        // Make sure error reporting is deterministic.\n+        names.sort_by_cached_key(|suggestion| suggestion.candidate.as_str());\n+\n+        match find_best_match_for_name(\n+            names.iter().map(|suggestion| &suggestion.candidate),\n+            &name.as_str(),\n+            None,\n+        ) {\n+            Some(found) if found != name => names\n+                .into_iter()\n+                .find(|suggestion| suggestion.candidate == found),\n+            _ => None,\n+        }\n+    }\n+\n+    fn lookup_import_candidates_from_module<FilterFn>(&mut self,\n+                                          lookup_ident: Ident,\n+                                          namespace: Namespace,\n+                                          start_module: Module<'a>,\n+                                          crate_name: Ident,\n+                                          filter_fn: FilterFn)\n+                                          -> Vec<ImportSuggestion>\n+        where FilterFn: Fn(Res) -> bool\n+    {\n+        let mut candidates = Vec::new();\n+        let mut seen_modules = FxHashSet::default();\n+        let not_local_module = crate_name.name != kw::Crate;\n+        let mut worklist = vec![(start_module, Vec::<ast::PathSegment>::new(), not_local_module)];\n+\n+        while let Some((in_module,\n+                        path_segments,\n+                        in_module_is_extern)) = worklist.pop() {\n+            self.populate_module_if_necessary(in_module);\n+\n+            // We have to visit module children in deterministic order to avoid\n+            // instabilities in reported imports (#43552).\n+            in_module.for_each_child_stable(|ident, ns, name_binding| {\n+                // avoid imports entirely\n+                if name_binding.is_import() && !name_binding.is_extern_crate() { return; }\n+                // avoid non-importable candidates as well\n+                if !name_binding.is_importable() { return; }\n+\n+                // collect results based on the filter function\n+                if ident.name == lookup_ident.name && ns == namespace {\n+                    let res = name_binding.res();\n+                    if filter_fn(res) {\n+                        // create the path\n+                        let mut segms = path_segments.clone();\n+                        if lookup_ident.span.rust_2018() {\n+                            // crate-local absolute paths start with `crate::` in edition 2018\n+                            // FIXME: may also be stabilized for Rust 2015 (Issues #45477, #44660)\n+                            segms.insert(\n+                                0, ast::PathSegment::from_ident(crate_name)\n+                            );\n+                        }\n+\n+                        segms.push(ast::PathSegment::from_ident(ident));\n+                        let path = Path {\n+                            span: name_binding.span,\n+                            segments: segms,\n+                        };\n+                        // the entity is accessible in the following cases:\n+                        // 1. if it's defined in the same crate, it's always\n+                        // accessible (since private entities can be made public)\n+                        // 2. if it's defined in another crate, it's accessible\n+                        // only if both the module is public and the entity is\n+                        // declared as public (due to pruning, we don't explore\n+                        // outside crate private modules => no need to check this)\n+                        if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n+                            let did = match res {\n+                                Res::Def(DefKind::Ctor(..), did) => self.parent(did),\n+                                _ => res.opt_def_id(),\n+                            };\n+                            candidates.push(ImportSuggestion { did, path });\n+                        }\n+                    }\n+                }\n+\n+                // collect submodules to explore\n+                if let Some(module) = name_binding.module() {\n+                    // form the path\n+                    let mut path_segments = path_segments.clone();\n+                    path_segments.push(ast::PathSegment::from_ident(ident));\n+\n+                    let is_extern_crate_that_also_appears_in_prelude =\n+                        name_binding.is_extern_crate() &&\n+                        lookup_ident.span.rust_2018();\n+\n+                    let is_visible_to_user =\n+                        !in_module_is_extern || name_binding.vis == ty::Visibility::Public;\n+\n+                    if !is_extern_crate_that_also_appears_in_prelude && is_visible_to_user {\n+                        // add the module to the lookup\n+                        let is_extern = in_module_is_extern || name_binding.is_extern_crate();\n+                        if seen_modules.insert(module.def_id().unwrap()) {\n+                            worklist.push((module, path_segments, is_extern));\n+                        }\n+                    }\n+                }\n+            })\n+        }\n+\n+        candidates\n+    }\n+\n+    /// When name resolution fails, this method can be used to look up candidate\n+    /// entities with the expected name. It allows filtering them using the\n+    /// supplied predicate (which should be used to only accept the types of\n+    /// definitions expected, e.g., traits). The lookup spans across all crates.\n+    ///\n+    /// N.B., the method does not look into imports, but this is not a problem,\n+    /// since we report the definitions (thus, the de-aliased imports).\n+    crate fn lookup_import_candidates<FilterFn>(\n+        &mut self, lookup_ident: Ident, namespace: Namespace, filter_fn: FilterFn\n+    ) -> Vec<ImportSuggestion>\n+        where FilterFn: Fn(Res) -> bool\n+    {\n+        let mut suggestions = self.lookup_import_candidates_from_module(\n+            lookup_ident, namespace, self.graph_root, Ident::with_empty_ctxt(kw::Crate), &filter_fn\n+        );\n+\n+        if lookup_ident.span.rust_2018() {\n+            let extern_prelude_names = self.extern_prelude.clone();\n+            for (ident, _) in extern_prelude_names.into_iter() {\n+                if let Some(crate_id) = self.crate_loader.maybe_process_path_extern(ident.name,\n+                                                                                    ident.span) {\n+                    let crate_root = self.get_module(DefId {\n+                        krate: crate_id,\n+                        index: CRATE_DEF_INDEX,\n+                    });\n+                    self.populate_module_if_necessary(&crate_root);\n+\n+                    suggestions.extend(self.lookup_import_candidates_from_module(\n+                        lookup_ident, namespace, crate_root, ident, &filter_fn));\n+                }\n+            }\n+        }\n+\n+        suggestions\n+    }\n+\n+    fn find_module(&mut self, def_id: DefId) -> Option<(Module<'a>, ImportSuggestion)> {\n+        let mut result = None;\n+        let mut seen_modules = FxHashSet::default();\n+        let mut worklist = vec![(self.graph_root, Vec::new())];\n+\n+        while let Some((in_module, path_segments)) = worklist.pop() {\n+            // abort if the module is already found\n+            if result.is_some() { break; }\n+\n+            self.populate_module_if_necessary(in_module);\n+\n+            in_module.for_each_child_stable(|ident, _, name_binding| {\n+                // abort if the module is already found or if name_binding is private external\n+                if result.is_some() || !name_binding.vis.is_visible_locally() {\n+                    return\n+                }\n+                if let Some(module) = name_binding.module() {\n+                    // form the path\n+                    let mut path_segments = path_segments.clone();\n+                    path_segments.push(ast::PathSegment::from_ident(ident));\n+                    let module_def_id = module.def_id().unwrap();\n+                    if module_def_id == def_id {\n+                        let path = Path {\n+                            span: name_binding.span,\n+                            segments: path_segments,\n+                        };\n+                        result = Some((module, ImportSuggestion { did: Some(def_id), path }));\n+                    } else {\n+                        // add the module to the lookup\n+                        if seen_modules.insert(module_def_id) {\n+                            worklist.push((module, path_segments));\n+                        }\n+                    }\n+                }\n+            });\n+        }\n+\n+        result\n+    }\n+\n+    fn collect_enum_variants(&mut self, def_id: DefId) -> Option<Vec<Path>> {\n+        self.find_module(def_id).map(|(enum_module, enum_import_suggestion)| {\n+            self.populate_module_if_necessary(enum_module);\n+\n+            let mut variants = Vec::new();\n+            enum_module.for_each_child_stable(|ident, _, name_binding| {\n+                if let Res::Def(DefKind::Variant, _) = name_binding.res() {\n+                    let mut segms = enum_import_suggestion.path.segments.clone();\n+                    segms.push(ast::PathSegment::from_ident(ident));\n+                    variants.push(Path {\n+                        span: name_binding.span,\n+                        segments: segms,\n+                    });\n+                }\n+            });\n+            variants\n+        })\n+    }\n+\n+    crate fn unresolved_macro_suggestions(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'a>,\n+        macro_kind: MacroKind,\n+        parent_scope: &ParentScope<'a>,\n+        ident: Ident,\n+    ) {\n+        let is_expected = &|res: Res| res.macro_kind() == Some(macro_kind);\n+        let suggestion = self.early_lookup_typo_candidate(\n+            ScopeSet::Macro(macro_kind), &parent_scope, ident, is_expected\n+        );\n+        add_typo_suggestion(err, suggestion, ident.span);\n+\n+        if macro_kind == MacroKind::Derive &&\n+           (ident.as_str() == \"Send\" || ident.as_str() == \"Sync\") {\n+            let msg = format!(\"unsafe traits like `{}` should be implemented explicitly\", ident);\n+            err.span_note(ident.span, &msg);\n+        }\n+        if self.macro_names.contains(&ident.modern()) {\n+            err.help(\"have you added the `#[macro_use]` on the module/import?\");\n+        }\n+    }\n }\n \n impl<'a, 'b> ImportResolver<'a, 'b> {\n@@ -871,3 +1427,70 @@ fn find_span_immediately_after_crate_name(\n \n     (next_left_bracket == after_second_colon, from_second_colon)\n }\n+\n+/// Gets the stringified path for an enum from an `ImportSuggestion` for an enum variant.\n+fn import_candidate_to_enum_paths(suggestion: &ImportSuggestion) -> (String, String) {\n+    let variant_path = &suggestion.path;\n+    let variant_path_string = path_names_to_string(variant_path);\n+\n+    let path_len = suggestion.path.segments.len();\n+    let enum_path = ast::Path {\n+        span: suggestion.path.span,\n+        segments: suggestion.path.segments[0..path_len - 1].to_vec(),\n+    };\n+    let enum_path_string = path_names_to_string(&enum_path);\n+\n+    (variant_path_string, enum_path_string)\n+}\n+\n+/// When an entity with a given name is not available in scope, we search for\n+/// entities with that name in all crates. This method allows outputting the\n+/// results of this search in a programmer-friendly way\n+crate fn show_candidates(\n+    err: &mut DiagnosticBuilder<'_>,\n+    // This is `None` if all placement locations are inside expansions\n+    span: Option<Span>,\n+    candidates: &[ImportSuggestion],\n+    better: bool,\n+    found_use: bool,\n+) {\n+    // we want consistent results across executions, but candidates are produced\n+    // by iterating through a hash map, so make sure they are ordered:\n+    let mut path_strings: Vec<_> =\n+        candidates.into_iter().map(|c| path_names_to_string(&c.path)).collect();\n+    path_strings.sort();\n+\n+    let better = if better { \"better \" } else { \"\" };\n+    let msg_diff = match path_strings.len() {\n+        1 => \" is found in another module, you can import it\",\n+        _ => \"s are found in other modules, you can import them\",\n+    };\n+    let msg = format!(\"possible {}candidate{} into scope\", better, msg_diff);\n+\n+    if let Some(span) = span {\n+        for candidate in &mut path_strings {\n+            // produce an additional newline to separate the new use statement\n+            // from the directly following item.\n+            let additional_newline = if found_use {\n+                \"\"\n+            } else {\n+                \"\\n\"\n+            };\n+            *candidate = format!(\"use {};\\n{}\", candidate, additional_newline);\n+        }\n+\n+        err.span_suggestions(\n+            span,\n+            &msg,\n+            path_strings.into_iter(),\n+            Applicability::Unspecified,\n+        );\n+    } else {\n+        let mut msg = msg;\n+        msg.push(':');\n+        for candidate in path_strings {\n+            msg.push('\\n');\n+            msg.push_str(&candidate);\n+        }\n+    }\n+}"}, {"sha": "ba8cfdcf53548afad8d96864e003bdeea3c7ef7b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 198, "deletions": 493, "changes": 691, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -31,7 +31,7 @@ use rustc::hir::def::{\n use rustc::hir::def::Namespace::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::hir::{TraitCandidate, TraitMap, GlobMap};\n-use rustc::ty::{self, DefIdTree};\n+use rustc::ty;\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n use rustc::{bug, span_bug};\n \n@@ -69,9 +69,10 @@ use rustc_data_structures::ptr_key::PtrKey;\n use rustc_data_structures::sync::Lrc;\n use smallvec::SmallVec;\n \n+use diagnostics::{Suggestion, ImportSuggestion};\n use diagnostics::{find_span_of_binding_until_next_binding, extend_span_to_previous_binding};\n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n-use macros::{InvocationData, LegacyBinding, ParentScope};\n+use macros::{InvocationData, LegacyBinding, LegacyScope};\n \n type Res = def::Res<NodeId>;\n \n@@ -84,9 +85,7 @@ mod check_unused;\n mod build_reduced_graph;\n mod resolve_imports;\n \n-fn is_known_tool(name: Name) -> bool {\n-    [\"clippy\", \"rustfmt\"].contains(&&*name.as_str())\n-}\n+const KNOWN_TOOLS: &[Name] = &[sym::clippy, sym::rustfmt];\n \n enum Weak {\n     Yes,\n@@ -105,24 +104,46 @@ impl Determinacy {\n     }\n }\n \n+/// A specific scope in which a name can be looked up.\n+/// This enum is currently used only for early resolution (imports and macros),\n+/// but not for late resolution yet.\n+#[derive(Clone, Copy)]\n+enum Scope<'a> {\n+    DeriveHelpers,\n+    MacroRules(LegacyScope<'a>),\n+    CrateRoot,\n+    Module(Module<'a>),\n+    MacroUsePrelude,\n+    BuiltinMacros,\n+    BuiltinAttrs,\n+    LegacyPluginHelpers,\n+    ExternPrelude,\n+    ToolPrelude,\n+    StdLibPrelude,\n+    BuiltinTypes,\n+}\n+\n+/// Names from different contexts may want to visit different subsets of all specific scopes\n+/// with different restrictions when looking up the resolution.\n+/// This enum is currently used only for early resolution (imports and macros),\n+/// but not for late resolution yet.\n enum ScopeSet {\n     Import(Namespace),\n     AbsolutePath(Namespace),\n     Macro(MacroKind),\n     Module,\n }\n \n-/// A free importable items suggested in case of resolution failure.\n-struct ImportSuggestion {\n-    did: Option<DefId>,\n-    path: Path,\n-}\n-\n-/// A field or associated item from self type suggested in case of resolution failure.\n-enum AssocSuggestion {\n-    Field,\n-    MethodWithSelf,\n-    AssocItem,\n+/// Everything you need to know about a name's location to resolve it.\n+/// Serves as a starting point for the scope visitor.\n+/// This struct is currently used only for early resolution (imports and macros),\n+/// but not for late resolution yet.\n+#[derive(Clone, Debug)]\n+pub struct ParentScope<'a> {\n+    module: Module<'a>,\n+    expansion: Mark,\n+    legacy: LegacyScope<'a>,\n+    derives: Vec<ast::Path>,\n }\n \n #[derive(Eq)]\n@@ -132,16 +153,6 @@ struct BindingError {\n     target: BTreeSet<Span>,\n }\n \n-struct TypoSuggestion {\n-    candidate: Symbol,\n-\n-    /// The kind of the binding (\"crate\", \"module\", etc.)\n-    kind: &'static str,\n-\n-    /// An appropriate article to refer to the binding (\"a\", \"an\", etc.)\n-    article: &'static str,\n-}\n-\n impl PartialOrd for BindingError {\n     fn partial_cmp(&self, other: &BindingError) -> Option<cmp::Ordering> {\n         Some(self.cmp(other))\n@@ -160,9 +171,6 @@ impl Ord for BindingError {\n     }\n }\n \n-/// A vector of spans and replacements, a message and applicability.\n-type Suggestion = (Vec<(Span, String)>, String, Applicability);\n-\n enum ResolutionError<'a> {\n     /// Error E0401: can't use type or const parameters from outer function.\n     GenericParamsFromOuterFunction(Res),\n@@ -1488,11 +1496,7 @@ impl<'a> NameBinding<'a> {\n     }\n \n     fn macro_kind(&self) -> Option<MacroKind> {\n-        match self.res() {\n-            Res::Def(DefKind::Macro(kind), _) => Some(kind),\n-            Res::NonMacroAttr(..) => Some(MacroKind::Attr),\n-            _ => None,\n-        }\n+        self.res().macro_kind()\n     }\n \n     fn descr(&self) -> &'static str {\n@@ -2134,6 +2138,149 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    /// A generic scope visitor.\n+    /// Visits scopes in order to resolve some identifier in them or perform other actions.\n+    /// If the callback returns `Some` result, we stop visiting scopes and return it.\n+    fn visit_scopes<T>(\n+        &mut self,\n+        scope_set: ScopeSet,\n+        parent_scope: &ParentScope<'a>,\n+        ident: Ident,\n+        mut visitor: impl FnMut(&mut Self, Scope<'a>, Ident) -> Option<T>,\n+    ) -> Option<T> {\n+        // General principles:\n+        // 1. Not controlled (user-defined) names should have higher priority than controlled names\n+        //    built into the language or standard library. This way we can add new names into the\n+        //    language or standard library without breaking user code.\n+        // 2. \"Closed set\" below means new names cannot appear after the current resolution attempt.\n+        // Places to search (in order of decreasing priority):\n+        // (Type NS)\n+        // 1. FIXME: Ribs (type parameters), there's no necessary infrastructure yet\n+        //    (open set, not controlled).\n+        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n+        //    (open, not controlled).\n+        // 3. Extern prelude (open, the open part is from macro expansions, not controlled).\n+        // 4. Tool modules (closed, controlled right now, but not in the future).\n+        // 5. Standard library prelude (de-facto closed, controlled).\n+        // 6. Language prelude (closed, controlled).\n+        // (Value NS)\n+        // 1. FIXME: Ribs (local variables), there's no necessary infrastructure yet\n+        //    (open set, not controlled).\n+        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n+        //    (open, not controlled).\n+        // 3. Standard library prelude (de-facto closed, controlled).\n+        // (Macro NS)\n+        // 1-3. Derive helpers (open, not controlled). All ambiguities with other names\n+        //    are currently reported as errors. They should be higher in priority than preludes\n+        //    and probably even names in modules according to the \"general principles\" above. They\n+        //    also should be subject to restricted shadowing because are effectively produced by\n+        //    derives (you need to resolve the derive first to add helpers into scope), but they\n+        //    should be available before the derive is expanded for compatibility.\n+        //    It's mess in general, so we are being conservative for now.\n+        // 1-3. `macro_rules` (open, not controlled), loop through legacy scopes. Have higher\n+        //    priority than prelude macros, but create ambiguities with macros in modules.\n+        // 1-3. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n+        //    (open, not controlled). Have higher priority than prelude macros, but create\n+        //    ambiguities with `macro_rules`.\n+        // 4. `macro_use` prelude (open, the open part is from macro expansions, not controlled).\n+        // 4a. User-defined prelude from macro-use\n+        //    (open, the open part is from macro expansions, not controlled).\n+        // 4b. Standard library prelude is currently implemented as `macro-use` (closed, controlled)\n+        // 5. Language prelude: builtin macros (closed, controlled, except for legacy plugins).\n+        // 6. Language prelude: builtin attributes (closed, controlled).\n+        // 4-6. Legacy plugin helpers (open, not controlled). Similar to derive helpers,\n+        //    but introduced by legacy plugins using `register_attribute`. Priority is somewhere\n+        //    in prelude, not sure where exactly (creates ambiguities with any other prelude names).\n+\n+        let rust_2015 = ident.span.rust_2015();\n+        let (ns, is_absolute_path) = match scope_set {\n+            ScopeSet::Import(ns) => (ns, false),\n+            ScopeSet::AbsolutePath(ns) => (ns, true),\n+            ScopeSet::Macro(_) => (MacroNS, false),\n+            ScopeSet::Module => (TypeNS, false),\n+        };\n+        let mut scope = match ns {\n+            _ if is_absolute_path => Scope::CrateRoot,\n+            TypeNS | ValueNS => Scope::Module(parent_scope.module),\n+            MacroNS => Scope::DeriveHelpers,\n+        };\n+        let mut ident = ident.modern();\n+        let mut use_prelude = !parent_scope.module.no_implicit_prelude;\n+\n+        loop {\n+            let visit = match scope {\n+                Scope::DeriveHelpers => true,\n+                Scope::MacroRules(..) => true,\n+                Scope::CrateRoot => true,\n+                Scope::Module(..) => true,\n+                Scope::MacroUsePrelude => use_prelude || rust_2015,\n+                Scope::BuiltinMacros => true,\n+                Scope::BuiltinAttrs => true,\n+                Scope::LegacyPluginHelpers => use_prelude || rust_2015,\n+                Scope::ExternPrelude => use_prelude || is_absolute_path,\n+                Scope::ToolPrelude => use_prelude,\n+                Scope::StdLibPrelude => use_prelude,\n+                Scope::BuiltinTypes => true,\n+            };\n+\n+            if visit {\n+                if let break_result @ Some(..) = visitor(self, scope, ident) {\n+                    return break_result;\n+                }\n+            }\n+\n+            scope = match scope {\n+                Scope::DeriveHelpers =>\n+                    Scope::MacroRules(parent_scope.legacy),\n+                Scope::MacroRules(legacy_scope) => match legacy_scope {\n+                    LegacyScope::Binding(binding) => Scope::MacroRules(\n+                        binding.parent_legacy_scope\n+                    ),\n+                    LegacyScope::Invocation(invoc) => Scope::MacroRules(\n+                        invoc.output_legacy_scope.get().unwrap_or(invoc.parent_legacy_scope)\n+                    ),\n+                    LegacyScope::Empty => Scope::Module(parent_scope.module),\n+                }\n+                Scope::CrateRoot => match ns {\n+                    TypeNS => {\n+                        ident.span.adjust(Mark::root());\n+                        Scope::ExternPrelude\n+                    }\n+                    ValueNS | MacroNS => break,\n+                }\n+                Scope::Module(module) => {\n+                    use_prelude = !module.no_implicit_prelude;\n+                    match self.hygienic_lexical_parent(module, &mut ident.span) {\n+                        Some(parent_module) => Scope::Module(parent_module),\n+                        None => {\n+                            ident.span.adjust(Mark::root());\n+                            match ns {\n+                                TypeNS => Scope::ExternPrelude,\n+                                ValueNS => Scope::StdLibPrelude,\n+                                MacroNS => Scope::MacroUsePrelude,\n+                            }\n+                        }\n+                    }\n+                }\n+                Scope::MacroUsePrelude => Scope::StdLibPrelude,\n+                Scope::BuiltinMacros => Scope::BuiltinAttrs,\n+                Scope::BuiltinAttrs => Scope::LegacyPluginHelpers,\n+                Scope::LegacyPluginHelpers => break, // nowhere else to search\n+                Scope::ExternPrelude if is_absolute_path => break,\n+                Scope::ExternPrelude => Scope::ToolPrelude,\n+                Scope::ToolPrelude => Scope::StdLibPrelude,\n+                Scope::StdLibPrelude => match ns {\n+                    TypeNS => Scope::BuiltinTypes,\n+                    ValueNS => break, // nowhere else to search\n+                    MacroNS => Scope::BuiltinMacros,\n+                }\n+                Scope::BuiltinTypes => break, // nowhere else to search\n+            };\n+        }\n+\n+        None\n+    }\n+\n     /// This resolves the identifier `ident` in the namespace `ns` in the current lexical scope.\n     /// More specifically, we proceed up the hierarchy of scopes and return the binding for\n     /// `ident` in the first scope that defines it (or None if no scopes define it).\n@@ -2258,7 +2405,7 @@ impl<'a> Resolver<'a> {\n                     return Some(LexicalScopeBinding::Item(binding));\n                 }\n             }\n-            if ns == TypeNS && is_known_tool(ident.name) {\n+            if ns == TypeNS && KNOWN_TOOLS.contains(&ident.name) {\n                 let binding = (Res::ToolMod, ty::Visibility::Public,\n                                DUMMY_SP, Mark::root()).to_name_binding(self.arenas);\n                 return Some(LexicalScopeBinding::Item(binding));\n@@ -3517,9 +3664,7 @@ impl<'a> Resolver<'a> {\n         crate_lint: CrateLint,\n     ) -> Option<PartialRes> {\n         let mut fin_res = None;\n-        // FIXME: can't resolve paths in macro namespace yet, macros are\n-        // processed by the little special hack below.\n-        for (i, ns) in [primary_ns, TypeNS, ValueNS, /*MacroNS*/].iter().cloned().enumerate() {\n+        for (i, ns) in [primary_ns, TypeNS, ValueNS].iter().cloned().enumerate() {\n             if i == 0 || ns != primary_ns {\n                 match self.resolve_qpath(id, qself, path, ns, span, global_by_default, crate_lint) {\n                     // If defer_to_typeck, then resolution > no resolution,\n@@ -3528,21 +3673,23 @@ impl<'a> Resolver<'a> {\n                                          defer_to_typeck =>\n                         return Some(partial_res),\n                     partial_res => if fin_res.is_none() { fin_res = partial_res },\n-                };\n+                }\n             }\n         }\n-        if primary_ns != MacroNS &&\n-           (self.macro_names.contains(&path[0].ident.modern()) ||\n-            self.builtin_macros.get(&path[0].ident.name).cloned()\n-                               .and_then(NameBinding::macro_kind) == Some(MacroKind::Bang) ||\n-            self.macro_use_prelude.get(&path[0].ident.name).cloned()\n-                                  .and_then(NameBinding::macro_kind) == Some(MacroKind::Bang)) {\n-            // Return some dummy definition, it's enough for error reporting.\n-            return Some(PartialRes::new(Res::Def(\n-                DefKind::Macro(MacroKind::Bang),\n-                DefId::local(CRATE_DEF_INDEX),\n-            )));\n+\n+        // `MacroNS`\n+        assert!(primary_ns != MacroNS);\n+        if qself.is_none() {\n+            let path_seg = |seg: &Segment| ast::PathSegment::from_ident(seg.ident);\n+            let path = Path { segments: path.iter().map(path_seg).collect(), span };\n+            let parent_scope =\n+                ParentScope { module: self.current_module, ..self.dummy_parent_scope() };\n+            if let Ok((_, res)) =\n+                    self.resolve_macro_path(&path, None, &parent_scope, false, false) {\n+                return Some(PartialRes::new(res));\n+            }\n         }\n+\n         fin_res\n     }\n \n@@ -4124,195 +4271,6 @@ impl<'a> Resolver<'a> {\n         res\n     }\n \n-    fn lookup_assoc_candidate<FilterFn: Fn(Res) -> bool>(\n-        &mut self,\n-        ident: Ident,\n-        ns: Namespace,\n-        filter_fn: FilterFn,\n-    ) -> Option<AssocSuggestion> {\n-        fn extract_node_id(t: &Ty) -> Option<NodeId> {\n-            match t.node {\n-                TyKind::Path(None, _) => Some(t.id),\n-                TyKind::Rptr(_, ref mut_ty) => extract_node_id(&mut_ty.ty),\n-                // This doesn't handle the remaining `Ty` variants as they are not\n-                // that commonly the self_type, it might be interesting to provide\n-                // support for those in future.\n-                _ => None,\n-            }\n-        }\n-\n-        // Fields are generally expected in the same contexts as locals.\n-        if filter_fn(Res::Local(ast::DUMMY_NODE_ID)) {\n-            if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n-                // Look for a field with the same name in the current self_type.\n-                if let Some(resolution) = self.partial_res_map.get(&node_id) {\n-                    match resolution.base_res() {\n-                        Res::Def(DefKind::Struct, did) | Res::Def(DefKind::Union, did)\n-                                if resolution.unresolved_segments() == 0 => {\n-                            if let Some(field_names) = self.field_names.get(&did) {\n-                                if field_names.iter().any(|&field_name| ident.name == field_name) {\n-                                    return Some(AssocSuggestion::Field);\n-                                }\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n-        }\n-\n-        for assoc_type_ident in &self.current_trait_assoc_types {\n-            if *assoc_type_ident == ident {\n-                return Some(AssocSuggestion::AssocItem);\n-            }\n-        }\n-\n-        // Look for associated items in the current trait.\n-        if let Some((module, _)) = self.current_trait_ref {\n-            if let Ok(binding) = self.resolve_ident_in_module(\n-                    ModuleOrUniformRoot::Module(module),\n-                    ident,\n-                    ns,\n-                    None,\n-                    false,\n-                    module.span,\n-                ) {\n-                let res = binding.res();\n-                if filter_fn(res) {\n-                    debug!(\"extract_node_id res not filtered\");\n-                    return Some(if self.has_self.contains(&res.def_id()) {\n-                        AssocSuggestion::MethodWithSelf\n-                    } else {\n-                        AssocSuggestion::AssocItem\n-                    });\n-                }\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    fn lookup_typo_candidate<FilterFn>(\n-        &mut self,\n-        path: &[Segment],\n-        ns: Namespace,\n-        filter_fn: FilterFn,\n-        span: Span,\n-    ) -> Option<TypoSuggestion>\n-    where\n-        FilterFn: Fn(Res) -> bool,\n-    {\n-        let add_module_candidates = |module: Module<'_>, names: &mut Vec<TypoSuggestion>| {\n-            for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n-                if let Some(binding) = resolution.borrow().binding {\n-                    if filter_fn(binding.res()) {\n-                        names.push(TypoSuggestion {\n-                            candidate: ident.name,\n-                            article: binding.res().article(),\n-                            kind: binding.res().descr(),\n-                        });\n-                    }\n-                }\n-            }\n-        };\n-\n-        let mut names = Vec::new();\n-        if path.len() == 1 {\n-            // Search in lexical scope.\n-            // Walk backwards up the ribs in scope and collect candidates.\n-            for rib in self.ribs[ns].iter().rev() {\n-                // Locals and type parameters\n-                for (ident, &res) in &rib.bindings {\n-                    if filter_fn(res) {\n-                        names.push(TypoSuggestion {\n-                            candidate: ident.name,\n-                            article: res.article(),\n-                            kind: res.descr(),\n-                        });\n-                    }\n-                }\n-                // Items in scope\n-                if let ModuleRibKind(module) = rib.kind {\n-                    // Items from this module\n-                    add_module_candidates(module, &mut names);\n-\n-                    if let ModuleKind::Block(..) = module.kind {\n-                        // We can see through blocks\n-                    } else {\n-                        // Items from the prelude\n-                        if !module.no_implicit_prelude {\n-                            names.extend(self.extern_prelude.clone().iter().flat_map(|(ident, _)| {\n-                                self.crate_loader\n-                                    .maybe_process_path_extern(ident.name, ident.span)\n-                                    .and_then(|crate_id| {\n-                                        let crate_mod = Res::Def(\n-                                            DefKind::Mod,\n-                                            DefId {\n-                                                krate: crate_id,\n-                                                index: CRATE_DEF_INDEX,\n-                                            },\n-                                        );\n-\n-                                        if filter_fn(crate_mod) {\n-                                            Some(TypoSuggestion {\n-                                                candidate: ident.name,\n-                                                article: \"a\",\n-                                                kind: \"crate\",\n-                                            })\n-                                        } else {\n-                                            None\n-                                        }\n-                                    })\n-                            }));\n-\n-                            if let Some(prelude) = self.prelude {\n-                                add_module_candidates(prelude, &mut names);\n-                            }\n-                        }\n-                        break;\n-                    }\n-                }\n-            }\n-            // Add primitive types to the mix\n-            if filter_fn(Res::PrimTy(Bool)) {\n-                names.extend(\n-                    self.primitive_type_table.primitive_types.iter().map(|(name, _)| {\n-                        TypoSuggestion {\n-                            candidate: *name,\n-                            article: \"a\",\n-                            kind: \"primitive type\",\n-                        }\n-                    })\n-                )\n-            }\n-        } else {\n-            // Search in module.\n-            let mod_path = &path[..path.len() - 1];\n-            if let PathResult::Module(module) = self.resolve_path_without_parent_scope(\n-                mod_path, Some(TypeNS), false, span, CrateLint::No\n-            ) {\n-                if let ModuleOrUniformRoot::Module(module) = module {\n-                    add_module_candidates(module, &mut names);\n-                }\n-            }\n-        }\n-\n-        let name = path[path.len() - 1].ident.name;\n-        // Make sure error reporting is deterministic.\n-        names.sort_by_cached_key(|suggestion| suggestion.candidate.as_str());\n-\n-        match find_best_match_for_name(\n-            names.iter().map(|suggestion| &suggestion.candidate),\n-            &name.as_str(),\n-            None,\n-        ) {\n-            Some(found) if found != name => names\n-                .into_iter()\n-                .find(|suggestion| suggestion.candidate == found),\n-            _ => None,\n-        }\n-    }\n-\n     fn with_resolved_label<F>(&mut self, label: Option<Label>, id: NodeId, f: F)\n         where F: FnOnce(&mut Resolver<'_>)\n     {\n@@ -4606,193 +4564,6 @@ impl<'a> Resolver<'a> {\n         import_ids\n     }\n \n-    fn lookup_import_candidates_from_module<FilterFn>(&mut self,\n-                                          lookup_ident: Ident,\n-                                          namespace: Namespace,\n-                                          start_module: &'a ModuleData<'a>,\n-                                          crate_name: Ident,\n-                                          filter_fn: FilterFn)\n-                                          -> Vec<ImportSuggestion>\n-        where FilterFn: Fn(Res) -> bool\n-    {\n-        let mut candidates = Vec::new();\n-        let mut seen_modules = FxHashSet::default();\n-        let not_local_module = crate_name.name != kw::Crate;\n-        let mut worklist = vec![(start_module, Vec::<ast::PathSegment>::new(), not_local_module)];\n-\n-        while let Some((in_module,\n-                        path_segments,\n-                        in_module_is_extern)) = worklist.pop() {\n-            self.populate_module_if_necessary(in_module);\n-\n-            // We have to visit module children in deterministic order to avoid\n-            // instabilities in reported imports (#43552).\n-            in_module.for_each_child_stable(|ident, ns, name_binding| {\n-                // avoid imports entirely\n-                if name_binding.is_import() && !name_binding.is_extern_crate() { return; }\n-                // avoid non-importable candidates as well\n-                if !name_binding.is_importable() { return; }\n-\n-                // collect results based on the filter function\n-                if ident.name == lookup_ident.name && ns == namespace {\n-                    let res = name_binding.res();\n-                    if filter_fn(res) {\n-                        // create the path\n-                        let mut segms = path_segments.clone();\n-                        if lookup_ident.span.rust_2018() {\n-                            // crate-local absolute paths start with `crate::` in edition 2018\n-                            // FIXME: may also be stabilized for Rust 2015 (Issues #45477, #44660)\n-                            segms.insert(\n-                                0, ast::PathSegment::from_ident(crate_name)\n-                            );\n-                        }\n-\n-                        segms.push(ast::PathSegment::from_ident(ident));\n-                        let path = Path {\n-                            span: name_binding.span,\n-                            segments: segms,\n-                        };\n-                        // the entity is accessible in the following cases:\n-                        // 1. if it's defined in the same crate, it's always\n-                        // accessible (since private entities can be made public)\n-                        // 2. if it's defined in another crate, it's accessible\n-                        // only if both the module is public and the entity is\n-                        // declared as public (due to pruning, we don't explore\n-                        // outside crate private modules => no need to check this)\n-                        if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n-                            let did = match res {\n-                                Res::Def(DefKind::Ctor(..), did) => self.parent(did),\n-                                _ => res.opt_def_id(),\n-                            };\n-                            candidates.push(ImportSuggestion { did, path });\n-                        }\n-                    }\n-                }\n-\n-                // collect submodules to explore\n-                if let Some(module) = name_binding.module() {\n-                    // form the path\n-                    let mut path_segments = path_segments.clone();\n-                    path_segments.push(ast::PathSegment::from_ident(ident));\n-\n-                    let is_extern_crate_that_also_appears_in_prelude =\n-                        name_binding.is_extern_crate() &&\n-                        lookup_ident.span.rust_2018();\n-\n-                    let is_visible_to_user =\n-                        !in_module_is_extern || name_binding.vis == ty::Visibility::Public;\n-\n-                    if !is_extern_crate_that_also_appears_in_prelude && is_visible_to_user {\n-                        // add the module to the lookup\n-                        let is_extern = in_module_is_extern || name_binding.is_extern_crate();\n-                        if seen_modules.insert(module.def_id().unwrap()) {\n-                            worklist.push((module, path_segments, is_extern));\n-                        }\n-                    }\n-                }\n-            })\n-        }\n-\n-        candidates\n-    }\n-\n-    /// When name resolution fails, this method can be used to look up candidate\n-    /// entities with the expected name. It allows filtering them using the\n-    /// supplied predicate (which should be used to only accept the types of\n-    /// definitions expected, e.g., traits). The lookup spans across all crates.\n-    ///\n-    /// N.B., the method does not look into imports, but this is not a problem,\n-    /// since we report the definitions (thus, the de-aliased imports).\n-    fn lookup_import_candidates<FilterFn>(&mut self,\n-                                          lookup_ident: Ident,\n-                                          namespace: Namespace,\n-                                          filter_fn: FilterFn)\n-                                          -> Vec<ImportSuggestion>\n-        where FilterFn: Fn(Res) -> bool\n-    {\n-        let mut suggestions = self.lookup_import_candidates_from_module(\n-            lookup_ident, namespace, self.graph_root, Ident::with_empty_ctxt(kw::Crate), &filter_fn\n-        );\n-\n-        if lookup_ident.span.rust_2018() {\n-            let extern_prelude_names = self.extern_prelude.clone();\n-            for (ident, _) in extern_prelude_names.into_iter() {\n-                if let Some(crate_id) = self.crate_loader.maybe_process_path_extern(ident.name,\n-                                                                                    ident.span) {\n-                    let crate_root = self.get_module(DefId {\n-                        krate: crate_id,\n-                        index: CRATE_DEF_INDEX,\n-                    });\n-                    self.populate_module_if_necessary(&crate_root);\n-\n-                    suggestions.extend(self.lookup_import_candidates_from_module(\n-                        lookup_ident, namespace, crate_root, ident, &filter_fn));\n-                }\n-            }\n-        }\n-\n-        suggestions\n-    }\n-\n-    fn find_module(&mut self, def_id: DefId) -> Option<(Module<'a>, ImportSuggestion)> {\n-        let mut result = None;\n-        let mut seen_modules = FxHashSet::default();\n-        let mut worklist = vec![(self.graph_root, Vec::new())];\n-\n-        while let Some((in_module, path_segments)) = worklist.pop() {\n-            // abort if the module is already found\n-            if result.is_some() { break; }\n-\n-            self.populate_module_if_necessary(in_module);\n-\n-            in_module.for_each_child_stable(|ident, _, name_binding| {\n-                // abort if the module is already found or if name_binding is private external\n-                if result.is_some() || !name_binding.vis.is_visible_locally() {\n-                    return\n-                }\n-                if let Some(module) = name_binding.module() {\n-                    // form the path\n-                    let mut path_segments = path_segments.clone();\n-                    path_segments.push(ast::PathSegment::from_ident(ident));\n-                    let module_def_id = module.def_id().unwrap();\n-                    if module_def_id == def_id {\n-                        let path = Path {\n-                            span: name_binding.span,\n-                            segments: path_segments,\n-                        };\n-                        result = Some((module, ImportSuggestion { did: Some(def_id), path }));\n-                    } else {\n-                        // add the module to the lookup\n-                        if seen_modules.insert(module_def_id) {\n-                            worklist.push((module, path_segments));\n-                        }\n-                    }\n-                }\n-            });\n-        }\n-\n-        result\n-    }\n-\n-    fn collect_enum_variants(&mut self, def_id: DefId) -> Option<Vec<Path>> {\n-        self.find_module(def_id).map(|(enum_module, enum_import_suggestion)| {\n-            self.populate_module_if_necessary(enum_module);\n-\n-            let mut variants = Vec::new();\n-            enum_module.for_each_child_stable(|ident, _, name_binding| {\n-                if let Res::Def(DefKind::Variant, _) = name_binding.res() {\n-                    let mut segms = enum_import_suggestion.path.segments.clone();\n-                    segms.push(ast::PathSegment::from_ident(ident));\n-                    variants.push(Path {\n-                        span: name_binding.span,\n-                        segments: segms,\n-                    });\n-                }\n-            });\n-            variants\n-        })\n-    }\n-\n     fn record_partial_res(&mut self, node_id: NodeId, resolution: PartialRes) {\n         debug!(\"(recording res) recording {:?} for {}\", resolution, node_id);\n         if let Some(prev_res) = self.partial_res_map.insert(node_id, resolution) {\n@@ -5010,7 +4781,7 @@ impl<'a> Resolver<'a> {\n         for UseError { mut err, candidates, node_id, better } in self.use_injections.drain(..) {\n             let (span, found_use) = UsePlacementFinder::check(krate, node_id);\n             if !candidates.is_empty() {\n-                show_candidates(&mut err, span, &candidates, better, found_use);\n+                diagnostics::show_candidates(&mut err, span, &candidates, better, found_use);\n             }\n             err.emit();\n         }\n@@ -5326,72 +5097,6 @@ fn path_names_to_string(path: &Path) -> String {\n                         .collect::<Vec<_>>())\n }\n \n-/// Gets the stringified path for an enum from an `ImportSuggestion` for an enum variant.\n-fn import_candidate_to_enum_paths(suggestion: &ImportSuggestion) -> (String, String) {\n-    let variant_path = &suggestion.path;\n-    let variant_path_string = path_names_to_string(variant_path);\n-\n-    let path_len = suggestion.path.segments.len();\n-    let enum_path = ast::Path {\n-        span: suggestion.path.span,\n-        segments: suggestion.path.segments[0..path_len - 1].to_vec(),\n-    };\n-    let enum_path_string = path_names_to_string(&enum_path);\n-\n-    (variant_path_string, enum_path_string)\n-}\n-\n-/// When an entity with a given name is not available in scope, we search for\n-/// entities with that name in all crates. This method allows outputting the\n-/// results of this search in a programmer-friendly way\n-fn show_candidates(err: &mut DiagnosticBuilder<'_>,\n-                   // This is `None` if all placement locations are inside expansions\n-                   span: Option<Span>,\n-                   candidates: &[ImportSuggestion],\n-                   better: bool,\n-                   found_use: bool) {\n-\n-    // we want consistent results across executions, but candidates are produced\n-    // by iterating through a hash map, so make sure they are ordered:\n-    let mut path_strings: Vec<_> =\n-        candidates.into_iter().map(|c| path_names_to_string(&c.path)).collect();\n-    path_strings.sort();\n-\n-    let better = if better { \"better \" } else { \"\" };\n-    let msg_diff = match path_strings.len() {\n-        1 => \" is found in another module, you can import it\",\n-        _ => \"s are found in other modules, you can import them\",\n-    };\n-    let msg = format!(\"possible {}candidate{} into scope\", better, msg_diff);\n-\n-    if let Some(span) = span {\n-        for candidate in &mut path_strings {\n-            // produce an additional newline to separate the new use statement\n-            // from the directly following item.\n-            let additional_newline = if found_use {\n-                \"\"\n-            } else {\n-                \"\\n\"\n-            };\n-            *candidate = format!(\"use {};\\n{}\", candidate, additional_newline);\n-        }\n-\n-        err.span_suggestions(\n-            span,\n-            &msg,\n-            path_strings.into_iter(),\n-            Applicability::Unspecified,\n-        );\n-    } else {\n-        let mut msg = msg;\n-        msg.push(':');\n-        for candidate in path_strings {\n-            msg.push('\\n');\n-            msg.push_str(&candidate);\n-        }\n-    }\n-}\n-\n /// A somewhat inefficient routine to obtain the name of a module.\n fn module_to_string(module: Module<'_>) -> Option<String> {\n     let mut names = Vec::new();"}, {"sha": "34e85e1cf1011ce7d90cff88e344ad994c8cdb4c", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 113, "deletions": 382, "changes": 495, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,7 +1,7 @@\n use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc, Determinacy};\n-use crate::{CrateLint, Resolver, ResolutionError, ScopeSet, Weak};\n+use crate::{CrateLint, Resolver, ResolutionError, Scope, ScopeSet, ParentScope, Weak};\n use crate::{Module, ModuleKind, NameBinding, NameBindingKind, PathResult, Segment, ToNameBinding};\n-use crate::{is_known_tool, resolve_error};\n+use crate::{resolve_error, KNOWN_TOOLS};\n use crate::ModuleOrUniformRoot;\n use crate::Namespace::*;\n use crate::build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n@@ -13,18 +13,15 @@ use rustc::middle::stability;\n use rustc::{ty, lint, span_bug};\n use syntax::ast::{self, Ident, ItemKind};\n use syntax::attr::{self, StabilityLevel};\n-use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Indeterminate};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n use syntax::ext::hygiene::{self, Mark, ExpnInfo, ExpnKind};\n use syntax::ext::tt::macro_rules;\n-use syntax::feature_gate::{feature_err, emit_feature_err, is_builtin_attr_name};\n-use syntax::feature_gate::{AttributeGate, GateIssue, Stability, BUILTIN_ATTRIBUTES};\n+use syntax::feature_gate::{emit_feature_err, is_builtin_attr_name};\n+use syntax::feature_gate::GateIssue;\n use syntax::symbol::{Symbol, kw, sym};\n-use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{Span, DUMMY_SP};\n-use errors::Applicability;\n \n use std::cell::Cell;\n use std::{mem, ptr};\n@@ -60,10 +57,10 @@ impl<'a> InvocationData<'a> {\n /// Not modularized, can shadow previous legacy bindings, etc.\n #[derive(Debug)]\n pub struct LegacyBinding<'a> {\n-    binding: &'a NameBinding<'a>,\n+    crate binding: &'a NameBinding<'a>,\n     /// Legacy scope into which the `macro_rules` item was planted.\n-    parent_legacy_scope: LegacyScope<'a>,\n-    ident: Ident,\n+    crate parent_legacy_scope: LegacyScope<'a>,\n+    crate ident: Ident,\n }\n \n /// The scope introduced by a `macro_rules!` macro.\n@@ -82,15 +79,6 @@ pub enum LegacyScope<'a> {\n     Invocation(&'a InvocationData<'a>),\n }\n \n-/// Everything you need to resolve a macro or import path.\n-#[derive(Clone, Debug)]\n-pub struct ParentScope<'a> {\n-    crate module: Module<'a>,\n-    crate expansion: Mark,\n-    crate legacy: LegacyScope<'a>,\n-    crate derives: Vec<ast::Path>,\n-}\n-\n // Macro namespace is separated into two sub-namespaces, one for bang macros and\n // one for attribute-like macros (attributes, derives).\n // We ignore resolutions from one sub-namespace when searching names in scope for another.\n@@ -232,7 +220,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         };\n \n         let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);\n-        let (ext, res) = self.smart_resolve_macro_path(path, kind, &parent_scope, true, force)?;\n+        let (ext, res) = self.smart_resolve_macro_path(path, kind, &parent_scope, force)?;\n \n         let span = invoc.span();\n         invoc.expansion_data.mark.set_expn_info(ext.expn_info(span, fast_print_path(path)));\n@@ -281,10 +269,10 @@ impl<'a> Resolver<'a> {\n         path: &ast::Path,\n         kind: MacroKind,\n         parent_scope: &ParentScope<'a>,\n-        trace: bool,\n         force: bool,\n     ) -> Result<(Lrc<SyntaxExtension>, Res), Indeterminate> {\n-        let (ext, res) = match self.resolve_macro_path(path, kind, parent_scope, trace, force) {\n+        let (ext, res) = match self.resolve_macro_path(path, Some(kind), parent_scope,\n+                                                       true, force) {\n             Ok((Some(ext), res)) => (ext, res),\n             // Use dummy syntax extensions for unresolved macros for better recovery.\n             Ok((None, res)) => (self.dummy_ext(kind), res),\n@@ -324,23 +312,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n             }\n-            Res::NonMacroAttr(attr_kind) => {\n-                if attr_kind == NonMacroAttrKind::Custom {\n-                    assert!(path.segments.len() == 1);\n-                    if !features.custom_attribute {\n-                        let msg = format!(\"The attribute `{}` is currently unknown to the \\\n-                                            compiler and may have meaning added to it in the \\\n-                                            future\", path);\n-                        self.report_unknown_attribute(\n-                            path.span,\n-                            &path.segments[0].ident.as_str(),\n-                            &msg,\n-                            sym::custom_attribute,\n-                        );\n-                    }\n-                }\n-            }\n-            Res::Err => {}\n+            Res::NonMacroAttr(..) | Res::Err => {}\n             _ => panic!(\"expected `DefKind::Macro` or `Res::NonMacroAttr`\"),\n         };\n \n@@ -359,64 +331,10 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    fn report_unknown_attribute(&self, span: Span, name: &str, msg: &str, feature: Symbol) {\n-        let mut err = feature_err(\n-            &self.session.parse_sess,\n-            feature,\n-            span,\n-            GateIssue::Language,\n-            &msg,\n-        );\n-\n-        let features = self.session.features_untracked();\n-\n-        let attr_candidates = BUILTIN_ATTRIBUTES\n-            .iter()\n-            .filter_map(|&(name, _, _, ref gate)| {\n-                if name.as_str().starts_with(\"rustc_\") && !features.rustc_attrs {\n-                    return None;\n-                }\n-\n-                match gate {\n-                    AttributeGate::Gated(Stability::Unstable, ..)\n-                        if self.session.opts.unstable_features.is_nightly_build() =>\n-                    {\n-                        Some(name)\n-                    }\n-                    AttributeGate::Gated(Stability::Deprecated(..), ..) => Some(name),\n-                    AttributeGate::Ungated => Some(name),\n-                    _ => None,\n-                }\n-            })\n-            .chain(\n-                // Add built-in macro attributes as well.\n-                self.builtin_macros.iter().filter_map(|(name, binding)| {\n-                    match binding.macro_kind() {\n-                        Some(MacroKind::Attr) => Some(*name),\n-                        _ => None,\n-                    }\n-                }),\n-            )\n-            .collect::<Vec<_>>();\n-\n-        let lev_suggestion = find_best_match_for_name(attr_candidates.iter(), &name, None);\n-\n-        if let Some(suggestion) = lev_suggestion {\n-            err.span_suggestion(\n-                span,\n-                \"a built-in attribute with a similar name exists\",\n-                suggestion.to_string(),\n-                Applicability::MaybeIncorrect,\n-            );\n-        }\n-\n-        err.emit();\n-    }\n-\n     pub fn resolve_macro_path(\n         &mut self,\n         path: &ast::Path,\n-        kind: MacroKind,\n+        kind: Option<MacroKind>,\n         parent_scope: &ParentScope<'a>,\n         trace: bool,\n         force: bool,\n@@ -425,7 +343,7 @@ impl<'a> Resolver<'a> {\n         let mut path = Segment::from_path(path);\n \n         // Possibly apply the macro helper hack\n-        if kind == MacroKind::Bang && path.len() == 1 &&\n+        if kind == Some(MacroKind::Bang) && path.len() == 1 &&\n            path[0].ident.span.ctxt().outer_expn_info()\n                .map_or(false, |info| info.local_inner_macros) {\n             let root = Ident::new(kw::DollarCrate, path[0].ident.span);\n@@ -446,21 +364,25 @@ impl<'a> Resolver<'a> {\n             };\n \n             if trace {\n+                let kind = kind.expect(\"macro kind must be specified if tracing is enabled\");\n                 parent_scope.module.multi_segment_macro_resolutions.borrow_mut()\n                     .push((path, path_span, kind, parent_scope.clone(), res.ok()));\n             }\n \n             self.prohibit_imported_non_macro_attrs(None, res.ok(), path_span);\n             res\n         } else {\n+            // Macro without a specific kind restriction is equvalent to a macro import.\n+            let scope_set = kind.map_or(ScopeSet::Import(MacroNS), ScopeSet::Macro);\n             let binding = self.early_resolve_ident_in_lexical_scope(\n-                path[0].ident, ScopeSet::Macro(kind), parent_scope, false, force, path_span\n+                path[0].ident, scope_set, parent_scope, false, force, path_span\n             );\n             if let Err(Determinacy::Undetermined) = binding {\n                 return Err(Determinacy::Undetermined);\n             }\n \n             if trace {\n+                let kind = kind.expect(\"macro kind must be specified if tracing is enabled\");\n                 parent_scope.module.single_segment_macro_resolutions.borrow_mut()\n                     .push((path[0].ident, kind, parent_scope.clone(), binding.ok()));\n             }\n@@ -487,65 +409,6 @@ impl<'a> Resolver<'a> {\n         force: bool,\n         path_span: Span,\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n-        // General principles:\n-        // 1. Not controlled (user-defined) names should have higher priority than controlled names\n-        //    built into the language or standard library. This way we can add new names into the\n-        //    language or standard library without breaking user code.\n-        // 2. \"Closed set\" below means new names cannot appear after the current resolution attempt.\n-        // Places to search (in order of decreasing priority):\n-        // (Type NS)\n-        // 1. FIXME: Ribs (type parameters), there's no necessary infrastructure yet\n-        //    (open set, not controlled).\n-        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n-        //    (open, not controlled).\n-        // 3. Extern prelude (closed, not controlled).\n-        // 4. Tool modules (closed, controlled right now, but not in the future).\n-        // 5. Standard library prelude (de-facto closed, controlled).\n-        // 6. Language prelude (closed, controlled).\n-        // (Value NS)\n-        // 1. FIXME: Ribs (local variables), there's no necessary infrastructure yet\n-        //    (open set, not controlled).\n-        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n-        //    (open, not controlled).\n-        // 3. Standard library prelude (de-facto closed, controlled).\n-        // (Macro NS)\n-        // 1-3. Derive helpers (open, not controlled). All ambiguities with other names\n-        //    are currently reported as errors. They should be higher in priority than preludes\n-        //    and probably even names in modules according to the \"general principles\" above. They\n-        //    also should be subject to restricted shadowing because are effectively produced by\n-        //    derives (you need to resolve the derive first to add helpers into scope), but they\n-        //    should be available before the derive is expanded for compatibility.\n-        //    It's mess in general, so we are being conservative for now.\n-        // 1-3. `macro_rules` (open, not controlled), loop through legacy scopes. Have higher\n-        //    priority than prelude macros, but create ambiguities with macros in modules.\n-        // 1-3. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n-        //    (open, not controlled). Have higher priority than prelude macros, but create\n-        //    ambiguities with `macro_rules`.\n-        // 4. `macro_use` prelude (open, the open part is from macro expansions, not controlled).\n-        // 4a. User-defined prelude from macro-use\n-        //    (open, the open part is from macro expansions, not controlled).\n-        // 4b. Standard library prelude is currently implemented as `macro-use` (closed, controlled)\n-        // 5. Language prelude: builtin macros (closed, controlled, except for legacy plugins).\n-        // 6. Language prelude: builtin attributes (closed, controlled).\n-        // 4-6. Legacy plugin helpers (open, not controlled). Similar to derive helpers,\n-        //    but introduced by legacy plugins using `register_attribute`. Priority is somewhere\n-        //    in prelude, not sure where exactly (creates ambiguities with any other prelude names).\n-\n-        enum WhereToResolve<'a> {\n-            DeriveHelpers,\n-            MacroRules(LegacyScope<'a>),\n-            CrateRoot,\n-            Module(Module<'a>),\n-            MacroUsePrelude,\n-            BuiltinMacros,\n-            BuiltinAttrs,\n-            LegacyPluginHelpers,\n-            ExternPrelude,\n-            ToolPrelude,\n-            StdLibPrelude,\n-            BuiltinTypes,\n-        }\n-\n         bitflags::bitflags! {\n             struct Flags: u8 {\n                 const MACRO_RULES        = 1 << 0;\n@@ -558,13 +421,19 @@ impl<'a> Resolver<'a> {\n         }\n \n         assert!(force || !record_used); // `record_used` implies `force`\n-        let mut ident = orig_ident.modern();\n \n         // Make sure `self`, `super` etc produce an error when passed to here.\n-        if ident.is_path_segment_keyword() {\n+        if orig_ident.is_path_segment_keyword() {\n             return Err(Determinacy::Determined);\n         }\n \n+        let (ns, macro_kind, is_import) = match scope_set {\n+            ScopeSet::Import(ns) => (ns, None, true),\n+            ScopeSet::AbsolutePath(ns) => (ns, None, false),\n+            ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false),\n+            ScopeSet::Module => (TypeNS, None, false),\n+        };\n+\n         // This is *the* result, resolution from the scope closest to the resolved identifier.\n         // However, sometimes this result is \"weak\" because it comes from a glob import or\n         // a macro expansion, and in this case it cannot shadow names from outer scopes, e.g.\n@@ -577,34 +446,22 @@ impl<'a> Resolver<'a> {\n         // So we have to save the innermost solution and continue searching in outer scopes\n         // to detect potential ambiguities.\n         let mut innermost_result: Option<(&NameBinding<'_>, Flags)> = None;\n+        let mut determinacy = Determinacy::Determined;\n \n         // Go through all the scopes and try to resolve the name.\n-        let rust_2015 = orig_ident.span.rust_2015();\n-        let (ns, macro_kind, is_import, is_absolute_path) = match scope_set {\n-            ScopeSet::Import(ns) => (ns, None, true, false),\n-            ScopeSet::AbsolutePath(ns) => (ns, None, false, true),\n-            ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false, false),\n-            ScopeSet::Module => (TypeNS, None, false, false),\n-        };\n-        let mut where_to_resolve = match ns {\n-            _ if is_absolute_path => WhereToResolve::CrateRoot,\n-            TypeNS | ValueNS => WhereToResolve::Module(parent_scope.module),\n-            MacroNS => WhereToResolve::DeriveHelpers,\n-        };\n-        let mut use_prelude = !parent_scope.module.no_implicit_prelude;\n-        let mut determinacy = Determinacy::Determined;\n-        loop {\n-            let result = match where_to_resolve {\n-                WhereToResolve::DeriveHelpers => {\n+        let break_result =\n+                self.visit_scopes(scope_set, parent_scope, orig_ident, |this, scope, ident| {\n+            let result = match scope {\n+                Scope::DeriveHelpers => {\n                     let mut result = Err(Determinacy::Determined);\n                     for derive in &parent_scope.derives {\n                         let parent_scope = ParentScope { derives: Vec::new(), ..*parent_scope };\n-                        match self.resolve_macro_path(derive, MacroKind::Derive,\n+                        match this.resolve_macro_path(derive, Some(MacroKind::Derive),\n                                                       &parent_scope, true, force) {\n                             Ok((Some(ext), _)) => if ext.helper_attrs.contains(&ident.name) {\n                                 let binding = (Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n                                                ty::Visibility::Public, derive.span, Mark::root())\n-                                               .to_name_binding(self.arenas);\n+                                               .to_name_binding(this.arenas);\n                                 result = Ok((binding, Flags::empty()));\n                                 break;\n                             }\n@@ -615,19 +472,19 @@ impl<'a> Resolver<'a> {\n                     }\n                     result\n                 }\n-                WhereToResolve::MacroRules(legacy_scope) => match legacy_scope {\n+                Scope::MacroRules(legacy_scope) => match legacy_scope {\n                     LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident =>\n                         Ok((legacy_binding.binding, Flags::MACRO_RULES)),\n                     LegacyScope::Invocation(invoc) if invoc.output_legacy_scope.get().is_none() =>\n                         Err(Determinacy::Undetermined),\n                     _ => Err(Determinacy::Determined),\n                 }\n-                WhereToResolve::CrateRoot => {\n-                    let root_ident = Ident::new(kw::PathRoot, orig_ident.span);\n-                    let root_module = self.resolve_crate_root(root_ident);\n-                    let binding = self.resolve_ident_in_module_ext(\n+                Scope::CrateRoot => {\n+                    let root_ident = Ident::new(kw::PathRoot, ident.span);\n+                    let root_module = this.resolve_crate_root(root_ident);\n+                    let binding = this.resolve_ident_in_module_ext(\n                         ModuleOrUniformRoot::Module(root_module),\n-                        orig_ident,\n+                        ident,\n                         ns,\n                         None,\n                         record_used,\n@@ -636,15 +493,15 @@ impl<'a> Resolver<'a> {\n                     match binding {\n                         Ok(binding) => Ok((binding, Flags::MODULE | Flags::MISC_SUGGEST_CRATE)),\n                         Err((Determinacy::Undetermined, Weak::No)) =>\n-                            return Err(Determinacy::determined(force)),\n+                            return Some(Err(Determinacy::determined(force))),\n                         Err((Determinacy::Undetermined, Weak::Yes)) =>\n                             Err(Determinacy::Undetermined),\n                         Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n                     }\n                 }\n-                WhereToResolve::Module(module) => {\n-                    let orig_current_module = mem::replace(&mut self.current_module, module);\n-                    let binding = self.resolve_ident_in_module_unadjusted_ext(\n+                Scope::Module(module) => {\n+                    let orig_current_module = mem::replace(&mut this.current_module, module);\n+                    let binding = this.resolve_ident_in_module_unadjusted_ext(\n                         ModuleOrUniformRoot::Module(module),\n                         ident,\n                         ns,\n@@ -653,10 +510,10 @@ impl<'a> Resolver<'a> {\n                         record_used,\n                         path_span,\n                     );\n-                    self.current_module = orig_current_module;\n+                    this.current_module = orig_current_module;\n                     match binding {\n                         Ok(binding) => {\n-                            let misc_flags = if ptr::eq(module, self.graph_root) {\n+                            let misc_flags = if ptr::eq(module, this.graph_root) {\n                                 Flags::MISC_SUGGEST_CRATE\n                             } else if module.is_normal() {\n                                 Flags::MISC_SUGGEST_SELF\n@@ -666,107 +523,82 @@ impl<'a> Resolver<'a> {\n                             Ok((binding, Flags::MODULE | misc_flags))\n                         }\n                         Err((Determinacy::Undetermined, Weak::No)) =>\n-                            return Err(Determinacy::determined(force)),\n+                            return Some(Err(Determinacy::determined(force))),\n                         Err((Determinacy::Undetermined, Weak::Yes)) =>\n                             Err(Determinacy::Undetermined),\n                         Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n                     }\n                 }\n-                WhereToResolve::MacroUsePrelude => {\n-                    if use_prelude || rust_2015 {\n-                        match self.macro_use_prelude.get(&ident.name).cloned() {\n-                            Some(binding) =>\n-                                Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE)),\n-                            None => Err(Determinacy::determined(\n-                                self.graph_root.unresolved_invocations.borrow().is_empty()\n-                            ))\n-                        }\n-                    } else {\n-                        Err(Determinacy::Determined)\n-                    }\n-                }\n-                WhereToResolve::BuiltinMacros => {\n-                    match self.builtin_macros.get(&ident.name).cloned() {\n-                        Some(binding) => Ok((binding, Flags::PRELUDE)),\n-                        None => Err(Determinacy::Determined),\n-                    }\n-                }\n-                WhereToResolve::BuiltinAttrs => {\n-                    if is_builtin_attr_name(ident.name) {\n-                        let binding = (Res::NonMacroAttr(NonMacroAttrKind::Builtin),\n-                                       ty::Visibility::Public, DUMMY_SP, Mark::root())\n-                                       .to_name_binding(self.arenas);\n-                        Ok((binding, Flags::PRELUDE))\n-                    } else {\n-                        Err(Determinacy::Determined)\n-                    }\n+                Scope::MacroUsePrelude => match this.macro_use_prelude.get(&ident.name).cloned() {\n+                    Some(binding) => Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE)),\n+                    None => Err(Determinacy::determined(\n+                        this.graph_root.unresolved_invocations.borrow().is_empty()\n+                    ))\n+                }\n+                Scope::BuiltinMacros => match this.builtin_macros.get(&ident.name).cloned() {\n+                    Some(binding) => Ok((binding, Flags::PRELUDE)),\n+                    None => Err(Determinacy::Determined),\n+                }\n+                Scope::BuiltinAttrs => if is_builtin_attr_name(ident.name) {\n+                    let binding = (Res::NonMacroAttr(NonMacroAttrKind::Builtin),\n+                                   ty::Visibility::Public, DUMMY_SP, Mark::root())\n+                                   .to_name_binding(this.arenas);\n+                    Ok((binding, Flags::PRELUDE))\n+                } else {\n+                    Err(Determinacy::Determined)\n                 }\n-                WhereToResolve::LegacyPluginHelpers => {\n-                    if (use_prelude || rust_2015) &&\n-                       self.session.plugin_attributes.borrow().iter()\n+                Scope::LegacyPluginHelpers => if this.session.plugin_attributes.borrow().iter()\n                                                      .any(|(name, _)| ident.name == *name) {\n-                        let binding = (Res::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper),\n-                                       ty::Visibility::Public, DUMMY_SP, Mark::root())\n-                                       .to_name_binding(self.arenas);\n-                        Ok((binding, Flags::PRELUDE))\n-                    } else {\n-                        Err(Determinacy::Determined)\n-                    }\n-                }\n-                WhereToResolve::ExternPrelude => {\n-                    if use_prelude || is_absolute_path {\n-                        match self.extern_prelude_get(ident, !record_used) {\n-                            Some(binding) => Ok((binding, Flags::PRELUDE)),\n-                            None => Err(Determinacy::determined(\n-                                self.graph_root.unresolved_invocations.borrow().is_empty()\n-                            )),\n-                        }\n-                    } else {\n-                        Err(Determinacy::Determined)\n-                    }\n-                }\n-                WhereToResolve::ToolPrelude => {\n-                    if use_prelude && is_known_tool(ident.name) {\n-                        let binding = (Res::ToolMod, ty::Visibility::Public,\n-                                       DUMMY_SP, Mark::root()).to_name_binding(self.arenas);\n-                        Ok((binding, Flags::PRELUDE))\n-                    } else {\n-                        Err(Determinacy::Determined)\n-                    }\n+                    let binding = (Res::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper),\n+                                   ty::Visibility::Public, DUMMY_SP, Mark::root())\n+                                   .to_name_binding(this.arenas);\n+                    Ok((binding, Flags::PRELUDE))\n+                } else {\n+                    Err(Determinacy::Determined)\n+                }\n+                Scope::ExternPrelude => match this.extern_prelude_get(ident, !record_used) {\n+                    Some(binding) => Ok((binding, Flags::PRELUDE)),\n+                    None => Err(Determinacy::determined(\n+                        this.graph_root.unresolved_invocations.borrow().is_empty()\n+                    )),\n+                }\n+                Scope::ToolPrelude => if KNOWN_TOOLS.contains(&ident.name) {\n+                    let binding = (Res::ToolMod, ty::Visibility::Public, DUMMY_SP, Mark::root())\n+                                   .to_name_binding(this.arenas);\n+                    Ok((binding, Flags::PRELUDE))\n+                } else {\n+                    Err(Determinacy::Determined)\n                 }\n-                WhereToResolve::StdLibPrelude => {\n+                Scope::StdLibPrelude => {\n                     let mut result = Err(Determinacy::Determined);\n-                    if use_prelude {\n-                        if let Some(prelude) = self.prelude {\n-                            if let Ok(binding) = self.resolve_ident_in_module_unadjusted(\n-                                ModuleOrUniformRoot::Module(prelude),\n-                                ident,\n-                                ns,\n-                                false,\n-                                path_span,\n-                            ) {\n-                                result = Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE));\n-                            }\n+                    if let Some(prelude) = this.prelude {\n+                        if let Ok(binding) = this.resolve_ident_in_module_unadjusted(\n+                            ModuleOrUniformRoot::Module(prelude),\n+                            ident,\n+                            ns,\n+                            false,\n+                            path_span,\n+                        ) {\n+                            result = Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE));\n                         }\n                     }\n                     result\n                 }\n-                WhereToResolve::BuiltinTypes => {\n-                    match self.primitive_type_table.primitive_types.get(&ident.name).cloned() {\n-                        Some(prim_ty) => {\n-                            let binding = (Res::PrimTy(prim_ty), ty::Visibility::Public,\n-                                           DUMMY_SP, Mark::root()).to_name_binding(self.arenas);\n-                            Ok((binding, Flags::PRELUDE))\n-                        }\n-                        None => Err(Determinacy::Determined)\n+                Scope::BuiltinTypes => match this.primitive_type_table.primitive_types\n+                                                 .get(&ident.name).cloned() {\n+                    Some(prim_ty) => {\n+                        let binding = (Res::PrimTy(prim_ty), ty::Visibility::Public,\n+                                       DUMMY_SP, Mark::root()).to_name_binding(this.arenas);\n+                        Ok((binding, Flags::PRELUDE))\n                     }\n+                    None => Err(Determinacy::Determined)\n                 }\n             };\n \n             match result {\n                 Ok((binding, flags)) if sub_namespace_match(binding.macro_kind(), macro_kind) => {\n                     if !record_used {\n-                        return Ok(binding);\n+                        return Some(Ok(binding));\n                     }\n \n                     if let Some((innermost_binding, innermost_flags)) = innermost_result {\n@@ -791,11 +623,11 @@ impl<'a> Resolver<'a> {\n                                 Some(AmbiguityKind::LegacyHelperVsPrelude)\n                             } else if innermost_flags.contains(Flags::MACRO_RULES) &&\n                                       flags.contains(Flags::MODULE) &&\n-                                      !self.disambiguate_legacy_vs_modern(innermost_binding,\n+                                      !this.disambiguate_legacy_vs_modern(innermost_binding,\n                                                                           binding) ||\n                                       flags.contains(Flags::MACRO_RULES) &&\n                                       innermost_flags.contains(Flags::MODULE) &&\n-                                      !self.disambiguate_legacy_vs_modern(binding,\n+                                      !this.disambiguate_legacy_vs_modern(binding,\n                                                                           innermost_binding) {\n                                 Some(AmbiguityKind::LegacyVsModern)\n                             } else if innermost_binding.is_glob_import() {\n@@ -816,15 +648,15 @@ impl<'a> Resolver<'a> {\n                                 } else {\n                                     AmbiguityErrorMisc::None\n                                 };\n-                                self.ambiguity_errors.push(AmbiguityError {\n+                                this.ambiguity_errors.push(AmbiguityError {\n                                     kind,\n                                     ident: orig_ident,\n                                     b1: innermost_binding,\n                                     b2: binding,\n                                     misc1: misc(innermost_flags),\n                                     misc2: misc(flags),\n                                 });\n-                                return Ok(innermost_binding);\n+                                return Some(Ok(innermost_binding));\n                             }\n                         }\n                     } else {\n@@ -836,55 +668,11 @@ impl<'a> Resolver<'a> {\n                 Err(Determinacy::Undetermined) => determinacy = Determinacy::Undetermined\n             }\n \n-            where_to_resolve = match where_to_resolve {\n-                WhereToResolve::DeriveHelpers =>\n-                    WhereToResolve::MacroRules(parent_scope.legacy),\n-                WhereToResolve::MacroRules(legacy_scope) => match legacy_scope {\n-                    LegacyScope::Binding(binding) => WhereToResolve::MacroRules(\n-                        binding.parent_legacy_scope\n-                    ),\n-                    LegacyScope::Invocation(invoc) => WhereToResolve::MacroRules(\n-                        invoc.output_legacy_scope.get().unwrap_or(invoc.parent_legacy_scope)\n-                    ),\n-                    LegacyScope::Empty => WhereToResolve::Module(parent_scope.module),\n-                }\n-                WhereToResolve::CrateRoot => match ns {\n-                    TypeNS => {\n-                        ident.span.adjust(Mark::root());\n-                        WhereToResolve::ExternPrelude\n-                    }\n-                    ValueNS | MacroNS => break,\n-                }\n-                WhereToResolve::Module(module) => {\n-                    match self.hygienic_lexical_parent(module, &mut ident.span) {\n-                        Some(parent_module) => WhereToResolve::Module(parent_module),\n-                        None => {\n-                            ident.span.adjust(Mark::root());\n-                            use_prelude = !module.no_implicit_prelude;\n-                            match ns {\n-                                TypeNS => WhereToResolve::ExternPrelude,\n-                                ValueNS => WhereToResolve::StdLibPrelude,\n-                                MacroNS => WhereToResolve::MacroUsePrelude,\n-                            }\n-                        }\n-                    }\n-                }\n-                WhereToResolve::MacroUsePrelude => WhereToResolve::StdLibPrelude,\n-                WhereToResolve::BuiltinMacros => WhereToResolve::BuiltinAttrs,\n-                WhereToResolve::BuiltinAttrs => WhereToResolve::LegacyPluginHelpers,\n-                WhereToResolve::LegacyPluginHelpers => break, // nowhere else to search\n-                WhereToResolve::ExternPrelude if is_absolute_path => break,\n-                WhereToResolve::ExternPrelude => WhereToResolve::ToolPrelude,\n-                WhereToResolve::ToolPrelude => WhereToResolve::StdLibPrelude,\n-                WhereToResolve::StdLibPrelude => match ns {\n-                    TypeNS => WhereToResolve::BuiltinTypes,\n-                    ValueNS => break, // nowhere else to search\n-                    MacroNS => WhereToResolve::BuiltinMacros,\n-                }\n-                WhereToResolve::BuiltinTypes => break, // nowhere else to search\n-            };\n+            None\n+        });\n \n-            continue;\n+        if let Some(break_result) = break_result {\n+            return break_result;\n         }\n \n         // The first found solution was the only one, return it.\n@@ -893,13 +681,14 @@ impl<'a> Resolver<'a> {\n         }\n \n         let determinacy = Determinacy::determined(determinacy == Determinacy::Determined || force);\n-        if determinacy == Determinacy::Determined && macro_kind == Some(MacroKind::Attr) {\n+        if determinacy == Determinacy::Determined && macro_kind == Some(MacroKind::Attr) &&\n+           self.session.features_untracked().custom_attribute {\n             // For single-segment attributes interpret determinate \"no resolution\" as a custom\n             // attribute. (Lexical resolution implies the first segment and attr kind should imply\n             // the last segment, so we are certainly working with a single-segment attribute here.)\n             assert!(ns == MacroNS);\n             let binding = (Res::NonMacroAttr(NonMacroAttrKind::Custom),\n-                           ty::Visibility::Public, ident.span, Mark::root())\n+                           ty::Visibility::Public, orig_ident.span, Mark::root())\n                            .to_name_binding(self.arenas);\n             Ok(binding)\n         } else {\n@@ -992,7 +781,7 @@ impl<'a> Resolver<'a> {\n                     let msg =\n                         format!(\"cannot find {} `{}{}` in this scope\", kind.descr(), ident, bang);\n                     let mut err = self.session.struct_span_err(ident.span, &msg);\n-                    self.suggest_macro_name(ident.name, kind, &mut err, ident.span);\n+                    self.unresolved_macro_suggestions(&mut err, kind, &parent_scope, ident);\n                     err.emit();\n                 }\n             }\n@@ -1042,64 +831,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn suggest_macro_name(&mut self, name: Symbol, kind: MacroKind,\n-                          err: &mut DiagnosticBuilder<'a>, span: Span) {\n-        if kind == MacroKind::Derive && (name.as_str() == \"Send\" || name.as_str() == \"Sync\") {\n-            let msg = format!(\"unsafe traits like `{}` should be implemented explicitly\", name);\n-            err.span_note(span, &msg);\n-            return;\n-        }\n-\n-        // First check if this is a locally-defined bang macro.\n-        let suggestion = if let MacroKind::Bang = kind {\n-            find_best_match_for_name(\n-                self.macro_names.iter().map(|ident| &ident.name), &name.as_str(), None)\n-        } else {\n-            None\n-        // Then check global macros.\n-        }.or_else(|| {\n-            let names = self.builtin_macros.iter().chain(self.macro_use_prelude.iter())\n-                                                  .filter_map(|(name, binding)| {\n-                if binding.macro_kind() == Some(kind) { Some(name) } else { None }\n-            });\n-            find_best_match_for_name(names, &name.as_str(), None)\n-        // Then check modules.\n-        }).or_else(|| {\n-            let is_macro = |res| {\n-                if let Res::Def(DefKind::Macro(def_kind), _) = res {\n-                    def_kind == kind\n-                } else {\n-                    false\n-                }\n-            };\n-            let ident = Ident::new(name, span);\n-            self.lookup_typo_candidate(&[Segment::from_ident(ident)], MacroNS, is_macro, span)\n-                .map(|suggestion| suggestion.candidate)\n-        });\n-\n-        if let Some(suggestion) = suggestion {\n-            if suggestion != name {\n-                if let MacroKind::Bang = kind {\n-                    err.span_suggestion(\n-                        span,\n-                        \"you could try the macro\",\n-                        suggestion.to_string(),\n-                        Applicability::MaybeIncorrect\n-                    );\n-                } else {\n-                    err.span_suggestion(\n-                        span,\n-                        \"try\",\n-                        suggestion.to_string(),\n-                        Applicability::MaybeIncorrect\n-                    );\n-                }\n-            } else {\n-                err.help(\"have you added the `#[macro_use]` on the module/import?\");\n-            }\n-        }\n-    }\n-\n     crate fn check_reserved_macro_name(&mut self, ident: Ident, res: Res) {\n         // Reserve some names that are not quite covered by the general check\n         // performed on `Resolver::builtin_attrs`."}, {"sha": "14622fd9f91fa545d5f010374a98562024f2baba", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,15 +1,15 @@\n use ImportDirectiveSubclass::*;\n \n use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n-use crate::{CrateLint, Module, ModuleOrUniformRoot, PerNS, ScopeSet, Weak};\n+use crate::{CrateLint, Module, ModuleOrUniformRoot, PerNS, ScopeSet, ParentScope, Weak};\n use crate::Determinacy::{self, *};\n use crate::Namespace::{self, TypeNS, MacroNS};\n use crate::{NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n use crate::{Resolver, Segment};\n use crate::{names_to_string, module_to_string};\n-use crate::{resolve_error, ResolutionError, Suggestion};\n+use crate::{resolve_error, ResolutionError};\n use crate::ModuleKind;\n-use crate::macros::ParentScope;\n+use crate::diagnostics::Suggestion;\n \n use errors::Applicability;\n "}, {"sha": "04de3374d0587af4f7d4d4c77833d22e68908049", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -6,6 +6,7 @@ use rustc::lint as lint;\n use rustc::ty;\n use syntax;\n use syntax::ast::{self, Ident};\n+use syntax::ext::base::SyntaxExtensionKind;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n@@ -425,12 +426,10 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n /// Resolves a string as a macro.\n fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n-    use syntax::ext::base::{MacroKind, SyntaxExtensionKind};\n-    let segment = ast::PathSegment::from_ident(Ident::from_str(path_str));\n-    let path = ast::Path { segments: vec![segment], span: DUMMY_SP };\n+    let path = ast::Path::from_ident(Ident::from_str(path_str));\n     cx.enter_resolver(|resolver| {\n         if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n-            &path, MacroKind::Bang, &resolver.dummy_parent_scope(), false, false\n+            &path, None, &resolver.dummy_parent_scope(), false, false\n         ) {\n             if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n                 return Some(res.map_id(|_| panic!(\"unexpected id\")));"}, {"sha": "f23ed7371c6dc4a1a2cabcd1daaa3924f2ec2725", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -604,6 +604,7 @@ symbols! {\n         rustc_then_this_would_need,\n         rustc_variance,\n         rustdoc,\n+        rustfmt,\n         rust_eh_personality,\n         rust_eh_unwind_resume,\n         rust_oom,"}, {"sha": "8759344e6f820940d867597f820de7287ca21f54", "filename": "src/test/ui/attributes/obsolete-attr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fattributes%2Fobsolete-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fattributes%2Fobsolete-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fobsolete-attr.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,7 +1,9 @@\n // Obsolete attributes fall back to feature gated custom attributes.\n \n-#[ab_isize=\"stdcall\"] extern {} //~ ERROR attribute `ab_isize` is currently unknown\n+#[ab_isize=\"stdcall\"] extern {}\n+//~^ ERROR cannot find attribute macro `ab_isize` in this scope\n \n-#[fixed_stack_segment] fn f() {} //~ ERROR attribute `fixed_stack_segment` is currently unknown\n+#[fixed_stack_segment] fn f() {}\n+//~^ ERROR cannot find attribute macro `fixed_stack_segment` in this scope\n \n fn main() {}"}, {"sha": "9c6909f65f3ea3ab3e48d73acbb0433c091e0140", "filename": "src/test/ui/attributes/obsolete-attr.stderr", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fattributes%2Fobsolete-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fattributes%2Fobsolete-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fobsolete-attr.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,21 +1,14 @@\n-error[E0658]: The attribute `fixed_stack_segment` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/obsolete-attr.rs:5:3\n+error: cannot find attribute macro `fixed_stack_segment` in this scope\n+  --> $DIR/obsolete-attr.rs:6:3\n    |\n LL | #[fixed_stack_segment] fn f() {}\n    |   ^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `ab_isize` is currently unknown to the compiler and may have meaning added to it in the future\n+error: cannot find attribute macro `ab_isize` in this scope\n   --> $DIR/obsolete-attr.rs:3:3\n    |\n LL | #[ab_isize=\"stdcall\"] extern {}\n    |   ^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "140a1fc3f93e59cfddf8f3d1d07c63c7141f08b8", "filename": "src/test/ui/attributes/unknown-attr.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fattributes%2Funknown-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fattributes%2Funknown-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Funknown-attr.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -2,8 +2,11 @@\n \n #![feature(custom_inner_attributes)]\n \n-#![mutable_doc] //~ ERROR attribute `mutable_doc` is currently unknown\n+#![mutable_doc]\n+//~^ ERROR cannot find attribute macro `mutable_doc` in this scope\n \n-#[dance] mod a {} //~ ERROR attribute `dance` is currently unknown\n+#[dance] mod a {}\n+//~^ ERROR cannot find attribute macro `dance` in this scope\n \n-#[dance] fn main() {} //~ ERROR attribute `dance` is currently unknown\n+#[dance] fn main() {}\n+//~^ ERROR cannot find attribute macro `dance` in this scope"}, {"sha": "4d463874d669e995c5b9e779f50a21373fde4bbd", "filename": "src/test/ui/attributes/unknown-attr.stderr", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fattributes%2Funknown-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fattributes%2Funknown-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Funknown-attr.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,30 +1,20 @@\n-error[E0658]: The attribute `mutable_doc` is currently unknown to the compiler and may have meaning added to it in the future\n+error: cannot find attribute macro `mutable_doc` in this scope\n   --> $DIR/unknown-attr.rs:5:4\n    |\n LL | #![mutable_doc]\n    |    ^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `dance` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/unknown-attr.rs:7:3\n+error: cannot find attribute macro `dance` in this scope\n+  --> $DIR/unknown-attr.rs:8:3\n    |\n LL | #[dance] mod a {}\n    |   ^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `dance` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/unknown-attr.rs:9:3\n+error: cannot find attribute macro `dance` in this scope\n+  --> $DIR/unknown-attr.rs:11:3\n    |\n LL | #[dance] fn main() {}\n    |   ^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "22dbac766707dca067c8e62fae0fb64fe5b40ab6", "filename": "src/test/ui/conditional-compilation/cfg-attr-unknown-attribute-macro-expansion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-unknown-attribute-macro-expansion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-unknown-attribute-macro-expansion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-unknown-attribute-macro-expansion.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,6 +1,7 @@\n macro_rules! foo {\n     () => {\n-        #[cfg_attr(all(), unknown)] //~ ERROR `unknown` is currently unknown\n+        #[cfg_attr(all(), unknown)]\n+        //~^ ERROR cannot find attribute macro `unknown` in this scope\n         fn foo() {}\n     }\n }"}, {"sha": "c7c52a2923a5998790dae92c9cd5dfedcbe8c25f", "filename": "src/test/ui/conditional-compilation/cfg-attr-unknown-attribute-macro-expansion.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-unknown-attribute-macro-expansion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-unknown-attribute-macro-expansion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-unknown-attribute-macro-expansion.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,15 +1,11 @@\n-error[E0658]: The attribute `unknown` is currently unknown to the compiler and may have meaning added to it in the future\n+error: cannot find attribute macro `unknown` in this scope\n   --> $DIR/cfg-attr-unknown-attribute-macro-expansion.rs:3:27\n    |\n LL |         #[cfg_attr(all(), unknown)]\n    |                           ^^^^^^^\n ...\n LL | foo!();\n    | ------- in this macro invocation\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "13c873c3b7e48cd2d559ae7ac694fd7152f01d47", "filename": "src/test/ui/custom_attribute.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fcustom_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fcustom_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom_attribute.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,9 +1,9 @@\n #![feature(stmt_expr_attributes)]\n \n-#[foo] //~ ERROR The attribute `foo`\n+#[foo] //~ ERROR cannot find attribute macro `foo` in this scope\n fn main() {\n-    #[foo] //~ ERROR The attribute `foo`\n+    #[foo] //~ ERROR cannot find attribute macro `foo` in this scope\n     let x = ();\n-    #[foo] //~ ERROR The attribute `foo`\n+    #[foo] //~ ERROR cannot find attribute macro `foo` in this scope\n     x\n }"}, {"sha": "b4f9f3f49b2350d443e915cfa81ead67a35c1c6f", "filename": "src/test/ui/custom_attribute.stderr", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fcustom_attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fcustom_attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom_attribute.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,30 +1,20 @@\n-error[E0658]: The attribute `foo` is currently unknown to the compiler and may have meaning added to it in the future\n+error: cannot find attribute macro `foo` in this scope\n   --> $DIR/custom_attribute.rs:3:3\n    |\n LL | #[foo]\n    |   ^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `foo` is currently unknown to the compiler and may have meaning added to it in the future\n+error: cannot find attribute macro `foo` in this scope\n   --> $DIR/custom_attribute.rs:5:7\n    |\n LL |     #[foo]\n    |       ^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `foo` is currently unknown to the compiler and may have meaning added to it in the future\n+error: cannot find attribute macro `foo` in this scope\n   --> $DIR/custom_attribute.rs:7:7\n    |\n LL |     #[foo]\n    |       ^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "1b8e689c753f31a2c7ca18d12806be1d3f7c4fe2", "filename": "src/test/ui/derives/deriving-meta-unknown-trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fderives%2Fderiving-meta-unknown-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fderives%2Fderiving-meta-unknown-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-meta-unknown-trait.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -2,7 +2,7 @@ error: cannot find derive macro `Eqr` in this scope\n   --> $DIR/deriving-meta-unknown-trait.rs:1:10\n    |\n LL | #[derive(Eqr)]\n-   |          ^^^ help: try: `Eq`\n+   |          ^^^ help: a derive macro with a similar name exists: `Eq`\n \n error: aborting due to previous error\n "}, {"sha": "d34936b42a6ffe8521aad764bd006052fe6ea572", "filename": "src/test/ui/feature-gates/feature-gate-custom_attribute.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_attribute.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,23 +1,18 @@\n // Check that literals in attributes parse just fine.\n \n+#[fake_attr] //~ ERROR cannot find attribute macro `fake_attr` in this scope\n+#[fake_attr(100)] //~ ERROR cannot find attribute macro `fake_attr` in this scope\n+#[fake_attr(1, 2, 3)] //~ ERROR cannot find attribute macro `fake_attr` in this scope\n+#[fake_attr(\"hello\")] //~ ERROR cannot find attribute macro `fake_attr` in this scope\n+#[fake_attr(name = \"hello\")] //~ ERROR cannot find attribute macro `fake_attr` in this scope\n+#[fake_attr(1, \"hi\", key = 12, true, false)] //~ ERROR cannot find attribute macro `fake_attr` in th\n+#[fake_attr(key = \"hello\", val = 10)] //~ ERROR cannot find attribute macro `fake_attr` in this scop\n+#[fake_attr(key(\"hello\"), val(10))] //~ ERROR cannot find attribute macro `fake_attr` in this scope\n+#[fake_attr(enabled = true, disabled = false)] //~ ERROR cannot find attribute macro `fake_attr` in\n+#[fake_attr(true)] //~ ERROR cannot find attribute macro `fake_attr` in this scope\n+#[fake_attr(pi = 3.14159)] //~ ERROR cannot find attribute macro `fake_attr` in this scope\n+#[fake_attr(b\"hi\")] //~ ERROR cannot find attribute macro `fake_attr` in this scope\n+#[fake_doc(r\"doc\")] //~ ERROR cannot find attribute macro `fake_doc` in this scope\n+struct Q {}\n \n-#![allow(dead_code)]\n-#![allow(unused_variables)]\n-\n-#[fake_attr] //~ ERROR attribute `fake_attr` is currently unknown\n-#[fake_attr(100)] //~ ERROR attribute `fake_attr` is currently unknown\n-#[fake_attr(1, 2, 3)] //~ ERROR attribute `fake_attr` is currently unknown\n-#[fake_attr(\"hello\")] //~ ERROR attribute `fake_attr` is currently unknown\n-#[fake_attr(name = \"hello\")] //~ ERROR attribute `fake_attr` is currently unknown\n-#[fake_attr(1, \"hi\", key = 12, true, false)] //~ ERROR attribute `fake_attr` is currently unknown\n-#[fake_attr(key = \"hello\", val = 10)] //~ ERROR attribute `fake_attr` is currently unknown\n-#[fake_attr(key(\"hello\"), val(10))] //~ ERROR attribute `fake_attr` is currently unknown\n-#[fake_attr(enabled = true, disabled = false)] //~ ERROR attribute `fake_attr` is currently unknown\n-#[fake_attr(true)] //~ ERROR attribute `fake_attr` is currently unknown\n-#[fake_attr(pi = 3.14159)] //~ ERROR attribute `fake_attr` is currently unknown\n-#[fake_attr(b\"hi\")] //~ ERROR attribute `fake_attr` is currently unknown\n-#[fake_doc(r\"doc\")] //~ ERROR attribute `fake_doc` is currently unknown\n-struct Q {  }\n-\n-\n-fn main() { }\n+fn main() {}"}, {"sha": "efdc2d1cd31ed6b70c9977dc746105a817aa61bc", "filename": "src/test/ui/feature-gates/feature-gate-custom_attribute.stderr", "status": "modified", "additions": 26, "deletions": 66, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_attribute.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,120 +1,80 @@\n-error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/feature-gate-custom_attribute.rs:7:3\n+error: cannot find attribute macro `fake_attr` in this scope\n+  --> $DIR/feature-gate-custom_attribute.rs:3:3\n    |\n LL | #[fake_attr]\n    |   ^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/feature-gate-custom_attribute.rs:8:3\n+error: cannot find attribute macro `fake_attr` in this scope\n+  --> $DIR/feature-gate-custom_attribute.rs:4:3\n    |\n LL | #[fake_attr(100)]\n    |   ^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/feature-gate-custom_attribute.rs:9:3\n+error: cannot find attribute macro `fake_attr` in this scope\n+  --> $DIR/feature-gate-custom_attribute.rs:5:3\n    |\n LL | #[fake_attr(1, 2, 3)]\n    |   ^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/feature-gate-custom_attribute.rs:10:3\n+error: cannot find attribute macro `fake_attr` in this scope\n+  --> $DIR/feature-gate-custom_attribute.rs:6:3\n    |\n LL | #[fake_attr(\"hello\")]\n    |   ^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/feature-gate-custom_attribute.rs:11:3\n+error: cannot find attribute macro `fake_attr` in this scope\n+  --> $DIR/feature-gate-custom_attribute.rs:7:3\n    |\n LL | #[fake_attr(name = \"hello\")]\n    |   ^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/feature-gate-custom_attribute.rs:12:3\n+error: cannot find attribute macro `fake_attr` in this scope\n+  --> $DIR/feature-gate-custom_attribute.rs:8:3\n    |\n LL | #[fake_attr(1, \"hi\", key = 12, true, false)]\n    |   ^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/feature-gate-custom_attribute.rs:13:3\n+error: cannot find attribute macro `fake_attr` in this scope\n+  --> $DIR/feature-gate-custom_attribute.rs:9:3\n    |\n LL | #[fake_attr(key = \"hello\", val = 10)]\n    |   ^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/feature-gate-custom_attribute.rs:14:3\n+error: cannot find attribute macro `fake_attr` in this scope\n+  --> $DIR/feature-gate-custom_attribute.rs:10:3\n    |\n LL | #[fake_attr(key(\"hello\"), val(10))]\n    |   ^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/feature-gate-custom_attribute.rs:15:3\n+error: cannot find attribute macro `fake_attr` in this scope\n+  --> $DIR/feature-gate-custom_attribute.rs:11:3\n    |\n LL | #[fake_attr(enabled = true, disabled = false)]\n    |   ^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/feature-gate-custom_attribute.rs:16:3\n+error: cannot find attribute macro `fake_attr` in this scope\n+  --> $DIR/feature-gate-custom_attribute.rs:12:3\n    |\n LL | #[fake_attr(true)]\n    |   ^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/feature-gate-custom_attribute.rs:17:3\n+error: cannot find attribute macro `fake_attr` in this scope\n+  --> $DIR/feature-gate-custom_attribute.rs:13:3\n    |\n LL | #[fake_attr(pi = 3.14159)]\n    |   ^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/feature-gate-custom_attribute.rs:18:3\n+error: cannot find attribute macro `fake_attr` in this scope\n+  --> $DIR/feature-gate-custom_attribute.rs:14:3\n    |\n LL | #[fake_attr(b\"hi\")]\n    |   ^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `fake_doc` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/feature-gate-custom_attribute.rs:19:3\n+error: cannot find attribute macro `fake_doc` in this scope\n+  --> $DIR/feature-gate-custom_attribute.rs:15:3\n    |\n LL | #[fake_doc(r\"doc\")]\n    |   ^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n error: aborting due to 13 previous errors\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "13983726c78debbd60cd587ca568b8b20a5ec244", "filename": "src/test/ui/feature-gates/feature-gate-rustc-attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -19,5 +19,5 @@ fn g() {}\n //~^ ERROR used by the test suite\n #[rustc_unknown]\n //~^ ERROR attributes starting with `rustc` are reserved for use by the `rustc` compiler\n-//~| ERROR attribute `rustc_unknown` is currently unknown\n+//~| ERROR cannot find attribute macro `rustc_unknown` in this scope\n fn main() {}"}, {"sha": "23cf936ee8350bdc548e3a07ff161ea04e459f04", "filename": "src/test/ui/feature-gates/feature-gate-rustc-attrs.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -37,14 +37,11 @@ LL | #[rustc_unknown]\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n    = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `rustc_unknown` is currently unknown to the compiler and may have meaning added to it in the future\n+error: cannot find attribute macro `rustc_unknown` in this scope\n   --> $DIR/feature-gate-rustc-attrs.rs:20:3\n    |\n LL | #[rustc_unknown]\n    |   ^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n error[E0658]: used by the test suite\n   --> $DIR/feature-gate-rustc-attrs.rs:18:1"}, {"sha": "0fdb18d967a6c41723598a15861654f47cf14a0f", "filename": "src/test/ui/hygiene/no_implicit_prelude-2018.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude-2018.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -3,8 +3,6 @@ error: cannot find macro `print!` in this scope\n    |\n LL |         print!();\n    |         ^^^^^\n-   |\n-   = help: have you added the `#[macro_use]` on the module/import?\n \n error: aborting due to previous error\n "}, {"sha": "a89176fe6907be708f828a492efe5c0be21fffb2", "filename": "src/test/ui/hygiene/no_implicit_prelude.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -13,7 +13,6 @@ error: cannot find macro `panic!` in this scope\n LL |         assert_eq!(0, 0);\n    |         ^^^^^^^^^^^^^^^^^\n    |\n-   = help: have you added the `#[macro_use]` on the module/import?\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error[E0599]: no method named `clone` found for type `()` in the current scope"}, {"sha": "5f36993af2f305106d09099a296d4536cc6e4f94", "filename": "src/test/ui/hygiene/rustc-macro-transparency.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -26,6 +26,6 @@ fn main() {\n     Opaque; //~ ERROR cannot find value `Opaque` in this scope\n \n     transparent; // OK\n-    semitransparent; //~ ERROR cannot find value `semitransparent` in this scope\n-    opaque; //~ ERROR cannot find value `opaque` in this scope\n+    semitransparent; //~ ERROR expected value, found macro `semitransparent`\n+    opaque; //~ ERROR expected value, found macro `opaque`\n }"}, {"sha": "5eacfdf8dee139b380227cfcf3d9004154c0bf4b", "filename": "src/test/ui/hygiene/rustc-macro-transparency.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -4,18 +4,19 @@ error[E0425]: cannot find value `Opaque` in this scope\n LL |     Opaque;\n    |     ^^^^^^ help: a local variable with a similar name exists: `opaque`\n \n-error[E0425]: cannot find value `semitransparent` in this scope\n+error[E0423]: expected value, found macro `semitransparent`\n   --> $DIR/rustc-macro-transparency.rs:29:5\n    |\n LL |     semitransparent;\n-   |     ^^^^^^^^^^^^^^^ not found in this scope\n+   |     ^^^^^^^^^^^^^^^ help: use `!` to invoke the macro: `semitransparent!`\n \n-error[E0425]: cannot find value `opaque` in this scope\n+error[E0423]: expected value, found macro `opaque`\n   --> $DIR/rustc-macro-transparency.rs:30:5\n    |\n LL |     opaque;\n-   |     ^^^^^^ not found in this scope\n+   |     ^^^^^^ help: use `!` to invoke the macro: `opaque!`\n \n error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0425`.\n+Some errors have detailed explanations: E0423, E0425.\n+For more information about an error, try `rustc --explain E0423`."}, {"sha": "2182506c7b71991c27192af037913757199ab55f", "filename": "src/test/ui/impl-trait/universal_wrong_bounds.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_bounds.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -6,9 +6,8 @@ fn foo(f: impl Display + Clone) -> String {\n     wants_clone(f);\n }\n \n-fn wants_debug(g: impl Debug) { } //~ ERROR cannot find\n-fn wants_display(g: impl Debug) { } //~ ERROR cannot find\n+fn wants_debug(g: impl Debug) { } //~ ERROR expected trait, found derive macro `Debug`\n+fn wants_display(g: impl Debug) { } //~ ERROR expected trait, found derive macro `Debug`\n fn wants_clone(g: impl Clone) { }\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "f530792955bc2e282ba7f05cb0f68c48089cae2e", "filename": "src/test/ui/impl-trait/universal_wrong_bounds.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_bounds.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,23 +1,23 @@\n-error[E0405]: cannot find trait `Debug` in this scope\n+error[E0404]: expected trait, found derive macro `Debug`\n   --> $DIR/universal_wrong_bounds.rs:9:24\n    |\n LL | fn wants_debug(g: impl Debug) { }\n-   |                        ^^^^^ not found in this scope\n-help: possible candidate is found in another module, you can import it into scope\n+   |                        ^^^^^ not a trait\n+help: possible better candidate is found in another module, you can import it into scope\n    |\n LL | use std::fmt::Debug;\n    |\n \n-error[E0405]: cannot find trait `Debug` in this scope\n+error[E0404]: expected trait, found derive macro `Debug`\n   --> $DIR/universal_wrong_bounds.rs:10:26\n    |\n LL | fn wants_display(g: impl Debug) { }\n-   |                          ^^^^^ not found in this scope\n-help: possible candidate is found in another module, you can import it into scope\n+   |                          ^^^^^ not a trait\n+help: possible better candidate is found in another module, you can import it into scope\n    |\n LL | use std::fmt::Debug;\n    |\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0405`.\n+For more information about this error, try `rustc --explain E0404`."}, {"sha": "fad7bf55cf4ea28bbe4593ca80c753c44ad9ab6f", "filename": "src/test/ui/issues/issue-32655.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fissues%2Fissue-32655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fissues%2Fissue-32655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32655.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,9 +1,6 @@\n-#![allow(dead_code)]\n-#![feature(rustc_attrs)]\n-\n macro_rules! foo (\n     () => (\n-        #[derive_Clone] //~ ERROR attribute `derive_Clone` is currently unknown\n+        #[derive_Clone] //~ ERROR cannot find attribute macro `derive_Clone` in this scope\n         struct T;\n     );\n );\n@@ -15,7 +12,7 @@ macro_rules! bar (\n foo!();\n \n bar!(\n-    #[derive_Clone] //~ ERROR attribute `derive_Clone` is currently unknown\n+    #[derive_Clone] //~ ERROR cannot find attribute macro `derive_Clone` in this scope\n     struct S;\n );\n "}, {"sha": "e13bed0fbfd660befb083ccb4cdb7b324150c54b", "filename": "src/test/ui/issues/issue-32655.stderr", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fissues%2Fissue-32655.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fissues%2Fissue-32655.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32655.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,24 +1,17 @@\n-error[E0658]: The attribute `derive_Clone` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/issue-32655.rs:6:11\n+error: cannot find attribute macro `derive_Clone` in this scope\n+  --> $DIR/issue-32655.rs:3:11\n    |\n LL |         #[derive_Clone]\n    |           ^^^^^^^^^^^^\n ...\n LL | foo!();\n    | ------- in this macro invocation\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `derive_Clone` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/issue-32655.rs:18:7\n+error: cannot find attribute macro `derive_Clone` in this scope\n+  --> $DIR/issue-32655.rs:15:7\n    |\n LL |     #[derive_Clone]\n    |       ^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "1e67e9a815830b0c14ea7d97b3a74d5e775f9e2a", "filename": "src/test/ui/issues/issue-37534.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fissues%2Fissue-37534.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fissues%2Fissue-37534.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37534.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,5 +1,5 @@\n struct Foo<T: ?Hash> { }\n-//~^ ERROR cannot find trait `Hash` in this scope\n+//~^ ERROR expected trait, found derive macro `Hash`\n //~^^ ERROR parameter `T` is never used\n //~^^^ WARN default bound relaxed for a type parameter, but this does nothing\n "}, {"sha": "3a0ab32dcc66be9064271551c331c7ef3f31360c", "filename": "src/test/ui/issues/issue-37534.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fissues%2Fissue-37534.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fissues%2Fissue-37534.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37534.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,9 +1,9 @@\n-error[E0405]: cannot find trait `Hash` in this scope\n+error[E0404]: expected trait, found derive macro `Hash`\n   --> $DIR/issue-37534.rs:1:16\n    |\n LL | struct Foo<T: ?Hash> { }\n-   |                ^^^^ not found in this scope\n-help: possible candidate is found in another module, you can import it into scope\n+   |                ^^^^ not a trait\n+help: possible better candidate is found in another module, you can import it into scope\n    |\n LL | use std::hash::Hash;\n    |\n@@ -24,5 +24,5 @@ LL | struct Foo<T: ?Hash> { }\n \n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0392, E0405.\n+Some errors have detailed explanations: E0392, E0404.\n For more information about an error, try `rustc --explain E0392`."}, {"sha": "38074d5b05ca2485859b352cf22c7623e6bcbe92", "filename": "src/test/ui/issues/issue-49074.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fissues%2Fissue-49074.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fissues%2Fissue-49074.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49074.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,7 +1,7 @@\n // Check that unknown attribute error is shown even if there are unresolved macros.\n \n #[marco_use] // typo\n-//~^ ERROR The attribute `marco_use` is currently unknown to the compiler\n+//~^ ERROR cannot find attribute macro `marco_use` in this scope\n mod foo {\n     macro_rules! bar {\n         () => ();"}, {"sha": "c557255ab502eab03f66b6efae3541cf9e1d8b10", "filename": "src/test/ui/issues/issue-49074.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fissues%2Fissue-49074.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fissues%2Fissue-49074.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49074.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,11 +1,8 @@\n-error[E0658]: The attribute `marco_use` is currently unknown to the compiler and may have meaning added to it in the future\n+error: cannot find attribute macro `marco_use` in this scope\n   --> $DIR/issue-49074.rs:3:3\n    |\n LL | #[marco_use] // typo\n    |   ^^^^^^^^^ help: a built-in attribute with a similar name exists: `macro_use`\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n error: cannot find macro `bar!` in this scope\n   --> $DIR/issue-49074.rs:12:4\n@@ -17,4 +14,3 @@ LL |    bar!();\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "967f4f3c4ac4a93f5785d19be37aab173189a18e", "filename": "src/test/ui/macros/macro-name-typo.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fmacros%2Fmacro-name-typo.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fmacros%2Fmacro-name-typo.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-name-typo.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -2,7 +2,7 @@ error: cannot find macro `printlx!` in this scope\n   --> $DIR/macro-name-typo.rs:2:5\n    |\n LL |     printlx!(\"oh noes!\");\n-   |     ^^^^^^^ help: you could try the macro: `println`\n+   |     ^^^^^^^ help: a macro with a similar name exists: `println`\n \n error: aborting due to previous error\n "}, {"sha": "96b8a24cff293c8ccc64622fa4a9fa2c05fcff5b", "filename": "src/test/ui/macros/macro-path-prelude-fail-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-3.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -2,7 +2,7 @@ error: cannot find macro `inline!` in this scope\n   --> $DIR/macro-path-prelude-fail-3.rs:2:5\n    |\n LL |     inline!();\n-   |     ^^^^^^ help: you could try the macro: `line`\n+   |     ^^^^^^ help: a macro with a similar name exists: `line`\n \n error: aborting due to previous error\n "}, {"sha": "b69a1fa4df08ac6bc475f4d6df028215455d73e0", "filename": "src/test/ui/macros/macro-reexport-removed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fmacros%2Fmacro-reexport-removed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fmacros%2Fmacro-reexport-removed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-reexport-removed.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -2,7 +2,7 @@\n \n #![feature(macro_reexport)] //~ ERROR feature has been removed\n \n-#[macro_reexport(macro_one)] //~ ERROR attribute `macro_reexport` is currently unknown\n+#[macro_reexport(macro_one)] //~ ERROR cannot find attribute macro `macro_reexport` in this scope\n extern crate two_macros;\n \n fn main() {}"}, {"sha": "25778fba68f7c2e008f9a15b726e6a736d89291c", "filename": "src/test/ui/macros/macro-reexport-removed.stderr", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fmacros%2Fmacro-reexport-removed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fmacros%2Fmacro-reexport-removed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-reexport-removed.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -10,16 +10,12 @@ note: subsumed by `pub use`\n LL | #![feature(macro_reexport)]\n    |            ^^^^^^^^^^^^^^\n \n-error[E0658]: The attribute `macro_reexport` is currently unknown to the compiler and may have meaning added to it in the future\n+error: cannot find attribute macro `macro_reexport` in this scope\n   --> $DIR/macro-reexport-removed.rs:5:3\n    |\n LL | #[macro_reexport(macro_one)]\n    |   ^^^^^^^^^^^^^^ help: a built-in attribute with a similar name exists: `macro_export`\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0557, E0658.\n-For more information about an error, try `rustc --explain E0557`.\n+For more information about this error, try `rustc --explain E0557`."}, {"sha": "28f727d6a58081ed12ddeb204824f98d99955b59", "filename": "src/test/ui/macros/macro-use-wrong-name.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fmacros%2Fmacro-use-wrong-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fmacros%2Fmacro-use-wrong-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-use-wrong-name.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -2,7 +2,7 @@ error: cannot find macro `macro_two!` in this scope\n   --> $DIR/macro-use-wrong-name.rs:7:5\n    |\n LL |     macro_two!();\n-   |     ^^^^^^^^^ help: you could try the macro: `macro_one`\n+   |     ^^^^^^^^^ help: a macro with a similar name exists: `macro_one`\n \n error: aborting due to previous error\n "}, {"sha": "9239b2a51e62b589aa0d4ba6560261675c3c1da8", "filename": "src/test/ui/macros/macro_undefined.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fmacros%2Fmacro_undefined.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fmacros%2Fmacro_undefined.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro_undefined.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -2,7 +2,7 @@ error: cannot find macro `k!` in this scope\n   --> $DIR/macro_undefined.rs:11:5\n    |\n LL |     k!();\n-   |     ^ help: you could try the macro: `kl`\n+   |     ^ help: a macro with a similar name exists: `kl`\n \n error: aborting due to previous error\n "}, {"sha": "c314967da4fb7c2dee7e71b348aa416844f05a32", "filename": "src/test/ui/no-implicit-prelude-nested.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fno-implicit-prelude-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fno-implicit-prelude-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-implicit-prelude-nested.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -9,7 +9,7 @@ mod foo {\n     mod baz {\n         struct Test;\n         impl Add for Test {} //~ ERROR cannot find trait `Add` in this scope\n-        impl Clone for Test {} //~ ERROR cannot find trait `Clone` in this scope\n+        impl Clone for Test {} //~ ERROR expected trait, found derive macro `Clone`\n         impl Iterator for Test {} //~ ERROR cannot find trait `Iterator` in this scope\n         impl ToString for Test {} //~ ERROR cannot find trait `ToString` in this scope\n         impl Writer for Test {} //~ ERROR cannot find trait `Writer` in this scope\n@@ -21,7 +21,7 @@ mod foo {\n \n     struct Test;\n     impl Add for Test {} //~ ERROR cannot find trait `Add` in this scope\n-    impl Clone for Test {} //~ ERROR cannot find trait `Clone` in this scope\n+    impl Clone for Test {} //~ ERROR expected trait, found derive macro `Clone`\n     impl Iterator for Test {} //~ ERROR cannot find trait `Iterator` in this scope\n     impl ToString for Test {} //~ ERROR cannot find trait `ToString` in this scope\n     impl Writer for Test {} //~ ERROR cannot find trait `Writer` in this scope\n@@ -36,7 +36,7 @@ fn qux() {\n     mod qux_inner {\n         struct Test;\n         impl Add for Test {} //~ ERROR cannot find trait `Add` in this scope\n-        impl Clone for Test {} //~ ERROR cannot find trait `Clone` in this scope\n+        impl Clone for Test {} //~ ERROR expected trait, found derive macro `Clone`\n         impl Iterator for Test {} //~ ERROR cannot find trait `Iterator` in this scope\n         impl ToString for Test {} //~ ERROR cannot find trait `ToString` in this scope\n         impl Writer for Test {} //~ ERROR cannot find trait `Writer` in this scope"}, {"sha": "8d695e45da457037d94b364f461c127cff749074", "filename": "src/test/ui/no-implicit-prelude-nested.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fno-implicit-prelude-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fno-implicit-prelude-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-implicit-prelude-nested.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -8,12 +8,12 @@ help: possible candidate is found in another module, you can import it into scop\n LL |         use std::ops::Add;\n    |\n \n-error[E0405]: cannot find trait `Clone` in this scope\n+error[E0404]: expected trait, found derive macro `Clone`\n   --> $DIR/no-implicit-prelude-nested.rs:12:14\n    |\n LL |         impl Clone for Test {}\n-   |              ^^^^^ not found in this scope\n-help: possible candidates are found in other modules, you can import them into scope\n+   |              ^^^^^ not a trait\n+help: possible better candidates are found in other modules, you can import them into scope\n    |\n LL |         use std::clone::Clone;\n    |\n@@ -72,12 +72,12 @@ help: possible candidate is found in another module, you can import it into scop\n LL |     use std::ops::Add;\n    |\n \n-error[E0405]: cannot find trait `Clone` in this scope\n+error[E0404]: expected trait, found derive macro `Clone`\n   --> $DIR/no-implicit-prelude-nested.rs:24:10\n    |\n LL |     impl Clone for Test {}\n-   |          ^^^^^ not found in this scope\n-help: possible candidates are found in other modules, you can import them into scope\n+   |          ^^^^^ not a trait\n+help: possible better candidates are found in other modules, you can import them into scope\n    |\n LL |     use std::clone::Clone;\n    |\n@@ -136,12 +136,12 @@ help: possible candidate is found in another module, you can import it into scop\n LL |         use std::ops::Add;\n    |\n \n-error[E0405]: cannot find trait `Clone` in this scope\n+error[E0404]: expected trait, found derive macro `Clone`\n   --> $DIR/no-implicit-prelude-nested.rs:39:14\n    |\n LL |         impl Clone for Test {}\n-   |              ^^^^^ not found in this scope\n-help: possible candidates are found in other modules, you can import them into scope\n+   |              ^^^^^ not a trait\n+help: possible better candidates are found in other modules, you can import them into scope\n    |\n LL |         use std::clone::Clone;\n    |\n@@ -192,5 +192,5 @@ LL |         use std::prelude::v1::drop;\n \n error: aborting due to 18 previous errors\n \n-Some errors have detailed explanations: E0405, E0425.\n-For more information about an error, try `rustc --explain E0405`.\n+Some errors have detailed explanations: E0404, E0405, E0425.\n+For more information about an error, try `rustc --explain E0404`."}, {"sha": "4b0ca4d524e620d09af55140b5d79e3d27ac7764", "filename": "src/test/ui/no-implicit-prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fno-implicit-prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fno-implicit-prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-implicit-prelude.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -8,7 +8,7 @@\n \n struct Test;\n impl Add for Test {} //~ ERROR cannot find trait `Add` in this scope\n-impl Clone for Test {} //~ ERROR cannot find trait `Clone` in this scope\n+impl Clone for Test {} //~ ERROR expected trait, found derive macro `Clone`\n impl Iterator for Test {} //~ ERROR cannot find trait `Iterator` in this scope\n impl ToString for Test {} //~ ERROR cannot find trait `ToString` in this scope\n impl Writer for Test {} //~ ERROR cannot find trait `Writer` in this scope"}, {"sha": "6ae889df602d76459ff33d5a6b9c7e1abca084ac", "filename": "src/test/ui/no-implicit-prelude.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fno-implicit-prelude.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fno-implicit-prelude.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-implicit-prelude.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -8,12 +8,12 @@ help: possible candidate is found in another module, you can import it into scop\n LL | use std::ops::Add;\n    |\n \n-error[E0405]: cannot find trait `Clone` in this scope\n+error[E0404]: expected trait, found derive macro `Clone`\n   --> $DIR/no-implicit-prelude.rs:11:6\n    |\n LL | impl Clone for Test {}\n-   |      ^^^^^ not found in this scope\n-help: possible candidates are found in other modules, you can import them into scope\n+   |      ^^^^^ not a trait\n+help: possible better candidates are found in other modules, you can import them into scope\n    |\n LL | use std::clone::Clone;\n    |\n@@ -64,5 +64,5 @@ LL | use std::prelude::v1::drop;\n \n error: aborting due to 6 previous errors\n \n-Some errors have detailed explanations: E0405, E0425.\n-For more information about an error, try `rustc --explain E0405`.\n+Some errors have detailed explanations: E0404, E0405, E0425.\n+For more information about an error, try `rustc --explain E0404`."}, {"sha": "59ba1390e13237e023caf6a59e50a0b70c764f8d", "filename": "src/test/ui/proc-macro/derive-helper-shadowing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -19,7 +19,7 @@ struct S {\n         struct U;\n \n         mod inner {\n-            #[empty_helper] //~ ERROR attribute `empty_helper` is currently unknown\n+            #[empty_helper] //~ ERROR cannot find attribute macro `empty_helper` in this scope\n             struct V;\n         }\n "}, {"sha": "149f6eef443c1f7c68d08862fb5df41e7de54d7f", "filename": "src/test/ui/proc-macro/derive-helper-shadowing.stderr", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,11 +1,8 @@\n-error[E0658]: The attribute `empty_helper` is currently unknown to the compiler and may have meaning added to it in the future\n+error: cannot find attribute macro `empty_helper` in this scope\n   --> $DIR/derive-helper-shadowing.rs:22:15\n    |\n LL |             #[empty_helper]\n    |               ^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n error[E0659]: `empty_helper` is ambiguous (derive helper attribute vs any other name)\n   --> $DIR/derive-helper-shadowing.rs:8:3\n@@ -27,5 +24,4 @@ LL | use test_macros::empty_attr as empty_helper;\n \n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0658, E0659.\n-For more information about an error, try `rustc --explain E0658`.\n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "4e6f9b072205da90ceb6388a9df4aacf2c493713", "filename": "src/test/ui/proc-macro/derive-still-gated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fderive-still-gated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fderive-still-gated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-still-gated.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -3,7 +3,7 @@\n #[macro_use]\n extern crate test_macros;\n \n-#[derive_Empty] //~ ERROR attribute `derive_Empty` is currently unknown\n+#[derive_Empty] //~ ERROR cannot find attribute macro `derive_Empty` in this scope\n struct A;\n \n fn main() {}"}, {"sha": "4df1715db94678e141292b8ea3b6662ce233632b", "filename": "src/test/ui/proc-macro/derive-still-gated.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fderive-still-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fderive-still-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-still-gated.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,12 +1,8 @@\n-error[E0658]: The attribute `derive_Empty` is currently unknown to the compiler and may have meaning added to it in the future\n+error: cannot find attribute macro `derive_Empty` in this scope\n   --> $DIR/derive-still-gated.rs:6:3\n    |\n LL | #[derive_Empty]\n    |   ^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "da7c89fdd46de40f8ec31ef382a3d7d7191e5850", "filename": "src/test/ui/proc-macro/expand-to-unstable-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-to-unstable-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-to-unstable-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-to-unstable-2.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,11 +1,12 @@\n // aux-build:derive-unstable-2.rs\n \n+#![feature(custom_attribute)]\n+\n #[macro_use]\n extern crate derive_unstable_2;\n \n #[derive(Unstable)]\n //~^ ERROR attributes starting with `rustc` are reserved for use by the `rustc` compiler\n-//~| ERROR attribute `rustc_foo` is currently unknown to the compiler\n \n struct A;\n "}, {"sha": "01e6a4a8ab95dc13ef6418bb078258e7bfe927bf", "filename": "src/test/ui/proc-macro/expand-to-unstable-2.stderr", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-to-unstable-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-to-unstable-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-to-unstable-2.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,21 +1,12 @@\n error[E0658]: attributes starting with `rustc` are reserved for use by the `rustc` compiler\n-  --> $DIR/expand-to-unstable-2.rs:6:10\n+  --> $DIR/expand-to-unstable-2.rs:8:10\n    |\n LL | #[derive(Unstable)]\n    |          ^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n    = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `rustc_foo` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/expand-to-unstable-2.rs:6:10\n-   |\n-LL | #[derive(Unstable)]\n-   |          ^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "491b89b2f5598018f7a80e6472791c0166544728", "filename": "src/test/ui/proc-macro/issue-41211.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fissue-41211.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fissue-41211.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-41211.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -3,11 +3,11 @@\n // FIXME: https://github.com/rust-lang/rust/issues/41430\n // This is a temporary regression test for the ICE reported in #41211\n \n+#![feature(custom_attribute)]\n #![feature(custom_inner_attributes)]\n \n #![identity_attr]\n-//~^ ERROR attribute `identity_attr` is currently unknown to the compiler\n-//~| ERROR inconsistent resolution for a macro: first custom attribute, then attribute macro\n+//~^ ERROR inconsistent resolution for a macro: first custom attribute, then attribute macro\n extern crate test_macros;\n use test_macros::identity_attr;\n "}, {"sha": "f01cba0c93034b416ce2f2db3c8d17f245a9e119", "filename": "src/test/ui/proc-macro/issue-41211.stderr", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fissue-41211.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fissue-41211.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-41211.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,18 +1,8 @@\n-error[E0658]: The attribute `identity_attr` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/issue-41211.rs:8:4\n-   |\n-LL | #![identity_attr]\n-   |    ^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n-\n error: inconsistent resolution for a macro: first custom attribute, then attribute macro\n-  --> $DIR/issue-41211.rs:8:4\n+  --> $DIR/issue-41211.rs:9:4\n    |\n LL | #![identity_attr]\n    |    ^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "8a26df9e76ade24209a90f1e308e738144737049", "filename": "src/test/ui/proc-macro/macro-namespace-reserved-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -35,7 +35,7 @@ fn check_bang3() {\n                        //~| ERROR expected macro, found derive macro `crate::MyTrait`\n }\n \n-#[my_macro] //~ ERROR attribute `my_macro` is currently unknown\n+#[my_macro] //~ ERROR cannot find attribute macro `my_macro` in this scope\n #[crate::my_macro] //~ ERROR can't use a procedural macro from the same crate that defines it\n                    //~| ERROR expected attribute, found macro `crate::my_macro`\n fn check_attr1() {}"}, {"sha": "e6017dc4d116387f618fa9259160c20fde5e704d", "filename": "src/test/ui/proc-macro/macro-namespace-reserved-2.stderr", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -76,15 +76,6 @@ error: can't use a procedural macro from the same crate that defines it\n LL | #[derive(MyTrait)]\n    |          ^^^^^^^\n \n-error[E0658]: The attribute `my_macro` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/macro-namespace-reserved-2.rs:38:3\n-   |\n-LL | #[my_macro]\n-   |   ^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n-\n error: can't use a procedural macro from the same crate that defines it\n   --> $DIR/macro-namespace-reserved-2.rs:39:3\n    |\n@@ -97,6 +88,12 @@ error: expected attribute, found macro `crate::my_macro`\n LL | #[crate::my_macro]\n    |   ^^^^^^^^^^^^^^^ not an attribute\n \n+error: cannot find attribute macro `my_macro` in this scope\n+  --> $DIR/macro-namespace-reserved-2.rs:38:3\n+   |\n+LL | #[my_macro]\n+   |   ^^^^^^^^\n+\n error: cannot find derive macro `my_macro` in this scope\n   --> $DIR/macro-namespace-reserved-2.rs:48:10\n    |\n@@ -117,4 +114,3 @@ LL |     MyTrait!();\n \n error: aborting due to 19 previous errors\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "04215226c6d4183b505f63a8f02b279ab9bec7cf", "filename": "src/test/ui/proc-macro/proc-macro-attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-attributes.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -4,7 +4,7 @@\n extern crate derive_b;\n \n #[B] //~ ERROR `B` is ambiguous\n-#[C] //~ ERROR attribute `C` is currently unknown to the compiler\n+#[C] //~ ERROR cannot find attribute macro `C` in this scope\n #[B(D)] //~ ERROR `B` is ambiguous\n #[B(E = \"foo\")] //~ ERROR `B` is ambiguous\n #[B(arbitrary tokens)] //~ ERROR `B` is ambiguous"}, {"sha": "b068c6bc83bf3804b6ed8f2f2fff41b818aafc44", "filename": "src/test/ui/proc-macro/proc-macro-attributes.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-attributes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-attributes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-attributes.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,11 +1,8 @@\n-error[E0658]: The attribute `C` is currently unknown to the compiler and may have meaning added to it in the future\n+error: cannot find attribute macro `C` in this scope\n   --> $DIR/proc-macro-attributes.rs:7:3\n    |\n LL | #[C]\n-   |   ^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n+   |   ^ help: a derive helper attribute with a similar name exists: `B`\n \n error[E0659]: `B` is ambiguous (derive helper attribute vs any other name)\n   --> $DIR/proc-macro-attributes.rs:6:3\n@@ -77,5 +74,4 @@ LL | #[macro_use]\n \n error: aborting due to 5 previous errors\n \n-Some errors have detailed explanations: E0658, E0659.\n-For more information about an error, try `rustc --explain E0658`.\n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "0a7861aba6ebb1a2888472e116aff2df2edd61e3", "filename": "src/test/ui/proc-macro/resolve-error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -24,11 +24,11 @@ macro_rules! attr_proc_mac {\n struct Foo;\n \n // Interpreted as a feature gated custom attribute\n-#[attr_proc_macra] //~ ERROR attribute `attr_proc_macra` is currently unknown\n+#[attr_proc_macra] //~ ERROR cannot find attribute macro `attr_proc_macra` in this scope\n struct Bar;\n \n // Interpreted as a feature gated custom attribute\n-#[FooWithLongNan] //~ ERROR attribute `FooWithLongNan` is currently unknown\n+#[FooWithLongNan] //~ ERROR cannot find attribute macro `FooWithLongNan` in this scope\n struct Asdf;\n \n #[derive(Dlone)]"}, {"sha": "3c9b2baacbd91ad330c04522c37987d4009001f5", "filename": "src/test/ui/proc-macro/resolve-error.stderr", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,38 +1,32 @@\n-error[E0658]: The attribute `attr_proc_macra` is currently unknown to the compiler and may have meaning added to it in the future\n+error: cannot find derive macro `FooWithLongNan` in this scope\n+  --> $DIR/resolve-error.rs:22:10\n+   |\n+LL | #[derive(FooWithLongNan)]\n+   |          ^^^^^^^^^^^^^^ help: a derive macro with a similar name exists: `FooWithLongName`\n+\n+error: cannot find attribute macro `attr_proc_macra` in this scope\n   --> $DIR/resolve-error.rs:27:3\n    |\n LL | #[attr_proc_macra]\n-   |   ^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n+   |   ^^^^^^^^^^^^^^^ help: an attribute macro with a similar name exists: `attr_proc_macro`\n \n-error[E0658]: The attribute `FooWithLongNan` is currently unknown to the compiler and may have meaning added to it in the future\n+error: cannot find attribute macro `FooWithLongNan` in this scope\n   --> $DIR/resolve-error.rs:31:3\n    |\n LL | #[FooWithLongNan]\n    |   ^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n-\n-error: cannot find derive macro `FooWithLongNan` in this scope\n-  --> $DIR/resolve-error.rs:22:10\n-   |\n-LL | #[derive(FooWithLongNan)]\n-   |          ^^^^^^^^^^^^^^ help: try: `FooWithLongName`\n \n error: cannot find derive macro `Dlone` in this scope\n   --> $DIR/resolve-error.rs:34:10\n    |\n LL | #[derive(Dlone)]\n-   |          ^^^^^ help: try: `Clone`\n+   |          ^^^^^ help: a derive macro with a similar name exists: `Clone`\n \n error: cannot find derive macro `Dlona` in this scope\n   --> $DIR/resolve-error.rs:38:10\n    |\n LL | #[derive(Dlona)]\n-   |          ^^^^^ help: try: `Clona`\n+   |          ^^^^^ help: a derive macro with a similar name exists: `Clona`\n \n error: cannot find derive macro `attr_proc_macra` in this scope\n   --> $DIR/resolve-error.rs:42:10\n@@ -44,13 +38,13 @@ error: cannot find macro `FooWithLongNama!` in this scope\n   --> $DIR/resolve-error.rs:47:5\n    |\n LL |     FooWithLongNama!();\n-   |     ^^^^^^^^^^^^^^^ help: you could try the macro: `FooWithLongNam`\n+   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `FooWithLongNam`\n \n error: cannot find macro `attr_proc_macra!` in this scope\n   --> $DIR/resolve-error.rs:50:5\n    |\n LL |     attr_proc_macra!();\n-   |     ^^^^^^^^^^^^^^^ help: you could try the macro: `attr_proc_mac`\n+   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `attr_proc_mac`\n \n error: cannot find macro `Dlona!` in this scope\n   --> $DIR/resolve-error.rs:53:5\n@@ -62,8 +56,7 @@ error: cannot find macro `bang_proc_macrp!` in this scope\n   --> $DIR/resolve-error.rs:56:5\n    |\n LL |     bang_proc_macrp!();\n-   |     ^^^^^^^^^^^^^^^ help: you could try the macro: `bang_proc_macro`\n+   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `bang_proc_macro`\n \n error: aborting due to 10 previous errors\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "fddb991da822cfa297c9db0a5ca67a365024e45c", "filename": "src/test/ui/reserved/reserved-attr-on-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Freserved%2Freserved-attr-on-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Freserved%2Freserved-attr-on-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freserved%2Freserved-attr-on-macro.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,5 +1,5 @@\n #[rustc_attribute_should_be_reserved]\n-//~^ ERROR attribute `rustc_attribute_should_be_reserved` is currently unknown\n+//~^ ERROR cannot find attribute macro `rustc_attribute_should_be_reserved` in this scope\n //~| ERROR attributes starting with `rustc` are reserved for use by the `rustc` compiler\n \n macro_rules! foo {"}, {"sha": "d4b97d290ea891b5593fa94748431bc1edb323ba", "filename": "src/test/ui/reserved/reserved-attr-on-macro.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Freserved%2Freserved-attr-on-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Freserved%2Freserved-attr-on-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freserved%2Freserved-attr-on-macro.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -7,14 +7,11 @@ LL | #[rustc_attribute_should_be_reserved]\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n    = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `rustc_attribute_should_be_reserved` is currently unknown to the compiler and may have meaning added to it in the future\n+error: cannot find attribute macro `rustc_attribute_should_be_reserved` in this scope\n   --> $DIR/reserved-attr-on-macro.rs:1:3\n    |\n LL | #[rustc_attribute_should_be_reserved]\n    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n error: cannot determine resolution for the macro `foo`\n   --> $DIR/reserved-attr-on-macro.rs:10:5"}, {"sha": "2e3c0f5448e865e770f7618db2bc4bbf1e36ceae", "filename": "src/test/ui/resolve/levenshtein.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -2,7 +2,7 @@ error[E0412]: cannot find type `esize` in this scope\n   --> $DIR/levenshtein.rs:5:11\n    |\n LL | fn foo(c: esize) {} // Misspelled primitive type name.\n-   |           ^^^^^ help: a primitive type with a similar name exists: `isize`\n+   |           ^^^^^ help: a builtin type with a similar name exists: `isize`\n \n error[E0412]: cannot find type `Baz` in this scope\n   --> $DIR/levenshtein.rs:10:10"}, {"sha": "14b2c8644e0b40f2caa9fc05695220cba02b16e1", "filename": "src/test/ui/span/issue-36530.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fspan%2Fissue-36530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fspan%2Fissue-36530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-36530.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,9 +1,10 @@\n // gate-test-custom_inner_attributes\n \n-#[foo] //~ ERROR is currently unknown to the compiler\n+#![feature(custom_attribute)]\n+\n+#[foo]\n mod foo {\n-    #![foo] //~ ERROR is currently unknown to the compiler\n-            //~| ERROR non-builtin inner attributes are unstable\n+    #![foo] //~ ERROR non-builtin inner attributes are unstable\n }\n \n fn main() {}"}, {"sha": "c6b7895e65a0f240620617e48a2417a5d0add39e", "filename": "src/test/ui/span/issue-36530.stderr", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fspan%2Fissue-36530.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fspan%2Fissue-36530.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-36530.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,30 +1,12 @@\n-error[E0658]: The attribute `foo` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/issue-36530.rs:3:3\n-   |\n-LL | #[foo]\n-   |   ^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n-\n error[E0658]: non-builtin inner attributes are unstable\n-  --> $DIR/issue-36530.rs:5:5\n+  --> $DIR/issue-36530.rs:7:5\n    |\n LL |     #![foo]\n    |     ^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54726\n    = help: add `#![feature(custom_inner_attributes)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `foo` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/issue-36530.rs:5:8\n-   |\n-LL |     #![foo]\n-   |        ^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "74f63f2b0ed073fca059049714baa620f07a907b", "filename": "src/test/ui/suggestions/attribute-typos.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,11 +1,11 @@\n-#[deprcated] //~ ERROR attribute `deprcated` is currently unknown\n+#[deprcated] //~ ERROR cannot find attribute macro `deprcated` in this scope\n fn foo() {}\n \n-#[tests] //~ ERROR attribute `tests` is currently unknown to the compiler\n+#[tests] //~ ERROR cannot find attribute macro `tests` in this scope\n fn bar() {}\n \n #[rustc_err]\n-//~^ ERROR attribute `rustc_err` is currently unknown\n+//~^ ERROR cannot find attribute macro `rustc_err` in this scope\n //~| ERROR attributes starting with `rustc` are reserved for use by the `rustc` compiler\n \n fn main() {}"}, {"sha": "6b2f591b9e7d9cb57e24dd96d66d8e7cdf8dd2d1", "filename": "src/test/ui/suggestions/attribute-typos.stderr", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -7,32 +7,23 @@ LL | #[rustc_err]\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n    = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n \n-error[E0658]: The attribute `rustc_err` is currently unknown to the compiler and may have meaning added to it in the future\n+error: cannot find attribute macro `rustc_err` in this scope\n   --> $DIR/attribute-typos.rs:7:3\n    |\n LL | #[rustc_err]\n-   |   ^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n+   |   ^^^^^^^^^ help: a built-in attribute with a similar name exists: `rustc_error`\n \n-error[E0658]: The attribute `tests` is currently unknown to the compiler and may have meaning added to it in the future\n+error: cannot find attribute macro `tests` in this scope\n   --> $DIR/attribute-typos.rs:4:3\n    |\n LL | #[tests]\n-   |   ^^^^^ help: a built-in attribute with a similar name exists: `test`\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n+   |   ^^^^^ help: an attribute macro with a similar name exists: `test`\n \n-error[E0658]: The attribute `deprcated` is currently unknown to the compiler and may have meaning added to it in the future\n+error: cannot find attribute macro `deprcated` in this scope\n   --> $DIR/attribute-typos.rs:1:3\n    |\n LL | #[deprcated]\n    |   ^^^^^^^^^ help: a built-in attribute with a similar name exists: `deprecated`\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n \n error: aborting due to 4 previous errors\n "}, {"sha": "8c62b34bd9ea5695edfdc1de5e454ff91114e5e7", "filename": "src/test/ui/tool-attributes/tool-attributes-misplaced-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-misplaced-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-misplaced-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-misplaced-1.rs?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -5,7 +5,7 @@ type B = rustfmt::skip; //~ ERROR expected type, found tool attribute `rustfmt::\n struct S;\n \n // Interpreted as a feature gated custom attribute\n-#[rustfmt] //~ ERROR attribute `rustfmt` is currently unknown\n+#[rustfmt] //~ ERROR cannot find attribute macro `rustfmt` in this scope\n fn check() {}\n \n #[rustfmt::skip] // OK"}, {"sha": "33581a170822b848857efffc6a5f837cb44078cd", "filename": "src/test/ui/tool-attributes/tool-attributes-misplaced-1.stderr", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-misplaced-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe499a7b34dcb1fc054dd637ea561a19a268d2de/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-misplaced-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-misplaced-1.stderr?ref=fe499a7b34dcb1fc054dd637ea561a19a268d2de", "patch": "@@ -1,18 +1,15 @@\n-error[E0658]: The attribute `rustfmt` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/tool-attributes-misplaced-1.rs:8:3\n-   |\n-LL | #[rustfmt]\n-   |   ^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n-   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n-\n error: cannot find derive macro `rustfmt` in this scope\n   --> $DIR/tool-attributes-misplaced-1.rs:4:10\n    |\n LL | #[derive(rustfmt)]\n    |          ^^^^^^^\n \n+error: cannot find attribute macro `rustfmt` in this scope\n+  --> $DIR/tool-attributes-misplaced-1.rs:8:3\n+   |\n+LL | #[rustfmt]\n+   |   ^^^^^^^\n+\n error: cannot find macro `rustfmt!` in this scope\n   --> $DIR/tool-attributes-misplaced-1.rs:14:5\n    |\n@@ -45,5 +42,4 @@ LL |     rustfmt::skip;\n \n error: aborting due to 7 previous errors\n \n-Some errors have detailed explanations: E0423, E0658.\n-For more information about an error, try `rustc --explain E0423`.\n+For more information about this error, try `rustc --explain E0423`."}]}