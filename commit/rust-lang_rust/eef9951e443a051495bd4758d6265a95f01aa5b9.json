{"sha": "eef9951e443a051495bd4758d6265a95f01aa5b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlZjk5NTFlNDQzYTA1MTQ5NWJkNDc1OGQ2MjY1YTk1ZjAxYWE1Yjk=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-11-08T12:36:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-08T12:36:07Z"}, "message": "Rollup merge of #78572 - de-vri-es:bsd-cloexec, r=m-ou-se\n\nUse SOCK_CLOEXEC and accept4() on more platforms.\n\nThis PR enables the use of `SOCK_CLOEXEC` and `accept4` on more platforms.\n\n-----\n\nAndroid uses the linux kernel, so it should also support it.\n\nDragonflyBSD introduced them in 4.4 (December 2015):\nhttps://www.dragonflybsd.org/release44/\n\nFreeBSD introduced them in 10.0 (January 2014):\nhttps://wiki.freebsd.org/AtomicCloseOnExec\n\nIllumos introduced them in a commit in April 2013, not sure when it was released. It is quite possible that is has always been in Illumos:\nhttps://github.com/illumos/illumos-gate/commit/5dbfd19ad5fcc2b779f40f80fa05c1bd28fd0b4e\nhttps://illumos.org/man/3socket/socket\nhttps://illumos.org/man/3socket/accept4\n\nNetBSD introduced them in 6.0 (Oktober 2012) and 8.0 (July 2018):\nhttps://man.netbsd.org/NetBSD-6.0/socket.2\nhttps://man.netbsd.org/NetBSD-8.0/accept.2\n\nOpenBSD introduced them in 5.7 (May 2015):\nhttps://man.openbsd.org/socket https://man.openbsd.org/accept", "tree": {"sha": "14cb2cf466216b7f6910bcada1d5ad4cb630d51a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14cb2cf466216b7f6910bcada1d5ad4cb630d51a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eef9951e443a051495bd4758d6265a95f01aa5b9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfp+Y3CRBK7hj4Ov3rIwAAdHIIAFOKHCYQbtnHge7vrYoUX/g3\nkTkbPVbtRKUYkWZJOysRAERCVqzcD9VW6jOW+8THENrrRN0uJZam/vMLbZf02NUm\nl25OhL/OySBdLk1HCs8iXGM/jyrMSQLXM7PdCRQwbkcjHXecI9mJc2gKF74w1Whm\nW3RAu8eU2hEpnn6tMsEP1pUvyR6BonbbHH2g/U+gVRwuamBPa07fEjYZLbfUYgOI\nGVVLAQ7H8Wv1xHRws3sXj9inigy8Mu20vausWUaeeRTf3HVSt5Ffofy+CikU7d3A\nJ57amAPr0kyb90n0oxwNq3N8Jmvw4WajQhrBu8RaVQKlxxl1H74J010xGTGCc+w=\n=Kj4X\n-----END PGP SIGNATURE-----\n", "payload": "tree 14cb2cf466216b7f6910bcada1d5ad4cb630d51a\nparent 834d761df2603cc1af229ebc13d751ffacc43206\nparent 3bee37c290fdd362fd4fd393606cc53acf1e7375\nauthor Mara Bos <m-ou.se@m-ou.se> 1604838967 +0100\ncommitter GitHub <noreply@github.com> 1604838967 +0100\n\nRollup merge of #78572 - de-vri-es:bsd-cloexec, r=m-ou-se\n\nUse SOCK_CLOEXEC and accept4() on more platforms.\n\nThis PR enables the use of `SOCK_CLOEXEC` and `accept4` on more platforms.\n\n-----\n\nAndroid uses the linux kernel, so it should also support it.\n\nDragonflyBSD introduced them in 4.4 (December 2015):\nhttps://www.dragonflybsd.org/release44/\n\nFreeBSD introduced them in 10.0 (January 2014):\nhttps://wiki.freebsd.org/AtomicCloseOnExec\n\nIllumos introduced them in a commit in April 2013, not sure when it was released. It is quite possible that is has always been in Illumos:\nhttps://github.com/illumos/illumos-gate/commit/5dbfd19ad5fcc2b779f40f80fa05c1bd28fd0b4e\nhttps://illumos.org/man/3socket/socket\nhttps://illumos.org/man/3socket/accept4\n\nNetBSD introduced them in 6.0 (Oktober 2012) and 8.0 (July 2018):\nhttps://man.netbsd.org/NetBSD-6.0/socket.2\nhttps://man.netbsd.org/NetBSD-8.0/accept.2\n\nOpenBSD introduced them in 5.7 (May 2015):\nhttps://man.openbsd.org/socket https://man.openbsd.org/accept\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eef9951e443a051495bd4758d6265a95f01aa5b9", "html_url": "https://github.com/rust-lang/rust/commit/eef9951e443a051495bd4758d6265a95f01aa5b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eef9951e443a051495bd4758d6265a95f01aa5b9/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "834d761df2603cc1af229ebc13d751ffacc43206", "url": "https://api.github.com/repos/rust-lang/rust/commits/834d761df2603cc1af229ebc13d751ffacc43206", "html_url": "https://github.com/rust-lang/rust/commit/834d761df2603cc1af229ebc13d751ffacc43206"}, {"sha": "3bee37c290fdd362fd4fd393606cc53acf1e7375", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bee37c290fdd362fd4fd393606cc53acf1e7375", "html_url": "https://github.com/rust-lang/rust/commit/3bee37c290fdd362fd4fd393606cc53acf1e7375"}], "stats": {"total": 44, "additions": 38, "deletions": 6}, "files": [{"sha": "378d690f8bfd7d5cfa42a5550a6f182ae85cfed6", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/eef9951e443a051495bd4758d6265a95f01aa5b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eef9951e443a051495bd4758d6265a95f01aa5b9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=eef9951e443a051495bd4758d6265a95f01aa5b9", "patch": "@@ -55,9 +55,18 @@ impl Socket {\n     pub fn new_raw(fam: c_int, ty: c_int) -> io::Result<Socket> {\n         unsafe {\n             cfg_if::cfg_if! {\n-                if #[cfg(target_os = \"linux\")] {\n-                    // On Linux we pass the SOCK_CLOEXEC flag to atomically create\n-                    // the socket and set it as CLOEXEC, added in 2.6.27.\n+                if #[cfg(any(\n+                    target_os = \"android\",\n+                    target_os = \"dragonfly\",\n+                    target_os = \"freebsd\",\n+                    target_os = \"illumos\",\n+                    target_os = \"linux\",\n+                    target_os = \"netbsd\",\n+                    target_os = \"opensbd\",\n+                ))] {\n+                    // On platforms that support it we pass the SOCK_CLOEXEC\n+                    // flag to atomically create the socket and set it as\n+                    // CLOEXEC. On Linux this was added in 2.6.27.\n                     let fd = cvt(libc::socket(fam, ty | libc::SOCK_CLOEXEC, 0))?;\n                     Ok(Socket(FileDesc::new(fd)))\n                 } else {\n@@ -83,7 +92,15 @@ impl Socket {\n             let mut fds = [0, 0];\n \n             cfg_if::cfg_if! {\n-                if #[cfg(target_os = \"linux\")] {\n+                if #[cfg(any(\n+                    target_os = \"android\",\n+                    target_os = \"dragonfly\",\n+                    target_os = \"freebsd\",\n+                    target_os = \"illumos\",\n+                    target_os = \"linux\",\n+                    target_os = \"netbsd\",\n+                    target_os = \"opensbd\",\n+                ))] {\n                     // Like above, set cloexec atomically\n                     cvt(libc::socketpair(fam, ty | libc::SOCK_CLOEXEC, 0, fds.as_mut_ptr()))?;\n                     Ok((Socket(FileDesc::new(fds[0])), Socket(FileDesc::new(fds[1]))))\n@@ -174,13 +191,28 @@ impl Socket {\n     pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t) -> io::Result<Socket> {\n         // Unfortunately the only known way right now to accept a socket and\n         // atomically set the CLOEXEC flag is to use the `accept4` syscall on\n-        // Linux. This was added in 2.6.28, glibc 2.10 and musl 0.9.5.\n+        // platforms that support it. On Linux, this was added in 2.6.28,\n+        // glibc 2.10 and musl 0.9.5.\n         cfg_if::cfg_if! {\n-            if #[cfg(target_os = \"linux\")] {\n+            if #[cfg(any(\n+                target_os = \"dragonfly\",\n+                target_os = \"freebsd\",\n+                target_os = \"illumos\",\n+                target_os = \"linux\",\n+                target_os = \"netbsd\",\n+                target_os = \"opensbd\",\n+            ))] {\n                 let fd = cvt_r(|| unsafe {\n                     libc::accept4(self.0.raw(), storage, len, libc::SOCK_CLOEXEC)\n                 })?;\n                 Ok(Socket(FileDesc::new(fd)))\n+            // While the Android kernel supports the syscall,\n+            // it is not included in all versions of Android's libc.\n+            } else if #[cfg(target_os = \"android\")] {\n+                let fd = cvt_r(|| unsafe {\n+                    libc::syscall(libc::SYS_accept4, self.0.raw(), storage, len, libc::SOCK_CLOEXEC)\n+                })?;\n+                Ok(Socket(FileDesc::new(fd as c_int)))\n             } else {\n                 let fd = cvt_r(|| unsafe { libc::accept(self.0.raw(), storage, len) })?;\n                 let fd = FileDesc::new(fd);"}]}