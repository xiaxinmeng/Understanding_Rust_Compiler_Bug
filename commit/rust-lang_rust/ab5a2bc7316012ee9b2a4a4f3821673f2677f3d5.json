{"sha": "ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "node_id": "C_kwDOAAsO6NoAKGFiNWEyYmM3MzE2MDEyZWU5YjJhNGE0ZjM4MjE2NzNmMjY3N2YzZDU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-01T18:15:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-01T18:15:32Z"}, "message": "Auto merge of #103841 - Dylan-DPC:rollup-rff2x1l, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #84022 (Make PROC_MACRO_DERIVE_RESOLUTION_FALLBACK a hard error)\n - #103760 (resolve: Turn the binding from `#[macro_export]` into a proper `Import`)\n - #103813 (rustdoc: remove unnecessary CSS `.search-results { clear: both }`)\n - #103817 (rustdoc: rename syntax highlighting CSS class `attribute` to `attr`)\n - #103833 (:arrow_up: rust-analyzer)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "b15708db58cf3fc25cfedc33e41320a8728c52bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b15708db58cf3fc25cfedc33e41320a8728c52bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "html_url": "https://github.com/rust-lang/rust/commit/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c736a21ae317086871094b1671d6535be593502", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c736a21ae317086871094b1671d6535be593502", "html_url": "https://github.com/rust-lang/rust/commit/4c736a21ae317086871094b1671d6535be593502"}, {"sha": "2b10891b969dea3875cd42a5b63d198abd47fcbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b10891b969dea3875cd42a5b63d198abd47fcbc", "html_url": "https://github.com/rust-lang/rust/commit/2b10891b969dea3875cd42a5b63d198abd47fcbc"}], "stats": {"total": 1950, "additions": 1126, "deletions": 824}, "files": [{"sha": "389f3ccf72acf3ea1b8d22dd16e41290890045b7", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -1982,73 +1982,6 @@ declare_lint! {\n     };\n }\n \n-declare_lint! {\n-    /// The `proc_macro_derive_resolution_fallback` lint detects proc macro\n-    /// derives using inaccessible names from parent modules.\n-    ///\n-    /// ### Example\n-    ///\n-    /// ```rust,ignore (proc-macro)\n-    /// // foo.rs\n-    /// #![crate_type = \"proc-macro\"]\n-    ///\n-    /// extern crate proc_macro;\n-    ///\n-    /// use proc_macro::*;\n-    ///\n-    /// #[proc_macro_derive(Foo)]\n-    /// pub fn foo1(a: TokenStream) -> TokenStream {\n-    ///     drop(a);\n-    ///     \"mod __bar { static mut BAR: Option<Something> = None; }\".parse().unwrap()\n-    /// }\n-    /// ```\n-    ///\n-    /// ```rust,ignore (needs-dependency)\n-    /// // bar.rs\n-    /// #[macro_use]\n-    /// extern crate foo;\n-    ///\n-    /// struct Something;\n-    ///\n-    /// #[derive(Foo)]\n-    /// struct Another;\n-    ///\n-    /// fn main() {}\n-    /// ```\n-    ///\n-    /// This will produce:\n-    ///\n-    /// ```text\n-    /// warning: cannot find type `Something` in this scope\n-    ///  --> src/main.rs:8:10\n-    ///   |\n-    /// 8 | #[derive(Foo)]\n-    ///   |          ^^^ names from parent modules are not accessible without an explicit import\n-    ///   |\n-    ///   = note: `#[warn(proc_macro_derive_resolution_fallback)]` on by default\n-    ///   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-    ///   = note: for more information, see issue #50504 <https://github.com/rust-lang/rust/issues/50504>\n-    /// ```\n-    ///\n-    /// ### Explanation\n-    ///\n-    /// If a proc-macro generates a module, the compiler unintentionally\n-    /// allowed items in that module to refer to items in the crate root\n-    /// without importing them. This is a [future-incompatible] lint to\n-    /// transition this to a hard error in the future. See [issue #50504] for\n-    /// more details.\n-    ///\n-    /// [issue #50504]: https://github.com/rust-lang/rust/issues/50504\n-    /// [future-incompatible]: ../index.md#future-incompatible-lints\n-    pub PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n-    Deny,\n-    \"detects proc macro derives using inaccessible names from parent modules\",\n-    @future_incompatible = FutureIncompatibleInfo {\n-        reference: \"issue #83583 <https://github.com/rust-lang/rust/issues/83583>\",\n-        reason: FutureIncompatibilityReason::FutureReleaseErrorReportNow,\n-    };\n-}\n-\n declare_lint! {\n     /// The `macro_use_extern_crate` lint detects the use of the\n     /// [`macro_use` attribute].\n@@ -3287,7 +3220,6 @@ declare_lint_pass! {\n         UNSTABLE_NAME_COLLISIONS,\n         IRREFUTABLE_LET_PATTERNS,\n         WHERE_CLAUSES_OBJECT_SAFETY,\n-        PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n         MACRO_USE_EXTERN_CRATE,\n         MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n         ILL_FORMED_ATTRIBUTE_INPUT,"}, {"sha": "423c57275333a2c355020942ecfb383816b8f24b", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 22, "deletions": 33, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -56,21 +56,7 @@ impl<'a, Id: Into<DefId>> ToNameBinding<'a>\n impl<'a, Id: Into<DefId>> ToNameBinding<'a> for (Res, ty::Visibility<Id>, Span, LocalExpnId) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Res(self.0, false),\n-            ambiguity: None,\n-            vis: self.1.to_def_id(),\n-            span: self.2,\n-            expansion: self.3,\n-        })\n-    }\n-}\n-\n-struct IsMacroExport;\n-\n-impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, LocalExpnId, IsMacroExport) {\n-    fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n-        arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Res(self.0, true),\n+            kind: NameBindingKind::Res(self.0),\n             ambiguity: None,\n             vis: self.1.to_def_id(),\n             span: self.2,\n@@ -364,7 +350,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         module_path: Vec<Segment>,\n         kind: ImportKind<'a>,\n         span: Span,\n-        id: NodeId,\n         item: &ast::Item,\n         root_span: Span,\n         root_id: NodeId,\n@@ -377,7 +362,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             module_path,\n             imported_module: Cell::new(None),\n             span,\n-            id,\n             use_span: item.span,\n             use_span_with_attributes: item.span_with_attributes(),\n             has_attributes: !item.attrs.is_empty(),\n@@ -574,27 +558,20 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     },\n                     type_ns_only,\n                     nested,\n+                    id,\n                     additional_ids: (id1, id2),\n                 };\n \n-                self.add_import(\n-                    module_path,\n-                    kind,\n-                    use_tree.span,\n-                    id,\n-                    item,\n-                    root_span,\n-                    item.id,\n-                    vis,\n-                );\n+                self.add_import(module_path, kind, use_tree.span, item, root_span, item.id, vis);\n             }\n             ast::UseTreeKind::Glob => {\n                 let kind = ImportKind::Glob {\n                     is_prelude: self.r.session.contains_name(&item.attrs, sym::prelude_import),\n                     max_vis: Cell::new(None),\n+                    id,\n                 };\n                 self.r.visibilities.insert(self.r.local_def_id(id), vis);\n-                self.add_import(prefix, kind, use_tree.span, id, item, root_span, item.id, vis);\n+                self.add_import(prefix, kind, use_tree.span, item, root_span, item.id, vis);\n             }\n             ast::UseTreeKind::Nested(ref items) => {\n                 // Ensure there is at most one `self` in the list\n@@ -881,9 +858,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         })\n         .unwrap_or((true, None, self.r.dummy_binding));\n         let import = self.r.arenas.alloc_import(Import {\n-            kind: ImportKind::ExternCrate { source: orig_name, target: ident },\n+            kind: ImportKind::ExternCrate { source: orig_name, target: ident, id: item.id },\n             root_id: item.id,\n-            id: item.id,\n             parent_scope: self.parent_scope,\n             imported_module: Cell::new(module),\n             has_attributes: !item.attrs.is_empty(),\n@@ -1118,7 +1094,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             this.r.arenas.alloc_import(Import {\n                 kind: ImportKind::MacroUse,\n                 root_id: item.id,\n-                id: item.id,\n                 parent_scope: this.parent_scope,\n                 imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n                 use_span_with_attributes: item.span_with_attributes(),\n@@ -1278,8 +1253,22 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             let binding = (res, vis, span, expansion).to_name_binding(self.r.arenas);\n             self.r.set_binding_parent_module(binding, parent_scope.module);\n             if is_macro_export {\n-                let module = self.r.graph_root;\n-                self.r.define(module, ident, MacroNS, (res, vis, span, expansion, IsMacroExport));\n+                let import = self.r.arenas.alloc_import(Import {\n+                    kind: ImportKind::MacroExport,\n+                    root_id: item.id,\n+                    parent_scope: self.parent_scope,\n+                    imported_module: Cell::new(None),\n+                    has_attributes: false,\n+                    use_span_with_attributes: span,\n+                    use_span: span,\n+                    root_span: span,\n+                    span: span,\n+                    module_path: Vec::new(),\n+                    vis: Cell::new(Some(vis)),\n+                    used: Cell::new(true),\n+                });\n+                let import_binding = self.r.import(binding, import);\n+                self.r.define(self.r.graph_root, ident, MacroNS, import_binding);\n             } else {\n                 self.r.check_reserved_macro_name(ident, res);\n                 self.insert_unused_macro(ident, def_id, item.id, &rule_spans);"}, {"sha": "32fb5e18276ab86fe721f533c56d88871cb2e44c", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -234,7 +234,7 @@ impl Resolver<'_> {\n                         if !import.span.is_dummy() {\n                             self.lint_buffer.buffer_lint(\n                                 MACRO_USE_EXTERN_CRATE,\n-                                import.id,\n+                                import.root_id,\n                                 import.span,\n                                 \"deprecated `#[macro_use]` attribute used to \\\n                                 import macros should be replaced at use sites \\\n@@ -244,13 +244,13 @@ impl Resolver<'_> {\n                         }\n                     }\n                 }\n-                ImportKind::ExternCrate { .. } => {\n-                    let def_id = self.local_def_id(import.id);\n+                ImportKind::ExternCrate { id, .. } => {\n+                    let def_id = self.local_def_id(id);\n                     self.maybe_unused_extern_crates.push((def_id, import.span));\n                 }\n                 ImportKind::MacroUse => {\n                     let msg = \"unused `#[macro_use]` import\";\n-                    self.lint_buffer.buffer_lint(UNUSED_IMPORTS, import.id, import.span, msg);\n+                    self.lint_buffer.buffer_lint(UNUSED_IMPORTS, import.root_id, import.span, msg);\n                 }\n                 _ => {}\n             }"}, {"sha": "7961e3f1194e1ab7743fc31d70ddec84dc2f36e3", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -190,12 +190,12 @@ impl<'a> Resolver<'a> {\n             ModuleKind::Block => \"block\",\n         };\n \n-        let old_noun = match old_binding.is_import() {\n+        let old_noun = match old_binding.is_import_user_facing() {\n             true => \"import\",\n             false => \"definition\",\n         };\n \n-        let new_participle = match new_binding.is_import() {\n+        let new_participle = match new_binding.is_import_user_facing() {\n             true => \"imported\",\n             false => \"defined\",\n         };\n@@ -226,7 +226,7 @@ impl<'a> Resolver<'a> {\n                 true => struct_span_err!(self.session, span, E0254, \"{}\", msg),\n                 false => struct_span_err!(self.session, span, E0260, \"{}\", msg),\n             },\n-            _ => match (old_binding.is_import(), new_binding.is_import()) {\n+            _ => match (old_binding.is_import_user_facing(), new_binding.is_import_user_facing()) {\n                 (false, false) => struct_span_err!(self.session, span, E0428, \"{}\", msg),\n                 (true, true) => struct_span_err!(self.session, span, E0252, \"{}\", msg),\n                 _ => struct_span_err!(self.session, span, E0255, \"{}\", msg),\n@@ -248,14 +248,18 @@ impl<'a> Resolver<'a> {\n \n         // See https://github.com/rust-lang/rust/issues/32354\n         use NameBindingKind::Import;\n+        let can_suggest = |binding: &NameBinding<'_>, import: &self::Import<'_>| {\n+            !binding.span.is_dummy()\n+                && !matches!(import.kind, ImportKind::MacroUse | ImportKind::MacroExport)\n+        };\n         let import = match (&new_binding.kind, &old_binding.kind) {\n             // If there are two imports where one or both have attributes then prefer removing the\n             // import without attributes.\n             (Import { import: new, .. }, Import { import: old, .. })\n                 if {\n-                    !new_binding.span.is_dummy()\n-                        && !old_binding.span.is_dummy()\n-                        && (new.has_attributes || old.has_attributes)\n+                    (new.has_attributes || old.has_attributes)\n+                        && can_suggest(old_binding, old)\n+                        && can_suggest(new_binding, new)\n                 } =>\n             {\n                 if old.has_attributes {\n@@ -265,10 +269,10 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             // Otherwise prioritize the new binding.\n-            (Import { import, .. }, other) if !new_binding.span.is_dummy() => {\n+            (Import { import, .. }, other) if can_suggest(new_binding, import) => {\n                 Some((import, new_binding.span, other.is_import()))\n             }\n-            (other, Import { import, .. }) if !old_binding.span.is_dummy() => {\n+            (other, Import { import, .. }) if can_suggest(old_binding, import) => {\n                 Some((import, old_binding.span, other.is_import()))\n             }\n             _ => None,\n@@ -353,7 +357,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n             }\n-            ImportKind::ExternCrate { source, target } => {\n+            ImportKind::ExternCrate { source, target, .. } => {\n                 suggestion = Some(format!(\n                     \"extern crate {} as {};\",\n                     source.unwrap_or(target.name),\n@@ -1202,7 +1206,7 @@ impl<'a> Resolver<'a> {\n                     let root_module = this.resolve_crate_root(root_ident);\n                     this.add_module_candidates(root_module, &mut suggestions, filter_fn, None);\n                 }\n-                Scope::Module(module, _) => {\n+                Scope::Module(module) => {\n                     this.add_module_candidates(module, &mut suggestions, filter_fn, None);\n                 }\n                 Scope::MacroUsePrelude => {\n@@ -1683,7 +1687,7 @@ impl<'a> Resolver<'a> {\n             let a = if built_in.is_empty() { res.article() } else { \"a\" };\n             format!(\"{a}{built_in} {thing}{from}\", thing = res.descr())\n         } else {\n-            let introduced = if b.is_import() { \"imported\" } else { \"defined\" };\n+            let introduced = if b.is_import_user_facing() { \"imported\" } else { \"defined\" };\n             format!(\"the {thing} {introduced} here\", thing = res.descr())\n         }\n     }\n@@ -1742,10 +1746,10 @@ impl<'a> Resolver<'a> {\n     /// If the binding refers to a tuple struct constructor with fields,\n     /// returns the span of its fields.\n     fn ctor_fields_span(&self, binding: &NameBinding<'_>) -> Option<Span> {\n-        if let NameBindingKind::Res(\n-            Res::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fn), ctor_def_id),\n-            _,\n-        ) = binding.kind\n+        if let NameBindingKind::Res(Res::Def(\n+            DefKind::Ctor(CtorOf::Struct, CtorKind::Fn),\n+            ctor_def_id,\n+        )) = binding.kind\n         {\n             let def_id = self.parent(ctor_def_id);\n             let fields = self.field_names.get(&def_id)?;\n@@ -1789,7 +1793,9 @@ impl<'a> Resolver<'a> {\n                         next_ident = source;\n                         Some(binding)\n                     }\n-                    ImportKind::Glob { .. } | ImportKind::MacroUse => Some(binding),\n+                    ImportKind::Glob { .. } | ImportKind::MacroUse | ImportKind::MacroExport => {\n+                        Some(binding)\n+                    }\n                     ImportKind::ExternCrate { .. } => None,\n                 },\n                 _ => None,"}, {"sha": "17ce854cb4388fa88a41aa87a9b8027730a98eee", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -57,26 +57,45 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n                     while let NameBindingKind::Import { binding: nested_binding, import, .. } =\n                         binding.kind\n                     {\n-                        let mut update = |node_id| self.update(\n-                            self.r.local_def_id(node_id),\n-                            binding.vis.expect_local(),\n-                            prev_parent_id,\n-                            level,\n-                        );\n-                        // In theory all the import IDs have individual visibilities and effective\n-                        // visibilities, but in practice these IDs go straigth to HIR where all\n-                        // their few uses assume that their (effective) visibility applies to the\n-                        // whole syntactic `use` item. So we update them all to the maximum value\n-                        // among the potential individual effective visibilities. Maybe HIR for\n-                        // imports shouldn't use three IDs at all.\n-                        update(import.id);\n-                        if let ImportKind::Single { additional_ids, .. } = import.kind {\n-                            update(additional_ids.0);\n-                            update(additional_ids.1);\n+                        let mut update = |node_id| {\n+                            self.update(\n+                                self.r.local_def_id(node_id),\n+                                binding.vis.expect_local(),\n+                                prev_parent_id,\n+                                level,\n+                            )\n+                        };\n+                        match import.kind {\n+                            ImportKind::Single { id, additional_ids, .. } => {\n+                                // In theory all the import IDs have individual visibilities and\n+                                // effective visibilities, but in practice these IDs go straigth to\n+                                // HIR where all their few uses assume that their (effective)\n+                                // visibility applies to the whole syntactic `use` item. So we\n+                                // update them all to the maximum value among the potential\n+                                // individual effective visibilities. Maybe HIR for imports\n+                                // shouldn't use three IDs at all.\n+                                update(id);\n+                                update(additional_ids.0);\n+                                update(additional_ids.1);\n+                                prev_parent_id = self.r.local_def_id(id);\n+                            }\n+                            ImportKind::Glob { id, .. } | ImportKind::ExternCrate { id, .. } => {\n+                                update(id);\n+                                prev_parent_id = self.r.local_def_id(id);\n+                            }\n+                            ImportKind::MacroUse => {\n+                                // In theory we should reset the parent id to something private\n+                                // here, but `macro_use` imports always refer to external items,\n+                                // so it doesn't matter and we can just do nothing.\n+                            }\n+                            ImportKind::MacroExport => {\n+                                // In theory we should reset the parent id to something public\n+                                // here, but it has the same effect as leaving the previous parent,\n+                                // so we can just do nothing.\n+                            }\n                         }\n \n                         level = Level::Reexported;\n-                        prev_parent_id = self.r.local_def_id(import.id);\n                         binding = nested_binding;\n                     }\n                 }\n@@ -138,13 +157,6 @@ impl<'r, 'ast> Visitor<'ast> for EffectiveVisibilitiesVisitor<'ast, 'r> {\n                 self.update(def_id, Visibility::Public, parent_id, Level::Direct);\n             }\n \n-            // Only exported `macro_rules!` items are public, but they always are\n-            ast::ItemKind::MacroDef(ref macro_def) if macro_def.macro_rules => {\n-                let parent_id = self.r.local_parent(def_id);\n-                let vis = self.r.visibilities[&def_id];\n-                self.update(def_id, vis, parent_id, Level::Direct);\n-            }\n-\n             ast::ItemKind::Mod(..) => {\n                 self.set_bindings_effective_visibilities(def_id);\n                 visit::walk_item(self, item);"}, {"sha": "0c4b35b88335ad5e429b68d74e14db5555fb3451", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 16, "deletions": 67, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -1,11 +1,9 @@\n-use rustc_ast::{self as ast, NodeId};\n+use rustc_ast as ast;\n use rustc_feature::is_builtin_attr_name;\n use rustc_hir::def::{DefKind, Namespace, NonMacroAttrKind, PartialRes, PerNS};\n use rustc_hir::PrimTy;\n use rustc_middle::bug;\n use rustc_middle::ty;\n-use rustc_session::lint::builtin::PROC_MACRO_DERIVE_RESOLUTION_FALLBACK;\n-use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::def_id::LocalDefId;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::{ExpnId, ExpnKind, LocalExpnId, MacroKind, SyntaxContext};\n@@ -19,7 +17,7 @@ use crate::late::{\n };\n use crate::macros::{sub_namespace_match, MacroRulesScope};\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, Determinacy, Finalize};\n-use crate::{ImportKind, LexicalScopeBinding, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{Import, ImportKind, LexicalScopeBinding, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{NameBinding, NameBindingKind, ParentScope, PathResult, PrivacyError, Res};\n use crate::{ResolutionError, Resolver, Scope, ScopeSet, Segment, ToNameBinding, Weak};\n \n@@ -101,7 +99,7 @@ impl<'a> Resolver<'a> {\n         };\n         let mut scope = match ns {\n             _ if is_absolute_path => Scope::CrateRoot,\n-            TypeNS | ValueNS => Scope::Module(module, None),\n+            TypeNS | ValueNS => Scope::Module(module),\n             MacroNS => Scope::DeriveHelpers(parent_scope.expansion),\n         };\n         let mut ctxt = ctxt.normalize_to_macros_2_0();\n@@ -165,7 +163,7 @@ impl<'a> Resolver<'a> {\n                     MacroRulesScope::Invocation(invoc_id) => {\n                         Scope::MacroRules(self.invocation_parent_scopes[&invoc_id].macro_rules)\n                     }\n-                    MacroRulesScope::Empty => Scope::Module(module, None),\n+                    MacroRulesScope::Empty => Scope::Module(module),\n                 },\n                 Scope::CrateRoot => match ns {\n                     TypeNS => {\n@@ -174,16 +172,10 @@ impl<'a> Resolver<'a> {\n                     }\n                     ValueNS | MacroNS => break,\n                 },\n-                Scope::Module(module, prev_lint_id) => {\n+                Scope::Module(module) => {\n                     use_prelude = !module.no_implicit_prelude;\n-                    let derive_fallback_lint_id = match scope_set {\n-                        ScopeSet::Late(.., lint_id) => lint_id,\n-                        _ => None,\n-                    };\n-                    match self.hygienic_lexical_parent(module, &mut ctxt, derive_fallback_lint_id) {\n-                        Some((parent_module, lint_id)) => {\n-                            Scope::Module(parent_module, lint_id.or(prev_lint_id))\n-                        }\n+                    match self.hygienic_lexical_parent(module, &mut ctxt) {\n+                        Some(parent_module) => Scope::Module(parent_module),\n                         None => {\n                             ctxt.adjust(ExpnId::root());\n                             match ns {\n@@ -215,45 +207,13 @@ impl<'a> Resolver<'a> {\n         &mut self,\n         module: Module<'a>,\n         ctxt: &mut SyntaxContext,\n-        derive_fallback_lint_id: Option<NodeId>,\n-    ) -> Option<(Module<'a>, Option<NodeId>)> {\n+    ) -> Option<Module<'a>> {\n         if !module.expansion.outer_expn_is_descendant_of(*ctxt) {\n-            return Some((self.expn_def_scope(ctxt.remove_mark()), None));\n+            return Some(self.expn_def_scope(ctxt.remove_mark()));\n         }\n \n         if let ModuleKind::Block = module.kind {\n-            return Some((module.parent.unwrap().nearest_item_scope(), None));\n-        }\n-\n-        // We need to support the next case under a deprecation warning\n-        // ```\n-        // struct MyStruct;\n-        // ---- begin: this comes from a proc macro derive\n-        // mod implementation_details {\n-        //     // Note that `MyStruct` is not in scope here.\n-        //     impl SomeTrait for MyStruct { ... }\n-        // }\n-        // ---- end\n-        // ```\n-        // So we have to fall back to the module's parent during lexical resolution in this case.\n-        if derive_fallback_lint_id.is_some() {\n-            if let Some(parent) = module.parent {\n-                // Inner module is inside the macro, parent module is outside of the macro.\n-                if module.expansion != parent.expansion\n-                    && module.expansion.is_descendant_of(parent.expansion)\n-                {\n-                    // The macro is a proc macro derive\n-                    if let Some(def_id) = module.expansion.expn_data().macro_def_id {\n-                        let ext = self.get_macro_by_def_id(def_id).ext;\n-                        if ext.builtin_name.is_none()\n-                            && ext.macro_kind() == MacroKind::Derive\n-                            && parent.expansion.outer_expn_is_descendant_of(*ctxt)\n-                        {\n-                            return Some((parent, derive_fallback_lint_id));\n-                        }\n-                    }\n-                }\n-            }\n+            return Some(module.parent.unwrap().nearest_item_scope());\n         }\n \n         None\n@@ -510,7 +470,7 @@ impl<'a> Resolver<'a> {\n                             Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n                         }\n                     }\n-                    Scope::Module(module, derive_fallback_lint_id) => {\n+                    Scope::Module(module) => {\n                         let adjusted_parent_scope = &ParentScope { module, ..*parent_scope };\n                         let binding = this.resolve_ident_in_module_unadjusted_ext(\n                             ModuleOrUniformRoot::Module(module),\n@@ -523,21 +483,6 @@ impl<'a> Resolver<'a> {\n                         );\n                         match binding {\n                             Ok(binding) => {\n-                                if let Some(lint_id) = derive_fallback_lint_id {\n-                                    this.lint_buffer.buffer_lint_with_diagnostic(\n-                                        PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n-                                        lint_id,\n-                                        orig_ident.span,\n-                                        &format!(\n-                                            \"cannot find {} `{}` in this scope\",\n-                                            ns.descr(),\n-                                            ident\n-                                        ),\n-                                        BuiltinLintDiagnostics::ProcMacroDeriveResolutionFallback(\n-                                            orig_ident.span,\n-                                        ),\n-                                    );\n-                                }\n                                 let misc_flags = if ptr::eq(module, this.graph_root) {\n                                     Flags::MISC_SUGGEST_CRATE\n                                 } else if module.is_normal() {\n@@ -915,7 +860,11 @@ impl<'a> Resolver<'a> {\n             }\n \n             if !restricted_shadowing && binding.expansion != LocalExpnId::ROOT {\n-                if let NameBindingKind::Res(_, true) = binding.kind {\n+                if let NameBindingKind::Import {\n+                    import: Import { kind: ImportKind::MacroExport, .. },\n+                    ..\n+                } = binding.kind\n+                {\n                     self.macro_expanded_macro_export_errors.insert((path_span, binding.span));\n                 }\n             }"}, {"sha": "bdb852548b84e43e652ba5764297173c20d181e8", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 96, "deletions": 62, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -44,20 +44,36 @@ pub enum ImportKind<'a> {\n         type_ns_only: bool,\n         /// Did this import result from a nested import? ie. `use foo::{bar, baz};`\n         nested: bool,\n+        /// The ID of the `UseTree` that imported this `Import`.\n+        ///\n+        /// In the case where the `Import` was expanded from a \"nested\" use tree,\n+        /// this id is the ID of the leaf tree. For example:\n+        ///\n+        /// ```ignore (pacify the merciless tidy)\n+        /// use foo::bar::{a, b}\n+        /// ```\n+        ///\n+        /// If this is the import for `foo::bar::a`, we would have the ID of the `UseTree`\n+        /// for `a` in this field.\n+        id: NodeId,\n         /// Additional `NodeId`s allocated to a `ast::UseTree` for automatically generated `use` statement\n         /// (eg. implicit struct constructors)\n         additional_ids: (NodeId, NodeId),\n     },\n     Glob {\n         is_prelude: bool,\n-        max_vis: Cell<Option<ty::Visibility>>, // The visibility of the greatest re-export.\n-                                               // n.b. `max_vis` is only used in `finalize_import` to check for re-export errors.\n+        // The visibility of the greatest re-export.\n+        // n.b. `max_vis` is only used in `finalize_import` to check for re-export errors.\n+        max_vis: Cell<Option<ty::Visibility>>,\n+        id: NodeId,\n     },\n     ExternCrate {\n         source: Option<Symbol>,\n         target: Ident,\n+        id: NodeId,\n     },\n     MacroUse,\n+    MacroExport,\n }\n \n /// Manually implement `Debug` for `ImportKind` because the `source/target_bindings`\n@@ -71,6 +87,7 @@ impl<'a> std::fmt::Debug for ImportKind<'a> {\n                 ref target,\n                 ref type_ns_only,\n                 ref nested,\n+                ref id,\n                 ref additional_ids,\n                 // Ignore the following to avoid an infinite loop while printing.\n                 source_bindings: _,\n@@ -81,19 +98,23 @@ impl<'a> std::fmt::Debug for ImportKind<'a> {\n                 .field(\"target\", target)\n                 .field(\"type_ns_only\", type_ns_only)\n                 .field(\"nested\", nested)\n+                .field(\"id\", id)\n                 .field(\"additional_ids\", additional_ids)\n                 .finish_non_exhaustive(),\n-            Glob { ref is_prelude, ref max_vis } => f\n+            Glob { ref is_prelude, ref max_vis, ref id } => f\n                 .debug_struct(\"Glob\")\n                 .field(\"is_prelude\", is_prelude)\n                 .field(\"max_vis\", max_vis)\n+                .field(\"id\", id)\n                 .finish(),\n-            ExternCrate { ref source, ref target } => f\n+            ExternCrate { ref source, ref target, ref id } => f\n                 .debug_struct(\"ExternCrate\")\n                 .field(\"source\", source)\n                 .field(\"target\", target)\n+                .field(\"id\", id)\n                 .finish(),\n             MacroUse => f.debug_struct(\"MacroUse\").finish(),\n+            MacroExport => f.debug_struct(\"MacroExport\").finish(),\n         }\n     }\n }\n@@ -103,24 +124,15 @@ impl<'a> std::fmt::Debug for ImportKind<'a> {\n pub(crate) struct Import<'a> {\n     pub kind: ImportKind<'a>,\n \n-    /// The ID of the `extern crate`, `UseTree` etc that imported this `Import`.\n-    ///\n-    /// In the case where the `Import` was expanded from a \"nested\" use tree,\n-    /// this id is the ID of the leaf tree. For example:\n-    ///\n-    /// ```ignore (pacify the merciless tidy)\n+    /// Node ID of the \"root\" use item -- this is always the same as `ImportKind`'s `id`\n+    /// (if it exists) except in the case of \"nested\" use trees, in which case\n+    /// it will be the ID of the root use tree. e.g., in the example\n+    /// ```ignore (incomplete code)\n     /// use foo::bar::{a, b}\n     /// ```\n-    ///\n-    /// If this is the import for `foo::bar::a`, we would have the ID of the `UseTree`\n-    /// for `a` in this field.\n-    pub id: NodeId,\n-\n-    /// The `id` of the \"root\" use-kind -- this is always the same as\n-    /// `id` except in the case of \"nested\" use trees, in which case\n-    /// it will be the `id` of the root use tree. e.g., in the example\n-    /// from `id`, this would be the ID of the `use foo::bar`\n-    /// `UseTree` node.\n+    /// this would be the ID of the `use foo::bar` `UseTree` node.\n+    /// In case of imports without their own node ID it's the closest node that can be used,\n+    /// for example, for reporting lints.\n     pub root_id: NodeId,\n \n     /// Span of the entire use statement.\n@@ -161,6 +173,15 @@ impl<'a> Import<'a> {\n     pub(crate) fn expect_vis(&self) -> ty::Visibility {\n         self.vis.get().expect(\"encountered cleared import visibility\")\n     }\n+\n+    pub(crate) fn id(&self) -> Option<NodeId> {\n+        match self.kind {\n+            ImportKind::Single { id, .. }\n+            | ImportKind::Glob { id, .. }\n+            | ImportKind::ExternCrate { id, .. } => Some(id),\n+            ImportKind::MacroUse | ImportKind::MacroExport => None,\n+        }\n+    }\n }\n \n /// Records information about the resolution of a name in a namespace of a module.\n@@ -368,7 +389,9 @@ impl<'a> Resolver<'a> {\n             self.record_use(target, dummy_binding, false);\n         } else if import.imported_module.get().is_none() {\n             import.used.set(true);\n-            self.used_imports.insert(import.id);\n+            if let Some(id) = import.id() {\n+                self.used_imports.insert(id);\n+            }\n         }\n     }\n }\n@@ -718,47 +741,51 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             PathResult::Indeterminate => unreachable!(),\n         };\n \n-        let (ident, target, source_bindings, target_bindings, type_ns_only) = match import.kind {\n-            ImportKind::Single {\n-                source,\n-                target,\n-                ref source_bindings,\n-                ref target_bindings,\n-                type_ns_only,\n-                ..\n-            } => (source, target, source_bindings, target_bindings, type_ns_only),\n-            ImportKind::Glob { is_prelude, ref max_vis } => {\n-                if import.module_path.len() <= 1 {\n-                    // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n-                    // 2 segments, so the `resolve_path` above won't trigger it.\n-                    let mut full_path = import.module_path.clone();\n-                    full_path.push(Segment::from_ident(Ident::empty()));\n-                    self.r.lint_if_path_starts_with_module(Some(finalize), &full_path, None);\n-                }\n+        let (ident, target, source_bindings, target_bindings, type_ns_only, import_id) =\n+            match import.kind {\n+                ImportKind::Single {\n+                    source,\n+                    target,\n+                    ref source_bindings,\n+                    ref target_bindings,\n+                    type_ns_only,\n+                    id,\n+                    ..\n+                } => (source, target, source_bindings, target_bindings, type_ns_only, id),\n+                ImportKind::Glob { is_prelude, ref max_vis, id } => {\n+                    if import.module_path.len() <= 1 {\n+                        // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n+                        // 2 segments, so the `resolve_path` above won't trigger it.\n+                        let mut full_path = import.module_path.clone();\n+                        full_path.push(Segment::from_ident(Ident::empty()));\n+                        self.r.lint_if_path_starts_with_module(Some(finalize), &full_path, None);\n+                    }\n \n-                if let ModuleOrUniformRoot::Module(module) = module {\n-                    if ptr::eq(module, import.parent_scope.module) {\n-                        // Importing a module into itself is not allowed.\n-                        return Some(UnresolvedImportError {\n-                            span: import.span,\n-                            label: Some(String::from(\"cannot glob-import a module into itself\")),\n-                            note: None,\n-                            suggestion: None,\n-                            candidate: None,\n-                        });\n+                    if let ModuleOrUniformRoot::Module(module) = module {\n+                        if ptr::eq(module, import.parent_scope.module) {\n+                            // Importing a module into itself is not allowed.\n+                            return Some(UnresolvedImportError {\n+                                span: import.span,\n+                                label: Some(String::from(\n+                                    \"cannot glob-import a module into itself\",\n+                                )),\n+                                note: None,\n+                                suggestion: None,\n+                                candidate: None,\n+                            });\n+                        }\n                     }\n-                }\n-                if !is_prelude\n+                    if !is_prelude\n                     && let Some(max_vis) = max_vis.get()\n                     && !max_vis.is_at_least(import.expect_vis(), &*self.r)\n                 {\n                     let msg = \"glob import doesn't reexport anything because no candidate is public enough\";\n-                    self.r.lint_buffer.buffer_lint(UNUSED_IMPORTS, import.id, import.span, msg);\n+                    self.r.lint_buffer.buffer_lint(UNUSED_IMPORTS, id, import.span, msg);\n                 }\n-                return None;\n-            }\n-            _ => unreachable!(),\n-        };\n+                    return None;\n+                }\n+                _ => unreachable!(),\n+            };\n \n         let mut all_ns_err = true;\n         self.r.per_ns(|this, ns| {\n@@ -858,7 +885,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                         match binding.kind {\n                                             // Never suggest the name that has binding error\n                                             // i.e., the name that cannot be previously resolved\n-                                            NameBindingKind::Res(Res::Err, _) => None,\n+                                            NameBindingKind::Res(Res::Err) => None,\n                                             _ => Some(i.name),\n                                         }\n                                     }\n@@ -960,7 +987,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 );\n                 self.r.lint_buffer.buffer_lint(\n                     PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n-                    import.id,\n+                    import_id,\n                     import.span,\n                     &msg,\n                 );\n@@ -989,7 +1016,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     let mut err =\n                         struct_span_err!(self.r.session, import.span, E0364, \"{error_msg}\");\n                     match binding.kind {\n-                        NameBindingKind::Res(Res::Def(DefKind::Macro(_), def_id), _)\n+                        NameBindingKind::Res(Res::Def(DefKind::Macro(_), def_id))\n                             // exclude decl_macro\n                             if self.r.get_macro_by_def_id(def_id).macro_rules =>\n                         {\n@@ -1029,7 +1056,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         // purposes it's good enough to just favor one over the other.\n         self.r.per_ns(|this, ns| {\n             if let Ok(binding) = source_bindings[ns].get() {\n-                this.import_res_map.entry(import.id).or_default()[ns] = Some(binding.res());\n+                this.import_res_map.entry(import_id).or_default()[ns] = Some(binding.res());\n             }\n         });\n \n@@ -1047,6 +1074,9 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         target_bindings: &PerNS<Cell<Option<&'b NameBinding<'b>>>>,\n         target: Ident,\n     ) {\n+        // This function is only called for single imports.\n+        let ImportKind::Single { id, .. } = import.kind else { unreachable!() };\n+\n         // Skip if the import was produced by a macro.\n         if import.parent_scope.expansion != LocalExpnId::ROOT {\n             return;\n@@ -1094,7 +1124,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             redundant_spans.dedup();\n             self.r.lint_buffer.buffer_lint_with_diagnostic(\n                 UNUSED_IMPORTS,\n-                import.id,\n+                id,\n                 import.span,\n                 &format!(\"the item `{}` is imported redundantly\", ident),\n                 BuiltinLintDiagnostics::RedundantImport(redundant_spans, ident),\n@@ -1103,6 +1133,9 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     }\n \n     fn resolve_glob_import(&mut self, import: &'b Import<'b>) {\n+        // This function is only called for glob imports.\n+        let ImportKind::Glob { id, is_prelude, .. } = import.kind else { unreachable!() };\n+\n         let ModuleOrUniformRoot::Module(module) = import.imported_module.get().unwrap() else {\n             self.r.session.span_err(import.span, \"cannot glob-import all possible crates\");\n             return;\n@@ -1113,7 +1146,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             return;\n         } else if ptr::eq(module, import.parent_scope.module) {\n             return;\n-        } else if let ImportKind::Glob { is_prelude: true, .. } = import.kind {\n+        } else if is_prelude {\n             self.r.prelude = Some(module);\n             return;\n         }\n@@ -1145,7 +1178,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         }\n \n         // Record the destination of this import\n-        self.r.record_partial_res(import.id, PartialRes::new(module.res().unwrap()));\n+        self.r.record_partial_res(id, PartialRes::new(module.res().unwrap()));\n     }\n \n     // Miscellaneous post-processing, including recording re-exports,\n@@ -1204,5 +1237,6 @@ fn import_kind_to_string(import_kind: &ImportKind<'_>) -> String {\n         ImportKind::Glob { .. } => \"*\".to_string(),\n         ImportKind::ExternCrate { .. } => \"<extern crate>\".to_string(),\n         ImportKind::MacroUse => \"#[macro_use]\".to_string(),\n+        ImportKind::MacroExport => \"#[macro_export]\".to_string(),\n     }\n }"}, {"sha": "ee1c97d5ad2b7925875e30bf0f3a74fb16094417", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -104,9 +104,7 @@ enum Scope<'a> {\n     DeriveHelpersCompat,\n     MacroRules(MacroRulesScopeRef<'a>),\n     CrateRoot,\n-    // The node ID is for reporting the `PROC_MACRO_DERIVE_RESOLUTION_FALLBACK`\n-    // lint if it should be reported.\n-    Module(Module<'a>, Option<NodeId>),\n+    Module(Module<'a>),\n     MacroUsePrelude,\n     BuiltinAttrs,\n     ExternPrelude,\n@@ -646,7 +644,7 @@ impl<'a> ToNameBinding<'a> for &'a NameBinding<'a> {\n \n #[derive(Clone, Debug)]\n enum NameBindingKind<'a> {\n-    Res(Res, /* is_macro_export */ bool),\n+    Res(Res),\n     Module(Module<'a>),\n     Import { binding: &'a NameBinding<'a>, import: &'a Import<'a>, used: Cell<bool> },\n }\n@@ -745,7 +743,7 @@ impl<'a> NameBinding<'a> {\n \n     fn res(&self) -> Res {\n         match self.kind {\n-            NameBindingKind::Res(res, _) => res,\n+            NameBindingKind::Res(res) => res,\n             NameBindingKind::Module(module) => module.res().unwrap(),\n             NameBindingKind::Import { binding, .. } => binding.res(),\n         }\n@@ -762,10 +760,10 @@ impl<'a> NameBinding<'a> {\n     fn is_possibly_imported_variant(&self) -> bool {\n         match self.kind {\n             NameBindingKind::Import { binding, .. } => binding.is_possibly_imported_variant(),\n-            NameBindingKind::Res(\n-                Res::Def(DefKind::Variant | DefKind::Ctor(CtorOf::Variant, ..), _),\n+            NameBindingKind::Res(Res::Def(\n+                DefKind::Variant | DefKind::Ctor(CtorOf::Variant, ..),\n                 _,\n-            ) => true,\n+            )) => true,\n             NameBindingKind::Res(..) | NameBindingKind::Module(..) => false,\n         }\n     }\n@@ -788,6 +786,13 @@ impl<'a> NameBinding<'a> {\n         matches!(self.kind, NameBindingKind::Import { .. })\n     }\n \n+    /// The binding introduced by `#[macro_export] macro_rules` is a public import, but it might\n+    /// not be perceived as such by users, so treat it as a non-import in some diagnostics.\n+    fn is_import_user_facing(&self) -> bool {\n+        matches!(self.kind, NameBindingKind::Import { import, .. }\n+            if !matches!(import.kind, ImportKind::MacroExport))\n+    }\n+\n     fn is_glob_import(&self) -> bool {\n         match self.kind {\n             NameBindingKind::Import { import, .. } => import.is_glob(),\n@@ -1283,7 +1288,7 @@ impl<'a> Resolver<'a> {\n \n             arenas,\n             dummy_binding: arenas.alloc_name_binding(NameBinding {\n-                kind: NameBindingKind::Res(Res::Err, false),\n+                kind: NameBindingKind::Res(Res::Err),\n                 ambiguity: None,\n                 expansion: LocalExpnId::ROOT,\n                 span: DUMMY_SP,\n@@ -1551,7 +1556,7 @@ impl<'a> Resolver<'a> {\n \n         self.visit_scopes(ScopeSet::All(TypeNS, false), parent_scope, ctxt, |this, scope, _, _| {\n             match scope {\n-                Scope::Module(module, _) => {\n+                Scope::Module(module) => {\n                     this.traits_in_module(module, assoc_item, &mut found_traits);\n                 }\n                 Scope::StdLibPrelude => {\n@@ -1613,10 +1618,12 @@ impl<'a> Resolver<'a> {\n     ) -> SmallVec<[LocalDefId; 1]> {\n         let mut import_ids = smallvec![];\n         while let NameBindingKind::Import { import, binding, .. } = kind {\n-            let id = self.local_def_id(import.id);\n-            self.maybe_unused_trait_imports.insert(id);\n+            if let Some(node_id) = import.id() {\n+                let def_id = self.local_def_id(node_id);\n+                self.maybe_unused_trait_imports.insert(def_id);\n+                import_ids.push(def_id);\n+            }\n             self.add_to_glob_map(&import, trait_name);\n-            import_ids.push(id);\n             kind = &binding.kind;\n         }\n         import_ids\n@@ -1683,16 +1690,18 @@ impl<'a> Resolver<'a> {\n             }\n             used.set(true);\n             import.used.set(true);\n-            self.used_imports.insert(import.id);\n+            if let Some(id) = import.id() {\n+                self.used_imports.insert(id);\n+            }\n             self.add_to_glob_map(&import, ident);\n             self.record_use(ident, binding, false);\n         }\n     }\n \n     #[inline]\n     fn add_to_glob_map(&mut self, import: &Import<'_>, ident: Ident) {\n-        if import.is_glob() {\n-            let def_id = self.local_def_id(import.id);\n+        if let ImportKind::Glob { id, .. } = import.kind {\n+            let def_id = self.local_def_id(id);\n             self.glob_map.entry(def_id).or_default().insert(ident.name);\n         }\n     }\n@@ -1994,11 +2003,7 @@ impl<'a> Resolver<'a> {\n \n     // Items that go to reexport table encoded to metadata and visible through it to other crates.\n     fn is_reexport(&self, binding: &NameBinding<'a>) -> Option<def::Res<!>> {\n-        // FIXME: Consider changing the binding inserted by `#[macro_export] macro_rules`\n-        // into the crate root to actual `NameBindingKind::Import`.\n-        if binding.is_import()\n-            || matches!(binding.kind, NameBindingKind::Res(_, _is_macro_export @ true))\n-        {\n+        if binding.is_import() {\n             let res = binding.res().expect_non_local();\n             // Ambiguous imports are treated as errors at this point and are\n             // not exposed to other crates (see #36837 for more details)."}, {"sha": "cd8c8c463b1ab60bafcaf15168de9dc1d6003362", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -362,7 +362,7 @@ impl Class {\n         match self {\n             Class::Comment => \"comment\",\n             Class::DocComment => \"doccomment\",\n-            Class::Attribute => \"attribute\",\n+            Class::Attribute => \"attr\",\n             Class::KeyWord => \"kw\",\n             Class::RefKeyWord => \"kw-2\",\n             Class::Self_(_) => \"self\","}, {"sha": "fced2eacd9e72555cd19474962df9428a684c4a1", "filename": "src/librustdoc/html/highlight/fixtures/sample.html", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.html", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.html?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -3,16 +3,16 @@\n .kw { color: #8959A8; }\n .kw-2, .prelude-ty { color: #4271AE; }\n .number, .string { color: #718C00; }\n-.self, .bool-val, .prelude-val, .attribute, .attribute .ident { color: #C82829; }\n+.self, .bool-val, .prelude-val, .attr, .attr .ident { color: #C82829; }\n .macro, .macro-nonterminal { color: #3E999F; }\n .lifetime { color: #B76514; }\n .question-mark { color: #ff9011; }\n </style>\n-<pre><code><span class=\"attribute\">#![crate_type = <span class=\"string\">&quot;lib&quot;</span>]\n+<pre><code><span class=\"attr\">#![crate_type = <span class=\"string\">&quot;lib&quot;</span>]\n \n </span><span class=\"kw\">use </span>std::path::{Path, PathBuf};\n \n-<span class=\"attribute\">#[cfg(target_os = <span class=\"string\">&quot;linux&quot;</span>)]\n+<span class=\"attr\">#[cfg(target_os = <span class=\"string\">&quot;linux&quot;</span>)]\n #[cfg(target_os = <span class=\"string\">&quot;windows&quot;</span>)]\n </span><span class=\"kw\">fn </span>main() -&gt; () {\n     <span class=\"kw\">let </span>foo = <span class=\"bool-val\">true </span>&amp;&amp; <span class=\"bool-val\">false </span>|| <span class=\"bool-val\">true</span>;\n@@ -23,7 +23,7 @@\n     <span class=\"macro\">mac!</span>(foo, <span class=\"kw-2\">&amp;mut </span>bar);\n     <span class=\"macro\">assert!</span>(<span class=\"self\">self</span>.length &lt; N &amp;&amp; index &lt;= <span class=\"self\">self</span>.length);\n     ::std::env::var(<span class=\"string\">&quot;gateau&quot;</span>).is_ok();\n-    <span class=\"attribute\">#[rustfmt::skip]\n+    <span class=\"attr\">#[rustfmt::skip]\n     </span><span class=\"kw\">let </span>s:std::path::PathBuf = std::path::PathBuf::new();\n     <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::new();\n "}, {"sha": "2c93b9a097f403e364b77baf0651f3788aac2cbe", "filename": "src/librustdoc/html/highlight/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -9,7 +9,7 @@ const STYLE: &str = r#\"\n .kw { color: #8959A8; }\n .kw-2, .prelude-ty { color: #4271AE; }\n .number, .string { color: #718C00; }\n-.self, .bool-val, .prelude-val, .attribute, .attribute .ident { color: #C82829; }\n+.self, .bool-val, .prelude-val, .attr, .attr .ident { color: #C82829; }\n .macro, .macro-nonterminal { color: #3E999F; }\n .lifetime { color: #B76514; }\n .question-mark { color: #ff9011; }"}, {"sha": "219d1b4ed53ffadea6aba8645bbf244cbdaecc63", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -880,8 +880,6 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \n .search-results.active {\n \tdisplay: block;\n-\t/* prevent overhanging tabs from moving the first result */\n-\tclear: both;\n }\n \n .search-results .desc > span {\n@@ -1092,7 +1090,7 @@ pre.rust .bool-val {\n pre.rust .self {\n \tcolor: var(--code-highlight-self-color);\n }\n-pre.rust .attribute {\n+pre.rust .attr {\n \tcolor: var(--code-highlight-attribute-color);\n }\n pre.rust .macro,"}, {"sha": "ff1be389dcb07af1a3d34047ff4cf6ee74af63f0", "filename": "src/test/rustdoc-gui/highlight-colors.goml", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftest%2Frustdoc-gui%2Fhighlight-colors.goml", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftest%2Frustdoc-gui%2Fhighlight-colors.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fhighlight-colors.goml?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -15,7 +15,7 @@ define-function: (\n         string,\n         bool_val,\n         self,\n-        attribute,\n+        attr,\n         macro,\n         question_mark,\n         comment,\n@@ -33,7 +33,7 @@ define-function: (\n         (\"assert-css\", (\"pre.rust .string\", {\"color\": |string|}, ALL)),\n         (\"assert-css\", (\"pre.rust .bool-val\", {\"color\": |bool_val|}, ALL)),\n         (\"assert-css\", (\"pre.rust .self\", {\"color\": |self|}, ALL)),\n-        (\"assert-css\", (\"pre.rust .attribute\", {\"color\": |attribute|}, ALL)),\n+        (\"assert-css\", (\"pre.rust .attr\", {\"color\": |attr|}, ALL)),\n         (\"assert-css\", (\"pre.rust .macro\", {\"color\": |macro|}, ALL)),\n         (\"assert-css\", (\"pre.rust .question-mark\", {\"color\": |question_mark|}, ALL)),\n         (\"assert-css\", (\"pre.rust .comment\", {\"color\": |comment|}, ALL)),\n@@ -52,7 +52,7 @@ call-function: (\"check-colors\", {\n     \"string\": \"rgb(184, 204, 82)\",\n     \"bool_val\": \"rgb(255, 119, 51)\",\n     \"self\": \"rgb(54, 163, 217)\",\n-    \"attribute\": \"rgb(230, 225, 207)\",\n+    \"attr\": \"rgb(230, 225, 207)\",\n     \"macro\": \"rgb(163, 122, 204)\",\n     \"question_mark\": \"rgb(255, 144, 17)\",\n     \"comment\": \"rgb(120, 135, 151)\",\n@@ -69,7 +69,7 @@ call-function: (\"check-colors\", {\n     \"string\": \"rgb(131, 163, 0)\",\n     \"bool_val\": \"rgb(238, 104, 104)\",\n     \"self\": \"rgb(238, 104, 104)\",\n-    \"attribute\": \"rgb(238, 104, 104)\",\n+    \"attr\": \"rgb(238, 104, 104)\",\n     \"macro\": \"rgb(62, 153, 159)\",\n     \"question_mark\": \"rgb(255, 144, 17)\",\n     \"comment\": \"rgb(141, 141, 139)\",\n@@ -86,7 +86,7 @@ call-function: (\"check-colors\", {\n     \"string\": \"rgb(113, 140, 0)\",\n     \"bool_val\": \"rgb(200, 40, 41)\",\n     \"self\": \"rgb(200, 40, 41)\",\n-    \"attribute\": \"rgb(200, 40, 41)\",\n+    \"attr\": \"rgb(200, 40, 41)\",\n     \"macro\": \"rgb(62, 153, 159)\",\n     \"question_mark\": \"rgb(255, 144, 17)\",\n     \"comment\": \"rgb(142, 144, 140)\","}, {"sha": "3bca4536cd5b6ccf79da819e7adfb83e48da08cf", "filename": "src/test/rustdoc/issue-41783.codeblock.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftest%2Frustdoc%2Fissue-41783.codeblock.html", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftest%2Frustdoc%2Fissue-41783.codeblock.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-41783.codeblock.html?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -1,5 +1,5 @@\n <code># single\n ## double\n ### triple\n-<span class=\"attribute\">#[outer]\n+<span class=\"attr\">#[outer]\n #![inner]</span></code>"}, {"sha": "769f984a274a776c8771eb34bc1b2ede21233dd7", "filename": "src/test/rustdoc/issue-41783.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftest%2Frustdoc%2Fissue-41783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftest%2Frustdoc%2Fissue-41783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-41783.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -1,10 +1,10 @@\n // @has issue_41783/struct.Foo.html\n // @!hasraw - 'space'\n // @!hasraw - 'comment'\n-// @hasraw - '<span class=\"attribute\">#[outer]'\n-// @!hasraw - '<span class=\"attribute\">#[outer]</span>'\n+// @hasraw - '<span class=\"attr\">#[outer]'\n+// @!hasraw - '<span class=\"attr\">#[outer]</span>'\n // @hasraw - '#![inner]</span>'\n-// @!hasraw - '<span class=\"attribute\">#![inner]</span>'\n+// @!hasraw - '<span class=\"attr\">#![inner]</span>'\n // @snapshot 'codeblock' - '//*[@class=\"rustdoc-toggle top-doc\"]/*[@class=\"docblock\"]//pre/code'\n \n /// ```no_run"}, {"sha": "85ed97663e8a0db7ff00411033bf8a9faff680d2", "filename": "src/test/ui/macros/issue-38715.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftest%2Fui%2Fmacros%2Fissue-38715.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftest%2Fui%2Fmacros%2Fissue-38715.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-38715.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -1,7 +1,17 @@\n #[macro_export]\n-macro_rules! foo { ($i:ident) => {} }\n+macro_rules! foo { () => {} }\n \n #[macro_export]\n macro_rules! foo { () => {} } //~ ERROR the name `foo` is defined multiple times\n \n+mod inner1 {\n+    #[macro_export]\n+    macro_rules! bar { () => {} }\n+}\n+\n+mod inner2 {\n+    #[macro_export]\n+    macro_rules! bar { () => {} } //~ ERROR the name `bar` is defined multiple times\n+}\n+\n fn main() {}"}, {"sha": "828a7f459301fce6e8f21b190107e42fc931a6b9", "filename": "src/test/ui/macros/issue-38715.stderr", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftest%2Fui%2Fmacros%2Fissue-38715.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftest%2Fui%2Fmacros%2Fissue-38715.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-38715.stderr?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -1,14 +1,25 @@\n error[E0428]: the name `foo` is defined multiple times\n   --> $DIR/issue-38715.rs:5:1\n    |\n-LL | macro_rules! foo { ($i:ident) => {} }\n+LL | macro_rules! foo { () => {} }\n    | ---------------- previous definition of the macro `foo` here\n ...\n LL | macro_rules! foo { () => {} }\n    | ^^^^^^^^^^^^^^^^ `foo` redefined here\n    |\n    = note: `foo` must be defined only once in the macro namespace of this module\n \n-error: aborting due to previous error\n+error[E0428]: the name `bar` is defined multiple times\n+  --> $DIR/issue-38715.rs:14:5\n+   |\n+LL |     macro_rules! bar { () => {} }\n+   |     ---------------- previous definition of the macro `bar` here\n+...\n+LL |     macro_rules! bar { () => {} }\n+   |     ^^^^^^^^^^^^^^^^ `bar` redefined here\n+   |\n+   = note: `bar` must be defined only once in the macro namespace of this module\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0428`."}, {"sha": "c1f9ee8dfdf73e1081e3841e9a8e8d26b4c41676", "filename": "src/test/ui/privacy/effective_visibilities.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -38,13 +38,13 @@ mod outer { //~ ERROR Direct: pub(crate), Reexported: pub(crate), Reachable: pub\n     }\n \n     #[rustc_effective_visibility]\n-    macro_rules! none_macro { //~ Direct: pub(crate), Reexported: pub(crate), Reachable: pub(crate), ReachableThroughImplTrait: pub(crate)\n+    macro_rules! none_macro { //~ ERROR not in the table\n         () => {};\n     }\n \n     #[macro_export]\n     #[rustc_effective_visibility]\n-    macro_rules! public_macro { //~ Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+    macro_rules! public_macro { //~ ERROR Direct: pub(self), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n         () => {};\n     }\n "}, {"sha": "5a8f7db38fc8a4db83fd53df3a1bf958b507ae7a", "filename": "src/test/ui/privacy/effective_visibilities.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.stderr?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -64,13 +64,13 @@ error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImpl\n LL |                 PubUnion,\n    |                 ^^^^^^^^\n \n-error: Direct: pub(crate), Reexported: pub(crate), Reachable: pub(crate), ReachableThroughImplTrait: pub(crate)\n+error: not in the table\n   --> $DIR/effective_visibilities.rs:41:5\n    |\n LL |     macro_rules! none_macro {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: Direct: pub, Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n+error: Direct: pub(self), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n   --> $DIR/effective_visibilities.rs:47:5\n    |\n LL |     macro_rules! public_macro {"}, {"sha": "9eea630c310ecb1fc17900e7744332b240d4291b", "filename": "src/test/ui/proc-macro/generate-mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -15,19 +15,16 @@ struct S;\n \n #[derive(generate_mod::CheckDerive)] //~ ERROR cannot find type `FromOutside` in this scope\n                                      //~| ERROR cannot find type `OuterDerive` in this scope\n-                                     //~| WARN this was previously accepted\n-                                     //~| WARN this was previously accepted\n struct Z;\n \n fn inner_block() {\n     #[derive(generate_mod::CheckDerive)] //~ ERROR cannot find type `FromOutside` in this scope\n                                         //~| ERROR cannot find type `OuterDerive` in this scope\n-                                        //~| WARN this was previously accepted\n-                                        //~| WARN this was previously accepted\n     struct InnerZ;\n }\n \n-#[derive(generate_mod::CheckDeriveLint)] // OK, lint is suppressed\n+#[derive(generate_mod::CheckDeriveLint)] //~  ERROR cannot find type `OuterDeriveLint` in this scope\n+                                         //~| ERROR cannot find type `FromOutside` in this scope\n struct W;\n \n fn main() {}"}, {"sha": "64042ca0ecdea1e58a2541285084d901fce7b7c5", "filename": "src/test/ui/proc-macro/generate-mod.stderr", "status": "modified", "additions": 34, "deletions": 95, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -38,127 +38,66 @@ LL | #[generate_mod::check_attr]\n            OuterAttr\n    = note: this error originates in the attribute macro `generate_mod::check_attr` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: cannot find type `FromOutside` in this scope\n+error[E0412]: cannot find type `FromOutside` in this scope\n   --> $DIR/generate-mod.rs:16:10\n    |\n LL | #[derive(generate_mod::CheckDerive)]\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n    |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n-   = note: `#[deny(proc_macro_derive_resolution_fallback)]` on by default\n+   = note: consider importing this struct:\n+           FromOutside\n    = note: this error originates in the derive macro `generate_mod::CheckDerive` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: cannot find type `OuterDerive` in this scope\n+error[E0412]: cannot find type `OuterDerive` in this scope\n   --> $DIR/generate-mod.rs:16:10\n    |\n LL | #[derive(generate_mod::CheckDerive)]\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n-   = note: this error originates in the derive macro `generate_mod::CheckDerive` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error: cannot find type `FromOutside` in this scope\n-  --> $DIR/generate-mod.rs:23:14\n-   |\n-LL |     #[derive(generate_mod::CheckDerive)]\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n    |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n+   = note: consider importing this struct:\n+           OuterDerive\n    = note: this error originates in the derive macro `generate_mod::CheckDerive` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: cannot find type `OuterDerive` in this scope\n-  --> $DIR/generate-mod.rs:23:14\n+error[E0412]: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:21:14\n    |\n LL |     #[derive(generate_mod::CheckDerive)]\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n-   = note: this error originates in the derive macro `generate_mod::CheckDerive` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error: aborting due to 8 previous errors\n-\n-For more information about this error, try `rustc --explain E0412`.\n-Future incompatibility report: Future breakage diagnostic:\n-error: cannot find type `FromOutside` in this scope\n-  --> $DIR/generate-mod.rs:16:10\n-   |\n-LL | #[derive(generate_mod::CheckDerive)]\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n-   = note: `#[deny(proc_macro_derive_resolution_fallback)]` on by default\n-   = note: this error originates in the derive macro `generate_mod::CheckDerive` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-Future breakage diagnostic:\n-error: cannot find type `OuterDerive` in this scope\n-  --> $DIR/generate-mod.rs:16:10\n-   |\n-LL | #[derive(generate_mod::CheckDerive)]\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n    |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n-   = note: `#[deny(proc_macro_derive_resolution_fallback)]` on by default\n+   = note: consider importing this struct:\n+           FromOutside\n    = note: this error originates in the derive macro `generate_mod::CheckDerive` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-Future breakage diagnostic:\n-error: cannot find type `FromOutside` in this scope\n-  --> $DIR/generate-mod.rs:23:14\n+error[E0412]: cannot find type `OuterDerive` in this scope\n+  --> $DIR/generate-mod.rs:21:14\n    |\n LL |     #[derive(generate_mod::CheckDerive)]\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n    |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n-   = note: `#[deny(proc_macro_derive_resolution_fallback)]` on by default\n+   = note: consider importing this struct:\n+           OuterDerive\n    = note: this error originates in the derive macro `generate_mod::CheckDerive` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-Future breakage diagnostic:\n-error: cannot find type `OuterDerive` in this scope\n-  --> $DIR/generate-mod.rs:23:14\n+error[E0412]: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:26:10\n    |\n-LL |     #[derive(generate_mod::CheckDerive)]\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n+LL | #[derive(generate_mod::CheckDeriveLint)]\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n    |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n-   = note: `#[deny(proc_macro_derive_resolution_fallback)]` on by default\n-   = note: this error originates in the derive macro `generate_mod::CheckDerive` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: consider importing this struct:\n+           FromOutside\n+   = note: this error originates in the derive macro `generate_mod::CheckDeriveLint` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-Future breakage diagnostic:\n-warning: cannot find type `FromOutside` in this scope\n-  --> $DIR/generate-mod.rs:30:10\n+error[E0412]: cannot find type `OuterDeriveLint` in this scope\n+  --> $DIR/generate-mod.rs:26:10\n    |\n-LL | #[derive(generate_mod::CheckDeriveLint)] // OK, lint is suppressed\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n+LL | #[derive(generate_mod::CheckDeriveLint)]\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n    |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n-note: the lint level is defined here\n-  --> $DIR/generate-mod.rs:30:10\n-   |\n-LL | #[derive(generate_mod::CheckDeriveLint)] // OK, lint is suppressed\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: this warning originates in the derive macro `generate_mod::CheckDeriveLint` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: consider importing this struct:\n+           OuterDeriveLint\n+   = note: this error originates in the derive macro `generate_mod::CheckDeriveLint` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-Future breakage diagnostic:\n-warning: cannot find type `OuterDeriveLint` in this scope\n-  --> $DIR/generate-mod.rs:30:10\n-   |\n-LL | #[derive(generate_mod::CheckDeriveLint)] // OK, lint is suppressed\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n-note: the lint level is defined here\n-  --> $DIR/generate-mod.rs:30:10\n-   |\n-LL | #[derive(generate_mod::CheckDeriveLint)] // OK, lint is suppressed\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: this warning originates in the derive macro `generate_mod::CheckDeriveLint` (in Nightly builds, run with -Z macro-backtrace for more info)\n+error: aborting due to 10 previous errors\n \n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "8931c17bbdc16fec06fd99243ef9a62e40f62ab1", "filename": "src/tools/rust-analyzer/Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.lock?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -872,9 +872,9 @@ dependencies = [\n \n [[package]]\n name = \"lsp-types\"\n-version = \"0.93.1\"\n+version = \"0.93.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a3bcfee315dde785ba887edb540b08765fd7df75a7d948844be6bf5712246734\"\n+checksum = \"9be6e9c7e2d18f651974370d7aff703f9513e0df6e464fd795660edc77e6ca51\"\n dependencies = [\n  \"bitflags\",\n  \"serde\","}, {"sha": "8a91d6066614f5b34e5a1c0a138c97ec42fe33d7", "filename": "src/tools/rust-analyzer/crates/flycheck/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -295,7 +295,9 @@ impl FlycheckActor {\n             } => {\n                 let mut cmd = Command::new(toolchain::cargo());\n                 cmd.arg(command);\n-                cmd.args(&[\"--workspace\", \"--message-format=json\"]);\n+                cmd.current_dir(&self.root);\n+                cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"])\n+                    .arg(self.root.join(\"Cargo.toml\").as_os_str());\n \n                 if let Some(target) = target_triple {\n                     cmd.args(&[\"--target\", target.as_str()]);"}, {"sha": "79249757d9e9bb407aee638c8338e489b58c7842", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree/lower.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -662,8 +662,12 @@ fn desugar_future_path(orig: TypeRef) -> Path {\n     let mut generic_args: Vec<_> =\n         std::iter::repeat(None).take(path.segments().len() - 1).collect();\n     let mut last = GenericArgs::empty();\n-    let binding =\n-        AssociatedTypeBinding { name: name![Output], type_ref: Some(orig), bounds: Vec::new() };\n+    let binding = AssociatedTypeBinding {\n+        name: name![Output],\n+        args: None,\n+        type_ref: Some(orig),\n+        bounds: Vec::new(),\n+    };\n     last.bindings.push(binding);\n     generic_args.push(Some(Interned::new(last)));\n "}, {"sha": "592223f7d85fe76c020892ce158625c9eeec28a5", "filename": "src/tools/rust-analyzer/crates/hir-def/src/path.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -68,6 +68,9 @@ pub struct GenericArgs {\n pub struct AssociatedTypeBinding {\n     /// The name of the associated type.\n     pub name: Name,\n+    /// The generic arguments to the associated type. e.g. For `Trait<Assoc<'a, T> = &'a T>`, this\n+    /// would be `['a, T]`.\n+    pub args: Option<Interned<GenericArgs>>,\n     /// The type bound to this associated type (in `Item = T`, this would be the\n     /// `T`). This can be `None` if there are bounds instead.\n     pub type_ref: Option<TypeRef>,"}, {"sha": "cfa3a6baaf8b4aae5cfc8dcdda63202036fd9c6a", "filename": "src/tools/rust-analyzer/crates/hir-def/src/path/lower.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -163,6 +163,10 @@ pub(super) fn lower_generic_args(\n             ast::GenericArg::AssocTypeArg(assoc_type_arg) => {\n                 if let Some(name_ref) = assoc_type_arg.name_ref() {\n                     let name = name_ref.as_name();\n+                    let args = assoc_type_arg\n+                        .generic_arg_list()\n+                        .and_then(|args| lower_generic_args(lower_ctx, args))\n+                        .map(Interned::new);\n                     let type_ref = assoc_type_arg.ty().map(|it| TypeRef::from_ast(lower_ctx, it));\n                     let bounds = if let Some(l) = assoc_type_arg.type_bound_list() {\n                         l.bounds()\n@@ -171,7 +175,7 @@ pub(super) fn lower_generic_args(\n                     } else {\n                         Vec::new()\n                     };\n-                    bindings.push(AssociatedTypeBinding { name, type_ref, bounds });\n+                    bindings.push(AssociatedTypeBinding { name, args, type_ref, bounds });\n                 }\n             }\n             ast::GenericArg::LifetimeArg(lifetime_arg) => {\n@@ -214,6 +218,7 @@ fn lower_generic_args_from_fn_path(\n         let type_ref = TypeRef::from_ast_opt(ctx, ret_type.ty());\n         bindings.push(AssociatedTypeBinding {\n             name: name![Output],\n+            args: None,\n             type_ref: Some(type_ref),\n             bounds: Vec::new(),\n         });\n@@ -222,6 +227,7 @@ fn lower_generic_args_from_fn_path(\n         let type_ref = TypeRef::Tuple(Vec::new());\n         bindings.push(AssociatedTypeBinding {\n             name: name![Output],\n+            args: None,\n             type_ref: Some(type_ref),\n             bounds: Vec::new(),\n         });"}, {"sha": "996b42f5bd83c03bb906bddf466d5eaa2c863973", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -11,9 +11,9 @@ use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id,\n-    from_placeholder_idx, to_chalk_trait_id, AdtId, AliasEq, AliasTy, Binders, CallableDefId,\n-    CallableSig, FnPointer, ImplTraitId, Interner, Lifetime, ProjectionTy, QuantifiedWhereClause,\n-    Substitution, TraitRef, Ty, TyBuilder, TyKind, WhereClause,\n+    from_placeholder_idx, to_chalk_trait_id, utils::generics, AdtId, AliasEq, AliasTy, Binders,\n+    CallableDefId, CallableSig, FnPointer, ImplTraitId, Interner, Lifetime, ProjectionTy,\n+    QuantifiedWhereClause, Substitution, TraitRef, Ty, TyBuilder, TyKind, WhereClause,\n };\n \n pub trait TyExt {\n@@ -338,10 +338,13 @@ pub trait ProjectionTyExt {\n \n impl ProjectionTyExt for ProjectionTy {\n     fn trait_ref(&self, db: &dyn HirDatabase) -> TraitRef {\n-        TraitRef {\n-            trait_id: to_chalk_trait_id(self.trait_(db)),\n-            substitution: self.substitution.clone(),\n-        }\n+        // FIXME: something like `Split` trait from chalk-solve might be nice.\n+        let generics = generics(db.upcast(), from_assoc_type_id(self.associated_ty_id).into());\n+        let substitution = Substitution::from_iter(\n+            Interner,\n+            self.substitution.iter(Interner).skip(generics.len_self()),\n+        );\n+        TraitRef { trait_id: to_chalk_trait_id(self.trait_(db)), substitution }\n     }\n \n     fn trait_(&self, db: &dyn HirDatabase) -> TraitId {"}, {"sha": "5ad66132635340c410488f425529be1d4397720f", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/display.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -289,16 +289,18 @@ impl HirDisplay for ProjectionTy {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n \n-        let trait_ = f.db.trait_data(self.trait_(f.db));\n+        let trait_ref = self.trait_ref(f.db);\n         write!(f, \"<\")?;\n-        self.self_type_parameter(f.db).hir_fmt(f)?;\n-        write!(f, \" as {}\", trait_.name)?;\n-        if self.substitution.len(Interner) > 1 {\n+        fmt_trait_ref(&trait_ref, f, true)?;\n+        write!(f, \">::{}\", f.db.type_alias_data(from_assoc_type_id(self.associated_ty_id)).name)?;\n+        let proj_params_count =\n+            self.substitution.len(Interner) - trait_ref.substitution.len(Interner);\n+        let proj_params = &self.substitution.as_slice(Interner)[..proj_params_count];\n+        if !proj_params.is_empty() {\n             write!(f, \"<\")?;\n-            f.write_joined(&self.substitution.as_slice(Interner)[1..], \", \")?;\n+            f.write_joined(proj_params, \", \")?;\n             write!(f, \">\")?;\n         }\n-        write!(f, \">::{}\", f.db.type_alias_data(from_assoc_type_id(self.associated_ty_id)).name)?;\n         Ok(())\n     }\n }\n@@ -641,9 +643,12 @@ impl HirDisplay for Ty {\n                 // Use placeholder associated types when the target is test (https://rust-lang.github.io/chalk/book/clauses/type_equality.html#placeholder-associated-types)\n                 if f.display_target.is_test() {\n                     write!(f, \"{}::{}\", trait_.name, type_alias_data.name)?;\n+                    // Note that the generic args for the associated type come before those for the\n+                    // trait (including the self type).\n+                    // FIXME: reconsider the generic args order upon formatting?\n                     if parameters.len(Interner) > 0 {\n                         write!(f, \"<\")?;\n-                        f.write_joined(&*parameters.as_slice(Interner), \", \")?;\n+                        f.write_joined(parameters.as_slice(Interner), \", \")?;\n                         write!(f, \">\")?;\n                     }\n                 } else {\n@@ -972,9 +977,20 @@ fn write_bounds_like_dyn_trait(\n                     angle_open = true;\n                 }\n                 if let AliasTy::Projection(proj) = alias {\n-                    let type_alias =\n-                        f.db.type_alias_data(from_assoc_type_id(proj.associated_ty_id));\n-                    write!(f, \"{} = \", type_alias.name)?;\n+                    let assoc_ty_id = from_assoc_type_id(proj.associated_ty_id);\n+                    let type_alias = f.db.type_alias_data(assoc_ty_id);\n+                    write!(f, \"{}\", type_alias.name)?;\n+\n+                    let proj_arg_count = generics(f.db.upcast(), assoc_ty_id.into()).len_self();\n+                    if proj_arg_count > 0 {\n+                        write!(f, \"<\")?;\n+                        f.write_joined(\n+                            &proj.substitution.as_slice(Interner)[..proj_arg_count],\n+                            \", \",\n+                        )?;\n+                        write!(f, \">\")?;\n+                    }\n+                    write!(f, \" = \")?;\n                 }\n                 ty.hir_fmt(f)?;\n             }"}, {"sha": "ebe9d6fb5e0146d6c687f17a925c1c1e74a88a2e", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -157,7 +157,7 @@ impl<'a> InferenceContext<'a> {\n                     remaining_segments_for_ty,\n                     true,\n                 );\n-                if let TyKind::Error = ty.kind(Interner) {\n+                if ty.is_unknown() {\n                     return None;\n                 }\n "}, {"sha": "12f45f00f9c4dce9a1052c39fe7e6f6c2f6b70fa", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -340,8 +340,8 @@ impl<'a> InferenceTable<'a> {\n         self.resolve_with_fallback(t, &|_, _, d, _| d)\n     }\n \n-    /// Unify two types and register new trait goals that arise from that.\n-    pub(crate) fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n+    /// Unify two relatable values (e.g. `Ty`) and register new trait goals that arise from that.\n+    pub(crate) fn unify<T: ?Sized + Zip<Interner>>(&mut self, ty1: &T, ty2: &T) -> bool {\n         let result = match self.try_unify(ty1, ty2) {\n             Ok(r) => r,\n             Err(_) => return false,\n@@ -350,9 +350,13 @@ impl<'a> InferenceTable<'a> {\n         true\n     }\n \n-    /// Unify two types and return new trait goals arising from it, so the\n+    /// Unify two relatable values (e.g. `Ty`) and return new trait goals arising from it, so the\n     /// caller needs to deal with them.\n-    pub(crate) fn try_unify<T: Zip<Interner>>(&mut self, t1: &T, t2: &T) -> InferResult<()> {\n+    pub(crate) fn try_unify<T: ?Sized + Zip<Interner>>(\n+        &mut self,\n+        t1: &T,\n+        t2: &T,\n+    ) -> InferResult<()> {\n         match self.var_unification_table.relate(\n             Interner,\n             &self.db,"}, {"sha": "42c3b58d5ada520ba626c22c5ace408f007b2797", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lib.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -81,7 +81,20 @@ pub type PlaceholderIndex = chalk_ir::PlaceholderIndex;\n pub type VariableKind = chalk_ir::VariableKind<Interner>;\n pub type VariableKinds = chalk_ir::VariableKinds<Interner>;\n pub type CanonicalVarKinds = chalk_ir::CanonicalVarKinds<Interner>;\n+/// Represents generic parameters and an item bound by them. When the item has parent, the binders\n+/// also contain the generic parameters for its parent. See chalk's documentation for details.\n+///\n+/// One thing to keep in mind when working with `Binders` (and `Substitution`s, which represent\n+/// generic arguments) in rust-analyzer is that the ordering within *is* significant - the generic\n+/// parameters/arguments for an item MUST come before those for its parent. This is to facilitate\n+/// the integration with chalk-solve, which mildly puts constraints as such. See #13335 for its\n+/// motivation in detail.\n pub type Binders<T> = chalk_ir::Binders<T>;\n+/// Interned list of generic arguments for an item. When an item has parent, the `Substitution` for\n+/// it contains generic arguments for both its parent and itself. See chalk's documentation for\n+/// details.\n+///\n+/// See `Binders` for the constraint on the ordering.\n pub type Substitution = chalk_ir::Substitution<Interner>;\n pub type GenericArg = chalk_ir::GenericArg<Interner>;\n pub type GenericArgData = chalk_ir::GenericArgData<Interner>;\n@@ -124,14 +137,6 @@ pub type ConstrainedSubst = chalk_ir::ConstrainedSubst<Interner>;\n pub type Guidance = chalk_solve::Guidance<Interner>;\n pub type WhereClause = chalk_ir::WhereClause<Interner>;\n \n-// FIXME: get rid of this\n-pub fn subst_prefix(s: &Substitution, n: usize) -> Substitution {\n-    Substitution::from_iter(\n-        Interner,\n-        s.as_slice(Interner)[..std::cmp::min(s.len(Interner), n)].iter().cloned(),\n-    )\n-}\n-\n /// Return an index of a parameter in the generic type parameter list by it's id.\n pub fn param_idx(db: &dyn HirDatabase, id: TypeOrConstParamId) -> Option<usize> {\n     generics(db.upcast(), id.parent).param_idx(id)\n@@ -382,7 +387,6 @@ pub(crate) fn fold_tys_and_consts<T: HasInterner<Interner = Interner> + TypeFold\n pub fn replace_errors_with_variables<T>(t: &T) -> Canonical<T>\n where\n     T: HasInterner<Interner = Interner> + TypeFoldable<Interner> + Clone,\n-    T: HasInterner<Interner = Interner>,\n {\n     use chalk_ir::{\n         fold::{FallibleTypeFolder, TypeSuperFoldable},"}, {"sha": "22a85cf154587fa79e05807f3196391255b6513e", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lower.rs", "status": "modified", "additions": 91, "deletions": 33, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -447,12 +447,31 @@ impl<'a> TyLoweringContext<'a> {\n                             .db\n                             .trait_data(trait_ref.hir_trait_id())\n                             .associated_type_by_name(segment.name);\n+\n                         match found {\n                             Some(associated_ty) => {\n-                                // FIXME handle type parameters on the segment\n+                                // FIXME: `substs_from_path_segment()` pushes `TyKind::Error` for every parent\n+                                // generic params. It's inefficient to splice the `Substitution`s, so we may want\n+                                // that method to optionally take parent `Substitution` as we already know them at\n+                                // this point (`trait_ref.substitution`).\n+                                let substitution = self.substs_from_path_segment(\n+                                    segment,\n+                                    Some(associated_ty.into()),\n+                                    false,\n+                                    None,\n+                                );\n+                                let len_self =\n+                                    generics(self.db.upcast(), associated_ty.into()).len_self();\n+                                let substitution = Substitution::from_iter(\n+                                    Interner,\n+                                    substitution\n+                                        .iter(Interner)\n+                                        .take(len_self)\n+                                        .chain(trait_ref.substitution.iter(Interner)),\n+                                );\n                                 TyKind::Alias(AliasTy::Projection(ProjectionTy {\n                                     associated_ty_id: to_assoc_type_id(associated_ty),\n-                                    substitution: trait_ref.substitution,\n+                                    substitution,\n                                 }))\n                                 .intern(Interner)\n                             }\n@@ -590,36 +609,48 @@ impl<'a> TyLoweringContext<'a> {\n             res,\n             Some(segment.name.clone()),\n             move |name, t, associated_ty| {\n-                if name == segment.name {\n-                    let substs = match self.type_param_mode {\n-                        ParamLoweringMode::Placeholder => {\n-                            // if we're lowering to placeholders, we have to put\n-                            // them in now\n-                            let generics = generics(\n-                                self.db.upcast(),\n-                                self.resolver\n-                                    .generic_def()\n-                                    .expect(\"there should be generics if there's a generic param\"),\n-                            );\n-                            let s = generics.placeholder_subst(self.db);\n-                            s.apply(t.substitution.clone(), Interner)\n-                        }\n-                        ParamLoweringMode::Variable => t.substitution.clone(),\n-                    };\n-                    // We need to shift in the bound vars, since\n-                    // associated_type_shorthand_candidates does not do that\n-                    let substs = substs.shifted_in_from(Interner, self.in_binders);\n-                    // FIXME handle type parameters on the segment\n-                    Some(\n-                        TyKind::Alias(AliasTy::Projection(ProjectionTy {\n-                            associated_ty_id: to_assoc_type_id(associated_ty),\n-                            substitution: substs,\n-                        }))\n-                        .intern(Interner),\n-                    )\n-                } else {\n-                    None\n+                if name != segment.name {\n+                    return None;\n                 }\n+\n+                // FIXME: `substs_from_path_segment()` pushes `TyKind::Error` for every parent\n+                // generic params. It's inefficient to splice the `Substitution`s, so we may want\n+                // that method to optionally take parent `Substitution` as we already know them at\n+                // this point (`t.substitution`).\n+                let substs = self.substs_from_path_segment(\n+                    segment.clone(),\n+                    Some(associated_ty.into()),\n+                    false,\n+                    None,\n+                );\n+\n+                let len_self = generics(self.db.upcast(), associated_ty.into()).len_self();\n+\n+                let substs = Substitution::from_iter(\n+                    Interner,\n+                    substs.iter(Interner).take(len_self).chain(t.substitution.iter(Interner)),\n+                );\n+\n+                let substs = match self.type_param_mode {\n+                    ParamLoweringMode::Placeholder => {\n+                        // if we're lowering to placeholders, we have to put\n+                        // them in now\n+                        let generics = generics(self.db.upcast(), def);\n+                        let s = generics.placeholder_subst(self.db);\n+                        s.apply(substs, Interner)\n+                    }\n+                    ParamLoweringMode::Variable => substs,\n+                };\n+                // We need to shift in the bound vars, since\n+                // associated_type_shorthand_candidates does not do that\n+                let substs = substs.shifted_in_from(Interner, self.in_binders);\n+                Some(\n+                    TyKind::Alias(AliasTy::Projection(ProjectionTy {\n+                        associated_ty_id: to_assoc_type_id(associated_ty),\n+                        substitution: substs,\n+                    }))\n+                    .intern(Interner),\n+                )\n             },\n         );\n \n@@ -777,7 +808,15 @@ impl<'a> TyLoweringContext<'a> {\n         // handle defaults. In expression or pattern path segments without\n         // explicitly specified type arguments, missing type arguments are inferred\n         // (i.e. defaults aren't used).\n-        if !infer_args || had_explicit_args {\n+        // Generic parameters for associated types are not supposed to have defaults, so we just\n+        // ignore them.\n+        let is_assoc_ty = if let GenericDefId::TypeAliasId(id) = def {\n+            let container = id.lookup(self.db.upcast()).container;\n+            matches!(container, ItemContainerId::TraitId(_))\n+        } else {\n+            false\n+        };\n+        if !is_assoc_ty && (!infer_args || had_explicit_args) {\n             let defaults = self.db.generic_defaults(def);\n             assert_eq!(total_len, defaults.len());\n             let parent_from = item_len - substs.len();\n@@ -966,9 +1005,28 @@ impl<'a> TyLoweringContext<'a> {\n                     None => return SmallVec::new(),\n                     Some(t) => t,\n                 };\n+                // FIXME: `substs_from_path_segment()` pushes `TyKind::Error` for every parent\n+                // generic params. It's inefficient to splice the `Substitution`s, so we may want\n+                // that method to optionally take parent `Substitution` as we already know them at\n+                // this point (`super_trait_ref.substitution`).\n+                let substitution = self.substs_from_path_segment(\n+                    // FIXME: This is hack. We shouldn't really build `PathSegment` directly.\n+                    PathSegment { name: &binding.name, args_and_bindings: binding.args.as_deref() },\n+                    Some(associated_ty.into()),\n+                    false, // this is not relevant\n+                    Some(super_trait_ref.self_type_parameter(Interner)),\n+                );\n+                let self_params = generics(self.db.upcast(), associated_ty.into()).len_self();\n+                let substitution = Substitution::from_iter(\n+                    Interner,\n+                    substitution\n+                        .iter(Interner)\n+                        .take(self_params)\n+                        .chain(super_trait_ref.substitution.iter(Interner)),\n+                );\n                 let projection_ty = ProjectionTy {\n                     associated_ty_id: to_assoc_type_id(associated_ty),\n-                    substitution: super_trait_ref.substitution,\n+                    substitution,\n                 };\n                 let mut preds: SmallVec<[_; 1]> = SmallVec::with_capacity(\n                     binding.type_ref.as_ref().map_or(0, |_| 1) + binding.bounds.len(),"}, {"sha": "50859475e1d948cf8361522dcefc40fa7c32b2b6", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 54, "deletions": 30, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -22,10 +22,10 @@ use crate::{\n     from_foreign_def_id,\n     infer::{unify::InferenceTable, Adjust, Adjustment, AutoBorrow, OverloadedDeref, PointerCast},\n     primitive::{FloatTy, IntTy, UintTy},\n-    static_lifetime,\n+    static_lifetime, to_chalk_trait_id,\n     utils::all_super_traits,\n     AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, ForeignDefId, InEnvironment, Interner,\n-    Scalar, TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n+    Scalar, Substitution, TraitEnvironment, TraitRef, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n };\n \n /// This is used as a key for indexing impls.\n@@ -624,52 +624,76 @@ pub(crate) fn iterate_method_candidates<T>(\n     slot\n }\n \n+/// Looks up the impl method that actually runs for the trait method `func`.\n+///\n+/// Returns `func` if it's not a method defined in a trait or the lookup failed.\n pub fn lookup_impl_method(\n-    self_ty: &Ty,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n-    trait_: TraitId,\n+    func: FunctionId,\n+    fn_subst: Substitution,\n+) -> FunctionId {\n+    let trait_id = match func.lookup(db.upcast()).container {\n+        ItemContainerId::TraitId(id) => id,\n+        _ => return func,\n+    };\n+    let trait_params = db.generic_params(trait_id.into()).type_or_consts.len();\n+    let fn_params = fn_subst.len(Interner) - trait_params;\n+    let trait_ref = TraitRef {\n+        trait_id: to_chalk_trait_id(trait_id),\n+        substitution: Substitution::from_iter(Interner, fn_subst.iter(Interner).skip(fn_params)),\n+    };\n+\n+    let name = &db.function_data(func).name;\n+    lookup_impl_method_for_trait_ref(trait_ref, db, env, name).unwrap_or(func)\n+}\n+\n+fn lookup_impl_method_for_trait_ref(\n+    trait_ref: TraitRef,\n+    db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n     name: &Name,\n ) -> Option<FunctionId> {\n-    let self_ty_fp = TyFingerprint::for_trait_impl(self_ty)?;\n-    let trait_impls = db.trait_impls_in_deps(env.krate);\n-    let impls = trait_impls.for_trait_and_self_ty(trait_, self_ty_fp);\n-    let mut table = InferenceTable::new(db, env.clone());\n-    find_matching_impl(impls, &mut table, &self_ty).and_then(|data| {\n-        data.items.iter().find_map(|it| match it {\n-            AssocItemId::FunctionId(f) => (db.function_data(*f).name == *name).then(|| *f),\n-            _ => None,\n-        })\n+    let self_ty = trait_ref.self_type_parameter(Interner);\n+    let self_ty_fp = TyFingerprint::for_trait_impl(&self_ty)?;\n+    let impls = db.trait_impls_in_deps(env.krate);\n+    let impls = impls.for_trait_and_self_ty(trait_ref.hir_trait_id(), self_ty_fp);\n+\n+    let table = InferenceTable::new(db, env);\n+\n+    let impl_data = find_matching_impl(impls, table, trait_ref)?;\n+    impl_data.items.iter().find_map(|it| match it {\n+        AssocItemId::FunctionId(f) => (db.function_data(*f).name == *name).then(|| *f),\n+        _ => None,\n     })\n }\n \n fn find_matching_impl(\n     mut impls: impl Iterator<Item = ImplId>,\n-    table: &mut InferenceTable<'_>,\n-    self_ty: &Ty,\n+    mut table: InferenceTable<'_>,\n+    actual_trait_ref: TraitRef,\n ) -> Option<Arc<ImplData>> {\n     let db = table.db;\n     loop {\n         let impl_ = impls.next()?;\n         let r = table.run_in_snapshot(|table| {\n             let impl_data = db.impl_data(impl_);\n-            let substs =\n+            let impl_substs =\n                 TyBuilder::subst_for_def(db, impl_, None).fill_with_inference_vars(table).build();\n-            let impl_ty = db.impl_self_ty(impl_).substitute(Interner, &substs);\n-\n-            table\n-                .unify(self_ty, &impl_ty)\n-                .then(|| {\n-                    let wh_goals =\n-                        crate::chalk_db::convert_where_clauses(db, impl_.into(), &substs)\n-                            .into_iter()\n-                            .map(|b| b.cast(Interner));\n+            let trait_ref = db\n+                .impl_trait(impl_)\n+                .expect(\"non-trait method in find_matching_impl\")\n+                .substitute(Interner, &impl_substs);\n \n-                    let goal = crate::Goal::all(Interner, wh_goals);\n+            if !table.unify(&trait_ref, &actual_trait_ref) {\n+                return None;\n+            }\n \n-                    table.try_obligation(goal).map(|_| impl_data)\n-                })\n-                .flatten()\n+            let wcs = crate::chalk_db::convert_where_clauses(db, impl_.into(), &impl_substs)\n+                .into_iter()\n+                .map(|b| b.cast(Interner));\n+            let goal = crate::Goal::all(Interner, wcs);\n+            table.try_obligation(goal).map(|_| impl_data)\n         });\n         if r.is_some() {\n             break r;\n@@ -1214,7 +1238,7 @@ fn is_valid_fn_candidate(\n             let expected_receiver =\n                 sig.map(|s| s.params()[0].clone()).substitute(Interner, &fn_subst);\n \n-            check_that!(table.unify(&receiver_ty, &expected_receiver));\n+            check_that!(table.unify(receiver_ty, &expected_receiver));\n         }\n \n         if let ItemContainerId::ImplId(impl_id) = container {"}, {"sha": "425432479e8159a822c907ce1b7ddd245530fbe1", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/display_source_code.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -196,3 +196,34 @@ fn test(\n \"#,\n     );\n }\n+\n+#[test]\n+fn projection_type_correct_arguments_order() {\n+    check_types_source_code(\n+        r#\"\n+trait Foo<T> {\n+    type Assoc<U>;\n+}\n+fn f<T: Foo<i32>>(a: T::Assoc<usize>) {\n+    a;\n+  //^ <T as Foo<i32>>::Assoc<usize>\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn generic_associated_type_binding_in_impl_trait() {\n+    check_types_source_code(\n+        r#\"\n+//- minicore: sized\n+trait Foo<T> {\n+    type Assoc<U>;\n+}\n+fn f(a: impl Foo<i8, Assoc<i16> = i32>) {\n+    a;\n+  //^ impl Foo<i8, Assoc<i16> = i32>\n+}\n+        \"#,\n+    );\n+}"}, {"sha": "7d42b8b9bc8d80951f258da956e786ee0a681273", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -3963,3 +3963,124 @@ fn g(t: &(dyn T + Send)) {\n         \"#,\n     );\n }\n+\n+#[test]\n+fn gats_in_path() {\n+    check_types(\n+        r#\"\n+//- minicore: deref\n+use core::ops::Deref;\n+trait PointerFamily {\n+    type Pointer<T>: Deref<Target = T>;\n+}\n+\n+fn f<P: PointerFamily>(p: P::Pointer<i32>) {\n+    let a = *p;\n+      //^ i32\n+}\n+fn g<P: PointerFamily>(p: <P as PointerFamily>::Pointer<i32>) {\n+    let a = *p;\n+      //^ i32\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn gats_with_impl_trait() {\n+    // FIXME: the last function (`fn i()`) is not valid Rust as of this writing because you cannot\n+    // specify the same associated type multiple times even if their arguments are different (c.f.\n+    // `fn h()`, which is valid). Reconsider how to treat these invalid types.\n+    check_types(\n+        r#\"\n+//- minicore: deref\n+use core::ops::Deref;\n+\n+trait Trait {\n+    type Assoc<T>: Deref<Target = T>;\n+    fn get<U>(&self) -> Self::Assoc<U>;\n+}\n+\n+fn f<T>(v: impl Trait) {\n+    let a = v.get::<i32>().deref();\n+      //^ &i32\n+    let a = v.get::<T>().deref();\n+      //^ &T\n+}\n+fn g<'a, T: 'a>(v: impl Trait<Assoc<T> = &'a T>) {\n+    let a = v.get::<T>();\n+      //^ &T\n+    let a = v.get::<()>();\n+      //^ Trait::Assoc<(), impl Trait<Assoc<T> = &T>>\n+}\n+fn h<'a>(v: impl Trait<Assoc<i32> = &'a i32> + Trait<Assoc<i64> = &'a i64>) {\n+    let a = v.get::<i32>();\n+      //^ &i32\n+    let a = v.get::<i64>();\n+      //^ &i64\n+}\n+fn i<'a>(v: impl Trait<Assoc<i32> = &'a i32, Assoc<i64> = &'a i64>) {\n+    let a = v.get::<i32>();\n+      //^ &i32\n+    let a = v.get::<i64>();\n+      //^ &i64\n+}\n+    \"#,\n+    );\n+}\n+\n+#[test]\n+fn gats_with_dyn() {\n+    // This test is here to keep track of how we infer things despite traits with GATs being not\n+    // object-safe currently.\n+    // FIXME: reconsider how to treat these invalid types.\n+    check_infer_with_mismatches(\n+        r#\"\n+//- minicore: deref\n+use core::ops::Deref;\n+\n+trait Trait {\n+    type Assoc<T>: Deref<Target = T>;\n+    fn get<U>(&self) -> Self::Assoc<U>;\n+}\n+\n+fn f<'a>(v: &dyn Trait<Assoc<i32> = &'a i32>) {\n+    v.get::<i32>().deref();\n+}\n+    \"#,\n+        expect![[r#\"\n+            90..94 'self': &Self\n+            127..128 'v': &(dyn Trait<Assoc<i32> = &i32>)\n+            164..195 '{     ...f(); }': ()\n+            170..171 'v': &(dyn Trait<Assoc<i32> = &i32>)\n+            170..184 'v.get::<i32>()': &i32\n+            170..192 'v.get:...eref()': &i32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn gats_in_associated_type_binding() {\n+    check_types(\n+        r#\"\n+trait Trait {\n+    type Assoc<T>;\n+    fn get<U>(&self) -> Self::Assoc<U>;\n+}\n+\n+fn f<T>(t: T)\n+where\n+    T: Trait<Assoc<i32> = u32>,\n+    T: Trait<Assoc<isize> = usize>,\n+{\n+    let a = t.get::<i32>();\n+      //^ u32\n+    let a = t.get::<isize>();\n+      //^ usize\n+    let a = t.get::<()>();\n+      //^ Trait::Assoc<(), T>\n+}\n+\n+    \"#,\n+    );\n+}"}, {"sha": "92711a24fe39fdc317328f7c76894c859ef76e64", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tls.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftls.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -5,7 +5,7 @@ use itertools::Itertools;\n \n use crate::{\n     chalk_db, db::HirDatabase, from_assoc_type_id, from_chalk_trait_id, mapping::from_chalk,\n-    CallableDefId, Interner,\n+    CallableDefId, Interner, ProjectionTyExt,\n };\n use hir_def::{AdtId, ItemContainerId, Lookup, TypeAliasId};\n \n@@ -63,17 +63,31 @@ impl DebugContext<'_> {\n             ItemContainerId::TraitId(t) => t,\n             _ => panic!(\"associated type not in trait\"),\n         };\n-        let trait_data = self.0.trait_data(trait_);\n-        let params = projection_ty.substitution.as_slice(Interner);\n-        write!(fmt, \"<{:?} as {}\", &params[0], trait_data.name,)?;\n-        if params.len() > 1 {\n+        let trait_name = &self.0.trait_data(trait_).name;\n+        let trait_ref = projection_ty.trait_ref(self.0);\n+        let trait_params = trait_ref.substitution.as_slice(Interner);\n+        let self_ty = trait_ref.self_type_parameter(Interner);\n+        write!(fmt, \"<{:?} as {}\", self_ty, trait_name)?;\n+        if trait_params.len() > 1 {\n+            write!(\n+                fmt,\n+                \"<{}>\",\n+                trait_params[1..].iter().format_with(\", \", |x, f| f(&format_args!(\"{:?}\", x))),\n+            )?;\n+        }\n+        write!(fmt, \">::{}\", type_alias_data.name)?;\n+\n+        let proj_params_count = projection_ty.substitution.len(Interner) - trait_params.len();\n+        let proj_params = &projection_ty.substitution.as_slice(Interner)[..proj_params_count];\n+        if !proj_params.is_empty() {\n             write!(\n                 fmt,\n                 \"<{}>\",\n-                &params[1..].iter().format_with(\", \", |x, f| f(&format_args!(\"{:?}\", x))),\n+                proj_params.iter().format_with(\", \", |x, f| f(&format_args!(\"{:?}\", x))),\n             )?;\n         }\n-        write!(fmt, \">::{}\", type_alias_data.name)\n+\n+        Ok(())\n     }\n \n     pub(crate) fn debug_fn_def_id("}, {"sha": "f86c571005367e5b4015472c55d1b8fd694c2d99", "filename": "src/tools/rust-analyzer/crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 26, "deletions": 39, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -270,7 +270,7 @@ impl SourceAnalyzer {\n         let expr_id = self.expr_id(db, &call.clone().into())?;\n         let (f_in_trait, substs) = self.infer.as_ref()?.method_resolution(expr_id)?;\n \n-        Some(self.resolve_impl_method_or_trait_def(db, f_in_trait, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, f_in_trait, substs))\n     }\n \n     pub(crate) fn resolve_await_to_poll(\n@@ -311,7 +311,7 @@ impl SourceAnalyzer {\n         // HACK: subst for `poll()` coincides with that for `Future` because `poll()` itself\n         // doesn't have any generic parameters, so we skip building another subst for `poll()`.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, future_trait, None).push(ty).build();\n-        Some(self.resolve_impl_method_or_trait_def(db, poll_fn, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, poll_fn, substs))\n     }\n \n     pub(crate) fn resolve_prefix_expr(\n@@ -331,7 +331,7 @@ impl SourceAnalyzer {\n         // don't have any generic parameters, so we skip building another subst for the methods.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None).push(ty.clone()).build();\n \n-        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))\n     }\n \n     pub(crate) fn resolve_index_expr(\n@@ -351,7 +351,7 @@ impl SourceAnalyzer {\n             .push(base_ty.clone())\n             .push(index_ty.clone())\n             .build();\n-        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))\n     }\n \n     pub(crate) fn resolve_bin_expr(\n@@ -372,7 +372,7 @@ impl SourceAnalyzer {\n             .push(rhs.clone())\n             .build();\n \n-        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))\n     }\n \n     pub(crate) fn resolve_try_expr(\n@@ -392,7 +392,7 @@ impl SourceAnalyzer {\n         // doesn't have any generic parameters, so we skip building another subst for `branch()`.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None).push(ty.clone()).build();\n \n-        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))\n     }\n \n     pub(crate) fn resolve_field(\n@@ -487,19 +487,22 @@ impl SourceAnalyzer {\n \n         let mut prefer_value_ns = false;\n         let resolved = (|| {\n+            let infer = self.infer.as_deref()?;\n             if let Some(path_expr) = parent().and_then(ast::PathExpr::cast) {\n                 let expr_id = self.expr_id(db, &path_expr.into())?;\n-                let infer = self.infer.as_ref()?;\n                 if let Some(assoc) = infer.assoc_resolutions_for_expr(expr_id) {\n                     let assoc = match assoc {\n                         AssocItemId::FunctionId(f_in_trait) => {\n                             match infer.type_of_expr.get(expr_id) {\n                                 None => assoc,\n                                 Some(func_ty) => {\n                                     if let TyKind::FnDef(_fn_def, subs) = func_ty.kind(Interner) {\n-                                        self.resolve_impl_method(db, f_in_trait, subs)\n-                                            .map(AssocItemId::FunctionId)\n-                                            .unwrap_or(assoc)\n+                                        self.resolve_impl_method_or_trait_def(\n+                                            db,\n+                                            f_in_trait,\n+                                            subs.clone(),\n+                                        )\n+                                        .into()\n                                     } else {\n                                         assoc\n                                     }\n@@ -520,18 +523,18 @@ impl SourceAnalyzer {\n                 prefer_value_ns = true;\n             } else if let Some(path_pat) = parent().and_then(ast::PathPat::cast) {\n                 let pat_id = self.pat_id(&path_pat.into())?;\n-                if let Some(assoc) = self.infer.as_ref()?.assoc_resolutions_for_pat(pat_id) {\n+                if let Some(assoc) = infer.assoc_resolutions_for_pat(pat_id) {\n                     return Some(PathResolution::Def(AssocItem::from(assoc).into()));\n                 }\n                 if let Some(VariantId::EnumVariantId(variant)) =\n-                    self.infer.as_ref()?.variant_resolution_for_pat(pat_id)\n+                    infer.variant_resolution_for_pat(pat_id)\n                 {\n                     return Some(PathResolution::Def(ModuleDef::Variant(variant.into())));\n                 }\n             } else if let Some(rec_lit) = parent().and_then(ast::RecordExpr::cast) {\n                 let expr_id = self.expr_id(db, &rec_lit.into())?;\n                 if let Some(VariantId::EnumVariantId(variant)) =\n-                    self.infer.as_ref()?.variant_resolution_for_expr(expr_id)\n+                    infer.variant_resolution_for_expr(expr_id)\n                 {\n                     return Some(PathResolution::Def(ModuleDef::Variant(variant.into())));\n                 }\n@@ -541,8 +544,7 @@ impl SourceAnalyzer {\n                     || parent().and_then(ast::TupleStructPat::cast).map(ast::Pat::from);\n                 if let Some(pat) = record_pat.or_else(tuple_struct_pat) {\n                     let pat_id = self.pat_id(&pat)?;\n-                    let variant_res_for_pat =\n-                        self.infer.as_ref()?.variant_resolution_for_pat(pat_id);\n+                    let variant_res_for_pat = infer.variant_resolution_for_pat(pat_id);\n                     if let Some(VariantId::EnumVariantId(variant)) = variant_res_for_pat {\n                         return Some(PathResolution::Def(ModuleDef::Variant(variant.into())));\n                     }\n@@ -780,37 +782,22 @@ impl SourceAnalyzer {\n         false\n     }\n \n-    fn resolve_impl_method(\n+    fn resolve_impl_method_or_trait_def(\n         &self,\n         db: &dyn HirDatabase,\n         func: FunctionId,\n-        substs: &Substitution,\n-    ) -> Option<FunctionId> {\n-        let impled_trait = match func.lookup(db.upcast()).container {\n-            ItemContainerId::TraitId(trait_id) => trait_id,\n-            _ => return None,\n-        };\n-        if substs.is_empty(Interner) {\n-            return None;\n-        }\n-        let self_ty = substs.at(Interner, 0).ty(Interner)?;\n+        substs: Substitution,\n+    ) -> FunctionId {\n         let krate = self.resolver.krate();\n-        let trait_env = self.resolver.body_owner()?.as_generic_def_id().map_or_else(\n+        let owner = match self.resolver.body_owner() {\n+            Some(it) => it,\n+            None => return func,\n+        };\n+        let env = owner.as_generic_def_id().map_or_else(\n             || Arc::new(hir_ty::TraitEnvironment::empty(krate)),\n             |d| db.trait_environment(d),\n         );\n-\n-        let fun_data = db.function_data(func);\n-        method_resolution::lookup_impl_method(self_ty, db, trait_env, impled_trait, &fun_data.name)\n-    }\n-\n-    fn resolve_impl_method_or_trait_def(\n-        &self,\n-        db: &dyn HirDatabase,\n-        func: FunctionId,\n-        substs: &Substitution,\n-    ) -> FunctionId {\n-        self.resolve_impl_method(db, func, substs).unwrap_or(func)\n+        method_resolution::lookup_impl_method(db, env, func, substs)\n     }\n \n     fn lang_trait_fn("}, {"sha": "f97c67b144ac15e4c67d8ee86d2a6563ebdda77d", "filename": "src/tools/rust-analyzer/crates/ide/src/goto_definition.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -1834,4 +1834,86 @@ fn f() {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn goto_bin_op_multiple_impl() {\n+        check(\n+            r#\"\n+//- minicore: add\n+struct S;\n+impl core::ops::Add for S {\n+    fn add(\n+     //^^^\n+    ) {}\n+}\n+impl core::ops::Add<usize> for S {\n+    fn add(\n+    ) {}\n+}\n+\n+fn f() {\n+    S +$0 S\n+}\n+\"#,\n+        );\n+\n+        check(\n+            r#\"\n+//- minicore: add\n+struct S;\n+impl core::ops::Add for S {\n+    fn add(\n+    ) {}\n+}\n+impl core::ops::Add<usize> for S {\n+    fn add(\n+     //^^^\n+    ) {}\n+}\n+\n+fn f() {\n+    S +$0 0usize\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn path_call_multiple_trait_impl() {\n+        check(\n+            r#\"\n+trait Trait<T> {\n+    fn f(_: T);\n+}\n+impl Trait<i32> for usize {\n+    fn f(_: i32) {}\n+     //^\n+}\n+impl Trait<i64> for usize {\n+    fn f(_: i64) {}\n+}\n+fn main() {\n+    usize::f$0(0i32);\n+}\n+\"#,\n+        );\n+\n+        check(\n+            r#\"\n+trait Trait<T> {\n+    fn f(_: T);\n+}\n+impl Trait<i32> for usize {\n+    fn f(_: i32) {}\n+}\n+impl Trait<i64> for usize {\n+    fn f(_: i64) {}\n+     //^\n+}\n+fn main() {\n+    usize::f$0(0i64);\n+}\n+\"#,\n+        )\n+    }\n }"}, {"sha": "7ae5324ab051ae7320d310ea01a54bc8a8c470a6", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -23,7 +23,7 @@ crossbeam-channel = \"0.5.5\"\n dissimilar = \"1.0.4\"\n itertools = \"0.10.5\"\n scip = \"0.1.1\"\n-lsp-types = { version = \"0.93.1\", features = [\"proposed\"] }\n+lsp-types = { version = \"=0.93.2\", features = [\"proposed\"] }\n parking_lot = \"0.12.1\"\n xflags = \"0.3.0\"\n oorandom = \"11.1.3\""}, {"sha": "7bf595d2a45f51c8a0784c6790bab4af0ae6f72d", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -11,7 +11,7 @@ use std::{env, fs, path::Path, process};\n \n use lsp_server::Connection;\n use project_model::ProjectManifest;\n-use rust_analyzer::{cli::flags, config::Config, from_json, lsp_ext::supports_utf8, Result};\n+use rust_analyzer::{cli::flags, config::Config, from_json, Result};\n use vfs::AbsPathBuf;\n \n #[cfg(all(feature = \"mimalloc\"))]\n@@ -191,11 +191,7 @@ fn run_server() -> Result<()> {\n             name: String::from(\"rust-analyzer\"),\n             version: Some(rust_analyzer::version().to_string()),\n         }),\n-        offset_encoding: if supports_utf8(config.caps()) {\n-            Some(\"utf-8\".to_string())\n-        } else {\n-            None\n-        },\n+        offset_encoding: None,\n     };\n \n     let initialize_result = serde_json::to_value(initialize_result).unwrap();"}, {"sha": "723b888d9abc8a1100184debf1e4b47c33c6a740", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/caps.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcaps.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -6,19 +6,25 @@ use lsp_types::{\n     FileOperationFilter, FileOperationPattern, FileOperationPatternKind,\n     FileOperationRegistrationOptions, FoldingRangeProviderCapability, HoverProviderCapability,\n     ImplementationProviderCapability, InlayHintOptions, InlayHintServerCapabilities, OneOf,\n-    RenameOptions, SaveOptions, SelectionRangeProviderCapability, SemanticTokensFullOptions,\n-    SemanticTokensLegend, SemanticTokensOptions, ServerCapabilities, SignatureHelpOptions,\n-    TextDocumentSyncCapability, TextDocumentSyncKind, TextDocumentSyncOptions,\n-    TypeDefinitionProviderCapability, WorkDoneProgressOptions,\n+    PositionEncodingKind, RenameOptions, SaveOptions, SelectionRangeProviderCapability,\n+    SemanticTokensFullOptions, SemanticTokensLegend, SemanticTokensOptions, ServerCapabilities,\n+    SignatureHelpOptions, TextDocumentSyncCapability, TextDocumentSyncKind,\n+    TextDocumentSyncOptions, TypeDefinitionProviderCapability, WorkDoneProgressOptions,\n     WorkspaceFileOperationsServerCapabilities, WorkspaceServerCapabilities,\n };\n use serde_json::json;\n \n use crate::config::{Config, RustfmtConfig};\n+use crate::lsp_ext::supports_utf8;\n use crate::semantic_tokens;\n \n pub fn server_capabilities(config: &Config) -> ServerCapabilities {\n     ServerCapabilities {\n+        position_encoding: if supports_utf8(config.caps()) {\n+            Some(PositionEncodingKind::UTF8)\n+        } else {\n+            None\n+        },\n         text_document_sync: Some(TextDocumentSyncCapability::Options(TextDocumentSyncOptions {\n             open_close: Some(true),\n             change: Some(TextDocumentSyncKind::INCREMENTAL),"}, {"sha": "5ff347b9bd7227dd886e73bf2b7bec69ce012a30", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/lsif.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -20,7 +20,7 @@ use crate::cli::{\n     load_cargo::{load_workspace, LoadCargoConfig},\n     Result,\n };\n-use crate::line_index::{LineEndings, LineIndex, OffsetEncoding};\n+use crate::line_index::{LineEndings, LineIndex, PositionEncoding};\n use crate::to_proto;\n use crate::version::version;\n \n@@ -126,7 +126,7 @@ impl LsifManager<'_> {\n         let line_index = self.db.line_index(file_id);\n         let line_index = LineIndex {\n             index: line_index,\n-            encoding: OffsetEncoding::Utf16,\n+            encoding: PositionEncoding::Utf16,\n             endings: LineEndings::Unix,\n         };\n         let range_id = self.add_vertex(lsif::Vertex::Range {\n@@ -248,7 +248,7 @@ impl LsifManager<'_> {\n         let line_index = self.db.line_index(file_id);\n         let line_index = LineIndex {\n             index: line_index,\n-            encoding: OffsetEncoding::Utf16,\n+            encoding: PositionEncoding::Utf16,\n             endings: LineEndings::Unix,\n         };\n         let result = folds"}, {"sha": "16298862b50f39fbaee254c76ccb8190ad4ec017", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/scip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -5,7 +5,7 @@ use std::{\n     time::Instant,\n };\n \n-use crate::line_index::{LineEndings, LineIndex, OffsetEncoding};\n+use crate::line_index::{LineEndings, LineIndex, PositionEncoding};\n use hir::Name;\n use ide::{\n     LineCol, MonikerDescriptorKind, StaticIndex, StaticIndexedFile, TextRange, TokenId,\n@@ -91,7 +91,7 @@ impl flags::Scip {\n \n             let line_index = LineIndex {\n                 index: db.line_index(file_id),\n-                encoding: OffsetEncoding::Utf8,\n+                encoding: PositionEncoding::Utf8,\n                 endings: LineEndings::Unix,\n             };\n "}, {"sha": "1ed8f2bb5f35a639e16d7a4b641677ce94ead90c", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -32,7 +32,7 @@ use vfs::AbsPathBuf;\n use crate::{\n     caps::completion_item_edit_resolve,\n     diagnostics::DiagnosticsMapConfig,\n-    line_index::OffsetEncoding,\n+    line_index::PositionEncoding,\n     lsp_ext::{self, supports_utf8, WorkspaceSymbolSearchKind, WorkspaceSymbolSearchScope},\n };\n \n@@ -948,11 +948,11 @@ impl Config {\n         .is_some()\n     }\n \n-    pub fn offset_encoding(&self) -> OffsetEncoding {\n+    pub fn position_encoding(&self) -> PositionEncoding {\n         if supports_utf8(&self.caps) {\n-            OffsetEncoding::Utf8\n+            PositionEncoding::Utf8\n         } else {\n-            OffsetEncoding::Utf16\n+            PositionEncoding::Utf16\n         }\n     }\n "}, {"sha": "189ac2fbf53393a1752ab1c50114803751ae3c58", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics/to_proto.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -8,7 +8,7 @@ use stdx::format_to;\n use vfs::{AbsPath, AbsPathBuf};\n \n use crate::{\n-    global_state::GlobalStateSnapshot, line_index::OffsetEncoding, lsp_ext,\n+    global_state::GlobalStateSnapshot, line_index::PositionEncoding, lsp_ext,\n     to_proto::url_from_abs_path,\n };\n \n@@ -66,17 +66,17 @@ fn location(\n     let uri = url_from_abs_path(&file_name);\n \n     let range = {\n-        let offset_encoding = snap.config.offset_encoding();\n+        let position_encoding = snap.config.position_encoding();\n         lsp_types::Range::new(\n-            position(&offset_encoding, span, span.line_start, span.column_start),\n-            position(&offset_encoding, span, span.line_end, span.column_end),\n+            position(&position_encoding, span, span.line_start, span.column_start),\n+            position(&position_encoding, span, span.line_end, span.column_end),\n         )\n     };\n     lsp_types::Location::new(uri, range)\n }\n \n fn position(\n-    offset_encoding: &OffsetEncoding,\n+    position_encoding: &PositionEncoding,\n     span: &DiagnosticSpan,\n     line_offset: usize,\n     column_offset: usize,\n@@ -93,9 +93,9 @@ fn position(\n             };\n         }\n         let mut char_offset = 0;\n-        let len_func = match offset_encoding {\n-            OffsetEncoding::Utf8 => char::len_utf8,\n-            OffsetEncoding::Utf16 => char::len_utf16,\n+        let len_func = match position_encoding {\n+            PositionEncoding::Utf8 => char::len_utf8,\n+            PositionEncoding::Utf16 => char::len_utf16,\n         };\n         for c in line.text.chars() {\n             char_offset += 1;"}, {"sha": "936957bab4882a41d3cfbdd3b7330c102c7c56e9", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/from_proto.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -8,7 +8,7 @@ use vfs::AbsPathBuf;\n use crate::{\n     from_json,\n     global_state::GlobalStateSnapshot,\n-    line_index::{LineIndex, OffsetEncoding},\n+    line_index::{LineIndex, PositionEncoding},\n     lsp_ext,\n     lsp_utils::invalid_params_error,\n     Result,\n@@ -25,10 +25,10 @@ pub(crate) fn vfs_path(url: &lsp_types::Url) -> Result<vfs::VfsPath> {\n \n pub(crate) fn offset(line_index: &LineIndex, position: lsp_types::Position) -> Result<TextSize> {\n     let line_col = match line_index.encoding {\n-        OffsetEncoding::Utf8 => {\n+        PositionEncoding::Utf8 => {\n             LineCol { line: position.line as u32, col: position.character as u32 }\n         }\n-        OffsetEncoding::Utf16 => {\n+        PositionEncoding::Utf16 => {\n             let line_col =\n                 LineColUtf16 { line: position.line as u32, col: position.character as u32 };\n             line_index.index.to_utf8(line_col)"}, {"sha": "74277ff2e576e45e6fa8501cd702b4c7f479061f", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -383,7 +383,7 @@ impl GlobalStateSnapshot {\n     pub(crate) fn file_line_index(&self, file_id: FileId) -> Cancellable<LineIndex> {\n         let endings = self.vfs.read().1[&file_id];\n         let index = self.analysis.file_line_index(file_id)?;\n-        let res = LineIndex { index, endings, encoding: self.config.offset_encoding() };\n+        let res = LineIndex { index, endings, encoding: self.config.position_encoding() };\n         Ok(res)\n     }\n "}, {"sha": "0d424b915703a7db1e56c56dd22bd955e44cdd81", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/line_index.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fline_index.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -7,15 +7,15 @@\n \n use std::sync::Arc;\n \n-pub enum OffsetEncoding {\n+pub enum PositionEncoding {\n     Utf8,\n     Utf16,\n }\n \n pub(crate) struct LineIndex {\n     pub(crate) index: Arc<ide::LineIndex>,\n     pub(crate) endings: LineEndings,\n-    pub(crate) encoding: OffsetEncoding,\n+    pub(crate) encoding: PositionEncoding,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]"}, {"sha": "8cc5648f3ce0cfb3e9f4f6d369b6553cc3c8a24a", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -3,6 +3,7 @@\n use std::{collections::HashMap, path::PathBuf};\n \n use lsp_types::request::Request;\n+use lsp_types::PositionEncodingKind;\n use lsp_types::{\n     notification::Notification, CodeActionKind, DocumentOnTypeFormattingParams,\n     PartialResultParams, Position, Range, TextDocumentIdentifier, WorkDoneProgressParams,\n@@ -455,7 +456,15 @@ pub(crate) enum CodeLensResolveData {\n }\n \n pub fn supports_utf8(caps: &lsp_types::ClientCapabilities) -> bool {\n-    caps.offset_encoding.as_deref().unwrap_or_default().iter().any(|it| it == \"utf-8\")\n+    match &caps.general {\n+        Some(general) => general\n+            .position_encodings\n+            .as_deref()\n+            .unwrap_or_default()\n+            .iter()\n+            .any(|it| it == &PositionEncodingKind::UTF8),\n+        _ => false,\n+    }\n }\n \n pub enum MoveItem {}"}, {"sha": "c6a4db9a453ac5069a27b3b2f6472ff21e40e997", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -6,7 +6,7 @@ use lsp_server::Notification;\n use crate::{\n     from_proto,\n     global_state::GlobalState,\n-    line_index::{LineEndings, LineIndex, OffsetEncoding},\n+    line_index::{LineEndings, LineIndex, PositionEncoding},\n     LspError,\n };\n \n@@ -140,7 +140,7 @@ pub(crate) fn apply_document_changes(\n         index: Arc::new(ide::LineIndex::new(old_text)),\n         // We don't care about line endings or offset encoding here.\n         endings: LineEndings::Unix,\n-        encoding: OffsetEncoding::Utf16,\n+        encoding: PositionEncoding::Utf16,\n     };\n \n     // The changes we got must be applied sequentially, but can cross lines so we"}, {"sha": "7d10dc5d15b62d1143e2dd07ad18358d642b71c9", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -607,30 +607,34 @@ impl GlobalState {\n \n     /// Handles a request.\n     fn on_request(&mut self, req: Request) {\n-        if self.shutdown_requested {\n-            self.respond(lsp_server::Response::new_err(\n-                req.id,\n-                lsp_server::ErrorCode::InvalidRequest as i32,\n-                \"Shutdown already requested.\".to_owned(),\n-            ));\n-            return;\n-        }\n+        let mut dispatcher = RequestDispatcher { req: Some(req), global_state: self };\n+        dispatcher.on_sync_mut::<lsp_types::request::Shutdown>(|s, ()| {\n+            s.shutdown_requested = true;\n+            Ok(())\n+        });\n+\n+        if let RequestDispatcher { req: Some(req), global_state: this } = &mut dispatcher {\n+            if this.shutdown_requested {\n+                this.respond(lsp_server::Response::new_err(\n+                    req.id.clone(),\n+                    lsp_server::ErrorCode::InvalidRequest as i32,\n+                    \"Shutdown already requested.\".to_owned(),\n+                ));\n+                return;\n+            }\n \n-        // Avoid flashing a bunch of unresolved references during initial load.\n-        if self.workspaces.is_empty() && !self.is_quiescent() {\n-            self.respond(lsp_server::Response::new_err(\n-                req.id,\n-                lsp_server::ErrorCode::ContentModified as i32,\n-                \"waiting for cargo metadata or cargo check\".to_owned(),\n-            ));\n-            return;\n+            // Avoid flashing a bunch of unresolved references during initial load.\n+            if this.workspaces.is_empty() && !this.is_quiescent() {\n+                this.respond(lsp_server::Response::new_err(\n+                    req.id.clone(),\n+                    lsp_server::ErrorCode::ContentModified as i32,\n+                    \"waiting for cargo metadata or cargo check\".to_owned(),\n+                ));\n+                return;\n+            }\n         }\n \n-        RequestDispatcher { req: Some(req), global_state: self }\n-            .on_sync_mut::<lsp_types::request::Shutdown>(|s, ()| {\n-                s.shutdown_requested = true;\n-                Ok(())\n-            })\n+        dispatcher\n             .on_sync_mut::<lsp_ext::ReloadWorkspace>(handlers::handle_workspace_reload)\n             .on_sync_mut::<lsp_ext::MemoryUsage>(handlers::handle_memory_usage)\n             .on_sync_mut::<lsp_ext::ShuffleCrateGraph>(handlers::handle_shuffle_crate_graph)"}, {"sha": "6c84a2069cd5779a439c43e7056f62ea8e8b9fc0", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -21,7 +21,7 @@ use crate::{\n     cargo_target_spec::CargoTargetSpec,\n     config::{CallInfoConfig, Config},\n     global_state::GlobalStateSnapshot,\n-    line_index::{LineEndings, LineIndex, OffsetEncoding},\n+    line_index::{LineEndings, LineIndex, PositionEncoding},\n     lsp_ext,\n     lsp_utils::invalid_params_error,\n     semantic_tokens, Result,\n@@ -30,8 +30,8 @@ use crate::{\n pub(crate) fn position(line_index: &LineIndex, offset: TextSize) -> lsp_types::Position {\n     let line_col = line_index.index.line_col(offset);\n     match line_index.encoding {\n-        OffsetEncoding::Utf8 => lsp_types::Position::new(line_col.line, line_col.col),\n-        OffsetEncoding::Utf16 => {\n+        PositionEncoding::Utf8 => lsp_types::Position::new(line_col.line, line_col.col),\n+        PositionEncoding::Utf16 => {\n             let line_col = line_index.index.to_utf16(line_col);\n             lsp_types::Position::new(line_col.line, line_col.col)\n         }\n@@ -1394,7 +1394,7 @@ fn main() {\n         let line_index = LineIndex {\n             index: Arc::new(ide::LineIndex::new(text)),\n             endings: LineEndings::Unix,\n-            encoding: OffsetEncoding::Utf16,\n+            encoding: PositionEncoding::Utf16,\n         };\n         let converted: Vec<lsp_types::FoldingRange> =\n             folds.into_iter().map(|it| folding_range(text, &line_index, true, it)).collect();"}, {"sha": "5379732ac6c377d3e5fbf23d5c801afd2dd4c960", "filename": "src/tools/rust-analyzer/crates/syntax/rust.ungram", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Frust.ungram?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -51,7 +51,7 @@ TypeArg =\n   Type\n \n AssocTypeArg =\n-  NameRef GenericParamList? (':' TypeBoundList | ('=' Type | ConstArg))\n+  NameRef GenericArgList? (':' TypeBoundList | ('=' Type | ConstArg))\n \n LifetimeArg =\n   Lifetime"}, {"sha": "6cfb98d92fcf289c5a69c4504e69f10e6d31202d", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -120,7 +120,7 @@ pub struct AssocTypeArg {\n impl ast::HasTypeBounds for AssocTypeArg {}\n impl AssocTypeArg {\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n-    pub fn generic_param_list(&self) -> Option<GenericParamList> { support::child(&self.syntax) }\n+    pub fn generic_arg_list(&self) -> Option<GenericArgList> { support::child(&self.syntax) }\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n     pub fn const_arg(&self) -> Option<ConstArg> { support::child(&self.syntax) }\n@@ -142,16 +142,6 @@ impl ConstArg {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct GenericParamList {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl GenericParamList {\n-    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }\n-    pub fn generic_params(&self) -> AstChildren<GenericParam> { support::children(&self.syntax) }\n-    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeBoundList {\n     pub(crate) syntax: SyntaxNode,\n@@ -527,6 +517,16 @@ impl Abi {\n     pub fn extern_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![extern]) }\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct GenericParamList {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl GenericParamList {\n+    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }\n+    pub fn generic_params(&self) -> AstChildren<GenericParam> { support::children(&self.syntax) }\n+    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WhereClause {\n     pub(crate) syntax: SyntaxNode,\n@@ -1834,17 +1834,6 @@ impl AstNode for ConstArg {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for GenericParamList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == GENERIC_PARAM_LIST }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n impl AstNode for TypeBoundList {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_BOUND_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -2153,6 +2142,17 @@ impl AstNode for Abi {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n+impl AstNode for GenericParamList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == GENERIC_PARAM_LIST }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n impl AstNode for WhereClause {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == WHERE_CLAUSE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -4263,11 +4263,6 @@ impl std::fmt::Display for ConstArg {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for GenericParamList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for TypeBoundList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -4408,6 +4403,11 @@ impl std::fmt::Display for Abi {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n+impl std::fmt::Display for GenericParamList {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n impl std::fmt::Display for WhereClause {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)"}, {"sha": "e3a4fdfda90c2f5bf76ef521248a73c2a5161325", "filename": "src/tools/rust-analyzer/docs/dev/architecture.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -479,7 +479,9 @@ It is not cheap enough to enable in prod, and this is a bug which should be fixe\n ### Configurability\n \n rust-analyzer strives to be as configurable as possible while offering reasonable defaults where no configuration exists yet.\n+The rule of thumb is to enable most features by default unless they are buggy or degrade performance too much.\n There will always be features that some people find more annoying than helpful, so giving the users the ability to tweak or disable these is a big part of offering a good user experience.\n+Enabling them by default is a matter of discoverability, as many users end up don't know about some features even though they are presented in the manual.\n Mind the code--architecture gap: at the moment, we are using fewer feature flags than we really should.\n \n ### Serialization"}, {"sha": "fe316fcae9b8817c51402932947cc26a0308bc92", "filename": "src/tools/rust-analyzer/docs/dev/lsp-extensions.md", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Flsp-extensions.md?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -1,5 +1,5 @@\n <!---\n-lsp_ext.rs hash: 7b710095d773b978\n+lsp_ext.rs hash: 62068e53ac202dc8\n \n If you need to change the above hash to make the test pass, please check if you\n need to adjust this doc as well and ping this issue:\n@@ -19,12 +19,6 @@ Requests, which are likely to always remain specific to `rust-analyzer` are unde\n \n If you want to be notified about the changes to this document, subscribe to [#4604](https://github.com/rust-lang/rust-analyzer/issues/4604).\n \n-## UTF-8 offsets\n-\n-rust-analyzer supports clangd's extension for opting into UTF-8 as the coordinate space for offsets (by default, LSP uses UTF-16 offsets).\n-\n-https://clangd.llvm.org/extensions.html#utf-8-offsets\n-\n ## Configuration in `initializationOptions`\n \n **Upstream Issue:** https://github.com/microsoft/language-server-protocol/issues/567"}, {"sha": "312087e4cffef9d6c7d5e74a7590a3d2837522a1", "filename": "src/tools/rust-analyzer/editors/code/src/commands.ts", "status": "modified", "additions": 62, "deletions": 67, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -3,7 +3,7 @@ import * as lc from \"vscode-languageclient\";\n import * as ra from \"./lsp_ext\";\n import * as path from \"path\";\n \n-import { Ctx, Cmd } from \"./ctx\";\n+import { Ctx, Cmd, CtxInit } from \"./ctx\";\n import { applySnippetWorkspaceEdit, applySnippetTextEdits } from \"./snippets\";\n import { spawnSync } from \"child_process\";\n import { RunnableQuickPick, selectRunnable, createTask, createArgs } from \"./run\";\n@@ -16,14 +16,14 @@ import { LINKED_COMMANDS } from \"./client\";\n export * from \"./ast_inspector\";\n export * from \"./run\";\n \n-export function analyzerStatus(ctx: Ctx): Cmd {\n+export function analyzerStatus(ctx: CtxInit): Cmd {\n     const tdcp = new (class implements vscode.TextDocumentContentProvider {\n         readonly uri = vscode.Uri.parse(\"rust-analyzer-status://status\");\n         readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n \n         async provideTextDocumentContent(_uri: vscode.Uri): Promise<string> {\n             if (!vscode.window.activeTextEditor) return \"\";\n-            const client = await ctx.getClient();\n+            const client = ctx.client;\n \n             const params: ra.AnalyzerStatusParams = {};\n             const doc = ctx.activeRustEditor?.document;\n@@ -52,22 +52,17 @@ export function analyzerStatus(ctx: Ctx): Cmd {\n     };\n }\n \n-export function memoryUsage(ctx: Ctx): Cmd {\n+export function memoryUsage(ctx: CtxInit): Cmd {\n     const tdcp = new (class implements vscode.TextDocumentContentProvider {\n         readonly uri = vscode.Uri.parse(\"rust-analyzer-memory://memory\");\n         readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n \n         provideTextDocumentContent(_uri: vscode.Uri): vscode.ProviderResult<string> {\n             if (!vscode.window.activeTextEditor) return \"\";\n \n-            return ctx\n-                .getClient()\n-                .then((it) => it.sendRequest(ra.memoryUsage))\n-                .then((mem: any) => {\n-                    return (\n-                        \"Per-query memory usage:\\n\" + mem + \"\\n(note: database has been cleared)\"\n-                    );\n-                });\n+            return ctx.client.sendRequest(ra.memoryUsage).then((mem: any) => {\n+                return \"Per-query memory usage:\\n\" + mem + \"\\n(note: database has been cleared)\";\n+            });\n         }\n \n         get onDidChange(): vscode.Event<vscode.Uri> {\n@@ -86,18 +81,18 @@ export function memoryUsage(ctx: Ctx): Cmd {\n     };\n }\n \n-export function shuffleCrateGraph(ctx: Ctx): Cmd {\n+export function shuffleCrateGraph(ctx: CtxInit): Cmd {\n     return async () => {\n-        return ctx.getClient().then((it) => it.sendRequest(ra.shuffleCrateGraph));\n+        return ctx.client.sendRequest(ra.shuffleCrateGraph);\n     };\n }\n \n-export function matchingBrace(ctx: Ctx): Cmd {\n+export function matchingBrace(ctx: CtxInit): Cmd {\n     return async () => {\n         const editor = ctx.activeRustEditor;\n         if (!editor) return;\n \n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n \n         const response = await client.sendRequest(ra.matchingBrace, {\n             textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(editor.document),\n@@ -114,12 +109,12 @@ export function matchingBrace(ctx: Ctx): Cmd {\n     };\n }\n \n-export function joinLines(ctx: Ctx): Cmd {\n+export function joinLines(ctx: CtxInit): Cmd {\n     return async () => {\n         const editor = ctx.activeRustEditor;\n         if (!editor) return;\n \n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n \n         const items: lc.TextEdit[] = await client.sendRequest(ra.joinLines, {\n             ranges: editor.selections.map((it) => client.code2ProtocolConverter.asRange(it)),\n@@ -134,19 +129,19 @@ export function joinLines(ctx: Ctx): Cmd {\n     };\n }\n \n-export function moveItemUp(ctx: Ctx): Cmd {\n+export function moveItemUp(ctx: CtxInit): Cmd {\n     return moveItem(ctx, ra.Direction.Up);\n }\n \n-export function moveItemDown(ctx: Ctx): Cmd {\n+export function moveItemDown(ctx: CtxInit): Cmd {\n     return moveItem(ctx, ra.Direction.Down);\n }\n \n-export function moveItem(ctx: Ctx, direction: ra.Direction): Cmd {\n+export function moveItem(ctx: CtxInit, direction: ra.Direction): Cmd {\n     return async () => {\n         const editor = ctx.activeRustEditor;\n         if (!editor) return;\n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n \n         const lcEdits = await client.sendRequest(ra.moveItem, {\n             range: client.code2ProtocolConverter.asRange(editor.selection),\n@@ -161,13 +156,13 @@ export function moveItem(ctx: Ctx, direction: ra.Direction): Cmd {\n     };\n }\n \n-export function onEnter(ctx: Ctx): Cmd {\n+export function onEnter(ctx: CtxInit): Cmd {\n     async function handleKeypress() {\n         const editor = ctx.activeRustEditor;\n \n         if (!editor) return false;\n \n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n         const lcEdits = await client\n             .sendRequest(ra.onEnter, {\n                 textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(\n@@ -193,13 +188,13 @@ export function onEnter(ctx: Ctx): Cmd {\n     };\n }\n \n-export function parentModule(ctx: Ctx): Cmd {\n+export function parentModule(ctx: CtxInit): Cmd {\n     return async () => {\n         const editor = vscode.window.activeTextEditor;\n         if (!editor) return;\n         if (!(isRustDocument(editor.document) || isCargoTomlDocument(editor.document))) return;\n \n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n \n         const locations = await client.sendRequest(ra.parentModule, {\n             textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(editor.document),\n@@ -230,12 +225,12 @@ export function parentModule(ctx: Ctx): Cmd {\n     };\n }\n \n-export function openCargoToml(ctx: Ctx): Cmd {\n+export function openCargoToml(ctx: CtxInit): Cmd {\n     return async () => {\n         const editor = ctx.activeRustEditor;\n         if (!editor) return;\n \n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n         const response = await client.sendRequest(ra.openCargoToml, {\n             textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(editor.document),\n         });\n@@ -251,12 +246,12 @@ export function openCargoToml(ctx: Ctx): Cmd {\n     };\n }\n \n-export function ssr(ctx: Ctx): Cmd {\n+export function ssr(ctx: CtxInit): Cmd {\n     return async () => {\n         const editor = vscode.window.activeTextEditor;\n         if (!editor) return;\n \n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n \n         const position = editor.selection.active;\n         const selections = editor.selections;\n@@ -308,7 +303,7 @@ export function ssr(ctx: Ctx): Cmd {\n     };\n }\n \n-export function serverVersion(ctx: Ctx): Cmd {\n+export function serverVersion(ctx: CtxInit): Cmd {\n     return async () => {\n         if (!ctx.serverPath) {\n             void vscode.window.showWarningMessage(`rust-analyzer server is not running`);\n@@ -324,7 +319,7 @@ export function serverVersion(ctx: Ctx): Cmd {\n // Opens the virtual file that will show the syntax tree\n //\n // The contents of the file come from the `TextDocumentContentProvider`\n-export function syntaxTree(ctx: Ctx): Cmd {\n+export function syntaxTree(ctx: CtxInit): Cmd {\n     const tdcp = new (class implements vscode.TextDocumentContentProvider {\n         readonly uri = vscode.Uri.parse(\"rust-analyzer-syntax-tree://syntaxtree/tree.rast\");\n         readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n@@ -360,7 +355,7 @@ export function syntaxTree(ctx: Ctx): Cmd {\n         ): Promise<string> {\n             const rustEditor = ctx.activeRustEditor;\n             if (!rustEditor) return \"\";\n-            const client = await ctx.getClient();\n+            const client = ctx.client;\n \n             // When the range based query is enabled we take the range of the selection\n             const range =\n@@ -407,7 +402,7 @@ export function syntaxTree(ctx: Ctx): Cmd {\n // Opens the virtual file that will show the HIR of the function containing the cursor position\n //\n // The contents of the file come from the `TextDocumentContentProvider`\n-export function viewHir(ctx: Ctx): Cmd {\n+export function viewHir(ctx: CtxInit): Cmd {\n     const tdcp = new (class implements vscode.TextDocumentContentProvider {\n         readonly uri = vscode.Uri.parse(\"rust-analyzer-hir://viewHir/hir.rs\");\n         readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n@@ -444,7 +439,7 @@ export function viewHir(ctx: Ctx): Cmd {\n             const rustEditor = ctx.activeRustEditor;\n             if (!rustEditor) return \"\";\n \n-            const client = await ctx.getClient();\n+            const client = ctx.client;\n             const params = {\n                 textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(\n                     rustEditor.document\n@@ -473,7 +468,7 @@ export function viewHir(ctx: Ctx): Cmd {\n     };\n }\n \n-export function viewFileText(ctx: Ctx): Cmd {\n+export function viewFileText(ctx: CtxInit): Cmd {\n     const tdcp = new (class implements vscode.TextDocumentContentProvider {\n         readonly uri = vscode.Uri.parse(\"rust-analyzer-file-text://viewFileText/file.rs\");\n         readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n@@ -509,7 +504,7 @@ export function viewFileText(ctx: Ctx): Cmd {\n         ): Promise<string> {\n             const rustEditor = ctx.activeRustEditor;\n             if (!rustEditor) return \"\";\n-            const client = await ctx.getClient();\n+            const client = ctx.client;\n \n             const params = client.code2ProtocolConverter.asTextDocumentIdentifier(\n                 rustEditor.document\n@@ -536,7 +531,7 @@ export function viewFileText(ctx: Ctx): Cmd {\n     };\n }\n \n-export function viewItemTree(ctx: Ctx): Cmd {\n+export function viewItemTree(ctx: CtxInit): Cmd {\n     const tdcp = new (class implements vscode.TextDocumentContentProvider {\n         readonly uri = vscode.Uri.parse(\"rust-analyzer-item-tree://viewItemTree/itemtree.rs\");\n         readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n@@ -572,7 +567,7 @@ export function viewItemTree(ctx: Ctx): Cmd {\n         ): Promise<string> {\n             const rustEditor = ctx.activeRustEditor;\n             if (!rustEditor) return \"\";\n-            const client = await ctx.getClient();\n+            const client = ctx.client;\n \n             const params = {\n                 textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(\n@@ -601,7 +596,7 @@ export function viewItemTree(ctx: Ctx): Cmd {\n     };\n }\n \n-function crateGraph(ctx: Ctx, full: boolean): Cmd {\n+function crateGraph(ctx: CtxInit, full: boolean): Cmd {\n     return async () => {\n         const nodeModulesPath = vscode.Uri.file(path.join(ctx.extensionPath, \"node_modules\"));\n \n@@ -618,7 +613,7 @@ function crateGraph(ctx: Ctx, full: boolean): Cmd {\n         const params = {\n             full: full,\n         };\n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n         const dot = await client.sendRequest(ra.viewCrateGraph, params);\n         const uri = panel.webview.asWebviewUri(nodeModulesPath);\n \n@@ -664,18 +659,18 @@ function crateGraph(ctx: Ctx, full: boolean): Cmd {\n     };\n }\n \n-export function viewCrateGraph(ctx: Ctx): Cmd {\n+export function viewCrateGraph(ctx: CtxInit): Cmd {\n     return crateGraph(ctx, false);\n }\n \n-export function viewFullCrateGraph(ctx: Ctx): Cmd {\n+export function viewFullCrateGraph(ctx: CtxInit): Cmd {\n     return crateGraph(ctx, true);\n }\n \n // Opens the virtual file that will show the syntax tree\n //\n // The contents of the file come from the `TextDocumentContentProvider`\n-export function expandMacro(ctx: Ctx): Cmd {\n+export function expandMacro(ctx: CtxInit): Cmd {\n     function codeFormat(expanded: ra.ExpandedMacro): string {\n         let result = `// Recursive expansion of ${expanded.name}! macro\\n`;\n         result += \"// \" + \"=\".repeat(result.length - 3);\n@@ -691,7 +686,7 @@ export function expandMacro(ctx: Ctx): Cmd {\n         async provideTextDocumentContent(_uri: vscode.Uri): Promise<string> {\n             const editor = vscode.window.activeTextEditor;\n             if (!editor) return \"\";\n-            const client = await ctx.getClient();\n+            const client = ctx.client;\n \n             const position = editor.selection.active;\n \n@@ -723,8 +718,8 @@ export function expandMacro(ctx: Ctx): Cmd {\n     };\n }\n \n-export function reloadWorkspace(ctx: Ctx): Cmd {\n-    return async () => (await ctx.getClient()).sendRequest(ra.reloadWorkspace);\n+export function reloadWorkspace(ctx: CtxInit): Cmd {\n+    return async () => ctx.client.sendRequest(ra.reloadWorkspace);\n }\n \n async function showReferencesImpl(\n@@ -743,13 +738,13 @@ async function showReferencesImpl(\n     }\n }\n \n-export function showReferences(ctx: Ctx): Cmd {\n+export function showReferences(ctx: CtxInit): Cmd {\n     return async (uri: string, position: lc.Position, locations: lc.Location[]) => {\n-        await showReferencesImpl(await ctx.getClient(), uri, position, locations);\n+        await showReferencesImpl(ctx.client, uri, position, locations);\n     };\n }\n \n-export function applyActionGroup(_ctx: Ctx): Cmd {\n+export function applyActionGroup(_ctx: CtxInit): Cmd {\n     return async (actions: { label: string; arguments: lc.CodeAction }[]) => {\n         const selectedAction = await vscode.window.showQuickPick(actions);\n         if (!selectedAction) return;\n@@ -760,9 +755,9 @@ export function applyActionGroup(_ctx: Ctx): Cmd {\n     };\n }\n \n-export function gotoLocation(ctx: Ctx): Cmd {\n+export function gotoLocation(ctx: CtxInit): Cmd {\n     return async (locationLink: lc.LocationLink) => {\n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n         const uri = client.protocol2CodeConverter.asUri(locationLink.targetUri);\n         let range = client.protocol2CodeConverter.asRange(locationLink.targetSelectionRange);\n         // collapse the range to a cursor position\n@@ -772,13 +767,13 @@ export function gotoLocation(ctx: Ctx): Cmd {\n     };\n }\n \n-export function openDocs(ctx: Ctx): Cmd {\n+export function openDocs(ctx: CtxInit): Cmd {\n     return async () => {\n         const editor = vscode.window.activeTextEditor;\n         if (!editor) {\n             return;\n         }\n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n \n         const position = editor.selection.active;\n         const textDocument = { uri: editor.document.uri.toString() };\n@@ -791,16 +786,16 @@ export function openDocs(ctx: Ctx): Cmd {\n     };\n }\n \n-export function cancelFlycheck(ctx: Ctx): Cmd {\n+export function cancelFlycheck(ctx: CtxInit): Cmd {\n     return async () => {\n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n         await client.sendRequest(ra.cancelFlycheck);\n     };\n }\n \n-export function resolveCodeAction(ctx: Ctx): Cmd {\n+export function resolveCodeAction(ctx: CtxInit): Cmd {\n     return async (params: lc.CodeAction) => {\n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n         params.command = undefined;\n         const item = await client?.sendRequest(lc.CodeActionResolveRequest.type, params);\n         if (!item?.edit) {\n@@ -825,13 +820,13 @@ export function resolveCodeAction(ctx: Ctx): Cmd {\n     };\n }\n \n-export function applySnippetWorkspaceEditCommand(_ctx: Ctx): Cmd {\n+export function applySnippetWorkspaceEditCommand(_ctx: CtxInit): Cmd {\n     return async (edit: vscode.WorkspaceEdit) => {\n         await applySnippetWorkspaceEdit(edit);\n     };\n }\n \n-export function run(ctx: Ctx): Cmd {\n+export function run(ctx: CtxInit): Cmd {\n     let prevRunnable: RunnableQuickPick | undefined;\n \n     return async () => {\n@@ -845,11 +840,11 @@ export function run(ctx: Ctx): Cmd {\n     };\n }\n \n-export function peekTests(ctx: Ctx): Cmd {\n+export function peekTests(ctx: CtxInit): Cmd {\n     return async () => {\n         const editor = ctx.activeRustEditor;\n         if (!editor) return;\n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n \n         await vscode.window.withProgress(\n             {\n@@ -878,7 +873,7 @@ export function peekTests(ctx: Ctx): Cmd {\n     };\n }\n \n-export function runSingle(ctx: Ctx): Cmd {\n+export function runSingle(ctx: CtxInit): Cmd {\n     return async (runnable: ra.Runnable) => {\n         const editor = ctx.activeRustEditor;\n         if (!editor) return;\n@@ -895,7 +890,7 @@ export function runSingle(ctx: Ctx): Cmd {\n     };\n }\n \n-export function copyRunCommandLine(ctx: Ctx) {\n+export function copyRunCommandLine(ctx: CtxInit) {\n     let prevRunnable: RunnableQuickPick | undefined;\n     return async () => {\n         const item = await selectRunnable(ctx, prevRunnable);\n@@ -907,7 +902,7 @@ export function copyRunCommandLine(ctx: Ctx) {\n     };\n }\n \n-export function debug(ctx: Ctx): Cmd {\n+export function debug(ctx: CtxInit): Cmd {\n     let prevDebuggee: RunnableQuickPick | undefined;\n \n     return async () => {\n@@ -920,13 +915,13 @@ export function debug(ctx: Ctx): Cmd {\n     };\n }\n \n-export function debugSingle(ctx: Ctx): Cmd {\n+export function debugSingle(ctx: CtxInit): Cmd {\n     return async (config: ra.Runnable) => {\n         await startDebugSession(ctx, config);\n     };\n }\n \n-export function newDebugConfig(ctx: Ctx): Cmd {\n+export function newDebugConfig(ctx: CtxInit): Cmd {\n     return async () => {\n         const item = await selectRunnable(ctx, undefined, true, false);\n         if (!item) return;"}, {"sha": "3e366525ee295392fcdef55b019aa6d511ba5bea", "filename": "src/tools/rust-analyzer/editors/code/src/ctx.ts", "status": "modified", "additions": 126, "deletions": 46, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fctx.ts", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fctx.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fctx.ts?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -4,12 +4,17 @@ import * as ra from \"./lsp_ext\";\n \n import { Config, substituteVariablesInEnv, substituteVSCodeVariables } from \"./config\";\n import { createClient } from \"./client\";\n-import { isRustEditor, log, RustEditor } from \"./util\";\n+import { isRustDocument, isRustEditor, log, RustEditor } from \"./util\";\n import { ServerStatusParams } from \"./lsp_ext\";\n import { PersistentState } from \"./persistent_state\";\n import { bootstrap } from \"./bootstrap\";\n \n+// We only support local folders, not eg. Live Share (`vlsl:` scheme), so don't activate if\n+// only those are in use. We use \"Empty\" to represent these scenarios\n+// (r-a still somewhat works with Live Share, because commands are tunneled to the host)\n+\n export type Workspace =\n+    | { kind: \"Empty\" }\n     | {\n           kind: \"Workspace Folder\";\n       }\n@@ -18,16 +23,39 @@ export type Workspace =\n           files: vscode.TextDocument[];\n       };\n \n+export function fetchWorkspace(): Workspace {\n+    const folders = (vscode.workspace.workspaceFolders || []).filter(\n+        (folder) => folder.uri.scheme === \"file\"\n+    );\n+    const rustDocuments = vscode.workspace.textDocuments.filter((document) =>\n+        isRustDocument(document)\n+    );\n+\n+    return folders.length === 0\n+        ? rustDocuments.length === 0\n+            ? { kind: \"Empty\" }\n+            : {\n+                  kind: \"Detached Files\",\n+                  files: rustDocuments,\n+              }\n+        : { kind: \"Workspace Folder\" };\n+}\n+\n export type CommandFactory = {\n-    enabled: (ctx: Ctx) => Cmd;\n+    enabled: (ctx: CtxInit) => Cmd;\n     disabled?: (ctx: Ctx) => Cmd;\n };\n \n+export type CtxInit = Ctx & {\n+    readonly client: lc.LanguageClient;\n+};\n+\n export class Ctx {\n     readonly statusBar: vscode.StatusBarItem;\n     readonly config: Config;\n+    readonly workspace: Workspace;\n \n-    private client: lc.LanguageClient | undefined;\n+    private _client: lc.LanguageClient | undefined;\n     private _serverPath: string | undefined;\n     private traceOutputChannel: vscode.OutputChannel | undefined;\n     private outputChannel: vscode.OutputChannel | undefined;\n@@ -36,18 +64,17 @@ export class Ctx {\n     private commandFactories: Record<string, CommandFactory>;\n     private commandDisposables: Disposable[];\n \n-    workspace: Workspace;\n+    get client() {\n+        return this._client;\n+    }\n \n     constructor(\n         readonly extCtx: vscode.ExtensionContext,\n-        workspace: Workspace,\n-        commandFactories: Record<string, CommandFactory>\n+        commandFactories: Record<string, CommandFactory>,\n+        workspace: Workspace\n     ) {\n         extCtx.subscriptions.push(this);\n         this.statusBar = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left);\n-        this.statusBar.text = \"rust-analyzer\";\n-        this.statusBar.tooltip = \"ready\";\n-        this.statusBar.command = \"rust-analyzer.analyzerStatus\";\n         this.statusBar.show();\n         this.workspace = workspace;\n         this.clientSubscriptions = [];\n@@ -57,7 +84,10 @@ export class Ctx {\n         this.state = new PersistentState(extCtx.globalState);\n         this.config = new Config(extCtx);\n \n-        this.updateCommands();\n+        this.updateCommands(\"disable\");\n+        this.setServerStatus({\n+            health: \"stopped\",\n+        });\n     }\n \n     dispose() {\n@@ -67,16 +97,36 @@ export class Ctx {\n         this.commandDisposables.forEach((disposable) => disposable.dispose());\n     }\n \n-    clientFetcher() {\n-        const self = this;\n-        return {\n-            get client(): lc.LanguageClient | undefined {\n-                return self.client;\n-            },\n-        };\n+    async onWorkspaceFolderChanges() {\n+        const workspace = fetchWorkspace();\n+        if (workspace.kind === \"Detached Files\" && this.workspace.kind === \"Detached Files\") {\n+            if (workspace.files !== this.workspace.files) {\n+                if (this.client?.isRunning()) {\n+                    // Ideally we wouldn't need to tear down the server here, but currently detached files\n+                    // are only specified at server start\n+                    await this.stopAndDispose();\n+                    await this.start();\n+                }\n+                return;\n+            }\n+        }\n+        if (workspace.kind === \"Workspace Folder\" && this.workspace.kind === \"Workspace Folder\") {\n+            return;\n+        }\n+        if (workspace.kind === \"Empty\") {\n+            await this.stopAndDispose();\n+            return;\n+        }\n+        if (this.client?.isRunning()) {\n+            await this.restart();\n+        }\n     }\n \n-    async getClient() {\n+    private async getOrCreateClient() {\n+        if (this.workspace.kind === \"Empty\") {\n+            return;\n+        }\n+\n         if (!this.traceOutputChannel) {\n             this.traceOutputChannel = vscode.window.createOutputChannel(\n                 \"Rust Analyzer Language Server Trace\"\n@@ -88,7 +138,7 @@ export class Ctx {\n             this.pushExtCleanup(this.outputChannel);\n         }\n \n-        if (!this.client) {\n+        if (!this._client) {\n             this._serverPath = await bootstrap(this.extCtx, this.config, this.state).catch(\n                 (err) => {\n                     let message = \"bootstrap error. \";\n@@ -125,47 +175,61 @@ export class Ctx {\n \n             const initializationOptions = substituteVSCodeVariables(rawInitializationOptions);\n \n-            this.client = await createClient(\n+            this._client = await createClient(\n                 this.traceOutputChannel,\n                 this.outputChannel,\n                 initializationOptions,\n                 serverOptions\n             );\n             this.pushClientCleanup(\n-                this.client.onNotification(ra.serverStatus, (params) =>\n+                this._client.onNotification(ra.serverStatus, (params) =>\n                     this.setServerStatus(params)\n                 )\n             );\n         }\n-        return this.client;\n+        return this._client;\n     }\n \n-    async activate() {\n-        log.info(\"Activating language client\");\n-        const client = await this.getClient();\n+    async start() {\n+        log.info(\"Starting language client\");\n+        const client = await this.getOrCreateClient();\n+        if (!client) {\n+            return;\n+        }\n         await client.start();\n         this.updateCommands();\n-        return client;\n     }\n \n-    async deactivate() {\n-        log.info(\"Deactivating language client\");\n-        await this.client?.stop();\n-        this.updateCommands();\n+    async restart() {\n+        // FIXME: We should re-use the client, that is ctx.deactivate() if none of the configs have changed\n+        await this.stopAndDispose();\n+        await this.start();\n     }\n \n     async stop() {\n+        if (!this._client) {\n+            return;\n+        }\n         log.info(\"Stopping language client\");\n+        this.updateCommands(\"disable\");\n+        await this._client.stop();\n+    }\n+\n+    async stopAndDispose() {\n+        if (!this._client) {\n+            return;\n+        }\n+        log.info(\"Disposing language client\");\n+        this.updateCommands(\"disable\");\n         await this.disposeClient();\n-        this.updateCommands();\n     }\n \n     private async disposeClient() {\n         this.clientSubscriptions?.forEach((disposable) => disposable.dispose());\n         this.clientSubscriptions = [];\n-        await this.client?.dispose();\n+        await this._client?.dispose();\n         this._serverPath = undefined;\n-        this.client = undefined;\n+        this._client = undefined;\n     }\n \n     get activeRustEditor(): RustEditor | undefined {\n@@ -185,32 +249,41 @@ export class Ctx {\n         return this._serverPath;\n     }\n \n-    private updateCommands() {\n+    private updateCommands(forceDisable?: \"disable\") {\n         this.commandDisposables.forEach((disposable) => disposable.dispose());\n         this.commandDisposables = [];\n-        const fetchFactory = (factory: CommandFactory, fullName: string) => {\n-            return this.client && this.client.isRunning()\n-                ? factory.enabled\n-                : factory.disabled ||\n-                      ((_) => () =>\n-                          vscode.window.showErrorMessage(\n-                              `command ${fullName} failed: rust-analyzer server is not running`\n-                          ));\n+\n+        const clientRunning = (!forceDisable && this._client?.isRunning()) ?? false;\n+        const isClientRunning = function (_ctx: Ctx): _ctx is CtxInit {\n+            return clientRunning;\n         };\n+\n         for (const [name, factory] of Object.entries(this.commandFactories)) {\n             const fullName = `rust-analyzer.${name}`;\n-            const callback = fetchFactory(factory, fullName)(this);\n+            let callback;\n+            if (isClientRunning(this)) {\n+                // we asserted that `client` is defined\n+                callback = factory.enabled(this);\n+            } else if (factory.disabled) {\n+                callback = factory.disabled(this);\n+            } else {\n+                callback = () =>\n+                    vscode.window.showErrorMessage(\n+                        `command ${fullName} failed: rust-analyzer server is not running`\n+                    );\n+            }\n+\n             this.commandDisposables.push(vscode.commands.registerCommand(fullName, callback));\n         }\n     }\n \n-    setServerStatus(status: ServerStatusParams) {\n+    setServerStatus(status: ServerStatusParams | { health: \"stopped\" }) {\n         let icon = \"\";\n         const statusBar = this.statusBar;\n         switch (status.health) {\n             case \"ok\":\n-                statusBar.tooltip = status.message ?? \"Ready\";\n-                statusBar.command = undefined;\n+                statusBar.tooltip = (status.message ?? \"Ready\") + \"\\nClick to stop server.\";\n+                statusBar.command = \"rust-analyzer.stopServer\";\n                 statusBar.color = undefined;\n                 statusBar.backgroundColor = undefined;\n                 break;\n@@ -234,6 +307,13 @@ export class Ctx {\n                 statusBar.backgroundColor = new vscode.ThemeColor(\"statusBarItem.errorBackground\");\n                 icon = \"$(error) \";\n                 break;\n+            case \"stopped\":\n+                statusBar.tooltip = \"Server is stopped.\\nClick to start.\";\n+                statusBar.command = \"rust-analyzer.startServer\";\n+                statusBar.color = undefined;\n+                statusBar.backgroundColor = undefined;\n+                statusBar.text = `$(stop-circle) rust-analyzer`;\n+                return;\n         }\n         if (!status.quiescent) icon = \"$(sync~spin) \";\n         statusBar.text = `${icon}rust-analyzer`;"}, {"sha": "e76b657c1bfb50605b1e77f85c329bc08ce06090", "filename": "src/tools/rust-analyzer/editors/code/src/main.ts", "status": "modified", "additions": 19, "deletions": 44, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -2,15 +2,13 @@ import * as vscode from \"vscode\";\n import * as lc from \"vscode-languageclient/node\";\n \n import * as commands from \"./commands\";\n-import { CommandFactory, Ctx, Workspace } from \"./ctx\";\n-import { isRustDocument } from \"./util\";\n+import { CommandFactory, Ctx, fetchWorkspace } from \"./ctx\";\n import { activateTaskProvider } from \"./tasks\";\n import { setContextValue } from \"./util\";\n \n const RUST_PROJECT_CONTEXT_NAME = \"inRustProject\";\n \n export interface RustAnalyzerExtensionApi {\n-    // FIXME: this should be non-optional\n     readonly client?: lc.LanguageClient;\n }\n \n@@ -32,32 +30,7 @@ export async function activate(\n             .then(() => {}, console.error);\n     }\n \n-    // We only support local folders, not eg. Live Share (`vlsl:` scheme), so don't activate if\n-    // only those are in use.\n-    // (r-a still somewhat works with Live Share, because commands are tunneled to the host)\n-    const folders = (vscode.workspace.workspaceFolders || []).filter(\n-        (folder) => folder.uri.scheme === \"file\"\n-    );\n-    const rustDocuments = vscode.workspace.textDocuments.filter((document) =>\n-        isRustDocument(document)\n-    );\n-\n-    if (folders.length === 0 && rustDocuments.length === 0) {\n-        // FIXME: Ideally we would choose not to activate at all (and avoid registering\n-        // non-functional editor commands), but VS Code doesn't seem to have a good way of doing\n-        // that\n-        return {};\n-    }\n-\n-    const workspace: Workspace =\n-        folders.length === 0\n-            ? {\n-                  kind: \"Detached Files\",\n-                  files: rustDocuments,\n-              }\n-            : { kind: \"Workspace Folder\" };\n-\n-    const ctx = new Ctx(context, workspace, createCommands());\n+    const ctx = new Ctx(context, createCommands(), fetchWorkspace());\n     // VS Code doesn't show a notification when an extension fails to activate\n     // so we do it ourselves.\n     const api = await activateServer(ctx).catch((err) => {\n@@ -75,18 +48,23 @@ async function activateServer(ctx: Ctx): Promise<RustAnalyzerExtensionApi> {\n         ctx.pushExtCleanup(activateTaskProvider(ctx.config));\n     }\n \n+    vscode.workspace.onDidChangeWorkspaceFolders(\n+        async (_) => ctx.onWorkspaceFolderChanges(),\n+        null,\n+        ctx.subscriptions\n+    );\n     vscode.workspace.onDidChangeConfiguration(\n         async (_) => {\n-            await ctx\n-                .clientFetcher()\n-                .client?.sendNotification(\"workspace/didChangeConfiguration\", { settings: \"\" });\n+            await ctx.client?.sendNotification(\"workspace/didChangeConfiguration\", {\n+                settings: \"\",\n+            });\n         },\n         null,\n         ctx.subscriptions\n     );\n \n-    await ctx.activate();\n-    return ctx.clientFetcher();\n+    await ctx.start();\n+    return ctx;\n }\n \n function createCommands(): Record<string, CommandFactory> {\n@@ -98,33 +76,30 @@ function createCommands(): Record<string, CommandFactory> {\n         reload: {\n             enabled: (ctx) => async () => {\n                 void vscode.window.showInformationMessage(\"Reloading rust-analyzer...\");\n-                // FIXME: We should re-use the client, that is ctx.deactivate() if none of the configs have changed\n-                await ctx.stop();\n-                await ctx.activate();\n+                await ctx.restart();\n             },\n             disabled: (ctx) => async () => {\n                 void vscode.window.showInformationMessage(\"Reloading rust-analyzer...\");\n-                await ctx.activate();\n+                await ctx.start();\n             },\n         },\n         startServer: {\n             enabled: (ctx) => async () => {\n-                await ctx.activate();\n+                await ctx.start();\n             },\n             disabled: (ctx) => async () => {\n-                await ctx.activate();\n+                await ctx.start();\n             },\n         },\n         stopServer: {\n             enabled: (ctx) => async () => {\n                 // FIXME: We should re-use the client, that is ctx.deactivate() if none of the configs have changed\n-                await ctx.stop();\n+                await ctx.stopAndDispose();\n                 ctx.setServerStatus({\n-                    health: \"ok\",\n-                    quiescent: true,\n-                    message: \"server is not running\",\n+                    health: \"stopped\",\n                 });\n             },\n+            disabled: (_) => async () => {},\n         },\n \n         analyzerStatus: { enabled: commands.analyzerStatus },"}, {"sha": "35627e2fc6beb1b60a1d58ab4712877dc23a6678", "filename": "src/tools/rust-analyzer/editors/code/src/run.ts", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Frun.ts", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Frun.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Frun.ts?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -3,7 +3,7 @@ import * as lc from \"vscode-languageclient\";\n import * as ra from \"./lsp_ext\";\n import * as tasks from \"./tasks\";\n \n-import { Ctx } from \"./ctx\";\n+import { CtxInit } from \"./ctx\";\n import { makeDebugConfig } from \"./debug\";\n import { Config, RunnableEnvCfg } from \"./config\";\n \n@@ -12,15 +12,15 @@ const quickPickButtons = [\n ];\n \n export async function selectRunnable(\n-    ctx: Ctx,\n+    ctx: CtxInit,\n     prevRunnable?: RunnableQuickPick,\n     debuggeeOnly = false,\n     showButtons: boolean = true\n ): Promise<RunnableQuickPick | undefined> {\n     const editor = ctx.activeRustEditor;\n     if (!editor) return;\n \n-    const client = await ctx.getClient();\n+    const client = ctx.client;\n     const textDocument: lc.TextDocumentIdentifier = {\n         uri: editor.document.uri.toString(),\n     };"}, {"sha": "9bba9e87ecb554f34d8b9b3a0ef6dd0314728531", "filename": "src/tools/rust-analyzer/lib/lsp-server/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Flib%2Flsp-server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5/src%2Ftools%2Frust-analyzer%2Flib%2Flsp-server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Flib%2Flsp-server%2FCargo.toml?ref=ab5a2bc7316012ee9b2a4a4f3821673f2677f3d5", "patch": "@@ -13,4 +13,4 @@ serde = { version = \"1.0.144\", features = [\"derive\"] }\n crossbeam-channel = \"0.5.6\"\n \n [dev-dependencies]\n-lsp-types = \"0.93.1\"\n+lsp-types = \"=0.93.2\""}]}