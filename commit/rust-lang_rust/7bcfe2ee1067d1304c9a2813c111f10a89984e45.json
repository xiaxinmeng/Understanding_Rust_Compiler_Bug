{"sha": "7bcfe2ee1067d1304c9a2813c111f10a89984e45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiY2ZlMmVlMTA2N2QxMzA0YzlhMjgxM2MxMTFmMTBhODk5ODRlNDU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-03-28T17:29:55Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-04-04T03:28:55Z"}, "message": "std: Remove `RefCell::get()`\n\nIt's surprising that `RefCell::get()` is implicitly doing a clone\non a value. This patch removes it and replaces all users with\neither `.borrow()` when we can autoderef, or `.borrow().clone()`\nwhen we cannot.", "tree": {"sha": "a42fc0ceadbf33bdfc722236697b65b9688b817e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a42fc0ceadbf33bdfc722236697b65b9688b817e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bcfe2ee1067d1304c9a2813c111f10a89984e45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bcfe2ee1067d1304c9a2813c111f10a89984e45", "html_url": "https://github.com/rust-lang/rust/commit/7bcfe2ee1067d1304c9a2813c111f10a89984e45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bcfe2ee1067d1304c9a2813c111f10a89984e45/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb31cb8d2e4e415cbb71d368918d72902e655e01", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb31cb8d2e4e415cbb71d368918d72902e655e01", "html_url": "https://github.com/rust-lang/rust/commit/bb31cb8d2e4e415cbb71d368918d72902e655e01"}], "stats": {"total": 134, "additions": 66, "deletions": 68}, "files": [{"sha": "82e2e3147c93db1b0b39b18f39def54c789028d3", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=7bcfe2ee1067d1304c9a2813c111f10a89984e45", "patch": "@@ -90,7 +90,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n     fn fold_item(&mut self, i: @ast::Item) -> SmallVector<@ast::Item> {\n         self.cx.path.borrow_mut().push(i.ident);\n         debug!(\"current path: {}\",\n-               ast_util::path_name_i(self.cx.path.get().as_slice()));\n+               ast_util::path_name_i(self.cx.path.borrow().as_slice()));\n \n         if is_test_fn(&self.cx, i) || is_bench_fn(&self.cx, i) {\n             match i.node {\n@@ -104,7 +104,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n                     debug!(\"this is a test function\");\n                     let test = Test {\n                         span: i.span,\n-                        path: self.cx.path.get(),\n+                        path: self.cx.path.borrow().clone(),\n                         bench: is_bench_fn(&self.cx, i),\n                         ignore: is_ignored(&self.cx, i),\n                         should_fail: should_fail(i)"}, {"sha": "b7cba60abe6432c58b00bd6ecd16e91fd4a57cd9", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=7bcfe2ee1067d1304c9a2813c111f10a89984e45", "patch": "@@ -1345,7 +1345,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n     }\n \n     ebml_w.end_tag();\n-    return /*bad*/(*index).get();\n+    return /*bad*/index.borrow().clone();\n }\n \n \n@@ -1365,7 +1365,7 @@ fn create_index<T:Clone + Hash + 'static>(\n \n     let mut buckets_frozen = Vec::new();\n     for bucket in buckets.iter() {\n-        buckets_frozen.push(@/*bad*/(**bucket).get());\n+        buckets_frozen.push(@/*bad*/bucket.borrow().clone());\n     }\n     return buckets_frozen;\n }"}, {"sha": "d0bf70ea1c2c10c45b39ca6eaf573d9c1c20f645", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=7bcfe2ee1067d1304c9a2813c111f10a89984e45", "patch": "@@ -270,7 +270,7 @@ fn create_and_seed_worklist(tcx: &ty::ctxt,\n     }\n \n     // Seed entry point\n-    match tcx.sess.entry_fn.get() {\n+    match *tcx.sess.entry_fn.borrow() {\n         Some((id, _)) => worklist.push(id),\n         None => ()\n     }"}, {"sha": "526ec66800a1614b819696612d78e9223a6a0794", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 38, "deletions": 29, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=7bcfe2ee1067d1304c9a2813c111f10a89984e45", "patch": "@@ -385,6 +385,10 @@ struct ImportResolution {\n     type_id: Cell<NodeId>,\n }\n \n+fn get<T: Clone>(cell: &RefCell<T>) -> T {\n+    cell.borrow().clone()\n+}\n+\n impl ImportResolution {\n     fn new(id: NodeId, is_public: bool) -> ImportResolution {\n         ImportResolution {\n@@ -400,8 +404,8 @@ impl ImportResolution {\n     fn target_for_namespace(&self, namespace: Namespace)\n                                 -> Option<Target> {\n         match namespace {\n-            TypeNS      => return self.type_target.get(),\n-            ValueNS     => return self.value_target.get(),\n+            TypeNS      => return self.type_target.borrow().clone(),\n+            ValueNS     => return self.value_target.borrow().clone(),\n         }\n     }\n \n@@ -546,7 +550,8 @@ impl NameBindings {\n         // Merges the module with the existing type def or creates a new one.\n         let module_ = @Module::new(parent_link, def_id, kind, external,\n                                        is_public);\n-        match self.type_def.get() {\n+        let type_def = self.type_def.borrow().clone();\n+        match type_def {\n             None => {\n                 self.type_def.set(Some(TypeNsDef {\n                     is_public: is_public,\n@@ -574,7 +579,8 @@ impl NameBindings {\n                        external: bool,\n                        is_public: bool,\n                        _sp: Span) {\n-        match self.type_def.get() {\n+        let type_def = self.type_def.borrow().clone();\n+        match type_def {\n             None => {\n                 let module = @Module::new(parent_link, def_id, kind,\n                                               external, is_public);\n@@ -609,7 +615,8 @@ impl NameBindings {\n     /// Records a type definition.\n     fn define_type(&self, def: Def, sp: Span, is_public: bool) {\n         // Merges the type with the existing type def or creates a new one.\n-        match self.type_def.get() {\n+        let type_def = self.type_def.borrow().clone();\n+        match type_def {\n             None => {\n                 self.type_def.set(Some(TypeNsDef {\n                     module_def: None,\n@@ -662,17 +669,17 @@ impl NameBindings {\n \n     fn defined_in_namespace(&self, namespace: Namespace) -> bool {\n         match namespace {\n-            TypeNS   => return self.type_def.get().is_some(),\n-            ValueNS  => return self.value_def.get().is_some()\n+            TypeNS   => return self.type_def.borrow().is_some(),\n+            ValueNS  => return self.value_def.borrow().is_some()\n         }\n     }\n \n     fn defined_in_public_namespace(&self, namespace: Namespace) -> bool {\n         match namespace {\n-            TypeNS => match self.type_def.get() {\n+            TypeNS => match *self.type_def.borrow() {\n                 Some(def) => def.is_public, None => false\n             },\n-            ValueNS => match self.value_def.get() {\n+            ValueNS => match *self.value_def.borrow() {\n                 Some(def) => def.is_public, None => false\n             }\n         }\n@@ -681,7 +688,7 @@ impl NameBindings {\n     fn def_for_namespace(&self, namespace: Namespace) -> Option<Def> {\n         match namespace {\n             TypeNS => {\n-                match self.type_def.get() {\n+                match *self.type_def.borrow() {\n                     None => None,\n                     Some(type_def) => {\n                         match type_def.type_def {\n@@ -702,7 +709,7 @@ impl NameBindings {\n                 }\n             }\n             ValueNS => {\n-                match self.value_def.get() {\n+                match *self.value_def.borrow() {\n                     None => None,\n                     Some(value_def) => Some(value_def.def)\n                 }\n@@ -714,13 +721,13 @@ impl NameBindings {\n         if self.defined_in_namespace(namespace) {\n             match namespace {\n                 TypeNS  => {\n-                    match self.type_def.get() {\n+                    match *self.type_def.borrow() {\n                         None => None,\n                         Some(type_def) => type_def.type_span\n                     }\n                 }\n                 ValueNS => {\n-                    match self.value_def.get() {\n+                    match *self.value_def.borrow() {\n                         None => None,\n                         Some(value_def) => value_def.value_span\n                     }\n@@ -1620,7 +1627,8 @@ impl<'a> Resolver<'a> {\n         match def {\n           DefMod(def_id) | DefForeignMod(def_id) | DefStruct(def_id) |\n           DefTy(def_id) => {\n-            match child_name_bindings.type_def.get() {\n+            let type_def = child_name_bindings.type_def.borrow().clone();\n+            match type_def {\n               Some(TypeNsDef { module_def: Some(module_def), .. }) => {\n                 debug!(\"(building reduced graph for external crate) \\\n                         already created module\");\n@@ -1812,7 +1820,8 @@ impl<'a> Resolver<'a> {\n                                 // Process the static methods. First,\n                                 // create the module.\n                                 let type_module;\n-                                match child_name_bindings.type_def.get() {\n+                                let type_def = child_name_bindings.type_def.borrow().clone();\n+                                match type_def {\n                                     Some(TypeNsDef {\n                                         module_def: Some(module_def),\n                                         ..\n@@ -2421,7 +2430,7 @@ impl<'a> Resolver<'a> {\n         match type_result {\n             BoundResult(target_module, name_bindings) => {\n                 debug!(\"(resolving single import) found type target: {:?}\",\n-                       {name_bindings.type_def.get().unwrap().type_def});\n+                       { name_bindings.type_def.borrow().clone().unwrap().type_def });\n                 import_resolution.type_target.set(\n                     Some(Target::new(target_module, name_bindings)));\n                 import_resolution.type_id.set(directive.id);\n@@ -2433,8 +2442,8 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        if import_resolution.value_target.get().is_none() &&\n-           import_resolution.type_target.get().is_none() {\n+        if import_resolution.value_target.borrow().is_none() &&\n+           import_resolution.type_target.borrow().is_none() {\n             let msg = format!(\"unresolved import: there is no \\\n                                `{}` in `{}`\",\n                               token::get_ident(source),\n@@ -2452,7 +2461,7 @@ impl<'a> Resolver<'a> {\n         // record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n-        let value_private = match import_resolution.value_target.get() {\n+        let value_private = match *import_resolution.value_target.borrow() {\n             Some(target) => {\n                 let def = target.bindings.def_for_namespace(ValueNS).unwrap();\n                 self.def_map.borrow_mut().insert(directive.id, def);\n@@ -2463,7 +2472,7 @@ impl<'a> Resolver<'a> {\n             // _exists is false.\n             None => None,\n         };\n-        let type_private = match import_resolution.type_target.get() {\n+        let type_private = match *import_resolution.type_target.borrow() {\n             Some(target) => {\n                 let def = target.bindings.def_for_namespace(TypeNS).unwrap();\n                 self.def_map.borrow_mut().insert(directive.id, def);\n@@ -2513,7 +2522,7 @@ impl<'a> Resolver<'a> {\n         for (ident, target_import_resolution) in import_resolutions.iter() {\n             debug!(\"(resolving glob import) writing module resolution \\\n                     {:?} into `{}`\",\n-                   target_import_resolution.type_target.get().is_none(),\n+                   target_import_resolution.type_target.borrow().is_none(),\n                    self.module_to_str(module_));\n \n             if !target_import_resolution.is_public.get() {\n@@ -2529,9 +2538,9 @@ impl<'a> Resolver<'a> {\n                     let new_import_resolution =\n                         @ImportResolution::new(id, is_public);\n                     new_import_resolution.value_target.set(\n-                        target_import_resolution.value_target.get());\n+                        get(&target_import_resolution.value_target));\n                     new_import_resolution.type_target.set(\n-                        target_import_resolution.type_target.get());\n+                        get(&target_import_resolution.type_target));\n \n                     import_resolutions.insert\n                         (*ident, new_import_resolution);\n@@ -2540,7 +2549,7 @@ impl<'a> Resolver<'a> {\n                     // Merge the two import resolutions at a finer-grained\n                     // level.\n \n-                    match target_import_resolution.value_target.get() {\n+                    match *target_import_resolution.value_target.borrow() {\n                         None => {\n                             // Continue.\n                         }\n@@ -2549,7 +2558,7 @@ impl<'a> Resolver<'a> {\n                                 Some(value_target));\n                         }\n                     }\n-                    match target_import_resolution.type_target.get() {\n+                    match *target_import_resolution.type_target.borrow() {\n                         None => {\n                             // Continue.\n                         }\n@@ -2692,7 +2701,7 @@ impl<'a> Resolver<'a> {\n                 Success((target, used_proxy)) => {\n                     // Check to see whether there are type bindings, and, if\n                     // so, whether there is a module within.\n-                    match target.bindings.type_def.get() {\n+                    match *target.bindings.type_def.borrow() {\n                         Some(type_def) => {\n                             match type_def.module_def {\n                                 None => {\n@@ -3004,7 +3013,7 @@ impl<'a> Resolver<'a> {\n         match resolve_result {\n             Success((target, _)) => {\n                 let bindings = &*target.bindings;\n-                match bindings.type_def.get() {\n+                match *bindings.type_def.borrow() {\n                     Some(type_def) => {\n                         match type_def.module_def {\n                             None => {\n@@ -4526,8 +4535,8 @@ impl<'a> Resolver<'a> {\n                 debug!(\"(resolve bare identifier pattern) succeeded in \\\n                          finding {} at {:?}\",\n                         token::get_ident(name),\n-                        target.bindings.value_def.get());\n-                match target.bindings.value_def.get() {\n+                        target.bindings.value_def.borrow());\n+                match *target.bindings.value_def.borrow() {\n                     None => {\n                         fail!(\"resolved name in the value namespace to a \\\n                               set of name bindings with no def?!\");"}, {"sha": "2f4163e8296f47b7cee6cbe4820102b005661ebd", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=7bcfe2ee1067d1304c9a2813c111f10a89984e45", "patch": "@@ -1128,7 +1128,7 @@ pub fn make_return_pointer(fcx: &FunctionContext, output_type: ty::t)\n             llvm::LLVMGetParam(fcx.llfn, 0)\n         } else {\n             let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n-            let bcx = fcx.entry_bcx.get().unwrap();\n+            let bcx = fcx.entry_bcx.borrow().clone().unwrap();\n             Alloca(bcx, lloutputtype, \"__make_return_pointer\")\n         }\n     }\n@@ -1399,7 +1399,7 @@ pub fn trans_closure(ccx: &CrateContext,\n \n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n-    let bcx_top = fcx.entry_bcx.get().unwrap();\n+    let bcx_top = fcx.entry_bcx.borrow().clone().unwrap();\n     let mut bcx = bcx_top;\n     let block_ty = node_id_type(bcx, body.id);\n \n@@ -1547,7 +1547,7 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n \n     let arg_datums = create_datums_for_fn_args(&fcx, arg_tys.as_slice());\n \n-    let bcx = fcx.entry_bcx.get().unwrap();\n+    let bcx = fcx.entry_bcx.borrow().clone().unwrap();\n \n     if !type_is_zero_size(fcx.ccx, result_ty) {\n         let repr = adt::represent_type(ccx, result_ty);\n@@ -1752,7 +1752,7 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n }\n \n pub fn is_entry_fn(sess: &Session, node_id: ast::NodeId) -> bool {\n-    match sess.entry_fn.get() {\n+    match *sess.entry_fn.borrow() {\n         Some((entry_id, _)) => node_id == entry_id,\n         None => false\n     }"}, {"sha": "4671e21170e869bea654b35e18d8cd5c2db5ab51", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=7bcfe2ee1067d1304c9a2813c111f10a89984e45", "patch": "@@ -464,7 +464,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n     let arena = TypedArena::new();\n     let fcx = new_fn_ctxt(ccx, llfn, -1, true, f.sig.output, None, None, &arena);\n     init_function(&fcx, true, f.sig.output, None);\n-    let bcx = fcx.entry_bcx.get().unwrap();\n+    let bcx = fcx.entry_bcx.borrow().clone().unwrap();\n \n     let args = create_datums_for_fn_args(&fcx,\n                                          ty::ty_fn_args(closure_ty)"}, {"sha": "87234ce3683531907f91b501a7c71a700cc54d77", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=7bcfe2ee1067d1304c9a2813c111f10a89984e45", "patch": "@@ -463,7 +463,7 @@ fn make_generic_glue(ccx: &CrateContext,\n     // llfn is expected be declared to take a parameter of the appropriate\n     // type, so we don't need to explicitly cast the function parameter.\n \n-    let bcx = fcx.entry_bcx.get().unwrap();\n+    let bcx = fcx.entry_bcx.borrow().clone().unwrap();\n     let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, fcx.arg_pos(0) as c_uint) };\n     let bcx = helper(bcx, llrawptr0, t);\n     finish_fn(&fcx, bcx);"}, {"sha": "28a39718e7fb6a32b6a79d300cd04cd941e89d5e", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=7bcfe2ee1067d1304c9a2813c111f10a89984e45", "patch": "@@ -199,7 +199,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n \n     set_always_inline(fcx.llfn);\n \n-    let mut bcx = fcx.entry_bcx.get().unwrap();\n+    let mut bcx = fcx.entry_bcx.borrow().clone().unwrap();\n     let first_real_arg = fcx.arg_pos(0u);\n \n     let name = token::get_ident(item.ident);"}, {"sha": "41d8b05c6eae1f58af32cd30bf0355c28f82729d", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=7bcfe2ee1067d1304c9a2813c111f10a89984e45", "patch": "@@ -300,7 +300,7 @@ impl<'a> Reflector<'a> {\n                     //\n                     llvm::LLVMGetParam(llfdecl, fcx.arg_pos(0u) as c_uint)\n                 };\n-                let bcx = fcx.entry_bcx.get().unwrap();\n+                let bcx = fcx.entry_bcx.borrow().clone().unwrap();\n                 let arg = BitCast(bcx, arg, llptrty);\n                 let ret = adt::trans_get_discr(bcx, repr, arg, Some(Type::i64(ccx)));\n                 Store(bcx, ret, fcx.llretptr.get().unwrap());"}, {"sha": "bbf2e60dfe325dd5b36f5912e5988538c1fd5acf", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=7bcfe2ee1067d1304c9a2813c111f10a89984e45", "patch": "@@ -2209,8 +2209,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         fcx.write_ty(expr.id, fty);\n \n         let (inherited_purity, id) =\n-            ty::determine_inherited_purity((fcx.ps.get().purity,\n-                                            fcx.ps.get().def),\n+            ty::determine_inherited_purity((fcx.ps.borrow().purity,\n+                                            fcx.ps.borrow().def),\n                                            (purity, expr.id),\n                                            sigil);\n "}, {"sha": "c8613fd70652ee60e8f5909de52c6c4029ea69de", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=7bcfe2ee1067d1304c9a2813c111f10a89984e45", "patch": "@@ -398,7 +398,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n            expr.repr(rcx.fcx.tcx()), rcx.repeating_scope);\n \n     let method_call = MethodCall::expr(expr.id);\n-    let has_method_map = rcx.fcx.inh.method_map.get().contains_key(&method_call);\n+    let has_method_map = rcx.fcx.inh.method_map.borrow().contains_key(&method_call);\n \n     // Check any autoderefs or autorefs that appear.\n     for &adjustment in rcx.fcx.inh.adjustments.borrow().find(&expr.id).iter() {\n@@ -498,7 +498,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         ast::ExprUnary(ast::UnDeref, base) => {\n             // For *a, the lifetime of a must enclose the deref\n             let method_call = MethodCall::expr(expr.id);\n-            let base_ty = match rcx.fcx.inh.method_map.get().find(&method_call) {\n+            let base_ty = match rcx.fcx.inh.method_map.borrow().find(&method_call) {\n                 Some(method) => {\n                     constrain_call(rcx, None, expr, Some(base), [], true);\n                     ty::ty_fn_ret(method.ty)\n@@ -852,7 +852,7 @@ fn constrain_autoderefs(rcx: &mut Rcx,\n                i, derefs);\n \n         let method_call = MethodCall::autoderef(deref_expr.id, i as u32);\n-        derefd_ty = match rcx.fcx.inh.method_map.get().find(&method_call) {\n+        derefd_ty = match rcx.fcx.inh.method_map.borrow().find(&method_call) {\n             Some(method) => {\n                 // Treat overloaded autoderefs as if an AutoRef adjustment\n                 // was applied on the base type, as that is always the case."}, {"sha": "9c947fb3360e455014adeb480934f15f3fad864e", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=7bcfe2ee1067d1304c9a2813c111f10a89984e45", "patch": "@@ -1286,6 +1286,6 @@ impl LifeGiver {\n     }\n \n     fn get_generated_lifetimes(&self) -> Vec<ast::Lifetime> {\n-        self.generated.get()\n+        self.generated.borrow().clone()\n     }\n }"}, {"sha": "edfd9b43865842bda2f55949845782f3d340013e", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=7bcfe2ee1067d1304c9a2813c111f10a89984e45", "patch": "@@ -431,7 +431,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n fn check_for_entry_fn(ccx: &CrateCtxt) {\n     let tcx = ccx.tcx;\n     if !tcx.sess.building_library.get() {\n-        match tcx.sess.entry_fn.get() {\n+        match *tcx.sess.entry_fn.borrow() {\n           Some((id, sp)) => match tcx.sess.entry_type.get() {\n               Some(session::EntryMain) => check_main_fn_ty(ccx, id, sp),\n               Some(session::EntryStart) => check_start_fn_ty(ccx, id, sp),"}, {"sha": "ec6994728f70666ab6dfb4e158210b49515363e1", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=7bcfe2ee1067d1304c9a2813c111f10a89984e45", "patch": "@@ -176,21 +176,9 @@ impl<T> RefCell<T> {\n     }\n }\n \n-impl<T:Clone> RefCell<T> {\n-    /// Returns a copy of the contained value.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value is currently mutably borrowed.\n-    #[inline]\n-    pub fn get(&self) -> T {\n-        (*self.borrow()).clone()\n-    }\n-}\n-\n impl<T: Clone> Clone for RefCell<T> {\n     fn clone(&self) -> RefCell<T> {\n-        RefCell::new(self.get())\n+        RefCell::new(self.borrow().clone())\n     }\n }\n \n@@ -216,7 +204,7 @@ impl<'b, T> Drop for Ref<'b, T> {\n impl<'b, T> Deref<T> for Ref<'b, T> {\n     #[inline]\n     fn deref<'a>(&'a self) -> &'a T {\n-        unsafe{ &*self.parent.value.get() }\n+        unsafe { &*self.parent.value.get() }\n     }\n }\n \n@@ -236,14 +224,14 @@ impl<'b, T> Drop for RefMut<'b, T> {\n impl<'b, T> Deref<T> for RefMut<'b, T> {\n     #[inline]\n     fn deref<'a>(&'a self) -> &'a T {\n-        unsafe{ &*self.parent.value.get() }\n+        unsafe { &*self.parent.value.get() }\n     }\n }\n \n impl<'b, T> DerefMut<T> for RefMut<'b, T> {\n     #[inline]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n-        unsafe{ &mut *self.parent.value.get() }\n+        unsafe { &mut *self.parent.value.get() }\n     }\n }\n "}, {"sha": "ce2c1378fc1a2ceb3579a8beb0cbe72f7e0eaa96", "filename": "src/libstd/option.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=7bcfe2ee1067d1304c9a2813c111f10a89984e45", "patch": "@@ -651,7 +651,8 @@ mod tests {\n         impl ::ops::Drop for R {\n            fn drop(&mut self) {\n                 let ii = &*self.i;\n-                ii.set(ii.get() + 1);\n+                let i = ii.borrow().clone();\n+                ii.set(i + 1);\n             }\n         }\n \n@@ -667,7 +668,7 @@ mod tests {\n             let opt = Some(x);\n             let _y = opt.unwrap();\n         }\n-        assert_eq!(i.get(), 1);\n+        assert_eq!(*i.borrow(), 1);\n     }\n \n     #[test]"}, {"sha": "e61510f2ef2d8e8136fa284c8d9cf516705e8751", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bcfe2ee1067d1304c9a2813c111f10a89984e45/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=7bcfe2ee1067d1304c9a2813c111f10a89984e45", "patch": "@@ -21,5 +21,5 @@ pub type header_map = HashMap<~str, @RefCell<Vec<@~str>>>;\n \n // the unused ty param is necessary so this gets monomorphized\n pub fn request<T>(req: &header_map) {\n-  let _x = (**((**req.get(&~\"METHOD\")).clone()).get().get(0)).clone();\n+  let _x = (**((**req.get(&~\"METHOD\")).clone()).borrow().clone().get(0)).clone();\n }"}]}