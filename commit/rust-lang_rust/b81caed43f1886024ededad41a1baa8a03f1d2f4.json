{"sha": "b81caed43f1886024ededad41a1baa8a03f1d2f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MWNhZWQ0M2YxODg2MDI0ZWRlZGFkNDFhMWJhYThhMDNmMWQyZjQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-06-16T12:00:41Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-06-16T12:00:41Z"}, "message": "Merge #1408\n\n1408: Associated type basics & Deref support r=matklad a=flodiebold\n\nThis adds the necessary Chalk integration to handle associated types and uses it to implement support for `Deref` in the `*` operator and autoderef; so e.g. dot completions through an `Arc` work now.\r\n\r\nIt doesn't yet implement resolution of associated types in paths, though. Also, there's a big FIXME about handling variables in the solution we get from Chalk correctly.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "0a0289899ec59b425eae6369929a01e97065ce43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a0289899ec59b425eae6369929a01e97065ce43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b81caed43f1886024ededad41a1baa8a03f1d2f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b81caed43f1886024ededad41a1baa8a03f1d2f4", "html_url": "https://github.com/rust-lang/rust/commit/b81caed43f1886024ededad41a1baa8a03f1d2f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b81caed43f1886024ededad41a1baa8a03f1d2f4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "e6fbff3246cdd3278ff1c376d5abfc1d579f86c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6fbff3246cdd3278ff1c376d5abfc1d579f86c2", "html_url": "https://github.com/rust-lang/rust/commit/e6fbff3246cdd3278ff1c376d5abfc1d579f86c2"}, {"sha": "ad3673d8d86a9b8f1a8dba858abd7cabaa1d5776", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad3673d8d86a9b8f1a8dba858abd7cabaa1d5776", "html_url": "https://github.com/rust-lang/rust/commit/ad3673d8d86a9b8f1a8dba858abd7cabaa1d5776"}], "stats": {"total": 524, "additions": 454, "deletions": 70}, "files": [{"sha": "167c620a397d72b373bfe3a38035cfac52a90b9f", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b81caed43f1886024ededad41a1baa8a03f1d2f4/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b81caed43f1886024ededad41a1baa8a03f1d2f4/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b81caed43f1886024ededad41a1baa8a03f1d2f4", "patch": "@@ -1080,6 +1080,7 @@ dependencies = [\n  \"flexi_logger 0.11.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"insta 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"once_cell 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "c7a8bce20250bc9be86a95e2facfe6a64984b619", "filename": "crates/ra_assists/src/fill_match_arms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs?ref=b81caed43f1886024ededad41a1baa8a03f1d2f4", "patch": "@@ -22,7 +22,7 @@ pub(crate) fn fill_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<As\n     let expr = match_expr.expr()?;\n     let analyzer = hir::SourceAnalyzer::new(ctx.db, ctx.frange.file_id, expr.syntax(), None);\n     let match_expr_ty = analyzer.type_of(ctx.db, expr)?;\n-    let enum_def = match_expr_ty.autoderef(ctx.db).find_map(|ty| match ty.as_adt() {\n+    let enum_def = analyzer.autoderef(ctx.db, match_expr_ty).find_map(|ty| match ty.as_adt() {\n         Some((AdtDef::Enum(e), _)) => Some(e),\n         _ => None,\n     })?;"}, {"sha": "aaace85e5f8b31e307314c10b777059ab04b7edb", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=b81caed43f1886024ededad41a1baa8a03f1d2f4", "patch": "@@ -25,6 +25,7 @@ ra_prof = { path = \"../ra_prof\" }\n chalk-solve = { git = \"https://github.com/flodiebold/chalk.git\", branch = \"fuel\" }\n chalk-rust-ir = { git = \"https://github.com/flodiebold/chalk.git\", branch = \"fuel\" }\n chalk-ir = { git = \"https://github.com/flodiebold/chalk.git\", branch = \"fuel\" }\n+lalrpop-intern = \"0.15.1\"\n \n [dev-dependencies]\n flexi_logger = \"0.11.0\""}, {"sha": "6602d12203f40d3b87e883ec54d91737c66c4a9d", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=b81caed43f1886024ededad41a1baa8a03f1d2f4", "patch": "@@ -779,6 +779,18 @@ impl Trait {\n         self.trait_data(db).items().to_vec()\n     }\n \n+    pub fn associated_type_by_name(self, db: &impl DefDatabase, name: Name) -> Option<TypeAlias> {\n+        let trait_data = self.trait_data(db);\n+        trait_data\n+            .items()\n+            .iter()\n+            .filter_map(|item| match item {\n+                TraitItem::TypeAlias(t) => Some(*t),\n+                _ => None,\n+            })\n+            .find(|t| t.name(db) == name)\n+    }\n+\n     pub(crate) fn trait_data(self, db: &impl DefDatabase) -> Arc<TraitData> {\n         db.trait_data(self)\n     }\n@@ -831,8 +843,12 @@ impl TypeAlias {\n         }\n     }\n \n-    pub fn type_ref(self, db: &impl DefDatabase) -> Arc<TypeRef> {\n-        db.type_alias_ref(self)\n+    pub fn type_ref(self, db: &impl DefDatabase) -> Option<TypeRef> {\n+        db.type_alias_data(self).type_ref.clone()\n+    }\n+\n+    pub fn name(self, db: &impl DefDatabase) -> Name {\n+        db.type_alias_data(self).name.clone()\n     }\n \n     /// Builds a resolver for the type references in this type alias."}, {"sha": "c4dd54596e0936f45a44edb4867f7ed756fea6ed", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=b81caed43f1886024ededad41a1baa8a03f1d2f4", "patch": "@@ -16,9 +16,8 @@ use crate::{\n     adt::{StructData, EnumData},\n     impl_block::{ModuleImplBlocks, ImplSourceMap, ImplBlock},\n     generics::{GenericParams, GenericDef},\n-    type_ref::TypeRef,\n     traits::TraitData,\n-    lang_item::{LangItems, LangItemTarget},\n+    lang_item::{LangItems, LangItemTarget}, type_alias::TypeAliasData,\n };\n \n // This database has access to source code, so queries here are not really\n@@ -113,8 +112,8 @@ pub trait DefDatabase: SourceDatabase {\n     #[salsa::invoke(crate::FnSignature::fn_signature_query)]\n     fn fn_signature(&self, func: Function) -> Arc<FnSignature>;\n \n-    #[salsa::invoke(crate::type_alias::type_alias_ref_query)]\n-    fn type_alias_ref(&self, typ: TypeAlias) -> Arc<TypeRef>;\n+    #[salsa::invoke(crate::type_alias::type_alias_data_query)]\n+    fn type_alias_data(&self, typ: TypeAlias) -> Arc<TypeAliasData>;\n \n     #[salsa::invoke(crate::ConstSignature::const_signature_query)]\n     fn const_signature(&self, konst: Const) -> Arc<ConstSignature>;\n@@ -185,6 +184,13 @@ pub trait HirDatabase: DefDatabase + AstDatabase {\n         krate: Crate,\n         goal: crate::ty::Canonical<crate::ty::TraitRef>,\n     ) -> Option<crate::ty::traits::Solution>;\n+\n+    #[salsa::invoke(crate::ty::traits::normalize_query)]\n+    fn normalize(\n+        &self,\n+        krate: Crate,\n+        goal: crate::ty::Canonical<crate::ty::ProjectionPredicate>,\n+    ) -> Option<crate::ty::traits::Solution>;\n }\n \n #[test]"}, {"sha": "18ac0fcf9eb4bde1f2687348bdb66dff8a4179ea", "filename": "crates/ra_hir/src/lang_item.rs", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flang_item.rs?ref=b81caed43f1886024ededad41a1baa8a03f1d2f4", "patch": "@@ -1,10 +1,11 @@\n use std::sync::Arc;\n use rustc_hash::FxHashMap;\n \n-use ra_syntax::{SmolStr, ast::AttrsOwner};\n+use ra_syntax::{SmolStr, TreeArc, ast::AttrsOwner};\n \n use crate::{\n-    Crate, DefDatabase, Enum, Function, HirDatabase, ImplBlock, Module, Static, Struct, Trait, AstDatabase,\n+    Crate, DefDatabase, Enum, Function, HirDatabase, ImplBlock, Module,\n+    Static, Struct, Trait, ModuleDef, AstDatabase, HasSource\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -87,23 +88,51 @@ impl LangItems {\n         let source = module.definition_source(db).ast;\n         for (impl_id, _) in impl_blocks.impls.iter() {\n             let impl_block = source_map.get(&source, impl_id);\n-            let lang_item_name = impl_block\n-                .attrs()\n-                .filter_map(|a| a.as_key_value())\n-                .filter(|(key, _)| key == \"lang\")\n-                .map(|(_, val)| val)\n-                .nth(0);\n-            if let Some(lang_item_name) = lang_item_name {\n+            if let Some(lang_item_name) = lang_item_name(&*impl_block) {\n                 let imp = ImplBlock::from_id(*module, impl_id);\n                 self.items.entry(lang_item_name).or_insert_with(|| LangItemTarget::ImplBlock(imp));\n             }\n         }\n \n-        // FIXME we should look for the other lang item targets (traits, structs, ...)\n+        for def in module.declarations(db) {\n+            match def {\n+                ModuleDef::Trait(trait_) => {\n+                    self.collect_lang_item(db, trait_, LangItemTarget::Trait)\n+                }\n+                ModuleDef::Enum(e) => self.collect_lang_item(db, e, LangItemTarget::Enum),\n+                ModuleDef::Struct(s) => self.collect_lang_item(db, s, LangItemTarget::Struct),\n+                ModuleDef::Function(f) => self.collect_lang_item(db, f, LangItemTarget::Function),\n+                ModuleDef::Static(s) => self.collect_lang_item(db, s, LangItemTarget::Static),\n+                _ => {}\n+            }\n+        }\n \n         // Look for lang items in the children\n         for child in module.children(db) {\n             self.collect_lang_items_recursive(db, &child);\n         }\n     }\n+\n+    fn collect_lang_item<T, N>(\n+        &mut self,\n+        db: &(impl DefDatabase + AstDatabase),\n+        item: T,\n+        constructor: fn(T) -> LangItemTarget,\n+    ) where\n+        T: Copy + HasSource<Ast = TreeArc<N>>,\n+        N: AttrsOwner,\n+    {\n+        let node = item.source(db).ast;\n+        if let Some(lang_item_name) = lang_item_name(&*node) {\n+            self.items.entry(lang_item_name).or_insert(constructor(item));\n+        }\n+    }\n+}\n+\n+fn lang_item_name<T: AttrsOwner>(node: &T) -> Option<SmolStr> {\n+    node.attrs()\n+        .filter_map(|a| a.as_key_value())\n+        .filter(|(key, _)| key == \"lang\")\n+        .map(|(_, val)| val)\n+        .nth(0)\n }"}, {"sha": "ba17958eb9f146b0b01f8ea39fe7051191d21a1e", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=b81caed43f1886024ededad41a1baa8a03f1d2f4", "patch": "@@ -46,6 +46,11 @@ impl Name {\n         Name::new(idx.to_string().into())\n     }\n \n+    // Needed for Deref\n+    pub(crate) fn target() -> Name {\n+        Name::new(\"Target\".into())\n+    }\n+\n     // There's should be no way to extract a string out of `Name`: `Name` in the\n     // future, `Name` will include hygiene information, and you can't encode\n     // hygiene into a String."}, {"sha": "08e86844de190df0393455e6445d9a4573d8bc3e", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=b81caed43f1886024ededad41a1baa8a03f1d2f4", "patch": "@@ -369,6 +369,17 @@ impl SourceAnalyzer {\n         )\n     }\n \n+    pub fn autoderef<'a>(\n+        &'a self,\n+        db: &'a impl HirDatabase,\n+        ty: Ty,\n+    ) -> impl Iterator<Item = Ty> + 'a {\n+        // There should be no inference vars in types passed here\n+        // FIXME check that?\n+        let canonical = crate::ty::Canonical { value: ty, num_vars: 0 };\n+        crate::ty::autoderef(db, &self.resolver, canonical).map(|canonical| canonical.value)\n+    }\n+\n     #[cfg(test)]\n     pub(crate) fn body_source_map(&self) -> Arc<BodySourceMap> {\n         self.body_source_map.clone().unwrap()"}, {"sha": "842d49e1fd42da1018e441964d56a1d65aca068e", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=b81caed43f1886024ededad41a1baa8a03f1d2f4", "patch": "@@ -16,12 +16,14 @@ use std::sync::Arc;\n use std::ops::Deref;\n use std::{fmt, mem};\n \n-use crate::{Name, AdtDef, type_ref::Mutability, db::HirDatabase, Trait, GenericParams};\n+use crate::{Name, AdtDef, type_ref::Mutability, db::HirDatabase, Trait, GenericParams, TypeAlias};\n use display::{HirDisplay, HirFormatter};\n \n pub(crate) use lower::{TypableDef, type_for_def, type_for_field, callable_item_sig, generic_predicates, generic_defaults};\n pub(crate) use infer::{infer_query, InferenceResult, InferTy};\n pub use lower::CallableDef;\n+pub(crate) use autoderef::autoderef;\n+pub(crate) use traits::ProjectionPredicate;\n \n /// A type constructor or type name: this might be something like the primitive\n /// type `bool`, a struct like `Vec`, or things like function pointers or\n@@ -100,6 +102,15 @@ pub struct ApplicationTy {\n     pub parameters: Substs,\n }\n \n+/// A \"projection\" type corresponds to an (unnormalized)\n+/// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n+/// trait and all its parameters are fully known.\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct ProjectionTy {\n+    pub associated_ty: TypeAlias,\n+    pub parameters: Substs,\n+}\n+\n /// A type.\n ///\n /// See also the `TyKind` enum in rustc (librustc/ty/sty.rs), which represents\n@@ -216,8 +227,8 @@ impl Deref for Substs {\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct TraitRef {\n     /// FIXME name?\n-    trait_: Trait,\n-    substs: Substs,\n+    pub trait_: Trait,\n+    pub substs: Substs,\n }\n \n impl TraitRef {\n@@ -464,6 +475,17 @@ impl Ty {\n             _ => None,\n         }\n     }\n+\n+    /// Shifts up `Ty::Bound` vars by `n`.\n+    pub fn shift_bound_vars(self, n: i32) -> Ty {\n+        self.fold(&mut |ty| match ty {\n+            Ty::Bound(idx) => {\n+                assert!(idx as i32 >= -n);\n+                Ty::Bound((idx as i32 + n) as u32)\n+            }\n+            ty => ty,\n+        })\n+    }\n }\n \n impl HirDisplay for &Ty {"}, {"sha": "1f443d49b688d237b23f163916e4eb2f2c930f00", "filename": "crates/ra_hir/src/ty/autoderef.rs", "status": "modified", "additions": 80, "deletions": 9, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs?ref=b81caed43f1886024ededad41a1baa8a03f1d2f4", "patch": "@@ -5,17 +5,88 @@\n \n use std::iter::successors;\n \n-use crate::HirDatabase;\n-use super::Ty;\n+use log::{info, warn};\n \n-impl Ty {\n-    /// Iterates over the possible derefs of `ty`.\n-    pub fn autoderef<'a>(self, db: &'a impl HirDatabase) -> impl Iterator<Item = Ty> + 'a {\n-        successors(Some(self), move |ty| ty.autoderef_step(db))\n+use crate::{HirDatabase, Name, Resolver, HasGenericParams};\n+use super::{traits::Solution, Ty, Canonical};\n+\n+const AUTODEREF_RECURSION_LIMIT: usize = 10;\n+\n+pub(crate) fn autoderef<'a>(\n+    db: &'a impl HirDatabase,\n+    resolver: &'a Resolver,\n+    ty: Canonical<Ty>,\n+) -> impl Iterator<Item = Canonical<Ty>> + 'a {\n+    successors(Some(ty), move |ty| deref(db, resolver, ty)).take(AUTODEREF_RECURSION_LIMIT)\n+}\n+\n+pub(crate) fn deref(\n+    db: &impl HirDatabase,\n+    resolver: &Resolver,\n+    ty: &Canonical<Ty>,\n+) -> Option<Canonical<Ty>> {\n+    if let Some(derefed) = ty.value.builtin_deref() {\n+        Some(Canonical { value: derefed, num_vars: ty.num_vars })\n+    } else {\n+        deref_by_trait(db, resolver, ty)\n+    }\n+}\n+\n+fn deref_by_trait(\n+    db: &impl HirDatabase,\n+    resolver: &Resolver,\n+    ty: &Canonical<Ty>,\n+) -> Option<Canonical<Ty>> {\n+    let krate = resolver.krate()?;\n+    let deref_trait = match db.lang_item(krate, \"deref\".into())? {\n+        crate::lang_item::LangItemTarget::Trait(t) => t,\n+        _ => return None,\n+    };\n+    let target = deref_trait.associated_type_by_name(db, Name::target())?;\n+\n+    if target.generic_params(db).count_params_including_parent() != 1 {\n+        // the Target type + Deref trait should only have one generic parameter,\n+        // namely Deref's Self type\n+        return None;\n     }\n \n-    fn autoderef_step(&self, _db: &impl HirDatabase) -> Option<Ty> {\n-        // FIXME Deref::deref\n-        self.builtin_deref()\n+    // FIXME make the Canonical handling nicer\n+\n+    let projection = super::traits::ProjectionPredicate {\n+        ty: Ty::Bound(0),\n+        projection_ty: super::ProjectionTy {\n+            associated_ty: target,\n+            parameters: vec![ty.value.clone().shift_bound_vars(1)].into(),\n+        },\n+    };\n+\n+    let canonical = super::Canonical { num_vars: 1 + ty.num_vars, value: projection };\n+\n+    let solution = db.normalize(krate, canonical)?;\n+\n+    match &solution {\n+        Solution::Unique(vars) => {\n+            // FIXME: vars may contain solutions for any inference variables\n+            // that happened to be inside ty. To correctly handle these, we\n+            // would have to pass the solution up to the inference context, but\n+            // that requires a larger refactoring (especially if the deref\n+            // happens during method resolution). So for the moment, we just\n+            // check that we're not in the situation we're we would actually\n+            // need to handle the values of the additional variables, i.e.\n+            // they're just being 'passed through'. In the 'standard' case where\n+            // we have `impl<T> Deref for Foo<T> { Target = T }`, that should be\n+            // the case.\n+            for i in 1..vars.0.num_vars {\n+                if vars.0.value[i] != Ty::Bound((i - 1) as u32) {\n+                    warn!(\"complex solution for derefing {:?}: {:?}, ignoring\", ty, solution);\n+                    return None;\n+                }\n+            }\n+            Some(Canonical { value: vars.0.value[0].clone(), num_vars: vars.0.num_vars })\n+        }\n+        Solution::Ambig(_) => {\n+            info!(\"Ambiguous solution for derefing {:?}: {:?}\", ty, solution);\n+            None\n+        }\n     }\n }"}, {"sha": "1ee40c70a83cffaf4fb0be27c40e51da3751fc75", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=b81caed43f1886024ededad41a1baa8a03f1d2f4", "patch": "@@ -46,7 +46,7 @@ use crate::{\n use super::{\n     Ty, TypableDef, Substs, primitive, op, ApplicationTy, TypeCtor, CallableDef, TraitRef,\n     traits::{Solution, Obligation, Guidance},\n-    method_resolution,\n+    method_resolution, autoderef,\n };\n \n mod unify;\n@@ -1074,25 +1074,27 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::Field { expr, name } => {\n                 let receiver_ty = self.infer_expr(*expr, &Expectation::none());\n-                let ty = receiver_ty\n-                    .autoderef(self.db)\n-                    .find_map(|derefed_ty| match derefed_ty {\n-                        Ty::Apply(a_ty) => match a_ty.ctor {\n-                            TypeCtor::Tuple { .. } => {\n-                                let i = name.to_string().parse::<usize>().ok();\n-                                i.and_then(|i| a_ty.parameters.0.get(i).cloned())\n-                            }\n-                            TypeCtor::Adt(AdtDef::Struct(s)) => {\n-                                s.field(self.db, name).map(|field| {\n-                                    self.write_field_resolution(tgt_expr, field);\n-                                    field.ty(self.db).subst(&a_ty.parameters)\n-                                })\n-                            }\n-                            _ => None,\n-                        },\n+                let canonicalized = self.canonicalizer().canonicalize_ty(receiver_ty);\n+                let ty = autoderef::autoderef(\n+                    self.db,\n+                    &self.resolver.clone(),\n+                    canonicalized.value.clone(),\n+                )\n+                .find_map(|derefed_ty| match canonicalized.decanonicalize_ty(derefed_ty.value) {\n+                    Ty::Apply(a_ty) => match a_ty.ctor {\n+                        TypeCtor::Tuple { .. } => {\n+                            let i = name.to_string().parse::<usize>().ok();\n+                            i.and_then(|i| a_ty.parameters.0.get(i).cloned())\n+                        }\n+                        TypeCtor::Adt(AdtDef::Struct(s)) => s.field(self.db, name).map(|field| {\n+                            self.write_field_resolution(tgt_expr, field);\n+                            field.ty(self.db).subst(&a_ty.parameters)\n+                        }),\n                         _ => None,\n-                    })\n-                    .unwrap_or(Ty::Unknown);\n+                    },\n+                    _ => None,\n+                })\n+                .unwrap_or(Ty::Unknown);\n                 self.insert_type_vars(ty)\n             }\n             Expr::Try { expr } => {\n@@ -1124,10 +1126,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let inner_ty = self.infer_expr(*expr, &Expectation::none());\n                 match op {\n                     UnaryOp::Deref => {\n-                        if let Some(derefed_ty) = inner_ty.builtin_deref() {\n-                            derefed_ty\n+                        let canonicalized = self.canonicalizer().canonicalize_ty(inner_ty);\n+                        if let Some(derefed_ty) =\n+                            autoderef::deref(self.db, &self.resolver, &canonicalized.value)\n+                        {\n+                            canonicalized.decanonicalize_ty(derefed_ty.value)\n                         } else {\n-                            // FIXME Deref::deref\n                             Ty::Unknown\n                         }\n                     }"}, {"sha": "300616a539e89822facc43da52a831e185b113e8", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=b81caed43f1886024ededad41a1baa8a03f1d2f4", "patch": "@@ -460,7 +460,7 @@ fn type_for_type_alias(db: &impl HirDatabase, t: TypeAlias) -> Ty {\n     let resolver = t.resolver(db);\n     let type_ref = t.type_ref(db);\n     let substs = Substs::identity(&generics);\n-    let inner = Ty::from_hir(db, &resolver, &type_ref);\n+    let inner = Ty::from_hir(db, &resolver, &type_ref.unwrap_or(TypeRef::Error));\n     inner.subst(&substs)\n }\n "}, {"sha": "ad26d591ce0012f39aa6c647c988a678c5f437b8", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=b81caed43f1886024ededad41a1baa8a03f1d2f4", "patch": "@@ -16,7 +16,7 @@ use crate::{\n     generics::HasGenericParams,\n     ty::primitive::{UncertainIntTy, UncertainFloatTy}\n };\n-use super::{TraitRef, Canonical};\n+use super::{TraitRef, Canonical, autoderef};\n \n /// This is used as a key for indexing impls.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -162,8 +162,7 @@ pub(crate) fn iterate_method_candidates<T>(\n     // rustc does an autoderef and then autoref again).\n \n     let krate = resolver.krate()?;\n-    for derefed_ty in ty.value.clone().autoderef(db) {\n-        let derefed_ty = Canonical { value: derefed_ty, num_vars: ty.num_vars };\n+    for derefed_ty in autoderef::autoderef(db, resolver, ty.clone()) {\n         if let Some(result) = iterate_inherent_methods(&derefed_ty, db, name, krate, &mut callback)\n         {\n             return Some(result);"}, {"sha": "0fe7805e24a15c020146101e3eaa837634b20c35", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=b81caed43f1886024ededad41a1baa8a03f1d2f4", "patch": "@@ -2737,6 +2737,90 @@ fn main() {\n     assert_eq!(t, \"Foo\");\n }\n \n+#[test]\n+fn deref_trait() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+struct Arc<T>;\n+impl<T> Deref for Arc<T> {\n+    type Target = T;\n+}\n+\n+struct S;\n+impl S {\n+    fn foo(&self) -> u128 {}\n+}\n+\n+fn test(s: Arc<S>) {\n+    (*s, s.foo())<|>\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"(S, u128)\");\n+}\n+\n+#[test]\n+fn deref_trait_with_inference_var() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+struct Arc<T>;\n+fn new_arc<T>() -> Arc<T> {}\n+impl<T> Deref for Arc<T> {\n+    type Target = T;\n+}\n+\n+struct S;\n+fn foo(a: Arc<S>) {}\n+\n+fn test() {\n+    let a = new_arc();\n+    let b = (*a)<|>;\n+    foo(a);\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"S\");\n+}\n+\n+#[test]\n+fn deref_trait_infinite_recursion() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+struct S;\n+\n+impl Deref for S {\n+    type Target = S;\n+}\n+\n+fn test(s: S) {\n+    s.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();"}, {"sha": "9a6349d4ba0062b670f1146643d87a88fa1ebb8b", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=b81caed43f1886024ededad41a1baa8a03f1d2f4", "patch": "@@ -8,7 +8,7 @@ use chalk_ir::cast::Cast;\n use ra_prof::profile;\n \n use crate::{Crate, Trait, db::HirDatabase, ImplBlock};\n-use super::{TraitRef, Ty, Canonical};\n+use super::{TraitRef, Ty, Canonical, ProjectionTy};\n \n use self::chalk::{ToChalk, from_chalk};\n \n@@ -75,6 +75,13 @@ pub enum Obligation {\n     /// Prove that a certain type implements a trait (the type is the `Self` type\n     /// parameter to the `TraitRef`).\n     Trait(TraitRef),\n+    // Projection(ProjectionPredicate),\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct ProjectionPredicate {\n+    pub projection_ty: ProjectionTy,\n+    pub ty: Ty,\n }\n \n /// Check using Chalk whether trait is implemented for given parameters including `Self` type.\n@@ -98,6 +105,30 @@ pub(crate) fn implements_query(\n     solution.map(|solution| solution_from_chalk(db, solution))\n }\n \n+pub(crate) fn normalize_query(\n+    db: &impl HirDatabase,\n+    krate: Crate,\n+    projection: Canonical<ProjectionPredicate>,\n+) -> Option<Solution> {\n+    let goal: chalk_ir::Goal = chalk_ir::Normalize {\n+        projection: projection.value.projection_ty.to_chalk(db),\n+        ty: projection.value.ty.to_chalk(db),\n+    }\n+    .cast();\n+    debug!(\"goal: {:?}\", goal);\n+    // FIXME unify with `implements`\n+    let env = chalk_ir::Environment::new();\n+    let in_env = chalk_ir::InEnvironment::new(&env, goal);\n+    let parameter = chalk_ir::ParameterKind::Ty(chalk_ir::UniverseIndex::ROOT);\n+    let canonical =\n+        chalk_ir::Canonical { value: in_env, binders: vec![parameter; projection.num_vars] };\n+    // We currently don't deal with universes (I think / hope they're not yet\n+    // relevant for our use cases?)\n+    let u_canonical = chalk_ir::UCanonical { canonical, universes: 1 };\n+    let solution = solve(db, krate, &u_canonical);\n+    solution.map(|solution| solution_from_chalk(db, solution))\n+}\n+\n fn solution_from_chalk(db: &impl HirDatabase, solution: chalk_solve::Solution) -> Solution {\n     let convert_subst = |subst: chalk_ir::Canonical<chalk_ir::Substitution>| {\n         let value = subst"}, {"sha": "5105588eeb51666f5ceed70c52318aed9bdb5efd", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 102, "deletions": 8, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=b81caed43f1886024ededad41a1baa8a03f1d2f4", "patch": "@@ -3,7 +3,7 @@ use std::sync::Arc;\n \n use log::debug;\n \n-use chalk_ir::{TypeId, ImplId, TypeKindId, ProjectionTy, Parameter, Identifier, cast::Cast, PlaceholderIndex, UniverseIndex, TypeName};\n+use chalk_ir::{TypeId, ImplId, TypeKindId, Parameter, Identifier, cast::Cast, PlaceholderIndex, UniverseIndex, TypeName};\n use chalk_rust_ir::{AssociatedTyDatum, TraitDatum, StructDatum, ImplDatum};\n \n use test_utils::tested_by;\n@@ -12,9 +12,9 @@ use ra_db::salsa::{InternId, InternKey};\n use crate::{\n     Trait, HasGenericParams, ImplBlock,\n     db::HirDatabase,\n-    ty::{TraitRef, Ty, ApplicationTy, TypeCtor, Substs, GenericPredicate, CallableDef},\n+    ty::{TraitRef, Ty, ApplicationTy, TypeCtor, Substs, GenericPredicate, CallableDef, ProjectionTy},\n     ty::display::HirDisplay,\n-    generics::GenericDef,\n+    generics::GenericDef, TypeAlias, ImplItem,\n };\n use super::ChalkContext;\n \n@@ -156,6 +156,18 @@ impl ToChalk for ImplBlock {\n     }\n }\n \n+impl ToChalk for TypeAlias {\n+    type Chalk = chalk_ir::TypeId;\n+\n+    fn to_chalk(self, _db: &impl HirDatabase) -> chalk_ir::TypeId {\n+        self.id.into()\n+    }\n+\n+    fn from_chalk(_db: &impl HirDatabase, impl_id: chalk_ir::TypeId) -> TypeAlias {\n+        TypeAlias { id: impl_id.into() }\n+    }\n+}\n+\n impl ToChalk for GenericPredicate {\n     type Chalk = chalk_ir::QuantifiedWhereClause;\n \n@@ -183,6 +195,24 @@ impl ToChalk for GenericPredicate {\n     }\n }\n \n+impl ToChalk for ProjectionTy {\n+    type Chalk = chalk_ir::ProjectionTy;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::ProjectionTy {\n+        chalk_ir::ProjectionTy {\n+            associated_ty_id: self.associated_ty.to_chalk(db),\n+            parameters: self.parameters.to_chalk(db),\n+        }\n+    }\n+\n+    fn from_chalk(db: &impl HirDatabase, projection_ty: chalk_ir::ProjectionTy) -> ProjectionTy {\n+        ProjectionTy {\n+            associated_ty: from_chalk(db, projection_ty.associated_ty_id),\n+            parameters: from_chalk(db, projection_ty.parameters),\n+        }\n+    }\n+}\n+\n fn make_binders<T>(value: T, num_vars: usize) -> chalk_ir::Binders<T> {\n     chalk_ir::Binders {\n         value,\n@@ -225,8 +255,29 @@ impl<'a, DB> chalk_solve::RustIrDatabase for ChalkContext<'a, DB>\n where\n     DB: HirDatabase,\n {\n-    fn associated_ty_data(&self, _ty: TypeId) -> Arc<AssociatedTyDatum> {\n-        unimplemented!()\n+    fn associated_ty_data(&self, id: TypeId) -> Arc<AssociatedTyDatum> {\n+        debug!(\"associated_ty_data {:?}\", id);\n+        let type_alias: TypeAlias = from_chalk(self.db, id);\n+        let trait_ = match type_alias.container(self.db) {\n+            Some(crate::Container::Trait(t)) => t,\n+            _ => panic!(\"associated type not in trait\"),\n+        };\n+        let generic_params = type_alias.generic_params(self.db);\n+        let parameter_kinds = generic_params\n+            .params_including_parent()\n+            .into_iter()\n+            .map(|p| chalk_ir::ParameterKind::Ty(lalrpop_intern::intern(&p.name.to_string())))\n+            .collect();\n+        let datum = AssociatedTyDatum {\n+            trait_id: trait_.to_chalk(self.db),\n+            id,\n+            name: lalrpop_intern::intern(&type_alias.name(self.db).to_string()),\n+            parameter_kinds,\n+            // FIXME add bounds and where clauses\n+            bounds: vec![],\n+            where_clauses: vec![],\n+        };\n+        Arc::new(datum)\n     }\n     fn trait_datum(&self, trait_id: chalk_ir::TraitId) -> Arc<TraitDatum> {\n         debug!(\"trait_datum {:?}\", trait_id);\n@@ -260,7 +311,15 @@ where\n             fundamental: false,\n         };\n         let where_clauses = convert_where_clauses(self.db, trait_.into(), &bound_vars);\n-        let associated_ty_ids = Vec::new(); // FIXME add associated tys\n+        let associated_ty_ids = trait_\n+            .items(self.db)\n+            .into_iter()\n+            .filter_map(|trait_item| match trait_item {\n+                crate::traits::TraitItem::TypeAlias(type_alias) => Some(type_alias),\n+                _ => None,\n+            })\n+            .map(|type_alias| type_alias.to_chalk(self.db))\n+            .collect();\n         let trait_datum_bound =\n             chalk_rust_ir::TraitDatumBound { trait_ref, where_clauses, flags, associated_ty_ids };\n         let trait_datum = TraitDatum { binders: make_binders(trait_datum_bound, bound_vars.len()) };\n@@ -359,17 +418,40 @@ where\n             trait_ref.display(self.db),\n             where_clauses\n         );\n+        let trait_ = trait_ref.trait_;\n         let trait_ref = trait_ref.to_chalk(self.db);\n+        let associated_ty_values = impl_block\n+            .items(self.db)\n+            .into_iter()\n+            .filter_map(|item| match item {\n+                ImplItem::TypeAlias(t) => Some(t),\n+                _ => None,\n+            })\n+            .filter_map(|t| {\n+                let assoc_ty = trait_.associated_type_by_name(self.db, t.name(self.db))?;\n+                let ty = self.db.type_for_def(t.into(), crate::Namespace::Types).subst(&bound_vars);\n+                Some(chalk_rust_ir::AssociatedTyValue {\n+                    impl_id,\n+                    associated_ty_id: assoc_ty.to_chalk(self.db),\n+                    value: chalk_ir::Binders {\n+                        value: chalk_rust_ir::AssociatedTyValueBound { ty: ty.to_chalk(self.db) },\n+                        binders: vec![], // we don't support GATs yet\n+                    },\n+                })\n+            })\n+            .collect();\n+\n         let impl_datum_bound = chalk_rust_ir::ImplDatumBound {\n             trait_ref: if negative {\n                 chalk_rust_ir::PolarizedTraitRef::Negative(trait_ref)\n             } else {\n                 chalk_rust_ir::PolarizedTraitRef::Positive(trait_ref)\n             },\n             where_clauses,\n-            associated_ty_values: Vec::new(), // FIXME add associated type values\n+            associated_ty_values,\n             impl_type,\n         };\n+        debug!(\"impl_datum: {:?}\", impl_datum_bound);\n         let impl_datum = ImplDatum { binders: make_binders(impl_datum_bound, bound_vars.len()) };\n         Arc::new(impl_datum)\n     }\n@@ -405,7 +487,7 @@ where\n     }\n     fn split_projection<'p>(\n         &self,\n-        projection: &'p ProjectionTy,\n+        projection: &'p chalk_ir::ProjectionTy,\n     ) -> (Arc<AssociatedTyDatum>, &'p [Parameter], &'p [Parameter]) {\n         debug!(\"split_projection {:?}\", projection);\n         unimplemented!()\n@@ -440,6 +522,18 @@ impl From<crate::ids::TraitId> for chalk_ir::TraitId {\n     }\n }\n \n+impl From<chalk_ir::TypeId> for crate::ids::TypeAliasId {\n+    fn from(type_id: chalk_ir::TypeId) -> Self {\n+        id_from_chalk(type_id.0)\n+    }\n+}\n+\n+impl From<crate::ids::TypeAliasId> for chalk_ir::TypeId {\n+    fn from(type_id: crate::ids::TypeAliasId) -> Self {\n+        chalk_ir::TypeId(id_to_chalk(type_id))\n+    }\n+}\n+\n impl From<chalk_ir::StructId> for crate::ids::TypeCtorId {\n     fn from(struct_id: chalk_ir::StructId) -> Self {\n         id_from_chalk(struct_id.0)"}, {"sha": "eada37274134ae427e0fdfa4b0a673f32e715262", "filename": "crates/ra_hir/src/type_alias.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Ftype_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_hir%2Fsrc%2Ftype_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftype_alias.rs?ref=b81caed43f1886024ededad41a1baa8a03f1d2f4", "patch": "@@ -2,12 +2,22 @@\n \n use std::sync::Arc;\n \n-use crate::{TypeAlias, DefDatabase, AstDatabase, HasSource, type_ref::TypeRef};\n+use ra_syntax::ast::NameOwner;\n \n-pub(crate) fn type_alias_ref_query(\n+use crate::{TypeAlias, db::{DefDatabase, AstDatabase}, type_ref::TypeRef, name::{Name, AsName}, HasSource};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TypeAliasData {\n+    pub(crate) name: Name,\n+    pub(crate) type_ref: Option<TypeRef>,\n+}\n+\n+pub(crate) fn type_alias_data_query(\n     db: &(impl DefDatabase + AstDatabase),\n     typ: TypeAlias,\n-) -> Arc<TypeRef> {\n+) -> Arc<TypeAliasData> {\n     let node = typ.source(db).ast;\n-    Arc::new(TypeRef::from_ast_opt(node.type_ref()))\n+    let name = node.name().map_or_else(Name::missing, |n| n.as_name());\n+    let type_ref = node.type_ref().map(TypeRef::from_ast);\n+    Arc::new(TypeAliasData { name, type_ref })\n }"}, {"sha": "f26fd06b370348aec0279dc2a7d90e5c967e0f14", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=b81caed43f1886024ededad41a1baa8a03f1d2f4", "patch": "@@ -15,7 +15,7 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n }\n \n fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) {\n-    for receiver in receiver.autoderef(ctx.db) {\n+    for receiver in ctx.analyzer.autoderef(ctx.db, receiver) {\n         if let Ty::Apply(a_ty) = receiver {\n             match a_ty.ctor {\n                 TypeCtor::Adt(AdtDef::Struct(s)) => {"}, {"sha": "6f5164e0babddebf2a9456ca19569dae12a9e922", "filename": "crates/ra_ide_api/src/goto_type_definition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81caed43f1886024ededad41a1baa8a03f1d2f4/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs?ref=b81caed43f1886024ededad41a1baa8a03f1d2f4", "patch": "@@ -30,7 +30,7 @@ pub(crate) fn goto_type_definition(\n         return None;\n     };\n \n-    let adt_def = ty.autoderef(db).find_map(|ty| ty.as_adt().map(|adt| adt.0))?;\n+    let adt_def = analyzer.autoderef(db, ty).find_map(|ty| ty.as_adt().map(|adt| adt.0))?;\n \n     let nav = NavigationTarget::from_adt_def(db, adt_def);\n     Some(RangeInfo::new(node.range(), vec![nav]))"}]}