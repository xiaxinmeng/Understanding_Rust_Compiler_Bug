{"sha": "a20969c489d7f415f8073aacef1d480de6459ce8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyMDk2OWM0ODlkN2Y0MTVmODA3M2FhY2VmMWQ0ODBkZTY0NTljZTg=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-12-27T17:31:21Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-01T22:10:43Z"}, "message": "Implement general or-patterns in `let` statements", "tree": {"sha": "226bdcb1212096fea9c55d8c636d21d63fb13ca7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/226bdcb1212096fea9c55d8c636d21d63fb13ca7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a20969c489d7f415f8073aacef1d480de6459ce8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a20969c489d7f415f8073aacef1d480de6459ce8", "html_url": "https://github.com/rust-lang/rust/commit/a20969c489d7f415f8073aacef1d480de6459ce8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a20969c489d7f415f8073aacef1d480de6459ce8/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cc4352bc4f9789d7243e79684b2943d3d9ad450", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cc4352bc4f9789d7243e79684b2943d3d9ad450", "html_url": "https://github.com/rust-lang/rust/commit/5cc4352bc4f9789d7243e79684b2943d3d9ad450"}], "stats": {"total": 107, "additions": 55, "deletions": 52}, "files": [{"sha": "928363246c2c0caf710c79a1d101a647a0c158d8", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "modified", "additions": 55, "deletions": 52, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/a20969c489d7f415f8073aacef1d480de6459ce8/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a20969c489d7f415f8073aacef1d480de6459ce8/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=a20969c489d7f415f8073aacef1d480de6459ce8", "patch": "@@ -96,11 +96,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let mut arm_candidates = self.create_match_candidates(&scrutinee_place, &arms);\n \n         let match_has_guard = arms.iter().any(|arm| arm.guard.is_some());\n-        let candidates =\n+        let mut candidates =\n             arm_candidates.iter_mut().map(|(_, candidate)| candidate).collect::<Vec<_>>();\n \n         let fake_borrow_temps =\n-            self.lower_match_tree(block, scrutinee_span, match_has_guard, candidates);\n+            self.lower_match_tree(block, scrutinee_span, match_has_guard, &mut candidates);\n \n         self.lower_match_arms(\n             &destination,\n@@ -181,7 +181,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         block: BasicBlock,\n         scrutinee_span: Span,\n         match_has_guard: bool,\n-        mut candidates: Vec<&mut Candidate<'pat, 'tcx>>,\n+        candidates: &mut [&mut Candidate<'pat, 'tcx>],\n     ) -> Vec<(Place<'tcx>, Local)> {\n         // The set of places that we are creating fake borrows of. If there are\n         // no match guards then we don't need any fake borrows, so don't track\n@@ -192,13 +192,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         // This will generate code to test scrutinee_place and\n         // branch to the appropriate arm block\n-        self.match_candidates(\n-            scrutinee_span,\n-            block,\n-            &mut otherwise,\n-            &mut candidates,\n-            &mut fake_borrows,\n-        );\n+        self.match_candidates(scrutinee_span, block, &mut otherwise, candidates, &mut fake_borrows);\n \n         if let Some(otherwise_block) = otherwise {\n             let source_info = self.source_info(scrutinee_span);\n@@ -207,7 +201,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let mut previous_candidate: Option<&mut Candidate<'_, '_>> = None;\n \n-        for candidate in candidates.into_iter() {\n+        for candidate in candidates {\n             candidate.visit_leaves(|leaf_candidate| {\n                 if let Some(ref mut prev) = previous_candidate {\n                     prev.next_candidate_pre_binding_block = leaf_candidate.pre_binding_block;\n@@ -263,7 +257,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         arm.guard.as_ref().map(|g| (g, match_scope)),\n                         &fake_borrow_temps,\n                         scrutinee_span,\n-                        arm.scope,\n+                        Some(arm.scope),\n                     );\n \n                     if let Some(source_scope) = scope {\n@@ -297,7 +291,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         guard: Option<(&Guard<'tcx>, region::Scope)>,\n         fake_borrow_temps: &Vec<(Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n-        arm_scope: region::Scope,\n+        arm_scope: Option<region::Scope>,\n     ) -> BasicBlock {\n         if candidate.subcandidates.is_empty() {\n             // Avoid generating another `BasicBlock` when we only have one\n@@ -308,25 +302,36 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 guard,\n                 fake_borrow_temps,\n                 scrutinee_span,\n+                true,\n             )\n         } else {\n             let target_block = self.cfg.start_new_block();\n-\n+            let mut schedule_drops = true;\n             // We keep a stack of all of the bindings and type asciptions\n             // from the the parent candidates that we visit, that also need to\n             // be bound for each candidate.\n             traverse_candidate(\n                 candidate,\n                 &mut Vec::new(),\n                 &mut |leaf_candidate, parent_bindings| {\n-                    self.clear_top_scope(arm_scope);\n+                    if let Some(arm_scope) = arm_scope {\n+                        // Avoid scheduling drops multiple times by unscheduling drops.\n+                        self.clear_top_scope(arm_scope);\n+                    }\n                     let binding_end = self.bind_and_guard_matched_candidate(\n                         leaf_candidate,\n                         parent_bindings,\n                         guard,\n                         &fake_borrow_temps,\n                         scrutinee_span,\n+                        schedule_drops,\n                     );\n+                    if arm_scope.is_none() {\n+                        // If we aren't in a match, then our bindings may not be\n+                        // the only thing in the top scope, so only schedule\n+                        // them to drop for the first pattern instead.\n+                        schedule_drops = false;\n+                    }\n                     self.cfg.goto(binding_end, outer_source_info, target_block);\n                 },\n                 |inner_candidate, parent_bindings| {\n@@ -460,51 +465,43 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             subcandidates: vec![],\n         };\n \n-        // Simplify the candidate. Since the pattern is irrefutable, this should\n-        // always convert all match-pairs into bindings.\n-        self.simplify_candidate(&mut candidate);\n-\n-        if !candidate.match_pairs.is_empty() {\n-            // ICE if no other errors have been emitted. This used to be a hard error that wouldn't\n-            // be reached because `hair::pattern::check_match::check_match` wouldn't have let the\n-            // compiler continue. In our tests this is only ever hit by\n-            // `ui/consts/const-match-check.rs` with `--cfg eval1`, and that file already generates\n-            // a different error before hand.\n-            self.hir.tcx().sess.delay_span_bug(\n-                candidate.match_pairs[0].pattern.span,\n-                &format!(\n-                    \"match pairs {:?} remaining after simplifying irrefutable pattern\",\n-                    candidate.match_pairs,\n-                ),\n-            );\n-        }\n+        let fake_borrow_temps =\n+            self.lower_match_tree(block, irrefutable_pat.span, false, &mut [&mut candidate]);\n \n         // for matches and function arguments, the place that is being matched\n         // can be set when creating the variables. But the place for\n         // let PATTERN = ... might not even exist until we do the assignment.\n         // so we set it here instead\n         if set_match_place {\n-            for binding in &candidate.bindings {\n-                let local = self.var_local_id(binding.var_id, OutsideGuard);\n-\n-                if let LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                    opt_match_place: Some((ref mut match_place, _)),\n-                    ..\n-                }))) = self.local_decls[local].local_info\n-                {\n-                    *match_place = Some(*initializer);\n-                } else {\n-                    bug!(\"Let binding to non-user variable.\")\n+            let mut candidate_ref = &candidate;\n+            while let Some(next) = {\n+                for binding in &candidate_ref.bindings {\n+                    let local = self.var_local_id(binding.var_id, OutsideGuard);\n+\n+                    if let LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                        VarBindingForm { opt_match_place: Some((ref mut match_place, _)), .. },\n+                    ))) = self.local_decls[local].local_info\n+                    {\n+                        *match_place = Some(*initializer);\n+                    } else {\n+                        bug!(\"Let binding to non-user variable.\")\n+                    }\n                 }\n+                candidate_ref.subcandidates.get(0)\n+            } {\n+                candidate_ref = next;\n             }\n         }\n \n-        self.ascribe_types(block, &candidate.ascriptions);\n-\n-        // now apply the bindings, which will also declare the variables\n-        self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n-\n-        block.unit()\n+        self.bind_pattern(\n+            self.source_info(irrefutable_pat.span),\n+            candidate,\n+            None,\n+            &fake_borrow_temps,\n+            irrefutable_pat.span,\n+            None,\n+        )\n+        .unit()\n     }\n \n     /// Declares the bindings of the given patterns and returns the visibility\n@@ -1486,6 +1483,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         guard: Option<(&Guard<'tcx>, region::Scope)>,\n         fake_borrows: &Vec<(Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n+        schedule_drops: bool,\n     ) -> BasicBlock {\n         debug!(\"bind_and_guard_matched_candidate(candidate={:?})\", candidate);\n \n@@ -1692,7 +1690,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let cause = FakeReadCause::ForGuardBinding;\n                 self.cfg.push_fake_read(post_guard_block, guard_end, cause, Place::from(local_id));\n             }\n-            self.bind_matched_candidate_for_arm_body(post_guard_block, by_value_bindings);\n+            assert!(schedule_drops, \"patterns with guards must schedule drops\");\n+            self.bind_matched_candidate_for_arm_body(post_guard_block, true, by_value_bindings);\n \n             post_guard_block\n         } else {\n@@ -1701,6 +1700,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // that we have to inspect before we bind them.)\n             self.bind_matched_candidate_for_arm_body(\n                 block,\n+                schedule_drops,\n                 parent_bindings\n                     .iter()\n                     .flat_map(|(bindings, _)| bindings)\n@@ -1793,6 +1793,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn bind_matched_candidate_for_arm_body<'b>(\n         &mut self,\n         block: BasicBlock,\n+        schedule_drops: bool,\n         bindings: impl IntoIterator<Item = &'b Binding<'tcx>>,\n     ) where\n         'tcx: 'b,\n@@ -1805,7 +1806,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let source_info = self.source_info(binding.span);\n             let local =\n                 self.storage_live_binding(block, binding.var_id, binding.span, OutsideGuard);\n-            self.schedule_drop_for_binding(binding.var_id, binding.span, OutsideGuard);\n+            if schedule_drops {\n+                self.schedule_drop_for_binding(binding.var_id, binding.span, OutsideGuard);\n+            }\n             let rvalue = match binding.binding_mode {\n                 BindingMode::ByValue => {\n                     Rvalue::Use(self.consume_by_copy_or_move(binding.source.clone()))"}]}