{"sha": "39733223fc817efba52a4204dd697192bf5da185", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5NzMzMjIzZmM4MTdlZmJhNTJhNDIwNGRkNjk3MTkyYmY1ZGExODU=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-01-30T20:26:36Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-02T21:46:29Z"}, "message": "Add IS_MANUALLY_DROP  to AdtFlags", "tree": {"sha": "15bc3922346ae63b1c62c6fcc3bd2a1cef98433a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15bc3922346ae63b1c62c6fcc3bd2a1cef98433a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39733223fc817efba52a4204dd697192bf5da185", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39733223fc817efba52a4204dd697192bf5da185", "html_url": "https://github.com/rust-lang/rust/commit/39733223fc817efba52a4204dd697192bf5da185", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39733223fc817efba52a4204dd697192bf5da185/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "570c1613c1225d5777af5603dcf526da9cf57e19", "url": "https://api.github.com/repos/rust-lang/rust/commits/570c1613c1225d5777af5603dcf526da9cf57e19", "html_url": "https://github.com/rust-lang/rust/commit/570c1613c1225d5777af5603dcf526da9cf57e19"}], "stats": {"total": 22, "additions": 17, "deletions": 5}, "files": [{"sha": "2b272d7fe08af636335bf6c64e7c02bcb5e7b9a8", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/39733223fc817efba52a4204dd697192bf5da185/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39733223fc817efba52a4204dd697192bf5da185/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=39733223fc817efba52a4204dd697192bf5da185", "patch": "@@ -1792,19 +1792,22 @@ bitflags! {\n         const IS_STRUCT           = 1 << 2;\n         /// Indicates whether the ADT is a struct and has a constructor.\n         const HAS_CTOR            = 1 << 3;\n-        /// Indicates whether the type is a `PhantomData`.\n+        /// Indicates whether the type is `PhantomData`.\n         const IS_PHANTOM_DATA     = 1 << 4;\n         /// Indicates whether the type has a `#[fundamental]` attribute.\n         const IS_FUNDAMENTAL      = 1 << 5;\n-        /// Indicates whether the type is a `Box`.\n+        /// Indicates whether the type is `Box`.\n         const IS_BOX              = 1 << 6;\n+        /// Indicates whether the type is `ManuallyDrop`.\n+        const IS_MANUALLY_DROP    = 1 << 7;\n+        // FIXME(matthewjasper) replace these with diagnostic items\n         /// Indicates whether the type is an `Arc`.\n-        const IS_ARC              = 1 << 7;\n+        const IS_ARC              = 1 << 8;\n         /// Indicates whether the type is an `Rc`.\n-        const IS_RC               = 1 << 8;\n+        const IS_RC               = 1 << 9;\n         /// Indicates whether the variant list of this ADT is `#[non_exhaustive]`.\n         /// (i.e., this flag is never set unless this ADT is an enum).\n-        const IS_VARIANT_LIST_NON_EXHAUSTIVE = 1 << 9;\n+        const IS_VARIANT_LIST_NON_EXHAUSTIVE = 1 << 10;\n     }\n }\n \n@@ -2180,6 +2183,9 @@ impl<'tcx> AdtDef {\n         if Some(did) == tcx.lang_items().owned_box() {\n             flags |= AdtFlags::IS_BOX;\n         }\n+        if Some(did) == tcx.lang_items().manually_drop() {\n+            flags |= AdtFlags::IS_MANUALLY_DROP;\n+        }\n         if Some(did) == tcx.lang_items().arc() {\n             flags |= AdtFlags::IS_ARC;\n         }\n@@ -2280,6 +2286,12 @@ impl<'tcx> AdtDef {\n         self.flags.contains(AdtFlags::IS_BOX)\n     }\n \n+    /// Returns `true` if this is ManuallyDrop<T>.\n+    #[inline]\n+    pub fn is_manually_drop(&self) -> bool {\n+        self.flags.contains(AdtFlags::IS_MANUALLY_DROP)\n+    }\n+\n     /// Returns `true` if this type has a destructor.\n     pub fn has_dtor(&self, tcx: TyCtxt<'tcx>) -> bool {\n         self.destructor(tcx).is_some()"}]}