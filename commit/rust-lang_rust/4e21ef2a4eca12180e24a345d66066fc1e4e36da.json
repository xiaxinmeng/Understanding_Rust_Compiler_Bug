{"sha": "4e21ef2a4eca12180e24a345d66066fc1e4e36da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlMjFlZjJhNGVjYTEyMTgwZTI0YTM0NWQ2NjA2NmZjMWU0ZTM2ZGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-01T16:45:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-01T16:45:47Z"}, "message": "Auto merge of #81825 - voidc:pidfd, r=joshtriplett\n\nAdd Linux-specific pidfd process extensions (take 2)\n\nContinuation of #77168.\nI addressed the following concerns from the original PR:\n\n- make `CommandExt` and `ChildExt` sealed traits\n- wrap file descriptors in `PidFd` struct representing ownership over the fd\n- add `take_pidfd` to take the fd out of `Child`\n- close fd when dropped\n\nTracking Issue: #82971", "tree": {"sha": "f4a6738e9cc0b047efed979e2f5a9d70b9b851b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4a6738e9cc0b047efed979e2f5a9d70b9b851b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e21ef2a4eca12180e24a345d66066fc1e4e36da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e21ef2a4eca12180e24a345d66066fc1e4e36da", "html_url": "https://github.com/rust-lang/rust/commit/4e21ef2a4eca12180e24a345d66066fc1e4e36da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e21ef2a4eca12180e24a345d66066fc1e4e36da/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e9c8705e94826da6aebe46512b4e3bbfc9e008f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e9c8705e94826da6aebe46512b4e3bbfc9e008f", "html_url": "https://github.com/rust-lang/rust/commit/2e9c8705e94826da6aebe46512b4e3bbfc9e008f"}, {"sha": "4a832d32f232a68acdabfd29e526d2a4b6366a1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a832d32f232a68acdabfd29e526d2a4b6366a1c", "html_url": "https://github.com/rust-lang/rust/commit/4a832d32f232a68acdabfd29e526d2a4b6366a1c"}], "stats": {"total": 421, "additions": 410, "deletions": 11}, "files": [{"sha": "8e7776f6646b58f5b4cee594289568a3426ab9bf", "filename": "library/std/src/os/linux/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e21ef2a4eca12180e24a345d66066fc1e4e36da/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e21ef2a4eca12180e24a345d66066fc1e4e36da/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fmod.rs?ref=4e21ef2a4eca12180e24a345d66066fc1e4e36da", "patch": "@@ -4,4 +4,5 @@\n #![doc(cfg(target_os = \"linux\"))]\n \n pub mod fs;\n+pub mod process;\n pub mod raw;"}, {"sha": "91547b8f9162272cd698f8eb52087d443fb7c017", "filename": "library/std/src/os/linux/process.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/4e21ef2a4eca12180e24a345d66066fc1e4e36da/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e21ef2a4eca12180e24a345d66066fc1e4e36da/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fprocess.rs?ref=4e21ef2a4eca12180e24a345d66066fc1e4e36da", "patch": "@@ -0,0 +1,154 @@\n+//! Linux-specific extensions to primitives in the `std::process` module.\n+\n+#![unstable(feature = \"linux_pidfd\", issue = \"82971\")]\n+\n+use crate::io::Result;\n+use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+use crate::process;\n+#[cfg(not(doc))]\n+use crate::sys::fd::FileDesc;\n+use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n+\n+#[cfg(doc)]\n+struct FileDesc;\n+\n+/// This type represents a file descriptor that refers to a process.\n+///\n+/// A `PidFd` can be obtained by setting the corresponding option on [`Command`]\n+/// with [`create_pidfd`]. Subsequently, the created pidfd can be retrieved\n+/// from the [`Child`] by calling [`pidfd`] or [`take_pidfd`].\n+///\n+/// Example:\n+/// ```no_run\n+/// #![feature(linux_pidfd)]\n+/// use std::os::linux::process::{CommandExt, ChildExt};\n+/// use std::process::Command;\n+///\n+/// let mut child = Command::new(\"echo\")\n+///     .create_pidfd(true)\n+///     .spawn()\n+///     .expect(\"Failed to spawn child\");\n+///\n+/// let pidfd = child\n+///     .take_pidfd()\n+///     .expect(\"Failed to retrieve pidfd\");\n+///\n+/// // The file descriptor will be closed when `pidfd` is dropped.\n+/// ```\n+/// Refer to the man page of [`pidfd_open(2)`] for further details.\n+///\n+/// [`Command`]: process::Command\n+/// [`create_pidfd`]: CommandExt::create_pidfd\n+/// [`Child`]: process::Child\n+/// [`pidfd`]: fn@ChildExt::pidfd\n+/// [`take_pidfd`]: ChildExt::take_pidfd\n+/// [`pidfd_open(2)`]: https://man7.org/linux/man-pages/man2/pidfd_open.2.html\n+#[derive(Debug)]\n+pub struct PidFd {\n+    inner: FileDesc,\n+}\n+\n+impl AsInner<FileDesc> for PidFd {\n+    fn as_inner(&self) -> &FileDesc {\n+        &self.inner\n+    }\n+}\n+\n+impl FromInner<FileDesc> for PidFd {\n+    fn from_inner(inner: FileDesc) -> PidFd {\n+        PidFd { inner }\n+    }\n+}\n+\n+impl IntoInner<FileDesc> for PidFd {\n+    fn into_inner(self) -> FileDesc {\n+        self.inner\n+    }\n+}\n+\n+impl AsRawFd for PidFd {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().raw()\n+    }\n+}\n+\n+impl FromRawFd for PidFd {\n+    unsafe fn from_raw_fd(fd: RawFd) -> Self {\n+        Self::from_inner(FileDesc::new(fd))\n+    }\n+}\n+\n+impl IntoRawFd for PidFd {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_raw()\n+    }\n+}\n+\n+mod private_child_ext {\n+    pub trait Sealed {}\n+    impl Sealed for crate::process::Child {}\n+}\n+\n+/// Os-specific extensions for [`Child`]\n+///\n+/// [`Child`]: process::Child\n+pub trait ChildExt: private_child_ext::Sealed {\n+    /// Obtains a reference to the [`PidFd`] created for this [`Child`], if available.\n+    ///\n+    /// A pidfd will only be available if its creation was requested with\n+    /// [`create_pidfd`] when the corresponding [`Command`] was created.\n+    ///\n+    /// Even if requested, a pidfd may not be available due to an older\n+    /// version of Linux being in use, or if some other error occurred.\n+    ///\n+    /// [`Command`]: process::Command\n+    /// [`create_pidfd`]: CommandExt::create_pidfd\n+    /// [`Child`]: process::Child\n+    fn pidfd(&self) -> Result<&PidFd>;\n+\n+    /// Takes ownership of the [`PidFd`] created for this [`Child`], if available.\n+    ///\n+    /// A pidfd will only be available if its creation was requested with\n+    /// [`create_pidfd`] when the corresponding [`Command`] was created.\n+    ///\n+    /// Even if requested, a pidfd may not be available due to an older\n+    /// version of Linux being in use, or if some other error occurred.\n+    ///\n+    /// [`Command`]: process::Command\n+    /// [`create_pidfd`]: CommandExt::create_pidfd\n+    /// [`Child`]: process::Child\n+    fn take_pidfd(&mut self) -> Result<PidFd>;\n+}\n+\n+mod private_command_ext {\n+    pub trait Sealed {}\n+    impl Sealed for crate::process::Command {}\n+}\n+\n+/// Os-specific extensions for [`Command`]\n+///\n+/// [`Command`]: process::Command\n+pub trait CommandExt: private_command_ext::Sealed {\n+    /// Sets whether a [`PidFd`](struct@PidFd) should be created for the [`Child`]\n+    /// spawned by this [`Command`].\n+    /// By default, no pidfd will be created.\n+    ///\n+    /// The pidfd can be retrieved from the child with [`pidfd`] or [`take_pidfd`].\n+    ///\n+    /// A pidfd will only be created if it is possible to do so\n+    /// in a guaranteed race-free manner (e.g. if the `clone3` system call\n+    /// is supported). Otherwise, [`pidfd`] will return an error.\n+    ///\n+    /// [`Command`]: process::Command\n+    /// [`Child`]: process::Child\n+    /// [`pidfd`]: fn@ChildExt::pidfd\n+    /// [`take_pidfd`]: ChildExt::take_pidfd\n+    fn create_pidfd(&mut self, val: bool) -> &mut process::Command;\n+}\n+\n+impl CommandExt for process::Command {\n+    fn create_pidfd(&mut self, val: bool) -> &mut process::Command {\n+        self.as_inner_mut().create_pidfd(val);\n+        self\n+    }\n+}"}, {"sha": "99c3369425b06361c11d96229c08e8600d971141", "filename": "library/std/src/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e21ef2a4eca12180e24a345d66066fc1e4e36da/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e21ef2a4eca12180e24a345d66066fc1e4e36da/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=4e21ef2a4eca12180e24a345d66066fc1e4e36da", "patch": "@@ -166,7 +166,7 @@ use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n /// [`wait`]: Child::wait\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Child {\n-    handle: imp::Process,\n+    pub(crate) handle: imp::Process,\n \n     /// The handle for writing to the child's standard input (stdin), if it has\n     /// been captured. To avoid partially moving"}, {"sha": "a1972380a9fdbb0c94fb9586675bc222680266c6", "filename": "library/std/src/sys/unix/process/process_common.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4e21ef2a4eca12180e24a345d66066fc1e4e36da/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e21ef2a4eca12180e24a345d66066fc1e4e36da/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=4e21ef2a4eca12180e24a345d66066fc1e4e36da", "patch": "@@ -79,6 +79,8 @@ pub struct Command {\n     stdin: Option<Stdio>,\n     stdout: Option<Stdio>,\n     stderr: Option<Stdio>,\n+    #[cfg(target_os = \"linux\")]\n+    create_pidfd: bool,\n }\n \n // Create a new type for argv, so that we can make it `Send` and `Sync`\n@@ -124,6 +126,7 @@ pub enum Stdio {\n }\n \n impl Command {\n+    #[cfg(not(target_os = \"linux\"))]\n     pub fn new(program: &OsStr) -> Command {\n         let mut saw_nul = false;\n         let program = os2c(program, &mut saw_nul);\n@@ -144,6 +147,28 @@ impl Command {\n         }\n     }\n \n+    #[cfg(target_os = \"linux\")]\n+    pub fn new(program: &OsStr) -> Command {\n+        let mut saw_nul = false;\n+        let program = os2c(program, &mut saw_nul);\n+        Command {\n+            argv: Argv(vec![program.as_ptr(), ptr::null()]),\n+            args: vec![program.clone()],\n+            program,\n+            env: Default::default(),\n+            cwd: None,\n+            uid: None,\n+            gid: None,\n+            saw_nul,\n+            closures: Vec::new(),\n+            groups: None,\n+            stdin: None,\n+            stdout: None,\n+            stderr: None,\n+            create_pidfd: false,\n+        }\n+    }\n+\n     pub fn set_arg_0(&mut self, arg: &OsStr) {\n         // Set a new arg0\n         let arg = os2c(arg, &mut self.saw_nul);\n@@ -177,6 +202,22 @@ impl Command {\n         self.groups = Some(Box::from(groups));\n     }\n \n+    #[cfg(target_os = \"linux\")]\n+    pub fn create_pidfd(&mut self, val: bool) {\n+        self.create_pidfd = val;\n+    }\n+\n+    #[cfg(not(target_os = \"linux\"))]\n+    #[allow(dead_code)]\n+    pub fn get_create_pidfd(&self) -> bool {\n+        false\n+    }\n+\n+    #[cfg(target_os = \"linux\")]\n+    pub fn get_create_pidfd(&self) -> bool {\n+        self.create_pidfd\n+    }\n+\n     pub fn saw_nul(&self) -> bool {\n         self.saw_nul\n     }"}, {"sha": "4b210d6af1303ed8d8f767fd971feb7c9c1e84db", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 133, "deletions": 3, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/4e21ef2a4eca12180e24a345d66066fc1e4e36da/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e21ef2a4eca12180e24a345d66066fc1e4e36da/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=4e21ef2a4eca12180e24a345d66066fc1e4e36da", "patch": "@@ -9,6 +9,12 @@ use crate::sys;\n use crate::sys::cvt;\n use crate::sys::process::process_common::*;\n \n+#[cfg(target_os = \"linux\")]\n+use crate::os::linux::process::PidFd;\n+\n+#[cfg(target_os = \"linux\")]\n+use crate::sys::weak::syscall;\n+\n #[cfg(any(\n     target_os = \"macos\",\n     target_os = \"freebsd\",\n@@ -61,7 +67,8 @@ impl Command {\n         // a lock any more because the parent won't do anything and the child is\n         // in its own process. Thus the parent drops the lock guard while the child\n         // forgets it to avoid unlocking it on a new thread, which would be invalid.\n-        let (env_lock, pid) = unsafe { (sys::os::env_read_lock(), cvt(libc::fork())?) };\n+        let env_lock = sys::os::env_read_lock();\n+        let (pid, pidfd) = unsafe { self.do_fork()? };\n \n         if pid == 0 {\n             crate::panic::always_abort();\n@@ -90,7 +97,7 @@ impl Command {\n         drop(env_lock);\n         drop(output);\n \n-        let mut p = Process { pid, status: None };\n+        let mut p = Process::new(pid, pidfd);\n         let mut bytes = [0; 8];\n \n         // loop to handle EINTR\n@@ -122,6 +129,92 @@ impl Command {\n         }\n     }\n \n+    // Attempts to fork the process. If successful, returns Ok((0, -1))\n+    // in the child, and Ok((child_pid, -1)) in the parent.\n+    #[cfg(not(target_os = \"linux\"))]\n+    unsafe fn do_fork(&mut self) -> Result<(pid_t, pid_t), io::Error> {\n+        cvt(libc::fork()).map(|res| (res, -1))\n+    }\n+\n+    // Attempts to fork the process. If successful, returns Ok((0, -1))\n+    // in the child, and Ok((child_pid, child_pidfd)) in the parent.\n+    #[cfg(target_os = \"linux\")]\n+    unsafe fn do_fork(&mut self) -> Result<(pid_t, pid_t), io::Error> {\n+        use crate::sync::atomic::{AtomicBool, Ordering};\n+\n+        static HAS_CLONE3: AtomicBool = AtomicBool::new(true);\n+        const CLONE_PIDFD: u64 = 0x00001000;\n+\n+        #[repr(C)]\n+        struct clone_args {\n+            flags: u64,\n+            pidfd: u64,\n+            child_tid: u64,\n+            parent_tid: u64,\n+            exit_signal: u64,\n+            stack: u64,\n+            stack_size: u64,\n+            tls: u64,\n+            set_tid: u64,\n+            set_tid_size: u64,\n+            cgroup: u64,\n+        }\n+\n+        syscall! {\n+            fn clone3(cl_args: *mut clone_args, len: libc::size_t) -> libc::c_long\n+        }\n+\n+        // If we fail to create a pidfd for any reason, this will\n+        // stay as -1, which indicates an error.\n+        let mut pidfd: pid_t = -1;\n+\n+        // Attempt to use the `clone3` syscall, which supports more arguments\n+        // (in particular, the ability to create a pidfd). If this fails,\n+        // we will fall through this block to a call to `fork()`\n+        if HAS_CLONE3.load(Ordering::Relaxed) {\n+            let mut flags = 0;\n+            if self.get_create_pidfd() {\n+                flags |= CLONE_PIDFD;\n+            }\n+\n+            let mut args = clone_args {\n+                flags,\n+                pidfd: &mut pidfd as *mut pid_t as u64,\n+                child_tid: 0,\n+                parent_tid: 0,\n+                exit_signal: libc::SIGCHLD as u64,\n+                stack: 0,\n+                stack_size: 0,\n+                tls: 0,\n+                set_tid: 0,\n+                set_tid_size: 0,\n+                cgroup: 0,\n+            };\n+\n+            let args_ptr = &mut args as *mut clone_args;\n+            let args_size = crate::mem::size_of::<clone_args>();\n+\n+            let res = cvt(clone3(args_ptr, args_size));\n+            match res {\n+                Ok(n) => return Ok((n as pid_t, pidfd)),\n+                Err(e) => match e.raw_os_error() {\n+                    // Multiple threads can race to execute this store,\n+                    // but that's fine - that just means that multiple threads\n+                    // will have tried and failed to execute the same syscall,\n+                    // with no other side effects.\n+                    Some(libc::ENOSYS) => HAS_CLONE3.store(false, Ordering::Relaxed),\n+                    // Fallback to fork if `EPERM` is returned. (e.g. blocked by seccomp)\n+                    Some(libc::EPERM) => {}\n+                    _ => return Err(e),\n+                },\n+            }\n+        }\n+\n+        // If we get here, the 'clone3' syscall does not exist\n+        // or we do not have permission to call it\n+        cvt(libc::fork()).map(|res| (res, pidfd))\n+    }\n+\n     pub fn exec(&mut self, default: Stdio) -> io::Error {\n         let envp = self.capture_env();\n \n@@ -308,6 +401,7 @@ impl Command {\n             || (self.env_saw_path() && !self.program_is_path())\n             || !self.get_closures().is_empty()\n             || self.get_groups().is_some()\n+            || self.get_create_pidfd()\n         {\n             return Ok(None);\n         }\n@@ -352,7 +446,7 @@ impl Command {\n             None => None,\n         };\n \n-        let mut p = Process { pid: 0, status: None };\n+        let mut p = Process::new(0, -1);\n \n         struct PosixSpawnFileActions<'a>(&'a mut MaybeUninit<libc::posix_spawn_file_actions_t>);\n \n@@ -441,9 +535,27 @@ impl Command {\n pub struct Process {\n     pid: pid_t,\n     status: Option<ExitStatus>,\n+    // On Linux, stores the pidfd created for this child.\n+    // This is None if the user did not request pidfd creation,\n+    // or if the pidfd could not be created for some reason\n+    // (e.g. the `clone3` syscall was not available).\n+    #[cfg(target_os = \"linux\")]\n+    pidfd: Option<PidFd>,\n }\n \n impl Process {\n+    #[cfg(target_os = \"linux\")]\n+    fn new(pid: pid_t, pidfd: pid_t) -> Self {\n+        use crate::sys_common::FromInner;\n+        let pidfd = (pidfd >= 0).then(|| PidFd::from_inner(sys::fd::FileDesc::new(pidfd)));\n+        Process { pid, status: None, pidfd }\n+    }\n+\n+    #[cfg(not(target_os = \"linux\"))]\n+    fn new(pid: pid_t, _pidfd: pid_t) -> Self {\n+        Process { pid, status: None }\n+    }\n+\n     pub fn id(&self) -> u32 {\n         self.pid as u32\n     }\n@@ -580,6 +692,24 @@ impl ExitStatusError {\n     }\n }\n \n+#[cfg(target_os = \"linux\")]\n+#[unstable(feature = \"linux_pidfd\", issue = \"82971\")]\n+impl crate::os::linux::process::ChildExt for crate::process::Child {\n+    fn pidfd(&self) -> io::Result<&PidFd> {\n+        self.handle\n+            .pidfd\n+            .as_ref()\n+            .ok_or_else(|| Error::new(ErrorKind::Other, \"No pidfd was created.\"))\n+    }\n+\n+    fn take_pidfd(&mut self) -> io::Result<PidFd> {\n+        self.handle\n+            .pidfd\n+            .take()\n+            .ok_or_else(|| Error::new(ErrorKind::Other, \"No pidfd was created.\"))\n+    }\n+}\n+\n #[cfg(test)]\n #[path = \"process_unix/tests.rs\"]\n mod tests;"}, {"sha": "93321ac536ab916c47b6db1b3ae592da9c6d8a2a", "filename": "src/test/ui/command/command-create-pidfd.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4e21ef2a4eca12180e24a345d66066fc1e4e36da/src%2Ftest%2Fui%2Fcommand%2Fcommand-create-pidfd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e21ef2a4eca12180e24a345d66066fc1e4e36da/src%2Ftest%2Fui%2Fcommand%2Fcommand-create-pidfd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcommand%2Fcommand-create-pidfd.rs?ref=4e21ef2a4eca12180e24a345d66066fc1e4e36da", "patch": "@@ -0,0 +1,45 @@\n+// run-pass\n+// only-linux - pidfds are a linux-specific concept\n+\n+#![feature(linux_pidfd)]\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+use std::io::Error;\n+use std::os::linux::process::{ChildExt, CommandExt};\n+use std::process::Command;\n+\n+fn has_clone3() -> bool {\n+    let res = unsafe { libc::syscall(libc::SYS_clone3, 0, 0) };\n+    let err = (res == -1)\n+        .then(|| Error::last_os_error())\n+        .expect(\"probe syscall should not succeed\");\n+    err.raw_os_error() != Some(libc::ENOSYS)\n+}\n+\n+fn main() {\n+    // pidfds require the clone3 syscall\n+    if !has_clone3() {\n+        return;\n+    }\n+\n+    // We don't assert the precise value, since the standard library\n+    // might have opened other file descriptors before our code runs.\n+    let _ = Command::new(\"echo\")\n+        .create_pidfd(true)\n+        .spawn()\n+        .unwrap()\n+        .pidfd().expect(\"failed to obtain pidfd\");\n+\n+    let _ = Command::new(\"echo\")\n+        .create_pidfd(false)\n+        .spawn()\n+        .unwrap()\n+        .pidfd().expect_err(\"pidfd should not have been created when create_pid(false) is set\");\n+\n+    let _ = Command::new(\"echo\")\n+        .spawn()\n+        .unwrap()\n+        .pidfd().expect_err(\"pidfd should not have been created\");\n+}"}, {"sha": "10a8b19159e02bfb2542844c248f8cd2da03f252", "filename": "src/test/ui/command/command-pre-exec.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4e21ef2a4eca12180e24a345d66066fc1e4e36da/src%2Ftest%2Fui%2Fcommand%2Fcommand-pre-exec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e21ef2a4eca12180e24a345d66066fc1e4e36da/src%2Ftest%2Fui%2Fcommand%2Fcommand-pre-exec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcommand%2Fcommand-pre-exec.rs?ref=4e21ef2a4eca12180e24a345d66066fc1e4e36da", "patch": "@@ -8,15 +8,30 @@\n // ignore-sgx no processes\n #![feature(process_exec, rustc_private)]\n \n-extern crate libc;\n-\n use std::env;\n use std::io::Error;\n use std::os::unix::process::CommandExt;\n use std::process::Command;\n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::sync::Arc;\n \n+#[cfg(not(target_os = \"linux\"))]\n+fn getpid() -> u32 {\n+    use std::process;\n+    process::id()\n+}\n+\n+/// We need to directly use the getpid syscall instead of using `process::id()`\n+/// because the libc wrapper might return incorrect values after a process was\n+/// forked.\n+#[cfg(target_os = \"linux\")]\n+fn getpid() -> u32 {\n+    extern crate libc;\n+    unsafe {\n+        libc::syscall(libc::SYS_getpid) as _\n+    }\n+}\n+\n fn main() {\n     if let Some(arg) = env::args().nth(1) {\n         match &arg[..] {\n@@ -68,14 +83,12 @@ fn main() {\n     };\n     assert_eq!(output.raw_os_error(), Some(102));\n \n-    let pid = unsafe { libc::getpid() };\n-    assert!(pid >= 0);\n+    let pid = getpid();\n     let output = unsafe {\n         Command::new(&me)\n             .arg(\"empty\")\n             .pre_exec(move || {\n-                let child = libc::getpid();\n-                assert!(child >= 0);\n+                let child = getpid();\n                 assert!(pid != child);\n                 Ok(())\n             })"}, {"sha": "ad749371beac041c4e56b691f5973ae772c18d3f", "filename": "src/test/ui/process/process-panic-after-fork.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4e21ef2a4eca12180e24a345d66066fc1e4e36da/src%2Ftest%2Fui%2Fprocess%2Fprocess-panic-after-fork.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e21ef2a4eca12180e24a345d66066fc1e4e36da/src%2Ftest%2Fui%2Fprocess%2Fprocess-panic-after-fork.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprocess%2Fprocess-panic-after-fork.rs?ref=4e21ef2a4eca12180e24a345d66066fc1e4e36da", "patch": "@@ -23,6 +23,21 @@ use std::sync::atomic::{AtomicU32, Ordering};\n \n use libc::c_int;\n \n+#[cfg(not(target_os = \"linux\"))]\n+fn getpid() -> u32 {\n+    process::id()\n+}\n+\n+/// We need to directly use the getpid syscall instead of using `process::id()`\n+/// because the libc wrapper might return incorrect values after a process was\n+/// forked.\n+#[cfg(target_os = \"linux\")]\n+fn getpid() -> u32 {\n+    unsafe {\n+        libc::syscall(libc::SYS_getpid) as _\n+    }\n+}\n+\n /// This stunt allocator allows us to spot heap allocations in the child.\n struct PidChecking<A> {\n     parent: A,\n@@ -44,7 +59,7 @@ impl<A> PidChecking<A> {\n     fn check(&self) {\n         let require_pid = self.require_pid.load(Ordering::Acquire);\n         if require_pid != 0 {\n-            let actual_pid = process::id();\n+            let actual_pid = getpid();\n             if require_pid != actual_pid {\n                 unsafe {\n                     libc::raise(libc::SIGUSR1);"}]}